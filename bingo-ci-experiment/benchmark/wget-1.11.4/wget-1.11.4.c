/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
enum log_options {
    LOG_VERBOSE = 0,
    LOG_NOTQUIET = 1,
    LOG_NONVERBOSE = 2,
    LOG_ALWAYS = 3
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 88 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 104 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 115 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 36 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 83 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 145 "/home/khheo/project/benchmark/wget-1.11.4/src/wget.h"
typedef long wgint;
#line 206 "/home/khheo/project/benchmark/wget-1.11.4/src/wget.h"
typedef wgint SUM_SIZE_INT;
#line 31 "/home/khheo/project/benchmark/wget-1.11.4/src/options.h"
enum __anonenum_secure_protocol_187193503 {
    secure_protocol_auto = 0,
    secure_protocol_sslv2 = 1,
    secure_protocol_sslv3 = 2,
    secure_protocol_tlsv1 = 3
} ;
#line 31
enum keyfile_type {
    keyfile_pem = 0,
    keyfile_asn1 = 1
} ;
#line 31
enum __anonenum_restrict_files_os_843006439 {
    restrict_unix = 0,
    restrict_windows = 1
} ;
#line 31
enum __anonenum_restrict_files_case_191639182 {
    restrict_no_case_restriction = 0,
    restrict_lowercase = 1,
    restrict_uppercase = 2
} ;
#line 31
enum __anonenum_prefer_family_762245126 {
    prefer_ipv4 = 0,
    prefer_ipv6 = 1,
    prefer_none = 2
} ;
#line 31 "/home/khheo/project/benchmark/wget-1.11.4/src/options.h"
struct options {
   int verbose ;
   _Bool quiet ;
   int ntry ;
   _Bool retry_connrefused ;
   _Bool background ;
   _Bool ignore_length ;
   _Bool recursive ;
   _Bool spanhost ;
   int max_redirect ;
   _Bool relative_only ;
   _Bool no_parent ;
   int reclevel ;
   _Bool dirstruct ;
   _Bool no_dirstruct ;
   int cut_dirs ;
   _Bool add_hostdir ;
   _Bool protocol_directories ;
   _Bool noclobber ;
   char *dir_prefix ;
   char *lfilename ;
   char *input_filename ;
   _Bool force_html ;
   _Bool spider ;
   char **accepts ;
   char **rejects ;
   char **excludes ;
   char **includes ;
   _Bool ignore_case ;
   char **domains ;
   char **exclude_domains ;
   _Bool dns_cache ;
   char **follow_tags ;
   char **ignore_tags ;
   _Bool follow_ftp ;
   _Bool retr_symlinks ;
   char *output_document ;
   char *user ;
   char *passwd ;
   _Bool always_rest ;
   char *ftp_user ;
   char *ftp_passwd ;
   _Bool netrc ;
   _Bool ftp_glob ;
   _Bool ftp_pasv ;
   char *http_user ;
   char *http_passwd ;
   char **user_headers ;
   _Bool http_keep_alive ;
   _Bool use_proxy ;
   _Bool allow_cache ;
   char *http_proxy ;
   char *ftp_proxy ;
   char *https_proxy ;
   char **no_proxy ;
   char *base_href ;
   char *progress_type ;
   char *proxy_user ;
   char *proxy_passwd ;
   double read_timeout ;
   double dns_timeout ;
   double connect_timeout ;
   _Bool random_wait ;
   double wait ;
   double waitretry ;
   _Bool use_robots ;
   wgint limit_rate ;
   SUM_SIZE_INT quota ;
   int numurls ;
   _Bool server_response ;
   _Bool save_headers ;
   _Bool debug ;
   _Bool timestamping ;
   _Bool backup_converted ;
   _Bool backups ;
   char *useragent ;
   char *referer ;
   _Bool convert_links ;
   _Bool remove_listing ;
   _Bool htmlify ;
   char *dot_style ;
   wgint dot_bytes ;
   int dots_in_line ;
   int dot_spacing ;
   _Bool delete_after ;
   _Bool html_extension ;
   _Bool page_requisites ;
   char *bind_address ;
   enum __anonenum_secure_protocol_187193503 secure_protocol ;
   _Bool check_cert ;
   char *cert_file ;
   char *private_key ;
   enum keyfile_type cert_type ;
   enum keyfile_type private_key_type ;
   char *ca_directory ;
   char *ca_cert ;
   char *random_file ;
   char *egd_file ;
   _Bool cookies ;
   char *cookies_input ;
   char *cookies_output ;
   _Bool keep_session_cookies ;
   char *post_data ;
   char *post_file_name ;
   enum __anonenum_restrict_files_os_843006439 restrict_files_os ;
   _Bool restrict_files_ctrl ;
   enum __anonenum_restrict_files_case_191639182 restrict_files_case ;
   _Bool strict_comments ;
   _Bool preserve_perm ;
   _Bool ipv4_only ;
   _Bool ipv6_only ;
   enum __anonenum_prefer_family_762245126 prefer_family ;
   _Bool content_disposition ;
   _Bool auth_without_challenge ;
};
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.h"
struct hash_table ;
#line 36 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.h"
struct file_memory {
   char *content ;
   long length ;
   int mmap_p ;
};
#line 51 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
struct __anonstruct_hash_table_iterator_1036286216 {
   void *key ;
   void *value ;
   void *pos ;
   void *end ;
};
#line 51 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
typedef struct __anonstruct_hash_table_iterator_1036286216 hash_table_iterator;
#line 41 "/home/khheo/project/benchmark/wget-1.11.4/src/url.h"
enum url_auth_mode {
    URL_AUTH_SHOW = 0,
    URL_AUTH_HIDE_PASSWD = 1,
    URL_AUTH_HIDE = 2
} ;
#line 50
enum url_scheme {
    SCHEME_HTTP = 0,
    SCHEME_HTTPS = 1,
    SCHEME_FTP = 2,
    SCHEME_INVALID = 3
} ;
#line 60 "/home/khheo/project/benchmark/wget-1.11.4/src/url.h"
struct url {
   char *url ;
   enum url_scheme scheme ;
   char *host ;
   int port ;
   char *path ;
   char *params ;
   char *query ;
   char *fragment ;
   char *dir ;
   char *file ;
   char *user ;
   char *passwd ;
};
#line 58 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
struct scheme_data {
   char const   *name ;
   char const   *leading_string ;
   int default_port ;
   int flags ;
};
#line 1179 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
struct growable {
   char *base ;
   int size ;
   int tail ;
};
#line 89 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c"
struct url_list ;
#line 326 "/home/khheo/project/benchmark/wget-1.11.4/src/wget.h"
enum __anonenum_uerr_t_42338639 {
    NOCONERROR = 0,
    HOSTERR = 1,
    CONSOCKERR = 2,
    CONERROR = 3,
    CONSSLERR = 4,
    CONIMPOSSIBLE = 5,
    NEWLOCATION = 6,
    NOTENOUGHMEM = 7,
    CONPORTERR = 8,
    CONCLOSED = 9,
    FTPOK = 10,
    FTPLOGINC = 11,
    FTPLOGREFUSED = 12,
    FTPPORTERR = 13,
    FTPSYSERR = 14,
    FTPNSFOD = 15,
    FTPRETROK = 16,
    FTPUNKNOWNTYPE = 17,
    FTPRERR = 18,
    FTPREXC = 19,
    FTPSRVERR = 20,
    FTPRETRINT = 21,
    FTPRESTFAIL = 22,
    URLERROR = 23,
    FOPENERR = 24,
    FOPEN_EXCL_ERR = 25,
    FWRITEERR = 26,
    HOK = 27,
    HLEXC = 28,
    HEOF = 29,
    HERR = 30,
    RETROK = 31,
    RECLEVELEXC = 32,
    FTPACCDENIED = 33,
    WRONGCODE = 34,
    FTPINVPASV = 35,
    FTPNOPASV = 36,
    CONTNOTSUPPORTED = 37,
    RETRUNNEEDED = 38,
    RETRFINISHED = 39,
    READERR = 40,
    TRYLIMEXC = 41,
    URLBADPATTERN = 42,
    FILEBADFILE = 43,
    RANGEERR = 44,
    RETRBADPATTERN = 45,
    RETNOTSUP = 46,
    ROBOTSOK = 47,
    NOROBOTS = 48,
    PROXERR = 49,
    AUTHFAILED = 50,
    QUOTEXC = 51,
    WRITEFAILED = 52,
    SSLINITFAILED = 53
} ;
#line 326 "/home/khheo/project/benchmark/wget-1.11.4/src/wget.h"
typedef enum __anonenum_uerr_t_42338639 uerr_t;
#line 42 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.h"
struct urlpos ;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
enum convert_options {
    CO_NOCONVERT = 0,
    CO_CONVERT_TO_RELATIVE = 1,
    CO_CONVERT_TO_COMPLETE = 2,
    CO_NULLIFY_BASE = 3
} ;
#line 51 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
struct urlpos {
   struct url *url ;
   char *local_name ;
   unsigned int ignore_when_downloading : 1 ;
   unsigned int link_relative_p : 1 ;
   unsigned int link_complete_p : 1 ;
   unsigned int link_base_p : 1 ;
   unsigned int link_inline_p : 1 ;
   unsigned int link_expect_html : 1 ;
   unsigned int link_refresh_p : 1 ;
   int refresh_timeout ;
   enum convert_options convert ;
   int pos ;
   int size ;
   struct urlpos *next ;
};
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.h"
struct ptimer ;
#line 70 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
struct __anonstruct_limit_data_916237038 {
   wgint chunk_bytes ;
   double chunk_start ;
   double sleep_adjust ;
};
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/res.h"
struct robot_specs ;
#line 91 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
struct path_info {
   char *path ;
   _Bool allowedp ;
   _Bool user_agent_exact_p ;
};
#line 97 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
struct robot_specs {
   int count ;
   int size ;
   struct path_info *paths ;
};
#line 56 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
struct queue_element {
   char const   *url ;
   char const   *referer ;
   int depth ;
   _Bool html_allowed ;
   struct queue_element *next ;
};
#line 66 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
struct url_queue {
   struct queue_element *head ;
   struct queue_element *tail ;
   int count ;
   int maxcount ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 100 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
typedef struct timespec ptimer_system_time;
#line 124 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
struct __anonstruct_clocks_1027777389 {
   int id ;
   int sysconf_name ;
};
#line 300 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
struct ptimer {
   ptimer_system_time start ;
   double elapsed_last ;
   double elapsed_pre_start ;
};
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 50 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
struct progress_implementation {
   char const   *name ;
   _Bool interactive ;
   void *(*create)(wgint  , wgint  ) ;
   void (*update)(void * , wgint  , double  ) ;
   void (*finish)(void * , double  ) ;
   void (*set_params)(char const   * ) ;
};
#line 201 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
struct dot_progress {
   wgint initial_length ;
   wgint total_length ;
   int accumulated ;
   int rows ;
   int dots ;
   double last_timer_value ;
};
#line 500 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
struct bar_progress_hist {
   int pos ;
   double times[20] ;
   wgint bytes[20] ;
   double total_time ;
   wgint total_bytes ;
};
#line 500 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
struct bar_progress {
   wgint initial_length ;
   wgint total_length ;
   wgint count ;
   double last_screen_update ;
   int width ;
   char *buffer ;
   int tick ;
   struct bar_progress_hist hist ;
   double recent_start ;
   wgint recent_bytes ;
   _Bool stalled ;
   double last_eta_time ;
   int last_eta_value ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 120 "/usr/include/openssl/ossl_typ.h"
struct x509_st ;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_st X509;
#line 125
struct X509_name_st ;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_name_st X509_NAME;
#line 128
struct x509_store_ctx_st ;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_store_ctx_st X509_STORE_CTX;
#line 141
struct ossl_init_settings_st ;
#line 141 "/usr/include/openssl/ossl_typ.h"
typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;
#line 147
struct ssl_st ;
#line 147 "/usr/include/openssl/ossl_typ.h"
typedef struct ssl_st SSL;
#line 148
struct ssl_ctx_st ;
#line 148 "/usr/include/openssl/ossl_typ.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 211 "/usr/include/openssl/ssl.h"
struct ssl_method_st ;
#line 211 "/usr/include/openssl/ssl.h"
typedef struct ssl_method_st SSL_METHOD;
#line 64 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
struct transport_implementation {
   int (*reader)(int  , char * , int  , void * ) ;
   int (*writer)(int  , char * , int  , void * ) ;
   int (*poller)(int  , double  , int  , void * ) ;
   int (*peeker)(int  , char * , int  , void * ) ;
   char const   *(*errstr)(int  , void * ) ;
   void (*closer)(int  , void * ) ;
};
#line 242 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
struct openssl_transport_context {
   SSL *conn ;
   char *last_error ;
};
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.h"
struct _acc_t {
   char *host ;
   char *acc ;
   char *passwd ;
   struct _acc_t *next ;
};
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.h"
typedef struct _acc_t acc_t;
#line 258 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
enum __anonenum_last_token_70149392 {
    tok_nothing = 0,
    tok_account = 1,
    tok_login = 2,
    tok_macdef = 3,
    tok_machine = 4,
    tok_password = 5
} ;
#line 76 "/home/khheo/project/benchmark/wget-1.11.4/src/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 110 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
enum __anonenum_type_727687094 {
    OPT_VALUE = 0,
    OPT_BOOLEAN = 1,
    OPT_FUNCALL = 2,
    OPT__APPEND_OUTPUT = 3,
    OPT__CLOBBER = 4,
    OPT__DONT_REMOVE_LISTING = 5,
    OPT__EXECUTE = 6,
    OPT__NO = 7,
    OPT__PARENT = 8
} ;
#line 110 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
struct cmdline_option {
   char const   *long_name ;
   char short_name ;
   enum __anonenum_type_727687094 type ;
   void const   *data ;
   int argtype ;
};
#line 109 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
struct log_ln {
   char static_line[129] ;
   char *malloced_line ;
   char *content ;
};
#line 320 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
struct logvprintf_state {
   char *bigmsg ;
   int expected_size ;
   int allocated ;
};
#line 676 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
struct ringel {
   char *buffer ;
   int size ;
};
#line 773
enum __anonenum_redirect_request_90896483 {
    RR_NONE = 0,
    RR_REQUESTED = 1,
    RR_DONE = 2
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 114 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
struct __anonstruct_commands_890992477 {
   char const   *name ;
   void *place ;
   _Bool (*action)(char const   * , char const   * , void * ) ;
};
#line 435
enum parse_line {
    line_ok = 0,
    line_empty = 1,
    line_syntax_error = 2,
    line_unknown_command = 3
} ;
#line 709 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
struct decode_item {
   char const   *name ;
   int code ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 41 "/home/khheo/project/benchmark/wget-1.11.4/src/http.h"
struct __anonstruct_param_token_1022237947 {
   char const   *b ;
   char const   *e ;
};
#line 41 "/home/khheo/project/benchmark/wget-1.11.4/src/http.h"
typedef struct __anonstruct_param_token_1022237947 param_token;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 211 "/usr/include/netinet/in.h"
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 211 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
#line 46 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
struct address_list ;
#line 50 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
union __anonunion_data_475986367 {
   struct in_addr d4 ;
   struct in6_addr d6 ;
};
#line 50 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
struct __anonstruct_ip_address_793472116 {
   int family ;
   union __anonunion_data_475986367 data ;
   int ipv6_scope ;
};
#line 50 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
typedef struct __anonstruct_ip_address_793472116 ip_address;
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.h"
enum __anonenum_wgetntlm_205137921 {
    NTLMSTATE_NONE = 0,
    NTLMSTATE_TYPE1 = 1,
    NTLMSTATE_TYPE2 = 2,
    NTLMSTATE_TYPE3 = 3,
    NTLMSTATE_LAST = 4
} ;
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.h"
typedef enum __anonenum_wgetntlm_205137921 wgetntlm;
#line 42 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.h"
struct ntlmdata {
   wgetntlm state ;
   unsigned char nonce[8] ;
};
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.h"
struct cookie_jar ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.h"
struct gen_md5_context ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.h"
typedef struct gen_md5_context gen_md5_context;
#line 83 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
enum __anonenum_downloaded_file_t_951207787 {
    FILE_NOT_ALREADY_DOWNLOADED = 0,
    FILE_DOWNLOADED_NORMALLY = 1,
    FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED = 2,
    CHECK_FOR_FILE = 3
} ;
#line 83 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
typedef enum __anonenum_downloaded_file_t_951207787 downloaded_file_t;
#line 128 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
enum rp {
    rel_none = 0,
    rel_name = 1,
    rel_value = 2,
    rel_both = 3
} ;
#line 132 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct request_header {
   char *name ;
   char *value ;
   enum rp release_policy ;
};
#line 132 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct request {
   char const   *method ;
   char *arg ;
   struct request_header *headers ;
   int hcount ;
   int hcapacity ;
};
#line 549 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct response {
   char const   *data ;
   char const   **headers ;
};
#line 1079 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct __anonstruct_pconn_951291558 {
   int socket ;
   char *host ;
   int port ;
   _Bool ssl ;
   _Bool authorized ;
   struct ntlmdata ntlm ;
};
#line 1288 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct http_stat {
   wgint len ;
   wgint contlen ;
   wgint restval ;
   int res ;
   char *rderrmsg ;
   char *newloc ;
   char *remote_time ;
   char *error ;
   int statcode ;
   wgint rd_size ;
   double dltime ;
   char const   *referer ;
   char *local_file ;
   _Bool existence_checked ;
   _Bool timestamp_checked ;
   char *orig_file_name ;
   wgint orig_file_size ;
   time_t orig_file_tstamp ;
};
#line 3012 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
struct __anonstruct_options_68445535 {
   char const   *name ;
   char **variable ;
};
#line 21 "/usr/include/openssl/des.h"
typedef unsigned int DES_LONG;
#line 28 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 29 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 35 "/usr/include/openssl/des.h"
union __anonunion_ks_909163901 {
   DES_cblock cblock ;
   DES_LONG deslong[2] ;
};
#line 35 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_909163901 ks[16] ;
};
#line 35 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 33 "/usr/include/openssl/md4.h"
struct MD4state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 33 "/usr/include/openssl/md4.h"
typedef struct MD4state_st MD4_CTX;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.h"
struct attr_pair {
   char *name ;
   char *value ;
   char const   *value_raw_beginning ;
   int value_raw_size ;
   int name_pool_index ;
   int value_pool_index ;
};
#line 47 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.h"
struct taginfo {
   char *name ;
   int end_tag_p ;
   int nattrs ;
   struct attr_pair *attrs ;
   char const   *start_position ;
   char const   *end_position ;
};
#line 47 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct map_context ;
#line 87 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct known_tag {
   int tagid ;
   char const   *name ;
   void (*handler)(int  , struct taginfo * , struct map_context * ) ;
};
#line 135 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct __anonstruct_tag_url_attributes_269907105 {
   int tagid ;
   char const   *attr_name ;
   int flags ;
};
#line 250 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct map_context {
   char *text ;
   char *base ;
   char const   *parent_base ;
   char const   *document_file ;
   _Bool nofollow ;
   struct urlpos *head ;
   struct urlpos *tail ;
};
#line 153 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
struct pool {
   char *contents ;
   int size ;
   int tail ;
   _Bool resized ;
   char *orig_contents ;
   int orig_size ;
};
#line 481
enum __anonenum_state_1000635653 {
    AC_S_DONE = 0,
    AC_S_BACKOUT = 1,
    AC_S_BANG = 2,
    AC_S_DEFAULT = 3,
    AC_S_DCLNAME = 4,
    AC_S_DASH1 = 5,
    AC_S_DASH2 = 6,
    AC_S_COMMENT = 7,
    AC_S_DASH3 = 8,
    AC_S_DASH4 = 9,
    AC_S_QUOTE1 = 10,
    AC_S_IN_QUOTE = 11,
    AC_S_QUOTE2 = 12
} ;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in ;
#line 79
struct sockaddr_in6 ;
#line 119 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 72 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
struct address_list {
   int count ;
   ip_address *addresses ;
   int faulty ;
   _Bool connected ;
   int refcount ;
};
#line 367 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
struct gaiwt_context {
   char const   *node ;
   char const   *service ;
   struct addrinfo  const  *hints ;
   struct addrinfo **res ;
   int exit_code ;
};
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 149 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
struct cell {
   void *key ;
   void *value ;
};
#line 157 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
struct hash_table {
   unsigned long (*hash_function)(void const   * ) ;
   int (*test_function)(void const   * , void const   * ) ;
   struct cell *cells ;
   int size ;
   int count ;
   int resize_threshold ;
   int prime_offset ;
};
#line 33 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 33 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 48 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
typedef MD5_CTX gen_md5_context_imp;
#line 51 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
struct gen_md5_context {
   gen_md5_context_imp imp ;
};
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
enum stype {
    ST_UNIX = 0,
    ST_VMS = 1,
    ST_WINNT = 2,
    ST_MACOS = 3,
    ST_OS400 = 4,
    ST_OTHER = 5
} ;
#line 75
enum ftype {
    FT_PLAINFILE = 0,
    FT_DIRECTORY = 1,
    FT_SYMLINK = 2,
    FT_UNKNOWN = 3
} ;
#line 91 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
struct fileinfo {
   enum ftype type ;
   char *name ;
   wgint size ;
   long tstamp ;
   int perms ;
   char *linkto ;
   struct fileinfo *prev ;
   struct fileinfo *next ;
};
#line 61 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
struct __anonstruct_ccon_878107638 {
   int st ;
   int cmd ;
   int csock ;
   double dltime ;
   enum stype rs ;
   char *id ;
   char *target ;
   struct url *proxy ;
};
#line 61 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
typedef struct __anonstruct_ccon_878107638 ccon;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 75 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
struct cookie_jar {
   struct hash_table *chains ;
   int cookie_count ;
};
#line 95 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
struct cookie {
   char *domain ;
   int port ;
   char *path ;
   unsigned int discard_requested : 1 ;
   unsigned int secure : 1 ;
   unsigned int domain_exact : 1 ;
   unsigned int permanent : 1 ;
   time_t expiry_time ;
   char *attr ;
   char *value ;
   struct cookie *next ;
};
#line 869 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
struct weighed_cookie {
   struct cookie *cookie ;
   int domain_goodness ;
   int path_goodness ;
};
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_356711149 fd_set;
#line 270 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
#line 217 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
struct cwt_context {
   int fd ;
   struct sockaddr  const  *addr ;
   socklen_t addrlen ;
   int result ;
};
#line 749 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
struct transport_info {
   struct transport_implementation *imp ;
   void *ctx ;
};
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 60 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.h"
void *checking_malloc(size_t size ) ;
#line 61
void *checking_malloc0(size_t size ) ;
#line 62
void *checking_realloc(void *ptr , size_t newsize ) ;
#line 63
char *checking_strdup(char const   *s ) ;
#line 64
void checking_free(void *ptr ) ;
#line 39 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void ( /* format attribute */  logprintf)(enum log_options o , char const   *fmt 
                                          , ...) ;
#line 45
_Bool log_set_save_context(_Bool savep ) ;
#line 32 "/home/khheo/project/benchmark/wget-1.11.4/src/progname.h"
char const   *program_name ;
#line 57 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
static void memfatal(char const   *context , long attempted_size ) 
{ 
  char *tmp ;

  {
  {
#line 62
  log_set_save_context((_Bool)0);
#line 63
  tmp = gettext("%s: %s: Failed to allocate %ld bytes; memory exhausted.\n");
#line 63
  logprintf((enum log_options )3, (char const   *)tmp, program_name, context, attempted_size);
#line 66
  exit(1);
  }
}
}
#line 102 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
void *checking_malloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 105
  tmp = malloc(size);
#line 105
  ptr = tmp;
  }
#line 106
  if (! ptr) {
    {
#line 107
    memfatal("malloc", (long )size);
    }
  }
#line 108
  return (ptr);
}
}
#line 111 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
void *checking_malloc0(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 117
  tmp = calloc((size_t )1, size);
#line 117
  ptr = tmp;
  }
#line 118
  if (! ptr) {
    {
#line 119
    memfatal("calloc", (long )size);
    }
  }
#line 120
  return (ptr);
}
}
#line 123 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
void *checking_realloc(void *ptr , size_t newsize ) 
{ 
  void *newptr ;

  {
#line 131
  if (ptr) {
    {
#line 132
    newptr = realloc(ptr, newsize);
    }
  } else {
    {
#line 134
    newptr = malloc(newsize);
    }
  }
#line 135
  if (! newptr) {
    {
#line 136
    memfatal("realloc", (long )newsize);
    }
  }
#line 137
  return (newptr);
}
}
#line 140 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
char *checking_strdup(char const   *s ) 
{ 
  char *copy ;
  size_t tmp ;

  {
  {
#line 152
  copy = strdup(s);
  }
#line 153
  if (! copy) {
    {
#line 154
    tmp = strlen(s);
#line 154
    memfatal("strdup", (long )(1UL + tmp));
    }
  }
#line 157
  return (copy);
}
}
#line 160 "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c"
void checking_free(void *ptr ) 
{ 


  {
#line 182
  if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
    {
#line 182
    __assert_fail("ptr != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/xmalloc.c",
                  182U, "checking_free");
    }
  }
  {
#line 184
  free(ptr);
  }
#line 185
  return;
}
}
#line 1 "/home/khheo/project/benchmark/wget-1.11.4/src/version.c"
char *version_string  =    (char *)"1.11.4";
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 137
extern struct _IO_FILE *stderr ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 238
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 340
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 352
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 467 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) drand48)(void) ;
#line 471
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 481
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 588
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 211
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 128 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 670
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 44 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *( __attribute__((__leaf__)) localeconv)(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 54 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 93
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 101 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.h"
unsigned short const   _sch_istable[256] ;
#line 126
unsigned char const   _sch_tolower[256] ;
#line 241 "/home/khheo/project/benchmark/wget-1.11.4/src/options.h"
struct options opt ;
#line 41 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void ( /* format attribute */  debug_logprintf)(char const   *fmt  , ...) ;
#line 44 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.h"
char *time_str(time_t t ) ;
#line 45
char *datetime_str(time_t t ) ;
#line 51
char *xstrdup_lower(char const   *s ) ;
#line 53
char *strdupdelim(char const   *beg , char const   *end ) ;
#line 54
char **sepstring(char const   *s ) ;
#line 55
_Bool subdir_p(char const   *d1 , char const   *d2 ) ;
#line 56
void fork_to_background(void) ;
#line 58
char *( /* format attribute */  aprintf)(char const   *fmt  , ...) ;
#line 59
char *concat_strings(char const   *str0  , ...) ;
#line 61
void touch(char const   *file , time_t tm ) ;
#line 62
int remove_link(char const   *file ) ;
#line 63
_Bool file_exists_p(char const   *filename ) ;
#line 64
_Bool file_non_directory_p(char const   *path ) ;
#line 65
wgint file_size(char const   *filename ) ;
#line 66
int make_directory(char const   *directory ) ;
#line 67
char *unique_name(char const   *file , _Bool allow_passthrough ) ;
#line 68
FILE *unique_create(char const   *name , _Bool binary , char **opened_name ) ;
#line 69
FILE *fopen_excl(char const   *fname , _Bool binary ) ;
#line 70
char *file_merge(char const   *base , char const   *file ) ;
#line 72
int fnmatch_nocase(char const   *pattern , char const   *string , int flags ) ;
#line 73
_Bool acceptable(char const   *s ) ;
#line 74
_Bool accdir(char const   *directory ) ;
#line 75
char *suffix(char const   *str ) ;
#line 76
_Bool match_tail(char const   *string , char const   *tail , _Bool fold_case ) ;
#line 77
_Bool has_wildcards_p(char const   *s ) ;
#line 79
_Bool has_html_suffix_p(char const   *fname ) ;
#line 81
char *read_whole_line(FILE *fp ) ;
#line 82
struct file_memory *read_file(char const   *file ) ;
#line 83
void read_file_free(struct file_memory *fm ) ;
#line 85
void free_vec(char **vec ) ;
#line 86
char **merge_vecs(char **v1___0 , char **v2___0 ) ;
#line 87
char **vec_append(char **vec , char const   *str ) ;
#line 89
void string_set_add(struct hash_table *ht , char const   *s ) ;
#line 90
int string_set_contains(struct hash_table *ht , char const   *s ) ;
#line 91
void string_set_to_array(struct hash_table *ht , char **array ) ;
#line 92
void string_set_free(struct hash_table *ht ) ;
#line 93
void free_keys_and_values(struct hash_table *ht ) ;
#line 95
char const   *with_thousand_seps(wgint n ) ;
#line 105
char *human_readable(wgint n ) ;
#line 108
int numdigit(wgint number ) ;
#line 109
char *number_to_string(char *buffer___0 , wgint number ) ;
#line 110
char *number_to_static_string(wgint number ) ;
#line 112
int determine_screen_width(void) ;
#line 113
int random_number(int max ) ;
#line 114
double random_float(void) ;
#line 116
_Bool run_with_timeout(double timeout , void (*fun)(void * ) , void *arg ) ;
#line 117
void xsleep(double seconds ) ;
#line 122
int base64_encode(void const   *data , int length , char *dest ) ;
#line 123
int base64_decode(char const   *base64 , void *dest ) ;
#line 125
void stable_sort(void *base , size_t nmemb , size_t size , int (*cmpfun)(void const   * ,
                                                                         void const   * ) ) ;
#line 127
char const   *print_decimal(double number ) ;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
void hash_table_destroy(struct hash_table *ht ) ;
#line 42
int hash_table_contains(struct hash_table  const  *ht , void const   *key ) ;
#line 44
void hash_table_put(struct hash_table *ht , void const   *key , void *value ) ;
#line 55
void hash_table_iterate(struct hash_table *ht , hash_table_iterator *iter ) ;
#line 56
int hash_table_iter_next(hash_table_iterator *iter ) ;
#line 94 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *xstrdup_lower(char const   *s ) 
{ 
  char *copy ;
  char *tmp ;
  char *p___0 ;

  {
  {
#line 97
  tmp = checking_strdup(s);
#line 97
  copy = tmp;
#line 98
  p___0 = copy;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! *p___0) {
#line 99
      goto while_break;
    }
#line 100
    *p___0 = (char )_sch_tolower[(int )*p___0 & 255];
#line 99
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (copy);
}
}
#line 107 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *strdupdelim(char const   *beg , char const   *end ) 
{ 
  char *res___0 ;
  void *tmp ;

  {
  {
#line 110
  tmp = checking_malloc((size_t )((end - beg) + 1L));
#line 110
  res___0 = (char *)tmp;
#line 111
  memcpy((void */* __restrict  */)res___0, (void const   */* __restrict  */)beg, (size_t )(end - beg));
#line 112
  *(res___0 + (end - beg)) = (char )'\000';
  }
#line 113
  return (res___0);
}
}
#line 119 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char **sepstring(char const   *s ) 
{ 
  char **res___0 ;
  char const   *p___0 ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 124
  i = 0;
#line 126
  if (! s) {
#line 127
    return ((char **)((void *)0));
  } else
#line 126
  if (! *s) {
#line 127
    return ((char **)((void *)0));
  }
#line 128
  res___0 = (char **)((void *)0);
#line 129
  p___0 = s;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! *s) {
#line 130
      goto while_break;
    }
#line 132
    if ((int const   )*s == 44) {
      {
#line 134
      tmp = checking_realloc((void *)res___0, (unsigned long )(i + 2) * sizeof(char *));
#line 134
      res___0 = (char **)tmp;
#line 135
      *(res___0 + i) = strdupdelim(p___0, s);
#line 136
      i ++;
#line 136
      *(res___0 + i) = (char *)((void *)0);
#line 137
      s ++;
      }
      {
#line 139
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 139
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 64)) {
#line 139
          goto while_break___0;
        }
#line 140
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 141
      p___0 = s;
    } else {
#line 144
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  tmp___0 = checking_realloc((void *)res___0, (unsigned long )(i + 2) * sizeof(char *));
#line 146
  res___0 = (char **)tmp___0;
#line 147
  *(res___0 + i) = strdupdelim(p___0, s);
#line 148
  *(res___0 + (i + 1)) = (char *)((void *)0);
  }
#line 149
  return (res___0);
}
}
#line 163 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *( /* format attribute */  aprintf)(char const   *fmt  , ...) 
{ 
  int ret ;
  va_list args ;
  char *str ;
  int *tmp ;

  {
  {
#line 171
  __builtin_va_start(args, fmt);
#line 172
  ret = vasprintf((char **/* __restrict  */)(& str), (char const   */* __restrict  */)fmt,
                  args);
#line 173
  __builtin_va_end(args);
  }
#line 174
  if (ret < 0) {
    {
#line 174
    tmp = __errno_location();
    }
#line 174
    if (*tmp == 12) {
      {
#line 175
      abort();
      }
    } else {
#line 174
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 176
  if (ret < 0) {
#line 177
    return ((char *)((void *)0));
  }
#line 178
  return (str);
}
}
#line 215 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *concat_strings(char const   *str0  , ...) 
{ 
  va_list args ;
  int saved_lengths[5] ;
  char *ret ;
  char *p___0 ;
  char const   *next_str ;
  int total_length ;
  int argcount ;
  char const   *tmp ;
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int len___0 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 223
  total_length = 0;
#line 228
  argcount = 0;
#line 229
  __builtin_va_start(args, str0);
#line 230
  next_str = str0;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned long )next_str != (unsigned long )((void *)0))) {
#line 230
      goto while_break;
    }
    {
#line 232
    tmp___0 = strlen(next_str);
#line 232
    len = (int )tmp___0;
    }
#line 233
    if ((unsigned long )argcount < sizeof(saved_lengths) / sizeof(saved_lengths[0])) {
#line 234
      tmp___1 = argcount;
#line 234
      argcount ++;
#line 234
      saved_lengths[tmp___1] = len;
    }
    {
#line 235
    total_length += len;
#line 230
    tmp = __builtin_va_arg(args, char *);
#line 230
    next_str = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  __builtin_va_end(args);
#line 238
  tmp___2 = checking_malloc((size_t )(total_length + 1));
#line 238
  ret = (char *)tmp___2;
#line 238
  p___0 = ret;
#line 242
  argcount = 0;
#line 243
  __builtin_va_start(args, str0);
#line 244
  next_str = str0;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! ((unsigned long )next_str != (unsigned long )((void *)0))) {
#line 244
      goto while_break___0;
    }
#line 247
    if ((unsigned long )argcount < sizeof(saved_lengths) / sizeof(saved_lengths[0])) {
#line 248
      tmp___4 = argcount;
#line 248
      argcount ++;
#line 248
      len___0 = saved_lengths[tmp___4];
    } else {
      {
#line 250
      tmp___5 = strlen(next_str);
#line 250
      len___0 = (int )tmp___5;
      }
    }
    {
#line 251
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)next_str,
           (size_t )len___0);
#line 252
    p___0 += len___0;
#line 244
    tmp___3 = __builtin_va_arg(args, char *);
#line 244
    next_str = tmp___3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 254
  __builtin_va_end(args);
#line 255
  *p___0 = (char )'\000';
  }
#line 257
  return (ret);
}
}
#line 266 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char output[32]  ;
#line 263 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char *fmttime(time_t t , char const   *fmt ) 
{ 
  struct tm *tm ;
  struct tm *tmp ;
  size_t tmp___0 ;

  {
  {
#line 267
  tmp = localtime((time_t const   *)(& t));
#line 267
  tm = tmp;
  }
#line 268
  if (! tm) {
    {
#line 269
    abort();
    }
  }
  {
#line 270
  tmp___0 = strftime((char */* __restrict  */)(output), sizeof(output), (char const   */* __restrict  */)fmt,
                     (struct tm  const  */* __restrict  */)tm);
  }
#line 270
  if (! tmp___0) {
    {
#line 271
    abort();
    }
  }
#line 272
  return (output);
}
}
#line 280 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *time_str(time_t t ) 
{ 
  char *tmp ;

  {
  {
#line 283
  tmp = fmttime(t, "%H:%M:%S");
  }
#line 283
  return (tmp);
}
}
#line 288 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *datetime_str(time_t t ) 
{ 
  char *tmp ;

  {
  {
#line 291
  tmp = fmttime(t, "%Y-%m-%d %H:%M:%S");
  }
#line 291
  return (tmp);
}
}
#line 298 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void fork_to_background(void) 
{ 
  pid_t pid ;
  _Bool logfile_changed ;
  FILE *new_log_fp ;
  FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 303
  logfile_changed = (_Bool)0;
#line 305
  if (! opt.lfilename) {
    {
#line 312
    tmp = unique_create("wget-log", (_Bool)0, & opt.lfilename);
#line 312
    new_log_fp = tmp;
    }
#line 313
    if (new_log_fp) {
      {
#line 315
      logfile_changed = (_Bool)1;
#line 316
      fclose(new_log_fp);
      }
    }
  }
  {
#line 319
  pid = fork();
  }
#line 320
  if (pid < 0) {
    {
#line 323
    perror("fork");
#line 324
    exit(1);
    }
  } else
#line 326
  if (pid != 0) {
    {
#line 329
    tmp___0 = gettext("Continuing in background, pid %d.\n");
#line 329
    printf((char const   */* __restrict  */)tmp___0, pid);
    }
#line 330
    if (logfile_changed) {
      {
#line 331
      tmp___1 = gettext("Output will be written to `%s\'.\n");
#line 331
      printf((char const   */* __restrict  */)tmp___1, opt.lfilename);
      }
    }
    {
#line 332
    exit(0);
    }
  }
  {
#line 336
  setsid();
#line 337
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
          (FILE */* __restrict  */)stdin);
#line 338
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stdout);
#line 339
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
  }
#line 340
  return;
}
}
#line 347 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void touch(char const   *file , time_t tm ) 
{ 
  struct utimbuf times ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 358
  times.modtime = tm;
#line 359
  times.actime = time((time_t *)((void *)0));
#line 360
  tmp___1 = utime(file, (struct utimbuf  const  *)(& times));
  }
#line 360
  if (tmp___1 == -1) {
    {
#line 361
    tmp = __errno_location();
#line 361
    tmp___0 = strerror(*tmp);
#line 361
    logprintf((enum log_options )1, "utime(%s): %s\n", file, tmp___0);
    }
  }
#line 362
  return;
}
}
#line 366 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int remove_link(char const   *file ) 
{ 
  int err ;
  struct stat st ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 369
  err = 0;
#line 372
  tmp___3 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 372
  if (tmp___3 == 0) {
#line 372
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 374
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 374
        tmp = __builtin_expect((long )opt.debug, 0L);
        }
#line 374
        if (tmp) {
          {
#line 374
          debug_logprintf("Unlinking %s (symlink).\n", file);
          }
        }
#line 374
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 375
      err = unlink(file);
      }
#line 376
      if (err != 0) {
        {
#line 377
        tmp___0 = __errno_location();
#line 377
        tmp___1 = strerror(*tmp___0);
#line 377
        tmp___2 = gettext("Failed to unlink symlink `%s\': %s\n");
#line 377
        logprintf((enum log_options )0, (char const   *)tmp___2, file, tmp___1);
        }
      }
    }
  }
#line 380
  return (err);
}
}
#line 390 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool file_exists_p(char const   *filename ) 
{ 
  struct stat buf___4 ;
  int tmp ;

  {
  {
#line 397
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& buf___4));
  }
#line 397
  return ((_Bool )(tmp >= 0));
}
}
#line 403 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool file_non_directory_p(char const   *path ) 
{ 
  struct stat buf___4 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 409
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf___4));
  }
#line 409
  if (tmp != 0) {
#line 410
    return ((_Bool)0);
  }
#line 411
  if ((buf___4.st_mode & 61440U) == 16384U) {
#line 411
    tmp___0 = 0;
  } else {
#line 411
    tmp___0 = 1;
  }
#line 411
  return ((_Bool )tmp___0);
}
}
#line 416 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
wgint file_size(char const   *filename ) 
{ 
  wgint size ;
  FILE *fp ;
  FILE *tmp ;

  {
  {
#line 425
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 425
  fp = tmp;
  }
#line 426
  if (! fp) {
#line 427
    return ((wgint )-1);
  }
  {
#line 428
  fseeko(fp, (__off_t )0, 2);
#line 429
  size = ftello(fp);
#line 430
  fclose(fp);
  }
#line 431
  return (size);
}
}
#line 444 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char *unique_name_1(char const   *prefix ) 
{ 
  int count ;
  int plen ;
  size_t tmp ;
  char *template ;
  void *tmp___0 ;
  char *template_tail ;
  char *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 447
  count = 1;
#line 448
  tmp = strlen(prefix);
#line 448
  plen = (int )tmp;
#line 449
  tmp___0 = __builtin_alloca((unsigned long )((plen + 1) + 24));
#line 449
  template = (char *)tmp___0;
#line 450
  template_tail = template + plen;
#line 452
  memcpy((void */* __restrict  */)template, (void const   */* __restrict  */)prefix,
         (size_t )plen);
#line 453
  tmp___1 = template_tail;
#line 453
  template_tail ++;
#line 453
  *tmp___1 = (char )'.';
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 456
    tmp___2 = count;
#line 456
    count ++;
#line 456
    number_to_string(template_tail, (wgint )tmp___2);
#line 455
    tmp___3 = file_exists_p((char const   *)template);
    }
#line 455
    if (! tmp___3) {
#line 455
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 459
  tmp___4 = checking_strdup((char const   *)template);
  }
#line 459
  return (tmp___4);
}
}
#line 478 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *unique_name(char const   *file , _Bool allow_passthrough ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 483
  tmp___1 = file_exists_p(file);
  }
#line 483
  if (! tmp___1) {
#line 484
    if (allow_passthrough) {
#line 484
      tmp___0 = (char *)file;
    } else {
      {
#line 484
      tmp = checking_strdup(file);
#line 484
      tmp___0 = tmp;
      }
    }
#line 484
    return (tmp___0);
  }
  {
#line 488
  tmp___2 = unique_name_1(file);
  }
#line 488
  return (tmp___2);
}
}
#line 496 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
FILE *unique_create(char const   *name , _Bool binary , char **opened_name ) 
{ 
  char *uname ;
  char *tmp ;
  FILE *fp ;
  int *tmp___0 ;

  {
  {
#line 500
  tmp = unique_name(name, (_Bool)0);
#line 500
  uname = tmp;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 502
    fp = fopen_excl((char const   *)uname, binary);
    }
#line 502
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 502
      tmp___0 = __errno_location();
      }
#line 502
      if (! (*tmp___0 == 17)) {
#line 502
        goto while_break;
      }
    } else {
#line 502
      goto while_break;
    }
    {
#line 504
    checking_free((void *)uname);
#line 505
    uname = unique_name(name, (_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  if (opened_name) {
#line 507
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 509
      if (fp) {
#line 510
        *opened_name = uname;
      } else {
        {
#line 513
        *opened_name = (char *)((void *)0);
#line 514
        checking_free((void *)uname);
        }
      }
    } else {
      {
#line 518
      checking_free((void *)uname);
      }
    }
  } else {
    {
#line 518
    checking_free((void *)uname);
    }
  }
#line 519
  return (fp);
}
}
#line 532 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
FILE *fopen_excl(char const   *fname , _Bool binary ) 
{ 
  int fd ;
  int flags ;
  char const   *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 537
  flags = 193;
#line 542
  fd = open(fname, flags, 438);
  }
#line 543
  if (fd < 0) {
#line 544
    return ((FILE *)((void *)0));
  }
#line 545
  if (binary) {
#line 545
    tmp = "wb";
  } else {
#line 545
    tmp = "w";
  }
  {
#line 545
  tmp___0 = fdopen(fd, tmp);
  }
#line 545
  return (tmp___0);
}
}
#line 565 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int make_directory(char const   *directory ) 
{ 
  int i ;
  int ret ;
  int quit ;
  char *dir ;
  char **SA_dest ;
  char const   *SA_src ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 568
  quit = 0;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 573
    SA_dest = & dir;
#line 573
    SA_src = directory;
#line 573
    tmp = strlen(SA_src);
#line 573
    tmp___0 = __builtin_alloca(tmp + 1UL);
#line 573
    *SA_dest = (char *)tmp___0;
#line 573
    strcpy((char */* __restrict  */)*SA_dest, (char const   */* __restrict  */)SA_src);
    }
#line 573
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  i = (int )*dir == 47;
  {
#line 577
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 579
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 579
      if (*(dir + i)) {
#line 579
        if (! ((int )*(dir + i) != 47)) {
#line 579
          goto while_break___1;
        }
      } else {
#line 579
        goto while_break___1;
      }
#line 579
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 581
    if (! *(dir + i)) {
#line 582
      quit = 1;
    }
    {
#line 583
    *(dir + i) = (char )'\000';
#line 587
    tmp___1 = file_exists_p((char const   *)dir);
    }
#line 587
    if (tmp___1) {
#line 590
      ret = 0;
    } else {
      {
#line 588
      ret = mkdir((char const   *)dir, (__mode_t )511);
      }
    }
#line 591
    if (quit) {
#line 592
      goto while_break___0;
    } else {
#line 594
      *(dir + i) = (char )'/';
    }
#line 577
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 596
  return (ret);
}
}
#line 608 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *file_merge(char const   *base , char const   *file ) 
{ 
  char *result ;
  char const   *cut ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 612
  tmp = strrchr(base, '/');
#line 612
  cut = (char const   *)tmp;
  }
#line 614
  if (! cut) {
    {
#line 615
    tmp___0 = checking_strdup(file);
    }
#line 615
    return (tmp___0);
  }
  {
#line 617
  tmp___1 = strlen(file);
#line 617
  tmp___2 = checking_malloc(((size_t )((cut - base) + 1L) + tmp___1) + 1UL);
#line 617
  result = (char *)tmp___2;
#line 618
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)base, (size_t )(cut - base));
#line 619
  *(result + (cut - base)) = (char )'/';
#line 620
  strcpy((char */* __restrict  */)((result + (cut - base)) + 1), (char const   */* __restrict  */)file);
  }
#line 622
  return (result);
}
}
#line 627 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int fnmatch_nocase(char const   *pattern , char const   *string , int flags ) 
{ 
  int tmp ;

  {
  {
#line 633
  tmp = fnmatch(pattern, string, flags | (1 << 4));
  }
#line 633
  return (tmp);
}
}
#line 649
static _Bool in_acclist(char const   * const  *accepts , char const   *s , _Bool backward ) ;
#line 653 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool acceptable(char const   *s ) 
{ 
  int l ;
  size_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  {
#line 656
  tmp = strlen(s);
#line 656
  l = (int )tmp;
  }
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (l) {
#line 658
      if (! ((int const   )*(s + l) != 47)) {
#line 658
        goto while_break;
      }
    } else {
#line 658
      goto while_break;
    }
#line 659
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  if ((int const   )*(s + l) == 47) {
#line 661
    s += l + 1;
  }
#line 662
  if (opt.accepts) {
#line 664
    if (opt.rejects) {
      {
#line 665
      tmp___0 = in_acclist((char const   * const  *)opt.accepts, s, (_Bool)1);
      }
#line 665
      if (tmp___0) {
        {
#line 665
        tmp___1 = in_acclist((char const   * const  *)opt.rejects, s, (_Bool)1);
        }
#line 665
        if (tmp___1) {
#line 665
          tmp___2 = 0;
        } else {
#line 665
          tmp___2 = 1;
        }
      } else {
#line 665
        tmp___2 = 0;
      }
#line 665
      return ((_Bool )tmp___2);
    } else {
      {
#line 668
      tmp___3 = in_acclist((char const   * const  *)opt.accepts, s, (_Bool)1);
      }
#line 668
      return (tmp___3);
    }
  } else
#line 670
  if (opt.rejects) {
    {
#line 671
    tmp___4 = in_acclist((char const   * const  *)opt.rejects, s, (_Bool)1);
    }
#line 671
    if (tmp___4) {
#line 671
      tmp___5 = 0;
    } else {
#line 671
      tmp___5 = 1;
    }
#line 671
    return ((_Bool )tmp___5);
  }
#line 672
  return ((_Bool)1);
}
}
#line 678 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool subdir_p(char const   *d1 , char const   *d2 ) 
{ 
  int tmp ;

  {
#line 681
  if ((int const   )*d1 == 0) {
#line 682
    return ((_Bool)1);
  }
#line 683
  if (! opt.ignore_case) {
    {
#line 684
    while (1) {
      while_continue: /* CIL Label */ ;
#line 684
      if (*d1) {
#line 684
        if (*d2) {
#line 684
          if (! ((int const   )*d1 == (int const   )*d2)) {
#line 684
            goto while_break;
          }
        } else {
#line 684
          goto while_break;
        }
      } else {
#line 684
        goto while_break;
      }
#line 684
      d1 ++;
#line 684
      d2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 687
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 687
      if (*d1) {
#line 687
        if (*d2) {
#line 687
          if (! ((int const   )_sch_tolower[(int const   )*d1 & 255] == (int const   )_sch_tolower[(int const   )*d2 & 255])) {
#line 687
            goto while_break___0;
          }
        } else {
#line 687
          goto while_break___0;
        }
      } else {
#line 687
        goto while_break___0;
      }
#line 687
      d1 ++;
#line 687
      d2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 690
  if ((int const   )*d1 == 0) {
#line 690
    if ((int const   )*d2 == 0) {
#line 690
      tmp = 1;
    } else
#line 690
    if ((int const   )*d2 == 47) {
#line 690
      tmp = 1;
    } else {
#line 690
      tmp = 0;
    }
  } else {
#line 690
    tmp = 0;
  }
#line 690
  return ((_Bool )tmp);
}
}
#line 696 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static _Bool dir_matches_p(char **dirlist , char const   *dir ) 
{ 
  char **x ;
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *pattern , char const   *string , int flags ) ;
  char *p___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
#line 700
  if (opt.ignore_case) {
#line 700
    tmp = & fnmatch_nocase;
  } else {
#line 700
    tmp = & fnmatch;
  }
#line 700
  matcher = tmp;
#line 703
  x = dirlist;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! *x) {
#line 703
      goto while_break;
    }
    {
#line 706
    p___0 = *x + ((int )*(*x) == 47);
#line 707
    tmp___2 = has_wildcards_p((char const   *)p___0);
    }
#line 707
    if (tmp___2) {
      {
#line 709
      tmp___0 = (*matcher)((char const   *)p___0, dir, 1);
      }
#line 709
      if (tmp___0 == 0) {
#line 710
        goto while_break;
      }
    } else {
      {
#line 714
      tmp___1 = subdir_p((char const   *)p___0, dir);
      }
#line 714
      if (tmp___1) {
#line 715
        goto while_break;
      }
    }
#line 703
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  if (*x) {
#line 719
    tmp___3 = 1;
  } else {
#line 719
    tmp___3 = 0;
  }
#line 719
  return ((_Bool )tmp___3);
}
}
#line 728 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool accdir(char const   *directory ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 732
  if ((int const   )*directory == 47) {
#line 733
    directory ++;
  }
#line 734
  if (opt.includes) {
    {
#line 736
    tmp = dir_matches_p(opt.includes, directory);
    }
#line 736
    if (! tmp) {
#line 737
      return ((_Bool)0);
    }
  }
#line 739
  if (opt.excludes) {
    {
#line 741
    tmp___0 = dir_matches_p(opt.excludes, directory);
    }
#line 741
    if (tmp___0) {
#line 742
      return ((_Bool)0);
    }
  }
#line 744
  return ((_Bool)1);
}
}
#line 755 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool match_tail(char const   *string , char const   *tail , _Bool fold_case ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 763
  if (! fold_case) {
    {
#line 765
    tmp = strlen(string);
#line 765
    i = (int )tmp;
#line 765
    tmp___0 = strlen(tail);
#line 765
    j = (int )tmp___0;
    }
    {
#line 765
    while (1) {
      while_continue: /* CIL Label */ ;
#line 765
      if (i >= 0) {
#line 765
        if (! (j >= 0)) {
#line 765
          goto while_break;
        }
      } else {
#line 765
        goto while_break;
      }
#line 766
      if ((int const   )*(string + i) != (int const   )*(tail + j)) {
#line 767
        goto while_break;
      }
#line 765
      i --;
#line 765
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 771
    tmp___1 = strlen(string);
#line 771
    i = (int )tmp___1;
#line 771
    tmp___2 = strlen(tail);
#line 771
    j = (int )tmp___2;
    }
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 771
      if (i >= 0) {
#line 771
        if (! (j >= 0)) {
#line 771
          goto while_break___0;
        }
      } else {
#line 771
        goto while_break___0;
      }
#line 772
      if ((int const   )_sch_tolower[(int const   )*(string + i) & 255] != (int const   )_sch_tolower[(int const   )*(tail + j) & 255]) {
#line 773
        goto while_break___0;
      }
#line 771
      i --;
#line 771
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 777
  if (j == -1) {
#line 778
    return ((_Bool)1);
  } else {
#line 780
    return ((_Bool)0);
  }
}
}
#line 789 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static _Bool in_acclist(char const   * const  *accepts , char const   *s , _Bool backward ) 
{ 
  int res___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int cmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! *accepts) {
#line 792
      goto while_break;
    }
    {
#line 794
    tmp___6 = has_wildcards_p((char const   *)*accepts);
    }
#line 794
    if (tmp___6) {
#line 796
      if (opt.ignore_case) {
        {
#line 796
        tmp = fnmatch_nocase((char const   *)*accepts, s, 0);
#line 796
        tmp___1 = tmp;
        }
      } else {
        {
#line 796
        tmp___0 = fnmatch((char const   *)*accepts, s, 0);
#line 796
        tmp___1 = tmp___0;
        }
      }
#line 796
      res___0 = tmp___1;
#line 799
      if (res___0 == 0) {
#line 800
        return ((_Bool)1);
      }
    } else
#line 804
    if (backward) {
      {
#line 806
      tmp___2 = match_tail(s, (char const   *)*accepts, opt.ignore_case);
      }
#line 806
      if (tmp___2) {
#line 807
        return ((_Bool)1);
      }
    } else {
#line 811
      if (opt.ignore_case) {
        {
#line 811
        tmp___3 = strcasecmp(s, (char const   *)*accepts);
#line 811
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 811
        tmp___4 = strcmp(s, (char const   *)*accepts);
#line 811
        tmp___5 = tmp___4;
        }
      }
#line 811
      cmp = tmp___5;
#line 813
      if (cmp == 0) {
#line 814
        return ((_Bool)1);
      }
    }
#line 792
    accepts ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  return ((_Bool)0);
}
}
#line 826 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *suffix(char const   *str ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 831
  tmp = strlen(str);
#line 831
  i = (int )tmp;
  }
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 831
    if (i) {
#line 831
      if ((int const   )*(str + i) != 47) {
#line 831
        if (! ((int const   )*(str + i) != 46)) {
#line 831
          goto while_break;
        }
      } else {
#line 831
        goto while_break;
      }
    } else {
#line 831
      goto while_break;
    }
#line 831
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  tmp___0 = i;
#line 834
  i ++;
#line 834
  if ((int const   )*(str + tmp___0) == 46) {
#line 835
    return ((char *)str + i);
  } else {
#line 837
    return ((char *)((void *)0));
  }
}
}
#line 843 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool has_wildcards_p(char const   *s ) 
{ 


  {
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! *s) {
#line 846
      goto while_break;
    }
#line 847
    if ((int const   )*s == 42) {
#line 848
      return ((_Bool)1);
    } else
#line 847
    if ((int const   )*s == 63) {
#line 848
      return ((_Bool)1);
    } else
#line 847
    if ((int const   )*s == 91) {
#line 848
      return ((_Bool)1);
    } else
#line 847
    if ((int const   )*s == 93) {
#line 848
      return ((_Bool)1);
    }
#line 846
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  return ((_Bool)0);
}
}
#line 862 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool has_html_suffix_p(char const   *fname ) 
{ 
  char *suf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 867
  suf = suffix(fname);
  }
#line 867
  if ((unsigned long )suf == (unsigned long )((void *)0)) {
#line 868
    return ((_Bool)0);
  }
  {
#line 869
  tmp = strcasecmp((char const   *)suf, "html");
  }
#line 869
  if (! tmp) {
#line 870
    return ((_Bool)1);
  }
  {
#line 871
  tmp___0 = strcasecmp((char const   *)suf, "htm");
  }
#line 871
  if (! tmp___0) {
#line 872
    return ((_Bool)1);
  }
#line 873
  if (*(suf + 0)) {
    {
#line 873
    tmp___1 = strcasecmp((char const   *)(suf + 1), "html");
    }
#line 873
    if (! tmp___1) {
#line 874
      return ((_Bool)1);
    }
  }
#line 875
  return ((_Bool)0);
}
}
#line 890 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *read_whole_line(FILE *fp ) 
{ 
  int length ;
  int bufsize ;
  char *line ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 893
  length = 0;
#line 894
  bufsize = 82;
#line 895
  tmp = checking_malloc((size_t )bufsize);
#line 895
  line = (char *)tmp;
  }
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 897
    tmp___2 = fgets((char */* __restrict  */)(line + length), bufsize - length, (FILE */* __restrict  */)fp);
    }
#line 897
    if (! tmp___2) {
#line 897
      goto while_break;
    }
    {
#line 899
    tmp___0 = strlen((char const   *)(line + length));
#line 899
    length = (int )((size_t )length + tmp___0);
    }
#line 900
    if (length == 0) {
#line 903
      goto while_continue;
    }
#line 905
    if ((int )*(line + (length - 1)) == 10) {
#line 906
      goto while_break;
    }
    {
#line 911
    bufsize <<= 1;
#line 912
    tmp___1 = checking_realloc((void *)line, (size_t )bufsize);
#line 912
    line = (char *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  if (length == 0) {
    {
#line 916
    checking_free((void *)line);
    }
#line 917
    return ((char *)((void *)0));
  } else {
    {
#line 914
    tmp___3 = ferror(fp);
    }
#line 914
    if (tmp___3) {
      {
#line 916
      checking_free((void *)line);
      }
#line 917
      return ((char *)((void *)0));
    }
  }
#line 919
  if (length + 1 < bufsize) {
    {
#line 924
    tmp___4 = checking_realloc((void *)line, (size_t )(length + 1));
#line 924
    line = (char *)tmp___4;
    }
  }
#line 925
  return (line);
}
}
#line 944 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
struct file_memory *read_file(char const   *file ) 
{ 
  int fd ;
  struct file_memory *fm ;
  long size ;
  _Bool inhibit_close ;
  void *tmp ;
  struct stat buf___4 ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  wgint nread ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 950
  inhibit_close = (_Bool)0;
#line 954
  if ((int const   )*file == 45) {
#line 954
    if (! *(file + 1)) {
      {
#line 956
      fd = fileno(stdin);
#line 957
      inhibit_close = (_Bool)1;
      }
    } else {
      {
#line 962
      fd = open(file, 0);
      }
    }
  } else {
    {
#line 962
    fd = open(file, 0);
    }
  }
#line 963
  if (fd < 0) {
#line 964
    return ((struct file_memory *)((void *)0));
  }
  {
#line 965
  tmp = checking_malloc(sizeof(struct file_memory ));
#line 965
  fm = (struct file_memory *)tmp;
#line 970
  tmp___0 = fstat(fd, & buf___4);
  }
#line 970
  if (tmp___0 < 0) {
#line 971
    goto mmap_lose;
  }
  {
#line 972
  fm->length = buf___4.st_size;
#line 977
  tmp___1 = mmap((void *)0, (size_t )fm->length, 3, 2, fd, (__off_t )0);
#line 977
  fm->content = (char *)tmp___1;
  }
#line 979
  if ((unsigned long )fm->content == (unsigned long )((char *)((void *)-1))) {
#line 980
    goto mmap_lose;
  }
#line 981
  if (! inhibit_close) {
    {
#line 982
    close(fd);
    }
  }
#line 984
  fm->mmap_p = 1;
#line 985
  return (fm);
  mmap_lose: 
  {
#line 995
  fm->length = 0L;
#line 996
  size = 512L;
#line 998
  tmp___2 = checking_malloc((size_t )size);
#line 998
  fm->content = (char *)tmp___2;
  }
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (fm->length > size / 2L) {
      {
#line 1018
      size <<= 1;
#line 1019
      tmp___3 = checking_realloc((void *)fm->content, (size_t )size);
#line 1019
      fm->content = (char *)tmp___3;
      }
    }
    {
#line 1021
    nread = read(fd, (void *)(fm->content + fm->length), (size_t )(size - fm->length));
    }
#line 1022
    if (nread > 0L) {
#line 1024
      fm->length += nread;
    } else
#line 1025
    if (nread < 0L) {
#line 1027
      goto lose;
    } else {
#line 1030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  if (! inhibit_close) {
    {
#line 1033
    close(fd);
    }
  }
#line 1034
  if (size > fm->length) {
#line 1034
    if (fm->length != 0L) {
      {
#line 1037
      tmp___4 = checking_realloc((void *)fm->content, (size_t )fm->length);
#line 1037
      fm->content = (char *)tmp___4;
      }
    }
  }
#line 1038
  fm->mmap_p = 0;
#line 1039
  return (fm);
  lose: 
#line 1042
  if (! inhibit_close) {
    {
#line 1043
    close(fd);
    }
  }
  {
#line 1044
  checking_free((void *)fm->content);
#line 1045
  checking_free((void *)fm);
  }
#line 1046
  return ((struct file_memory *)((void *)0));
}
}
#line 1054 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void read_file_free(struct file_memory *fm ) 
{ 


  {
#line 1058
  if (fm->mmap_p) {
    {
#line 1060
    munmap((void *)fm->content, (size_t )fm->length);
    }
  } else {
    {
#line 1065
    checking_free((void *)fm->content);
    }
  }
  {
#line 1067
  checking_free((void *)fm);
  }
#line 1068
  return;
}
}
#line 1072 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void free_vec(char **vec ) 
{ 
  char **p___0 ;
  char **tmp ;

  {
#line 1075
  if (vec) {
#line 1077
    p___0 = vec;
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1078
      if (! *p___0) {
#line 1078
        goto while_break;
      }
      {
#line 1079
      tmp = p___0;
#line 1079
      p___0 ++;
#line 1079
      checking_free((void *)*tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1080
    checking_free((void *)vec);
    }
  }
#line 1082
  return;
}
}
#line 1087 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char **merge_vecs(char **v1___0 , char **v2___0 ) 
{ 
  int i ;
  int j ;
  void *tmp ;

  {
#line 1092
  if (! v1___0) {
#line 1093
    return (v2___0);
  }
#line 1094
  if (! v2___0) {
#line 1095
    return (v1___0);
  }
#line 1096
  if (! *v2___0) {
    {
#line 1099
    checking_free((void *)v2___0);
    }
#line 1100
    return (v1___0);
  }
#line 1103
  i = 0;
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (! *(v1___0 + i)) {
#line 1103
      goto while_break;
    }
#line 1103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  j = 0;
  {
#line 1106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1106
    if (! *(v2___0 + j)) {
#line 1106
      goto while_break___0;
    }
#line 1106
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1109
  tmp = checking_realloc((void *)v1___0, (unsigned long )((i + j) + 1) * sizeof(char **));
#line 1109
  v1___0 = (char **)tmp;
#line 1110
  memcpy((void */* __restrict  */)(v1___0 + i), (void const   */* __restrict  */)v2___0,
         (unsigned long )(j + 1) * sizeof(char *));
#line 1111
  checking_free((void *)v2___0);
  }
#line 1112
  return (v1___0);
}
}
#line 1118 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char **vec_append(char **vec , char const   *str ) 
{ 
  int cnt ;
  void *tmp ;

  {
#line 1123
  if ((unsigned long )vec != (unsigned long )((void *)0)) {
#line 1125
    cnt = 0;
    {
#line 1125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1125
      if (! *(vec + cnt)) {
#line 1125
        goto while_break;
      }
#line 1125
      cnt ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1127
    cnt ++;
  } else {
#line 1130
    cnt = 1;
  }
  {
#line 1132
  tmp = checking_realloc((void *)vec, (unsigned long )(cnt + 1) * sizeof(char *));
#line 1132
  vec = (char **)tmp;
#line 1134
  *(vec + (cnt - 1)) = checking_strdup(str);
#line 1135
  *(vec + cnt) = (char *)((void *)0);
  }
#line 1136
  return (vec);
}
}
#line 1144 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void string_set_add(struct hash_table *ht , char const   *s ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1150
  tmp = hash_table_contains((struct hash_table  const  *)ht, (void const   *)s);
  }
#line 1150
  if (tmp) {
#line 1151
    return;
  }
  {
#line 1157
  tmp___0 = checking_strdup(s);
#line 1157
  hash_table_put(ht, (void const   *)tmp___0, (void *)"1");
  }
#line 1158
  return;
}
}
#line 1162 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int string_set_contains(struct hash_table *ht , char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 1165
  tmp = hash_table_contains((struct hash_table  const  *)ht, (void const   *)s);
  }
#line 1165
  return (tmp);
}
}
#line 1171 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void string_set_to_array(struct hash_table *ht , char **array ) 
{ 
  hash_table_iterator iter ;
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 1174
  hash_table_iterate(ht, & iter);
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1174
    tmp___0 = hash_table_iter_next(& iter);
    }
#line 1174
    if (! tmp___0) {
#line 1174
      goto while_break;
    }
#line 1175
    tmp = array;
#line 1175
    array ++;
#line 1175
    *tmp = (char *)iter.key;
  }
  while_break: /* CIL Label */ ;
  }
#line 1176
  return;
}
}
#line 1182 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void string_set_free(struct hash_table *ht ) 
{ 
  hash_table_iterator iter ;
  int tmp ;

  {
  {
#line 1186
  hash_table_iterate(ht, & iter);
  }
  {
#line 1186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1186
    tmp = hash_table_iter_next(& iter);
    }
#line 1186
    if (! tmp) {
#line 1186
      goto while_break;
    }
    {
#line 1187
    checking_free(iter.key);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1188
  hash_table_destroy(ht);
  }
#line 1189
  return;
}
}
#line 1193 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void free_keys_and_values(struct hash_table *ht ) 
{ 
  hash_table_iterator iter ;
  int tmp ;

  {
  {
#line 1197
  hash_table_iterate(ht, & iter);
  }
  {
#line 1197
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1197
    tmp = hash_table_iter_next(& iter);
    }
#line 1197
    if (! tmp) {
#line 1197
      goto while_break;
    }
    {
#line 1199
    checking_free(iter.key);
#line 1200
    checking_free(iter.value);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1202
  return;
}
}
#line 1216 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char const   *cached_sep  ;
#line 1217 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char const   *cached_grouping  ;
#line 1218 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static _Bool initialized  ;
#line 1213 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static void get_grouping_data(char const   **sep , char const   **grouping ) 
{ 
  struct lconv *lconv ;
  struct lconv *tmp ;

  {
#line 1219
  if (! initialized) {
    {
#line 1222
    tmp = localeconv();
#line 1222
    lconv = tmp;
#line 1223
    cached_sep = (char const   *)lconv->thousands_sep;
#line 1224
    cached_grouping = (char const   *)lconv->grouping;
    }
#line 1231
    if (! *cached_sep) {
#line 1238
      if ((int )*(lconv->decimal_point) != 44) {
#line 1239
        cached_sep = ",";
      } else {
#line 1241
        cached_sep = ".";
      }
#line 1242
      cached_grouping = "\003";
    }
#line 1244
    initialized = (_Bool)1;
  }
#line 1246
  *sep = cached_sep;
#line 1247
  *grouping = cached_grouping;
#line 1248
  return;
}
}
#line 1262 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char outbuf[48]  ;
#line 1259 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char const   *with_thousand_seps(wgint n ) 
{ 
  char *p___0 ;
  char const   *grouping ;
  char const   *sep ;
  int seplen ;
  int i ;
  int groupsize ;
  char const   *atgroup ;
  _Bool negative ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1263
  p___0 = outbuf + sizeof(outbuf);
#line 1270
  i = 0;
#line 1273
  negative = (_Bool )(n < 0L);
#line 1276
  get_grouping_data(& sep, & grouping);
#line 1277
  tmp = strlen(sep);
#line 1277
  seplen = (int )tmp;
#line 1278
  atgroup = grouping;
#line 1279
  tmp___0 = atgroup;
#line 1279
  atgroup ++;
#line 1279
  groupsize = (int )*tmp___0;
  }
#line 1283
  if (negative) {
#line 1284
    n = - n;
  }
#line 1288
  p___0 --;
#line 1288
  *p___0 = (char )'\000';
  {
#line 1289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1291
    p___0 --;
#line 1291
    *p___0 = (char )(n % 10L + 48L);
#line 1292
    n /= 10L;
#line 1293
    if (n == 0L) {
#line 1294
      goto while_break;
    }
#line 1296
    i ++;
#line 1296
    if (i == groupsize) {
#line 1298
      if (seplen == 1) {
#line 1299
        p___0 --;
#line 1299
        *p___0 = (char )*sep;
      } else {
        {
#line 1301
        p___0 -= seplen;
#line 1301
        memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)sep,
               (size_t )seplen);
        }
      }
#line 1302
      i = 0;
#line 1303
      if (*atgroup) {
#line 1304
        tmp___1 = atgroup;
#line 1304
        atgroup ++;
#line 1304
        groupsize = (int )*tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1307
  if (negative) {
#line 1308
    p___0 --;
#line 1308
    *p___0 = (char )'-';
  }
#line 1310
  return ((char const   *)p___0);
}
}
#line 1333 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char powers[6]  = {      (char )'K',      (char )'M',      (char )'G',      (char )'T', 
        (char )'P',      (char )'E'};
#line 1342 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char buf[8]  ;
#line 1329 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *human_readable(wgint n ) 
{ 
  int i ;
  double val ;
  int tmp ;

  {
#line 1346
  if (n < 1024L) {
    {
#line 1348
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
             (int )n);
    }
#line 1349
    return (buf);
  }
#line 1355
  i = 0;
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1355
    if (! ((unsigned long )i < sizeof(powers) / sizeof(powers[0]))) {
#line 1355
      goto while_break;
    }
#line 1360
    if (n / 1024L < 1024L) {
#line 1360
      goto _L;
    } else
#line 1360
    if ((unsigned long )i == sizeof(powers) / sizeof(powers[0]) - 1UL) {
      _L: /* CIL Label */ 
#line 1362
      val = (double )n / 1024.0;
#line 1365
      if (val < (double )10) {
#line 1365
        tmp = 1;
      } else {
#line 1365
        tmp = 0;
      }
      {
#line 1365
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.*f%c",
               tmp, val, (int )powers[i]);
      }
#line 1367
      return (buf);
    }
#line 1369
    n /= 1024L;
#line 1355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1371
  return ((char *)((void *)0));
}
}
#line 1377 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int numdigit(wgint number ) 
{ 
  int cnt ;

  {
#line 1380
  cnt = 1;
#line 1381
  if (number < 0L) {
#line 1382
    cnt ++;
  }
  {
#line 1383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1383
    number /= 10L;
#line 1383
    if (! (number != 0L)) {
#line 1383
      goto while_break;
    }
#line 1384
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1385
  return (cnt);
}
}
#line 1440 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *number_to_string(char *buffer___0 , wgint number ) 
{ 
  char *p___0 ;
  wgint n ;
  int last_digit_char ;
  int last_digit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char *tmp___113 ;
  char *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  char *tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  char *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  char *tmp___131 ;
  char *tmp___132 ;
  char *tmp___133 ;
  char *tmp___134 ;
  char *tmp___135 ;
  char *tmp___136 ;
  char *tmp___137 ;
  char *tmp___138 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  char *tmp___142 ;
  char *tmp___143 ;
  char *tmp___144 ;
  char *tmp___145 ;
  char *tmp___146 ;
  char *tmp___147 ;
  char *tmp___148 ;
  char *tmp___149 ;
  char *tmp___150 ;
  char *tmp___151 ;
  char *tmp___152 ;
  char *tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  char *tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  char *tmp___160 ;
  char *tmp___161 ;
  char *tmp___162 ;
  char *tmp___163 ;
  char *tmp___164 ;
  char *tmp___165 ;
  char *tmp___166 ;
  char *tmp___167 ;
  char *tmp___168 ;
  char *tmp___169 ;
  char *tmp___170 ;
  char *tmp___171 ;
  char *tmp___172 ;
  char *tmp___173 ;
  char *tmp___174 ;
  char *tmp___175 ;
  char *tmp___176 ;
  char *tmp___177 ;
  char *tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  char *tmp___181 ;
  char *tmp___182 ;
  char *tmp___183 ;
  char *tmp___184 ;
  char *tmp___185 ;
  char *tmp___186 ;
  char *tmp___187 ;
  char *tmp___188 ;
  char *tmp___189 ;
  char *tmp___190 ;

  {
#line 1443
  p___0 = buffer___0;
#line 1444
  n = number;
#line 1446
  last_digit_char = 0;
#line 1454
  if (n < 0L) {
#line 1456
    if (n < - (~ (-1L << (sizeof(wgint ) * 8UL - 1UL)))) {
#line 1461
      last_digit = (int )(n % 10L);
#line 1463
      if (last_digit < 0) {
#line 1464
        last_digit_char = 48 - last_digit;
      } else {
#line 1466
        last_digit_char = 48 + last_digit;
      }
#line 1468
      n /= 10L;
    }
#line 1471
    tmp = p___0;
#line 1471
    p___0 ++;
#line 1471
    *tmp = (char )'-';
#line 1472
    n = - n;
  }
#line 1479
  if (n < 10L) {
#line 1479
    tmp___0 = p___0;
#line 1479
    p___0 ++;
#line 1479
    *tmp___0 = (char )(n + 48L);
  } else
#line 1480
  if (n < 100L) {
#line 1480
    tmp___1 = p___0;
#line 1480
    p___0 ++;
#line 1480
    *tmp___1 = (char )(n / 10L + 48L);
#line 1480
    n %= 10L;
#line 1480
    tmp___2 = p___0;
#line 1480
    p___0 ++;
#line 1480
    *tmp___2 = (char )(n + 48L);
  } else
#line 1481
  if (n < 1000L) {
#line 1481
    tmp___3 = p___0;
#line 1481
    p___0 ++;
#line 1481
    *tmp___3 = (char )(n / 100L + 48L);
#line 1481
    n %= 100L;
#line 1481
    tmp___4 = p___0;
#line 1481
    p___0 ++;
#line 1481
    *tmp___4 = (char )(n / 10L + 48L);
#line 1481
    n %= 10L;
#line 1481
    tmp___5 = p___0;
#line 1481
    p___0 ++;
#line 1481
    *tmp___5 = (char )(n + 48L);
  } else
#line 1482
  if (n < 10000L) {
#line 1482
    tmp___6 = p___0;
#line 1482
    p___0 ++;
#line 1482
    *tmp___6 = (char )(n / 1000L + 48L);
#line 1482
    n %= 1000L;
#line 1482
    tmp___7 = p___0;
#line 1482
    p___0 ++;
#line 1482
    *tmp___7 = (char )(n / 100L + 48L);
#line 1482
    n %= 100L;
#line 1482
    tmp___8 = p___0;
#line 1482
    p___0 ++;
#line 1482
    *tmp___8 = (char )(n / 10L + 48L);
#line 1482
    n %= 10L;
#line 1482
    tmp___9 = p___0;
#line 1482
    p___0 ++;
#line 1482
    *tmp___9 = (char )(n + 48L);
  } else
#line 1483
  if (n < 100000L) {
#line 1483
    tmp___10 = p___0;
#line 1483
    p___0 ++;
#line 1483
    *tmp___10 = (char )(n / 10000L + 48L);
#line 1483
    n %= 10000L;
#line 1483
    tmp___11 = p___0;
#line 1483
    p___0 ++;
#line 1483
    *tmp___11 = (char )(n / 1000L + 48L);
#line 1483
    n %= 1000L;
#line 1483
    tmp___12 = p___0;
#line 1483
    p___0 ++;
#line 1483
    *tmp___12 = (char )(n / 100L + 48L);
#line 1483
    n %= 100L;
#line 1483
    tmp___13 = p___0;
#line 1483
    p___0 ++;
#line 1483
    *tmp___13 = (char )(n / 10L + 48L);
#line 1483
    n %= 10L;
#line 1483
    tmp___14 = p___0;
#line 1483
    p___0 ++;
#line 1483
    *tmp___14 = (char )(n + 48L);
  } else
#line 1484
  if (n < 1000000L) {
#line 1484
    tmp___15 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___15 = (char )(n / 100000L + 48L);
#line 1484
    n %= 100000L;
#line 1484
    tmp___16 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___16 = (char )(n / 10000L + 48L);
#line 1484
    n %= 10000L;
#line 1484
    tmp___17 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___17 = (char )(n / 1000L + 48L);
#line 1484
    n %= 1000L;
#line 1484
    tmp___18 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___18 = (char )(n / 100L + 48L);
#line 1484
    n %= 100L;
#line 1484
    tmp___19 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___19 = (char )(n / 10L + 48L);
#line 1484
    n %= 10L;
#line 1484
    tmp___20 = p___0;
#line 1484
    p___0 ++;
#line 1484
    *tmp___20 = (char )(n + 48L);
  } else
#line 1485
  if (n < 10000000L) {
#line 1485
    tmp___21 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___21 = (char )(n / 1000000L + 48L);
#line 1485
    n %= 1000000L;
#line 1485
    tmp___22 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___22 = (char )(n / 100000L + 48L);
#line 1485
    n %= 100000L;
#line 1485
    tmp___23 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___23 = (char )(n / 10000L + 48L);
#line 1485
    n %= 10000L;
#line 1485
    tmp___24 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___24 = (char )(n / 1000L + 48L);
#line 1485
    n %= 1000L;
#line 1485
    tmp___25 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___25 = (char )(n / 100L + 48L);
#line 1485
    n %= 100L;
#line 1485
    tmp___26 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___26 = (char )(n / 10L + 48L);
#line 1485
    n %= 10L;
#line 1485
    tmp___27 = p___0;
#line 1485
    p___0 ++;
#line 1485
    *tmp___27 = (char )(n + 48L);
  } else
#line 1486
  if (n < 100000000L) {
#line 1486
    tmp___28 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___28 = (char )(n / 10000000L + 48L);
#line 1486
    n %= 10000000L;
#line 1486
    tmp___29 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___29 = (char )(n / 1000000L + 48L);
#line 1486
    n %= 1000000L;
#line 1486
    tmp___30 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___30 = (char )(n / 100000L + 48L);
#line 1486
    n %= 100000L;
#line 1486
    tmp___31 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___31 = (char )(n / 10000L + 48L);
#line 1486
    n %= 10000L;
#line 1486
    tmp___32 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___32 = (char )(n / 1000L + 48L);
#line 1486
    n %= 1000L;
#line 1486
    tmp___33 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___33 = (char )(n / 100L + 48L);
#line 1486
    n %= 100L;
#line 1486
    tmp___34 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___34 = (char )(n / 10L + 48L);
#line 1486
    n %= 10L;
#line 1486
    tmp___35 = p___0;
#line 1486
    p___0 ++;
#line 1486
    *tmp___35 = (char )(n + 48L);
  } else
#line 1487
  if (n < 1000000000L) {
#line 1487
    tmp___36 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___36 = (char )(n / 100000000L + 48L);
#line 1487
    n %= 100000000L;
#line 1487
    tmp___37 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___37 = (char )(n / 10000000L + 48L);
#line 1487
    n %= 10000000L;
#line 1487
    tmp___38 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___38 = (char )(n / 1000000L + 48L);
#line 1487
    n %= 1000000L;
#line 1487
    tmp___39 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___39 = (char )(n / 100000L + 48L);
#line 1487
    n %= 100000L;
#line 1487
    tmp___40 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___40 = (char )(n / 10000L + 48L);
#line 1487
    n %= 10000L;
#line 1487
    tmp___41 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___41 = (char )(n / 1000L + 48L);
#line 1487
    n %= 1000L;
#line 1487
    tmp___42 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___42 = (char )(n / 100L + 48L);
#line 1487
    n %= 100L;
#line 1487
    tmp___43 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___43 = (char )(n / 10L + 48L);
#line 1487
    n %= 10L;
#line 1487
    tmp___44 = p___0;
#line 1487
    p___0 ++;
#line 1487
    *tmp___44 = (char )(n + 48L);
  } else
#line 1496
  if (n < 10000000000L) {
#line 1496
    tmp___45 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___45 = (char )(n / 1000000000L + 48L);
#line 1496
    n %= 1000000000L;
#line 1496
    tmp___46 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___46 = (char )(n / 100000000L + 48L);
#line 1496
    n %= 100000000L;
#line 1496
    tmp___47 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___47 = (char )(n / 10000000L + 48L);
#line 1496
    n %= 10000000L;
#line 1496
    tmp___48 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___48 = (char )(n / 1000000L + 48L);
#line 1496
    n %= 1000000L;
#line 1496
    tmp___49 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___49 = (char )(n / 100000L + 48L);
#line 1496
    n %= 100000L;
#line 1496
    tmp___50 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___50 = (char )(n / 10000L + 48L);
#line 1496
    n %= 10000L;
#line 1496
    tmp___51 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___51 = (char )(n / 1000L + 48L);
#line 1496
    n %= 1000L;
#line 1496
    tmp___52 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___52 = (char )(n / 100L + 48L);
#line 1496
    n %= 100L;
#line 1496
    tmp___53 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___53 = (char )(n / 10L + 48L);
#line 1496
    n %= 10L;
#line 1496
    tmp___54 = p___0;
#line 1496
    p___0 ++;
#line 1496
    *tmp___54 = (char )(n + 48L);
  } else
#line 1497
  if (n < 100000000000L) {
#line 1497
    tmp___55 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___55 = (char )(n / 10000000000L + 48L);
#line 1497
    n %= 10000000000L;
#line 1497
    tmp___56 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___56 = (char )(n / 1000000000L + 48L);
#line 1497
    n %= 1000000000L;
#line 1497
    tmp___57 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___57 = (char )(n / 100000000L + 48L);
#line 1497
    n %= 100000000L;
#line 1497
    tmp___58 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___58 = (char )(n / 10000000L + 48L);
#line 1497
    n %= 10000000L;
#line 1497
    tmp___59 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___59 = (char )(n / 1000000L + 48L);
#line 1497
    n %= 1000000L;
#line 1497
    tmp___60 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___60 = (char )(n / 100000L + 48L);
#line 1497
    n %= 100000L;
#line 1497
    tmp___61 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___61 = (char )(n / 10000L + 48L);
#line 1497
    n %= 10000L;
#line 1497
    tmp___62 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___62 = (char )(n / 1000L + 48L);
#line 1497
    n %= 1000L;
#line 1497
    tmp___63 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___63 = (char )(n / 100L + 48L);
#line 1497
    n %= 100L;
#line 1497
    tmp___64 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___64 = (char )(n / 10L + 48L);
#line 1497
    n %= 10L;
#line 1497
    tmp___65 = p___0;
#line 1497
    p___0 ++;
#line 1497
    *tmp___65 = (char )(n + 48L);
  } else
#line 1498
  if (n < 1000000000000L) {
#line 1498
    tmp___66 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___66 = (char )(n / 100000000000L + 48L);
#line 1498
    n %= 100000000000L;
#line 1498
    tmp___67 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___67 = (char )(n / 10000000000L + 48L);
#line 1498
    n %= 10000000000L;
#line 1498
    tmp___68 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___68 = (char )(n / 1000000000L + 48L);
#line 1498
    n %= 1000000000L;
#line 1498
    tmp___69 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___69 = (char )(n / 100000000L + 48L);
#line 1498
    n %= 100000000L;
#line 1498
    tmp___70 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___70 = (char )(n / 10000000L + 48L);
#line 1498
    n %= 10000000L;
#line 1498
    tmp___71 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___71 = (char )(n / 1000000L + 48L);
#line 1498
    n %= 1000000L;
#line 1498
    tmp___72 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___72 = (char )(n / 100000L + 48L);
#line 1498
    n %= 100000L;
#line 1498
    tmp___73 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___73 = (char )(n / 10000L + 48L);
#line 1498
    n %= 10000L;
#line 1498
    tmp___74 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___74 = (char )(n / 1000L + 48L);
#line 1498
    n %= 1000L;
#line 1498
    tmp___75 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___75 = (char )(n / 100L + 48L);
#line 1498
    n %= 100L;
#line 1498
    tmp___76 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___76 = (char )(n / 10L + 48L);
#line 1498
    n %= 10L;
#line 1498
    tmp___77 = p___0;
#line 1498
    p___0 ++;
#line 1498
    *tmp___77 = (char )(n + 48L);
  } else
#line 1499
  if (n < 10000000000000L) {
#line 1499
    tmp___78 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___78 = (char )(n / 1000000000000L + 48L);
#line 1499
    n %= 1000000000000L;
#line 1499
    tmp___79 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___79 = (char )(n / 100000000000L + 48L);
#line 1499
    n %= 100000000000L;
#line 1499
    tmp___80 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___80 = (char )(n / 10000000000L + 48L);
#line 1499
    n %= 10000000000L;
#line 1499
    tmp___81 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___81 = (char )(n / 1000000000L + 48L);
#line 1499
    n %= 1000000000L;
#line 1499
    tmp___82 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___82 = (char )(n / 100000000L + 48L);
#line 1499
    n %= 100000000L;
#line 1499
    tmp___83 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___83 = (char )(n / 10000000L + 48L);
#line 1499
    n %= 10000000L;
#line 1499
    tmp___84 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___84 = (char )(n / 1000000L + 48L);
#line 1499
    n %= 1000000L;
#line 1499
    tmp___85 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___85 = (char )(n / 100000L + 48L);
#line 1499
    n %= 100000L;
#line 1499
    tmp___86 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___86 = (char )(n / 10000L + 48L);
#line 1499
    n %= 10000L;
#line 1499
    tmp___87 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___87 = (char )(n / 1000L + 48L);
#line 1499
    n %= 1000L;
#line 1499
    tmp___88 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___88 = (char )(n / 100L + 48L);
#line 1499
    n %= 100L;
#line 1499
    tmp___89 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___89 = (char )(n / 10L + 48L);
#line 1499
    n %= 10L;
#line 1499
    tmp___90 = p___0;
#line 1499
    p___0 ++;
#line 1499
    *tmp___90 = (char )(n + 48L);
  } else
#line 1500
  if (n < 100000000000000L) {
#line 1500
    tmp___91 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___91 = (char )(n / 10000000000000L + 48L);
#line 1500
    n %= 10000000000000L;
#line 1500
    tmp___92 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___92 = (char )(n / 1000000000000L + 48L);
#line 1500
    n %= 1000000000000L;
#line 1500
    tmp___93 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___93 = (char )(n / 100000000000L + 48L);
#line 1500
    n %= 100000000000L;
#line 1500
    tmp___94 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___94 = (char )(n / 10000000000L + 48L);
#line 1500
    n %= 10000000000L;
#line 1500
    tmp___95 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___95 = (char )(n / 1000000000L + 48L);
#line 1500
    n %= 1000000000L;
#line 1500
    tmp___96 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___96 = (char )(n / 100000000L + 48L);
#line 1500
    n %= 100000000L;
#line 1500
    tmp___97 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___97 = (char )(n / 10000000L + 48L);
#line 1500
    n %= 10000000L;
#line 1500
    tmp___98 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___98 = (char )(n / 1000000L + 48L);
#line 1500
    n %= 1000000L;
#line 1500
    tmp___99 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___99 = (char )(n / 100000L + 48L);
#line 1500
    n %= 100000L;
#line 1500
    tmp___100 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___100 = (char )(n / 10000L + 48L);
#line 1500
    n %= 10000L;
#line 1500
    tmp___101 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___101 = (char )(n / 1000L + 48L);
#line 1500
    n %= 1000L;
#line 1500
    tmp___102 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___102 = (char )(n / 100L + 48L);
#line 1500
    n %= 100L;
#line 1500
    tmp___103 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___103 = (char )(n / 10L + 48L);
#line 1500
    n %= 10L;
#line 1500
    tmp___104 = p___0;
#line 1500
    p___0 ++;
#line 1500
    *tmp___104 = (char )(n + 48L);
  } else
#line 1501
  if (n < 1000000000000000L) {
#line 1501
    tmp___105 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___105 = (char )(n / 100000000000000L + 48L);
#line 1501
    n %= 100000000000000L;
#line 1501
    tmp___106 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___106 = (char )(n / 10000000000000L + 48L);
#line 1501
    n %= 10000000000000L;
#line 1501
    tmp___107 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___107 = (char )(n / 1000000000000L + 48L);
#line 1501
    n %= 1000000000000L;
#line 1501
    tmp___108 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___108 = (char )(n / 100000000000L + 48L);
#line 1501
    n %= 100000000000L;
#line 1501
    tmp___109 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___109 = (char )(n / 10000000000L + 48L);
#line 1501
    n %= 10000000000L;
#line 1501
    tmp___110 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___110 = (char )(n / 1000000000L + 48L);
#line 1501
    n %= 1000000000L;
#line 1501
    tmp___111 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___111 = (char )(n / 100000000L + 48L);
#line 1501
    n %= 100000000L;
#line 1501
    tmp___112 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___112 = (char )(n / 10000000L + 48L);
#line 1501
    n %= 10000000L;
#line 1501
    tmp___113 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___113 = (char )(n / 1000000L + 48L);
#line 1501
    n %= 1000000L;
#line 1501
    tmp___114 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___114 = (char )(n / 100000L + 48L);
#line 1501
    n %= 100000L;
#line 1501
    tmp___115 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___115 = (char )(n / 10000L + 48L);
#line 1501
    n %= 10000L;
#line 1501
    tmp___116 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___116 = (char )(n / 1000L + 48L);
#line 1501
    n %= 1000L;
#line 1501
    tmp___117 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___117 = (char )(n / 100L + 48L);
#line 1501
    n %= 100L;
#line 1501
    tmp___118 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___118 = (char )(n / 10L + 48L);
#line 1501
    n %= 10L;
#line 1501
    tmp___119 = p___0;
#line 1501
    p___0 ++;
#line 1501
    *tmp___119 = (char )(n + 48L);
  } else
#line 1502
  if (n < 10000000000000000L) {
#line 1502
    tmp___120 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___120 = (char )(n / 1000000000000000L + 48L);
#line 1502
    n %= 1000000000000000L;
#line 1502
    tmp___121 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___121 = (char )(n / 100000000000000L + 48L);
#line 1502
    n %= 100000000000000L;
#line 1502
    tmp___122 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___122 = (char )(n / 10000000000000L + 48L);
#line 1502
    n %= 10000000000000L;
#line 1502
    tmp___123 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___123 = (char )(n / 1000000000000L + 48L);
#line 1502
    n %= 1000000000000L;
#line 1502
    tmp___124 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___124 = (char )(n / 100000000000L + 48L);
#line 1502
    n %= 100000000000L;
#line 1502
    tmp___125 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___125 = (char )(n / 10000000000L + 48L);
#line 1502
    n %= 10000000000L;
#line 1502
    tmp___126 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___126 = (char )(n / 1000000000L + 48L);
#line 1502
    n %= 1000000000L;
#line 1502
    tmp___127 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___127 = (char )(n / 100000000L + 48L);
#line 1502
    n %= 100000000L;
#line 1502
    tmp___128 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___128 = (char )(n / 10000000L + 48L);
#line 1502
    n %= 10000000L;
#line 1502
    tmp___129 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___129 = (char )(n / 1000000L + 48L);
#line 1502
    n %= 1000000L;
#line 1502
    tmp___130 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___130 = (char )(n / 100000L + 48L);
#line 1502
    n %= 100000L;
#line 1502
    tmp___131 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___131 = (char )(n / 10000L + 48L);
#line 1502
    n %= 10000L;
#line 1502
    tmp___132 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___132 = (char )(n / 1000L + 48L);
#line 1502
    n %= 1000L;
#line 1502
    tmp___133 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___133 = (char )(n / 100L + 48L);
#line 1502
    n %= 100L;
#line 1502
    tmp___134 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___134 = (char )(n / 10L + 48L);
#line 1502
    n %= 10L;
#line 1502
    tmp___135 = p___0;
#line 1502
    p___0 ++;
#line 1502
    *tmp___135 = (char )(n + 48L);
  } else
#line 1503
  if (n < 100000000000000000L) {
#line 1503
    tmp___136 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___136 = (char )(n / 10000000000000000L + 48L);
#line 1503
    n %= 10000000000000000L;
#line 1503
    tmp___137 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___137 = (char )(n / 1000000000000000L + 48L);
#line 1503
    n %= 1000000000000000L;
#line 1503
    tmp___138 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___138 = (char )(n / 100000000000000L + 48L);
#line 1503
    n %= 100000000000000L;
#line 1503
    tmp___139 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___139 = (char )(n / 10000000000000L + 48L);
#line 1503
    n %= 10000000000000L;
#line 1503
    tmp___140 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___140 = (char )(n / 1000000000000L + 48L);
#line 1503
    n %= 1000000000000L;
#line 1503
    tmp___141 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___141 = (char )(n / 100000000000L + 48L);
#line 1503
    n %= 100000000000L;
#line 1503
    tmp___142 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___142 = (char )(n / 10000000000L + 48L);
#line 1503
    n %= 10000000000L;
#line 1503
    tmp___143 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___143 = (char )(n / 1000000000L + 48L);
#line 1503
    n %= 1000000000L;
#line 1503
    tmp___144 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___144 = (char )(n / 100000000L + 48L);
#line 1503
    n %= 100000000L;
#line 1503
    tmp___145 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___145 = (char )(n / 10000000L + 48L);
#line 1503
    n %= 10000000L;
#line 1503
    tmp___146 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___146 = (char )(n / 1000000L + 48L);
#line 1503
    n %= 1000000L;
#line 1503
    tmp___147 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___147 = (char )(n / 100000L + 48L);
#line 1503
    n %= 100000L;
#line 1503
    tmp___148 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___148 = (char )(n / 10000L + 48L);
#line 1503
    n %= 10000L;
#line 1503
    tmp___149 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___149 = (char )(n / 1000L + 48L);
#line 1503
    n %= 1000L;
#line 1503
    tmp___150 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___150 = (char )(n / 100L + 48L);
#line 1503
    n %= 100L;
#line 1503
    tmp___151 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___151 = (char )(n / 10L + 48L);
#line 1503
    n %= 10L;
#line 1503
    tmp___152 = p___0;
#line 1503
    p___0 ++;
#line 1503
    *tmp___152 = (char )(n + 48L);
  } else
#line 1504
  if (n < 1000000000000000000L) {
#line 1504
    tmp___153 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___153 = (char )(n / 100000000000000000L + 48L);
#line 1504
    n %= 100000000000000000L;
#line 1504
    tmp___154 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___154 = (char )(n / 10000000000000000L + 48L);
#line 1504
    n %= 10000000000000000L;
#line 1504
    tmp___155 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___155 = (char )(n / 1000000000000000L + 48L);
#line 1504
    n %= 1000000000000000L;
#line 1504
    tmp___156 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___156 = (char )(n / 100000000000000L + 48L);
#line 1504
    n %= 100000000000000L;
#line 1504
    tmp___157 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___157 = (char )(n / 10000000000000L + 48L);
#line 1504
    n %= 10000000000000L;
#line 1504
    tmp___158 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___158 = (char )(n / 1000000000000L + 48L);
#line 1504
    n %= 1000000000000L;
#line 1504
    tmp___159 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___159 = (char )(n / 100000000000L + 48L);
#line 1504
    n %= 100000000000L;
#line 1504
    tmp___160 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___160 = (char )(n / 10000000000L + 48L);
#line 1504
    n %= 10000000000L;
#line 1504
    tmp___161 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___161 = (char )(n / 1000000000L + 48L);
#line 1504
    n %= 1000000000L;
#line 1504
    tmp___162 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___162 = (char )(n / 100000000L + 48L);
#line 1504
    n %= 100000000L;
#line 1504
    tmp___163 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___163 = (char )(n / 10000000L + 48L);
#line 1504
    n %= 10000000L;
#line 1504
    tmp___164 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___164 = (char )(n / 1000000L + 48L);
#line 1504
    n %= 1000000L;
#line 1504
    tmp___165 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___165 = (char )(n / 100000L + 48L);
#line 1504
    n %= 100000L;
#line 1504
    tmp___166 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___166 = (char )(n / 10000L + 48L);
#line 1504
    n %= 10000L;
#line 1504
    tmp___167 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___167 = (char )(n / 1000L + 48L);
#line 1504
    n %= 1000L;
#line 1504
    tmp___168 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___168 = (char )(n / 100L + 48L);
#line 1504
    n %= 100L;
#line 1504
    tmp___169 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___169 = (char )(n / 10L + 48L);
#line 1504
    n %= 10L;
#line 1504
    tmp___170 = p___0;
#line 1504
    p___0 ++;
#line 1504
    *tmp___170 = (char )(n + 48L);
  } else {
#line 1505
    tmp___171 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___171 = (char )(n / 1000000000000000000L + 48L);
#line 1505
    n %= 1000000000000000000L;
#line 1505
    tmp___172 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___172 = (char )(n / 100000000000000000L + 48L);
#line 1505
    n %= 100000000000000000L;
#line 1505
    tmp___173 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___173 = (char )(n / 10000000000000000L + 48L);
#line 1505
    n %= 10000000000000000L;
#line 1505
    tmp___174 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___174 = (char )(n / 1000000000000000L + 48L);
#line 1505
    n %= 1000000000000000L;
#line 1505
    tmp___175 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___175 = (char )(n / 100000000000000L + 48L);
#line 1505
    n %= 100000000000000L;
#line 1505
    tmp___176 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___176 = (char )(n / 10000000000000L + 48L);
#line 1505
    n %= 10000000000000L;
#line 1505
    tmp___177 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___177 = (char )(n / 1000000000000L + 48L);
#line 1505
    n %= 1000000000000L;
#line 1505
    tmp___178 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___178 = (char )(n / 100000000000L + 48L);
#line 1505
    n %= 100000000000L;
#line 1505
    tmp___179 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___179 = (char )(n / 10000000000L + 48L);
#line 1505
    n %= 10000000000L;
#line 1505
    tmp___180 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___180 = (char )(n / 1000000000L + 48L);
#line 1505
    n %= 1000000000L;
#line 1505
    tmp___181 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___181 = (char )(n / 100000000L + 48L);
#line 1505
    n %= 100000000L;
#line 1505
    tmp___182 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___182 = (char )(n / 10000000L + 48L);
#line 1505
    n %= 10000000L;
#line 1505
    tmp___183 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___183 = (char )(n / 1000000L + 48L);
#line 1505
    n %= 1000000L;
#line 1505
    tmp___184 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___184 = (char )(n / 100000L + 48L);
#line 1505
    n %= 100000L;
#line 1505
    tmp___185 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___185 = (char )(n / 10000L + 48L);
#line 1505
    n %= 10000L;
#line 1505
    tmp___186 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___186 = (char )(n / 1000L + 48L);
#line 1505
    n %= 1000L;
#line 1505
    tmp___187 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___187 = (char )(n / 100L + 48L);
#line 1505
    n %= 100L;
#line 1505
    tmp___188 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___188 = (char )(n / 10L + 48L);
#line 1505
    n %= 10L;
#line 1505
    tmp___189 = p___0;
#line 1505
    p___0 ++;
#line 1505
    *tmp___189 = (char )(n + 48L);
  }
#line 1508
  if (last_digit_char) {
#line 1509
    tmp___190 = p___0;
#line 1509
    p___0 ++;
#line 1509
    *tmp___190 = (char )last_digit_char;
  }
#line 1511
  *p___0 = (char )'\000';
#line 1514
  return (p___0);
}
}
#line 1576 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char ring[3][24]  ;
#line 1577 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static int ringpos  ;
#line 1573 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char *number_to_static_string(wgint number ) 
{ 
  char *buf___4 ;

  {
  {
#line 1578
  buf___4 = ring[ringpos];
#line 1579
  number_to_string(buf___4, number);
#line 1580
  ringpos = (ringpos + 1) % 3;
  }
#line 1581
  return (buf___4);
}
}
#line 1587 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int determine_screen_width(void) 
{ 
  int fd ;
  struct winsize wsz ;
  int tmp ;

  {
#line 1596
  if ((unsigned long )opt.lfilename != (unsigned long )((void *)0)) {
#line 1597
    return (0);
  }
  {
#line 1599
  fd = fileno(stderr);
#line 1600
  tmp = ioctl(fd, 21523UL, & wsz);
  }
#line 1600
  if (tmp < 0) {
#line 1601
    return (0);
  }
#line 1603
  return ((int )wsz.ws_col);
}
}
#line 1616 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static int rnd_seeded  ;
#line 1630 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int random_number(int max ) 
{ 
  time_t tmp ;
  __pid_t tmp___0 ;
  long tmp___1 ;

  {
#line 1634
  if (! rnd_seeded) {
    {
#line 1636
    tmp = time((time_t *)((void *)0));
#line 1636
    tmp___0 = getpid();
#line 1636
    srand48(tmp ^ (long )tmp___0);
#line 1637
    rnd_seeded = 1;
    }
  }
  {
#line 1639
  tmp___1 = lrand48();
  }
#line 1639
  return ((int )(tmp___1 % (long )max));
}
}
#line 1665 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
double random_float(void) 
{ 
  time_t tmp ;
  __pid_t tmp___0 ;
  double tmp___1 ;

  {
#line 1669
  if (! rnd_seeded) {
    {
#line 1671
    tmp = time((time_t *)((void *)0));
#line 1671
    tmp___0 = getpid();
#line 1671
    srand48(tmp ^ (long )tmp___0);
#line 1672
    rnd_seeded = 1;
    }
  }
  {
#line 1674
  tmp___1 = drand48();
  }
#line 1674
  return (tmp___1);
}
}
#line 1690 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static sigjmp_buf run_with_timeout_env  ;
#line 1692 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static void abort_run_with_timeout(int sig ) 
{ 


  {
#line 1695
  if (! (sig == 14)) {
    {
#line 1695
    __assert_fail("sig == SIGALRM", "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c",
                  1695U, "abort_run_with_timeout");
    }
  }
  {
#line 1696
  siglongjmp((struct __jmp_buf_tag *)(run_with_timeout_env), -1);
  }
}
}
#line 1727 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static void alarm_set(double timeout ) 
{ 
  struct itimerval itv ;

  {
  {
#line 1733
  memset((void *)(& itv), '\000', sizeof(itv));
#line 1734
  itv.it_value.tv_sec = (long )timeout;
#line 1735
  itv.it_value.tv_usec = (__suseconds_t )((double )1000000 * (timeout - (double )((long )timeout)));
  }
#line 1736
  if (itv.it_value.tv_sec == 0L) {
#line 1736
    if (itv.it_value.tv_usec == 0L) {
#line 1739
      itv.it_value.tv_usec = (__suseconds_t )1;
    }
  }
  {
#line 1740
  setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& itv),
            (struct itimerval */* __restrict  */)((void *)0));
  }
#line 1752
  return;
}
}
#line 1756 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static void alarm_cancel(void) 
{ 
  struct itimerval disable ;

  {
  {
#line 1761
  memset((void *)(& disable), '\000', sizeof(disable));
#line 1762
  setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& disable),
            (struct itimerval */* __restrict  */)((void *)0));
  }
#line 1766
  return;
}
}
#line 1795 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
_Bool run_with_timeout(double timeout , void (*fun)(void * ) , void *arg ) 
{ 
  int saved_errno ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1800
  if (timeout == (double )0) {
    {
#line 1802
    (*fun)(arg);
    }
#line 1803
    return ((_Bool)0);
  }
  {
#line 1806
  signal(14, & abort_run_with_timeout);
#line 1807
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(run_with_timeout_env), 1);
  }
#line 1807
  if (tmp != 0) {
    {
#line 1810
    signal(14, (void (*)(int  ))0);
    }
#line 1811
    return ((_Bool)1);
  }
  {
#line 1813
  alarm_set(timeout);
#line 1814
  (*fun)(arg);
#line 1817
  tmp___0 = __errno_location();
#line 1817
  saved_errno = *tmp___0;
#line 1818
  alarm_cancel();
#line 1819
  signal(14, (void (*)(int  ))0);
#line 1820
  tmp___1 = __errno_location();
#line 1820
  *tmp___1 = saved_errno;
  }
#line 1822
  return ((_Bool)0);
}
}
#line 1846 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void xsleep(double seconds ) 
{ 
  struct timespec sleep___0 ;
  struct timespec remaining ;
  int tmp ;
  int *tmp___0 ;

  {
#line 1856
  sleep___0.tv_sec = (long )seconds;
#line 1857
  sleep___0.tv_nsec = (__syscall_slong_t )((double )1000000000 * (seconds - (double )((long )seconds)));
  {
#line 1858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1858
    tmp = nanosleep((struct timespec  const  *)(& sleep___0), & remaining);
    }
#line 1858
    if (tmp < 0) {
      {
#line 1858
      tmp___0 = __errno_location();
      }
#line 1858
      if (! (*tmp___0 == 4)) {
#line 1858
        goto while_break;
      }
    } else {
#line 1858
      goto while_break;
    }
#line 1861
    sleep___0 = remaining;
  }
  while_break: /* CIL Label */ ;
  }
#line 1887
  return;
}
}
#line 1904 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char const   tbl[64]  = 
#line 1904
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 1900 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int base64_encode(void const   *data , int length , char *dest ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *end ;
  char *p___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 1912
  s = (unsigned char const   *)data;
#line 1914
  end = ((unsigned char const   *)data + length) - 2;
#line 1915
  p___0 = dest;
  {
#line 1918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1918
    if (! ((unsigned long )s < (unsigned long )end)) {
#line 1918
      goto while_break;
    }
#line 1920
    tmp = p___0;
#line 1920
    p___0 ++;
#line 1920
    *tmp = (char )tbl[(int const   )*(s + 0) >> 2];
#line 1921
    tmp___0 = p___0;
#line 1921
    p___0 ++;
#line 1921
    *tmp___0 = (char )tbl[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 1922
    tmp___1 = p___0;
#line 1922
    p___0 ++;
#line 1922
    *tmp___1 = (char )tbl[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 1923
    tmp___2 = p___0;
#line 1923
    p___0 ++;
#line 1923
    *tmp___2 = (char )tbl[(int const   )*(s + 2) & 63];
#line 1918
    s += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1929
  if (length % 3 == 1) {
#line 1929
    goto case_1;
  }
#line 1935
  if (length % 3 == 2) {
#line 1935
    goto case_2;
  }
#line 1927
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1930
  tmp___3 = p___0;
#line 1930
  p___0 ++;
#line 1930
  *tmp___3 = (char )tbl[(int const   )*(s + 0) >> 2];
#line 1931
  tmp___4 = p___0;
#line 1931
  p___0 ++;
#line 1931
  *tmp___4 = (char )tbl[((int const   )*(s + 0) & 3) << 4];
#line 1932
  tmp___5 = p___0;
#line 1932
  p___0 ++;
#line 1932
  *tmp___5 = (char )'=';
#line 1933
  tmp___6 = p___0;
#line 1933
  p___0 ++;
#line 1933
  *tmp___6 = (char )'=';
#line 1934
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1936
  tmp___7 = p___0;
#line 1936
  p___0 ++;
#line 1936
  *tmp___7 = (char )tbl[(int const   )*(s + 0) >> 2];
#line 1937
  tmp___8 = p___0;
#line 1937
  p___0 ++;
#line 1937
  *tmp___8 = (char )tbl[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 1938
  tmp___9 = p___0;
#line 1938
  p___0 ++;
#line 1938
  *tmp___9 = (char )tbl[((int const   )*(s + 1) & 15) << 2];
#line 1939
  tmp___10 = p___0;
#line 1939
  p___0 ++;
#line 1939
  *tmp___10 = (char )'=';
#line 1940
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1943
  *p___0 = (char )'\000';
#line 1945
  return ((int )(p___0 - dest));
}
}
#line 1973 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static signed char const   base64_char_to_value[128]  = 
#line 1973
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 1968 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
int base64_decode(char const   *base64 , void *dest ) 
{ 
  char const   *p___0 ;
  char *q ;
  unsigned char c ;
  unsigned long value ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
#line 1992
  p___0 = base64;
#line 1993
  q = (char *)dest;
  {
#line 1995
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2001
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2001
      tmp = p___0;
#line 2001
      p___0 ++;
#line 2001
      c = (unsigned char )*tmp;
#line 2001
      if (! ((int const   )_sch_istable[(int )c & 255] & 64)) {
#line 2001
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2002
    if (! c) {
#line 2003
      goto while_break;
    }
#line 2004
    if ((int )c == 61) {
#line 2005
      return (-1);
    } else
#line 2004
    if (((int )c & 128) == 0) {
#line 2004
      if (! ((int )base64_char_to_value[c] >= 0)) {
#line 2004
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2004
    if (! ((int )c == 61)) {
#line 2005
      return (-1);
    }
#line 2006
    value = (unsigned long )((int )base64_char_to_value[c] << 18);
    {
#line 2009
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2009
      tmp___0 = p___0;
#line 2009
      p___0 ++;
#line 2009
      c = (unsigned char )*tmp___0;
#line 2009
      if (! ((int const   )_sch_istable[(int )c & 255] & 64)) {
#line 2009
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2010
    if (! c) {
#line 2011
      return (-1);
    }
#line 2012
    if ((int )c == 61) {
#line 2013
      return (-1);
    } else
#line 2012
    if (((int )c & 128) == 0) {
#line 2012
      if (! ((int )base64_char_to_value[c] >= 0)) {
#line 2012
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2012
    if (! ((int )c == 61)) {
#line 2013
      return (-1);
    }
#line 2014
    value |= (unsigned long )((int )base64_char_to_value[c] << 12);
#line 2015
    tmp___1 = q;
#line 2015
    q ++;
#line 2015
    *tmp___1 = (char )(value >> 16);
    {
#line 2018
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2018
      tmp___2 = p___0;
#line 2018
      p___0 ++;
#line 2018
      c = (unsigned char )*tmp___2;
#line 2018
      if (! ((int const   )_sch_istable[(int )c & 255] & 64)) {
#line 2018
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2019
    if (! c) {
#line 2020
      return (-1);
    }
#line 2021
    if (((int )c & 128) == 0) {
#line 2021
      if (! ((int )base64_char_to_value[c] >= 0)) {
#line 2021
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2021
    if (! ((int )c == 61)) {
#line 2022
      return (-1);
    }
#line 2024
    if ((int )c == 61) {
      {
#line 2026
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2026
        tmp___3 = p___0;
#line 2026
        p___0 ++;
#line 2026
        c = (unsigned char )*tmp___3;
#line 2026
        if (! ((int const   )_sch_istable[(int )c & 255] & 64)) {
#line 2026
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2027
      if (! c) {
#line 2028
        return (-1);
      }
#line 2029
      if ((int )c != 61) {
#line 2030
        return (-1);
      }
#line 2031
      goto while_continue;
    }
#line 2034
    value |= (unsigned long )((int )base64_char_to_value[c] << 6);
#line 2035
    tmp___4 = q;
#line 2035
    q ++;
#line 2035
    *tmp___4 = (char )(255UL & (value >> 8));
    {
#line 2038
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2038
      tmp___5 = p___0;
#line 2038
      p___0 ++;
#line 2038
      c = (unsigned char )*tmp___5;
#line 2038
      if (! ((int const   )_sch_istable[(int )c & 255] & 64)) {
#line 2038
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2039
    if (! c) {
#line 2040
      return (-1);
    }
#line 2041
    if ((int )c == 61) {
#line 2042
      goto while_continue;
    }
#line 2043
    if (((int )c & 128) == 0) {
#line 2043
      if (! ((int )base64_char_to_value[c] >= 0)) {
#line 2043
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2043
    if (! ((int )c == 61)) {
#line 2044
      return (-1);
    }
#line 2046
    value |= (unsigned long )((int )base64_char_to_value[c]);
#line 2047
    tmp___6 = q;
#line 2047
    q ++;
#line 2047
    *tmp___6 = (char )(255UL & value);
  }
  while_break: /* CIL Label */ ;
  }
#line 2052
  return ((int )(q - (char *)dest));
}
}
#line 2061 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static void mergesort_internal(void *base , void *temp , size_t size , size_t from ,
                               size_t to , int (*cmpfun)(void const   * , void const   * ) ) 
{ 
  size_t i ;
  size_t j ;
  size_t k ;
  size_t mid ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 2066
  if (from < to) {
    {
#line 2069
    mid = (to + from) / 2UL;
#line 2070
    mergesort_internal(base, temp, size, from, mid, cmpfun);
#line 2071
    mergesort_internal(base, temp, size, mid + 1UL, to, cmpfun);
#line 2072
    i = from;
#line 2073
    j = mid + 1UL;
#line 2074
    k = from;
    }
    {
#line 2074
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2074
      if (i <= mid) {
#line 2074
        if (! (j <= to)) {
#line 2074
          goto while_break;
        }
      } else {
#line 2074
        goto while_break;
      }
      {
#line 2075
      tmp___1 = (*cmpfun)((void const   *)((char *)base + i * size), (void const   *)((char *)base + j * size));
      }
#line 2075
      if (tmp___1 <= 0) {
        {
#line 2076
        tmp = i;
#line 2076
        i ++;
#line 2076
        memcpy((void */* __restrict  */)((char *)temp + k * size), (void const   */* __restrict  */)((char *)base + tmp * size),
               size);
        }
      } else {
        {
#line 2078
        tmp___0 = j;
#line 2078
        j ++;
#line 2078
        memcpy((void */* __restrict  */)((char *)temp + k * size), (void const   */* __restrict  */)((char *)base + tmp___0 * size),
               size);
        }
      }
#line 2074
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2079
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2079
      if (! (i <= mid)) {
#line 2079
        goto while_break___0;
      }
      {
#line 2080
      tmp___2 = i;
#line 2080
      i ++;
#line 2080
      tmp___3 = k;
#line 2080
      k ++;
#line 2080
      memcpy((void */* __restrict  */)((char *)temp + tmp___3 * size), (void const   */* __restrict  */)((char *)base + tmp___2 * size),
             size);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2081
      if (! (j <= to)) {
#line 2081
        goto while_break___1;
      }
      {
#line 2082
      tmp___4 = j;
#line 2082
      j ++;
#line 2082
      tmp___5 = k;
#line 2082
      k ++;
#line 2082
      memcpy((void */* __restrict  */)((char *)temp + tmp___5 * size), (void const   */* __restrict  */)((char *)base + tmp___4 * size),
             size);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2083
    k = from;
    {
#line 2083
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2083
      if (! (k <= to)) {
#line 2083
        goto while_break___2;
      }
      {
#line 2084
      memcpy((void */* __restrict  */)((char *)base + k * size), (void const   */* __restrict  */)((char *)temp + k * size),
             size);
#line 2083
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2087
  return;
}
}
#line 2093 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
void stable_sort(void *base , size_t nmemb , size_t size , int (*cmpfun)(void const   * ,
                                                                         void const   * ) ) 
{ 
  void *temp ;
  void *tmp ;

  {
#line 2097
  if (size > 1UL) {
    {
#line 2099
    tmp = __builtin_alloca((nmemb * size) * sizeof(void *));
#line 2099
    temp = tmp;
#line 2100
    mergesort_internal(base, temp, size, (size_t )0, nmemb - 1UL, cmpfun);
    }
  }
#line 2102
  return;
}
}
#line 2118 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
static char buf___0[32]  ;
#line 2115 "/home/khheo/project/benchmark/wget-1.11.4/src/utils.c"
char const   *print_decimal(double number ) 
{ 
  double n ;
  double tmp ;

  {
#line 2119
  if (number >= (double )0) {
#line 2119
    tmp = number;
  } else {
#line 2119
    tmp = - number;
  }
#line 2119
  n = tmp;
#line 2121
  if (n >= 9.95) {
    {
#line 2124
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%.0f",
             number);
    }
  } else
#line 2125
  if (n >= 0.95) {
    {
#line 2126
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%.1f",
             number);
    }
  } else
#line 2127
  if (n >= 0.001) {
    {
#line 2128
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%.1g",
             number);
    }
  } else
#line 2129
  if (n >= 0.0005) {
    {
#line 2131
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%.3f",
             number);
    }
  } else {
    {
#line 2134
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"0");
    }
  }
#line 2136
  return ((char const   *)(buf___0));
}
}
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 114
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 125 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.h"
unsigned char const   _sch_toupper[256] ;
#line 85 "/home/khheo/project/benchmark/wget-1.11.4/src/url.h"
char *url_escape(char const   *s ) ;
#line 87
struct url *url_parse(char const   *url , int *error ) ;
#line 88
char const   *url_error(int error_code ) ;
#line 89
char *url_full_path(struct url  const  *url ) ;
#line 90
void url_set_dir(struct url *url , char const   *newdir ) ;
#line 91
void url_set_file(struct url *url , char const   *newfile ) ;
#line 92
void url_free(struct url *url ) ;
#line 94
enum url_scheme url_scheme(char const   *url ) ;
#line 95
_Bool url_has_scheme(char const   *url ) ;
#line 96
int scheme_default_port(enum url_scheme scheme ) ;
#line 97
void scheme_disable(enum url_scheme scheme ) ;
#line 99
char *url_string(struct url  const  *url , enum url_auth_mode auth_mode ) ;
#line 100
char *url_file_name(struct url  const  *u ) ;
#line 102
char *uri_merge(char const   *base , char const   *link___0 ) ;
#line 104
int mkalldirs(char const   *path ) ;
#line 106
char *rewrite_shorthand_url(char const   *url ) ;
#line 107
_Bool schemes_are_similar_p(enum url_scheme a , enum url_scheme b ) ;
#line 109
_Bool are_urls_equal(char const   *u1 , char const   *u2 ) ;
#line 93 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
_Bool is_valid_ipv6_address(char const   *str , char const   *end ) ;
#line 71 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static struct scheme_data supported_schemes[4]  = {      {"http", "http://", 80, 12}, 
        {"https", "https://", 443, 12}, 
        {"ftp", "ftp://", 21, 10}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), -1, 0}};
#line 85
static _Bool path_simplify(enum url_scheme scheme , char *path ) ;
#line 128 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static unsigned char const   urlchr_table[256]  = 
#line 128
  {      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
#line 170 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void url_unescape(char *s ) 
{ 
  char *t ;
  char *h ;
  char c ;
  int tmp ;
  int tmp___0 ;

  {
#line 173
  t = s;
#line 174
  h = s;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! *h) {
#line 176
      goto while_break;
    }
#line 178
    if ((int )*h != 37) {
      copychar: 
#line 181
      *t = *h;
    } else {
#line 187
      if (! *(h + 1)) {
#line 188
        goto copychar;
      } else
#line 187
      if (! *(h + 2)) {
#line 188
        goto copychar;
      } else
#line 187
      if ((int const   )_sch_istable[(int )*(h + 1) & 255] & 256) {
#line 187
        if (! ((int const   )_sch_istable[(int )*(h + 2) & 255] & 256)) {
#line 188
          goto copychar;
        }
      } else {
#line 188
        goto copychar;
      }
#line 189
      if ((int )*(h + 1) < 65) {
#line 189
        tmp = (int )*(h + 1) - 48;
      } else {
#line 189
        tmp = (int )(((int const   )_sch_toupper[(int )*(h + 1) & 255] - 65) + 10);
      }
#line 189
      if ((int )*(h + 2) < 65) {
#line 189
        tmp___0 = (int )*(h + 2) - 48;
      } else {
#line 189
        tmp___0 = (int )(((int const   )_sch_toupper[(int )*(h + 2) & 255] - 65) + 10);
      }
#line 189
      c = (char )((tmp << 4) + tmp___0);
#line 192
      if ((int )c == 0) {
#line 193
        goto copychar;
      }
#line 194
      *t = c;
#line 195
      h += 2;
    }
#line 176
    h ++;
#line 176
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  *t = (char )'\000';
#line 199
  return;
}
}
#line 208 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char *url_escape_1(char const   *s , unsigned char mask , _Bool allow_passthrough ) 
{ 
  char const   *p1 ;
  char *p2 ;
  char *newstr ;
  int newlen ;
  int addition ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 214
  addition = 0;
#line 216
  p1 = s;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! *p1) {
#line 216
      goto while_break;
    }
#line 217
    if ((int const   )urlchr_table[(unsigned char )*p1] & (int const   )mask) {
#line 218
      addition += 2;
    }
#line 216
    p1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (! addition) {
#line 221
    if (allow_passthrough) {
#line 221
      tmp___0 = (char *)s;
    } else {
      {
#line 221
      tmp = checking_strdup(s);
#line 221
      tmp___0 = tmp;
      }
    }
#line 221
    return (tmp___0);
  }
  {
#line 223
  newlen = (int )((p1 - s) + (long )addition);
#line 224
  tmp___1 = checking_malloc((size_t )(newlen + 1));
#line 224
  newstr = (char *)tmp___1;
#line 226
  p1 = s;
#line 227
  p2 = newstr;
  }
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! *p1) {
#line 228
      goto while_break___0;
    }
#line 231
    if ((int const   )urlchr_table[(unsigned char )*p1] & (int const   )mask) {
#line 233
      tmp___2 = p1;
#line 233
      p1 ++;
#line 233
      c = (unsigned char )*tmp___2;
#line 234
      tmp___3 = p2;
#line 234
      p2 ++;
#line 234
      *tmp___3 = (char )'%';
#line 235
      tmp___4 = p2;
#line 235
      p2 ++;
#line 235
      *tmp___4 = (char )((int const   )*("0123456789ABCDEF" + ((int )c >> 4)));
#line 236
      tmp___5 = p2;
#line 236
      p2 ++;
#line 236
      *tmp___5 = (char )((int const   )*("0123456789ABCDEF" + ((int )c & 15)));
    } else {
#line 239
      tmp___6 = p2;
#line 239
      p2 ++;
#line 239
      tmp___7 = p1;
#line 239
      p1 ++;
#line 239
      *tmp___6 = (char )*tmp___7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 241
  if (! (p2 - newstr == (long )newlen)) {
    {
#line 241
    __assert_fail("p2 - newstr == newlen", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  241U, "url_escape_1");
    }
  }
#line 242
  *p2 = (char )'\000';
#line 244
  return (newstr);
}
}
#line 250 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *url_escape(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 253
  tmp = url_escape_1(s, (unsigned char)2, (_Bool)0);
  }
#line 253
  return (tmp);
}
}
#line 259 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char *url_escape_allow_passthrough(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 262
  tmp = url_escape_1(s, (unsigned char)2, (_Bool)1);
  }
#line 262
  return (tmp);
}
}
#line 271 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
__inline static _Bool char_needs_escaping(char const   *p___0 ) 
{ 


  {
#line 274
  if ((int const   )*p___0 == 37) {
#line 276
    if ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 256) {
#line 276
      if ((int const   )_sch_istable[(int const   )*(p___0 + 2) & 255] & 256) {
#line 277
        return ((_Bool)0);
      } else {
#line 280
        return ((_Bool)1);
      }
    } else {
#line 280
      return ((_Bool)1);
    }
  } else
#line 282
  if ((int const   )urlchr_table[(unsigned char )*p___0] & 2) {
#line 282
    if (! ((int const   )urlchr_table[(unsigned char )*p___0] & 1)) {
#line 283
      return ((_Bool)1);
    } else {
#line 285
      return ((_Bool)0);
    }
  } else {
#line 285
    return ((_Bool)0);
  }
}
}
#line 366 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char *reencode_escapes(char const   *s ) 
{ 
  char const   *p1 ;
  char *newstr ;
  char *p2 ;
  int oldlen ;
  int newlen ;
  int encode_count ;
  _Bool tmp ;
  void *tmp___0 ;
  unsigned char c ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 373
  encode_count = 0;
#line 377
  p1 = s;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! *p1) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp = char_needs_escaping(p1);
    }
#line 378
    if (tmp) {
#line 379
      encode_count ++;
    }
#line 377
    p1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if (! encode_count) {
#line 383
    return ((char *)s);
  }
  {
#line 385
  oldlen = (int )(p1 - s);
#line 387
  newlen = oldlen + 2 * encode_count;
#line 388
  tmp___0 = checking_malloc((size_t )(newlen + 1));
#line 388
  newstr = (char *)tmp___0;
#line 392
  p1 = s;
#line 393
  p2 = newstr;
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (! *p1) {
#line 395
      goto while_break___0;
    }
    {
#line 396
    tmp___7 = char_needs_escaping(p1);
    }
#line 396
    if (tmp___7) {
#line 398
      tmp___1 = p1;
#line 398
      p1 ++;
#line 398
      c = (unsigned char )*tmp___1;
#line 399
      tmp___2 = p2;
#line 399
      p2 ++;
#line 399
      *tmp___2 = (char )'%';
#line 400
      tmp___3 = p2;
#line 400
      p2 ++;
#line 400
      *tmp___3 = (char )((int const   )*("0123456789ABCDEF" + ((int )c >> 4)));
#line 401
      tmp___4 = p2;
#line 401
      p2 ++;
#line 401
      *tmp___4 = (char )((int const   )*("0123456789ABCDEF" + ((int )c & 15)));
    } else {
#line 404
      tmp___5 = p2;
#line 404
      p2 ++;
#line 404
      tmp___6 = p1;
#line 404
      p1 ++;
#line 404
      *tmp___5 = (char )*tmp___6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  *p2 = (char )'\000';
#line 407
  if (! (p2 - newstr == (long )newlen)) {
    {
#line 407
    __assert_fail("p2 - newstr == newlen", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  407U, "reencode_escapes");
    }
  }
#line 408
  return (newstr);
}
}
#line 414 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
enum url_scheme url_scheme(char const   *url ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 419
  i = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! supported_schemes[i].leading_string) {
#line 419
      goto while_break;
    }
    {
#line 420
    tmp = strlen(supported_schemes[i].leading_string);
#line 420
    tmp___0 = strncasecmp(url, supported_schemes[i].leading_string, tmp);
    }
#line 420
    if (0 == tmp___0) {
#line 423
      if (! (supported_schemes[i].flags & 1)) {
#line 424
        return ((enum url_scheme )i);
      } else {
#line 426
        return ((enum url_scheme )3);
      }
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return ((enum url_scheme )3);
}
}
#line 438 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
_Bool url_has_scheme(char const   *url ) 
{ 
  char const   *p___0 ;

  {
#line 441
  p___0 = url;
#line 444
  if (! *p___0) {
#line 445
    return ((_Bool)0);
  } else
#line 444
  if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 140)) {
#line 444
    if (! ((int const   )*p___0 == 45)) {
#line 444
      if (! ((int const   )*p___0 == 43)) {
#line 445
        return ((_Bool)0);
      }
    }
  }
#line 446
  p___0 ++;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (*p___0) {
#line 448
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 140)) {
#line 448
        if (! ((int const   )*p___0 == 45)) {
#line 448
          if (! ((int const   )*p___0 == 43)) {
#line 448
            goto while_break;
          }
        }
      }
    } else {
#line 448
      goto while_break;
    }
#line 449
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return ((_Bool )((int const   )*p___0 == 58));
}
}
#line 454 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
int scheme_default_port(enum url_scheme scheme ) 
{ 


  {
#line 457
  return (supported_schemes[scheme].default_port);
}
}
#line 460 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
void scheme_disable(enum url_scheme scheme ) 
{ 


  {
#line 463
  supported_schemes[scheme].flags |= 1;
#line 464
  return;
}
}
#line 472 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char const   *url_skip_credentials(char const   *url ) 
{ 
  char const   *p___0 ;
  char *tmp ;

  {
  {
#line 477
  tmp = strpbrk(url, "@/?#;");
#line 477
  p___0 = (char const   *)tmp;
  }
#line 478
  if (! p___0) {
#line 479
    return (url);
  } else
#line 478
  if ((int const   )*p___0 != 64) {
#line 479
    return (url);
  }
#line 480
  return (p___0 + 1);
}
}
#line 486 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static _Bool parse_credentials(char const   *beg , char const   *end , char **user ,
                               char **passwd ) 
{ 
  char *colon ;
  char const   *userend ;
  void *tmp ;

  {
#line 492
  if ((unsigned long )beg == (unsigned long )end) {
#line 493
    return ((_Bool)0);
  }
  {
#line 495
  tmp = memchr((void const   *)beg, ':', (size_t )(end - beg));
#line 495
  colon = (char *)tmp;
  }
#line 496
  if ((unsigned long )colon == (unsigned long )beg) {
#line 497
    return ((_Bool)0);
  }
#line 499
  if (colon) {
    {
#line 501
    *passwd = strdupdelim((char const   *)(colon + 1), end);
#line 502
    userend = (char const   *)colon;
#line 503
    url_unescape(*passwd);
    }
  } else {
#line 507
    *passwd = (char *)((void *)0);
#line 508
    userend = end;
  }
  {
#line 510
  *user = strdupdelim(beg, userend);
#line 511
  url_unescape(*user);
  }
#line 512
  return ((_Bool)1);
}
}
#line 529 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *rewrite_shorthand_url(char const   *url ) 
{ 
  char const   *p___0 ;
  char *ret ;
  enum url_scheme tmp ;
  char *tmp___0 ;
  int digits ;
  size_t tmp___1 ;

  {
  {
#line 535
  tmp = url_scheme(url);
  }
#line 535
  if ((unsigned int )tmp != 3U) {
#line 536
    return ((char *)((void *)0));
  }
  {
#line 540
  tmp___0 = strpbrk(url, ":/");
#line 540
  p___0 = (char const   *)tmp___0;
  }
#line 541
  if ((unsigned long )p___0 == (unsigned long )url) {
#line 542
    return ((char *)((void *)0));
  }
#line 547
  if (p___0) {
#line 547
    if ((int const   )*(p___0 + 0) == 58) {
#line 547
      if ((int const   )*(p___0 + 1) == 47) {
#line 547
        if ((int const   )*(p___0 + 2) == 47) {
#line 548
          return ((char *)((void *)0));
        }
      }
    }
  }
#line 550
  if (p___0) {
#line 550
    if ((int const   )*p___0 == 58) {
      {
#line 554
      tmp___1 = strspn(p___0 + 1, "0123456789");
#line 554
      digits = (int )tmp___1;
      }
#line 555
      if (digits) {
#line 555
        if ((int const   )*(p___0 + (1 + digits)) == 47) {
#line 556
          goto http;
        } else
#line 555
        if ((int const   )*(p___0 + (1 + digits)) == 0) {
#line 556
          goto http;
        }
      }
      {
#line 559
      ret = aprintf("ftp://%s", url);
#line 560
      *(ret + (6L + (p___0 - url))) = (char )'/';
      }
    } else {
#line 550
      goto http;
    }
  } else {
    http: 
    {
#line 566
    ret = aprintf("http://%s", url);
    }
  }
#line 568
  return (ret);
}
}
#line 571
static void split_path(char const   *path , char **dir , char **file ) ;
#line 577 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
__inline static char *strpbrk_or_eos(char const   *s , char const   *accept___0 ) 
{ 
  char *p___0 ;
  char *tmp ;

  {
  {
#line 580
  tmp = strpbrk(s, accept___0);
#line 580
  p___0 = tmp;
  }
#line 581
  if (! p___0) {
    {
#line 582
    p___0 = strchr(s, '\000');
    }
  }
#line 583
  return (p___0);
}
}
#line 589 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static _Bool lowercase_str(char *str ) 
{ 
  _Bool changed ;

  {
#line 592
  changed = (_Bool)0;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! *str) {
#line 593
      goto while_break;
    }
#line 594
    if ((int const   )_sch_istable[(int )*str & 255] & 128) {
#line 596
      changed = (_Bool)1;
#line 597
      *str = (char )_sch_tolower[(int )*str & 255];
    }
#line 593
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  return (changed);
}
}
#line 605
static char const   *init_seps(enum url_scheme scheme ) ;
#line 605 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char seps[8]  = {      (char )':',      (char )'/',      (char )'\000'};
#line 602 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char const   *init_seps(enum url_scheme scheme ) 
{ 
  char *p___0 ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 606
  p___0 = seps + 2;
#line 607
  flags = supported_schemes[scheme].flags;
#line 609
  if (flags & 2) {
#line 610
    tmp = p___0;
#line 610
    p___0 ++;
#line 610
    *tmp = (char )';';
  }
#line 611
  if (flags & 4) {
#line 612
    tmp___0 = p___0;
#line 612
    p___0 ++;
#line 612
    *tmp___0 = (char )'?';
  }
#line 613
  if (flags & 8) {
#line 614
    tmp___1 = p___0;
#line 614
    p___0 ++;
#line 614
    *tmp___1 = (char )'#';
  }
#line 615
  tmp___2 = p___0;
#line 615
  p___0 ++;
#line 615
  *tmp___2 = (char )'\000';
#line 616
  return ((char const   *)(seps));
}
}
#line 619 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char const   *parse_errors[8]  = 
#line 619
  {      "No error",      "Unsupported scheme",      "Invalid host name",      "Bad port number", 
        "Invalid user name",      "Unterminated IPv6 numeric address",      "IPv6 addresses not supported",      "Invalid IPv6 numeric address"};
#line 643 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
struct url *url_parse(char const   *url , int *error ) 
{ 
  struct url *u ;
  char const   *p___0 ;
  _Bool path_modified ;
  _Bool host_modified ;
  enum url_scheme scheme ;
  char const   *seps___0 ;
  char const   *uname_b ;
  char const   *uname_e ;
  char const   *host_b ;
  char const   *host_e ;
  char const   *path_b ;
  char const   *path_e ;
  char const   *params_b ;
  char const   *params_e ;
  char const   *query_b ;
  char const   *query_e ;
  char const   *fragment_b ;
  char const   *fragment_e ;
  int port ;
  char *user ;
  char *passwd ;
  char *url_encoded ;
  int error_code ;
  size_t tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *port_b ;
  char const   *port_e ;
  char const   *pp ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 661
  user = (char *)((void *)0);
#line 661
  passwd = (char *)((void *)0);
#line 663
  url_encoded = (char *)((void *)0);
#line 667
  scheme = url_scheme(url);
  }
#line 668
  if ((unsigned int )scheme == 3U) {
#line 670
    error_code = 1;
#line 671
    goto error;
  }
  {
#line 674
  url_encoded = reencode_escapes(url);
#line 675
  p___0 = (char const   *)url_encoded;
#line 677
  tmp = strlen(supported_schemes[scheme].leading_string);
#line 677
  p___0 += tmp;
#line 678
  uname_b = p___0;
#line 679
  p___0 = url_skip_credentials(p___0);
#line 680
  uname_e = p___0;
#line 690
  path_e = (char const   *)((void *)0);
#line 690
  path_b = path_e;
#line 691
  params_e = (char const   *)((void *)0);
#line 691
  params_b = params_e;
#line 692
  query_e = (char const   *)((void *)0);
#line 692
  query_b = query_e;
#line 693
  fragment_e = (char const   *)((void *)0);
#line 693
  fragment_b = fragment_e;
#line 698
  seps___0 = init_seps(scheme);
#line 700
  host_b = p___0;
  }
#line 702
  if ((int const   )*p___0 == 91) {
    {
#line 709
    host_b = p___0 + 1;
#line 710
    tmp___0 = strchr(host_b, ']');
#line 710
    host_e = (char const   *)tmp___0;
    }
#line 712
    if (! host_e) {
#line 714
      error_code = 5;
#line 715
      goto error;
    }
    {
#line 720
    tmp___1 = is_valid_ipv6_address(host_b, host_e);
    }
#line 720
    if (! tmp___1) {
#line 722
      error_code = 7;
#line 723
      goto error;
    }
    {
#line 727
    p___0 = host_e + 1;
#line 737
    tmp___2 = strchr(seps___0, (int )*p___0);
    }
#line 737
    if (! tmp___2) {
#line 740
      error_code = 2;
#line 741
      goto error;
    }
  } else {
    {
#line 746
    tmp___3 = strpbrk_or_eos(p___0, seps___0);
#line 746
    p___0 = (char const   *)tmp___3;
#line 747
    host_e = p___0;
    }
  }
#line 749
  seps___0 ++;
#line 751
  if ((unsigned long )host_b == (unsigned long )host_e) {
#line 753
    error_code = 2;
#line 754
    goto error;
  }
  {
#line 757
  port = scheme_default_port(scheme);
  }
#line 758
  if ((int const   )*p___0 == 58) {
    {
#line 764
    p___0 ++;
#line 765
    port_b = p___0;
#line 766
    tmp___4 = strpbrk_or_eos(p___0, seps___0);
#line 766
    p___0 = (char const   *)tmp___4;
#line 767
    port_e = p___0;
    }
#line 770
    if ((unsigned long )port_b != (unsigned long )port_e) {
#line 771
      port = 0;
#line 771
      pp = port_b;
      {
#line 771
      while (1) {
        while_continue: /* CIL Label */ ;
#line 771
        if (! ((unsigned long )pp < (unsigned long )port_e)) {
#line 771
          goto while_break;
        }
#line 773
        if (! ((int const   )_sch_istable[(int const   )*pp & 255] & 4)) {
#line 777
          error_code = 3;
#line 778
          goto error;
        }
#line 780
        port = 10 * port + (int )((int const   )*pp - 48);
#line 783
        if (port > 65535) {
#line 785
          error_code = 3;
#line 786
          goto error;
        }
#line 771
        pp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 792
  seps___0 ++;
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 802
    if ((int const   )*p___0 == 47) {
      {
#line 802
      p___0 ++;
#line 802
      path_b = p___0;
#line 802
      tmp___5 = strpbrk_or_eos(p___0, seps___0);
#line 802
      p___0 = (char const   *)tmp___5;
#line 802
      path_e = p___0;
      }
    }
#line 802
    seps___0 ++;
#line 802
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 803
  if (supported_schemes[scheme].flags & 2) {
    {
#line 804
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 804
      if ((int const   )*p___0 == 59) {
        {
#line 804
        p___0 ++;
#line 804
        params_b = p___0;
#line 804
        tmp___6 = strpbrk_or_eos(p___0, seps___0);
#line 804
        p___0 = (char const   *)tmp___6;
#line 804
        params_e = p___0;
        }
      }
#line 804
      seps___0 ++;
#line 804
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 805
  if (supported_schemes[scheme].flags & 4) {
    {
#line 806
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 806
      if ((int const   )*p___0 == 63) {
        {
#line 806
        p___0 ++;
#line 806
        query_b = p___0;
#line 806
        tmp___7 = strpbrk_or_eos(p___0, seps___0);
#line 806
        p___0 = (char const   *)tmp___7;
#line 806
        query_e = p___0;
        }
      }
#line 806
      seps___0 ++;
#line 806
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 807
  if (supported_schemes[scheme].flags & 8) {
    {
#line 808
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 808
      if ((int const   )*p___0 == 35) {
        {
#line 808
        p___0 ++;
#line 808
        fragment_b = p___0;
#line 808
        tmp___8 = strpbrk_or_eos(p___0, seps___0);
#line 808
        p___0 = (char const   *)tmp___8;
#line 808
        fragment_e = p___0;
        }
      }
#line 808
      seps___0 ++;
#line 808
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 811
  if (! ((int const   )*p___0 == 0)) {
    {
#line 811
    __assert_fail("*p == 0", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  811U, "url_parse");
    }
  }
#line 813
  if ((unsigned long )uname_b != (unsigned long )uname_e) {
    {
#line 818
    tmp___10 = parse_credentials(uname_b, uname_e - 1, & user, & passwd);
    }
#line 818
    if (! tmp___10) {
#line 820
      error_code = 4;
#line 821
      goto error;
    }
  }
  {
#line 825
  tmp___11 = checking_malloc0(sizeof(struct url ));
#line 825
  u = (struct url *)tmp___11;
#line 826
  u->scheme = scheme;
#line 827
  u->host = strdupdelim(host_b, host_e);
#line 828
  u->port = port;
#line 829
  u->user = user;
#line 830
  u->passwd = passwd;
#line 832
  u->path = strdupdelim(path_b, path_e);
#line 833
  path_modified = path_simplify(scheme, u->path);
#line 834
  split_path((char const   *)u->path, & u->dir, & u->file);
#line 836
  host_modified = lowercase_str(u->host);
#line 842
  tmp___12 = strchr((char const   *)u->host, '%');
  }
#line 842
  if (tmp___12) {
    {
#line 844
    url_unescape(u->host);
#line 845
    host_modified = (_Bool)1;
    }
  }
#line 848
  if (params_b) {
    {
#line 849
    u->params = strdupdelim(params_b, params_e);
    }
  }
#line 850
  if (query_b) {
    {
#line 851
    u->query = strdupdelim(query_b, query_e);
    }
  }
#line 852
  if (fragment_b) {
    {
#line 853
    u->fragment = strdupdelim(fragment_b, fragment_e);
    }
  }
#line 855
  if (path_modified) {
#line 855
    goto _L;
  } else
#line 855
  if (u->fragment) {
#line 855
    goto _L;
  } else
#line 855
  if (host_modified) {
#line 855
    goto _L;
  } else
#line 855
  if ((unsigned long )path_b == (unsigned long )path_e) {
    _L: /* CIL Label */ 
    {
#line 860
    u->url = url_string((struct url  const  *)u, (enum url_auth_mode )0);
    }
#line 862
    if ((unsigned long )url_encoded != (unsigned long )url) {
      {
#line 863
      checking_free((void *)url_encoded);
      }
    }
  } else
#line 867
  if ((unsigned long )url_encoded == (unsigned long )url) {
    {
#line 868
    u->url = checking_strdup(url);
    }
  } else {
#line 870
    u->url = url_encoded;
  }
#line 873
  return (u);
  error: 
#line 877
  if (url_encoded) {
#line 877
    if ((unsigned long )url_encoded != (unsigned long )url) {
      {
#line 878
      checking_free((void *)url_encoded);
      }
    }
  }
#line 882
  if (error) {
#line 883
    *error = error_code;
  }
#line 884
  return ((struct url *)((void *)0));
}
}
#line 890 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char const   *url_error(int error_code ) 
{ 
  char *tmp___0 ;

  {
#line 893
  if (error_code >= 0) {
#line 893
    if (! ((unsigned long )error_code < sizeof(parse_errors) / sizeof(parse_errors[0]))) {
      {
#line 893
      __assert_fail("error_code >= 0 && error_code < countof (parse_errors)", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                    893U, "url_error");
      }
    }
  } else {
    {
#line 893
    __assert_fail("error_code >= 0 && error_code < countof (parse_errors)", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  893U, "url_error");
    }
  }
  {
#line 894
  tmp___0 = gettext(parse_errors[error_code]);
  }
#line 894
  return ((char const   *)tmp___0);
}
}
#line 912 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void split_path(char const   *path , char **dir , char **file ) 
{ 
  char *last_slash ;
  char *tmp ;

  {
  {
#line 915
  tmp = strrchr(path, '/');
#line 915
  last_slash = tmp;
  }
#line 916
  if (! last_slash) {
    {
#line 918
    *dir = checking_strdup("");
#line 919
    *file = checking_strdup(path);
    }
  } else {
    {
#line 923
    *dir = strdupdelim(path, (char const   *)last_slash);
#line 924
    *file = checking_strdup((char const   *)(last_slash + 1));
    }
  }
  {
#line 926
  url_unescape(*dir);
#line 927
  url_unescape(*file);
  }
#line 928
  return;
}
}
#line 939 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static int full_path_length(struct url  const  *url ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 942
  len = 0;
#line 946
  if (url->path) {
    {
#line 946
    tmp = strlen((char const   *)url->path);
#line 946
    len = (int )((size_t )len + (1UL + tmp));
    }
  }
#line 947
  if (url->params) {
    {
#line 947
    tmp___0 = strlen((char const   *)url->params);
#line 947
    len = (int )((size_t )len + (1UL + tmp___0));
    }
  }
#line 948
  if (url->query) {
    {
#line 948
    tmp___1 = strlen((char const   *)url->query);
#line 948
    len = (int )((size_t )len + (1UL + tmp___1));
    }
  }
#line 952
  return (len);
}
}
#line 957 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void full_path_write(struct url  const  *url , char *where ) 
{ 
  char *f_el ;
  int l ;
  size_t tmp ;
  char *tmp___0 ;
  char *f_el___0 ;
  int l___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *f_el___1 ;
  int l___1 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    f_el = (char *)url->path;
#line 970
    if (f_el) {
      {
#line 970
      tmp = strlen((char const   *)f_el);
#line 970
      l = (int )tmp;
#line 970
      tmp___0 = where;
#line 970
      where ++;
#line 970
      *tmp___0 = (char )'/';
#line 970
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el,
             (size_t )l);
#line 970
      where += l;
      }
    }
#line 970
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 971
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 971
    f_el___0 = (char *)url->params;
#line 971
    if (f_el___0) {
      {
#line 971
      tmp___1 = strlen((char const   *)f_el___0);
#line 971
      l___0 = (int )tmp___1;
#line 971
      tmp___2 = where;
#line 971
      where ++;
#line 971
      *tmp___2 = (char )';';
#line 971
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el___0,
             (size_t )l___0);
#line 971
      where += l___0;
      }
    }
#line 971
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 972
    f_el___1 = (char *)url->query;
#line 972
    if (f_el___1) {
      {
#line 972
      tmp___3 = strlen((char const   *)f_el___1);
#line 972
      l___1 = (int )tmp___3;
#line 972
      tmp___4 = where;
#line 972
      where ++;
#line 972
      *tmp___4 = (char )'?';
#line 972
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el___1,
             (size_t )l___1);
#line 972
      where += l___1;
      }
    }
#line 972
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 975
  return;
}
}
#line 981 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *url_full_path(struct url  const  *url ) 
{ 
  int length ;
  int tmp ;
  char *full_path ;
  void *tmp___0 ;

  {
  {
#line 984
  tmp = full_path_length(url);
#line 984
  length = tmp;
#line 985
  tmp___0 = checking_malloc((size_t )(length + 1));
#line 985
  full_path = (char *)tmp___0;
#line 987
  full_path_write(url, full_path);
#line 988
  *(full_path + length) = (char )'\000';
  }
#line 990
  return (full_path);
}
}
#line 997 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void unescape_single_char(char *str , char chr ) 
{ 
  char c1 ;
  char c2 ;
  char *h ;
  char *t ;

  {
#line 1000
  c1 = (char )((int const   )*("0123456789ABCDEF" + ((int )chr >> 4)));
#line 1001
  c2 = (char )((int const   )*("0123456789ABCDEF" + ((int )chr & 15)));
#line 1002
  h = str;
#line 1003
  t = str;
  {
#line 1004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1004
    if (! *h) {
#line 1004
      goto while_break;
    }
#line 1006
    if ((int )*(h + 0) == 37) {
#line 1006
      if ((int )*(h + 1) == (int )c1) {
#line 1006
        if ((int )*(h + 2) == (int )c2) {
#line 1008
          *t = chr;
#line 1009
          h += 2;
        } else {
#line 1012
          *t = *h;
        }
      } else {
#line 1012
        *t = *h;
      }
    } else {
#line 1012
      *t = *h;
    }
#line 1004
    h ++;
#line 1004
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1014
  *t = (char )'\000';
#line 1015
  return;
}
}
#line 1020 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char *url_escape_dir(char const   *dir ) 
{ 
  char *newdir ;
  char *tmp ;

  {
  {
#line 1023
  tmp = url_escape_1(dir, (unsigned char)3, (_Bool)1);
#line 1023
  newdir = tmp;
  }
#line 1024
  if ((unsigned long )newdir == (unsigned long )dir) {
#line 1025
    return ((char *)dir);
  }
  {
#line 1027
  unescape_single_char(newdir, (char )'/');
  }
#line 1028
  return (newdir);
}
}
#line 1034 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void sync_path(struct url *u ) 
{ 
  char *newpath ;
  char *efile ;
  char *edir ;
  int dirlen ;
  size_t tmp ;
  int filelen ;
  size_t tmp___0 ;
  char *p___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1039
  checking_free((void *)u->path);
#line 1047
  edir = url_escape_dir((char const   *)u->dir);
#line 1048
  efile = url_escape_1((char const   *)u->file, (unsigned char)3, (_Bool)1);
  }
#line 1050
  if (! *edir) {
    {
#line 1051
    newpath = checking_strdup((char const   *)efile);
    }
  } else {
    {
#line 1054
    tmp = strlen((char const   *)edir);
#line 1054
    dirlen = (int )tmp;
#line 1055
    tmp___0 = strlen((char const   *)efile);
#line 1055
    filelen = (int )tmp___0;
#line 1058
    tmp___1 = checking_malloc((size_t )(((dirlen + 1) + filelen) + 1));
#line 1058
    newpath = (char *)tmp___1;
#line 1058
    p___0 = newpath;
#line 1059
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)edir,
           (size_t )dirlen);
#line 1060
    p___0 += dirlen;
#line 1061
    tmp___2 = p___0;
#line 1061
    p___0 ++;
#line 1061
    *tmp___2 = (char )'/';
#line 1062
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)efile,
           (size_t )filelen);
#line 1063
    p___0 += filelen;
#line 1064
    *p___0 = (char )'\000';
    }
  }
#line 1067
  u->path = newpath;
#line 1069
  if ((unsigned long )edir != (unsigned long )u->dir) {
    {
#line 1070
    checking_free((void *)edir);
    }
  }
#line 1071
  if ((unsigned long )efile != (unsigned long )u->file) {
    {
#line 1072
    checking_free((void *)efile);
    }
  }
  {
#line 1075
  checking_free((void *)u->url);
#line 1076
  u->url = url_string((struct url  const  *)u, (enum url_auth_mode )0);
  }
#line 1077
  return;
}
}
#line 1082 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
void url_set_dir(struct url *url , char const   *newdir ) 
{ 


  {
  {
#line 1085
  checking_free((void *)url->dir);
#line 1086
  url->dir = checking_strdup(newdir);
#line 1087
  sync_path(url);
  }
#line 1088
  return;
}
}
#line 1090 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
void url_set_file(struct url *url , char const   *newfile ) 
{ 


  {
  {
#line 1093
  checking_free((void *)url->file);
#line 1094
  url->file = checking_strdup(newfile);
#line 1095
  sync_path(url);
  }
#line 1096
  return;
}
}
#line 1098 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
void url_free(struct url *url ) 
{ 


  {
  {
#line 1101
  checking_free((void *)url->host);
#line 1102
  checking_free((void *)url->path);
#line 1103
  checking_free((void *)url->url);
  }
#line 1105
  if (! (! url->params)) {
    {
#line 1105
    checking_free((void *)url->params);
    }
  }
#line 1106
  if (! (! url->query)) {
    {
#line 1106
    checking_free((void *)url->query);
    }
  }
#line 1107
  if (! (! url->fragment)) {
    {
#line 1107
    checking_free((void *)url->fragment);
    }
  }
#line 1108
  if (! (! url->user)) {
    {
#line 1108
    checking_free((void *)url->user);
    }
  }
#line 1109
  if (! (! url->passwd)) {
    {
#line 1109
    checking_free((void *)url->passwd);
    }
  }
  {
#line 1111
  checking_free((void *)url->dir);
#line 1112
  checking_free((void *)url->file);
#line 1114
  checking_free((void *)url);
  }
#line 1115
  return;
}
}
#line 1119 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
int mkalldirs(char const   *path ) 
{ 
  char const   *p___0 ;
  char *t ;
  struct stat st ;
  int res___0 ;
  size_t tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1127
  tmp = strlen(path);
#line 1127
  p___0 = path + tmp;
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if ((int const   )*p___0 != 47) {
#line 1128
      if (! ((unsigned long )p___0 != (unsigned long )path)) {
#line 1128
        goto while_break;
      }
    } else {
#line 1128
      goto while_break;
    }
#line 1128
    p___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1132
  if ((unsigned long )p___0 == (unsigned long )path) {
#line 1132
    if ((int const   )*p___0 != 47) {
#line 1133
      return (0);
    }
  }
  {
#line 1134
  t = strdupdelim(path, p___0);
#line 1137
  tmp___1 = stat((char const   */* __restrict  */)t, (struct stat */* __restrict  */)(& st));
  }
#line 1137
  if (tmp___1 == 0) {
#line 1139
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 1141
      checking_free((void *)t);
      }
#line 1142
      return (0);
    } else {
      {
#line 1158
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1158
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 1158
        if (tmp___0) {
          {
#line 1158
          debug_logprintf("Removing %s because of directory danger!\n", t);
          }
        }
#line 1158
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1159
      unlink((char const   *)t);
      }
    }
  }
  {
#line 1162
  res___0 = make_directory((char const   *)t);
  }
#line 1163
  if (res___0 != 0) {
    {
#line 1164
    tmp___2 = __errno_location();
#line 1164
    tmp___3 = strerror(*tmp___2);
#line 1164
    logprintf((enum log_options )1, "%s: %s", t, tmp___3);
    }
  }
  {
#line 1165
  checking_free((void *)t);
  }
#line 1166
  return (res___0);
}
}
#line 1203 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void append_string(char const   *str , struct growable *dest ) 
{ 
  int l ;
  size_t tmp ;
  struct growable *G_ ;
  long DR_needed_size ;
  long DR_newsize ;
  void *tmp___0 ;

  {
  {
#line 1206
  tmp = strlen(str);
#line 1206
  l = (int )tmp;
  }
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    G_ = dest;
    {
#line 1207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1207
      DR_needed_size = (long )(G_->tail + l);
#line 1207
      DR_newsize = 0L;
      {
#line 1207
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1207
        if (! ((long )G_->size < DR_needed_size)) {
#line 1207
          goto while_break___1;
        }
#line 1207
        DR_newsize = (long )(G_->size << 1);
#line 1207
        if (DR_newsize < 16L) {
#line 1207
          DR_newsize = 16L;
        }
#line 1207
        G_->size = (int )DR_newsize;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1207
      if (DR_newsize) {
        {
#line 1207
        tmp___0 = checking_realloc((void *)G_->base, (unsigned long )DR_newsize * sizeof(char ));
#line 1207
        G_->base = (char *)tmp___0;
        }
      }
#line 1207
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1207
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1208
  memcpy((void */* __restrict  */)(dest->base + dest->tail), (void const   */* __restrict  */)str,
         (size_t )l);
#line 1209
  dest->tail += l;
  }
#line 1210
  return;
}
}
#line 1215 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void append_char(char ch , struct growable *dest ) 
{ 
  struct growable *G_ ;
  long DR_needed_size ;
  long DR_newsize ;
  void *tmp ;

  {
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    G_ = dest;
    {
#line 1218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1218
      DR_needed_size = (long )(G_->tail + 1);
#line 1218
      DR_newsize = 0L;
      {
#line 1218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1218
        if (! ((long )G_->size < DR_needed_size)) {
#line 1218
          goto while_break___1;
        }
#line 1218
        DR_newsize = (long )(G_->size << 1);
#line 1218
        if (DR_newsize < 16L) {
#line 1218
          DR_newsize = 16L;
        }
#line 1218
        G_->size = (int )DR_newsize;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1218
      if (DR_newsize) {
        {
#line 1218
        tmp = checking_realloc((void *)G_->base, (unsigned long )DR_newsize * sizeof(char ));
#line 1218
        G_->base = (char *)tmp;
        }
      }
#line 1218
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1219
  *(dest->base + dest->tail) = ch;
#line 1220
  (dest->tail) ++;
#line 1221
  return;
}
}
#line 1246 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static unsigned char const   filechr_table[256]  = 
#line 1246
  {      (unsigned char const   )7,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 1299 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void append_uri_pathel(char const   *b , char const   *e , _Bool escaped ,
                              struct growable *dest ) 
{ 
  char const   *p___0 ;
  int quoted ;
  int outlen ;
  int mask ;
  char *unescaped ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp ;
  size_t tmp___0 ;
  struct growable *G_ ;
  long DR_needed_size ;
  long DR_newsize ;
  void *tmp___1 ;
  char *q ;
  char *tmp___2 ;
  unsigned char ch ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *q___0 ;

  {
#line 1307
  if ((unsigned int )opt.restrict_files_os == 0U) {
#line 1308
    mask = 1;
  } else {
#line 1310
    mask = 2;
  }
#line 1311
  if (opt.restrict_files_ctrl) {
#line 1312
    mask |= 4;
  }
#line 1315
  if (escaped) {
    {
#line 1318
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1318
      BTA_beg = b;
#line 1318
      BTA_len = (int )(e - BTA_beg);
#line 1318
      BTA_dest = & unescaped;
#line 1318
      tmp = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 1318
      *BTA_dest = (char *)tmp;
#line 1318
      memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
             (size_t )BTA_len);
#line 1318
      *(*BTA_dest + BTA_len) = (char )'\000';
      }
#line 1318
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1319
    url_unescape(unescaped);
#line 1320
    b = (char const   *)unescaped;
#line 1321
    tmp___0 = strlen((char const   *)unescaped);
#line 1321
    e = (char const   *)(unescaped + tmp___0);
    }
  }
#line 1326
  if (e - b == 2L) {
#line 1326
    if ((int const   )*(b + 0) == 46) {
#line 1326
      if ((int const   )*(b + 1) == 46) {
#line 1328
        b = "%2E%2E";
#line 1329
        e = b + 6;
      }
    }
  }
#line 1334
  quoted = 0;
#line 1335
  p___0 = b;
  {
#line 1335
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1335
    if (! ((unsigned long )p___0 < (unsigned long )e)) {
#line 1335
      goto while_break___0;
    }
#line 1336
    if ((int const   )filechr_table[(unsigned char )*p___0] & (int const   )mask) {
#line 1337
      quoted ++;
    }
#line 1335
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1342
  outlen = (int )((e - b) + (long )(2 * quoted));
  {
#line 1343
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1343
    G_ = dest;
    {
#line 1343
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1343
      DR_needed_size = (long )(G_->tail + outlen);
#line 1343
      DR_newsize = 0L;
      {
#line 1343
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1343
        if (! ((long )G_->size < DR_needed_size)) {
#line 1343
          goto while_break___3;
        }
#line 1343
        DR_newsize = (long )(G_->size << 1);
#line 1343
        if (DR_newsize < 16L) {
#line 1343
          DR_newsize = 16L;
        }
#line 1343
        G_->size = (int )DR_newsize;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1343
      if (DR_newsize) {
        {
#line 1343
        tmp___1 = checking_realloc((void *)G_->base, (unsigned long )DR_newsize * sizeof(char ));
#line 1343
        G_->base = (char *)tmp___1;
        }
      }
#line 1343
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1343
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1345
  if (! quoted) {
    {
#line 1349
    memcpy((void */* __restrict  */)(dest->base + dest->tail), (void const   */* __restrict  */)b,
           (size_t )outlen);
    }
  } else {
#line 1353
    q = dest->base + dest->tail;
#line 1354
    p___0 = b;
    {
#line 1354
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1354
      if (! ((unsigned long )p___0 < (unsigned long )e)) {
#line 1354
        goto while_break___4;
      }
#line 1356
      if (! ((int const   )filechr_table[(unsigned char )*p___0] & (int const   )mask)) {
#line 1357
        tmp___2 = q;
#line 1357
        q ++;
#line 1357
        *tmp___2 = (char )*p___0;
      } else {
#line 1360
        ch = (unsigned char )*p___0;
#line 1361
        tmp___3 = q;
#line 1361
        q ++;
#line 1361
        *tmp___3 = (char )'%';
#line 1362
        tmp___4 = q;
#line 1362
        q ++;
#line 1362
        *tmp___4 = (char )((int const   )*("0123456789ABCDEF" + ((int )ch >> 4)));
#line 1363
        tmp___5 = q;
#line 1363
        q ++;
#line 1363
        *tmp___5 = (char )((int const   )*("0123456789ABCDEF" + ((int )ch & 15)));
      }
#line 1354
      p___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1366
    if (! (q - (dest->base + dest->tail) == (long )outlen)) {
      {
#line 1366
      __assert_fail("q - TAIL (dest) == outlen", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                    1366U, "append_uri_pathel");
      }
    }
  }
#line 1370
  if ((unsigned int )opt.restrict_files_case == 1U) {
#line 1370
    goto _L;
  } else
#line 1370
  if ((unsigned int )opt.restrict_files_case == 2U) {
    _L: /* CIL Label */ 
#line 1374
    q___0 = dest->base + dest->tail;
    {
#line 1374
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1374
      if (! ((unsigned long )q___0 < (unsigned long )((dest->base + dest->tail) + outlen))) {
#line 1374
        goto while_break___5;
      }
#line 1376
      if ((unsigned int )opt.restrict_files_case == 1U) {
#line 1377
        *q___0 = (char )_sch_tolower[(int )*q___0 & 255];
      } else {
#line 1379
        *q___0 = (char )_sch_toupper[(int )*q___0 & 255];
      }
#line 1374
      q___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1383
  dest->tail += outlen;
#line 1384
  return;
}
}
#line 1400 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static void append_dir_structure(struct url  const  *u , struct growable *dest ) 
{ 
  char *pathel ;
  char *next ;
  int cut ;
  int tmp ;

  {
#line 1404
  cut = opt.cut_dirs;
#line 1409
  pathel = (char *)u->path;
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1410
    next = strchr((char const   *)pathel, '/');
    }
#line 1410
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 1410
      goto while_break;
    }
#line 1412
    tmp = cut;
#line 1412
    cut --;
#line 1412
    if (tmp > 0) {
#line 1413
      goto __Cont;
    }
#line 1414
    if ((unsigned long )pathel == (unsigned long )next) {
#line 1416
      goto __Cont;
    }
#line 1418
    if (dest->tail) {
      {
#line 1419
      append_char((char )'/', dest);
      }
    }
    {
#line 1420
    append_uri_pathel((char const   *)pathel, (char const   *)next, (_Bool)1, dest);
    }
    __Cont: /* CIL Label */ 
#line 1410
    pathel = next + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return;
}
}
#line 1427 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *url_file_name(struct url  const  *u ) 
{ 
  struct growable fnres ;
  char const   *u_file ;
  char const   *u_query ;
  char *fname ;
  char *unique ;
  int tmp ;
  char portstr[24] ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
#line 1435
  fnres.base = (char *)((void *)0);
#line 1436
  fnres.size = 0;
#line 1437
  fnres.tail = 0;
#line 1440
  if (opt.dir_prefix) {
    {
#line 1441
    append_string((char const   *)opt.dir_prefix, & fnres);
    }
  }
#line 1446
  if (opt.dirstruct) {
#line 1448
    if (opt.protocol_directories) {
#line 1450
      if (fnres.tail) {
        {
#line 1451
        append_char((char )'/', & fnres);
        }
      }
      {
#line 1452
      append_string(supported_schemes[u->scheme].name, & fnres);
      }
    }
#line 1454
    if (opt.add_hostdir) {
#line 1456
      if (fnres.tail) {
        {
#line 1457
        append_char((char )'/', & fnres);
        }
      }
      {
#line 1458
      tmp = strcmp((char const   *)u->host, "..");
      }
#line 1458
      if (0 != tmp) {
        {
#line 1459
        append_string((char const   *)u->host, & fnres);
        }
      } else {
        {
#line 1464
        append_string("%2E%2E", & fnres);
        }
      }
      {
#line 1465
      tmp___1 = scheme_default_port((enum url_scheme )u->scheme);
      }
#line 1465
      if (u->port != (int const   )tmp___1) {
        {
#line 1468
        number_to_string(portstr, (wgint )u->port);
        }
#line 1469
        if ((unsigned int )opt.restrict_files_os != 1U) {
#line 1469
          tmp___0 = ':';
        } else {
#line 1469
          tmp___0 = '+';
        }
        {
#line 1469
        append_char((char )tmp___0, & fnres);
#line 1470
        append_string((char const   *)(portstr), & fnres);
        }
      }
    }
    {
#line 1474
    append_dir_structure(u, & fnres);
    }
  }
#line 1478
  if (fnres.tail) {
    {
#line 1479
    append_char((char )'/', & fnres);
    }
  }
#line 1480
  if (*(u->file)) {
#line 1480
    u_file = (char const   *)u->file;
  } else {
#line 1480
    u_file = "index.html";
  }
  {
#line 1481
  tmp___2 = strlen(u_file);
#line 1481
  append_uri_pathel(u_file, u_file + tmp___2, (_Bool)0, & fnres);
  }
#line 1484
  if (u->query) {
#line 1484
    if (*(u->query)) {
#line 1484
      u_query = (char const   *)u->query;
    } else {
#line 1484
      u_query = (char const   *)((void *)0);
    }
  } else {
#line 1484
    u_query = (char const   *)((void *)0);
  }
#line 1485
  if (u_query) {
#line 1487
    if ((unsigned int )opt.restrict_files_os != 1U) {
#line 1487
      tmp___3 = '?';
    } else {
#line 1487
      tmp___3 = '@';
    }
    {
#line 1487
    append_char((char )tmp___3, & fnres);
#line 1488
    tmp___4 = strlen(u_query);
#line 1488
    append_uri_pathel(u_query, u_query + tmp___4, (_Bool)1, & fnres);
    }
  }
  {
#line 1492
  append_char((char )'\000', & fnres);
#line 1494
  fname = fnres.base;
  }
#line 1505
  if (opt.noclobber) {
#line 1505
    goto _L;
  } else
#line 1505
  if (opt.always_rest) {
#line 1505
    goto _L;
  } else
#line 1505
  if (opt.timestamping) {
#line 1505
    goto _L;
  } else
#line 1505
  if (opt.dirstruct) {
    _L: /* CIL Label */ 
    {
#line 1505
    tmp___5 = file_exists_p((char const   *)fname);
    }
#line 1505
    if (tmp___5) {
      {
#line 1505
      tmp___6 = file_non_directory_p((char const   *)fname);
      }
#line 1505
      if (tmp___6) {
#line 1507
        return (fname);
      }
    } else {
#line 1507
      return (fname);
    }
  }
  {
#line 1509
  unique = unique_name((char const   *)fname, (_Bool)1);
  }
#line 1510
  if ((unsigned long )unique != (unsigned long )fname) {
    {
#line 1511
    checking_free((void *)fname);
    }
  }
#line 1512
  return (unique);
}
}
#line 1529 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static _Bool path_simplify(enum url_scheme scheme , char *path ) 
{ 
  char *h ;
  char *t ;
  char *beg ;
  char *end ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1532
  h = path;
#line 1533
  t = path;
#line 1534
  beg = path;
#line 1535
  tmp = strchr((char const   *)path, '\000');
#line 1535
  end = tmp;
  }
  {
#line 1537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1537
    if (! ((unsigned long )h < (unsigned long )end)) {
#line 1537
      goto while_break;
    }
#line 1541
    if ((int )*(h + 0) == 46) {
#line 1541
      if ((int )*(h + 1) == 47) {
#line 1544
        h += 2;
      } else
#line 1541
      if ((int )*(h + 1) == 0) {
#line 1544
        h += 2;
      } else {
#line 1541
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1546
    if ((int )*(h + 0) == 46) {
#line 1546
      if ((int )*(h + 1) == 46) {
#line 1546
        if ((int )*(h + 2) == 47) {
#line 1546
          goto _L___0;
        } else
#line 1546
        if ((int )*(h + 2) == 0) {
          _L___0: /* CIL Label */ 
#line 1550
          if ((unsigned long )t > (unsigned long )beg) {
#line 1554
            t --;
            {
#line 1554
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1554
              if ((unsigned long )t > (unsigned long )beg) {
#line 1554
                if (! ((int )*(t + -1) != 47)) {
#line 1554
                  goto while_break___0;
                }
              } else {
#line 1554
                goto while_break___0;
              }
#line 1554
              t --;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 1557
          if ((unsigned int )scheme == 2U) {
#line 1565
            beg = t + 3;
#line 1566
            goto regular;
          }
#line 1568
          h += 3;
        } else {
#line 1546
          goto regular;
        }
      } else {
#line 1546
        goto regular;
      }
    } else
    regular: 
#line 1576
    if ((unsigned long )t == (unsigned long )h) {
      {
#line 1579
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1579
        if ((unsigned long )h < (unsigned long )end) {
#line 1579
          if (! ((int )*h != 47)) {
#line 1579
            goto while_break___1;
          }
        } else {
#line 1579
          goto while_break___1;
        }
#line 1580
        t ++;
#line 1580
        h ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1581
      if ((unsigned long )h < (unsigned long )end) {
#line 1582
        t ++;
#line 1582
        h ++;
      }
    } else {
      {
#line 1587
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1587
        if ((unsigned long )h < (unsigned long )end) {
#line 1587
          if (! ((int )*h != 47)) {
#line 1587
            goto while_break___2;
          }
        } else {
#line 1587
          goto while_break___2;
        }
#line 1588
        tmp___0 = t;
#line 1588
        t ++;
#line 1588
        tmp___1 = h;
#line 1588
        h ++;
#line 1588
        *tmp___0 = *tmp___1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1589
      if ((unsigned long )h < (unsigned long )end) {
#line 1590
        tmp___2 = t;
#line 1590
        t ++;
#line 1590
        tmp___3 = h;
#line 1590
        h ++;
#line 1590
        *tmp___2 = *tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  if ((unsigned long )t != (unsigned long )h) {
#line 1596
    *t = (char )'\000';
  }
#line 1598
  return ((_Bool )((unsigned long )t != (unsigned long )h));
}
}
#line 1605 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static char const   *path_end(char const   *url ) 
{ 
  enum url_scheme scheme ;
  enum url_scheme tmp ;
  char const   *seps___0 ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1608
  tmp = url_scheme(url);
#line 1608
  scheme = tmp;
  }
#line 1610
  if ((unsigned int )scheme == 3U) {
#line 1611
    scheme = (enum url_scheme )0;
  }
  {
#line 1613
  tmp___0 = init_seps(scheme);
#line 1613
  seps___0 = tmp___0 + 2;
#line 1614
  tmp___1 = strpbrk_or_eos(url, seps___0);
  }
#line 1614
  return ((char const   *)tmp___1);
}
}
#line 1633 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *uri_merge(char const   *base , char const   *link___0 ) 
{ 
  int linklength ;
  char const   *end ;
  char *merge ;
  char *tmp ;
  _Bool tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int baselength ;
  void *tmp___3 ;
  int baselength___0 ;
  char const   *end1 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int span ;
  char const   *slash ;
  char const   *start_insert ;
  void *tmp___7 ;
  void *tmp___8 ;
  int span___0 ;
  char const   *slash___0 ;
  char const   *start_insert___0 ;
  char const   *pos ;
  _Bool seen_slash_slash ;
  void *tmp___9 ;
  void *tmp___10 ;
  _Bool need_explicit_slash ;
  int span___1 ;
  char const   *start_insert___1 ;
  char const   *last_slash ;
  void *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 1640
  tmp___0 = url_has_scheme(link___0);
  }
#line 1640
  if (tmp___0) {
    {
#line 1641
    tmp = checking_strdup(link___0);
    }
#line 1641
    return (tmp);
  }
  {
#line 1644
  end = path_end(base);
#line 1645
  tmp___1 = strlen(link___0);
#line 1645
  linklength = (int )tmp___1;
  }
#line 1647
  if (! *link___0) {
    {
#line 1650
    tmp___2 = checking_strdup(base);
    }
#line 1650
    return (tmp___2);
  } else
#line 1652
  if ((int const   )*link___0 == 63) {
    {
#line 1660
    baselength = (int )(end - base);
#line 1661
    tmp___3 = checking_malloc((size_t )((baselength + linklength) + 1));
#line 1661
    merge = (char *)tmp___3;
#line 1662
    memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
           (size_t )baselength);
#line 1663
    memcpy((void */* __restrict  */)(merge + baselength), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1664
    *(merge + (baselength + linklength)) = (char )'\000';
    }
  } else
#line 1666
  if ((int const   )*link___0 == 35) {
    {
#line 1673
    tmp___4 = strchr(base, '#');
#line 1673
    end1 = (char const   *)tmp___4;
    }
#line 1674
    if (! end1) {
      {
#line 1675
      tmp___5 = strlen(base);
#line 1675
      end1 = base + tmp___5;
      }
    }
    {
#line 1676
    baselength___0 = (int )(end1 - base);
#line 1677
    tmp___6 = checking_malloc((size_t )((baselength___0 + linklength) + 1));
#line 1677
    merge = (char *)tmp___6;
#line 1678
    memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
           (size_t )baselength___0);
#line 1679
    memcpy((void */* __restrict  */)(merge + baselength___0), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1680
    *(merge + (baselength___0 + linklength)) = (char )'\000';
    }
  } else
#line 1682
  if ((int const   )*link___0 == 47) {
#line 1682
    if ((int const   )*(link___0 + 1) == 47) {
      {
#line 1697
      tmp___7 = memchr((void const   *)base, '/', (size_t )(end - base));
#line 1697
      slash = (char const   *)tmp___7;
      }
#line 1701
      if (slash) {
#line 1701
        if ((int const   )*(slash + 1) == 47) {
#line 1702
          start_insert = slash;
        } else {
#line 1704
          start_insert = base;
        }
      } else {
#line 1704
        start_insert = base;
      }
      {
#line 1706
      span = (int )(start_insert - base);
#line 1707
      tmp___8 = checking_malloc((size_t )((span + linklength) + 1));
#line 1707
      merge = (char *)tmp___8;
      }
#line 1708
      if (span) {
        {
#line 1709
        memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
               (size_t )span);
        }
      }
      {
#line 1710
      memcpy((void */* __restrict  */)(merge + span), (void const   */* __restrict  */)link___0,
             (size_t )linklength);
#line 1711
      *(merge + (span + linklength)) = (char )'\000';
      }
    } else {
#line 1682
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1713
  if ((int const   )*link___0 == 47) {
#line 1723
    start_insert___0 = (char const   *)((void *)0);
#line 1724
    pos = base;
#line 1725
    seen_slash_slash = (_Bool)0;
    again: 
    {
#line 1729
    tmp___9 = memchr((void const   *)pos, '/', (size_t )(end - pos));
#line 1729
    slash___0 = (char const   *)tmp___9;
    }
#line 1730
    if (slash___0) {
#line 1730
      if (! seen_slash_slash) {
#line 1731
        if ((int const   )*(slash___0 + 1) == 47) {
#line 1733
          pos = slash___0 + 2;
#line 1734
          seen_slash_slash = (_Bool)1;
#line 1735
          goto again;
        }
      }
    }
#line 1744
    if (! slash___0) {
#line 1744
      if (! seen_slash_slash) {
#line 1747
        start_insert___0 = base;
      } else {
#line 1744
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1748
    if (! slash___0) {
#line 1748
      if (seen_slash_slash) {
#line 1751
        start_insert___0 = end;
      } else {
#line 1748
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1752
    if (slash___0) {
#line 1752
      if (! seen_slash_slash) {
#line 1755
        start_insert___0 = base;
      } else {
#line 1752
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1756
    if (slash___0) {
#line 1756
      if (seen_slash_slash) {
#line 1759
        start_insert___0 = slash___0;
      }
    }
    {
#line 1761
    span___0 = (int )(start_insert___0 - base);
#line 1762
    tmp___10 = checking_malloc((size_t )((span___0 + linklength) + 1));
#line 1762
    merge = (char *)tmp___10;
    }
#line 1763
    if (span___0) {
      {
#line 1764
      memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
             (size_t )span___0);
      }
    }
    {
#line 1765
    memcpy((void */* __restrict  */)(merge + span___0), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1766
    *(merge + (span___0 + linklength)) = (char )'\000';
    }
  } else {
    {
#line 1775
    need_explicit_slash = (_Bool)0;
#line 1778
    tmp___11 = memrchr((void const   *)base, '/', (size_t )(end - base));
#line 1778
    last_slash = (char const   *)tmp___11;
    }
#line 1779
    if (! last_slash) {
#line 1782
      start_insert___1 = base;
    } else
#line 1784
    if (last_slash) {
#line 1784
      if ((unsigned long )last_slash >= (unsigned long )(base + 2)) {
#line 1784
        if ((int const   )*(last_slash + -2) == 58) {
#line 1784
          if ((int const   )*(last_slash + -1) == 47) {
#line 1789
            start_insert___1 = end + 1;
#line 1790
            need_explicit_slash = (_Bool)1;
          } else {
#line 1796
            start_insert___1 = last_slash + 1;
          }
        } else {
#line 1796
          start_insert___1 = last_slash + 1;
        }
      } else {
#line 1796
        start_insert___1 = last_slash + 1;
      }
    } else {
#line 1796
      start_insert___1 = last_slash + 1;
    }
    {
#line 1799
    span___1 = (int )(start_insert___1 - base);
#line 1800
    tmp___12 = checking_malloc((size_t )((span___1 + linklength) + 1));
#line 1800
    merge = (char *)tmp___12;
    }
#line 1801
    if (span___1) {
      {
#line 1802
      memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
             (size_t )span___1);
      }
    }
#line 1803
    if (need_explicit_slash) {
#line 1804
      *(merge + (span___1 - 1)) = (char )'/';
    }
    {
#line 1805
    memcpy((void */* __restrict  */)(merge + span___1), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1806
    *(merge + (span___1 + linklength)) = (char )'\000';
    }
  }
#line 1809
  return (merge);
}
}
#line 1831 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
char *url_string(struct url  const  *url , enum url_auth_mode auth_mode ) 
{ 
  int size ;
  char *result ;
  char *p___0 ;
  char *quoted_host ;
  char *quoted_user ;
  char *quoted_passwd ;
  int scheme_port ;
  char const   *scheme_str ;
  int fplen ;
  int tmp ;
  _Bool brackets_around_host ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int len ;
  size_t tmp___9 ;
  int len___0 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  int len___1 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int len___2 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 1836
  quoted_user = (char *)((void *)0);
#line 1836
  quoted_passwd = (char *)((void *)0);
#line 1838
  scheme_port = supported_schemes[url->scheme].default_port;
#line 1839
  scheme_str = supported_schemes[url->scheme].leading_string;
#line 1840
  tmp = full_path_length(url);
#line 1840
  fplen = tmp;
  }
#line 1844
  if (! ((unsigned long )scheme_str != (unsigned long )((void *)0))) {
    {
#line 1844
    __assert_fail("scheme_str != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  1844U, "url_string");
    }
  }
#line 1847
  if (url->user) {
#line 1849
    if ((unsigned int )auth_mode != 2U) {
      {
#line 1851
      quoted_user = url_escape_allow_passthrough((char const   *)url->user);
      }
#line 1852
      if (url->passwd) {
#line 1854
        if ((unsigned int )auth_mode == 1U) {
#line 1855
          quoted_passwd = (char *)"*password*";
        } else {
          {
#line 1857
          quoted_passwd = url_escape_allow_passthrough((char const   *)url->passwd);
          }
        }
      }
    }
  }
  {
#line 1864
  quoted_host = url_escape_allow_passthrough((char const   *)url->host);
  }
#line 1869
  if ((unsigned long )quoted_host != (unsigned long )url->host) {
    {
#line 1870
    unescape_single_char(quoted_host, (char )':');
    }
  }
  {
#line 1871
  tmp___1 = strchr((char const   *)quoted_host, ':');
#line 1871
  brackets_around_host = (_Bool )((unsigned long )tmp___1 != (unsigned long )((void *)0));
#line 1873
  tmp___2 = strlen(scheme_str);
#line 1873
  tmp___3 = strlen((char const   *)quoted_host);
  }
#line 1873
  if (brackets_around_host) {
#line 1873
    tmp___4 = 2;
  } else {
#line 1873
    tmp___4 = 0;
  }
#line 1873
  size = (int )((((tmp___2 + tmp___3) + (size_t )tmp___4) + (size_t )fplen) + 1UL);
#line 1878
  if (url->port != (int const   )scheme_port) {
    {
#line 1879
    tmp___5 = numdigit((wgint )url->port);
#line 1879
    size += 1 + tmp___5;
    }
  }
#line 1880
  if (quoted_user) {
    {
#line 1882
    tmp___6 = strlen((char const   *)quoted_user);
#line 1882
    size = (int )((size_t )size + (1UL + tmp___6));
    }
#line 1883
    if (quoted_passwd) {
      {
#line 1884
      tmp___7 = strlen((char const   *)quoted_passwd);
#line 1884
      size = (int )((size_t )size + (1UL + tmp___7));
      }
    }
  }
  {
#line 1887
  tmp___8 = checking_malloc((size_t )size);
#line 1887
  result = (char *)tmp___8;
#line 1887
  p___0 = result;
  }
  {
#line 1889
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1889
    tmp___9 = strlen(scheme_str);
#line 1889
    len = (int )tmp___9;
#line 1889
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)scheme_str,
           (size_t )len);
#line 1889
    p___0 += len;
    }
#line 1889
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1890
  if (quoted_user) {
    {
#line 1892
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1892
      tmp___10 = strlen((char const   *)quoted_user);
#line 1892
      len___0 = (int )tmp___10;
#line 1892
      memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)quoted_user,
             (size_t )len___0);
#line 1892
      p___0 += len___0;
      }
#line 1892
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1893
    if (quoted_passwd) {
#line 1895
      tmp___11 = p___0;
#line 1895
      p___0 ++;
#line 1895
      *tmp___11 = (char )':';
      {
#line 1896
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1896
        tmp___12 = strlen((char const   *)quoted_passwd);
#line 1896
        len___1 = (int )tmp___12;
#line 1896
        memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)quoted_passwd,
               (size_t )len___1);
#line 1896
        p___0 += len___1;
        }
#line 1896
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1898
    tmp___13 = p___0;
#line 1898
    p___0 ++;
#line 1898
    *tmp___13 = (char )'@';
  }
#line 1901
  if (brackets_around_host) {
#line 1902
    tmp___14 = p___0;
#line 1902
    p___0 ++;
#line 1902
    *tmp___14 = (char )'[';
  }
  {
#line 1903
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1903
    tmp___15 = strlen((char const   *)quoted_host);
#line 1903
    len___2 = (int )tmp___15;
#line 1903
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)quoted_host,
           (size_t )len___2);
#line 1903
    p___0 += len___2;
    }
#line 1903
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1904
  if (brackets_around_host) {
#line 1905
    tmp___16 = p___0;
#line 1905
    p___0 ++;
#line 1905
    *tmp___16 = (char )']';
  }
#line 1906
  if (url->port != (int const   )scheme_port) {
    {
#line 1908
    tmp___17 = p___0;
#line 1908
    p___0 ++;
#line 1908
    *tmp___17 = (char )':';
#line 1909
    p___0 = number_to_string(p___0, (wgint )url->port);
    }
  }
  {
#line 1912
  full_path_write(url, p___0);
#line 1913
  p___0 += fplen;
#line 1914
  tmp___18 = p___0;
#line 1914
  p___0 ++;
#line 1914
  *tmp___18 = (char )'\000';
  }
#line 1916
  if (! (p___0 - result == (long )size)) {
    {
#line 1916
    __assert_fail("p - result == size", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  1916U, "url_string");
    }
  }
#line 1918
  if (quoted_user) {
#line 1918
    if ((unsigned long )quoted_user != (unsigned long )url->user) {
      {
#line 1919
      checking_free((void *)quoted_user);
      }
    }
  }
#line 1920
  if (quoted_passwd) {
#line 1920
    if ((unsigned int )auth_mode == 0U) {
#line 1920
      if ((unsigned long )quoted_passwd != (unsigned long )url->passwd) {
        {
#line 1922
        checking_free((void *)quoted_passwd);
        }
      }
    }
  }
#line 1923
  if ((unsigned long )quoted_host != (unsigned long )url->host) {
    {
#line 1924
    checking_free((void *)quoted_host);
    }
  }
#line 1926
  return (result);
}
}
#line 1934 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
_Bool schemes_are_similar_p(enum url_scheme a , enum url_scheme b ) 
{ 


  {
#line 1937
  if ((unsigned int )a == (unsigned int )b) {
#line 1938
    return ((_Bool)1);
  }
#line 1940
  if ((unsigned int )a == 0U) {
#line 1940
    if ((unsigned int )b == 1U) {
#line 1942
      return ((_Bool)1);
    } else {
#line 1940
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1940
  if ((unsigned int )a == 1U) {
#line 1940
    if ((unsigned int )b == 0U) {
#line 1942
      return ((_Bool)1);
    }
  }
#line 1944
  return ((_Bool)0);
}
}
#line 1947 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
static int getchar_from_escaped_string(char const   *str , char *c ) 
{ 
  char const   *p___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1950
  p___0 = str;
#line 1952
  if (str) {
#line 1952
    if (! *str) {
      {
#line 1952
      __assert_fail("str && *str", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                    1952U, "getchar_from_escaped_string");
      }
    }
  } else {
    {
#line 1952
    __assert_fail("str && *str", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  1952U, "getchar_from_escaped_string");
    }
  }
#line 1953
  if (! c) {
    {
#line 1953
    __assert_fail("c", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c", 1953U,
                  "getchar_from_escaped_string");
    }
  }
#line 1955
  if ((int const   )*(p___0 + 0) == 37) {
#line 1957
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 256)) {
#line 1959
      *c = (char )'%';
#line 1960
      return (1);
    } else
#line 1957
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 2) & 255] & 256)) {
#line 1959
      *c = (char )'%';
#line 1960
      return (1);
    } else {
#line 1964
      if ((int const   )*(p___0 + 2) == 0) {
#line 1965
        return (0);
      }
#line 1967
      if ((int const   )*(p___0 + 1) < 65) {
#line 1967
        tmp___1 = (int const   )*(p___0 + 1) - 48;
      } else {
#line 1967
        tmp___1 = ((int const   )_sch_toupper[(int const   )*(p___0 + 1) & 255] - 65) + 10;
      }
#line 1967
      if ((int const   )*(p___0 + 2) < 65) {
#line 1967
        tmp___2 = (int const   )*(p___0 + 2) - 48;
      } else {
#line 1967
        tmp___2 = ((int const   )_sch_toupper[(int const   )*(p___0 + 2) & 255] - 65) + 10;
      }
#line 1967
      *c = (char )((tmp___1 << 4) + tmp___2);
#line 1968
      if ((int const   )urlchr_table[(unsigned char )*c] & 1) {
#line 1970
        *c = (char )'%';
#line 1971
        return (1);
      } else {
#line 1974
        return (3);
      }
    }
  } else {
#line 1979
    *c = (char )*(p___0 + 0);
  }
#line 1982
  return (1);
}
}
#line 1985 "/home/khheo/project/benchmark/wget-1.11.4/src/url.c"
_Bool are_urls_equal(char const   *u1 , char const   *u2 ) 
{ 
  char const   *p___0 ;
  char const   *q ;
  int pp ;
  int qq ;
  char ch1 ;
  char ch2 ;
  int tmp___0 ;

  {
#line 1991
  if (u1) {
#line 1991
    if (! u2) {
      {
#line 1991
      __assert_fail("u1 && u2", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                    1991U, "are_urls_equal");
      }
    }
  } else {
    {
#line 1991
    __assert_fail("u1 && u2", "/home/khheo/project/benchmark/wget-1.11.4/src/url.c",
                  1991U, "are_urls_equal");
    }
  }
#line 1993
  p___0 = u1;
#line 1994
  q = u2;
  {
#line 1996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1996
    if (*p___0) {
#line 1996
      if (*q) {
        {
#line 1996
        pp = getchar_from_escaped_string(p___0, & ch1);
        }
#line 1996
        if (pp) {
          {
#line 1996
          qq = getchar_from_escaped_string(q, & ch2);
          }
#line 1996
          if (qq) {
#line 1996
            if (! ((int const   )_sch_tolower[(int )ch1 & 255] == (int const   )_sch_tolower[(int )ch2 & 255])) {
#line 1996
              goto while_break;
            }
          } else {
#line 1996
            goto while_break;
          }
        } else {
#line 1996
          goto while_break;
        }
      } else {
#line 1996
        goto while_break;
      }
    } else {
#line 1996
      goto while_break;
    }
#line 2001
    p___0 += pp;
#line 2002
    q += qq;
  }
  while_break: /* CIL Label */ ;
  }
#line 2005
  if ((int const   )*p___0 == 0) {
#line 2005
    if ((int const   )*q == 0) {
#line 2005
      tmp___0 = 1;
    } else {
#line 2005
      tmp___0 = 0;
    }
  } else {
#line 2005
    tmp___0 = 0;
  }
#line 2005
  return ((_Bool )tmp___0);
}
}
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 42 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void logputs(enum log_options o , char const   *s ) ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.h"
void nonexisting_url(char const   *url ) ;
#line 35
void print_broken_links(void) ;
#line 58 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
int hash_table_count(struct hash_table  const  *ht ) ;
#line 60
struct hash_table *make_string_hash_table(int items ) ;
#line 45 "/home/khheo/project/benchmark/wget-1.11.4/src/res.h"
_Bool is_robots_txt_url(char const   *url ) ;
#line 44 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c"
static struct hash_table *nonexisting_urls_set  ;
#line 48 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c"
void spider_cleanup(void) 
{ 


  {
#line 51
  if (nonexisting_urls_set) {
    {
#line 52
    string_set_free(nonexisting_urls_set);
    }
  }
#line 53
  return;
}
}
#line 56 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c"
void nonexisting_url(char const   *url ) 
{ 
  _Bool tmp ;

  {
  {
#line 60
  tmp = is_robots_txt_url(url);
  }
#line 60
  if (tmp) {
#line 61
    return;
  }
#line 62
  if (! nonexisting_urls_set) {
    {
#line 63
    nonexisting_urls_set = make_string_hash_table(0);
    }
  }
  {
#line 64
  string_set_add(nonexisting_urls_set, url);
  }
#line 65
  return;
}
}
#line 67 "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c"
void print_broken_links(void) 
{ 
  hash_table_iterator iter ;
  int num_elems ;
  char *tmp ;
  char *tmp___1 ;
  char const   *url ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 73
  if (! nonexisting_urls_set) {
    {
#line 75
    tmp = gettext("Found no broken links.\n\n");
#line 75
    logprintf((enum log_options )1, (char const   *)tmp);
    }
#line 76
    return;
  }
  {
#line 79
  num_elems = hash_table_count((struct hash_table  const  *)nonexisting_urls_set);
  }
#line 80
  if (! (num_elems > 0)) {
    {
#line 80
    __assert_fail("num_elems > 0", "/home/khheo/project/benchmark/wget-1.11.4/src/spider.c",
                  80U, "print_broken_links");
    }
  }
  {
#line 82
  tmp___1 = ngettext("Found %d broken link.\n\n", "Found %d broken links.\n\n", (unsigned long )num_elems);
#line 82
  logprintf((enum log_options )1, (char const   *)tmp___1, num_elems);
#line 86
  hash_table_iterate(nonexisting_urls_set, & iter);
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    tmp___3 = hash_table_iter_next(& iter);
    }
#line 86
    if (! tmp___3) {
#line 86
      goto while_break;
    }
    {
#line 90
    url = (char const   *)iter.key;
#line 92
    tmp___2 = gettext("%s\n");
#line 92
    logprintf((enum log_options )1, (char const   *)tmp___2, url);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  logputs((enum log_options )1, "\n");
  }
#line 95
  return;
}
}
#line 80 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.c"
unsigned short const   _sch_istable[256]  = 
#line 80 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.c"
  {      (unsigned short const   )2050,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2115,      (unsigned short const   )1090,      (unsigned short const   )2114, 
        (unsigned short const   )2114,      (unsigned short const   )1090,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2129,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912, 
        (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )560, 
        (unsigned short const   )48,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792, 
        (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )2, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0};
#line 112 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.c"
unsigned char const   _sch_tolower[256]  = 
#line 112
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 141 "/home/khheo/project/benchmark/wget-1.11.4/src/safe-ctype.c"
unsigned char const   _sch_toupper[256]  = 
#line 141
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 53 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
char const   *escnonprint_uri(char const   *str ) ;
#line 36 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.h"
SUM_SIZE_INT total_downloaded_bytes  ;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.h"
double total_download_time  ;
#line 38 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.h"
FILE *output_stream  ;
#line 39 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.h"
_Bool output_stream_regular  ;
#line 47
int fd_read_body(int fd , FILE *out , wgint toread , wgint startpos , wgint *qtyread ,
                 wgint *qtywritten , double *elapsed , int flags ) ;
#line 51
char *fd_read_hunk(int fd , char const   *(*terminator)(char const   * , char const   * ,
                                                        int  ) , long sizehint , long maxsize ) ;
#line 52
char *fd_read_line(int fd ) ;
#line 54
uerr_t retrieve_url(char const   *origurl , char **file , char **newloc , char const   *refurl ,
                    int *dt , _Bool recursive ) ;
#line 55
uerr_t retrieve_from_file(char const   *file , _Bool html , int *count ) ;
#line 57
char const   *retr_rate(wgint bytes , double secs ) ;
#line 58
double calc_rate(wgint bytes , double secs , int *units ) ;
#line 59
void printwhat(int n1 , int n2 ) ;
#line 61
void sleep_between_retrievals(int count ) ;
#line 63
void rotate_backups(char const   *fname ) ;
#line 65
_Bool url_uses_proxy(char const   *url ) ;
#line 38 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.h"
void *progress_create(wgint initial , wgint total ) ;
#line 39
_Bool progress_interactive_p(void *progress ) ;
#line 40
void progress_update(void *progress , wgint howmuch , double dltime ) ;
#line 41
void progress_finish(void *progress , double dltime ) ;
#line 45 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.h"
uerr_t retrieve_tree(char const   *start_url ) ;
#line 48
struct urlpos *get_urls_file(char const   *file ) ;
#line 49
struct urlpos *get_urls_html(char const   *file , char const   *url , _Bool *meta_disallow_follow ) ;
#line 50
void free_urlpos(struct urlpos *l ) ;
#line 97 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
_Bool sufmatch(char const   **list , char const   *what ) ;
#line 123 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
uerr_t ftp_loop(struct url *u , int *dt , struct url *proxy , _Bool recursive , _Bool glob ) ;
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/http.h"
uerr_t http_loop(struct url *u , char **newloc , char **local_file , char const   *referer ,
                 int *dt , struct url *proxy ) ;
#line 75 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
int fd_read(int fd , char *buf___4 , int bufsize , double timeout ) ;
#line 77
int fd_peek(int fd , char *buf___4 , int bufsize , double timeout ) ;
#line 98 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
void register_download(char const   *url , char const   *file ) ;
#line 99
void register_redirection(char const   *from , char const   *to ) ;
#line 100
void register_html(char const   *url , char const   *file ) ;
#line 36 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.h"
struct ptimer *ptimer_new(void) ;
#line 37
void ptimer_destroy(struct ptimer *pt ) ;
#line 40
double ptimer_measure(struct ptimer *pt ) ;
#line 41
double ptimer_read(struct ptimer  const  *pt ) ;
#line 43
double ptimer_resolution(void) ;
#line 70 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static struct __anonstruct_limit_data_916237038 limit_data  ;
#line 76 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static void limit_bandwidth_reset(void) 
{ 


  {
  {
#line 79
  memset((void *)(& limit_data), '\000', sizeof(limit_data));
  }
#line 80
  return;
}
}
#line 86 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static void limit_bandwidth(wgint bytes , struct ptimer *timer ) 
{ 
  double delta_t ;
  double tmp ;
  double expected ;
  double slp ;
  double t0 ;
  double t1 ;
  char *tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 89
  tmp = ptimer_read((struct ptimer  const  *)timer);
#line 89
  delta_t = tmp - limit_data.chunk_start;
#line 92
  limit_data.chunk_bytes += bytes;
#line 97
  expected = (double )limit_data.chunk_bytes / (double )opt.limit_rate;
  }
#line 99
  if (expected > delta_t) {
#line 101
    slp = (expected - delta_t) + limit_data.sleep_adjust;
#line 103
    if (slp < 0.2) {
      {
#line 105
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 105
        tmp___1 = __builtin_expect((long )opt.debug, 0L);
        }
#line 105
        if (tmp___1) {
          {
#line 105
          tmp___0 = number_to_static_string(limit_data.chunk_bytes);
#line 105
          debug_logprintf("deferring a %.2f ms sleep (%s/%.2f).\n", slp * (double )1000,
                          tmp___0, delta_t);
          }
        }
#line 105
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 108
      return;
    }
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 110
      tmp___3 = __builtin_expect((long )opt.debug, 0L);
      }
#line 110
      if (tmp___3) {
        {
#line 110
        tmp___2 = number_to_static_string(limit_data.chunk_bytes);
#line 110
        debug_logprintf("\nsleeping %.2f ms for %s bytes, adjust %.2f ms\n", slp * (double )1000,
                        tmp___2, limit_data.sleep_adjust);
        }
      }
#line 110
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    t0 = ptimer_read((struct ptimer  const  *)timer);
#line 115
    xsleep(slp);
#line 116
    t1 = ptimer_measure(timer);
#line 122
    limit_data.sleep_adjust = slp - (t1 - t0);
    }
#line 125
    if (limit_data.sleep_adjust > 0.5) {
#line 126
      limit_data.sleep_adjust = 0.5;
    } else
#line 127
    if (limit_data.sleep_adjust < - 0.5) {
#line 128
      limit_data.sleep_adjust = - 0.5;
    }
  }
  {
#line 131
  limit_data.chunk_bytes = (wgint )0;
#line 132
  limit_data.chunk_start = ptimer_read((struct ptimer  const  *)timer);
  }
#line 133
  return;
}
}
#line 143 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static int write_data(FILE *out , char const   *buf___4 , int bufsize , wgint *skip ,
                      wgint *written ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 147
  if (! out) {
#line 148
    return (1);
  }
#line 149
  if (*skip > (wgint )bufsize) {
#line 151
    *skip -= (wgint )bufsize;
#line 152
    return (1);
  }
#line 154
  if (*skip) {
#line 156
    buf___4 += *skip;
#line 157
    bufsize = (int )((wgint )bufsize - *skip);
#line 158
    *skip = (wgint )0;
#line 159
    if (bufsize == 0) {
#line 160
      return (1);
    }
  }
  {
#line 163
  fwrite((void const   */* __restrict  */)buf___4, (size_t )1, (size_t )bufsize, (FILE */* __restrict  */)out);
#line 164
  *written += (wgint )bufsize;
#line 170
  fflush(out);
#line 171
  tmp = ferror(out);
  }
#line 171
  if (tmp) {
#line 171
    tmp___0 = 0;
  } else {
#line 171
    tmp___0 = 1;
  }
#line 171
  return (tmp___0);
}
}
#line 199 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char dlbuf[16384]  ;
#line 193 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
int fd_read_body(int fd , FILE *out , wgint toread , wgint startpos , wgint *qtyread ,
                 wgint *qtywritten , double *elapsed , int flags ) 
{ 
  int ret ;
  int dlbufsize ;
  struct ptimer *timer ;
  double last_successful_read_tm ;
  void *progress ;
  _Bool progress_interactive ;
  _Bool exact ;
  wgint skip ;
  wgint sum_read ;
  wgint sum_written ;
  wgint tmp ;
  int rdsize ;
  wgint tmp___0 ;
  wgint tmp___1 ;
  double tmout ;
  double waittm ;
  double tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;

  {
#line 197
  ret = 0;
#line 200
  dlbufsize = (int )sizeof(dlbuf);
#line 202
  timer = (struct ptimer *)((void *)0);
#line 203
  last_successful_read_tm = (double )0;
#line 206
  progress = (void *)0;
#line 212
  progress_interactive = (_Bool)0;
#line 214
  exact = (_Bool )(! (! (flags & 1)));
#line 215
  skip = (wgint )0;
#line 218
  sum_read = (wgint )0;
#line 219
  sum_written = (wgint )0;
#line 221
  if (flags & 2) {
#line 222
    skip = startpos;
  }
#line 224
  if (opt.verbose) {
#line 229
    if (skip) {
#line 229
      tmp = (wgint )0;
    } else {
#line 229
      tmp = startpos;
    }
    {
#line 229
    progress = progress_create(tmp, startpos + toread);
#line 230
    progress_interactive = progress_interactive_p(progress);
    }
  }
#line 233
  if (opt.limit_rate) {
    {
#line 234
    limit_bandwidth_reset();
    }
  }
#line 239
  if (progress) {
    {
#line 241
    timer = ptimer_new();
#line 242
    last_successful_read_tm = (double )0;
    }
  } else
#line 239
  if (opt.limit_rate) {
    {
#line 241
    timer = ptimer_new();
#line 242
    last_successful_read_tm = (double )0;
    }
  } else
#line 239
  if (elapsed) {
    {
#line 241
    timer = ptimer_new();
#line 242
    last_successful_read_tm = (double )0;
    }
  }
#line 249
  if (opt.limit_rate) {
#line 249
    if (opt.limit_rate < (wgint )dlbufsize) {
#line 250
      dlbufsize = (int )opt.limit_rate;
    }
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (! exact)) {
#line 256
      if (! (sum_read < toread)) {
#line 256
        goto while_break;
      }
    }
#line 258
    if (exact) {
#line 258
      if (toread - sum_read <= (wgint )dlbufsize) {
#line 258
        tmp___0 = toread - sum_read;
      } else {
#line 258
        tmp___0 = (wgint )dlbufsize;
      }
#line 258
      tmp___1 = tmp___0;
    } else {
#line 258
      tmp___1 = (wgint )dlbufsize;
    }
#line 258
    rdsize = (int )tmp___1;
#line 259
    tmout = opt.read_timeout;
#line 260
    if (progress_interactive) {
#line 265
      tmout = 0.95;
#line 266
      if (opt.read_timeout) {
        {
#line 269
        tmp___2 = ptimer_read((struct ptimer  const  *)timer);
#line 269
        waittm = tmp___2 - last_successful_read_tm;
        }
#line 270
        if (waittm + tmout > opt.read_timeout) {
#line 273
          tmout = opt.read_timeout - waittm;
#line 274
          if (tmout < (double )0) {
            {
#line 277
            ret = -1;
#line 277
            tmp___3 = __errno_location();
#line 277
            *tmp___3 = 110;
            }
#line 278
            goto while_break;
          }
        }
      }
    }
    {
#line 283
    ret = fd_read(fd, dlbuf, rdsize, tmout);
    }
#line 285
    if (progress_interactive) {
#line 285
      if (ret < 0) {
        {
#line 285
        tmp___4 = __errno_location();
        }
#line 285
        if (*tmp___4 == 110) {
#line 286
          ret = 0;
        } else {
#line 285
          goto _L___0;
        }
      } else {
#line 285
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 287
    if (ret <= 0) {
#line 288
      goto while_break;
    }
#line 290
    if (progress) {
#line 290
      goto _L___1;
    } else
#line 290
    if (opt.limit_rate) {
      _L___1: /* CIL Label */ 
      {
#line 292
      ptimer_measure(timer);
      }
#line 293
      if (ret > 0) {
        {
#line 294
        last_successful_read_tm = ptimer_read((struct ptimer  const  *)timer);
        }
      }
    }
#line 297
    if (ret > 0) {
      {
#line 299
      sum_read += (wgint )ret;
#line 300
      tmp___5 = write_data(out, (char const   *)(dlbuf), ret, & skip, & sum_written);
      }
#line 300
      if (! tmp___5) {
#line 302
        ret = -2;
#line 303
        goto out;
      }
    }
#line 307
    if (opt.limit_rate) {
      {
#line 308
      limit_bandwidth((wgint )ret, timer);
      }
    }
#line 310
    if (progress) {
      {
#line 311
      tmp___6 = ptimer_read((struct ptimer  const  *)timer);
#line 311
      progress_update(progress, (wgint )ret, tmp___6);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  if (ret < -1) {
#line 319
    ret = -1;
  }
  out: 
#line 322
  if (progress) {
    {
#line 323
    tmp___7 = ptimer_read((struct ptimer  const  *)timer);
#line 323
    progress_finish(progress, tmp___7);
    }
  }
#line 325
  if (elapsed) {
    {
#line 326
    *elapsed = ptimer_read((struct ptimer  const  *)timer);
    }
  }
#line 327
  if (timer) {
    {
#line 328
    ptimer_destroy(timer);
    }
  }
#line 330
  if (qtyread) {
#line 331
    *qtyread += sum_read;
  }
#line 332
  if (qtywritten) {
#line 333
    *qtywritten += sum_written;
  }
#line 335
  return (ret);
}
}
#line 389 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
char *fd_read_hunk(int fd , char const   *(*terminator)(char const   * , char const   * ,
                                                        int  ) , long sizehint , long maxsize ) 
{ 
  long bufsize ;
  char *hunk ;
  void *tmp ;
  int tail ;
  char const   *end ;
  int pklen ;
  int rdlen ;
  int remain ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 392
  bufsize = sizehint;
#line 393
  tmp = checking_malloc((size_t )bufsize);
#line 393
  hunk = (char *)tmp;
#line 394
  tail = 0;
  }
#line 396
  if (! (maxsize >= bufsize)) {
    {
#line 396
    __assert_fail("maxsize >= bufsize", "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c",
                  396U, "fd_read_hunk");
    }
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    pklen = fd_peek(fd, hunk + tail, (int )((bufsize - 1L) - (long )tail), (double )-1);
    }
#line 406
    if (pklen < 0) {
      {
#line 408
      checking_free((void *)hunk);
      }
#line 409
      return ((char *)((void *)0));
    }
    {
#line 411
    end = (*terminator)((char const   *)hunk, (char const   *)(hunk + tail), pklen);
    }
#line 412
    if (end) {
#line 416
      remain = (int )(end - (char const   *)(hunk + tail));
#line 417
      if (! (remain >= 0)) {
        {
#line 417
        __assert_fail("remain >= 0", "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c",
                      417U, "fd_read_hunk");
        }
      }
#line 418
      if (remain == 0) {
#line 421
        *(hunk + tail) = (char )'\000';
#line 422
        return (hunk);
      }
#line 424
      if (bufsize - 1L < (long )(tail + remain)) {
        {
#line 426
        bufsize = (long )((tail + remain) + 1);
#line 427
        tmp___2 = checking_realloc((void *)hunk, (size_t )bufsize);
#line 427
        hunk = (char *)tmp___2;
        }
      }
    } else {
#line 433
      remain = pklen;
    }
    {
#line 439
    rdlen = fd_read(fd, hunk + tail, remain, (double )0);
    }
#line 440
    if (rdlen < 0) {
#line 442
      if (! (! hunk)) {
        {
#line 442
        checking_free((void *)hunk);
        }
      }
#line 443
      return ((char *)((void *)0));
    }
#line 445
    tail += rdlen;
#line 446
    *(hunk + tail) = (char )'\000';
#line 448
    if (rdlen == 0) {
#line 450
      if (tail == 0) {
        {
#line 453
        checking_free((void *)hunk);
#line 454
        tmp___3 = __errno_location();
#line 454
        *tmp___3 = 0;
        }
#line 455
        return ((char *)((void *)0));
      } else {
#line 459
        return (hunk);
      }
    }
#line 461
    if (end) {
#line 461
      if (rdlen == remain) {
#line 464
        return (hunk);
      }
    }
#line 468
    if ((long )tail == bufsize - 1L) {
#line 472
      if (maxsize) {
#line 472
        if (bufsize >= maxsize) {
          {
#line 474
          checking_free((void *)hunk);
#line 475
          tmp___4 = __errno_location();
#line 475
          *tmp___4 = 12;
          }
#line 476
          return ((char *)((void *)0));
        }
      }
#line 478
      bufsize <<= 1;
#line 479
      if (maxsize) {
#line 479
        if (bufsize > maxsize) {
#line 480
          bufsize = maxsize;
        }
      }
      {
#line 481
      tmp___5 = checking_realloc((void *)hunk, (size_t )bufsize);
#line 481
      hunk = (char *)tmp___5;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 486 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char const   *line_terminator(char const   *start , char const   *peeked ,
                                     int peeklen ) 
{ 
  char const   *p___0 ;
  void *tmp ;

  {
  {
#line 489
  tmp = memchr((void const   *)peeked, '\n', (size_t )peeklen);
#line 489
  p___0 = (char const   *)tmp;
  }
#line 490
  if (p___0) {
#line 492
    return (p___0 + 1);
  }
#line 493
  return ((char const   *)((void *)0));
}
}
#line 509 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
char *fd_read_line(int fd ) 
{ 
  char *tmp ;

  {
  {
#line 512
  tmp = fd_read_hunk(fd, & line_terminator, 128L, 4096L);
  }
#line 512
  return (tmp);
}
}
#line 521 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char res[20]  ;
#line 522 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char const   *rate_names[4]  = {      "B/s",      "KB/s",      "MB/s",      "GB/s"};
#line 518 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
char const   *retr_rate(wgint bytes , double secs ) 
{ 
  int units ;
  double dlrate ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 525
  tmp = calc_rate(bytes, secs, & units);
#line 525
  dlrate = tmp;
  }
#line 528
  if (dlrate >= 99.95) {
#line 528
    tmp___1 = 0;
  } else {
#line 528
    if (dlrate >= 9.995) {
#line 528
      tmp___0 = 1;
    } else {
#line 528
      tmp___0 = 2;
    }
#line 528
    tmp___1 = tmp___0;
  }
  {
#line 528
  sprintf((char */* __restrict  */)(res), (char const   */* __restrict  */)"%.*f %s",
          tmp___1, dlrate, rate_names[units]);
  }
#line 532
  return ((char const   *)(res));
}
}
#line 543 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
double calc_rate(wgint bytes , double secs , int *units ) 
{ 
  double dlrate ;
  double tmp___1 ;

  {
#line 548
  if (! (secs >= (double )0)) {
    {
#line 548
    __assert_fail("secs >= 0", "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c",
                  548U, "calc_rate");
    }
  }
#line 549
  if (! (bytes >= 0L)) {
    {
#line 549
    __assert_fail("bytes >= 0", "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c",
                  549U, "calc_rate");
    }
  }
#line 551
  if (secs == (double )0) {
    {
#line 556
    tmp___1 = ptimer_resolution();
#line 556
    secs = tmp___1 / 2.0;
    }
  }
#line 558
  dlrate = (double )bytes / secs;
#line 559
  if (dlrate < 1024.0) {
#line 560
    *units = 0;
  } else
#line 561
  if (dlrate < 1024.0 * 1024.0) {
#line 562
    *units = 1;
#line 562
    dlrate /= 1024.0;
  } else
#line 563
  if (dlrate < (1024.0 * 1024.0) * 1024.0) {
#line 564
    *units = 2;
#line 564
    dlrate /= 1024.0 * 1024.0;
  } else {
#line 567
    *units = 3;
#line 567
    dlrate /= (1024.0 * 1024.0) * 1024.0;
  }
#line 569
  return (dlrate);
}
}
#line 590
static char *getproxy(struct url *u ) ;
#line 598 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
uerr_t retrieve_url(char const   *origurl , char **file , char **newloc , char const   *refurl ,
                    int *dt , _Bool recursive ) 
{ 
  uerr_t result ;
  char *url ;
  _Bool location_changed ;
  int dummy ;
  char *mynewloc ;
  char *proxy ;
  struct url *u ;
  struct url *proxy_url ;
  int up_error_code ;
  char *local_file ;
  int redirection_count ;
  _Bool post_data_suspended ;
  char *saved_post_data ;
  char *saved_post_file_name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool oldrec ;
  _Bool glob ;
  _Bool tmp___3 ;
  char *construced_newloc ;
  struct url *newloc_parsed ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 610
  redirection_count = 0;
#line 612
  post_data_suspended = (_Bool)0;
#line 613
  saved_post_data = (char *)((void *)0);
#line 614
  saved_post_file_name = (char *)((void *)0);
#line 617
  if (! dt) {
#line 619
    dt = & dummy;
#line 620
    dummy = 0;
  }
  {
#line 622
  url = checking_strdup(origurl);
  }
#line 623
  if (newloc) {
#line 624
    *newloc = (char *)((void *)0);
  }
#line 625
  if (file) {
#line 626
    *file = (char *)((void *)0);
  }
  {
#line 628
  u = url_parse((char const   *)url, & up_error_code);
  }
#line 629
  if (! u) {
    {
#line 631
    tmp = url_error(up_error_code);
#line 631
    logprintf((enum log_options )1, "%s: %s.\n", url, tmp);
#line 632
    checking_free((void *)url);
    }
#line 633
    return ((uerr_t )23);
  }
#line 636
  if (! refurl) {
#line 637
    refurl = (char const   *)opt.referer;
  }
  redirected: 
  {
#line 641
  result = (uerr_t )0;
#line 642
  mynewloc = (char *)((void *)0);
#line 643
  local_file = (char *)((void *)0);
#line 644
  proxy_url = (struct url *)((void *)0);
#line 646
  proxy = getproxy(u);
  }
#line 647
  if (proxy) {
    {
#line 650
    proxy_url = url_parse((char const   *)proxy, & up_error_code);
    }
#line 651
    if (! proxy_url) {
      {
#line 653
      tmp___0 = url_error(up_error_code);
#line 653
      tmp___1 = gettext("Error parsing proxy URL %s: %s.\n");
#line 653
      logprintf((enum log_options )1, (char const   *)tmp___1, proxy, tmp___0);
#line 655
      checking_free((void *)url);
      }
      {
#line 656
      while (1) {
        while_continue: /* CIL Label */ ;
#line 656
        if (post_data_suspended) {
#line 656
          opt.post_data = saved_post_data;
#line 656
          opt.post_file_name = saved_post_file_name;
#line 656
          post_data_suspended = (_Bool)0;
        }
#line 656
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 657
      return ((uerr_t )49);
    }
#line 659
    if ((unsigned int )proxy_url->scheme != 0U) {
#line 659
      if ((unsigned int )proxy_url->scheme != (unsigned int )u->scheme) {
        {
#line 661
        tmp___2 = gettext("Error in proxy URL %s: Must be HTTP.\n");
#line 661
        logprintf((enum log_options )1, (char const   *)tmp___2, proxy);
#line 662
        url_free(proxy_url);
#line 663
        checking_free((void *)url);
        }
        {
#line 664
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 664
          if (post_data_suspended) {
#line 664
            opt.post_data = saved_post_data;
#line 664
            opt.post_file_name = saved_post_file_name;
#line 664
            post_data_suspended = (_Bool)0;
          }
#line 664
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 665
        return ((uerr_t )49);
      }
    }
  }
#line 669
  if ((unsigned int )u->scheme == 0U) {
    {
#line 675
    result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
    }
  } else
#line 669
  if ((unsigned int )u->scheme == 1U) {
    {
#line 675
    result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
    }
  } else
#line 669
  if (proxy_url) {
#line 669
    if ((unsigned int )proxy_url->scheme == 0U) {
      {
#line 675
      result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
      }
    } else {
#line 669
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 677
  if ((unsigned int )u->scheme == 2U) {
#line 682
    oldrec = recursive;
#line 682
    glob = opt.ftp_glob;
#line 683
    if (redirection_count) {
#line 684
      glob = (_Bool)0;
#line 684
      oldrec = glob;
    }
    {
#line 686
    result = ftp_loop(u, dt, proxy_url, recursive, glob);
#line 687
    recursive = oldrec;
    }
#line 693
    if (redirection_count) {
#line 693
      if (local_file) {
#line 693
        if ((unsigned int )u->scheme == 2U) {
          {
#line 695
          tmp___3 = has_html_suffix_p((char const   *)local_file);
          }
#line 695
          if (tmp___3) {
#line 696
            *dt |= 1;
          }
        }
      }
    }
  }
#line 700
  if (proxy_url) {
    {
#line 702
    url_free(proxy_url);
#line 703
    proxy_url = (struct url *)((void *)0);
    }
  }
#line 706
  location_changed = (_Bool )((unsigned int )result == 6U);
#line 707
  if (location_changed) {
#line 712
    if (! ((unsigned long )mynewloc != (unsigned long )((void *)0))) {
      {
#line 712
      __assert_fail("mynewloc != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c",
                    712U, "retrieve_url");
      }
    }
#line 714
    if (local_file) {
      {
#line 715
      checking_free((void *)local_file);
      }
    }
    {
#line 721
    construced_newloc = uri_merge((char const   *)url, (char const   *)mynewloc);
#line 722
    checking_free((void *)mynewloc);
#line 723
    mynewloc = construced_newloc;
#line 726
    newloc_parsed = url_parse((char const   *)mynewloc, & up_error_code);
    }
#line 727
    if (! newloc_parsed) {
      {
#line 729
      tmp___5 = url_error(up_error_code);
#line 729
      tmp___6 = escnonprint_uri((char const   *)mynewloc);
#line 729
      logprintf((enum log_options )1, "%s: %s.\n", tmp___6, tmp___5);
#line 731
      url_free(u);
#line 732
      checking_free((void *)url);
#line 733
      checking_free((void *)mynewloc);
      }
      {
#line 734
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 734
        if (post_data_suspended) {
#line 734
          opt.post_data = saved_post_data;
#line 734
          opt.post_file_name = saved_post_file_name;
#line 734
          post_data_suspended = (_Bool)0;
        }
#line 734
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 735
      return (result);
    }
    {
#line 741
    checking_free((void *)mynewloc);
#line 742
    mynewloc = checking_strdup((char const   *)newloc_parsed->url);
#line 745
    redirection_count ++;
    }
#line 745
    if (redirection_count > opt.max_redirect) {
      {
#line 747
      tmp___7 = gettext("%d redirections exceeded.\n");
#line 747
      logprintf((enum log_options )1, (char const   *)tmp___7, opt.max_redirect);
#line 749
      url_free(newloc_parsed);
#line 750
      url_free(u);
#line 751
      checking_free((void *)url);
#line 752
      checking_free((void *)mynewloc);
      }
      {
#line 753
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 753
        if (post_data_suspended) {
#line 753
          opt.post_data = saved_post_data;
#line 753
          opt.post_file_name = saved_post_file_name;
#line 753
          post_data_suspended = (_Bool)0;
        }
#line 753
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 754
      return ((uerr_t )34);
    }
    {
#line 757
    checking_free((void *)url);
#line 758
    url = mynewloc;
#line 759
    url_free(u);
#line 760
    u = newloc_parsed;
    }
#line 767
    if (! post_data_suspended) {
      {
#line 768
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 768
        post_data_suspended = (_Bool)1;
#line 768
        saved_post_data = opt.post_data;
#line 768
        saved_post_file_name = opt.post_file_name;
#line 768
        opt.post_data = (char *)((void *)0);
#line 768
        opt.post_file_name = (char *)((void *)0);
#line 768
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 770
    goto redirected;
  }
#line 773
  if (local_file) {
#line 775
    if (*dt & 2) {
      {
#line 777
      register_download((char const   *)u->url, (char const   *)local_file);
      }
#line 778
      if (redirection_count) {
        {
#line 778
        tmp___8 = strcmp(origurl, (char const   *)u->url);
        }
#line 778
        if (0 != tmp___8) {
          {
#line 779
          register_redirection(origurl, (char const   *)u->url);
          }
        }
      }
#line 780
      if (*dt & 1) {
        {
#line 781
        register_html((char const   *)u->url, (char const   *)local_file);
        }
      }
    }
  }
#line 785
  if (file) {
#line 786
    if (local_file) {
#line 786
      *file = local_file;
    } else {
#line 786
      *file = (char *)((void *)0);
    }
  } else
#line 788
  if (! (! local_file)) {
    {
#line 788
    checking_free((void *)local_file);
    }
  }
  {
#line 790
  url_free(u);
  }
#line 792
  if (redirection_count) {
#line 794
    if (newloc) {
#line 795
      *newloc = url;
    } else {
      {
#line 797
      checking_free((void *)url);
      }
    }
  } else {
#line 801
    if (newloc) {
#line 802
      *newloc = (char *)((void *)0);
    }
    {
#line 803
    checking_free((void *)url);
    }
  }
  {
#line 806
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 806
    if (post_data_suspended) {
#line 806
      opt.post_data = saved_post_data;
#line 806
      opt.post_file_name = saved_post_file_name;
#line 806
      post_data_suspended = (_Bool)0;
    }
#line 806
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 808
  return (result);
}
}
#line 817 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
uerr_t retrieve_from_file(char const   *file , _Bool html , int *count ) 
{ 
  uerr_t status ;
  struct urlpos *url_list ;
  struct urlpos *cur_url ;
  struct urlpos *tmp ;
  struct urlpos *tmp___0 ;
  char *filename ;
  char *new_file ;
  int dt ;
  int old_follow_ftp ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;

  {
#line 823
  if (html) {
    {
#line 823
    tmp = get_urls_html(file, (char const   *)((void *)0), (_Bool *)((void *)0));
#line 823
    url_list = tmp;
    }
  } else {
    {
#line 823
    tmp___0 = get_urls_file(file);
#line 823
    url_list = tmp___0;
    }
  }
#line 825
  status = (uerr_t )31;
#line 826
  *count = 0;
#line 828
  cur_url = url_list;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cur_url) {
#line 828
      goto while_break;
    }
#line 830
    filename = (char *)((void *)0);
#line 830
    new_file = (char *)((void *)0);
#line 833
    if (cur_url->ignore_when_downloading) {
#line 834
      goto __Cont;
    }
#line 836
    if (opt.quota) {
#line 836
      if (total_downloaded_bytes > opt.quota) {
#line 838
        status = (uerr_t )51;
#line 839
        goto while_break;
      }
    }
#line 841
    if (opt.recursive) {
#line 841
      goto _L___0;
    } else
#line 841
    if (opt.page_requisites) {
      _L___0: /* CIL Label */ 
#line 841
      if ((unsigned int )(cur_url->url)->scheme != 2U) {
#line 841
        goto _L;
      } else {
        {
#line 841
        tmp___1 = getproxy(cur_url->url);
        }
#line 841
        if (tmp___1) {
          _L: /* CIL Label */ 
#line 844
          old_follow_ftp = (int )opt.follow_ftp;
#line 847
          if ((unsigned int )(cur_url->url)->scheme == 2U) {
#line 848
            opt.follow_ftp = (_Bool)1;
          }
          {
#line 850
          status = retrieve_tree((char const   *)(cur_url->url)->url);
#line 852
          opt.follow_ftp = (_Bool )old_follow_ftp;
          }
        } else {
          {
#line 855
          status = retrieve_url((char const   *)(cur_url->url)->url, & filename, & new_file,
                                (char const   *)((void *)0), & dt, opt.recursive);
          }
        }
      }
    } else {
      {
#line 855
      status = retrieve_url((char const   *)(cur_url->url)->url, & filename, & new_file,
                            (char const   *)((void *)0), & dt, opt.recursive);
      }
    }
#line 857
    if (filename) {
#line 857
      if (opt.delete_after) {
        {
#line 857
        tmp___7 = file_exists_p((char const   *)filename);
        }
#line 857
        if (tmp___7) {
          {
#line 859
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 859
            tmp___2 = __builtin_expect((long )opt.debug, 0L);
            }
#line 859
            if (tmp___2) {
              {
#line 859
              debug_logprintf("Removing file due to --delete-after in retrieve_from_file():\n");
              }
            }
#line 859
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 861
          tmp___3 = gettext("Removing %s.\n");
#line 861
          logprintf((enum log_options )0, (char const   *)tmp___3, filename);
#line 862
          tmp___6 = unlink((char const   *)filename);
          }
#line 862
          if (tmp___6) {
            {
#line 863
            tmp___4 = __errno_location();
#line 863
            tmp___5 = strerror(*tmp___4);
#line 863
            logprintf((enum log_options )1, "unlink: %s\n", tmp___5);
            }
          }
#line 864
          dt &= -3;
        }
      }
    }
#line 867
    if (! (! new_file)) {
      {
#line 867
      checking_free((void *)new_file);
      }
    }
#line 868
    if (! (! filename)) {
      {
#line 868
      checking_free((void *)filename);
      }
    }
    __Cont: /* CIL Label */ 
#line 828
    cur_url = cur_url->next;
#line 828
    (*count) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 872
  free_urlpos(url_list);
  }
#line 874
  return (status);
}
}
#line 879 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
void printwhat(int n1 , int n2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 882
  if (n1 == n2) {
    {
#line 882
    tmp = gettext("Giving up.\n\n");
#line 882
    tmp___1 = tmp;
    }
  } else {
    {
#line 882
    tmp___0 = gettext("Retrying.\n\n");
#line 882
    tmp___1 = tmp___0;
    }
  }
  {
#line 882
  logputs((enum log_options )0, (char const   *)tmp___1);
  }
#line 883
  return;
}
}
#line 894 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static _Bool first_retrieval  =    (_Bool)1;
#line 891 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
void sleep_between_retrievals(int count ) 
{ 
  double waitsecs ;
  double tmp ;
  long tmp___0 ;

  {
#line 896
  if (first_retrieval) {
#line 899
    first_retrieval = (_Bool)0;
#line 900
    return;
  }
#line 903
  if (opt.waitretry) {
#line 903
    if (count > 1) {
#line 907
      if ((double )count <= opt.waitretry) {
        {
#line 908
        xsleep((double )(count - 1));
        }
      } else {
        {
#line 910
        xsleep(opt.waitretry);
        }
      }
    } else {
#line 903
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 912
  if (opt.wait) {
#line 914
    if (! opt.random_wait) {
      {
#line 918
      xsleep(opt.wait);
      }
    } else
#line 914
    if (count > 1) {
      {
#line 918
      xsleep(opt.wait);
      }
    } else {
      {
#line 924
      tmp = random_float();
#line 924
      waitsecs = (0.5 + tmp) * opt.wait;
      }
      {
#line 925
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 925
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 925
        if (tmp___0) {
          {
#line 925
          debug_logprintf("sleep_between_retrievals: avg=%f,sleep=%f\n", opt.wait,
                          waitsecs);
          }
        }
#line 925
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 927
      xsleep(waitsecs);
      }
    }
  }
#line 930
  return;
}
}
#line 933 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
void free_urlpos(struct urlpos *l ) 
{ 
  struct urlpos *next ;

  {
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! l) {
#line 936
      goto while_break;
    }
#line 938
    next = l->next;
#line 939
    if (l->url) {
      {
#line 940
      url_free(l->url);
      }
    }
#line 941
    if (! (! l->local_name)) {
      {
#line 941
      checking_free((void *)l->local_name);
      }
    }
    {
#line 942
    checking_free((void *)l);
#line 943
    l = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 945
  return;
}
}
#line 948 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
void rotate_backups(char const   *fname ) 
{ 
  int maxlen ;
  size_t tmp ;
  int tmp___0 ;
  char *from ;
  void *tmp___1 ;
  char *to ;
  void *tmp___2 ;
  struct stat sb ;
  int i ;
  int tmp___3 ;

  {
  {
#line 951
  tmp = strlen(fname);
#line 951
  tmp___0 = numdigit((wgint )opt.backups);
#line 951
  maxlen = (int )(((tmp + 1UL) + (size_t )tmp___0) + 1UL);
#line 952
  tmp___1 = __builtin_alloca((unsigned long )maxlen);
#line 952
  from = (char *)tmp___1;
#line 953
  tmp___2 = __builtin_alloca((unsigned long )maxlen);
#line 953
  to = (char *)tmp___2;
#line 957
  tmp___3 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& sb));
  }
#line 957
  if (tmp___3 == 0) {
#line 958
    if (((sb.st_mode & 61440U) == 32768U) == 0) {
#line 959
      return;
    }
  }
#line 961
  i = (int )opt.backups;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (i > 1)) {
#line 961
      goto while_break;
    }
    {
#line 963
    sprintf((char */* __restrict  */)from, (char const   */* __restrict  */)"%s.%d",
            fname, i - 1);
#line 964
    sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%s.%d",
            fname, i);
#line 965
    rename((char const   *)from, (char const   *)to);
#line 961
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 968
  sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%s.%d", fname,
          1);
#line 969
  rename(fname, (char const   *)to);
  }
#line 970
  return;
}
}
#line 972
static _Bool no_proxy_match(char const   *host , char const   **no_proxy ) ;
#line 981 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char rewritten_storage[1024]  ;
#line 976 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static char *getproxy(struct url *u ) 
{ 
  char *proxy ;
  char *rewritten_url ;
  _Bool tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 979
  proxy = (char *)((void *)0);
#line 983
  if (! opt.use_proxy) {
#line 984
    return ((char *)((void *)0));
  }
  {
#line 985
  tmp = no_proxy_match((char const   *)u->host, (char const   **)opt.no_proxy);
  }
#line 985
  if (tmp) {
#line 986
    return ((char *)((void *)0));
  }
  {
#line 990
  if ((unsigned int )u->scheme == 0U) {
#line 990
    goto case_0;
  }
#line 994
  if ((unsigned int )u->scheme == 1U) {
#line 994
    goto case_1;
  }
#line 998
  if ((unsigned int )u->scheme == 2U) {
#line 998
    goto case_2;
  }
#line 1001
  if ((unsigned int )u->scheme == 3U) {
#line 1001
    goto case_3;
  }
#line 988
  goto switch_break;
  case_0: /* CIL Label */ 
#line 991
  if (opt.http_proxy) {
#line 991
    proxy = opt.http_proxy;
  } else {
    {
#line 991
    tmp___0 = getenv("http_proxy");
#line 991
    proxy = tmp___0;
    }
  }
#line 992
  goto switch_break;
  case_1: /* CIL Label */ 
#line 995
  if (opt.https_proxy) {
#line 995
    proxy = opt.https_proxy;
  } else {
    {
#line 995
    tmp___1 = getenv("https_proxy");
#line 995
    proxy = tmp___1;
    }
  }
#line 996
  goto switch_break;
  case_2: /* CIL Label */ 
#line 999
  if (opt.ftp_proxy) {
#line 999
    proxy = opt.ftp_proxy;
  } else {
    {
#line 999
    tmp___2 = getenv("ftp_proxy");
#line 999
    proxy = tmp___2;
    }
  }
#line 1000
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1002
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1004
  if (! proxy) {
#line 1005
    return ((char *)((void *)0));
  } else
#line 1004
  if (! *proxy) {
#line 1005
    return ((char *)((void *)0));
  }
  {
#line 1009
  rewritten_url = rewrite_shorthand_url((char const   *)proxy);
  }
#line 1010
  if (rewritten_url) {
    {
#line 1012
    strncpy((char */* __restrict  */)(rewritten_storage), (char const   */* __restrict  */)rewritten_url,
            sizeof(rewritten_storage));
#line 1013
    rewritten_storage[sizeof(rewritten_storage) - 1UL] = (char )'\000';
#line 1014
    proxy = rewritten_storage;
    }
  }
#line 1017
  return (proxy);
}
}
#line 1022 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
_Bool url_uses_proxy(char const   *url ) 
{ 
  _Bool ret ;
  struct url *u ;
  struct url *tmp ;
  char *tmp___0 ;

  {
  {
#line 1026
  tmp = url_parse(url, (int *)((void *)0));
#line 1026
  u = tmp;
  }
#line 1027
  if (! u) {
#line 1028
    return ((_Bool)0);
  }
  {
#line 1029
  tmp___0 = getproxy(u);
#line 1029
  ret = (_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0));
#line 1030
  url_free(u);
  }
#line 1031
  return (ret);
}
}
#line 1035 "/home/khheo/project/benchmark/wget-1.11.4/src/retr.c"
static _Bool no_proxy_match(char const   *host , char const   **no_proxy ) 
{ 
  _Bool tmp ;

  {
#line 1038
  if (! no_proxy) {
#line 1039
    return ((_Bool)0);
  } else {
    {
#line 1041
    tmp = sufmatch(no_proxy, host);
    }
#line 1041
    return (tmp);
  }
}
}
#line 39 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
void *hash_table_get(struct hash_table  const  *ht , void const   *key ) ;
#line 40
int hash_table_get_pair(struct hash_table  const  *ht , void const   *lookup_key ,
                        void *orig_key , void *value ) ;
#line 61
struct hash_table *make_nocase_string_hash_table(int items ) ;
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/res.h"
struct robot_specs *res_parse(char const   *source , int length ) ;
#line 36
struct robot_specs *res_parse_from_file(char const   *filename ) ;
#line 38
_Bool res_match_path(struct robot_specs  const  *specs , char const   *path ) ;
#line 40
void res_register_specs(char const   *host , int port , struct robot_specs *specs ) ;
#line 41
struct robot_specs *res_get_specs(char const   *host , int port ) ;
#line 43
_Bool res_retrieve_file(char const   *url , char **file ) ;
#line 47
void res_cleanup(void) ;
#line 109 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static void match_user_agent(char const   *agent , int length , _Bool *matches___0 ,
                             _Bool *exact_match ) 
{ 
  int tmp ;

  {
#line 113
  if (length == 1) {
#line 113
    if ((int const   )*agent == 42) {
#line 115
      *matches___0 = (_Bool)1;
#line 116
      *exact_match = (_Bool)0;
    } else {
#line 113
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 118
  if ((unsigned long )((agent + length) - agent) == sizeof("wget") - 1UL) {
    {
#line 118
    tmp = strncasecmp(agent, "wget", sizeof("wget") - 1UL);
    }
#line 118
    if (tmp) {
#line 125
      *matches___0 = (_Bool)0;
#line 126
      *exact_match = (_Bool)0;
    } else {
#line 120
      *matches___0 = (_Bool)1;
#line 121
      *exact_match = (_Bool)1;
    }
  } else {
#line 125
    *matches___0 = (_Bool)0;
#line 126
    *exact_match = (_Bool)0;
  }
#line 128
  return;
}
}
#line 133 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static void add_path(struct robot_specs *specs , char const   *path_b , char const   *path_e ,
                     _Bool allowedp , _Bool exactp ) 
{ 
  struct path_info pp ;
  void *tmp ;

  {
#line 138
  if ((unsigned long )path_b < (unsigned long )path_e) {
#line 138
    if ((int const   )*path_b == 47) {
#line 141
      path_b ++;
    }
  }
  {
#line 142
  pp.path = strdupdelim(path_b, path_e);
#line 143
  pp.allowedp = allowedp;
#line 144
  pp.user_agent_exact_p = exactp;
#line 145
  (specs->count) ++;
  }
#line 146
  if (specs->count > specs->size) {
#line 148
    if (specs->size == 0) {
#line 149
      specs->size = 1;
    } else {
#line 151
      specs->size <<= 1;
    }
    {
#line 152
    tmp = checking_realloc((void *)specs->paths, (unsigned long )specs->size * sizeof(struct path_info ));
#line 152
    specs->paths = (struct path_info *)tmp;
    }
  }
#line 155
  *(specs->paths + (specs->count - 1)) = pp;
#line 156
  return;
}
}
#line 161 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static void prune_non_exact(struct robot_specs *specs ) 
{ 
  struct path_info *newpaths ;
  int i ;
  int j ;
  int cnt ;
  void *tmp ;
  int tmp___0 ;

  {
#line 166
  cnt = 0;
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < specs->count)) {
#line 167
      goto while_break;
    }
#line 168
    if ((specs->paths + i)->user_agent_exact_p) {
#line 169
      cnt ++;
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tmp = checking_malloc((unsigned long )cnt * sizeof(struct path_info ));
#line 170
  newpaths = (struct path_info *)tmp;
#line 171
  i = 0;
#line 171
  j = 0;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < specs->count)) {
#line 171
      goto while_break___0;
    }
#line 172
    if ((specs->paths + i)->user_agent_exact_p) {
#line 173
      tmp___0 = j;
#line 173
      j ++;
#line 173
      *(newpaths + tmp___0) = *(specs->paths + i);
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  if (! (j == cnt)) {
    {
#line 174
    __assert_fail("j == cnt", "/home/khheo/project/benchmark/wget-1.11.4/src/res.c",
                  174U, "prune_non_exact");
    }
  }
  {
#line 175
  checking_free((void *)specs->paths);
#line 176
  specs->paths = newpaths;
#line 177
  specs->count = cnt;
#line 178
  specs->size = cnt;
  }
#line 179
  return;
}
}
#line 221 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
struct robot_specs *res_parse(char const   *source , int length ) 
{ 
  int line_count ;
  char const   *p___0 ;
  char const   *end ;
  _Bool user_agent_applies ;
  _Bool user_agent_exact ;
  _Bool found_exact ;
  int record_count ;
  struct robot_specs *specs ;
  void *tmp ;
  char const   *lineend ;
  char const   *lineend_real ;
  char const   *field_b ;
  char const   *field_e ;
  char const   *value_b ;
  char const   *value_e ;
  void *tmp___0 ;
  long tmp___2 ;
  _Bool allowed ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 224
  line_count = 1;
#line 226
  p___0 = source;
#line 227
  end = source + length;
#line 230
  user_agent_applies = (_Bool)0;
#line 234
  user_agent_exact = (_Bool)0;
#line 237
  found_exact = (_Bool)0;
#line 241
  record_count = 0;
#line 243
  tmp = checking_malloc0(sizeof(struct robot_specs ));
#line 243
  specs = (struct robot_specs *)tmp;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if ((unsigned long )p___0 == (unsigned long )end) {
#line 252
      goto while_break;
    }
    {
#line 253
    tmp___0 = memchr((void const   *)p___0, '\n', (size_t )(end - p___0));
#line 253
    lineend_real = (char const   *)tmp___0;
    }
#line 254
    if (lineend_real) {
#line 255
      lineend_real ++;
    } else {
#line 257
      lineend_real = end;
    }
#line 258
    lineend = lineend_real;
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 262
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 262
        if (! ((unsigned long )p___0 >= (unsigned long )lineend)) {
#line 262
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 262
            goto while_break___1;
          }
        } else {
#line 262
          goto while_break___1;
        }
#line 262
        p___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 262
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    if ((unsigned long )p___0 >= (unsigned long )lineend) {
#line 264
      goto next;
    } else
#line 263
    if ((int const   )*p___0 == 35) {
#line 264
      goto next;
    }
#line 269
    lineend = p___0;
    {
#line 269
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 269
      if (! ((unsigned long )lineend < (unsigned long )lineend_real)) {
#line 269
        goto while_break___2;
      }
#line 270
      if ((unsigned long )lineend == (unsigned long )p___0) {
#line 270
        goto _L;
      } else
#line 270
      if ((int const   )_sch_istable[(int const   )*(lineend - 1) & 255] & 64) {
        _L: /* CIL Label */ 
#line 270
        if ((int const   )*lineend == 35) {
#line 272
          goto while_break___2;
        }
      }
#line 269
      lineend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 275
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 275
      if ((unsigned long )lineend > (unsigned long )p___0) {
#line 275
        if (! ((int const   )_sch_istable[(int const   )*(lineend - 1) & 255] & 64)) {
#line 275
          goto while_break___3;
        }
      } else {
#line 275
        goto while_break___3;
      }
#line 276
      lineend --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 278
    if (! (! ((unsigned long )p___0 >= (unsigned long )lineend))) {
      {
#line 278
      __assert_fail("!EOL (p)", "/home/khheo/project/benchmark/wget-1.11.4/src/res.c",
                    278U, "res_parse");
      }
    }
#line 280
    field_b = p___0;
    {
#line 281
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 281
      if (! ((unsigned long )p___0 >= (unsigned long )lineend)) {
#line 281
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 140)) {
#line 281
          if (! ((int const   )*p___0 == 45)) {
#line 281
            goto while_break___4;
          }
        }
      } else {
#line 281
        goto while_break___4;
      }
#line 282
      p___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 283
    field_e = p___0;
    {
#line 285
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 285
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 285
        if (! ((unsigned long )p___0 >= (unsigned long )lineend)) {
#line 285
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 285
            goto while_break___6;
          }
        } else {
#line 285
          goto while_break___6;
        }
#line 285
        p___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 285
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 286
    if ((unsigned long )field_b == (unsigned long )field_e) {
#line 286
      goto _L___0;
    } else
#line 286
    if ((unsigned long )p___0 >= (unsigned long )lineend) {
#line 286
      goto _L___0;
    } else
#line 286
    if ((int const   )*p___0 != 58) {
      _L___0: /* CIL Label */ 
      {
#line 288
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 288
        tmp___2 = __builtin_expect((long )opt.debug, 0L);
        }
#line 288
        if (tmp___2) {
          {
#line 288
          debug_logprintf("Ignoring malformed line %d", line_count);
          }
        }
#line 288
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 289
      goto next;
    }
#line 291
    p___0 ++;
    {
#line 292
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 292
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 292
        if (! ((unsigned long )p___0 >= (unsigned long )lineend)) {
#line 292
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 292
            goto while_break___9;
          }
        } else {
#line 292
          goto while_break___9;
        }
#line 292
        p___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 292
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 294
    value_b = p___0;
    {
#line 295
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 295
      if (! (! ((unsigned long )p___0 >= (unsigned long )lineend))) {
#line 295
        goto while_break___10;
      }
#line 296
      p___0 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 297
    value_e = p___0;
#line 300
    if ((unsigned long )(field_e - field_b) == sizeof("user-agent") - 1UL) {
      {
#line 300
      tmp___6 = strncasecmp(field_b, "user-agent", sizeof("user-agent") - 1UL);
      }
#line 300
      if (tmp___6) {
#line 300
        goto _L___3;
      } else {
#line 327
        if (record_count != 0) {
          {
#line 328
          match_user_agent(value_b, (int )(value_e - value_b), & user_agent_applies,
                           & user_agent_exact);
          }
        } else
#line 327
        if ((int )user_agent_applies == 0) {
          {
#line 328
          match_user_agent(value_b, (int )(value_e - value_b), & user_agent_applies,
                           & user_agent_exact);
          }
        }
#line 330
        if (user_agent_exact) {
#line 331
          found_exact = (_Bool)1;
        }
#line 332
        record_count = 0;
      }
    } else
    _L___3: /* CIL Label */ 
#line 334
    if ((unsigned long )(field_e - field_b) == sizeof("allow") - 1UL) {
      {
#line 334
      tmp___5 = strncasecmp(field_b, "allow", sizeof("allow") - 1UL);
      }
#line 334
      if (tmp___5) {
#line 334
        goto _L___2;
      } else {
#line 336
        if (user_agent_applies) {
          {
#line 338
          add_path(specs, value_b, value_e, (_Bool)1, user_agent_exact);
          }
        }
#line 340
        record_count ++;
      }
    } else
    _L___2: /* CIL Label */ 
#line 342
    if ((unsigned long )(field_e - field_b) == sizeof("disallow") - 1UL) {
      {
#line 342
      tmp___4 = strncasecmp(field_b, "disallow", sizeof("disallow") - 1UL);
      }
#line 342
      if (tmp___4) {
#line 342
        goto _L___1;
      } else {
#line 344
        if (user_agent_applies) {
#line 346
          allowed = (_Bool)0;
#line 347
          if ((unsigned long )value_b == (unsigned long )value_e) {
#line 349
            allowed = (_Bool)1;
          }
          {
#line 350
          add_path(specs, value_b, value_e, allowed, user_agent_exact);
          }
        }
#line 352
        record_count ++;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 356
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 356
        tmp___3 = __builtin_expect((long )opt.debug, 0L);
        }
#line 356
        if (tmp___3) {
          {
#line 356
          debug_logprintf("Ignoring unknown field at line %d", line_count);
          }
        }
#line 356
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 357
      goto next;
    }
    next: 
#line 361
    p___0 = lineend_real;
#line 362
    line_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (found_exact) {
    {
#line 369
    prune_non_exact(specs);
    }
  } else
#line 371
  if (specs->size > specs->count) {
    {
#line 375
    tmp___7 = checking_realloc((void *)specs->paths, (unsigned long )specs->count * sizeof(struct path_info ));
#line 375
    specs->paths = (struct path_info *)tmp___7;
#line 377
    specs->size = specs->count;
    }
  }
#line 380
  return (specs);
}
}
#line 386 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
struct robot_specs *res_parse_from_file(char const   *filename ) 
{ 
  struct robot_specs *specs ;
  struct file_memory *fm ;
  struct file_memory *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 390
  tmp = read_file(filename);
#line 390
  fm = tmp;
  }
#line 391
  if (! fm) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    tmp___1 = strerror(*tmp___0);
#line 393
    tmp___2 = gettext("Cannot open %s: %s");
#line 393
    logprintf((enum log_options )1, (char const   *)tmp___2, filename, tmp___1);
    }
#line 395
    return ((struct robot_specs *)((void *)0));
  }
  {
#line 397
  specs = res_parse((char const   *)fm->content, (int )fm->length);
#line 398
  read_file_free(fm);
  }
#line 399
  return (specs);
}
}
#line 402 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static void free_specs(struct robot_specs *specs ) 
{ 
  int i ;

  {
#line 406
  i = 0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i < specs->count)) {
#line 406
      goto while_break;
    }
    {
#line 407
    checking_free((void *)(specs->paths + i)->path);
#line 406
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  if (! (! specs->paths)) {
    {
#line 408
    checking_free((void *)specs->paths);
    }
  }
  {
#line 409
  checking_free((void *)specs);
  }
#line 410
  return;
}
}
#line 434 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static _Bool matches(char const   *record_path , char const   *url_path ) 
{ 
  char const   *rp ;
  char const   *up ;
  char rc ;
  char uc ;
  char decoded ;
  int tmp ;
  int tmp___0 ;
  char decoded___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 437
  rp = record_path;
#line 438
  up = url_path;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    rc = (char )*rp;
#line 443
    uc = (char )*up;
#line 444
    if (! rc) {
#line 445
      return ((_Bool)1);
    }
#line 446
    if (! uc) {
#line 447
      return ((_Bool)0);
    }
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 448
      if ((int )rc == 37) {
#line 448
        if ((int const   )_sch_istable[(int const   )*(rp + 1) & 255] & 256) {
#line 448
          if ((int const   )_sch_istable[(int const   )*(rp + 2) & 255] & 256) {
#line 448
            if ((int const   )*(rp + 1) < 65) {
#line 448
              tmp = (int const   )*(rp + 1) - 48;
            } else {
#line 448
              tmp = ((int const   )_sch_toupper[(int const   )*(rp + 1) & 255] - 65) + 10;
            }
#line 448
            if ((int const   )*(rp + 2) < 65) {
#line 448
              tmp___0 = (int const   )*(rp + 2) - 48;
            } else {
#line 448
              tmp___0 = ((int const   )_sch_toupper[(int const   )*(rp + 2) & 255] - 65) + 10;
            }
#line 448
            decoded = (char )((tmp << 4) + tmp___0);
#line 448
            if ((int )decoded != 47) {
#line 448
              rc = decoded;
#line 448
              rp += 2;
            }
          }
        }
      }
#line 448
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 449
      if ((int )uc == 37) {
#line 449
        if ((int const   )_sch_istable[(int const   )*(up + 1) & 255] & 256) {
#line 449
          if ((int const   )_sch_istable[(int const   )*(up + 2) & 255] & 256) {
#line 449
            if ((int const   )*(up + 1) < 65) {
#line 449
              tmp___1 = (int const   )*(up + 1) - 48;
            } else {
#line 449
              tmp___1 = ((int const   )_sch_toupper[(int const   )*(up + 1) & 255] - 65) + 10;
            }
#line 449
            if ((int const   )*(up + 2) < 65) {
#line 449
              tmp___2 = (int const   )*(up + 2) - 48;
            } else {
#line 449
              tmp___2 = ((int const   )_sch_toupper[(int const   )*(up + 2) & 255] - 65) + 10;
            }
#line 449
            decoded___0 = (char )((tmp___1 << 4) + tmp___2);
#line 449
            if ((int )decoded___0 != 47) {
#line 449
              uc = decoded___0;
#line 449
              up += 2;
            }
          }
        }
      }
#line 449
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 450
    if ((int )rc != (int )uc) {
#line 451
      return ((_Bool)0);
    }
#line 440
    rp ++;
#line 440
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 459 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
_Bool res_match_path(struct robot_specs  const  *specs , char const   *path ) 
{ 
  int i ;
  _Bool allowedp ;
  char const   *tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;

  {
#line 463
  if (! specs) {
#line 464
    return ((_Bool)1);
  }
#line 465
  i = 0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < (int )specs->count)) {
#line 465
      goto while_break;
    }
    {
#line 466
    tmp___1 = matches((char const   *)(specs->paths + i)->path, path);
    }
#line 466
    if (tmp___1) {
#line 468
      allowedp = (specs->paths + i)->allowedp;
      {
#line 469
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 469
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 469
        if (tmp___0) {
#line 469
          if (allowedp) {
#line 469
            tmp = "Allowing";
          } else {
#line 469
            tmp = "Rejecting";
          }
          {
#line 469
          debug_logprintf("%s path %s because of rule `%s\'.\n", tmp, path, (specs->paths + i)->path);
          }
        }
#line 469
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 472
      return (allowedp);
    }
#line 465
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return ((_Bool)1);
}
}
#line 479 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
static struct hash_table *registered_specs  ;
#line 493 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
void res_register_specs(char const   *host , int port , struct robot_specs *specs ) 
{ 
  struct robot_specs *old ;
  char *hp ;
  char *hp_old ;
  int HP_len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 498
    tmp = strlen(host);
#line 498
    HP_len = (int )tmp;
#line 498
    tmp___0 = numdigit((wgint )port);
#line 498
    tmp___1 = __builtin_alloca((unsigned long )(((HP_len + 1) + tmp___0) + 1));
#line 498
    hp = (char *)tmp___1;
#line 498
    memcpy((void */* __restrict  */)hp, (void const   */* __restrict  */)host, (size_t )HP_len);
#line 498
    *(hp + HP_len) = (char )':';
#line 498
    number_to_string((hp + HP_len) + 1, (wgint )port);
    }
#line 498
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  if (! registered_specs) {
    {
#line 501
    registered_specs = make_nocase_string_hash_table(0);
    }
  }
  {
#line 503
  tmp___3 = hash_table_get_pair((struct hash_table  const  *)registered_specs, (void const   *)hp,
                                (void *)(& hp_old), (void *)(& old));
  }
#line 503
  if (tmp___3) {
#line 505
    if (old) {
      {
#line 506
      free_specs(old);
      }
    }
    {
#line 507
    hash_table_put(registered_specs, (void const   *)hp_old, (void *)specs);
    }
  } else {
    {
#line 511
    tmp___2 = checking_strdup((char const   *)hp);
#line 511
    hash_table_put(registered_specs, (void const   *)tmp___2, (void *)specs);
    }
  }
#line 513
  return;
}
}
#line 517 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
struct robot_specs *res_get_specs(char const   *host , int port ) 
{ 
  char *hp ;
  int HP_len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    tmp = strlen(host);
#line 521
    HP_len = (int )tmp;
#line 521
    tmp___0 = numdigit((wgint )port);
#line 521
    tmp___1 = __builtin_alloca((unsigned long )(((HP_len + 1) + tmp___0) + 1));
#line 521
    hp = (char *)tmp___1;
#line 521
    memcpy((void */* __restrict  */)hp, (void const   */* __restrict  */)host, (size_t )HP_len);
#line 521
    *(hp + HP_len) = (char )':';
#line 521
    number_to_string((hp + HP_len) + 1, (wgint )port);
    }
#line 521
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if (! registered_specs) {
#line 523
    return ((struct robot_specs *)((void *)0));
  }
  {
#line 524
  tmp___2 = hash_table_get((struct hash_table  const  *)registered_specs, (void const   *)hp);
  }
#line 524
  return ((struct robot_specs *)tmp___2);
}
}
#line 537 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
_Bool res_retrieve_file(char const   *url , char **file ) 
{ 
  uerr_t err ;
  char *robots_url ;
  char *tmp ;
  int saved_ts_val ;
  int saved_sp_val ;
  char *tmp___0 ;

  {
  {
#line 541
  tmp = uri_merge(url, "/robots.txt");
#line 541
  robots_url = tmp;
#line 542
  saved_ts_val = (int )opt.timestamping;
#line 543
  saved_sp_val = (int )opt.spider;
#line 545
  tmp___0 = gettext("Loading robots.txt; please ignore errors.\n");
#line 545
  logputs((enum log_options )0, (char const   *)tmp___0);
#line 546
  *file = (char *)((void *)0);
#line 547
  opt.timestamping = (_Bool)0;
#line 548
  opt.spider = (_Bool)0;
#line 549
  err = retrieve_url((char const   *)robots_url, file, (char **)((void *)0), (char const   *)((void *)0),
                     (int *)((void *)0), (_Bool)0);
#line 550
  opt.timestamping = (_Bool )saved_ts_val;
#line 551
  opt.spider = (_Bool )saved_sp_val;
#line 552
  checking_free((void *)robots_url);
  }
#line 554
  if ((unsigned int )err != 31U) {
#line 554
    if ((unsigned long )*file != (unsigned long )((void *)0)) {
      {
#line 559
      checking_free((void *)*file);
#line 560
      *file = (char *)((void *)0);
      }
    }
  }
#line 562
  return ((_Bool )((unsigned int )err == 31U));
}
}
#line 565 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
_Bool is_robots_txt_url(char const   *url ) 
{ 
  char *robots_url ;
  char *tmp ;
  _Bool ret ;
  _Bool tmp___0 ;

  {
  {
#line 568
  tmp = uri_merge(url, "/robots.txt");
#line 568
  robots_url = tmp;
#line 569
  tmp___0 = are_urls_equal(url, (char const   *)robots_url);
#line 569
  ret = tmp___0;
#line 571
  checking_free((void *)robots_url);
  }
#line 573
  return (ret);
}
}
#line 576 "/home/khheo/project/benchmark/wget-1.11.4/src/res.c"
void res_cleanup(void) 
{ 
  hash_table_iterator iter ;
  int tmp ;

  {
#line 579
  if (registered_specs) {
    {
#line 582
    hash_table_iterate(registered_specs, & iter);
    }
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 582
      tmp = hash_table_iter_next(& iter);
      }
#line 582
      if (! tmp) {
#line 582
        goto while_break;
      }
      {
#line 586
      checking_free(iter.key);
#line 587
      free_specs((struct robot_specs *)iter.value);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 589
    hash_table_destroy(registered_specs);
#line 590
    registered_specs = (struct hash_table *)((void *)0);
    }
  }
#line 592
  return;
}
}
#line 96 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
_Bool accept_domain(struct url *u ) ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
struct hash_table *dl_url_file_map ;
#line 35
struct hash_table *downloaded_html_set ;
#line 101
void register_delete_file(char const   *file ) ;
#line 74 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static struct url_queue *url_queue_new(void) 
{ 
  struct url_queue *queue ;
  void *tmp ;

  {
  {
#line 77
  tmp = checking_malloc0(sizeof(struct url_queue ));
#line 77
  queue = (struct url_queue *)tmp;
  }
#line 78
  return (queue);
}
}
#line 83 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static void url_queue_delete(struct url_queue *queue ) 
{ 


  {
  {
#line 86
  checking_free((void *)queue);
  }
#line 87
  return;
}
}
#line 93 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static void url_enqueue(struct url_queue *queue , char const   *url , char const   *referer ,
                        int depth___0 , _Bool html_allowed ) 
{ 
  struct queue_element *qel ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 97
  tmp = checking_malloc(sizeof(struct queue_element ));
#line 97
  qel = (struct queue_element *)tmp;
#line 98
  qel->url = url;
#line 99
  qel->referer = referer;
#line 100
  qel->depth = depth___0;
#line 101
  qel->html_allowed = html_allowed;
#line 102
  qel->next = (struct queue_element *)((void *)0);
#line 104
  (queue->count) ++;
  }
#line 105
  if (queue->count > queue->maxcount) {
#line 106
    queue->maxcount = queue->count;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp___0 = __builtin_expect((long )opt.debug, 0L);
    }
#line 108
    if (tmp___0) {
      {
#line 108
      debug_logprintf("Enqueuing %s at depth %d\n", url, depth___0);
      }
    }
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___1 = __builtin_expect((long )opt.debug, 0L);
    }
#line 109
    if (tmp___1) {
      {
#line 109
      debug_logprintf("Queue count %d, maxcount %d.\n", queue->count, queue->maxcount);
      }
    }
#line 109
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  if (queue->tail) {
#line 112
    (queue->tail)->next = qel;
  }
#line 113
  queue->tail = qel;
#line 115
  if (! queue->head) {
#line 116
    queue->head = queue->tail;
  }
#line 117
  return;
}
}
#line 122 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static _Bool url_dequeue(struct url_queue *queue , char const   **url , char const   **referer ,
                         int *depth___0 , _Bool *html_allowed ) 
{ 
  struct queue_element *qel ;
  long tmp ;
  long tmp___0 ;

  {
#line 127
  qel = queue->head;
#line 129
  if (! qel) {
#line 130
    return ((_Bool)0);
  }
#line 132
  queue->head = (queue->head)->next;
#line 133
  if (! queue->head) {
#line 134
    queue->tail = (struct queue_element *)((void *)0);
  }
#line 136
  *url = qel->url;
#line 137
  *referer = qel->referer;
#line 138
  *depth___0 = qel->depth;
#line 139
  *html_allowed = qel->html_allowed;
#line 141
  (queue->count) --;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 143
    if (tmp) {
      {
#line 143
      debug_logprintf("Dequeuing %s at depth %d\n", qel->url, qel->depth);
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 144
    tmp___0 = __builtin_expect((long )opt.debug, 0L);
    }
#line 144
    if (tmp___0) {
      {
#line 144
      debug_logprintf("Queue count %d, maxcount %d.\n", queue->count, queue->maxcount);
      }
    }
#line 144
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  checking_free((void *)qel);
  }
#line 147
  return ((_Bool)1);
}
}
#line 150
static _Bool download_child_p(struct urlpos  const  *upos , struct url *parent , int depth___0 ,
                              struct url *start_url_parsed , struct hash_table *blacklist ) ;
#line 152
static _Bool descend_redirect_p(char const   *redirected , char const   *original ,
                                int depth___0 , struct url *start_url_parsed , struct hash_table *blacklist ) ;
#line 177 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
uerr_t retrieve_tree(char const   *start_url ) 
{ 
  uerr_t status ;
  struct url_queue *queue ;
  struct hash_table *blacklist ;
  int up_error_code ;
  struct url *start_url_parsed ;
  struct url *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  _Bool descend ;
  char *url ;
  char *referer ;
  char *file ;
  int depth___0 ;
  _Bool html_allowed ;
  _Bool dash_p_leaf_HTML ;
  _Bool tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int dt ;
  char *redirected ;
  _Bool tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  _Bool meta_disallow_follow ;
  struct urlpos *children ;
  struct urlpos *tmp___9 ;
  struct urlpos *child ;
  struct url *url_parsed ;
  char *referer_url ;
  _Bool strip_auth ;
  int tmp___10 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  long tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  char *d1 ;
  char *d2 ;
  int d3 ;
  _Bool d4 ;
  _Bool tmp___25 ;

  {
  {
#line 180
  status = (uerr_t )31;
#line 190
  tmp = url_parse(start_url, & up_error_code);
#line 190
  start_url_parsed = tmp;
  }
#line 192
  if (! start_url_parsed) {
    {
#line 194
    tmp___0 = url_error(up_error_code);
#line 194
    logprintf((enum log_options )1, "%s: %s.\n", start_url, tmp___0);
    }
#line 196
    return ((uerr_t )23);
  }
  {
#line 199
  queue = url_queue_new();
#line 200
  blacklist = make_string_hash_table(0);
#line 204
  tmp___1 = checking_strdup((char const   *)start_url_parsed->url);
#line 204
  url_enqueue(queue, (char const   *)tmp___1, (char const   *)((void *)0), 0, (_Bool)1);
#line 205
  string_set_add(blacklist, (char const   *)start_url_parsed->url);
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    descend = (_Bool)0;
#line 210
    file = (char *)((void *)0);
#line 213
    dash_p_leaf_HTML = (_Bool)0;
#line 215
    if (opt.quota) {
#line 215
      if (total_downloaded_bytes > opt.quota) {
#line 216
        goto while_break;
      }
    }
#line 217
    if ((unsigned int )status == 26U) {
#line 218
      goto while_break;
    }
    {
#line 222
    tmp___2 = url_dequeue(queue, (char const   **)(& url), (char const   **)(& referer),
                          & depth___0, & html_allowed);
    }
#line 222
    if (! tmp___2) {
#line 225
      goto while_break;
    }
#line 235
    if (dl_url_file_map) {
      {
#line 235
      tmp___7 = hash_table_contains((struct hash_table  const  *)dl_url_file_map,
                                    (void const   *)url);
      }
#line 235
      if (tmp___7) {
        {
#line 237
        tmp___3 = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)url);
#line 237
        file = checking_strdup((char const   *)tmp___3);
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          tmp___4 = __builtin_expect((long )opt.debug, 0L);
          }
#line 239
          if (tmp___4) {
            {
#line 239
            debug_logprintf("Already downloaded \"%s\", reusing it from \"%s\".\n",
                            url, file);
            }
          }
#line 239
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 242
        if (html_allowed) {
#line 242
          if (downloaded_html_set) {
            {
#line 242
            tmp___5 = string_set_contains(downloaded_html_set, (char const   *)file);
            }
#line 242
            if (tmp___5) {
#line 245
              descend = (_Bool)1;
            }
          }
        }
      } else {
#line 235
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 249
      dt = 0;
#line 250
      redirected = (char *)((void *)0);
#line 252
      status = retrieve_url((char const   *)url, & file, & redirected, (char const   *)referer,
                            & dt, (_Bool)0);
      }
#line 254
      if (html_allowed) {
#line 254
        if (file) {
#line 254
          if ((unsigned int )status == 31U) {
#line 254
            if (dt & 2) {
#line 254
              if (dt & 1) {
#line 256
                descend = (_Bool)1;
              }
            }
          }
        }
      }
#line 258
      if (redirected) {
#line 263
        if (descend) {
          {
#line 265
          tmp___6 = descend_redirect_p((char const   *)redirected, (char const   *)url,
                                       depth___0, start_url_parsed, blacklist);
          }
#line 265
          if (tmp___6) {
            {
#line 271
            string_set_add(blacklist, (char const   *)url);
            }
          } else {
#line 267
            descend = (_Bool)0;
          }
        }
        {
#line 274
        checking_free((void *)url);
#line 275
        url = redirected;
        }
      }
    }
#line 284
    if (descend) {
#line 284
      if (depth___0 >= opt.reclevel) {
#line 284
        if (opt.reclevel != -1) {
#line 287
          if (opt.page_requisites) {
#line 287
            if (depth___0 == opt.reclevel) {
#line 297
              dash_p_leaf_HTML = (_Bool)1;
            } else
#line 287
            if (depth___0 == opt.reclevel + 1) {
#line 297
              dash_p_leaf_HTML = (_Bool)1;
            } else {
#line 287
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 304
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 304
              tmp___8 = __builtin_expect((long )opt.debug, 0L);
              }
#line 304
              if (tmp___8) {
                {
#line 304
                debug_logprintf("Not descending further; at depth %d, max. %d.\n",
                                depth___0, opt.reclevel);
                }
              }
#line 304
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 306
            descend = (_Bool)0;
          }
        }
      }
    }
#line 313
    if (descend) {
      {
#line 315
      meta_disallow_follow = (_Bool)0;
#line 316
      tmp___9 = get_urls_html((char const   *)file, (char const   *)url, & meta_disallow_follow);
#line 316
      children = tmp___9;
      }
#line 319
      if (opt.use_robots) {
#line 319
        if (meta_disallow_follow) {
          {
#line 321
          free_urlpos(children);
#line 322
          children = (struct urlpos *)((void *)0);
          }
        }
      }
#line 325
      if (children) {
        {
#line 327
        child = children;
#line 328
        url_parsed = url_parse((char const   *)url, (int *)((void *)0));
#line 328
        url_parsed = url_parsed;
#line 329
        referer_url = url;
        }
#line 330
        if ((unsigned long )url_parsed != (unsigned long )((void *)0)) {
#line 330
          if ((unsigned long )url_parsed->user != (unsigned long )((void *)0)) {
#line 330
            tmp___10 = 1;
          } else {
#line 330
            tmp___10 = 0;
          }
        } else {
#line 330
          tmp___10 = 0;
        }
#line 330
        strip_auth = (_Bool )tmp___10;
#line 332
        if (! ((unsigned long )url_parsed != (unsigned long )((void *)0))) {
          {
#line 332
          __assert_fail("url_parsed != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c",
                        332U, "retrieve_tree");
          }
        }
#line 335
        if (strip_auth) {
          {
#line 336
          referer_url = url_string((struct url  const  *)url_parsed, (enum url_auth_mode )2);
          }
        }
        {
#line 338
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 338
          if (! child) {
#line 338
            goto while_break___2;
          }
#line 340
          if (child->ignore_when_downloading) {
#line 341
            goto __Cont;
          }
#line 342
          if (dash_p_leaf_HTML) {
#line 342
            if (! child->link_inline_p) {
#line 343
              goto __Cont;
            }
          }
          {
#line 344
          tmp___14 = download_child_p((struct urlpos  const  *)child, url_parsed,
                                      depth___0, start_url_parsed, blacklist);
          }
#line 344
          if (tmp___14) {
            {
#line 347
            tmp___12 = checking_strdup((char const   *)referer_url);
#line 347
            tmp___13 = checking_strdup((char const   *)(child->url)->url);
#line 347
            url_enqueue(queue, (char const   *)tmp___13, (char const   *)tmp___12,
                        depth___0 + 1, (_Bool )child->link_expect_html);
#line 353
            string_set_add(blacklist, (char const   *)(child->url)->url);
            }
          }
          __Cont: /* CIL Label */ 
#line 338
          child = child->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 357
        if (strip_auth) {
          {
#line 358
          checking_free((void *)referer_url);
          }
        }
        {
#line 359
        url_free(url_parsed);
#line 360
        free_urlpos(children);
        }
      }
    }
#line 364
    if (file) {
#line 364
      if (opt.delete_after) {
#line 364
        goto _L___1;
      } else
#line 364
      if (opt.spider) {
#line 364
        goto _L___1;
      } else {
        {
#line 364
        tmp___24 = acceptable((char const   *)file);
        }
#line 364
        if (! tmp___24) {
          _L___1: /* CIL Label */ 
          {
#line 373
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 373
            tmp___17 = __builtin_expect((long )opt.debug, 0L);
            }
#line 373
            if (tmp___17) {
#line 373
              if (opt.delete_after) {
#line 373
                tmp___16 = "--delete-after";
              } else {
#line 373
                if (opt.spider) {
#line 373
                  tmp___15 = "--spider";
                } else {
#line 373
                  tmp___15 = "recursive rejection criteria";
                }
#line 373
                tmp___16 = tmp___15;
              }
              {
#line 373
              debug_logprintf("Removing file due to %s in recursive_retrieve():\n",
                              tmp___16);
              }
            }
#line 373
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 377
          if (opt.delete_after) {
            {
#line 377
            tmp___18 = gettext("Removing %s.\n");
#line 377
            tmp___20 = tmp___18;
            }
          } else
#line 377
          if (opt.spider) {
            {
#line 377
            tmp___18 = gettext("Removing %s.\n");
#line 377
            tmp___20 = tmp___18;
            }
          } else {
            {
#line 377
            tmp___19 = gettext("Removing %s since it should be rejected.\n");
#line 377
            tmp___20 = tmp___19;
            }
          }
          {
#line 377
          logprintf((enum log_options )0, (char const   *)tmp___20, file);
#line 382
          tmp___23 = unlink((char const   *)file);
          }
#line 382
          if (tmp___23) {
            {
#line 383
            tmp___21 = __errno_location();
#line 383
            tmp___22 = strerror(*tmp___21);
#line 383
            logprintf((enum log_options )1, "unlink: %s\n", tmp___22);
            }
          }
          {
#line 384
          logputs((enum log_options )0, "\n");
#line 385
          register_delete_file((char const   *)file);
          }
        }
      }
    }
    {
#line 388
    checking_free((void *)url);
    }
#line 389
    if (! (! referer)) {
      {
#line 389
      checking_free((void *)referer);
      }
    }
#line 390
    if (! (! file)) {
      {
#line 390
      checking_free((void *)file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 399
    tmp___25 = url_dequeue(queue, (char const   **)(& d1), (char const   **)(& d2),
                           & d3, & d4);
    }
#line 399
    if (! tmp___25) {
#line 399
      goto while_break___4;
    }
    {
#line 402
    checking_free((void *)d1);
    }
#line 403
    if (! (! d2)) {
      {
#line 403
      checking_free((void *)d2);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 406
  url_queue_delete(queue);
  }
#line 408
  if (start_url_parsed) {
    {
#line 409
    url_free(start_url_parsed);
    }
  }
  {
#line 410
  string_set_free(blacklist);
  }
#line 412
  if (opt.quota) {
#line 412
    if (total_downloaded_bytes > opt.quota) {
#line 413
      return ((uerr_t )51);
    } else {
#line 412
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 414
  if ((unsigned int )status == 26U) {
#line 415
    return ((uerr_t )26);
  } else {
#line 417
    return ((uerr_t )31);
  }
}
}
#line 428 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static _Bool download_child_p(struct urlpos  const  *upos , struct url *parent , int depth___0 ,
                              struct url *start_url_parsed , struct hash_table *blacklist ) 
{ 
  struct url *u ;
  char const   *url ;
  _Bool u_scheme_like_http ;
  long tmp ;
  char *referrer ;
  char *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  _Bool tmp___7 ;
  long tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  _Bool tmp___13 ;
  long tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  struct robot_specs *specs ;
  struct robot_specs *tmp___20 ;
  char *rfile ;
  _Bool tmp___21 ;
  long tmp___22 ;
  _Bool tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;

  {
#line 432
  u = (struct url *)upos->url;
#line 433
  url = (char const   *)u->url;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 436
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 436
    if (tmp) {
      {
#line 436
      debug_logprintf("Deciding whether to enqueue \"%s\".\n", url);
      }
    }
#line 436
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 438
  tmp___3 = string_set_contains(blacklist, url);
  }
#line 438
  if (tmp___3) {
#line 440
    if (opt.spider) {
      {
#line 442
      tmp___0 = url_string((struct url  const  *)parent, (enum url_auth_mode )1);
#line 442
      referrer = tmp___0;
      }
      {
#line 443
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 443
        tmp___1 = __builtin_expect((long )opt.debug, 0L);
        }
#line 443
        if (tmp___1) {
          {
#line 443
          debug_logprintf("download_child_p: parent->url is: `%s\'\n", parent->url);
          }
        }
#line 443
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 445
      checking_free((void *)referrer);
      }
    }
    {
#line 447
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 447
      tmp___2 = __builtin_expect((long )opt.debug, 0L);
      }
#line 447
      if (tmp___2) {
        {
#line 447
        debug_logprintf("Already on the black list.\n");
        }
      }
#line 447
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 448
    goto out;
  }
  {
#line 473
  u_scheme_like_http = schemes_are_similar_p(u->scheme, (enum url_scheme )0);
  }
#line 476
  if (! u_scheme_like_http) {
#line 476
    if ((unsigned int )u->scheme == 2U) {
#line 476
      if (! opt.follow_ftp) {
#line 476
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 478
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 478
        tmp___4 = __builtin_expect((long )opt.debug, 0L);
        }
#line 478
        if (tmp___4) {
          {
#line 478
          debug_logprintf("Not following non-HTTP schemes.\n");
          }
        }
#line 478
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 479
      goto out;
    }
  }
#line 484
  if (u_scheme_like_http) {
#line 485
    if (opt.relative_only) {
#line 485
      if (! upos->link_relative_p) {
        {
#line 487
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 487
          tmp___5 = __builtin_expect((long )opt.debug, 0L);
          }
#line 487
          if (tmp___5) {
            {
#line 487
            debug_logprintf("It doesn\'t really look like a relative link.\n");
            }
          }
#line 487
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 488
        goto out;
      }
    }
  }
  {
#line 493
  tmp___7 = accept_domain(u);
  }
#line 493
  if (! tmp___7) {
    {
#line 495
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 495
      tmp___6 = __builtin_expect((long )opt.debug, 0L);
      }
#line 495
      if (tmp___6) {
        {
#line 495
        debug_logprintf("The domain was not accepted.\n");
        }
      }
#line 495
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 496
    goto out;
  }
#line 504
  if (opt.no_parent) {
    {
#line 504
    tmp___10 = schemes_are_similar_p(u->scheme, start_url_parsed->scheme);
    }
#line 504
    if (tmp___10) {
      {
#line 504
      tmp___11 = strcasecmp((char const   *)u->host, (char const   *)start_url_parsed->host);
      }
#line 504
      if (0 == tmp___11) {
#line 504
        if (u->port == start_url_parsed->port) {
#line 504
          if (opt.page_requisites) {
#line 504
            if (! upos->link_inline_p) {
#line 504
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 510
            tmp___9 = subdir_p((char const   *)start_url_parsed->dir, (char const   *)u->dir);
            }
#line 510
            if (! tmp___9) {
              {
#line 512
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 512
                tmp___8 = __builtin_expect((long )opt.debug, 0L);
                }
#line 512
                if (tmp___8) {
                  {
#line 512
                  debug_logprintf("Going to \"%s\" would escape \"%s\" with no_parent on.\n",
                                  u->dir, start_url_parsed->dir);
                  }
                }
#line 512
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 514
              goto out;
            }
          }
        }
      }
    }
  }
#line 521
  if (opt.includes) {
#line 521
    goto _L___1;
  } else
#line 521
  if (opt.excludes) {
    _L___1: /* CIL Label */ 
    {
#line 523
    tmp___13 = accdir((char const   *)u->dir);
    }
#line 523
    if (! tmp___13) {
      {
#line 525
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 525
        tmp___12 = __builtin_expect((long )opt.debug, 0L);
        }
#line 525
        if (tmp___12) {
          {
#line 525
          debug_logprintf("%s (%s) is excluded/not-included.\n", url, u->dir);
          }
        }
#line 525
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 526
      goto out;
    }
  }
#line 535
  if ((int )*(u->file + 0) != 0) {
    {
#line 535
    tmp___16 = has_html_suffix_p((char const   *)u->file);
    }
#line 535
    if (tmp___16) {
#line 535
      if (! (opt.reclevel == -1)) {
#line 535
        if (! (depth___0 < opt.reclevel - 1)) {
#line 535
          if (! opt.page_requisites) {
#line 535
            goto _L___2;
          }
        }
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 547
      tmp___15 = acceptable((char const   *)u->file);
      }
#line 547
      if (! tmp___15) {
        {
#line 549
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 549
          tmp___14 = __builtin_expect((long )opt.debug, 0L);
          }
#line 549
          if (tmp___14) {
            {
#line 549
            debug_logprintf("%s (%s) does not match acc/rej rules.\n", url, u->file);
            }
          }
#line 549
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 551
        goto out;
      }
    }
  }
  {
#line 556
  tmp___19 = schemes_are_similar_p(u->scheme, parent->scheme);
  }
#line 556
  if (tmp___19) {
#line 557
    if (! opt.spanhost) {
      {
#line 557
      tmp___18 = strcasecmp((char const   *)parent->host, (char const   *)u->host);
      }
#line 557
      if (0 != tmp___18) {
        {
#line 559
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 559
          tmp___17 = __builtin_expect((long )opt.debug, 0L);
          }
#line 559
          if (tmp___17) {
            {
#line 559
            debug_logprintf("This is not the same hostname as the parent\'s (%s and %s).\n",
                            u->host, parent->host);
            }
          }
#line 559
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 561
        goto out;
      }
    }
  }
#line 565
  if (opt.use_robots) {
#line 565
    if (u_scheme_like_http) {
      {
#line 567
      tmp___20 = res_get_specs((char const   *)u->host, u->port);
#line 567
      specs = tmp___20;
      }
#line 568
      if (! specs) {
        {
#line 571
        tmp___21 = res_retrieve_file(url, & rfile);
        }
#line 571
        if (tmp___21) {
          {
#line 573
          specs = res_parse_from_file((char const   *)rfile);
#line 574
          checking_free((void *)rfile);
          }
        } else {
          {
#line 581
          specs = res_parse("", 0);
          }
        }
        {
#line 583
        res_register_specs((char const   *)u->host, u->port, specs);
        }
      }
      {
#line 588
      tmp___23 = res_match_path((struct robot_specs  const  *)specs, (char const   *)u->path);
      }
#line 588
      if (! tmp___23) {
        {
#line 590
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 590
          tmp___22 = __builtin_expect((long )opt.debug, 0L);
          }
#line 590
          if (tmp___22) {
            {
#line 590
            debug_logprintf("Not following %s because robots.txt forbids it.\n", url);
            }
          }
#line 590
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 591
        string_set_add(blacklist, url);
        }
#line 592
        goto out;
      }
    }
  }
  {
#line 598
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 598
    tmp___24 = __builtin_expect((long )opt.debug, 0L);
    }
#line 598
    if (tmp___24) {
      {
#line 598
      debug_logprintf("Decided to load it.\n");
      }
    }
#line 598
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 600
  return ((_Bool)1);
  out: 
  {
#line 603
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 603
    tmp___25 = __builtin_expect((long )opt.debug, 0L);
    }
#line 603
    if (tmp___25) {
      {
#line 603
      debug_logprintf("Decided NOT to load it.\n");
      }
    }
#line 603
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 605
  return ((_Bool)0);
}
}
#line 613 "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c"
static _Bool descend_redirect_p(char const   *redirected , char const   *original ,
                                int depth___0 , struct url *start_url_parsed , struct hash_table *blacklist ) 
{ 
  struct url *orig_parsed ;
  struct url *new_parsed ;
  struct urlpos *upos ;
  _Bool success ;
  void *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 621
  orig_parsed = url_parse(original, (int *)((void *)0));
  }
#line 622
  if (! ((unsigned long )orig_parsed != (unsigned long )((void *)0))) {
    {
#line 622
    __assert_fail("orig_parsed != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c",
                  622U, "descend_redirect_p");
    }
  }
  {
#line 624
  new_parsed = url_parse(redirected, (int *)((void *)0));
  }
#line 625
  if (! ((unsigned long )new_parsed != (unsigned long )((void *)0))) {
    {
#line 625
    __assert_fail("new_parsed != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/recur.c",
                  625U, "descend_redirect_p");
    }
  }
  {
#line 627
  tmp___1 = checking_malloc0(sizeof(struct urlpos ));
#line 627
  upos = (struct urlpos *)tmp___1;
#line 628
  upos->url = new_parsed;
#line 630
  success = download_child_p((struct urlpos  const  *)upos, orig_parsed, depth___0,
                             start_url_parsed, blacklist);
#line 633
  url_free(orig_parsed);
#line 634
  url_free(new_parsed);
#line 635
  checking_free((void *)upos);
  }
#line 637
  if (! success) {
    {
#line 638
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 638
      tmp___2 = __builtin_expect((long )opt.debug, 0L);
      }
#line 638
      if (tmp___2) {
        {
#line 638
        debug_logprintf("Redirection \"%s\" failed the test.\n", redirected);
        }
      }
#line 638
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 640
  return (success);
}
}
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 216 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id ,
                                                                                   struct timespec *__res ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 39 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.h"
void ptimer_reset(struct ptimer *pt ) ;
#line 109 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
static int posix_clock_id  ;
#line 112 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
static double posix_clock_resolution  ;
#line 124
static void posix_init(void) ;
#line 124 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
static struct __anonstruct_clocks_1027777389  const  clocks[2]  = {      {1, 149}, 
        {0, -1}};
#line 116 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
static void posix_init(void) 
{ 
  int i ;
  struct timespec r ;
  long tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((unsigned long )i < sizeof(clocks) / sizeof(clocks[0]))) {
#line 142
      goto while_break;
    }
#line 145
    if (clocks[i].sysconf_name != -1) {
      {
#line 146
      tmp = sysconf((int )clocks[i].sysconf_name);
      }
#line 146
      if (tmp < 0L) {
#line 147
        goto __Cont;
      }
    }
    {
#line 148
    tmp___0 = clock_getres((clockid_t )clocks[i].id, & r);
    }
#line 148
    if (tmp___0 < 0) {
#line 149
      goto __Cont;
    }
#line 150
    posix_clock_id = (int )clocks[i].id;
#line 151
    posix_clock_resolution = (double )r.tv_sec + (double )r.tv_nsec / 1e9;
#line 153
    if (posix_clock_resolution == (double )0) {
#line 154
      posix_clock_resolution = 1e-3;
    }
#line 155
    goto while_break;
    __Cont: /* CIL Label */ 
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if ((unsigned long )i == sizeof(clocks) / sizeof(clocks[0])) {
    {
#line 161
    tmp___1 = __errno_location();
#line 161
    tmp___2 = strerror(*tmp___1);
#line 161
    tmp___3 = gettext("Cannot get REALTIME clock frequency: %s\n");
#line 161
    logprintf((enum log_options )1, (char const   *)tmp___3, tmp___2);
#line 164
    posix_clock_id = 0;
#line 165
    posix_clock_resolution = 1e-3;
    }
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
__inline static void posix_measure(ptimer_system_time *pst ) 
{ 


  {
  {
#line 172
  clock_gettime(posix_clock_id, pst);
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
__inline static double posix_diff(ptimer_system_time *pst1 , ptimer_system_time *pst2 ) 
{ 


  {
#line 178
  return ((double )(pst1->tv_sec - pst2->tv_sec) + (double )(pst1->tv_nsec - pst2->tv_nsec) / 1e9);
}
}
#line 182 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
__inline static double posix_resolution(void) 
{ 


  {
#line 185
  return (posix_clock_resolution);
}
}
#line 321 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
static _Bool init_done  ;
#line 316 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
struct ptimer *ptimer_new(void) 
{ 
  struct ptimer *pt ;
  void *tmp ;

  {
  {
#line 319
  tmp = checking_malloc0(sizeof(struct ptimer ));
#line 319
  pt = (struct ptimer *)tmp;
  }
#line 322
  if (! init_done) {
    {
#line 324
    init_done = (_Bool)1;
#line 325
    posix_init();
    }
  }
  {
#line 328
  ptimer_reset(pt);
  }
#line 329
  return (pt);
}
}
#line 335 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
void ptimer_destroy(struct ptimer *pt ) 
{ 


  {
  {
#line 338
  checking_free((void *)pt);
  }
#line 339
  return;
}
}
#line 345 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
void ptimer_reset(struct ptimer *pt ) 
{ 


  {
  {
#line 349
  posix_measure(& pt->start);
#line 350
  pt->elapsed_last = (double )0;
#line 351
  pt->elapsed_pre_start = (double )0;
  }
#line 352
  return;
}
}
#line 362 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
double ptimer_measure(struct ptimer *pt ) 
{ 
  ptimer_system_time now ;
  double elapsed ;
  double tmp ;

  {
  {
#line 368
  posix_measure(& now);
#line 369
  tmp = posix_diff(& now, & pt->start);
#line 369
  elapsed = pt->elapsed_pre_start + tmp;
  }
#line 387
  if (elapsed < pt->elapsed_last) {
#line 389
    pt->start = now;
#line 390
    pt->elapsed_pre_start = pt->elapsed_last;
#line 391
    elapsed = pt->elapsed_last;
  }
#line 394
  pt->elapsed_last = elapsed;
#line 395
  return (elapsed);
}
}
#line 402 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
double ptimer_read(struct ptimer  const  *pt ) 
{ 


  {
#line 405
  return ((double )pt->elapsed_last);
}
}
#line 412 "/home/khheo/project/benchmark/wget-1.11.4/src/ptimer.c"
double ptimer_resolution(void) 
{ 
  double tmp ;

  {
  {
#line 415
  tmp = posix_resolution();
  }
#line 415
  return (tmp);
}
}
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 922 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbtowc)(wchar_t * __restrict  __pwc ,
                                                                             char const   * __restrict  __s ,
                                                                             size_t __n ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 367 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 44 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void log_set_flush(_Bool flush ) ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.h"
_Bool valid_progress_implementation_p(char const   *name ) ;
#line 35
void set_progress_implementation(char const   *name ) ;
#line 36
void progress_schedule_redirect(void) ;
#line 43
void progress_handle_sigwinch(int sig ) ;
#line 61 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void *dot_create(wgint initial , wgint total ) ;
#line 62
static void dot_update(void *progress , wgint howmuch , double dltime ) ;
#line 63
static void dot_finish(void *progress , double dltime ) ;
#line 64
static void dot_set_params(char const   *params ) ;
#line 66
static void *bar_create(wgint initial , wgint total ) ;
#line 67
static void bar_update(void *progress , wgint howmuch , double dltime ) ;
#line 68
static void bar_finish(void *progress , double dltime ) ;
#line 69
static void bar_set_params(char const   *params ) ;
#line 71 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static struct progress_implementation implementations[2]  = {      {"dot", (_Bool)0, & dot_create, & dot_update, & dot_finish, & dot_set_params}, 
        {"bar",
      (_Bool)1, & bar_create, & bar_update, & bar_finish, & bar_set_params}};
#line 75 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static struct progress_implementation *current_impl  ;
#line 76 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static int current_impl_locked  ;
#line 94 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
_Bool valid_progress_implementation_p(char const   *name ) 
{ 
  int i ;
  struct progress_implementation *pi ;
  char *colon ;
  char *tmp ;
  int namelen ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 98
  pi = implementations;
#line 99
  tmp = strchr(name, ':');
#line 99
  colon = tmp;
  }
#line 100
  if (colon) {
#line 100
    tmp___1 = (size_t )(colon - (char *)name);
  } else {
    {
#line 100
    tmp___0 = strlen(name);
#line 100
    tmp___1 = tmp___0;
    }
  }
#line 100
  namelen = (int )tmp___1;
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )i < sizeof(implementations) / sizeof(implementations[0]))) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp___2 = strncmp(pi->name, name, (size_t )namelen);
    }
#line 103
    if (! tmp___2) {
#line 104
      return ((_Bool)1);
    }
#line 102
    i ++;
#line 102
    pi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return ((_Bool)0);
}
}
#line 110 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void set_progress_implementation(char const   *name ) 
{ 
  int i ;
  int namelen ;
  struct progress_implementation *pi ;
  char const   *colon ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 114
  pi = implementations;
#line 117
  if (! name) {
#line 118
    name = "bar";
  }
  {
#line 120
  tmp = strchr(name, ':');
#line 120
  colon = (char const   *)tmp;
  }
#line 121
  if (colon) {
#line 121
    namelen = (int )(colon - name);
  } else {
    {
#line 121
    tmp___0 = strlen(name);
#line 121
    namelen = (int )tmp___0;
    }
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((unsigned long )i < sizeof(implementations) / sizeof(implementations[0]))) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___1 = strncmp(pi->name, name, (size_t )namelen);
    }
#line 124
    if (! tmp___1) {
#line 126
      current_impl = pi;
#line 127
      current_impl_locked = 0;
#line 129
      if (colon) {
#line 133
        colon ++;
      }
#line 135
      if (pi->set_params) {
        {
#line 136
        (*(pi->set_params))(colon);
        }
      }
#line 137
      return;
    }
#line 123
    i ++;
#line 123
    pi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  abort();
  }
}
}
#line 142 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static int output_redirected  ;
#line 144 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void progress_schedule_redirect(void) 
{ 


  {
#line 147
  output_redirected = 1;
#line 148
  return;
}
}
#line 156 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void *progress_create(wgint initial , wgint total ) 
{ 
  void *tmp ;

  {
#line 160
  if (output_redirected) {
#line 162
    if (! current_impl_locked) {
      {
#line 163
      set_progress_implementation("dot");
      }
    }
#line 164
    output_redirected = 0;
  }
  {
#line 167
  tmp = (*(current_impl->create))(initial, total);
  }
#line 167
  return (tmp);
}
}
#line 175 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
_Bool progress_interactive_p(void *progress ) 
{ 


  {
#line 178
  return (current_impl->interactive);
}
}
#line 184 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void progress_update(void *progress , wgint howmuch , double dltime ) 
{ 


  {
  {
#line 187
  (*(current_impl->update))(progress, howmuch, dltime);
  }
#line 188
  return;
}
}
#line 193 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void progress_finish(void *progress , double dltime ) 
{ 


  {
  {
#line 196
  (*(current_impl->finish))(progress, dltime);
  }
#line 197
  return;
}
}
#line 218 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void *dot_create(wgint initial , wgint total ) 
{ 
  struct dot_progress *dp ;
  void *tmp ;
  int dot_bytes ;
  wgint ROW_BYTES ;
  int remainder ;
  wgint skipped ;
  wgint skipped_k ;
  int skipped_k_len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 221
  tmp = checking_malloc0(sizeof(struct dot_progress ));
#line 221
  dp = (struct dot_progress *)tmp;
#line 222
  dp->initial_length = initial;
#line 223
  dp->total_length = total;
  }
#line 225
  if (dp->initial_length) {
#line 227
    dot_bytes = (int )opt.dot_bytes;
#line 228
    ROW_BYTES = opt.dot_bytes * (wgint )opt.dots_in_line;
#line 230
    remainder = (int )(dp->initial_length % ROW_BYTES);
#line 231
    skipped = dp->initial_length - (wgint )remainder;
#line 233
    if (skipped) {
      {
#line 235
      skipped_k = skipped / 1024L;
#line 236
      tmp___0 = numdigit(skipped_k);
#line 236
      skipped_k_len = tmp___0;
      }
#line 237
      if (skipped_k_len < 6) {
#line 238
        skipped_k_len = 6;
      }
      {
#line 243
      tmp___1 = number_to_static_string(skipped_k);
#line 243
      tmp___2 = gettext("\n%*s[ skipping %sK ]");
#line 243
      logprintf((enum log_options )0, (char const   *)tmp___2, 2 + skipped_k_len,
                "", tmp___1);
      }
    }
    {
#line 248
    tmp___3 = number_to_static_string(skipped / 1024L);
#line 248
    logprintf((enum log_options )0, "\n%6sK", tmp___3);
    }
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 250
      if (! (remainder >= dot_bytes)) {
#line 250
        goto while_break;
      }
#line 252
      if (dp->dots % opt.dot_spacing == 0) {
        {
#line 253
        logputs((enum log_options )0, " ");
        }
      }
      {
#line 254
      logputs((enum log_options )0, ",");
#line 255
      (dp->dots) ++;
#line 250
      remainder -= dot_bytes;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 257
    if (! (dp->dots < opt.dots_in_line)) {
      {
#line 257
      __assert_fail("dp->dots < opt.dots_in_line", "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c",
                    257U, "dot_create");
      }
    }
#line 259
    dp->accumulated = remainder;
#line 260
    dp->rows = (int )(skipped / ROW_BYTES);
  }
#line 263
  return ((void *)dp);
}
}
#line 266
static char const   *eta_to_human_short(int secs , _Bool condensed ) ;
#line 299
static void print_row_stats(struct dot_progress *dp , double dltime , _Bool last___0 ) ;
#line 299 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char names[4]  = {      (char )' ',      (char )'K',      (char )'M',      (char )'G'};
#line 276 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void print_row_stats(struct dot_progress *dp , double dltime , _Bool last___0 ) 
{ 
  wgint ROW_BYTES ;
  wgint bytes_displayed ;
  int percentage ;
  int units ;
  double rate ;
  wgint bytes_this_row ;
  int tmp ;
  int tmp___0 ;
  wgint bytes_remaining ;
  wgint bytes_sofar ;
  double eta ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 279
  ROW_BYTES = opt.dot_bytes * (wgint )opt.dots_in_line;
#line 283
  bytes_displayed = (wgint )dp->rows * ROW_BYTES + (wgint )dp->dots * opt.dot_bytes;
#line 285
  if (last___0) {
#line 287
    bytes_displayed += (wgint )dp->accumulated;
  }
#line 289
  if (dp->total_length) {
    {
#line 294
    percentage = (int )((100.0 * (double )bytes_displayed) / (double )dp->total_length);
#line 295
    logprintf((enum log_options )0, "%3d%%", percentage);
    }
  }
#line 303
  if (! last___0) {
#line 304
    bytes_this_row = ROW_BYTES;
  } else {
#line 307
    bytes_this_row = (wgint )dp->dots * opt.dot_bytes + (wgint )dp->accumulated;
  }
#line 309
  if ((wgint )dp->rows == dp->initial_length / ROW_BYTES) {
#line 310
    bytes_this_row -= dp->initial_length % ROW_BYTES;
  }
  {
#line 311
  rate = calc_rate(bytes_this_row, dltime - dp->last_timer_value, & units);
  }
#line 312
  if (rate >= 99.95) {
#line 312
    tmp___0 = 0;
  } else {
#line 312
    if (rate >= 9.995) {
#line 312
      tmp = 1;
    } else {
#line 312
      tmp = 2;
    }
#line 312
    tmp___0 = tmp;
  }
  {
#line 312
  logprintf((enum log_options )0, " %4.*f%c", tmp___0, rate, (int )names[units]);
#line 315
  dp->last_timer_value = dltime;
  }
#line 318
  if (! last___0) {
#line 322
    if (dp->total_length) {
#line 324
      bytes_remaining = dp->total_length - bytes_displayed;
#line 326
      bytes_sofar = bytes_displayed - dp->initial_length;
#line 327
      eta = (dltime * (double )bytes_remaining) / (double )bytes_sofar;
#line 328
      if (eta < (double )2147483646) {
        {
#line 329
        tmp___1 = eta_to_human_short((int )(eta + 0.5), (_Bool)1);
#line 329
        logprintf((enum log_options )0, " %s", tmp___1);
        }
      }
    }
  } else
#line 336
  if (dltime >= (double )10) {
    {
#line 337
    tmp___2 = eta_to_human_short((int )(dltime + 0.5), (_Bool)1);
#line 337
    logprintf((enum log_options )0, "=%s", tmp___2);
    }
  } else {
    {
#line 340
    tmp___3 = print_decimal(dltime);
#line 340
    logprintf((enum log_options )0, "=%ss", tmp___3);
    }
  }
#line 342
  return;
}
}
#line 346 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void dot_update(void *progress , wgint howmuch , double dltime ) 
{ 
  struct dot_progress *dp ;
  int dot_bytes ;
  wgint ROW_BYTES ;
  char *tmp ;

  {
  {
#line 349
  dp = (struct dot_progress *)progress;
#line 350
  dot_bytes = (int )opt.dot_bytes;
#line 351
  ROW_BYTES = opt.dot_bytes * (wgint )opt.dots_in_line;
#line 353
  log_set_flush((_Bool)0);
#line 355
  dp->accumulated = (int )((wgint )dp->accumulated + howmuch);
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (dp->accumulated >= dot_bytes)) {
#line 356
      goto while_break;
    }
#line 358
    if (dp->dots == 0) {
      {
#line 359
      tmp = number_to_static_string(((wgint )dp->rows * ROW_BYTES) / 1024L);
#line 359
      logprintf((enum log_options )0, "\n%6sK", tmp);
      }
    }
#line 362
    if (dp->dots % opt.dot_spacing == 0) {
      {
#line 363
      logputs((enum log_options )0, " ");
      }
    }
    {
#line 364
    logputs((enum log_options )0, ".");
#line 366
    (dp->dots) ++;
    }
#line 367
    if (dp->dots >= opt.dots_in_line) {
      {
#line 369
      (dp->rows) ++;
#line 370
      dp->dots = 0;
#line 372
      print_row_stats(dp, dltime, (_Bool)0);
      }
    }
#line 356
    dp->accumulated -= dot_bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  log_set_flush((_Bool)1);
  }
#line 377
  return;
}
}
#line 381 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void dot_finish(void *progress , double dltime ) 
{ 
  struct dot_progress *dp ;
  wgint ROW_BYTES ;
  int i ;
  char *tmp ;

  {
  {
#line 384
  dp = (struct dot_progress *)progress;
#line 385
  ROW_BYTES = opt.dot_bytes * (wgint )opt.dots_in_line;
#line 388
  log_set_flush((_Bool)0);
  }
#line 390
  if (dp->dots == 0) {
    {
#line 391
    tmp = number_to_static_string(((wgint )dp->rows * ROW_BYTES) / 1024L);
#line 391
    logprintf((enum log_options )0, "\n%6sK", tmp);
    }
  }
#line 393
  i = dp->dots;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < opt.dots_in_line)) {
#line 393
      goto while_break;
    }
#line 395
    if (i % opt.dot_spacing == 0) {
      {
#line 396
      logputs((enum log_options )0, " ");
      }
    }
    {
#line 397
    logputs((enum log_options )0, " ");
#line 393
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  print_row_stats(dp, dltime, (_Bool)1);
#line 401
  logputs((enum log_options )0, "\n\n");
#line 402
  log_set_flush((_Bool)0);
#line 404
  checking_free((void *)dp);
  }
#line 405
  return;
}
}
#line 412 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void dot_set_params(char const   *params ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 415
  if (! params) {
#line 416
    params = (char const   *)opt.dot_style;
  } else
#line 415
  if (! *params) {
#line 416
    params = (char const   *)opt.dot_style;
  }
#line 418
  if (! params) {
#line 419
    return;
  }
  {
#line 422
  tmp___3 = strcasecmp(params, "default");
  }
#line 422
  if (tmp___3) {
    {
#line 430
    tmp___2 = strcasecmp(params, "binary");
    }
#line 430
    if (tmp___2) {
      {
#line 438
      tmp___1 = strcasecmp(params, "mega");
      }
#line 438
      if (tmp___1) {
        {
#line 446
        tmp___0 = strcasecmp(params, "giga");
        }
#line 446
        if (tmp___0) {
          {
#line 456
          tmp = gettext("Invalid dot style specification `%s\'; leaving unchanged.\n");
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                  params);
          }
        } else {
#line 451
          opt.dot_bytes = 1L << 20;
#line 452
          opt.dot_spacing = 8;
#line 453
          opt.dots_in_line = 32;
        }
      } else {
#line 442
        opt.dot_bytes = 65536L;
#line 443
        opt.dot_spacing = 8;
#line 444
        opt.dots_in_line = 48;
      }
    } else {
#line 434
      opt.dot_bytes = (wgint )8192;
#line 435
      opt.dot_spacing = 16;
#line 436
      opt.dots_in_line = 48;
    }
  } else {
#line 426
    opt.dot_bytes = (wgint )1024;
#line 427
    opt.dot_spacing = 10;
#line 428
    opt.dots_in_line = 50;
  }
#line 459
  return;
}
}
#line 473 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static int screen_width  ;
#line 476 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static sig_atomic_t volatile   received_sigwinch  ;
#line 553
static void create_image(struct bar_progress *bp , double dl_total_time , _Bool done ) ;
#line 554
static void display_image(char *buf___4 ) ;
#line 556 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void *bar_create(wgint initial , wgint total ) 
{ 
  struct bar_progress *bp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 559
  tmp = checking_malloc0(sizeof(struct bar_progress ));
#line 559
  bp = (struct bar_progress *)tmp;
  }
#line 563
  if (initial > total) {
#line 564
    total = initial;
  }
#line 566
  bp->initial_length = initial;
#line 567
  bp->total_length = total;
#line 571
  if (! screen_width) {
#line 571
    goto _L;
  } else
#line 571
  if (received_sigwinch) {
    _L: /* CIL Label */ 
    {
#line 573
    screen_width = determine_screen_width();
    }
#line 574
    if (! screen_width) {
#line 575
      screen_width = 80;
    } else
#line 576
    if (screen_width < 45) {
#line 577
      screen_width = 45;
    }
#line 578
    received_sigwinch = (sig_atomic_t volatile   )0;
  }
  {
#line 582
  bp->width = screen_width - 1;
#line 585
  tmp___0 = checking_malloc((size_t )(bp->width + 100));
#line 585
  bp->buffer = (char *)tmp___0;
#line 587
  logputs((enum log_options )0, "\n");
#line 589
  create_image(bp, (double )0, (_Bool)0);
#line 590
  display_image(bp->buffer);
  }
#line 592
  return ((void *)bp);
}
}
#line 595
static void update_speed_ring(struct bar_progress *bp , wgint howmuch , double dltime ) ;
#line 597 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void bar_update(void *progress , wgint howmuch , double dltime ) 
{ 
  struct bar_progress *bp ;
  _Bool force_screen_update ;
  int old_width ;
  void *tmp ;

  {
#line 600
  bp = (struct bar_progress *)progress;
#line 601
  force_screen_update = (_Bool)0;
#line 603
  bp->count += howmuch;
#line 604
  if (bp->total_length > 0L) {
#line 604
    if (bp->count + bp->initial_length > bp->total_length) {
#line 611
      bp->total_length = bp->initial_length + bp->count;
    }
  }
  {
#line 613
  update_speed_ring(bp, howmuch, dltime);
  }
#line 617
  if (received_sigwinch) {
    {
#line 619
    old_width = screen_width;
#line 620
    screen_width = determine_screen_width();
    }
#line 621
    if (! screen_width) {
#line 622
      screen_width = 80;
    } else
#line 623
    if (screen_width < 45) {
#line 624
      screen_width = 45;
    }
#line 625
    if (screen_width != old_width) {
      {
#line 627
      bp->width = screen_width - 1;
#line 628
      tmp = checking_realloc((void *)bp->buffer, (size_t )(bp->width + 100));
#line 628
      bp->buffer = (char *)tmp;
#line 629
      force_screen_update = (_Bool)1;
      }
    }
#line 631
    received_sigwinch = (sig_atomic_t volatile   )0;
  }
#line 634
  if (dltime - bp->last_screen_update < 0.2) {
#line 634
    if (! force_screen_update) {
#line 636
      return;
    }
  }
  {
#line 638
  create_image(bp, dltime, (_Bool)0);
#line 639
  display_image(bp->buffer);
#line 640
  bp->last_screen_update = dltime;
  }
#line 641
  return;
}
}
#line 643 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void bar_finish(void *progress , double dltime ) 
{ 
  struct bar_progress *bp ;

  {
#line 646
  bp = (struct bar_progress *)progress;
#line 648
  if (bp->total_length > 0L) {
#line 648
    if (bp->count + bp->initial_length > bp->total_length) {
#line 651
      bp->total_length = bp->initial_length + bp->count;
    }
  }
  {
#line 653
  create_image(bp, dltime, (_Bool)1);
#line 654
  display_image(bp->buffer);
#line 656
  logputs((enum log_options )0, "\n\n");
#line 658
  checking_free((void *)bp->buffer);
#line 659
  checking_free((void *)bp);
  }
#line 660
  return;
}
}
#line 680 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void update_speed_ring(struct bar_progress *bp , wgint howmuch , double dltime ) 
{ 
  struct bar_progress_hist *hist ;
  double recent_age ;

  {
#line 683
  hist = & bp->hist;
#line 684
  recent_age = dltime - bp->recent_start;
#line 687
  bp->recent_bytes += howmuch;
#line 692
  if (recent_age < 0.15) {
#line 693
    return;
  }
#line 695
  if (howmuch == 0L) {
#line 701
    if (recent_age >= (double )5) {
      {
#line 706
      bp->stalled = (_Bool)1;
#line 707
      memset((void *)hist, '\000', sizeof(*hist));
#line 708
      bp->recent_bytes = (wgint )0;
      }
    }
#line 710
    return;
  }
#line 716
  if (bp->stalled) {
#line 718
    bp->stalled = (_Bool)0;
#line 724
    recent_age = (double )1;
  }
#line 732
  hist->total_time -= hist->times[hist->pos];
#line 733
  hist->total_bytes -= hist->bytes[hist->pos];
#line 736
  hist->times[hist->pos] = recent_age;
#line 737
  hist->bytes[hist->pos] = bp->recent_bytes;
#line 738
  hist->total_time += recent_age;
#line 739
  hist->total_bytes += bp->recent_bytes;
#line 742
  bp->recent_start = dltime;
#line 743
  bp->recent_bytes = (wgint )0;
#line 746
  (hist->pos) ++;
#line 746
  if (hist->pos == 20) {
#line 747
    hist->pos = 0;
  }
#line 769
  return;
}
}
#line 772 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
int count_cols(char const   *mbs ) 
{ 
  wchar_t wc ;
  int bytes ;
  int remaining ;
  size_t tmp ;
  int cols ;
  int wccols ;
  int tmp___1 ;

  {
  {
#line 777
  tmp = strlen(mbs);
#line 777
  remaining = (int )tmp;
#line 778
  cols = 0;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! ((int const   )*mbs != 0)) {
#line 781
      goto while_break;
    }
    {
#line 783
    bytes = mbtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)mbs,
                   (size_t )remaining);
    }
#line 784
    if (! (bytes != 0)) {
      {
#line 784
      __assert_fail("bytes != 0", "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c",
                    784U, "count_cols");
      }
    }
#line 785
    if (bytes == -1) {
#line 788
      return (cols + remaining);
    }
    {
#line 790
    mbs += bytes;
#line 791
    remaining -= bytes;
#line 792
    wccols = wcwidth(wc);
    }
#line 793
    if (wccols == -1) {
#line 793
      tmp___1 = 1;
    } else {
#line 793
      tmp___1 = wccols;
    }
#line 793
    cols += tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  return (cols);
}
}
#line 806
char const   *get_eta(int *bcd ) ;
#line 806 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char const   eta_str[9]  = 
#line 806
  {      (char const   )' ',      (char const   )' ',      (char const   )'e',      (char const   )'t', 
        (char const   )'a',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )'\000'};
#line 807 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char const   *eta_trans  ;
#line 808 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static int bytes_cols_diff  ;
#line 801 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
char const   *get_eta(int *bcd ) 
{ 
  int nbytes ;
  int ncols ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 809
  if ((unsigned long )eta_trans == (unsigned long )((void *)0)) {
    {
#line 815
    tmp = gettext(eta_str);
#line 815
    eta_trans = (char const   *)tmp;
#line 827
    tmp___0 = strlen(eta_trans);
#line 827
    nbytes = (int )tmp___0;
#line 828
    ncols = count_cols(eta_trans);
#line 829
    bytes_cols_diff = nbytes - ncols;
    }
  }
#line 832
  if ((unsigned long )bcd != (unsigned long )((void *)0)) {
#line 833
    *bcd = bytes_cols_diff;
  }
#line 835
  return (eta_trans);
}
}
#line 986 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char const   *short_units[4]  = {      "B/s",      "K/s",      "M/s",      "G/s"};
#line 852 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void create_image(struct bar_progress *bp , double dl_total_time , _Bool done ) 
{ 
  char *p___0 ;
  wgint size ;
  char const   *size_grouped ;
  char const   *tmp ;
  int size_grouped_len ;
  int tmp___0 ;
  int size_grouped_diff ;
  size_t tmp___1 ;
  int size_grouped_pad ;
  struct bar_progress_hist *hist ;
  int dlbytes_size ;
  int tmp___2 ;
  int progress_size ;
  int bytes_cols_diff___0 ;
  int percentage ;
  int insz ;
  int dlsz ;
  char *begin ;
  int i ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int ind ;
  int i___0 ;
  int pos ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int units ;
  wgint dlquant ;
  double dltime ;
  double dlspeed ;
  double tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int eta ;
  wgint bytes_remaining ;
  double eta_ ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  int nbytes ;
  int ncols ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 855
  p___0 = bp->buffer;
#line 856
  size = bp->initial_length + bp->count;
#line 858
  tmp = with_thousand_seps(size);
#line 858
  size_grouped = tmp;
#line 859
  tmp___0 = count_cols(size_grouped);
#line 859
  size_grouped_len = tmp___0;
#line 861
  tmp___1 = strlen(size_grouped);
#line 861
  size_grouped_diff = (int )(tmp___1 - (size_t )size_grouped_len);
#line 864
  hist = & bp->hist;
  }
#line 884
  if (size_grouped_len >= 11) {
#line 884
    tmp___2 = size_grouped_len;
  } else {
#line 884
    tmp___2 = 11;
  }
#line 884
  dlbytes_size = 1 + tmp___2;
#line 885
  progress_size = bp->width - (((6 + dlbytes_size) + 8) + 14);
#line 889
  bytes_cols_diff___0 = 0;
#line 891
  if (progress_size < 5) {
#line 892
    progress_size = 0;
  }
#line 895
  if (bp->total_length > 0L) {
#line 897
    percentage = (int )((100.0 * (double )size) / (double )bp->total_length);
#line 898
    if (! (percentage <= 100)) {
      {
#line 898
      __assert_fail("percentage <= 100", "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c",
                    898U, "create_image");
      }
    }
#line 900
    if (percentage < 100) {
      {
#line 901
      sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)"%2d%% ",
              percentage);
      }
    } else {
      {
#line 903
      strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)"100%");
      }
    }
#line 904
    p___0 += 4;
  } else {
    {
#line 907
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 907
      memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)"    ",
             sizeof("    ") - 1UL);
#line 907
      p___0 += sizeof("    ") - 1UL;
      }
#line 907
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 910
  if (progress_size) {
#line 910
    if (bp->total_length > 0L) {
#line 913
      insz = (int )(((double )bp->initial_length / (double )bp->total_length) * (double )progress_size);
#line 916
      dlsz = (int )(((double )size / (double )bp->total_length) * (double )progress_size);
#line 921
      if (! (dlsz <= progress_size)) {
        {
#line 921
        __assert_fail("dlsz <= progress_size", "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c",
                      921U, "create_image");
        }
      }
#line 922
      if (! (insz <= dlsz)) {
        {
#line 922
        __assert_fail("insz <= dlsz", "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c",
                      922U, "create_image");
        }
      }
#line 924
      tmp___6 = p___0;
#line 924
      p___0 ++;
#line 924
      *tmp___6 = (char )'[';
#line 925
      begin = p___0;
#line 929
      i = 0;
      {
#line 929
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 929
        if (! (i < insz)) {
#line 929
          goto while_break___0;
        }
#line 930
        tmp___7 = p___0;
#line 930
        p___0 ++;
#line 930
        *tmp___7 = (char )'+';
#line 929
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 931
      dlsz -= insz;
#line 932
      if (dlsz > 0) {
#line 934
        i = 0;
        {
#line 934
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 934
          if (! (i < dlsz - 1)) {
#line 934
            goto while_break___1;
          }
#line 935
          tmp___8 = p___0;
#line 935
          p___0 ++;
#line 935
          *tmp___8 = (char )'=';
#line 934
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 936
        tmp___9 = p___0;
#line 936
        p___0 ++;
#line 936
        *tmp___9 = (char )'>';
      }
      {
#line 939
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 939
        if (! (p___0 - begin < (long )progress_size)) {
#line 939
          goto while_break___2;
        }
#line 940
        tmp___10 = p___0;
#line 940
        p___0 ++;
#line 940
        *tmp___10 = (char )' ';
      }
      while_break___2: /* CIL Label */ ;
      }
#line 941
      tmp___11 = p___0;
#line 941
      p___0 ++;
#line 941
      *tmp___11 = (char )']';
    } else {
#line 910
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 943
  if (progress_size) {
#line 947
    ind = bp->tick % (progress_size * 2 - 6);
#line 951
    if (ind < progress_size - 2) {
#line 952
      pos = ind + 1;
    } else {
#line 954
      pos = progress_size - ((ind - progress_size) + 5);
    }
#line 956
    tmp___12 = p___0;
#line 956
    p___0 ++;
#line 956
    *tmp___12 = (char )'[';
#line 957
    i___0 = 0;
    {
#line 957
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 957
      if (! (i___0 < progress_size)) {
#line 957
        goto while_break___3;
      }
#line 959
      if (i___0 == pos - 1) {
#line 959
        tmp___13 = p___0;
#line 959
        p___0 ++;
#line 959
        *tmp___13 = (char )'<';
      } else
#line 960
      if (i___0 == pos) {
#line 960
        tmp___14 = p___0;
#line 960
        p___0 ++;
#line 960
        *tmp___14 = (char )'=';
      } else
#line 961
      if (i___0 == pos + 1) {
#line 961
        tmp___15 = p___0;
#line 961
        p___0 ++;
#line 961
        *tmp___15 = (char )'>';
      } else {
#line 963
        tmp___16 = p___0;
#line 963
        p___0 ++;
#line 963
        *tmp___16 = (char )' ';
      }
#line 957
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 965
    tmp___17 = p___0;
#line 965
    p___0 ++;
#line 965
    *tmp___17 = (char )']';
#line 967
    (bp->tick) ++;
  }
  {
#line 971
  sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)" %s",
          size_grouped);
#line 972
  p___0 = strchr((char const   *)p___0, '\000');
#line 976
  size_grouped_pad = 11 - size_grouped_len;
  }
  {
#line 976
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 976
    if (! (size_grouped_pad > 0)) {
#line 976
      goto while_break___4;
    }
#line 980
    tmp___18 = p___0;
#line 980
    p___0 ++;
#line 980
    *tmp___18 = (char )' ';
#line 976
    size_grouped_pad --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 984
  if (hist->total_time > (double )0) {
#line 984
    if (hist->total_bytes) {
      {
#line 987
      units = 0;
#line 990
      dlquant = hist->total_bytes + bp->recent_bytes;
#line 991
      dltime = hist->total_time + (dl_total_time - bp->recent_start);
#line 992
      tmp___19 = calc_rate(dlquant, dltime, & units);
#line 992
      dlspeed = tmp___19;
      }
#line 993
      if (dlspeed >= 99.95) {
#line 993
        tmp___21 = 0;
      } else {
#line 993
        if (dlspeed >= 9.995) {
#line 993
          tmp___20 = 1;
        } else {
#line 993
          tmp___20 = 2;
        }
#line 993
        tmp___21 = tmp___20;
      }
      {
#line 993
      sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)" %4.*f%s",
              tmp___21, dlspeed, short_units[units]);
#line 995
      p___0 = strchr((char const   *)p___0, '\000');
      }
    } else {
#line 984
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 998
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 998
      memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)" --.-K/s",
             sizeof(" --.-K/s") - 1UL);
#line 998
      p___0 += sizeof(" --.-K/s") - 1UL;
      }
#line 998
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1000
  if (! done) {
#line 1005
    if (bp->total_length > 0L) {
#line 1005
      if (bp->count > 0L) {
#line 1005
        if (dl_total_time > (double )3) {
#line 1012
          if (bp->total_length != size) {
#line 1012
            if (bp->last_eta_value != 0) {
#line 1012
              if (dl_total_time - bp->last_eta_time < 0.99) {
#line 1015
                eta = bp->last_eta_value;
              } else {
#line 1012
                goto _L___2;
              }
            } else {
#line 1012
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 1024
            bytes_remaining = bp->total_length - size;
#line 1025
            eta_ = (dl_total_time * (double )bytes_remaining) / (double )bp->count;
#line 1026
            if (eta_ >= (double )2147483646) {
#line 1027
              goto skip_eta;
            }
#line 1028
            eta = (int )(eta_ + 0.5);
#line 1029
            bp->last_eta_value = eta;
#line 1030
            bp->last_eta_time = dl_total_time;
          }
          {
#line 1033
          tmp___22 = eta_to_human_short(eta, (_Bool)0);
#line 1033
          tmp___23 = get_eta(& bytes_cols_diff___0);
#line 1033
          sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)tmp___23,
                  tmp___22);
#line 1035
          p___0 = strchr((char const   *)p___0, '\000');
          }
        } else {
#line 1005
          goto _L___4;
        }
      } else {
#line 1005
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1037
    if (bp->total_length > 0L) {
      skip_eta: 
      {
#line 1040
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1040
        memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)"             ",
               sizeof("             ") - 1UL);
#line 1040
        p___0 += sizeof("             ") - 1UL;
        }
#line 1040
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1051
    tmp___24 = gettext("   in ");
#line 1051
    strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)tmp___24);
#line 1052
    tmp___25 = strlen((char const   *)p___0);
#line 1052
    nbytes = (int )tmp___25;
#line 1053
    ncols = count_cols((char const   *)p___0);
#line 1054
    bytes_cols_diff___0 = nbytes - ncols;
#line 1055
    p___0 += nbytes;
    }
#line 1056
    if (dl_total_time >= (double )10) {
      {
#line 1057
      tmp___26 = eta_to_human_short((int )(dl_total_time + 0.5), (_Bool)0);
#line 1057
      strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)tmp___26);
      }
    } else {
      {
#line 1059
      tmp___27 = print_decimal(dl_total_time);
#line 1059
      sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)"%ss",
              tmp___27);
      }
    }
    {
#line 1060
    p___0 = strchr((char const   *)p___0, '\000');
    }
  }
  {
#line 1063
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1063
    if (! (((p___0 - bp->buffer) - (long )bytes_cols_diff___0) - (long )size_grouped_diff < (long )bp->width)) {
#line 1063
      goto while_break___7;
    }
#line 1064
    tmp___28 = p___0;
#line 1064
    p___0 ++;
#line 1064
    *tmp___28 = (char )' ';
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1065
  *p___0 = (char )'\000';
#line 1066
  return;
}
}
#line 1071 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void display_image(char *buf___4 ) 
{ 
  _Bool old ;
  _Bool tmp ;

  {
  {
#line 1074
  tmp = log_set_save_context((_Bool)0);
#line 1074
  old = tmp;
#line 1075
  logputs((enum log_options )0, "\r");
#line 1076
  logputs((enum log_options )0, (char const   *)buf___4);
#line 1077
  log_set_save_context(old);
  }
#line 1078
  return;
}
}
#line 1080 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static void bar_set_params(char const   *params ) 
{ 
  char *term ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1083
  tmp = getenv("TERM");
#line 1083
  term = tmp;
  }
#line 1085
  if (params) {
    {
#line 1085
    tmp___0 = strcmp(params, "force");
    }
#line 1085
    if (0 == tmp___0) {
#line 1087
      current_impl_locked = 1;
    }
  }
#line 1089
  if (opt.lfilename) {
#line 1089
    goto _L;
  } else {
    {
#line 1089
    tmp___1 = fileno(stderr);
#line 1089
    tmp___2 = isatty(tmp___1);
    }
#line 1089
    if (tmp___2) {
#line 1089
      if (term) {
        {
#line 1089
        tmp___3 = strcmp((char const   *)term, "emacs");
        }
#line 1089
        if (0 == tmp___3) {
          _L: /* CIL Label */ 
#line 1089
          if (! current_impl_locked) {
            {
#line 1110
            set_progress_implementation("dot");
            }
#line 1111
            return;
          }
        }
      }
    } else {
#line 1089
      goto _L;
    }
  }
#line 1113
  return;
}
}
#line 1116 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
void progress_handle_sigwinch(int sig ) 
{ 


  {
  {
#line 1119
  received_sigwinch = (sig_atomic_t volatile   )1;
#line 1120
  signal(28, & progress_handle_sigwinch);
  }
#line 1121
  return;
}
}
#line 1143 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char buf___1[10]  ;
#line 1144 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static int last  =    -1;
#line 1140 "/home/khheo/project/benchmark/wget-1.11.4/src/progress.c"
static char const   *eta_to_human_short(int secs , _Bool condensed ) 
{ 
  char const   *space ;
  char const   *tmp ;

  {
#line 1145
  if (condensed) {
#line 1145
    tmp = "";
  } else {
#line 1145
    tmp = " ";
  }
#line 1145
  space = tmp;
#line 1150
  if (secs == last) {
#line 1151
    return ((char const   *)(buf___1));
  }
#line 1152
  last = secs;
#line 1154
  if (secs < 100) {
    {
#line 1155
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%ds",
            secs);
    }
  } else
#line 1156
  if (secs < 6000) {
    {
#line 1157
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%dm%s%ds",
            secs / 60, space, secs % 60);
    }
  } else
#line 1158
  if (secs < 172800) {
    {
#line 1159
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%dh%s%dm",
            secs / 3600, space, (secs / 60) % 60);
    }
  } else
#line 1160
  if (secs < 8640000) {
    {
#line 1161
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%dd%s%dh",
            secs / 86400, space, (secs / 3600) % 60);
    }
  } else {
    {
#line 1164
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%dd",
            secs / 86400);
    }
  }
#line 1166
  return ((char const   *)(buf___1));
}
}
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/progname.h"
void set_program_name(char const   *argv0 ) ;
#line 30 "/home/khheo/project/benchmark/wget-1.11.4/src/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 33 "/home/khheo/project/benchmark/wget-1.11.4/src/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 42
  tmp = strrchr(argv0, '/');
#line 42
  slash = (char const   *)tmp;
  }
#line 43
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 43
    base = slash + 1;
  } else {
#line 43
    base = argv0;
  }
#line 44
  if (base - argv0 >= 7L) {
    {
#line 44
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 44
    if (tmp___1 == 0) {
      {
#line 46
      argv0 = base;
#line 47
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        argv0 = base + 3;
      }
    }
  }
#line 50
  program_name = argv0;
#line 51
  return;
}
}
#line 276 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void *ptr , char const   *file , int line ) ;
#line 348 "/usr/include/openssl/x509.h"
extern char const   *X509_verify_cert_error_string(long n ) ;
#line 551
extern void X509_free(X509 *a ) ;
#line 609
extern char *X509_NAME_oneline(X509_NAME const   *a , char *buf , int size ) ;
#line 640
extern X509_NAME *X509_get_issuer_name(X509 const   *a ) ;
#line 642
extern X509_NAME *X509_get_subject_name(X509 const   *a ) ;
#line 802
extern int X509_NAME_get_text_by_NID(X509_NAME *name , int nid , char *buf , int len ) ;
#line 1478 "/usr/include/openssl/ssl.h"
extern SSL_CTX *SSL_CTX_new(SSL_METHOD const   *meth ) ;
#line 1480
extern void SSL_CTX_free(SSL_CTX * ) ;
#line 1511
extern int SSL_pending(SSL const   *s ) ;
#line 1514
extern int SSL_set_fd(SSL *s , int fd ) ;
#line 1570
extern int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1572
extern int SSL_CTX_use_certificate_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1653
extern X509 *SSL_get_peer_certificate(SSL const   *s ) ;
#line 1661
extern void SSL_CTX_set_verify(SSL_CTX *ctx , int mode , int (*callback)(int preverify_ok ,
                                                                         X509_STORE_CTX *x509_ctx ) ) ;
#line 1698
extern SSL *SSL_new(SSL_CTX *ctx ) ;
#line 1790
extern void SSL_free(SSL *ssl ) ;
#line 1804
extern int SSL_read(SSL *ssl , void *buf , int num ) ;
#line 1813
extern int SSL_peek(SSL *ssl , void *buf , int num ) ;
#line 1815
extern int SSL_write(SSL *ssl , void const   *buf , int num ) ;
#line 1821
extern long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
#line 1830
extern int SSL_get_error(SSL const   *s , int ret_code ) ;
#line 1849
extern SSL_METHOD const   *TLS_client_method(void) ;
#line 1854
extern SSL_METHOD const   *TLSv1_client_method(void)  __attribute__((__deprecated__)) ;
#line 1899
extern int SSL_shutdown(SSL *s ) ;
#line 1927
extern void SSL_set_connect_state(SSL *s ) ;
#line 1958
extern int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx ) ;
#line 1961
extern int SSL_CTX_load_verify_locations(SSL_CTX *ctx , char const   *CAfile , char const   *CApath ) ;
#line 1975
extern long SSL_get_verify_result(SSL const   *ssl ) ;
#line 2339
extern int OPENSSL_init_ssl(uint64_t opts , OPENSSL_INIT_SETTINGS const   *settings ) ;
#line 222 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 235
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 53 "/usr/include/openssl/rand.h"
extern int RAND_load_file(char const   *file , long max_bytes ) ;
#line 55
extern char const   *RAND_file_name(char *file , size_t num ) ;
#line 56
extern int RAND_status(void) ;
#line 52 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
char const   *escnonprint(char const   *str ) ;
#line 61 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
int select_fd(int fd , double maxtime , int wait_for ) ;
#line 73
void fd_register_transport(int fd , struct transport_implementation *imp , void *ctx ) ;
#line 74
void *fd_transport_context(int fd ) ;
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/ssl.h"
_Bool ssl_init(void) ;
#line 36
_Bool ssl_connect(int fd ) ;
#line 37
_Bool ssl_check_certificate(int fd , char const   *host ) ;
#line 54 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static SSL_CTX *ssl_ctx  ;
#line 90
extern int ( /* missing proto */  RAND_egd)() ;
#line 58 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static void init_prng(void) 
{ 
  char namebuf[256] ;
  char const   *random_file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 64
  tmp = RAND_status();
  }
#line 64
  if (tmp) {
#line 66
    return;
  }
#line 71
  if (opt.random_file) {
#line 72
    random_file = (char const   *)opt.random_file;
  } else {
    {
#line 76
    namebuf[0] = (char )'\000';
#line 77
    random_file = RAND_file_name(namebuf, sizeof(namebuf));
    }
  }
#line 80
  if (random_file) {
#line 80
    if (*random_file) {
      {
#line 83
      RAND_load_file(random_file, 16384L);
      }
    }
  }
  {
#line 85
  tmp___0 = RAND_status();
  }
#line 85
  if (tmp___0) {
#line 86
    return;
  }
#line 89
  if (opt.egd_file) {
#line 89
    if (*(opt.egd_file)) {
      {
#line 90
      RAND_egd(opt.egd_file);
      }
    }
  }
  {
#line 92
  tmp___1 = RAND_status();
  }
#line 92
  if (tmp___1) {
#line 93
    return;
  }
#line 123
  return;
}
}
#line 127 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static void print_errors(void) 
{ 
  unsigned long err ;
  char *tmp ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    err = ERR_get_error();
    }
#line 131
    if (! (err != 0UL)) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp = ERR_error_string(err, (char *)((void *)0));
#line 132
    logprintf((enum log_options )1, "OpenSSL: %s\n", tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 141 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static int key_type_to_ssl_type(enum keyfile_type type ) 
{ 


  {
  {
#line 146
  if ((unsigned int )type == 0U) {
#line 146
    goto case_0;
  }
#line 148
  if ((unsigned int )type == 1U) {
#line 148
    goto case_1;
  }
#line 150
  goto switch_default;
  case_0: /* CIL Label */ 
#line 147
  return (1);
  case_1: /* CIL Label */ 
#line 149
  return (2);
  switch_default: /* CIL Label */ 
  {
#line 151
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 180
extern int ( /* missing proto */  SSLeay_add_all_algorithms)() ;
#line 189
extern int ( /* missing proto */  SSLv2_client_method)() ;
#line 192
extern int ( /* missing proto */  SSLv3_client_method)() ;
#line 160 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
_Bool ssl_init(void) 
{ 
  SSL_METHOD *meth ;
  char *tmp ;
  int tmp___0 ;
  SSL_METHOD const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  SSL_METHOD const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 165
  if (ssl_ctx) {
#line 167
    return ((_Bool)1);
  }
  {
#line 170
  init_prng();
#line 171
  tmp___0 = RAND_status();
  }
#line 171
  if (tmp___0 != 1) {
    {
#line 173
    tmp = gettext("Could not seed PRNG; consider using --random-file.\n");
#line 173
    logprintf((enum log_options )1, (char const   *)tmp);
    }
#line 175
    goto error;
  }
  {
#line 178
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
#line 179
  OPENSSL_init_ssl((uint64_t )2097154L, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
#line 180
  SSLeay_add_all_algorithms();
#line 181
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  }
  {
#line 185
  if ((unsigned int )opt.secure_protocol == 0U) {
#line 185
    goto case_0;
  }
#line 188
  if ((unsigned int )opt.secure_protocol == 1U) {
#line 188
    goto case_1;
  }
#line 191
  if ((unsigned int )opt.secure_protocol == 2U) {
#line 191
    goto case_2;
  }
#line 194
  if ((unsigned int )opt.secure_protocol == 3U) {
#line 194
    goto case_3;
  }
#line 197
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 186
  tmp___1 = TLS_client_method();
#line 186
  meth = (SSL_METHOD *)tmp___1;
  }
#line 187
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 189
  tmp___2 = SSLv2_client_method();
#line 189
  meth = (SSL_METHOD *)tmp___2;
  }
#line 190
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  tmp___3 = SSLv3_client_method();
#line 192
  meth = (SSL_METHOD *)tmp___3;
  }
#line 193
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 195
  tmp___4 = TLSv1_client_method();
#line 195
  meth = (SSL_METHOD *)tmp___4;
  }
#line 196
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 198
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 201
  ssl_ctx = SSL_CTX_new((SSL_METHOD const   *)meth);
  }
#line 202
  if (! ssl_ctx) {
#line 203
    goto error;
  }
  {
#line 205
  SSL_CTX_set_default_verify_paths(ssl_ctx);
#line 206
  SSL_CTX_load_verify_locations(ssl_ctx, (char const   *)opt.ca_cert, (char const   *)opt.ca_directory);
#line 212
  SSL_CTX_set_verify(ssl_ctx, 0, (int (*)(int preverify_ok , X509_STORE_CTX *x509_ctx ))((void *)0));
  }
#line 214
  if (opt.cert_file) {
    {
#line 215
    tmp___5 = key_type_to_ssl_type(opt.cert_type);
#line 215
    tmp___6 = SSL_CTX_use_certificate_file(ssl_ctx, (char const   *)opt.cert_file,
                                           tmp___5);
    }
#line 215
    if (tmp___6 != 1) {
#line 218
      goto error;
    }
  }
#line 219
  if (opt.private_key) {
    {
#line 220
    tmp___7 = key_type_to_ssl_type(opt.private_key_type);
#line 220
    tmp___8 = SSL_CTX_use_PrivateKey_file(ssl_ctx, (char const   *)opt.private_key,
                                          tmp___7);
    }
#line 220
    if (tmp___8 != 1) {
#line 223
      goto error;
    }
  }
  {
#line 227
  SSL_CTX_ctrl(ssl_ctx, 33, 1L, (void *)0);
#line 231
  SSL_CTX_ctrl(ssl_ctx, 33, 4L, (void *)0);
  }
#line 233
  return ((_Bool)1);
  error: 
#line 236
  if (ssl_ctx) {
    {
#line 237
    SSL_CTX_free(ssl_ctx);
    }
  }
  {
#line 238
  print_errors();
  }
#line 239
  return ((_Bool)0);
}
}
#line 247 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static int openssl_read(int fd , char *buf___4 , int bufsize , void *arg ) 
{ 
  int ret ;
  struct openssl_transport_context *ctx ;
  SSL *conn ;
  int tmp ;
  int *tmp___0 ;

  {
#line 251
  ctx = (struct openssl_transport_context *)arg;
#line 252
  conn = ctx->conn;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 254
    ret = SSL_read(conn, (void *)buf___4, bufsize);
    }
#line 253
    if (ret == -1) {
      {
#line 253
      tmp = SSL_get_error((SSL const   *)conn, ret);
      }
#line 253
      if (tmp == 5) {
        {
#line 253
        tmp___0 = __errno_location();
        }
#line 253
        if (! (*tmp___0 == 4)) {
#line 253
          goto while_break;
        }
      } else {
#line 253
        goto while_break;
      }
    } else {
#line 253
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (ret);
}
}
#line 261 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static int openssl_write(int fd , char *buf___4 , int bufsize , void *arg ) 
{ 
  int ret ;
  struct openssl_transport_context *ctx ;
  SSL *conn ;
  int tmp ;
  int *tmp___0 ;

  {
#line 264
  ret = 0;
#line 265
  ctx = (struct openssl_transport_context *)arg;
#line 266
  conn = ctx->conn;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    ret = SSL_write(conn, (void const   *)buf___4, bufsize);
    }
#line 267
    if (ret == -1) {
      {
#line 267
      tmp = SSL_get_error((SSL const   *)conn, ret);
      }
#line 267
      if (tmp == 5) {
        {
#line 267
        tmp___0 = __errno_location();
        }
#line 267
        if (! (*tmp___0 == 4)) {
#line 267
          goto while_break;
        }
      } else {
#line 267
        goto while_break;
      }
    } else {
#line 267
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (ret);
}
}
#line 275 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static int openssl_poll(int fd , double timeout , int wait_for , void *arg ) 
{ 
  struct openssl_transport_context *ctx ;
  SSL *conn ;
  int tmp ;
  int tmp___0 ;

  {
#line 278
  ctx = (struct openssl_transport_context *)arg;
#line 279
  conn = ctx->conn;
#line 280
  if (timeout == (double )0) {
#line 281
    return (1);
  }
  {
#line 282
  tmp = SSL_pending((SSL const   *)conn);
  }
#line 282
  if (tmp) {
#line 283
    return (1);
  }
  {
#line 284
  tmp___0 = select_fd(fd, timeout, wait_for);
  }
#line 284
  return (tmp___0);
}
}
#line 287 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static int openssl_peek(int fd , char *buf___4 , int bufsize , void *arg ) 
{ 
  int ret ;
  struct openssl_transport_context *ctx ;
  SSL *conn ;
  int tmp ;
  int *tmp___0 ;

  {
#line 291
  ctx = (struct openssl_transport_context *)arg;
#line 292
  conn = ctx->conn;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    ret = SSL_peek(conn, (void *)buf___4, bufsize);
    }
#line 293
    if (ret == -1) {
      {
#line 293
      tmp = SSL_get_error((SSL const   *)conn, ret);
      }
#line 293
      if (tmp == 5) {
        {
#line 293
        tmp___0 = __errno_location();
        }
#line 293
        if (! (*tmp___0 == 4)) {
#line 293
          goto while_break;
        }
      } else {
#line 293
        goto while_break;
      }
    } else {
#line 293
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (ret);
}
}
#line 301 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static char const   *openssl_errstr(int fd , void *arg ) 
{ 
  struct openssl_transport_context *ctx ;
  unsigned long errcode ;
  char *errmsg ;
  int msglen ;
  char const   *str ;
  char *tmp ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 304
  ctx = (struct openssl_transport_context *)arg;
#line 306
  errmsg = (char *)((void *)0);
#line 307
  msglen = 0;
#line 310
  errcode = ERR_get_error();
  }
#line 310
  if (errcode == 0UL) {
#line 311
    return ((char const   *)((void *)0));
  }
#line 314
  if (! (! ctx->last_error)) {
    {
#line 314
    checking_free((void *)ctx->last_error);
    }
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    tmp = ERR_error_string(errcode, (char *)((void *)0));
#line 324
    str = (char const   *)tmp;
#line 325
    tmp___0 = strlen(str);
#line 325
    len = (int )tmp___0;
#line 329
    tmp___1 = checking_realloc((void *)errmsg, (size_t )(((msglen + len) + 2) + 1));
#line 329
    errmsg = (char *)tmp___1;
#line 330
    memcpy((void */* __restrict  */)(errmsg + msglen), (void const   */* __restrict  */)str,
           (size_t )len);
#line 331
    msglen += len;
#line 334
    errcode = ERR_get_error();
    }
#line 335
    if (errcode == 0UL) {
#line 336
      goto while_break;
    }
#line 338
    tmp___2 = msglen;
#line 338
    msglen ++;
#line 338
    *(errmsg + tmp___2) = (char )';';
#line 339
    tmp___3 = msglen;
#line 339
    msglen ++;
#line 339
    *(errmsg + tmp___3) = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  *(errmsg + msglen) = (char )'\000';
#line 345
  ctx->last_error = errmsg;
#line 347
  return ((char const   *)errmsg);
}
}
#line 350 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static void openssl_close(int fd , void *arg ) 
{ 
  struct openssl_transport_context *ctx ;
  SSL *conn ;
  long tmp ;

  {
  {
#line 353
  ctx = (struct openssl_transport_context *)arg;
#line 354
  conn = ctx->conn;
#line 356
  SSL_shutdown(conn);
#line 357
  SSL_free(conn);
  }
#line 358
  if (! (! ctx->last_error)) {
    {
#line 358
    checking_free((void *)ctx->last_error);
    }
  }
  {
#line 359
  checking_free((void *)ctx);
#line 364
  close(fd);
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 367
    if (tmp) {
      {
#line 367
      debug_logprintf("Closed %d/SSL 0x%0*lx\n", fd, (int )(2UL * sizeof(void *)),
                      (unsigned long )conn);
      }
    }
#line 367
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 373 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static struct transport_implementation openssl_transport  =    {& openssl_read, & openssl_write, & openssl_poll, & openssl_peek, & openssl_errstr,
    & openssl_close};
#line 386 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
_Bool ssl_connect(int fd ) 
{ 
  SSL *conn ;
  struct openssl_transport_context *ctx ;
  long tmp ;
  int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 392
    if (tmp) {
      {
#line 392
      debug_logprintf("Initiating SSL handshake.\n");
      }
    }
#line 392
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if (! ((unsigned long )ssl_ctx != (unsigned long )((void *)0))) {
    {
#line 394
    __assert_fail("ssl_ctx != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c",
                  394U, "ssl_connect");
    }
  }
  {
#line 395
  conn = SSL_new(ssl_ctx);
  }
#line 396
  if (! conn) {
#line 397
    goto error;
  }
  {
#line 398
  tmp___1 = SSL_set_fd(conn, fd);
  }
#line 398
  if (! tmp___1) {
#line 399
    goto error;
  }
  {
#line 400
  SSL_set_connect_state(conn);
#line 404
  tmp___2 = checking_malloc0(sizeof(struct openssl_transport_context ));
#line 404
  ctx = (struct openssl_transport_context *)tmp___2;
#line 405
  ctx->conn = conn;
#line 409
  fd_register_transport(fd, & openssl_transport, (void *)ctx);
  }
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 410
    tmp___3 = __builtin_expect((long )opt.debug, 0L);
    }
#line 410
    if (tmp___3) {
      {
#line 410
      debug_logprintf("Handshake successful; connected socket %d to SSL handle 0x%0*lx\n",
                      fd, (int )(2UL * sizeof(void *)), (unsigned long )conn);
      }
    }
#line 410
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 412
  return ((_Bool)1);
  error: 
  {
#line 415
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 415
    tmp___4 = __builtin_expect((long )opt.debug, 0L);
    }
#line 415
    if (tmp___4) {
      {
#line 415
      debug_logprintf("SSL handshake failed.\n");
      }
    }
#line 415
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 416
  print_errors();
  }
#line 417
  if (conn) {
    {
#line 418
    SSL_free(conn);
    }
  }
#line 419
  return ((_Bool)0);
}
}
#line 438 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
static _Bool pattern_match(char const   *pattern , char const   *string ) 
{ 
  char const   *p___0 ;
  char const   *n ;
  char c ;
  _Bool tmp ;
  char const   *tmp___0 ;

  {
#line 441
  p___0 = pattern;
#line 441
  n = string;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    tmp___0 = p___0;
#line 443
    p___0 ++;
#line 443
    c = (char )_sch_tolower[(int const   )*tmp___0 & 255];
#line 443
    if (! ((int )c != 0)) {
#line 443
      goto while_break;
    }
#line 444
    if ((int )c == 42) {
#line 446
      c = (char )_sch_tolower[(int const   )*p___0 & 255];
      {
#line 446
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 446
        if (! ((int )c == 42)) {
#line 446
          goto while_break___0;
        }
#line 446
        p___0 ++;
#line 446
        c = (char )_sch_tolower[(int const   )*p___0 & 255];
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 448
        if (! ((int const   )*n != 0)) {
#line 448
          goto while_break___1;
        }
#line 449
        if ((int const   )_sch_tolower[(int const   )*n & 255] == (int const   )c) {
          {
#line 449
          tmp = pattern_match(p___0, n);
          }
#line 449
          if (tmp) {
#line 450
            return ((_Bool)1);
          } else {
#line 449
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 452
        if ((int const   )*n == 46) {
#line 453
          return ((_Bool)0);
        }
#line 448
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 455
      return ((_Bool )((int )c == 0));
    } else
#line 459
    if ((int )c != (int )_sch_tolower[(int const   )*n & 255]) {
#line 460
      return ((_Bool)0);
    }
#line 443
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return ((_Bool )((int const   )*n == 0));
}
}
#line 479 "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c"
_Bool ssl_check_certificate(int fd , char const   *host ) 
{ 
  X509 *cert ;
  char common_name[256] ;
  long vresult ;
  _Bool success ;
  char const   *severity ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct openssl_transport_context *ctx ;
  void *tmp___2 ;
  SSL *conn ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *subject ;
  X509_NAME *tmp___6 ;
  char *tmp___7 ;
  char *issuer ;
  X509_NAME *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  char *issuer___0 ;
  X509_NAME *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  X509_NAME *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  _Bool tmp___28 ;
  char const   *tmp___29 ;
  long tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;

  {
#line 485
  success = (_Bool)1;
#line 489
  if (opt.check_cert) {
    {
#line 489
    tmp = gettext("ERROR");
#line 489
    tmp___1 = tmp;
    }
  } else {
    {
#line 489
    tmp___0 = gettext("WARNING");
#line 489
    tmp___1 = tmp___0;
    }
  }
  {
#line 489
  severity = (char const   *)tmp___1;
#line 491
  tmp___2 = fd_transport_context(fd);
#line 491
  ctx = (struct openssl_transport_context *)tmp___2;
#line 492
  conn = ctx->conn;
  }
#line 493
  if (! ((unsigned long )conn != (unsigned long )((void *)0))) {
    {
#line 493
    __assert_fail("conn != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c",
                  493U, "ssl_check_certificate");
    }
  }
  {
#line 495
  cert = SSL_get_peer_certificate((SSL const   *)conn);
  }
#line 496
  if (! cert) {
    {
#line 498
    tmp___4 = escnonprint(host);
#line 498
    tmp___5 = gettext("%s: No certificate presented by %s.\n");
#line 498
    logprintf((enum log_options )1, (char const   *)tmp___5, severity, tmp___4);
#line 500
    success = (_Bool)0;
    }
#line 501
    goto no_cert;
  }
  {
#line 504
  tmp___13 = __builtin_expect((long )opt.debug, 0L);
  }
#line 504
  if (tmp___13) {
    {
#line 506
    tmp___6 = X509_get_subject_name((X509 const   *)cert);
#line 506
    tmp___7 = X509_NAME_oneline((X509_NAME const   *)tmp___6, (char *)0, 0);
#line 506
    subject = tmp___7;
#line 507
    tmp___8 = X509_get_issuer_name((X509 const   *)cert);
#line 507
    tmp___9 = X509_NAME_oneline((X509_NAME const   *)tmp___8, (char *)0, 0);
#line 507
    issuer = tmp___9;
    }
    {
#line 508
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 508
      tmp___12 = __builtin_expect((long )opt.debug, 0L);
      }
#line 508
      if (tmp___12) {
        {
#line 508
        tmp___10 = escnonprint((char const   *)issuer);
#line 508
        tmp___11 = escnonprint((char const   *)subject);
#line 508
        debug_logprintf("certificate:\n  subject: %s\n  issuer:  %s\n", tmp___11,
                        tmp___10);
        }
      }
#line 508
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 510
    CRYPTO_free((void *)subject, "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c",
                510);
#line 511
    CRYPTO_free((void *)issuer, "/home/khheo/project/benchmark/wget-1.11.4/src/openssl.c",
                511);
    }
  }
  {
#line 514
  vresult = SSL_get_verify_result((SSL const   *)conn);
  }
#line 515
  if (vresult != 0L) {
    {
#line 517
    tmp___14 = X509_get_issuer_name((X509 const   *)cert);
#line 517
    tmp___15 = X509_NAME_oneline((X509_NAME const   *)tmp___14, (char *)0, 0);
#line 517
    issuer___0 = tmp___15;
#line 518
    tmp___16 = escnonprint((char const   *)issuer___0);
#line 518
    tmp___17 = escnonprint(host);
#line 518
    tmp___18 = gettext("%s: cannot verify %s\'s certificate, issued by `%s\':\n");
#line 518
    logprintf((enum log_options )1, (char const   *)tmp___18, severity, tmp___17,
              tmp___16);
    }
    {
#line 525
    if (vresult == 20L) {
#line 525
      goto case_20;
    }
#line 530
    if (vresult == 18L) {
#line 530
      goto case_18;
    }
#line 530
    if (vresult == 19L) {
#line 530
      goto case_18;
    }
#line 533
    if (vresult == 9L) {
#line 533
      goto case_9;
    }
#line 536
    if (vresult == 10L) {
#line 536
      goto case_10;
    }
#line 539
    goto switch_default;
    case_20: /* CIL Label */ 
    {
#line 526
    tmp___19 = gettext("  Unable to locally verify the issuer\'s authority.\n");
#line 526
    logprintf((enum log_options )1, (char const   *)tmp___19);
    }
#line 528
    goto switch_break;
    case_18: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
#line 531
    tmp___20 = gettext("  Self-signed certificate encountered.\n");
#line 531
    logprintf((enum log_options )1, (char const   *)tmp___20);
    }
#line 532
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 534
    tmp___21 = gettext("  Issued certificate not yet valid.\n");
#line 534
    logprintf((enum log_options )1, (char const   *)tmp___21);
    }
#line 535
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 537
    tmp___22 = gettext("  Issued certificate has expired.\n");
#line 537
    logprintf((enum log_options )1, (char const   *)tmp___22);
    }
#line 538
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 542
    tmp___23 = X509_verify_cert_error_string(vresult);
#line 542
    logprintf((enum log_options )1, "  %s\n", tmp___23);
    }
    switch_break: /* CIL Label */ ;
    }
#line 545
    success = (_Bool)0;
  }
  {
#line 564
  common_name[0] = (char )'\000';
#line 565
  tmp___24 = X509_get_subject_name((X509 const   *)cert);
#line 565
  X509_NAME_get_text_by_NID(tmp___24, 13, common_name, (int )sizeof(common_name));
#line 567
  tmp___28 = pattern_match((char const   *)(common_name), host);
  }
#line 567
  if (! tmp___28) {
    {
#line 569
    tmp___25 = escnonprint(host);
#line 569
    tmp___26 = escnonprint((char const   *)(common_name));
#line 569
    tmp___27 = gettext("%s: certificate common name `%s\' doesn\'t match requested host name `%s\'.\n");
#line 569
    logprintf((enum log_options )1, (char const   *)tmp___27, severity, tmp___26,
              tmp___25);
#line 572
    success = (_Bool)0;
    }
  }
#line 575
  if (success) {
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 576
      tmp___30 = __builtin_expect((long )opt.debug, 0L);
      }
#line 576
      if (tmp___30) {
        {
#line 576
        tmp___29 = escnonprint(host);
#line 576
        debug_logprintf("X509 certificate successfully verified and matches host %s\n",
                        tmp___29);
        }
      }
#line 576
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 578
  X509_free(cert);
  }
  no_cert: 
#line 581
  if (opt.check_cert) {
#line 581
    if (! success) {
      {
#line 582
      tmp___31 = escnonprint(host);
#line 582
      tmp___32 = gettext("To connect to %s insecurely, use `--no-check-certificate\'.\n");
#line 582
      logprintf((enum log_options )1, (char const   *)tmp___32, tmp___31);
      }
    }
  }
#line 587
  if (opt.check_cert) {
#line 587
    tmp___33 = (int )success;
  } else {
#line 587
    tmp___33 = 1;
  }
#line 587
  return ((_Bool )tmp___33);
}
}
#line 42 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.h"
void search_netrc(char const   *host , char const   **acc , char const   **passwd ,
                  int slack_default ) ;
#line 43
void free_netrc(acc_t *l ) ;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/init.h"
char *home_dir(void) ;
#line 49 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
acc_t *netrc_list  ;
#line 51
static acc_t *parse_netrc(char const   *path ) ;
#line 64 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
static int processed_netrc  ;
#line 59 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
void search_netrc(char const   *host , char const   **acc , char const   **passwd ,
                  int slack_default ) 
{ 
  acc_t *l ;
  char *home ;
  char *tmp ;
  int err ;
  struct stat buf___4 ;
  char *path ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 66
  if (! opt.netrc) {
#line 67
    return;
  }
#line 69
  if (! processed_netrc) {
    {
#line 71
    tmp = home_dir();
#line 71
    home = tmp;
#line 73
    netrc_list = (acc_t *)((void *)0);
#line 74
    processed_netrc = 1;
    }
#line 75
    if (home) {
      {
#line 79
      tmp___0 = strlen((char const   *)home);
#line 79
      tmp___1 = strlen(".netrc");
#line 79
      tmp___2 = __builtin_alloca(((tmp___0 + 1UL) + tmp___1) + 1UL);
#line 79
      path = (char *)tmp___2;
#line 81
      sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%s",
              home, ".netrc");
#line 82
      checking_free((void *)home);
#line 83
      err = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf___4));
      }
#line 84
      if (err == 0) {
        {
#line 85
        netrc_list = parse_netrc((char const   *)path);
        }
      }
    }
  }
#line 89
  if (! netrc_list) {
#line 90
    return;
  }
#line 92
  if (*acc) {
#line 92
    if (*passwd) {
#line 93
      return;
    }
  }
#line 95
  l = netrc_list;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! l) {
#line 95
      goto while_break;
    }
#line 97
    if (! (! l->host)) {
      {
#line 99
      tmp___3 = strcasecmp((char const   *)l->host, host);
      }
#line 99
      if (! tmp___3) {
#line 100
        goto while_break;
      }
    }
#line 95
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (l) {
#line 104
    if (*acc) {
      {
#line 107
      tmp___4 = strcmp((char const   *)l->acc, *acc);
      }
#line 107
      if (tmp___4) {
#line 110
        *passwd = (char const   *)((void *)0);
      } else {
#line 108
        *passwd = (char const   *)l->passwd;
      }
    } else {
#line 115
      *acc = (char const   *)l->acc;
#line 116
      if (l->passwd) {
#line 117
        *passwd = (char const   *)l->passwd;
      }
    }
#line 119
    return;
  } else {
#line 123
    if (! slack_default) {
#line 124
      return;
    }
#line 125
    if (*acc) {
#line 126
      return;
    }
#line 128
    l = netrc_list;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! l) {
#line 128
        goto while_break___0;
      }
#line 129
      if (! l->host) {
#line 130
        goto while_break___0;
      }
#line 128
      l = l->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    if (! l) {
#line 132
      return;
    }
#line 133
    *acc = (char const   *)l->acc;
#line 134
    if (! *passwd) {
#line 135
      *passwd = (char const   *)l->passwd;
    }
#line 136
    return;
  }
}
}
#line 198 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
static void maybe_add_to_list(acc_t **newentry , acc_t **list ) 
{ 
  acc_t *a ;
  acc_t *l ;
  void *tmp ;

  {
#line 202
  a = *newentry;
#line 203
  l = *list;
#line 206
  if (a) {
#line 206
    if (! a->acc) {
#line 209
      if (! (! a->host)) {
        {
#line 209
        checking_free((void *)a->host);
        }
      }
#line 210
      if (! (! a->acc)) {
        {
#line 210
        checking_free((void *)a->acc);
        }
      }
#line 211
      if (! (! a->passwd)) {
        {
#line 211
        checking_free((void *)a->passwd);
        }
      }
    } else {
#line 206
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 215
    if (a) {
#line 218
      a->next = l;
#line 219
      l = a;
    }
    {
#line 223
    tmp = checking_malloc(sizeof(acc_t ));
#line 223
    a = (acc_t *)tmp;
    }
  }
  {
#line 227
  memset((void *)a, 0, sizeof(*a));
#line 230
  *newentry = a;
#line 231
  *list = l;
  }
#line 232
  return;
}
}
#line 238 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
static void shift_left(char *string ) 
{ 
  char *p___0 ;

  {
#line 243
  p___0 = string;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! *p___0) {
#line 243
      goto while_break;
    }
#line 244
    *p___0 = *(p___0 + 1);
#line 243
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 248 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
static acc_t *parse_netrc(char const   *path ) 
{ 
  FILE *fp ;
  char *line ;
  char *p___0 ;
  char *tok ;
  char const   *premature_token ;
  acc_t *current ;
  acc_t *retval ;
  int ln ;
  int quote ;
  enum __anonenum_last_token_70149392 last_token ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  acc_t *saved_reference ;

  {
  {
#line 258
  last_token = (enum __anonenum_last_token_70149392 )0;
#line 263
  retval = (acc_t *)((void *)0);
#line 263
  current = retval;
#line 265
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 266
  if (! fp) {
    {
#line 268
    tmp = __errno_location();
#line 268
    tmp___0 = strerror(*tmp);
#line 268
    tmp___1 = gettext("%s: Cannot read %s (%s).\n");
#line 268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            program_name, path, tmp___0);
    }
#line 270
    return (retval);
  }
#line 274
  ln = 0;
#line 275
  premature_token = (char const   *)((void *)0);
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 278
    line = read_whole_line(fp);
    }
#line 278
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 278
      goto while_break;
    }
#line 280
    ln ++;
#line 283
    p___0 = line;
#line 284
    quote = 0;
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 287
      if (*p___0) {
#line 287
        if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 64)) {
#line 287
          goto while_break___0;
        }
      } else {
#line 287
        goto while_break___0;
      }
#line 288
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 291
    if ((unsigned int )last_token == 3U) {
#line 291
      if (! *p___0) {
#line 293
        last_token = (enum __anonenum_last_token_70149392 )0;
      }
    }
    {
#line 296
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 296
      if (*p___0) {
#line 296
        if (! ((unsigned int )last_token != 3U)) {
#line 296
          goto while_break___1;
        }
      } else {
#line 296
        goto while_break___1;
      }
      {
#line 299
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 299
        if (*p___0) {
#line 299
          if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 64)) {
#line 299
            goto while_break___2;
          }
        } else {
#line 299
          goto while_break___2;
        }
#line 300
        p___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 304
      if ((int )*p___0 == 35) {
#line 305
        goto while_break___1;
      } else
#line 304
      if (! *p___0) {
#line 305
        goto while_break___1;
      }
#line 309
      if ((int )*p___0 == 34) {
        {
#line 310
        quote = 1;
#line 311
        shift_left(p___0);
        }
      }
#line 314
      tok = p___0;
      {
#line 317
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 317
        if (*p___0) {
#line 317
          if (quote) {
#line 317
            tmp___2 = (int )*p___0 != 34;
          } else {
#line 317
            tmp___2 = ! ((int const   )_sch_istable[(int )*p___0 & 255] & 64);
          }
#line 317
          if (! tmp___2) {
#line 317
            goto while_break___3;
          }
        } else {
#line 317
          goto while_break___3;
        }
#line 318
        if ((int )*p___0 == 92) {
          {
#line 319
          shift_left(p___0);
          }
        }
#line 320
        p___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 325
      if (quote) {
        {
#line 327
        shift_left(p___0);
#line 328
        quote = 0;
        }
      }
#line 332
      if (*p___0) {
#line 333
        tmp___3 = p___0;
#line 333
        p___0 ++;
#line 333
        *tmp___3 = (char )'\000';
      }
      {
#line 337
      if ((unsigned int )last_token == 2U) {
#line 337
        goto case_2;
      }
#line 344
      if ((unsigned int )last_token == 4U) {
#line 344
        goto case_4;
      }
#line 350
      if ((unsigned int )last_token == 5U) {
#line 350
        goto case_5;
      }
#line 358
      if ((unsigned int )last_token == 3U) {
#line 358
        goto case_3;
      }
#line 364
      if ((unsigned int )last_token == 1U) {
#line 364
        goto case_1;
      }
#line 370
      if ((unsigned int )last_token == 0U) {
#line 370
        goto case_0;
      }
#line 335
      goto switch_break;
      case_2: /* CIL Label */ 
#line 338
      if (current) {
        {
#line 339
        current->acc = checking_strdup((char const   *)tok);
        }
      } else {
#line 341
        premature_token = "login";
      }
#line 342
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 346
      maybe_add_to_list(& current, & retval);
#line 347
      current->host = checking_strdup((char const   *)tok);
      }
#line 348
      goto switch_break;
      case_5: /* CIL Label */ 
#line 351
      if (current) {
        {
#line 352
        current->passwd = checking_strdup((char const   *)tok);
        }
      } else {
#line 354
        premature_token = "password";
      }
#line 355
      goto switch_break;
      case_3: /* CIL Label */ 
#line 359
      if (! current) {
#line 360
        premature_token = "macdef";
      }
#line 361
      goto switch_break;
      case_1: /* CIL Label */ 
#line 365
      if (! current) {
#line 366
        premature_token = "account";
      }
#line 367
      goto switch_break;
      case_0: /* CIL Label */ 
#line 371
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 374
      if (premature_token) {
        {
#line 376
        tmp___4 = gettext("%s: %s:%d: warning: \"%s\" token appears before any machine name\n");
#line 376
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                program_name, path, ln, premature_token);
#line 379
        premature_token = (char const   *)((void *)0);
        }
      }
#line 382
      if ((unsigned int )last_token != 0U) {
#line 384
        last_token = (enum __anonenum_last_token_70149392 )0;
      } else {
        {
#line 388
        tmp___11 = strcmp((char const   *)tok, "account");
        }
#line 388
        if (tmp___11) {
          {
#line 390
          tmp___10 = strcmp((char const   *)tok, "default");
          }
#line 390
          if (tmp___10) {
            {
#line 394
            tmp___9 = strcmp((char const   *)tok, "login");
            }
#line 394
            if (tmp___9) {
              {
#line 397
              tmp___8 = strcmp((char const   *)tok, "macdef");
              }
#line 397
              if (tmp___8) {
                {
#line 400
                tmp___7 = strcmp((char const   *)tok, "machine");
                }
#line 400
                if (tmp___7) {
                  {
#line 403
                  tmp___6 = strcmp((char const   *)tok, "password");
                  }
#line 403
                  if (tmp___6) {
                    {
#line 407
                    tmp___5 = gettext("%s: %s:%d: unknown token \"%s\"\n");
#line 407
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                            program_name, path, ln, tok);
                    }
                  } else {
#line 404
                    last_token = (enum __anonenum_last_token_70149392 )5;
                  }
                } else {
#line 401
                  last_token = (enum __anonenum_last_token_70149392 )4;
                }
              } else {
#line 398
                last_token = (enum __anonenum_last_token_70149392 )3;
              }
            } else {
#line 395
              last_token = (enum __anonenum_last_token_70149392 )2;
            }
          } else {
            {
#line 392
            maybe_add_to_list(& current, & retval);
            }
          }
        } else {
#line 389
          last_token = (enum __anonenum_last_token_70149392 )1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 412
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  fclose(fp);
#line 418
  maybe_add_to_list(& current, & retval);
#line 419
  checking_free((void *)current);
#line 422
  current = retval;
#line 423
  retval = (acc_t *)((void *)0);
  }
  {
#line 424
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 424
    if (! current) {
#line 424
      goto while_break___4;
    }
#line 429
    saved_reference = current->next;
#line 430
    current->next = retval;
#line 433
    retval = current;
#line 434
    current = saved_reference;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 437
  return (retval);
}
}
#line 442 "/home/khheo/project/benchmark/wget-1.11.4/src/netrc.c"
void free_netrc(acc_t *l ) 
{ 
  acc_t *t ;

  {
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! l) {
#line 447
      goto while_break;
    }
#line 449
    t = l->next;
#line 450
    if (! (! l->acc)) {
      {
#line 450
      checking_free((void *)l->acc);
      }
    }
#line 451
    if (! (! l->passwd)) {
      {
#line 451
      checking_free((void *)l->passwd);
      }
    }
#line 452
    if (! (! l->host)) {
      {
#line 452
      checking_free((void *)l->host);
      }
    }
    {
#line 453
    checking_free((void *)l);
#line 454
    l = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 626 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 241 "/home/khheo/project/benchmark/wget-1.11.4/src/options.h"
struct options opt  ;
#line 47 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void log_init(char const   *file , _Bool appendp ) ;
#line 48
void log_close(void) ;
#line 50
void log_request_redirect_output(char const   *signal_name ) ;
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/init.h"
void initialize(void) ;
#line 35
void run_command(char const   *opt___0 ) ;
#line 36
void setoptval(char const   *com , char const   *val , char const   *optname ) ;
#line 38
void cleanup(void) ;
#line 102 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
void convert_all_links(void) ;
#line 37 "/home/khheo/project/benchmark/wget-1.11.4/src/http.h"
void save_cookies(void) ;
#line 101 "/home/khheo/project/benchmark/wget-1.11.4/src/getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 71 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void redirect_output_signal(int sig ) ;
#line 80 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void i18n_initialize(void) 
{ 


  {
  {
#line 86
  setlocale(6, "");
#line 88
  bindtextdomain("wget", "/usr/local/share/locale");
#line 89
  textdomain("wget");
  }
#line 91
  return;
}
}
#line 95
static void print_help(void) ;
#line 96
static void print_version(void) ;
#line 130 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static struct cmdline_option option_data[115]  = 
#line 130
  {      {"accept", (char )'A', (enum __anonenum_type_727687094 )0, (void const   *)"accept",
      -1}, 
        {"append-output", (char )'a', (enum __anonenum_type_727687094 )3, (void const   *)((void *)0),
      1}, 
        {"auth-no-challenge", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"authnochallenge",
      -1}, 
        {"background", (char )'b', (enum __anonenum_type_727687094 )1, (void const   *)"background",
      -1}, 
        {"backup-converted", (char )'K', (enum __anonenum_type_727687094 )1, (void const   *)"backupconverted",
      -1}, 
        {"backups", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"backups",
      -1}, 
        {"base", (char )'B', (enum __anonenum_type_727687094 )0, (void const   *)"base",
      -1}, 
        {"bind-address", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"bindaddress",
      -1}, 
        {"ca-certificate", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"cacertificate",
      -1}, 
        {"ca-directory", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"cadirectory",
      -1}, 
        {"cache", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"cache",
      -1}, 
        {"certificate", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"certificate",
      -1}, 
        {"certificate-type", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"certificatetype",
      -1}, 
        {"check-certificate", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"checkcertificate",
      -1}, 
        {"clobber", (char)0, (enum __anonenum_type_727687094 )4, (void const   *)((void *)0),
      2}, 
        {"connect-timeout", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"connecttimeout",
      -1}, 
        {"continue", (char )'c', (enum __anonenum_type_727687094 )1, (void const   *)"continue",
      -1}, 
        {"convert-links", (char )'k', (enum __anonenum_type_727687094 )1, (void const   *)"convertlinks",
      -1}, 
        {"content-disposition", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"contentdisposition",
      -1}, 
        {"cookies", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"cookies",
      -1}, 
        {"cut-dirs", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"cutdirs",
      -1}, 
        {"debug", (char )'d', (enum __anonenum_type_727687094 )1, (void const   *)"debug",
      -1}, 
        {"delete-after", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"deleteafter",
      -1}, 
        {"directories", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"dirstruct",
      -1}, 
        {"directory-prefix", (char )'P', (enum __anonenum_type_727687094 )0, (void const   *)"dirprefix",
      -1}, 
        {"dns-cache", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"dnscache",
      -1}, 
        {"dns-timeout", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"dnstimeout",
      -1}, 
        {"domains", (char )'D', (enum __anonenum_type_727687094 )0, (void const   *)"domains",
      -1}, 
        {"dont-remove-listing", (char)0, (enum __anonenum_type_727687094 )5, (void const   *)((void *)0),
      0}, 
        {"dot-style", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"dotstyle",
      -1}, 
        {"egd-file", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"egdfile",
      -1}, 
        {"exclude-directories", (char )'X', (enum __anonenum_type_727687094 )0, (void const   *)"excludedirectories",
      -1}, 
        {"exclude-domains", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"excludedomains",
      -1}, 
        {"execute", (char )'e', (enum __anonenum_type_727687094 )6, (void const   *)((void *)0),
      1}, 
        {"follow-ftp", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"followftp",
      -1}, 
        {"follow-tags", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"followtags",
      -1}, 
        {"force-directories", (char )'x', (enum __anonenum_type_727687094 )1, (void const   *)"dirstruct",
      -1}, 
        {"force-html", (char )'F', (enum __anonenum_type_727687094 )1, (void const   *)"forcehtml",
      -1}, 
        {"ftp-password", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"ftppassword",
      -1}, 
        {"ftp-user", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"ftpuser",
      -1}, 
        {"glob", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"glob",
      -1}, 
        {"header", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"header",
      -1}, 
        {"help", (char )'h', (enum __anonenum_type_727687094 )2, (void const   *)((void *)(& print_help)),
      0}, 
        {"host-directories", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"addhostdir",
      -1}, 
        {"html-extension", (char )'E', (enum __anonenum_type_727687094 )1, (void const   *)"htmlextension",
      -1}, 
        {"htmlify", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"htmlify",
      -1}, 
        {"http-keep-alive", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"httpkeepalive",
      -1}, 
        {"http-passwd", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"httppassword",
      -1}, 
        {"http-password", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"httppassword",
      -1}, 
        {"http-user", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"httpuser",
      -1}, 
        {"ignore-case", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"ignorecase",
      -1}, 
        {"ignore-length", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"ignorelength",
      -1}, 
        {"ignore-tags", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"ignoretags",
      -1}, 
        {"include-directories", (char )'I', (enum __anonenum_type_727687094 )0, (void const   *)"includedirectories",
      -1}, 
        {"inet4-only", (char )'4', (enum __anonenum_type_727687094 )1, (void const   *)"inet4only",
      -1}, 
        {"inet6-only", (char )'6', (enum __anonenum_type_727687094 )1, (void const   *)"inet6only",
      -1}, 
        {"input-file", (char )'i', (enum __anonenum_type_727687094 )0, (void const   *)"input",
      -1}, 
        {"keep-session-cookies", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"keepsessioncookies",
      -1}, 
        {"level", (char )'l', (enum __anonenum_type_727687094 )0, (void const   *)"reclevel",
      -1}, 
        {"limit-rate", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"limitrate",
      -1}, 
        {"load-cookies", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"loadcookies",
      -1}, 
        {"max-redirect", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"maxredirect",
      -1}, 
        {"mirror", (char )'m', (enum __anonenum_type_727687094 )1, (void const   *)"mirror",
      -1}, 
        {"no", (char )'n', (enum __anonenum_type_727687094 )7, (void const   *)((void *)0),
      1}, 
        {"no-clobber", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"noclobber",
      -1}, 
        {"no-parent", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"noparent",
      -1}, 
        {"output-document", (char )'O', (enum __anonenum_type_727687094 )0, (void const   *)"outputdocument",
      -1}, 
        {"output-file", (char )'o', (enum __anonenum_type_727687094 )0, (void const   *)"logfile",
      -1}, 
        {"page-requisites", (char )'p', (enum __anonenum_type_727687094 )1, (void const   *)"pagerequisites",
      -1}, 
        {"parent", (char)0, (enum __anonenum_type_727687094 )8, (void const   *)((void *)0),
      2}, 
        {"passive-ftp", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"passiveftp",
      -1}, 
        {"password", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"password",
      -1}, 
        {"post-data", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"postdata",
      -1}, 
        {"post-file", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"postfile",
      -1}, 
        {"prefer-family", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"preferfamily",
      -1}, 
        {"preserve-permissions", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"preservepermissions",
      -1}, 
        {"private-key", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"privatekey",
      -1}, 
        {"private-key-type", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"privatekeytype",
      -1}, 
        {"progress", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"progress",
      -1}, 
        {"protocol-directories", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"protocoldirectories",
      -1}, 
        {"proxy", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"useproxy",
      -1}, 
        {"proxy__compat", (char )'Y', (enum __anonenum_type_727687094 )0, (void const   *)"useproxy",
      -1}, 
        {"proxy-passwd", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"proxypassword",
      -1}, 
        {"proxy-password", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"proxypassword",
      -1}, 
        {"proxy-user", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"proxyuser",
      -1}, 
        {"quiet", (char )'q', (enum __anonenum_type_727687094 )1, (void const   *)"quiet",
      -1}, 
        {"quota", (char )'Q', (enum __anonenum_type_727687094 )0, (void const   *)"quota",
      -1}, 
        {"random-file", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"randomfile",
      -1}, 
        {"random-wait", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"randomwait",
      -1}, 
        {"read-timeout", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"readtimeout",
      -1}, 
        {"recursive", (char )'r', (enum __anonenum_type_727687094 )1, (void const   *)"recursive",
      -1}, 
        {"referer", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"referer",
      -1}, 
        {"reject", (char )'R', (enum __anonenum_type_727687094 )0, (void const   *)"reject",
      -1}, 
        {"relative", (char )'L', (enum __anonenum_type_727687094 )1, (void const   *)"relativeonly",
      -1}, 
        {"remove-listing", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"removelisting",
      -1}, 
        {"restrict-file-names", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"restrictfilenames",
      -1}, 
        {"retr-symlinks", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"retrsymlinks",
      -1}, 
        {"retry-connrefused", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"retryconnrefused",
      -1}, 
        {"save-cookies", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"savecookies",
      -1}, 
        {"save-headers", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"saveheaders",
      -1}, 
        {"secure-protocol", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"secureprotocol",
      -1}, 
        {"server-response", (char )'S', (enum __anonenum_type_727687094 )1, (void const   *)"serverresponse",
      -1}, 
        {"span-hosts", (char )'H', (enum __anonenum_type_727687094 )1, (void const   *)"spanhosts",
      -1}, 
        {"spider", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"spider",
      -1}, 
        {"strict-comments", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"strictcomments",
      -1}, 
        {"timeout", (char )'T', (enum __anonenum_type_727687094 )0, (void const   *)"timeout",
      -1}, 
        {"timestamping", (char )'N', (enum __anonenum_type_727687094 )1, (void const   *)"timestamping",
      -1}, 
        {"tries", (char )'t', (enum __anonenum_type_727687094 )0, (void const   *)"tries",
      -1}, 
        {"user", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"user",
      -1}, 
        {"user-agent", (char )'U', (enum __anonenum_type_727687094 )0, (void const   *)"useragent",
      -1}, 
        {"verbose", (char )'v', (enum __anonenum_type_727687094 )1, (void const   *)"verbose",
      -1}, 
        {"verbose", (char)0, (enum __anonenum_type_727687094 )1, (void const   *)"verbose",
      -1}, 
        {"version", (char )'V', (enum __anonenum_type_727687094 )2, (void const   *)((void *)(& print_version)),
      0}, 
        {"wait", (char )'w', (enum __anonenum_type_727687094 )0, (void const   *)"wait",
      -1}, 
        {"waitretry", (char)0, (enum __anonenum_type_727687094 )0, (void const   *)"waitretry",
      -1}};
#line 264 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char buffer[1024]  ;
#line 265
static char *no_prefix(char const   *s ) ;
#line 265 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char *p  =    buffer;
#line 261 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char *no_prefix(char const   *s ) 
{ 
  char *cp ;
  int size ;
  size_t tmp ;

  {
  {
#line 267
  cp = p;
#line 268
  tmp = strlen(s);
#line 268
  size = (int )((3UL + tmp) + 1UL);
  }
#line 269
  if ((unsigned long )(p + size) >= (unsigned long )(buffer + sizeof(buffer))) {
    {
#line 270
    abort();
    }
  }
  {
#line 272
  *(cp + 0) = (char )'n';
#line 272
  *(cp + 1) = (char )'o';
#line 272
  *(cp + 2) = (char )'-';
#line 273
  strcpy((char */* __restrict  */)(cp + 3), (char const   */* __restrict  */)s);
#line 274
  p += size;
  }
#line 275
  return (cp);
}
}
#line 279 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static struct option long_options[2UL * (sizeof(option_data) / sizeof(option_data[0])) + 1UL]  ;
#line 280 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char short_options[128]  ;
#line 283 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static unsigned char optmap[96]  ;
#line 291 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void init_switches(void) 
{ 
  char *p___0 ;
  int i ;
  int o ;
  struct cmdline_option *opt___0 ;
  struct option *longopt ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___5 ;

  {
#line 294
  p___0 = short_options;
#line 295
  o = 0;
#line 296
  i = 0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )i < sizeof(option_data) / sizeof(option_data[0]))) {
#line 296
      goto while_break;
    }
#line 298
    opt___0 = & option_data[i];
#line 301
    if (! opt___0->long_name) {
#line 303
      goto __Cont;
    }
#line 305
    tmp = o;
#line 305
    o ++;
#line 305
    longopt = & long_options[tmp];
#line 306
    longopt->name = opt___0->long_name;
#line 307
    longopt->val = i;
#line 308
    if (opt___0->short_name) {
#line 310
      tmp___0 = p___0;
#line 310
      p___0 ++;
#line 310
      *tmp___0 = opt___0->short_name;
#line 311
      optmap[(int )opt___0->short_name - 32] = (unsigned char )(longopt - long_options);
    }
    {
#line 315
    if ((unsigned int )opt___0->type == 0U) {
#line 315
      goto case_0;
    }
#line 320
    if ((unsigned int )opt___0->type == 1U) {
#line 320
      goto case_1;
    }
#line 337
    goto switch_default;
    case_0: /* CIL Label */ 
#line 316
    longopt->has_arg = 1;
#line 317
    if (opt___0->short_name) {
#line 318
      tmp___1 = p___0;
#line 318
      p___0 ++;
#line 318
      *tmp___1 = (char )':';
    }
#line 319
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 326
    longopt->has_arg = 2;
#line 330
    tmp___2 = o;
#line 330
    o ++;
#line 330
    longopt = & long_options[tmp___2];
#line 331
    tmp___3 = no_prefix(opt___0->long_name);
#line 331
    longopt->name = (char const   *)tmp___3;
#line 332
    longopt->has_arg = 0;
#line 335
    longopt->val = i | 1024;
    }
#line 336
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 338
    if (! (opt___0->argtype != -1)) {
      {
#line 338
      __assert_fail("opt->argtype != -1", "/home/khheo/project/benchmark/wget-1.11.4/src/main.c",
                    338U, "init_switches");
      }
    }
#line 339
    longopt->has_arg = opt___0->argtype;
#line 340
    if (opt___0->short_name) {
#line 342
      if (longopt->has_arg == 1) {
#line 343
        tmp___5 = p___0;
#line 343
        p___0 ++;
#line 343
        *tmp___5 = (char )':';
      }
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  *p___0 = (char )'\000';
#line 352
  if (! ((unsigned long )o <= sizeof(long_options) / sizeof(long_options[0]))) {
    {
#line 352
    __assert_fail("o <= countof (long_options)", "/home/khheo/project/benchmark/wget-1.11.4/src/main.c",
                  352U, "init_switches");
    }
  }
#line 353
  return;
}
}
#line 356 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void print_usage(void) 
{ 
  char *tmp ;

  {
  {
#line 359
  tmp = gettext("Usage: %s [OPTION]... [URL]...\n");
#line 359
  printf((char const   */* __restrict  */)tmp, program_name);
  }
#line 360
  return;
}
}
#line 369 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char const   *help[126]  = 
#line 369
  {      "\n",      "Mandatory arguments to long options are mandatory for short options too.\n\n",      "Startup:\n",      "  -V,  --version           display the version of Wget and exit.\n", 
        "  -h,  --help              print this help.\n",      "  -b,  --background        go to background after startup.\n",      "  -e,  --execute=COMMAND   execute a `.wgetrc\'-style command.\n",      "\n", 
        "Logging and input file:\n",      "  -o,  --output-file=FILE    log messages to FILE.\n",      "  -a,  --append-output=FILE  append messages to FILE.\n",      "  -d,  --debug               print lots of debugging information.\n", 
        "  -q,  --quiet               quiet (no output).\n",      "  -v,  --verbose             be verbose (this is the default).\n",      "  -nv, --no-verbose          turn off verboseness, without being quiet.\n",      "  -i,  --input-file=FILE     download URLs found in FILE.\n", 
        "  -F,  --force-html          treat input file as HTML.\n",      "  -B,  --base=URL            prepends URL to relative links in -F -i file.\n",      "\n",      "Download:\n", 
        "  -t,  --tries=NUMBER            set number of retries to NUMBER (0 unlimits).\n",      "       --retry-connrefused       retry even if connection is refused.\n",      "  -O,  --output-document=FILE    write documents to FILE.\n",      "  -nc, --no-clobber              skip downloads that would download to\n                                 existing files.\n", 
        "  -c,  --continue                resume getting a partially-downloaded file.\n",      "       --progress=TYPE           select progress gauge type.\n",      "  -N,  --timestamping            don\'t re-retrieve files unless newer than\n                                 local.\n",      "  -S,  --server-response         print server response.\n", 
        "       --spider                  don\'t download anything.\n",      "  -T,  --timeout=SECONDS         set all timeout values to SECONDS.\n",      "       --dns-timeout=SECS        set the DNS lookup timeout to SECS.\n",      "       --connect-timeout=SECS    set the connect timeout to SECS.\n", 
        "       --read-timeout=SECS       set the read timeout to SECS.\n",      "  -w,  --wait=SECONDS            wait SECONDS between retrievals.\n",      "       --waitretry=SECONDS       wait 1..SECONDS between retries of a retrieval.\n",      "       --random-wait             wait from 0...2*WAIT secs between retrievals.\n", 
        "       --no-proxy                explicitly turn off proxy.\n",      "  -Q,  --quota=NUMBER            set retrieval quota to NUMBER.\n",      "       --bind-address=ADDRESS    bind to ADDRESS (hostname or IP) on local host.\n",      "       --limit-rate=RATE         limit download rate to RATE.\n", 
        "       --no-dns-cache            disable caching DNS lookups.\n",      "       --restrict-file-names=OS  restrict chars in file names to ones OS allows.\n",      "       --ignore-case             ignore case when matching files/directories.\n",      "  -4,  --inet4-only              connect only to IPv4 addresses.\n", 
        "  -6,  --inet6-only              connect only to IPv6 addresses.\n",      "       --prefer-family=FAMILY    connect first to addresses of specified family,\n                                 one of IPv6, IPv4, or none.\n",      "       --user=USER               set both ftp and http user to USER.\n",      "       --password=PASS           set both ftp and http password to PASS.\n", 
        "\n",      "Directories:\n",      "  -nd, --no-directories           don\'t create directories.\n",      "  -x,  --force-directories        force creation of directories.\n", 
        "  -nH, --no-host-directories      don\'t create host directories.\n",      "       --protocol-directories     use protocol name in directories.\n",      "  -P,  --directory-prefix=PREFIX  save files to PREFIX/...\n",      "       --cut-dirs=NUMBER          ignore NUMBER remote directory components.\n", 
        "\n",      "HTTP options:\n",      "       --http-user=USER        set http user to USER.\n",      "       --http-password=PASS    set http password to PASS.\n", 
        "       --no-cache              disallow server-cached data.\n",      "  -E,  --html-extension        save HTML documents with `.html\' extension.\n",      "       --ignore-length         ignore `Content-Length\' header field.\n",      "       --header=STRING         insert STRING among the headers.\n", 
        "       --max-redirect          maximum redirections allowed per page.\n",      "       --proxy-user=USER       set USER as proxy username.\n",      "       --proxy-password=PASS   set PASS as proxy password.\n",      "       --referer=URL           include `Referer: URL\' header in HTTP request.\n", 
        "       --save-headers          save the HTTP headers to file.\n",      "  -U,  --user-agent=AGENT      identify as AGENT instead of Wget/VERSION.\n",      "       --no-http-keep-alive    disable HTTP keep-alive (persistent connections).\n",      "       --no-cookies            don\'t use cookies.\n", 
        "       --load-cookies=FILE     load cookies from FILE before session.\n",      "       --save-cookies=FILE     save cookies to FILE after session.\n",      "       --keep-session-cookies  load and save session (non-permanent) cookies.\n",      "       --post-data=STRING      use the POST method; send STRING as the data.\n", 
        "       --post-file=FILE        use the POST method; send contents of FILE.\n",      "       --content-disposition   honor the Content-Disposition header when\n                               choosing local file names (EXPERIMENTAL).\n",      "       --auth-no-challenge     Send Basic HTTP authentication information\n                               without first waiting for the server\'s\n                               challenge.\n",      "\n", 
        "HTTPS (SSL/TLS) options:\n",      "       --secure-protocol=PR     choose secure protocol, one of auto, SSLv2,\n                                SSLv3, and TLSv1.\n",      "       --no-check-certificate   don\'t validate the server\'s certificate.\n",      "       --certificate=FILE       client certificate file.\n", 
        "       --certificate-type=TYPE  client certificate type, PEM or DER.\n",      "       --private-key=FILE       private key file.\n",      "       --private-key-type=TYPE  private key type, PEM or DER.\n",      "       --ca-certificate=FILE    file with the bundle of CA\'s.\n", 
        "       --ca-directory=DIR       directory where hash list of CA\'s is stored.\n",      "       --random-file=FILE       file with random data for seeding the SSL PRNG.\n",      "       --egd-file=FILE          file naming the EGD socket with random data.\n",      "\n", 
        "FTP options:\n",      "       --ftp-user=USER         set ftp user to USER.\n",      "       --ftp-password=PASS     set ftp password to PASS.\n",      "       --no-remove-listing     don\'t remove `.listing\' files.\n", 
        "       --no-glob               turn off FTP file name globbing.\n",      "       --no-passive-ftp        disable the \"passive\" transfer mode.\n",      "       --retr-symlinks         when recursing, get linked-to files (not dir).\n",      "       --preserve-permissions  preserve remote file permissions.\n", 
        "\n",      "Recursive download:\n",      "  -r,  --recursive          specify recursive download.\n",      "  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).\n", 
        "       --delete-after       delete files locally after downloading them.\n",      "  -k,  --convert-links      make links in downloaded HTML point to local files.\n",      "  -K,  --backup-converted   before converting file X, back up as X.orig.\n",      "  -m,  --mirror             shortcut for -N -r -l inf --no-remove-listing.\n", 
        "  -p,  --page-requisites    get all images, etc. needed to display HTML page.\n",      "       --strict-comments    turn on strict (SGML) handling of HTML comments.\n",      "\n",      "Recursive accept/reject:\n", 
        "  -A,  --accept=LIST               comma-separated list of accepted extensions.\n",      "  -R,  --reject=LIST               comma-separated list of rejected extensions.\n",      "  -D,  --domains=LIST              comma-separated list of accepted domains.\n",      "       --exclude-domains=LIST      comma-separated list of rejected domains.\n", 
        "       --follow-ftp                follow FTP links from HTML documents.\n",      "       --follow-tags=LIST          comma-separated list of followed HTML tags.\n",      "       --ignore-tags=LIST          comma-separated list of ignored HTML tags.\n",      "  -H,  --span-hosts                go to foreign hosts when recursive.\n", 
        "  -L,  --relative                  follow relative links only.\n",      "  -I,  --include-directories=LIST  list of allowed directories.\n",      "  -X,  --exclude-directories=LIST  list of excluded directories.\n",      "  -np, --no-parent                 don\'t ascend to the parent directory.\n", 
        "\n",      "Mail bug reports and suggestions to <bug-wget@gnu.org>.\n"};
#line 364 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void print_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 641
  tmp = gettext("GNU Wget %s, a non-interactive network retriever.\n");
#line 641
  printf((char const   */* __restrict  */)tmp, version_string);
#line 643
  print_usage();
#line 645
  i = 0;
  }
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! ((unsigned long )i < sizeof(help) / sizeof(help[0]))) {
#line 645
      goto while_break;
    }
    {
#line 646
    tmp___0 = gettext(help[i]);
#line 646
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
#line 645
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 648
  exit(0);
  }
}
}
#line 657 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char buf___2[32]  ;
#line 654 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static char *secs_to_human_time(double interval ) 
{ 
  int secs ;
  int hours ;
  int mins ;
  int days ;
  char const   *tmp ;

  {
#line 658
  secs = (int )(interval + 0.5);
#line 661
  days = secs / 86400;
#line 661
  secs %= 86400;
#line 662
  hours = secs / 3600;
#line 662
  secs %= 3600;
#line 663
  mins = secs / 60;
#line 663
  secs %= 60;
#line 665
  if (days) {
    {
#line 666
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%dd %dh %dm %ds",
            days, hours, mins, secs);
    }
  } else
#line 667
  if (hours) {
    {
#line 668
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%dh %dm %ds",
            hours, mins, secs);
    }
  } else
#line 669
  if (mins) {
    {
#line 670
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%dm %ds",
            mins, secs);
    }
  } else {
    {
#line 672
    tmp = print_decimal(interval);
#line 672
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%ss",
            tmp);
    }
  }
#line 674
  return (buf___2);
}
}
#line 677 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void print_version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 680
  printf((char const   */* __restrict  */)"GNU Wget %s\n\n", version_string);
#line 681
  tmp = gettext("Copyright (C) 2008 Free Software Foundation, Inc.\n");
#line 681
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stdout);
#line 683
  tmp___0 = gettext("License GPLv3+: GNU GPL version 3 or later\n<http://www.gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n");
#line 683
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
#line 688
  tmp___1 = gettext("\nOriginally written by Hrvoje Niksic <hniksic@xemacs.org>.\n");
#line 688
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 690
  tmp___2 = gettext("Currently maintained by Micah Cowan <micah@cowan.name>.\n");
#line 690
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 692
  exit(0);
  }
}
}
#line 696 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
int main(int argc , char * const  *argv ) 
{ 
  char **url ;
  char **t ;
  int i ;
  int ret ;
  int longindex ;
  int nurl ;
  int status ;
  _Bool append_to_log ;
  int val ;
  struct cmdline_option *opt___0 ;
  char *tmp ;
  _Bool neg ;
  char const   *tmp___0 ;
  void (*func)(void) ;
  char *p___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool flag ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  char *rewritten ;
  char *tmp___17 ;
  long tmp___18 ;
  struct stat st ;
  char const   *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  __sighandler_t tmp___22 ;
  char *filename ;
  char *redirected_URL ;
  int dt ;
  int old_follow_ftp ;
  enum url_scheme tmp___23 ;
  uerr_t tmp___24 ;
  uerr_t tmp___25 ;
  enum url_scheme tmp___26 ;
  _Bool tmp___27 ;
  long tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  _Bool tmp___33 ;
  int count ;
  uerr_t tmp___34 ;
  char *tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  time_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;

  {
  {
#line 702
  append_to_log = (_Bool)0;
#line 704
  i18n_initialize();
#line 707
  set_program_name((char const   *)*(argv + 0));
#line 715
  initialize();
#line 717
  init_switches();
#line 718
  longindex = -1;
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 719
    ret = getopt_long(argc, argv, (char const   *)(short_options), (struct option  const  *)(long_options),
                      & longindex);
    }
#line 719
    if (! (ret != -1)) {
#line 719
      goto while_break;
    }
#line 727
    if (longindex == -1) {
#line 729
      if (ret == 63) {
        {
#line 731
        print_usage();
#line 732
        printf((char const   */* __restrict  */)"\n");
#line 733
        tmp = gettext("Try `%s --help\' for more options.\n");
#line 733
        printf((char const   */* __restrict  */)tmp, program_name);
#line 734
        exit(2);
        }
      }
#line 737
      longindex = (int )optmap[ret - 32];
    }
#line 739
    val = long_options[longindex].val;
#line 744
    opt___0 = & option_data[val & -1025];
    {
#line 747
    if ((unsigned int )opt___0->type == 0U) {
#line 747
      goto case_0;
    }
#line 750
    if ((unsigned int )opt___0->type == 1U) {
#line 750
      goto case_1;
    }
#line 761
    if ((unsigned int )opt___0->type == 2U) {
#line 761
      goto case_2;
    }
#line 767
    if ((unsigned int )opt___0->type == 3U) {
#line 767
      goto case_3;
    }
#line 771
    if ((unsigned int )opt___0->type == 6U) {
#line 771
      goto case_6;
    }
#line 774
    if ((unsigned int )opt___0->type == 7U) {
#line 774
      goto case_7;
    }
#line 808
    if ((unsigned int )opt___0->type == 4U) {
#line 808
      goto case_4;
    }
#line 808
    if ((unsigned int )opt___0->type == 8U) {
#line 808
      goto case_4;
    }
#line 822
    if ((unsigned int )opt___0->type == 5U) {
#line 822
      goto case_5;
    }
#line 745
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 748
    setoptval((char const   *)opt___0->data, (char const   *)optarg, opt___0->long_name);
    }
#line 749
    goto switch_break;
    case_1: /* CIL Label */ 
#line 751
    if (optarg) {
      {
#line 753
      setoptval((char const   *)opt___0->data, (char const   *)optarg, opt___0->long_name);
      }
    } else {
#line 757
      neg = (_Bool )(! (! (val & 1024)));
#line 758
      if (neg) {
#line 758
        tmp___0 = "0";
      } else {
#line 758
        tmp___0 = "1";
      }
      {
#line 758
      setoptval((char const   *)opt___0->data, tmp___0, opt___0->long_name);
      }
    }
#line 760
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 763
    func = (void (*)(void))opt___0->data;
#line 764
    (*func)();
    }
#line 766
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 768
    setoptval("logfile", (char const   *)optarg, opt___0->long_name);
#line 769
    append_to_log = (_Bool)1;
    }
#line 770
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 772
    run_command((char const   *)optarg);
    }
#line 773
    goto switch_break;
    case_7: /* CIL Label */ 
#line 780
    p___0 = optarg;
    {
#line 780
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 780
      if (! *p___0) {
#line 780
        goto while_break___0;
      }
      {
#line 783
      if ((int )*p___0 == 118) {
#line 783
        goto case_118;
      }
#line 786
      if ((int )*p___0 == 72) {
#line 786
        goto case_72;
      }
#line 789
      if ((int )*p___0 == 100) {
#line 789
        goto case_100;
      }
#line 792
      if ((int )*p___0 == 99) {
#line 792
        goto case_99;
      }
#line 795
      if ((int )*p___0 == 112) {
#line 795
        goto case_112;
      }
#line 798
      goto switch_default;
      case_118: /* CIL Label */ 
      {
#line 784
      setoptval("verbose", "0", opt___0->long_name);
      }
#line 785
      goto switch_break___0;
      case_72: /* CIL Label */ 
      {
#line 787
      setoptval("addhostdir", "0", opt___0->long_name);
      }
#line 788
      goto switch_break___0;
      case_100: /* CIL Label */ 
      {
#line 790
      setoptval("dirstruct", "0", opt___0->long_name);
      }
#line 791
      goto switch_break___0;
      case_99: /* CIL Label */ 
      {
#line 793
      setoptval("noclobber", "1", opt___0->long_name);
      }
#line 794
      goto switch_break___0;
      case_112: /* CIL Label */ 
      {
#line 796
      setoptval("noparent", "1", opt___0->long_name);
      }
#line 797
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 799
      tmp___1 = gettext("%s: illegal option -- `-n%c\'\n");
#line 799
      printf((char const   */* __restrict  */)tmp___1, program_name, (int )*p___0);
#line 800
      print_usage();
#line 801
      printf((char const   */* __restrict  */)"\n");
#line 802
      tmp___2 = gettext("Try `%s --help\' for more options.\n");
#line 802
      printf((char const   */* __restrict  */)tmp___2, program_name);
#line 803
      exit(1);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 780
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 805
    goto switch_break;
    case_4: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 813
    flag = (_Bool)1;
#line 814
    if (optarg) {
#line 815
      if ((int )*optarg == 49) {
#line 815
        tmp___3 = 1;
      } else
#line 815
      if ((int const   )_sch_tolower[(int )*optarg & 255] == 121) {
#line 815
        tmp___3 = 1;
      } else
#line 815
      if ((int const   )_sch_tolower[(int )*(optarg + 0) & 255] == 111) {
#line 815
        if ((int const   )_sch_tolower[(int )*(optarg + 1) & 255] == 110) {
#line 815
          tmp___3 = 1;
        } else {
#line 815
          tmp___3 = 0;
        }
      } else {
#line 815
        tmp___3 = 0;
      }
#line 815
      flag = (_Bool )tmp___3;
    }
#line 818
    if (flag) {
#line 818
      tmp___4 = "0";
    } else {
#line 818
      tmp___4 = "1";
    }
#line 818
    if ((unsigned int )opt___0->type == 8U) {
#line 818
      tmp___5 = "noparent";
    } else {
#line 818
      tmp___5 = "noclobber";
    }
    {
#line 818
    setoptval(tmp___5, tmp___4, opt___0->long_name);
    }
#line 820
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 823
    setoptval("removelisting", "0", opt___0->long_name);
    }
#line 824
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 827
    longindex = -1;
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  nurl = argc - optind;
#line 835
  if (opt.reclevel == 0) {
#line 836
    opt.reclevel = -1;
  }
#line 838
  if (opt.page_requisites) {
#line 838
    if (! opt.recursive) {
#line 843
      opt.reclevel = 0;
#line 844
      if (! opt.no_dirstruct) {
#line 845
        opt.dirstruct = (_Bool)1;
      }
    }
  }
#line 848
  if (opt.verbose == -1) {
#line 849
    opt.verbose = ! opt.quiet;
  }
#line 852
  if (opt.verbose) {
#line 852
    if (opt.quiet) {
      {
#line 854
      tmp___6 = gettext("Can\'t be verbose and quiet at the same time.\n");
#line 854
      printf((char const   */* __restrict  */)tmp___6);
#line 855
      print_usage();
#line 856
      exit(1);
      }
    }
  }
#line 858
  if (opt.timestamping) {
#line 858
    if (opt.noclobber) {
      {
#line 860
      tmp___7 = gettext("Can\'t timestamp and not clobber old files at the same time.\n");
#line 860
      printf((char const   */* __restrict  */)tmp___7);
#line 862
      print_usage();
#line 863
      exit(1);
      }
    }
  }
#line 866
  if (opt.ipv4_only) {
#line 866
    if (opt.ipv6_only) {
      {
#line 868
      tmp___8 = gettext("Cannot specify both --inet4-only and --inet6-only.\n");
#line 868
      printf((char const   */* __restrict  */)tmp___8);
#line 869
      print_usage();
#line 870
      exit(1);
      }
    }
  }
#line 873
  if (opt.output_document) {
#line 875
    if (opt.convert_links) {
#line 875
      if (nurl > 1) {
        {
#line 878
        tmp___9 = gettext("Cannot specify both -k and -O if multiple URLs are given, or in combination\nwith -p or -r. See the manual for details.\n\n");
#line 878
        fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 881
        print_usage();
#line 882
        exit(1);
        }
      } else
#line 875
      if (opt.page_requisites) {
        {
#line 878
        tmp___9 = gettext("Cannot specify both -k and -O if multiple URLs are given, or in combination\nwith -p or -r. See the manual for details.\n\n");
#line 878
        fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 881
        print_usage();
#line 882
        exit(1);
        }
      } else
#line 875
      if (opt.recursive) {
        {
#line 878
        tmp___9 = gettext("Cannot specify both -k and -O if multiple URLs are given, or in combination\nwith -p or -r. See the manual for details.\n\n");
#line 878
        fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 881
        print_usage();
#line 882
        exit(1);
        }
      }
    }
#line 884
    if (opt.page_requisites) {
      {
#line 887
      tmp___10 = gettext("WARNING: combining -O with -r or -p will mean that all downloaded content\nwill be placed in the single file you specified.\n\n");
#line 887
      logprintf((enum log_options )1, "%s", tmp___10);
      }
    } else
#line 884
    if (opt.recursive) {
      {
#line 887
      tmp___10 = gettext("WARNING: combining -O with -r or -p will mean that all downloaded content\nwill be placed in the single file you specified.\n\n");
#line 887
      logprintf((enum log_options )1, "%s", tmp___10);
      }
    }
#line 891
    if (opt.timestamping) {
      {
#line 893
      tmp___11 = gettext("WARNING: timestamping does nothing in combination with -O. See the manual\nfor details.\n\n");
#line 893
      logprintf((enum log_options )1, "%s", tmp___11);
#line 896
      opt.timestamping = (_Bool)0;
      }
    }
#line 898
    if (opt.noclobber) {
      {
#line 898
      tmp___13 = file_exists_p((char const   *)opt.output_document);
      }
#line 898
      if (tmp___13) {
        {
#line 901
        tmp___12 = gettext("File `%s\' already there; not retrieving.\n");
#line 901
        logprintf((enum log_options )0, (char const   *)tmp___12, opt.output_document);
#line 902
        exit(1);
        }
      }
    }
  }
#line 906
  if (! nurl) {
#line 906
    if (! opt.input_filename) {
      {
#line 909
      tmp___14 = gettext("%s: missing URL\n");
#line 909
      printf((char const   */* __restrict  */)tmp___14, program_name);
#line 910
      print_usage();
#line 911
      printf((char const   */* __restrict  */)"\n");
#line 914
      tmp___15 = gettext("Try `%s --help\' for more options.\n");
#line 914
      printf((char const   */* __restrict  */)tmp___15, program_name);
#line 915
      exit(1);
      }
    }
  }
#line 923
  if (opt.background) {
    {
#line 924
    fork_to_background();
    }
  }
#line 929
  if (opt.verbose) {
    {
#line 930
    set_progress_implementation((char const   *)opt.progress_type);
    }
  }
  {
#line 933
  tmp___16 = __builtin_alloca((unsigned long )(nurl + 1) * sizeof(char *));
#line 933
  url = (char **)tmp___16;
#line 934
  i = 0;
  }
  {
#line 934
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 934
    if (! (i < nurl)) {
#line 934
      goto while_break___1;
    }
    {
#line 936
    tmp___17 = rewrite_shorthand_url((char const   *)*(argv + optind));
#line 936
    rewritten = tmp___17;
    }
#line 937
    if (rewritten) {
#line 938
      *(url + i) = rewritten;
    } else {
      {
#line 940
      *(url + i) = checking_strdup((char const   *)*(argv + optind));
      }
    }
#line 934
    i ++;
#line 934
    optind ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 942
  *(url + i) = (char *)((void *)0);
#line 945
  log_init((char const   *)opt.lfilename, append_to_log);
  }
  {
#line 947
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 947
    tmp___18 = __builtin_expect((long )opt.debug, 0L);
    }
#line 947
    if (tmp___18) {
      {
#line 947
      debug_logprintf("DEBUG output created by Wget %s on %s.\n\n", version_string,
                      "linux-gnu");
      }
    }
#line 947
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 951
  if (opt.output_document) {
#line 953
    if ((int )*(opt.output_document) == 45) {
#line 953
      if (! *(opt.output_document + 1)) {
#line 954
        output_stream = stdout;
      } else {
#line 953
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 958
      if (opt.always_rest) {
#line 958
        tmp___19 = "ab";
      } else {
#line 958
        tmp___19 = "wb";
      }
      {
#line 958
      output_stream = fopen((char const   */* __restrict  */)opt.output_document,
                            (char const   */* __restrict  */)tmp___19);
      }
#line 960
      if ((unsigned long )output_stream == (unsigned long )((void *)0)) {
        {
#line 962
        perror((char const   *)opt.output_document);
#line 963
        exit(1);
        }
      }
      {
#line 965
      tmp___20 = fileno(output_stream);
#line 965
      tmp___21 = fstat(tmp___20, & st);
      }
#line 965
      if (tmp___21 == 0) {
#line 965
        if ((st.st_mode & 61440U) == 32768U) {
#line 966
          output_stream_regular = (_Bool)1;
        }
      }
    }
  }
  {
#line 977
  tmp___22 = signal(1, (void (*)(int  ))1);
  }
#line 977
  if ((unsigned long )tmp___22 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 978
    signal(1, & redirect_output_signal);
    }
  }
  {
#line 982
  signal(10, & redirect_output_signal);
#line 988
  signal(13, (void (*)(int  ))1);
#line 991
  signal(28, & progress_handle_sigwinch);
#line 994
  status = 31;
#line 996
  t = url;
  }
  {
#line 996
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 996
    if (! *t) {
#line 996
      goto while_break___3;
    }
#line 998
    filename = (char *)((void *)0);
#line 998
    redirected_URL = (char *)((void *)0);
#line 1001
    if (opt.recursive) {
#line 1001
      goto _L___1;
    } else
#line 1001
    if (opt.page_requisites) {
      _L___1: /* CIL Label */ 
      {
#line 1001
      tmp___26 = url_scheme((char const   *)*t);
      }
#line 1001
      if ((unsigned int )tmp___26 != 2U) {
#line 1001
        goto _L___0;
      } else {
        {
#line 1001
        tmp___27 = url_uses_proxy((char const   *)*t);
        }
#line 1001
        if (tmp___27) {
          _L___0: /* CIL Label */ 
          {
#line 1004
          old_follow_ftp = (int )opt.follow_ftp;
#line 1007
          tmp___23 = url_scheme((char const   *)*t);
          }
#line 1007
          if ((unsigned int )tmp___23 == 2U) {
#line 1008
            opt.follow_ftp = (_Bool)1;
          }
          {
#line 1010
          tmp___24 = retrieve_tree((char const   *)*t);
#line 1010
          status = (int )tmp___24;
#line 1012
          opt.follow_ftp = (_Bool )old_follow_ftp;
          }
        } else {
          {
#line 1015
          tmp___25 = retrieve_url((char const   *)*t, & filename, & redirected_URL,
                                  (char const   *)((void *)0), & dt, opt.recursive);
#line 1015
          status = (int )tmp___25;
          }
        }
      }
    } else {
      {
#line 1015
      tmp___25 = retrieve_url((char const   *)*t, & filename, & redirected_URL, (char const   *)((void *)0),
                              & dt, opt.recursive);
#line 1015
      status = (int )tmp___25;
      }
    }
#line 1017
    if (opt.delete_after) {
      {
#line 1017
      tmp___33 = file_exists_p((char const   *)filename);
      }
#line 1017
      if (tmp___33) {
        {
#line 1019
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1019
          tmp___28 = __builtin_expect((long )opt.debug, 0L);
          }
#line 1019
          if (tmp___28) {
            {
#line 1019
            debug_logprintf("Removing file due to --delete-after in main():\n");
            }
          }
#line 1019
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1020
        tmp___29 = gettext("Removing %s.\n");
#line 1020
        logprintf((enum log_options )0, (char const   *)tmp___29, filename);
#line 1021
        tmp___32 = unlink((char const   *)filename);
        }
#line 1021
        if (tmp___32) {
          {
#line 1022
          tmp___30 = __errno_location();
#line 1022
          tmp___31 = strerror(*tmp___30);
#line 1022
          logprintf((enum log_options )1, "unlink: %s\n", tmp___31);
          }
        }
      }
    }
#line 1025
    if (! (! redirected_URL)) {
      {
#line 1025
      checking_free((void *)redirected_URL);
      }
    }
#line 1026
    if (! (! filename)) {
      {
#line 1026
      checking_free((void *)filename);
      }
    }
#line 996
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1030
  if (opt.input_filename) {
    {
#line 1033
    tmp___34 = retrieve_from_file((char const   *)opt.input_filename, opt.force_html,
                                  & count);
#line 1033
    status = (int )tmp___34;
    }
#line 1034
    if (! count) {
      {
#line 1035
      tmp___35 = gettext("No URLs found in %s.\n");
#line 1035
      logprintf((enum log_options )1, (char const   *)tmp___35, opt.input_filename);
      }
    }
  }
#line 1040
  if (opt.recursive) {
#line 1040
    if (opt.spider) {
      {
#line 1042
      print_broken_links();
      }
    }
  }
#line 1046
  if (opt.recursive) {
#line 1046
    goto _L___2;
  } else
#line 1046
  if (opt.page_requisites) {
#line 1046
    goto _L___2;
  } else
#line 1046
  if (nurl > 1) {
#line 1046
    goto _L___2;
  } else
#line 1046
  if (opt.input_filename) {
#line 1046
    if (total_downloaded_bytes != 0L) {
      _L___2: /* CIL Label */ 
#line 1046
      if (total_downloaded_bytes != 0L) {
        {
#line 1052
        tmp___36 = retr_rate(total_downloaded_bytes, total_download_time);
#line 1052
        tmp___37 = secs_to_human_time(total_download_time);
#line 1052
        tmp___38 = human_readable(total_downloaded_bytes);
#line 1052
        tmp___39 = time((time_t *)((void *)0));
#line 1052
        tmp___40 = datetime_str(tmp___39);
#line 1052
        tmp___41 = gettext("FINISHED --%s--\nDownloaded: %d files, %s in %s (%s)\n");
#line 1052
        logprintf((enum log_options )1, (char const   *)tmp___41, tmp___40, opt.numurls,
                  tmp___38, tmp___37, tmp___36);
        }
#line 1060
        if (opt.quota) {
#line 1060
          if (total_downloaded_bytes > opt.quota) {
            {
#line 1061
            tmp___42 = human_readable(opt.quota);
#line 1061
            tmp___43 = gettext("Download quota of %s EXCEEDED!\n");
#line 1061
            logprintf((enum log_options )1, (char const   *)tmp___43, tmp___42);
            }
          }
        }
      }
    }
  }
#line 1066
  if (opt.cookies_output) {
    {
#line 1067
    save_cookies();
    }
  }
#line 1069
  if (opt.convert_links) {
#line 1069
    if (! opt.delete_after) {
      {
#line 1070
      convert_all_links();
      }
    }
  }
  {
#line 1072
  log_close();
#line 1073
  i = 0;
  }
  {
#line 1073
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1073
    if (! (i < nurl)) {
#line 1073
      goto while_break___5;
    }
    {
#line 1074
    checking_free((void *)*(url + i));
#line 1073
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1075
  cleanup();
  }
#line 1080
  if (status == 31) {
#line 1081
    return (0);
  } else {
#line 1083
    return (1);
  }
}
}
#line 1101 "/home/khheo/project/benchmark/wget-1.11.4/src/main.c"
static void redirect_output_signal(int sig ) 
{ 
  char const   *signal_name ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1104
  if (sig == 1) {
#line 1104
    tmp___0 = "SIGHUP";
  } else {
#line 1104
    if (sig == 10) {
#line 1104
      tmp = "SIGUSR1";
    } else {
#line 1104
      tmp = "WTF?!";
    }
#line 1104
    tmp___0 = tmp;
  }
  {
#line 1104
  signal_name = tmp___0;
#line 1107
  log_request_redirect_output(signal_name);
#line 1108
  progress_schedule_redirect();
#line 1109
  signal(sig, & redirect_output_signal);
  }
#line 1110
  return;
}
}
#line 327 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 344
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 43 "/home/khheo/project/benchmark/wget-1.11.4/src/log.h"
void logflush(void) ;
#line 49
void log_cleanup(void) ;
#line 70 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static FILE *logfp  ;
#line 74 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool inhibit_logging  ;
#line 77 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool save_context_p  ;
#line 80 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool flush_log_p  =    (_Bool)1;
#line 83 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool needs_flushing  ;
#line 109 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static struct log_ln log_lines[24]  ;
#line 121 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static int log_line_current  =    -1;
#line 127 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool trailing_line  ;
#line 129
static void check_redirect_output(void) ;
#line 140 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void free_log_line(int num ) 
{ 
  struct log_ln *ln ;

  {
#line 143
  ln = log_lines + num;
#line 144
  if (ln->malloced_line) {
    {
#line 146
    checking_free((void *)ln->malloced_line);
#line 147
    ln->malloced_line = (char *)((void *)0);
    }
  }
#line 149
  ln->content = (char *)((void *)0);
#line 150
  return;
}
}
#line 156 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void saved_append_1(char const   *start , char const   *end ) 
{ 
  int len ;
  struct log_ln *ln ;
  struct log_ln *ln___0 ;
  int old_len ;
  size_t tmp ;
  void *tmp___0 ;
  int old_len___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 159
  len = (int )(end - start);
#line 160
  if (! len) {
#line 161
    return;
  }
#line 165
  if (! trailing_line) {
#line 170
    if (log_line_current == -1) {
#line 171
      log_line_current = 0;
    } else {
      {
#line 173
      free_log_line(log_line_current);
      }
    }
#line 174
    ln = log_lines + log_line_current;
#line 175
    if (len > 128) {
      {
#line 177
      ln->malloced_line = strdupdelim(start, end);
#line 178
      ln->content = ln->malloced_line;
      }
    } else {
      {
#line 182
      memcpy((void */* __restrict  */)(ln->static_line), (void const   */* __restrict  */)start,
             (size_t )len);
#line 183
      ln->static_line[len] = (char )'\000';
#line 184
      ln->content = ln->static_line;
      }
    }
  } else {
#line 194
    ln___0 = log_lines + log_line_current;
#line 195
    if (ln___0->malloced_line) {
      {
#line 198
      tmp = strlen((char const   *)ln___0->malloced_line);
#line 198
      old_len = (int )tmp;
#line 199
      tmp___0 = checking_realloc((void *)ln___0->malloced_line, (size_t )((old_len + len) + 1));
#line 199
      ln___0->malloced_line = (char *)tmp___0;
#line 200
      memcpy((void */* __restrict  */)(ln___0->malloced_line + old_len), (void const   */* __restrict  */)start,
             (size_t )len);
#line 201
      *(ln___0->malloced_line + (old_len + len)) = (char )'\000';
#line 203
      ln___0->content = ln___0->malloced_line;
      }
    } else {
      {
#line 207
      tmp___1 = strlen((char const   *)(ln___0->static_line));
#line 207
      old_len___0 = (int )tmp___1;
      }
#line 208
      if (old_len___0 + len > 128) {
        {
#line 212
        tmp___2 = checking_malloc((size_t )((old_len___0 + len) + 1));
#line 212
        ln___0->malloced_line = (char *)tmp___2;
#line 213
        memcpy((void */* __restrict  */)ln___0->malloced_line, (void const   */* __restrict  */)(ln___0->static_line),
               (size_t )old_len___0);
#line 215
        memcpy((void */* __restrict  */)(ln___0->malloced_line + old_len___0), (void const   */* __restrict  */)start,
               (size_t )len);
#line 216
        *(ln___0->malloced_line + (old_len___0 + len)) = (char )'\000';
#line 217
        ln___0->content = ln___0->malloced_line;
        }
      } else {
        {
#line 223
        memcpy((void */* __restrict  */)(ln___0->static_line + old_len___0), (void const   */* __restrict  */)start,
               (size_t )len);
#line 224
        ln___0->static_line[old_len___0 + len] = (char )'\000';
#line 225
        ln___0->content = ln___0->static_line;
        }
      }
    }
  }
#line 229
  trailing_line = (_Bool )(! ((int const   )*(end + -1) == 10));
#line 230
  if (! trailing_line) {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      log_line_current ++;
#line 231
      if (log_line_current >= 24) {
#line 231
        log_line_current = 0;
      }
#line 231
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 232
  return;
}
}
#line 239 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void saved_append(char const   *s ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! *s) {
#line 242
      goto while_break;
    }
    {
#line 244
    tmp = strchr(s, '\n');
#line 244
    end = (char const   *)tmp;
    }
#line 245
    if (! end) {
      {
#line 246
      tmp___0 = strlen(s);
#line 246
      end = s + tmp___0;
      }
    } else {
#line 248
      end ++;
    }
    {
#line 249
    saved_append_1(s, end);
#line 250
    s = end;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 288 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static FILE *get_log_fp(void) 
{ 


  {
#line 291
  if (inhibit_logging) {
#line 292
    return ((FILE *)((void *)0));
  }
#line 293
  if (logfp) {
#line 294
    return (logfp);
  }
#line 295
  return (stderr);
}
}
#line 301 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void logputs(enum log_options o , char const   *s ) 
{ 
  FILE *fp ;

  {
  {
#line 306
  check_redirect_output();
#line 307
  fp = get_log_fp();
  }
#line 307
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 308
    return;
  }
  {
#line 309
  if ((unsigned int )o == 3U) {
#line 309
    goto case_3;
  }
#line 309
  if ((unsigned int )o == 1U) {
#line 309
    goto case_1;
  }
#line 309
  if ((unsigned int )o == 2U) {
#line 309
    goto case_2;
  }
#line 309
  if ((unsigned int )o == 0U) {
#line 309
    goto case_0;
  }
#line 309
  goto switch_break;
  case_3: /* CIL Label */ 
#line 309
  goto switch_break;
  case_1: /* CIL Label */ 
#line 309
  if (opt.quiet) {
#line 309
    return;
  }
#line 309
  goto switch_break;
  case_2: /* CIL Label */ 
#line 309
  if (opt.verbose) {
#line 309
    return;
  } else
#line 309
  if (opt.quiet) {
#line 309
    return;
  }
#line 309
  goto switch_break;
  case_0: /* CIL Label */ 
#line 309
  if (! opt.verbose) {
#line 309
    return;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 311
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)fp);
  }
#line 312
  if (save_context_p) {
    {
#line 313
    saved_append(s);
    }
  }
#line 314
  if (flush_log_p) {
    {
#line 315
    logflush();
    }
  } else {
#line 317
    needs_flushing = (_Bool)1;
  }
#line 318
  return;
}
}
#line 340 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static _Bool log_vprintf_internal(struct logvprintf_state *state , char const   *fmt ,
                                  va_list args ) 
{ 
  char smallmsg[128] ;
  char *write_ptr ;
  int available_size ;
  int numwritten ;
  FILE *fp ;
  FILE *tmp ;
  int newsize ;
  void *tmp___0 ;
  int newsize___0 ;
  void *tmp___1 ;

  {
  {
#line 345
  write_ptr = smallmsg;
#line 346
  available_size = (int )sizeof(smallmsg);
#line 348
  tmp = get_log_fp();
#line 348
  fp = tmp;
  }
#line 350
  if (! save_context_p) {
    {
#line 354
    vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt, args);
    }
#line 355
    goto flush;
  }
#line 358
  if (state->allocated != 0) {
#line 360
    write_ptr = state->bigmsg;
#line 361
    available_size = state->allocated;
  }
  {
#line 370
  numwritten = vsnprintf((char */* __restrict  */)write_ptr, (size_t )available_size,
                         (char const   */* __restrict  */)fmt, args);
  }
#line 380
  if (numwritten == -1) {
    {
#line 384
    newsize = available_size << 1;
#line 385
    tmp___0 = checking_realloc((void *)state->bigmsg, (size_t )newsize);
#line 385
    state->bigmsg = (char *)tmp___0;
#line 386
    state->allocated = newsize;
    }
#line 387
    return ((_Bool)0);
  } else
#line 389
  if (numwritten >= available_size) {
    {
#line 393
    newsize___0 = numwritten + 1;
#line 394
    tmp___1 = checking_realloc((void *)state->bigmsg, (size_t )newsize___0);
#line 394
    state->bigmsg = (char *)tmp___1;
#line 395
    state->allocated = newsize___0;
    }
#line 396
    return ((_Bool)0);
  }
  {
#line 400
  saved_append((char const   *)write_ptr);
#line 401
  fputs((char const   */* __restrict  */)write_ptr, (FILE */* __restrict  */)fp);
  }
#line 402
  if (state->bigmsg) {
    {
#line 403
    checking_free((void *)state->bigmsg);
    }
  }
  flush: 
#line 406
  if (flush_log_p) {
    {
#line 407
    logflush();
    }
  } else {
#line 409
    needs_flushing = (_Bool)1;
  }
#line 411
  return ((_Bool)1);
}
}
#line 415 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void logflush(void) 
{ 
  FILE *fp ;
  FILE *tmp ;

  {
  {
#line 418
  tmp = get_log_fp();
#line 418
  fp = tmp;
  }
#line 419
  if (fp) {
    {
#line 420
    fflush(fp);
    }
  }
#line 421
  needs_flushing = (_Bool)0;
#line 422
  return;
}
}
#line 425 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void log_set_flush(_Bool flush ) 
{ 


  {
#line 428
  if ((int )flush == (int )flush_log_p) {
#line 429
    return;
  }
#line 431
  if ((int )flush == 0) {
#line 434
    flush_log_p = (_Bool)0;
  } else {
#line 440
    if (needs_flushing) {
      {
#line 441
      logflush();
      }
    }
#line 442
    flush_log_p = (_Bool)1;
  }
#line 444
  return;
}
}
#line 450 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
_Bool log_set_save_context(_Bool savep ) 
{ 
  _Bool old ;

  {
#line 453
  old = save_context_p;
#line 454
  save_context_p = savep;
#line 455
  return (old);
}
}
#line 462 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void ( /* format attribute */  logprintf)(enum log_options o , char const   *fmt 
                                          , ...) 
{ 
  va_list args ;
  struct logvprintf_state lpstate ;
  _Bool done ;

  {
  {
#line 469
  check_redirect_output();
  }
#line 470
  if (inhibit_logging) {
#line 471
    return;
  }
  {
#line 472
  if ((unsigned int )o == 3U) {
#line 472
    goto case_3;
  }
#line 472
  if ((unsigned int )o == 1U) {
#line 472
    goto case_1;
  }
#line 472
  if ((unsigned int )o == 2U) {
#line 472
    goto case_2;
  }
#line 472
  if ((unsigned int )o == 0U) {
#line 472
    goto case_0;
  }
#line 472
  goto switch_break;
  case_3: /* CIL Label */ 
#line 472
  goto switch_break;
  case_1: /* CIL Label */ 
#line 472
  if (opt.quiet) {
#line 472
    return;
  }
#line 472
  goto switch_break;
  case_2: /* CIL Label */ 
#line 472
  if (opt.verbose) {
#line 472
    return;
  } else
#line 472
  if (opt.quiet) {
#line 472
    return;
  }
#line 472
  goto switch_break;
  case_0: /* CIL Label */ 
#line 472
  if (! opt.verbose) {
#line 472
    return;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 474
  memset((void *)(& lpstate), '\000', sizeof(lpstate));
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 477
    __builtin_va_start(args, fmt);
#line 478
    done = log_vprintf_internal(& lpstate, fmt, args);
#line 479
    __builtin_va_end(args);
    }
#line 475
    if (! (! done)) {
#line 475
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 487 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void ( /* format attribute */  debug_logprintf)(char const   *fmt  , ...) 
{ 
  va_list args ;
  struct logvprintf_state lpstate ;
  _Bool done ;

  {
#line 490
  if (opt.debug) {
    {
#line 496
    check_redirect_output();
    }
#line 497
    if (inhibit_logging) {
#line 498
      return;
    }
    {
#line 500
    memset((void *)(& lpstate), '\000', sizeof(lpstate));
    }
    {
#line 501
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 503
      __builtin_va_start(args, fmt);
#line 504
      done = log_vprintf_internal(& lpstate, fmt, args);
#line 505
      __builtin_va_end(args);
      }
#line 501
      if (! (! done)) {
#line 501
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 509
  return;
}
}
#line 514 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void log_init(char const   *file , _Bool appendp ) 
{ 
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 517
  if (file) {
#line 519
    if (appendp) {
#line 519
      tmp = "a";
    } else {
#line 519
      tmp = "w";
    }
    {
#line 519
    logfp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)tmp);
    }
#line 520
    if (! logfp) {
      {
#line 522
      tmp___0 = __errno_location();
#line 522
      tmp___1 = strerror(*tmp___0);
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program_name, file, tmp___1);
#line 523
      exit(1);
      }
    }
  } else {
    {
#line 534
    logfp = stderr;
#line 536
    tmp___2 = fileno(logfp);
#line 536
    tmp___3 = isatty(tmp___2);
    }
#line 536
    if (tmp___3) {
#line 546
      save_context_p = (_Bool)1;
    }
  }
#line 549
  return;
}
}
#line 553 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void log_close(void) 
{ 
  int i ;

  {
#line 558
  if (logfp) {
    {
#line 559
    fclose(logfp);
    }
  }
#line 560
  logfp = (FILE *)((void *)0);
#line 561
  inhibit_logging = (_Bool)1;
#line 562
  save_context_p = (_Bool)0;
#line 564
  i = 0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < 24)) {
#line 564
      goto while_break;
    }
    {
#line 565
    free_log_line(i);
#line 564
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  log_line_current = -1;
#line 567
  trailing_line = (_Bool)0;
#line 568
  return;
}
}
#line 571 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void log_dump_context(void) 
{ 
  int num ;
  FILE *fp ;
  FILE *tmp ;
  struct log_ln *ln ;

  {
  {
#line 574
  num = log_line_current;
#line 575
  tmp = get_log_fp();
#line 575
  fp = tmp;
  }
#line 576
  if (! fp) {
#line 577
    return;
  }
#line 579
  if (num == -1) {
#line 580
    return;
  }
#line 581
  if (trailing_line) {
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 582
      num ++;
#line 582
      if (num >= 24) {
#line 582
        num = 0;
      }
#line 582
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 585
    ln = log_lines + num;
#line 586
    if (ln->content) {
      {
#line 587
      fputs((char const   */* __restrict  */)ln->content, (FILE */* __restrict  */)fp);
      }
    }
    {
#line 588
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 588
      num ++;
#line 588
      if (num >= 24) {
#line 588
        num = 0;
      }
#line 588
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 583
    if (! (num != log_line_current)) {
#line 583
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 591
  if (trailing_line) {
#line 592
    if (log_lines[log_line_current].content) {
      {
#line 593
      fputs((char const   */* __restrict  */)log_lines[log_line_current].content,
            (FILE */* __restrict  */)fp);
      }
    }
  }
  {
#line 594
  fflush(fp);
  }
#line 595
  return;
}
}
#line 602 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static int count_nonprint(char const   *source ) 
{ 
  char const   *p___0 ;
  int cnt ;

  {
#line 607
  p___0 = source;
#line 607
  cnt = 0;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! *p___0) {
#line 607
      goto while_break;
    }
#line 608
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 16)) {
#line 609
      cnt ++;
    }
#line 607
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return (cnt);
}
}
#line 636 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void copy_and_escape(char const   *source , char *dest , char escape , int base ) 
{ 
  char const   *from ;
  char *to ;
  unsigned char c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 639
  from = source;
#line 640
  to = dest;
  {
#line 646
  if (base == 8) {
#line 646
    goto case_8;
  }
#line 658
  if (base == 16) {
#line 658
    goto case_16;
  }
#line 669
  goto switch_default;
  case_8: /* CIL Label */ 
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    tmp___4 = from;
#line 647
    from ++;
#line 647
    c = (unsigned char )*tmp___4;
#line 647
    if (! ((int )c != 0)) {
#line 647
      goto while_break;
    }
#line 648
    if ((int const   )_sch_istable[(int )c & 255] & 16) {
#line 649
      tmp = to;
#line 649
      to ++;
#line 649
      *tmp = (char )c;
    } else {
#line 652
      tmp___0 = to;
#line 652
      to ++;
#line 652
      *tmp___0 = escape;
#line 653
      tmp___1 = to;
#line 653
      to ++;
#line 653
      *tmp___1 = (char )(48 + ((int )c >> 6));
#line 654
      tmp___2 = to;
#line 654
      to ++;
#line 654
      *tmp___2 = (char )(48 + (((int )c >> 3) & 7));
#line 655
      tmp___3 = to;
#line 655
      to ++;
#line 655
      *tmp___3 = (char )(48 + ((int )c & 7));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    tmp___9 = from;
#line 659
    from ++;
#line 659
    c = (unsigned char )*tmp___9;
#line 659
    if (! ((int )c != 0)) {
#line 659
      goto while_break___0;
    }
#line 660
    if ((int const   )_sch_istable[(int )c & 255] & 16) {
#line 661
      tmp___5 = to;
#line 661
      to ++;
#line 661
      *tmp___5 = (char )c;
    } else {
#line 664
      tmp___6 = to;
#line 664
      to ++;
#line 664
      *tmp___6 = escape;
#line 665
      tmp___7 = to;
#line 665
      to ++;
#line 665
      *tmp___7 = (char )((int const   )*("0123456789ABCDEF" + ((int )c >> 4)));
#line 666
      tmp___8 = to;
#line 666
      to ++;
#line 666
      *tmp___8 = (char )((int const   )*("0123456789ABCDEF" + ((int )c & 15)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 668
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 670
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 672
  *to = (char )'\000';
#line 673
  return;
}
}
#line 680 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static struct ringel ring___0[3]  ;
#line 685 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static int ringpos___0  ;
#line 682 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static char const   *escnonprint_internal(char const   *str , char escape , int base ) 
{ 
  int nprcnt ;
  struct ringel *r ;
  int needed_size ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 688
  if (! (base == 8)) {
#line 688
    if (! (base == 16)) {
      {
#line 688
      __assert_fail("base == 8 || base == 16", "/home/khheo/project/benchmark/wget-1.11.4/src/log.c",
                    688U, "escnonprint_internal");
      }
    }
  }
  {
#line 690
  nprcnt = count_nonprint(str);
  }
#line 691
  if (nprcnt == 0) {
#line 694
    return (str);
  }
  {
#line 699
  r = ring___0 + ringpos___0;
#line 705
  tmp___0 = strlen(str);
  }
#line 705
  if (base == 8) {
#line 705
    tmp___1 = 3 * nprcnt;
  } else {
#line 705
    tmp___1 = 2 * nprcnt;
  }
#line 705
  needed_size = (int )((tmp___0 + 1UL) + (size_t )tmp___1);
#line 709
  if ((unsigned long )r->buffer == (unsigned long )((void *)0)) {
    {
#line 711
    tmp___2 = checking_realloc((void *)r->buffer, (size_t )needed_size);
#line 711
    r->buffer = (char *)tmp___2;
#line 712
    r->size = needed_size;
    }
  } else
#line 709
  if (r->size < needed_size) {
    {
#line 711
    tmp___2 = checking_realloc((void *)r->buffer, (size_t )needed_size);
#line 711
    r->buffer = (char *)tmp___2;
#line 712
    r->size = needed_size;
    }
  }
  {
#line 715
  copy_and_escape(str, r->buffer, escape, base);
#line 716
  ringpos___0 = (ringpos___0 + 1) % 3;
  }
#line 717
  return ((char const   *)r->buffer);
}
}
#line 745 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
char const   *escnonprint(char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 748
  tmp = escnonprint_internal(str, (char )'\\', 8);
  }
#line 748
  return (tmp);
}
}
#line 757 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
char const   *escnonprint_uri(char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 760
  tmp = escnonprint_internal(str, (char )'%', 16);
  }
#line 760
  return (tmp);
}
}
#line 763 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void log_cleanup(void) 
{ 
  int i ;

  {
#line 767
  i = 0;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! ((unsigned long )i < sizeof(ring___0) / sizeof(ring___0[0]))) {
#line 767
      goto while_break;
    }
#line 768
    if (! (! ring___0[i].buffer)) {
      {
#line 768
      checking_free((void *)ring___0[i].buffer);
      }
    }
#line 767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  return;
}
}
#line 773 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static enum __anonenum_redirect_request_90896483 redirect_request  =    (enum __anonenum_redirect_request_90896483 )0;
#line 774 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static char const   *redirect_request_signal_name  ;
#line 778 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void redirect_output(void) 
{ 
  char *logfile ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 782
  logfp = unique_create("wget-log", (_Bool)0, & logfile);
  }
#line 783
  if (logfp) {
    {
#line 785
    tmp = gettext("\n%s received, redirecting output to `%s\'.\n");
#line 785
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            redirect_request_signal_name, logfile);
#line 787
    checking_free((void *)logfile);
#line 789
    log_dump_context();
    }
  } else {
    {
#line 795
    tmp___0 = gettext("\n%s received.\n");
#line 795
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            redirect_request_signal_name);
#line 796
    tmp___1 = __errno_location();
#line 796
    tmp___2 = strerror(*tmp___1);
#line 796
    tmp___3 = gettext("%s: %s; disabling logging.\n");
#line 796
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            logfile, tmp___2);
#line 798
    inhibit_logging = (_Bool)1;
    }
  }
#line 800
  save_context_p = (_Bool)0;
#line 801
  return;
}
}
#line 806 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
static void check_redirect_output(void) 
{ 


  {
#line 809
  if ((unsigned int )redirect_request == 1U) {
    {
#line 811
    redirect_request = (enum __anonenum_redirect_request_90896483 )2;
#line 812
    redirect_output();
    }
  }
#line 814
  return;
}
}
#line 819 "/home/khheo/project/benchmark/wget-1.11.4/src/log.c"
void log_request_redirect_output(char const   *signal_name ) 
{ 


  {
#line 822
  if ((unsigned int )redirect_request == 0U) {
#line 822
    if (save_context_p) {
#line 826
      redirect_request = (enum __anonenum_redirect_request_90896483 )1;
    }
  }
#line 827
  redirect_request_signal_name = signal_name;
#line 828
  return;
}
}
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 72 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool enable_tilde_expansion  ;
#line 77
static _Bool cmd_boolean(char const   *com , char const   *val , void *place ) ;
#line 78
static _Bool cmd_bytes(char const   *com , char const   *val , void *place ) ;
#line 79
static _Bool cmd_bytes_sum(char const   *com , char const   *val , void *place ) ;
#line 81
static _Bool cmd_cert_type(char const   *com , char const   *val , void *place ) ;
#line 83
static _Bool cmd_directory_vector(char const   *com , char const   *val , void *place ) ;
#line 84
static _Bool cmd_number(char const   *com , char const   *val , void *place ) ;
#line 85
static _Bool cmd_number_inf(char const   *com , char const   *val , void *place ) ;
#line 86
static _Bool cmd_string(char const   *com , char const   *val , void *place ) ;
#line 87
static _Bool cmd_file(char const   *com , char const   *val , void *place ) ;
#line 88
static _Bool cmd_directory(char const   *com , char const   *val , void *place ) ;
#line 89
static _Bool cmd_time(char const   *com , char const   *val , void *place ) ;
#line 90
static _Bool cmd_vector(char const   *com , char const   *val , void *place ) ;
#line 92
static _Bool cmd_spec_dirstruct(char const   *com , char const   *val , void *place_ignored ) ;
#line 93
static _Bool cmd_spec_header(char const   *com , char const   *val , void *place_ignored ) ;
#line 94
static _Bool cmd_spec_htmlify(char const   *com , char const   *val , void *place_ignored ) ;
#line 95
static _Bool cmd_spec_mirror(char const   *com , char const   *val , void *place_ignored ) ;
#line 96
static _Bool cmd_spec_prefer_family(char const   *com , char const   *val , void *place_ignored ) ;
#line 97
static _Bool cmd_spec_progress(char const   *com , char const   *val , void *place_ignored ) ;
#line 98
static _Bool cmd_spec_recursive(char const   *com , char const   *val , void *place_ignored ) ;
#line 99
static _Bool cmd_spec_restrict_file_names(char const   *com , char const   *val ,
                                          void *place_ignored ) ;
#line 101
static _Bool cmd_spec_secure_protocol(char const   *com , char const   *val , void *place ) ;
#line 103
static _Bool cmd_spec_timeout(char const   *com , char const   *val , void *place_ignored ) ;
#line 104
static _Bool cmd_spec_useragent(char const   *com , char const   *val , void *place_ignored ) ;
#line 105
static _Bool cmd_spec_verbose(char const   *com , char const   *val , void *place_ignored ) ;
#line 114 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static struct __anonstruct_commands_890992477  const  commands[118]  = 
#line 114
  {      {"accept", (void *)(& opt.accepts), & cmd_vector}, 
        {"addhostdir", (void *)(& opt.add_hostdir), & cmd_boolean}, 
        {"alwaysrest", (void *)(& opt.always_rest), & cmd_boolean}, 
        {"authnochallenge", (void *)(& opt.auth_without_challenge), & cmd_boolean}, 
        {"background", (void *)(& opt.background), & cmd_boolean}, 
        {"backupconverted", (void *)(& opt.backup_converted), & cmd_boolean}, 
        {"backups", (void *)(& opt.backups), & cmd_number}, 
        {"base", (void *)(& opt.base_href), & cmd_string}, 
        {"bindaddress", (void *)(& opt.bind_address), & cmd_string}, 
        {"cacertificate", (void *)(& opt.ca_cert), & cmd_file}, 
        {"cache", (void *)(& opt.allow_cache), & cmd_boolean}, 
        {"cadirectory", (void *)(& opt.ca_directory), & cmd_directory}, 
        {"certificate", (void *)(& opt.cert_file), & cmd_file}, 
        {"certificatetype", (void *)(& opt.cert_type), & cmd_cert_type}, 
        {"checkcertificate", (void *)(& opt.check_cert), & cmd_boolean}, 
        {"connecttimeout", (void *)(& opt.connect_timeout), & cmd_time}, 
        {"contentdisposition", (void *)(& opt.content_disposition), & cmd_boolean}, 
        {"continue", (void *)(& opt.always_rest), & cmd_boolean}, 
        {"convertlinks", (void *)(& opt.convert_links), & cmd_boolean}, 
        {"cookies", (void *)(& opt.cookies), & cmd_boolean}, 
        {"cutdirs", (void *)(& opt.cut_dirs), & cmd_number}, 
        {"debug", (void *)(& opt.debug), & cmd_boolean}, 
        {"deleteafter", (void *)(& opt.delete_after), & cmd_boolean}, 
        {"dirprefix", (void *)(& opt.dir_prefix), & cmd_directory}, 
        {"dirstruct", (void *)0, & cmd_spec_dirstruct}, 
        {"dnscache", (void *)(& opt.dns_cache), & cmd_boolean}, 
        {"dnstimeout", (void *)(& opt.dns_timeout), & cmd_time}, 
        {"domains", (void *)(& opt.domains), & cmd_vector}, 
        {"dotbytes", (void *)(& opt.dot_bytes), & cmd_bytes}, 
        {"dotsinline", (void *)(& opt.dots_in_line), & cmd_number}, 
        {"dotspacing", (void *)(& opt.dot_spacing), & cmd_number}, 
        {"dotstyle", (void *)(& opt.dot_style), & cmd_string}, 
        {"egdfile", (void *)(& opt.egd_file), & cmd_file}, 
        {"excludedirectories", (void *)(& opt.excludes), & cmd_directory_vector}, 
        {"excludedomains", (void *)(& opt.exclude_domains), & cmd_vector}, 
        {"followftp", (void *)(& opt.follow_ftp), & cmd_boolean}, 
        {"followtags", (void *)(& opt.follow_tags), & cmd_vector}, 
        {"forcehtml", (void *)(& opt.force_html), & cmd_boolean}, 
        {"ftppasswd", (void *)(& opt.ftp_passwd), & cmd_string}, 
        {"ftppassword", (void *)(& opt.ftp_passwd), & cmd_string}, 
        {"ftpproxy", (void *)(& opt.ftp_proxy), & cmd_string}, 
        {"ftpuser", (void *)(& opt.ftp_user), & cmd_string}, 
        {"glob", (void *)(& opt.ftp_glob), & cmd_boolean}, 
        {"header", (void *)0, & cmd_spec_header}, 
        {"htmlextension", (void *)(& opt.html_extension), & cmd_boolean}, 
        {"htmlify", (void *)0, & cmd_spec_htmlify}, 
        {"httpkeepalive", (void *)(& opt.http_keep_alive), & cmd_boolean}, 
        {"httppasswd", (void *)(& opt.http_passwd), & cmd_string}, 
        {"httppassword", (void *)(& opt.http_passwd), & cmd_string}, 
        {"httpproxy", (void *)(& opt.http_proxy), & cmd_string}, 
        {"httpsproxy", (void *)(& opt.https_proxy), & cmd_string}, 
        {"httpuser", (void *)(& opt.http_user), & cmd_string}, 
        {"ignorecase", (void *)(& opt.ignore_case), & cmd_boolean}, 
        {"ignorelength", (void *)(& opt.ignore_length), & cmd_boolean}, 
        {"ignoretags", (void *)(& opt.ignore_tags), & cmd_vector}, 
        {"includedirectories", (void *)(& opt.includes), & cmd_directory_vector}, 
        {"inet4only", (void *)(& opt.ipv4_only), & cmd_boolean}, 
        {"inet6only", (void *)(& opt.ipv6_only), & cmd_boolean}, 
        {"input", (void *)(& opt.input_filename), & cmd_file}, 
        {"keepsessioncookies", (void *)(& opt.keep_session_cookies), & cmd_boolean}, 
        {"limitrate", (void *)(& opt.limit_rate), & cmd_bytes}, 
        {"loadcookies", (void *)(& opt.cookies_input), & cmd_file}, 
        {"logfile", (void *)(& opt.lfilename), & cmd_file}, 
        {"login", (void *)(& opt.ftp_user), & cmd_string}, 
        {"maxredirect", (void *)(& opt.max_redirect), & cmd_number}, 
        {"mirror", (void *)0, & cmd_spec_mirror}, 
        {"netrc", (void *)(& opt.netrc), & cmd_boolean}, 
        {"noclobber", (void *)(& opt.noclobber), & cmd_boolean}, 
        {"noparent", (void *)(& opt.no_parent), & cmd_boolean}, 
        {"noproxy", (void *)(& opt.no_proxy), & cmd_vector}, 
        {"numtries", (void *)(& opt.ntry), & cmd_number_inf}, 
        {"outputdocument", (void *)(& opt.output_document), & cmd_file}, 
        {"pagerequisites", (void *)(& opt.page_requisites), & cmd_boolean}, 
        {"passiveftp", (void *)(& opt.ftp_pasv), & cmd_boolean}, 
        {"passwd", (void *)(& opt.ftp_passwd), & cmd_string}, 
        {"password", (void *)(& opt.passwd), & cmd_string}, 
        {"postdata", (void *)(& opt.post_data), & cmd_string}, 
        {"postfile", (void *)(& opt.post_file_name), & cmd_file}, 
        {"preferfamily", (void *)0, & cmd_spec_prefer_family}, 
        {"preservepermissions", (void *)(& opt.preserve_perm), & cmd_boolean}, 
        {"privatekey", (void *)(& opt.private_key), & cmd_file}, 
        {"privatekeytype", (void *)(& opt.private_key_type), & cmd_cert_type}, 
        {"progress", (void *)(& opt.progress_type), & cmd_spec_progress}, 
        {"protocoldirectories", (void *)(& opt.protocol_directories), & cmd_boolean}, 
        {"proxypasswd",
      (void *)(& opt.proxy_passwd), & cmd_string}, 
        {"proxypassword", (void *)(& opt.proxy_passwd), & cmd_string}, 
        {"proxyuser", (void *)(& opt.proxy_user), & cmd_string}, 
        {"quiet", (void *)(& opt.quiet), & cmd_boolean}, 
        {"quota", (void *)(& opt.quota), & cmd_bytes_sum}, 
        {"randomfile", (void *)(& opt.random_file), & cmd_file}, 
        {"randomwait", (void *)(& opt.random_wait), & cmd_boolean}, 
        {"readtimeout", (void *)(& opt.read_timeout), & cmd_time}, 
        {"reclevel", (void *)(& opt.reclevel), & cmd_number_inf}, 
        {"recursive", (void *)0, & cmd_spec_recursive}, 
        {"referer", (void *)(& opt.referer), & cmd_string}, 
        {"reject", (void *)(& opt.rejects), & cmd_vector}, 
        {"relativeonly", (void *)(& opt.relative_only), & cmd_boolean}, 
        {"removelisting", (void *)(& opt.remove_listing), & cmd_boolean}, 
        {"restrictfilenames", (void *)0, & cmd_spec_restrict_file_names}, 
        {"retrsymlinks", (void *)(& opt.retr_symlinks), & cmd_boolean}, 
        {"retryconnrefused", (void *)(& opt.retry_connrefused), & cmd_boolean}, 
        {"robots", (void *)(& opt.use_robots), & cmd_boolean}, 
        {"savecookies", (void *)(& opt.cookies_output), & cmd_file}, 
        {"saveheaders", (void *)(& opt.save_headers), & cmd_boolean}, 
        {"secureprotocol", (void *)(& opt.secure_protocol), & cmd_spec_secure_protocol}, 
        {"serverresponse",
      (void *)(& opt.server_response), & cmd_boolean}, 
        {"spanhosts", (void *)(& opt.spanhost), & cmd_boolean}, 
        {"spider", (void *)(& opt.spider), & cmd_boolean}, 
        {"strictcomments", (void *)(& opt.strict_comments), & cmd_boolean}, 
        {"timeout", (void *)0, & cmd_spec_timeout}, 
        {"timestamping", (void *)(& opt.timestamping), & cmd_boolean}, 
        {"tries", (void *)(& opt.ntry), & cmd_number_inf}, 
        {"useproxy", (void *)(& opt.use_proxy), & cmd_boolean}, 
        {"user", (void *)(& opt.user), & cmd_string}, 
        {"useragent", (void *)0, & cmd_spec_useragent}, 
        {"verbose", (void *)0, & cmd_spec_verbose}, 
        {"wait", (void *)(& opt.wait), & cmd_time}, 
        {"waitretry", (void *)(& opt.waitretry), & cmd_time}};
#line 263 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static int command_by_name(char const   *cmdname ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int cmp ;
  int tmp ;

  {
#line 268
  lo = 0;
#line 268
  hi = (int )(sizeof(commands) / sizeof(commands[0]) - 1UL);
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (lo <= hi)) {
#line 270
      goto while_break;
    }
    {
#line 272
    mid = (lo + hi) >> 1;
#line 273
    tmp = strcasecmp(cmdname, (char const   *)commands[mid].name);
#line 273
    cmp = tmp;
    }
#line 274
    if (cmp < 0) {
#line 275
      hi = mid - 1;
    } else
#line 276
    if (cmp > 0) {
#line 277
      lo = mid + 1;
    } else {
#line 279
      return (mid);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 285 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static void defaults(void) 
{ 
  char *tmp ;

  {
  {
#line 295
  memset((void *)(& opt), '\000', sizeof(opt));
#line 297
  opt.cookies = (_Bool)1;
#line 298
  opt.verbose = -1;
#line 299
  opt.ntry = 20;
#line 300
  opt.reclevel = 5;
#line 301
  opt.add_hostdir = (_Bool)1;
#line 302
  opt.netrc = (_Bool)1;
#line 303
  opt.ftp_glob = (_Bool)1;
#line 304
  opt.htmlify = (_Bool)1;
#line 305
  opt.http_keep_alive = (_Bool)1;
#line 306
  opt.use_proxy = (_Bool)1;
#line 307
  tmp = getenv("no_proxy");
  }
#line 308
  if (tmp) {
    {
#line 309
    opt.no_proxy = sepstring((char const   *)tmp);
    }
  }
#line 310
  opt.allow_cache = (_Bool)1;
#line 312
  opt.read_timeout = (double )900;
#line 313
  opt.use_robots = (_Bool)1;
#line 315
  opt.remove_listing = (_Bool)1;
#line 317
  opt.dot_bytes = (wgint )1024;
#line 318
  opt.dot_spacing = 10;
#line 319
  opt.dots_in_line = 50;
#line 321
  opt.dns_cache = (_Bool)1;
#line 322
  opt.ftp_pasv = (_Bool)1;
#line 325
  opt.check_cert = (_Bool)1;
#line 332
  opt.restrict_files_os = (enum __anonenum_restrict_files_os_843006439 )0;
#line 334
  opt.restrict_files_ctrl = (_Bool)1;
#line 335
  opt.restrict_files_case = (enum __anonenum_restrict_files_case_191639182 )0;
#line 337
  opt.max_redirect = 20;
#line 338
  return;
}
}
#line 342 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
char *home_dir(void) 
{ 
  char *home ;
  char *tmp ;
  struct passwd *pwd ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 345
  tmp = getenv("HOME");
#line 345
  home = tmp;
  }
#line 347
  if (! home) {
    {
#line 365
    tmp___0 = getuid();
#line 365
    tmp___1 = getpwuid(tmp___0);
#line 365
    pwd = tmp___1;
    }
#line 366
    if (! pwd) {
#line 367
      return ((char *)((void *)0));
    } else
#line 366
    if (! pwd->pw_dir) {
#line 367
      return ((char *)((void *)0));
    }
#line 368
    home = pwd->pw_dir;
  }
#line 376
  if (home) {
    {
#line 376
    tmp___2 = checking_strdup((char const   *)home);
#line 376
    tmp___3 = tmp___2;
    }
  } else {
#line 376
    tmp___3 = (char *)((void *)0);
  }
#line 376
  return (tmp___3);
}
}
#line 384 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static char *wgetrc_file_name(void) 
{ 
  char *env ;
  char *home ;
  char *file ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 388
  file = (char *)((void *)0);
#line 391
  env = getenv("WGETRC");
  }
#line 392
  if (env) {
#line 392
    if (*env) {
      {
#line 394
      tmp___0 = file_exists_p((char const   *)env);
      }
#line 394
      if (! tmp___0) {
        {
#line 396
        tmp = gettext("%s: WGETRC points to %s, which doesn\'t exist.\n");
#line 396
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                program_name, env);
#line 398
        exit(1);
        }
      }
      {
#line 400
      tmp___1 = checking_strdup((char const   *)env);
      }
#line 400
      return (tmp___1);
    }
  }
  {
#line 404
  home = home_dir();
  }
#line 405
  if (home) {
    {
#line 406
    file = aprintf("%s/.wgetrc", home);
    }
  }
#line 407
  if (! (! home)) {
    {
#line 407
    checking_free((void *)home);
    }
  }
#line 424
  if (! file) {
#line 425
    return ((char *)((void *)0));
  }
  {
#line 426
  tmp___2 = file_exists_p((char const   *)file);
  }
#line 426
  if (! tmp___2) {
    {
#line 428
    checking_free((void *)file);
    }
#line 429
    return ((char *)((void *)0));
  }
#line 431
  return (file);
}
}
#line 442
static enum parse_line parse_line(char const   *line , char **com , char **val , int *comind ) ;
#line 443
static _Bool setval_internal(int comind , char const   *com , char const   *val ) ;
#line 448 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool run_wgetrc(char const   *file ) 
{ 
  FILE *fp ;
  char *line ;
  int ln ;
  int errcnt ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *com ;
  char *val ;
  int comind ;
  enum parse_line tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 454
  errcnt = 0;
#line 456
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 457
  if (! fp) {
    {
#line 459
    tmp = __errno_location();
#line 459
    tmp___0 = strerror(*tmp);
#line 459
    tmp___1 = gettext("%s: Cannot read %s (%s).\n");
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            program_name, file, tmp___0);
    }
#line 461
    return ((_Bool)1);
  }
#line 463
  enable_tilde_expansion = (_Bool)1;
#line 464
  ln = 1;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 465
    line = read_whole_line(fp);
    }
#line 465
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 465
      goto while_break;
    }
    {
#line 467
    com = (char *)((void *)0);
#line 467
    val = (char *)((void *)0);
#line 471
    tmp___2 = parse_line((char const   *)line, & com, & val, & comind);
    }
    {
#line 473
    if ((unsigned int )tmp___2 == 0U) {
#line 473
      goto case_0;
    }
#line 482
    if ((unsigned int )tmp___2 == 2U) {
#line 482
      goto case_2;
    }
#line 487
    if ((unsigned int )tmp___2 == 3U) {
#line 487
      goto case_3;
    }
#line 492
    if ((unsigned int )tmp___2 == 1U) {
#line 492
      goto case_1;
    }
#line 494
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 475
    tmp___4 = setval_internal(comind, (char const   *)com, (char const   *)val);
    }
#line 475
    if (! tmp___4) {
      {
#line 477
      tmp___3 = gettext("%s: Error in %s at line %d.\n");
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              program_name, file, ln);
#line 479
      errcnt ++;
      }
    }
#line 481
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 483
    tmp___5 = gettext("%s: Syntax error in %s at line %d.\n");
#line 483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            program_name, file, ln);
#line 485
    errcnt ++;
    }
#line 486
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 488
    tmp___6 = gettext("%s: Unknown command `%s\' in %s at line %d.\n");
#line 488
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            program_name, com, file, ln);
#line 490
    errcnt ++;
    }
#line 491
    goto switch_break;
    case_1: /* CIL Label */ 
#line 493
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 495
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 497
    if (! (! com)) {
      {
#line 497
      checking_free((void *)com);
      }
    }
#line 498
    if (! (! val)) {
      {
#line 498
      checking_free((void *)val);
      }
    }
    {
#line 499
    checking_free((void *)line);
#line 500
    ln ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  enable_tilde_expansion = (_Bool)0;
#line 503
  fclose(fp);
  }
#line 505
  return ((_Bool )(errcnt == 0));
}
}
#line 510 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
void initialize(void) 
{ 
  char *file ;
  int ok ;
  char *syswgetrc ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  {
#line 514
  ok = 1;
#line 517
  defaults();
  }
#line 521
  if (opt.verbose) {
    {
#line 522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SYSTEM_WGETRC = %s\n",
            "/usr/local/etc/wgetrc");
    }
  }
#line 523
  syswgetrc = (char *)"/usr/local/etc/wgetrc";
#line 524
  if (opt.verbose) {
    {
#line 525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"syswgetrc = %s\n",
            syswgetrc);
    }
  }
  {
#line 526
  tmp___0 = file_exists_p((char const   *)syswgetrc);
  }
#line 526
  if (tmp___0) {
    {
#line 527
    tmp = run_wgetrc((char const   *)syswgetrc);
#line 527
    ok &= (int )tmp;
    }
  }
  {
#line 530
  file = wgetrc_file_name();
  }
#line 531
  if (! file) {
#line 532
    if (syswgetrc) {
      {
#line 533
      free((void *)syswgetrc);
      }
    }
#line 534
    return;
  }
#line 536
  if (opt.verbose) {
    {
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wgetrc_file_name = %s\n",
            file);
    }
  }
  {
#line 541
  tmp___3 = strcmp((char const   *)file, (char const   *)syswgetrc);
  }
#line 541
  if (tmp___3) {
    {
#line 549
    tmp___2 = run_wgetrc((char const   *)file);
#line 549
    ok &= (int )tmp___2;
    }
  } else {
    {
#line 543
    tmp___1 = gettext("%s: Warning: Both system and user wgetrc point to `%s\'.\n");
#line 543
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            program_name, file);
    }
  }
#line 551
  if (syswgetrc) {
    {
#line 552
    free((void *)syswgetrc);
    }
  }
#line 556
  if (! ok) {
    {
#line 557
    exit(2);
    }
  }
  {
#line 559
  checking_free((void *)file);
  }
#line 560
  return;
}
}
#line 566 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static void dehyphen(char *s ) 
{ 
  char *t ;
  char *h ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 569
  t = s;
#line 570
  h = s;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! *h) {
#line 571
      goto while_break;
    }
#line 572
    if ((int )*h == 95) {
#line 573
      h ++;
    } else
#line 572
    if ((int )*h == 45) {
#line 573
      h ++;
    } else {
#line 575
      tmp = t;
#line 575
      t ++;
#line 575
      tmp___0 = h;
#line 575
      h ++;
#line 575
      *tmp = *tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  *t = (char )'\000';
#line 577
  return;
}
}
#line 590 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static enum parse_line parse_line(char const   *line , char **com , char **val , int *comind ) 
{ 
  char const   *p___0 ;
  char const   *end ;
  size_t tmp ;
  char const   *cmdstart ;
  char const   *cmdend ;
  char const   *valstart ;
  char const   *valend ;
  char *cmdcopy ;
  int ind ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___0 ;

  {
  {
#line 594
  tmp = strlen(line);
#line 594
  end = line + tmp;
  }
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (*line) {
#line 602
      if (! ((int const   )_sch_istable[(int const   )*line & 255] & 64)) {
#line 602
        goto while_break;
      }
    } else {
#line 602
      goto while_break;
    }
#line 603
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 604
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 604
    if ((unsigned long )end > (unsigned long )line) {
#line 604
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 604
        goto while_break___0;
      }
    } else {
#line 604
      goto while_break___0;
    }
#line 605
    end --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 608
  if (! *line) {
#line 609
    return ((enum parse_line )1);
  } else
#line 608
  if ((int const   )*line == 35) {
#line 609
    return ((enum parse_line )1);
  }
#line 611
  p___0 = line;
#line 613
  cmdstart = p___0;
  {
#line 614
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 614
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 614
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 140)) {
#line 614
        if (! ((int const   )*p___0 == 95)) {
#line 614
          if (! ((int const   )*p___0 == 45)) {
#line 614
            goto while_break___1;
          }
        }
      }
    } else {
#line 614
      goto while_break___1;
    }
#line 615
    p___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 616
  cmdend = p___0;
  {
#line 619
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 619
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 619
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 619
        goto while_break___2;
      }
    } else {
#line 619
      goto while_break___2;
    }
#line 620
    p___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 621
  if ((unsigned long )p___0 == (unsigned long )end) {
#line 622
    return ((enum parse_line )2);
  } else
#line 621
  if ((int const   )*p___0 != 61) {
#line 622
    return ((enum parse_line )2);
  }
#line 623
  p___0 ++;
  {
#line 624
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 624
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 624
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 624
        goto while_break___3;
      }
    } else {
#line 624
      goto while_break___3;
    }
#line 625
    p___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 627
  valstart = p___0;
#line 628
  valend = end;
#line 632
  *com = strdupdelim(cmdstart, cmdend);
#line 633
  *val = strdupdelim(valstart, valend);
  }
  {
#line 637
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 637
    BTA_beg = cmdstart;
#line 637
    BTA_len = (int )(cmdend - BTA_beg);
#line 637
    BTA_dest = & cmdcopy;
#line 637
    tmp___0 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 637
    *BTA_dest = (char *)tmp___0;
#line 637
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 637
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 637
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 638
  dehyphen(cmdcopy);
#line 639
  ind = command_by_name((char const   *)cmdcopy);
  }
#line 640
  if (ind == -1) {
#line 641
    return ((enum parse_line )3);
  }
#line 644
  *comind = ind;
#line 645
  return ((enum parse_line )0);
}
}
#line 650 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool setval_internal(int comind , char const   *com , char const   *val ) 
{ 
  long tmp___0 ;
  _Bool tmp___1 ;

  {
#line 653
  if (0 <= comind) {
#line 653
    if (! ((unsigned long )comind < sizeof(commands) / sizeof(commands[0]))) {
      {
#line 653
      __assert_fail("0 <= comind && comind < countof (commands)", "/home/khheo/project/benchmark/wget-1.11.4/src/init.c",
                    653U, "setval_internal");
      }
    }
  } else {
    {
#line 653
    __assert_fail("0 <= comind && comind < countof (commands)", "/home/khheo/project/benchmark/wget-1.11.4/src/init.c",
                  653U, "setval_internal");
    }
  }
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 654
    tmp___0 = __builtin_expect((long )opt.debug, 0L);
    }
#line 654
    if (tmp___0) {
      {
#line 654
      debug_logprintf("Setting %s (%s) to %s\n", com, commands[comind].name, val);
      }
    }
#line 654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 655
  tmp___1 = (*(commands[comind].action))(com, val, (void *)commands[comind].place);
  }
#line 655
  return (tmp___1);
}
}
#line 668 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
void setoptval(char const   *com , char const   *val , char const   *optname ) 
{ 
  char *dd_optname ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 672
  tmp = strlen(optname);
#line 672
  tmp___0 = __builtin_alloca((2UL + tmp) + 1UL);
#line 672
  dd_optname = (char *)tmp___0;
#line 673
  *(dd_optname + 0) = (char )'-';
#line 674
  *(dd_optname + 1) = (char )'-';
#line 675
  strcpy((char */* __restrict  */)(dd_optname + 2), (char const   */* __restrict  */)optname);
  }
#line 677
  if (! ((unsigned long )val != (unsigned long )((void *)0))) {
    {
#line 677
    __assert_fail("val != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/init.c",
                  677U, "setoptval");
    }
  }
  {
#line 678
  tmp___2 = command_by_name(com);
#line 678
  tmp___3 = setval_internal(tmp___2, (char const   *)dd_optname, val);
  }
#line 678
  if (! tmp___3) {
    {
#line 679
    exit(2);
    }
  }
#line 680
  return;
}
}
#line 686 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
void run_command(char const   *opt___0 ) 
{ 
  char *com ;
  char *val ;
  int comind ;
  enum parse_line tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 691
  tmp = parse_line(opt___0, & com, & val, & comind);
  }
  {
#line 693
  if ((unsigned int )tmp == 0U) {
#line 693
    goto case_0;
  }
#line 699
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 694
  tmp___0 = setval_internal(comind, (char const   *)com, (char const   *)val);
  }
#line 694
  if (! tmp___0) {
    {
#line 695
    exit(2);
    }
  }
  {
#line 696
  checking_free((void *)com);
#line 697
  checking_free((void *)val);
  }
#line 698
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 700
  tmp___1 = gettext("%s: Invalid --execute command `%s\'\n");
#line 700
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          program_name, opt___0);
#line 702
  exit(2);
  }
  switch_break: /* CIL Label */ ;
  }
#line 704
  return;
}
}
#line 713
static _Bool decode_string(char const   *val , struct decode_item  const  *items ,
                           int itemcount , int *place ) ;
#line 714
static _Bool simple_atoi(char const   *beg , char const   *end , int *dest ) ;
#line 715
static _Bool simple_atof(char const   *beg , char const   *end , double *dest ) ;
#line 731 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_boolean(char const   *com , char const   *val , void *place ) 
{ 
  _Bool value ;
  char *tmp ;

  {
#line 736
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 736
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 110) {
#line 736
      if ((int const   )*(val + 2) == 0) {
#line 738
        value = (_Bool)1;
      } else {
#line 736
        goto _L___9;
      }
    } else {
#line 736
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 736
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 121) {
#line 736
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 101) {
#line 736
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 115) {
#line 736
        if ((int const   )*(val + 3) == 0) {
#line 738
          value = (_Bool)1;
        } else {
#line 736
          goto _L___7;
        }
      } else {
#line 736
        goto _L___7;
      }
    } else {
#line 736
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 736
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 49) {
#line 736
    if ((int const   )*(val + 1) == 0) {
#line 738
      value = (_Bool)1;
    } else {
#line 736
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 739
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 739
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 102) {
#line 739
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 102) {
#line 739
        if ((int const   )*(val + 3) == 0) {
#line 741
          value = (_Bool)0;
        } else {
#line 739
          goto _L___3;
        }
      } else {
#line 739
        goto _L___3;
      }
    } else {
#line 739
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 739
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 110) {
#line 739
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 111) {
#line 739
      if ((int const   )*(val + 2) == 0) {
#line 741
        value = (_Bool)0;
      } else {
#line 739
        goto _L___0;
      }
    } else {
#line 739
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 739
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 48) {
#line 739
    if ((int const   )*(val + 1) == 0) {
#line 741
      value = (_Bool)0;
    } else {
      {
#line 744
      tmp = gettext("%s: %s: Invalid boolean `%s\'; use `on\' or `off\'.\n");
#line 744
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              program_name, com, val);
      }
#line 747
      return ((_Bool)0);
    }
  } else {
    {
#line 744
    tmp = gettext("%s: %s: Invalid boolean `%s\'; use `on\' or `off\'.\n");
#line 744
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 747
    return ((_Bool)0);
  }
#line 750
  *((_Bool *)place) = value;
#line 751
  return ((_Bool)1);
}
}
#line 756 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_number(char const   *com , char const   *val , void *place ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 759
  tmp___0 = strlen(val);
#line 759
  tmp___1 = simple_atoi(val, val + tmp___0, (int *)place);
  }
#line 759
  if (tmp___1) {
#line 759
    if (*((int *)place) < 0) {
      {
#line 762
      tmp = gettext("%s: %s: Invalid number `%s\'.\n");
#line 762
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              program_name, com, val);
      }
#line 764
      return ((_Bool)0);
    }
  } else {
    {
#line 762
    tmp = gettext("%s: %s: Invalid number `%s\'.\n");
#line 762
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 764
    return ((_Bool)0);
  }
#line 766
  return ((_Bool)1);
}
}
#line 770 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_number_inf(char const   *com , char const   *val , void *place ) 
{ 
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 773
  tmp = strcasecmp(val, "inf");
  }
#line 773
  if (! tmp) {
#line 775
    *((int *)place) = 0;
#line 776
    return ((_Bool)1);
  }
  {
#line 778
  tmp___0 = cmd_number(com, val, place);
  }
#line 778
  return (tmp___0);
}
}
#line 783 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_string(char const   *com , char const   *val , void *place ) 
{ 
  char **pstring ;

  {
#line 786
  pstring = (char **)place;
#line 788
  if (! (! *pstring)) {
    {
#line 788
    checking_free((void *)*pstring);
    }
  }
  {
#line 789
  *pstring = checking_strdup(val);
  }
#line 790
  return ((_Bool)1);
}
}
#line 802 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_file(char const   *com , char const   *val , void *place ) 
{ 
  char **pstring ;
  int homelen ;
  char *home ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 805
  pstring = (char **)place;
#line 807
  if (! (! *pstring)) {
    {
#line 807
    checking_free((void *)*pstring);
    }
  }
#line 811
  if (! enable_tilde_expansion) {
#line 811
    goto noexpand;
  } else
#line 811
  if ((int const   )*val == 126) {
#line 811
    if ((int const   )*(val + 1) == 47) {
      {
#line 819
      tmp = home_dir();
#line 819
      home = tmp;
      }
#line 820
      if (! home) {
#line 821
        goto noexpand;
      }
      {
#line 823
      tmp___0 = strlen((char const   *)home);
#line 823
      homelen = (int )tmp___0;
      }
      {
#line 824
      while (1) {
        while_continue: /* CIL Label */ ;
#line 824
        if (homelen) {
#line 824
          if (! ((int )*(home + (homelen - 1)) == 47)) {
#line 824
            goto while_break;
          }
        } else {
#line 824
          goto while_break;
        }
#line 825
        homelen --;
#line 825
        *(home + homelen) = (char )'\000';
      }
      while_break: /* CIL Label */ ;
      }
#line 828
      val ++;
      {
#line 828
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 828
        if (! ((int const   )*val == 47)) {
#line 828
          goto while_break___0;
        }
#line 828
        val ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 831
      *pstring = concat_strings((char const   *)home, "/", val, (char *)0);
      }
    } else {
#line 811
      goto noexpand;
    }
  } else {
    noexpand: 
    {
#line 814
    *pstring = checking_strdup(val);
    }
  }
#line 843
  return ((_Bool)1);
}
}
#line 847 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_directory(char const   *com , char const   *val , void *place ) 
{ 
  char *s ;
  char *t ;
  _Bool tmp ;
  size_t tmp___0 ;

  {
  {
#line 855
  tmp = cmd_file(com, val, place);
  }
#line 855
  if (! tmp) {
#line 856
    return ((_Bool)0);
  }
  {
#line 858
  s = *((char **)place);
#line 859
  tmp___0 = strlen((char const   *)s);
#line 859
  t = s + tmp___0;
  }
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if ((unsigned long )t > (unsigned long )s) {
#line 860
      t --;
#line 860
      if (! ((int )*t == 47)) {
#line 860
        goto while_break;
      }
    } else {
#line 860
      goto while_break;
    }
#line 861
    *t = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return ((_Bool)1);
}
}
#line 870 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_vector(char const   *com , char const   *val , void *place ) 
{ 
  char ***pvec ;
  char **tmp ;

  {
#line 873
  pvec = (char ***)place;
#line 875
  if (*val) {
    {
#line 876
    tmp = sepstring(val);
#line 876
    *pvec = merge_vecs(*pvec, tmp);
    }
  } else {
    {
#line 879
    free_vec(*pvec);
#line 880
    *pvec = (char **)((void *)0);
    }
  }
#line 882
  return ((_Bool)1);
}
}
#line 885 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_directory_vector(char const   *com , char const   *val , void *place ) 
{ 
  char ***pvec ;
  char **t ;
  char **seps___0 ;
  int len ;
  size_t tmp ;

  {
#line 888
  pvec = (char ***)place;
#line 890
  if (*val) {
    {
#line 895
    seps___0 = sepstring(val);
#line 896
    t = seps___0;
    }
    {
#line 896
    while (1) {
      while_continue: /* CIL Label */ ;
#line 896
      if (t) {
#line 896
        if (! *t) {
#line 896
          goto while_break;
        }
      } else {
#line 896
        goto while_break;
      }
      {
#line 898
      tmp = strlen((char const   *)*t);
#line 898
      len = (int )tmp;
      }
#line 900
      if (len > 1) {
#line 902
        if ((int )*(*t + (len - 1)) == 47) {
#line 903
          *(*t + (len - 1)) = (char )'\000';
        }
      }
#line 896
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 906
    *pvec = merge_vecs(*pvec, seps___0);
    }
  } else {
    {
#line 910
    free_vec(*pvec);
#line 911
    *pvec = (char **)((void *)0);
    }
  }
#line 913
  return ((_Bool)1);
}
}
#line 919 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool parse_bytes_helper(char const   *val , double *result ) 
{ 
  double number ;
  double mult ;
  char const   *end ;
  size_t tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 923
  tmp = strlen(val);
#line 923
  end = val + tmp;
#line 926
  tmp___0 = strcmp(val, "inf");
  }
#line 926
  if (0 == tmp___0) {
#line 928
    *result = (double )0;
#line 929
    return ((_Bool)1);
  }
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if ((unsigned long )val < (unsigned long )end) {
#line 933
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 933
        goto while_break;
      }
    } else {
#line 933
      goto while_break;
    }
#line 934
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  if ((unsigned long )val == (unsigned long )end) {
#line 936
    return ((_Bool)0);
  }
  {
#line 940
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 107) {
#line 940
    goto case_107;
  }
#line 943
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 109) {
#line 943
    goto case_109;
  }
#line 946
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 103) {
#line 946
    goto case_103;
  }
#line 949
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 116) {
#line 949
    goto case_116;
  }
#line 952
  goto switch_default;
  case_107: /* CIL Label */ 
#line 941
  end --;
#line 941
  mult = 1024.0;
#line 942
  goto switch_break;
  case_109: /* CIL Label */ 
#line 944
  end --;
#line 944
  mult = 1048576.0;
#line 945
  goto switch_break;
  case_103: /* CIL Label */ 
#line 947
  end --;
#line 947
  mult = 1073741824.0;
#line 948
  goto switch_break;
  case_116: /* CIL Label */ 
#line 950
  end --;
#line 950
  mult = 1099511627776.0;
#line 951
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 955
  mult = (double )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 959
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 959
    if ((unsigned long )val < (unsigned long )end) {
#line 959
      if (! ((int const   )_sch_istable[(int const   )*val & 255] & 64)) {
#line 959
        goto while_break___0;
      }
    } else {
#line 959
      goto while_break___0;
    }
#line 960
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 961
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 961
    if ((unsigned long )val < (unsigned long )end) {
#line 961
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 961
        goto while_break___1;
      }
    } else {
#line 961
      goto while_break___1;
    }
#line 962
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 963
  if ((unsigned long )val == (unsigned long )end) {
#line 964
    return ((_Bool)0);
  }
  {
#line 966
  tmp___1 = simple_atof(val, end, & number);
  }
#line 966
  if (tmp___1) {
#line 966
    if (number < (double )0) {
#line 967
      return ((_Bool)0);
    }
  } else {
#line 967
    return ((_Bool)0);
  }
#line 969
  *result = number * mult;
#line 970
  return ((_Bool)1);
}
}
#line 987 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_bytes(char const   *com , char const   *val , void *place ) 
{ 
  double byte_value ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 991
  tmp___0 = parse_bytes_helper(val, & byte_value);
  }
#line 991
  if (! tmp___0) {
    {
#line 993
    tmp = gettext("%s: %s: Invalid byte value `%s\'\n");
#line 993
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 995
    return ((_Bool)0);
  }
#line 997
  *((wgint *)place) = (wgint )byte_value;
#line 998
  return ((_Bool)1);
}
}
#line 1006 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_bytes_sum(char const   *com , char const   *val , void *place ) 
{ 
  double byte_value ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1010
  tmp___0 = parse_bytes_helper(val, & byte_value);
  }
#line 1010
  if (! tmp___0) {
    {
#line 1012
    tmp = gettext("%s: %s: Invalid byte value `%s\'\n");
#line 1012
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 1014
    return ((_Bool)0);
  }
#line 1016
  *((SUM_SIZE_INT *)place) = (SUM_SIZE_INT )byte_value;
#line 1017
  return ((_Bool)1);
}
}
#line 1024 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_time(char const   *com , char const   *val , void *place ) 
{ 
  double number ;
  double mult ;
  char const   *end ;
  size_t tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1028
  tmp = strlen(val);
#line 1028
  end = val + tmp;
  }
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    if ((unsigned long )val < (unsigned long )end) {
#line 1031
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 1031
        goto while_break;
      }
    } else {
#line 1031
      goto while_break;
    }
#line 1032
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1034
  if ((unsigned long )val == (unsigned long )end) {
    err: 
    {
#line 1037
    tmp___0 = gettext("%s: %s: Invalid time period `%s\'\n");
#line 1037
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name, com, val);
    }
#line 1039
    return ((_Bool)0);
  }
  {
#line 1044
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 115) {
#line 1044
    goto case_115;
  }
#line 1047
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 109) {
#line 1047
    goto case_109;
  }
#line 1050
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 104) {
#line 1050
    goto case_104;
  }
#line 1053
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 100) {
#line 1053
    goto case_100;
  }
#line 1056
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 119) {
#line 1056
    goto case_119;
  }
#line 1059
  goto switch_default;
  case_115: /* CIL Label */ 
#line 1045
  end --;
#line 1045
  mult = (double )1;
#line 1046
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1048
  end --;
#line 1048
  mult = (double )60;
#line 1049
  goto switch_break;
  case_104: /* CIL Label */ 
#line 1051
  end --;
#line 1051
  mult = (double )3600;
#line 1052
  goto switch_break;
  case_100: /* CIL Label */ 
#line 1054
  end --;
#line 1054
  mult = 86400.0;
#line 1055
  goto switch_break;
  case_119: /* CIL Label */ 
#line 1057
  end --;
#line 1057
  mult = 604800.0;
#line 1058
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1062
  mult = (double )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1066
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1066
    if ((unsigned long )val < (unsigned long )end) {
#line 1066
      if (! ((int const   )_sch_istable[(int const   )*val & 255] & 64)) {
#line 1066
        goto while_break___0;
      }
    } else {
#line 1066
      goto while_break___0;
    }
#line 1067
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1068
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1068
    if ((unsigned long )val < (unsigned long )end) {
#line 1068
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 1068
        goto while_break___1;
      }
    } else {
#line 1068
      goto while_break___1;
    }
#line 1069
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1070
  if ((unsigned long )val == (unsigned long )end) {
#line 1071
    goto err;
  }
  {
#line 1073
  tmp___1 = simple_atof(val, end, & number);
  }
#line 1073
  if (! tmp___1) {
#line 1074
    goto err;
  }
#line 1076
  *((double *)place) = number * mult;
#line 1077
  return ((_Bool)1);
}
}
#line 1084 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static struct decode_item  const  choices[3]  = {      {"pem", 0}, 
        {"der", 1}, 
        {"asn1", 1}};
#line 1081 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_cert_type(char const   *com , char const   *val , void *place ) 
{ 
  int ok ;
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 1089
  tmp = decode_string(val, choices, (int )(sizeof(choices) / sizeof(choices[0])),
                      (int *)place);
#line 1089
  ok = (int )tmp;
  }
#line 1090
  if (! ok) {
    {
#line 1091
    tmp___0 = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1091
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name, com, val);
    }
  }
#line 1092
  return ((_Bool )ok);
}
}
#line 1099
static _Bool check_user_specified_header(char const   *s ) ;
#line 1101 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_dirstruct(char const   *com , char const   *val , void *place_ignored ) 
{ 
  _Bool tmp ;

  {
  {
#line 1104
  tmp = cmd_boolean(com, val, (void *)(& opt.dirstruct));
  }
#line 1104
  if (! tmp) {
#line 1105
    return ((_Bool)0);
  }
#line 1108
  if (opt.dirstruct) {
#line 1109
    opt.no_dirstruct = (_Bool)0;
  } else {
#line 1111
    opt.no_dirstruct = (_Bool)1;
  }
#line 1112
  return ((_Bool)1);
}
}
#line 1115 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_header(char const   *com , char const   *val , void *place_ignored ) 
{ 
  char *tmp ;
  _Bool tmp___0 ;

  {
#line 1119
  if ((int const   )*val == 0) {
    {
#line 1121
    free_vec(opt.user_headers);
#line 1122
    opt.user_headers = (char **)((void *)0);
    }
#line 1123
    return ((_Bool)1);
  }
  {
#line 1126
  tmp___0 = check_user_specified_header(val);
  }
#line 1126
  if (! tmp___0) {
    {
#line 1128
    tmp = gettext("%s: %s: Invalid header `%s\'.\n");
#line 1128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 1130
    return ((_Bool)0);
  }
  {
#line 1132
  opt.user_headers = vec_append(opt.user_headers, val);
  }
#line 1133
  return ((_Bool)1);
}
}
#line 1136 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_htmlify(char const   *com , char const   *val , void *place_ignored ) 
{ 
  int flag ;
  _Bool tmp ;

  {
  {
#line 1139
  tmp = cmd_boolean(com, val, (void *)(& opt.htmlify));
#line 1139
  flag = (int )tmp;
  }
#line 1140
  if (flag) {
#line 1140
    if (! opt.htmlify) {
#line 1141
      opt.remove_listing = (_Bool)0;
    }
  }
#line 1142
  return ((_Bool )flag);
}
}
#line 1148 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_mirror(char const   *com , char const   *val , void *place_ignored ) 
{ 
  int mirror ;
  _Bool tmp ;

  {
  {
#line 1153
  tmp = cmd_boolean(com, val, (void *)(& mirror));
  }
#line 1153
  if (! tmp) {
#line 1154
    return ((_Bool)0);
  }
#line 1155
  if (mirror) {
#line 1157
    opt.recursive = (_Bool)1;
#line 1158
    if (! opt.no_dirstruct) {
#line 1159
      opt.dirstruct = (_Bool)1;
    }
#line 1160
    opt.timestamping = (_Bool)1;
#line 1161
    opt.reclevel = -1;
#line 1162
    opt.remove_listing = (_Bool)0;
  }
#line 1164
  return ((_Bool)1);
}
}
#line 1173 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static struct decode_item  const  choices___0[3]  = {      {"IPv4", 0}, 
        {"IPv6", 1}, 
        {"none", 2}};
#line 1170 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_prefer_family(char const   *com , char const   *val , void *place_ignored ) 
{ 
  int prefer_family ;
  int ok ;
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 1178
  prefer_family = 0;
#line 1179
  tmp = decode_string(val, choices___0, (int )(sizeof(choices___0) / sizeof(choices___0[0])),
                      & prefer_family);
#line 1179
  ok = (int )tmp;
  }
#line 1180
  if (! ok) {
    {
#line 1181
    tmp___0 = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name, com, val);
    }
  }
#line 1182
  opt.prefer_family = (enum __anonenum_prefer_family_762245126 )prefer_family;
#line 1183
  return ((_Bool )ok);
}
}
#line 1189 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_progress(char const   *com , char const   *val , void *place_ignored ) 
{ 
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1192
  tmp___0 = valid_progress_implementation_p(val);
  }
#line 1192
  if (! tmp___0) {
    {
#line 1194
    tmp = gettext("%s: %s: Invalid progress type `%s\'.\n");
#line 1194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 1196
    return ((_Bool)0);
  }
#line 1198
  if (! (! opt.progress_type)) {
    {
#line 1198
    checking_free((void *)opt.progress_type);
    }
  }
  {
#line 1202
  opt.progress_type = checking_strdup(val);
  }
#line 1203
  return ((_Bool)1);
}
}
#line 1210 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_recursive(char const   *com , char const   *val , void *place_ignored ) 
{ 
  _Bool tmp ;

  {
  {
#line 1213
  tmp = cmd_boolean(com, val, (void *)(& opt.recursive));
  }
#line 1213
  if (tmp) {
#line 1217
    if (opt.recursive) {
#line 1217
      if (! opt.no_dirstruct) {
#line 1218
        opt.dirstruct = (_Bool)1;
      }
    }
  } else {
#line 1214
    return ((_Bool)0);
  }
#line 1220
  return ((_Bool)1);
}
}
#line 1223 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_restrict_file_names(char const   *com , char const   *val ,
                                          void *place_ignored ) 
{ 
  int restrict_os ;
  int restrict_ctrl ;
  int restrict_case ;
  char const   *end ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1226
  restrict_os = (int )opt.restrict_files_os;
#line 1227
  restrict_ctrl = (int )opt.restrict_files_ctrl;
#line 1228
  restrict_case = (int )opt.restrict_files_case;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1236
    tmp = strchr(val, ',');
#line 1236
    end = (char const   *)tmp;
    }
#line 1237
    if (! end) {
      {
#line 1238
      tmp___0 = strlen(val);
#line 1238
      end = val + tmp___0;
      }
    }
#line 1240
    if ((unsigned long )(end - val) == sizeof("unix") - 1UL) {
      {
#line 1240
      tmp___6 = memcmp((void const   *)val, (void const   *)"unix", sizeof("unix") - 1UL);
      }
#line 1240
      if (tmp___6) {
#line 1240
        goto _L___2;
      } else {
#line 1241
        restrict_os = 0;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1242
    if ((unsigned long )(end - val) == sizeof("windows") - 1UL) {
      {
#line 1242
      tmp___5 = memcmp((void const   *)val, (void const   *)"windows", sizeof("windows") - 1UL);
      }
#line 1242
      if (tmp___5) {
#line 1242
        goto _L___1;
      } else {
#line 1243
        restrict_os = 1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1244
    if ((unsigned long )(end - val) == sizeof("lowercase") - 1UL) {
      {
#line 1244
      tmp___4 = memcmp((void const   *)val, (void const   *)"lowercase", sizeof("lowercase") - 1UL);
      }
#line 1244
      if (tmp___4) {
#line 1244
        goto _L___0;
      } else {
#line 1245
        restrict_case = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1246
    if ((unsigned long )(end - val) == sizeof("uppercase") - 1UL) {
      {
#line 1246
      tmp___3 = memcmp((void const   *)val, (void const   *)"uppercase", sizeof("uppercase") - 1UL);
      }
#line 1246
      if (tmp___3) {
#line 1246
        goto _L;
      } else {
#line 1247
        restrict_case = 2;
      }
    } else
    _L: /* CIL Label */ 
#line 1248
    if ((unsigned long )(end - val) == sizeof("nocontrol") - 1UL) {
      {
#line 1248
      tmp___2 = memcmp((void const   *)val, (void const   *)"nocontrol", sizeof("nocontrol") - 1UL);
      }
#line 1248
      if (tmp___2) {
        {
#line 1252
        tmp___1 = gettext("%s: %s: Invalid restriction `%s\', use [unix|windows],[lowercase|uppercase],[nocontrol].\n");
#line 1252
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                program_name, com, val);
        }
#line 1255
        return ((_Bool)0);
      } else {
#line 1249
        restrict_ctrl = 0;
      }
    } else {
      {
#line 1252
      tmp___1 = gettext("%s: %s: Invalid restriction `%s\', use [unix|windows],[lowercase|uppercase],[nocontrol].\n");
#line 1252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              program_name, com, val);
      }
#line 1255
      return ((_Bool)0);
    }
#line 1258
    if (*end) {
#line 1259
      val = end + 1;
    }
#line 1234
    if (*val) {
#line 1234
      if (! *end) {
#line 1234
        goto while_break;
      }
    } else {
#line 1234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1265
  opt.restrict_files_os = (enum __anonenum_restrict_files_os_843006439 )restrict_os;
#line 1266
  opt.restrict_files_ctrl = (_Bool )restrict_ctrl;
#line 1267
  opt.restrict_files_case = (enum __anonenum_restrict_files_case_191639182 )restrict_case;
#line 1269
  return ((_Bool)1);
}
}
#line 1276 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static struct decode_item  const  choices___1[4]  = {      {"auto", 0}, 
        {"sslv2", 1}, 
        {"sslv3", 2}, 
        {"tlsv1", 3}};
#line 1273 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_secure_protocol(char const   *com , char const   *val , void *place ) 
{ 
  int ok ;
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 1282
  tmp = decode_string(val, choices___1, (int )(sizeof(choices___1) / sizeof(choices___1[0])),
                      (int *)place);
#line 1282
  ok = (int )tmp;
  }
#line 1283
  if (! ok) {
    {
#line 1284
    tmp___0 = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name, com, val);
    }
  }
#line 1285
  return ((_Bool )ok);
}
}
#line 1291 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_timeout(char const   *com , char const   *val , void *place_ignored ) 
{ 
  double value ;
  _Bool tmp ;

  {
  {
#line 1295
  tmp = cmd_time(com, val, (void *)(& value));
  }
#line 1295
  if (! tmp) {
#line 1296
    return ((_Bool)0);
  }
#line 1297
  opt.read_timeout = value;
#line 1298
  opt.connect_timeout = value;
#line 1299
  opt.dns_timeout = value;
#line 1300
  return ((_Bool)1);
}
}
#line 1303 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_useragent(char const   *com , char const   *val , void *place_ignored ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1307
  tmp___0 = strchr(val, '\n');
  }
#line 1307
  if (tmp___0) {
    {
#line 1309
    tmp = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name, com, val);
    }
#line 1311
    return ((_Bool)0);
  }
#line 1313
  if (! (! opt.useragent)) {
    {
#line 1313
    checking_free((void *)opt.useragent);
    }
  }
  {
#line 1314
  opt.useragent = checking_strdup(val);
  }
#line 1315
  return ((_Bool)1);
}
}
#line 1322 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool cmd_spec_verbose(char const   *com , char const   *val , void *place_ignored ) 
{ 
  _Bool flag ;
  _Bool tmp ;

  {
  {
#line 1326
  tmp = cmd_boolean(com, val, (void *)(& flag));
  }
#line 1326
  if (tmp) {
#line 1328
    opt.verbose = (int )flag;
#line 1329
    return ((_Bool)1);
  }
#line 1331
  return ((_Bool)0);
}
}
#line 1340 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool simple_atoi(char const   *beg , char const   *end , int *dest ) 
{ 
  int result ;
  _Bool negative ;
  char const   *p___0 ;
  int next ;
  int next___0 ;

  {
#line 1343
  result = 0;
#line 1344
  negative = (_Bool)0;
#line 1345
  p___0 = beg;
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 1347
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 1347
        goto while_break;
      }
    } else {
#line 1347
      goto while_break;
    }
#line 1348
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1349
  if ((unsigned long )p___0 < (unsigned long )end) {
#line 1349
    if ((int const   )*p___0 == 45) {
#line 1351
      negative = (_Bool )((int const   )*p___0 == 45);
#line 1352
      p___0 ++;
    } else
#line 1349
    if ((int const   )*p___0 == 43) {
#line 1351
      negative = (_Bool )((int const   )*p___0 == 45);
#line 1352
      p___0 ++;
    }
  }
#line 1354
  if ((unsigned long )p___0 == (unsigned long )end) {
#line 1355
    return ((_Bool)0);
  }
#line 1360
  if (! negative) {
    {
#line 1361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1361
      if ((unsigned long )p___0 < (unsigned long )end) {
#line 1361
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 1361
          goto while_break___0;
        }
      } else {
#line 1361
        goto while_break___0;
      }
#line 1363
      next = 10 * result + (int )((int const   )*p___0 - 48);
#line 1364
      if (next < result) {
#line 1365
        return ((_Bool)0);
      }
#line 1366
      result = next;
#line 1361
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1369
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1369
      if ((unsigned long )p___0 < (unsigned long )end) {
#line 1369
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 1369
          goto while_break___1;
        }
      } else {
#line 1369
        goto while_break___1;
      }
#line 1371
      next___0 = 10 * result - (int )((int const   )*p___0 - 48);
#line 1372
      if (next___0 > result) {
#line 1373
        return ((_Bool)0);
      }
#line 1374
      result = next___0;
#line 1369
      p___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1377
  if ((unsigned long )p___0 != (unsigned long )end) {
#line 1378
    return ((_Bool)0);
  }
#line 1380
  *dest = result;
#line 1381
  return ((_Bool)1);
}
}
#line 1389 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool simple_atof(char const   *beg , char const   *end , double *dest ) 
{ 
  double result ;
  _Bool negative ;
  _Bool seen_dot ;
  _Bool seen_digit ;
  double divider ;
  char const   *p___0 ;
  char ch ;

  {
#line 1392
  result = (double )0;
#line 1394
  negative = (_Bool)0;
#line 1395
  seen_dot = (_Bool)0;
#line 1396
  seen_digit = (_Bool)0;
#line 1397
  divider = (double )1;
#line 1399
  p___0 = beg;
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 1401
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 1401
        goto while_break;
      }
    } else {
#line 1401
      goto while_break;
    }
#line 1402
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1403
  if ((unsigned long )p___0 < (unsigned long )end) {
#line 1403
    if ((int const   )*p___0 == 45) {
#line 1405
      negative = (_Bool )((int const   )*p___0 == 45);
#line 1406
      p___0 ++;
    } else
#line 1403
    if ((int const   )*p___0 == 43) {
#line 1405
      negative = (_Bool )((int const   )*p___0 == 45);
#line 1406
      p___0 ++;
    }
  }
  {
#line 1409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1409
    if (! ((unsigned long )p___0 < (unsigned long )end)) {
#line 1409
      goto while_break___0;
    }
#line 1411
    ch = (char )*p___0;
#line 1412
    if ((int const   )_sch_istable[(int )ch & 255] & 4) {
#line 1414
      if (! seen_dot) {
#line 1415
        result = (double )10 * result + (double )((int )ch - 48);
      } else {
#line 1417
        divider *= (double )10;
#line 1417
        result += (double )((int )ch - 48) / divider;
      }
#line 1418
      seen_digit = (_Bool)1;
    } else
#line 1420
    if ((int )ch == 46) {
#line 1422
      if (! seen_dot) {
#line 1423
        seen_dot = (_Bool)1;
      } else {
#line 1425
        return ((_Bool)0);
      }
    } else {
#line 1428
      return ((_Bool)0);
    }
#line 1409
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1430
  if (! seen_digit) {
#line 1431
    return ((_Bool)0);
  }
#line 1432
  if (negative) {
#line 1433
    result = - result;
  }
#line 1435
  *dest = result;
#line 1436
  return ((_Bool)1);
}
}
#line 1443 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool check_user_specified_header(char const   *s ) 
{ 
  char const   *p___0 ;
  char *tmp ;

  {
#line 1448
  p___0 = s;
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1448
    if (*p___0) {
#line 1448
      if ((int const   )*p___0 != 58) {
#line 1448
        if (! (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64))) {
#line 1448
          goto while_break;
        }
      } else {
#line 1448
        goto while_break;
      }
    } else {
#line 1448
      goto while_break;
    }
#line 1448
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1452
  if ((int const   )*p___0 != 58) {
#line 1453
    return ((_Bool)0);
  } else
#line 1452
  if ((unsigned long )p___0 == (unsigned long )s) {
#line 1453
    return ((_Bool)0);
  }
  {
#line 1455
  tmp = strchr(s, '\n');
  }
#line 1455
  if (tmp) {
#line 1456
    return ((_Bool)0);
  }
#line 1457
  return ((_Bool)1);
}
}
#line 1462 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
static _Bool decode_string(char const   *val , struct decode_item  const  *items ,
                           int itemcount , int *place ) 
{ 
  int i ;
  int tmp ;

  {
#line 1467
  i = 0;
  {
#line 1467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1467
    if (! (i < itemcount)) {
#line 1467
      goto while_break;
    }
    {
#line 1468
    tmp = strcasecmp(val, (char const   *)(items + i)->name);
    }
#line 1468
    if (0 == tmp) {
#line 1470
      *place = (int )(items + i)->code;
#line 1471
      return ((_Bool)1);
    }
#line 1467
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  return ((_Bool)0);
}
}
#line 1481 "/home/khheo/project/benchmark/wget-1.11.4/src/init.c"
void cleanup(void) 
{ 


  {
#line 1486
  if (output_stream) {
    {
#line 1487
    fclose(output_stream);
    }
  }
#line 1548
  return;
}
}
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 95 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                                                 char const   * __restrict  __fmt ,
                                                                                 struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) ;
#line 38 "/home/khheo/project/benchmark/wget-1.11.4/src/http.h"
void http_cleanup(void) ;
#line 39
time_t http_atotm(char const   *time_string ) ;
#line 45
_Bool extract_param(char const   **source , param_token *name , param_token *value ,
                    char separator ) ;
#line 81 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
struct address_list *lookup_host(char const   *host , int flags ) ;
#line 85
_Bool address_list_contains(struct address_list  const  *al , ip_address const   *ip___0 ) ;
#line 89
void address_list_release(struct address_list *al ) ;
#line 42 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
int connect_to_host(char const   *host , int port ) ;
#line 52
_Bool socket_ip_address(int sock , ip_address *ip___0 , int endpoint ) ;
#line 54
_Bool retryable_socket_connect_error(int err ) ;
#line 62
_Bool test_socket_open(int sock ) ;
#line 76
int fd_write(int fd , char *buf___4 , int bufsize , double timeout ) ;
#line 78
char const   *fd_errstr(int fd ) ;
#line 79
void fd_close(int fd ) ;
#line 48 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.h"
_Bool ntlm_input(struct ntlmdata *ntlm , char const   *header ) ;
#line 51
char *ntlm_output(struct ntlmdata *ntlm , char const   *user , char const   *passwd ,
                  _Bool *ready ) ;
#line 36 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.h"
struct cookie_jar *cookie_jar_new(void) ;
#line 37
void cookie_jar_delete(struct cookie_jar *jar ) ;
#line 39
void cookie_handle_set_cookie(struct cookie_jar *jar , char const   *host , int port ,
                              char const   *path , char const   *set_cookie ) ;
#line 41
char *cookie_header(struct cookie_jar *jar , char const   *host , int port , char const   *path ,
                    _Bool secflag ) ;
#line 44
void cookie_jar_load(struct cookie_jar *jar , char const   *file ) ;
#line 45
void cookie_jar_save(struct cookie_jar *jar , char const   *file ) ;
#line 46 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.h"
int gen_md5_context_size(void) ;
#line 47
void gen_md5_init(gen_md5_context *ctx ) ;
#line 48
void gen_md5_update(unsigned char const   *buffer___0 , int len , gen_md5_context *ctx ) ;
#line 49
void gen_md5_finish(gen_md5_context *ctx , unsigned char *result ) ;
#line 96 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
downloaded_file_t downloaded_file(downloaded_file_t mode , char const   *file ) ;
#line 73 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *create_authorization_line(char const   *au , char const   *user , char const   *passwd ,
                                       char const   *method , char const   *path ,
                                       _Bool *finished ) ;
#line 76
static char *basic_authentication_encode(char const   *user , char const   *passwd ) ;
#line 77
static _Bool known_authentication_scheme_p(char const   *hdrbeg , char const   *hdrend ) ;
#line 78
static void load_cookies(void) ;
#line 85 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool cookies_loaded_p  ;
#line 86 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct cookie_jar *wget_cookie_jar  ;
#line 146 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct request *request_new(void) 
{ 
  struct request *req ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 149
  tmp = checking_malloc0(sizeof(struct request ));
#line 149
  req = (struct request *)tmp;
#line 150
  req->hcapacity = 8;
#line 151
  tmp___0 = checking_malloc((unsigned long )req->hcapacity * sizeof(struct request_header ));
#line 151
  req->headers = (struct request_header *)tmp___0;
  }
#line 152
  return (req);
}
}
#line 159 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void request_set_method(struct request *req , char const   *meth , char *arg ) 
{ 


  {
#line 162
  req->method = meth;
#line 163
  req->arg = arg;
#line 164
  return;
}
}
#line 169 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char const   *request_method(struct request  const  *req ) 
{ 


  {
#line 172
  return ((char const   *)req->method);
}
}
#line 178 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void release_header(struct request_header *hdr ) 
{ 


  {
  {
#line 183
  if ((unsigned int )hdr->release_policy == 0U) {
#line 183
    goto case_0;
  }
#line 185
  if ((unsigned int )hdr->release_policy == 1U) {
#line 185
    goto case_1;
  }
#line 188
  if ((unsigned int )hdr->release_policy == 2U) {
#line 188
    goto case_2;
  }
#line 191
  if ((unsigned int )hdr->release_policy == 3U) {
#line 191
    goto case_3;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
#line 184
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 186
  checking_free((void *)hdr->name);
  }
#line 187
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 189
  checking_free((void *)hdr->value);
  }
#line 190
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 192
  checking_free((void *)hdr->name);
#line 193
  checking_free((void *)hdr->value);
  }
#line 194
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 226 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void request_set_header(struct request *req , char *name , char *value , enum rp release_policy ) 
{ 
  struct request_header *hdr ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 233
  if (! value) {
#line 237
    if ((unsigned int )release_policy == 1U) {
      {
#line 238
      checking_free((void *)name);
      }
    } else
#line 237
    if ((unsigned int )release_policy == 3U) {
      {
#line 238
      checking_free((void *)name);
      }
    }
#line 239
    return;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < req->hcount)) {
#line 242
      goto while_break;
    }
    {
#line 244
    hdr = req->headers + i;
#line 245
    tmp = strcasecmp((char const   *)name, (char const   *)hdr->name);
    }
#line 245
    if (0 == tmp) {
      {
#line 248
      release_header(hdr);
#line 249
      hdr->name = name;
#line 250
      hdr->value = value;
#line 251
      hdr->release_policy = release_policy;
      }
#line 252
      return;
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if (req->hcount >= req->hcapacity) {
    {
#line 260
    req->hcapacity <<= 1;
#line 261
    tmp___0 = checking_realloc((void *)req->headers, (unsigned long )req->hcapacity * sizeof(*hdr));
#line 261
    req->headers = (struct request_header *)tmp___0;
    }
  }
#line 263
  tmp___1 = req->hcount;
#line 263
  (req->hcount) ++;
#line 263
  hdr = req->headers + tmp___1;
#line 264
  hdr->name = name;
#line 265
  hdr->value = value;
#line 266
  hdr->release_policy = release_policy;
#line 267
  return;
}
}
#line 274 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void request_set_user_header(struct request *req , char const   *header ) 
{ 
  char *name ;
  char const   *p___0 ;
  char *tmp ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 278
  tmp = strchr(header, ':');
#line 278
  p___0 = (char const   *)tmp;
  }
#line 279
  if (! p___0) {
#line 280
    return;
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    BTA_beg = header;
#line 281
    BTA_len = (int )(p___0 - BTA_beg);
#line 281
    BTA_dest = & name;
#line 281
    tmp___0 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 281
    *BTA_dest = (char *)tmp___0;
#line 281
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 281
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  p___0 ++;
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 283
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 283
      goto while_break___0;
    }
#line 284
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 285
  tmp___1 = checking_strdup((char const   *)name);
#line 285
  request_set_header(req, tmp___1, (char *)p___0, (enum rp )1);
  }
#line 286
  return;
}
}
#line 291 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool request_remove_header(struct request *req , char *name ) 
{ 
  int i ;
  struct request_header *hdr ;
  int tmp ;

  {
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < req->hcount)) {
#line 295
      goto while_break;
    }
    {
#line 297
    hdr = req->headers + i;
#line 298
    tmp = strcasecmp((char const   *)name, (char const   *)hdr->name);
    }
#line 298
    if (0 == tmp) {
      {
#line 300
      release_header(hdr);
      }
#line 302
      if (i < req->hcount - 1) {
        {
#line 303
        memmove((void *)hdr, (void const   *)(hdr + 1), (unsigned long )((req->hcount - i) - 1) * sizeof(*hdr));
        }
      }
#line 304
      (req->hcount) --;
#line 305
      return ((_Bool)1);
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return ((_Bool)0);
}
}
#line 319 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static int request_send(struct request  const  *req , int fd ) 
{ 
  char *request_string ;
  char *p___0 ;
  int i ;
  int size ;
  int write_error ;
  size_t tmp ;
  size_t tmp___0 ;
  struct request_header *hdr ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int A_len ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int A_len___0 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  struct request_header *hdr___0 ;
  int A_len___1 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int A_len___2 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  long tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 326
  size = 0;
#line 329
  tmp = strlen((char const   *)req->method);
#line 329
  tmp___0 = strlen((char const   *)req->arg);
#line 329
  size = (int )((size_t )size + (((((tmp + 1UL) + tmp___0) + 1UL) + 8UL) + 2UL));
#line 331
  i = 0;
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < (int )req->hcount)) {
#line 331
      goto while_break;
    }
    {
#line 333
    hdr = req->headers + i;
#line 335
    tmp___1 = strlen((char const   *)hdr->name);
#line 335
    tmp___2 = strlen((char const   *)hdr->value);
#line 335
    size = (int )((size_t )size + (((tmp___1 + 2UL) + tmp___2) + 2UL));
#line 331
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  size += 3;
#line 341
  tmp___3 = __builtin_alloca((unsigned long )size * sizeof(char ));
#line 341
  request_string = (char *)tmp___3;
#line 341
  p___0 = request_string;
  }
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 345
    tmp___4 = strlen((char const   *)req->method);
#line 345
    A_len = (int )tmp___4;
#line 345
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)req->method,
           (size_t )A_len);
#line 345
    p___0 += A_len;
    }
#line 345
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 345
  tmp___5 = p___0;
#line 345
  p___0 ++;
#line 345
  *tmp___5 = (char )' ';
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 346
    tmp___6 = strlen((char const   *)req->arg);
#line 346
    A_len___0 = (int )tmp___6;
#line 346
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)req->arg,
           (size_t )A_len___0);
#line 346
    p___0 += A_len___0;
    }
#line 346
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 346
  tmp___7 = p___0;
#line 346
  p___0 ++;
#line 346
  *tmp___7 = (char )' ';
#line 347
  memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)"HTTP/1.0\r\n",
         (size_t )10);
#line 347
  p___0 += 10;
#line 349
  i = 0;
  }
  {
#line 349
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 349
    if (! (i < (int )req->hcount)) {
#line 349
      goto while_break___2;
    }
#line 351
    hdr___0 = req->headers + i;
    {
#line 352
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 352
      tmp___8 = strlen((char const   *)hdr___0->name);
#line 352
      A_len___1 = (int )tmp___8;
#line 352
      memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)hdr___0->name,
             (size_t )A_len___1);
#line 352
      p___0 += A_len___1;
      }
#line 352
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 353
    tmp___9 = p___0;
#line 353
    p___0 ++;
#line 353
    *tmp___9 = (char )':';
#line 353
    tmp___10 = p___0;
#line 353
    p___0 ++;
#line 353
    *tmp___10 = (char )' ';
    {
#line 354
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 354
      tmp___11 = strlen((char const   *)hdr___0->value);
#line 354
      A_len___2 = (int )tmp___11;
#line 354
      memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)hdr___0->value,
             (size_t )A_len___2);
#line 354
      p___0 += A_len___2;
      }
#line 354
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 355
    tmp___12 = p___0;
#line 355
    p___0 ++;
#line 355
    *tmp___12 = (char )'\r';
#line 355
    tmp___13 = p___0;
#line 355
    p___0 ++;
#line 355
    *tmp___13 = (char )'\n';
#line 349
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 358
  tmp___14 = p___0;
#line 358
  p___0 ++;
#line 358
  *tmp___14 = (char )'\r';
#line 358
  tmp___15 = p___0;
#line 358
  p___0 ++;
#line 358
  *tmp___15 = (char )'\n';
#line 358
  tmp___16 = p___0;
#line 358
  p___0 ++;
#line 358
  *tmp___16 = (char )'\000';
#line 359
  if (! (p___0 - request_string == (long )size)) {
    {
#line 359
    __assert_fail("p - request_string == size", "/home/khheo/project/benchmark/wget-1.11.4/src/http.c",
                  359U, "request_send");
    }
  }
  {
#line 363
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 363
    tmp___18 = __builtin_expect((long )opt.debug, 0L);
    }
#line 363
    if (tmp___18) {
      {
#line 363
      debug_logprintf("\n---request begin---\n%s---request end---\n", request_string);
      }
    }
#line 363
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 367
  write_error = fd_write(fd, request_string, size - 1, (double )-1);
  }
#line 368
  if (write_error < 0) {
    {
#line 369
    tmp___19 = fd_errstr(fd);
#line 369
    tmp___20 = gettext("Failed writing HTTP request: %s.\n");
#line 369
    logprintf((enum log_options )0, (char const   *)tmp___20, tmp___19);
    }
  }
#line 371
  return (write_error);
}
}
#line 376 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void request_free(struct request *req ) 
{ 
  int i ;

  {
#line 380
  if (! (! req->arg)) {
    {
#line 380
    checking_free((void *)req->arg);
    }
  }
#line 381
  i = 0;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < req->hcount)) {
#line 381
      goto while_break;
    }
    {
#line 382
    release_header(req->headers + i);
#line 381
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  if (! (! req->headers)) {
    {
#line 383
    checking_free((void *)req->headers);
    }
  }
  {
#line 384
  checking_free((void *)req);
  }
#line 385
  return;
}
}
#line 387 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct hash_table *basic_authed_hosts  ;
#line 393 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool maybe_send_basic_creds(char const   *hostname , char const   *user ,
                                    char const   *passwd , struct request *req ) 
{ 
  _Bool do_challenge ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 397
  do_challenge = (_Bool)0;
#line 399
  if (opt.auth_without_challenge) {
    {
#line 401
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 401
      tmp = __builtin_expect((long )opt.debug, 0L);
      }
#line 401
      if (tmp) {
        {
#line 401
        debug_logprintf("Auth-without-challenge set, sending Basic credentials.\n");
        }
      }
#line 401
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 402
    do_challenge = (_Bool)1;
  } else
#line 404
  if (basic_authed_hosts) {
    {
#line 404
    tmp___2 = hash_table_contains((struct hash_table  const  *)basic_authed_hosts,
                                  (void const   *)hostname);
    }
#line 404
    if (tmp___2) {
      {
#line 407
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 407
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 407
        if (tmp___0) {
          {
#line 407
          debug_logprintf("Found `%s\' in basic_authed_hosts.\n", hostname);
          }
        }
#line 407
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 408
      do_challenge = (_Bool)1;
    } else {
#line 404
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 412
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 412
      tmp___1 = __builtin_expect((long )opt.debug, 0L);
      }
#line 412
      if (tmp___1) {
        {
#line 412
        debug_logprintf("Host `%s\' has not issued a general basic challenge.\n",
                        hostname);
        }
      }
#line 412
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 415
  if (do_challenge) {
    {
#line 417
    tmp___3 = basic_authentication_encode(user, passwd);
#line 417
    request_set_header(req, (char *)"Authorization", tmp___3, (enum rp )2);
    }
  }
#line 421
  return (do_challenge);
}
}
#line 424 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void register_basic_auth_host(char const   *hostname ) 
{ 
  char *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 427
  if (! basic_authed_hosts) {
    {
#line 429
    basic_authed_hosts = make_nocase_string_hash_table(1);
    }
  }
  {
#line 431
  tmp___1 = hash_table_contains((struct hash_table  const  *)basic_authed_hosts, (void const   *)hostname);
  }
#line 431
  if (! tmp___1) {
    {
#line 433
    tmp = checking_strdup(hostname);
#line 433
    hash_table_put(basic_authed_hosts, (void const   *)tmp, (void *)0);
    }
    {
#line 434
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 434
      tmp___0 = __builtin_expect((long )opt.debug, 0L);
      }
#line 434
      if (tmp___0) {
        {
#line 434
        debug_logprintf("Inserted `%s\' into basic_authed_hosts\n", hostname);
        }
      }
#line 434
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 436
  return;
}
}
#line 446 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char chunk[8192]  ;
#line 443 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static int post_file(int sock , char const   *file_name , wgint promised_size ) 
{ 
  wgint written ;
  int write_error ;
  FILE *fp ;
  long tmp ;
  int towrite ;
  int length ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  long tmp___4 ;

  {
#line 447
  written = (wgint )0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 451
    if (tmp) {
      {
#line 451
      debug_logprintf("[writing POST file %s ... ", file_name);
      }
    }
#line 451
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 453
  fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"rb");
  }
#line 454
  if (! fp) {
#line 455
    return (-1);
  }
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 456
    tmp___1 = feof(fp);
    }
#line 456
    if (tmp___1) {
#line 456
      goto while_break___0;
    } else
#line 456
    if (! (written < promised_size)) {
#line 456
      goto while_break___0;
    }
    {
#line 459
    tmp___0 = fread((void */* __restrict  */)(chunk), (size_t )1, sizeof(chunk), (FILE */* __restrict  */)fp);
#line 459
    length = (int )tmp___0;
    }
#line 460
    if (length == 0) {
#line 461
      goto while_break___0;
    }
#line 462
    if (promised_size - written > (wgint )length) {
#line 462
      towrite = length;
    } else {
#line 462
      towrite = (int )(promised_size - written);
    }
    {
#line 463
    write_error = fd_write(sock, chunk, towrite, (double )-1);
    }
#line 464
    if (write_error < 0) {
      {
#line 466
      fclose(fp);
      }
#line 467
      return (-1);
    }
#line 469
    written += (wgint )towrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 471
  fclose(fp);
  }
#line 475
  if (written < promised_size) {
    {
#line 477
    tmp___2 = __errno_location();
#line 477
    *tmp___2 = 22;
    }
#line 478
    return (-1);
  }
#line 481
  if (! (written == promised_size)) {
    {
#line 481
    __assert_fail("written == promised_size", "/home/khheo/project/benchmark/wget-1.11.4/src/http.c",
                  481U, "post_file");
    }
  }
  {
#line 482
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 482
    tmp___4 = __builtin_expect((long )opt.debug, 0L);
    }
#line 482
    if (tmp___4) {
      {
#line 482
      debug_logprintf("done]\n");
      }
    }
#line 482
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 483
  return (0);
}
}
#line 492 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char const   *response_head_terminator(char const   *start , char const   *peeked ,
                                              int peeklen ) 
{ 
  char const   *p___0 ;
  char const   *end ;
  int tmp ;
  int tmp___0 ;

  {
#line 500
  if ((unsigned long )start == (unsigned long )peeked) {
#line 500
    if (peeklen > 4) {
#line 500
      tmp = 4;
    } else {
#line 500
      tmp = peeklen;
    }
    {
#line 500
    tmp___0 = memcmp((void const   *)start, (void const   *)"HTTP", (size_t )tmp);
    }
#line 500
    if (0 != tmp___0) {
#line 501
      return (start);
    }
  }
#line 507
  if (peeked - start < 2L) {
#line 507
    p___0 = start;
  } else {
#line 507
    p___0 = peeked - 2;
  }
#line 508
  end = peeked + peeklen;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! ((unsigned long )p___0 < (unsigned long )(end - 2))) {
#line 511
      goto while_break;
    }
#line 512
    if ((int const   )*p___0 == 10) {
#line 514
      if ((int const   )*(p___0 + 1) == 13) {
#line 514
        if ((int const   )*(p___0 + 2) == 10) {
#line 515
          return (p___0 + 3);
        } else {
#line 514
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 516
      if ((int const   )*(p___0 + 1) == 10) {
#line 517
        return (p___0 + 2);
      }
    }
#line 511
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if ((int const   )*(p___0 + 0) == 10) {
#line 520
    if ((int const   )*(p___0 + 1) == 10) {
#line 521
      return (p___0 + 2);
    }
  }
#line 523
  return ((char const   *)((void *)0));
}
}
#line 542 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *read_http_response_head(int fd ) 
{ 
  char *tmp ;

  {
  {
#line 545
  tmp = fd_read_hunk(fd, & response_head_terminator, 512L, 65536L);
  }
#line 545
  return (tmp);
}
}
#line 579 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct response *resp_new(char const   *head ) 
{ 
  char const   *hdr ;
  int count ;
  int size ;
  struct response *resp ;
  void *tmp ;
  long DR_needed_size ;
  long DR_newsize ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *end ;
  char *tmp___2 ;
  size_t tmp___3 ;
  long DR_needed_size___0 ;
  long DR_newsize___0 ;
  void *tmp___4 ;

  {
  {
#line 585
  tmp = checking_malloc0(sizeof(struct response ));
#line 585
  resp = (struct response *)tmp;
#line 586
  resp->data = head;
  }
#line 588
  if ((int const   )*head == 0) {
#line 593
    return (resp);
  }
#line 599
  count = 0;
#line 599
  size = count;
#line 600
  hdr = head;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 603
      DR_needed_size = (long )(count + 1);
#line 603
      DR_newsize = 0L;
      {
#line 603
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 603
        if (! ((long )size < DR_needed_size)) {
#line 603
          goto while_break___1;
        }
#line 603
        DR_newsize = (long )(size << 1);
#line 603
        if (DR_newsize < 16L) {
#line 603
          DR_newsize = 16L;
        }
#line 603
        size = (int )DR_newsize;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 603
      if (DR_newsize) {
        {
#line 603
        tmp___0 = checking_realloc((void *)resp->headers, (unsigned long )DR_newsize * sizeof(char const   *));
#line 603
        resp->headers = (char const   **)tmp___0;
        }
      }
#line 603
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 604
    tmp___1 = count;
#line 604
    count ++;
#line 604
    *(resp->headers + tmp___1) = hdr;
#line 607
    if (! *(hdr + 0)) {
#line 608
      goto while_break;
    } else
#line 607
    if ((int const   )*(hdr + 0) == 13) {
#line 607
      if ((int const   )*(hdr + 1) == 10) {
#line 608
        goto while_break;
      } else {
#line 607
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 607
    if ((int const   )*(hdr + 0) == 10) {
#line 608
      goto while_break;
    }
    {
#line 611
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 613
      tmp___2 = strchr(hdr, '\n');
#line 613
      end = (char const   *)tmp___2;
      }
#line 614
      if (end) {
#line 615
        hdr = end + 1;
      } else {
        {
#line 617
        tmp___3 = strlen(hdr);
#line 617
        hdr += tmp___3;
        }
      }
#line 611
      if (! ((int const   )*hdr == 32)) {
#line 611
        if (! ((int const   )*hdr == 9)) {
#line 611
          goto while_break___2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 621
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 621
    DR_needed_size___0 = (long )(count + 1);
#line 621
    DR_newsize___0 = 0L;
    {
#line 621
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 621
      if (! ((long )size < DR_needed_size___0)) {
#line 621
        goto while_break___4;
      }
#line 621
      DR_newsize___0 = (long )(size << 1);
#line 621
      if (DR_newsize___0 < 16L) {
#line 621
        DR_newsize___0 = 16L;
      }
#line 621
      size = (int )DR_newsize___0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 621
    if (DR_newsize___0) {
      {
#line 621
      tmp___4 = checking_realloc((void *)resp->headers, (unsigned long )DR_newsize___0 * sizeof(char const   *));
#line 621
      resp->headers = (char const   **)tmp___4;
      }
    }
#line 621
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 622
  *(resp->headers + count) = (char const   *)((void *)0);
#line 624
  return (resp);
}
}
#line 639 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static int resp_header_locate(struct response  const  *resp , char const   *name ,
                              int start , char const   **begptr , char const   **endptr ) 
{ 
  int i ;
  char const   **headers ;
  int name_len ;
  size_t tmp ;
  char const   *b ;
  char const   *e ;
  int tmp___0 ;

  {
#line 644
  headers = (char const   **)resp->headers;
#line 647
  if (! headers) {
#line 648
    return (-1);
  } else
#line 647
  if (! *(headers + 1)) {
#line 648
    return (-1);
  }
  {
#line 650
  tmp = strlen(name);
#line 650
  name_len = (int )tmp;
  }
#line 651
  if (start > 0) {
#line 652
    i = start;
  } else {
#line 654
    i = 1;
  }
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! *(headers + (i + 1))) {
#line 656
      goto while_break;
    }
#line 658
    b = *(headers + i);
#line 659
    e = *(headers + (i + 1));
#line 660
    if (e - b > (long )name_len) {
#line 660
      if ((int const   )*(b + name_len) == 58) {
        {
#line 660
        tmp___0 = strncasecmp(b, name, (size_t )name_len);
        }
#line 660
        if (0 == tmp___0) {
#line 664
          b += name_len + 1;
          {
#line 665
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 665
            if ((unsigned long )b < (unsigned long )e) {
#line 665
              if (! ((int const   )_sch_istable[(int const   )*b & 255] & 64)) {
#line 665
                goto while_break___0;
              }
            } else {
#line 665
              goto while_break___0;
            }
#line 666
            b ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 667
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 667
            if ((unsigned long )b < (unsigned long )e) {
#line 667
              if (! ((int const   )_sch_istable[(int const   )*(e + -1) & 255] & 64)) {
#line 667
                goto while_break___1;
              }
            } else {
#line 667
              goto while_break___1;
            }
#line 668
            e --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 669
          *begptr = b;
#line 670
          *endptr = e;
#line 671
          return (i);
        }
      }
    }
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  return (-1);
}
}
#line 684 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool resp_header_get(struct response  const  *resp , char const   *name ,
                             char const   **begptr , char const   **endptr ) 
{ 
  int pos ;
  int tmp ;

  {
  {
#line 688
  tmp = resp_header_locate(resp, name, 0, begptr, endptr);
#line 688
  pos = tmp;
  }
#line 689
  return ((_Bool )(pos != -1));
}
}
#line 700 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool resp_header_copy(struct response  const  *resp , char const   *name ,
                              char *buf___4 , int bufsize ) 
{ 
  char const   *b ;
  char const   *e ;
  _Bool tmp ;
  int len ;
  long tmp___0 ;

  {
  {
#line 705
  tmp = resp_header_get(resp, name, & b, & e);
  }
#line 705
  if (! tmp) {
#line 706
    return ((_Bool)0);
  }
#line 707
  if (bufsize) {
#line 709
    if (e - b > (long )(bufsize - 1)) {
#line 709
      tmp___0 = (long )(bufsize - 1);
    } else {
#line 709
      tmp___0 = e - b;
    }
    {
#line 709
    len = (int )tmp___0;
#line 710
    memcpy((void */* __restrict  */)buf___4, (void const   */* __restrict  */)b, (size_t )len);
#line 711
    *(buf___4 + len) = (char )'\000';
    }
  }
#line 713
  return ((_Bool)1);
}
}
#line 719 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *resp_header_strdup(struct response  const  *resp , char const   *name ) 
{ 
  char const   *b ;
  char const   *e ;
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 723
  tmp = resp_header_get(resp, name, & b, & e);
  }
#line 723
  if (! tmp) {
#line 724
    return ((char *)((void *)0));
  }
  {
#line 725
  tmp___0 = strdupdelim(b, e);
  }
#line 725
  return (tmp___0);
}
}
#line 736 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static int resp_status(struct response  const  *resp , char **message ) 
{ 
  int status ;
  char const   *p___0 ;
  char const   *end ;
  char *tmp ;
  int tmp___0 ;

  {
#line 742
  if (! resp->headers) {
#line 745
    if (message) {
      {
#line 746
      tmp = gettext("No headers, assuming HTTP/0.9");
#line 746
      *message = checking_strdup((char const   *)tmp);
      }
    }
#line 747
    return (200);
  }
#line 750
  p___0 = *(resp->headers + 0);
#line 751
  end = *(resp->headers + 1);
#line 753
  if (! end) {
#line 754
    return (-1);
  }
#line 757
  if (end - p___0 < 4L) {
#line 758
    return (-1);
  } else {
    {
#line 757
    tmp___0 = strncmp(p___0, "HTTP", (size_t )4);
    }
#line 757
    if (0 != tmp___0) {
#line 758
      return (-1);
    }
  }
#line 759
  p___0 += 4;
#line 763
  if ((unsigned long )p___0 < (unsigned long )end) {
#line 763
    if ((int const   )*p___0 == 47) {
#line 765
      p___0 ++;
      {
#line 766
      while (1) {
        while_continue: /* CIL Label */ ;
#line 766
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 766
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 766
            goto while_break;
          }
        } else {
#line 766
          goto while_break;
        }
#line 767
        p___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 768
      if ((unsigned long )p___0 < (unsigned long )end) {
#line 768
        if ((int const   )*p___0 == 46) {
#line 769
          p___0 ++;
        }
      }
      {
#line 770
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 770
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 770
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 770
            goto while_break___0;
          }
        } else {
#line 770
          goto while_break___0;
        }
#line 771
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 774
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 774
    if ((unsigned long )p___0 < (unsigned long )end) {
#line 774
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 774
        goto while_break___1;
      }
    } else {
#line 774
      goto while_break___1;
    }
#line 775
    p___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 776
  if (end - p___0 < 3L) {
#line 777
    return (-1);
  } else
#line 776
  if (! ((int const   )_sch_istable[(int const   )*(p___0 + 0) & 255] & 4)) {
#line 777
    return (-1);
  } else
#line 776
  if (! ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 4)) {
#line 777
    return (-1);
  } else
#line 776
  if (! ((int const   )_sch_istable[(int const   )*(p___0 + 2) & 255] & 4)) {
#line 777
    return (-1);
  }
#line 779
  status = (100 * (int )((int const   )*(p___0 + 0) - 48) + 10 * (int )((int const   )*(p___0 + 1) - 48)) + (int )((int const   )*(p___0 + 2) - 48);
#line 780
  p___0 += 3;
#line 782
  if (message) {
    {
#line 784
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 784
      if ((unsigned long )p___0 < (unsigned long )end) {
#line 784
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 784
          goto while_break___2;
        }
      } else {
#line 784
        goto while_break___2;
      }
#line 785
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 786
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 786
      if ((unsigned long )p___0 < (unsigned long )end) {
#line 786
        if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 786
          goto while_break___3;
        }
      } else {
#line 786
        goto while_break___3;
      }
#line 787
      end --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 788
    *message = strdupdelim(p___0, end);
    }
  }
#line 791
  return (status);
}
}
#line 796 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void resp_free(struct response *resp ) 
{ 


  {
#line 799
  if (! (! resp->headers)) {
    {
#line 799
    checking_free((void *)resp->headers);
    }
  }
  {
#line 800
  checking_free((void *)resp);
  }
#line 801
  return;
}
}
#line 809 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void print_response_line(char const   *prefix , char const   *b , char const   *e ) 
{ 
  char *copy ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 813
    BTA_beg = b;
#line 813
    BTA_len = (int )(e - BTA_beg);
#line 813
    BTA_dest = & copy;
#line 813
    tmp = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 813
    *BTA_dest = (char *)tmp;
#line 813
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 813
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 813
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 814
  tmp___0 = escnonprint((char const   *)copy);
#line 814
  logprintf((enum log_options )0, "%s%s\n", prefix, tmp___0);
  }
#line 815
  return;
}
}
#line 820 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void print_server_response(struct response  const  *resp , char const   *prefix ) 
{ 
  int i ;
  char const   *b ;
  char const   *e ;

  {
#line 824
  if (! resp->headers) {
#line 825
    return;
  }
#line 826
  i = 0;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! *(resp->headers + (i + 1))) {
#line 826
      goto while_break;
    }
#line 828
    b = *(resp->headers + i);
#line 829
    e = *(resp->headers + (i + 1));
#line 831
    if ((unsigned long )b < (unsigned long )e) {
#line 831
      if ((int const   )*(e + -1) == 10) {
#line 832
        e --;
      }
    }
#line 833
    if ((unsigned long )b < (unsigned long )e) {
#line 833
      if ((int const   )*(e + -1) == 13) {
#line 834
        e --;
      }
    }
    {
#line 835
    print_response_line(prefix, b, e);
#line 826
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  return;
}
}
#line 841 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool parse_content_range(char const   *hdr , wgint *first_byte_ptr , wgint *last_byte_ptr ,
                                 wgint *entity_length_ptr ) 
{ 
  wgint num ;
  int tmp ;

  {
  {
#line 850
  tmp = strncasecmp(hdr, "bytes", (size_t )5);
  }
#line 850
  if (0 == tmp) {
#line 852
    hdr += 5;
#line 855
    if ((int const   )*hdr == 58) {
#line 856
      hdr ++;
    }
    {
#line 857
    while (1) {
      while_continue: /* CIL Label */ ;
#line 857
      if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 64)) {
#line 857
        goto while_break;
      }
#line 858
      hdr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 859
    if (! *hdr) {
#line 860
      return ((_Bool)0);
    }
  }
#line 862
  if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 863
    return ((_Bool)0);
  }
#line 864
  num = (wgint )0;
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 864
    if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 864
      goto while_break___0;
    }
#line 865
    num = 10L * num + (wgint )((int const   )*hdr - 48);
#line 864
    hdr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 866
  if ((int const   )*hdr != 45) {
#line 867
    return ((_Bool)0);
  } else
#line 866
  if (! ((int const   )_sch_istable[(int const   )*(hdr + 1) & 255] & 4)) {
#line 867
    return ((_Bool)0);
  }
#line 868
  *first_byte_ptr = num;
#line 869
  hdr ++;
#line 870
  num = (wgint )0;
  {
#line 870
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 870
    if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 870
      goto while_break___1;
    }
#line 871
    num = 10L * num + (wgint )((int const   )*hdr - 48);
#line 870
    hdr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 872
  if ((int const   )*hdr != 47) {
#line 873
    return ((_Bool)0);
  } else
#line 872
  if (! ((int const   )_sch_istable[(int const   )*(hdr + 1) & 255] & 4)) {
#line 873
    return ((_Bool)0);
  }
#line 874
  *last_byte_ptr = num;
#line 875
  hdr ++;
#line 876
  if ((int const   )*hdr == 42) {
#line 877
    num = (wgint )-1;
  } else {
#line 879
    num = (wgint )0;
    {
#line 879
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 879
      if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 879
        goto while_break___2;
      }
#line 880
      num = 10L * num + (wgint )((int const   )*hdr - 48);
#line 879
      hdr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 881
  *entity_length_ptr = num;
#line 882
  return ((_Bool)1);
}
}
#line 894 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool skip_short_body(int fd , wgint contlen ) 
{ 
  char dlbuf___0[513] ;
  char *tmp___0 ;
  long tmp___1 ;
  int ret ;
  wgint tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 902
  dlbuf___0[512] = (char )'\000';
#line 906
  if (! (contlen != -1L)) {
    {
#line 906
    __assert_fail("contlen != -1", "/home/khheo/project/benchmark/wget-1.11.4/src/http.c",
                  906U, "skip_short_body");
    }
  }
#line 910
  if (contlen > 4096L) {
#line 911
    return ((_Bool)0);
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 913
    tmp___1 = __builtin_expect((long )opt.debug, 0L);
    }
#line 913
    if (tmp___1) {
      {
#line 913
      tmp___0 = number_to_static_string(contlen);
#line 913
      debug_logprintf("Skipping %s bytes of body: [", tmp___0);
      }
    }
#line 913
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 915
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 915
    if (! (contlen > 0L)) {
#line 915
      goto while_break___0;
    }
#line 917
    if (contlen > 512L) {
#line 917
      tmp___2 = (wgint )512;
    } else {
#line 917
      tmp___2 = contlen;
    }
    {
#line 917
    tmp___3 = fd_read(fd, dlbuf___0, (int )tmp___2, (double )-1);
#line 917
    ret = tmp___3;
    }
#line 918
    if (ret <= 0) {
      {
#line 922
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 922
        tmp___6 = __builtin_expect((long )opt.debug, 0L);
        }
#line 922
        if (tmp___6) {
#line 922
          if (ret < 0) {
            {
#line 922
            tmp___4 = fd_errstr(fd);
#line 922
            tmp___5 = tmp___4;
            }
          } else {
#line 922
            tmp___5 = "EOF received";
          }
          {
#line 922
          debug_logprintf("] aborting (%s).\n", tmp___5);
          }
        }
#line 922
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 924
      return ((_Bool)0);
    }
#line 926
    contlen -= (wgint )ret;
    {
#line 929
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 929
      tmp___7 = __builtin_expect((long )opt.debug, 0L);
      }
#line 929
      if (tmp___7) {
        {
#line 929
        debug_logprintf("%.*s", ret, dlbuf___0);
        }
      }
#line 929
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 932
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 932
    tmp___8 = __builtin_expect((long )opt.debug, 0L);
    }
#line 932
    if (tmp___8) {
      {
#line 932
      debug_logprintf("] done.\n");
      }
    }
#line 932
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 933
  return ((_Bool)1);
}
}
#line 948 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
_Bool extract_param(char const   **source , param_token *name , param_token *value ,
                    char separator ) 
{ 
  char const   *p___0 ;
  char const   *tmp ;

  {
#line 952
  p___0 = *source;
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 954
      goto while_break;
    }
#line 954
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 955
  if (! *p___0) {
#line 957
    *source = p___0;
#line 958
    return ((_Bool)0);
  }
#line 962
  name->b = p___0;
  {
#line 963
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 963
    if (*p___0) {
#line 963
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 963
        if ((int const   )*p___0 != 61) {
#line 963
          if (! ((int const   )*p___0 != (int const   )separator)) {
#line 963
            goto while_break___0;
          }
        } else {
#line 963
          goto while_break___0;
        }
      } else {
#line 963
        goto while_break___0;
      }
    } else {
#line 963
      goto while_break___0;
    }
#line 963
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 964
  name->e = p___0;
#line 965
  if ((unsigned long )name->b == (unsigned long )name->e) {
#line 966
    return ((_Bool)0);
  }
  {
#line 967
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 967
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 967
      goto while_break___1;
    }
#line 967
    p___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 968
  if ((int const   )*p___0 == (int const   )separator) {
#line 968
    goto _L;
  } else
#line 968
  if (! *p___0) {
    _L: /* CIL Label */ 
    {
#line 970
    memset((void *)value, '\000', sizeof(*value));
    }
#line 971
    if ((int const   )*p___0 == (int const   )separator) {
#line 971
      p___0 ++;
    }
#line 972
    *source = p___0;
#line 973
    return ((_Bool)1);
  }
#line 975
  if ((int const   )*p___0 != 61) {
#line 976
    return ((_Bool)0);
  }
#line 979
  p___0 ++;
  {
#line 980
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 980
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 980
      goto while_break___2;
    }
#line 980
    p___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 981
  if ((int const   )*p___0 == 34) {
#line 983
    p___0 ++;
#line 983
    value->b = p___0;
    {
#line 984
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 984
      if (*p___0) {
#line 984
        if (! ((int const   )*p___0 != 34)) {
#line 984
          goto while_break___3;
        }
      } else {
#line 984
        goto while_break___3;
      }
#line 984
      p___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 985
    if (! *p___0) {
#line 986
      return ((_Bool)0);
    }
#line 987
    tmp = p___0;
#line 987
    p___0 ++;
#line 987
    value->e = tmp;
    {
#line 989
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 989
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 989
        goto while_break___4;
      }
#line 989
      p___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 990
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 990
      if (*p___0) {
#line 990
        if (! ((int const   )*p___0 != (int const   )separator)) {
#line 990
          goto while_break___5;
        }
      } else {
#line 990
        goto while_break___5;
      }
#line 990
      p___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 991
    if ((int const   )*p___0 == (int const   )separator) {
#line 992
      p___0 ++;
    } else
#line 993
    if (*p___0) {
#line 995
      return ((_Bool)0);
    }
  } else {
#line 999
    value->b = p___0;
    {
#line 1000
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1000
      if (*p___0) {
#line 1000
        if (! ((int const   )*p___0 != (int const   )separator)) {
#line 1000
          goto while_break___6;
        }
      } else {
#line 1000
        goto while_break___6;
      }
#line 1000
      p___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1001
    value->e = p___0;
    {
#line 1002
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1002
      if ((unsigned long )value->e != (unsigned long )value->b) {
#line 1002
        if (! ((int const   )_sch_istable[(int const   )*(value->e + -1) & 255] & 64)) {
#line 1002
          goto while_break___7;
        }
      } else {
#line 1002
        goto while_break___7;
      }
#line 1003
      (value->e) --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1004
    if ((int const   )*p___0 == (int const   )separator) {
#line 1004
      p___0 ++;
    }
  }
#line 1006
  *source = p___0;
#line 1007
  return ((_Bool)1);
}
}
#line 1030 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool parse_content_disposition(char const   *hdr , char **filename ) 
{ 
  param_token name ;
  param_token value ;
  char const   *last_slash ;
  void *tmp ;
  char const   *last_bs ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int prefix_length ;
  size_t tmp___3 ;
  _Bool add_slash ;
  int total_length ;
  void *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1034
    tmp___6 = extract_param(& hdr, & name, & value, (char )';');
    }
#line 1034
    if (! tmp___6) {
#line 1034
      goto while_break;
    }
#line 1035
    if ((unsigned long )(name.e - name.b) == sizeof("filename") - 1UL) {
      {
#line 1035
      tmp___5 = strncasecmp(name.b, "filename", sizeof("filename") - 1UL);
      }
#line 1035
      if (! tmp___5) {
#line 1035
        if ((unsigned long )value.b != (unsigned long )((void *)0)) {
          {
#line 1038
          tmp = memrchr((void const   *)value.b, '/', (size_t )(value.e - value.b));
#line 1038
          last_slash = (char const   *)tmp;
#line 1039
          tmp___0 = memrchr((void const   *)value.b, '\\', (size_t )(value.e - value.b));
#line 1039
          last_bs = (char const   *)tmp___0;
          }
#line 1040
          if (last_slash) {
#line 1040
            if (last_bs) {
#line 1041
              if ((unsigned long )last_slash > (unsigned long )last_bs) {
#line 1041
                tmp___1 = last_slash;
              } else {
#line 1041
                tmp___1 = last_bs;
              }
#line 1041
              value.b = tmp___1 + 1;
            } else {
#line 1040
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1042
          if (last_slash) {
#line 1042
            goto _L;
          } else
#line 1042
          if (last_bs) {
            _L: /* CIL Label */ 
#line 1043
            if (last_slash) {
#line 1043
              tmp___2 = last_slash;
            } else {
#line 1043
              tmp___2 = last_bs;
            }
#line 1043
            value.b = tmp___2 + 1;
          }
#line 1044
          if ((unsigned long )value.b == (unsigned long )value.e) {
#line 1045
            goto while_continue;
          }
#line 1047
          if (opt.dir_prefix) {
            {
#line 1049
            tmp___3 = strlen((char const   *)opt.dir_prefix);
#line 1049
            prefix_length = (int )tmp___3;
#line 1050
            add_slash = (_Bool )((int )*(opt.dir_prefix + (prefix_length - 1)) != 47);
            }
#line 1053
            if (add_slash) {
#line 1054
              prefix_length ++;
            }
            {
#line 1055
            total_length = (int )((long )prefix_length + (value.e - value.b));
#line 1056
            tmp___4 = checking_malloc((size_t )(total_length + 1));
#line 1056
            *filename = (char *)tmp___4;
#line 1057
            strcpy((char */* __restrict  */)*filename, (char const   */* __restrict  */)opt.dir_prefix);
            }
#line 1058
            if (add_slash) {
#line 1059
              *(*filename + (prefix_length - 1)) = (char )'/';
            }
            {
#line 1060
            memcpy((void */* __restrict  */)(*filename + prefix_length), (void const   */* __restrict  */)value.b,
                   (size_t )(value.e - value.b));
#line 1061
            *(*filename + total_length) = (char )'\000';
            }
          } else {
            {
#line 1064
            *filename = strdupdelim(value.b, value.e);
            }
          }
#line 1065
          return ((_Bool)1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  return ((_Bool)0);
}
}
#line 1077 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool pconn_active  ;
#line 1079 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct __anonstruct_pconn_951291558 pconn  ;
#line 1106 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void invalidate_persistent(void) 
{ 
  long tmp ;

  {
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1109
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 1109
    if (tmp) {
      {
#line 1109
      debug_logprintf("Disabling further reuse of socket %d.\n", pconn.socket);
      }
    }
#line 1109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1110
  pconn_active = (_Bool)0;
#line 1111
  fd_close(pconn.socket);
#line 1112
  checking_free((void *)pconn.host);
#line 1113
  memset((void *)(& pconn), '\000', sizeof(pconn));
  }
#line 1114
  return;
}
}
#line 1124 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void register_persistent(char const   *host , int port , int fd , _Bool ssl ) 
{ 
  long tmp ;

  {
#line 1127
  if (pconn_active) {
#line 1129
    if (pconn.socket == fd) {
#line 1132
      return;
    } else {
      {
#line 1141
      invalidate_persistent();
      }
    }
  }
  {
#line 1145
  pconn_active = (_Bool)1;
#line 1146
  pconn.socket = fd;
#line 1147
  pconn.host = checking_strdup(host);
#line 1148
  pconn.port = port;
#line 1149
  pconn.ssl = ssl;
#line 1150
  pconn.authorized = (_Bool)0;
  }
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1152
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 1152
    if (tmp) {
      {
#line 1152
      debug_logprintf("Registered socket %d for persistent reuse.\n", fd);
      }
    }
#line 1152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  return;
}
}
#line 1158 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool persistent_available_p(char const   *host , int port , _Bool ssl , _Bool *host_lookup_failed ) 
{ 
  _Bool found ;
  ip_address ip___0 ;
  struct address_list *al ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1163
  if (! pconn_active) {
#line 1164
    return ((_Bool)0);
  }
#line 1169
  if ((int )ssl != (int )pconn.ssl) {
#line 1170
    return ((_Bool)0);
  }
#line 1173
  if (port != pconn.port) {
#line 1174
    return ((_Bool)0);
  }
  {
#line 1178
  tmp___0 = strcasecmp(host, (char const   *)pconn.host);
  }
#line 1178
  if (0 != tmp___0) {
#line 1192
    if (ssl) {
#line 1196
      return ((_Bool)0);
    }
    {
#line 1202
    tmp = socket_ip_address(pconn.socket, & ip___0, 1);
    }
#line 1202
    if (! tmp) {
      {
#line 1206
      invalidate_persistent();
      }
#line 1207
      return ((_Bool)0);
    }
    {
#line 1209
    al = lookup_host(host, 0);
    }
#line 1210
    if (! al) {
#line 1212
      *host_lookup_failed = (_Bool)1;
#line 1213
      return ((_Bool)0);
    }
    {
#line 1216
    found = address_list_contains((struct address_list  const  *)al, (ip_address const   *)(& ip___0));
#line 1217
    address_list_release(al);
    }
#line 1219
    if (! found) {
#line 1220
      return ((_Bool)0);
    }
  }
  {
#line 1240
  tmp___1 = test_socket_open(pconn.socket);
  }
#line 1240
  if (! tmp___1) {
    {
#line 1245
    invalidate_persistent();
    }
#line 1246
    return ((_Bool)0);
  }
#line 1249
  return ((_Bool)1);
}
}
#line 1316 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void free_hstat(struct http_stat *hs ) 
{ 


  {
#line 1319
  if (! (! hs->newloc)) {
    {
#line 1319
    checking_free((void *)hs->newloc);
    }
  }
#line 1320
  if (! (! hs->remote_time)) {
    {
#line 1320
    checking_free((void *)hs->remote_time);
    }
  }
#line 1321
  if (! (! hs->error)) {
    {
#line 1321
    checking_free((void *)hs->error);
    }
  }
#line 1322
  if (! (! hs->rderrmsg)) {
    {
#line 1322
    checking_free((void *)hs->rderrmsg);
    }
  }
#line 1323
  if (! (! hs->local_file)) {
    {
#line 1323
    checking_free((void *)hs->local_file);
    }
  }
#line 1324
  if (! (! hs->orig_file_name)) {
    {
#line 1324
    checking_free((void *)hs->orig_file_name);
    }
  }
#line 1327
  hs->newloc = (char *)((void *)0);
#line 1328
  hs->remote_time = (char *)((void *)0);
#line 1329
  hs->error = (char *)((void *)0);
#line 1330
  return;
}
}
#line 1512
static uerr_t gethttp(struct url *u , struct http_stat *hs , int *dt , struct url *proxy ) ;
#line 1512 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char const   *hfmt[2][2]  = { {        "%s",        "[%s]"}, 
   {        "%s:%d",        "[%s]:%d"}};
#line 1361 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static uerr_t gethttp(struct url *u , struct http_stat *hs , int *dt , struct url *proxy ) 
{ 
  struct request *req ;
  char *type ;
  char *user ;
  char *passwd ;
  char *proxyauth ;
  int statcode ;
  int write_error ;
  wgint contlen ;
  wgint contrange ;
  struct url *conn ;
  FILE *fp ;
  int sock ;
  int flags ;
  _Bool auth_finished ;
  _Bool basic_auth_finished ;
  _Bool ntlm_seen ;
  _Bool using_ssl ;
  _Bool head_only ;
  char *head ;
  struct response *resp ;
  char hdrval[256] ;
  char *message ;
  _Bool keep_alive ;
  _Bool inhibit_keep_alive ;
  int tmp ;
  wgint post_data_size ;
  _Bool host_lookup_failed ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *meth_arg ;
  char const   *meth ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int add_port ;
  int tmp___7 ;
  int add_squares ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int i ;
  char *proxy_user ;
  char *proxy_passwd ;
  struct url *relevant ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  long tmp___19 ;
  char *tmp___20 ;
  _Bool tmp___21 ;
  int tmp___24 ;
  int *tmp___25 ;
  _Bool tmp___26 ;
  struct request *connreq ;
  struct request *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  long tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  _Bool tmp___36 ;
  _Bool tmp___37 ;
  long tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___42 ;
  char *tmp___43 ;
  int *tmp___44 ;
  long tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  _Bool tmp___48 ;
  _Bool tmp___49 ;
  char *tmp___50 ;
  _Bool tmp___51 ;
  char *unique ;
  char *tmp___52 ;
  _Bool tmp___53 ;
  size_t filename_len ;
  size_t tmp___54 ;
  char *filename_plus_orig_suffix ;
  void *tmp___55 ;
  _Bool local_dot_orig_file_exists ;
  char *local_filename ;
  struct stat st ;
  int tmp___56 ;
  int tmp___57 ;
  wgint parsed ;
  int *tmp___58 ;
  int *tmp___59 ;
  _Bool tmp___60 ;
  int tmp___61 ;
  _Bool tmp___62 ;
  _Bool tmp___63 ;
  _Bool tmp___64 ;
  int wapos ;
  char const   *wabeg ;
  char const   *waend ;
  char *www_authenticate ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___65 ;
  _Bool tmp___66 ;
  char *tmp___67 ;
  char *pth ;
  char const   *tmp___68 ;
  char *tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  int scpos ;
  char const   *scbeg ;
  char const   *scend ;
  char *set_cookie ;
  char const   *BTA_beg___0 ;
  int BTA_len___0 ;
  char **BTA_dest___0 ;
  void *tmp___79 ;
  wgint first_byte_pos ;
  wgint last_byte_pos ;
  wgint entity_length ;
  _Bool tmp___80 ;
  _Bool tmp___81 ;
  char *tmp___82 ;
  char const   *tmp___83 ;
  char const   *tmp___84 ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  char *tmp___87 ;
  _Bool tmp___88 ;
  size_t tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  int tmp___92 ;
  char *last_period_in_local_filename ;
  char *tmp___93 ;
  int local_filename_len ;
  size_t tmp___94 ;
  void *tmp___95 ;
  int ext_num ;
  int tmp___96 ;
  _Bool tmp___97 ;
  _Bool tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char const   *tmp___113 ;
  _Bool tmp___114 ;
  char *tmp___115 ;
  int *tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  char const   *tmp___119 ;
  char *tmp___120 ;
  size_t tmp___121 ;
  wgint tmp___122 ;
  char const   *tmp___123 ;

  {
#line 1375
  sock = -1;
#line 1380
  auth_finished = (_Bool)0;
#line 1385
  basic_auth_finished = (_Bool)0;
#line 1388
  ntlm_seen = (_Bool)0;
#line 1391
  using_ssl = (_Bool)0;
#line 1395
  head_only = (_Bool )(! (! (*dt & 4)));
#line 1413
  if (! opt.http_keep_alive) {
#line 1413
    tmp = 1;
  } else
#line 1413
  if (opt.ignore_length) {
#line 1413
    tmp = 1;
  } else
#line 1413
  if ((unsigned long )proxy != (unsigned long )((void *)0)) {
#line 1413
    tmp = 1;
  } else {
#line 1413
    tmp = 0;
  }
#line 1413
  inhibit_keep_alive = (_Bool )tmp;
#line 1417
  post_data_size = (wgint )0;
#line 1419
  host_lookup_failed = (_Bool)0;
#line 1422
  if ((unsigned int )u->scheme == 1U) {
    {
#line 1426
    tmp___1 = ssl_init();
    }
#line 1426
    if (! tmp___1) {
      {
#line 1428
      scheme_disable((enum url_scheme )1);
#line 1429
      tmp___0 = gettext("Disabling SSL due to encountered errors.\n");
#line 1429
      logprintf((enum log_options )1, (char const   *)tmp___0);
      }
#line 1431
      return ((uerr_t )53);
    }
  }
  {
#line 1437
  hs->len = (wgint )0;
#line 1438
  hs->contlen = (wgint )-1;
#line 1439
  hs->res = -1;
#line 1440
  hs->rderrmsg = (char *)((void *)0);
#line 1441
  hs->newloc = (char *)((void *)0);
#line 1442
  hs->remote_time = (char *)((void *)0);
#line 1443
  hs->error = (char *)((void *)0);
#line 1445
  conn = u;
#line 1449
  req = request_new();
#line 1452
  meth = "GET";
  }
#line 1453
  if (head_only) {
#line 1454
    meth = "HEAD";
  } else
#line 1455
  if (opt.post_file_name) {
#line 1456
    meth = "POST";
  } else
#line 1455
  if (opt.post_data) {
#line 1456
    meth = "POST";
  }
#line 1460
  if (proxy) {
#line 1460
    if ((unsigned int )u->scheme != 1U) {
      {
#line 1468
      meth_arg = checking_strdup((char const   *)u->url);
      }
    } else {
      {
#line 1470
      meth_arg = url_full_path((struct url  const  *)u);
      }
    }
  } else {
    {
#line 1470
    meth_arg = url_full_path((struct url  const  *)u);
    }
  }
  {
#line 1471
  request_set_method(req, meth, meth_arg);
#line 1474
  request_set_header(req, (char *)"Referer", (char *)hs->referer, (enum rp )0);
  }
#line 1475
  if (*dt & 8) {
    {
#line 1476
    request_set_header(req, (char *)"Pragma", (char *)"no-cache", (enum rp )0);
    }
  }
#line 1477
  if (hs->restval) {
    {
#line 1478
    tmp___2 = number_to_static_string(hs->restval);
#line 1478
    tmp___3 = aprintf("bytes=%s-", tmp___2);
#line 1478
    request_set_header(req, (char *)"Range", tmp___3, (enum rp )2);
    }
  }
  {
#line 1482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1482
    if (! opt.useragent) {
      {
#line 1482
      tmp___4 = aprintf("Wget/%s", version_string);
#line 1482
      request_set_header(req, (char *)"User-Agent", tmp___4, (enum rp )2);
      }
    } else
#line 1482
    if (*(opt.useragent)) {
      {
#line 1482
      request_set_header(req, (char *)"User-Agent", opt.useragent, (enum rp )0);
      }
    }
#line 1482
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1483
  request_set_header(req, (char *)"Accept", (char *)"*/*", (enum rp )0);
#line 1486
  user = u->user;
#line 1487
  passwd = u->passwd;
#line 1488
  search_netrc((char const   *)u->host, (char const   **)(& user), (char const   **)(& passwd),
               0);
  }
#line 1489
  if (user) {
#line 1489
    user = user;
  } else {
#line 1489
    if (opt.http_user) {
#line 1489
      tmp___5 = opt.http_user;
    } else {
#line 1489
      tmp___5 = opt.user;
    }
#line 1489
    user = tmp___5;
  }
#line 1490
  if (passwd) {
#line 1490
    passwd = passwd;
  } else {
#line 1490
    if (opt.http_passwd) {
#line 1490
      tmp___6 = opt.http_passwd;
    } else {
#line 1490
      tmp___6 = opt.passwd;
    }
#line 1490
    passwd = tmp___6;
  }
#line 1492
  if (user) {
#line 1492
    if (passwd) {
#line 1492
      if (! u->user) {
        {
#line 1498
        basic_auth_finished = maybe_send_basic_creds((char const   *)u->host, (char const   *)user,
                                                     (char const   *)passwd, req);
        }
      }
    }
  }
  {
#line 1515
  tmp___7 = scheme_default_port(u->scheme);
#line 1515
  add_port = u->port != tmp___7;
#line 1516
  tmp___8 = strchr((char const   *)u->host, ':');
#line 1516
  add_squares = (unsigned long )tmp___8 != (unsigned long )((void *)0);
#line 1517
  tmp___9 = aprintf(hfmt[add_port][add_squares], u->host, u->port);
#line 1517
  request_set_header(req, (char *)"Host", tmp___9, (enum rp )2);
  }
#line 1522
  if (! inhibit_keep_alive) {
    {
#line 1523
    request_set_header(req, (char *)"Connection", (char *)"Keep-Alive", (enum rp )0);
    }
  }
#line 1525
  if (opt.cookies) {
    {
#line 1526
    tmp___10 = cookie_header(wget_cookie_jar, (char const   *)u->host, u->port, (char const   *)u->path,
                             (_Bool )((unsigned int )u->scheme == 1U));
#line 1526
    request_set_header(req, (char *)"Cookie", tmp___10, (enum rp )2);
    }
  }
#line 1537
  if (opt.post_data) {
#line 1537
    goto _L;
  } else
#line 1537
  if (opt.post_file_name) {
    _L: /* CIL Label */ 
    {
#line 1539
    request_set_header(req, (char *)"Content-Type", (char *)"application/x-www-form-urlencoded",
                       (enum rp )0);
    }
#line 1541
    if (opt.post_data) {
      {
#line 1542
      tmp___11 = strlen((char const   *)opt.post_data);
#line 1542
      post_data_size = (wgint )tmp___11;
      }
    } else {
      {
#line 1545
      post_data_size = file_size((char const   *)opt.post_file_name);
      }
#line 1546
      if (post_data_size == -1L) {
        {
#line 1548
        tmp___12 = __errno_location();
#line 1548
        tmp___13 = strerror(*tmp___12);
#line 1548
        tmp___14 = gettext("POST data file `%s\' missing: %s\n");
#line 1548
        logprintf((enum log_options )1, (char const   *)tmp___14, opt.post_file_name,
                  tmp___13);
#line 1550
        post_data_size = (wgint )0;
        }
      }
    }
    {
#line 1553
    tmp___15 = number_to_static_string(post_data_size);
#line 1553
    tmp___16 = checking_strdup((char const   *)tmp___15);
#line 1553
    request_set_header(req, (char *)"Content-Length", tmp___16, (enum rp )2);
    }
  }
#line 1559
  if (opt.user_headers) {
#line 1562
    i = 0;
    {
#line 1562
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1562
      if (! *(opt.user_headers + i)) {
#line 1562
        goto while_break___0;
      }
      {
#line 1563
      request_set_user_header(req, (char const   *)*(opt.user_headers + i));
#line 1562
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  retry_with_auth: 
#line 1571
  proxyauth = (char *)((void *)0);
#line 1572
  if (proxy) {
#line 1580
    if (opt.proxy_user) {
#line 1580
      if (opt.proxy_passwd) {
#line 1582
        proxy_user = opt.proxy_user;
#line 1583
        proxy_passwd = opt.proxy_passwd;
      } else {
#line 1587
        proxy_user = proxy->user;
#line 1588
        proxy_passwd = proxy->passwd;
      }
    } else {
#line 1587
      proxy_user = proxy->user;
#line 1588
      proxy_passwd = proxy->passwd;
    }
#line 1592
    if (proxy_user) {
#line 1592
      if (proxy_passwd) {
        {
#line 1593
        proxyauth = basic_authentication_encode((char const   *)proxy_user, (char const   *)proxy_passwd);
        }
      }
    }
#line 1597
    conn = proxy;
#line 1601
    if ((unsigned int )u->scheme != 1U) {
      {
#line 1603
      request_set_header(req, (char *)"Proxy-Authorization", proxyauth, (enum rp )2);
      }
    }
  }
#line 1606
  keep_alive = (_Bool)0;
#line 1610
  if (! inhibit_keep_alive) {
#line 1616
    relevant = conn;
#line 1618
    if ((unsigned int )u->scheme == 1U) {
#line 1619
      relevant = u;
    }
    {
#line 1622
    tmp___21 = persistent_available_p((char const   *)relevant->host, relevant->port,
                                      (_Bool )((unsigned int )relevant->scheme == 1U),
                                      & host_lookup_failed);
    }
#line 1622
    if (tmp___21) {
      {
#line 1630
      sock = pconn.socket;
#line 1631
      using_ssl = pconn.ssl;
#line 1632
      tmp___17 = escnonprint((char const   *)pconn.host);
#line 1632
      tmp___18 = gettext("Reusing existing connection to %s:%d.\n");
#line 1632
      logprintf((enum log_options )0, (char const   *)tmp___18, tmp___17, pconn.port);
      }
      {
#line 1634
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1634
        tmp___19 = __builtin_expect((long )opt.debug, 0L);
        }
#line 1634
        if (tmp___19) {
          {
#line 1634
          debug_logprintf("Reusing fd %d.\n", sock);
          }
        }
#line 1634
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1635
      if (pconn.authorized) {
        {
#line 1639
        request_remove_header(req, (char *)"Authorization");
        }
      }
    } else
#line 1641
    if (host_lookup_failed) {
      {
#line 1643
      request_free(req);
#line 1644
      tmp___20 = gettext("%s: unable to resolve host address `%s\'\n");
#line 1644
      logprintf((enum log_options )1, (char const   *)tmp___20, program_name, relevant->host);
      }
#line 1647
      return ((uerr_t )1);
    }
  }
#line 1651
  if (sock < 0) {
    {
#line 1653
    sock = connect_to_host((char const   *)conn->host, conn->port);
    }
#line 1654
    if (sock == -100) {
      {
#line 1656
      request_free(req);
      }
#line 1657
      return ((uerr_t )1);
    } else
#line 1659
    if (sock < 0) {
      {
#line 1661
      request_free(req);
#line 1662
      tmp___25 = __errno_location();
#line 1662
      tmp___26 = retryable_socket_connect_error(*tmp___25);
      }
#line 1662
      if (tmp___26) {
#line 1662
        tmp___24 = 3;
      } else {
#line 1662
        tmp___24 = 5;
      }
#line 1662
      return ((uerr_t )tmp___24);
    }
#line 1667
    if (proxy) {
#line 1667
      if ((unsigned int )u->scheme == 1U) {
        {
#line 1671
        tmp___27 = request_new();
#line 1671
        connreq = tmp___27;
#line 1672
        tmp___28 = aprintf("%s:%d", u->host, u->port);
#line 1672
        request_set_method(connreq, "CONNECT", tmp___28);
        }
        {
#line 1674
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1674
          if (! opt.useragent) {
            {
#line 1674
            tmp___29 = aprintf("Wget/%s", version_string);
#line 1674
            request_set_header(connreq, (char *)"User-Agent", tmp___29, (enum rp )2);
            }
          } else
#line 1674
          if (*(opt.useragent)) {
            {
#line 1674
            request_set_header(connreq, (char *)"User-Agent", opt.useragent, (enum rp )0);
            }
          }
#line 1674
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1675
        if (proxyauth) {
          {
#line 1677
          request_set_header(connreq, (char *)"Proxy-Authorization", proxyauth, (enum rp )2);
#line 1682
          proxyauth = (char *)((void *)0);
          }
        }
        {
#line 1689
        write_error = request_send((struct request  const  *)connreq, sock);
#line 1690
        request_free(connreq);
        }
#line 1691
        if (write_error < 0) {
          {
#line 1693
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1693
            if (pconn_active) {
#line 1693
              if (sock == pconn.socket) {
                {
#line 1693
                invalidate_persistent();
                }
              } else {
                {
#line 1693
                fd_close(sock);
                }
              }
            } else {
              {
#line 1693
              fd_close(sock);
              }
            }
#line 1693
            sock = -1;
#line 1693
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1694
          return ((uerr_t )52);
        }
        {
#line 1697
        head = read_http_response_head(sock);
        }
#line 1698
        if (! head) {
          {
#line 1700
          tmp___30 = fd_errstr(sock);
#line 1700
          tmp___31 = gettext("Failed reading proxy response: %s\n");
#line 1700
          logprintf((enum log_options )0, (char const   *)tmp___31, tmp___30);
          }
          {
#line 1702
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1702
            if (pconn_active) {
#line 1702
              if (sock == pconn.socket) {
                {
#line 1702
                invalidate_persistent();
                }
              } else {
                {
#line 1702
                fd_close(sock);
                }
              }
            } else {
              {
#line 1702
              fd_close(sock);
              }
            }
#line 1702
            sock = -1;
#line 1702
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1703
          return ((uerr_t )30);
        }
#line 1705
        message = (char *)((void *)0);
#line 1706
        if (! *head) {
          {
#line 1708
          checking_free((void *)head);
          }
#line 1709
          goto failed_tunnel;
        }
        {
#line 1711
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1711
          tmp___32 = __builtin_expect((long )opt.debug, 0L);
          }
#line 1711
          if (tmp___32) {
            {
#line 1711
            debug_logprintf("proxy responded with: [%s]\n", head);
            }
          }
#line 1711
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1713
        resp = resp_new((char const   *)head);
#line 1714
        statcode = resp_status((struct response  const  *)resp, & message);
#line 1715
        resp_free(resp);
#line 1716
        checking_free((void *)head);
        }
#line 1717
        if (statcode != 200) {
          failed_tunnel: 
#line 1720
          if (message) {
            {
#line 1720
            tmp___33 = escnonprint((char const   *)message);
#line 1720
            tmp___34 = tmp___33;
            }
          } else {
#line 1720
            tmp___34 = "?";
          }
          {
#line 1720
          tmp___35 = gettext("Proxy tunneling failed: %s");
#line 1720
          logprintf((enum log_options )1, (char const   *)tmp___35, tmp___34);
          }
#line 1722
          if (! (! message)) {
            {
#line 1722
            checking_free((void *)message);
            }
          }
#line 1723
          return ((uerr_t )4);
        }
#line 1725
        if (! (! message)) {
          {
#line 1725
          checking_free((void *)message);
          }
        }
#line 1730
        conn = u;
      }
    }
#line 1733
    if ((unsigned int )conn->scheme == 1U) {
      {
#line 1735
      tmp___36 = ssl_connect(sock);
      }
#line 1735
      if (tmp___36) {
        {
#line 1735
        tmp___37 = ssl_check_certificate(sock, (char const   *)u->host);
        }
#line 1735
        if (! tmp___37) {
          {
#line 1737
          fd_close(sock);
          }
#line 1738
          return ((uerr_t )4);
        }
      } else {
        {
#line 1737
        fd_close(sock);
        }
#line 1738
        return ((uerr_t )4);
      }
#line 1740
      using_ssl = (_Bool)1;
    }
  }
  {
#line 1746
  write_error = request_send((struct request  const  *)req, sock);
  }
#line 1748
  if (write_error >= 0) {
#line 1750
    if (opt.post_data) {
      {
#line 1752
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1752
        tmp___38 = __builtin_expect((long )opt.debug, 0L);
        }
#line 1752
        if (tmp___38) {
          {
#line 1752
          debug_logprintf("[POST data: %s]\n", opt.post_data);
          }
        }
#line 1752
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1753
      write_error = fd_write(sock, opt.post_data, (int )post_data_size, (double )-1);
      }
    } else
#line 1755
    if (opt.post_file_name) {
#line 1755
      if (post_data_size != 0L) {
        {
#line 1756
        write_error = post_file(sock, (char const   *)opt.post_file_name, post_data_size);
        }
      }
    }
  }
#line 1759
  if (write_error < 0) {
    {
#line 1761
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1761
      if (pconn_active) {
#line 1761
        if (sock == pconn.socket) {
          {
#line 1761
          invalidate_persistent();
          }
        } else {
          {
#line 1761
          fd_close(sock);
          }
        }
      } else {
        {
#line 1761
        fd_close(sock);
        }
      }
#line 1761
      sock = -1;
#line 1761
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1762
    request_free(req);
    }
#line 1763
    return ((uerr_t )52);
  }
#line 1765
  if (proxy) {
#line 1765
    tmp___39 = "Proxy";
  } else {
#line 1765
    tmp___39 = "HTTP";
  }
  {
#line 1765
  tmp___40 = gettext("%s request sent, awaiting response... ");
#line 1765
  logprintf((enum log_options )0, (char const   *)tmp___40, tmp___39);
#line 1767
  contlen = (wgint )-1;
#line 1768
  contrange = (wgint )0;
#line 1769
  *dt &= -3;
#line 1771
  head = read_http_response_head(sock);
  }
#line 1772
  if (! head) {
    {
#line 1774
    tmp___44 = __errno_location();
    }
#line 1774
    if (*tmp___44 == 0) {
      {
#line 1776
      tmp___41 = gettext("No data received.\n");
#line 1776
      logputs((enum log_options )1, (char const   *)tmp___41);
      }
      {
#line 1777
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1777
        if (pconn_active) {
#line 1777
          if (sock == pconn.socket) {
            {
#line 1777
            invalidate_persistent();
            }
          } else {
            {
#line 1777
            fd_close(sock);
            }
          }
        } else {
          {
#line 1777
          fd_close(sock);
          }
        }
#line 1777
        sock = -1;
#line 1777
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1778
      request_free(req);
      }
#line 1779
      return ((uerr_t )29);
    } else {
      {
#line 1783
      tmp___42 = fd_errstr(sock);
#line 1783
      tmp___43 = gettext("Read error (%s) in headers.\n");
#line 1783
      logprintf((enum log_options )1, (char const   *)tmp___43, tmp___42);
      }
      {
#line 1785
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1785
        if (pconn_active) {
#line 1785
          if (sock == pconn.socket) {
            {
#line 1785
            invalidate_persistent();
            }
          } else {
            {
#line 1785
            fd_close(sock);
            }
          }
        } else {
          {
#line 1785
          fd_close(sock);
          }
        }
#line 1785
        sock = -1;
#line 1785
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1786
      request_free(req);
      }
#line 1787
      return ((uerr_t )30);
    }
  }
  {
#line 1790
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 1790
    tmp___45 = __builtin_expect((long )opt.debug, 0L);
    }
#line 1790
    if (tmp___45) {
      {
#line 1790
      debug_logprintf("\n---response begin---\n%s---response end---\n", head);
      }
    }
#line 1790
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1792
  resp = resp_new((char const   *)head);
#line 1795
  message = (char *)((void *)0);
#line 1796
  statcode = resp_status((struct response  const  *)resp, & message);
  }
#line 1797
  if (! opt.server_response) {
#line 1798
    if (message) {
      {
#line 1798
      tmp___46 = escnonprint((char const   *)message);
#line 1798
      tmp___47 = tmp___46;
      }
    } else {
#line 1798
      tmp___47 = "";
    }
    {
#line 1798
    logprintf((enum log_options )0, "%2d %s\n", statcode, tmp___47);
    }
  } else {
    {
#line 1802
    logprintf((enum log_options )0, "\n");
#line 1803
    print_server_response((struct response  const  *)resp, "  ");
    }
  }
#line 1808
  if (! hs->local_file) {
#line 1811
    if (! opt.content_disposition) {
      {
#line 1818
      hs->local_file = url_file_name((struct url  const  *)u);
      }
    } else {
      {
#line 1811
      tmp___48 = resp_header_copy((struct response  const  *)resp, "Content-Disposition",
                                  hdrval, (int )sizeof(hdrval));
      }
#line 1811
      if (tmp___48) {
        {
#line 1811
        tmp___49 = parse_content_disposition((char const   *)(hdrval), & hs->local_file);
        }
#line 1811
        if (! tmp___49) {
          {
#line 1818
          hs->local_file = url_file_name((struct url  const  *)u);
          }
        }
      } else {
        {
#line 1818
        hs->local_file = url_file_name((struct url  const  *)u);
        }
      }
    }
  }
#line 1823
  if (! hs->existence_checked) {
    {
#line 1823
    tmp___53 = file_exists_p((char const   *)hs->local_file);
    }
#line 1823
    if (tmp___53) {
#line 1825
      if (opt.noclobber) {
#line 1825
        if (! opt.output_document) {
          {
#line 1830
          tmp___50 = gettext("File `%s\' already there; not retrieving.\n\n");
#line 1830
          logprintf((enum log_options )0, (char const   *)tmp___50, hs->local_file);
#line 1833
          *dt |= 2;
#line 1837
          tmp___51 = has_html_suffix_p((char const   *)hs->local_file);
          }
#line 1837
          if (tmp___51) {
#line 1838
            *dt |= 1;
          }
#line 1840
          return ((uerr_t )38);
        } else {
#line 1825
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1842
      if (! opt.noclobber) {
#line 1842
        if (! opt.always_rest) {
#line 1842
          if (! opt.timestamping) {
#line 1842
            if (! opt.dirstruct) {
#line 1842
              if (! opt.output_document) {
                {
#line 1844
                tmp___52 = unique_name((char const   *)hs->local_file, (_Bool)1);
#line 1844
                unique = tmp___52;
                }
#line 1845
                if ((unsigned long )unique != (unsigned long )hs->local_file) {
                  {
#line 1846
                  checking_free((void *)hs->local_file);
                  }
                }
#line 1847
                hs->local_file = unique;
              }
            }
          }
        }
      }
    }
  }
#line 1850
  hs->existence_checked = (_Bool)1;
#line 1854
  if (opt.timestamping) {
#line 1854
    if (! hs->timestamp_checked) {
      {
#line 1856
      tmp___54 = strlen((char const   *)hs->local_file);
#line 1856
      filename_len = tmp___54;
#line 1857
      tmp___55 = __builtin_alloca(filename_len + sizeof(".orig"));
#line 1857
      filename_plus_orig_suffix = (char *)tmp___55;
#line 1858
      local_dot_orig_file_exists = (_Bool)0;
#line 1859
      local_filename = (char *)((void *)0);
      }
#line 1862
      if (opt.backup_converted) {
        {
#line 1880
        memcpy((void */* __restrict  */)filename_plus_orig_suffix, (void const   */* __restrict  */)hs->local_file,
               filename_len);
#line 1881
        memcpy((void */* __restrict  */)(filename_plus_orig_suffix + filename_len),
               (void const   */* __restrict  */)".orig", sizeof(".orig"));
#line 1885
        tmp___56 = stat((char const   */* __restrict  */)filename_plus_orig_suffix,
                        (struct stat */* __restrict  */)(& st));
        }
#line 1885
        if (tmp___56 == 0) {
#line 1887
          local_dot_orig_file_exists = (_Bool)1;
#line 1888
          local_filename = filename_plus_orig_suffix;
        }
      }
#line 1892
      if (! local_dot_orig_file_exists) {
        {
#line 1894
        tmp___57 = stat((char const   */* __restrict  */)hs->local_file, (struct stat */* __restrict  */)(& st));
        }
#line 1894
        if (tmp___57 == 0) {
#line 1895
          local_filename = hs->local_file;
        }
      }
#line 1897
      if ((unsigned long )local_filename != (unsigned long )((void *)0)) {
        {
#line 1902
        hs->orig_file_name = checking_strdup((char const   *)local_filename);
#line 1903
        hs->orig_file_size = st.st_size;
#line 1904
        hs->orig_file_tstamp = st.st_mtim.tv_sec;
        }
      }
    }
  }
#line 1913
  if (! opt.ignore_length) {
    {
#line 1913
    tmp___60 = resp_header_copy((struct response  const  *)resp, "Content-Length",
                                hdrval, (int )sizeof(hdrval));
    }
#line 1913
    if (tmp___60) {
      {
#line 1917
      tmp___58 = __errno_location();
#line 1917
      *tmp___58 = 0;
#line 1918
      parsed = strtol((char const   */* __restrict  */)(hdrval), (char **/* __restrict  */)((void *)0),
                      10);
      }
#line 1919
      if (parsed == ~ (-1L << (sizeof(wgint ) * 8UL - 1UL))) {
        {
#line 1919
        tmp___59 = __errno_location();
        }
#line 1919
        if (*tmp___59 == 34) {
#line 1926
          contlen = (wgint )-1;
        } else {
#line 1919
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1928
      if (parsed < 0L) {
#line 1932
        contlen = (wgint )-1;
      } else {
#line 1935
        contlen = parsed;
      }
    }
  }
#line 1939
  if (! inhibit_keep_alive) {
#line 1939
    if (contlen != -1L) {
      {
#line 1941
      tmp___63 = resp_header_copy((struct response  const  *)resp, "Keep-Alive", (char *)((void *)0),
                                  0);
      }
#line 1941
      if (tmp___63) {
#line 1942
        keep_alive = (_Bool)1;
      } else {
        {
#line 1943
        tmp___62 = resp_header_copy((struct response  const  *)resp, "Connection",
                                    hdrval, (int )sizeof(hdrval));
        }
#line 1943
        if (tmp___62) {
          {
#line 1945
          tmp___61 = strcasecmp((char const   *)(hdrval), "Keep-Alive");
          }
#line 1945
          if (0 == tmp___61) {
#line 1946
            keep_alive = (_Bool)1;
          }
        }
      }
    }
  }
#line 1949
  if (keep_alive) {
    {
#line 1952
    register_persistent((char const   *)conn->host, conn->port, sock, using_ssl);
    }
  }
#line 1954
  if (statcode == 401) {
#line 1957
    if (keep_alive) {
#line 1957
      if (! head_only) {
        {
#line 1957
        tmp___64 = skip_short_body(sock, contlen);
        }
#line 1957
        if (tmp___64) {
          {
#line 1958
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1958
            if (! keep_alive) {
#line 1958
              if (pconn_active) {
#line 1958
                if (sock == pconn.socket) {
                  {
#line 1958
                  invalidate_persistent();
                  }
                } else {
                  {
#line 1958
                  fd_close(sock);
#line 1958
                  sock = -1;
                  }
                }
              } else {
                {
#line 1958
                fd_close(sock);
#line 1958
                sock = -1;
                }
              }
            }
#line 1958
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        } else {
#line 1957
          goto _L___3;
        }
      } else {
#line 1957
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 1960
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1960
        if (pconn_active) {
#line 1960
          if (sock == pconn.socket) {
            {
#line 1960
            invalidate_persistent();
            }
          } else {
            {
#line 1960
            fd_close(sock);
            }
          }
        } else {
          {
#line 1960
          fd_close(sock);
          }
        }
#line 1960
        sock = -1;
#line 1960
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1961
    pconn.authorized = (_Bool)0;
#line 1962
    if (! auth_finished) {
#line 1962
      if (user) {
#line 1962
        if (passwd) {
#line 1969
          www_authenticate = (char *)((void *)0);
#line 1970
          wapos = 0;
          {
#line 1970
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 1970
            wapos = resp_header_locate((struct response  const  *)resp, "WWW-Authenticate",
                                       wapos, & wabeg, & waend);
            }
#line 1970
            if (! (wapos != -1)) {
#line 1970
              goto while_break___13;
            }
            {
#line 1974
            tmp___66 = known_authentication_scheme_p(wabeg, waend);
            }
#line 1974
            if (tmp___66) {
              {
#line 1976
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 1976
                BTA_beg = wabeg;
#line 1976
                BTA_len = (int )(waend - BTA_beg);
#line 1976
                BTA_dest = & www_authenticate;
#line 1976
                tmp___65 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 1976
                *BTA_dest = (char *)tmp___65;
#line 1976
                memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
                       (size_t )BTA_len);
#line 1976
                *(*BTA_dest + BTA_len) = (char )'\000';
                }
#line 1976
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 1977
              goto while_break___13;
            }
#line 1970
            wapos ++;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 1980
          if (! www_authenticate) {
            {
#line 1984
            tmp___67 = gettext("Unknown authentication scheme.\n");
#line 1984
            logputs((enum log_options )1, (char const   *)tmp___67);
            }
          } else
#line 1986
          if (! basic_auth_finished) {
#line 1986
            goto _L___6;
          } else {
            {
#line 1986
            tmp___72 = strncasecmp((char const   *)www_authenticate, "Basic", sizeof("Basic") - 1UL);
            }
#line 1986
            if (tmp___72) {
              _L___6: /* CIL Label */ 
              {
#line 1990
              pth = url_full_path((struct url  const  *)u);
#line 1991
              tmp___68 = request_method((struct request  const  *)req);
#line 1991
              tmp___69 = create_authorization_line((char const   *)www_authenticate,
                                                   (char const   *)user, (char const   *)passwd,
                                                   tmp___68, (char const   *)pth,
                                                   & auth_finished);
#line 1991
              request_set_header(req, (char *)"Authorization", tmp___69, (enum rp )2);
#line 1998
              tmp___71 = strncasecmp((char const   *)www_authenticate, "NTLM", sizeof("NTLM") - 1UL);
              }
#line 1998
              if (tmp___71) {
                _L___4: /* CIL Label */ 
#line 2000
                if (! u->user) {
                  {
#line 2000
                  tmp___70 = strncasecmp((char const   *)www_authenticate, "Basic",
                                         sizeof("Basic") - 1UL);
                  }
#line 2000
                  if (! tmp___70) {
#line 2000
                    if ((int const   )_sch_istable[(int )*(www_authenticate + (sizeof("Basic") - 1UL)) & 255] & 64) {
                      {
#line 2004
                      register_basic_auth_host((char const   *)u->host);
                      }
                    } else
#line 2000
                    if (! *(www_authenticate + (sizeof("Basic") - 1UL))) {
                      {
#line 2004
                      register_basic_auth_host((char const   *)u->host);
                      }
                    }
                  }
                }
              } else
#line 1998
              if ((int const   )_sch_istable[(int )*(www_authenticate + (sizeof("NTLM") - 1UL)) & 255] & 64) {
#line 1999
                ntlm_seen = (_Bool)1;
              } else
#line 1998
              if (! *(www_authenticate + (sizeof("NTLM") - 1UL))) {
#line 1999
                ntlm_seen = (_Bool)1;
              } else {
#line 1998
                goto _L___4;
              }
              {
#line 2006
              checking_free((void *)pth);
              }
#line 2007
              goto retry_with_auth;
            } else
#line 1986
            if (! ((int const   )_sch_istable[(int )*(www_authenticate + (sizeof("Basic") - 1UL)) & 255] & 64)) {
#line 1986
              if (! (! *(www_authenticate + (sizeof("Basic") - 1UL)))) {
#line 1986
                goto _L___6;
              }
            }
          }
        }
      }
    }
    {
#line 2015
    tmp___73 = gettext("Authorization failed.\n");
#line 2015
    logputs((enum log_options )1, (char const   *)tmp___73);
#line 2016
    request_free(req);
    }
#line 2017
    return ((uerr_t )50);
  } else
#line 2022
  if (ntlm_seen) {
#line 2023
    pconn.authorized = (_Bool)1;
  }
  {
#line 2025
  request_free(req);
#line 2027
  hs->statcode = statcode;
  }
#line 2028
  if (statcode == -1) {
    {
#line 2029
    tmp___74 = gettext("Malformed status line");
#line 2029
    hs->error = checking_strdup((char const   *)tmp___74);
    }
  } else
#line 2030
  if (! *message) {
    {
#line 2031
    tmp___75 = gettext("(no description)");
#line 2031
    hs->error = checking_strdup((char const   *)tmp___75);
    }
  } else {
    {
#line 2033
    hs->error = checking_strdup((char const   *)message);
    }
  }
#line 2034
  if (! (! message)) {
    {
#line 2034
    checking_free((void *)message);
    }
  }
  {
#line 2036
  type = resp_header_strdup((struct response  const  *)resp, "Content-Type");
  }
#line 2037
  if (type) {
    {
#line 2039
    tmp___77 = strchr((char const   *)type, ';');
#line 2039
    tmp___76 = tmp___77;
    }
#line 2040
    if (tmp___76) {
      {
#line 2042
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 2042
        if ((unsigned long )tmp___76 > (unsigned long )type) {
#line 2042
          if (! ((int const   )_sch_istable[(int )*(tmp___76 + -1) & 255] & 64)) {
#line 2042
            goto while_break___15;
          }
        } else {
#line 2042
          goto while_break___15;
        }
#line 2043
        tmp___76 --;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 2044
      *tmp___76 = (char )'\000';
    }
  }
  {
#line 2047
  hs->newloc = resp_header_strdup((struct response  const  *)resp, "Location");
#line 2048
  hs->remote_time = resp_header_strdup((struct response  const  *)resp, "Last-Modified");
  }
#line 2051
  if (opt.cookies) {
#line 2056
    if (! ((unsigned long )wget_cookie_jar != (unsigned long )((void *)0))) {
      {
#line 2056
      __assert_fail("wget_cookie_jar != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/http.c",
                    2056U, "gethttp");
      }
    }
#line 2057
    scpos = 0;
    {
#line 2057
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 2057
      scpos = resp_header_locate((struct response  const  *)resp, "Set-Cookie", scpos,
                                 & scbeg, & scend);
      }
#line 2057
      if (! (scpos != -1)) {
#line 2057
        goto while_break___16;
      }
      {
#line 2062
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 2062
        BTA_beg___0 = scbeg;
#line 2062
        BTA_len___0 = (int )(scend - BTA_beg___0);
#line 2062
        BTA_dest___0 = & set_cookie;
#line 2062
        tmp___79 = __builtin_alloca((unsigned long )(BTA_len___0 + 1));
#line 2062
        *BTA_dest___0 = (char *)tmp___79;
#line 2062
        memcpy((void */* __restrict  */)*BTA_dest___0, (void const   */* __restrict  */)BTA_beg___0,
               (size_t )BTA_len___0);
#line 2062
        *(*BTA_dest___0 + BTA_len___0) = (char )'\000';
        }
#line 2062
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 2063
      cookie_handle_set_cookie(wget_cookie_jar, (char const   *)u->host, u->port,
                               (char const   *)u->path, (char const   *)set_cookie);
#line 2057
      scpos ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 2068
  tmp___81 = resp_header_copy((struct response  const  *)resp, "Content-Range", hdrval,
                              (int )sizeof(hdrval));
  }
#line 2068
  if (tmp___81) {
    {
#line 2071
    tmp___80 = parse_content_range((char const   *)(hdrval), & first_byte_pos, & last_byte_pos,
                                   & entity_length);
    }
#line 2071
    if (tmp___80) {
#line 2074
      contrange = first_byte_pos;
#line 2075
      contlen = (last_byte_pos - first_byte_pos) + 1L;
    }
  }
  {
#line 2078
  resp_free(resp);
  }
#line 2081
  if (statcode >= 200) {
#line 2081
    if (statcode < 300) {
#line 2082
      *dt |= 2;
    }
  }
#line 2085
  if (statcode == 301) {
#line 2085
    goto _L___10;
  } else
#line 2085
  if (statcode == 302) {
#line 2085
    goto _L___10;
  } else
#line 2085
  if (statcode == 303) {
#line 2085
    goto _L___10;
  } else
#line 2085
  if (statcode == 307) {
#line 2085
    goto _L___10;
  } else
#line 2085
  if (statcode == 300) {
    _L___10: /* CIL Label */ 
#line 2092
    if (statcode == 300) {
#line 2092
      if (! hs->newloc) {
#line 2093
        *dt |= 2;
      } else {
#line 2092
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
#line 2096
      if (hs->newloc) {
        {
#line 2096
        tmp___82 = gettext(" [following]");
#line 2096
        tmp___83 = (char const   *)tmp___82;
        }
      } else {
#line 2096
        tmp___83 = "";
      }
#line 2096
      if (hs->newloc) {
        {
#line 2096
        tmp___84 = escnonprint_uri((char const   *)hs->newloc);
#line 2096
        tmp___86 = tmp___84;
        }
      } else {
        {
#line 2096
        tmp___85 = gettext("unspecified");
#line 2096
        tmp___86 = (char const   *)tmp___85;
        }
      }
      {
#line 2096
      tmp___87 = gettext("Location: %s%s\n");
#line 2096
      logprintf((enum log_options )0, (char const   *)tmp___87, tmp___86, tmp___83);
      }
#line 2100
      if (keep_alive) {
#line 2100
        if (! head_only) {
          {
#line 2100
          tmp___88 = skip_short_body(sock, contlen);
          }
#line 2100
          if (tmp___88) {
            {
#line 2101
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 2101
              if (! keep_alive) {
#line 2101
                if (pconn_active) {
#line 2101
                  if (sock == pconn.socket) {
                    {
#line 2101
                    invalidate_persistent();
                    }
                  } else {
                    {
#line 2101
                    fd_close(sock);
#line 2101
                    sock = -1;
                    }
                  }
                } else {
                  {
#line 2101
                  fd_close(sock);
#line 2101
                  sock = -1;
                  }
                }
              }
#line 2101
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
          } else {
#line 2100
            goto _L___8;
          }
        } else {
#line 2100
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ 
        {
#line 2103
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 2103
          if (pconn_active) {
#line 2103
            if (sock == pconn.socket) {
              {
#line 2103
              invalidate_persistent();
              }
            } else {
              {
#line 2103
              fd_close(sock);
              }
            }
          } else {
            {
#line 2103
            fd_close(sock);
            }
          }
#line 2103
          sock = -1;
#line 2103
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 2104
      if (! (! type)) {
        {
#line 2104
        checking_free((void *)type);
        }
      }
#line 2105
      return ((uerr_t )6);
    }
  }
#line 2112
  if (! type) {
#line 2115
    *dt |= 1;
  } else {
    {
#line 2112
    tmp___89 = strlen("text/html");
#line 2112
    tmp___90 = strncasecmp((char const   *)type, "text/html", tmp___89);
    }
#line 2112
    if (0 == tmp___90) {
#line 2115
      *dt |= 1;
    } else {
      {
#line 2112
      tmp___91 = strlen("application/xhtml+xml");
#line 2112
      tmp___92 = strncasecmp((char const   *)type, "application/xhtml+xml", tmp___91);
      }
#line 2112
      if (0 == tmp___92) {
#line 2115
        *dt |= 1;
      } else {
#line 2117
        *dt &= -2;
      }
    }
  }
#line 2119
  if (opt.html_extension) {
#line 2119
    if (*dt & 1) {
      {
#line 2124
      tmp___93 = strrchr((char const   *)hs->local_file, '.');
#line 2124
      last_period_in_local_filename = tmp___93;
      }
#line 2126
      if ((unsigned long )last_period_in_local_filename == (unsigned long )((void *)0)) {
#line 2126
        goto _L___11;
      } else {
        {
#line 2126
        tmp___99 = strcasecmp((char const   *)last_period_in_local_filename, ".htm");
        }
#line 2126
        if (! (0 == tmp___99)) {
          {
#line 2126
          tmp___100 = strcasecmp((char const   *)last_period_in_local_filename, ".html");
          }
#line 2126
          if (! (0 == tmp___100)) {
            _L___11: /* CIL Label */ 
            {
#line 2130
            tmp___94 = strlen((char const   *)hs->local_file);
#line 2130
            local_filename_len = (int )tmp___94;
#line 2133
            tmp___95 = checking_realloc((void *)hs->local_file, (unsigned long )(local_filename_len + 24) + sizeof(".html"));
#line 2133
            hs->local_file = (char *)tmp___95;
#line 2135
            strcpy((char */* __restrict  */)(hs->local_file + local_filename_len),
                   (char const   */* __restrict  */)".html");
            }
#line 2138
            if (! opt.noclobber) {
#line 2138
              if (! opt.always_rest) {
#line 2138
                if (! opt.timestamping) {
#line 2138
                  if (! opt.dirstruct) {
#line 2138
                    if (! opt.output_document) {
                      {
#line 2138
                      tmp___98 = file_exists_p((char const   *)hs->local_file);
                      }
#line 2138
                      if (tmp___98) {
#line 2140
                        ext_num = 1;
                        {
#line 2141
                        while (1) {
                          while_continue___20: /* CIL Label */ ;
                          {
#line 2142
                          tmp___96 = ext_num;
#line 2142
                          ext_num ++;
#line 2142
                          sprintf((char */* __restrict  */)(hs->local_file + local_filename_len),
                                  (char const   */* __restrict  */)".%d.html", tmp___96);
#line 2141
                          tmp___97 = file_exists_p((char const   *)hs->local_file);
                          }
#line 2141
                          if (! tmp___97) {
#line 2141
                            goto while_break___20;
                          }
                        }
                        while_break___20: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 2146
            *dt |= 32;
          }
        }
      }
    }
  }
#line 2150
  if (statcode == 416) {
    {
#line 2155
    tmp___101 = gettext("\n    The file is already fully retrieved; nothing to do.\n\n");
#line 2155
    logputs((enum log_options )0, (char const   *)tmp___101);
#line 2158
    hs->len = contlen;
#line 2159
    hs->res = 0;
#line 2161
    *dt |= 2;
    }
#line 2162
    if (! (! type)) {
      {
#line 2162
      checking_free((void *)type);
      }
    }
    {
#line 2163
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 2163
      if (pconn_active) {
#line 2163
        if (sock == pconn.socket) {
          {
#line 2163
          invalidate_persistent();
          }
        } else {
          {
#line 2163
          fd_close(sock);
          }
        }
      } else {
        {
#line 2163
        fd_close(sock);
        }
      }
#line 2163
      sock = -1;
#line 2163
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 2165
    return ((uerr_t )38);
  }
#line 2167
  if (contrange != 0L) {
#line 2167
    if (contrange != hs->restval) {
#line 2167
      goto _L___12;
    } else {
#line 2167
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 2167
  if (statcode == 206) {
#line 2167
    if (! contrange) {
      _L___12: /* CIL Label */ 
#line 2172
      if (! (! type)) {
        {
#line 2172
        checking_free((void *)type);
        }
      }
      {
#line 2173
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 2173
        if (pconn_active) {
#line 2173
          if (sock == pconn.socket) {
            {
#line 2173
            invalidate_persistent();
            }
          } else {
            {
#line 2173
            fd_close(sock);
            }
          }
        } else {
          {
#line 2173
          fd_close(sock);
          }
        }
#line 2173
        sock = -1;
#line 2173
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 2174
      return ((uerr_t )44);
    }
  }
#line 2176
  if (contlen == -1L) {
#line 2177
    hs->contlen = (wgint )-1;
  } else {
#line 2179
    hs->contlen = contlen + contrange;
  }
#line 2181
  if (opt.verbose) {
#line 2183
    if (*dt & 2) {
      {
#line 2188
      tmp___102 = gettext("Length: ");
#line 2188
      logputs((enum log_options )0, (char const   *)tmp___102);
      }
#line 2189
      if (contlen != -1L) {
        {
#line 2191
        tmp___103 = number_to_static_string(contlen + contrange);
#line 2191
        logputs((enum log_options )0, (char const   *)tmp___103);
        }
#line 2192
        if (contlen + contrange >= 1024L) {
          {
#line 2193
          tmp___104 = human_readable(contlen + contrange);
#line 2193
          logprintf((enum log_options )0, " (%s)", tmp___104);
          }
        }
#line 2195
        if (contrange) {
#line 2197
          if (contlen >= 1024L) {
            {
#line 2198
            tmp___105 = human_readable(contlen);
#line 2198
            tmp___106 = number_to_static_string(contlen);
#line 2198
            tmp___107 = gettext(", %s (%s) remaining");
#line 2198
            logprintf((enum log_options )0, (char const   *)tmp___107, tmp___106,
                      tmp___105);
            }
          } else {
            {
#line 2202
            tmp___108 = number_to_static_string(contlen);
#line 2202
            tmp___109 = gettext(", %s remaining");
#line 2202
            logprintf((enum log_options )0, (char const   *)tmp___109, tmp___108);
            }
          }
        }
      } else {
#line 2207
        if (opt.ignore_length) {
          {
#line 2207
          tmp___110 = gettext("ignored");
#line 2207
          tmp___112 = tmp___110;
          }
        } else {
          {
#line 2207
          tmp___111 = gettext("unspecified");
#line 2207
          tmp___112 = tmp___111;
          }
        }
        {
#line 2207
        logputs((enum log_options )0, (char const   *)tmp___112);
        }
      }
#line 2209
      if (type) {
        {
#line 2210
        tmp___113 = escnonprint((char const   *)type);
#line 2210
        logprintf((enum log_options )0, " [%s]\n", tmp___113);
        }
      } else {
        {
#line 2212
        logputs((enum log_options )0, "\n");
        }
      }
    }
  }
#line 2215
  if (! (! type)) {
    {
#line 2215
    checking_free((void *)type);
    }
  }
#line 2216
  type = (char *)((void *)0);
#line 2219
  if (! (*dt & 2)) {
#line 2219
    goto _L___15;
  } else
#line 2219
  if (head_only) {
    _L___15: /* CIL Label */ 
#line 2222
    hs->len = (wgint )0;
#line 2223
    hs->res = 0;
#line 2224
    if (! (! type)) {
      {
#line 2224
      checking_free((void *)type);
      }
    }
#line 2225
    if (head_only) {
      {
#line 2231
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 2231
        if (! keep_alive) {
#line 2231
          if (pconn_active) {
#line 2231
            if (sock == pconn.socket) {
              {
#line 2231
              invalidate_persistent();
              }
            } else {
              {
#line 2231
              fd_close(sock);
#line 2231
              sock = -1;
              }
            }
          } else {
            {
#line 2231
            fd_close(sock);
#line 2231
            sock = -1;
            }
          }
        }
#line 2231
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
    } else
#line 2232
    if (keep_alive) {
      {
#line 2232
      tmp___114 = skip_short_body(sock, contlen);
      }
#line 2232
      if (tmp___114) {
        {
#line 2234
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 2234
          if (! keep_alive) {
#line 2234
            if (pconn_active) {
#line 2234
              if (sock == pconn.socket) {
                {
#line 2234
                invalidate_persistent();
                }
              } else {
                {
#line 2234
                fd_close(sock);
#line 2234
                sock = -1;
                }
              }
            } else {
              {
#line 2234
              fd_close(sock);
#line 2234
              sock = -1;
              }
            }
          }
#line 2234
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
      } else {
#line 2232
        goto _L___14;
      }
    } else {
      _L___14: /* CIL Label */ 
      {
#line 2236
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 2236
        if (pconn_active) {
#line 2236
          if (sock == pconn.socket) {
            {
#line 2236
            invalidate_persistent();
            }
          } else {
            {
#line 2236
            fd_close(sock);
            }
          }
        } else {
          {
#line 2236
          fd_close(sock);
          }
        }
#line 2236
        sock = -1;
#line 2236
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
#line 2237
    return ((uerr_t )39);
  }
#line 2241
  if (! output_stream) {
    {
#line 2243
    mkalldirs((char const   *)hs->local_file);
    }
#line 2244
    if (opt.backups) {
      {
#line 2245
      rotate_backups((char const   *)hs->local_file);
      }
    }
#line 2246
    if (hs->restval) {
      {
#line 2247
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"ab");
      }
    } else
#line 2248
    if (opt.noclobber) {
      {
#line 2249
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"wb");
      }
    } else
#line 2248
    if (opt.always_rest) {
      {
#line 2249
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"wb");
      }
    } else
#line 2248
    if (opt.timestamping) {
      {
#line 2249
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"wb");
      }
    } else
#line 2248
    if (opt.dirstruct) {
      {
#line 2249
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"wb");
      }
    } else
#line 2248
    if (opt.output_document) {
      {
#line 2249
      fp = fopen((char const   */* __restrict  */)hs->local_file, (char const   */* __restrict  */)"wb");
      }
    } else {
      {
#line 2252
      fp = fopen_excl((char const   *)hs->local_file, (_Bool)1);
      }
#line 2253
      if (! fp) {
        {
#line 2253
        tmp___116 = __errno_location();
        }
#line 2253
        if (*tmp___116 == 17) {
          {
#line 2259
          tmp___115 = gettext("%s has sprung into existence.\n");
#line 2259
          logprintf((enum log_options )1, (char const   *)tmp___115, hs->local_file);
          }
          {
#line 2262
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 2262
            if (pconn_active) {
#line 2262
              if (sock == pconn.socket) {
                {
#line 2262
                invalidate_persistent();
                }
              } else {
                {
#line 2262
                fd_close(sock);
                }
              }
            } else {
              {
#line 2262
              fd_close(sock);
              }
            }
#line 2262
            sock = -1;
#line 2262
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 2263
          return ((uerr_t )25);
        }
      }
    }
#line 2266
    if (! fp) {
      {
#line 2268
      tmp___117 = __errno_location();
#line 2268
      tmp___118 = strerror(*tmp___117);
#line 2268
      logprintf((enum log_options )1, "%s: %s\n", hs->local_file, tmp___118);
      }
      {
#line 2269
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 2269
        if (pconn_active) {
#line 2269
          if (sock == pconn.socket) {
            {
#line 2269
            invalidate_persistent();
            }
          } else {
            {
#line 2269
            fd_close(sock);
            }
          }
        } else {
          {
#line 2269
          fd_close(sock);
          }
        }
#line 2269
        sock = -1;
#line 2269
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 2270
      return ((uerr_t )24);
    }
  } else {
#line 2274
    fp = output_stream;
  }
#line 2277
  if (opt.verbose) {
#line 2279
    if ((int )*(hs->local_file) == 45) {
#line 2279
      if (! *(hs->local_file + 1)) {
#line 2279
        tmp___119 = "STDOUT";
      } else {
#line 2279
        tmp___119 = (char const   *)hs->local_file;
      }
    } else {
#line 2279
      tmp___119 = (char const   *)hs->local_file;
    }
    {
#line 2279
    tmp___120 = gettext("Saving to: `%s\'\n");
#line 2279
    logprintf((enum log_options )1, (char const   *)tmp___120, tmp___119);
    }
  }
#line 2285
  if (opt.save_headers) {
#line 2285
    if (hs->restval == 0L) {
      {
#line 2286
      tmp___121 = strlen((char const   *)head);
#line 2286
      fwrite((void const   */* __restrict  */)head, (size_t )1, tmp___121, (FILE */* __restrict  */)fp);
      }
    }
  }
  {
#line 2289
  checking_free((void *)head);
#line 2292
  flags = 0;
  }
#line 2293
  if (contlen != -1L) {
#line 2297
    flags |= 1;
  }
#line 2298
  if (hs->restval > 0L) {
#line 2298
    if (contrange == 0L) {
#line 2301
      flags |= 2;
    }
  }
#line 2302
  hs->len = hs->restval;
#line 2303
  hs->rd_size = (wgint )0;
#line 2304
  if (contlen != -1L) {
#line 2304
    tmp___122 = contlen;
  } else {
#line 2304
    tmp___122 = (wgint )0;
  }
  {
#line 2304
  hs->res = fd_read_body(sock, fp, tmp___122, hs->restval, & hs->rd_size, & hs->len,
                         & hs->dltime, flags);
  }
#line 2308
  if (hs->res >= 0) {
    {
#line 2309
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 2309
      if (! keep_alive) {
#line 2309
        if (pconn_active) {
#line 2309
          if (sock == pconn.socket) {
            {
#line 2309
            invalidate_persistent();
            }
          } else {
            {
#line 2309
            fd_close(sock);
#line 2309
            sock = -1;
            }
          }
        } else {
          {
#line 2309
          fd_close(sock);
#line 2309
          sock = -1;
          }
        }
      }
#line 2309
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
  } else {
#line 2312
    if (hs->res < 0) {
      {
#line 2313
      tmp___123 = fd_errstr(sock);
#line 2313
      hs->rderrmsg = checking_strdup(tmp___123);
      }
    }
    {
#line 2314
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 2314
      if (pconn_active) {
#line 2314
        if (sock == pconn.socket) {
          {
#line 2314
          invalidate_persistent();
          }
        } else {
          {
#line 2314
          fd_close(sock);
          }
        }
      } else {
        {
#line 2314
        fd_close(sock);
        }
      }
#line 2314
      sock = -1;
#line 2314
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
  }
#line 2317
  if (! output_stream) {
    {
#line 2318
    fclose(fp);
    }
  }
#line 2319
  if (hs->res == -2) {
#line 2320
    return ((uerr_t )26);
  }
#line 2321
  return ((uerr_t )39);
}
}
#line 2326 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
uerr_t http_loop(struct url *u , char **newloc , char **local_file , char const   *referer ,
                 int *dt , struct url *proxy ) 
{ 
  int count ;
  _Bool got_head ;
  _Bool time_came_from_head ;
  _Bool got_name ;
  char *tms ;
  char const   *tmrate ;
  uerr_t err ;
  uerr_t ret ;
  time_t tmr ;
  struct http_stat hstat ;
  struct stat st ;
  _Bool send_head_first ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  char *hurl ;
  char *tmp___10 ;
  char tmp___11[256] ;
  char *tmp___12 ;
  int tmp___13 ;
  time_t tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *hurl___0 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char const   *fl ;
  time_t newtmr ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;

  {
#line 2331
  got_head = (_Bool)0;
#line 2332
  time_came_from_head = (_Bool)0;
#line 2333
  got_name = (_Bool)0;
#line 2336
  ret = (uerr_t )41;
#line 2337
  tmr = (time_t )-1;
#line 2340
  send_head_first = (_Bool)1;
#line 2343
  if (! ((unsigned long )local_file == (unsigned long )((void *)0))) {
#line 2343
    if (! ((unsigned long )*local_file == (unsigned long )((void *)0))) {
      {
#line 2343
      __assert_fail("local_file == NULL || *local_file == NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/http.c",
                    2343U, "http_loop");
      }
    }
  }
#line 2346
  if (local_file) {
#line 2346
    if (opt.output_document) {
#line 2347
      if ((int )*(opt.output_document) == 45) {
#line 2347
        if (! *(opt.output_document + 1)) {
#line 2347
          *local_file = (char *)((void *)0);
        } else {
          {
#line 2347
          tmp___0 = checking_strdup((char const   *)opt.output_document);
#line 2347
          *local_file = tmp___0;
          }
        }
      } else {
        {
#line 2347
        tmp___0 = checking_strdup((char const   *)opt.output_document);
#line 2347
        *local_file = tmp___0;
        }
      }
    }
  }
#line 2350
  *newloc = (char *)((void *)0);
#line 2355
  if (opt.cookies) {
    {
#line 2356
    load_cookies();
    }
  }
#line 2359
  if (opt.ftp_glob) {
    {
#line 2359
    tmp___2 = has_wildcards_p((char const   *)u->path);
    }
#line 2359
    if (tmp___2) {
      {
#line 2360
      tmp___1 = gettext("Warning: wildcards not supported in HTTP.\n");
#line 2360
      logputs((enum log_options )0, (char const   *)tmp___1);
      }
    }
  }
  {
#line 2363
  memset((void *)(& hstat), '\000', sizeof(hstat));
#line 2364
  hstat.referer = referer;
  }
#line 2366
  if (opt.output_document) {
    {
#line 2368
    hstat.local_file = checking_strdup((char const   *)opt.output_document);
#line 2369
    got_name = (_Bool)1;
    }
  } else
#line 2371
  if (! opt.content_disposition) {
    {
#line 2373
    hstat.local_file = url_file_name((struct url  const  *)u);
#line 2374
    got_name = (_Bool)1;
    }
  }
#line 2379
  if (got_name) {
    {
#line 2379
    tmp___5 = file_exists_p((char const   *)hstat.local_file);
    }
#line 2379
    if (tmp___5) {
#line 2379
      if (opt.noclobber) {
#line 2379
        if (! opt.output_document) {
          {
#line 2384
          tmp___3 = gettext("File `%s\' already there; not retrieving.\n\n");
#line 2384
          logprintf((enum log_options )0, (char const   *)tmp___3, hstat.local_file);
#line 2388
          *dt |= 2;
#line 2392
          tmp___4 = has_html_suffix_p((char const   *)hstat.local_file);
          }
#line 2392
          if (tmp___4) {
#line 2393
            *dt |= 1;
          }
#line 2395
          ret = (uerr_t )31;
#line 2396
          goto exit;
        }
      }
    }
  }
#line 2400
  count = 0;
#line 2403
  *dt = 0;
#line 2407
  if (! opt.spider) {
#line 2407
    if (got_name) {
#line 2409
      send_head_first = (_Bool)0;
    } else
#line 2407
    if (! opt.content_disposition) {
#line 2409
      send_head_first = (_Bool)0;
    }
  }
#line 2413
  if (opt.timestamping) {
#line 2413
    if (! opt.content_disposition) {
      {
#line 2413
      tmp___6 = url_file_name((struct url  const  *)u);
#line 2413
      tmp___7 = file_exists_p((char const   *)tmp___6);
      }
#line 2413
      if (tmp___7) {
#line 2416
        send_head_first = (_Bool)1;
      }
    }
  }
  {
#line 2419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2422
    count ++;
#line 2423
    sleep_between_retrievals(count);
#line 2426
    tmp___8 = time((time_t *)((void *)0));
#line 2426
    tms = datetime_str(tmp___8);
    }
#line 2428
    if (opt.spider) {
#line 2428
      if (! got_head) {
        {
#line 2429
        tmp___9 = gettext("Spider mode enabled. Check if remote file exists.\n");
#line 2429
        logprintf((enum log_options )0, (char const   *)tmp___9);
        }
      }
    }
#line 2433
    if (opt.verbose) {
      {
#line 2435
      tmp___10 = url_string((struct url  const  *)u, (enum url_auth_mode )1);
#line 2435
      hurl = tmp___10;
      }
#line 2437
      if (count > 1) {
        {
#line 2440
        tmp___12 = gettext("(try:%2d)");
#line 2440
        sprintf((char */* __restrict  */)(tmp___11), (char const   */* __restrict  */)tmp___12,
                count);
#line 2441
        logprintf((enum log_options )1, "--%s--  %s  %s\n", tms, tmp___11, hurl);
        }
      } else {
        {
#line 2446
        logprintf((enum log_options )1, "--%s--  %s\n", tms, hurl);
        }
      }
      {
#line 2453
      checking_free((void *)hurl);
      }
    }
#line 2459
    if (send_head_first) {
#line 2459
      if (! got_head) {
#line 2460
        *dt |= 4;
      } else {
#line 2462
        *dt &= -5;
      }
    } else {
#line 2462
      *dt &= -5;
    }
#line 2465
    if (opt.always_rest) {
#line 2465
      if (got_name) {
        {
#line 2465
        tmp___13 = stat((char const   */* __restrict  */)hstat.local_file, (struct stat */* __restrict  */)(& st));
        }
#line 2465
        if (tmp___13 == 0) {
#line 2465
          if ((st.st_mode & 61440U) == 32768U) {
#line 2472
            hstat.restval = st.st_size;
          } else {
#line 2465
            goto _L___1;
          }
        } else {
#line 2465
          goto _L___1;
        }
      } else {
#line 2465
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2473
    if (count > 1) {
#line 2475
      hstat.restval = hstat.len;
    } else {
#line 2477
      hstat.restval = (wgint )0;
    }
#line 2485
    if (proxy) {
#line 2485
      if (count > 1) {
#line 2487
        *dt |= 8;
      } else {
#line 2485
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2485
    if (! opt.allow_cache) {
#line 2487
      *dt |= 8;
    } else {
#line 2489
      *dt &= -9;
    }
    {
#line 2492
    err = gethttp(u, & hstat, dt, proxy);
#line 2495
    tmp___14 = time((time_t *)((void *)0));
#line 2495
    tms = datetime_str(tmp___14);
    }
#line 2498
    if (hstat.newloc) {
      {
#line 2499
      *newloc = checking_strdup((char const   *)hstat.newloc);
      }
    }
    {
#line 2505
    if ((unsigned int )err == 25U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 44U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 52U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 40U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 3U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 9U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 2U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 29U) {
#line 2505
      goto case_25;
    }
#line 2505
    if ((unsigned int )err == 30U) {
#line 2505
      goto case_25;
    }
#line 2511
    if ((unsigned int )err == 24U) {
#line 2511
      goto case_24;
    }
#line 2511
    if ((unsigned int )err == 26U) {
#line 2511
      goto case_24;
    }
#line 2517
    if ((unsigned int )err == 37U) {
#line 2517
      goto case_37;
    }
#line 2517
    if ((unsigned int )err == 53U) {
#line 2517
      goto case_37;
    }
#line 2517
    if ((unsigned int )err == 50U) {
#line 2517
      goto case_37;
    }
#line 2517
    if ((unsigned int )err == 49U) {
#line 2517
      goto case_37;
    }
#line 2517
    if ((unsigned int )err == 5U) {
#line 2517
      goto case_37;
    }
#line 2517
    if ((unsigned int )err == 1U) {
#line 2517
      goto case_37;
    }
#line 2521
    if ((unsigned int )err == 4U) {
#line 2521
      goto case_4;
    }
#line 2526
    if ((unsigned int )err == 6U) {
#line 2526
      goto case_6;
    }
#line 2540
    if ((unsigned int )err == 38U) {
#line 2540
      goto case_38;
    }
#line 2544
    if ((unsigned int )err == 39U) {
#line 2544
      goto case_39;
    }
#line 2547
    goto switch_default;
    case_25: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_30: /* CIL Label */ 
    {
#line 2509
    printwhat(count, opt.ntry);
    }
#line 2510
    goto __Cont;
    case_24: /* CIL Label */ 
    case_26: /* CIL Label */ 
    {
#line 2513
    logputs((enum log_options )0, "\n");
#line 2514
    tmp___15 = __errno_location();
#line 2514
    tmp___16 = strerror(*tmp___15);
#line 2514
    tmp___17 = gettext("Cannot write to `%s\' (%s).\n");
#line 2514
    logprintf((enum log_options )1, (char const   *)tmp___17, hstat.local_file, tmp___16);
    }
    case_37: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 2519
    ret = err;
#line 2520
    goto exit;
    case_4: /* CIL Label */ 
    {
#line 2523
    tmp___18 = gettext("Unable to establish SSL connection.\n");
#line 2523
    logprintf((enum log_options )1, (char const   *)tmp___18);
#line 2524
    ret = err;
    }
#line 2525
    goto exit;
    case_6: /* CIL Label */ 
#line 2528
    if (! *newloc) {
      {
#line 2530
      tmp___19 = gettext("ERROR: Redirection (%d) without location.\n");
#line 2530
      logprintf((enum log_options )1, (char const   *)tmp___19, hstat.statcode);
#line 2533
      ret = (uerr_t )34;
      }
    } else {
#line 2537
      ret = (uerr_t )6;
    }
#line 2539
    goto exit;
    case_38: /* CIL Label */ 
#line 2542
    ret = (uerr_t )31;
#line 2543
    goto exit;
    case_39: /* CIL Label */ 
#line 2546
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2549
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 2552
    if (! (*dt & 2)) {
#line 2554
      hurl___0 = (char *)((void *)0);
#line 2555
      if (! opt.verbose) {
        {
#line 2558
        hurl___0 = url_string((struct url  const  *)u, (enum url_auth_mode )1);
#line 2559
        logprintf((enum log_options )2, "%s:\n", hurl___0);
        }
      }
#line 2563
      if (*dt & 4) {
#line 2563
        if (hstat.statcode == 500) {
#line 2566
          got_head = (_Bool)1;
#line 2567
          goto __Cont;
        } else
#line 2563
        if (hstat.statcode == 501) {
#line 2566
          got_head = (_Bool)1;
#line 2567
          goto __Cont;
        } else {
#line 2563
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 2571
      if (opt.spider) {
#line 2574
        if (! hurl___0) {
          {
#line 2575
          hurl___0 = url_string((struct url  const  *)u, (enum url_auth_mode )1);
          }
        }
        {
#line 2576
        nonexisting_url((char const   *)hurl___0);
#line 2577
        tmp___20 = gettext("Remote file does not exist -- broken link!!!\n");
#line 2577
        logprintf((enum log_options )1, (char const   *)tmp___20);
        }
      } else {
        {
#line 2582
        tmp___21 = escnonprint((char const   *)hstat.error);
#line 2582
        tmp___22 = gettext("%s ERROR %d: %s.\n");
#line 2582
        logprintf((enum log_options )1, (char const   *)tmp___22, tms, hstat.statcode,
                  tmp___21);
        }
      }
      {
#line 2585
      logputs((enum log_options )0, "\n");
#line 2586
      ret = (uerr_t )34;
      }
#line 2587
      if (! (! hurl___0)) {
        {
#line 2587
        checking_free((void *)hurl___0);
        }
      }
#line 2588
      goto exit;
    }
#line 2592
    if (! got_head) {
#line 2594
      got_head = (_Bool)1;
#line 2596
      if (opt.timestamping) {
#line 2596
        if (! hstat.remote_time) {
          {
#line 2598
          tmp___23 = gettext("Last-modified header missing -- time-stamps turned off.\n");
#line 2598
          logputs((enum log_options )1, (char const   *)tmp___23);
          }
        } else {
#line 2596
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 2601
      if (hstat.remote_time) {
        {
#line 2604
        tmr = http_atotm((char const   *)hstat.remote_time);
        }
#line 2605
        if (tmr == -1L) {
          {
#line 2606
          tmp___24 = gettext("Last-modified header invalid -- time-stamp ignored.\n");
#line 2606
          logputs((enum log_options )0, (char const   *)tmp___24);
          }
        }
#line 2608
        if (*dt & 4) {
#line 2609
          time_came_from_head = (_Bool)1;
        }
      }
#line 2612
      if (send_head_first) {
#line 2615
        if (opt.timestamping) {
#line 2617
          if (hstat.orig_file_name) {
#line 2622
            if (hstat.remote_time) {
#line 2622
              if (tmr != -1L) {
#line 2631
                if (hstat.orig_file_tstamp >= tmr) {
#line 2633
                  if (hstat.contlen == -1L) {
                    {
#line 2636
                    tmp___25 = gettext("Server file no newer than local file `%s\' -- not retrieving.\n\n");
#line 2636
                    logprintf((enum log_options )0, (char const   *)tmp___25, hstat.orig_file_name);
#line 2639
                    ret = (uerr_t )31;
                    }
#line 2640
                    goto exit;
                  } else
#line 2633
                  if (hstat.orig_file_size == hstat.contlen) {
                    {
#line 2636
                    tmp___25 = gettext("Server file no newer than local file `%s\' -- not retrieving.\n\n");
#line 2636
                    logprintf((enum log_options )0, (char const   *)tmp___25, hstat.orig_file_name);
#line 2639
                    ret = (uerr_t )31;
                    }
#line 2640
                    goto exit;
                  } else {
                    {
#line 2644
                    tmp___26 = number_to_static_string(hstat.orig_file_size);
#line 2644
                    tmp___27 = gettext("The sizes do not match (local %s) -- retrieving.\n");
#line 2644
                    logprintf((enum log_options )0, (char const   *)tmp___27, tmp___26);
                    }
                  }
                } else {
                  {
#line 2650
                  tmp___28 = gettext("Remote file is newer, retrieving.\n");
#line 2650
                  logputs((enum log_options )0, (char const   *)tmp___28);
                  }
                }
                {
#line 2653
                logputs((enum log_options )0, "\n");
                }
              }
            }
          }
#line 2658
          hstat.timestamp_checked = (_Bool)1;
        }
#line 2661
        if (opt.spider) {
#line 2663
          if (opt.recursive) {
#line 2665
            if (*dt & 1) {
              {
#line 2667
              tmp___29 = gettext("Remote file exists and could contain links to other resources -- retrieving.\n\n");
#line 2667
              logputs((enum log_options )0, (char const   *)tmp___29);
              }
            } else {
              {
#line 2672
              tmp___30 = gettext("Remote file exists but does not contain any link -- not retrieving.\n\n");
#line 2672
              logprintf((enum log_options )0, (char const   *)tmp___30);
#line 2674
              ret = (uerr_t )31;
              }
#line 2675
              goto exit;
            }
          } else {
#line 2680
            if (*dt & 1) {
              {
#line 2682
              tmp___31 = gettext("Remote file exists and could contain further links,\nbut recursion is disabled -- not retrieving.\n\n");
#line 2682
              logprintf((enum log_options )0, (char const   *)tmp___31);
              }
            } else {
              {
#line 2688
              tmp___32 = gettext("Remote file exists.\n\n");
#line 2688
              logprintf((enum log_options )0, (char const   *)tmp___32);
              }
            }
#line 2691
            ret = (uerr_t )31;
#line 2692
            goto exit;
          }
        }
#line 2696
        got_name = (_Bool)1;
#line 2697
        *dt &= -5;
#line 2698
        count = 0;
#line 2699
        goto __Cont;
      }
    }
#line 2703
    if (tmr != -1L) {
#line 2703
      if (hstat.len == hstat.contlen) {
#line 2703
        goto _L___5;
      } else
#line 2703
      if (hstat.res == 0) {
#line 2703
        if (hstat.contlen == -1L) {
          _L___5: /* CIL Label */ 
#line 2709
          fl = (char const   *)((void *)0);
#line 2710
          if (opt.output_document) {
#line 2712
            if (output_stream_regular) {
#line 2713
              fl = (char const   *)opt.output_document;
            }
          } else {
#line 2716
            fl = (char const   *)hstat.local_file;
          }
#line 2717
          if (fl) {
#line 2719
            newtmr = (time_t )-1;
#line 2721
            if (time_came_from_head) {
#line 2721
              if (hstat.remote_time) {
#line 2721
                if (*(hstat.remote_time + 0)) {
                  {
#line 2724
                  newtmr = http_atotm((char const   *)hstat.remote_time);
                  }
#line 2725
                  if (newtmr != -1L) {
#line 2726
                    tmr = newtmr;
                  }
                }
              }
            }
            {
#line 2728
            touch(fl, tmr);
            }
          }
        }
      }
    }
    {
#line 2733
    tmrate = retr_rate(hstat.rd_size, hstat.dltime);
#line 2734
    total_download_time += hstat.dltime;
    }
#line 2736
    if (hstat.len == hstat.contlen) {
#line 2738
      if (*dt & 2) {
        {
#line 2740
        tmp___33 = number_to_static_string(hstat.contlen);
#line 2740
        tmp___34 = number_to_static_string(hstat.len);
#line 2740
        tmp___35 = gettext("%s (%s) - `%s\' saved [%s/%s]\n\n");
#line 2740
        logprintf((enum log_options )0, (char const   *)tmp___35, tms, tmrate, hstat.local_file,
                  tmp___34, tmp___33);
#line 2745
        tmp___36 = number_to_static_string(hstat.contlen);
#line 2745
        tmp___37 = number_to_static_string(hstat.len);
#line 2745
        logprintf((enum log_options )2, "%s URL:%s [%s/%s] -> \"%s\" [%d]\n", tms,
                  u->url, tmp___37, tmp___36, hstat.local_file, count);
        }
      }
#line 2752
      (opt.numurls) ++;
#line 2753
      total_downloaded_bytes += hstat.len;
#line 2756
      if (*dt & 32) {
        {
#line 2757
        downloaded_file((downloaded_file_t )2, (char const   *)hstat.local_file);
        }
      } else {
        {
#line 2759
        downloaded_file((downloaded_file_t )1, (char const   *)hstat.local_file);
        }
      }
#line 2761
      ret = (uerr_t )31;
#line 2762
      goto exit;
    } else
#line 2764
    if (hstat.res == 0) {
#line 2766
      if (hstat.contlen == -1L) {
#line 2769
        if (*dt & 2) {
          {
#line 2771
          tmp___38 = number_to_static_string(hstat.len);
#line 2771
          tmp___39 = gettext("%s (%s) - `%s\' saved [%s]\n\n");
#line 2771
          logprintf((enum log_options )0, (char const   *)tmp___39, tms, tmrate, hstat.local_file,
                    tmp___38);
#line 2775
          tmp___40 = number_to_static_string(hstat.len);
#line 2775
          logprintf((enum log_options )2, "%s URL:%s [%s] -> \"%s\" [%d]\n", tms,
                    u->url, tmp___40, hstat.local_file, count);
          }
        }
#line 2780
        (opt.numurls) ++;
#line 2781
        total_downloaded_bytes += hstat.len;
#line 2784
        if (*dt & 32) {
          {
#line 2785
          downloaded_file((downloaded_file_t )2, (char const   *)hstat.local_file);
          }
        } else {
          {
#line 2787
          downloaded_file((downloaded_file_t )1, (char const   *)hstat.local_file);
          }
        }
#line 2789
        ret = (uerr_t )31;
#line 2790
        goto exit;
      } else
#line 2792
      if (hstat.len < hstat.contlen) {
        {
#line 2795
        tmp___41 = number_to_static_string(hstat.len);
#line 2795
        tmp___42 = gettext("%s (%s) - Connection closed at byte %s. ");
#line 2795
        logprintf((enum log_options )0, (char const   *)tmp___42, tms, tmrate, tmp___41);
#line 2798
        printwhat(count, opt.ntry);
        }
#line 2799
        goto __Cont;
      } else
#line 2801
      if (hstat.len != hstat.restval) {
        {
#line 2804
        abort();
        }
      } else {
#line 2810
        ret = (uerr_t )31;
#line 2811
        goto exit;
      }
    } else
#line 2816
    if (hstat.contlen == -1L) {
      {
#line 2818
      tmp___43 = number_to_static_string(hstat.len);
#line 2818
      tmp___44 = gettext("%s (%s) - Read error at byte %s (%s).");
#line 2818
      logprintf((enum log_options )0, (char const   *)tmp___44, tms, tmrate, tmp___43,
                hstat.rderrmsg);
#line 2822
      printwhat(count, opt.ntry);
      }
#line 2823
      goto __Cont;
    } else {
      {
#line 2827
      tmp___45 = number_to_static_string(hstat.contlen);
#line 2827
      tmp___46 = number_to_static_string(hstat.len);
#line 2827
      tmp___47 = gettext("%s (%s) - Read error at byte %s/%s (%s). ");
#line 2827
      logprintf((enum log_options )0, (char const   *)tmp___47, tms, tmrate, tmp___46,
                tmp___45, hstat.rderrmsg);
#line 2833
      printwhat(count, opt.ntry);
      }
#line 2834
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 2419
    if (! (! opt.ntry)) {
#line 2419
      if (! (count < opt.ntry)) {
#line 2419
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit: 
#line 2842
  if ((unsigned int )ret == 31U) {
    {
#line 2843
    *local_file = checking_strdup((char const   *)hstat.local_file);
    }
  }
  {
#line 2844
  free_hstat(& hstat);
  }
#line 2846
  return (ret);
}
}
#line 2857 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool check_end(char const   *p___0 ) 
{ 


  {
#line 2860
  if (! p___0) {
#line 2861
    return ((_Bool)0);
  }
  {
#line 2862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2862
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 2862
      goto while_break;
    }
#line 2863
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2864
  if (! *p___0) {
#line 2867
    return ((_Bool)1);
  } else
#line 2864
  if ((int const   )*(p___0 + 0) == 71) {
#line 2864
    if ((int const   )*(p___0 + 1) == 77) {
#line 2864
      if ((int const   )*(p___0 + 2) == 84) {
#line 2867
        return ((_Bool)1);
      } else {
#line 2864
        goto _L___1;
      }
    } else {
#line 2864
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2864
  if ((int const   )*(p___0 + 0) == 43) {
#line 2864
    goto _L;
  } else
#line 2864
  if ((int const   )*(p___0 + 0) == 45) {
    _L: /* CIL Label */ 
#line 2864
    if ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 4) {
#line 2867
      return ((_Bool)1);
    } else {
#line 2869
      return ((_Bool)0);
    }
  } else {
#line 2869
    return ((_Bool)0);
  }
}
}
#line 2908 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char const   *time_formats[4]  = {      "%a, %d %b %Y %T",      "%A, %d-%b-%y %T",      "%a %b %d %T %Y",      "%a, %d-%b-%Y %T"};
#line 2900 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
time_t http_atotm(char const   *time_string ) 
{ 
  char const   *oldlocale ;
  int i ;
  time_t ret ;
  char *tmp ;
  struct tm t ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 2918
  ret = (time_t )-1;
#line 2923
  tmp = setlocale(2, (char const   *)((void *)0));
#line 2923
  oldlocale = (char const   *)tmp;
#line 2924
  setlocale(2, "C");
#line 2926
  i = 0;
  }
  {
#line 2926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2926
    if (! ((unsigned long )i < sizeof(time_formats) / sizeof(time_formats[0]))) {
#line 2926
      goto while_break;
    }
    {
#line 2933
    memset((void *)(& t), '\000', sizeof(t));
#line 2935
    tmp___0 = strptime((char const   */* __restrict  */)time_string, (char const   */* __restrict  */)time_formats[i],
                       & t);
#line 2935
    tmp___1 = check_end((char const   *)tmp___0);
    }
#line 2935
    if (tmp___1) {
      {
#line 2937
      ret = timegm(& t);
      }
#line 2938
      goto while_break;
    }
#line 2926
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2943
  setlocale(2, oldlocale);
  }
#line 2945
  return (ret);
}
}
#line 2966 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *basic_authentication_encode(char const   *user , char const   *passwd ) 
{ 
  char *t1 ;
  char *t2 ;
  int len1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 2970
  tmp = strlen(user);
#line 2970
  tmp___0 = strlen(passwd);
#line 2970
  len1 = (int )((tmp + 1UL) + tmp___0);
#line 2972
  tmp___1 = __builtin_alloca((unsigned long )(len1 + 1));
#line 2972
  t1 = (char *)tmp___1;
#line 2973
  sprintf((char */* __restrict  */)t1, (char const   */* __restrict  */)"%s:%s", user,
          passwd);
#line 2975
  tmp___2 = __builtin_alloca((unsigned long )(4 * ((len1 + 2) / 3) + 1));
#line 2975
  t2 = (char *)tmp___2;
#line 2976
  base64_encode((void const   *)t1, len1, t2);
#line 2978
  tmp___3 = concat_strings("Basic ", t2, (char *)0);
  }
#line 2978
  return (tmp___3);
}
}
#line 2991 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void dump_hash(char *buf___4 , unsigned char const   *hash ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2996
  i = 0;
  {
#line 2996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2996
    if (! (i < 16)) {
#line 2996
      goto while_break;
    }
#line 2998
    tmp = buf___4;
#line 2998
    buf___4 ++;
#line 2998
    *tmp = (char )((int const   )*("0123456789abcdef" + ((int const   )*hash >> 4)));
#line 2999
    tmp___0 = buf___4;
#line 2999
    buf___4 ++;
#line 2999
    *tmp___0 = (char )((int const   )*("0123456789abcdef" + ((int const   )*hash & 15)));
#line 2996
    i ++;
#line 2996
    hash ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3001
  *buf___4 = (char )'\000';
#line 3002
  return;
}
}
#line 3011 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *realm  ;
#line 3011 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *opaque  ;
#line 3011 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *nonce  ;
#line 3012
static char *digest_authentication_encode(char const   *au , char const   *user ,
                                          char const   *passwd , char const   *method ,
                                          char const   *path ) ;
#line 3012 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static struct __anonstruct_options_68445535 options[3]  = {      {"realm", & realm}, 
        {"opaque", & opaque}, 
        {"nonce", & nonce}};
#line 3006 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *digest_authentication_encode(char const   *au , char const   *user ,
                                          char const   *passwd , char const   *method ,
                                          char const   *path ) 
{ 
  char *res___0 ;
  param_token name ;
  param_token value ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  gen_md5_context *ctx ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned char hash[16] ;
  char a1buf[33] ;
  char a2buf[33] ;
  char response_digest[33] ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  char *p___0 ;
  size_t tmp___18 ;

  {
#line 3023
  nonce = (char *)((void *)0);
#line 3023
  opaque = nonce;
#line 3023
  realm = opaque;
#line 3025
  au += 6;
  {
#line 3026
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3026
    tmp___1 = extract_param(& au, & name, & value, (char )',');
    }
#line 3026
    if (! tmp___1) {
#line 3026
      goto while_break;
    }
#line 3029
    i = 0;
    {
#line 3029
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3029
      if (! ((unsigned long )i < sizeof(options) / sizeof(options[0]))) {
#line 3029
        goto while_break___0;
      }
      {
#line 3030
      tmp = strlen(options[i].name);
      }
#line 3030
      if ((size_t )(name.e - name.b) == tmp) {
        {
#line 3030
        tmp___0 = strncmp(name.b, options[i].name, (size_t )(name.e - name.b));
        }
#line 3030
        if (0 == tmp___0) {
          {
#line 3033
          *(options[i].variable) = strdupdelim(value.b, value.e);
          }
#line 3034
          goto while_break___0;
        }
      }
#line 3029
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3037
  if (! realm) {
#line 3037
    goto _L;
  } else
#line 3037
  if (! nonce) {
#line 3037
    goto _L;
  } else
#line 3037
  if (! user) {
#line 3037
    goto _L;
  } else
#line 3037
  if (! passwd) {
#line 3037
    goto _L;
  } else
#line 3037
  if (! path) {
#line 3037
    goto _L;
  } else
#line 3037
  if (! method) {
    _L: /* CIL Label */ 
#line 3039
    if (! (! realm)) {
      {
#line 3039
      checking_free((void *)realm);
      }
    }
#line 3040
    if (! (! opaque)) {
      {
#line 3040
      checking_free((void *)opaque);
      }
    }
#line 3041
    if (! (! nonce)) {
      {
#line 3041
      checking_free((void *)nonce);
      }
    }
#line 3042
    return ((char *)((void *)0));
  }
  {
#line 3047
  tmp___2 = gen_md5_context_size();
#line 3047
  tmp___3 = __builtin_alloca((unsigned long )tmp___2);
#line 3047
  ctx = (gen_md5_context *)tmp___3;
#line 3053
  gen_md5_init(ctx);
#line 3054
  tmp___4 = strlen(user);
#line 3054
  gen_md5_update((unsigned char const   *)((unsigned char *)user), (int )tmp___4,
                 ctx);
#line 3055
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 3056
  tmp___5 = strlen((char const   *)realm);
#line 3056
  gen_md5_update((unsigned char const   *)((unsigned char *)realm), (int )tmp___5,
                 ctx);
#line 3057
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 3058
  tmp___6 = strlen(passwd);
#line 3058
  gen_md5_update((unsigned char const   *)((unsigned char *)passwd), (int )tmp___6,
                 ctx);
#line 3059
  gen_md5_finish(ctx, hash);
#line 3060
  dump_hash(a1buf, (unsigned char const   *)(hash));
#line 3063
  gen_md5_init(ctx);
#line 3064
  tmp___7 = strlen(method);
#line 3064
  gen_md5_update((unsigned char const   *)((unsigned char *)method), (int )tmp___7,
                 ctx);
#line 3065
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 3066
  tmp___8 = strlen(path);
#line 3066
  gen_md5_update((unsigned char const   *)((unsigned char *)path), (int )tmp___8,
                 ctx);
#line 3067
  gen_md5_finish(ctx, hash);
#line 3068
  dump_hash(a2buf, (unsigned char const   *)(hash));
#line 3071
  gen_md5_init(ctx);
#line 3072
  gen_md5_update((unsigned char const   *)((unsigned char *)(a1buf)), 32, ctx);
#line 3073
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 3074
  tmp___9 = strlen((char const   *)nonce);
#line 3074
  gen_md5_update((unsigned char const   *)((unsigned char *)nonce), (int )tmp___9,
                 ctx);
#line 3075
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 3076
  gen_md5_update((unsigned char const   *)((unsigned char *)(a2buf)), 32, ctx);
#line 3077
  gen_md5_finish(ctx, hash);
#line 3078
  dump_hash(response_digest, (unsigned char const   *)(hash));
#line 3080
  tmp___10 = strlen(user);
#line 3080
  tmp___11 = strlen(user);
#line 3080
  tmp___12 = strlen((char const   *)realm);
#line 3080
  tmp___13 = strlen((char const   *)nonce);
#line 3080
  tmp___14 = strlen(path);
  }
#line 3080
  if (opaque) {
    {
#line 3080
    tmp___15 = strlen((char const   *)opaque);
#line 3080
    tmp___16 = tmp___15;
    }
  } else {
#line 3080
    tmp___16 = (size_t )0;
  }
  {
#line 3080
  tmp___17 = checking_malloc(((((((tmp___10 + tmp___11) + tmp___12) + tmp___13) + tmp___14) + 32UL) + tmp___16) + 128UL);
#line 3080
  res___0 = (char *)tmp___17;
#line 3088
  sprintf((char */* __restrict  */)res___0, (char const   */* __restrict  */)"Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"",
          user, realm, nonce, path, response_digest);
  }
#line 3091
  if (opaque) {
    {
#line 3093
    tmp___18 = strlen((char const   *)res___0);
#line 3093
    p___0 = res___0 + tmp___18;
#line 3094
    strcat((char */* __restrict  */)p___0, (char const   */* __restrict  */)", opaque=\"");
#line 3095
    strcat((char */* __restrict  */)p___0, (char const   */* __restrict  */)opaque);
#line 3096
    strcat((char */* __restrict  */)p___0, (char const   */* __restrict  */)"\"");
    }
  }
#line 3099
  return (res___0);
}
}
#line 3116 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static _Bool known_authentication_scheme_p(char const   *hdrbeg , char const   *hdrend ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3119
  if ((unsigned long )(hdrend - hdrbeg) >= sizeof("Basic") - 1UL) {
    {
#line 3119
    tmp = strncasecmp(hdrbeg, "Basic", sizeof("Basic") - 1UL);
    }
#line 3119
    if (0 == tmp) {
#line 3119
      if ((unsigned long )(hdrend - hdrbeg) == sizeof("Basic") - 1UL) {
#line 3119
        tmp___2 = 1;
      } else
#line 3119
      if ((int const   )_sch_istable[(int const   )*(hdrbeg + (sizeof("Basic") - 1UL)) & 255] & 64) {
#line 3119
        tmp___2 = 1;
      } else {
#line 3119
        goto _L___2;
      }
    } else {
#line 3119
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3119
  if ((unsigned long )(hdrend - hdrbeg) >= sizeof("Digest") - 1UL) {
    {
#line 3119
    tmp___0 = strncasecmp(hdrbeg, "Digest", sizeof("Digest") - 1UL);
    }
#line 3119
    if (0 == tmp___0) {
#line 3119
      if ((unsigned long )(hdrend - hdrbeg) == sizeof("Digest") - 1UL) {
#line 3119
        tmp___2 = 1;
      } else
#line 3119
      if ((int const   )_sch_istable[(int const   )*(hdrbeg + (sizeof("Digest") - 1UL)) & 255] & 64) {
#line 3119
        tmp___2 = 1;
      } else {
#line 3119
        goto _L___0;
      }
    } else {
#line 3119
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3119
  if ((unsigned long )(hdrend - hdrbeg) >= sizeof("NTLM") - 1UL) {
    {
#line 3119
    tmp___1 = strncasecmp(hdrbeg, "NTLM", sizeof("NTLM") - 1UL);
    }
#line 3119
    if (0 == tmp___1) {
#line 3119
      if ((unsigned long )(hdrend - hdrbeg) == sizeof("NTLM") - 1UL) {
#line 3119
        tmp___2 = 1;
      } else
#line 3119
      if ((int const   )_sch_istable[(int const   )*(hdrbeg + (sizeof("NTLM") - 1UL)) & 255] & 64) {
#line 3119
        tmp___2 = 1;
      } else {
#line 3119
        tmp___2 = 0;
      }
    } else {
#line 3119
      tmp___2 = 0;
    }
  } else {
#line 3119
    tmp___2 = 0;
  }
#line 3119
  return ((_Bool )tmp___2);
}
}
#line 3136 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static char *create_authorization_line(char const   *au , char const   *user , char const   *passwd ,
                                       char const   *method , char const   *path ,
                                       _Bool *finished ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 3145
  if ((int const   )_sch_toupper[(int const   )*au & 255] == 66) {
#line 3145
    goto case_66;
  }
#line 3149
  if ((int const   )_sch_toupper[(int const   )*au & 255] == 68) {
#line 3149
    goto case_68;
  }
#line 3154
  if ((int const   )_sch_toupper[(int const   )*au & 255] == 78) {
#line 3154
    goto case_78;
  }
#line 3162
  goto switch_default;
  case_66: /* CIL Label */ 
  {
#line 3146
  *finished = (_Bool)1;
#line 3147
  tmp = basic_authentication_encode(user, passwd);
  }
#line 3147
  return (tmp);
  case_68: /* CIL Label */ 
  {
#line 3150
  *finished = (_Bool)1;
#line 3151
  tmp___0 = digest_authentication_encode(au, user, passwd, method, path);
  }
#line 3151
  return (tmp___0);
  case_78: /* CIL Label */ 
  {
#line 3155
  tmp___1 = ntlm_input(& pconn.ntlm, au);
  }
#line 3155
  if (! tmp___1) {
#line 3157
    *finished = (_Bool)1;
#line 3158
    return ((char *)((void *)0));
  }
  {
#line 3160
  tmp___2 = ntlm_output(& pconn.ntlm, user, passwd, finished);
  }
#line 3160
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 3165
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3169 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
static void load_cookies(void) 
{ 


  {
#line 3172
  if (! wget_cookie_jar) {
    {
#line 3173
    wget_cookie_jar = cookie_jar_new();
    }
  }
#line 3174
  if (opt.cookies_input) {
#line 3174
    if (! cookies_loaded_p) {
      {
#line 3176
      cookie_jar_load(wget_cookie_jar, (char const   *)opt.cookies_input);
#line 3177
      cookies_loaded_p = (_Bool)1;
      }
    }
  }
#line 3179
  return;
}
}
#line 3181 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
void save_cookies(void) 
{ 


  {
#line 3184
  if (wget_cookie_jar) {
    {
#line 3185
    cookie_jar_save(wget_cookie_jar, (char const   *)opt.cookies_output);
    }
  }
#line 3186
  return;
}
}
#line 3188 "/home/khheo/project/benchmark/wget-1.11.4/src/http.c"
void http_cleanup(void) 
{ 


  {
#line 3191
  if (! (! pconn.host)) {
    {
#line 3191
    checking_free((void *)pconn.host);
    }
  }
#line 3192
  if (wget_cookie_jar) {
    {
#line 3193
    cookie_jar_delete(wget_cookie_jar);
    }
  }
#line 3194
  return;
}
}
#line 90 "/usr/include/openssl/des.h"
extern void DES_ecb_encrypt(const_DES_cblock *input , DES_cblock *output , DES_key_schedule *ks ,
                            int enc ) ;
#line 146
extern void DES_set_odd_parity(DES_cblock *key ) ;
#line 154
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 40 "/usr/include/openssl/md4.h"
extern int MD4_Init(MD4_CTX *c ) ;
#line 41
extern int MD4_Update(MD4_CTX *c , void const   *data , size_t len ) ;
#line 42
extern int MD4_Final(unsigned char *md , MD4_CTX *c ) ;
#line 118 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
_Bool ntlm_input(struct ntlmdata *ntlm , char const   *header ) 
{ 
  int tmp ;
  int size ;
  char *buffer___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 121
  tmp = strncmp(header, "NTLM", (size_t )4);
  }
#line 121
  if (0 != tmp) {
#line 122
    return ((_Bool)0);
  }
#line 124
  header += 4;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (*header) {
#line 125
      if (! ((int const   )_sch_istable[(int const   )*header & 255] & 64)) {
#line 125
        goto while_break;
      }
    } else {
#line 125
      goto while_break;
    }
#line 126
    header ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (*header) {
    {
#line 144
    tmp___0 = strlen(header);
#line 144
    tmp___1 = __builtin_alloca(tmp___0);
#line 144
    buffer___0 = (char *)tmp___1;
    }
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 146
      tmp___2 = __builtin_expect((long )opt.debug, 0L);
      }
#line 146
      if (tmp___2) {
        {
#line 146
        debug_logprintf("Received a type-2 NTLM message.\n");
        }
      }
#line 146
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 148
    size = base64_decode(header, (void *)buffer___0);
    }
#line 149
    if (size < 0) {
#line 150
      return ((_Bool)0);
    }
#line 152
    ntlm->state = (wgetntlm )2;
#line 154
    if (size >= 48) {
      {
#line 156
      memcpy((void */* __restrict  */)(ntlm->nonce), (void const   */* __restrict  */)(buffer___0 + 24),
             (size_t )8);
      }
    }
  } else {
#line 162
    if ((unsigned int )ntlm->state >= 1U) {
      {
#line 164
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 164
        tmp___3 = __builtin_expect((long )opt.debug, 0L);
        }
#line 164
        if (tmp___3) {
          {
#line 164
          debug_logprintf("Unexpected empty NTLM message.\n");
          }
        }
#line 164
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 165
      return ((_Bool)0);
    }
    {
#line 168
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 168
      tmp___4 = __builtin_expect((long )opt.debug, 0L);
      }
#line 168
      if (tmp___4) {
        {
#line 168
        debug_logprintf("Empty NTLM message, starting transaction.\n");
        }
      }
#line 168
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 169
    ntlm->state = (wgetntlm )1;
  }
#line 172
  return ((_Bool)1);
}
}
#line 179 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
static void setup_des_key(unsigned char *key_56 , DES_key_schedule *ks ) 
{ 
  DES_cblock key ;

  {
  {
#line 185
  key[0] = *(key_56 + 0);
#line 186
  key[1] = (unsigned char )((((int )*(key_56 + 0) << 7) & 255) | ((int )*(key_56 + 1) >> 1));
#line 187
  key[2] = (unsigned char )((((int )*(key_56 + 1) << 6) & 255) | ((int )*(key_56 + 2) >> 2));
#line 188
  key[3] = (unsigned char )((((int )*(key_56 + 2) << 5) & 255) | ((int )*(key_56 + 3) >> 3));
#line 189
  key[4] = (unsigned char )((((int )*(key_56 + 3) << 4) & 255) | ((int )*(key_56 + 4) >> 4));
#line 190
  key[5] = (unsigned char )((((int )*(key_56 + 4) << 3) & 255) | ((int )*(key_56 + 5) >> 5));
#line 191
  key[6] = (unsigned char )((((int )*(key_56 + 5) << 2) & 255) | ((int )*(key_56 + 6) >> 6));
#line 192
  key[7] = (unsigned char )(((int )*(key_56 + 6) << 1) & 255);
#line 194
  DES_set_odd_parity(& key);
#line 195
  DES_set_key(& key, ks);
  }
#line 196
  return;
}
}
#line 203 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
static void calc_resp(unsigned char *keys , unsigned char *plaintext , unsigned char *results ) 
{ 
  DES_key_schedule ks ;

  {
  {
#line 208
  setup_des_key(keys, & ks);
#line 209
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)results, & ks, 1);
#line 212
  setup_des_key(keys + 7, & ks);
#line 213
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)(results + 8), & ks, 1);
#line 216
  setup_des_key(keys + 14, & ks);
#line 217
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)(results + 16), & ks, 1);
  }
#line 219
  return;
}
}
#line 238
static void mkhash(char const   *password , unsigned char *nonce___0 , unsigned char *lmresp ,
                   unsigned char *ntresp ) ;
#line 238 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
static unsigned char const   magic[8]  = 
#line 238
  {      (unsigned char const   )75,      (unsigned char const   )71,      (unsigned char const   )83,      (unsigned char const   )33, 
        (unsigned char const   )64,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37};
#line 224 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
static void mkhash(char const   *password , unsigned char *nonce___0 , unsigned char *lmresp ,
                   unsigned char *ntresp ) 
{ 
  unsigned char lmbuffer[21] ;
  unsigned char ntbuffer[21] ;
  unsigned char *pw ;
  int i ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  DES_key_schedule ks ;
  MD4_CTX MD4___0 ;
  size_t tmp___2 ;

  {
  {
#line 242
  tmp = strlen(password);
#line 242
  len = (int )tmp;
  }
#line 245
  if (len < 7) {
#line 245
    tmp___0 = 14;
  } else {
#line 245
    tmp___0 = len * 2;
  }
  {
#line 245
  tmp___1 = __builtin_alloca((unsigned long )tmp___0);
#line 245
  pw = (unsigned char *)tmp___1;
  }
#line 247
  if (len > 14) {
#line 248
    len = 14;
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < len)) {
#line 250
      goto while_break;
    }
#line 251
    *(pw + i) = (unsigned char )_sch_toupper[(int const   )*(password + i) & 255];
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! (i < 14)) {
#line 253
      goto while_break___0;
    }
#line 254
    *(pw + i) = (unsigned char)0;
#line 253
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 260
  setup_des_key(pw, & ks);
#line 261
  DES_ecb_encrypt((DES_cblock *)(magic), (DES_cblock *)(lmbuffer), & ks, 1);
#line 264
  setup_des_key(pw + 7, & ks);
#line 265
  DES_ecb_encrypt((DES_cblock *)(magic), (DES_cblock *)(lmbuffer + 8), & ks, 1);
#line 268
  memset((void *)(lmbuffer + 16), 0, (size_t )5);
#line 271
  calc_resp(lmbuffer, nonce___0, lmresp);
#line 278
  tmp___2 = strlen(password);
#line 278
  len = (int )tmp___2;
#line 280
  i = 0;
  }
  {
#line 280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 280
    if (! (i < len)) {
#line 280
      goto while_break___1;
    }
#line 281
    *(pw + 2 * i) = (unsigned char )*(password + i);
#line 282
    *(pw + (2 * i + 1)) = (unsigned char)0;
#line 280
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 285
  MD4_Init(& MD4___0);
#line 286
  MD4_Update(& MD4___0, (void const   *)pw, (size_t )(2 * len));
#line 287
  MD4_Final(ntbuffer, & MD4___0);
#line 289
  memset((void *)(ntbuffer + 16), 0, (size_t )5);
#line 292
  calc_resp(ntbuffer, nonce___0, ntresp);
  }
#line 294
  return;
}
}
#line 301 "/home/khheo/project/benchmark/wget-1.11.4/src/http-ntlm.c"
char *ntlm_output(struct ntlmdata *ntlm , char const   *user , char const   *passwd ,
                  _Bool *ready ) 
{ 
  char const   *domain ;
  char const   *host ;
  int domlen ;
  size_t tmp ;
  int hostlen ;
  size_t tmp___0 ;
  int hostoff ;
  int domoff ;
  int size ;
  char *base64 ;
  char ntlmbuf[256] ;
  char *output___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  int lmrespoff ;
  int ntrespoff ;
  int useroff ;
  unsigned char lmresp[24] ;
  unsigned char ntresp[24] ;
  char const   *usr ;
  int userlen ;
  long tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 305
  domain = "";
#line 306
  host = "";
#line 307
  tmp = strlen(domain);
#line 307
  domlen = (int )tmp;
#line 308
  tmp___0 = strlen(host);
#line 308
  hostlen = (int )tmp___0;
#line 319
  *ready = (_Bool)0;
  }
#line 322
  if (! user) {
#line 323
    user = "";
  }
#line 325
  if (! passwd) {
#line 326
    passwd = "";
  }
  {
#line 389
  if ((unsigned int )ntlm->state == 2U) {
#line 389
    goto case_2;
  }
#line 566
  if ((unsigned int )ntlm->state == 3U) {
#line 566
    goto case_3;
  }
#line 330
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 331
  hostoff = 32;
#line 332
  domoff = hostoff + hostlen;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 334
    tmp___1 = __builtin_expect((long )opt.debug, 0L);
    }
#line 334
    if (tmp___1) {
      {
#line 334
      debug_logprintf("Creating a type-1 NTLM message.\n");
      }
    }
#line 334
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  snprintf((char */* __restrict  */)(ntlmbuf), sizeof(ntlmbuf), (char const   */* __restrict  */)"NTLMSSP%c\001%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%s%s",
           0, 0, 0, 0, ((1 << 1) | (1 << 9)) & 255, (((1 << 1) | (1 << 9)) >> 8) & 255,
           (((1 << 1) | (1 << 9)) >> 16) & 255, ((1 << 1) | (1 << 9)) >> 24, domlen & 255,
           domlen >> 8, domlen & 255, domlen >> 8, domoff & 255, domoff >> 8, 0, 0,
           hostlen & 255, hostlen >> 8, hostlen & 255, hostlen >> 8, hostoff & 255,
           hostoff >> 8, 0, 0, host, domain);
#line 381
  size = (32 + hostlen) + domlen;
#line 383
  tmp___2 = __builtin_alloca((unsigned long )(4 * ((size + 2) / 3) + 1));
#line 383
  base64 = (char *)tmp___2;
#line 384
  base64_encode((void const   *)(ntlmbuf), size, base64);
#line 386
  output___0 = concat_strings("NTLM ", base64, (char *)0);
  }
#line 387
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 418
    tmp___3 = __builtin_expect((long )opt.debug, 0L);
    }
#line 418
    if (tmp___3) {
      {
#line 418
      debug_logprintf("Creating a type-3 NTLM message.\n");
      }
    }
#line 418
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 420
  tmp___4 = strchr(user, '\\');
#line 420
  usr = (char const   *)tmp___4;
  }
#line 421
  if (! usr) {
    {
#line 422
    tmp___5 = strchr(user, '/');
#line 422
    usr = (char const   *)tmp___5;
    }
  }
#line 424
  if (usr) {
#line 425
    domain = user;
#line 426
    domlen = (int )(usr - domain);
#line 427
    usr ++;
  } else {
#line 430
    usr = user;
  }
  {
#line 431
  tmp___6 = strlen(usr);
#line 431
  userlen = (int )tmp___6;
#line 433
  mkhash(passwd, & ntlm->nonce[0], lmresp, ntresp);
#line 439
  domoff = 64;
#line 440
  useroff = domoff + domlen;
#line 441
  hostoff = useroff + userlen;
#line 442
  lmrespoff = hostoff + hostlen;
#line 443
  ntrespoff = lmrespoff + 24;
#line 447
  size = snprintf((char */* __restrict  */)(ntlmbuf), sizeof(ntlmbuf), (char const   */* __restrict  */)"NTLMSSP%c\003%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\377\377%c%c\001\202%c%c",
                  0, 0, 0, 0, 24, 24 >> 8, 24, 24 >> 8, lmrespoff & 255, lmrespoff >> 8,
                  0, 0, 24, 24 >> 8, 24, 24 >> 8, ntrespoff & 255, ntrespoff >> 8,
                  0, 0, domlen & 255, domlen >> 8, domlen & 255, domlen >> 8, domoff & 255,
                  domoff >> 8, 0, 0, userlen & 255, userlen >> 8, userlen & 255, userlen >> 8,
                  useroff & 255, useroff >> 8, 0, 0, hostlen & 255, hostlen >> 8,
                  hostlen & 255, hostlen >> 8, hostoff & 255, hostoff >> 8, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0);
#line 525
  size = 64;
#line 526
  ntlmbuf[63] = (char)0;
#line 526
  ntlmbuf[62] = ntlmbuf[63];
  }
#line 530
  if ((unsigned long )((size + userlen) + domlen) >= sizeof(ntlmbuf)) {
#line 531
    return ((char *)((void *)0));
  }
  {
#line 533
  memcpy((void */* __restrict  */)(& ntlmbuf[size]), (void const   */* __restrict  */)domain,
         (size_t )domlen);
#line 534
  size += domlen;
#line 536
  memcpy((void */* __restrict  */)(& ntlmbuf[size]), (void const   */* __restrict  */)usr,
         (size_t )userlen);
#line 537
  size += userlen;
  }
#line 540
  if (size < (int )sizeof(ntlmbuf) - 24) {
    {
#line 541
    memcpy((void */* __restrict  */)(& ntlmbuf[size]), (void const   */* __restrict  */)(lmresp),
           (size_t )24);
#line 542
    size += 24;
    }
  }
#line 546
  if (size < (int )sizeof(ntlmbuf) - 24) {
    {
#line 547
    memcpy((void */* __restrict  */)(& ntlmbuf[size]), (void const   */* __restrict  */)(ntresp),
           (size_t )24);
#line 548
    size += 24;
    }
  }
  {
#line 552
  ntlmbuf[56] = (char )(size & 255);
#line 553
  ntlmbuf[57] = (char )(size >> 8);
#line 556
  tmp___7 = __builtin_alloca((unsigned long )(4 * ((size + 2) / 3) + 1));
#line 556
  base64 = (char *)tmp___7;
#line 557
  base64_encode((void const   *)(ntlmbuf), size, base64);
#line 559
  output___0 = concat_strings("NTLM ", base64, (char *)0);
#line 561
  ntlm->state = (wgetntlm )3;
#line 562
  *ready = (_Bool)1;
  }
#line 564
  goto switch_break;
  case_3: /* CIL Label */ 
#line 569
  *ready = (_Bool)1;
#line 570
  output___0 = (char *)((void *)0);
#line 571
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 574
  return (output___0);
}
}
#line 64 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.h"
void map_html_tags(char const   *text , int size , void (*mapfun)(struct taginfo * ,
                                                                  void * ) , void *maparg ,
                   int flags , struct hash_table  const  *allowed_tags , struct hash_table  const  *allowed_attributes ) ;
#line 45 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
int hash_table_remove(struct hash_table *ht , void const   *key ) ;
#line 54 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_find_urls(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 55
static void tag_handle_base(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 56
static void tag_handle_form(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 57
static void tag_handle_link(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 58
static void tag_handle_meta(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 87 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static struct known_tag known_tags[22]  = 
#line 87
  {      {0, "a", & tag_find_urls}, 
        {1, "applet", & tag_find_urls}, 
        {2, "area", & tag_find_urls}, 
        {3, "base", & tag_handle_base}, 
        {4, "bgsound", & tag_find_urls}, 
        {5, "body", & tag_find_urls}, 
        {6, "embed", & tag_find_urls}, 
        {7, "fig", & tag_find_urls}, 
        {8, "form", & tag_handle_form}, 
        {9, "frame", & tag_find_urls}, 
        {10, "iframe", & tag_find_urls}, 
        {11, "img", & tag_find_urls}, 
        {12, "input", & tag_find_urls}, 
        {13, "layer", & tag_find_urls}, 
        {14, "link", & tag_handle_link}, 
        {15, "meta", & tag_handle_meta}, 
        {16, "object", & tag_find_urls}, 
        {17, "overlay", & tag_find_urls}, 
        {18, "script", & tag_find_urls}, 
        {19, "table", & tag_find_urls}, 
        {20, "td", & tag_find_urls}, 
        {21, "th", & tag_find_urls}};
#line 135 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static struct __anonstruct_tag_url_attributes_269907105 tag_url_attributes[21]  = 
#line 135
  {      {0, "href", 2}, 
        {1, "code", 1}, 
        {2, "href", 2}, 
        {4, "src", 1}, 
        {5, "background", 1}, 
        {6, "href", 2}, 
        {6, "src", 3}, 
        {7, "src", 1}, 
        {9, "src", 3}, 
        {10, "src", 3}, 
        {11, "href", 1}, 
        {11, "lowsrc", 1}, 
        {11, "src", 1}, 
        {12, "src", 1}, 
        {13, "src", 3}, 
        {16, "data", 1}, 
        {17, "src", 3}, 
        {18, "src", 1}, 
        {19, "background", 1}, 
        {20, "background", 1}, 
        {21, "background", 1}};
#line 166 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static char const   *additional_attributes[5]  = {      "rel",      "http-equiv",      "name",      "content", 
        "action"};
#line 174 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static struct hash_table *interesting_tags  ;
#line 175 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static struct hash_table *interesting_attributes  ;
#line 177 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void init_interesting(void) 
{ 
  int i ;
  char **ignored ;
  struct hash_table *intersect ;
  struct hash_table *tmp ;
  char **followed ;
  struct known_tag *t ;
  void *tmp___0 ;

  {
  {
#line 190
  interesting_tags = make_nocase_string_hash_table((int )(sizeof(known_tags) / sizeof(known_tags[0])));
#line 194
  i = 0;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ((unsigned long )i < sizeof(known_tags) / sizeof(known_tags[0]))) {
#line 194
      goto while_break;
    }
    {
#line 195
    hash_table_put(interesting_tags, (void const   *)known_tags[i].name, (void *)(known_tags + i));
#line 194
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if (opt.ignore_tags) {
#line 201
    ignored = opt.ignore_tags;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! *ignored) {
#line 201
        goto while_break___0;
      }
      {
#line 202
      hash_table_remove(interesting_tags, (void const   *)*ignored);
#line 201
      ignored ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 206
  if (opt.follow_tags) {
    {
#line 210
    tmp = make_nocase_string_hash_table(0);
#line 210
    intersect = tmp;
#line 212
    followed = opt.follow_tags;
    }
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 212
      if (! *followed) {
#line 212
        goto while_break___1;
      }
      {
#line 214
      tmp___0 = hash_table_get((struct hash_table  const  *)interesting_tags, (void const   *)*followed);
#line 214
      t = (struct known_tag *)tmp___0;
      }
#line 215
      if (! t) {
#line 216
        goto __Cont;
      }
      {
#line 217
      hash_table_put(intersect, (void const   *)*followed, (void *)t);
      }
      __Cont: /* CIL Label */ 
#line 212
      followed ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 219
    hash_table_destroy(interesting_tags);
#line 220
    interesting_tags = intersect;
    }
  }
  {
#line 224
  interesting_attributes = make_nocase_string_hash_table(10);
#line 225
  i = 0;
  }
  {
#line 225
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 225
    if (! ((unsigned long )i < sizeof(additional_attributes) / sizeof(additional_attributes[0]))) {
#line 225
      goto while_break___2;
    }
    {
#line 226
    hash_table_put(interesting_attributes, (void const   *)additional_attributes[i],
                   (void *)"1");
#line 225
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 227
    if (! ((unsigned long )i < sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]))) {
#line 227
      goto while_break___3;
    }
    {
#line 228
    hash_table_put(interesting_attributes, (void const   *)tag_url_attributes[i].attr_name,
                   (void *)"1");
#line 227
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 236 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static char *find_attr(struct taginfo *tag , char const   *name , int *attrind ) 
{ 
  int i ;
  int tmp ;

  {
#line 240
  i = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i < tag->nattrs)) {
#line 240
      goto while_break;
    }
    {
#line 241
    tmp = strcasecmp((char const   *)(tag->attrs + i)->name, name);
    }
#line 241
    if (! tmp) {
#line 243
      if (attrind) {
#line 244
        *attrind = i;
      }
#line 245
      return ((tag->attrs + i)->value);
    }
#line 240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return ((char *)((void *)0));
}
}
#line 269 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static struct urlpos *append_url(char const   *link_uri , struct taginfo *tag , int attrind ,
                                 struct map_context *ctx ) 
{ 
  int link_has_scheme ;
  _Bool tmp ;
  struct urlpos *newel ;
  char const   *base ;
  char const   *tmp___0 ;
  struct url *url ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  char *complete_uri ;
  char *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct urlpos *tmp___9 ;

  {
  {
#line 273
  tmp = url_has_scheme(link_uri);
#line 273
  link_has_scheme = (int )tmp;
  }
#line 275
  if (ctx->base) {
#line 275
    tmp___0 = (char const   *)ctx->base;
  } else {
#line 275
    tmp___0 = ctx->parent_base;
  }
#line 275
  base = tmp___0;
#line 278
  if (! base) {
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 280
      tmp___1 = __builtin_expect((long )opt.debug, 0L);
      }
#line 280
      if (tmp___1) {
        {
#line 280
        debug_logprintf("%s: no base, merge will use \"%s\".\n", ctx->document_file,
                        link_uri);
        }
      }
#line 280
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 283
    if (! link_has_scheme) {
      {
#line 289
      tmp___2 = gettext("%s: Cannot resolve incomplete link %s.\n");
#line 289
      logprintf((enum log_options )1, (char const   *)tmp___2, ctx->document_file,
                link_uri);
      }
#line 292
      return ((struct urlpos *)((void *)0));
    }
    {
#line 295
    url = url_parse(link_uri, (int *)((void *)0));
    }
#line 296
    if (! url) {
      {
#line 298
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 298
        tmp___3 = __builtin_expect((long )opt.debug, 0L);
        }
#line 298
        if (tmp___3) {
          {
#line 298
          debug_logprintf("%s: link \"%s\" doesn\'t parse.\n", ctx->document_file,
                          link_uri);
          }
        }
#line 298
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 300
      return ((struct urlpos *)((void *)0));
    }
  } else {
    {
#line 309
    tmp___4 = uri_merge(base, link_uri);
#line 309
    complete_uri = tmp___4;
    }
    {
#line 311
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 311
      tmp___5 = __builtin_expect((long )opt.debug, 0L);
      }
#line 311
      if (tmp___5) {
        {
#line 311
        debug_logprintf("%s: merge(\"%s\", \"%s\") -> %s\n", ctx->document_file, base,
                        link_uri, complete_uri);
        }
      }
#line 311
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 314
    url = url_parse((char const   *)complete_uri, (int *)((void *)0));
    }
#line 315
    if (! url) {
      {
#line 317
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 317
        tmp___6 = __builtin_expect((long )opt.debug, 0L);
        }
#line 317
        if (tmp___6) {
          {
#line 317
          debug_logprintf("%s: merged link \"%s\" doesn\'t parse.\n", ctx->document_file,
                          complete_uri);
          }
        }
#line 317
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 319
      checking_free((void *)complete_uri);
      }
#line 320
      return ((struct urlpos *)((void *)0));
    }
    {
#line 322
    checking_free((void *)complete_uri);
    }
  }
  {
#line 325
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 325
    tmp___7 = __builtin_expect((long )opt.debug, 0L);
    }
#line 325
    if (tmp___7) {
      {
#line 325
      debug_logprintf("appending \"%s\" to urlpos.\n", url->url);
      }
    }
#line 325
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 327
  tmp___8 = checking_malloc0(sizeof(struct urlpos ));
#line 327
  newel = (struct urlpos *)tmp___8;
#line 328
  newel->url = url;
#line 329
  newel->pos = (int )((tag->attrs + attrind)->value_raw_beginning - (char const   *)ctx->text);
#line 330
  newel->size = (tag->attrs + attrind)->value_raw_size;
  }
#line 334
  if (! link_has_scheme) {
#line 334
    if ((int const   )*link_uri != 47) {
#line 335
      newel->link_relative_p = 1U;
    } else {
#line 334
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 336
  if (link_has_scheme) {
#line 337
    newel->link_complete_p = 1U;
  }
#line 339
  if (ctx->tail) {
#line 341
    (ctx->tail)->next = newel;
#line 342
    ctx->tail = newel;
  } else {
#line 345
    tmp___9 = newel;
#line 345
    ctx->head = tmp___9;
#line 345
    ctx->tail = tmp___9;
  }
#line 347
  return (newel);
}
}
#line 356 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_find_urls(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int i ;
  int attrind ;
  int first ;
  char *link ;
  int size ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;
  int flags ;
  int tmp___1 ;

  {
#line 360
  first = -1;
#line 362
  i = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((unsigned long )i < sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]))) {
#line 362
      goto while_break;
    }
#line 363
    if (tag_url_attributes[i].tagid == tagid) {
#line 367
      first = i;
#line 368
      goto while_break;
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (! (first != -1)) {
    {
#line 370
    __assert_fail("first != -1", "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c",
                  370U, "tag_find_urls");
    }
  }
#line 381
  attrind = 0;
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    if (! (attrind < tag->nattrs)) {
#line 381
      goto while_break___0;
    }
#line 385
    link = (tag->attrs + attrind)->value;
#line 386
    size = (int )(sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]));
#line 392
    i = first;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (i < size) {
#line 392
        if (! (tag_url_attributes[i].tagid == tagid)) {
#line 392
          goto while_break___1;
        }
      } else {
#line 392
        goto while_break___1;
      }
      {
#line 394
      tmp___1 = strcasecmp((char const   *)(tag->attrs + attrind)->name, tag_url_attributes[i].attr_name);
      }
#line 394
      if (0 == tmp___1) {
        {
#line 397
        tmp___0 = append_url((char const   *)link, tag, attrind, ctx);
#line 397
        up = tmp___0;
        }
#line 398
        if (up) {
#line 400
          flags = tag_url_attributes[i].flags;
#line 401
          if (flags & 1) {
#line 402
            up->link_inline_p = 1U;
          }
#line 403
          if (flags & 2) {
#line 404
            up->link_expect_html = 1U;
          }
        }
      }
#line 392
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 381
    attrind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 409
  return;
}
}
#line 413 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_handle_base(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  struct urlpos *base_urlpos ;
  int attrind ;
  char *newbase ;
  char *tmp ;

  {
  {
#line 418
  tmp = find_attr(tag, "href", & attrind);
#line 418
  newbase = tmp;
  }
#line 419
  if (! newbase) {
#line 420
    return;
  }
  {
#line 422
  base_urlpos = append_url((char const   *)newbase, tag, attrind, ctx);
  }
#line 423
  if (! base_urlpos) {
#line 424
    return;
  }
#line 425
  base_urlpos->ignore_when_downloading = 1U;
#line 426
  base_urlpos->link_base_p = 1U;
#line 428
  if (ctx->base) {
    {
#line 429
    checking_free((void *)ctx->base);
    }
  }
#line 430
  if (ctx->parent_base) {
    {
#line 431
    ctx->base = uri_merge(ctx->parent_base, (char const   *)newbase);
    }
  } else {
    {
#line 433
    ctx->base = checking_strdup((char const   *)newbase);
    }
  }
#line 434
  return;
}
}
#line 438 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_handle_form(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int attrind ;
  char *action ;
  char *tmp ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;

  {
  {
#line 442
  tmp = find_attr(tag, "action", & attrind);
#line 442
  action = tmp;
  }
#line 443
  if (action) {
    {
#line 445
    tmp___0 = append_url((char const   *)action, tag, attrind, ctx);
#line 445
    up = tmp___0;
    }
#line 446
    if (up) {
#line 447
      up->ignore_when_downloading = 1U;
    }
  }
#line 449
  return;
}
}
#line 454 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_handle_link(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int attrind ;
  char *href ;
  char *tmp ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;
  char *rel ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 458
  tmp = find_attr(tag, "href", & attrind);
#line 458
  href = tmp;
  }
#line 466
  if (href) {
    {
#line 468
    tmp___0 = append_url((char const   *)href, tag, attrind, ctx);
#line 468
    up = tmp___0;
    }
#line 469
    if (up) {
      {
#line 471
      tmp___1 = find_attr(tag, "rel", (int *)((void *)0));
#line 471
      rel = tmp___1;
      }
#line 472
      if (rel) {
        {
#line 472
        tmp___2 = strcasecmp((char const   *)rel, "stylesheet");
        }
#line 472
        if (0 == tmp___2) {
#line 475
          up->link_inline_p = 1U;
        } else {
          {
#line 472
          tmp___3 = strcasecmp((char const   *)rel, "shortcut icon");
          }
#line 472
          if (0 == tmp___3) {
#line 475
            up->link_inline_p = 1U;
          } else {
#line 479
            up->link_expect_html = 1U;
          }
        }
      } else {
#line 479
        up->link_expect_html = 1U;
      }
    }
  }
#line 482
  return;
}
}
#line 487 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void tag_handle_meta(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  char *name ;
  char *tmp ;
  char *http_equiv ;
  char *tmp___0 ;
  struct urlpos *entry ;
  int attrind ;
  int timeout ;
  char *p___0 ;
  char *refresh ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *content ;
  char *tmp___3 ;
  char *end ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 490
  tmp = find_attr(tag, "name", (int *)((void *)0));
#line 490
  name = tmp;
#line 491
  tmp___0 = find_attr(tag, "http-equiv", (int *)((void *)0));
#line 491
  http_equiv = tmp___0;
  }
#line 493
  if (http_equiv) {
    {
#line 493
    tmp___9 = strcasecmp((char const   *)http_equiv, "refresh");
    }
#line 493
    if (0 == tmp___9) {
      {
#line 506
      timeout = 0;
#line 509
      tmp___1 = find_attr(tag, "content", & attrind);
#line 509
      refresh = tmp___1;
      }
#line 510
      if (! refresh) {
#line 511
        return;
      }
#line 513
      p___0 = refresh;
      {
#line 513
      while (1) {
        while_continue: /* CIL Label */ ;
#line 513
        if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 4)) {
#line 513
          goto while_break;
        }
#line 514
        timeout = (10 * timeout + (int )*p___0) - 48;
#line 513
        p___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 515
      tmp___2 = p___0;
#line 515
      p___0 ++;
#line 515
      if ((int )*tmp___2 != 59) {
#line 516
        return;
      }
      {
#line 518
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 518
        if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 64)) {
#line 518
          goto while_break___0;
        }
#line 519
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 520
      if ((int const   )_sch_toupper[(int )*p___0 & 255] == 85) {
#line 520
        if ((int const   )_sch_toupper[(int )*(p___0 + 1) & 255] == 82) {
#line 520
          if ((int const   )_sch_toupper[(int )*(p___0 + 2) & 255] == 76) {
#line 520
            if (! ((int )*(p___0 + 3) == 61)) {
#line 524
              return;
            }
          } else {
#line 524
            return;
          }
        } else {
#line 524
          return;
        }
      } else {
#line 524
        return;
      }
#line 525
      p___0 += 4;
      {
#line 526
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 526
        if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 64)) {
#line 526
          goto while_break___1;
        }
#line 527
        p___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 529
      entry = append_url((char const   *)p___0, tag, attrind, ctx);
      }
#line 530
      if (entry) {
#line 532
        entry->link_refresh_p = 1U;
#line 533
        entry->refresh_timeout = timeout;
#line 534
        entry->link_expect_html = 1U;
      }
    } else {
#line 493
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 537
  if (name) {
    {
#line 537
    tmp___8 = strcasecmp((char const   *)name, "robots");
    }
#line 537
    if (0 == tmp___8) {
      {
#line 541
      tmp___3 = find_attr(tag, "content", (int *)((void *)0));
#line 541
      content = tmp___3;
      }
#line 542
      if (! content) {
#line 543
        return;
      }
      {
#line 544
      tmp___7 = strcasecmp((char const   *)content, "none");
      }
#line 544
      if (tmp___7) {
        {
#line 548
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 548
          if (! *content) {
#line 548
            goto while_break___2;
          }
          {
#line 552
          tmp___4 = strchr((char const   *)content, ',');
#line 552
          end = tmp___4;
          }
#line 553
          if (end) {
#line 554
            end ++;
          } else {
            {
#line 556
            tmp___5 = strlen((char const   *)content);
#line 556
            end = content + tmp___5;
            }
          }
          {
#line 557
          tmp___6 = strncasecmp((char const   *)content, "nofollow", (size_t )(end - content));
          }
#line 557
          if (! tmp___6) {
#line 558
            ctx->nofollow = (_Bool)1;
          }
#line 559
          content = end;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 545
        ctx->nofollow = (_Bool)1;
      }
    }
  }
#line 563
  return;
}
}
#line 568 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
static void collect_tags_mapper(struct taginfo *tag , void *arg ) 
{ 
  struct map_context *ctx ;
  struct known_tag *t ;
  void *tmp ;

  {
  {
#line 571
  ctx = (struct map_context *)arg;
#line 575
  tmp = hash_table_get((struct hash_table  const  *)interesting_tags, (void const   *)tag->name);
#line 575
  t = (struct known_tag *)tmp;
  }
#line 576
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 576
    __assert_fail("t != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c",
                  576U, "collect_tags_mapper");
    }
  }
  {
#line 578
  (*(t->handler))(t->tagid, tag, ctx);
  }
#line 579
  return;
}
}
#line 585 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct urlpos *get_urls_html(char const   *file , char const   *url , _Bool *meta_disallow_follow ) 
{ 
  struct file_memory *fm ;
  struct map_context ctx ;
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 593
  fm = read_file(file);
  }
#line 594
  if (! fm) {
    {
#line 596
    tmp = __errno_location();
#line 596
    tmp___0 = strerror(*tmp);
#line 596
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 597
    return ((struct urlpos *)((void *)0));
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 599
    tmp___2 = __builtin_expect((long )opt.debug, 0L);
    }
#line 599
    if (tmp___2) {
      {
#line 599
      tmp___1 = number_to_static_string(fm->length);
#line 599
      debug_logprintf("Loaded %s (size %s).\n", file, tmp___1);
      }
    }
#line 599
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  ctx.text = fm->content;
#line 602
  ctx.tail = (struct urlpos *)((void *)0);
#line 602
  ctx.head = ctx.tail;
#line 603
  ctx.base = (char *)((void *)0);
#line 604
  if (url) {
#line 604
    ctx.parent_base = url;
  } else {
#line 604
    ctx.parent_base = (char const   *)opt.base_href;
  }
#line 605
  ctx.document_file = file;
#line 606
  ctx.nofollow = (_Bool)0;
#line 608
  if (! interesting_tags) {
    {
#line 609
    init_interesting();
    }
  }
#line 618
  flags = 2;
#line 619
  if (opt.strict_comments) {
#line 620
    flags |= 1;
  }
  {
#line 622
  map_html_tags((char const   *)fm->content, (int )fm->length, & collect_tags_mapper,
                (void *)(& ctx), flags, (struct hash_table  const  *)interesting_tags,
                (struct hash_table  const  *)interesting_attributes);
  }
  {
#line 625
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 625
    tmp___3 = __builtin_expect((long )opt.debug, 0L);
    }
#line 625
    if (tmp___3) {
      {
#line 625
      debug_logprintf("no-follow in %s: %d\n", file, (int )ctx.nofollow);
      }
    }
#line 625
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 626
  if (meta_disallow_follow) {
#line 627
    *meta_disallow_follow = ctx.nofollow;
  }
#line 629
  if (! (! ctx.base)) {
    {
#line 629
    checking_free((void *)ctx.base);
    }
  }
  {
#line 630
  read_file_free(fm);
  }
#line 631
  return (ctx.head);
}
}
#line 637 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
struct urlpos *get_urls_file(char const   *file ) 
{ 
  struct file_memory *fm ;
  struct urlpos *head ;
  struct urlpos *tail ;
  char const   *text ;
  char const   *text_end ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  int up_error_code ;
  char *url_text ;
  struct urlpos *entry ;
  struct url *url ;
  char const   *line_beg ;
  char const   *line_end ;
  void *tmp___3 ;
  char *merged ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 645
  fm = read_file(file);
  }
#line 646
  if (! fm) {
    {
#line 648
    tmp = __errno_location();
#line 648
    tmp___0 = strerror(*tmp);
#line 648
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 649
    return ((struct urlpos *)((void *)0));
  }
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 651
    tmp___2 = __builtin_expect((long )opt.debug, 0L);
    }
#line 651
    if (tmp___2) {
      {
#line 651
      tmp___1 = number_to_static_string(fm->length);
#line 651
      debug_logprintf("Loaded %s (size %s).\n", file, tmp___1);
      }
    }
#line 651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  tail = (struct urlpos *)((void *)0);
#line 653
  head = tail;
#line 654
  text = (char const   *)fm->content;
#line 655
  text_end = (char const   *)(fm->content + fm->length);
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 656
    if (! ((unsigned long )text < (unsigned long )text_end)) {
#line 656
      goto while_break___0;
    }
    {
#line 663
    line_beg = text;
#line 664
    tmp___3 = memchr((void const   *)text, '\n', (size_t )(text_end - text));
#line 664
    line_end = (char const   *)tmp___3;
    }
#line 665
    if (! line_end) {
#line 666
      line_end = text_end;
    } else {
#line 668
      line_end ++;
    }
#line 669
    text = line_end;
    {
#line 672
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 672
      if ((unsigned long )line_beg < (unsigned long )line_end) {
#line 672
        if (! ((int const   )_sch_istable[(int const   )*line_beg & 255] & 64)) {
#line 672
          goto while_break___1;
        }
      } else {
#line 672
        goto while_break___1;
      }
#line 673
      line_beg ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 674
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 674
      if ((unsigned long )line_end > (unsigned long )line_beg) {
#line 674
        if (! ((int const   )_sch_istable[(int const   )*(line_end - 1) & 255] & 64)) {
#line 674
          goto while_break___2;
        }
      } else {
#line 674
        goto while_break___2;
      }
#line 675
      line_end --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 677
    if ((unsigned long )line_beg == (unsigned long )line_end) {
#line 678
      goto while_continue___0;
    }
    {
#line 684
    url_text = strdupdelim(line_beg, line_end);
    }
#line 686
    if (opt.base_href) {
      {
#line 689
      tmp___4 = uri_merge((char const   *)opt.base_href, (char const   *)url_text);
#line 689
      merged = tmp___4;
#line 690
      checking_free((void *)url_text);
#line 691
      url_text = merged;
      }
    }
    {
#line 694
    url = url_parse((char const   *)url_text, & up_error_code);
    }
#line 695
    if (! url) {
      {
#line 697
      tmp___5 = url_error(up_error_code);
#line 697
      tmp___6 = gettext("%s: Invalid URL %s: %s\n");
#line 697
      logprintf((enum log_options )1, (char const   *)tmp___6, file, url_text, tmp___5);
#line 699
      checking_free((void *)url_text);
      }
#line 700
      goto while_continue___0;
    }
    {
#line 702
    checking_free((void *)url_text);
#line 704
    tmp___7 = checking_malloc0(sizeof(struct urlpos ));
#line 704
    entry = (struct urlpos *)tmp___7;
#line 705
    entry->url = url;
    }
#line 707
    if (! head) {
#line 708
      head = entry;
    } else {
#line 710
      tail->next = entry;
    }
#line 711
    tail = entry;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 713
  read_file_free(fm);
  }
#line 714
  return (head);
}
}
#line 717 "/home/khheo/project/benchmark/wget-1.11.4/src/html-url.c"
void cleanup_html_url(void) 
{ 


  {
#line 722
  if (interesting_tags) {
    {
#line 723
    hash_table_destroy(interesting_tags);
    }
  }
#line 724
  if (interesting_attributes) {
    {
#line 725
    hash_table_destroy(interesting_attributes);
    }
  }
#line 726
  return;
}
}
#line 283 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
static int decode_entity(char const   **ptr , char const   *end ) 
{ 
  char const   *p___0 ;
  int value ;
  char const   *tmp ;
  int digits ;
  int tmp___0 ;

  {
#line 286
  p___0 = *ptr;
#line 287
  value = -1;
#line 289
  p___0 ++;
#line 289
  if ((unsigned long )p___0 == (unsigned long )end) {
#line 290
    return (-1);
  }
#line 292
  tmp = p___0;
#line 292
  p___0 ++;
  {
#line 294
  if ((int const   )*tmp == 35) {
#line 294
    goto case_35;
  }
#line 315
  if ((int const   )*tmp == 103) {
#line 315
    goto case_103;
  }
#line 319
  if ((int const   )*tmp == 108) {
#line 319
    goto case_108;
  }
#line 323
  if ((int const   )*tmp == 97) {
#line 323
    goto case_97;
  }
#line 330
  if ((int const   )*tmp == 113) {
#line 330
    goto case_113;
  }
#line 292
  goto switch_break;
  case_35: /* CIL Label */ 
#line 297
  digits = 0;
#line 298
  value = 0;
#line 299
  if ((int const   )*p___0 == 120) {
#line 300
    p___0 ++;
    {
#line 300
    while (1) {
      while_continue: /* CIL Label */ ;
#line 300
      if (value < 256) {
#line 300
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 300
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 256)) {
#line 300
            goto while_break;
          }
        } else {
#line 300
          goto while_break;
        }
      } else {
#line 300
        goto while_break;
      }
#line 301
      if ((int const   )*p___0 < 65) {
#line 301
        tmp___0 = (int const   )*p___0 - 48;
      } else {
#line 301
        tmp___0 = ((int const   )_sch_toupper[(int const   )*p___0 & 255] - 65) + 10;
      }
#line 301
      value = (value << 4) + (int )tmp___0;
#line 300
      p___0 ++;
#line 300
      digits ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 303
      if (value < 256) {
#line 303
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 303
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 303
            goto while_break___0;
          }
        } else {
#line 303
          goto while_break___0;
        }
      } else {
#line 303
        goto while_break___0;
      }
#line 304
      value = value * 10 + (int )((int const   )*p___0 - 48);
#line 303
      p___0 ++;
#line 303
      digits ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 305
  if (! digits) {
#line 306
    return (-1);
  }
#line 309
  if (! value) {
#line 310
    return (-1);
  } else
#line 309
  if (value & -128) {
#line 310
    return (-1);
  }
#line 311
  p___0 += 0;
#line 311
  if ((unsigned long )p___0 < (unsigned long )end) {
#line 311
    if ((int const   )*p___0 == 59) {
#line 311
      p___0 ++;
#line 311
      *ptr = p___0;
    } else {
#line 311
      *ptr = p___0;
    }
  } else {
#line 311
    *ptr = p___0;
  }
#line 312
  return (value);
  case_103: /* CIL Label */ 
#line 316
  if ((unsigned long )(p___0 + 1) == (unsigned long )end) {
#line 316
    goto _L;
  } else
#line 316
  if ((unsigned long )(p___0 + 1) < (unsigned long )end) {
#line 316
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 140)) {
      _L: /* CIL Label */ 
#line 316
      if ((int const   )*(p___0 + 0) == 116) {
#line 317
        value = '>';
#line 317
        p___0 ++;
#line 317
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 317
          if ((int const   )*p___0 == 59) {
#line 317
            p___0 ++;
#line 317
            *ptr = p___0;
          } else {
#line 317
            *ptr = p___0;
          }
        } else {
#line 317
          *ptr = p___0;
        }
      }
    }
  }
#line 318
  goto switch_break;
  case_108: /* CIL Label */ 
#line 320
  if ((unsigned long )(p___0 + 1) == (unsigned long )end) {
#line 320
    goto _L___0;
  } else
#line 320
  if ((unsigned long )(p___0 + 1) < (unsigned long )end) {
#line 320
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 1) & 255] & 140)) {
      _L___0: /* CIL Label */ 
#line 320
      if ((int const   )*(p___0 + 0) == 116) {
#line 321
        value = '<';
#line 321
        p___0 ++;
#line 321
        if ((unsigned long )p___0 < (unsigned long )end) {
#line 321
          if ((int const   )*p___0 == 59) {
#line 321
            p___0 ++;
#line 321
            *ptr = p___0;
          } else {
#line 321
            *ptr = p___0;
          }
        } else {
#line 321
          *ptr = p___0;
        }
      }
    }
  }
#line 322
  goto switch_break;
  case_97: /* CIL Label */ 
#line 324
  if ((unsigned long )(p___0 + 2) == (unsigned long )end) {
#line 324
    goto _L___4;
  } else
#line 324
  if ((unsigned long )(p___0 + 2) < (unsigned long )end) {
#line 324
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 2) & 255] & 140)) {
      _L___4: /* CIL Label */ 
#line 324
      if ((int const   )*(p___0 + 0) == 109) {
#line 324
        if ((int const   )*(p___0 + 1) == 112) {
#line 325
          value = '&';
#line 325
          p___0 += 2;
#line 325
          if ((unsigned long )p___0 < (unsigned long )end) {
#line 325
            if ((int const   )*p___0 == 59) {
#line 325
              p___0 ++;
#line 325
              *ptr = p___0;
            } else {
#line 325
              *ptr = p___0;
            }
          } else {
#line 325
            *ptr = p___0;
          }
        } else {
#line 324
          goto _L___5;
        }
      } else {
#line 324
        goto _L___5;
      }
    } else {
#line 324
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 326
  if ((unsigned long )(p___0 + 3) == (unsigned long )end) {
#line 326
    goto _L___1;
  } else
#line 326
  if ((unsigned long )(p___0 + 3) < (unsigned long )end) {
#line 326
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 3) & 255] & 140)) {
      _L___1: /* CIL Label */ 
#line 326
      if ((int const   )*(p___0 + 0) == 112) {
#line 326
        if ((int const   )*(p___0 + 1) == 111) {
#line 326
          if ((int const   )*(p___0 + 2) == 115) {
#line 328
            value = '\'';
#line 328
            p___0 += 3;
#line 328
            if ((unsigned long )p___0 < (unsigned long )end) {
#line 328
              if ((int const   )*p___0 == 59) {
#line 328
                p___0 ++;
#line 328
                *ptr = p___0;
              } else {
#line 328
                *ptr = p___0;
              }
            } else {
#line 328
              *ptr = p___0;
            }
          }
        }
      }
    }
  }
#line 329
  goto switch_break;
  case_113: /* CIL Label */ 
#line 331
  if ((unsigned long )(p___0 + 3) == (unsigned long )end) {
#line 331
    goto _L___6;
  } else
#line 331
  if ((unsigned long )(p___0 + 3) < (unsigned long )end) {
#line 331
    if (! ((int const   )_sch_istable[(int const   )*(p___0 + 3) & 255] & 140)) {
      _L___6: /* CIL Label */ 
#line 331
      if ((int const   )*(p___0 + 0) == 117) {
#line 331
        if ((int const   )*(p___0 + 1) == 111) {
#line 331
          if ((int const   )*(p___0 + 2) == 116) {
#line 332
            value = '\"';
#line 332
            p___0 += 3;
#line 332
            if ((unsigned long )p___0 < (unsigned long )end) {
#line 332
              if ((int const   )*p___0 == 59) {
#line 332
                p___0 ++;
#line 332
                *ptr = p___0;
              } else {
#line 332
                *ptr = p___0;
              }
            } else {
#line 332
              *ptr = p___0;
            }
          }
        }
      }
    }
  }
#line 333
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 335
  return (value);
}
}
#line 362 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
static void convert_and_copy(struct pool *pool , char const   *beg , char const   *end ,
                             int flags ) 
{ 
  int old_tail ;
  char const   *from ;
  char *to ;
  _Bool squash_newlines ;
  long ga_needed_size ;
  long ga_newsize ;
  void *tmp ;
  void *ga_new ;
  void *tmp___0 ;
  int entity ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char PAC_char ;
  long ga_needed_size___0 ;
  long ga_newsize___0 ;
  void *tmp___8 ;
  void *ga_new___0 ;
  void *tmp___9 ;
  int tmp___10 ;
  char const   *PA_beg ;
  int PA_size ;
  long ga_needed_size___1 ;
  long ga_newsize___1 ;
  void *tmp___11 ;
  void *ga_new___1 ;
  void *tmp___12 ;
  char PAC_char___0 ;
  long ga_needed_size___2 ;
  long ga_newsize___2 ;
  void *tmp___13 ;
  void *ga_new___2 ;
  void *tmp___14 ;
  int tmp___15 ;
  char *p___0 ;

  {
#line 365
  old_tail = pool->tail;
#line 370
  if (flags & 4) {
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;
#line 372
      if ((unsigned long )beg < (unsigned long )end) {
#line 372
        if (! ((int const   )_sch_istable[(int const   )*beg & 255] & 64)) {
#line 372
          goto while_break;
        }
      } else {
#line 372
        goto while_break;
      }
#line 373
      beg ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if ((unsigned long )end > (unsigned long )beg) {
#line 374
        if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 374
          goto while_break___0;
        }
      } else {
#line 374
        goto while_break___0;
      }
#line 375
      end --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 378
  if (flags & 2) {
#line 387
    from = beg;
#line 389
    squash_newlines = (_Bool )(! (! (flags & 4)));
    {
#line 391
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 391
      ga_needed_size = (long )pool->tail + (end - beg);
#line 391
      ga_newsize = (long )pool->size;
      {
#line 391
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 391
        if (! (ga_newsize < ga_needed_size)) {
#line 391
          goto while_break___2;
        }
#line 391
        ga_newsize <<= 1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 391
      if (ga_newsize != (long )pool->size) {
#line 391
        if (pool->resized) {
          {
#line 391
          tmp = checking_realloc((void *)pool->contents, (unsigned long )ga_newsize * sizeof(char ));
#line 391
          pool->contents = (char *)tmp;
          }
        } else {
          {
#line 391
          tmp___0 = checking_malloc((unsigned long )ga_newsize * sizeof(char ));
#line 391
          ga_new = tmp___0;
#line 391
          memcpy((void */* __restrict  */)ga_new, (void const   */* __restrict  */)pool->contents,
                 (unsigned long )pool->size * sizeof(char ));
#line 391
          pool->contents = (char *)ga_new;
#line 391
          pool->resized = (_Bool)1;
          }
        }
#line 391
        pool->size = (int )ga_newsize;
      }
#line 391
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 392
    to = pool->contents + pool->tail;
    {
#line 394
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 394
      if (! ((unsigned long )from < (unsigned long )end)) {
#line 394
        goto while_break___3;
      }
#line 396
      if ((int const   )*from == 38) {
        {
#line 398
        tmp___1 = decode_entity(& from, end);
#line 398
        entity = tmp___1;
        }
#line 399
        if (entity != -1) {
#line 400
          tmp___2 = to;
#line 400
          to ++;
#line 400
          *tmp___2 = (char )entity;
        } else {
#line 402
          tmp___3 = to;
#line 402
          to ++;
#line 402
          tmp___4 = from;
#line 402
          from ++;
#line 402
          *tmp___3 = (char )*tmp___4;
        }
      } else
#line 404
      if ((int const   )*from == 10) {
#line 404
        goto _L;
      } else
#line 404
      if ((int const   )*from == 13) {
        _L: /* CIL Label */ 
#line 404
        if (squash_newlines) {
#line 405
          from ++;
        } else {
#line 407
          tmp___5 = to;
#line 407
          to ++;
#line 407
          tmp___6 = from;
#line 407
          from ++;
#line 407
          *tmp___5 = (char )*tmp___6;
        }
      } else {
#line 407
        tmp___5 = to;
#line 407
        to ++;
#line 407
        tmp___6 = from;
#line 407
        from ++;
#line 407
        *tmp___5 = (char )*tmp___6;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 411
    if (! (to - (pool->contents + pool->tail) <= end - beg)) {
      {
#line 411
      __assert_fail("to - (pool->contents + pool->tail) <= end - beg", "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c",
                    411U, "convert_and_copy");
      }
    }
#line 415
    pool->tail = (int )(to - pool->contents);
    {
#line 416
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 416
      PAC_char = (char )'\000';
      {
#line 416
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 416
        ga_needed_size___0 = (long )(pool->tail + 1);
#line 416
        ga_newsize___0 = (long )pool->size;
        {
#line 416
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 416
          if (! (ga_newsize___0 < ga_needed_size___0)) {
#line 416
            goto while_break___6;
          }
#line 416
          ga_newsize___0 <<= 1;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 416
        if (ga_newsize___0 != (long )pool->size) {
#line 416
          if (pool->resized) {
            {
#line 416
            tmp___8 = checking_realloc((void *)pool->contents, (unsigned long )ga_newsize___0 * sizeof(char ));
#line 416
            pool->contents = (char *)tmp___8;
            }
          } else {
            {
#line 416
            tmp___9 = checking_malloc((unsigned long )ga_newsize___0 * sizeof(char ));
#line 416
            ga_new___0 = tmp___9;
#line 416
            memcpy((void */* __restrict  */)ga_new___0, (void const   */* __restrict  */)pool->contents,
                   (unsigned long )pool->size * sizeof(char ));
#line 416
            pool->contents = (char *)ga_new___0;
#line 416
            pool->resized = (_Bool)1;
            }
          }
#line 416
          pool->size = (int )ga_newsize___0;
        }
#line 416
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 416
      tmp___10 = pool->tail;
#line 416
      (pool->tail) ++;
#line 416
      *(pool->contents + tmp___10) = PAC_char;
#line 416
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 421
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 421
      PA_beg = beg;
#line 421
      PA_size = (int )(end - PA_beg);
      {
#line 421
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 421
        ga_needed_size___1 = (long )(pool->tail + PA_size);
#line 421
        ga_newsize___1 = (long )pool->size;
        {
#line 421
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 421
          if (! (ga_newsize___1 < ga_needed_size___1)) {
#line 421
            goto while_break___9;
          }
#line 421
          ga_newsize___1 <<= 1;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 421
        if (ga_newsize___1 != (long )pool->size) {
#line 421
          if (pool->resized) {
            {
#line 421
            tmp___11 = checking_realloc((void *)pool->contents, (unsigned long )ga_newsize___1 * sizeof(char ));
#line 421
            pool->contents = (char *)tmp___11;
            }
          } else {
            {
#line 421
            tmp___12 = checking_malloc((unsigned long )ga_newsize___1 * sizeof(char ));
#line 421
            ga_new___1 = tmp___12;
#line 421
            memcpy((void */* __restrict  */)ga_new___1, (void const   */* __restrict  */)pool->contents,
                   (unsigned long )pool->size * sizeof(char ));
#line 421
            pool->contents = (char *)ga_new___1;
#line 421
            pool->resized = (_Bool)1;
            }
          }
#line 421
          pool->size = (int )ga_newsize___1;
        }
#line 421
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 421
      memcpy((void */* __restrict  */)(pool->contents + pool->tail), (void const   */* __restrict  */)PA_beg,
             (size_t )PA_size);
#line 421
      pool->tail += PA_size;
      }
#line 421
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 422
      PAC_char___0 = (char )'\000';
      {
#line 422
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 422
        ga_needed_size___2 = (long )(pool->tail + 1);
#line 422
        ga_newsize___2 = (long )pool->size;
        {
#line 422
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 422
          if (! (ga_newsize___2 < ga_needed_size___2)) {
#line 422
            goto while_break___12;
          }
#line 422
          ga_newsize___2 <<= 1;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 422
        if (ga_newsize___2 != (long )pool->size) {
#line 422
          if (pool->resized) {
            {
#line 422
            tmp___13 = checking_realloc((void *)pool->contents, (unsigned long )ga_newsize___2 * sizeof(char ));
#line 422
            pool->contents = (char *)tmp___13;
            }
          } else {
            {
#line 422
            tmp___14 = checking_malloc((unsigned long )ga_newsize___2 * sizeof(char ));
#line 422
            ga_new___2 = tmp___14;
#line 422
            memcpy((void */* __restrict  */)ga_new___2, (void const   */* __restrict  */)pool->contents,
                   (unsigned long )pool->size * sizeof(char ));
#line 422
            pool->contents = (char *)ga_new___2;
#line 422
            pool->resized = (_Bool)1;
            }
          }
#line 422
          pool->size = (int )ga_newsize___2;
        }
#line 422
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 422
      tmp___15 = pool->tail;
#line 422
      (pool->tail) ++;
#line 422
      *(pool->contents + tmp___15) = PAC_char___0;
#line 422
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 425
  if (flags & 1) {
#line 427
    p___0 = pool->contents + old_tail;
    {
#line 428
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 428
      if (! *p___0) {
#line 428
        goto while_break___13;
      }
#line 429
      *p___0 = (char )_sch_tolower[(int )*p___0 & 255];
#line 428
      p___0 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
#line 431
  return;
}
}
#line 474 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
static char const   *advance_declaration(char const   *beg , char const   *end ) 
{ 
  char const   *p___0 ;
  char quote_char ;
  char ch ;
  enum __anonenum_state_1000635653 state ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___7 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
#line 477
  p___0 = beg;
#line 478
  quote_char = (char )'\000';
#line 481
  state = (enum __anonenum_state_1000635653 )2;
#line 497
  if ((unsigned long )beg == (unsigned long )end) {
#line 498
    return (beg);
  }
#line 499
  tmp = p___0;
#line 499
  p___0 ++;
#line 499
  ch = (char )*tmp;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if ((unsigned int )state != 0U) {
#line 504
      if (! ((unsigned int )state != 1U)) {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
#line 506
    if ((unsigned long )p___0 == (unsigned long )end) {
#line 507
      state = (enum __anonenum_state_1000635653 )1;
    }
    {
#line 511
    if ((unsigned int )state == 1U) {
#line 511
      goto case_1;
    }
#line 511
    if ((unsigned int )state == 0U) {
#line 511
      goto case_1;
    }
#line 513
    if ((unsigned int )state == 2U) {
#line 513
      goto case_2;
    }
#line 522
    if ((unsigned int )state == 3U) {
#line 522
      goto case_3;
    }
#line 549
    if ((unsigned int )state == 4U) {
#line 549
      goto case_4;
    }
#line 557
    if ((unsigned int )state == 10U) {
#line 557
      goto case_10___0;
    }
#line 567
    if ((unsigned int )state == 11U) {
#line 567
      goto case_11;
    }
#line 573
    if ((unsigned int )state == 12U) {
#line 573
      goto case_12;
    }
#line 578
    if ((unsigned int )state == 5U) {
#line 578
      goto case_5;
    }
#line 583
    if ((unsigned int )state == 6U) {
#line 583
      goto case_6;
    }
#line 594
    if ((unsigned int )state == 7U) {
#line 594
      goto case_7;
    }
#line 605
    if ((unsigned int )state == 8U) {
#line 605
      goto case_8;
    }
#line 610
    if ((unsigned int )state == 9U) {
#line 610
      goto case_9___0;
    }
#line 508
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 512
    goto switch_break;
    case_2: /* CIL Label */ 
#line 514
    if ((int )ch == 33) {
#line 516
      tmp___0 = p___0;
#line 516
      p___0 ++;
#line 516
      ch = (char )*tmp___0;
#line 517
      state = (enum __anonenum_state_1000635653 )3;
    } else {
#line 520
      state = (enum __anonenum_state_1000635653 )1;
    }
#line 521
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 525
    if ((int )ch == 45) {
#line 525
      goto case_45;
    }
#line 531
    if ((int )ch == 10) {
#line 531
      goto case_10;
    }
#line 531
    if ((int )ch == 13) {
#line 531
      goto case_10;
    }
#line 531
    if ((int )ch == 9) {
#line 531
      goto case_10;
    }
#line 531
    if ((int )ch == 32) {
#line 531
      goto case_10;
    }
#line 534
    if ((int )ch == 62) {
#line 534
      goto case_62;
    }
#line 538
    if ((int )ch == 34) {
#line 538
      goto case_34;
    }
#line 538
    if ((int )ch == 39) {
#line 538
      goto case_34;
    }
#line 541
    goto switch_default;
    case_45: /* CIL Label */ 
#line 526
    state = (enum __anonenum_state_1000635653 )5;
#line 527
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 532
    tmp___1 = p___0;
#line 532
    p___0 ++;
#line 532
    ch = (char )*tmp___1;
#line 533
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 535
    state = (enum __anonenum_state_1000635653 )0;
#line 536
    goto switch_break___0;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 539
    state = (enum __anonenum_state_1000635653 )10;
#line 540
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 542
    if ((int )ch > 32) {
#line 542
      if ((int )ch < 127) {
#line 542
        if ((int )ch != 61) {
#line 542
          if ((int )ch != 62) {
#line 542
            if ((int )ch != 47) {
#line 543
              state = (enum __anonenum_state_1000635653 )4;
            } else {
#line 545
              state = (enum __anonenum_state_1000635653 )1;
            }
          } else {
#line 545
            state = (enum __anonenum_state_1000635653 )1;
          }
        } else {
#line 545
          state = (enum __anonenum_state_1000635653 )1;
        }
      } else {
#line 545
        state = (enum __anonenum_state_1000635653 )1;
      }
    } else {
#line 545
      state = (enum __anonenum_state_1000635653 )1;
    }
#line 546
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 548
    goto switch_break;
    case_4: /* CIL Label */ 
#line 550
    if ((int )ch == 45) {
#line 551
      state = (enum __anonenum_state_1000635653 )5;
    } else
#line 552
    if ((int )ch > 32) {
#line 552
      if ((int )ch < 127) {
#line 552
        if ((int )ch != 61) {
#line 552
          if ((int )ch != 62) {
#line 552
            if ((int )ch != 47) {
#line 553
              tmp___2 = p___0;
#line 553
              p___0 ++;
#line 553
              ch = (char )*tmp___2;
            } else {
#line 555
              state = (enum __anonenum_state_1000635653 )3;
            }
          } else {
#line 555
            state = (enum __anonenum_state_1000635653 )3;
          }
        } else {
#line 555
          state = (enum __anonenum_state_1000635653 )3;
        }
      } else {
#line 555
        state = (enum __anonenum_state_1000635653 )3;
      }
    } else {
#line 555
      state = (enum __anonenum_state_1000635653 )3;
    }
#line 556
    goto switch_break;
    case_10___0: /* CIL Label */ 
#line 560
    if (! ((int )ch == 39)) {
#line 560
      if (! ((int )ch == 34)) {
        {
#line 560
        __assert_fail("ch == \'\\\'\' || ch == 0x22", "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c",
                      560U, "advance_declaration");
        }
      }
    }
#line 561
    quote_char = ch;
#line 564
    tmp___4 = p___0;
#line 564
    p___0 ++;
#line 564
    ch = (char )*tmp___4;
#line 565
    state = (enum __anonenum_state_1000635653 )11;
#line 566
    goto switch_break;
    case_11: /* CIL Label */ 
#line 568
    if ((int )ch == (int )quote_char) {
#line 569
      state = (enum __anonenum_state_1000635653 )12;
    } else {
#line 571
      tmp___5 = p___0;
#line 571
      p___0 ++;
#line 571
      ch = (char )*tmp___5;
    }
#line 572
    goto switch_break;
    case_12: /* CIL Label */ 
#line 574
    if (! ((int )ch == (int )quote_char)) {
      {
#line 574
      __assert_fail("ch == quote_char", "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c",
                    574U, "advance_declaration");
      }
    }
#line 575
    tmp___7 = p___0;
#line 575
    p___0 ++;
#line 575
    ch = (char )*tmp___7;
#line 576
    state = (enum __anonenum_state_1000635653 )3;
#line 577
    goto switch_break;
    case_5: /* CIL Label */ 
#line 579
    if (! ((int )ch == 45)) {
      {
#line 579
      __assert_fail("ch == \'-\'", "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c",
                    579U, "advance_declaration");
      }
    }
#line 580
    tmp___9 = p___0;
#line 580
    p___0 ++;
#line 580
    ch = (char )*tmp___9;
#line 581
    state = (enum __anonenum_state_1000635653 )6;
#line 582
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 586
    if ((int )ch == 45) {
#line 586
      goto case_45___0;
    }
#line 590
    goto switch_default___0;
    case_45___0: /* CIL Label */ 
#line 587
    tmp___10 = p___0;
#line 587
    p___0 ++;
#line 587
    ch = (char )*tmp___10;
#line 588
    state = (enum __anonenum_state_1000635653 )7;
#line 589
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 591
    state = (enum __anonenum_state_1000635653 )1;
    switch_break___1: /* CIL Label */ ;
    }
#line 593
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 597
    if ((int )ch == 45) {
#line 597
      goto case_45___1;
    }
#line 600
    goto switch_default___1;
    case_45___1: /* CIL Label */ 
#line 598
    state = (enum __anonenum_state_1000635653 )8;
#line 599
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 601
    tmp___11 = p___0;
#line 601
    p___0 ++;
#line 601
    ch = (char )*tmp___11;
#line 602
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 604
    goto switch_break;
    case_8: /* CIL Label */ 
#line 606
    if (! ((int )ch == 45)) {
      {
#line 606
      __assert_fail("ch == \'-\'", "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c",
                    606U, "advance_declaration");
      }
    }
#line 607
    tmp___13 = p___0;
#line 607
    p___0 ++;
#line 607
    ch = (char )*tmp___13;
#line 608
    state = (enum __anonenum_state_1000635653 )9;
#line 609
    goto switch_break;
    case_9___0: /* CIL Label */ 
    {
#line 613
    if ((int )ch == 45) {
#line 613
      goto case_45___2;
    }
#line 617
    goto switch_default___2;
    case_45___2: /* CIL Label */ 
#line 614
    tmp___14 = p___0;
#line 614
    p___0 ++;
#line 614
    ch = (char )*tmp___14;
#line 615
    state = (enum __anonenum_state_1000635653 )3;
#line 616
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 618
    state = (enum __anonenum_state_1000635653 )7;
#line 619
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 621
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  if ((unsigned int )state == 1U) {
#line 630
    return (beg + 1);
  }
#line 632
  return (p___0);
}
}
#line 639 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
static char const   *find_comment_end(char const   *beg , char const   *end ) 
{ 
  char const   *p___0 ;

  {
#line 646
  p___0 = beg - 1;
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 648
    p___0 += 3;
#line 648
    if (! ((unsigned long )p___0 < (unsigned long )end)) {
#line 648
      goto while_break;
    }
    {
#line 651
    if ((int const   )*(p___0 + 0) == 62) {
#line 651
      goto case_62;
    }
#line 655
    if ((int const   )*(p___0 + 0) == 45) {
#line 655
      goto at_dash;
    }
#line 649
    goto switch_break;
    case_62: /* CIL Label */ 
#line 652
    if ((int const   )*(p___0 + -1) == 45) {
#line 652
      if ((int const   )*(p___0 + -2) == 45) {
#line 653
        return (p___0 + 1);
      }
    }
#line 654
    goto switch_break;
    at_dash: 
    case_45: /* CIL Label */ 
#line 657
    if ((int const   )*(p___0 + -1) == 45) {
      at_dash_dash: 
#line 660
      p___0 ++;
#line 660
      if ((unsigned long )p___0 == (unsigned long )end) {
#line 660
        return ((char const   *)((void *)0));
      }
      {
#line 663
      if ((int const   )*(p___0 + 0) == 62) {
#line 663
        goto case_62___0;
      }
#line 664
      if ((int const   )*(p___0 + 0) == 45) {
#line 664
        goto case_45___0;
      }
#line 661
      goto switch_break___0;
      case_62___0: /* CIL Label */ 
#line 663
      return (p___0 + 1);
      case_45___0: /* CIL Label */ 
#line 664
      goto at_dash_dash;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 669
      p___0 += 2;
#line 669
      if ((unsigned long )p___0 >= (unsigned long )end) {
#line 669
        return ((char const   *)((void *)0));
      }
      {
#line 672
      if ((int const   )*(p___0 + 0) == 62) {
#line 672
        goto case_62___1;
      }
#line 676
      if ((int const   )*(p___0 + 0) == 45) {
#line 676
        goto case_45___1;
      }
#line 670
      goto switch_break___1;
      case_62___1: /* CIL Label */ 
#line 673
      if ((int const   )*(p___0 + -1) == 45) {
#line 674
        return (p___0 + 1);
      }
#line 675
      goto switch_break___1;
      case_45___1: /* CIL Label */ 
#line 677
      goto at_dash;
      switch_break___1: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  return ((char const   *)((void *)0));
}
}
#line 687 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
static _Bool name_allowed(struct hash_table  const  *ht , char const   *b , char const   *e ) 
{ 
  char *copy ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 691
  if (! ht) {
#line 692
    return ((_Bool)1);
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 693
    BTA_beg = b;
#line 693
    BTA_len = (int )(e - BTA_beg);
#line 693
    BTA_dest = & copy;
#line 693
    tmp = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 693
    *BTA_dest = (char *)tmp;
#line 693
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 693
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 693
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  tmp___0 = hash_table_get(ht, (void const   *)copy);
  }
#line 694
  return ((_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0)));
}
}
#line 740 "/home/khheo/project/benchmark/wget-1.11.4/src/html-parse.c"
void map_html_tags(char const   *text , int size , void (*mapfun)(struct taginfo * ,
                                                                  void * ) , void *maparg ,
                   int flags , struct hash_table  const  *allowed_tags , struct hash_table  const  *allowed_attributes ) 
{ 
  char pool_initial_storage[256] ;
  struct pool pool ;
  char const   *p___0 ;
  char const   *end ;
  struct attr_pair attr_pair_initial_storage[8] ;
  int attr_pair_size ;
  _Bool attr_pair_resized ;
  struct attr_pair *pairs ;
  struct pool *P ;
  int nattrs ;
  int end_tag ;
  char const   *tag_name_begin ;
  char const   *tag_name_end ;
  char const   *tag_start_position ;
  _Bool uninteresting_tag ;
  void *tmp ;
  char const   *comment_end ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char const   *attr_name_begin ;
  char const   *attr_name_end ;
  char const   *attr_value_begin ;
  char const   *attr_value_end ;
  char const   *attr_raw_value_begin ;
  char const   *attr_raw_value_end ;
  int operation ;
  _Bool newline_seen ;
  char quote_char ;
  _Bool tmp___2 ;
  long ga_needed_size ;
  long ga_newsize ;
  void *tmp___3 ;
  void *ga_new ;
  void *tmp___4 ;
  int i ;
  struct taginfo taginfo ;
  struct pool *P___0 ;

  {
#line 752
  p___0 = text;
#line 753
  end = text + size;
#line 756
  attr_pair_size = (int )(sizeof(attr_pair_initial_storage) / sizeof(attr_pair_initial_storage[0]));
#line 757
  attr_pair_resized = (_Bool)0;
#line 758
  pairs = attr_pair_initial_storage;
#line 760
  if (! size) {
#line 761
    return;
  }
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    P = & pool;
#line 763
    P->contents = pool_initial_storage;
#line 763
    P->size = (int )(sizeof(pool_initial_storage) / sizeof(pool_initial_storage[0]));
#line 763
    P->tail = 0;
#line 763
    P->resized = (_Bool)0;
#line 763
    P->orig_contents = P->contents;
#line 763
    P->orig_size = P->size;
#line 763
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  look_for_tag: 
  {
#line 772
  pool.tail = 0;
#line 774
  nattrs = 0;
#line 775
  end_tag = 0;
#line 779
  tmp = memchr((void const   *)p___0, '<', (size_t )(end - p___0));
#line 779
  p___0 = (char const   *)tmp;
  }
#line 780
  if (! p___0) {
#line 781
    goto finish;
  }
#line 783
  tag_start_position = p___0;
  {
#line 784
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 784
    p___0 ++;
#line 784
    if ((unsigned long )p___0 >= (unsigned long )end) {
#line 784
      goto finish;
    }
#line 784
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 788
  if ((int const   )*p___0 == 33) {
#line 790
    if (! (flags & 1)) {
#line 790
      if ((unsigned long )p___0 < (unsigned long )(end + 3)) {
#line 790
        if ((int const   )*(p___0 + 1) == 45) {
#line 790
          if ((int const   )*(p___0 + 2) == 45) {
            {
#line 798
            tmp___0 = find_comment_end(p___0 + 3, end);
#line 798
            comment_end = tmp___0;
            }
#line 799
            if (comment_end) {
#line 800
              p___0 = comment_end;
            }
          } else {
            {
#line 808
            p___0 = advance_declaration(p___0, end);
            }
          }
        } else {
          {
#line 808
          p___0 = advance_declaration(p___0, end);
          }
        }
      } else {
        {
#line 808
        p___0 = advance_declaration(p___0, end);
        }
      }
    } else {
      {
#line 808
      p___0 = advance_declaration(p___0, end);
      }
    }
#line 810
    if ((unsigned long )p___0 == (unsigned long )end) {
#line 811
      goto finish;
    }
#line 812
    goto look_for_tag;
  } else
#line 814
  if ((int const   )*p___0 == 47) {
#line 816
    end_tag = 1;
    {
#line 817
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 817
      p___0 ++;
#line 817
      if ((unsigned long )p___0 >= (unsigned long )end) {
#line 817
        goto finish;
      }
#line 817
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 819
  tag_name_begin = p___0;
  {
#line 820
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 820
    if ((int const   )*p___0 > 32) {
#line 820
      if ((int const   )*p___0 < 127) {
#line 820
        if ((int const   )*p___0 != 61) {
#line 820
          if ((int const   )*p___0 != 62) {
#line 820
            if (! ((int const   )*p___0 != 47)) {
#line 820
              goto while_break___2;
            }
          } else {
#line 820
            goto while_break___2;
          }
        } else {
#line 820
          goto while_break___2;
        }
      } else {
#line 820
        goto while_break___2;
      }
    } else {
#line 820
      goto while_break___2;
    }
    {
#line 821
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 821
      p___0 ++;
#line 821
      if ((unsigned long )p___0 >= (unsigned long )end) {
#line 821
        goto finish;
      }
#line 821
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 822
  if ((unsigned long )p___0 == (unsigned long )tag_name_begin) {
#line 823
    goto look_for_tag;
  }
#line 824
  tag_name_end = p___0;
  {
#line 825
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 825
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 825
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 825
        goto while_break___5;
      }
      {
#line 825
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 825
        p___0 ++;
#line 825
        if ((unsigned long )p___0 >= (unsigned long )end) {
#line 825
          goto finish;
        }
#line 825
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 825
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 826
  if (end_tag) {
#line 826
    if ((int const   )*p___0 != 62) {
#line 827
      goto backout_tag;
    }
  }
  {
#line 829
  tmp___1 = name_allowed(allowed_tags, tag_name_begin, tag_name_end);
  }
#line 829
  if (tmp___1) {
    {
#line 835
    uninteresting_tag = (_Bool)0;
#line 836
    convert_and_copy(& pool, tag_name_begin, tag_name_end, 1);
    }
  } else {
#line 832
    uninteresting_tag = (_Bool)1;
  }
  {
#line 840
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 845
    operation = 1;
    {
#line 847
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 847
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 847
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 847
          goto while_break___9;
        }
        {
#line 847
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 847
          p___0 ++;
#line 847
          if ((unsigned long )p___0 >= (unsigned long )end) {
#line 847
            goto finish;
          }
#line 847
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 847
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 849
    if ((int const   )*p___0 == 47) {
      {
#line 856
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 856
        p___0 ++;
#line 856
        if ((unsigned long )p___0 >= (unsigned long )end) {
#line 856
          goto finish;
        }
#line 856
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 857
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 857
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 857
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 857
            goto while_break___13;
          }
          {
#line 857
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 857
            p___0 ++;
#line 857
            if ((unsigned long )p___0 >= (unsigned long )end) {
#line 857
              goto finish;
            }
#line 857
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 857
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 858
      if ((int const   )*p___0 != 62) {
#line 859
        goto backout_tag;
      }
    }
#line 863
    if ((int const   )*p___0 == 62) {
#line 864
      goto while_break___7;
    }
#line 867
    attr_name_begin = p___0;
    {
#line 869
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 869
      if ((int const   )*p___0 > 32) {
#line 869
        if ((int const   )*p___0 < 127) {
#line 869
          if ((int const   )*p___0 != 61) {
#line 869
            if ((int const   )*p___0 != 62) {
#line 869
              if (! ((int const   )*p___0 != 47)) {
#line 869
                goto while_break___15;
              }
            } else {
#line 869
              goto while_break___15;
            }
          } else {
#line 869
            goto while_break___15;
          }
        } else {
#line 869
          goto while_break___15;
        }
      } else {
#line 869
        goto while_break___15;
      }
      {
#line 870
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 870
        p___0 ++;
#line 870
        if ((unsigned long )p___0 >= (unsigned long )end) {
#line 870
          goto finish;
        }
#line 870
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 871
    attr_name_end = p___0;
#line 873
    if ((unsigned long )attr_name_begin == (unsigned long )attr_name_end) {
#line 874
      goto backout_tag;
    }
    {
#line 877
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 877
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 877
        if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 877
          goto while_break___18;
        }
        {
#line 877
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 877
          p___0 ++;
#line 877
          if ((unsigned long )p___0 >= (unsigned long )end) {
#line 877
            goto finish;
          }
#line 877
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
#line 877
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 878
    if ((int const   )*p___0 > 32) {
#line 878
      if ((int const   )*p___0 < 127) {
#line 878
        if ((int const   )*p___0 != 61) {
#line 878
          if ((int const   )*p___0 != 62) {
#line 878
            if ((int const   )*p___0 != 47) {
#line 885
              attr_value_begin = attr_name_begin;
#line 885
              attr_raw_value_begin = attr_value_begin;
#line 886
              attr_value_end = attr_name_end;
#line 886
              attr_raw_value_end = attr_value_end;
            } else {
#line 878
              goto _L___4;
            }
          } else {
#line 878
            goto _L___4;
          }
        } else {
#line 878
          goto _L___4;
        }
      } else {
#line 878
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 878
    if ((int const   )*p___0 == 47) {
#line 885
      attr_value_begin = attr_name_begin;
#line 885
      attr_raw_value_begin = attr_value_begin;
#line 886
      attr_value_end = attr_name_end;
#line 886
      attr_raw_value_end = attr_value_end;
    } else
#line 878
    if ((int const   )*p___0 == 62) {
#line 885
      attr_value_begin = attr_name_begin;
#line 885
      attr_raw_value_begin = attr_value_begin;
#line 886
      attr_value_end = attr_name_end;
#line 886
      attr_raw_value_end = attr_value_end;
    } else
#line 888
    if ((int const   )*p___0 == 61) {
      {
#line 890
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 890
        p___0 ++;
#line 890
        if ((unsigned long )p___0 >= (unsigned long )end) {
#line 890
          goto finish;
        }
#line 890
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 891
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 891
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 891
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 891
            goto while_break___22;
          }
          {
#line 891
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 891
            p___0 ++;
#line 891
            if ((unsigned long )p___0 >= (unsigned long )end) {
#line 891
              goto finish;
            }
#line 891
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 891
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 892
      if ((int const   )*p___0 == 34) {
#line 892
        goto _L___0;
      } else
#line 892
      if ((int const   )*p___0 == 39) {
        _L___0: /* CIL Label */ 
#line 894
        newline_seen = (_Bool)0;
#line 895
        quote_char = (char )*p___0;
#line 896
        attr_raw_value_begin = p___0;
        {
#line 897
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 897
          p___0 ++;
#line 897
          if ((unsigned long )p___0 >= (unsigned long )end) {
#line 897
            goto finish;
          }
#line 897
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 898
        attr_value_begin = p___0;
        {
#line 900
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 900
          if (! ((int const   )*p___0 != (int const   )quote_char)) {
#line 900
            goto while_break___25;
          }
#line 902
          if (! newline_seen) {
#line 902
            if ((int const   )*p___0 == 10) {
#line 911
              p___0 = attr_value_begin;
#line 912
              newline_seen = (_Bool)1;
#line 913
              goto while_continue___25;
            } else {
#line 902
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 915
          if (newline_seen) {
#line 915
            if ((int const   )*p___0 == 62) {
#line 916
              goto while_break___25;
            }
          }
          {
#line 917
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 917
            p___0 ++;
#line 917
            if ((unsigned long )p___0 >= (unsigned long )end) {
#line 917
              goto finish;
            }
#line 917
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 919
        attr_value_end = p___0;
#line 921
        if ((int const   )*p___0 == (int const   )quote_char) {
          {
#line 922
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 922
            p___0 ++;
#line 922
            if ((unsigned long )p___0 >= (unsigned long )end) {
#line 922
              goto finish;
            }
#line 922
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
        } else {
#line 924
          goto look_for_tag;
        }
#line 925
        attr_raw_value_end = p___0;
#line 927
        operation = 2;
#line 928
        if (flags & 2) {
#line 929
          operation |= 4;
        }
      } else {
#line 933
        attr_value_begin = p___0;
        {
#line 940
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 940
          if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 64)) {
#line 940
            if (! ((int const   )*p___0 != 62)) {
#line 940
              goto while_break___28;
            }
          } else {
#line 940
            goto while_break___28;
          }
          {
#line 941
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 941
            p___0 ++;
#line 941
            if ((unsigned long )p___0 >= (unsigned long )end) {
#line 941
              goto finish;
            }
#line 941
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
#line 942
        attr_value_end = p___0;
#line 944
        if ((unsigned long )attr_value_begin == (unsigned long )attr_value_end) {
#line 947
          goto backout_tag;
        }
#line 948
        attr_raw_value_begin = attr_value_begin;
#line 949
        attr_raw_value_end = attr_value_end;
#line 950
        operation = 2;
      }
    } else {
#line 958
      goto backout_tag;
    }
#line 964
    if (uninteresting_tag) {
#line 965
      goto while_continue___7;
    }
    {
#line 970
    tmp___2 = name_allowed(allowed_attributes, attr_name_begin, attr_name_end);
    }
#line 970
    if (! tmp___2) {
#line 971
      goto while_continue___7;
    }
    {
#line 973
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 973
      ga_needed_size = (long )(nattrs + 1);
#line 973
      ga_newsize = (long )attr_pair_size;
      {
#line 973
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 973
        if (! (ga_newsize < ga_needed_size)) {
#line 973
          goto while_break___31;
        }
#line 973
        ga_newsize <<= 1;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 973
      if (ga_newsize != (long )attr_pair_size) {
#line 973
        if (attr_pair_resized) {
          {
#line 973
          tmp___3 = checking_realloc((void *)pairs, (unsigned long )ga_newsize * sizeof(struct attr_pair ));
#line 973
          pairs = (struct attr_pair *)tmp___3;
          }
        } else {
          {
#line 973
          tmp___4 = checking_malloc((unsigned long )ga_newsize * sizeof(struct attr_pair ));
#line 973
          ga_new = tmp___4;
#line 973
          memcpy((void */* __restrict  */)ga_new, (void const   */* __restrict  */)pairs,
                 (unsigned long )attr_pair_size * sizeof(struct attr_pair ));
#line 973
          pairs = (struct attr_pair *)ga_new;
#line 973
          attr_pair_resized = (_Bool)1;
          }
        }
#line 973
        attr_pair_size = (int )ga_newsize;
      }
#line 973
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 976
    (pairs + nattrs)->name_pool_index = pool.tail;
#line 977
    convert_and_copy(& pool, attr_name_begin, attr_name_end, 1);
#line 979
    (pairs + nattrs)->value_pool_index = pool.tail;
#line 980
    convert_and_copy(& pool, attr_value_begin, attr_value_end, operation);
#line 981
    (pairs + nattrs)->value_raw_beginning = attr_raw_value_begin;
#line 982
    (pairs + nattrs)->value_raw_size = (int )(attr_raw_value_end - attr_raw_value_begin);
#line 984
    nattrs ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 987
  if (uninteresting_tag) {
    {
#line 989
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 989
      p___0 ++;
#line 989
      if ((unsigned long )p___0 >= (unsigned long )end) {
#line 989
        goto finish;
      }
#line 989
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 990
    goto look_for_tag;
  }
#line 999
  taginfo.name = pool.contents;
#line 1000
  taginfo.end_tag_p = end_tag;
#line 1001
  taginfo.nattrs = nattrs;
#line 1006
  i = 0;
  {
#line 1006
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 1006
    if (! (i < nattrs)) {
#line 1006
      goto while_break___33;
    }
#line 1008
    (pairs + i)->name = pool.contents + (pairs + i)->name_pool_index;
#line 1009
    (pairs + i)->value = pool.contents + (pairs + i)->value_pool_index;
#line 1006
    i ++;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 1011
  taginfo.attrs = pairs;
#line 1012
  taginfo.start_position = tag_start_position;
#line 1013
  taginfo.end_position = p___0 + 1;
#line 1014
  (*mapfun)(& taginfo, maparg);
  }
  {
#line 1015
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 1015
    p___0 ++;
#line 1015
    if ((unsigned long )p___0 >= (unsigned long )end) {
#line 1015
      goto finish;
    }
#line 1015
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 1017
  goto look_for_tag;
  backout_tag: 
#line 1025
  p___0 = tag_start_position + 1;
#line 1026
  goto look_for_tag;
  finish: 
  {
#line 1030
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 1030
    P___0 = & pool;
#line 1030
    if (P___0->resized) {
      {
#line 1030
      checking_free((void *)P___0->contents);
      }
    }
#line 1030
    P___0->contents = P___0->orig_contents;
#line 1030
    P___0->size = P___0->orig_size;
#line 1030
    P___0->tail = 0;
#line 1030
    P___0->resized = (_Bool)0;
#line 1030
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 1031
  if (attr_pair_resized) {
    {
#line 1032
    checking_free((void *)pairs);
    }
  }
#line 1033
  return;
}
}
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 660 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 666
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 669
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 83 "/home/khheo/project/benchmark/wget-1.11.4/src/host.h"
void address_list_get_bounds(struct address_list  const  *al , int *start , int *end ) ;
#line 84
ip_address const   *address_list_address_at(struct address_list  const  *al , int pos ) ;
#line 86
void address_list_set_faulty(struct address_list *al , int index___0 ) ;
#line 87
void address_list_set_connected(struct address_list *al ) ;
#line 88
_Bool address_list_connected_p(struct address_list  const  *al ) ;
#line 91
char const   *print_address(ip_address const   *addr ) ;
#line 99
void host_cleanup(void) ;
#line 87 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
void address_list_get_bounds(struct address_list  const  *al , int *start , int *end ) 
{ 


  {
#line 90
  *start = (int )al->faulty;
#line 91
  *end = (int )al->count;
#line 92
  return;
}
}
#line 96 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
ip_address const   *address_list_address_at(struct address_list  const  *al , int pos ) 
{ 


  {
#line 99
  if (pos >= (int )al->faulty) {
#line 99
    if (! (pos < (int )al->count)) {
      {
#line 99
      __assert_fail("pos >= al->faulty && pos < al->count", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                    99U, "address_list_address_at");
      }
    }
  } else {
    {
#line 99
    __assert_fail("pos >= al->faulty && pos < al->count", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                  99U, "address_list_address_at");
    }
  }
#line 100
  return ((ip_address const   *)(al->addresses + pos));
}
}
#line 105 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
_Bool address_list_contains(struct address_list  const  *al , ip_address const   *ip___0 ) 
{ 
  int i ;
  ip_address *cur ;
  ip_address *cur___0 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
  {
#line 111
  if (ip___0->family == 2) {
#line 111
    goto case_2;
  }
#line 121
  if (ip___0->family == 10) {
#line 121
    goto case_10;
  }
#line 134
  goto switch_default;
  case_2: /* CIL Label */ 
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < (int )al->count)) {
#line 112
      goto while_break;
    }
#line 114
    cur = (ip_address *)(al->addresses + i);
#line 115
    if (cur->family == 2) {
#line 115
      if (cur->data.d4.s_addr == (in_addr_t )ip___0->data.d4.s_addr) {
#line 117
        return ((_Bool)1);
      }
    }
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((_Bool)0);
  case_10: /* CIL Label */ 
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! (i < (int )al->count)) {
#line 122
      goto while_break___0;
    }
#line 124
    cur___0 = (ip_address *)(al->addresses + i);
#line 129
    if (cur___0->family == 10) {
#line 129
      if (cur___0->ipv6_scope == (int )ip___0->ipv6_scope) {
#line 129
        __a = (struct in6_addr  const  *)(& cur___0->data.d6);
#line 129
        __b = & ip___0->data.d6;
#line 129
        if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 129
          if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 129
            if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 129
              if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 129
                tmp = 1;
              } else {
#line 129
                tmp = 0;
              }
            } else {
#line 129
              tmp = 0;
            }
          } else {
#line 129
            tmp = 0;
          }
        } else {
#line 129
          tmp = 0;
        }
#line 129
        if (tmp) {
#line 130
          return ((_Bool)1);
        }
      }
    }
#line 122
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 132
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
  {
#line 135
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 142 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
void address_list_set_faulty(struct address_list *al , int index___0 ) 
{ 


  {
#line 148
  if (! (index___0 == al->faulty)) {
    {
#line 148
    __assert_fail("index == al->faulty", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                  148U, "address_list_set_faulty");
    }
  }
#line 150
  (al->faulty) ++;
#line 151
  if (al->faulty >= al->count) {
#line 156
    al->faulty = 0;
  }
#line 157
  return;
}
}
#line 162 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
void address_list_set_connected(struct address_list *al ) 
{ 


  {
#line 165
  al->connected = (_Bool)1;
#line 166
  return;
}
}
#line 170 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
_Bool address_list_connected_p(struct address_list  const  *al ) 
{ 


  {
#line 173
  return ((_Bool )al->connected);
}
}
#line 181 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static struct address_list *address_list_from_addrinfo(struct addrinfo  const  *ai ) 
{ 
  struct address_list *al ;
  struct addrinfo  const  *ptr ;
  int cnt ;
  ip_address *ip___0 ;
  void *tmp ;
  void *tmp___0 ;
  struct sockaddr_in6  const  *sin6 ;
  struct sockaddr_in  const  *sin ;

  {
#line 189
  cnt = 0;
#line 190
  ptr = ai;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 190
      goto while_break;
    }
#line 191
    if (ptr->ai_family == 2) {
#line 192
      cnt ++;
    } else
#line 191
    if (ptr->ai_family == 10) {
#line 192
      cnt ++;
    }
#line 190
    ptr = (struct addrinfo  const  *)ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (cnt == 0) {
#line 194
    return ((struct address_list *)((void *)0));
  }
  {
#line 196
  tmp = checking_malloc0(sizeof(struct address_list ));
#line 196
  al = (struct address_list *)tmp;
#line 197
  tmp___0 = checking_malloc((unsigned long )cnt * sizeof(ip_address ));
#line 197
  al->addresses = (ip_address *)tmp___0;
#line 198
  al->count = cnt;
#line 199
  al->refcount = 1;
#line 201
  ip___0 = al->addresses;
#line 202
  ptr = ai;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 202
      goto while_break___0;
    }
#line 203
    if (ptr->ai_family == 10) {
#line 205
      sin6 = (struct sockaddr_in6  const  *)ptr->ai_addr;
#line 207
      ip___0->family = 10;
#line 208
      ip___0->data.d6 = (struct in6_addr )sin6->sin6_addr;
#line 210
      ip___0->ipv6_scope = (int )sin6->sin6_scope_id;
#line 212
      ip___0 ++;
    } else
#line 214
    if (ptr->ai_family == 2) {
#line 216
      sin = (struct sockaddr_in  const  *)ptr->ai_addr;
#line 218
      ip___0->family = 2;
#line 219
      ip___0->data.d4 = (struct in_addr )sin->sin_addr;
#line 220
      ip___0 ++;
    }
#line 202
    ptr = (struct addrinfo  const  *)ptr->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  if (! (ip___0 - al->addresses == (long )cnt)) {
    {
#line 222
    __assert_fail("ip - al->addresses == cnt", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                  222U, "address_list_from_addrinfo");
    }
  }
#line 223
  return (al);
}
}
#line 236 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static int cmp_prefer_ipv4(void const   *addr1 , void const   *addr2 ) 
{ 


  {
#line 239
  return (! (((ip_address const   *)addr1)->family == 2) - ! (((ip_address const   *)addr2)->family == 2));
}
}
#line 246 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static int cmp_prefer_ipv6(void const   *addr1 , void const   *addr2 ) 
{ 


  {
#line 249
  return (! (((ip_address const   *)addr1)->family == 10) - ! (((ip_address const   *)addr2)->family == 10));
}
}
#line 284 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static void address_list_delete(struct address_list *al ) 
{ 


  {
  {
#line 287
  checking_free((void *)al->addresses);
#line 288
  checking_free((void *)al);
  }
#line 289
  return;
}
}
#line 295 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
void address_list_release(struct address_list *al ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 298
  (al->refcount) --;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 299
    if (tmp) {
      {
#line 299
      debug_logprintf("Releasing 0x%0*lx (new refcount %d).\n", (int )(2UL * sizeof(void *)),
                      (unsigned long )al, al->refcount);
      }
    }
#line 299
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (al->refcount <= 0) {
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 303
      tmp___0 = __builtin_expect((long )opt.debug, 0L);
      }
#line 303
      if (tmp___0) {
        {
#line 303
        debug_logprintf("Deleting unused 0x%0*lx.\n", (int )(2UL * sizeof(void *)),
                        (unsigned long )al);
        }
      }
#line 303
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 304
    address_list_delete(al);
    }
  }
#line 306
  return;
}
}
#line 375 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static void getaddrinfo_with_timeout_callback(void *arg ) 
{ 
  struct gaiwt_context *ctx ;

  {
  {
#line 378
  ctx = (struct gaiwt_context *)arg;
#line 379
  ctx->exit_code = getaddrinfo((char const   */* __restrict  */)ctx->node, (char const   */* __restrict  */)ctx->service,
                               (struct addrinfo  const  */* __restrict  */)ctx->hints,
                               (struct addrinfo **/* __restrict  */)ctx->res);
  }
#line 380
  return;
}
}
#line 386 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static int getaddrinfo_with_timeout(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                                    struct addrinfo **res___0 , double timeout ) 
{ 
  struct gaiwt_context ctx ;
  int *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 392
  ctx.node = node;
#line 393
  ctx.service = service;
#line 394
  ctx.hints = hints;
#line 395
  ctx.res = res___0;
#line 397
  tmp___0 = run_with_timeout(timeout, & getaddrinfo_with_timeout_callback, (void *)(& ctx));
  }
#line 397
  if (tmp___0) {
    {
#line 399
    tmp = __errno_location();
#line 399
    *tmp = 110;
    }
#line 400
    return (-11);
  }
#line 402
  return (ctx.exit_code);
}
}
#line 415 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static char buf___3[64]  ;
#line 411 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
char const   *print_address(ip_address const   *addr ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 416
  tmp___1 = inet_ntop((int )addr->family, (void const   */* __restrict  */)((void *)(& addr->data)),
                      (char */* __restrict  */)(buf___3), (socklen_t )sizeof(buf___3));
  }
#line 416
  if (! tmp___1) {
    {
#line 417
    tmp = __errno_location();
#line 417
    tmp___0 = strerror(*tmp);
#line 417
    snprintf((char */* __restrict  */)(buf___3), sizeof(buf___3), (char const   */* __restrict  */)"<error: %s>",
             tmp___0);
    }
  }
#line 418
  return ((char const   *)(buf___3));
}
}
#line 427 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static _Bool is_valid_ipv4_address(char const   *str , char const   *end ) 
{ 
  _Bool saw_digit ;
  int octets ;
  int val ;
  int ch ;
  char const   *tmp ;

  {
#line 430
  saw_digit = (_Bool)0;
#line 431
  octets = 0;
#line 432
  val = 0;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! ((unsigned long )str < (unsigned long )end)) {
#line 434
      goto while_break;
    }
#line 436
    tmp = str;
#line 436
    str ++;
#line 436
    ch = (int )*tmp;
#line 438
    if (ch >= 48) {
#line 438
      if (ch <= 57) {
#line 440
        val = val * 10 + (ch - 48);
#line 442
        if (val > 255) {
#line 443
          return ((_Bool)0);
        }
#line 444
        if (! saw_digit) {
#line 446
          octets ++;
#line 446
          if (octets > 4) {
#line 447
            return ((_Bool)0);
          }
#line 448
          saw_digit = (_Bool)1;
        }
      } else {
#line 438
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 451
    if (ch == 46) {
#line 451
      if (saw_digit) {
#line 453
        if (octets == 4) {
#line 454
          return ((_Bool)0);
        }
#line 455
        val = 0;
#line 456
        saw_digit = (_Bool)0;
      } else {
#line 459
        return ((_Bool)0);
      }
    } else {
#line 459
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (octets < 4) {
#line 462
    return ((_Bool)0);
  }
#line 464
  return ((_Bool)1);
}
}
#line 467 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
_Bool is_valid_ipv6_address(char const   *str , char const   *end ) 
{ 
  char const   *curtok ;
  int tp ;
  char const   *colonp ;
  _Bool saw_xdigit ;
  unsigned int val ;
  int ch ;
  char const   *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 483
  tp = 0;
#line 484
  colonp = (char const   *)((void *)0);
#line 486
  if ((unsigned long )str == (unsigned long )end) {
#line 487
    return ((_Bool)0);
  }
#line 490
  if ((int const   )*str == 58) {
#line 492
    str ++;
#line 493
    if ((unsigned long )str == (unsigned long )end) {
#line 494
      return ((_Bool)0);
    } else
#line 493
    if ((int const   )*str != 58) {
#line 494
      return ((_Bool)0);
    }
  }
#line 497
  curtok = str;
#line 498
  saw_xdigit = (_Bool)0;
#line 499
  val = 0U;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! ((unsigned long )str < (unsigned long )end)) {
#line 501
      goto while_break;
    }
#line 503
    tmp = str;
#line 503
    str ++;
#line 503
    ch = (int )*tmp;
#line 506
    if ((int const   )_sch_istable[ch & 255] & 256) {
#line 508
      val <<= 4;
#line 509
      if (ch < 65) {
#line 509
        tmp___0 = ch - 48;
      } else {
#line 509
        tmp___0 = (int )(((int const   )_sch_toupper[ch & 255] - 65) + 10);
      }
#line 509
      val |= (unsigned int )tmp___0;
#line 510
      if (val > 65535U) {
#line 511
        return ((_Bool)0);
      }
#line 512
      saw_xdigit = (_Bool)1;
#line 513
      goto while_continue;
    }
#line 517
    if (ch == 58) {
#line 519
      curtok = str;
#line 520
      if (! saw_xdigit) {
#line 522
        if ((unsigned long )colonp != (unsigned long )((void *)0)) {
#line 523
          return ((_Bool)0);
        }
#line 524
        colonp = str + tp;
#line 525
        goto while_continue;
      } else
#line 527
      if ((unsigned long )str == (unsigned long )end) {
#line 528
        return ((_Bool)0);
      }
#line 529
      if (tp > 14) {
#line 530
        return ((_Bool)0);
      }
#line 531
      tp += 2;
#line 532
      saw_xdigit = (_Bool)0;
#line 533
      val = 0U;
#line 534
      goto while_continue;
    }
#line 538
    if (ch == 46) {
#line 538
      if (tp <= 12) {
        {
#line 538
        tmp___1 = is_valid_ipv4_address(curtok, end);
        }
#line 538
        if ((int )tmp___1 == 1) {
#line 541
          tp += 4;
#line 542
          saw_xdigit = (_Bool)0;
#line 543
          goto while_break;
        }
      }
    }
#line 546
    return ((_Bool)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if (saw_xdigit) {
#line 551
    if (tp > 14) {
#line 552
      return ((_Bool)0);
    }
#line 553
    tp += 2;
  }
#line 556
  if ((unsigned long )colonp != (unsigned long )((void *)0)) {
#line 558
    if (tp == 16) {
#line 559
      return ((_Bool)0);
    }
#line 560
    tp = 16;
  }
#line 563
  if (tp != 16) {
#line 564
    return ((_Bool)0);
  }
#line 566
  return ((_Bool)1);
}
}
#line 575 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static struct hash_table *host_name_addresses_map  ;
#line 581 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static struct address_list *cache_query(char const   *host ) 
{ 
  struct address_list *al ;
  void *tmp ;
  long tmp___0 ;

  {
#line 585
  if (! host_name_addresses_map) {
#line 586
    return ((struct address_list *)((void *)0));
  }
  {
#line 587
  tmp = hash_table_get((struct hash_table  const  *)host_name_addresses_map, (void const   *)host);
#line 587
  al = (struct address_list *)tmp;
  }
#line 588
  if (al) {
    {
#line 590
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 590
      tmp___0 = __builtin_expect((long )opt.debug, 0L);
      }
#line 590
      if (tmp___0) {
        {
#line 590
        debug_logprintf("Found %s in host_name_addresses_map (%p)\n", host, al);
        }
      }
#line 590
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 591
    (al->refcount) ++;
#line 592
    return (al);
  }
#line 594
  return ((struct address_list *)((void *)0));
}
}
#line 600 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static void cache_store(char const   *host , struct address_list *al ) 
{ 
  char *tmp ;
  int i ;
  char const   *tmp___0 ;
  long tmp___1 ;

  {
#line 603
  if (! host_name_addresses_map) {
    {
#line 604
    host_name_addresses_map = make_nocase_string_hash_table(0);
    }
  }
  {
#line 606
  (al->refcount) ++;
#line 607
  tmp = xstrdup_lower(host);
#line 607
  hash_table_put(host_name_addresses_map, (void const   *)tmp, (void *)al);
#line 609
  tmp___1 = __builtin_expect((long )opt.debug, 0L);
  }
#line 609
  if (tmp___1) {
    {
#line 612
    debug_logprintf("Caching %s =>", host);
#line 613
    i = 0;
    }
    {
#line 613
    while (1) {
      while_continue: /* CIL Label */ ;
#line 613
      if (! (i < al->count)) {
#line 613
        goto while_break;
      }
      {
#line 614
      tmp___0 = print_address((ip_address const   *)(al->addresses + i));
#line 614
      debug_logprintf(" %s", tmp___0);
#line 613
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 615
    debug_logprintf("\n");
    }
  }
#line 617
  return;
}
}
#line 622 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
static void cache_remove(char const   *host ) 
{ 
  struct address_list *al ;
  void *tmp ;

  {
#line 626
  if (! host_name_addresses_map) {
#line 627
    return;
  }
  {
#line 628
  tmp = hash_table_get((struct hash_table  const  *)host_name_addresses_map, (void const   *)host);
#line 628
  al = (struct address_list *)tmp;
  }
#line 629
  if (al) {
    {
#line 631
    address_list_release(al);
#line 632
    hash_table_remove(host_name_addresses_map, (void const   *)host);
    }
  }
#line 634
  return;
}
}
#line 658 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
struct address_list *lookup_host(char const   *host , int flags ) 
{ 
  struct address_list *al ;
  _Bool silent ;
  _Bool use_cache ;
  _Bool numeric_address ;
  double timeout ;
  char const   *end ;
  size_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int err ;
  struct addrinfo hints ;
  struct addrinfo *res___0 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int (*tmp___10)(void const   *addr1 , void const   *addr2 ) ;
  int i ;
  int printmax ;
  int tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 662
  silent = (_Bool )(! (! (flags & 1)));
#line 664
  numeric_address = (_Bool)0;
#line 665
  timeout = opt.dns_timeout;
#line 691
  tmp = strlen(host);
#line 691
  end = host + tmp;
#line 692
  tmp___0 = is_valid_ipv4_address(host, end);
  }
#line 692
  if (tmp___0) {
#line 693
    numeric_address = (_Bool)1;
  } else {
    {
#line 692
    tmp___1 = is_valid_ipv6_address(host, end);
    }
#line 692
    if (tmp___1) {
#line 693
      numeric_address = (_Bool)1;
    }
  }
#line 699
  use_cache = opt.dns_cache;
#line 701
  if (flags & 2) {
#line 702
    use_cache = (_Bool)0;
  } else
#line 701
  if (numeric_address) {
#line 702
    use_cache = (_Bool)0;
  }
#line 708
  if (use_cache) {
#line 710
    if (! (flags & 4)) {
      {
#line 712
      al = cache_query(host);
      }
#line 713
      if (al) {
#line 714
        return (al);
      }
    } else {
      {
#line 717
      cache_remove(host);
      }
    }
  }
#line 722
  if (! silent) {
#line 722
    if (! numeric_address) {
      {
#line 723
      tmp___2 = escnonprint(host);
#line 723
      tmp___3 = gettext("Resolving %s... ");
#line 723
      logprintf((enum log_options )0, (char const   *)tmp___3, tmp___2);
      }
    }
  }
  {
#line 730
  memset((void *)(& hints), '\000', sizeof(hints));
#line 731
  hints.ai_socktype = 1;
  }
#line 732
  if (opt.ipv4_only) {
#line 733
    hints.ai_family = 2;
  } else
#line 734
  if (opt.ipv6_only) {
#line 735
    hints.ai_family = 10;
  } else {
#line 740
    hints.ai_family = 0;
  }
#line 742
  if (flags & 2) {
#line 743
    hints.ai_flags |= 1;
  }
#line 746
  if (numeric_address) {
#line 750
    hints.ai_flags |= 4;
#line 751
    timeout = (double )0;
  }
  {
#line 757
  err = getaddrinfo_with_timeout(host, (char const   *)((void *)0), (struct addrinfo  const  *)(& hints),
                                 & res___0, timeout);
  }
#line 758
  if (err != 0) {
#line 758
    goto _L;
  } else
#line 758
  if ((unsigned long )res___0 == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 760
    if (! silent) {
#line 761
      if (err != -11) {
        {
#line 761
        tmp___4 = gai_strerror(err);
#line 761
        tmp___7 = tmp___4;
        }
      } else {
        {
#line 761
        tmp___5 = __errno_location();
#line 761
        tmp___6 = strerror(*tmp___5);
#line 761
        tmp___7 = (char const   *)tmp___6;
        }
      }
      {
#line 761
      tmp___8 = gettext("failed: %s.\n");
#line 761
      logprintf((enum log_options )0, (char const   *)tmp___8, tmp___7);
      }
    }
#line 763
    return ((struct address_list *)((void *)0));
  }
  {
#line 765
  al = address_list_from_addrinfo((struct addrinfo  const  *)res___0);
#line 766
  freeaddrinfo(res___0);
  }
#line 767
  if (! al) {
    {
#line 769
    tmp___9 = gettext("failed: No IPv4/IPv6 addresses for host.\n");
#line 769
    logprintf((enum log_options )0, (char const   *)tmp___9);
    }
#line 771
    return ((struct address_list *)((void *)0));
  }
#line 777
  if (al->count > 1) {
#line 777
    if ((unsigned int )opt.prefer_family != 2U) {
#line 778
      if ((unsigned int )opt.prefer_family == 0U) {
#line 778
        tmp___10 = & cmp_prefer_ipv4;
      } else {
#line 778
        tmp___10 = & cmp_prefer_ipv6;
      }
      {
#line 778
      stable_sort((void *)al->addresses, (size_t )al->count, sizeof(ip_address ),
                  tmp___10);
      }
    }
  }
#line 804
  if (! silent) {
#line 804
    if (! numeric_address) {
#line 807
      if (al->count <= 3) {
#line 807
        tmp___11 = al->count;
      } else {
#line 807
        tmp___11 = 3;
      }
#line 807
      printmax = tmp___11;
#line 808
      i = 0;
      {
#line 808
      while (1) {
        while_continue: /* CIL Label */ ;
#line 808
        if (! (i < printmax)) {
#line 808
          goto while_break;
        }
        {
#line 810
        tmp___12 = print_address((ip_address const   *)(al->addresses + i));
#line 810
        logputs((enum log_options )0, tmp___12);
        }
#line 811
        if (i < printmax - 1) {
          {
#line 812
          logputs((enum log_options )0, ", ");
          }
        }
#line 808
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 814
      if (printmax != al->count) {
        {
#line 815
        logputs((enum log_options )0, ", ...");
        }
      }
      {
#line 816
      logputs((enum log_options )0, "\n");
      }
    }
  }
#line 820
  if (use_cache) {
    {
#line 821
    cache_store(host, al);
    }
  }
#line 823
  return (al);
}
}
#line 828 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
_Bool accept_domain(struct url *u ) 
{ 
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 831
  if (! ((unsigned long )u->host != (unsigned long )((void *)0))) {
    {
#line 831
    __assert_fail("u->host != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                  831U, "accept_domain");
    }
  }
#line 832
  if (opt.domains) {
    {
#line 834
    tmp___0 = sufmatch((char const   **)opt.domains, (char const   *)u->host);
    }
#line 834
    if (! tmp___0) {
#line 835
      return ((_Bool)0);
    }
  }
#line 837
  if (opt.exclude_domains) {
    {
#line 839
    tmp___1 = sufmatch((char const   **)opt.exclude_domains, (char const   *)u->host);
    }
#line 839
    if (tmp___1) {
#line 840
      return ((_Bool)0);
    }
  }
#line 842
  return ((_Bool)1);
}
}
#line 850 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
_Bool sufmatch(char const   **list , char const   *what ) 
{ 
  int i ;
  int j ;
  int k ;
  int lw ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 855
  tmp = strlen(what);
#line 855
  lw = (int )tmp;
#line 856
  i = 0;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! *(list + i)) {
#line 856
      goto while_break;
    }
    {
#line 858
    tmp___0 = strlen(*(list + i));
#line 858
    j = (int )tmp___0;
#line 858
    k = lw;
    }
    {
#line 858
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 858
      if (j >= 0) {
#line 858
        if (! (k >= 0)) {
#line 858
          goto while_break___0;
        }
      } else {
#line 858
        goto while_break___0;
      }
#line 859
      if ((int const   )_sch_tolower[(int const   )*(*(list + i) + j) & 255] != (int const   )_sch_tolower[(int const   )*(what + k) & 255]) {
#line 860
        goto while_break___0;
      }
#line 858
      j --;
#line 858
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 862
    if (j == -1) {
#line 863
      return ((_Bool)1);
    }
#line 856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 865
  return ((_Bool)0);
}
}
#line 868 "/home/khheo/project/benchmark/wget-1.11.4/src/host.c"
void host_cleanup(void) 
{ 
  hash_table_iterator iter ;
  char *host ;
  struct address_list *al ;
  int tmp___0 ;

  {
#line 871
  if (host_name_addresses_map) {
    {
#line 874
    hash_table_iterate(host_name_addresses_map, & iter);
    }
    {
#line 874
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 874
      tmp___0 = hash_table_iter_next(& iter);
      }
#line 874
      if (! tmp___0) {
#line 874
        goto while_break;
      }
      {
#line 878
      host = (char *)iter.key;
#line 879
      al = (struct address_list *)iter.value;
#line 880
      checking_free((void *)host);
      }
#line 881
      if (! (al->refcount == 1)) {
        {
#line 881
        __assert_fail("al->refcount == 1", "/home/khheo/project/benchmark/wget-1.11.4/src/host.c",
                      881U, "host_cleanup");
        }
      }
      {
#line 882
      address_list_delete(al);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 884
    hash_table_destroy(host_name_addresses_map);
#line 885
    host_name_addresses_map = (struct hash_table *)((void *)0);
    }
  }
#line 887
  return;
}
}
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.h"
struct hash_table *hash_table_new(int items , unsigned long (*hash_function)(void const   * ) ,
                                  int (*test_function)(void const   * , void const   * ) ) ;
#line 46
void hash_table_clear(struct hash_table *ht ) ;
#line 48
void hash_table_for_each(struct hash_table *ht , int (*fn)(void * , void * , void * ) ,
                         void *arg ) ;
#line 63
unsigned long hash_pointer(void const   *ptr ) ;
#line 219 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int prime_size(int size , int *prime_offset ) ;
#line 219 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int const   primes[71]  = 
#line 219
  {      (int const   )13,      (int const   )19,      (int const   )29,      (int const   )41, 
        (int const   )59,      (int const   )79,      (int const   )107,      (int const   )149, 
        (int const   )197,      (int const   )263,      (int const   )347,      (int const   )457, 
        (int const   )599,      (int const   )787,      (int const   )1031,      (int const   )1361, 
        (int const   )1777,      (int const   )2333,      (int const   )3037,      (int const   )3967, 
        (int const   )5167,      (int const   )6719,      (int const   )8737,      (int const   )11369, 
        (int const   )14783,      (int const   )19219,      (int const   )24989,      (int const   )32491, 
        (int const   )42257,      (int const   )54941,      (int const   )71429,      (int const   )92861, 
        (int const   )120721,      (int const   )156941,      (int const   )204047,      (int const   )265271, 
        (int const   )344857,      (int const   )448321,      (int const   )582821,      (int const   )757693, 
        (int const   )985003,      (int const   )1280519,      (int const   )1664681,      (int const   )2164111, 
        (int const   )2813353,      (int const   )3657361,      (int const   )4754591,      (int const   )6180989, 
        (int const   )8035301,      (int const   )10445899,      (int const   )13579681,      (int const   )17653589, 
        (int const   )22949669,      (int const   )29834603,      (int const   )38784989,      (int const   )50420551, 
        (int const   )65546729,      (int const   )85210757,      (int const   )110774011,      (int const   )144006217, 
        (int const   )187208107,      (int const   )243370577,      (int const   )316381771,      (int const   )411296309, 
        (int const   )534685237,      (int const   )695090819,      (int const   )903618083,      (int const   )1174703521, 
        (int const   )1527114613,      (int const   )1837299131,      (int const   )2147483647};
#line 216 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int prime_size(int size , int *prime_offset ) 
{ 
  int i ;

  {
#line 232
  i = *prime_offset;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )i < sizeof(primes) / sizeof(primes[0]))) {
#line 232
      goto while_break;
    }
#line 233
    if (primes[i] >= (int const   )size) {
#line 240
      *prime_offset = i + 1;
#line 241
      return ((int )primes[i]);
    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  abort();
  }
}
}
#line 247
static int cmp_pointer(void const   *ptr1 , void const   *ptr2 ) ;
#line 273 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
struct hash_table *hash_table_new(int items , unsigned long (*hash_function)(void const   * ) ,
                                  int (*test_function)(void const   * , void const   * ) ) 
{ 
  int size ;
  struct hash_table *ht ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 279
  tmp = checking_malloc(sizeof(struct hash_table ));
#line 279
  ht = (struct hash_table *)tmp;
  }
#line 281
  if (hash_function) {
#line 281
    ht->hash_function = hash_function;
  } else {
#line 281
    ht->hash_function = & hash_pointer;
  }
#line 282
  if (test_function) {
#line 282
    ht->test_function = test_function;
  } else {
#line 282
    ht->test_function = & cmp_pointer;
  }
  {
#line 286
  ht->prime_offset = 0;
#line 290
  size = (int )((double )1 + (double )items / 0.75);
#line 291
  size = prime_size(size, & ht->prime_offset);
#line 292
  ht->size = size;
#line 293
  ht->resize_threshold = (int )((double )size * 0.75);
#line 296
  tmp___0 = checking_malloc((unsigned long )ht->size * sizeof(struct cell ));
#line 296
  ht->cells = (struct cell *)tmp___0;
#line 300
  memset((void *)ht->cells, 255, (unsigned long )size * sizeof(struct cell ));
#line 302
  ht->count = 0;
  }
#line 304
  return (ht);
}
}
#line 309 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void hash_table_destroy(struct hash_table *ht ) 
{ 


  {
  {
#line 312
  checking_free((void *)ht->cells);
#line 313
  checking_free((void *)ht);
  }
#line 314
  return;
}
}
#line 320 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
__inline static struct cell *find_cell(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct cell *cells ;
  int size ;
  struct cell *c ;
  unsigned long tmp ;
  int (*equals)(void const   * , void const   * ) ;
  int tmp___0 ;

  {
  {
#line 323
  cells = (struct cell *)ht->cells;
#line 324
  size = (int )ht->size;
#line 325
  tmp = (*(ht->hash_function))(key);
#line 325
  c = cells + tmp % (unsigned long )size;
#line 326
  equals = (int (*)(void const   * , void const   * ))ht->test_function;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL))) {
#line 328
      goto while_break;
    }
    {
#line 329
    tmp___0 = (*equals)(key, (void const   *)c->key);
    }
#line 329
    if (tmp___0) {
#line 330
      goto while_break;
    }
#line 328
    if ((unsigned long )c != (unsigned long )(cells + (size - 1))) {
#line 328
      c ++;
    } else {
#line 328
      c = cells;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  return (c);
}
}
#line 341 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void *hash_table_get(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct cell *c ;
  struct cell *tmp ;

  {
  {
#line 344
  tmp = find_cell(ht, key);
#line 344
  c = tmp;
  }
#line 345
  if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
#line 346
    return (c->value);
  } else {
#line 348
    return ((void *)0);
  }
}
}
#line 354 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
int hash_table_get_pair(struct hash_table  const  *ht , void const   *lookup_key ,
                        void *orig_key , void *value ) 
{ 
  struct cell *c ;
  struct cell *tmp ;

  {
  {
#line 358
  tmp = find_cell(ht, lookup_key);
#line 358
  c = tmp;
  }
#line 359
  if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
#line 361
    if (orig_key) {
#line 362
      *((void **)orig_key) = c->key;
    }
#line 363
    if (value) {
#line 364
      *((void **)value) = c->value;
    }
#line 365
    return (1);
  } else {
#line 368
    return (0);
  }
}
}
#line 373 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
int hash_table_contains(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct cell *c ;
  struct cell *tmp ;

  {
  {
#line 376
  tmp = find_cell(ht, key);
#line 376
  c = tmp;
  }
#line 377
  return ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL));
}
}
#line 383 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static void grow_hash_table(struct hash_table *ht ) 
{ 
  unsigned long (*hasher)(void const   * ) ;
  struct cell *old_cells ;
  struct cell *old_end ;
  struct cell *c ;
  struct cell *cells ;
  int newsize ;
  void *tmp ;
  struct cell *new_c ;
  unsigned long tmp___0 ;

  {
  {
#line 386
  hasher = ht->hash_function;
#line 387
  old_cells = ht->cells;
#line 388
  old_end = ht->cells + ht->size;
#line 392
  newsize = prime_size(ht->size * 2, & ht->prime_offset);
#line 400
  ht->size = newsize;
#line 401
  ht->resize_threshold = (int )((double )newsize * 0.75);
#line 403
  tmp = checking_malloc((unsigned long )newsize * sizeof(struct cell ));
#line 403
  cells = (struct cell *)tmp;
#line 404
  memset((void *)cells, 255, (unsigned long )newsize * sizeof(struct cell ));
#line 405
  ht->cells = cells;
#line 407
  c = old_cells;
  }
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! ((unsigned long )c < (unsigned long )old_end)) {
#line 407
      goto while_break;
    }
#line 408
    if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
      {
#line 414
      tmp___0 = (*hasher)((void const   *)c->key);
#line 414
      new_c = cells + tmp___0 % (unsigned long )newsize;
      }
      {
#line 415
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 415
        if (! ((unsigned long )new_c->key != (unsigned long )((void *)0xffffffffffffffffUL))) {
#line 415
          goto while_break___0;
        }
#line 415
        if ((unsigned long )new_c != (unsigned long )(cells + (newsize - 1))) {
#line 415
          new_c ++;
        } else {
#line 415
          new_c = cells;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 417
      *new_c = *c;
    }
#line 407
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 420
  checking_free((void *)old_cells);
  }
#line 421
  return;
}
}
#line 426 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void hash_table_put(struct hash_table *ht , void const   *key , void *value ) 
{ 
  struct cell *c ;
  struct cell *tmp ;

  {
  {
#line 429
  tmp = find_cell((struct hash_table  const  *)ht, key);
#line 429
  c = tmp;
  }
#line 430
  if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
#line 433
    c->key = (void *)key;
#line 434
    c->value = value;
#line 435
    return;
  }
#line 440
  if (ht->count >= ht->resize_threshold) {
    {
#line 442
    grow_hash_table(ht);
#line 443
    c = find_cell((struct hash_table  const  *)ht, key);
    }
  }
#line 447
  (ht->count) ++;
#line 448
  c->key = (void *)key;
#line 449
  c->value = value;
#line 450
  return;
}
}
#line 455 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
int hash_table_remove(struct hash_table *ht , void const   *key ) 
{ 
  struct cell *c ;
  struct cell *tmp ;
  int size ;
  struct cell *cells ;
  unsigned long (*hasher)(void const   * ) ;
  void const   *key2 ;
  struct cell *c_new ;
  unsigned long tmp___0 ;

  {
  {
#line 458
  tmp = find_cell((struct hash_table  const  *)ht, key);
#line 458
  c = tmp;
  }
#line 459
  if (! ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL))) {
#line 460
    return (0);
  } else {
#line 463
    size = ht->size;
#line 464
    cells = ht->cells;
#line 465
    hasher = ht->hash_function;
#line 467
    c->key = (void *)(~ ((uintptr_t )0));
#line 468
    (ht->count) --;
#line 475
    if ((unsigned long )c != (unsigned long )(cells + (size - 1))) {
#line 475
      c ++;
    } else {
#line 475
      c = cells;
    }
    {
#line 476
    while (1) {
      while_continue: /* CIL Label */ ;
#line 476
      if (! ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL))) {
#line 476
        goto while_break;
      }
      {
#line 478
      key2 = (void const   *)c->key;
#line 482
      tmp___0 = (*hasher)(key2);
#line 482
      c_new = cells + tmp___0 % (unsigned long )size;
      }
      {
#line 483
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 483
        if (! ((unsigned long )c_new->key != (unsigned long )((void *)0xffffffffffffffffUL))) {
#line 483
          goto while_break___0;
        }
#line 484
        if ((unsigned long )key2 == (unsigned long )c_new->key) {
#line 487
          goto next_rehash;
        }
#line 483
        if ((unsigned long )c_new != (unsigned long )(cells + (size - 1))) {
#line 483
          c_new ++;
        } else {
#line 483
          c_new = cells;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 489
      *c_new = *c;
#line 490
      c->key = (void *)(~ ((uintptr_t )0));
      next_rehash: ;
#line 476
      if ((unsigned long )c != (unsigned long )(cells + (size - 1))) {
#line 476
        c ++;
      } else {
#line 476
        c = cells;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 495
    return (1);
  }
}
}
#line 503 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void hash_table_clear(struct hash_table *ht ) 
{ 


  {
  {
#line 506
  memset((void *)ht->cells, 255, (unsigned long )ht->size * sizeof(struct cell ));
#line 507
  ht->count = 0;
  }
#line 508
  return;
}
}
#line 521 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void hash_table_for_each(struct hash_table *ht , int (*fn)(void * , void * , void * ) ,
                         void *arg ) 
{ 
  struct cell *c ;
  struct cell *end ;
  void *key ;
  int tmp ;

  {
#line 525
  c = ht->cells;
#line 526
  end = ht->cells + ht->size;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! ((unsigned long )c < (unsigned long )end)) {
#line 528
      goto while_break;
    }
#line 529
    if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
      repeat: 
      {
#line 533
      key = c->key;
#line 534
      tmp = (*fn)(key, c->value, arg);
      }
#line 534
      if (tmp) {
#line 535
        return;
      }
#line 537
      if ((unsigned long )c->key != (unsigned long )key) {
#line 537
        if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
#line 538
          goto repeat;
        }
      }
    }
#line 528
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 552 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
void hash_table_iterate(struct hash_table *ht , hash_table_iterator *iter ) 
{ 


  {
#line 555
  iter->pos = (void *)ht->cells;
#line 556
  iter->end = (void *)(ht->cells + ht->size);
#line 557
  return;
}
}
#line 568 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
int hash_table_iter_next(hash_table_iterator *iter ) 
{ 
  struct cell *c ;
  struct cell *end ;

  {
#line 571
  c = (struct cell *)iter->pos;
#line 572
  end = (struct cell *)iter->end;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! ((unsigned long )c < (unsigned long )end)) {
#line 573
      goto while_break;
    }
#line 574
    if ((unsigned long )c->key != (unsigned long )((void *)0xffffffffffffffffUL)) {
#line 576
      iter->key = c->key;
#line 577
      iter->value = c->value;
#line 578
      iter->pos = (void *)(c + 1);
#line 579
      return (1);
    }
#line 573
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  return (0);
}
}
#line 588 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
int hash_table_count(struct hash_table  const  *ht ) 
{ 


  {
#line 591
  return ((int )ht->count);
}
}
#line 642 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static unsigned long hash_string(void const   *key ) 
{ 
  char const   *p___0 ;
  unsigned int h ;

  {
#line 645
  p___0 = (char const   *)key;
#line 646
  h = (unsigned int )*p___0;
#line 648
  if (h) {
#line 649
    p___0 ++;
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;
#line 649
      if (! ((int const   )*p___0 != 0)) {
#line 649
        goto while_break;
      }
#line 650
      h = ((h << 5) - h) + (unsigned int )*p___0;
#line 649
      p___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 652
  return ((unsigned long )h);
}
}
#line 657 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int cmp_string(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 660
  tmp = strcmp((char const   *)s1, (char const   *)s2);
  }
#line 660
  if (tmp) {
#line 660
    tmp___0 = 0;
  } else {
#line 660
    tmp___0 = 1;
  }
#line 660
  return (tmp___0);
}
}
#line 666 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
struct hash_table *make_string_hash_table(int items ) 
{ 
  struct hash_table *tmp ;

  {
  {
#line 669
  tmp = hash_table_new(items, & hash_string, & cmp_string);
  }
#line 669
  return (tmp);
}
}
#line 680 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static unsigned long hash_string_nocase(void const   *key ) 
{ 
  char const   *p___0 ;
  unsigned int h ;

  {
#line 683
  p___0 = (char const   *)key;
#line 684
  h = (unsigned int )_sch_tolower[(int const   )*p___0 & 255];
#line 686
  if (h) {
#line 687
    p___0 ++;
    {
#line 687
    while (1) {
      while_continue: /* CIL Label */ ;
#line 687
      if (! ((int const   )*p___0 != 0)) {
#line 687
        goto while_break;
      }
#line 688
      h = ((h << 5) - h) + (unsigned int )_sch_tolower[(int const   )*p___0 & 255];
#line 687
      p___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 690
  return ((unsigned long )h);
}
}
#line 695 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int string_cmp_nocase(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 698
  tmp = strcasecmp((char const   *)s1, (char const   *)s2);
  }
#line 698
  if (tmp) {
#line 698
    tmp___0 = 0;
  } else {
#line 698
    tmp___0 = 1;
  }
#line 698
  return (tmp___0);
}
}
#line 704 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
struct hash_table *make_nocase_string_hash_table(int items ) 
{ 
  struct hash_table *tmp ;

  {
  {
#line 707
  tmp = hash_table_new(items, & hash_string_nocase, & string_cmp_nocase);
  }
#line 707
  return (tmp);
}
}
#line 718 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
unsigned long hash_pointer(void const   *ptr ) 
{ 
  uintptr_t key ;

  {
#line 721
  key = (uintptr_t )ptr;
#line 722
  key += key << 12;
#line 723
  key ^= key >> 22;
#line 724
  key += key << 4;
#line 725
  key ^= key >> 9;
#line 726
  key += key << 10;
#line 727
  key ^= key >> 2;
#line 728
  key += key << 7;
#line 729
  key ^= key >> 12;
#line 731
  key += key << 44;
#line 732
  key ^= key >> 54;
#line 733
  key += key << 36;
#line 734
  key ^= key >> 41;
#line 735
  key += key << 42;
#line 736
  key ^= key >> 34;
#line 737
  key += key << 39;
#line 738
  key ^= key >> 44;
#line 740
  return (key);
}
}
#line 743 "/home/khheo/project/benchmark/wget-1.11.4/src/hash.c"
static int cmp_pointer(void const   *ptr1 , void const   *ptr2 ) 
{ 


  {
#line 746
  return ((unsigned long )ptr1 == (unsigned long )ptr2);
}
}
#line 40 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 41
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 42
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 61 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
int gen_md5_context_size(void) 
{ 


  {
#line 64
  return ((int )sizeof(struct gen_md5_context ));
}
}
#line 67 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
void gen_md5_init(gen_md5_context *ctx ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 70
  ctx_imp = & ctx->imp;
#line 81
  MD5_Init(ctx_imp);
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
void gen_md5_update(unsigned char const   *buffer___0 , int len , gen_md5_context *ctx ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 88
  ctx_imp = & ctx->imp;
#line 99
  MD5_Update(ctx_imp, (void const   *)buffer___0, (size_t )len);
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/wget-1.11.4/src/gen-md5.c"
void gen_md5_finish(gen_md5_context *ctx , unsigned char *result ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 106
  ctx_imp = & ctx->imp;
#line 117
  MD5_Final(result, ctx_imp);
  }
#line 119
  return;
}
}
#line 69 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
char const   *skey_response(int sequence , char const   *seed , char const   *pass ) ;
#line 43 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
static char Wp[2048][4]  = 
#line 43 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
  { {        (char )'A',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'C',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'A',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'G',        (char )'O',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'A',        (char )'L',        (char )'L',        (char )'\000'}, 
   {        (char )'A',        (char )'L',        (char )'P',        (char )'\000'}, 
   {        (char )'A',        (char )'M',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'M',        (char )'Y',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'A',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'Y',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'S',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'C',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'M',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'H',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'T',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'T',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'A',        (char )'U',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'V',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'L',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'N',        (char )'\000'}, 
   {        (char )'A',        (char )'X',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'H',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'Y',        (char )'\000',        (char )'\000'}, 
   {        (char )'B',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'C',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'S',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'D',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'E',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'E',        (char )'D',        (char )'\000',        (char )'\000'}, 
   {        (char )'E',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'E',        (char )'G',        (char )'G',        (char )'\000'}, 
   {        (char )'E',        (char )'G',        (char )'O',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'I',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'K',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'M',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'E',        (char )'M',        (char )'\000',        (char )'\000'}, 
   {        (char )'E',        (char )'N',        (char )'D',        (char )'\000'}, 
   {        (char )'E',        (char )'S',        (char )'T',        (char )'\000'}, 
   {        (char )'E',        (char )'T',        (char )'C',        (char )'\000'}, 
   {        (char )'E',        (char )'V',        (char )'A',        (char )'\000'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'\000'}, 
   {        (char )'E',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'E',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'\000'}, 
   {        (char )'F',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'G',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'G',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'Y',        (char )'\000'}, 
   {        (char )'G',        (char )'Y',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'Y',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'S',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'C',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'H',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'I',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'C',        (char )'Y',        (char )'\000'}, 
   {        (char )'I',        (char )'D',        (char )'A',        (char )'\000'}, 
   {        (char )'I',        (char )'F',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'K',        (char )'E',        (char )'\000'}, 
   {        (char )'I',        (char )'L',        (char )'L',        (char )'\000'}, 
   {        (char )'I',        (char )'N',        (char )'K',        (char )'\000'}, 
   {        (char )'I',        (char )'N',        (char )'N',        (char )'\000'}, 
   {        (char )'I',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'I',        (char )'Q',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'A',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'K',        (char )'\000'}, 
   {        (char )'I',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'T',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'T',        (char )'S',        (char )'\000'}, 
   {        (char )'I',        (char )'V',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'J',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'K',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'O',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'U',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'L',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'O',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'M',        (char )'Y',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'R',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'V',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'F',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'K',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'D',        (char )'D',        (char )'\000'}, 
   {        (char )'O',        (char )'D',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'H',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'O',        (char )'K',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'L',        (char )'D',        (char )'\000'}, 
   {        (char )'O',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'N',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'B',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'T',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'V',        (char )'A',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'L',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'N',        (char )'\000'}, 
   {        (char )'O',        (char )'X',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'H',        (char )'I',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'O',        (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'Q',        (char )'U',        (char )'O',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'O',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'C',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'H',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'S',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'\000'}, 
   {        (char )'S',        (char )'K',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'P',        (char )'A',        (char )'\000'}, 
   {        (char )'S',        (char )'P',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'C',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'W',        (char )'O',        (char )'\000'}, 
   {        (char )'U',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'P',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'\000'}, 
   {        (char )'V',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'V',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'V',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'V',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'B',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'\000'}, 
   {        (char )'W',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'W',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'K',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'W',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'U',        (char )'\000',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'S',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'Y',        (char )'O',        (char )'U',        (char )'\000'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'D'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'L'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'T'}, 
   {        (char )'A',        (char )'B',        (char )'L',        (char )'E'}, 
   {        (char )'A',        (char )'B',        (char )'U',        (char )'T'}, 
   {        (char )'A',        (char )'C',        (char )'H',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'C',        (char )'M',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'R',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'A'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'S'}, 
   {        (char )'A',        (char )'D',        (char )'A',        (char )'M'}, 
   {        (char )'A',        (char )'D',        (char )'D',        (char )'S'}, 
   {        (char )'A',        (char )'D',        (char )'E',        (char )'N'}, 
   {        (char )'A',        (char )'F',        (char )'A',        (char )'R'}, 
   {        (char )'A',        (char )'F',        (char )'R',        (char )'O'}, 
   {        (char )'A',        (char )'G',        (char )'E',        (char )'E'}, 
   {        (char )'A',        (char )'H',        (char )'E',        (char )'M'}, 
   {        (char )'A',        (char )'H',        (char )'O',        (char )'Y'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'A'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'S'}, 
   {        (char )'A',        (char )'I',        (char )'R',        (char )'Y'}, 
   {        (char )'A',        (char )'J',        (char )'A',        (char )'R'}, 
   {        (char )'A',        (char )'K',        (char )'I',        (char )'N'}, 
   {        (char )'A',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'A',        (char )'L',        (char )'E',        (char )'C'}, 
   {        (char )'A',        (char )'L',        (char )'G',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'I',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'L',        (char )'Y'}, 
   {        (char )'A',        (char )'L',        (char )'M',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'O',        (char )'E'}, 
   {        (char )'A',        (char )'L',        (char )'S',        (char )'O'}, 
   {        (char )'A',        (char )'L',        (char )'T',        (char )'O'}, 
   {        (char )'A',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'A',        (char )'L',        (char )'V',        (char )'A'}, 
   {        (char )'A',        (char )'M',        (char )'E',        (char )'N'}, 
   {        (char )'A',        (char )'M',        (char )'E',        (char )'S'}, 
   {        (char )'A',        (char )'M',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'M',        (char )'M',        (char )'O'}, 
   {        (char )'A',        (char )'M',        (char )'O',        (char )'K'}, 
   {        (char )'A',        (char )'M',        (char )'O',        (char )'S'}, 
   {        (char )'A',        (char )'M',        (char )'R',        (char )'A'}, 
   {        (char )'A',        (char )'N',        (char )'D',        (char )'Y'}, 
   {        (char )'A',        (char )'N',        (char )'E',        (char )'W'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'A'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'E'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'E'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'I'}, 
   {        (char )'A',        (char )'Q',        (char )'U',        (char )'A'}, 
   {        (char )'A',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'A',        (char )'R',        (char )'C',        (char )'H'}, 
   {        (char )'A',        (char )'R',        (char )'E',        (char )'A'}, 
   {        (char )'A',        (char )'R',        (char )'G',        (char )'O'}, 
   {        (char )'A',        (char )'R',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'R',        (char )'M',        (char )'Y'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'S'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'Y'}, 
   {        (char )'A',        (char )'S',        (char )'I',        (char )'A'}, 
   {        (char )'A',        (char )'S',        (char )'K',        (char )'S'}, 
   {        (char )'A',        (char )'T',        (char )'O',        (char )'M'}, 
   {        (char )'A',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'A',        (char )'U',        (char )'R',        (char )'A'}, 
   {        (char )'A',        (char )'U',        (char )'T',        (char )'O'}, 
   {        (char )'A',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'A',        (char )'V',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'V',        (char )'I',        (char )'S'}, 
   {        (char )'A',        (char )'V',        (char )'O',        (char )'N'}, 
   {        (char )'A',        (char )'V',        (char )'O',        (char )'W'}, 
   {        (char )'A',        (char )'W',        (char )'A',        (char )'Y'}, 
   {        (char )'A',        (char )'W',        (char )'R',        (char )'Y'}, 
   {        (char )'B',        (char )'A',        (char )'B',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'B',        (char )'Y'}, 
   {        (char )'B',        (char )'A',        (char )'C',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'B',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'B',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'I'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'M'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'B'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'R'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'W',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'W',        (char )'L'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'U'}, 
   {        (char )'B',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'F'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'A'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'A'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'H',        (char )'O',        (char )'Y'}, 
   {        (char )'B',        (char )'I',        (char )'A',        (char )'S'}, 
   {        (char )'B',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'E',        (char )'N'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'I',        (char )'R',        (char )'D'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'B',        (char )'L',        (char )'A',        (char )'B'}, 
   {        (char )'B',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'B',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'C'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'C',        (char )'A'}, 
   {        (char )'B',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'D',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'G',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'H',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'O'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'M',        (char )'B'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'A'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'B',        (char )'O',        (char )'Y',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'E'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'N'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'B',        (char )'R',        (char )'E',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'B',        (char )'R',        (char )'I',        (char )'G'}, 
   {        (char )'B',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'B',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'B',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'B',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'B'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'O',        (char )'Y'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'R'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'Y'}, 
   {        (char )'B',        (char )'Y',        (char )'T',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'D',        (char )'Y'}, 
   {        (char )'C',        (char )'A',        (char )'F',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'F'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'M'}, 
   {        (char )'C',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'R'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'C',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'C',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'C',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'D'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'R'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'F'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'I',        (char )'C'}, 
   {        (char )'C',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'O',        (char )'U'}, 
   {        (char )'C',        (char )'H',        (char )'O',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'B'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'G'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'M'}, 
   {        (char )'C',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'C',        (char )'I',        (char )'T',        (char )'Y'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'D'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'W'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'Y'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'D'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'C',        (char )'L',        (char )'U',        (char )'B'}, 
   {        (char )'C',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'O'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'Y'}, 
   {        (char )'C',        (char )'O',        (char )'E',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'K',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'B'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'C',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'C',        (char )'R',        (char )'I',        (char )'B'}, 
   {        (char )'C',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'C',        (char )'R',        (char )'U',        (char )'D'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'A'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'C',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'C',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'U',        (char )'L',        (char )'T'}, 
   {        (char )'C',        (char )'U',        (char )'N',        (char )'Y'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'B'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'C',        (char )'U',        (char )'T',        (char )'S'}, 
   {        (char )'D',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'A'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'D',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'D',        (char )'A',        (char )'T',        (char )'A'}, 
   {        (char )'D',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'D',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'D',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'F'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'D',        (char )'E',        (char )'B',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'D',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'F',        (char )'Y'}, 
   {        (char )'D',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'Y'}, 
   {        (char )'D',        (char )'E',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'I',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'R',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'C'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'O',        (char )'E',        (char )'S'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'D',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'D',        (char )'O',        (char )'O',        (char )'R'}, 
   {        (char )'D',        (char )'O',        (char )'R',        (char )'A'}, 
   {        (char )'D',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'U',        (char )'G'}, 
   {        (char )'D',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'D',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'W'}, 
   {        (char )'D',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'B'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'G'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'M'}, 
   {        (char )'D',        (char )'U',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'C',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'D',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'M',        (char )'B'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'T',        (char )'Y'}, 
   {        (char )'E',        (char )'A',        (char )'C',        (char )'H'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'Y'}, 
   {        (char )'E',        (char )'B',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'C',        (char )'H',        (char )'O'}, 
   {        (char )'E',        (char )'D',        (char )'D',        (char )'Y'}, 
   {        (char )'E',        (char )'D',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'D',        (char )'G',        (char )'E'}, 
   {        (char )'E',        (char )'D',        (char )'G',        (char )'Y'}, 
   {        (char )'E',        (char )'D',        (char )'I',        (char )'T'}, 
   {        (char )'E',        (char )'D',        (char )'N',        (char )'A'}, 
   {        (char )'E',        (char )'G',        (char )'A',        (char )'N'}, 
   {        (char )'E',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'E',        (char )'L',        (char )'B',        (char )'A'}, 
   {        (char )'E',        (char )'L',        (char )'L',        (char )'A'}, 
   {        (char )'E',        (char )'L',        (char )'S',        (char )'E'}, 
   {        (char )'E',        (char )'M',        (char )'I',        (char )'L'}, 
   {        (char )'E',        (char )'M',        (char )'I',        (char )'T'}, 
   {        (char )'E',        (char )'M',        (char )'M',        (char )'A'}, 
   {        (char )'E',        (char )'N',        (char )'D',        (char )'S'}, 
   {        (char )'E',        (char )'R',        (char )'I',        (char )'C'}, 
   {        (char )'E',        (char )'R',        (char )'O',        (char )'S'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'E',        (char )'V',        (char )'I',        (char )'L'}, 
   {        (char )'E',        (char )'Y',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'C',        (char )'T'}, 
   {        (char )'F',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'F',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'F',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'F',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'F',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'F',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'U',        (char )'D'}, 
   {        (char )'F',        (char )'I',        (char )'E',        (char )'F'}, 
   {        (char )'F',        (char )'I',        (char )'G',        (char )'S'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'M'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'F',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'G'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'K'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'A'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'I',        (char )'T'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'C'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'U',        (char )'B'}, 
   {        (char )'F',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'F',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'F',        (char )'O',        (char )'G',        (char )'Y'}, 
   {        (char )'F',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'L',        (char )'K'}, 
   {        (char )'F',        (char )'O',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'F',        (char )'O',        (char )'U',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'F',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'F',        (char )'R',        (char )'A',        (char )'U'}, 
   {        (char )'F',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'E'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'T'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'Y'}, 
   {        (char )'F',        (char )'R',        (char )'O',        (char )'G'}, 
   {        (char )'F',        (char )'R',        (char )'O',        (char )'M'}, 
   {        (char )'F',        (char )'U',        (char )'E',        (char )'L'}, 
   {        (char )'F',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'U',        (char )'M',        (char )'E'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'F',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'F',        (char )'U',        (char )'S',        (char )'E'}, 
   {        (char )'F',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'G',        (char )'A',        (char )'F',        (char )'F'}, 
   {        (char )'G',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'A'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'G',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'G',        (char )'A',        (char )'R',        (char )'B'}, 
   {        (char )'G',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'G',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'U',        (char )'R'}, 
   {        (char )'G',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'W',        (char )'K'}, 
   {        (char )'G',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'G',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'E',        (char )'N',        (char )'E'}, 
   {        (char )'G',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'G',        (char )'E',        (char )'R',        (char )'M'}, 
   {        (char )'G',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'G',        (char )'I',        (char )'B',        (char )'E'}, 
   {        (char )'G',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'G',        (char )'I',        (char )'R',        (char )'D'}, 
   {        (char )'G',        (char )'I',        (char )'R',        (char )'L'}, 
   {        (char )'G',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'L',        (char )'E',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'E',        (char )'N'}, 
   {        (char )'G',        (char )'L',        (char )'I',        (char )'B'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'M'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'E',        (char )'R'}, 
   {        (char )'G',        (char )'O',        (char )'E',        (char )'S'}, 
   {        (char )'G',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'L',        (char )'F'}, 
   {        (char )'G',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'G',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'G',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'G',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'G',        (char )'O',        (char )'R',        (char )'Y'}, 
   {        (char )'G',        (char )'O',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'G'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'Y'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'D'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'N'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'T'}, 
   {        (char )'G',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'G',        (char )'R',        (char )'U',        (char )'B'}, 
   {        (char )'G',        (char )'U',        (char )'L',        (char )'F'}, 
   {        (char )'G',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'G',        (char )'U',        (char )'R',        (char )'U'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'G',        (char )'W',        (char )'E',        (char )'N'}, 
   {        (char )'G',        (char )'W',        (char )'Y',        (char )'N'}, 
   {        (char )'H',        (char )'A',        (char )'A',        (char )'G'}, 
   {        (char )'H',        (char )'A',        (char )'A',        (char )'S'}, 
   {        (char )'H',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'F'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'O'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'S'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'H',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'W',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'H',        (char )'E',        (char )'B',        (char )'E'}, 
   {        (char )'H',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'M'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'B'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'E'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'O'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'W',        (char )'N'}, 
   {        (char )'H',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'G',        (char )'H'}, 
   {        (char )'H',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'H',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'H',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'H',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'B',        (char )'O'}, 
   {        (char )'H',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'F',        (char )'F'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'M'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'H',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'H',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'H',        (char )'O',        (char )'Y',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'E',        (char )'D'}, 
   {        (char )'H',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'E'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'H'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'O'}, 
   {        (char )'H',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'H',        (char )'Y',        (char )'D',        (char )'E'}, 
   {        (char )'H',        (char )'Y',        (char )'M',        (char )'N'}, 
   {        (char )'I',        (char )'B',        (char )'I',        (char )'S'}, 
   {        (char )'I',        (char )'C',        (char )'O',        (char )'N'}, 
   {        (char )'I',        (char )'D',        (char )'E',        (char )'A'}, 
   {        (char )'I',        (char )'D',        (char )'L',        (char )'E'}, 
   {        (char )'I',        (char )'F',        (char )'F',        (char )'Y'}, 
   {        (char )'I',        (char )'N',        (char )'C',        (char )'A'}, 
   {        (char )'I',        (char )'N',        (char )'C',        (char )'H'}, 
   {        (char )'I',        (char )'N',        (char )'T',        (char )'O'}, 
   {        (char )'I',        (char )'O',        (char )'N',        (char )'S'}, 
   {        (char )'I',        (char )'O',        (char )'T',        (char )'A'}, 
   {        (char )'I',        (char )'O',        (char )'W',        (char )'A'}, 
   {        (char )'I',        (char )'R',        (char )'I',        (char )'S'}, 
   {        (char )'I',        (char )'R',        (char )'M',        (char )'A'}, 
   {        (char )'I',        (char )'R',        (char )'O',        (char )'N'}, 
   {        (char )'I',        (char )'S',        (char )'L',        (char )'E'}, 
   {        (char )'I',        (char )'T',        (char )'C',        (char )'H'}, 
   {        (char )'I',        (char )'T',        (char )'E',        (char )'M'}, 
   {        (char )'I',        (char )'V',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'J',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'J',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'V',        (char )'A'}, 
   {        (char )'J',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'E',        (char )'F',        (char )'F'}, 
   {        (char )'J',        (char )'E',        (char )'R',        (char )'K'}, 
   {        (char )'J',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'J',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'J',        (char )'I',        (char )'B',        (char )'E'}, 
   {        (char )'J',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'J',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'J',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'J',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'B',        (char )'S'}, 
   {        (char )'J',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'L'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'Y'}, 
   {        (char )'J',        (char )'O',        (char )'H',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'I',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'J',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'O'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'J',        (char )'U'}, 
   {        (char )'J',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'L',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'O'}, 
   {        (char )'J',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'J',        (char )'U',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'H',        (char )'N'}, 
   {        (char )'K',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'K',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'K',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'K',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'O'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'K',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'K',        (char )'E',        (char )'R',        (char )'R'}, 
   {        (char )'K',        (char )'E',        (char )'Y',        (char )'S'}, 
   {        (char )'K',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'K',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'K',        (char )'I',        (char )'R',        (char )'K'}, 
   {        (char )'K',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'K',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'K',        (char )'N',        (char )'E',        (char )'E'}, 
   {        (char )'K',        (char )'N',        (char )'E',        (char )'W'}, 
   {        (char )'K',        (char )'N',        (char )'I',        (char )'T'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'B'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'T'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'W'}, 
   {        (char )'K',        (char )'O',        (char )'C',        (char )'H'}, 
   {        (char )'K',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'K',        (char )'U',        (char )'D',        (char )'O'}, 
   {        (char )'K',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'K',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'K',        (char )'Y',        (char )'L',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'Y'}, 
   {        (char )'L',        (char )'A',        (char )'D',        (char )'Y'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'L',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'B'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'L',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'U',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'V',        (char )'A'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'S'}, 
   {        (char )'L',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'F'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'L',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'L',        (char )'I',        (char )'A',        (char )'R'}, 
   {        (char )'L',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'N'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'S'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'U'}, 
   {        (char )'L',        (char )'I',        (char )'F',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'Y'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'B'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'I',        (char )'S',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'F'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'L',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'O',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'G',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'I',        (char )'S'}, 
   {        (char )'L',        (char )'O',        (char )'L',        (char )'A'}, 
   {        (char )'L',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'U',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'U',        (char )'C',        (char )'Y'}, 
   {        (char )'L',        (char )'U',        (char )'G',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'L',        (char )'U'}, 
   {        (char )'L',        (char )'U',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'A'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'K'}, 
   {        (char )'L',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'L',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'Y',        (char )'L',        (char )'E'}, 
   {        (char )'L',        (char )'Y',        (char )'N',        (char )'N'}, 
   {        (char )'L',        (char )'Y',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'Y',        (char )'R',        (char )'A'}, 
   {        (char )'M',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'G',        (char )'I'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'M',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'I'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'A'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'N'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'Y'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'C'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'S'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'M',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'Y',        (char )'O'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'M',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'M',        (char )'O'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'U'}, 
   {        (char )'M',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'M',        (char )'I'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'I'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'M',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'A'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'K'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'R'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'M',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'M',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'M',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'M',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'M',        (char )'U',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'U',        (char )'R',        (char )'K'}, 
   {        (char )'M',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'U',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'T',        (char )'T'}, 
   {        (char )'M',        (char )'Y',        (char )'R',        (char )'A'}, 
   {        (char )'M',        (char )'Y',        (char )'T',        (char )'H'}, 
   {        (char )'N',        (char )'A',        (char )'G',        (char )'Y'}, 
   {        (char )'N',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'N',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'N',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'N',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'N',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'N',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'N',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'N',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'N',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'N',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'O',        (char )'N'}, 
   {        (char )'N',        (char )'E',        (char )'R',        (char )'O'}, 
   {        (char )'N',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'N',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'S'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'T'}, 
   {        (char )'N',        (char )'I',        (char )'B',        (char )'S'}, 
   {        (char )'N',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'N',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'N',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'N',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'N',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'A',        (char )'H'}, 
   {        (char )'N',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'E',        (char )'L'}, 
   {        (char )'N',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'N',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'N',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'N',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'U',        (char )'N'}, 
   {        (char )'N',        (char )'O',        (char )'V',        (char )'A'}, 
   {        (char )'N',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'N',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'U',        (char )'M',        (char )'B'}, 
   {        (char )'O',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'O',        (char )'B',        (char )'E',        (char )'Y'}, 
   {        (char )'O',        (char )'B',        (char )'O',        (char )'E'}, 
   {        (char )'O',        (char )'D',        (char )'I',        (char )'N'}, 
   {        (char )'O',        (char )'H',        (char )'I',        (char )'O'}, 
   {        (char )'O',        (char )'I',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'O',        (char )'K',        (char )'A',        (char )'Y'}, 
   {        (char )'O',        (char )'L',        (char )'A',        (char )'F'}, 
   {        (char )'O',        (char )'L',        (char )'D',        (char )'Y'}, 
   {        (char )'O',        (char )'L',        (char )'G',        (char )'A'}, 
   {        (char )'O',        (char )'L',        (char )'I',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'A',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'E',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'I',        (char )'T'}, 
   {        (char )'O',        (char )'N',        (char )'C',        (char )'E'}, 
   {        (char )'O',        (char )'N',        (char )'E',        (char )'S'}, 
   {        (char )'O',        (char )'N',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'N',        (char )'T',        (char )'O'}, 
   {        (char )'O',        (char )'N',        (char )'U',        (char )'S'}, 
   {        (char )'O',        (char )'R',        (char )'A',        (char )'L'}, 
   {        (char )'O',        (char )'R',        (char )'G',        (char )'Y'}, 
   {        (char )'O',        (char )'S',        (char )'L',        (char )'O'}, 
   {        (char )'O',        (char )'T',        (char )'I',        (char )'S'}, 
   {        (char )'O',        (char )'T',        (char )'T',        (char )'O'}, 
   {        (char )'O',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'O',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'O',        (char )'U',        (char )'T',        (char )'S'}, 
   {        (char )'O',        (char )'V',        (char )'A',        (char )'L'}, 
   {        (char )'O',        (char )'V',        (char )'E',        (char )'N'}, 
   {        (char )'O',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'O',        (char )'W',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'W',        (char )'N',        (char )'S'}, 
   {        (char )'Q',        (char )'U',        (char )'A',        (char )'D'}, 
   {        (char )'Q',        (char )'U',        (char )'I',        (char )'T'}, 
   {        (char )'Q',        (char )'U',        (char )'O',        (char )'D'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'Y'}, 
   {        (char )'R',        (char )'A',        (char )'F',        (char )'T'}, 
   {        (char )'R',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'R',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'R',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'F'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'R',        (char )'E',        (char )'I',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'A'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'H'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'R',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'R',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'R',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'R',        (char )'O',        (char )'B',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'R',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'R',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'A'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'Y'}, 
   {        (char )'R',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'R',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'R',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'Y'}, 
   {        (char )'R',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'D',        (char )'Y'}, 
   {        (char )'R',        (char )'U',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'U',        (char )'L',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'R',        (char )'U',        (char )'T',        (char )'H'}, 
   {        (char )'S',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'F',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'S',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'R',        (char )'A'}, 
   {        (char )'S',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'S',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'C',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'S'}, 
   {        (char )'S',        (char )'E',        (char )'L',        (char )'F'}, 
   {        (char )'S',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'S',        (char )'E',        (char )'W',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'W'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'H',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'H',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'D'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'E'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'H',        (char )'U',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'U',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'G',        (char )'H'}, 
   {        (char )'S',        (char )'I',        (char )'G',        (char )'N'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'O'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'U'}, 
   {        (char )'S',        (char )'K',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'K',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'N'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'R'}, 
   {        (char )'S',        (char )'M',        (char )'O',        (char )'G'}, 
   {        (char )'S',        (char )'M',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'N',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'N',        (char )'O',        (char )'B'}, 
   {        (char )'S',        (char )'N',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'N',        (char )'U',        (char )'B'}, 
   {        (char )'S',        (char )'N',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'O',        (char )'A',        (char )'K'}, 
   {        (char )'S',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'O',        (char )'D',        (char )'A'}, 
   {        (char )'S',        (char )'O',        (char )'F',        (char )'A'}, 
   {        (char )'S',        (char )'O',        (char )'F',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'S',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'S',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'S',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'S',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'U',        (char )'L'}, 
   {        (char )'S',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'S',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'T',        (char )'E',        (char )'M'}, 
   {        (char )'S',        (char )'T',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'T',        (char )'I',        (char )'R'}, 
   {        (char )'S',        (char )'T',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'T',        (char )'U',        (char )'B'}, 
   {        (char )'S',        (char )'T',        (char )'U',        (char )'N'}, 
   {        (char )'S',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'S',        (char )'U',        (char )'D',        (char )'S'}, 
   {        (char )'S',        (char )'U',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'U',        (char )'M',        (char )'S'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'U',        (char )'R',        (char )'F'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'W',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'W',        (char )'U',        (char )'M'}, 
   {        (char )'T',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'C',        (char )'T'}, 
   {        (char )'T',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'T',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'U',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'T',        (char )'E',        (char )'C',        (char )'H'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'R',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'T',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'T',        (char )'H',        (char )'A',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'E'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'M'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'Y'}, 
   {        (char )'T',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'I',        (char )'S'}, 
   {        (char )'T',        (char )'H',        (char )'U',        (char )'D'}, 
   {        (char )'T',        (char )'H',        (char )'U',        (char )'G'}, 
   {        (char )'T',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'D',        (char )'Y'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'R'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'T',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'Y'}, 
   {        (char )'T',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'T',        (char )'O',        (char )'G',        (char )'O'}, 
   {        (char )'T',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'T',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'Y'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'T',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'T',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'T',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'T',        (char )'R',        (char )'E',        (char )'E'}, 
   {        (char )'T',        (char )'R',        (char )'E',        (char )'K'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'G'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'O'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'D'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'T'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'Y'}, 
   {        (char )'T',        (char )'R',        (char )'U',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'A'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'U',        (char )'F',        (char )'T'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'A'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'T',        (char )'U',        (char )'R',        (char )'F'}, 
   {        (char )'T',        (char )'U',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'G'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'N'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'T'}, 
   {        (char )'U',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'U',        (char )'N',        (char )'I',        (char )'T'}, 
   {        (char )'U',        (char )'R',        (char )'G',        (char )'E'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'D'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'R'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'S'}, 
   {        (char )'U',        (char )'T',        (char )'A',        (char )'H'}, 
   {        (char )'V',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'V',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'V',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'V',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'V',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'V',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'V',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'V',        (char )'E',        (char )'D',        (char )'A'}, 
   {        (char )'V',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'V',        (char )'E',        (char )'I',        (char )'N'}, 
   {        (char )'V',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'V',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'V',        (char )'E',        (char )'R',        (char )'B'}, 
   {        (char )'V',        (char )'E',        (char )'R',        (char )'Y'}, 
   {        (char )'V',        (char )'E',        (char )'T',        (char )'O'}, 
   {        (char )'V',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'V',        (char )'I',        (char )'E',        (char )'W'}, 
   {        (char )'V',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'V',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'V',        (char )'O',        (char )'I',        (char )'D'}, 
   {        (char )'V',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'V',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'W',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'W',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'T',        (char )'S'}, 
   {        (char )'W',        (char )'A',        (char )'T',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'W',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'W',        (char )'E',        (char )'I',        (char )'R'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'A',        (char )'M'}, 
   {        (char )'W',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'E'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'A'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'M'}, 
   {        (char )'W',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'W',        (char )'I',        (char )'F',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'W',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'O'}, 
   {        (char )'W',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'W',        (char )'I',        (char )'T',        (char )'H'}, 
   {        (char )'W',        (char )'O',        (char )'L',        (char )'F'}, 
   {        (char )'W',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'W',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'W',        (char )'R',        (char )'I',        (char )'T'}, 
   {        (char )'W',        (char )'Y',        (char )'N',        (char )'N'}, 
   {        (char )'Y',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'Y',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'Y',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'Y',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'Y',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'L'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'H'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'Y',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'Y',        (char )'O',        (char )'G',        (char )'A'}, 
   {        (char )'Y',        (char )'O',        (char )'K',        (char )'E'}};
#line 2098 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
static uint32_t extract(unsigned char const   *s , int start , int length ) 
{ 
  unsigned char cl ;
  unsigned char cc ;
  unsigned char cr ;
  uint32_t x ;

  {
#line 2101
  cl = (unsigned char )*(s + start / 8);
#line 2102
  cc = (unsigned char )*(s + (start / 8 + 1));
#line 2103
  cr = (unsigned char )*(s + (start / 8 + 2));
#line 2105
  x = ((uint32_t )(((int )cl << 8) | (int )cc) << 8) | (unsigned int )cr;
#line 2106
  x >>= 24 - (length + start % 8);
#line 2107
  x &= (unsigned int )(65535 >> (16 - length));
#line 2108
  return (x);
}
}
#line 2119 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
static char *btoe(char *store , unsigned char const   *c ) 
{ 
  unsigned char cp[10] ;
  int p___0 ;
  int i ;
  char *store_beg ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  uint32_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  uint32_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  uint32_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  uint32_t tmp___25 ;
  long tmp___26 ;

  {
  {
#line 2125
  store_beg = store;
#line 2127
  *store = (char )'\000';
#line 2130
  memset((void *)(& cp), '\000', sizeof(cp));
#line 2131
  memcpy((void */* __restrict  */)(cp), (void const   */* __restrict  */)c, (size_t )8);
#line 2134
  p___0 = 0;
#line 2134
  i = 0;
  }
  {
#line 2134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2134
    if (! (i < 64)) {
#line 2134
      goto while_break;
    }
    {
#line 2135
    tmp = extract((unsigned char const   *)(cp), i, 2);
#line 2135
    p___0 = (int )((uint32_t )p___0 + tmp);
#line 2134
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2136
  cp[8] = (unsigned char )((int )((char )p___0) << 6);
#line 2143
  tmp___0 = extract((unsigned char const   *)(cp), 0, 11);
#line 2143
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___0][0]),
         (size_t )4);
  }
#line 2144
  if (! *(store + 1)) {
#line 2144
    tmp___3 = 1;
  } else {
#line 2144
    if (! *(store + 2)) {
#line 2144
      tmp___2 = 2;
    } else {
#line 2144
      if (! *(store + 3)) {
#line 2144
        tmp___1 = 3;
      } else {
#line 2144
        tmp___1 = 4;
      }
#line 2144
      tmp___2 = tmp___1;
    }
#line 2144
    tmp___3 = tmp___2;
  }
  {
#line 2144
  store += tmp___3;
#line 2145
  tmp___4 = store;
#line 2145
  store ++;
#line 2145
  *tmp___4 = (char )' ';
#line 2146
  tmp___5 = extract((unsigned char const   *)(cp), 11, 11);
#line 2146
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___5][0]),
         (size_t )4);
  }
#line 2147
  if (! *(store + 1)) {
#line 2147
    tmp___8 = 1;
  } else {
#line 2147
    if (! *(store + 2)) {
#line 2147
      tmp___7 = 2;
    } else {
#line 2147
      if (! *(store + 3)) {
#line 2147
        tmp___6 = 3;
      } else {
#line 2147
        tmp___6 = 4;
      }
#line 2147
      tmp___7 = tmp___6;
    }
#line 2147
    tmp___8 = tmp___7;
  }
  {
#line 2147
  store += tmp___8;
#line 2148
  tmp___9 = store;
#line 2148
  store ++;
#line 2148
  *tmp___9 = (char )' ';
#line 2149
  tmp___10 = extract((unsigned char const   *)(cp), 22, 11);
#line 2149
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___10][0]),
         (size_t )4);
  }
#line 2150
  if (! *(store + 1)) {
#line 2150
    tmp___13 = 1;
  } else {
#line 2150
    if (! *(store + 2)) {
#line 2150
      tmp___12 = 2;
    } else {
#line 2150
      if (! *(store + 3)) {
#line 2150
        tmp___11 = 3;
      } else {
#line 2150
        tmp___11 = 4;
      }
#line 2150
      tmp___12 = tmp___11;
    }
#line 2150
    tmp___13 = tmp___12;
  }
  {
#line 2150
  store += tmp___13;
#line 2151
  tmp___14 = store;
#line 2151
  store ++;
#line 2151
  *tmp___14 = (char )' ';
#line 2152
  tmp___15 = extract((unsigned char const   *)(cp), 33, 11);
#line 2152
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___15][0]),
         (size_t )4);
  }
#line 2153
  if (! *(store + 1)) {
#line 2153
    tmp___18 = 1;
  } else {
#line 2153
    if (! *(store + 2)) {
#line 2153
      tmp___17 = 2;
    } else {
#line 2153
      if (! *(store + 3)) {
#line 2153
        tmp___16 = 3;
      } else {
#line 2153
        tmp___16 = 4;
      }
#line 2153
      tmp___17 = tmp___16;
    }
#line 2153
    tmp___18 = tmp___17;
  }
  {
#line 2153
  store += tmp___18;
#line 2154
  tmp___19 = store;
#line 2154
  store ++;
#line 2154
  *tmp___19 = (char )' ';
#line 2155
  tmp___20 = extract((unsigned char const   *)(cp), 44, 11);
#line 2155
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___20][0]),
         (size_t )4);
  }
#line 2156
  if (! *(store + 1)) {
#line 2156
    tmp___23 = 1;
  } else {
#line 2156
    if (! *(store + 2)) {
#line 2156
      tmp___22 = 2;
    } else {
#line 2156
      if (! *(store + 3)) {
#line 2156
        tmp___21 = 3;
      } else {
#line 2156
        tmp___21 = 4;
      }
#line 2156
      tmp___22 = tmp___21;
    }
#line 2156
    tmp___23 = tmp___22;
  }
  {
#line 2156
  store += tmp___23;
#line 2157
  tmp___24 = store;
#line 2157
  store ++;
#line 2157
  *tmp___24 = (char )' ';
#line 2158
  tmp___25 = extract((unsigned char const   *)(cp), 55, 11);
#line 2158
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___25][0]),
         (size_t )4);
#line 2159
  *(store + 4) = (char )'\000';
  }
  {
#line 2161
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2161
    tmp___26 = __builtin_expect((long )opt.debug, 0L);
    }
#line 2161
    if (tmp___26) {
      {
#line 2161
      debug_logprintf("wrote `%s\' to STORE\n", store_beg);
      }
    }
#line 2161
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2162
  return (store_beg);
}
}
#line 2198 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
static char english[30]  ;
#line 2191 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-opie.c"
char const   *skey_response(int sequence , char const   *seed , char const   *pass ) 
{ 
  unsigned char key[8] ;
  gen_md5_context *md5_ctx ;
  int tmp ;
  void *tmp___0 ;
  uint32_t checksum[4] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 2200
  tmp = gen_md5_context_size();
#line 2200
  tmp___0 = __builtin_alloca((unsigned long )tmp);
#line 2200
  md5_ctx = (gen_md5_context *)tmp___0;
#line 2203
  gen_md5_init(md5_ctx);
#line 2204
  tmp___1 = strlen(seed);
#line 2204
  gen_md5_update((unsigned char const   *)seed, (int )tmp___1, md5_ctx);
#line 2205
  tmp___2 = strlen(pass);
#line 2205
  gen_md5_update((unsigned char const   *)pass, (int )tmp___2, md5_ctx);
#line 2206
  gen_md5_finish(md5_ctx, (unsigned char *)(checksum));
#line 2207
  checksum[0] ^= checksum[2];
#line 2208
  checksum[1] ^= checksum[3];
#line 2209
  memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)(checksum),
         (size_t )8);
  }
  {
#line 2211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2211
    tmp___3 = sequence;
#line 2211
    sequence --;
#line 2211
    if (! (tmp___3 > 0)) {
#line 2211
      goto while_break;
    }
    {
#line 2213
    gen_md5_init(md5_ctx);
#line 2214
    gen_md5_update((unsigned char const   *)(key), 8, md5_ctx);
#line 2215
    gen_md5_finish(md5_ctx, (unsigned char *)(checksum));
#line 2216
    checksum[0] ^= checksum[2];
#line 2217
    checksum[1] ^= checksum[3];
#line 2218
    memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)(checksum),
           (size_t )8);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2220
  tmp___4 = btoe(english, (unsigned char const   *)(key));
  }
#line 2220
  return ((char const   *)tmp___4);
}
}
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 805 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 811
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 47 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
char ftp_last_respline[128] ;
#line 49
uerr_t ftp_response(int fd , char **ret_line ) ;
#line 50
uerr_t ftp_login(int csock , char const   *acc , char const   *pass ) ;
#line 51
uerr_t ftp_port(int csock , int *local_sock ) ;
#line 52
uerr_t ftp_pasv(int csock , ip_address *addr , int *port ) ;
#line 54
uerr_t ftp_lprt(int csock , int *local_sock ) ;
#line 55
uerr_t ftp_lpsv(int csock , ip_address *addr , int *port ) ;
#line 56
uerr_t ftp_eprt(int csock , int *local_sock ) ;
#line 57
uerr_t ftp_epsv(int csock , ip_address *ip___0 , int *port ) ;
#line 59
uerr_t ftp_type(int csock , int type ) ;
#line 60
uerr_t ftp_cwd(int csock , char const   *dir ) ;
#line 61
uerr_t ftp_retr(int csock , char const   *file ) ;
#line 62
uerr_t ftp_rest(int csock , wgint offset ) ;
#line 63
uerr_t ftp_list(int csock , char const   *file ) ;
#line 64
uerr_t ftp_syst(int csock , enum stype *server_type ) ;
#line 65
uerr_t ftp_pwd(int csock , char **pwd ) ;
#line 66
uerr_t ftp_size(int csock , char const   *file , wgint *size ) ;
#line 122
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) ;
#line 125
uerr_t ftp_index(char const   *file , struct url *u , struct fileinfo *f ) ;
#line 127
char ftp_process_type(char const   *params ) ;
#line 43 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
int connect_to_ip(ip_address const   *ip___0 , int port , char const   *print ) ;
#line 46
int accept_connection(int local_sock ) ;
#line 77 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static wgint ftp_expected_bytes(char const   *s ) 
{ 
  wgint res___0 ;
  int tmp ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 84
      if (*s) {
#line 84
        if (! ((int const   )*s != 40)) {
#line 84
          goto while_break___0;
        }
      } else {
#line 84
        goto while_break___0;
      }
#line 85
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    if (! *s) {
#line 87
      return ((wgint )0);
    }
    {
#line 88
    s ++;
#line 89
    res___0 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((char **)(& s)),
                     10);
    }
#line 90
    if (! *s) {
#line 91
      return ((wgint )0);
    }
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (*s) {
#line 92
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 64)) {
#line 92
          goto while_break___1;
        }
      } else {
#line 92
        goto while_break___1;
      }
#line 93
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 94
    if (! *s) {
#line 95
      return ((wgint )0);
    }
#line 96
    if ((int const   )_sch_tolower[(int const   )*s & 255] != 98) {
#line 97
      goto while_continue;
    }
    {
#line 98
    tmp = strncasecmp(s, "byte", (size_t )4);
    }
#line 98
    if (tmp) {
#line 99
      goto while_continue;
    } else {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (res___0);
}
}
#line 111 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_do_pasv(int csock , ip_address *addr , int *port ) 
{ 
  uerr_t err ;
  _Bool tmp ;

  {
  {
#line 119
  tmp = socket_ip_address(csock, addr, 1);
  }
#line 119
  if (! tmp) {
    {
#line 120
    abort();
    }
  }
  {
#line 127
  if (addr->family == 2) {
#line 127
    goto case_2;
  }
#line 132
  if (addr->family == 10) {
#line 132
    goto case_10;
  }
#line 145
  goto switch_default;
  case_2: /* CIL Label */ 
#line 128
  if (! opt.server_response) {
    {
#line 129
    logputs((enum log_options )0, "==> PASV ... ");
    }
  }
  {
#line 130
  err = ftp_pasv(csock, addr, port);
  }
#line 131
  goto switch_break;
  case_10: /* CIL Label */ 
#line 133
  if (! opt.server_response) {
    {
#line 134
    logputs((enum log_options )0, "==> EPSV ... ");
    }
  }
  {
#line 135
  err = ftp_epsv(csock, addr, port);
  }
#line 138
  if ((unsigned int )err == 36U) {
#line 140
    if (! opt.server_response) {
      {
#line 141
      logputs((enum log_options )0, "==> LPSV ... ");
      }
    }
    {
#line 142
    err = ftp_lpsv(csock, addr, port);
    }
  }
#line 144
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 146
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 149
  return (err);
}
}
#line 156 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_do_port(int csock , int *local_sock ) 
{ 
  uerr_t err ;
  ip_address cip ;
  _Bool tmp ;

  {
  {
#line 162
  tmp = socket_ip_address(csock, & cip, 1);
  }
#line 162
  if (! tmp) {
    {
#line 163
    abort();
    }
  }
  {
#line 170
  if (cip.family == 2) {
#line 170
    goto case_2;
  }
#line 175
  if (cip.family == 10) {
#line 175
    goto case_10;
  }
#line 188
  goto switch_default;
  case_2: /* CIL Label */ 
#line 171
  if (! opt.server_response) {
    {
#line 172
    logputs((enum log_options )0, "==> PORT ... ");
    }
  }
  {
#line 173
  err = ftp_port(csock, local_sock);
  }
#line 174
  goto switch_break;
  case_10: /* CIL Label */ 
#line 176
  if (! opt.server_response) {
    {
#line 177
    logputs((enum log_options )0, "==> EPRT ... ");
    }
  }
  {
#line 178
  err = ftp_eprt(csock, local_sock);
  }
#line 181
  if ((unsigned int )err == 13U) {
#line 183
    if (! opt.server_response) {
      {
#line 184
      logputs((enum log_options )0, "==> LPRT ... ");
      }
    }
    {
#line 185
    err = ftp_lprt(csock, local_sock);
    }
  }
#line 187
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 189
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 191
  return (err);
}
}
#line 212 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static void print_length(wgint size , wgint start , _Bool authoritative ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 215
  tmp = number_to_static_string(size);
#line 215
  tmp___0 = gettext("Length: %s");
#line 215
  logprintf((enum log_options )0, (char const   *)tmp___0, tmp);
  }
#line 216
  if (size >= 1024L) {
    {
#line 217
    tmp___1 = human_readable(size);
#line 217
    logprintf((enum log_options )0, " (%s)", tmp___1);
    }
  }
#line 218
  if (start > 0L) {
#line 220
    if (start >= 1024L) {
      {
#line 221
      tmp___2 = human_readable(size - start);
#line 221
      tmp___3 = number_to_static_string(size - start);
#line 221
      tmp___4 = gettext(", %s (%s) remaining");
#line 221
      logprintf((enum log_options )0, (char const   *)tmp___4, tmp___3, tmp___2);
      }
    } else {
      {
#line 225
      tmp___5 = number_to_static_string(size - start);
#line 225
      tmp___6 = gettext(", %s remaining");
#line 225
      logprintf((enum log_options )0, (char const   *)tmp___6, tmp___5);
      }
    }
  }
#line 228
  if (! authoritative) {
    {
#line 228
    tmp___7 = gettext(" (unauthoritative)\n");
#line 228
    tmp___8 = (char const   *)tmp___7;
    }
  } else {
#line 228
    tmp___8 = "\n";
  }
  {
#line 228
  logputs((enum log_options )0, tmp___8);
  }
#line 229
  return;
}
}
#line 234 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t getftp(struct url *u , wgint *len , wgint restval , ccon *con ) 
{ 
  int csock ;
  int dtsock ;
  int local_sock ;
  int res___0 ;
  uerr_t err ;
  FILE *fp ;
  char *user ;
  char *passwd ;
  char *respline ;
  char *tms ;
  char const   *tmrate ;
  int cmd ;
  _Bool pasv_mode_open ;
  wgint expected_bytes ;
  _Bool rest_failed ;
  int flags ;
  wgint rd_size ;
  char *tmp___3 ;
  char *tmp___4 ;
  char type_char ;
  char *host ;
  char *tmp___5 ;
  int port ;
  int tmp___6 ;
  char *logname ;
  int tmp___9 ;
  int *tmp___10 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *path ;
  char *tmp___24 ;
  char *pathend ;
  char *tmp___25 ;
  char *tmp___26 ;
  long tmp___27 ;
  char *idir ;
  long tmp___28 ;
  long tmp___29 ;
  char *tmp___30 ;
  long tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *target ;
  long tmp___38 ;
  int idlen ;
  size_t tmp___39 ;
  char *ntarget ;
  char *p___0 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  char *tmp___42 ;
  long tmp___43 ;
  long tmp___44 ;
  char *tmpp ;
  char *ntarget___0 ;
  size_t tmp___45 ;
  void *tmp___46 ;
  char *tmp___48 ;
  long tmp___49 ;
  long tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char const   *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char const   *tmp___62 ;
  ip_address passive_addr ;
  int passive_port ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char const   *tmp___67 ;
  long tmp___68 ;
  int save_errno ;
  int *tmp___69 ;
  char *tmp___70 ;
  char const   *tmp___71 ;
  char *tmp___72 ;
  int tmp___74 ;
  _Bool tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  int *tmp___79 ;
  char *tmp___80 ;
  int *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char const   *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char const   *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  long tmp___101 ;
  int *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  int *tmp___105 ;
  int *tmp___106 ;
  char *tmp___107 ;
  wgint tmp___108 ;
  time_t tmp___109 ;
  int *tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char const   *tmp___113 ;
  char *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  char *line ;
  char *p___1 ;
  char *tmp___119 ;
  char const   *tmp___120 ;

  {
#line 238
  err = (uerr_t )31;
#line 243
  cmd = con->cmd;
#line 244
  pasv_mode_open = (_Bool)0;
#line 245
  expected_bytes = (wgint )0;
#line 246
  rest_failed = (_Bool)0;
#line 250
  if (! ((unsigned long )con != (unsigned long )((void *)0))) {
    {
#line 250
    __assert_fail("con != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                  250U, "getftp");
    }
  }
#line 251
  if (! ((unsigned long )con->target != (unsigned long )((void *)0))) {
    {
#line 251
    __assert_fail("con->target != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                  251U, "getftp");
    }
  }
#line 256
  if (cmd & 8) {
#line 256
    if (cmd & 4) {
      {
#line 256
      __assert_fail("!((cmd & DO_LIST) && (cmd & DO_RETR))", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                    256U, "getftp");
      }
    }
  }
#line 258
  if (! ((cmd & 15) != 0)) {
    {
#line 258
    __assert_fail("(cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                  258U, "getftp");
    }
  }
  {
#line 260
  user = u->user;
#line 261
  passwd = u->passwd;
#line 262
  search_netrc((char const   *)u->host, (char const   **)(& user), (char const   **)(& passwd),
               1);
  }
#line 263
  if (user) {
#line 263
    user = user;
  } else {
#line 263
    if (opt.ftp_user) {
#line 263
      tmp___3 = opt.ftp_user;
    } else {
#line 263
      tmp___3 = opt.user;
    }
#line 263
    user = tmp___3;
  }
#line 264
  if (! user) {
#line 264
    user = (char *)"anonymous";
  }
#line 265
  if (passwd) {
#line 265
    passwd = passwd;
  } else {
#line 265
    if (opt.ftp_passwd) {
#line 265
      tmp___4 = opt.ftp_passwd;
    } else {
#line 265
      tmp___4 = opt.passwd;
    }
#line 265
    passwd = tmp___4;
  }
#line 266
  if (! passwd) {
#line 266
    passwd = (char *)"-wget@";
  }
#line 268
  dtsock = -1;
#line 269
  local_sock = -1;
#line 270
  con->dltime = (double )0;
#line 272
  if (! (cmd & 1)) {
#line 273
    csock = con->csock;
  } else {
#line 277
    if (con->proxy) {
#line 277
      tmp___5 = (con->proxy)->host;
    } else {
#line 277
      tmp___5 = u->host;
    }
#line 277
    host = tmp___5;
#line 278
    if (con->proxy) {
#line 278
      tmp___6 = (con->proxy)->port;
    } else {
#line 278
      tmp___6 = u->port;
    }
#line 278
    port = tmp___6;
#line 279
    logname = user;
#line 281
    if (con->proxy) {
      {
#line 284
      logname = concat_strings((char const   *)user, "@", u->host, (char *)0);
      }
    }
    {
#line 291
    csock = connect_to_host((char const   *)host, port);
    }
#line 292
    if (csock == -100) {
#line 293
      return ((uerr_t )1);
    } else
#line 294
    if (csock < 0) {
      {
#line 295
      tmp___10 = __errno_location();
#line 295
      tmp___11 = retryable_socket_connect_error(*tmp___10);
      }
#line 295
      if (tmp___11) {
#line 295
        tmp___9 = 3;
      } else {
#line 295
        tmp___9 = 5;
      }
#line 295
      return ((uerr_t )tmp___9);
    }
#line 298
    if (cmd & 16) {
#line 299
      con->csock = csock;
    } else {
#line 301
      con->csock = -1;
    }
    {
#line 304
    tmp___12 = escnonprint((char const   *)user);
#line 304
    tmp___13 = gettext("Logging in as %s ... ");
#line 304
    logprintf((enum log_options )0, (char const   *)tmp___13, tmp___12);
    }
#line 305
    if (opt.server_response) {
      {
#line 306
      logputs((enum log_options )3, "\n");
      }
    }
    {
#line 307
    err = ftp_login(csock, (char const   *)logname, (char const   *)passwd);
    }
#line 309
    if (con->proxy) {
      {
#line 310
      checking_free((void *)logname);
      }
    }
    {
#line 315
    if ((unsigned int )err == 18U) {
#line 315
      goto case_18;
    }
#line 322
    if ((unsigned int )err == 20U) {
#line 322
      goto case_20;
    }
#line 328
    if ((unsigned int )err == 52U) {
#line 328
      goto case_52;
    }
#line 335
    if ((unsigned int )err == 12U) {
#line 335
      goto case_12;
    }
#line 341
    if ((unsigned int )err == 11U) {
#line 341
      goto case_11;
    }
#line 347
    if ((unsigned int )err == 10U) {
#line 347
      goto case_10;
    }
#line 351
    goto switch_default;
    case_18: /* CIL Label */ 
    {
#line 316
    logputs((enum log_options )0, "\n");
#line 317
    tmp___14 = gettext("Error in server response, closing control connection.\n");
#line 317
    logputs((enum log_options )1, (char const   *)tmp___14);
#line 319
    fd_close(csock);
#line 320
    con->csock = -1;
    }
#line 321
    return (err);
    case_20: /* CIL Label */ 
    {
#line 323
    logputs((enum log_options )0, "\n");
#line 324
    tmp___15 = gettext("Error in server greeting.\n");
#line 324
    logputs((enum log_options )1, (char const   *)tmp___15);
#line 325
    fd_close(csock);
#line 326
    con->csock = -1;
    }
#line 327
    return (err);
    case_52: /* CIL Label */ 
    {
#line 329
    logputs((enum log_options )0, "\n");
#line 330
    tmp___16 = gettext("Write failed, closing control connection.\n");
#line 330
    logputs((enum log_options )1, (char const   *)tmp___16);
#line 332
    fd_close(csock);
#line 333
    con->csock = -1;
    }
#line 334
    return (err);
    case_12: /* CIL Label */ 
    {
#line 336
    logputs((enum log_options )0, "\n");
#line 337
    tmp___17 = gettext("The server refuses login.\n");
#line 337
    logputs((enum log_options )1, (char const   *)tmp___17);
#line 338
    fd_close(csock);
#line 339
    con->csock = -1;
    }
#line 340
    return ((uerr_t )12);
    case_11: /* CIL Label */ 
    {
#line 342
    logputs((enum log_options )0, "\n");
#line 343
    tmp___18 = gettext("Login incorrect.\n");
#line 343
    logputs((enum log_options )1, (char const   *)tmp___18);
#line 344
    fd_close(csock);
#line 345
    con->csock = -1;
    }
#line 346
    return ((uerr_t )11);
    case_10: /* CIL Label */ 
#line 348
    if (! opt.server_response) {
      {
#line 349
      tmp___19 = gettext("Logged in!\n");
#line 349
      logputs((enum log_options )0, (char const   *)tmp___19);
      }
    }
#line 350
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 352
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 355
    if (! opt.server_response) {
      {
#line 356
      logprintf((enum log_options )0, "==> SYST ... ");
      }
    }
    {
#line 357
    err = ftp_syst(csock, & con->rs);
    }
    {
#line 361
    if ((unsigned int )err == 18U) {
#line 361
      goto case_18___0;
    }
#line 368
    if ((unsigned int )err == 20U) {
#line 368
      goto case_20___0;
    }
#line 373
    if ((unsigned int )err == 10U) {
#line 373
      goto case_10___0;
    }
#line 376
    goto switch_default___0;
    case_18___0: /* CIL Label */ 
    {
#line 362
    logputs((enum log_options )0, "\n");
#line 363
    tmp___20 = gettext("Error in server response, closing control connection.\n");
#line 363
    logputs((enum log_options )1, (char const   *)tmp___20);
#line 365
    fd_close(csock);
#line 366
    con->csock = -1;
    }
#line 367
    return (err);
    case_20___0: /* CIL Label */ 
    {
#line 369
    logputs((enum log_options )0, "\n");
#line 370
    tmp___21 = gettext("Server error, can\'t determine system type.\n");
#line 370
    logputs((enum log_options )1, (char const   *)tmp___21);
    }
#line 372
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 375
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 377
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 379
    if (! opt.server_response) {
#line 379
      if ((unsigned int )err != 20U) {
        {
#line 380
        tmp___22 = gettext("done.    ");
#line 380
        logputs((enum log_options )0, (char const   *)tmp___22);
        }
      }
    }
#line 384
    if (! opt.server_response) {
      {
#line 385
      logprintf((enum log_options )0, "==> PWD ... ");
      }
    }
    {
#line 386
    err = ftp_pwd(csock, & con->id);
    }
    {
#line 390
    if ((unsigned int )err == 18U) {
#line 390
      goto case_18___1;
    }
#line 397
    if ((unsigned int )err == 20U) {
#line 397
      goto case_20___1;
    }
#line 402
    if ((unsigned int )err == 10U) {
#line 402
      goto case_10___1;
    }
#line 405
    goto switch_default___1;
    case_18___1: /* CIL Label */ 
    {
#line 391
    logputs((enum log_options )0, "\n");
#line 392
    tmp___23 = gettext("Error in server response, closing control connection.\n");
#line 392
    logputs((enum log_options )1, (char const   *)tmp___23);
#line 394
    fd_close(csock);
#line 395
    con->csock = -1;
    }
#line 396
    return (err);
    case_20___1: /* CIL Label */ 
#line 399
    if (! (! con->id)) {
      {
#line 399
      checking_free((void *)con->id);
      }
    }
    {
#line 400
    con->id = checking_strdup("/");
    }
#line 401
    goto switch_break___1;
    case_10___1: /* CIL Label */ 
#line 404
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 406
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 410
    if ((unsigned int )con->rs == 1U) {
      {
#line 412
      tmp___24 = strchr((char const   *)con->id, '[');
#line 412
      path = tmp___24;
      }
#line 413
      if (path) {
        {
#line 413
        tmp___25 = strchr((char const   *)(path + 1), ']');
#line 413
        tmp___26 = tmp___25;
        }
      } else {
#line 413
        tmp___26 = (char *)((void *)0);
      }
#line 413
      pathend = tmp___26;
#line 414
      if (! path) {
#line 414
        goto _L;
      } else
#line 414
      if (! pathend) {
        _L: /* CIL Label */ 
        {
#line 415
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 415
          tmp___27 = __builtin_expect((long )opt.debug, 0L);
          }
#line 415
          if (tmp___27) {
            {
#line 415
            debug_logprintf("Initial VMS directory not in the form [...]!\n");
            }
          }
#line 415
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 418
        idir = con->id;
        {
#line 419
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 419
          tmp___28 = __builtin_expect((long )opt.debug, 0L);
          }
#line 419
          if (tmp___28) {
            {
#line 419
            debug_logprintf("Preprocessing the initial VMS directory\n");
            }
          }
#line 419
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 420
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 420
          tmp___29 = __builtin_expect((long )opt.debug, 0L);
          }
#line 420
          if (tmp___29) {
            {
#line 420
            debug_logprintf("  old = \'%s\'\n", con->id);
            }
          }
#line 420
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 424
        tmp___30 = idir;
#line 424
        idir ++;
#line 424
        *tmp___30 = (char )'/';
#line 425
        path ++;
        {
#line 425
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 425
          if (! ((unsigned long )path < (unsigned long )pathend)) {
#line 425
            goto while_break___2;
          }
#line 426
          if ((int )*path == 46) {
#line 426
            *idir = (char )'/';
          } else {
#line 426
            *idir = *path;
          }
#line 425
          path ++;
#line 425
          idir ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 427
        *idir = (char )'\000';
        {
#line 428
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 428
          tmp___31 = __builtin_expect((long )opt.debug, 0L);
          }
#line 428
          if (tmp___31) {
            {
#line 428
            debug_logprintf("  new = \'%s\'\n\n", con->id);
            }
          }
#line 428
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 431
    if (! opt.server_response) {
      {
#line 432
      tmp___32 = gettext("done.\n");
#line 432
      logputs((enum log_options )0, (char const   *)tmp___32);
      }
    }
    {
#line 435
    type_char = ftp_process_type((char const   *)u->params);
    }
#line 436
    if (! opt.server_response) {
      {
#line 437
      logprintf((enum log_options )0, "==> TYPE %c ... ", (int )type_char);
      }
    }
    {
#line 438
    err = ftp_type(csock, (int )type_char);
    }
    {
#line 442
    if ((unsigned int )err == 18U) {
#line 442
      goto case_18___2;
    }
#line 449
    if ((unsigned int )err == 52U) {
#line 449
      goto case_52___0;
    }
#line 456
    if ((unsigned int )err == 17U) {
#line 456
      goto case_17;
    }
#line 464
    if ((unsigned int )err == 10U) {
#line 464
      goto case_10___2;
    }
#line 467
    goto switch_default___2;
    case_18___2: /* CIL Label */ 
    {
#line 443
    logputs((enum log_options )0, "\n");
#line 444
    tmp___33 = gettext("Error in server response, closing control connection.\n");
#line 444
    logputs((enum log_options )1, (char const   *)tmp___33);
#line 446
    fd_close(csock);
#line 447
    con->csock = -1;
    }
#line 448
    return (err);
    case_52___0: /* CIL Label */ 
    {
#line 450
    logputs((enum log_options )0, "\n");
#line 451
    tmp___34 = gettext("Write failed, closing control connection.\n");
#line 451
    logputs((enum log_options )1, (char const   *)tmp___34);
#line 453
    fd_close(csock);
#line 454
    con->csock = -1;
    }
#line 455
    return (err);
    case_17: /* CIL Label */ 
    {
#line 457
    logputs((enum log_options )0, "\n");
#line 458
    tmp___35 = gettext("Unknown type `%c\', closing control connection.\n");
#line 458
    logprintf((enum log_options )1, (char const   *)tmp___35, (int )type_char);
#line 461
    fd_close(csock);
#line 462
    con->csock = -1;
    }
#line 463
    return (err);
    case_10___2: /* CIL Label */ 
#line 466
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 468
    abort();
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 470
    if (! opt.server_response) {
      {
#line 471
      tmp___36 = gettext("done.  ");
#line 471
      logputs((enum log_options )0, (char const   *)tmp___36);
      }
    }
  }
#line 474
  if (cmd & 2) {
#line 476
    if (! *(u->dir)) {
      {
#line 477
      tmp___37 = gettext("==> CWD not needed.\n");
#line 477
      logputs((enum log_options )0, (char const   *)tmp___37);
      }
    } else {
#line 480
      target = u->dir;
      {
#line 482
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 482
        tmp___38 = __builtin_expect((long )opt.debug, 0L);
        }
#line 482
        if (tmp___38) {
          {
#line 482
          debug_logprintf("changing working directory\n");
          }
        }
#line 482
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 498
      if ((int )*(target + 0) != 47) {
#line 498
        if ((unsigned int )con->rs != 0U) {
#line 498
          if ((int const   )_sch_istable[(int )*(target + 0) & 255] & 136) {
#line 498
            if (! ((int )*(target + 1) == 58)) {
#line 498
              goto _L___1;
            }
          } else {
#line 498
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 498
        if ((unsigned int )con->rs != 4U) {
          {
#line 504
          tmp___39 = strlen((char const   *)con->id);
#line 504
          idlen = (int )tmp___39;
          }
          {
#line 508
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 508
            if (idlen > 0) {
#line 508
              if (! ((int )*(con->id + (idlen - 1)) == 47)) {
#line 508
                goto while_break___5;
              }
            } else {
#line 508
              goto while_break___5;
            }
#line 509
            idlen --;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 510
          tmp___40 = strlen((char const   *)u->dir);
#line 510
          tmp___41 = __builtin_alloca(((size_t )(idlen + 1) + tmp___40) + 1UL);
#line 510
          ntarget = (char *)tmp___41;
#line 510
          p___0 = ntarget;
#line 511
          memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)con->id,
                 (size_t )idlen);
#line 512
          p___0 += idlen;
#line 513
          tmp___42 = p___0;
#line 513
          p___0 ++;
#line 513
          *tmp___42 = (char )'/';
#line 514
          strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)target);
          }
          {
#line 516
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 516
            tmp___43 = __builtin_expect((long )opt.debug, 0L);
            }
#line 516
            if (tmp___43) {
              {
#line 516
              debug_logprintf("Prepended initial PWD to relative path:\n");
              }
            }
#line 516
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 517
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 517
            tmp___44 = __builtin_expect((long )opt.debug, 0L);
            }
#line 517
            if (tmp___44) {
              {
#line 517
              debug_logprintf("   pwd: \'%s\'\n   old: \'%s\'\n  new: \'%s\'\n", con->id,
                              target, ntarget);
              }
            }
#line 517
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 519
          target = ntarget;
        }
      }
#line 527
      if ((unsigned int )con->rs == 1U) {
        {
#line 530
        tmp___45 = strlen((char const   *)target);
#line 530
        tmp___46 = __builtin_alloca(tmp___45 + 2UL);
#line 530
        ntarget___0 = (char *)tmp___46;
#line 535
        strcpy((char */* __restrict  */)ntarget___0, (char const   */* __restrict  */)target);
        }
#line 536
        if (! ((int )*ntarget___0 == 47)) {
          {
#line 536
          __assert_fail("*ntarget == \'/\'", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                        536U, "getftp");
          }
        }
#line 537
        *ntarget___0 = (char )'[';
#line 538
        tmpp = ntarget___0 + 1;
        {
#line 538
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 538
          if (! *tmpp) {
#line 538
            goto while_break___8;
          }
#line 539
          if ((int )*tmpp == 47) {
#line 540
            *tmpp = (char )'.';
          }
#line 538
          tmpp ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 541
        tmp___48 = tmpp;
#line 541
        tmpp ++;
#line 541
        *tmp___48 = (char )']';
#line 542
        *tmpp = (char )'\000';
        {
#line 543
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 543
          tmp___49 = __builtin_expect((long )opt.debug, 0L);
          }
#line 543
          if (tmp___49) {
            {
#line 543
            debug_logprintf("Changed file name to VMS syntax:\n");
            }
          }
#line 543
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 544
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 544
          tmp___50 = __builtin_expect((long )opt.debug, 0L);
          }
#line 544
          if (tmp___50) {
            {
#line 544
            debug_logprintf("  Unix: \'%s\'\n  VMS: \'%s\'\n", target, ntarget___0);
            }
          }
#line 544
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 545
        target = ntarget___0;
      }
#line 548
      if (! opt.server_response) {
        {
#line 549
        tmp___51 = escnonprint((char const   *)target);
#line 549
        logprintf((enum log_options )0, "==> CWD %s ... ", tmp___51);
        }
      }
      {
#line 550
      err = ftp_cwd(csock, (char const   *)target);
      }
      {
#line 554
      if ((unsigned int )err == 18U) {
#line 554
        goto case_18___3;
      }
#line 561
      if ((unsigned int )err == 52U) {
#line 561
        goto case_52___1;
      }
#line 568
      if ((unsigned int )err == 15U) {
#line 568
        goto case_15;
      }
#line 575
      if ((unsigned int )err == 10U) {
#line 575
        goto case_10___3;
      }
#line 577
      goto switch_default___3;
      case_18___3: /* CIL Label */ 
      {
#line 555
      logputs((enum log_options )0, "\n");
#line 556
      tmp___52 = gettext("Error in server response, closing control connection.\n");
#line 556
      logputs((enum log_options )1, (char const   *)tmp___52);
#line 558
      fd_close(csock);
#line 559
      con->csock = -1;
      }
#line 560
      return (err);
      case_52___1: /* CIL Label */ 
      {
#line 562
      logputs((enum log_options )0, "\n");
#line 563
      tmp___53 = gettext("Write failed, closing control connection.\n");
#line 563
      logputs((enum log_options )1, (char const   *)tmp___53);
#line 565
      fd_close(csock);
#line 566
      con->csock = -1;
      }
#line 567
      return (err);
      case_15: /* CIL Label */ 
      {
#line 569
      logputs((enum log_options )0, "\n");
#line 570
      tmp___54 = escnonprint((char const   *)u->dir);
#line 570
      tmp___55 = gettext("No such directory `%s\'.\n\n");
#line 570
      logprintf((enum log_options )1, (char const   *)tmp___55, tmp___54);
#line 572
      fd_close(csock);
#line 573
      con->csock = -1;
      }
#line 574
      return (err);
      case_10___3: /* CIL Label */ 
#line 576
      goto switch_break___3;
      switch_default___3: /* CIL Label */ 
      {
#line 578
      abort();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 580
      if (! opt.server_response) {
        {
#line 581
        tmp___56 = gettext("done.\n");
#line 581
        logputs((enum log_options )0, (char const   *)tmp___56);
        }
      }
    }
  } else {
    {
#line 585
    tmp___57 = gettext("==> CWD not required.\n");
#line 585
    logputs((enum log_options )0, (char const   *)tmp___57);
    }
  }
#line 587
  if (cmd & 4) {
#line 587
    if (*len == 0L) {
#line 589
      if (opt.verbose) {
#line 591
        if (! opt.server_response) {
          {
#line 592
          tmp___58 = escnonprint((char const   *)u->file);
#line 592
          logprintf((enum log_options )0, "==> SIZE %s ... ", tmp___58);
          }
        }
      }
      {
#line 595
      err = ftp_size(csock, (char const   *)u->file, len);
      }
      {
#line 600
      if ((unsigned int )err == 20U) {
#line 600
        goto case_20___2;
      }
#line 600
      if ((unsigned int )err == 18U) {
#line 600
        goto case_20___2;
      }
#line 607
      if ((unsigned int )err == 10U) {
#line 607
        goto case_10___4;
      }
#line 610
      goto switch_default___4;
      case_20___2: /* CIL Label */ 
      case_18___4: /* CIL Label */ 
      {
#line 601
      logputs((enum log_options )0, "\n");
#line 602
      tmp___59 = gettext("Error in server response, closing control connection.\n");
#line 602
      logputs((enum log_options )1, (char const   *)tmp___59);
#line 604
      fd_close(csock);
#line 605
      con->csock = -1;
      }
#line 606
      return (err);
      case_10___4: /* CIL Label */ 
#line 609
      goto switch_break___4;
      switch_default___4: /* CIL Label */ 
      {
#line 611
      abort();
      }
      switch_break___4: /* CIL Label */ ;
      }
#line 613
      if (! opt.server_response) {
        {
#line 614
        tmp___60 = number_to_static_string(*len);
        }
#line 614
        if (*len) {
#line 614
          tmp___62 = "%s\n";
        } else {
          {
#line 614
          tmp___61 = gettext("done.\n");
#line 614
          tmp___62 = (char const   *)tmp___61;
          }
        }
        {
#line 614
        logprintf((enum log_options )0, tmp___62, tmp___60);
        }
      }
    }
  }
#line 619
  if (cmd & 12) {
#line 621
    if (opt.ftp_pasv) {
      {
#line 625
      err = ftp_do_pasv(csock, & passive_addr, & passive_port);
      }
      {
#line 629
      if ((unsigned int )err == 18U) {
#line 629
        goto case_18___5;
      }
#line 636
      if ((unsigned int )err == 52U) {
#line 636
        goto case_52___2;
      }
#line 643
      if ((unsigned int )err == 36U) {
#line 643
        goto case_36;
      }
#line 647
      if ((unsigned int )err == 35U) {
#line 647
        goto case_35;
      }
#line 651
      if ((unsigned int )err == 10U) {
#line 651
        goto case_10___5;
      }
#line 653
      goto switch_default___5;
      case_18___5: /* CIL Label */ 
      {
#line 630
      logputs((enum log_options )0, "\n");
#line 631
      tmp___63 = gettext("Error in server response, closing control connection.\n");
#line 631
      logputs((enum log_options )1, (char const   *)tmp___63);
#line 633
      fd_close(csock);
#line 634
      con->csock = -1;
      }
#line 635
      return (err);
      case_52___2: /* CIL Label */ 
      {
#line 637
      logputs((enum log_options )0, "\n");
#line 638
      tmp___64 = gettext("Write failed, closing control connection.\n");
#line 638
      logputs((enum log_options )1, (char const   *)tmp___64);
#line 640
      fd_close(csock);
#line 641
      con->csock = -1;
      }
#line 642
      return (err);
      case_36: /* CIL Label */ 
      {
#line 644
      logputs((enum log_options )0, "\n");
#line 645
      tmp___65 = gettext("Cannot initiate PASV transfer.\n");
#line 645
      logputs((enum log_options )1, (char const   *)tmp___65);
      }
#line 646
      goto switch_break___5;
      case_35: /* CIL Label */ 
      {
#line 648
      logputs((enum log_options )0, "\n");
#line 649
      tmp___66 = gettext("Cannot parse PASV response.\n");
#line 649
      logputs((enum log_options )1, (char const   *)tmp___66);
      }
#line 650
      goto switch_break___5;
      case_10___5: /* CIL Label */ 
#line 652
      goto switch_break___5;
      switch_default___5: /* CIL Label */ 
      {
#line 654
      abort();
      }
      switch_break___5: /* CIL Label */ ;
      }
#line 656
      if ((unsigned int )err == 10U) {
        {
#line 658
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 658
          tmp___68 = __builtin_expect((long )opt.debug, 0L);
          }
#line 658
          if (tmp___68) {
            {
#line 658
            tmp___67 = print_address((ip_address const   *)(& passive_addr));
#line 658
            debug_logprintf("trying to connect to %s port %d\n", tmp___67, passive_port);
            }
          }
#line 658
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 660
        dtsock = connect_to_ip((ip_address const   *)(& passive_addr), passive_port,
                               (char const   *)((void *)0));
        }
#line 661
        if (dtsock < 0) {
          {
#line 663
          tmp___69 = __errno_location();
#line 663
          save_errno = *tmp___69;
#line 664
          fd_close(csock);
#line 665
          con->csock = -1;
#line 666
          tmp___70 = strerror(save_errno);
#line 666
          tmp___71 = print_address((ip_address const   *)(& passive_addr));
#line 666
          tmp___72 = gettext("couldn\'t connect to %s port %d: %s\n");
#line 666
          logprintf((enum log_options )0, (char const   *)tmp___72, tmp___71, passive_port,
                    tmp___70);
#line 669
          tmp___75 = retryable_socket_connect_error(save_errno);
          }
#line 669
          if (tmp___75) {
#line 669
            tmp___74 = 3;
          } else {
#line 669
            tmp___74 = 5;
          }
#line 669
          return ((uerr_t )tmp___74);
        }
#line 673
        pasv_mode_open = (_Bool)1;
#line 674
        if (! opt.server_response) {
          {
#line 675
          tmp___76 = gettext("done.    ");
#line 675
          logputs((enum log_options )0, (char const   *)tmp___76);
          }
        }
      }
    }
#line 679
    if (! pasv_mode_open) {
      {
#line 681
      err = ftp_do_port(csock, & local_sock);
      }
      {
#line 686
      if ((unsigned int )err == 18U) {
#line 686
        goto case_18___6;
      }
#line 695
      if ((unsigned int )err == 52U) {
#line 695
        goto case_52___3;
      }
#line 704
      if ((unsigned int )err == 2U) {
#line 704
        goto case_2;
      }
#line 712
      if ((unsigned int )err == 14U) {
#line 712
        goto case_14;
      }
#line 718
      if ((unsigned int )err == 13U) {
#line 718
        goto case_13;
      }
#line 726
      if ((unsigned int )err == 10U) {
#line 726
        goto case_10___6;
      }
#line 728
      goto switch_default___6;
      case_18___6: /* CIL Label */ 
      {
#line 687
      logputs((enum log_options )0, "\n");
#line 688
      tmp___77 = gettext("Error in server response, closing control connection.\n");
#line 688
      logputs((enum log_options )1, (char const   *)tmp___77);
#line 690
      fd_close(csock);
#line 691
      con->csock = -1;
#line 692
      fd_close(dtsock);
#line 693
      fd_close(local_sock);
      }
#line 694
      return (err);
      case_52___3: /* CIL Label */ 
      {
#line 696
      logputs((enum log_options )0, "\n");
#line 697
      tmp___78 = gettext("Write failed, closing control connection.\n");
#line 697
      logputs((enum log_options )1, (char const   *)tmp___78);
#line 699
      fd_close(csock);
#line 700
      con->csock = -1;
#line 701
      fd_close(dtsock);
#line 702
      fd_close(local_sock);
      }
#line 703
      return (err);
      case_2: /* CIL Label */ 
      {
#line 705
      logputs((enum log_options )0, "\n");
#line 706
      tmp___79 = __errno_location();
#line 706
      tmp___80 = strerror(*tmp___79);
#line 706
      logprintf((enum log_options )1, "socket: %s\n", tmp___80);
#line 707
      fd_close(csock);
#line 708
      con->csock = -1;
#line 709
      fd_close(dtsock);
#line 710
      fd_close(local_sock);
      }
#line 711
      return (err);
      case_14: /* CIL Label */ 
      {
#line 713
      logputs((enum log_options )0, "\n");
#line 714
      tmp___81 = __errno_location();
#line 714
      tmp___82 = strerror(*tmp___81);
#line 714
      tmp___83 = gettext("Bind error (%s).\n");
#line 714
      logprintf((enum log_options )1, (char const   *)tmp___83, tmp___82);
#line 716
      fd_close(dtsock);
      }
#line 717
      return (err);
      case_13: /* CIL Label */ 
      {
#line 719
      logputs((enum log_options )0, "\n");
#line 720
      tmp___84 = gettext("Invalid PORT.\n");
#line 720
      logputs((enum log_options )1, (char const   *)tmp___84);
#line 721
      fd_close(csock);
#line 722
      con->csock = -1;
#line 723
      fd_close(dtsock);
#line 724
      fd_close(local_sock);
      }
#line 725
      return (err);
      case_10___6: /* CIL Label */ 
#line 727
      goto switch_break___6;
      switch_default___6: /* CIL Label */ 
      {
#line 729
      abort();
      }
      switch_break___6: /* CIL Label */ ;
      }
#line 731
      if (! opt.server_response) {
        {
#line 732
        tmp___85 = gettext("done.    ");
#line 732
        logputs((enum log_options )0, (char const   *)tmp___85);
        }
      }
    }
  }
#line 737
  if (restval) {
#line 737
    if (cmd & 4) {
#line 739
      if (! opt.server_response) {
        {
#line 740
        tmp___86 = number_to_static_string(restval);
#line 740
        logprintf((enum log_options )0, "==> REST %s ... ", tmp___86);
        }
      }
      {
#line 742
      err = ftp_rest(csock, restval);
      }
      {
#line 747
      if ((unsigned int )err == 18U) {
#line 747
        goto case_18___7;
      }
#line 756
      if ((unsigned int )err == 52U) {
#line 756
        goto case_52___4;
      }
#line 765
      if ((unsigned int )err == 22U) {
#line 765
        goto case_22;
      }
#line 769
      if ((unsigned int )err == 10U) {
#line 769
        goto case_10___7;
      }
#line 771
      goto switch_default___7;
      case_18___7: /* CIL Label */ 
      {
#line 748
      logputs((enum log_options )0, "\n");
#line 749
      tmp___87 = gettext("Error in server response, closing control connection.\n");
#line 749
      logputs((enum log_options )1, (char const   *)tmp___87);
#line 751
      fd_close(csock);
#line 752
      con->csock = -1;
#line 753
      fd_close(dtsock);
#line 754
      fd_close(local_sock);
      }
#line 755
      return (err);
      case_52___4: /* CIL Label */ 
      {
#line 757
      logputs((enum log_options )0, "\n");
#line 758
      tmp___88 = gettext("Write failed, closing control connection.\n");
#line 758
      logputs((enum log_options )1, (char const   *)tmp___88);
#line 760
      fd_close(csock);
#line 761
      con->csock = -1;
#line 762
      fd_close(dtsock);
#line 763
      fd_close(local_sock);
      }
#line 764
      return (err);
      case_22: /* CIL Label */ 
      {
#line 766
      tmp___89 = gettext("\nREST failed, starting from scratch.\n");
#line 766
      logputs((enum log_options )0, (char const   *)tmp___89);
#line 767
      rest_failed = (_Bool)1;
      }
#line 768
      goto switch_break___7;
      case_10___7: /* CIL Label */ 
#line 770
      goto switch_break___7;
      switch_default___7: /* CIL Label */ 
      {
#line 772
      abort();
      }
      switch_break___7: /* CIL Label */ ;
      }
#line 774
      if ((unsigned int )err != 22U) {
#line 774
        if (! opt.server_response) {
          {
#line 775
          tmp___90 = gettext("done.    ");
#line 775
          logputs((enum log_options )0, (char const   *)tmp___90);
          }
        }
      }
    }
  }
#line 778
  if (cmd & 4) {
#line 784
    if (opt.spider) {
      {
#line 786
      fd_close(csock);
#line 787
      con->csock = -1;
#line 788
      fd_close(dtsock);
#line 789
      fd_close(local_sock);
      }
#line 790
      return ((uerr_t )39);
    }
#line 793
    if (opt.verbose) {
#line 795
      if (! opt.server_response) {
#line 797
        if (restval) {
          {
#line 798
          logputs((enum log_options )0, "\n");
          }
        }
        {
#line 799
        tmp___91 = escnonprint((char const   *)u->file);
#line 799
        logprintf((enum log_options )0, "==> RETR %s ... ", tmp___91);
        }
      }
    }
    {
#line 803
    err = ftp_retr(csock, (char const   *)u->file);
    }
    {
#line 807
    if ((unsigned int )err == 18U) {
#line 807
      goto case_18___8;
    }
#line 816
    if ((unsigned int )err == 52U) {
#line 816
      goto case_52___5;
    }
#line 825
    if ((unsigned int )err == 15U) {
#line 825
      goto case_15___0;
    }
#line 832
    if ((unsigned int )err == 10U) {
#line 832
      goto case_10___8;
    }
#line 834
    goto switch_default___8;
    case_18___8: /* CIL Label */ 
    {
#line 808
    logputs((enum log_options )0, "\n");
#line 809
    tmp___92 = gettext("Error in server response, closing control connection.\n");
#line 809
    logputs((enum log_options )1, (char const   *)tmp___92);
#line 811
    fd_close(csock);
#line 812
    con->csock = -1;
#line 813
    fd_close(dtsock);
#line 814
    fd_close(local_sock);
    }
#line 815
    return (err);
    case_52___5: /* CIL Label */ 
    {
#line 817
    logputs((enum log_options )0, "\n");
#line 818
    tmp___93 = gettext("Write failed, closing control connection.\n");
#line 818
    logputs((enum log_options )1, (char const   *)tmp___93);
#line 820
    fd_close(csock);
#line 821
    con->csock = -1;
#line 822
    fd_close(dtsock);
#line 823
    fd_close(local_sock);
    }
#line 824
    return (err);
    case_15___0: /* CIL Label */ 
    {
#line 826
    logputs((enum log_options )0, "\n");
#line 827
    tmp___94 = escnonprint((char const   *)u->file);
#line 827
    tmp___95 = gettext("No such file `%s\'.\n\n");
#line 827
    logprintf((enum log_options )1, (char const   *)tmp___95, tmp___94);
#line 829
    fd_close(dtsock);
#line 830
    fd_close(local_sock);
    }
#line 831
    return (err);
    case_10___8: /* CIL Label */ 
#line 833
    goto switch_break___8;
    switch_default___8: /* CIL Label */ 
    {
#line 835
    abort();
    }
    switch_break___8: /* CIL Label */ ;
    }
#line 838
    if (! opt.server_response) {
      {
#line 839
      tmp___96 = gettext("done.\n");
#line 839
      logputs((enum log_options )0, (char const   *)tmp___96);
      }
    }
    {
#line 840
    expected_bytes = ftp_expected_bytes((char const   *)(ftp_last_respline));
    }
  }
#line 843
  if (cmd & 8) {
#line 845
    if (! opt.server_response) {
      {
#line 846
      logputs((enum log_options )0, "==> LIST ... ");
      }
    }
    {
#line 850
    err = ftp_list(csock, (char const   *)((void *)0));
    }
    {
#line 854
    if ((unsigned int )err == 18U) {
#line 854
      goto case_18___9;
    }
#line 863
    if ((unsigned int )err == 52U) {
#line 863
      goto case_52___6;
    }
#line 872
    if ((unsigned int )err == 15U) {
#line 872
      goto case_15___1;
    }
#line 879
    if ((unsigned int )err == 10U) {
#line 879
      goto case_10___9;
    }
#line 881
    goto switch_default___9;
    case_18___9: /* CIL Label */ 
    {
#line 855
    logputs((enum log_options )0, "\n");
#line 856
    tmp___97 = gettext("Error in server response, closing control connection.\n");
#line 856
    logputs((enum log_options )1, (char const   *)tmp___97);
#line 858
    fd_close(csock);
#line 859
    con->csock = -1;
#line 860
    fd_close(dtsock);
#line 861
    fd_close(local_sock);
    }
#line 862
    return (err);
    case_52___6: /* CIL Label */ 
    {
#line 864
    logputs((enum log_options )0, "\n");
#line 865
    tmp___98 = gettext("Write failed, closing control connection.\n");
#line 865
    logputs((enum log_options )1, (char const   *)tmp___98);
#line 867
    fd_close(csock);
#line 868
    con->csock = -1;
#line 869
    fd_close(dtsock);
#line 870
    fd_close(local_sock);
    }
#line 871
    return (err);
    case_15___1: /* CIL Label */ 
    {
#line 873
    logputs((enum log_options )0, "\n");
#line 874
    tmp___99 = gettext("No such file or directory `%s\'.\n\n");
#line 874
    logprintf((enum log_options )1, (char const   *)tmp___99, ".");
#line 876
    fd_close(dtsock);
#line 877
    fd_close(local_sock);
    }
#line 878
    return (err);
    case_10___9: /* CIL Label */ 
#line 880
    goto switch_break___9;
    switch_default___9: /* CIL Label */ 
    {
#line 882
    abort();
    }
    switch_break___9: /* CIL Label */ ;
    }
#line 884
    if (! opt.server_response) {
      {
#line 885
      tmp___100 = gettext("done.\n");
#line 885
      logputs((enum log_options )0, (char const   *)tmp___100);
      }
    }
    {
#line 886
    expected_bytes = ftp_expected_bytes((char const   *)(ftp_last_respline));
    }
  }
#line 889
  if (! (cmd & 12)) {
#line 890
    return ((uerr_t )39);
  } else
#line 889
  if (opt.spider) {
#line 889
    if (! (cmd & 8)) {
#line 890
      return ((uerr_t )39);
    }
  }
#line 894
  if (*len) {
#line 894
    if (restval) {
#line 894
      if (expected_bytes) {
#line 894
        if (expected_bytes == *len - restval) {
          {
#line 897
          while (1) {
            while_continue___12: /* CIL Label */ ;
            {
#line 897
            tmp___101 = __builtin_expect((long )opt.debug, 0L);
            }
#line 897
            if (tmp___101) {
              {
#line 897
              debug_logprintf("Lying FTP server found, adjusting.\n");
              }
            }
#line 897
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 898
          expected_bytes = *len;
        }
      }
    }
  }
#line 902
  if (! pasv_mode_open) {
    {
#line 907
    dtsock = accept_connection(local_sock);
    }
#line 908
    if (dtsock < 0) {
      {
#line 910
      tmp___102 = __errno_location();
#line 910
      tmp___103 = strerror(*tmp___102);
#line 910
      logprintf((enum log_options )1, "accept: %s\n", tmp___103);
      }
#line 911
      return (err);
    }
  }
#line 916
  if (! output_stream) {
#line 916
    goto _L___3;
  } else
#line 916
  if (con->cmd & 8) {
    _L___3: /* CIL Label */ 
    {
#line 918
    mkalldirs((char const   *)con->target);
    }
#line 919
    if (opt.backups) {
      {
#line 920
      rotate_backups((char const   *)con->target);
      }
    }
#line 922
    if (restval) {
#line 922
      if (! (con->cmd & 8)) {
        {
#line 923
        fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"ab");
        }
      } else {
#line 922
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 924
    if (opt.noclobber) {
      {
#line 926
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"wb");
      }
    } else
#line 924
    if (opt.always_rest) {
      {
#line 926
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"wb");
      }
    } else
#line 924
    if (opt.timestamping) {
      {
#line 926
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"wb");
      }
    } else
#line 924
    if (opt.dirstruct) {
      {
#line 926
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"wb");
      }
    } else
#line 924
    if (opt.output_document) {
      {
#line 926
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"wb");
      }
    } else {
      {
#line 929
      fp = fopen_excl((char const   *)con->target, (_Bool)1);
      }
#line 930
      if (! fp) {
        {
#line 930
        tmp___105 = __errno_location();
        }
#line 930
        if (*tmp___105 == 17) {
          {
#line 936
          tmp___104 = gettext("%s has sprung into existence.\n");
#line 936
          logprintf((enum log_options )1, (char const   *)tmp___104, con->target);
#line 938
          fd_close(csock);
#line 939
          con->csock = -1;
#line 940
          fd_close(dtsock);
#line 941
          fd_close(local_sock);
          }
#line 942
          return ((uerr_t )25);
        }
      }
    }
#line 945
    if (! fp) {
      {
#line 947
      tmp___106 = __errno_location();
#line 947
      tmp___107 = strerror(*tmp___106);
#line 947
      logprintf((enum log_options )1, "%s: %s\n", con->target, tmp___107);
#line 948
      fd_close(csock);
#line 949
      con->csock = -1;
#line 950
      fd_close(dtsock);
#line 951
      fd_close(local_sock);
      }
#line 952
      return ((uerr_t )24);
    }
  } else {
#line 956
    fp = output_stream;
  }
#line 958
  if (*len) {
    {
#line 960
    print_length(*len, restval, (_Bool)1);
#line 961
    expected_bytes = *len;
    }
  } else
#line 963
  if (expected_bytes) {
    {
#line 964
    print_length(expected_bytes, restval, (_Bool)0);
    }
  }
#line 967
  flags = 0;
#line 968
  if (restval) {
#line 968
    if (rest_failed) {
#line 969
      flags |= 2;
    }
  }
#line 970
  *len = restval;
#line 971
  rd_size = (wgint )0;
#line 972
  if (expected_bytes) {
#line 972
    tmp___108 = expected_bytes - restval;
  } else {
#line 972
    tmp___108 = (wgint )0;
  }
  {
#line 972
  res___0 = fd_read_body(dtsock, fp, tmp___108, restval, & rd_size, len, & con->dltime,
                         flags);
#line 976
  tmp___109 = time((time_t *)((void *)0));
#line 976
  tms = datetime_str(tmp___109);
#line 977
  tmrate = retr_rate(rd_size, con->dltime);
#line 978
  total_download_time += con->dltime;
#line 980
  fd_close(local_sock);
  }
#line 982
  if (! output_stream) {
    {
#line 983
    fclose(fp);
    }
  } else
#line 982
  if (con->cmd & 8) {
    {
#line 983
    fclose(fp);
    }
  }
#line 986
  if (res___0 == -2) {
    {
#line 988
    tmp___110 = __errno_location();
#line 988
    tmp___111 = strerror(*tmp___110);
#line 988
    tmp___112 = gettext("%s: %s, closing control connection.\n");
#line 988
    logprintf((enum log_options )1, (char const   *)tmp___112, con->target, tmp___111);
#line 990
    fd_close(csock);
#line 991
    con->csock = -1;
#line 992
    fd_close(dtsock);
    }
#line 993
    return ((uerr_t )26);
  } else
#line 995
  if (res___0 == -1) {
    {
#line 997
    tmp___113 = fd_errstr(dtsock);
#line 997
    tmp___114 = gettext("%s (%s) - Data connection: %s; ");
#line 997
    logprintf((enum log_options )1, (char const   *)tmp___114, tms, tmrate, tmp___113);
    }
#line 999
    if (opt.server_response) {
      {
#line 1000
      logputs((enum log_options )3, "\n");
      }
    }
  }
  {
#line 1002
  fd_close(dtsock);
#line 1005
  err = ftp_response(csock, & respline);
  }
#line 1006
  if ((unsigned int )err != 10U) {
#line 1010
    if (res___0 != -1) {
      {
#line 1011
      logprintf((enum log_options )1, "%s (%s) - ", tms, tmrate);
      }
    }
    {
#line 1012
    tmp___115 = gettext("Control connection closed.\n");
#line 1012
    logputs((enum log_options )1, (char const   *)tmp___115);
#line 1017
    fd_close(csock);
#line 1018
    con->csock = -1;
    }
#line 1019
    return ((uerr_t )21);
  }
#line 1025
  if ((int )*respline != 50) {
    {
#line 1027
    checking_free((void *)respline);
    }
#line 1028
    if (res___0 != -1) {
      {
#line 1029
      logprintf((enum log_options )1, "%s (%s) - ", tms, tmrate);
      }
    }
    {
#line 1030
    tmp___116 = gettext("Data transfer aborted.\n");
#line 1030
    logputs((enum log_options )1, (char const   *)tmp___116);
    }
#line 1031
    return ((uerr_t )21);
  }
  {
#line 1033
  checking_free((void *)respline);
  }
#line 1035
  if (res___0 == -1) {
#line 1039
    return ((uerr_t )21);
  }
#line 1042
  if (! (cmd & 16)) {
    {
#line 1046
    fd_close(csock);
#line 1047
    con->csock = -1;
    }
  }
#line 1051
  if (opt.server_response) {
#line 1051
    if (con->cmd & 8) {
      {
#line 1053
      mkalldirs((char const   *)con->target);
#line 1054
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"r");
      }
#line 1055
      if (! fp) {
        {
#line 1056
        tmp___117 = __errno_location();
#line 1056
        tmp___118 = strerror(*tmp___117);
#line 1056
        logprintf((enum log_options )3, "%s: %s\n", con->target, tmp___118);
        }
      } else {
        {
#line 1062
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 1062
          line = read_whole_line(fp);
          }
#line 1062
          if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 1062
            goto while_break___13;
          }
          {
#line 1064
          tmp___119 = strchr((char const   *)line, '\000');
#line 1064
          p___1 = tmp___119;
          }
          {
#line 1065
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1065
            if ((unsigned long )p___1 > (unsigned long )line) {
#line 1065
              if (! ((int )*(p___1 + -1) == 10)) {
#line 1065
                if (! ((int )*(p___1 + -1) == 13)) {
#line 1065
                  goto while_break___14;
                }
              }
            } else {
#line 1065
              goto while_break___14;
            }
#line 1066
            p___1 --;
#line 1066
            *p___1 = (char )'\000';
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 1067
          tmp___120 = escnonprint((char const   *)line);
#line 1067
          logprintf((enum log_options )3, "%s\n", tmp___120);
#line 1068
          checking_free((void *)line);
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 1070
        fclose(fp);
        }
      }
    }
  }
#line 1074
  return ((uerr_t )39);
}
}
#line 1082 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_loop_internal(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  int count ;
  int orig_lp ;
  wgint restval ;
  wgint len ;
  char *tms ;
  char *locf ;
  char const   *tmrate ;
  uerr_t err ;
  struct stat st ;
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  char *hurl ;
  char *tmp___3 ;
  char tmp___4[256] ;
  char *tmp___5 ;
  time_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *hurl___0 ;
  char *tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 1086
  len = (wgint )0;
#line 1088
  tmrate = (char const   *)((void *)0);
#line 1092
  if (! con->target) {
    {
#line 1093
    con->target = url_file_name((struct url  const  *)u);
    }
  }
#line 1097
  if (opt.noclobber) {
#line 1097
    if (! opt.output_document) {
      {
#line 1097
      tmp___0 = file_exists_p((char const   *)con->target);
      }
#line 1097
      if (tmp___0) {
        {
#line 1099
        tmp = gettext("File `%s\' already there; not retrieving.\n");
#line 1099
        logprintf((enum log_options )0, (char const   *)tmp, con->target);
        }
#line 1102
        return ((uerr_t )31);
      }
    }
  }
  {
#line 1106
  remove_link((char const   *)con->target);
  }
#line 1107
  if (! opt.output_document) {
#line 1108
    locf = con->target;
  } else {
#line 1110
    locf = opt.output_document;
  }
#line 1112
  count = 0;
#line 1114
  if (con->st & 1) {
#line 1115
    con->st = 1;
  }
#line 1117
  if (con->cmd & 16) {
#line 1117
    orig_lp = 1;
  } else {
#line 1117
    orig_lp = 0;
  }
  {
#line 1120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1123
    count ++;
#line 1124
    sleep_between_retrievals(count);
    }
#line 1125
    if (con->st & 1) {
#line 1127
      con->cmd = 0;
#line 1128
      con->cmd |= 20;
#line 1129
      if (con->csock != -1) {
#line 1130
        con->cmd &= -4;
      } else {
#line 1132
        con->cmd |= 3;
      }
    } else {
#line 1136
      if (con->csock != -1) {
#line 1137
        con->cmd &= -2;
      } else {
#line 1139
        con->cmd |= 1;
      }
#line 1140
      if (con->st & 2) {
#line 1141
        con->cmd &= -3;
      } else {
#line 1143
        con->cmd |= 2;
      }
    }
#line 1147
    if (con->cmd & 8) {
#line 1148
      restval = (wgint )0;
    } else
#line 1149
    if (opt.always_rest) {
      {
#line 1149
      tmp___1 = stat((char const   */* __restrict  */)locf, (struct stat */* __restrict  */)(& st));
      }
#line 1149
      if (tmp___1 == 0) {
#line 1149
        if ((st.st_mode & 61440U) == 32768U) {
#line 1155
          restval = st.st_size;
        } else {
#line 1149
          goto _L___0;
        }
      } else {
#line 1149
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1156
    if (count > 1) {
#line 1157
      restval = len;
    } else {
#line 1159
      restval = (wgint )0;
    }
    {
#line 1162
    tmp___2 = time((time_t *)((void *)0));
#line 1162
    tms = datetime_str(tmp___2);
    }
#line 1164
    if (opt.verbose) {
      {
#line 1166
      tmp___3 = url_string((struct url  const  *)u, (enum url_auth_mode )1);
#line 1166
      hurl = tmp___3;
#line 1168
      strcpy((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)"        ");
      }
#line 1169
      if (count > 1) {
        {
#line 1170
        tmp___5 = gettext("(try:%2d)");
#line 1170
        sprintf((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)tmp___5,
                count);
        }
      }
      {
#line 1171
      logprintf((enum log_options )0, "--%s--  %s\n  %s => `%s\'\n", tms, hurl, tmp___4,
                locf);
#line 1176
      checking_free((void *)hurl);
      }
    }
#line 1179
    if (f) {
#line 1180
      len = f->size;
    } else {
#line 1182
      len = (wgint )0;
    }
    {
#line 1183
    err = getftp(u, & len, restval, con);
    }
#line 1185
    if (con->csock == -1) {
#line 1186
      con->st &= -3;
    } else {
#line 1188
      con->st |= 2;
    }
    {
#line 1193
    if ((unsigned int )err == 37U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 36U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 11U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 15U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 24U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 26U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 5U) {
#line 1193
      goto case_37;
    }
#line 1193
    if ((unsigned int )err == 1U) {
#line 1193
      goto case_37;
    }
#line 1199
    if ((unsigned int )err == 25U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 35U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 12U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 13U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 14U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 17U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 52U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 18U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 20U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 3U) {
#line 1199
      goto case_25;
    }
#line 1199
    if ((unsigned int )err == 2U) {
#line 1199
      goto case_25;
    }
#line 1210
    if ((unsigned int )err == 21U) {
#line 1210
      goto case_21;
    }
#line 1219
    if ((unsigned int )err == 39U) {
#line 1219
      goto case_39;
    }
#line 1222
    goto switch_default;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1195
    return (err);
    case_25: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1200
    printwhat(count, opt.ntry);
    }
#line 1202
    if ((unsigned int )err == 25U) {
#line 1205
      if (! (! con->target)) {
        {
#line 1205
        checking_free((void *)con->target);
        }
      }
      {
#line 1206
      con->target = url_file_name((struct url  const  *)u);
#line 1207
      locf = con->target;
      }
    }
#line 1209
    goto __Cont;
    case_21: /* CIL Label */ 
#line 1213
    if (! f) {
      {
#line 1215
      printwhat(count, opt.ntry);
      }
#line 1216
      goto __Cont;
    } else
#line 1213
    if (len != f->size) {
      {
#line 1215
      printwhat(count, opt.ntry);
      }
#line 1216
      goto __Cont;
    }
#line 1218
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1221
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1224
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1226
    tmp___6 = time((time_t *)((void *)0));
#line 1226
    tms = datetime_str(tmp___6);
    }
#line 1227
    if (! opt.spider) {
      {
#line 1228
      tmrate = retr_rate(len - restval, con->dltime);
      }
    }
    {
#line 1232
    downloaded_file((downloaded_file_t )1, (char const   *)locf);
    }
#line 1234
    if (con->st & 1) {
      {
#line 1236
      fd_close(con->csock);
#line 1237
      con->csock = -1;
      }
    }
#line 1239
    if (! opt.spider) {
      {
#line 1240
      tmp___7 = number_to_static_string(len);
#line 1240
      tmp___8 = gettext("%s (%s) - `%s\' saved [%s]\n\n");
#line 1240
      logprintf((enum log_options )0, (char const   *)tmp___8, tms, tmrate, locf,
                tmp___7);
      }
    }
#line 1242
    if (! opt.verbose) {
#line 1242
      if (! opt.quiet) {
        {
#line 1247
        tmp___9 = url_string((struct url  const  *)u, (enum url_auth_mode )1);
#line 1247
        hurl___0 = tmp___9;
#line 1248
        tmp___10 = number_to_static_string(len);
#line 1248
        logprintf((enum log_options )2, "%s URL: %s [%s] -> \"%s\" [%d]\n", tms, hurl___0,
                  tmp___10, locf, count);
#line 1250
        checking_free((void *)hurl___0);
        }
      }
    }
#line 1253
    if (con->cmd & 8) {
#line 1256
      if (! opt.remove_listing) {
#line 1260
        total_downloaded_bytes += len;
#line 1261
        (opt.numurls) ++;
      }
    } else
#line 1268
    if (! opt.spider) {
#line 1275
      total_downloaded_bytes += len;
#line 1276
      (opt.numurls) ++;
#line 1278
      if (opt.delete_after) {
        {
#line 1280
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1280
          tmp___11 = __builtin_expect((long )opt.debug, 0L);
          }
#line 1280
          if (tmp___11) {
            {
#line 1280
            debug_logprintf("Removing file due to --delete-after in ftp_loop_internal():\n");
            }
          }
#line 1280
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1282
        tmp___12 = gettext("Removing %s.\n");
#line 1282
        logprintf((enum log_options )0, (char const   *)tmp___12, locf);
#line 1283
        tmp___15 = unlink((char const   *)locf);
        }
#line 1283
        if (tmp___15) {
          {
#line 1284
          tmp___13 = __errno_location();
#line 1284
          tmp___14 = strerror(*tmp___13);
#line 1284
          logprintf((enum log_options )1, "unlink: %s\n", tmp___14);
          }
        }
      }
    }
#line 1289
    if (orig_lp) {
#line 1290
      con->cmd |= 16;
    } else {
#line 1292
      con->cmd &= -17;
    }
#line 1293
    return ((uerr_t )31);
    __Cont: /* CIL Label */ 
#line 1120
    if (! (! opt.ntry)) {
#line 1120
      if (! (count < opt.ntry)) {
#line 1120
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  if (con->csock != -1) {
#line 1296
    if (con->st & 1) {
      {
#line 1298
      fd_close(con->csock);
#line 1299
      con->csock = -1;
      }
    }
  }
#line 1301
  return ((uerr_t )41);
}
}
#line 1306 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_get_listing(struct url *u , ccon *con , struct fileinfo **f ) 
{ 
  uerr_t err ;
  char *uf ;
  char *lf ;
  char *old_target ;
  char *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1312
  old_target = con->target;
#line 1314
  con->st &= -2;
#line 1315
  con->cmd |= 24;
#line 1316
  con->cmd &= -5;
#line 1321
  uf = url_file_name((struct url  const  *)u);
#line 1322
  lf = file_merge((char const   *)uf, ".listing");
#line 1323
  checking_free((void *)uf);
  }
  {
#line 1324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1324
    tmp___0 = __builtin_expect((long )opt.debug, 0L);
    }
#line 1324
    if (tmp___0) {
      {
#line 1324
      tmp = gettext("Using `%s\' as listing tmp file.\n");
#line 1324
      debug_logprintf((char const   *)tmp, lf);
      }
    }
#line 1324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1326
  con->target = lf;
#line 1327
  err = ftp_loop_internal(u, (struct fileinfo *)((void *)0), con);
#line 1328
  con->target = old_target;
  }
#line 1330
  if ((unsigned int )err == 31U) {
    {
#line 1331
    *f = ftp_parse_ls((char const   *)lf, (enum stype  const  )con->rs);
    }
  } else {
#line 1333
    *f = (struct fileinfo *)((void *)0);
  }
#line 1334
  if (opt.remove_listing) {
    {
#line 1336
    tmp___4 = unlink((char const   *)lf);
    }
#line 1336
    if (tmp___4) {
      {
#line 1337
      tmp___1 = __errno_location();
#line 1337
      tmp___2 = strerror(*tmp___1);
#line 1337
      logprintf((enum log_options )1, "unlink: %s\n", tmp___2);
      }
    } else {
      {
#line 1339
      tmp___3 = gettext("Removed `%s\'.\n");
#line 1339
      logprintf((enum log_options )0, (char const   *)tmp___3, lf);
      }
    }
  }
  {
#line 1341
  checking_free((void *)lf);
#line 1342
  con->cmd &= -9;
  }
#line 1343
  return (err);
}
}
#line 1346
static uerr_t ftp_retrieve_dirs(struct url *u , struct fileinfo *f , ccon *con ) ;
#line 1347
static uerr_t ftp_retrieve_glob(struct url *u , ccon *con , int action ) ;
#line 1348
static struct fileinfo *delelement(struct fileinfo *f , struct fileinfo **start ) ;
#line 1349
static void freefileinfo(struct fileinfo *f ) ;
#line 1361
static uerr_t ftp_retrieve_list(struct url *u , struct fileinfo *f , ccon *con ) ;
#line 1361 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static int depth  =    0;
#line 1358 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_retrieve_list(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  uerr_t err ;
  struct fileinfo *orig ;
  wgint local_size ;
  time_t tml ;
  _Bool dlthis ;
  char *tmp ;
  long tmp___0 ;
  char *old_target ;
  char *ofile ;
  struct stat st ;
  _Bool eq_size ;
  _Bool cor_val ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  struct stat st___0 ;
  int rc ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  char *link_target ;
  void *tmp___11 ;
  size_t n ;
  ssize_t tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char const   *fl ;
  char *tmp___25 ;
  _Bool tmp___26 ;
  long tmp___27 ;
  char *tmp___28 ;
  long tmp___29 ;

  {
#line 1369
  depth ++;
#line 1370
  if (opt.reclevel != -1) {
#line 1370
    if (depth > opt.reclevel) {
      {
#line 1372
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1372
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 1372
        if (tmp___0) {
          {
#line 1372
          tmp = gettext("Recursion depth %d exceeded max. depth %d.\n");
#line 1372
          debug_logprintf((char const   *)tmp, depth, opt.reclevel);
          }
        }
#line 1372
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1374
      depth --;
#line 1375
      return ((uerr_t )32);
    }
  }
#line 1378
  if (! ((unsigned long )f != (unsigned long )((void *)0))) {
    {
#line 1378
    __assert_fail("f != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c",
                  1378U, "ftp_retrieve_list");
    }
  }
#line 1379
  orig = f;
#line 1381
  con->st &= -2;
#line 1382
  if (! (con->st & 2)) {
#line 1383
    con->cmd |= 2;
  } else {
#line 1385
    con->cmd &= -3;
  }
#line 1386
  con->cmd |= 20;
#line 1388
  if (con->csock < 0) {
#line 1389
    con->cmd |= 1;
  } else {
#line 1391
    con->cmd &= -2;
  }
#line 1393
  err = (uerr_t )31;
  {
#line 1395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1395
    if (! f) {
#line 1395
      goto while_break___0;
    }
#line 1399
    if (opt.quota) {
#line 1399
      if (total_downloaded_bytes > opt.quota) {
#line 1401
        depth --;
#line 1402
        return ((uerr_t )51);
      }
    }
    {
#line 1404
    old_target = con->target;
#line 1406
    ofile = checking_strdup((char const   *)u->file);
#line 1407
    url_set_file(u, (char const   *)f->name);
#line 1409
    con->target = url_file_name((struct url  const  *)u);
#line 1410
    err = (uerr_t )31;
#line 1412
    dlthis = (_Bool)1;
    }
#line 1413
    if (opt.timestamping) {
#line 1413
      if ((unsigned int )f->type == 0U) {
        {
#line 1421
        tmp___7 = stat((char const   */* __restrict  */)con->target, (struct stat */* __restrict  */)(& st));
        }
#line 1421
        if (! tmp___7) {
#line 1426
          local_size = st.st_size;
#line 1427
          tml = st.st_mtim.tv_sec;
#line 1436
          if ((unsigned int )con->rs == 0U) {
#line 1436
            tmp___2 = 1;
          } else
#line 1436
          if ((unsigned int )con->rs == 2U) {
#line 1436
            tmp___2 = 1;
          } else {
#line 1436
            tmp___2 = 0;
          }
#line 1436
          cor_val = (_Bool )tmp___2;
#line 1437
          if (cor_val) {
#line 1437
            eq_size = (_Bool )(local_size == f->size);
          } else {
#line 1437
            eq_size = (_Bool)1;
          }
#line 1438
          if (f->tstamp <= tml) {
#line 1438
            if (eq_size) {
              {
#line 1442
              tmp___3 = gettext("Remote file no newer than local file `%s\' -- not retrieving.\n");
#line 1442
              logprintf((enum log_options )0, (char const   *)tmp___3, con->target);
#line 1444
              dlthis = (_Bool)0;
              }
            } else {
#line 1438
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1446
          if (eq_size) {
            {
#line 1449
            tmp___4 = gettext("Remote file is newer than local file `%s\' -- retrieving.\n\n");
#line 1449
            logprintf((enum log_options )0, (char const   *)tmp___4, con->target);
            }
          } else {
            {
#line 1456
            tmp___5 = number_to_static_string(local_size);
#line 1456
            tmp___6 = gettext("The sizes do not match (local %s) -- retrieving.\n\n");
#line 1456
            logprintf((enum log_options )0, (char const   *)tmp___6, tmp___5);
            }
          }
        }
      }
    }
    {
#line 1464
    if ((unsigned int )f->type == 2U) {
#line 1464
      goto case_2;
    }
#line 1519
    if ((unsigned int )f->type == 1U) {
#line 1519
      goto case_1;
    }
#line 1524
    if ((unsigned int )f->type == 0U) {
#line 1524
      goto case_0;
    }
#line 1529
    if ((unsigned int )f->type == 3U) {
#line 1529
      goto case_3;
    }
#line 1462
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1469
    if (! opt.retr_symlinks) {
#line 1472
      if (! f->linkto) {
        {
#line 1473
        tmp___8 = gettext("Invalid name of the symlink, skipping.\n");
#line 1473
        logputs((enum log_options )1, (char const   *)tmp___8);
        }
      } else {
        {
#line 1480
        tmp___9 = lstat((char const   */* __restrict  */)con->target, (struct stat */* __restrict  */)(& st___0));
#line 1480
        rc = tmp___9;
        }
#line 1481
        if (rc == 0) {
          {
#line 1483
          tmp___10 = strlen((char const   *)f->linkto);
#line 1483
          len = tmp___10 + 1UL;
          }
#line 1484
          if ((st___0.st_mode & 61440U) == 40960U) {
            {
#line 1486
            tmp___11 = __builtin_alloca(len);
#line 1486
            link_target = (char *)tmp___11;
#line 1487
            tmp___12 = readlink((char const   */* __restrict  */)con->target, (char */* __restrict  */)link_target,
                                len);
#line 1487
            n = (size_t )tmp___12;
            }
#line 1488
            if (n == len - 1UL) {
              {
#line 1488
              tmp___15 = memcmp((void const   *)link_target, (void const   *)f->linkto,
                                n);
              }
#line 1488
              if (tmp___15 == 0) {
                {
#line 1491
                tmp___13 = escnonprint((char const   *)f->linkto);
#line 1491
                tmp___14 = gettext("Already have correct symlink %s -> %s\n\n");
#line 1491
                logprintf((enum log_options )0, (char const   *)tmp___14, con->target,
                          tmp___13);
#line 1494
                dlthis = (_Bool)0;
                }
#line 1495
                goto switch_break;
              }
            }
          }
        }
        {
#line 1499
        tmp___16 = escnonprint((char const   *)f->linkto);
#line 1499
        tmp___17 = gettext("Creating symlink %s -> %s\n");
#line 1499
        logprintf((enum log_options )0, (char const   *)tmp___17, con->target, tmp___16);
#line 1502
        unlink((char const   *)con->target);
#line 1503
        tmp___20 = symlink((char const   *)f->linkto, (char const   *)con->target);
        }
#line 1503
        if (tmp___20 == -1) {
          {
#line 1504
          tmp___18 = __errno_location();
#line 1504
          tmp___19 = strerror(*tmp___18);
#line 1504
          logprintf((enum log_options )1, "symlink: %s\n", tmp___19);
          }
        }
        {
#line 1505
        logputs((enum log_options )0, "\n");
        }
      }
    } else
#line 1515
    if (dlthis) {
      {
#line 1516
      err = ftp_loop_internal(u, f, con);
      }
    }
#line 1518
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1520
    if (! opt.recursive) {
      {
#line 1521
      tmp___21 = escnonprint((char const   *)f->name);
#line 1521
      tmp___22 = gettext("Skipping directory `%s\'.\n");
#line 1521
      logprintf((enum log_options )1, (char const   *)tmp___22, tmp___21);
      }
    }
#line 1523
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1526
    if (dlthis) {
      {
#line 1527
      err = ftp_loop_internal(u, f, con);
      }
    }
#line 1528
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1530
    tmp___23 = escnonprint((char const   *)f->name);
#line 1530
    tmp___24 = gettext("%s: unknown/unsupported file type.\n");
#line 1530
    logprintf((enum log_options )1, (char const   *)tmp___24, tmp___23);
    }
#line 1532
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1538
    if ((unsigned int )f->type == 2U) {
#line 1538
      if (! opt.retr_symlinks) {
        _L___2: /* CIL Label */ 
#line 1556
        if (f->tstamp == -1L) {
          {
#line 1557
          tmp___25 = gettext("%s: corrupt time-stamp.\n");
#line 1557
          logprintf((enum log_options )1, (char const   *)tmp___25, con->target);
          }
        }
      } else {
#line 1538
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1538
    if (f->tstamp != -1L) {
#line 1538
      if (dlthis) {
        {
#line 1538
        tmp___26 = file_exists_p((char const   *)con->target);
        }
#line 1538
        if (tmp___26) {
#line 1545
          fl = (char const   *)((void *)0);
#line 1546
          if (opt.output_document) {
#line 1548
            if (output_stream_regular) {
#line 1549
              fl = (char const   *)opt.output_document;
            }
          } else {
#line 1552
            fl = (char const   *)con->target;
          }
#line 1553
          if (fl) {
            {
#line 1554
            touch(fl, f->tstamp);
            }
          }
        } else {
#line 1538
          goto _L___2;
        }
      } else {
#line 1538
        goto _L___2;
      }
    } else {
#line 1538
      goto _L___2;
    }
#line 1559
    if (f->perms) {
#line 1559
      if ((unsigned int )f->type == 0U) {
#line 1559
        if (dlthis) {
#line 1561
          if (opt.preserve_perm) {
            {
#line 1562
            chmod((char const   *)con->target, (__mode_t )f->perms);
            }
          }
        } else {
#line 1559
          goto _L___5;
        }
      } else {
#line 1559
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      {
#line 1565
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1565
        tmp___27 = __builtin_expect((long )opt.debug, 0L);
        }
#line 1565
        if (tmp___27) {
          {
#line 1565
          debug_logprintf("Unrecognized permissions for %s.\n", con->target);
          }
        }
#line 1565
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1567
    checking_free((void *)con->target);
#line 1568
    con->target = old_target;
#line 1570
    url_set_file(u, (char const   *)ofile);
#line 1571
    checking_free((void *)ofile);
    }
#line 1574
    if ((unsigned int )err == 51U) {
#line 1575
      goto while_break___0;
    } else
#line 1574
    if ((unsigned int )err == 1U) {
#line 1575
      goto while_break___0;
    } else
#line 1574
    if ((unsigned int )err == 26U) {
#line 1575
      goto while_break___0;
    }
#line 1576
    con->cmd &= -4;
#line 1577
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1581
  if (opt.recursive) {
#line 1581
    if (opt.reclevel != -1) {
#line 1581
      if (depth >= opt.reclevel) {
#line 1581
        goto _L___6;
      } else {
        {
#line 1583
        err = ftp_retrieve_dirs(u, orig, con);
        }
      }
    } else {
      {
#line 1583
      err = ftp_retrieve_dirs(u, orig, con);
      }
    }
  } else
  _L___6: /* CIL Label */ 
#line 1584
  if (opt.recursive) {
    {
#line 1585
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1585
      tmp___29 = __builtin_expect((long )opt.debug, 0L);
      }
#line 1585
      if (tmp___29) {
        {
#line 1585
        tmp___28 = gettext("Will not retrieve dirs since depth is %d (max %d).\n");
#line 1585
        debug_logprintf((char const   *)tmp___28, depth, opt.reclevel);
        }
      }
#line 1585
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1587
  depth --;
#line 1588
  return (err);
}
}
#line 1595 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_retrieve_dirs(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  char *container ;
  int container_size ;
  int size ;
  char *odir ;
  char *newdir ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;

  {
#line 1598
  container = (char *)((void *)0);
#line 1599
  container_size = 0;
  {
#line 1601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1601
    if (! f) {
#line 1601
      goto while_break;
    }
#line 1606
    if (opt.quota) {
#line 1606
      if (total_downloaded_bytes > opt.quota) {
#line 1607
        goto while_break;
      }
    }
#line 1608
    if ((unsigned int )f->type != 1U) {
#line 1609
      goto __Cont;
    }
    {
#line 1614
    tmp = strlen((char const   *)u->dir);
#line 1614
    tmp___0 = strlen((char const   *)f->name);
#line 1614
    size = (int )(((tmp + 1UL) + tmp___0) + 1UL);
    }
#line 1615
    if (size > container_size) {
      {
#line 1616
      tmp___1 = __builtin_alloca((unsigned long )size);
#line 1616
      container = (char *)tmp___1;
      }
    }
#line 1617
    newdir = container;
#line 1619
    odir = u->dir;
#line 1620
    if ((int )*odir == 0) {
      {
#line 1625
      sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s%s",
              odir, f->name);
      }
    } else
#line 1620
    if ((int )*odir == 47) {
#line 1620
      if ((int )*(odir + 1) == 0) {
        {
#line 1625
        sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s%s",
                odir, f->name);
        }
      } else {
        {
#line 1628
        sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s/%s",
                odir, f->name);
        }
      }
    } else {
      {
#line 1628
      sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s/%s",
              odir, f->name);
      }
    }
    {
#line 1630
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1630
      tmp___2 = __builtin_expect((long )opt.debug, 0L);
      }
#line 1630
      if (tmp___2) {
        {
#line 1630
        debug_logprintf("Composing new CWD relative to the initial directory.\n");
        }
      }
#line 1630
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1631
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1631
      tmp___3 = __builtin_expect((long )opt.debug, 0L);
      }
#line 1631
      if (tmp___3) {
        {
#line 1631
        debug_logprintf("  odir = \'%s\'\n  f->name = \'%s\'\n  newdir = \'%s\'\n\n",
                        odir, f->name, newdir);
        }
      }
#line 1631
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1633
    tmp___6 = accdir((char const   *)newdir);
    }
#line 1633
    if (! tmp___6) {
      {
#line 1635
      tmp___4 = escnonprint((char const   *)newdir);
#line 1635
      tmp___5 = gettext("Not descending to `%s\' as it is excluded/not-included.\n");
#line 1635
      logprintf((enum log_options )0, (char const   *)tmp___5, tmp___4);
      }
#line 1638
      goto __Cont;
    }
    {
#line 1641
    con->st &= -3;
#line 1643
    odir = checking_strdup((char const   *)u->dir);
#line 1645
    url_set_dir(u, (char const   *)newdir);
#line 1646
    ftp_retrieve_glob(u, con, 1);
#line 1647
    url_set_dir(u, (char const   *)odir);
#line 1648
    checking_free((void *)odir);
    }
    __Cont: /* CIL Label */ 
#line 1601
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1653
  if (opt.quota) {
#line 1653
    if (total_downloaded_bytes > opt.quota) {
#line 1654
      return ((uerr_t )51);
    } else {
#line 1656
      return ((uerr_t )31);
    }
  } else {
#line 1656
    return ((uerr_t )31);
  }
}
}
#line 1660 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static _Bool has_insecure_name_p(char const   *s ) 
{ 
  char *tmp ;

  {
#line 1663
  if ((int const   )*s == 47) {
#line 1664
    return ((_Bool)1);
  }
  {
#line 1666
  tmp = strstr(s, "../");
  }
#line 1666
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1667
    return ((_Bool)1);
  }
#line 1669
  return ((_Bool)0);
}
}
#line 1681 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static uerr_t ftp_retrieve_glob(struct url *u , ccon *con , int action ) 
{ 
  struct fileinfo *f ;
  struct fileinfo *start ;
  uerr_t res___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp___5)(char const   * , char const   * , int  ) ;
  int matchres ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int (*cmp)(char const   * , char const   * ) ;
  int ( __attribute__((__nonnull__(1,2), __leaf__)) (*tmp___10))(char const   *__s1 ,
                                                                 char const   *__s2 ) ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 1687
  con->cmd |= 16;
#line 1689
  res___0 = ftp_get_listing(u, con, & start);
  }
#line 1690
  if ((unsigned int )res___0 != 31U) {
#line 1691
    return (res___0);
  }
#line 1694
  if (opt.accepts) {
#line 1694
    goto _L;
  } else
#line 1694
  if (opt.rejects) {
    _L: /* CIL Label */ 
#line 1696
    f = start;
    {
#line 1697
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1697
      if (! f) {
#line 1697
        goto while_break;
      }
#line 1699
      if ((unsigned int )f->type != 1U) {
        {
#line 1699
        tmp___1 = acceptable((char const   *)f->name);
        }
#line 1699
        if (tmp___1) {
#line 1706
          f = f->next;
        } else {
          {
#line 1701
          tmp = escnonprint((char const   *)f->name);
#line 1701
          tmp___0 = gettext("Rejecting `%s\'.\n");
#line 1701
          logprintf((enum log_options )0, (char const   *)tmp___0, tmp);
#line 1703
          f = delelement(f, & start);
          }
        }
      } else {
#line 1706
        f = f->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1710
  f = start;
  {
#line 1711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1711
    if (! f) {
#line 1711
      goto while_break___0;
    }
    {
#line 1713
    tmp___4 = has_insecure_name_p((char const   *)f->name);
    }
#line 1713
    if (tmp___4) {
      {
#line 1715
      tmp___2 = escnonprint((char const   *)f->name);
#line 1715
      tmp___3 = gettext("Rejecting `%s\'.\n");
#line 1715
      logprintf((enum log_options )0, (char const   *)tmp___3, tmp___2);
#line 1717
      f = delelement(f, & start);
      }
    } else {
#line 1720
      f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1724
  if (*(u->file)) {
#line 1726
    if (action == 0) {
#line 1728
      if (opt.ignore_case) {
#line 1728
        tmp___5 = & fnmatch_nocase;
      } else {
#line 1728
        tmp___5 = & fnmatch;
      }
#line 1728
      matcher = tmp___5;
#line 1730
      matchres = 0;
#line 1732
      f = start;
      {
#line 1733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1733
        if (! f) {
#line 1733
          goto while_break___1;
        }
        {
#line 1735
        matchres = (*matcher)((char const   *)u->file, (char const   *)f->name, 0);
        }
#line 1736
        if (matchres == -1) {
          {
#line 1738
          tmp___6 = __errno_location();
#line 1738
          tmp___7 = strerror(*tmp___6);
#line 1738
          tmp___8 = escnonprint((char const   *)f->name);
#line 1738
          tmp___9 = gettext("Error matching %s against %s: %s\n");
#line 1738
          logprintf((enum log_options )1, (char const   *)tmp___9, u->file, tmp___8,
                    tmp___7);
          }
#line 1740
          goto while_break___1;
        }
#line 1742
        if (matchres == 1) {
          {
#line 1743
          f = delelement(f, & start);
          }
        } else {
#line 1745
          f = f->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1747
      if (matchres == -1) {
        {
#line 1749
        freefileinfo(start);
        }
#line 1750
        return ((uerr_t )45);
      }
    } else
#line 1753
    if (action == 2) {
#line 1755
      if (opt.ignore_case) {
#line 1755
        tmp___10 = & strcasecmp;
      } else {
#line 1755
        tmp___10 = & strcmp;
      }
#line 1755
      cmp = (int (*)(char const   * , char const   * ))tmp___10;
#line 1757
      f = start;
      {
#line 1758
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1758
        if (! f) {
#line 1758
          goto while_break___2;
        }
        {
#line 1760
        tmp___11 = (*cmp)((char const   *)u->file, (char const   *)f->name);
        }
#line 1760
        if (0 != tmp___11) {
          {
#line 1761
          f = delelement(f, & start);
          }
        } else {
#line 1763
          f = f->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1767
  if (start) {
    {
#line 1770
    ftp_retrieve_list(u, start, con);
    }
  } else
#line 1774
  if (action == 0) {
    {
#line 1779
    tmp___12 = escnonprint((char const   *)u->file);
#line 1779
    tmp___13 = gettext("No matches on pattern `%s\'.\n");
#line 1779
    logprintf((enum log_options )0, (char const   *)tmp___13, tmp___12);
    }
  } else
#line 1782
  if (*(u->file)) {
    {
#line 1785
    con->st |= 1;
#line 1786
    res___0 = ftp_loop_internal(u, (struct fileinfo *)((void *)0), con);
    }
#line 1787
    return (res___0);
  }
  {
#line 1790
  freefileinfo(start);
  }
#line 1791
  if (opt.quota) {
#line 1791
    if (total_downloaded_bytes > opt.quota) {
#line 1792
      return ((uerr_t )51);
    } else {
#line 1795
      return ((uerr_t )31);
    }
  } else {
#line 1795
    return ((uerr_t )31);
  }
}
}
#line 1801 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
uerr_t ftp_loop(struct url *u , int *dt , struct url *proxy , _Bool recursive , _Bool glob ) 
{ 
  ccon con ;
  uerr_t res___0 ;
  struct fileinfo *f ;
  char *filename ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat st ;
  wgint sz ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  _Bool ispattern ;
  char *file_part ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1807
  *dt = 0;
#line 1809
  memset((void *)(& con), '\000', sizeof(con));
#line 1811
  con.csock = -1;
#line 1812
  con.st = 1;
#line 1813
  con.rs = (enum stype )0;
#line 1814
  con.id = (char *)((void *)0);
#line 1815
  con.proxy = proxy;
  }
#line 1820
  if (! *(u->file)) {
#line 1820
    if (! recursive) {
      {
#line 1823
      res___0 = ftp_get_listing(u, & con, & f);
      }
#line 1825
      if ((unsigned int )res___0 == 31U) {
#line 1827
        if (opt.htmlify) {
#line 1827
          if (! opt.spider) {
#line 1829
            if (opt.output_document) {
              {
#line 1829
              tmp = checking_strdup((char const   *)opt.output_document);
#line 1829
              tmp___3 = tmp;
              }
            } else {
#line 1829
              if (con.target) {
                {
#line 1829
                tmp___0 = checking_strdup((char const   *)con.target);
#line 1829
                tmp___2 = tmp___0;
                }
              } else {
                {
#line 1829
                tmp___1 = url_file_name((struct url  const  *)u);
#line 1829
                tmp___2 = tmp___1;
                }
              }
#line 1829
              tmp___3 = tmp___2;
            }
            {
#line 1829
            filename = tmp___3;
#line 1833
            res___0 = ftp_index((char const   *)filename, u, f);
            }
#line 1834
            if ((unsigned int )res___0 == 10U) {
#line 1834
              if (opt.verbose) {
#line 1836
                if (! opt.output_document) {
                  {
#line 1840
                  tmp___4 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
                  }
#line 1840
                  if (tmp___4 == 0) {
#line 1841
                    sz = st.st_size;
                  } else {
#line 1843
                    sz = (wgint )-1;
                  }
                  {
#line 1844
                  tmp___5 = number_to_static_string(sz);
#line 1844
                  tmp___6 = gettext("Wrote HTML-ized index to `%s\' [%s].\n");
#line 1844
                  logprintf((enum log_options )1, (char const   *)tmp___6, filename,
                            tmp___5);
                  }
                } else {
                  {
#line 1849
                  tmp___7 = gettext("Wrote HTML-ized index to `%s\'.\n");
#line 1849
                  logprintf((enum log_options )1, (char const   *)tmp___7, filename);
                  }
                }
              }
            }
            {
#line 1853
            checking_free((void *)filename);
            }
          }
        }
        {
#line 1855
        freefileinfo(f);
        }
      }
    } else {
#line 1820
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1860
    ispattern = (_Bool)0;
#line 1861
    if (glob) {
      {
#line 1867
      tmp___8 = strrchr((char const   *)u->path, '/');
#line 1867
      file_part = tmp___8;
      }
#line 1868
      if (! file_part) {
#line 1869
        file_part = u->path;
      }
      {
#line 1870
      ispattern = has_wildcards_p((char const   *)file_part);
      }
    }
#line 1872
    if (ispattern) {
#line 1872
      goto _L;
    } else
#line 1872
    if (recursive) {
#line 1872
      goto _L;
    } else
#line 1872
    if (opt.timestamping) {
      _L: /* CIL Label */ 
#line 1877
      if (ispattern) {
#line 1877
        tmp___9 = 0;
      } else {
#line 1877
        tmp___9 = 2;
      }
      {
#line 1877
      res___0 = ftp_retrieve_glob(u, & con, tmp___9);
      }
    } else {
      {
#line 1881
      res___0 = ftp_loop_internal(u, (struct fileinfo *)((void *)0), & con);
      }
    }
  }
#line 1883
  if ((unsigned int )res___0 == 10U) {
#line 1884
    res___0 = (uerr_t )31;
  }
#line 1885
  if ((unsigned int )res___0 == 31U) {
#line 1886
    *dt |= 2;
  }
#line 1888
  if (con.csock != -1) {
    {
#line 1889
    fd_close(con.csock);
    }
  }
#line 1890
  if (! (! con.id)) {
    {
#line 1890
    checking_free((void *)con.id);
    }
  }
#line 1891
  con.id = (char *)((void *)0);
#line 1892
  if (! (! con.target)) {
    {
#line 1892
    checking_free((void *)con.target);
    }
  }
#line 1893
  con.target = (char *)((void *)0);
#line 1894
  return (res___0);
}
}
#line 1900 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static struct fileinfo *delelement(struct fileinfo *f , struct fileinfo **start ) 
{ 
  struct fileinfo *prev ;
  struct fileinfo *next ;

  {
  {
#line 1903
  prev = f->prev;
#line 1904
  next = f->next;
#line 1906
  checking_free((void *)f->name);
  }
#line 1907
  if (! (! f->linkto)) {
    {
#line 1907
    checking_free((void *)f->linkto);
    }
  }
  {
#line 1908
  checking_free((void *)f);
  }
#line 1910
  if (next) {
#line 1911
    next->prev = prev;
  }
#line 1912
  if (prev) {
#line 1913
    prev->next = next;
  } else {
#line 1915
    *start = next;
  }
#line 1916
  return (next);
}
}
#line 1920 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.c"
static void freefileinfo(struct fileinfo *f ) 
{ 
  struct fileinfo *next ;

  {
  {
#line 1923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1923
    if (! f) {
#line 1923
      goto while_break;
    }
    {
#line 1925
    next = f->next;
#line 1926
    checking_free((void *)f->name);
    }
#line 1927
    if (f->linkto) {
      {
#line 1928
      checking_free((void *)f->linkto);
      }
    }
    {
#line 1929
    checking_free((void *)f);
#line 1930
    f = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1932
  return;
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 477 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 82 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 105 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
char *html_quote_string(char const   *s ) ;
#line 52 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static int symperms(char const   *s ) 
{ 
  int perms ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 55
  perms = 0;
#line 57
  tmp = strlen(s);
  }
#line 57
  if (tmp < 9UL) {
#line 58
    return (0);
  }
#line 59
  i = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < 3)) {
#line 59
      goto while_break;
    }
#line 61
    perms <<= 3;
#line 62
    if ((int const   )*(s + 2) == 120) {
#line 62
      tmp___0 = 1;
    } else
#line 62
    if ((int const   )*(s + 2) == 115) {
#line 62
      tmp___0 = 1;
    } else {
#line 62
      tmp___0 = 0;
    }
#line 62
    perms += ((((int const   )*(s + 0) == 114) << 2) + (((int const   )*(s + 1) == 119) << 1)) + tmp___0;
#line 59
    i ++;
#line 59
    s += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (perms);
}
}
#line 73 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static int clean_line(char *line ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 76
  tmp = strlen((char const   *)line);
#line 76
  len = (int )tmp;
  }
#line 77
  if (! len) {
#line 77
    return (0);
  }
#line 78
  if ((int )*(line + (len - 1)) == 10) {
#line 79
    len --;
#line 79
    *(line + len) = (char )'\000';
  }
#line 80
  if ((int )*(line + (len - 1)) == 13) {
#line 81
    len --;
#line 81
    *(line + len) = (char )'\000';
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! *line) {
#line 82
      goto while_break;
    }
#line 82
    if ((int )*line == 9) {
#line 82
      *line = (char )' ';
    }
#line 82
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (len);
}
}
#line 98
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) ;
#line 98 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static char const   *months[12]  = 
#line 98
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 94 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) 
{ 
  FILE *fp ;
  int next ;
  int len ;
  int i ;
  int error ;
  int ignore ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm timestruct ;
  struct tm *tnow ;
  time_t timenow ;
  char *line ;
  char *tok ;
  char *ptok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  wgint size ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  int fnlen ;
  char *p___0 ;
  size_t tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  char const   *tmp___27 ;
  long tmp___28 ;
  long tmp___29 ;
  void *tmp___30 ;
  struct fileinfo *tmp___31 ;
  void *tmp___32 ;

  {
  {
#line 111
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 112
  if (! fp) {
    {
#line 114
    tmp = __errno_location();
#line 114
    tmp___0 = strerror(*tmp);
#line 114
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 115
    return ((struct fileinfo *)((void *)0));
  }
#line 117
  l = (struct fileinfo *)((void *)0);
#line 117
  dir = l;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    line = read_whole_line(fp);
    }
#line 120
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 120
      goto while_break;
    }
    {
#line 122
    len = clean_line(line);
#line 124
    tmp___1 = strncasecmp((char const   *)line, "total", (size_t )5);
    }
#line 124
    if (! tmp___1) {
      {
#line 126
      checking_free((void *)line);
      }
#line 127
      goto while_continue;
    }
    {
#line 130
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 131
    if (! tok) {
      {
#line 133
      checking_free((void *)line);
      }
#line 134
      goto while_continue;
    }
#line 137
    cur.name = (char *)((void *)0);
#line 138
    cur.linkto = (char *)((void *)0);
    {
#line 143
    if ((int )*tok == 45) {
#line 143
      goto case_45;
    }
#line 147
    if ((int )*tok == 100) {
#line 147
      goto case_100;
    }
#line 151
    if ((int )*tok == 108) {
#line 151
      goto case_108;
    }
#line 155
    goto switch_default;
    case_45: /* CIL Label */ 
#line 144
    cur.type = (enum ftype )0;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 145
      tmp___2 = __builtin_expect((long )opt.debug, 0L);
      }
#line 145
      if (tmp___2) {
        {
#line 145
        debug_logprintf("PLAINFILE; ");
        }
      }
#line 145
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 146
    goto switch_break;
    case_100: /* CIL Label */ 
#line 148
    cur.type = (enum ftype )1;
    {
#line 149
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 149
      tmp___3 = __builtin_expect((long )opt.debug, 0L);
      }
#line 149
      if (tmp___3) {
        {
#line 149
        debug_logprintf("DIRECTORY; ");
        }
      }
#line 149
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 150
    goto switch_break;
    case_108: /* CIL Label */ 
#line 152
    cur.type = (enum ftype )2;
    {
#line 153
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 153
      tmp___4 = __builtin_expect((long )opt.debug, 0L);
      }
#line 153
      if (tmp___4) {
        {
#line 153
        debug_logprintf("SYMLINK; ");
        }
      }
#line 153
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 154
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 156
    cur.type = (enum ftype )3;
    {
#line 157
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 157
      tmp___5 = __builtin_expect((long )opt.debug, 0L);
      }
#line 157
      if (tmp___5) {
        {
#line 157
        debug_logprintf("UNKNOWN; ");
        }
      }
#line 157
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 158
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 161
    if (ignore_perms) {
      {
#line 165
      if ((unsigned int )cur.type == 0U) {
#line 165
        goto case_0;
      }
#line 168
      if ((unsigned int )cur.type == 1U) {
#line 168
        goto case_1;
      }
#line 171
      goto switch_default___0;
      case_0: /* CIL Label */ 
#line 166
      cur.perms = 420;
#line 167
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 169
      cur.perms = 493;
#line 170
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 173
      cur.perms = 420;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 175
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 175
        tmp___6 = __builtin_expect((long )opt.debug, 0L);
        }
#line 175
        if (tmp___6) {
          {
#line 175
          debug_logprintf("implicit perms %0o; ", cur.perms);
          }
        }
#line 175
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 179
      cur.perms = symperms((char const   *)(tok + 1));
      }
      {
#line 180
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 180
        tmp___7 = __builtin_expect((long )opt.debug, 0L);
        }
#line 180
        if (tmp___7) {
          {
#line 180
          debug_logprintf("perms %0o; ", cur.perms);
          }
        }
#line 180
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 183
    ignore = 0;
#line 183
    error = ignore;
#line 185
    sec = 0;
#line 185
    min = sec;
#line 185
    hour = min;
#line 185
    year = hour;
#line 186
    day = 0;
#line 186
    month = day;
#line 187
    next = -1;
#line 199
    tok = line;
    {
#line 200
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 200
      ptok = tok;
#line 200
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
#line 200
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 200
        goto while_break___6;
      }
#line 203
      next --;
#line 204
      if (next < 0) {
#line 206
        i = 0;
        {
#line 206
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 206
          if (! (i < 12)) {
#line 206
            goto while_break___7;
          }
          {
#line 207
          tmp___8 = strcmp((char const   *)tok, months[i]);
          }
#line 207
          if (! tmp___8) {
#line 208
            goto while_break___7;
          }
#line 206
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 211
        if (i != 12) {
#line 216
          if ((unsigned long )ptok == (unsigned long )line) {
#line 219
            error = 1;
#line 220
            goto while_break___6;
          }
          {
#line 222
          tmp___9 = __errno_location();
#line 222
          *tmp___9 = 0;
#line 223
          size = strtol((char const   */* __restrict  */)ptok, (char **/* __restrict  */)((void *)0),
                        10);
          }
#line 224
          if (size == ~ (-1L << (sizeof(wgint ) * 8UL - 1UL))) {
            {
#line 224
            tmp___10 = __errno_location();
            }
#line 224
            if (*tmp___10 == 34) {
#line 227
              cur.size = (wgint )0;
            } else {
#line 229
              cur.size = size;
            }
          } else {
#line 229
            cur.size = size;
          }
          {
#line 230
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 230
            tmp___12 = __builtin_expect((long )opt.debug, 0L);
            }
#line 230
            if (tmp___12) {
              {
#line 230
              tmp___11 = number_to_static_string(cur.size);
#line 230
              debug_logprintf("size: %s; ", tmp___11);
              }
            }
#line 230
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 232
          month = i;
#line 233
          next = 5;
          {
#line 234
          while (1) {
            while_continue___9: /* CIL Label */ ;
            {
#line 234
            tmp___13 = __builtin_expect((long )opt.debug, 0L);
            }
#line 234
            if (tmp___13) {
              {
#line 234
              debug_logprintf("month: %s; ", months[month]);
              }
            }
#line 234
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      } else
#line 237
      if (next == 4) {
#line 239
        if (*(tok + 1)) {
#line 240
          day = (10 * ((int )*tok - 48) + (int )*(tok + 1)) - 48;
        } else {
#line 242
          day = (int )*tok - 48;
        }
        {
#line 243
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 243
          tmp___14 = __builtin_expect((long )opt.debug, 0L);
          }
#line 243
          if (tmp___14) {
            {
#line 243
            debug_logprintf("day: %d; ", day);
            }
          }
#line 243
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else
#line 245
      if (next == 3) {
#line 253
        year = 0;
#line 254
        sec = 0;
#line 254
        hour = sec;
#line 254
        min = hour;
#line 256
        if ((int const   )_sch_istable[(int )*tok & 255] & 4) {
          {
#line 259
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 259
            if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 259
              goto while_break___11;
            }
#line 260
            year = ((int )*tok - 48) + 10 * year;
#line 259
            tok ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 261
          if ((int )*tok == 58) {
#line 264
            hour = year;
#line 265
            year = 0;
#line 266
            tok ++;
            {
#line 268
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 268
              if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 268
                goto while_break___12;
              }
#line 269
              min = ((int )*tok - 48) + 10 * min;
#line 268
              tok ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 270
            if ((int )*tok == 58) {
#line 273
              tok ++;
              {
#line 274
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 274
                if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 274
                  goto while_break___13;
                }
#line 275
                sec = ((int )*tok - 48) + 10 * sec;
#line 274
                tok ++;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        }
#line 279
        if (year) {
          {
#line 280
          while (1) {
            while_continue___14: /* CIL Label */ ;
            {
#line 280
            tmp___15 = __builtin_expect((long )opt.debug, 0L);
            }
#line 280
            if (tmp___15) {
              {
#line 280
              debug_logprintf("year: %d (no tm); ", year);
              }
            }
#line 280
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        } else {
          {
#line 282
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 282
            tmp___16 = __builtin_expect((long )opt.debug, 0L);
            }
#line 282
            if (tmp___16) {
              {
#line 282
              debug_logprintf("time: %02d:%02d:%02d (no yr); ", hour, min, sec);
              }
            }
#line 282
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      } else
#line 284
      if (next == 2) {
        {
#line 291
        tmp___17 = strlen((char const   *)tok);
#line 291
        fnlen = (int )tmp___17;
        }
#line 292
        if ((long )fnlen < (long )len - (tok - line)) {
#line 296
          *(tok + fnlen) = (char )' ';
#line 299
          if ((unsigned int )cur.type == 2U) {
            {
#line 301
            p___0 = strstr((char const   *)tok, " -> ");
            }
#line 302
            if (! p___0) {
#line 304
              error = 1;
#line 305
              goto while_break___6;
            }
            {
#line 307
            cur.linkto = checking_strdup((char const   *)(p___0 + 4));
            }
            {
#line 308
            while (1) {
              while_continue___16: /* CIL Label */ ;
              {
#line 308
              tmp___18 = __builtin_expect((long )opt.debug, 0L);
              }
#line 308
              if (tmp___18) {
                {
#line 308
                debug_logprintf("link to: %s\n", cur.linkto);
                }
              }
#line 308
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 310
            *p___0 = (char )'\000';
          }
        }
        {
#line 316
        tmp___20 = strcmp((char const   *)tok, ".");
        }
#line 316
        if (tmp___20) {
          {
#line 316
          tmp___21 = strcmp((char const   *)tok, "..");
          }
#line 316
          if (! tmp___21) {
            _L: /* CIL Label */ 
            {
#line 318
            while (1) {
              while_continue___17: /* CIL Label */ ;
              {
#line 318
              tmp___19 = __builtin_expect((long )opt.debug, 0L);
              }
#line 318
              if (tmp___19) {
                {
#line 318
                debug_logprintf("\nIgnoring `.\' and `..\'; ");
                }
              }
#line 318
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 319
            ignore = 1;
#line 320
            goto while_break___6;
          }
        } else {
#line 316
          goto _L;
        }
        {
#line 330
        tmp___22 = strlen((char const   *)tok);
#line 330
        fnlen = (int )tmp___22;
#line 331
        tmp___23 = checking_malloc((size_t )(fnlen + 1));
#line 331
        cur.name = (char *)tmp___23;
#line 332
        memcpy((void */* __restrict  */)cur.name, (void const   */* __restrict  */)tok,
               (size_t )(fnlen + 1));
        }
#line 333
        if (fnlen) {
#line 335
          if ((unsigned int )cur.type == 1U) {
#line 335
            if ((int )*(cur.name + (fnlen - 1)) == 47) {
#line 337
              *(cur.name + (fnlen - 1)) = (char )'\000';
              {
#line 338
              while (1) {
                while_continue___18: /* CIL Label */ ;
                {
#line 338
                tmp___24 = __builtin_expect((long )opt.debug, 0L);
                }
#line 338
                if (tmp___24) {
                  {
#line 338
                  debug_logprintf("trailing `/\' on dir.\n");
                  }
                }
#line 338
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
            } else {
#line 335
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 340
          if ((unsigned int )cur.type == 2U) {
#line 340
            if ((int )*(cur.name + (fnlen - 1)) == 64) {
#line 342
              *(cur.name + (fnlen - 1)) = (char )'\000';
              {
#line 343
              while (1) {
                while_continue___19: /* CIL Label */ ;
                {
#line 343
                tmp___25 = __builtin_expect((long )opt.debug, 0L);
                }
#line 343
                if (tmp___25) {
                  {
#line 343
                  debug_logprintf("trailing `@\' on link.\n");
                  }
                }
#line 343
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
            } else {
#line 340
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 345
          if ((unsigned int )cur.type == 0U) {
#line 345
            if (cur.perms & 73) {
#line 345
              if ((int )*(cur.name + (fnlen - 1)) == 42) {
#line 349
                *(cur.name + (fnlen - 1)) = (char )'\000';
                {
#line 350
                while (1) {
                  while_continue___20: /* CIL Label */ ;
                  {
#line 350
                  tmp___26 = __builtin_expect((long )opt.debug, 0L);
                  }
#line 350
                  if (tmp___26) {
                    {
#line 350
                    debug_logprintf("trailing `*\' on exec.\n");
                    }
                  }
#line 350
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
        } else {
#line 354
          error = 1;
        }
#line 355
        goto while_break___6;
      } else {
        {
#line 358
        abort();
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 361
    if (! cur.name) {
#line 362
      error = 1;
    } else
#line 361
    if ((unsigned int )cur.type == 2U) {
#line 361
      if (! cur.linkto) {
#line 362
        error = 1;
      }
    }
    {
#line 364
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 364
      tmp___28 = __builtin_expect((long )opt.debug, 0L);
      }
#line 364
      if (tmp___28) {
#line 364
        if (cur.name) {
#line 364
          tmp___27 = (char const   *)cur.name;
        } else {
#line 364
          tmp___27 = "";
        }
        {
#line 364
        debug_logprintf("%s\n", tmp___27);
        }
      }
#line 364
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 366
    if (error) {
#line 366
      goto _L___2;
    } else
#line 366
    if (ignore) {
      _L___2: /* CIL Label */ 
      {
#line 368
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 368
        tmp___29 = __builtin_expect((long )opt.debug, 0L);
        }
#line 368
        if (tmp___29) {
          {
#line 368
          debug_logprintf("Skipping.\n");
          }
        }
#line 368
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 369
      if (! (! cur.name)) {
        {
#line 369
        checking_free((void *)cur.name);
        }
      }
#line 370
      if (! (! cur.linkto)) {
        {
#line 370
        checking_free((void *)cur.linkto);
        }
      }
      {
#line 371
      checking_free((void *)line);
      }
#line 372
      goto while_continue;
    }
#line 375
    if (! dir) {
      {
#line 377
      tmp___30 = checking_malloc(sizeof(struct fileinfo ));
#line 377
      dir = (struct fileinfo *)tmp___30;
#line 377
      l = dir;
#line 378
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 379
      tmp___31 = (struct fileinfo *)((void *)0);
#line 379
      l->next = tmp___31;
#line 379
      l->prev = tmp___31;
      }
    } else {
      {
#line 383
      cur.prev = l;
#line 384
      tmp___32 = checking_malloc(sizeof(struct fileinfo ));
#line 384
      l->next = (struct fileinfo *)tmp___32;
#line 385
      l = l->next;
#line 386
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 387
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 390
    timenow = time((time_t *)((void *)0));
#line 391
    tnow = localtime((time_t const   *)(& timenow));
#line 393
    timestruct.tm_sec = sec;
#line 394
    timestruct.tm_min = min;
#line 395
    timestruct.tm_hour = hour;
#line 396
    timestruct.tm_mday = day;
#line 397
    timestruct.tm_mon = month;
    }
#line 398
    if (year == 0) {
#line 405
      if (month > tnow->tm_mon) {
#line 406
        timestruct.tm_year = tnow->tm_year - 1;
      } else {
#line 408
        timestruct.tm_year = tnow->tm_year;
      }
    } else {
#line 411
      timestruct.tm_year = year;
    }
#line 412
    if (timestruct.tm_year >= 1900) {
#line 413
      timestruct.tm_year -= 1900;
    }
    {
#line 414
    timestruct.tm_wday = 0;
#line 415
    timestruct.tm_yday = 0;
#line 416
    timestruct.tm_isdst = -1;
#line 417
    l->tstamp = mktime(& timestruct);
#line 419
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  fclose(fp);
  }
#line 423
  return (dir);
}
}
#line 426 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static struct fileinfo *ftp_parse_winnt_ls(char const   *file ) 
{ 
  FILE *fp ;
  int len ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  struct tm timestruct ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  wgint size ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  struct fileinfo *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 438
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 439
  if (! fp) {
    {
#line 441
    tmp = __errno_location();
#line 441
    tmp___0 = strerror(*tmp);
#line 441
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 442
    return ((struct fileinfo *)((void *)0));
  }
#line 444
  l = (struct fileinfo *)((void *)0);
#line 444
  dir = l;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    line = read_whole_line(fp);
    }
#line 447
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 447
      goto while_break;
    }
    {
#line 449
    len = clean_line(line);
    }
#line 457
    if (len < 40) {
#line 457
      goto while_continue;
    }
    {
#line 458
    tok = line + 39;
#line 459
    cur.name = checking_strdup((char const   *)tok);
    }
    {
#line 460
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 460
      tmp___1 = __builtin_expect((long )opt.debug, 0L);
      }
#line 460
      if (tmp___1) {
        {
#line 460
        debug_logprintf("Name: \'%s\'\n", cur.name);
        }
      }
#line 460
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 464
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)"-");
    }
#line 465
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 465
      goto while_continue;
    }
    {
#line 466
    tmp___2 = atoi((char const   *)tok);
#line 466
    month = tmp___2 - 1;
    }
#line 467
    if (month < 0) {
#line 467
      month = 0;
    }
    {
#line 468
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
    }
#line 469
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 469
      goto while_continue;
    }
    {
#line 470
    day = atoi((char const   *)tok);
#line 471
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 472
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 472
      goto while_continue;
    }
    {
#line 473
    year = atoi((char const   *)tok);
    }
#line 475
    if (year <= 70) {
#line 475
      year += 100;
    }
    {
#line 479
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
    }
#line 480
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 480
      goto while_continue;
    }
    {
#line 481
    hour = atoi((char const   *)tok);
#line 482
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"M");
    }
#line 483
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 483
      goto while_continue;
    }
    {
#line 484
    min = atoi((char const   *)tok);
#line 487
    tok += 2;
    }
#line 488
    if (hour == 12) {
#line 488
      hour = 0;
    }
#line 489
    if ((int )*tok == 80) {
#line 489
      hour += 12;
    }
    {
#line 491
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 491
      tmp___3 = __builtin_expect((long )opt.debug, 0L);
      }
#line 491
      if (tmp___3) {
        {
#line 491
        debug_logprintf("YYYY/MM/DD HH:MM - %d/%02d/%02d %02d:%02d\n", year + 1900,
                        month, day, hour, min);
        }
      }
#line 491
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 495
    timestruct.tm_sec = 0;
#line 496
    timestruct.tm_min = min;
#line 497
    timestruct.tm_hour = hour;
#line 498
    timestruct.tm_mday = day;
#line 499
    timestruct.tm_mon = month;
#line 500
    timestruct.tm_year = year;
#line 501
    timestruct.tm_wday = 0;
#line 502
    timestruct.tm_yday = 0;
#line 503
    timestruct.tm_isdst = -1;
#line 504
    cur.tstamp = mktime(& timestruct);
    }
    {
#line 506
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 506
      tmp___4 = __builtin_expect((long )opt.debug, 0L);
      }
#line 506
      if (tmp___4) {
        {
#line 506
        debug_logprintf("Timestamp: %ld\n", cur.tstamp);
        }
      }
#line 506
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 512
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 513
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 513
      goto while_continue;
    }
    {
#line 514
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 514
      if ((unsigned long )tok != (unsigned long )((void *)0)) {
#line 514
        if (! ((int )*tok == 0)) {
#line 514
          goto while_break___3;
        }
      } else {
#line 514
        goto while_break___3;
      }
      {
#line 514
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 515
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 515
      goto while_continue;
    }
#line 516
    if ((int )*tok == 60) {
#line 518
      cur.type = (enum ftype )1;
#line 519
      cur.size = (wgint )0;
#line 520
      cur.perms = 493;
      {
#line 521
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 521
        tmp___5 = __builtin_expect((long )opt.debug, 0L);
        }
#line 521
        if (tmp___5) {
          {
#line 521
          debug_logprintf("Directory\n");
          }
        }
#line 521
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 526
      cur.type = (enum ftype )0;
#line 527
      tmp___6 = __errno_location();
#line 527
      *tmp___6 = 0;
#line 528
      size = strtol((char const   */* __restrict  */)tok, (char **/* __restrict  */)((void *)0),
                    10);
      }
#line 529
      if (size == ~ (-1L << (sizeof(wgint ) * 8UL - 1UL))) {
        {
#line 529
        tmp___7 = __errno_location();
        }
#line 529
        if (*tmp___7 == 34) {
#line 530
          cur.size = (wgint )0;
        } else {
#line 532
          cur.size = size;
        }
      } else {
#line 532
        cur.size = size;
      }
#line 533
      cur.perms = 420;
      {
#line 534
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 534
        tmp___9 = __builtin_expect((long )opt.debug, 0L);
        }
#line 534
        if (tmp___9) {
          {
#line 534
          tmp___8 = number_to_static_string(cur.size);
#line 534
          debug_logprintf("File, size %s bytes\n", tmp___8);
          }
        }
#line 534
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 537
    cur.linkto = (char *)((void *)0);
#line 540
    if (! dir) {
      {
#line 542
      tmp___10 = checking_malloc(sizeof(struct fileinfo ));
#line 542
      dir = (struct fileinfo *)tmp___10;
#line 542
      l = dir;
#line 543
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 544
      tmp___11 = (struct fileinfo *)((void *)0);
#line 544
      l->next = tmp___11;
#line 544
      l->prev = tmp___11;
      }
    } else {
      {
#line 548
      cur.prev = l;
#line 549
      tmp___12 = checking_malloc(sizeof(struct fileinfo ));
#line 549
      l->next = (struct fileinfo *)tmp___12;
#line 550
      l = l->next;
#line 551
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 552
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 555
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  fclose(fp);
  }
#line 559
  return (dir);
}
}
#line 565 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static int vmsperms(char const   *s ) 
{ 
  int perms ;
  long tmp ;

  {
#line 568
  perms = 0;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 573
    if ((int const   )*s == 44) {
#line 573
      goto case_44;
    }
#line 574
    if ((int const   )*s == 82) {
#line 574
      goto case_82;
    }
#line 575
    if ((int const   )*s == 87) {
#line 575
      goto case_87;
    }
#line 576
    if ((int const   )*s == 68) {
#line 576
      goto case_68;
    }
#line 577
    if ((int const   )*s == 69) {
#line 577
      goto case_69;
    }
#line 578
    goto switch_default;
    case_44: /* CIL Label */ 
#line 573
    perms <<= 3;
#line 573
    goto switch_break;
    case_82: /* CIL Label */ 
#line 574
    perms |= 4;
#line 574
    goto switch_break;
    case_87: /* CIL Label */ 
#line 575
    perms |= 2;
#line 575
    goto switch_break;
    case_68: /* CIL Label */ 
#line 576
    perms |= 2;
#line 576
    goto switch_break;
    case_69: /* CIL Label */ 
#line 577
    perms |= 1;
#line 577
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 578
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 578
      tmp = __builtin_expect((long )opt.debug, 0L);
      }
#line 578
      if (tmp) {
        {
#line 578
        debug_logprintf("wrong VMS permissons!\n");
        }
      }
#line 578
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 570
    s ++;
#line 570
    if (! *s) {
#line 570
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  return (perms);
}
}
#line 591
static struct fileinfo *ftp_parse_vms_ls(char const   *file ) ;
#line 591 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static char const   *months___0[12]  = 
#line 591
  {      "JAN",      "FEB",      "MAR",      "APR", 
        "MAY",      "JUN",      "JUL",      "AUG", 
        "SEP",      "OCT",      "NOV",      "DEC"};
#line 586 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static struct fileinfo *ftp_parse_vms_ls(char const   *file ) 
{ 
  FILE *fp ;
  int i ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm timestruct ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  char *p___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  void *tmp___20 ;
  struct fileinfo *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 603
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 604
  if (! fp) {
    {
#line 606
    tmp = __errno_location();
#line 606
    tmp___0 = strerror(*tmp);
#line 606
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 607
    return ((struct fileinfo *)((void *)0));
  }
  {
#line 609
  l = (struct fileinfo *)((void *)0);
#line 609
  dir = l;
#line 612
  line = read_whole_line(fp);
  }
#line 613
  if (! (! line)) {
    {
#line 613
    checking_free((void *)line);
    }
  }
  {
#line 616
  line = read_whole_line(fp);
  }
#line 617
  if (! (! line)) {
    {
#line 617
    checking_free((void *)line);
    }
  }
  {
#line 620
  line = read_whole_line(fp);
  }
#line 621
  if (! (! line)) {
    {
#line 621
    checking_free((void *)line);
    }
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 624
    line = read_whole_line(fp);
    }
#line 624
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 624
      goto while_break;
    }
    {
#line 627
    i = clean_line(line);
    }
#line 628
    if (! i) {
      {
#line 630
      checking_free((void *)line);
      }
#line 631
      goto while_break;
    }
    {
#line 642
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 643
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 643
      tok = line;
    }
    {
#line 644
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 644
      tmp___1 = __builtin_expect((long )opt.debug, 0L);
      }
#line 644
      if (tmp___1) {
        {
#line 644
        debug_logprintf("file name: \'%s\'\n", tok);
        }
      }
#line 644
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    p___0 = tok;
    {
#line 645
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 645
      if (*p___0) {
#line 645
        if (! ((int )*p___0 != 59)) {
#line 645
          goto while_break___1;
        }
      } else {
#line 645
        goto while_break___1;
      }
#line 645
      p___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 647
    if ((int )*p___0 == 59) {
#line 647
      *p___0 = (char )'\000';
    }
    {
#line 648
    tmp___2 = strlen((char const   *)tok);
#line 648
    p___0 = (tok + tmp___2) - 4;
#line 649
    tmp___3 = strcmp((char const   *)p___0, ".DIR");
    }
#line 649
    if (! tmp___3) {
#line 649
      *p___0 = (char )'\000';
    }
    {
#line 650
    cur.name = checking_strdup((char const   *)tok);
    }
    {
#line 651
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 651
      tmp___4 = __builtin_expect((long )opt.debug, 0L);
      }
#line 651
      if (tmp___4) {
        {
#line 651
        debug_logprintf("Name: \'%s\'\n", cur.name);
        }
      }
#line 651
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 658
    if (! *p___0) {
#line 660
      cur.type = (enum ftype )1;
#line 661
      cur.size = (wgint )0;
      {
#line 662
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 662
        tmp___5 = __builtin_expect((long )opt.debug, 0L);
        }
#line 662
        if (tmp___5) {
          {
#line 662
          debug_logprintf("Directory\n");
          }
        }
#line 662
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 666
      cur.type = (enum ftype )0;
      {
#line 667
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 667
        tmp___6 = __builtin_expect((long )opt.debug, 0L);
        }
#line 667
        if (tmp___6) {
          {
#line 667
          debug_logprintf("File\n");
          }
        }
#line 667
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 670
    cur.size = (wgint )0;
#line 675
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 676
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      {
#line 678
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 678
        tmp___7 = __builtin_expect((long )opt.debug, 0L);
        }
#line 678
        if (tmp___7) {
          {
#line 678
          debug_logprintf("Getting additional line\n");
          }
        }
#line 678
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 679
      checking_free((void *)line);
#line 680
      line = read_whole_line(fp);
      }
#line 681
      if (! line) {
        {
#line 683
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 683
          tmp___8 = __builtin_expect((long )opt.debug, 0L);
          }
#line 683
          if (tmp___8) {
            {
#line 683
            debug_logprintf("empty line read, leaving listing parser\n");
            }
          }
#line 683
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 684
        goto while_break;
      }
      {
#line 686
      i = clean_line(line);
      }
#line 687
      if (! i) {
        {
#line 689
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 689
          tmp___9 = __builtin_expect((long )opt.debug, 0L);
          }
#line 689
          if (tmp___9) {
            {
#line 689
            debug_logprintf("confusing VMS listing item, leaving listing parser\n");
            }
          }
#line 689
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 690
        checking_free((void *)line);
        }
#line 691
        goto while_break;
      }
      {
#line 693
      tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 695
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 695
      tmp___10 = __builtin_expect((long )opt.debug, 0L);
      }
#line 695
      if (tmp___10) {
        {
#line 695
        debug_logprintf("second token: \'%s\'\n", tok);
        }
      }
#line 695
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 699
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
    }
#line 700
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 700
      goto while_continue;
    }
    {
#line 701
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 701
      tmp___11 = __builtin_expect((long )opt.debug, 0L);
      }
#line 701
      if (tmp___11) {
        {
#line 701
        debug_logprintf("day: \'%s\'\n", tok);
        }
      }
#line 701
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 702
    day = atoi((char const   *)tok);
#line 703
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
    }
#line 704
    if (! tok) {
      {
#line 710
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 710
        tmp___12 = __builtin_expect((long )opt.debug, 0L);
        }
#line 710
        if (tmp___12) {
          {
#line 710
          debug_logprintf("nonsense in VMS listing, skipping this line\n");
          }
        }
#line 710
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 711
      checking_free((void *)line);
      }
#line 712
      goto while_break;
    }
#line 714
    i = 0;
    {
#line 714
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 714
      if (! (i < 12)) {
#line 714
        goto while_break___11;
      }
      {
#line 714
      tmp___13 = strcmp((char const   *)tok, months___0[i]);
      }
#line 714
      if (! tmp___13) {
#line 714
        goto while_break___11;
      }
#line 714
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 716
    month = i % 12;
#line 717
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 718
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 718
      goto while_continue;
    }
    {
#line 719
    tmp___14 = atoi((char const   *)tok);
#line 719
    year = tmp___14 - 1900;
    }
    {
#line 720
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 720
      tmp___15 = __builtin_expect((long )opt.debug, 0L);
      }
#line 720
      if (tmp___15) {
        {
#line 720
        debug_logprintf("date parsed\n");
        }
      }
#line 720
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 723
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 724
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 724
      goto while_continue;
    }
    {
#line 725
    sec = 0;
#line 725
    min = sec;
#line 726
    p___0 = tok;
#line 727
    hour = atoi((char const   *)p___0);
    }
    {
#line 728
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 728
      if (*p___0) {
#line 728
        if (! ((int )*p___0 != 58)) {
#line 728
          goto while_break___13;
        }
      } else {
#line 728
        goto while_break___13;
      }
#line 728
      p___0 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 730
    if (*p___0) {
      {
#line 731
      p___0 ++;
#line 731
      min = atoi((char const   *)p___0);
      }
    }
    {
#line 732
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 732
      if (*p___0) {
#line 732
        if (! ((int )*p___0 != 58)) {
#line 732
          goto while_break___14;
        }
      } else {
#line 732
        goto while_break___14;
      }
#line 732
      p___0 ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 734
    if (*p___0) {
      {
#line 735
      p___0 ++;
#line 735
      sec = atoi((char const   *)p___0);
      }
    }
    {
#line 737
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 737
      tmp___16 = __builtin_expect((long )opt.debug, 0L);
      }
#line 737
      if (tmp___16) {
        {
#line 737
        debug_logprintf("YYYY/MM/DD HH:MM:SS - %d/%02d/%02d %02d:%02d:%02d\n", year + 1900,
                        month, day, hour, min, sec);
        }
      }
#line 737
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 741
    timestruct.tm_sec = sec;
#line 742
    timestruct.tm_min = min;
#line 743
    timestruct.tm_hour = hour;
#line 744
    timestruct.tm_mday = day;
#line 745
    timestruct.tm_mon = month;
#line 746
    timestruct.tm_year = year;
#line 747
    timestruct.tm_wday = 0;
#line 748
    timestruct.tm_yday = 0;
#line 749
    timestruct.tm_isdst = -1;
#line 750
    cur.tstamp = mktime(& timestruct);
    }
    {
#line 752
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 752
      tmp___17 = __builtin_expect((long )opt.debug, 0L);
      }
#line 752
      if (tmp___17) {
        {
#line 752
        debug_logprintf("Timestamp: %ld\n", cur.tstamp);
        }
      }
#line 752
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 756
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 757
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 757
      goto while_continue;
    }
    {
#line 761
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
#line 762
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 762
      goto while_continue;
    }
    {
#line 763
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)")");
    }
#line 764
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      {
#line 766
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 766
        tmp___18 = __builtin_expect((long )opt.debug, 0L);
        }
#line 766
        if (tmp___18) {
          {
#line 766
          debug_logprintf("confusing VMS permissions, skipping line\n");
          }
        }
#line 766
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 767
      checking_free((void *)line);
      }
#line 768
      goto while_continue;
    }
    {
#line 771
    cur.perms = vmsperms((char const   *)tok);
    }
    {
#line 772
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 772
      tmp___19 = __builtin_expect((long )opt.debug, 0L);
      }
#line 772
      if (tmp___19) {
        {
#line 772
        debug_logprintf("permissions: %s -> 0%o\n", tok, cur.perms);
        }
      }
#line 772
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 774
    cur.linkto = (char *)((void *)0);
#line 777
    if (! dir) {
      {
#line 779
      tmp___20 = checking_malloc(sizeof(struct fileinfo ));
#line 779
      dir = (struct fileinfo *)tmp___20;
#line 779
      l = dir;
#line 780
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 781
      tmp___21 = (struct fileinfo *)((void *)0);
#line 781
      l->next = tmp___21;
#line 781
      l->prev = tmp___21;
      }
    } else {
      {
#line 785
      cur.prev = l;
#line 786
      tmp___22 = checking_malloc(sizeof(struct fileinfo ));
#line 786
      l->next = (struct fileinfo *)tmp___22;
#line 787
      l = l->next;
#line 788
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 789
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 792
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  fclose(fp);
  }
#line 796
  return (dir);
}
}
#line 806 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) 
{ 
  struct fileinfo *tmp ;
  FILE *fp ;
  int c ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct fileinfo *tmp___2 ;
  struct fileinfo *tmp___3 ;
  struct fileinfo *tmp___4 ;
  struct fileinfo *tmp___5 ;
  char *tmp___6 ;
  struct fileinfo *tmp___7 ;

  {
  {
#line 811
  if ((unsigned int const   )system_type == 0U) {
#line 811
    goto case_0;
  }
#line 813
  if ((unsigned int const   )system_type == 2U) {
#line 813
    goto case_2;
  }
#line 833
  if ((unsigned int const   )system_type == 1U) {
#line 833
    goto case_1;
  }
#line 835
  if ((unsigned int const   )system_type == 3U) {
#line 835
    goto case_3;
  }
#line 837
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 812
  tmp = ftp_parse_unix_ls(file, 0);
  }
#line 812
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 818
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 819
  if (! fp) {
    {
#line 821
    tmp___0 = __errno_location();
#line 821
    tmp___1 = strerror(*tmp___0);
#line 821
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___1);
    }
#line 822
    return ((struct fileinfo *)((void *)0));
  }
  {
#line 824
  c = fgetc(fp);
#line 825
  fclose(fp);
  }
#line 828
  if (c >= 48) {
#line 828
    if (c <= 57) {
      {
#line 829
      tmp___2 = ftp_parse_winnt_ls(file);
      }
#line 829
      return (tmp___2);
    } else {
      {
#line 831
      tmp___3 = ftp_parse_unix_ls(file, 1);
      }
#line 831
      return (tmp___3);
    }
  } else {
    {
#line 831
    tmp___3 = ftp_parse_unix_ls(file, 1);
    }
#line 831
    return (tmp___3);
  }
  case_1: /* CIL Label */ 
  {
#line 834
  tmp___4 = ftp_parse_vms_ls(file);
  }
#line 834
  return (tmp___4);
  case_3: /* CIL Label */ 
  {
#line 836
  tmp___5 = ftp_parse_unix_ls(file, 1);
  }
#line 836
  return (tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 838
  tmp___6 = gettext("Unsupported listing type, trying Unix listing parser.\n");
#line 838
  logprintf((enum log_options )1, (char const   *)tmp___6);
#line 840
  tmp___7 = ftp_parse_unix_ls(file, 0);
  }
#line 840
  return (tmp___7);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 895 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
static char const   *months___1[12]  = 
#line 895
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 849 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-ls.c"
uerr_t ftp_index(char const   *file , struct url *u , struct fileinfo *f ) 
{ 
  FILE *fp ;
  char *upwd ;
  char *htclfile ;
  int *tmp ;
  char *tmp___0 ;
  char *tmpu ;
  char *tmpp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  time_t tstamp ;
  struct tm *ptm ;
  struct tm *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 856
  if (! output_stream) {
    {
#line 858
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"wb");
    }
#line 859
    if (! fp) {
      {
#line 861
      tmp = __errno_location();
#line 861
      tmp___0 = strerror(*tmp);
#line 861
      logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
      }
#line 862
      return ((uerr_t )24);
    }
  } else {
#line 866
    fp = output_stream;
  }
#line 867
  if (u->user) {
    {
#line 871
    tmpu = url_escape((char const   *)u->user);
    }
#line 872
    if (u->passwd) {
      {
#line 872
      tmp___1 = url_escape((char const   *)u->passwd);
#line 872
      tmpp = tmp___1;
      }
    } else {
#line 872
      tmpp = (char *)((void *)0);
    }
#line 873
    if (tmpp) {
      {
#line 874
      upwd = concat_strings((char const   *)tmpu, ":", tmpp, "@", (char *)0);
      }
    } else {
      {
#line 876
      upwd = concat_strings((char const   *)tmpu, "@", (char *)0);
      }
    }
    {
#line 877
    checking_free((void *)tmpu);
    }
#line 878
    if (! (! tmpp)) {
      {
#line 878
      checking_free((void *)tmpp);
      }
    }
  } else {
    {
#line 881
    upwd = checking_strdup("");
    }
  }
  {
#line 882
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n");
#line 883
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<html>\n<head>\n<title>");
#line 884
  tmp___2 = gettext("Index of /%s on %s:%d");
#line 884
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___2, u->dir,
          u->host, u->port);
#line 885
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</title>\n</head>\n<body>\n<h1>");
#line 886
  tmp___3 = gettext("Index of /%s on %s:%d");
#line 886
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___3, u->dir,
          u->host, u->port);
#line 887
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</h1>\n<hr>\n<pre>\n");
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! f) {
#line 888
      goto while_break;
    }
    {
#line 890
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
    }
#line 891
    if (f->tstamp != -1L) {
      {
#line 899
      tstamp = f->tstamp;
#line 900
      tmp___4 = localtime((time_t const   *)(& tstamp));
#line 900
      ptm = tmp___4;
#line 902
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %s %02d ",
              ptm->tm_year + 1900, months___1[ptm->tm_mon], ptm->tm_mday);
      }
#line 904
      if (ptm->tm_hour) {
        {
#line 905
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%02d:%02d  ",
                ptm->tm_hour, ptm->tm_min);
        }
      } else {
        {
#line 907
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"       ");
        }
      }
    } else {
      {
#line 910
      tmp___5 = gettext("time unknown       ");
#line 910
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___5);
      }
    }
    {
#line 913
    if ((unsigned int )f->type == 0U) {
#line 913
      goto case_0;
    }
#line 916
    if ((unsigned int )f->type == 1U) {
#line 916
      goto case_1;
    }
#line 919
    if ((unsigned int )f->type == 2U) {
#line 919
      goto case_2;
    }
#line 922
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 914
    tmp___6 = gettext("File        ");
#line 914
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___6);
    }
#line 915
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 917
    tmp___7 = gettext("Directory   ");
#line 917
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___7);
    }
#line 918
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 920
    tmp___8 = gettext("Link        ");
#line 920
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___8);
    }
#line 921
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 923
    tmp___9 = gettext("Not sure    ");
#line 923
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___9);
    }
#line 924
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 926
    htclfile = html_quote_string((char const   *)f->name);
#line 927
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<a href=\"ftp://%s%s:%d",
            upwd, u->host, u->port);
    }
#line 928
    if ((int )*(u->dir) != 47) {
      {
#line 929
      _IO_putc('/', fp);
      }
    }
    {
#line 930
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", u->dir);
    }
#line 931
    if (*(u->dir)) {
      {
#line 932
      _IO_putc('/', fp);
      }
    }
    {
#line 933
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", htclfile);
    }
#line 934
    if ((unsigned int )f->type == 1U) {
      {
#line 935
      _IO_putc('/', fp);
      }
    }
    {
#line 936
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\">%s",
            htclfile);
    }
#line 937
    if ((unsigned int )f->type == 1U) {
      {
#line 938
      _IO_putc('/', fp);
      }
    }
    {
#line 939
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</a> ");
    }
#line 940
    if ((unsigned int )f->type == 0U) {
      {
#line 941
      tmp___10 = number_to_static_string(f->size);
#line 941
      tmp___11 = gettext(" (%s bytes)");
#line 941
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___11,
              tmp___10);
      }
    } else
#line 942
    if ((unsigned int )f->type == 2U) {
#line 943
      if (f->linkto) {
#line 943
        tmp___12 = (char const   *)f->linkto;
      } else {
#line 943
        tmp___12 = "(nil)";
      }
      {
#line 943
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-> %s",
              tmp___12);
      }
    }
    {
#line 944
    _IO_putc('\n', fp);
#line 945
    checking_free((void *)htclfile);
#line 946
    f = f->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</pre>\n</body>\n</html>\n");
#line 949
  checking_free((void *)upwd);
  }
#line 950
  if (! output_stream) {
    {
#line 951
    fclose(fp);
    }
  } else {
    {
#line 953
    fflush(fp);
    }
  }
#line 954
  return ((uerr_t )10);
}
}
#line 45 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.h"
int bind_local(ip_address const   *bind_address , int *port ) ;
#line 47 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp.h"
char ftp_last_respline[128]  ;
#line 62 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_response(int fd , char **ret_line ) 
{ 
  char *p___0 ;
  char *line ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    tmp = fd_read_line(fd);
#line 68
    line = tmp;
    }
#line 69
    if (! line) {
#line 70
      return ((uerr_t )18);
    }
    {
#line 74
    p___0 = strchr((char const   *)line, '\000');
    }
#line 75
    if ((unsigned long )p___0 > (unsigned long )line) {
#line 75
      if ((int )*(p___0 + -1) == 10) {
#line 76
        p___0 --;
#line 76
        *p___0 = (char )'\000';
      }
    }
#line 77
    if ((unsigned long )p___0 > (unsigned long )line) {
#line 77
      if ((int )*(p___0 + -1) == 13) {
#line 78
        p___0 --;
#line 78
        *p___0 = (char )'\000';
      }
    }
#line 80
    if (opt.server_response) {
      {
#line 81
      tmp___0 = escnonprint((char const   *)line);
#line 81
      logprintf((enum log_options )1, "%s\n", tmp___0);
      }
    } else {
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 83
        tmp___2 = __builtin_expect((long )opt.debug, 0L);
        }
#line 83
        if (tmp___2) {
          {
#line 83
          tmp___1 = escnonprint((char const   *)line);
#line 83
          debug_logprintf("%s\n", tmp___1);
          }
        }
#line 83
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 86
    if ((int const   )_sch_istable[(int )*(line + 0) & 255] & 4) {
#line 86
      if ((int const   )_sch_istable[(int )*(line + 1) & 255] & 4) {
#line 86
        if ((int const   )_sch_istable[(int )*(line + 2) & 255] & 4) {
#line 86
          if ((int )*(line + 3) == 32) {
            {
#line 89
            strncpy((char */* __restrict  */)(ftp_last_respline), (char const   */* __restrict  */)line,
                    sizeof(ftp_last_respline));
#line 90
            ftp_last_respline[sizeof(ftp_last_respline) - 1UL] = (char )'\000';
#line 91
            *ret_line = line;
            }
#line 92
            return ((uerr_t )10);
          }
        }
      }
    }
    {
#line 94
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 101 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
static char *ftp_request(char const   *command , char const   *value ) 
{ 
  char *res___0 ;
  char *defanged ;
  char *p___0 ;
  char **SA_dest ;
  char const   *SA_src ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 105
  if (value) {
    {
#line 112
    tmp___4 = strpbrk(value, "\r\n");
    }
#line 112
    if (tmp___4) {
      {
#line 116
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 116
        SA_dest = & defanged;
#line 116
        SA_src = value;
#line 116
        tmp = strlen(SA_src);
#line 116
        tmp___0 = __builtin_alloca(tmp + 1UL);
#line 116
        *SA_dest = (char *)tmp___0;
#line 116
        strcpy((char */* __restrict  */)*SA_dest, (char const   */* __restrict  */)SA_src);
        }
#line 116
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 117
      p___0 = defanged;
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! *p___0) {
#line 117
          goto while_break___0;
        }
#line 118
        if ((int )*p___0 == 13) {
#line 119
          *p___0 = (char )' ';
        } else
#line 118
        if ((int )*p___0 == 10) {
#line 119
          *p___0 = (char )' ';
        }
#line 117
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 120
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 120
        tmp___3 = __builtin_expect((long )opt.debug, 0L);
        }
#line 120
        if (tmp___3) {
          {
#line 120
          tmp___1 = escnonprint((char const   *)defanged);
#line 120
          tmp___2 = escnonprint(value);
#line 120
          debug_logprintf("\nDetected newlines in %s \"%s\"; changing to %s \"%s\"\n",
                          command, tmp___2, command, tmp___1);
          }
        }
#line 120
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 123
      value = (char const   *)defanged;
    }
    {
#line 125
    res___0 = concat_strings(command, " ", value, "\r\n", (char *)0);
    }
  } else {
    {
#line 128
    res___0 = concat_strings(command, "\r\n", (char *)0);
    }
  }
#line 129
  if (opt.server_response) {
    {
#line 132
    tmp___5 = strncmp((char const   *)res___0, "PASS", (size_t )4);
    }
#line 132
    if (tmp___5 != 0) {
      {
#line 133
      logprintf((enum log_options )3, "--> %s\n", res___0);
      }
    } else {
      {
#line 135
      logputs((enum log_options )3, "--> PASS Turtle Power!\n\n");
      }
    }
  } else {
    {
#line 138
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 138
      tmp___6 = __builtin_expect((long )opt.debug, 0L);
      }
#line 138
      if (tmp___6) {
        {
#line 138
        debug_logprintf("\n--> %s\n", res___0);
        }
      }
#line 138
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 139
  return (res___0);
}
}
#line 188 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
static char const   *skey_head[2]  = {      "331 s/key ",      "331 opiekey "};
#line 144 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_login(int csock , char const   *acc , char const   *pass ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  int nwritten ;
  size_t tmp ;
  int i ;
  char const   *seed ;
  int l ;
  size_t tmp___0 ;
  int tmp___1 ;
  int skey_sequence ;
  size_t tmp___2 ;

  {
  {
#line 152
  err = ftp_response(csock, & respline);
  }
#line 153
  if ((unsigned int )err != 10U) {
#line 154
    return (err);
  }
#line 155
  if ((int )*respline != 50) {
    {
#line 157
    checking_free((void *)respline);
    }
#line 158
    return ((uerr_t )20);
  }
  {
#line 160
  checking_free((void *)respline);
#line 162
  request = ftp_request("USER", acc);
#line 163
  tmp = strlen((char const   *)request);
#line 163
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 164
  if (nwritten < 0) {
    {
#line 166
    checking_free((void *)request);
    }
#line 167
    return ((uerr_t )52);
  }
  {
#line 169
  checking_free((void *)request);
#line 171
  err = ftp_response(csock, & respline);
  }
#line 172
  if ((unsigned int )err != 10U) {
#line 173
    return (err);
  }
#line 175
  if ((int )*respline == 50) {
    {
#line 177
    checking_free((void *)respline);
    }
#line 178
    return ((uerr_t )10);
  }
#line 181
  if ((int )*respline != 51) {
    {
#line 183
    checking_free((void *)respline);
    }
#line 184
    return ((uerr_t )12);
  }
#line 193
  seed = (char const   *)((void *)0);
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! ((unsigned long )i < sizeof(skey_head) / sizeof(skey_head[0]))) {
#line 195
      goto while_break;
    }
    {
#line 197
    tmp___0 = strlen(skey_head[i]);
#line 197
    l = (int )tmp___0;
#line 198
    tmp___1 = strncasecmp(skey_head[i], (char const   *)respline, (size_t )l);
    }
#line 198
    if (0 == tmp___1) {
#line 200
      seed = (char const   *)(respline + l);
#line 201
      goto while_break;
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (seed) {
#line 206
    skey_sequence = 0;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! ((int const   )_sch_istable[(int const   )*seed & 255] & 4)) {
#line 209
        goto while_break___0;
      }
#line 210
      skey_sequence = (10 * skey_sequence + (int )*seed) - 48;
#line 209
      seed ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    if ((int const   )*seed == 32) {
#line 212
      seed ++;
    } else {
      {
#line 215
      checking_free((void *)respline);
      }
#line 216
      return ((uerr_t )12);
    }
    {
#line 220
    pass = skey_response(skey_sequence, seed, pass);
    }
  }
  {
#line 224
  checking_free((void *)respline);
#line 226
  request = ftp_request("PASS", pass);
#line 227
  tmp___2 = strlen((char const   *)request);
#line 227
  nwritten = fd_write(csock, request, (int )tmp___2, (double )-1);
  }
#line 228
  if (nwritten < 0) {
    {
#line 230
    checking_free((void *)request);
    }
#line 231
    return ((uerr_t )52);
  }
  {
#line 233
  checking_free((void *)request);
#line 235
  err = ftp_response(csock, & respline);
  }
#line 236
  if ((unsigned int )err != 10U) {
#line 237
    return (err);
  }
#line 238
  if ((int )*respline != 50) {
    {
#line 240
    checking_free((void *)respline);
    }
#line 241
    return ((uerr_t )11);
  }
  {
#line 243
  checking_free((void *)respline);
  }
#line 245
  return ((uerr_t )10);
}
}
#line 248 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
static void ip_address_to_port_repr(ip_address const   *addr , int port , char *buf___4 ,
                                    size_t buflen ) 
{ 
  unsigned char *ptr ;

  {
#line 254
  if (! (addr->family == 2)) {
    {
#line 254
    __assert_fail("addr->family == AF_INET", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  254U, "ip_address_to_port_repr");
    }
  }
#line 256
  if (! (buflen >= 24UL)) {
    {
#line 256
    __assert_fail("buflen >= 6 * 4", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  256U, "ip_address_to_port_repr");
    }
  }
  {
#line 258
  ptr = (unsigned char *)((void *)(& addr->data));
#line 259
  snprintf((char */* __restrict  */)buf___4, buflen, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
           (int )*(ptr + 0), (int )*(ptr + 1), (int )*(ptr + 2), (int )*(ptr + 3),
           (port & 65280) >> 8, port & 255);
#line 261
  *(buf___4 + (buflen - 1UL)) = (char )'\000';
  }
#line 262
  return;
}
}
#line 267 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_port(int csock , int *local_sock ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  ip_address addr ;
  int nwritten ;
  int port ;
  char bytes[25] ;
  _Bool tmp ;
  size_t tmp___1 ;

  {
  {
#line 279
  tmp = socket_ip_address(csock, & addr, 0);
  }
#line 279
  if (! tmp) {
#line 280
    return ((uerr_t )14);
  }
#line 282
  if (! (addr.family == 2)) {
    {
#line 282
    __assert_fail("addr.family == AF_INET", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  282U, "ftp_port");
    }
  }
  {
#line 285
  port = 0;
#line 288
  *local_sock = bind_local((ip_address const   *)(& addr), & port);
  }
#line 289
  if (*local_sock < 0) {
#line 290
    return ((uerr_t )14);
  }
  {
#line 293
  ip_address_to_port_repr((ip_address const   *)(& addr), port, bytes, sizeof(bytes));
#line 296
  request = ftp_request("PORT", (char const   *)(bytes));
#line 297
  tmp___1 = strlen((char const   *)request);
#line 297
  nwritten = fd_write(csock, request, (int )tmp___1, (double )-1);
  }
#line 298
  if (nwritten < 0) {
    {
#line 300
    checking_free((void *)request);
#line 301
    fd_close(*local_sock);
    }
#line 302
    return ((uerr_t )52);
  }
  {
#line 304
  checking_free((void *)request);
#line 307
  err = ftp_response(csock, & respline);
  }
#line 308
  if ((unsigned int )err != 10U) {
    {
#line 310
    fd_close(*local_sock);
    }
#line 311
    return (err);
  }
#line 313
  if ((int )*respline != 50) {
    {
#line 315
    checking_free((void *)respline);
#line 316
    fd_close(*local_sock);
    }
#line 317
    return ((uerr_t )13);
  }
  {
#line 319
  checking_free((void *)respline);
  }
#line 320
  return ((uerr_t )10);
}
}
#line 324 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
static void ip_address_to_lprt_repr(ip_address const   *addr , int port , char *buf___4 ,
                                    size_t buflen ) 
{ 
  unsigned char *ptr ;

  {
#line 328
  ptr = (unsigned char *)((void *)(& addr->data));
#line 331
  if (! (buflen >= 84UL)) {
    {
#line 331
    __assert_fail("buflen >= 21 * 4", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  331U, "ip_address_to_lprt_repr");
    }
  }
  {
#line 336
  if (addr->family == 2) {
#line 336
    goto case_2;
  }
#line 341
  if (addr->family == 10) {
#line 341
    goto case_10;
  }
#line 349
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 337
  snprintf((char */* __restrict  */)buf___4, buflen, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d,%d,%d,%d",
           4, 4, (int )*(ptr + 0), (int )*(ptr + 1), (int )*(ptr + 2), (int )*(ptr + 3),
           2, (port & 65280) >> 8, port & 255);
  }
#line 340
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 342
  snprintf((char */* __restrict  */)buf___4, buflen, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
           6, 16, (int )*(ptr + 0), (int )*(ptr + 1), (int )*(ptr + 2), (int )*(ptr + 3),
           (int )*(ptr + 4), (int )*(ptr + 5), (int )*(ptr + 6), (int )*(ptr + 7),
           (int )*(ptr + 8), (int )*(ptr + 9), (int )*(ptr + 10), (int )*(ptr + 11),
           (int )*(ptr + 12), (int )*(ptr + 13), (int )*(ptr + 14), (int )*(ptr + 15),
           2, (port & 65280) >> 8, port & 255);
  }
#line 348
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 357 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_lprt(int csock , int *local_sock ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  ip_address addr ;
  int nwritten ;
  int port ;
  char bytes[85] ;
  _Bool tmp ;
  size_t tmp___1 ;

  {
  {
#line 369
  tmp = socket_ip_address(csock, & addr, 0);
  }
#line 369
  if (! tmp) {
#line 370
    return ((uerr_t )14);
  }
#line 372
  if (! (addr.family == 2)) {
#line 372
    if (! (addr.family == 10)) {
      {
#line 372
      __assert_fail("addr.family == AF_INET || addr.family == AF_INET6", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                    372U, "ftp_lprt");
      }
    }
  }
  {
#line 375
  port = 0;
#line 378
  *local_sock = bind_local((ip_address const   *)(& addr), & port);
  }
#line 379
  if (*local_sock < 0) {
#line 380
    return ((uerr_t )14);
  }
  {
#line 383
  ip_address_to_lprt_repr((ip_address const   *)(& addr), port, bytes, sizeof(bytes));
#line 386
  request = ftp_request("LPRT", (char const   *)(bytes));
#line 387
  tmp___1 = strlen((char const   *)request);
#line 387
  nwritten = fd_write(csock, request, (int )tmp___1, (double )-1);
  }
#line 388
  if (nwritten < 0) {
    {
#line 390
    checking_free((void *)request);
#line 391
    fd_close(*local_sock);
    }
#line 392
    return ((uerr_t )52);
  }
  {
#line 394
  checking_free((void *)request);
#line 396
  err = ftp_response(csock, & respline);
  }
#line 397
  if ((unsigned int )err != 10U) {
    {
#line 399
    fd_close(*local_sock);
    }
#line 400
    return (err);
  }
#line 402
  if ((int )*respline != 50) {
    {
#line 404
    checking_free((void *)respline);
#line 405
    fd_close(*local_sock);
    }
#line 406
    return ((uerr_t )13);
  }
  {
#line 408
  checking_free((void *)respline);
  }
#line 409
  return ((uerr_t )10);
}
}
#line 412 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
static void ip_address_to_eprt_repr(ip_address const   *addr , int port , char *buf___4 ,
                                    size_t buflen ) 
{ 
  int afnum ;
  char const   *tmp___0 ;

  {
#line 421
  if (! (buflen >= 56UL)) {
    {
#line 421
    __assert_fail("buflen >= 4 + INET6_ADDRSTRLEN + 1 + 5", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  421U, "ip_address_to_eprt_repr");
    }
  }
#line 424
  if (addr->family == 2) {
#line 424
    afnum = 1;
  } else {
#line 424
    afnum = 2;
  }
  {
#line 425
  tmp___0 = print_address(addr);
#line 425
  snprintf((char */* __restrict  */)buf___4, buflen, (char const   */* __restrict  */)"|%d|%s|%d|",
           afnum, tmp___0, port);
#line 426
  *(buf___4 + (buflen - 1UL)) = (char )'\000';
  }
#line 427
  return;
}
}
#line 432 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_eprt(int csock , int *local_sock ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  ip_address addr ;
  int nwritten ;
  int port ;
  char bytes[57] ;
  _Bool tmp ;
  size_t tmp___0 ;

  {
  {
#line 446
  tmp = socket_ip_address(csock, & addr, 0);
  }
#line 446
  if (! tmp) {
#line 447
    return ((uerr_t )14);
  }
  {
#line 450
  port = 0;
#line 453
  *local_sock = bind_local((ip_address const   *)(& addr), & port);
  }
#line 454
  if (*local_sock < 0) {
#line 455
    return ((uerr_t )14);
  }
  {
#line 458
  ip_address_to_eprt_repr((ip_address const   *)(& addr), port, bytes, sizeof(bytes));
#line 461
  request = ftp_request("EPRT", (char const   *)(bytes));
#line 462
  tmp___0 = strlen((char const   *)request);
#line 462
  nwritten = fd_write(csock, request, (int )tmp___0, (double )-1);
  }
#line 463
  if (nwritten < 0) {
    {
#line 465
    checking_free((void *)request);
#line 466
    fd_close(*local_sock);
    }
#line 467
    return ((uerr_t )52);
  }
  {
#line 469
  checking_free((void *)request);
#line 471
  err = ftp_response(csock, & respline);
  }
#line 472
  if ((unsigned int )err != 10U) {
    {
#line 474
    fd_close(*local_sock);
    }
#line 475
    return (err);
  }
#line 477
  if ((int )*respline != 50) {
    {
#line 479
    checking_free((void *)respline);
#line 480
    fd_close(*local_sock);
    }
#line 481
    return ((uerr_t )13);
  }
  {
#line 483
  checking_free((void *)respline);
  }
#line 484
  return ((uerr_t )10);
}
}
#line 491 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_pasv(int csock , ip_address *addr , int *port ) 
{ 
  char *request ;
  char *respline ;
  char *s ;
  int nwritten ;
  int i ;
  uerr_t err ;
  unsigned char tmp[6] ;
  size_t tmp___2 ;

  {
#line 499
  if (! ((unsigned long )addr != (unsigned long )((void *)0))) {
    {
#line 499
    __assert_fail("addr != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  499U, "ftp_pasv");
    }
  }
#line 500
  if (! ((unsigned long )port != (unsigned long )((void *)0))) {
    {
#line 500
    __assert_fail("port != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  500U, "ftp_pasv");
    }
  }
  {
#line 502
  memset((void *)addr, '\000', sizeof(*addr));
#line 505
  request = ftp_request("PASV", (char const   *)((void *)0));
#line 507
  tmp___2 = strlen((char const   *)request);
#line 507
  nwritten = fd_write(csock, request, (int )tmp___2, (double )-1);
  }
#line 508
  if (nwritten < 0) {
    {
#line 510
    checking_free((void *)request);
    }
#line 511
    return ((uerr_t )52);
  }
  {
#line 513
  checking_free((void *)request);
#line 515
  err = ftp_response(csock, & respline);
  }
#line 516
  if ((unsigned int )err != 10U) {
#line 517
    return (err);
  }
#line 518
  if ((int )*respline != 50) {
    {
#line 520
    checking_free((void *)respline);
    }
#line 521
    return ((uerr_t )36);
  }
#line 524
  s = respline;
#line 525
  s += 4;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (*s) {
#line 525
      if (! (! ((int const   )_sch_istable[(int )*s & 255] & 4))) {
#line 525
        goto while_break;
      }
    } else {
#line 525
      goto while_break;
    }
#line 525
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  if (! *s) {
#line 528
    return ((uerr_t )35);
  }
#line 529
  i = 0;
  {
#line 529
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 529
    if (! (i < 6)) {
#line 529
      goto while_break___0;
    }
#line 531
    tmp[i] = (unsigned char)0;
    {
#line 532
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 532
      if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 532
        goto while_break___1;
      }
#line 533
      tmp[i] = (unsigned char )(((int )*s - 48) + 10 * (int )tmp[i]);
#line 532
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 534
    if ((int )*s == 44) {
#line 535
      s ++;
    } else
#line 536
    if (i < 5) {
      {
#line 539
      checking_free((void *)respline);
      }
#line 540
      return ((uerr_t )35);
    }
#line 529
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 543
  checking_free((void *)respline);
#line 545
  addr->family = 2;
#line 546
  memcpy((void */* __restrict  */)((void *)(& addr->data)), (void const   */* __restrict  */)(tmp),
         (size_t )4);
#line 547
  *port = (((int )tmp[4] << 8) & 65280) + (int )tmp[5];
  }
#line 549
  return ((uerr_t )10);
}
}
#line 556 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_lpsv(int csock , ip_address *addr , int *port ) 
{ 
  char *request ;
  char *respline ;
  char *s ;
  int nwritten ;
  int i ;
  int af ;
  int addrlen ;
  int portlen ;
  uerr_t err ;
  unsigned char tmp[16] ;
  unsigned char tmpprt[2] ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  char const   *tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;

  {
#line 565
  if (! ((unsigned long )addr != (unsigned long )((void *)0))) {
    {
#line 565
    __assert_fail("addr != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  565U, "ftp_lpsv");
    }
  }
#line 566
  if (! ((unsigned long )port != (unsigned long )((void *)0))) {
    {
#line 566
    __assert_fail("port != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  566U, "ftp_lpsv");
    }
  }
  {
#line 568
  memset((void *)addr, '\000', sizeof(*addr));
#line 571
  request = ftp_request("LPSV", (char const   *)((void *)0));
#line 574
  tmp___2 = strlen((char const   *)request);
#line 574
  nwritten = fd_write(csock, request, (int )tmp___2, (double )-1);
  }
#line 575
  if (nwritten < 0) {
    {
#line 577
    checking_free((void *)request);
    }
#line 578
    return ((uerr_t )52);
  }
  {
#line 580
  checking_free((void *)request);
#line 583
  err = ftp_response(csock, & respline);
  }
#line 584
  if ((unsigned int )err != 10U) {
#line 585
    return (err);
  }
#line 586
  if ((int )*respline != 50) {
    {
#line 588
    checking_free((void *)respline);
    }
#line 589
    return ((uerr_t )36);
  }
#line 593
  s = respline;
#line 594
  s += 4;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (*s) {
#line 594
      if (! (! ((int const   )_sch_istable[(int )*s & 255] & 4))) {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
#line 594
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  if (! *s) {
#line 597
    return ((uerr_t )35);
  }
#line 600
  af = 0;
  {
#line 601
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 601
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 601
      goto while_break___0;
    }
#line 602
    af = ((int )*s - 48) + 10 * af;
#line 601
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 604
  if (af != 4) {
#line 604
    if (af != 6) {
      {
#line 606
      checking_free((void *)respline);
      }
#line 607
      return ((uerr_t )35);
    }
  }
#line 610
  if (! *s) {
    {
#line 612
    checking_free((void *)respline);
    }
#line 613
    return ((uerr_t )35);
  } else {
#line 610
    tmp___3 = s;
#line 610
    s ++;
#line 610
    if ((int )*tmp___3 != 44) {
      {
#line 612
      checking_free((void *)respline);
      }
#line 613
      return ((uerr_t )35);
    }
  }
#line 617
  addrlen = 0;
  {
#line 618
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 618
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 618
      goto while_break___1;
    }
#line 619
    addrlen = ((int )*s - 48) + 10 * addrlen;
#line 618
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 621
  if (! *s) {
    {
#line 623
    checking_free((void *)respline);
    }
#line 624
    return ((uerr_t )35);
  } else {
#line 621
    tmp___4 = s;
#line 621
    s ++;
#line 621
    if ((int )*tmp___4 != 44) {
      {
#line 623
      checking_free((void *)respline);
      }
#line 624
      return ((uerr_t )35);
    }
  }
#line 627
  if (addrlen > 16) {
    {
#line 629
    checking_free((void *)respline);
    }
#line 630
    return ((uerr_t )35);
  }
#line 633
  if (af == 4) {
#line 633
    if (addrlen != 4) {
      {
#line 636
      checking_free((void *)respline);
      }
#line 637
      return ((uerr_t )35);
    } else {
#line 633
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 633
  if (af == 6) {
#line 633
    if (addrlen != 16) {
      {
#line 636
      checking_free((void *)respline);
      }
#line 637
      return ((uerr_t )35);
    }
  }
#line 641
  i = 0;
  {
#line 641
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 641
    if (! (i < addrlen)) {
#line 641
      goto while_break___2;
    }
#line 643
    tmp[i] = (unsigned char)0;
    {
#line 644
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 644
        goto while_break___3;
      }
#line 645
      tmp[i] = (unsigned char )(((int )*s - 48) + 10 * (int )tmp[i]);
#line 644
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 646
    if ((int )*s == 44) {
#line 647
      s ++;
    } else {
      {
#line 650
      checking_free((void *)respline);
      }
#line 651
      return ((uerr_t )35);
    }
#line 641
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 656
  portlen = 0;
  {
#line 657
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 657
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 657
      goto while_break___4;
    }
#line 658
    portlen = ((int )*s - 48) + 10 * portlen;
#line 657
    s ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 660
  if (! *s) {
    {
#line 662
    checking_free((void *)respline);
    }
#line 663
    return ((uerr_t )35);
  } else {
#line 660
    tmp___5 = s;
#line 660
    s ++;
#line 660
    if ((int )*tmp___5 != 44) {
      {
#line 662
      checking_free((void *)respline);
      }
#line 663
      return ((uerr_t )35);
    }
  }
#line 666
  if (portlen > 2) {
    {
#line 668
    checking_free((void *)respline);
    }
#line 669
    return ((uerr_t )35);
  }
#line 673
  tmpprt[0] = (unsigned char)0;
  {
#line 674
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 674
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 674
      goto while_break___5;
    }
#line 675
    tmpprt[0] = (unsigned char )(((int )*s - 48) + 10 * (int )tmpprt[0]);
#line 674
    s ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 677
  if (! *s) {
    {
#line 679
    checking_free((void *)respline);
    }
#line 680
    return ((uerr_t )35);
  } else {
#line 677
    tmp___6 = s;
#line 677
    s ++;
#line 677
    if ((int )*tmp___6 != 44) {
      {
#line 679
      checking_free((void *)respline);
      }
#line 680
      return ((uerr_t )35);
    }
  }
#line 683
  tmpprt[1] = (unsigned char)0;
  {
#line 684
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 684
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 684
      goto while_break___6;
    }
#line 685
    tmpprt[1] = (unsigned char )(((int )*s - 48) + 10 * (int )tmpprt[1]);
#line 684
    s ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 687
  if (! ((unsigned long )s != (unsigned long )((void *)0))) {
    {
#line 687
    __assert_fail("s != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  687U, "ftp_lpsv");
    }
  }
#line 689
  if (af == 4) {
    {
#line 691
    addr->family = 2;
#line 692
    memcpy((void */* __restrict  */)((void *)(& addr->data)), (void const   */* __restrict  */)(tmp),
           (size_t )4);
#line 693
    *port = (((int )tmpprt[0] << 8) & 65280) + (int )tmpprt[1];
    }
    {
#line 694
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 694
      tmp___9 = __builtin_expect((long )opt.debug, 0L);
      }
#line 694
      if (tmp___9) {
        {
#line 694
        tmp___8 = print_address((ip_address const   *)addr);
#line 694
        debug_logprintf("lpsv addr is: %s\n", tmp___8);
        }
      }
#line 694
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 695
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 695
      tmp___10 = __builtin_expect((long )opt.debug, 0L);
      }
#line 695
      if (tmp___10) {
        {
#line 695
        debug_logprintf("tmpprt[0] is: %d\n", (int )tmpprt[0]);
        }
      }
#line 695
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 696
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 696
      tmp___11 = __builtin_expect((long )opt.debug, 0L);
      }
#line 696
      if (tmp___11) {
        {
#line 696
        debug_logprintf("tmpprt[1] is: %d\n", (int )tmpprt[1]);
        }
      }
#line 696
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 697
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 697
      tmp___12 = __builtin_expect((long )opt.debug, 0L);
      }
#line 697
      if (tmp___12) {
        {
#line 697
        debug_logprintf("*port is: %d\n", *port);
        }
      }
#line 697
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else {
#line 701
    if (! (af == 6)) {
      {
#line 701
      __assert_fail("af == 6", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                    701U, "ftp_lpsv");
      }
    }
    {
#line 702
    addr->family = 10;
#line 703
    memcpy((void */* __restrict  */)((void *)(& addr->data)), (void const   */* __restrict  */)(tmp),
           (size_t )16);
#line 704
    *port = (((int )tmpprt[0] << 8) & 65280) + (int )tmpprt[1];
    }
    {
#line 705
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 705
      tmp___15 = __builtin_expect((long )opt.debug, 0L);
      }
#line 705
      if (tmp___15) {
        {
#line 705
        tmp___14 = print_address((ip_address const   *)addr);
#line 705
        debug_logprintf("lpsv addr is: %s\n", tmp___14);
        }
      }
#line 705
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 706
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 706
      tmp___16 = __builtin_expect((long )opt.debug, 0L);
      }
#line 706
      if (tmp___16) {
        {
#line 706
        debug_logprintf("tmpprt[0] is: %d\n", (int )tmpprt[0]);
        }
      }
#line 706
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 707
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 707
      tmp___17 = __builtin_expect((long )opt.debug, 0L);
      }
#line 707
      if (tmp___17) {
        {
#line 707
        debug_logprintf("tmpprt[1] is: %d\n", (int )tmpprt[1]);
        }
      }
#line 707
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 708
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 708
      tmp___18 = __builtin_expect((long )opt.debug, 0L);
      }
#line 708
      if (tmp___18) {
        {
#line 708
        debug_logprintf("*port is: %d\n", *port);
        }
      }
#line 708
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  {
#line 711
  checking_free((void *)respline);
  }
#line 712
  return ((uerr_t )10);
}
}
#line 718 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_epsv(int csock , ip_address *ip___0 , int *port ) 
{ 
  char *request ;
  char *respline ;
  char *start ;
  char delim ;
  char *s ;
  int nwritten ;
  int i ;
  uerr_t err ;
  int tport ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 726
  if (! ((unsigned long )ip___0 != (unsigned long )((void *)0))) {
    {
#line 726
    __assert_fail("ip != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  726U, "ftp_epsv");
    }
  }
#line 727
  if (! ((unsigned long )port != (unsigned long )((void *)0))) {
    {
#line 727
    __assert_fail("port != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  727U, "ftp_epsv");
    }
  }
#line 734
  if (ip___0->family == 2) {
#line 734
    tmp___1 = "1";
  } else {
#line 734
    tmp___1 = "2";
  }
  {
#line 734
  request = ftp_request("EPSV", tmp___1);
#line 737
  tmp___2 = strlen((char const   *)request);
#line 737
  nwritten = fd_write(csock, request, (int )tmp___2, (double )-1);
  }
#line 738
  if (nwritten < 0) {
    {
#line 740
    checking_free((void *)request);
    }
#line 741
    return ((uerr_t )52);
  }
  {
#line 743
  checking_free((void *)request);
#line 746
  err = ftp_response(csock, & respline);
  }
#line 747
  if ((unsigned int )err != 10U) {
#line 748
    return (err);
  }
#line 749
  if ((int )*respline != 50) {
    {
#line 751
    checking_free((void *)respline);
    }
#line 752
    return ((uerr_t )36);
  }
#line 755
  if (! ((unsigned long )respline != (unsigned long )((void *)0))) {
    {
#line 755
    __assert_fail("respline != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c",
                  755U, "ftp_epsv");
    }
  }
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 757
    tmp___4 = __builtin_expect((long )opt.debug, 0L);
    }
#line 757
    if (tmp___4) {
      {
#line 757
      debug_logprintf("respline is %s\n", respline);
      }
    }
#line 757
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  s = respline;
#line 763
  start = strchr((char const   *)respline, '(');
  }
#line 764
  if ((unsigned long )start == (unsigned long )((void *)0)) {
    {
#line 766
    checking_free((void *)respline);
    }
#line 767
    return ((uerr_t )35);
  }
#line 771
  s = start + 1;
#line 772
  tmp___5 = s;
#line 772
  s ++;
#line 772
  delim = *tmp___5;
#line 773
  if ((int )delim < 33) {
    {
#line 775
    checking_free((void *)respline);
    }
#line 776
    return ((uerr_t )35);
  } else
#line 773
  if ((int )delim > 126) {
    {
#line 775
    checking_free((void *)respline);
    }
#line 776
    return ((uerr_t )35);
  }
#line 779
  i = 0;
  {
#line 779
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 779
    if (! (i < 2)) {
#line 779
      goto while_break___0;
    }
#line 781
    tmp___6 = s;
#line 781
    s ++;
#line 781
    if ((int )*tmp___6 != (int )delim) {
      {
#line 783
      checking_free((void *)respline);
      }
#line 784
      return ((uerr_t )35);
    }
#line 779
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 789
  tport = 0;
#line 790
  i = 1;
  {
#line 790
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 790
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 790
      goto while_break___1;
    }
#line 792
    if (i > 5) {
      {
#line 794
      checking_free((void *)respline);
      }
#line 795
      return ((uerr_t )35);
    }
#line 797
    tport = ((int )*s - 48) + 10 * tport;
#line 790
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 801
  tmp___7 = s;
#line 801
  s ++;
#line 801
  if ((int )*tmp___7 != (int )delim) {
    {
#line 803
    checking_free((void *)respline);
    }
#line 804
    return ((uerr_t )35);
  }
#line 807
  tmp___8 = s;
#line 807
  s ++;
#line 807
  if ((int )*tmp___8 != 41) {
    {
#line 809
    checking_free((void *)respline);
    }
#line 810
    return ((uerr_t )35);
  }
  {
#line 813
  *port = tport;
#line 815
  checking_free((void *)respline);
  }
#line 816
  return ((uerr_t )10);
}
}
#line 821 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_type(int csock , int type ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  char stype[2] ;
  size_t tmp ;

  {
  {
#line 830
  stype[0] = (char )type;
#line 831
  stype[1] = (char)0;
#line 833
  request = ftp_request("TYPE", (char const   *)(stype));
#line 834
  tmp = strlen((char const   *)request);
#line 834
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 835
  if (nwritten < 0) {
    {
#line 837
    checking_free((void *)request);
    }
#line 838
    return ((uerr_t )52);
  }
  {
#line 840
  checking_free((void *)request);
#line 842
  err = ftp_response(csock, & respline);
  }
#line 843
  if ((unsigned int )err != 10U) {
#line 844
    return (err);
  }
#line 845
  if ((int )*respline != 50) {
    {
#line 847
    checking_free((void *)respline);
    }
#line 848
    return ((uerr_t )17);
  }
  {
#line 850
  checking_free((void *)respline);
  }
#line 852
  return ((uerr_t )10);
}
}
#line 857 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_cwd(int csock , char const   *dir ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 865
  request = ftp_request("CWD", dir);
#line 866
  tmp = strlen((char const   *)request);
#line 866
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 867
  if (nwritten < 0) {
    {
#line 869
    checking_free((void *)request);
    }
#line 870
    return ((uerr_t )52);
  }
  {
#line 872
  checking_free((void *)request);
#line 874
  err = ftp_response(csock, & respline);
  }
#line 875
  if ((unsigned int )err != 10U) {
#line 876
    return (err);
  }
#line 877
  if ((int )*respline == 53) {
    {
#line 879
    checking_free((void *)respline);
    }
#line 880
    return ((uerr_t )15);
  }
#line 882
  if ((int )*respline != 50) {
    {
#line 884
    checking_free((void *)respline);
    }
#line 885
    return ((uerr_t )18);
  }
  {
#line 887
  checking_free((void *)respline);
  }
#line 889
  return ((uerr_t )10);
}
}
#line 893 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_rest(int csock , wgint offset ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 900
  tmp = number_to_static_string(offset);
#line 900
  request = ftp_request("REST", (char const   *)tmp);
#line 901
  tmp___0 = strlen((char const   *)request);
#line 901
  nwritten = fd_write(csock, request, (int )tmp___0, (double )-1);
  }
#line 902
  if (nwritten < 0) {
    {
#line 904
    checking_free((void *)request);
    }
#line 905
    return ((uerr_t )52);
  }
  {
#line 907
  checking_free((void *)request);
#line 909
  err = ftp_response(csock, & respline);
  }
#line 910
  if ((unsigned int )err != 10U) {
#line 911
    return (err);
  }
#line 912
  if ((int )*respline != 51) {
    {
#line 914
    checking_free((void *)respline);
    }
#line 915
    return ((uerr_t )22);
  }
  {
#line 917
  checking_free((void *)respline);
  }
#line 919
  return ((uerr_t )10);
}
}
#line 923 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_retr(int csock , char const   *file ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 931
  request = ftp_request("RETR", file);
#line 932
  tmp = strlen((char const   *)request);
#line 932
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 933
  if (nwritten < 0) {
    {
#line 935
    checking_free((void *)request);
    }
#line 936
    return ((uerr_t )52);
  }
  {
#line 938
  checking_free((void *)request);
#line 940
  err = ftp_response(csock, & respline);
  }
#line 941
  if ((unsigned int )err != 10U) {
#line 942
    return (err);
  }
#line 943
  if ((int )*respline == 53) {
    {
#line 945
    checking_free((void *)respline);
    }
#line 946
    return ((uerr_t )15);
  }
#line 948
  if ((int )*respline != 49) {
    {
#line 950
    checking_free((void *)respline);
    }
#line 951
    return ((uerr_t )18);
  }
  {
#line 953
  checking_free((void *)respline);
  }
#line 955
  return ((uerr_t )10);
}
}
#line 960 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_list(int csock , char const   *file ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  _Bool ok ;
  int i ;
  char const   *list_commands[2] ;
  size_t tmp ;

  {
#line 966
  ok = (_Bool)0;
#line 967
  i = 0;
#line 969
  list_commands[0] = "LIST -a";
#line 969
  list_commands[1] = "LIST";
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 974
    request = ftp_request(list_commands[i], file);
#line 975
    tmp = strlen((char const   *)request);
#line 975
    nwritten = fd_write(csock, request, (int )tmp, (double )-1);
    }
#line 976
    if (nwritten < 0) {
      {
#line 978
      checking_free((void *)request);
      }
#line 979
      return ((uerr_t )52);
    }
    {
#line 981
    checking_free((void *)request);
#line 983
    err = ftp_response(csock, & respline);
    }
#line 984
    if ((unsigned int )err == 10U) {
#line 986
      if ((int )*respline == 53) {
#line 988
        err = (uerr_t )15;
      } else
#line 990
      if ((int )*respline == 49) {
#line 992
        err = (uerr_t )10;
#line 993
        ok = (_Bool)1;
      } else {
#line 997
        err = (uerr_t )18;
      }
      {
#line 999
      checking_free((void *)respline);
      }
    }
#line 1001
    i ++;
#line 972
    if ((unsigned long )i < sizeof(list_commands) / sizeof(list_commands[0])) {
#line 972
      if (! (! ok)) {
#line 972
        goto while_break;
      }
    } else {
#line 972
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  return (err);
}
}
#line 1008 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_syst(int csock , enum stype *server_type ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1016
  request = ftp_request("SYST", (char const   *)((void *)0));
#line 1017
  tmp = strlen((char const   *)request);
#line 1017
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 1018
  if (nwritten < 0) {
    {
#line 1020
    checking_free((void *)request);
    }
#line 1021
    return ((uerr_t )52);
  }
  {
#line 1023
  checking_free((void *)request);
#line 1026
  err = ftp_response(csock, & respline);
  }
#line 1027
  if ((unsigned int )err != 10U) {
#line 1028
    return (err);
  }
#line 1029
  if ((int )*respline == 53) {
    {
#line 1031
    checking_free((void *)respline);
    }
#line 1032
    return ((uerr_t )20);
  }
  {
#line 1036
  strtok((char */* __restrict  */)respline, (char const   */* __restrict  */)" ");
#line 1040
  request = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
  }
#line 1042
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 1043
    *server_type = (enum stype )5;
  } else {
    {
#line 1044
    tmp___5 = strcasecmp((char const   *)request, "VMS");
    }
#line 1044
    if (tmp___5) {
      {
#line 1046
      tmp___4 = strcasecmp((char const   *)request, "UNIX");
      }
#line 1046
      if (tmp___4) {
        {
#line 1048
        tmp___2 = strcasecmp((char const   *)request, "WINDOWS_NT");
        }
#line 1048
        if (tmp___2) {
          {
#line 1048
          tmp___3 = strcasecmp((char const   *)request, "WINDOWS2000");
          }
#line 1048
          if (tmp___3) {
            {
#line 1051
            tmp___1 = strcasecmp((char const   *)request, "MACOS");
            }
#line 1051
            if (tmp___1) {
              {
#line 1053
              tmp___0 = strcasecmp((char const   *)request, "OS/400");
              }
#line 1053
              if (tmp___0) {
#line 1056
                *server_type = (enum stype )5;
              } else {
#line 1054
                *server_type = (enum stype )4;
              }
            } else {
#line 1052
              *server_type = (enum stype )3;
            }
          } else {
#line 1050
            *server_type = (enum stype )2;
          }
        } else {
#line 1050
          *server_type = (enum stype )2;
        }
      } else {
#line 1047
        *server_type = (enum stype )0;
      }
    } else {
#line 1045
      *server_type = (enum stype )1;
    }
  }
  {
#line 1058
  checking_free((void *)respline);
  }
#line 1060
  return ((uerr_t )10);
}
}
#line 1064 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_pwd(int csock , char **pwd ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 1072
  request = ftp_request("PWD", (char const   *)((void *)0));
#line 1073
  tmp = strlen((char const   *)request);
#line 1073
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 1074
  if (nwritten < 0) {
    {
#line 1076
    checking_free((void *)request);
    }
#line 1077
    return ((uerr_t )52);
  }
  {
#line 1079
  checking_free((void *)request);
#line 1081
  err = ftp_response(csock, & respline);
  }
#line 1082
  if ((unsigned int )err != 10U) {
#line 1083
    return (err);
  }
#line 1084
  if ((int )*respline == 53) {
    err: 
    {
#line 1087
    checking_free((void *)respline);
    }
#line 1088
    return ((uerr_t )20);
  }
  {
#line 1093
  strtok((char */* __restrict  */)respline, (char const   */* __restrict  */)"\"");
#line 1094
  request = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\"");
  }
#line 1095
  if (! request) {
#line 1098
    goto err;
  }
#line 1101
  if (! (! *pwd)) {
    {
#line 1101
    checking_free((void *)*pwd);
    }
  }
  {
#line 1103
  *pwd = checking_strdup((char const   *)request);
#line 1105
  checking_free((void *)respline);
  }
#line 1107
  return ((uerr_t )10);
}
}
#line 1112 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
uerr_t ftp_size(int csock , char const   *file , wgint *size ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1120
  request = ftp_request("SIZE", file);
#line 1121
  tmp = strlen((char const   *)request);
#line 1121
  nwritten = fd_write(csock, request, (int )tmp, (double )-1);
  }
#line 1122
  if (nwritten < 0) {
    {
#line 1124
    checking_free((void *)request);
#line 1125
    *size = (wgint )0;
    }
#line 1126
    return ((uerr_t )52);
  }
  {
#line 1128
  checking_free((void *)request);
#line 1130
  err = ftp_response(csock, & respline);
  }
#line 1131
  if ((unsigned int )err != 10U) {
#line 1133
    *size = (wgint )0;
#line 1134
    return (err);
  }
#line 1136
  if ((int )*respline == 53) {
    {
#line 1142
    checking_free((void *)respline);
#line 1143
    *size = (wgint )0;
    }
#line 1144
    return ((uerr_t )10);
  }
  {
#line 1147
  tmp___0 = __errno_location();
#line 1147
  *tmp___0 = 0;
#line 1148
  *size = strtol((char const   */* __restrict  */)(respline + 4), (char **/* __restrict  */)((void *)0),
                 10);
#line 1149
  tmp___1 = __errno_location();
  }
#line 1149
  if (*tmp___1) {
    {
#line 1157
    checking_free((void *)respline);
#line 1158
    *size = (wgint )0;
    }
#line 1159
    return ((uerr_t )10);
  }
  {
#line 1162
  checking_free((void *)respline);
  }
#line 1164
  return ((uerr_t )10);
}
}
#line 1169 "/home/khheo/project/benchmark/wget-1.11.4/src/ftp-basic.c"
char ftp_process_type(char const   *params ) 
{ 
  int tmp ;

  {
#line 1172
  if (params) {
    {
#line 1172
    tmp = strncasecmp(params, "type=", (size_t )5);
    }
#line 1172
    if (0 == tmp) {
#line 1172
      if ((int const   )*(params + 5) != 0) {
#line 1175
        return ((char )_sch_toupper[(int const   )*(params + 5) & 255]);
      } else {
#line 1177
        return ((char )'I');
      }
    } else {
#line 1177
      return ((char )'I');
    }
  } else {
#line 1177
    return ((char )'I');
  }
}
}
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 84 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static time_t cookies_now  ;
#line 86 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
struct cookie_jar *cookie_jar_new(void) 
{ 
  struct cookie_jar *jar ;
  void *tmp ;

  {
  {
#line 89
  tmp = checking_malloc(sizeof(struct cookie_jar ));
#line 89
  jar = (struct cookie_jar *)tmp;
#line 90
  jar->chains = make_nocase_string_hash_table(0);
#line 91
  jar->cookie_count = 0;
  }
#line 92
  return (jar);
}
}
#line 126 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static struct cookie *cookie_new(void) 
{ 
  struct cookie *cookie ;
  void *tmp ;

  {
  {
#line 129
  tmp = checking_malloc0(sizeof(struct cookie ));
#line 129
  cookie = (struct cookie *)tmp;
#line 135
  cookie->port = -1;
  }
#line 136
  return (cookie);
}
}
#line 142 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static _Bool cookie_expired_p(struct cookie  const  *c ) 
{ 
  int tmp ;

  {
#line 145
  if (c->expiry_time != 0L) {
#line 145
    if (c->expiry_time < (time_t const   )cookies_now) {
#line 145
      tmp = 1;
    } else {
#line 145
      tmp = 0;
    }
  } else {
#line 145
    tmp = 0;
  }
#line 145
  return ((_Bool )tmp);
}
}
#line 150 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static void delete_cookie(struct cookie *cookie ) 
{ 


  {
#line 153
  if (! (! cookie->domain)) {
    {
#line 153
    checking_free((void *)cookie->domain);
    }
  }
#line 154
  if (! (! cookie->path)) {
    {
#line 154
    checking_free((void *)cookie->path);
    }
  }
#line 155
  if (! (! cookie->attr)) {
    {
#line 155
    checking_free((void *)cookie->attr);
    }
  }
#line 156
  if (! (! cookie->value)) {
    {
#line 156
    checking_free((void *)cookie->value);
    }
  }
  {
#line 157
  checking_free((void *)cookie);
  }
#line 158
  return;
}
}
#line 174 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static struct cookie *find_matching_cookie(struct cookie_jar *jar , struct cookie *cookie ,
                                           struct cookie **prevptr ) 
{ 
  struct cookie *chain ;
  struct cookie *prev ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 180
  tmp = hash_table_get((struct hash_table  const  *)jar->chains, (void const   *)cookie->domain);
#line 180
  chain = (struct cookie *)tmp;
  }
#line 181
  if (! chain) {
#line 182
    goto nomatch;
  }
#line 184
  prev = (struct cookie *)((void *)0);
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! chain) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp___0 = strcmp((char const   *)cookie->path, (char const   *)chain->path);
    }
#line 186
    if (0 == tmp___0) {
      {
#line 186
      tmp___1 = strcmp((char const   *)cookie->attr, (char const   *)chain->attr);
      }
#line 186
      if (0 == tmp___1) {
#line 186
        if (cookie->port == chain->port) {
#line 190
          *prevptr = prev;
#line 191
          return (chain);
        }
      }
    }
#line 185
    prev = chain;
#line 185
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
  nomatch: 
#line 195
  *prevptr = (struct cookie *)((void *)0);
#line 196
  return ((struct cookie *)((void *)0));
}
}
#line 208 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static void store_cookie(struct cookie_jar *jar , struct cookie *cookie ) 
{ 
  struct cookie *chain_head ;
  char *chain_key ;
  struct cookie *prev ;
  struct cookie *victim ;
  struct cookie *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  time_t exptime ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 214
  tmp___1 = hash_table_get_pair((struct hash_table  const  *)jar->chains, (void const   *)cookie->domain,
                                (void *)(& chain_key), (void *)(& chain_head));
  }
#line 214
  if (tmp___1) {
    {
#line 221
    tmp = find_matching_cookie(jar, cookie, & prev);
#line 221
    victim = tmp;
    }
#line 223
    if (victim) {
#line 227
      if (prev) {
#line 229
        prev->next = victim->next;
#line 230
        cookie->next = chain_head;
      } else {
#line 237
        cookie->next = victim->next;
      }
      {
#line 239
      delete_cookie(victim);
#line 240
      (jar->cookie_count) --;
      }
      {
#line 241
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 241
        tmp___0 = __builtin_expect((long )opt.debug, 0L);
        }
#line 241
        if (tmp___0) {
          {
#line 241
          debug_logprintf("Deleted old cookie (to be replaced.)\n");
          }
        }
#line 241
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 244
      cookie->next = chain_head;
    }
  } else {
    {
#line 253
    cookie->next = (struct cookie *)((void *)0);
#line 254
    chain_key = checking_strdup((char const   *)cookie->domain);
    }
  }
  {
#line 257
  hash_table_put(jar->chains, (void const   *)chain_key, (void *)cookie);
#line 258
  (jar->cookie_count) ++;
#line 260
  tmp___8 = __builtin_expect((long )opt.debug, 0L);
  }
#line 260
  if (tmp___8) {
#line 262
    exptime = cookie->expiry_time;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 263
      tmp___7 = __builtin_expect((long )opt.debug, 0L);
      }
#line 263
      if (tmp___7) {
#line 263
        if (cookie->expiry_time) {
          {
#line 263
          tmp___2 = datetime_str(exptime);
#line 263
          tmp___3 = (char const   *)tmp___2;
          }
        } else {
#line 263
          tmp___3 = "none";
        }
#line 263
        if (cookie->secure) {
#line 263
          tmp___4 = "secure";
        } else {
#line 263
          tmp___4 = "insecure";
        }
#line 263
        if (cookie->permanent) {
#line 263
          tmp___5 = "permanent";
        } else {
#line 263
          tmp___5 = "session";
        }
#line 263
        if (cookie->port == -1) {
#line 263
          tmp___6 = " (ANY)";
        } else {
#line 263
          tmp___6 = "";
        }
        {
#line 263
        debug_logprintf("\nStored cookie %s %d%s %s <%s> <%s> [expiry %s] %s %s\n",
                        cookie->domain, cookie->port, tmp___6, cookie->path, tmp___5,
                        tmp___4, tmp___3, cookie->attr, cookie->value);
        }
      }
#line 263
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 272
  return;
}
}
#line 280 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static void discard_matching_cookie(struct cookie_jar *jar , struct cookie *cookie ) 
{ 
  struct cookie *prev ;
  struct cookie *victim ;
  int tmp ;
  char *chain_key ;
  int res___0 ;
  long tmp___1 ;

  {
  {
#line 285
  tmp = hash_table_count((struct hash_table  const  *)jar->chains);
  }
#line 285
  if (! tmp) {
#line 287
    return;
  }
  {
#line 289
  victim = find_matching_cookie(jar, cookie, & prev);
  }
#line 290
  if (victim) {
#line 292
    if (prev) {
#line 294
      prev->next = victim->next;
    } else {
      {
#line 299
      chain_key = (char *)((void *)0);
#line 302
      res___0 = hash_table_get_pair((struct hash_table  const  *)jar->chains, (void const   *)victim->domain,
                                    (void *)(& chain_key), (void *)0);
      }
#line 304
      if (! (res___0 != 0)) {
        {
#line 304
        __assert_fail("res != 0", "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c",
                      304U, "discard_matching_cookie");
        }
      }
#line 305
      if (! victim->next) {
        {
#line 309
        hash_table_remove(jar->chains, (void const   *)victim->domain);
#line 310
        checking_free((void *)chain_key);
        }
      } else {
        {
#line 313
        hash_table_put(jar->chains, (void const   *)chain_key, (void *)victim->next);
        }
      }
    }
    {
#line 315
    delete_cookie(victim);
    }
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 316
      tmp___1 = __builtin_expect((long )opt.debug, 0L);
      }
#line 316
      if (tmp___1) {
        {
#line 316
        debug_logprintf("Discarded old cookie.\n");
        }
      }
#line 316
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 318
  return;
}
}
#line 344 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static struct cookie *parse_set_cookie(char const   *set_cookie , _Bool silent ) 
{ 
  char const   *ptr ;
  struct cookie *cookie ;
  struct cookie *tmp ;
  param_token name ;
  param_token value ;
  _Bool tmp___0 ;
  char *value_copy ;
  time_t expires ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___1 ;
  double maxage ;
  char *value_copy___0 ;
  char const   *BTA_beg___0 ;
  int BTA_len___0 ;
  char **BTA_dest___0 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 347
  ptr = set_cookie;
#line 348
  tmp = cookie_new();
#line 348
  cookie = tmp;
#line 351
  tmp___0 = extract_param(& ptr, & name, & value, (char )';');
  }
#line 351
  if (! tmp___0) {
#line 352
    goto error;
  }
#line 353
  if (! value.b) {
#line 354
    goto error;
  }
  {
#line 355
  cookie->attr = strdupdelim(name.b, name.e);
#line 356
  cookie->value = strdupdelim(value.b, value.e);
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    tmp___8 = extract_param(& ptr, & name, & value, (char )';');
    }
#line 358
    if (! tmp___8) {
#line 358
      goto while_break;
    }
#line 360
    if ((unsigned long )(name.e - name.b) == sizeof("domain") - 1UL) {
      {
#line 360
      tmp___7 = strncasecmp(name.b, "domain", sizeof("domain") - 1UL);
      }
#line 360
      if (tmp___7) {
#line 360
        goto _L___2;
      } else {
#line 362
        if ((unsigned long )value.b != (unsigned long )((void *)0)) {
#line 362
          if (! ((unsigned long )value.b != (unsigned long )value.e)) {
#line 363
            goto error;
          }
        } else {
#line 363
          goto error;
        }
#line 364
        if (! (! cookie->domain)) {
          {
#line 364
          checking_free((void *)cookie->domain);
          }
        }
#line 369
        if ((int const   )*(value.b) == 46) {
#line 370
          (value.b) ++;
        }
        {
#line 371
        cookie->domain = strdupdelim(value.b, value.e);
        }
      }
    } else
    _L___2: /* CIL Label */ 
#line 373
    if ((unsigned long )(name.e - name.b) == sizeof("path") - 1UL) {
      {
#line 373
      tmp___6 = strncasecmp(name.b, "path", sizeof("path") - 1UL);
      }
#line 373
      if (tmp___6) {
#line 373
        goto _L___1;
      } else {
#line 375
        if ((unsigned long )value.b != (unsigned long )((void *)0)) {
#line 375
          if (! ((unsigned long )value.b != (unsigned long )value.e)) {
#line 376
            goto error;
          }
        } else {
#line 376
          goto error;
        }
#line 377
        if (! (! cookie->path)) {
          {
#line 377
          checking_free((void *)cookie->path);
          }
        }
        {
#line 378
        cookie->path = strdupdelim(value.b, value.e);
        }
      }
    } else
    _L___1: /* CIL Label */ 
#line 380
    if ((unsigned long )(name.e - name.b) == sizeof("expires") - 1UL) {
      {
#line 380
      tmp___5 = strncasecmp(name.b, "expires", sizeof("expires") - 1UL);
      }
#line 380
      if (tmp___5) {
#line 380
        goto _L___0;
      } else {
#line 385
        if ((unsigned long )value.b != (unsigned long )((void *)0)) {
#line 385
          if (! ((unsigned long )value.b != (unsigned long )value.e)) {
#line 386
            goto error;
          }
        } else {
#line 386
          goto error;
        }
        {
#line 387
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 387
          BTA_beg = value.b;
#line 387
          BTA_len = (int )(value.e - BTA_beg);
#line 387
          BTA_dest = & value_copy;
#line 387
          tmp___1 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 387
          *BTA_dest = (char *)tmp___1;
#line 387
          memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
                 (size_t )BTA_len);
#line 387
          *(*BTA_dest + BTA_len) = (char )'\000';
          }
#line 387
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 389
        expires = http_atotm((char const   *)value_copy);
        }
#line 390
        if (expires != -1L) {
#line 392
          cookie->permanent = 1U;
#line 393
          cookie->expiry_time = expires;
#line 397
          if (cookie->expiry_time < cookies_now) {
#line 398
            cookie->discard_requested = 1U;
          }
        }
      }
    } else
    _L___0: /* CIL Label */ 
#line 405
    if ((unsigned long )(name.e - name.b) == sizeof("max-age") - 1UL) {
      {
#line 405
      tmp___4 = strncasecmp(name.b, "max-age", sizeof("max-age") - 1UL);
      }
#line 405
      if (tmp___4) {
#line 405
        goto _L;
      } else {
#line 407
        maxage = (double )-1;
#line 410
        if ((unsigned long )value.b != (unsigned long )((void *)0)) {
#line 410
          if (! ((unsigned long )value.b != (unsigned long )value.e)) {
#line 411
            goto error;
          }
        } else {
#line 411
          goto error;
        }
        {
#line 412
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 412
          BTA_beg___0 = value.b;
#line 412
          BTA_len___0 = (int )(value.e - BTA_beg___0);
#line 412
          BTA_dest___0 = & value_copy___0;
#line 412
          tmp___2 = __builtin_alloca((unsigned long )(BTA_len___0 + 1));
#line 412
          *BTA_dest___0 = (char *)tmp___2;
#line 412
          memcpy((void */* __restrict  */)*BTA_dest___0, (void const   */* __restrict  */)BTA_beg___0,
                 (size_t )BTA_len___0);
#line 412
          *(*BTA_dest___0 + BTA_len___0) = (char )'\000';
          }
#line 412
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 414
        sscanf((char const   */* __restrict  */)value_copy___0, (char const   */* __restrict  */)"%lf",
               & maxage);
        }
#line 415
        if (maxage == (double )-1) {
#line 417
          goto error;
        }
#line 418
        cookie->permanent = 1U;
#line 419
        cookie->expiry_time = (time_t )((double )cookies_now + maxage);
#line 423
        if (maxage == (double )0) {
#line 424
          cookie->discard_requested = 1U;
        }
      }
    } else
    _L: /* CIL Label */ 
#line 426
    if ((unsigned long )(name.e - name.b) == sizeof("secure") - 1UL) {
      {
#line 426
      tmp___3 = strncasecmp(name.b, "secure", sizeof("secure") - 1UL);
      }
#line 426
      if (! tmp___3) {
#line 429
        cookie->secure = 1U;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (*ptr) {
#line 437
    goto error;
  }
#line 440
  return (cookie);
  error: 
#line 443
  if (! silent) {
    {
#line 444
    tmp___9 = escnonprint(set_cookie);
#line 444
    tmp___10 = gettext("Syntax error in Set-Cookie: %s at position %d.\n");
#line 444
    logprintf((enum log_options )1, (char const   *)tmp___10, tmp___9, (int )(ptr - set_cookie));
    }
  }
  {
#line 447
  delete_cookie(cookie);
  }
#line 448
  return ((struct cookie *)((void *)0));
}
}
#line 477 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static _Bool numeric_address_p(char const   *addr ) 
{ 
  char const   *p___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 480
  p___0 = addr;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 482
      return ((_Bool)0);
    }
#line 482
    p___0 ++;
    {
#line 482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 482
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 482
        goto while_break___0;
      }
#line 482
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 482
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 483
    tmp = p___0;
#line 483
    p___0 ++;
#line 483
    if ((int const   )*tmp != 46) {
#line 483
      return ((_Bool)0);
    }
#line 483
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 484
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 484
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 484
      return ((_Bool)0);
    }
#line 484
    p___0 ++;
    {
#line 484
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 484
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 484
        goto while_break___3;
      }
#line 484
      p___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 484
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 485
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 485
    tmp___0 = p___0;
#line 485
    p___0 ++;
#line 485
    if ((int const   )*tmp___0 != 46) {
#line 485
      return ((_Bool)0);
    }
#line 485
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 486
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 486
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 486
      return ((_Bool)0);
    }
#line 486
    p___0 ++;
    {
#line 486
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 486
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 486
        goto while_break___6;
      }
#line 486
      p___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 486
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 487
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 487
    tmp___1 = p___0;
#line 487
    p___0 ++;
#line 487
    if ((int const   )*tmp___1 != 46) {
#line 487
      return ((_Bool)0);
    }
#line 487
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 488
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 488
    if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 488
      return ((_Bool)0);
    }
#line 488
    p___0 ++;
    {
#line 488
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 488
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 488
        goto while_break___9;
      }
#line 488
      p___0 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 488
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 490
  if ((int const   )*p___0 != 0) {
#line 491
    return ((_Bool)0);
  }
#line 492
  return ((_Bool)1);
}
}
#line 593
static _Bool check_domain_match(char const   *cookie_domain , char const   *host ) ;
#line 593 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static char const   *known_toplevel_domains[7]  = {      ".com",      ".edu",      ".net",      ".org", 
        ".gov",      ".mil",      ".int"};
#line 500 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static _Bool check_domain_match(char const   *cookie_domain , char const   *host ) 
{ 
  long tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  _Bool tmp___5 ;
  char const   *p___0 ;
  int dccount ;
  int ldcl ;
  int nldcl ;
  int out ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int i ;
  int known_toplevel ;
  _Bool tmp___9 ;
  long tmp___10 ;
  int dlen ;
  size_t tmp___11 ;
  int hlen ;
  size_t tmp___12 ;
  long tmp___13 ;

  {
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 503
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 503
    if (tmp) {
      {
#line 503
      debug_logprintf("cdm: 1");
      }
    }
#line 503
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 507
  tmp___1 = numeric_address_p(cookie_domain);
  }
#line 507
  if (tmp___1) {
    {
#line 508
    tmp___0 = strcmp(cookie_domain, host);
    }
#line 508
    return ((_Bool )(0 == tmp___0));
  }
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 510
    tmp___2 = __builtin_expect((long )opt.debug, 0L);
    }
#line 510
    if (tmp___2) {
      {
#line 510
      debug_logprintf(" 2");
      }
    }
#line 510
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 513
  tmp___3 = strcasecmp(cookie_domain, host);
  }
#line 513
  if (0 == tmp___3) {
#line 514
    return ((_Bool)1);
  }
  {
#line 516
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 516
    tmp___4 = __builtin_expect((long )opt.debug, 0L);
    }
#line 516
    if (tmp___4) {
      {
#line 516
      debug_logprintf(" 3");
      }
    }
#line 516
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 519
  tmp___5 = match_tail(host, cookie_domain, (_Bool)1);
  }
#line 519
  if (! tmp___5) {
#line 520
    return ((_Bool)0);
  }
#line 548
  p___0 = cookie_domain;
#line 549
  dccount = 1;
#line 550
  ldcl = 0;
#line 551
  nldcl = 0;
#line 553
  if ((int const   )*p___0 == 46) {
#line 555
    p___0 ++;
  }
  {
#line 556
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 556
    tmp___6 = __builtin_expect((long )opt.debug, 0L);
    }
#line 556
    if (tmp___6) {
      {
#line 556
      debug_logprintf(" 4");
      }
    }
#line 556
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 557
  out = 0;
  {
#line 557
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 557
    if (! (! out)) {
#line 557
      goto while_break___3;
    }
    {
#line 560
    if ((int const   )*p___0 == 0) {
#line 560
      goto case_0;
    }
#line 563
    if ((int const   )*p___0 == 46) {
#line 563
      goto case_46;
    }
#line 578
    goto switch_default;
    case_0: /* CIL Label */ 
#line 561
    out = 1;
#line 562
    goto switch_break;
    case_46: /* CIL Label */ 
#line 564
    if (ldcl == 0) {
#line 566
      return ((_Bool)0);
    }
#line 567
    if ((int const   )*(p___0 + 1) == 0) {
#line 571
      out = 1;
#line 572
      goto switch_break;
    }
#line 574
    nldcl = ldcl;
#line 575
    ldcl = 0;
#line 576
    dccount ++;
#line 577
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 579
    ldcl ++;
    switch_break: /* CIL Label */ ;
    }
#line 557
    p___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 582
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 582
    tmp___7 = __builtin_expect((long )opt.debug, 0L);
    }
#line 582
    if (tmp___7) {
      {
#line 582
      debug_logprintf(" 5");
      }
    }
#line 582
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 584
  if (dccount < 2) {
#line 585
    return ((_Bool)0);
  }
  {
#line 587
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 587
    tmp___8 = __builtin_expect((long )opt.debug, 0L);
    }
#line 587
    if (tmp___8) {
      {
#line 587
      debug_logprintf(" 6");
      }
    }
#line 587
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 589
  if (dccount == 2) {
#line 592
    known_toplevel = 0;
#line 596
    i = 0;
    {
#line 596
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 596
      if (! ((unsigned long )i < sizeof(known_toplevel_domains) / sizeof(known_toplevel_domains[0]))) {
#line 596
        goto while_break___6;
      }
      {
#line 597
      tmp___9 = match_tail(cookie_domain, known_toplevel_domains[i], (_Bool)1);
      }
#line 597
      if (tmp___9) {
#line 599
        known_toplevel = 1;
#line 600
        goto while_break___6;
      }
#line 596
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 602
    if (! known_toplevel) {
#line 602
      if (nldcl <= 3) {
#line 603
        return ((_Bool)0);
      }
    }
  }
  {
#line 607
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 607
    tmp___10 = __builtin_expect((long )opt.debug, 0L);
    }
#line 607
    if (tmp___10) {
      {
#line 607
      debug_logprintf(" 7");
      }
    }
#line 607
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 611
  if ((int const   )*cookie_domain != 46) {
    {
#line 613
    tmp___11 = strlen(cookie_domain);
#line 613
    dlen = (int )tmp___11;
#line 614
    tmp___12 = strlen(host);
#line 614
    hlen = (int )tmp___12;
    }
#line 618
    if (hlen > dlen) {
#line 618
      if ((int const   )*(host + ((hlen - dlen) - 1)) != 46) {
#line 619
        return ((_Bool)0);
      }
    }
  }
  {
#line 622
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 622
    tmp___13 = __builtin_expect((long )opt.debug, 0L);
    }
#line 622
    if (tmp___13) {
      {
#line 622
      debug_logprintf(" 8");
      }
    }
#line 622
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 624
  return ((_Bool)1);
}
}
#line 627
static int path_matches(char const   *full_path , char const   *prefix ) ;
#line 631 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static _Bool check_path_match(char const   *cookie_path , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 634
  tmp = path_matches(path, cookie_path);
  }
#line 634
  return ((_Bool )(tmp != 0));
}
}
#line 652 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
void cookie_handle_set_cookie(struct cookie_jar *jar , char const   *host , int port ,
                              char const   *path , char const   *set_cookie ) 
{ 
  struct cookie *cookie ;
  char *PS_newstr ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  char *trailing_slash ;
  char *tmp___5 ;
  long tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 658
  cookies_now = time((time_t *)((void *)0));
  }
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 663
    tmp = strlen(path);
#line 663
    tmp___0 = __builtin_alloca((1UL + tmp) + 1UL);
#line 663
    PS_newstr = (char *)tmp___0;
#line 663
    *PS_newstr = (char )'/';
#line 663
    strcpy((char */* __restrict  */)(PS_newstr + 1), (char const   */* __restrict  */)path);
#line 663
    path = (char const   *)PS_newstr;
    }
#line 663
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 665
  cookie = parse_set_cookie(set_cookie, (_Bool)0);
  }
#line 666
  if (! cookie) {
#line 667
    goto out;
  }
#line 671
  if (! cookie->domain) {
    copy_domain: 
    {
#line 676
    cookie->domain = checking_strdup(host);
#line 677
    cookie->domain_exact = 1U;
    }
#line 679
    if (port != 80) {
#line 679
      if (port != 443) {
#line 680
        cookie->port = port;
      }
    }
  } else {
    {
#line 684
    tmp___4 = check_domain_match((char const   *)cookie->domain, host);
    }
#line 684
    if (! tmp___4) {
      {
#line 686
      tmp___1 = escnonprint((char const   *)cookie->domain);
#line 686
      tmp___2 = escnonprint(host);
#line 686
      tmp___3 = gettext("Cookie coming from %s attempted to set domain to %s\n");
#line 686
      logprintf((enum log_options )1, (char const   *)tmp___3, tmp___2, tmp___1);
#line 689
      checking_free((void *)cookie->domain);
      }
#line 690
      goto copy_domain;
    }
  }
#line 694
  if (! cookie->path) {
    {
#line 698
    tmp___5 = strrchr(path, '/');
#line 698
    trailing_slash = tmp___5;
    }
#line 699
    if (trailing_slash) {
      {
#line 700
      cookie->path = strdupdelim(path, (char const   *)(trailing_slash + 1));
      }
    } else {
      {
#line 703
      cookie->path = checking_strdup(path);
      }
    }
  } else {
    {
#line 708
    tmp___7 = check_path_match((char const   *)cookie->path, path);
    }
#line 708
    if (! tmp___7) {
      {
#line 710
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 710
        tmp___6 = __builtin_expect((long )opt.debug, 0L);
        }
#line 710
        if (tmp___6) {
          {
#line 710
          debug_logprintf("Attempt to fake the path: %s, %s\n", cookie->path, path);
          }
        }
#line 710
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 712
      goto out;
    }
  }
#line 719
  if (cookie->discard_requested) {
    {
#line 721
    discard_matching_cookie(jar, cookie);
    }
#line 722
    goto out;
  }
  {
#line 725
  store_cookie(jar, cookie);
  }
#line 726
  return;
  out: 
#line 729
  if (cookie) {
    {
#line 730
    delete_cookie(cookie);
    }
  }
#line 731
  return;
}
}
#line 739 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int count_char(char const   *string , char chr ) 
{ 
  char const   *p___0 ;
  int count ;

  {
#line 743
  count = 0;
#line 744
  p___0 = string;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! *p___0) {
#line 744
      goto while_break;
    }
#line 745
    if ((int const   )*p___0 == (int const   )chr) {
#line 746
      count ++;
    }
#line 744
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  return (count);
}
}
#line 762 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int find_chains_of_host(struct cookie_jar *jar , char const   *host , struct cookie **dest ) 
{ 
  int dest_count ;
  int passes ;
  int passcnt ;
  int tmp ;
  _Bool tmp___0 ;
  struct cookie *chain ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 766
  dest_count = 0;
#line 770
  tmp = hash_table_count((struct hash_table  const  *)jar->chains);
  }
#line 770
  if (! tmp) {
#line 771
    return (0);
  }
  {
#line 773
  tmp___0 = numeric_address_p(host);
  }
#line 773
  if (tmp___0) {
#line 775
    passes = 1;
  } else {
    {
#line 780
    passes = count_char(host, (char )'.');
    }
  }
#line 782
  passcnt = 0;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 790
    tmp___1 = hash_table_get((struct hash_table  const  *)jar->chains, (void const   *)host);
#line 790
    chain = (struct cookie *)tmp___1;
    }
#line 791
    if (chain) {
#line 792
      tmp___2 = dest_count;
#line 792
      dest_count ++;
#line 792
      *(dest + tmp___2) = chain;
    }
#line 793
    passcnt ++;
#line 793
    if (passcnt >= passes) {
#line 794
      goto while_break;
    }
    {
#line 795
    tmp___3 = strchr(host, '.');
#line 795
    host = (char const   *)(tmp___3 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  return (dest_count);
}
}
#line 804 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int path_matches(char const   *full_path , char const   *prefix ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 807
  tmp = strlen(prefix);
#line 807
  len = (int )tmp;
#line 809
  tmp___0 = strncmp(full_path, prefix, (size_t )len);
  }
#line 809
  if (0 != tmp___0) {
#line 811
    return (0);
  }
#line 814
  return (len + 1);
}
}
#line 824 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static _Bool cookie_matches_url(struct cookie  const  *cookie , char const   *host ,
                                int port , char const   *path , _Bool secflag , int *path_goodness ) 
{ 
  int pg ;
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 831
  tmp = cookie_expired_p(cookie);
  }
#line 831
  if (tmp) {
#line 837
    return ((_Bool)0);
  }
#line 839
  if (cookie->secure) {
#line 839
    if (! secflag) {
#line 841
      return ((_Bool)0);
    }
  }
#line 842
  if (cookie->port != -1) {
#line 842
    if (cookie->port != (int const   )port) {
#line 843
      return ((_Bool)0);
    }
  }
#line 848
  if (cookie->domain_exact) {
    {
#line 848
    tmp___0 = strcasecmp(host, (char const   *)cookie->domain);
    }
#line 848
    if (0 != tmp___0) {
#line 850
      return ((_Bool)0);
    }
  }
  {
#line 852
  pg = path_matches(path, (char const   *)cookie->path);
  }
#line 853
  if (pg == 0) {
#line 854
    return ((_Bool)0);
  }
#line 856
  if (path_goodness) {
#line 860
    *path_goodness = pg;
  }
#line 861
  return ((_Bool)1);
}
}
#line 877 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int equality_comparator(void const   *p1 , void const   *p2 ) 
{ 
  struct weighed_cookie *wc1 ;
  struct weighed_cookie *wc2 ;
  int namecmp ;
  int tmp ;
  int valuecmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 880
  wc1 = (struct weighed_cookie *)p1;
#line 881
  wc2 = (struct weighed_cookie *)p2;
#line 883
  tmp = strcmp((char const   *)(wc1->cookie)->attr, (char const   *)(wc2->cookie)->attr);
#line 883
  namecmp = tmp;
#line 884
  tmp___0 = strcmp((char const   *)(wc1->cookie)->value, (char const   *)(wc2->cookie)->value);
#line 884
  valuecmp = tmp___0;
  }
#line 888
  if (namecmp) {
#line 888
    tmp___1 = namecmp;
  } else {
#line 888
    tmp___1 = valuecmp;
  }
#line 888
  return (tmp___1);
}
}
#line 895 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int eliminate_dups(struct weighed_cookie *outgoing , int count ) 
{ 
  struct weighed_cookie *h ;
  struct weighed_cookie *t ;
  struct weighed_cookie *end ;
  struct cookie *c0 ;
  struct cookie *c1 ;
  int tmp ;
  int tmp___0 ;
  struct weighed_cookie *tmp___1 ;

  {
  {
#line 900
  end = outgoing + count;
#line 906
  qsort((void *)outgoing, (size_t )count, sizeof(struct weighed_cookie ), & equality_comparator);
#line 912
  t = outgoing;
#line 912
  h = t;
  }
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! ((unsigned long )h < (unsigned long )end)) {
#line 912
      goto while_break;
    }
#line 914
    if ((unsigned long )h != (unsigned long )(end - 1)) {
      {
#line 916
      c0 = (h + 0)->cookie;
#line 917
      c1 = (h + 1)->cookie;
#line 918
      tmp = strcmp((char const   *)c0->attr, (char const   *)c1->attr);
      }
#line 918
      if (! tmp) {
        {
#line 918
        tmp___0 = strcmp((char const   *)c0->value, (char const   *)c1->value);
        }
#line 918
        if (! tmp___0) {
#line 919
          goto __Cont;
        }
      }
    }
#line 925
    if ((unsigned long )h != (unsigned long )t) {
#line 926
      tmp___1 = t;
#line 926
      t ++;
#line 926
      *tmp___1 = *h;
    } else {
#line 928
      t ++;
    }
    __Cont: /* CIL Label */ 
#line 912
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  return ((int )(t - outgoing));
}
}
#line 935 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int goodness_comparator(void const   *p1 , void const   *p2 ) 
{ 
  struct weighed_cookie *wc1 ;
  struct weighed_cookie *wc2 ;
  int dgdiff ;
  int pgdiff ;
  int tmp ;

  {
#line 938
  wc1 = (struct weighed_cookie *)p1;
#line 939
  wc2 = (struct weighed_cookie *)p2;
#line 943
  dgdiff = wc2->domain_goodness - wc1->domain_goodness;
#line 944
  pgdiff = wc2->path_goodness - wc1->path_goodness;
#line 949
  if (dgdiff) {
#line 949
    tmp = dgdiff;
  } else {
#line 949
    tmp = pgdiff;
  }
#line 949
  return (tmp);
}
}
#line 958 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
char *cookie_header(struct cookie_jar *jar , char const   *host , int port , char const   *path ,
                    _Bool secflag ) 
{ 
  struct cookie **chains ;
  int chain_count ;
  struct cookie *cookie ;
  struct weighed_cookie *outgoing ;
  int count ;
  int i ;
  int ocnt ;
  char *result ;
  int result_size ;
  int pos ;
  char *PS_newstr ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  _Bool tmp___3 ;
  void *tmp___4 ;
  int pg ;
  _Bool tmp___5 ;
  size_t tmp___6 ;
  struct cookie *c ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  struct cookie *c___0 ;
  int namlen ;
  size_t tmp___11 ;
  int vallen ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 970
    tmp = strlen(path);
#line 970
    tmp___0 = __builtin_alloca((1UL + tmp) + 1UL);
#line 970
    PS_newstr = (char *)tmp___0;
#line 970
    *PS_newstr = (char )'/';
#line 970
    strcpy((char */* __restrict  */)(PS_newstr + 1), (char const   */* __restrict  */)path);
#line 970
    path = (char const   *)PS_newstr;
    }
#line 970
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 977
  tmp___1 = count_char(host, (char )'.');
#line 977
  tmp___2 = __builtin_alloca((unsigned long )(1 + tmp___1) * sizeof(struct cookie *));
#line 977
  chains = (struct cookie **)tmp___2;
#line 978
  chain_count = find_chains_of_host(jar, host, chains);
  }
#line 981
  if (! chain_count) {
#line 982
    return ((char *)((void *)0));
  }
  {
#line 984
  cookies_now = time((time_t *)((void *)0));
#line 991
  count = 0;
#line 992
  i = 0;
  }
  {
#line 992
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 992
    if (! (i < chain_count)) {
#line 992
      goto while_break___0;
    }
#line 993
    cookie = *(chains + i);
    {
#line 993
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 993
      if (! cookie) {
#line 993
        goto while_break___1;
      }
      {
#line 994
      tmp___3 = cookie_matches_url((struct cookie  const  *)cookie, host, port, path,
                                   secflag, (int *)((void *)0));
      }
#line 994
      if (tmp___3) {
#line 995
        count ++;
      }
#line 993
      cookie = cookie->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 992
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 996
  if (! count) {
#line 997
    return ((char *)((void *)0));
  }
  {
#line 1000
  tmp___4 = __builtin_alloca((unsigned long )count * sizeof(struct weighed_cookie ));
#line 1000
  outgoing = (struct weighed_cookie *)tmp___4;
#line 1004
  ocnt = 0;
#line 1005
  i = 0;
  }
  {
#line 1005
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1005
    if (! (i < chain_count)) {
#line 1005
      goto while_break___2;
    }
#line 1006
    cookie = *(chains + i);
    {
#line 1006
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1006
      if (! cookie) {
#line 1006
        goto while_break___3;
      }
      {
#line 1009
      tmp___5 = cookie_matches_url((struct cookie  const  *)cookie, host, port, path,
                                   secflag, & pg);
      }
#line 1009
      if (! tmp___5) {
#line 1010
        goto __Cont;
      }
      {
#line 1011
      (outgoing + ocnt)->cookie = cookie;
#line 1012
      tmp___6 = strlen((char const   *)cookie->domain);
#line 1012
      (outgoing + ocnt)->domain_goodness = (int )tmp___6;
#line 1013
      (outgoing + ocnt)->path_goodness = pg;
#line 1014
      ocnt ++;
      }
      __Cont: /* CIL Label */ 
#line 1006
      cookie = cookie->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1005
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1016
  if (! (ocnt == count)) {
    {
#line 1016
    __assert_fail("ocnt == count", "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c",
                  1016U, "cookie_header");
    }
  }
  {
#line 1020
  count = eliminate_dups(outgoing, count);
#line 1024
  qsort((void *)outgoing, (size_t )count, sizeof(struct weighed_cookie ), & goodness_comparator);
#line 1027
  result_size = 0;
#line 1028
  i = 0;
  }
  {
#line 1028
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1028
    if (! (i < count)) {
#line 1028
      goto while_break___4;
    }
    {
#line 1030
    c = (outgoing + i)->cookie;
#line 1032
    tmp___8 = strlen((char const   *)c->attr);
#line 1032
    tmp___9 = strlen((char const   *)c->value);
#line 1032
    result_size = (int )((size_t )result_size + ((tmp___8 + 1UL) + tmp___9));
#line 1028
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1039
  result_size = (result_size + (count - 1) * 2) + 1;
#line 1040
  tmp___10 = checking_malloc((size_t )result_size);
#line 1040
  result = (char *)tmp___10;
#line 1041
  pos = 0;
#line 1042
  i = 0;
  }
  {
#line 1042
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1042
    if (! (i < count)) {
#line 1042
      goto while_break___5;
    }
    {
#line 1044
    c___0 = (outgoing + i)->cookie;
#line 1045
    tmp___11 = strlen((char const   *)c___0->attr);
#line 1045
    namlen = (int )tmp___11;
#line 1046
    tmp___12 = strlen((char const   *)c___0->value);
#line 1046
    vallen = (int )tmp___12;
#line 1048
    memcpy((void */* __restrict  */)(result + pos), (void const   */* __restrict  */)c___0->attr,
           (size_t )namlen);
#line 1049
    pos += namlen;
#line 1050
    tmp___13 = pos;
#line 1050
    pos ++;
#line 1050
    *(result + tmp___13) = (char )'=';
#line 1051
    memcpy((void */* __restrict  */)(result + pos), (void const   */* __restrict  */)c___0->value,
           (size_t )vallen);
#line 1052
    pos += vallen;
    }
#line 1053
    if (i < count - 1) {
#line 1055
      tmp___14 = pos;
#line 1055
      pos ++;
#line 1055
      *(result + tmp___14) = (char )';';
#line 1056
      tmp___15 = pos;
#line 1056
      pos ++;
#line 1056
      *(result + tmp___15) = (char )' ';
    }
#line 1042
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1059
  tmp___16 = pos;
#line 1059
  pos ++;
#line 1059
  *(result + tmp___16) = (char )'\000';
#line 1060
  if (! (pos == result_size)) {
    {
#line 1060
    __assert_fail("pos == result_size", "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c",
                  1060U, "cookie_header");
    }
  }
#line 1061
  return (result);
}
}
#line 1097 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
static int domain_port(char const   *domain_b , char const   *domain_e , char const   **domain_e_ptr ) 
{ 
  int port ;
  char const   *p___0 ;
  char const   *colon ;
  void *tmp ;

  {
  {
#line 1101
  port = 0;
#line 1103
  tmp = memchr((void const   *)domain_b, ':', (size_t )(domain_e - domain_b));
#line 1103
  colon = (char const   *)tmp;
  }
#line 1104
  if (! colon) {
#line 1105
    return (0);
  }
#line 1106
  p___0 = colon + 1;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    if ((unsigned long )p___0 < (unsigned long )domain_e) {
#line 1106
      if (! ((int const   )_sch_istable[(int const   )*p___0 & 255] & 4)) {
#line 1106
        goto while_break;
      }
    } else {
#line 1106
      goto while_break;
    }
#line 1107
    port = 10 * port + (int )((int const   )*p___0 - 48);
#line 1106
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  if ((unsigned long )p___0 < (unsigned long )domain_e) {
#line 1110
    return (0);
  }
#line 1111
  *domain_e_ptr = colon;
#line 1112
  return (port);
}
}
#line 1127 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
void cookie_jar_load(struct cookie_jar *jar , char const   *file ) 
{ 
  char *line ;
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct cookie *cookie ;
  char *p___0 ;
  double expiry ;
  int port ;
  char *domain_b ;
  char *domain_e ;
  char *domflag_b ;
  char *domflag_e ;
  char *path_b ;
  char *path_e ;
  char *secure_b ;
  char *secure_e ;
  char *expires_b ;
  char *expires_e ;
  char *name_b ;
  char *name_e ;
  char *value_b ;
  char *value_e ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1131
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
#line 1131
  fp = tmp;
  }
#line 1132
  if (! fp) {
    {
#line 1134
    tmp___0 = __errno_location();
#line 1134
    tmp___1 = strerror(*tmp___0);
#line 1134
    tmp___2 = gettext("Cannot open cookies file `%s\': %s\n");
#line 1134
    logprintf((enum log_options )1, (char const   *)tmp___2, file, tmp___1);
    }
#line 1136
    return;
  }
  {
#line 1138
  cookies_now = time((time_t *)((void *)0));
  }
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1140
    line = read_whole_line(fp);
    }
#line 1140
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 1140
      goto while_break;
    }
#line 1143
    p___0 = line;
#line 1148
    domain_b = (char *)((void *)0);
#line 1148
    domain_e = (char *)((void *)0);
#line 1149
    domflag_b = (char *)((void *)0);
#line 1149
    domflag_e = (char *)((void *)0);
#line 1150
    path_b = (char *)((void *)0);
#line 1150
    path_e = (char *)((void *)0);
#line 1151
    secure_b = (char *)((void *)0);
#line 1151
    secure_e = (char *)((void *)0);
#line 1152
    expires_b = (char *)((void *)0);
#line 1152
    expires_e = (char *)((void *)0);
#line 1153
    name_b = (char *)((void *)0);
#line 1153
    name_e = (char *)((void *)0);
#line 1154
    value_b = (char *)((void *)0);
#line 1154
    value_e = (char *)((void *)0);
    {
#line 1157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1157
      if (*p___0) {
#line 1157
        if (! ((int const   )_sch_istable[(int )*p___0 & 255] & 64)) {
#line 1157
          goto while_break___0;
        }
      } else {
#line 1157
        goto while_break___0;
      }
#line 1158
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1160
    if (! *p___0) {
#line 1161
      goto __Cont;
    } else
#line 1160
    if ((int )*p___0 == 35) {
#line 1161
      goto __Cont;
    }
    {
#line 1163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1163
      domain_b = p___0;
      {
#line 1163
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1163
        if (*p___0) {
#line 1163
          if (! ((int )*p___0 != 9)) {
#line 1163
            goto while_break___2;
          }
        } else {
#line 1163
          goto while_break___2;
        }
#line 1163
        p___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1163
      domain_e = p___0;
#line 1163
      if ((unsigned long )domain_b == (unsigned long )domain_e) {
#line 1163
        goto next;
      } else
#line 1163
      if (! *p___0) {
#line 1163
        goto next;
      }
#line 1163
      p___0 ++;
#line 1163
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1164
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1164
      domflag_b = p___0;
      {
#line 1164
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1164
        if (*p___0) {
#line 1164
          if (! ((int )*p___0 != 9)) {
#line 1164
            goto while_break___4;
          }
        } else {
#line 1164
          goto while_break___4;
        }
#line 1164
        p___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1164
      domflag_e = p___0;
#line 1164
      if ((unsigned long )domflag_b == (unsigned long )domflag_e) {
#line 1164
        goto next;
      } else
#line 1164
      if (! *p___0) {
#line 1164
        goto next;
      }
#line 1164
      p___0 ++;
#line 1164
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1165
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1165
      path_b = p___0;
      {
#line 1165
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1165
        if (*p___0) {
#line 1165
          if (! ((int )*p___0 != 9)) {
#line 1165
            goto while_break___6;
          }
        } else {
#line 1165
          goto while_break___6;
        }
#line 1165
        p___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1165
      path_e = p___0;
#line 1165
      if ((unsigned long )path_b == (unsigned long )path_e) {
#line 1165
        goto next;
      } else
#line 1165
      if (! *p___0) {
#line 1165
        goto next;
      }
#line 1165
      p___0 ++;
#line 1165
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1166
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1166
      secure_b = p___0;
      {
#line 1166
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1166
        if (*p___0) {
#line 1166
          if (! ((int )*p___0 != 9)) {
#line 1166
            goto while_break___8;
          }
        } else {
#line 1166
          goto while_break___8;
        }
#line 1166
        p___0 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1166
      secure_e = p___0;
#line 1166
      if ((unsigned long )secure_b == (unsigned long )secure_e) {
#line 1166
        goto next;
      } else
#line 1166
      if (! *p___0) {
#line 1166
        goto next;
      }
#line 1166
      p___0 ++;
#line 1166
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1167
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1167
      expires_b = p___0;
      {
#line 1167
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1167
        if (*p___0) {
#line 1167
          if (! ((int )*p___0 != 9)) {
#line 1167
            goto while_break___10;
          }
        } else {
#line 1167
          goto while_break___10;
        }
#line 1167
        p___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1167
      expires_e = p___0;
#line 1167
      if ((unsigned long )expires_b == (unsigned long )expires_e) {
#line 1167
        goto next;
      } else
#line 1167
      if (! *p___0) {
#line 1167
        goto next;
      }
#line 1167
      p___0 ++;
#line 1167
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1168
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1168
      name_b = p___0;
      {
#line 1168
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1168
        if (*p___0) {
#line 1168
          if (! ((int )*p___0 != 9)) {
#line 1168
            goto while_break___12;
          }
        } else {
#line 1168
          goto while_break___12;
        }
#line 1168
        p___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1168
      name_e = p___0;
#line 1168
      if ((unsigned long )name_b == (unsigned long )name_e) {
#line 1168
        goto next;
      } else
#line 1168
      if (! *p___0) {
#line 1168
        goto next;
      }
#line 1168
      p___0 ++;
#line 1168
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1172
    value_b = p___0;
#line 1173
    tmp___3 = strlen((char const   *)p___0);
#line 1173
    value_e = p___0 + tmp___3;
    }
#line 1174
    if ((unsigned long )value_e > (unsigned long )value_b) {
#line 1174
      if ((int )*(value_e + -1) == 10) {
#line 1175
        value_e --;
      }
    }
#line 1176
    if ((unsigned long )value_e > (unsigned long )value_b) {
#line 1176
      if ((int )*(value_e + -1) == 13) {
#line 1177
        value_e --;
      }
    }
    {
#line 1180
    cookie = cookie_new();
#line 1182
    cookie->attr = strdupdelim((char const   *)name_b, (char const   *)name_e);
#line 1183
    cookie->value = strdupdelim((char const   *)value_b, (char const   *)value_e);
#line 1184
    cookie->path = strdupdelim((char const   *)path_b, (char const   *)path_e);
    }
#line 1185
    if ((unsigned long )(secure_e - secure_b) == sizeof("TRUE") - 1UL) {
      {
#line 1185
      tmp___4 = memcmp((void const   *)secure_b, (void const   *)"TRUE", sizeof("TRUE") - 1UL);
      }
#line 1185
      if (tmp___4) {
#line 1185
        tmp___5 = 0;
      } else {
#line 1185
        tmp___5 = 1;
      }
    } else {
#line 1185
      tmp___5 = 0;
    }
#line 1185
    cookie->secure = (unsigned int )tmp___5;
#line 1191
    if ((unsigned long )(domflag_e - domflag_b) == sizeof("TRUE") - 1UL) {
      {
#line 1191
      tmp___6 = memcmp((void const   *)domflag_b, (void const   *)"TRUE", sizeof("TRUE") - 1UL);
      }
#line 1191
      if (tmp___6) {
#line 1191
        tmp___7 = 1;
      } else {
#line 1191
        tmp___7 = 0;
      }
    } else {
#line 1191
      tmp___7 = 1;
    }
    {
#line 1191
    cookie->domain_exact = (unsigned int )tmp___7;
#line 1195
    port = domain_port((char const   *)domain_b, (char const   *)domain_e, (char const   **)(& domain_e));
    }
#line 1196
    if (port) {
#line 1197
      cookie->port = port;
    }
#line 1199
    if ((int )*domain_b == 46) {
#line 1200
      domain_b ++;
    }
    {
#line 1201
    cookie->domain = strdupdelim((char const   *)domain_b, (char const   *)domain_e);
#line 1204
    expiry = (double )cookies_now - (double )1;
#line 1208
    *expires_e = (char )'\000';
#line 1209
    sscanf((char const   */* __restrict  */)expires_b, (char const   */* __restrict  */)"%lf",
           & expiry);
    }
#line 1211
    if (! (expiry == (double )0)) {
#line 1220
      if (expiry < (double )cookies_now) {
#line 1221
        goto abort_cookie;
      }
#line 1222
      cookie->expiry_time = (time_t )expiry;
#line 1223
      cookie->permanent = 1U;
    }
    {
#line 1226
    store_cookie(jar, cookie);
    }
    next: 
#line 1229
    goto __Cont;
    abort_cookie: 
    {
#line 1232
    delete_cookie(cookie);
    }
    __Cont: /* CIL Label */ 
    {
#line 1140
    checking_free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1234
  fclose(fp);
  }
#line 1235
  return;
}
}
#line 1239 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
void cookie_jar_save(struct cookie_jar *jar , char const   *file ) 
{ 
  FILE *fp ;
  hash_table_iterator iter ;
  long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *domain ;
  struct cookie *cookie ;
  _Bool tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;

  {
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1245
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 1245
    if (tmp) {
      {
#line 1245
      debug_logprintf("Saving cookies to %s.\n", file);
      }
    }
#line 1245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1247
  cookies_now = time((time_t *)((void *)0));
#line 1249
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 1250
  if (! fp) {
    {
#line 1252
    tmp___0 = __errno_location();
#line 1252
    tmp___1 = strerror(*tmp___0);
#line 1252
    tmp___2 = gettext("Cannot open cookies file `%s\': %s\n");
#line 1252
    logprintf((enum log_options )1, (char const   *)tmp___2, file, tmp___1);
    }
#line 1254
    return;
  }
  {
#line 1257
  fputs((char const   */* __restrict  */)"# HTTP cookie file.\n", (FILE */* __restrict  */)fp);
#line 1258
  tmp___3 = datetime_str(cookies_now);
#line 1258
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Generated by Wget on %s.\n",
          tmp___3);
#line 1259
  fputs((char const   */* __restrict  */)"# Edit at your own risk.\n\n", (FILE */* __restrict  */)fp);
#line 1261
  hash_table_iterate(jar->chains, & iter);
  }
  {
#line 1261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1261
    tmp___8 = hash_table_iter_next(& iter);
    }
#line 1261
    if (! tmp___8) {
#line 1261
      goto while_break___0;
    }
#line 1265
    domain = (char const   *)iter.key;
#line 1266
    cookie = (struct cookie *)iter.value;
    {
#line 1267
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1267
      if (! cookie) {
#line 1267
        goto while_break___1;
      }
#line 1269
      if (! cookie->permanent) {
#line 1269
        if (! opt.keep_session_cookies) {
#line 1270
          goto __Cont;
        }
      }
      {
#line 1271
      tmp___4 = cookie_expired_p((struct cookie  const  *)cookie);
      }
#line 1271
      if (tmp___4) {
#line 1272
        goto __Cont;
      }
#line 1273
      if (! cookie->domain_exact) {
        {
#line 1274
        fputc('.', fp);
        }
      }
      {
#line 1275
      fputs((char const   */* __restrict  */)domain, (FILE */* __restrict  */)fp);
      }
#line 1276
      if (cookie->port != -1) {
        {
#line 1277
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)":%d",
                cookie->port);
        }
      }
#line 1278
      if (cookie->secure) {
#line 1278
        tmp___5 = "TRUE";
      } else {
#line 1278
        tmp___5 = "FALSE";
      }
#line 1278
      if (cookie->domain_exact) {
#line 1278
        tmp___6 = "FALSE";
      } else {
#line 1278
        tmp___6 = "TRUE";
      }
      {
#line 1278
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t%s\t%s\t%s\t%.0f\t%s\t%s\n",
              tmp___6, cookie->path, tmp___5, (double )cookie->expiry_time, cookie->attr,
              cookie->value);
#line 1283
      tmp___7 = ferror(fp);
      }
#line 1283
      if (tmp___7) {
#line 1284
        goto out;
      }
      __Cont: /* CIL Label */ 
#line 1267
      cookie = cookie->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
  {
#line 1288
  tmp___12 = ferror(fp);
  }
#line 1288
  if (tmp___12) {
    {
#line 1289
    tmp___9 = __errno_location();
#line 1289
    tmp___10 = strerror(*tmp___9);
#line 1289
    tmp___11 = gettext("Error writing to `%s\': %s\n");
#line 1289
    logprintf((enum log_options )1, (char const   *)tmp___11, file, tmp___10);
    }
  }
  {
#line 1291
  tmp___16 = fclose(fp);
  }
#line 1291
  if (tmp___16 < 0) {
    {
#line 1292
    tmp___13 = __errno_location();
#line 1292
    tmp___14 = strerror(*tmp___13);
#line 1292
    tmp___15 = gettext("Error closing `%s\': %s\n");
#line 1292
    logprintf((enum log_options )1, (char const   *)tmp___15, file, tmp___14);
    }
  }
  {
#line 1295
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1295
    tmp___17 = __builtin_expect((long )opt.debug, 0L);
    }
#line 1295
    if (tmp___17) {
      {
#line 1295
      debug_logprintf("Done saving cookies.\n");
      }
    }
#line 1295
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1296
  return;
}
}
#line 1300 "/home/khheo/project/benchmark/wget-1.11.4/src/cookies.c"
void cookie_jar_delete(struct cookie_jar *jar ) 
{ 
  hash_table_iterator iter ;
  struct cookie *chain ;
  struct cookie *next ;
  int tmp ;

  {
  {
#line 1305
  hash_table_iterate(jar->chains, & iter);
  }
  {
#line 1305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1305
    tmp = hash_table_iter_next(& iter);
    }
#line 1305
    if (! tmp) {
#line 1305
      goto while_break;
    }
    {
#line 1307
    chain = (struct cookie *)iter.value;
#line 1308
    checking_free(iter.key);
    }
    {
#line 1310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1310
      if (! chain) {
#line 1310
        goto while_break___0;
      }
      {
#line 1312
      next = chain->next;
#line 1313
      delete_cookie(chain);
#line 1314
      chain = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1317
  hash_table_destroy(jar->chains);
#line 1318
  checking_free((void *)jar);
  }
#line 1319
  return;
}
}
#line 34 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
struct hash_table *dl_url_file_map  ;
#line 35 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.h"
struct hash_table *downloaded_html_set  ;
#line 103
void convert_cleanup(void) ;
#line 51 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static struct hash_table *dl_file_url_map  ;
#line 58
static void convert_links(char const   *file , struct urlpos *links ) ;
#line 75 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void convert_all_links(void) 
{ 
  int i ;
  double secs ;
  int file_count ;
  struct ptimer *timer ;
  struct ptimer *tmp ;
  int cnt ;
  char **file_array ;
  void *tmp___0 ;
  struct urlpos *urls ;
  struct urlpos *cur_url ;
  char *url ;
  char *file ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *local_name ;
  struct url *u ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 80
  file_count = 0;
#line 82
  tmp = ptimer_new();
#line 82
  timer = tmp;
#line 87
  cnt = 0;
  }
#line 88
  if (downloaded_html_set) {
    {
#line 89
    cnt = hash_table_count((struct hash_table  const  *)downloaded_html_set);
    }
  }
#line 90
  if (cnt == 0) {
#line 91
    goto cleanup;
  }
  {
#line 92
  tmp___0 = __builtin_alloca((unsigned long )cnt * sizeof(char *));
#line 92
  file_array = (char **)tmp___0;
#line 93
  string_set_to_array(downloaded_html_set, file_array);
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < cnt)) {
#line 95
      goto while_break;
    }
    {
#line 99
    file = *(file_array + i);
#line 103
    tmp___1 = hash_table_get((struct hash_table  const  *)dl_file_url_map, (void const   *)file);
#line 103
    url = (char *)tmp___1;
    }
#line 104
    if (! url) {
      {
#line 106
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 106
        tmp___2 = __builtin_expect((long )opt.debug, 0L);
        }
#line 106
        if (tmp___2) {
          {
#line 106
          debug_logprintf("Apparently %s has been removed.\n", file);
          }
        }
#line 106
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 107
      goto __Cont;
    }
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 110
      tmp___3 = __builtin_expect((long )opt.debug, 0L);
      }
#line 110
      if (tmp___3) {
        {
#line 110
        debug_logprintf("Scanning %s (from %s)\n", file, url);
        }
      }
#line 110
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 113
    urls = get_urls_html((char const   *)file, (char const   *)url, (_Bool *)((void *)0));
#line 119
    cur_url = urls;
    }
    {
#line 119
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 119
      if (! cur_url) {
#line 119
        goto while_break___2;
      }
#line 122
      u = cur_url->url;
#line 124
      if (cur_url->link_base_p) {
#line 129
        cur_url->convert = (enum convert_options )3;
#line 130
        goto __Cont___0;
      }
      {
#line 136
      tmp___4 = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)u->url);
#line 136
      local_name = (char *)tmp___4;
      }
#line 139
      if (local_name) {
        {
#line 146
        cur_url->convert = (enum convert_options )1;
#line 147
        cur_url->local_name = checking_strdup((char const   *)local_name);
        }
        {
#line 148
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 148
          tmp___5 = __builtin_expect((long )opt.debug, 0L);
          }
#line 148
          if (tmp___5) {
            {
#line 148
            debug_logprintf("will convert url %s to local %s\n", u->url, local_name);
            }
          }
#line 148
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 156
        if (! cur_url->link_complete_p) {
#line 157
          cur_url->convert = (enum convert_options )2;
        }
#line 158
        cur_url->local_name = (char *)((void *)0);
        {
#line 159
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 159
          tmp___6 = __builtin_expect((long )opt.debug, 0L);
          }
#line 159
          if (tmp___6) {
            {
#line 159
            debug_logprintf("will convert url %s to complete\n", u->url);
            }
          }
#line 159
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 119
      cur_url = cur_url->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 164
    convert_links((char const   *)file, urls);
#line 165
    file_count ++;
#line 168
    free_urlpos(urls);
    }
    __Cont: /* CIL Label */ 
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  secs = ptimer_measure(timer);
#line 172
  tmp___7 = print_decimal(secs);
#line 172
  tmp___8 = gettext("Converted %d files in %s seconds.\n");
#line 172
  logprintf((enum log_options )0, (char const   *)tmp___8, file_count, tmp___7);
  }
  cleanup: 
  {
#line 175
  ptimer_destroy(timer);
  }
#line 176
  return;
}
}
#line 178
static void write_backup_file(char const   *file , downloaded_file_t downloaded_file_return ) ;
#line 179
static char const   *replace_attr(char const   *p___0 , int size , FILE *fp , char const   *new_text ) ;
#line 180
static char const   *replace_attr_refresh_hack(char const   *p___0 , int size , FILE *fp ,
                                               char const   *new_text , int timeout ) ;
#line 182
static char *local_quote_string(char const   *file ) ;
#line 183
static char *construct_relative(char const   *basefile , char const   *linkfile ) ;
#line 188 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static void convert_links(char const   *file , struct urlpos *links ) 
{ 
  struct file_memory *fm ;
  FILE *fp ;
  char const   *p___0 ;
  downloaded_file_t downloaded_file_return ;
  struct urlpos *link___0 ;
  int to_url_count ;
  int to_file_count ;
  char *tmp ;
  int dry_count ;
  struct urlpos *dry ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *url_start ;
  long tmp___12 ;
  long tmp___13 ;
  char *newname ;
  char *tmp___14 ;
  char *quoted_newname ;
  char *tmp___15 ;
  long tmp___16 ;
  char *newlink ;
  char *quoted_newlink ;
  char *tmp___17 ;
  long tmp___18 ;

  {
  {
#line 197
  to_url_count = 0;
#line 197
  to_file_count = 0;
#line 199
  tmp = gettext("Converting %s... ");
#line 199
  logprintf((enum log_options )0, (char const   *)tmp, file);
#line 205
  dry_count = 0;
#line 207
  dry = links;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! dry) {
#line 207
      goto while_break;
    }
#line 208
    if ((unsigned int )dry->convert != 0U) {
#line 209
      dry_count ++;
    }
#line 207
    dry = dry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (! dry_count) {
    {
#line 212
    tmp___0 = gettext("nothing to do.\n");
#line 212
    logputs((enum log_options )0, (char const   *)tmp___0);
    }
#line 213
    return;
  }
  {
#line 217
  fm = read_file(file);
  }
#line 218
  if (! fm) {
    {
#line 220
    tmp___1 = __errno_location();
#line 220
    tmp___2 = strerror(*tmp___1);
#line 220
    tmp___3 = gettext("Cannot convert links in %s: %s\n");
#line 220
    logprintf((enum log_options )1, (char const   *)tmp___3, file, tmp___2);
    }
#line 222
    return;
  }
  {
#line 225
  downloaded_file_return = downloaded_file((downloaded_file_t )3, file);
  }
#line 226
  if (opt.backup_converted) {
#line 226
    if (downloaded_file_return) {
      {
#line 227
      write_backup_file(file, downloaded_file_return);
      }
    }
  }
  {
#line 233
  tmp___7 = unlink(file);
  }
#line 233
  if (tmp___7 < 0) {
    {
#line 233
    tmp___8 = __errno_location();
    }
#line 233
    if (*tmp___8 != 2) {
      {
#line 235
      tmp___4 = __errno_location();
#line 235
      tmp___5 = strerror(*tmp___4);
#line 235
      tmp___6 = gettext("Unable to delete `%s\': %s\n");
#line 235
      logprintf((enum log_options )1, (char const   *)tmp___6, file, tmp___5);
#line 237
      read_file_free(fm);
      }
#line 238
      return;
    }
  }
  {
#line 241
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"wb");
  }
#line 242
  if (! fp) {
    {
#line 244
    tmp___9 = __errno_location();
#line 244
    tmp___10 = strerror(*tmp___9);
#line 244
    tmp___11 = gettext("Cannot convert links in %s: %s\n");
#line 244
    logprintf((enum log_options )1, (char const   *)tmp___11, file, tmp___10);
#line 246
    read_file_free(fm);
    }
#line 247
    return;
  }
#line 252
  p___0 = (char const   *)fm->content;
#line 253
  link___0 = links;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! link___0) {
#line 253
      goto while_break___0;
    }
#line 255
    url_start = fm->content + link___0->pos;
#line 257
    if ((long )link___0->pos >= fm->length) {
      {
#line 259
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 259
        tmp___12 = __builtin_expect((long )opt.debug, 0L);
        }
#line 259
        if (tmp___12) {
          {
#line 259
          debug_logprintf("Something strange is going on.  Please investigate.");
          }
        }
#line 259
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 260
      goto while_break___0;
    }
#line 263
    if ((unsigned int )link___0->convert == 0U) {
      {
#line 265
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 265
        tmp___13 = __builtin_expect((long )opt.debug, 0L);
        }
#line 265
        if (tmp___13) {
          {
#line 265
          debug_logprintf("Skipping %s at position %d.\n", (link___0->url)->url, link___0->pos);
          }
        }
#line 265
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 266
      goto __Cont;
    }
    {
#line 271
    fwrite((void const   */* __restrict  */)p___0, (size_t )1, (size_t )(url_start - (char *)p___0),
           (FILE */* __restrict  */)fp);
#line 272
    p___0 = (char const   *)url_start;
    }
    {
#line 276
    if ((unsigned int )link___0->convert == 1U) {
#line 276
      goto case_1;
    }
#line 295
    if ((unsigned int )link___0->convert == 2U) {
#line 295
      goto case_2;
    }
#line 313
    if ((unsigned int )link___0->convert == 3U) {
#line 313
      goto case_3;
    }
#line 317
    if ((unsigned int )link___0->convert == 0U) {
#line 317
      goto case_0;
    }
#line 274
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 279
    tmp___14 = construct_relative(file, (char const   *)link___0->local_name);
#line 279
    newname = tmp___14;
#line 280
    tmp___15 = local_quote_string((char const   *)newname);
#line 280
    quoted_newname = tmp___15;
    }
#line 282
    if (! link___0->link_refresh_p) {
      {
#line 283
      p___0 = replace_attr(p___0, link___0->size, fp, (char const   *)quoted_newname);
      }
    } else {
      {
#line 285
      p___0 = replace_attr_refresh_hack(p___0, link___0->size, fp, (char const   *)quoted_newname,
                                        link___0->refresh_timeout);
      }
    }
    {
#line 288
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 288
      tmp___16 = __builtin_expect((long )opt.debug, 0L);
      }
#line 288
      if (tmp___16) {
        {
#line 288
        debug_logprintf("TO_RELATIVE: %s to %s at position %d in %s.\n", (link___0->url)->url,
                        newname, link___0->pos, file);
        }
      }
#line 288
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 290
    checking_free((void *)newname);
#line 291
    checking_free((void *)quoted_newname);
#line 292
    to_file_count ++;
    }
#line 293
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 298
    newlink = (link___0->url)->url;
#line 299
    tmp___17 = html_quote_string((char const   *)newlink);
#line 299
    quoted_newlink = tmp___17;
    }
#line 301
    if (! link___0->link_refresh_p) {
      {
#line 302
      p___0 = replace_attr(p___0, link___0->size, fp, (char const   *)quoted_newlink);
      }
    } else {
      {
#line 304
      p___0 = replace_attr_refresh_hack(p___0, link___0->size, fp, (char const   *)quoted_newlink,
                                        link___0->refresh_timeout);
      }
    }
    {
#line 307
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 307
      tmp___18 = __builtin_expect((long )opt.debug, 0L);
      }
#line 307
      if (tmp___18) {
        {
#line 307
        debug_logprintf("TO_COMPLETE: <something> to %s at position %d in %s.\n",
                        newlink, link___0->pos, file);
        }
      }
#line 307
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 309
    checking_free((void *)quoted_newlink);
#line 310
    to_url_count ++;
    }
#line 311
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 315
    p___0 = replace_attr(p___0, link___0->size, fp, "");
    }
#line 316
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 318
    abort();
    }
#line 319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 253
    link___0 = link___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 324
  if (p___0 - (char const   *)fm->content < fm->length) {
    {
#line 325
    fwrite((void const   */* __restrict  */)p___0, (size_t )1, (size_t )(fm->length - (p___0 - (char const   *)fm->content)),
           (FILE */* __restrict  */)fp);
    }
  }
  {
#line 326
  fclose(fp);
#line 327
  read_file_free(fm);
#line 329
  logprintf((enum log_options )0, "%d-%d\n", to_file_count, to_url_count);
  }
#line 330
  return;
}
}
#line 349 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static char *construct_relative(char const   *basefile , char const   *linkfile ) 
{ 
  char *link___0 ;
  int basedirs ;
  char const   *b ;
  char const   *l ;
  int i ;
  int start ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 359
  start = 0;
#line 360
  b = basefile;
#line 360
  l = linkfile;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if ((int const   )*b == (int const   )*l) {
#line 360
      if (! ((int const   )*b != 0)) {
#line 360
        goto while_break;
      }
    } else {
#line 360
      goto while_break;
    }
#line 362
    if ((int const   )*b == 47) {
#line 363
      start = (int )((b - basefile) + 1L);
    }
#line 360
    b ++;
#line 360
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  basefile += start;
#line 366
  linkfile += start;
#line 380
  basedirs = 0;
#line 381
  b = basefile;
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    if (! *b) {
#line 381
      goto while_break___0;
    }
#line 383
    if ((int const   )*b == 47) {
#line 384
      basedirs ++;
    }
#line 381
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  tmp = strlen(linkfile);
#line 388
  tmp___0 = checking_malloc(((size_t )(3 * basedirs) + tmp) + 1UL);
#line 388
  link___0 = (char *)tmp___0;
#line 389
  i = 0;
  }
  {
#line 389
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 389
    if (! (i < basedirs)) {
#line 389
      goto while_break___1;
    }
    {
#line 390
    memcpy((void */* __restrict  */)(link___0 + 3 * i), (void const   */* __restrict  */)"../",
           (size_t )3);
#line 389
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 391
  strcpy((char */* __restrict  */)(link___0 + 3 * i), (char const   */* __restrict  */)linkfile);
  }
#line 392
  return (link___0);
}
}
#line 397 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static struct hash_table *converted_files  ;
#line 399 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static void write_backup_file(char const   *file , downloaded_file_t downloaded_file_return ) 
{ 
  size_t filename_len ;
  size_t tmp ;
  char *filename_plus_orig_suffix ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 408
  tmp = strlen(file);
#line 408
  filename_len = tmp;
  }
#line 411
  if ((unsigned int )downloaded_file_return == 2U) {
    {
#line 420
    tmp___0 = __builtin_alloca(filename_len + 1UL);
#line 420
    filename_plus_orig_suffix = (char *)tmp___0;
#line 421
    strcpy((char */* __restrict  */)filename_plus_orig_suffix, (char const   */* __restrict  */)file);
#line 422
    strcpy((char */* __restrict  */)((filename_plus_orig_suffix + filename_len) - 4),
           (char const   */* __restrict  */)"orig");
    }
  } else {
    {
#line 427
    tmp___1 = __builtin_alloca(filename_len + sizeof(".orig"));
#line 427
    filename_plus_orig_suffix = (char *)tmp___1;
#line 428
    strcpy((char */* __restrict  */)filename_plus_orig_suffix, (char const   */* __restrict  */)file);
#line 429
    strcpy((char */* __restrict  */)(filename_plus_orig_suffix + filename_len), (char const   */* __restrict  */)".orig");
    }
  }
#line 432
  if (! converted_files) {
    {
#line 433
    converted_files = make_string_hash_table(0);
    }
  }
  {
#line 440
  tmp___6 = string_set_contains(converted_files, file);
  }
#line 440
  if (! tmp___6) {
    {
#line 443
    tmp___5 = rename(file, (char const   *)filename_plus_orig_suffix);
    }
#line 443
    if (tmp___5 != 0) {
      {
#line 444
      tmp___2 = __errno_location();
#line 444
      tmp___3 = strerror(*tmp___2);
#line 444
      tmp___4 = gettext("Cannot back up %s as %s: %s\n");
#line 444
      logprintf((enum log_options )1, (char const   *)tmp___4, file, filename_plus_orig_suffix,
                tmp___3);
      }
    }
    {
#line 464
    string_set_add(converted_files, file);
    }
  }
#line 466
  return;
}
}
#line 468
static _Bool find_fragment(char const   *beg , int size , char const   **bp , char const   **ep ) ;
#line 472 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static char const   *replace_attr(char const   *p___0 , int size , FILE *fp , char const   *new_text ) 
{ 
  _Bool quote_flag ;
  char quote_char ;
  char const   *frag_beg ;
  char const   *frag_end ;
  _Bool tmp ;

  {
#line 475
  quote_flag = (_Bool)0;
#line 476
  quote_char = (char )'\"';
#line 488
  if ((int const   )*p___0 == 34) {
#line 490
    quote_char = (char )*p___0;
#line 491
    quote_flag = (_Bool)1;
#line 492
    p___0 ++;
#line 493
    size -= 2;
  } else
#line 488
  if ((int const   )*p___0 == 39) {
#line 490
    quote_char = (char )*p___0;
#line 491
    quote_flag = (_Bool)1;
#line 492
    p___0 ++;
#line 493
    size -= 2;
  }
  {
#line 495
  _IO_putc((int )quote_char, fp);
#line 496
  fputs((char const   */* __restrict  */)new_text, (FILE */* __restrict  */)fp);
#line 499
  tmp = find_fragment(p___0, size, & frag_beg, & frag_end);
  }
#line 499
  if (tmp) {
    {
#line 500
    fwrite((void const   */* __restrict  */)frag_beg, (size_t )1, (size_t )(frag_end - frag_beg),
           (FILE */* __restrict  */)fp);
    }
  }
#line 501
  p___0 += size;
#line 502
  if (quote_flag) {
#line 503
    p___0 ++;
  }
  {
#line 504
  _IO_putc((int )quote_char, fp);
  }
#line 506
  return (p___0);
}
}
#line 513 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static char const   *replace_attr_refresh_hack(char const   *p___0 , int size , FILE *fp ,
                                               char const   *new_text , int timeout ) 
{ 
  char *new_with_timeout ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 518
  tmp = numdigit((wgint )timeout);
#line 518
  tmp___0 = strlen(new_text);
#line 518
  tmp___1 = __builtin_alloca(((size_t )(tmp + 6) + tmp___0) + 1UL);
#line 518
  new_with_timeout = (char *)tmp___1;
#line 522
  sprintf((char */* __restrict  */)new_with_timeout, (char const   */* __restrict  */)"%d; URL=%s",
          timeout, new_text);
#line 524
  tmp___2 = replace_attr(p___0, size, fp, (char const   *)new_with_timeout);
  }
#line 524
  return (tmp___2);
}
}
#line 534 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static _Bool find_fragment(char const   *beg , int size , char const   **bp , char const   **ep ) 
{ 
  char const   *end ;
  _Bool saw_amp ;

  {
#line 537
  end = beg + size;
#line 538
  saw_amp = (_Bool)0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 539
      goto while_break;
    }
    {
#line 543
    if ((int const   )*beg == 38) {
#line 543
      goto case_38;
    }
#line 546
    if ((int const   )*beg == 35) {
#line 546
      goto case_35;
    }
#line 554
    goto switch_default;
    case_38: /* CIL Label */ 
#line 544
    saw_amp = (_Bool)1;
#line 545
    goto switch_break;
    case_35: /* CIL Label */ 
#line 547
    if (! saw_amp) {
#line 549
      *bp = beg;
#line 550
      *ep = end;
#line 551
      return ((_Bool)1);
    }
    switch_default: /* CIL Label */ 
#line 555
    saw_amp = (_Bool)0;
    switch_break: /* CIL Label */ ;
    }
#line 539
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  return ((_Bool)0);
}
}
#line 575 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static char *local_quote_string(char const   *file ) 
{ 
  char const   *from ;
  char *newname ;
  char *to ;
  char *any ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 581
  tmp = strpbrk(file, "?#%");
#line 581
  any = tmp;
  }
#line 582
  if (! any) {
    {
#line 583
    tmp___0 = html_quote_string(file);
    }
#line 583
    return (tmp___0);
  }
  {
#line 587
  tmp___1 = strlen(file);
#line 587
  tmp___2 = __builtin_alloca(3UL * tmp___1 + 1UL);
#line 587
  newname = (char *)tmp___2;
#line 587
  to = newname;
#line 588
  from = file;
  }
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! *from) {
#line 588
      goto while_break;
    }
    {
#line 591
    if ((int const   )*from == 37) {
#line 591
      goto case_37;
    }
#line 596
    if ((int const   )*from == 35) {
#line 596
      goto case_35;
    }
#line 601
    if ((int const   )*from == 63) {
#line 601
      goto case_63;
    }
#line 610
    goto switch_default;
    case_37: /* CIL Label */ 
#line 592
    tmp___3 = to;
#line 592
    to ++;
#line 592
    *tmp___3 = (char )'%';
#line 593
    tmp___4 = to;
#line 593
    to ++;
#line 593
    *tmp___4 = (char )'2';
#line 594
    tmp___5 = to;
#line 594
    to ++;
#line 594
    *tmp___5 = (char )'5';
#line 595
    goto switch_break;
    case_35: /* CIL Label */ 
#line 597
    tmp___6 = to;
#line 597
    to ++;
#line 597
    *tmp___6 = (char )'%';
#line 598
    tmp___7 = to;
#line 598
    to ++;
#line 598
    *tmp___7 = (char )'2';
#line 599
    tmp___8 = to;
#line 599
    to ++;
#line 599
    *tmp___8 = (char )'3';
#line 600
    goto switch_break;
    case_63: /* CIL Label */ 
#line 602
    if (opt.html_extension) {
#line 604
      tmp___9 = to;
#line 604
      to ++;
#line 604
      *tmp___9 = (char )'%';
#line 605
      tmp___10 = to;
#line 605
      to ++;
#line 605
      *tmp___10 = (char )'3';
#line 606
      tmp___11 = to;
#line 606
      to ++;
#line 606
      *tmp___11 = (char )'F';
#line 607
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 611
    tmp___12 = to;
#line 611
    to ++;
#line 611
    *tmp___12 = (char )*from;
    switch_break: /* CIL Label */ ;
    }
#line 588
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  *to = (char )'\000';
#line 615
  tmp___13 = html_quote_string((char const   *)newname);
  }
#line 615
  return (tmp___13);
}
}
#line 639 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static _Bool match_except_index(char const   *s1 , char const   *s2 ) 
{ 
  int i ;
  char const   *lng ;
  int tmp ;

  {
#line 646
  i = 0;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (*s1) {
#line 646
      if (*s2) {
#line 646
        if (! ((int const   )*s1 == (int const   )*s2)) {
#line 646
          goto while_break;
        }
      } else {
#line 646
        goto while_break;
      }
    } else {
#line 646
      goto while_break;
    }
#line 646
    s1 ++;
#line 646
    s2 ++;
#line 646
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  if (i == 0) {
#line 652
    return ((_Bool)0);
  }
#line 654
  if (! *s1) {
#line 654
    if (! *s2) {
#line 656
      return ((_Bool)1);
    } else {
#line 654
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 657
  if (*s1) {
#line 657
    if (*s2) {
#line 659
      return ((_Bool)0);
    } else {
#line 657
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 660
  if (*s1) {
#line 662
    lng = s1;
  } else {
#line 665
    lng = s2;
  }
#line 671
  if ((int const   )*lng != 47) {
#line 673
    lng --;
  }
#line 675
  if ((int const   )*lng == 47) {
#line 675
    if ((int const   )*(lng + 1) == 0) {
#line 678
      return ((_Bool)1);
    }
  }
  {
#line 680
  tmp = strcmp(lng, "/index.html");
  }
#line 680
  return ((_Bool )(0 == tmp));
}
}
#line 683 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static int dissociate_urls_from_file_mapper(void *key , void *value , void *arg ) 
{ 
  char *mapping_url ;
  char *mapping_file ;
  char *file ;
  int tmp ;

  {
  {
#line 686
  mapping_url = (char *)key;
#line 687
  mapping_file = (char *)value;
#line 688
  file = (char *)arg;
#line 690
  tmp = strcmp((char const   *)mapping_file, (char const   *)file);
  }
#line 690
  if (0 == tmp) {
    {
#line 692
    hash_table_remove(dl_url_file_map, (void const   *)mapping_url);
#line 693
    checking_free((void *)mapping_url);
#line 694
    checking_free((void *)mapping_file);
    }
  }
#line 698
  return (0);
}
}
#line 703 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static void dissociate_urls_from_file(char const   *file ) 
{ 


  {
  {
#line 707
  hash_table_for_each(dl_url_file_map, & dissociate_urls_from_file_mapper, (void *)((char *)file));
  }
#line 709
  return;
}
}
#line 716 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void register_download(char const   *url , char const   *file ) 
{ 
  char *old_file ;
  char *old_url ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! dl_file_url_map) {
      {
#line 721
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 721
    if (! dl_url_file_map) {
      {
#line 721
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 721
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  tmp___2 = hash_table_get_pair((struct hash_table  const  *)dl_file_url_map, (void const   *)file,
                                (void *)(& old_file), (void *)(& old_url));
  }
#line 728
  if (tmp___2) {
    {
#line 730
    tmp = strcmp(url, (char const   *)old_url);
    }
#line 730
    if (0 == tmp) {
#line 733
      return;
    }
    {
#line 735
    tmp___0 = match_except_index(url, (char const   *)old_url);
    }
#line 735
    if (tmp___0) {
      {
#line 735
      tmp___1 = hash_table_contains((struct hash_table  const  *)dl_url_file_map,
                                    (void const   *)url);
      }
#line 735
      if (! tmp___1) {
#line 741
        goto url_only;
      }
    }
    {
#line 743
    hash_table_remove(dl_file_url_map, (void const   *)file);
#line 744
    checking_free((void *)old_file);
#line 745
    checking_free((void *)old_url);
#line 760
    dissociate_urls_from_file(file);
    }
  }
  {
#line 763
  tmp___3 = checking_strdup(url);
#line 763
  tmp___4 = checking_strdup(file);
#line 763
  hash_table_put(dl_file_url_map, (void const   *)tmp___4, (void *)tmp___3);
  }
  url_only: 
  {
#line 782
  tmp___5 = hash_table_get_pair((struct hash_table  const  *)dl_url_file_map, (void const   *)url,
                                (void *)(& old_url), (void *)(& old_file));
  }
#line 782
  if (tmp___5) {
    {
#line 784
    hash_table_remove(dl_url_file_map, (void const   *)url);
#line 785
    checking_free((void *)old_url);
#line 786
    checking_free((void *)old_file);
    }
  }
  {
#line 789
  tmp___6 = checking_strdup(file);
#line 789
  tmp___7 = checking_strdup(url);
#line 789
  hash_table_put(dl_url_file_map, (void const   *)tmp___7, (void *)tmp___6);
  }
#line 790
  return;
}
}
#line 796 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void register_redirection(char const   *from , char const   *to ) 
{ 
  char *file ;
  void *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (! dl_file_url_map) {
      {
#line 801
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 801
    if (! dl_url_file_map) {
      {
#line 801
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 801
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 803
  tmp = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)to);
#line 803
  file = (char *)tmp;
  }
#line 804
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
    {
#line 804
    __assert_fail("file != NULL", "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c",
                  804U, "register_redirection");
    }
  }
  {
#line 805
  tmp___3 = hash_table_contains((struct hash_table  const  *)dl_url_file_map, (void const   *)from);
  }
#line 805
  if (! tmp___3) {
    {
#line 806
    tmp___1 = checking_strdup((char const   *)file);
#line 806
    tmp___2 = checking_strdup(from);
#line 806
    hash_table_put(dl_url_file_map, (void const   *)tmp___2, (void *)tmp___1);
    }
  }
#line 807
  return;
}
}
#line 811 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void register_delete_file(char const   *file ) 
{ 
  char *old_url ;
  char *old_file ;
  int tmp ;

  {
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! dl_file_url_map) {
      {
#line 816
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 816
    if (! dl_url_file_map) {
      {
#line 816
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 816
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  tmp = hash_table_get_pair((struct hash_table  const  *)dl_file_url_map, (void const   *)file,
                            (void *)(& old_file), (void *)(& old_url));
  }
#line 818
  if (! tmp) {
#line 819
    return;
  }
  {
#line 821
  hash_table_remove(dl_file_url_map, (void const   *)file);
#line 822
  checking_free((void *)old_file);
#line 823
  checking_free((void *)old_url);
#line 824
  dissociate_urls_from_file(file);
  }
#line 825
  return;
}
}
#line 829 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void register_html(char const   *url , char const   *file ) 
{ 


  {
#line 832
  if (! downloaded_html_set) {
    {
#line 833
    downloaded_html_set = make_string_hash_table(0);
    }
  }
  {
#line 834
  string_set_add(downloaded_html_set, file);
  }
#line 835
  return;
}
}
#line 837
static void downloaded_files_free(void) ;
#line 841 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
void convert_cleanup(void) 
{ 


  {
#line 844
  if (dl_file_url_map) {
    {
#line 846
    free_keys_and_values(dl_file_url_map);
#line 847
    hash_table_destroy(dl_file_url_map);
#line 848
    dl_file_url_map = (struct hash_table *)((void *)0);
    }
  }
#line 850
  if (dl_url_file_map) {
    {
#line 852
    free_keys_and_values(dl_url_file_map);
#line 853
    hash_table_destroy(dl_url_file_map);
#line 854
    dl_url_file_map = (struct hash_table *)((void *)0);
    }
  }
#line 856
  if (downloaded_html_set) {
    {
#line 857
    string_set_free(downloaded_html_set);
    }
  }
  {
#line 858
  downloaded_files_free();
  }
#line 859
  if (converted_files) {
    {
#line 860
    string_set_free(converted_files);
    }
  }
#line 861
  return;
}
}
#line 871 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static struct hash_table *downloaded_files_hash  ;
#line 881
static downloaded_file_t *downloaded_mode_to_ptr(downloaded_file_t mode ) ;
#line 881 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static downloaded_file_t v1  =    (downloaded_file_t )0;
#line 881 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static downloaded_file_t v2  =    (downloaded_file_t )1;
#line 881 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static downloaded_file_t v3  =    (downloaded_file_t )2;
#line 881 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static downloaded_file_t v4  =    (downloaded_file_t )3;
#line 878 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static downloaded_file_t *downloaded_mode_to_ptr(downloaded_file_t mode ) 
{ 


  {
  {
#line 889
  if ((unsigned int )mode == 0U) {
#line 889
    goto case_0;
  }
#line 891
  if ((unsigned int )mode == 1U) {
#line 891
    goto case_1;
  }
#line 893
  if ((unsigned int )mode == 2U) {
#line 893
    goto case_2;
  }
#line 895
  if ((unsigned int )mode == 3U) {
#line 895
    goto case_3;
  }
#line 887
  goto switch_break;
  case_0: /* CIL Label */ 
#line 890
  return (& v1);
  case_1: /* CIL Label */ 
#line 892
  return (& v2);
  case_2: /* CIL Label */ 
#line 894
  return (& v3);
  case_3: /* CIL Label */ 
#line 896
  return (& v4);
  switch_break: /* CIL Label */ ;
  }
#line 898
  return ((downloaded_file_t *)((void *)0));
}
}
#line 916 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
downloaded_file_t downloaded_file(downloaded_file_t mode , char const   *file ) 
{ 
  downloaded_file_t *ptr ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 921
  if ((unsigned int )mode == 3U) {
#line 923
    if (! downloaded_files_hash) {
#line 924
      return ((downloaded_file_t )0);
    }
    {
#line 925
    tmp = hash_table_get((struct hash_table  const  *)downloaded_files_hash, (void const   *)file);
#line 925
    ptr = (downloaded_file_t *)tmp;
    }
#line 926
    if (! ptr) {
#line 927
      return ((downloaded_file_t )0);
    }
#line 928
    return (*ptr);
  }
#line 931
  if (! downloaded_files_hash) {
    {
#line 932
    downloaded_files_hash = make_string_hash_table(0);
    }
  }
  {
#line 934
  tmp___0 = hash_table_get((struct hash_table  const  *)downloaded_files_hash, (void const   *)file);
#line 934
  ptr = (downloaded_file_t *)tmp___0;
  }
#line 935
  if (ptr) {
#line 936
    return (*ptr);
  }
  {
#line 938
  ptr = downloaded_mode_to_ptr(mode);
#line 939
  tmp___1 = checking_strdup(file);
#line 939
  hash_table_put(downloaded_files_hash, (void const   *)tmp___1, (void *)ptr);
  }
#line 941
  return ((downloaded_file_t )0);
}
}
#line 944 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
static void downloaded_files_free(void) 
{ 
  hash_table_iterator iter ;
  int tmp ;

  {
#line 947
  if (downloaded_files_hash) {
    {
#line 950
    hash_table_iterate(downloaded_files_hash, & iter);
    }
    {
#line 950
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 950
      tmp = hash_table_iter_next(& iter);
      }
#line 950
      if (! tmp) {
#line 950
        goto while_break;
      }
      {
#line 953
      checking_free(iter.key);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 954
    hash_table_destroy(downloaded_files_hash);
#line 955
    downloaded_files_hash = (struct hash_table *)((void *)0);
    }
  }
#line 957
  return;
}
}
#line 970 "/home/khheo/project/benchmark/wget-1.11.4/src/convert.c"
char *html_quote_string(char const   *s ) 
{ 
  char const   *b ;
  char *p___0 ;
  char *res___0 ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 973
  b = s;
#line 978
  i = 0;
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 978
    if (! *s) {
#line 978
      goto while_break;
    }
#line 980
    if ((int const   )*s == 38) {
#line 981
      i += 4;
    } else
#line 982
    if ((int const   )*s == 60) {
#line 983
      i += 3;
    } else
#line 982
    if ((int const   )*s == 62) {
#line 983
      i += 3;
    } else
#line 984
    if ((int const   )*s == 34) {
#line 985
      i += 5;
    } else
#line 986
    if ((int const   )*s == 32) {
#line 987
      i += 4;
    }
#line 978
    s ++;
#line 978
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 989
  tmp = checking_malloc((size_t )(i + 1));
#line 989
  res___0 = (char *)tmp;
#line 990
  s = b;
#line 991
  p___0 = res___0;
  }
  {
#line 991
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 991
    if (! *s) {
#line 991
      goto while_break___0;
    }
    {
#line 995
    if ((int const   )*s == 38) {
#line 995
      goto case_38;
    }
#line 1002
    if ((int const   )*s == 62) {
#line 1002
      goto case_62;
    }
#line 1002
    if ((int const   )*s == 60) {
#line 1002
      goto case_62;
    }
#line 1008
    if ((int const   )*s == 34) {
#line 1008
      goto case_34;
    }
#line 1016
    if ((int const   )*s == 32) {
#line 1016
      goto case_32;
    }
#line 1023
    goto switch_default;
    case_38: /* CIL Label */ 
#line 996
    tmp___0 = p___0;
#line 996
    p___0 ++;
#line 996
    *tmp___0 = (char )'&';
#line 997
    tmp___1 = p___0;
#line 997
    p___0 ++;
#line 997
    *tmp___1 = (char )'a';
#line 998
    tmp___2 = p___0;
#line 998
    p___0 ++;
#line 998
    *tmp___2 = (char )'m';
#line 999
    tmp___3 = p___0;
#line 999
    p___0 ++;
#line 999
    *tmp___3 = (char )'p';
#line 1000
    tmp___4 = p___0;
#line 1000
    p___0 ++;
#line 1000
    *tmp___4 = (char )';';
#line 1001
    goto switch_break;
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
#line 1003
    tmp___5 = p___0;
#line 1003
    p___0 ++;
#line 1003
    *tmp___5 = (char )'&';
#line 1004
    tmp___6 = p___0;
#line 1004
    p___0 ++;
#line 1004
    if ((int const   )*s == 60) {
#line 1004
      *tmp___6 = (char )'l';
    } else {
#line 1004
      *tmp___6 = (char )'g';
    }
#line 1005
    tmp___7 = p___0;
#line 1005
    p___0 ++;
#line 1005
    *tmp___7 = (char )'t';
#line 1006
    tmp___8 = p___0;
#line 1006
    p___0 ++;
#line 1006
    *tmp___8 = (char )';';
#line 1007
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1009
    tmp___9 = p___0;
#line 1009
    p___0 ++;
#line 1009
    *tmp___9 = (char )'&';
#line 1010
    tmp___10 = p___0;
#line 1010
    p___0 ++;
#line 1010
    *tmp___10 = (char )'q';
#line 1011
    tmp___11 = p___0;
#line 1011
    p___0 ++;
#line 1011
    *tmp___11 = (char )'u';
#line 1012
    tmp___12 = p___0;
#line 1012
    p___0 ++;
#line 1012
    *tmp___12 = (char )'o';
#line 1013
    tmp___13 = p___0;
#line 1013
    p___0 ++;
#line 1013
    *tmp___13 = (char )'t';
#line 1014
    tmp___14 = p___0;
#line 1014
    p___0 ++;
#line 1014
    *tmp___14 = (char )';';
#line 1015
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1017
    tmp___15 = p___0;
#line 1017
    p___0 ++;
#line 1017
    *tmp___15 = (char )'&';
#line 1018
    tmp___16 = p___0;
#line 1018
    p___0 ++;
#line 1018
    *tmp___16 = (char )'#';
#line 1019
    tmp___17 = p___0;
#line 1019
    p___0 ++;
#line 1019
    *tmp___17 = (char )'3';
#line 1020
    tmp___18 = p___0;
#line 1020
    p___0 ++;
#line 1020
    *tmp___18 = (char )'2';
#line 1021
    tmp___19 = p___0;
#line 1021
    p___0 ++;
#line 1021
    *tmp___19 = (char )';';
#line 1022
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1024
    tmp___20 = p___0;
#line 1024
    p___0 ++;
#line 1024
    *tmp___20 = (char )*s;
    switch_break: /* CIL Label */ ;
    }
#line 991
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1027
  *p___0 = (char )'\000';
#line 1028
  return (res___0);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 126
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 145
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 232
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 77 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static void sockaddr_set_data(struct sockaddr *sa , ip_address const   *ip___0 , int port ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 82
  if (ip___0->family == 2) {
#line 82
    goto case_2;
  }
#line 92
  if (ip___0->family == 10) {
#line 92
    goto case_10;
  }
#line 105
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 84
  sin = (struct sockaddr_in *)sa;
#line 85
  memset((void *)sin, '\000', sizeof(*sin));
#line 86
  sin->sin_family = (sa_family_t )2;
#line 87
  sin->sin_port = htons((uint16_t )port);
#line 88
  sin->sin_addr = (struct in_addr )ip___0->data.d4;
  }
#line 89
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 94
  sin6 = (struct sockaddr_in6 *)sa;
#line 95
  memset((void *)sin6, '\000', sizeof(*sin6));
#line 96
  sin6->sin6_family = (sa_family_t )10;
#line 97
  sin6->sin6_port = htons((uint16_t )port);
#line 98
  sin6->sin6_addr = (struct in6_addr )ip___0->data.d6;
#line 100
  sin6->sin6_scope_id = (uint32_t )ip___0->ipv6_scope;
  }
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 106
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 114 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static void sockaddr_get_data(struct sockaddr  const  *sa , ip_address *ip___0 , int *port ) 
{ 
  struct sockaddr_in *sin ;
  uint16_t tmp ;
  struct sockaddr_in6 *sin6 ;
  uint16_t tmp___0 ;

  {
  {
#line 119
  if ((int const   )sa->sa_family == 2) {
#line 119
    goto case_2;
  }
#line 132
  if ((int const   )sa->sa_family == 10) {
#line 132
    goto case_10;
  }
#line 148
  goto switch_default;
  case_2: /* CIL Label */ 
#line 121
  sin = (struct sockaddr_in *)sa;
#line 122
  if (ip___0) {
#line 124
    ip___0->family = 2;
#line 125
    ip___0->data.d4 = sin->sin_addr;
  }
#line 127
  if (port) {
    {
#line 128
    tmp = ntohs(sin->sin_port);
#line 128
    *port = (int )tmp;
    }
  }
#line 129
  goto switch_break;
  case_10: /* CIL Label */ 
#line 134
  sin6 = (struct sockaddr_in6 *)sa;
#line 135
  if (ip___0) {
#line 137
    ip___0->family = 10;
#line 138
    ip___0->data.d6 = sin6->sin6_addr;
#line 140
    ip___0->ipv6_scope = (int )sin6->sin6_scope_id;
  }
#line 143
  if (port) {
    {
#line 144
    tmp___0 = ntohs(sin6->sin6_port);
#line 144
    *port = (int )tmp___0;
    }
  }
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 149
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 156 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static socklen_t sockaddr_size(struct sockaddr  const  *sa ) 
{ 


  {
  {
#line 161
  if ((int const   )sa->sa_family == 2) {
#line 161
    goto case_2;
  }
#line 164
  if ((int const   )sa->sa_family == 10) {
#line 164
    goto case_10;
  }
#line 167
  goto switch_default;
  case_2: /* CIL Label */ 
#line 162
  return ((socklen_t )sizeof(struct sockaddr_in ));
  case_10: /* CIL Label */ 
#line 165
  return ((socklen_t )sizeof(struct sockaddr_in6 ));
  switch_default: /* CIL Label */ 
  {
#line 168
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 185 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static _Bool called  ;
#line 185 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static _Bool should_bind  ;
#line 186 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static ip_address ip  ;
#line 178 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static _Bool resolve_bind_address(struct sockaddr *sa ) 
{ 
  struct address_list *al ;
  char *tmp ;
  ip_address const   *tmp___0 ;

  {
#line 187
  if (called) {
#line 189
    if (should_bind) {
      {
#line 190
      sockaddr_set_data(sa, (ip_address const   *)(& ip), 0);
      }
    }
#line 191
    return (should_bind);
  }
  {
#line 193
  called = (_Bool)1;
#line 195
  al = lookup_host((char const   *)opt.bind_address, 3);
  }
#line 196
  if (! al) {
    {
#line 199
    tmp = gettext("%s: unable to resolve bind address `%s\'; disabling bind.\n");
#line 199
    logprintf((enum log_options )1, (char const   *)tmp, program_name, opt.bind_address);
#line 202
    should_bind = (_Bool)0;
    }
#line 203
    return ((_Bool)0);
  }
  {
#line 209
  tmp___0 = address_list_address_at((struct address_list  const  *)al, 0);
#line 209
  ip = (ip_address )*tmp___0;
#line 210
  address_list_release(al);
#line 212
  sockaddr_set_data(sa, (ip_address const   *)(& ip), 0);
#line 213
  should_bind = (_Bool)1;
  }
#line 214
  return ((_Bool)1);
}
}
#line 224 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static void connect_with_timeout_callback(void *arg ) 
{ 
  struct cwt_context *ctx ;

  {
  {
#line 227
  ctx = (struct cwt_context *)arg;
#line 228
  ctx->result = connect(ctx->fd, (struct sockaddr  const  */* __restrict  */)ctx->addr,
                        ctx->addrlen);
  }
#line 229
  return;
}
}
#line 235 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int connect_with_timeout(int fd , struct sockaddr  const  *addr , socklen_t addrlen ,
                                double timeout ) 
{ 
  struct cwt_context ctx ;
  int *tmp ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 240
  ctx.fd = fd;
#line 241
  ctx.addr = addr;
#line 242
  ctx.addrlen = addrlen;
#line 244
  tmp___0 = run_with_timeout(timeout, & connect_with_timeout_callback, (void *)(& ctx));
  }
#line 244
  if (tmp___0) {
    {
#line 246
    tmp = __errno_location();
#line 246
    *tmp = 110;
    }
#line 247
    return (-1);
  }
#line 249
  if (ctx.result == -1) {
    {
#line 249
    tmp___2 = __errno_location();
    }
#line 249
    if (*tmp___2 == 4) {
      {
#line 250
      tmp___1 = __errno_location();
#line 250
      *tmp___1 = 110;
      }
    }
  }
#line 251
  return (ctx.result);
}
}
#line 259 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int connect_to_ip(ip_address const   *ip___0 , int port , char const   *print ) 
{ 
  struct sockaddr_storage ss ;
  struct sockaddr *sa ;
  int sock ;
  char const   *txt_addr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int on ;
  int err ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int bufsize ;
  struct sockaddr_storage bind_ss ;
  struct sockaddr *bind_sa ;
  socklen_t tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  socklen_t tmp___12 ;
  int tmp___13 ;
  char *tmp___15 ;
  long tmp___16 ;
  int save_errno ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;

  {
#line 263
  sa = (struct sockaddr *)(& ss);
#line 268
  if (print) {
    {
#line 270
    tmp = print_address(ip___0);
#line 270
    txt_addr = tmp;
    }
#line 271
    if (print) {
      {
#line 271
      tmp___3 = strcmp(print, txt_addr);
      }
#line 271
      if (0 != tmp___3) {
        {
#line 272
        tmp___0 = escnonprint(print);
#line 272
        tmp___1 = gettext("Connecting to %s|%s|:%d... ");
#line 272
        logprintf((enum log_options )0, (char const   *)tmp___1, tmp___0, txt_addr,
                  port);
        }
      } else {
        {
#line 275
        tmp___2 = gettext("Connecting to %s:%d... ");
#line 275
        logprintf((enum log_options )0, (char const   *)tmp___2, txt_addr, port);
        }
      }
    } else {
      {
#line 275
      tmp___2 = gettext("Connecting to %s:%d... ");
#line 275
      logprintf((enum log_options )0, (char const   *)tmp___2, txt_addr, port);
      }
    }
  }
  {
#line 279
  sockaddr_set_data(sa, ip___0, port);
#line 282
  sock = socket((int )sa->sa_family, 1, 0);
  }
#line 283
  if (sock < 0) {
#line 284
    goto err;
  }
#line 287
  if (opt.ipv6_only) {
    {
#line 288
    on = 1;
#line 290
    tmp___4 = setsockopt(sock, 41, 26, (void const   *)(& on), (socklen_t )sizeof(on));
#line 290
    err = tmp___4;
#line 291
    tmp___8 = __builtin_expect((long )opt.debug, 0L);
    }
#line 291
    if (tmp___8) {
#line 292
      if (err < 0) {
        {
#line 293
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 293
          tmp___7 = __builtin_expect((long )opt.debug, 0L);
          }
#line 293
          if (tmp___7) {
            {
#line 293
            tmp___5 = __errno_location();
#line 293
            tmp___6 = strerror(*tmp___5);
#line 293
            debug_logprintf("Failed setting IPV6_V6ONLY: %s", tmp___6);
            }
          }
#line 293
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 301
  if (opt.limit_rate) {
#line 301
    if (opt.limit_rate < 8192L) {
#line 303
      bufsize = (int )opt.limit_rate;
#line 304
      if (bufsize < 512) {
#line 305
        bufsize = 512;
      }
      {
#line 307
      setsockopt(sock, 1, 8, (void const   *)((void *)(& bufsize)), (socklen_t )sizeof(bufsize));
      }
    }
  }
#line 314
  if (opt.bind_address) {
    {
#line 319
    bind_sa = (struct sockaddr *)(& bind_ss);
#line 320
    tmp___11 = resolve_bind_address(bind_sa);
    }
#line 320
    if (tmp___11) {
      {
#line 322
      tmp___9 = sockaddr_size((struct sockaddr  const  *)bind_sa);
#line 322
      tmp___10 = bind(sock, (struct sockaddr  const  */* __restrict  */)bind_sa, tmp___9);
      }
#line 322
      if (tmp___10 < 0) {
#line 323
        goto err;
      }
    }
  }
  {
#line 328
  tmp___12 = sockaddr_size((struct sockaddr  const  *)sa);
#line 328
  tmp___13 = connect_with_timeout(sock, (struct sockaddr  const  *)sa, tmp___12, opt.connect_timeout);
  }
#line 328
  if (tmp___13 < 0) {
#line 330
    goto err;
  }
#line 333
  if (! (sock >= 0)) {
    {
#line 333
    __assert_fail("sock >= 0", "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c",
                  333U, "connect_to_ip");
    }
  }
#line 334
  if (print) {
    {
#line 335
    tmp___15 = gettext("connected.\n");
#line 335
    logprintf((enum log_options )0, (char const   *)tmp___15);
    }
  }
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 336
    tmp___16 = __builtin_expect((long )opt.debug, 0L);
    }
#line 336
    if (tmp___16) {
      {
#line 336
      debug_logprintf("Created socket %d.\n", sock);
      }
    }
#line 336
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 337
  return (sock);
  err: 
  {
#line 343
  tmp___17 = __errno_location();
#line 343
  save_errno = *tmp___17;
  }
#line 344
  if (sock >= 0) {
    {
#line 345
    fd_close(sock);
    }
  }
#line 346
  if (print) {
    {
#line 347
    tmp___18 = __errno_location();
#line 347
    tmp___19 = strerror(*tmp___18);
#line 347
    tmp___20 = gettext("failed: %s.\n");
#line 347
    logprintf((enum log_options )0, (char const   *)tmp___20, tmp___19);
    }
  }
  {
#line 348
  tmp___21 = __errno_location();
#line 348
  *tmp___21 = save_errno;
  }
#line 349
  return (-1);
}
}
#line 359 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int connect_to_host(char const   *host , int port ) 
{ 
  int i ;
  int start ;
  int end ;
  int sock ;
  struct address_list *al ;
  struct address_list *tmp ;
  char *tmp___0 ;
  ip_address const   *ip___0 ;
  ip_address const   *tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 365
  tmp = lookup_host(host, 0);
#line 365
  al = tmp;
  }
  retry: 
#line 368
  if (! al) {
    {
#line 370
    tmp___0 = gettext("%s: unable to resolve host address `%s\'\n");
#line 370
    logprintf((enum log_options )1, (char const   *)tmp___0, program_name, host);
    }
#line 373
    return (-100);
  }
  {
#line 376
  address_list_get_bounds((struct address_list  const  *)al, & start, & end);
#line 377
  i = start;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < end)) {
#line 377
      goto while_break;
    }
    {
#line 379
    tmp___1 = address_list_address_at((struct address_list  const  *)al, i);
#line 379
    ip___0 = tmp___1;
#line 380
    sock = connect_to_ip(ip___0, port, host);
    }
#line 381
    if (sock >= 0) {
      {
#line 384
      address_list_set_connected(al);
#line 385
      address_list_release(al);
      }
#line 386
      return (sock);
    }
    {
#line 392
    address_list_set_faulty(al, i);
#line 377
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  tmp___2 = address_list_connected_p((struct address_list  const  *)al);
  }
#line 397
  if (tmp___2) {
    {
#line 401
    address_list_release(al);
#line 402
    al = lookup_host(host, 4);
    }
#line 403
    goto retry;
  }
  {
#line 405
  address_list_release(al);
  }
#line 407
  return (-1);
}
}
#line 423 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int bind_local(ip_address const   *bind_address , int *port ) 
{ 
  int sock ;
  struct sockaddr_storage ss ;
  struct sockaddr *sa ;
  int setopt_val ;
  void *setopt_ptr ;
  socklen_t setopt_size ;
  socklen_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  socklen_t addrlen ;
  socklen_t tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 428
  sa = (struct sockaddr *)(& ss);
#line 431
  setopt_val = 1;
#line 432
  setopt_ptr = (void *)(& setopt_val);
#line 433
  setopt_size = (socklen_t )sizeof(setopt_val);
#line 435
  sock = socket((int )bind_address->family, 1, 0);
  }
#line 436
  if (sock < 0) {
#line 437
    return (-1);
  }
  {
#line 440
  setsockopt(sock, 1, 2, (void const   *)setopt_ptr, setopt_size);
#line 443
  memset((void *)(& ss), '\000', sizeof(ss));
#line 444
  sockaddr_set_data(sa, bind_address, *port);
#line 445
  tmp = sockaddr_size((struct sockaddr  const  *)sa);
#line 445
  tmp___0 = bind(sock, (struct sockaddr  const  */* __restrict  */)sa, tmp);
  }
#line 445
  if (tmp___0 < 0) {
    {
#line 447
    fd_close(sock);
    }
#line 448
    return (-1);
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 450
    tmp___1 = __builtin_expect((long )opt.debug, 0L);
    }
#line 450
    if (tmp___1) {
      {
#line 450
      debug_logprintf("Local socket fd %d bound.\n", sock);
      }
    }
#line 450
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  if (*port == 0) {
    {
#line 455
    tmp___2 = sockaddr_size((struct sockaddr  const  *)sa);
#line 455
    addrlen = tmp___2;
#line 456
    tmp___3 = getsockname(sock, (struct sockaddr */* __restrict  */)sa, (socklen_t */* __restrict  */)(& addrlen));
    }
#line 456
    if (tmp___3 < 0) {
      {
#line 462
      fd_close(sock);
      }
#line 463
      return (-1);
    }
    {
#line 465
    sockaddr_get_data((struct sockaddr  const  *)sa, (ip_address *)((void *)0), port);
    }
    {
#line 466
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 466
      tmp___5 = __builtin_expect((long )opt.debug, 0L);
      }
#line 466
      if (tmp___5) {
        {
#line 466
        tmp___4 = print_address(bind_address);
#line 466
        debug_logprintf("binding to address %s using port %i.\n", tmp___4, *port);
        }
      }
#line 466
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 469
  tmp___6 = listen(sock, 1);
  }
#line 469
  if (tmp___6 < 0) {
    {
#line 471
    fd_close(sock);
    }
#line 472
    return (-1);
  }
#line 474
  return (sock);
}
}
#line 487 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int accept_connection(int local_sock ) 
{ 
  int sock ;
  struct sockaddr_storage ss ;
  struct sockaddr *sa ;
  socklen_t addrlen ;
  int test ;
  int tmp ;
  int *tmp___0 ;
  long tmp___1 ;

  {
#line 495
  sa = (struct sockaddr *)(& ss);
#line 496
  addrlen = (socklen_t )sizeof(ss);
#line 498
  if (opt.connect_timeout) {
    {
#line 500
    tmp = select_fd(local_sock, opt.connect_timeout, 1);
#line 500
    test = tmp;
    }
#line 501
    if (test == 0) {
      {
#line 502
      tmp___0 = __errno_location();
#line 502
      *tmp___0 = 110;
      }
    }
#line 503
    if (test <= 0) {
#line 504
      return (-1);
    }
  }
  {
#line 506
  sock = accept(local_sock, (struct sockaddr */* __restrict  */)sa, (socklen_t */* __restrict  */)(& addrlen));
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 507
    tmp___1 = __builtin_expect((long )opt.debug, 0L);
    }
#line 507
    if (tmp___1) {
      {
#line 507
      debug_logprintf("Accepted client at socket %d.\n", sock);
      }
    }
#line 507
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return (sock);
}
}
#line 518 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
_Bool socket_ip_address(int sock , ip_address *ip___0 , int endpoint ) 
{ 
  struct sockaddr_storage storage ;
  struct sockaddr *sockaddr ;
  socklen_t addrlen ;
  int ret ;
  struct sockaddr_in6 *sa6 ;
  char const   *tmp ;
  long tmp___0 ;
  struct sockaddr_in *sa ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
#line 522
  sockaddr = (struct sockaddr *)(& storage);
#line 523
  addrlen = (socklen_t )sizeof(storage);
#line 526
  if (endpoint == 0) {
    {
#line 527
    ret = getsockname(sock, (struct sockaddr */* __restrict  */)sockaddr, (socklen_t */* __restrict  */)(& addrlen));
    }
  } else
#line 528
  if (endpoint == 1) {
    {
#line 529
    ret = getpeername(sock, (struct sockaddr */* __restrict  */)sockaddr, (socklen_t */* __restrict  */)(& addrlen));
    }
  } else {
    {
#line 531
    abort();
    }
  }
#line 532
  if (ret < 0) {
#line 533
    return ((_Bool)0);
  }
#line 535
  ip___0->family = (int )sockaddr->sa_family;
  {
#line 539
  if ((int )sockaddr->sa_family == 10) {
#line 539
    goto case_10;
  }
#line 550
  if ((int )sockaddr->sa_family == 2) {
#line 550
    goto case_2;
  }
#line 557
  goto switch_default;
  case_10: /* CIL Label */ 
#line 541
  sa6 = (struct sockaddr_in6 *)(& storage);
#line 542
  ip___0->data.d6 = sa6->sin6_addr;
#line 544
  ip___0->ipv6_scope = (int )sa6->sin6_scope_id;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 546
    tmp___0 = __builtin_expect((long )opt.debug, 0L);
    }
#line 546
    if (tmp___0) {
      {
#line 546
      tmp = print_address((ip_address const   *)ip___0);
#line 546
      debug_logprintf("conaddr is: %s\n", tmp);
      }
    }
#line 546
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return ((_Bool)1);
  case_2: /* CIL Label */ 
#line 552
  sa = (struct sockaddr_in *)(& storage);
#line 553
  ip___0->data.d4 = sa->sin_addr;
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 554
    tmp___2 = __builtin_expect((long )opt.debug, 0L);
    }
#line 554
    if (tmp___2) {
      {
#line 554
      tmp___1 = print_address((ip_address const   *)ip___0);
#line 554
      debug_logprintf("conaddr is: %s\n", tmp___1);
      }
    }
#line 554
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 555
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
  {
#line 558
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 567 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
_Bool retryable_socket_connect_error(int err ) 
{ 


  {
#line 573
  if (err == 97) {
#line 593
    return ((_Bool)0);
  } else
#line 573
  if (err == 96) {
#line 593
    return ((_Bool)0);
  } else
#line 573
  if (err == 94) {
#line 593
    return ((_Bool)0);
  } else
#line 573
  if (err == 93) {
#line 593
    return ((_Bool)0);
  } else
#line 573
  if (err == 92) {
#line 593
    return ((_Bool)0);
  } else
#line 573
  if (err == 22) {
#line 593
    return ((_Bool)0);
  }
#line 595
  if (! opt.retry_connrefused) {
#line 596
    if (err == 111) {
#line 604
      return ((_Bool)0);
    } else
#line 596
    if (err == 101) {
#line 604
      return ((_Bool)0);
    } else
#line 596
    if (err == 113) {
#line 604
      return ((_Bool)0);
    }
  }
#line 606
  return ((_Bool)1);
}
}
#line 618 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int select_fd(int fd , double maxtime , int wait_for ) 
{ 
  fd_set fdset ;
  fd_set *rd ;
  fd_set *wr ;
  struct timeval tmout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;

  {
#line 622
  rd = (fd_set *)((void *)0);
#line 622
  wr = (fd_set *)((void *)0);
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.fds_bits[0]): "memory");
#line 626
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  fdset.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 628
  if (wait_for & 1) {
#line 629
    rd = & fdset;
  }
#line 630
  if (wait_for & 2) {
#line 631
    wr = & fdset;
  }
#line 633
  tmout.tv_sec = (long )maxtime;
#line 634
  tmout.tv_usec = (__suseconds_t )((double )1000000 * (maxtime - (double )((long )maxtime)));
  {
#line 636
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 637
    result = select(fd + 1, (fd_set */* __restrict  */)rd, (fd_set */* __restrict  */)wr,
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tmout));
    }
#line 636
    if (result < 0) {
      {
#line 636
      tmp = __errno_location();
      }
#line 636
      if (! (*tmp == 4)) {
#line 636
        goto while_break___0;
      }
    } else {
#line 636
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  return (result);
}
}
#line 654 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
_Bool test_socket_open(int sock ) 
{ 
  fd_set check_set ;
  struct timeval to ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 663
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& check_set.fds_bits[0]): "memory");
#line 663
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 664
  check_set.fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sock % (8 * (int )sizeof(__fd_mask )));
#line 667
  to.tv_sec = (__time_t )0;
#line 668
  to.tv_usec = (__suseconds_t )1;
#line 670
  tmp = select(sock + 1, (fd_set */* __restrict  */)(& check_set), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
  }
#line 670
  if (tmp == 0) {
#line 672
    return ((_Bool)1);
  } else {
#line 676
    return ((_Bool)0);
  }
}
}
#line 692 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int sock_read(int fd , char *buf___4 , int bufsize ) 
{ 
  int res___0 ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 697
    tmp = read(fd, (void *)buf___4, (size_t )bufsize);
#line 697
    res___0 = (int )tmp;
    }
#line 696
    if (res___0 == -1) {
      {
#line 696
      tmp___0 = __errno_location();
      }
#line 696
      if (! (*tmp___0 == 4)) {
#line 696
        goto while_break;
      }
    } else {
#line 696
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return (res___0);
}
}
#line 702 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int sock_write(int fd , char *buf___4 , int bufsize ) 
{ 
  int res___0 ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 707
    tmp = write(fd, (void const   *)buf___4, (size_t )bufsize);
#line 707
    res___0 = (int )tmp;
    }
#line 706
    if (res___0 == -1) {
      {
#line 706
      tmp___0 = __errno_location();
      }
#line 706
      if (! (*tmp___0 == 4)) {
#line 706
        goto while_break;
      }
    } else {
#line 706
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return (res___0);
}
}
#line 712 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int sock_poll(int fd , double timeout , int wait_for ) 
{ 
  int tmp ;

  {
  {
#line 715
  tmp = select_fd(fd, timeout, wait_for);
  }
#line 715
  return (tmp);
}
}
#line 718 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int sock_peek(int fd , char *buf___4 , int bufsize ) 
{ 
  int res___0 ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 723
    tmp = recv(fd, (void *)buf___4, (size_t )bufsize, 2);
#line 723
    res___0 = (int )tmp;
    }
#line 722
    if (res___0 == -1) {
      {
#line 722
      tmp___0 = __errno_location();
      }
#line 722
      if (! (*tmp___0 == 4)) {
#line 722
        goto while_break;
      }
    } else {
#line 722
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  return (res___0);
}
}
#line 728 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static void sock_close(int fd ) 
{ 
  long tmp ;

  {
  {
#line 731
  close(fd);
  }
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 732
    tmp = __builtin_expect((long )opt.debug, 0L);
    }
#line 732
    if (tmp) {
      {
#line 732
      debug_logprintf("Closed fd %d\n", fd);
      }
    }
#line 732
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  return;
}
}
#line 746 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static struct hash_table *transport_map  ;
#line 747 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static unsigned int transport_map_modified_tick  ;
#line 761 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
void fd_register_transport(int fd , struct transport_implementation *imp , void *ctx ) 
{ 
  struct transport_info *info ;
  void *tmp___0 ;

  {
#line 769
  if (! (fd >= 0)) {
    {
#line 769
    __assert_fail("fd >= 0", "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c",
                  769U, "fd_register_transport");
    }
  }
  {
#line 771
  tmp___0 = checking_malloc(sizeof(struct transport_info ));
#line 771
  info = (struct transport_info *)tmp___0;
#line 772
  info->imp = imp;
#line 773
  info->ctx = ctx;
  }
#line 774
  if (! transport_map) {
    {
#line 775
    transport_map = hash_table_new(0, (unsigned long (*)(void const   * ))((void *)0),
                                   (int (*)(void const   * , void const   * ))((void *)0));
    }
  }
  {
#line 776
  hash_table_put(transport_map, (void const   *)((void *)((intptr_t )fd)), (void *)info);
#line 777
  transport_map_modified_tick ++;
  }
#line 778
  return;
}
}
#line 784 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
void *fd_transport_context(int fd ) 
{ 
  struct transport_info *info ;
  void *tmp ;

  {
  {
#line 787
  tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 787
  info = (struct transport_info *)tmp;
  }
#line 788
  return (info->ctx);
}
}
#line 817 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static _Bool poll_internal(int fd , struct transport_info *info , int wf , double timeout ) 
{ 
  int test ;
  int *tmp ;

  {
#line 820
  if (timeout == (double )-1) {
#line 821
    timeout = opt.read_timeout;
  }
#line 822
  if (timeout) {
#line 825
    if (info) {
#line 825
      if ((info->imp)->poller) {
        {
#line 826
        test = (*((info->imp)->poller))(fd, timeout, wf, info->ctx);
        }
      } else {
        {
#line 828
        test = sock_poll(fd, timeout, wf);
        }
      }
    } else {
      {
#line 828
      test = sock_poll(fd, timeout, wf);
      }
    }
#line 829
    if (test == 0) {
      {
#line 830
      tmp = __errno_location();
#line 830
      *tmp = 110;
      }
    }
#line 831
    if (test <= 0) {
#line 832
      return ((_Bool)0);
    }
  }
#line 834
  return ((_Bool)1);
}
}
#line 846 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static struct transport_info *last_info  ;
#line 846 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int last_fd  =    -1;
#line 846 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static unsigned int last_tick  ;
#line 842 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int fd_read(int fd , char *buf___4 , int bufsize , double timeout ) 
{ 
  struct transport_info *info ;
  void *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! transport_map) {
#line 846
      info = (struct transport_info *)((void *)0);
    } else
#line 846
    if (last_fd == fd) {
#line 846
      if (last_tick == transport_map_modified_tick) {
#line 846
        info = last_info;
      } else {
        {
#line 846
        tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 846
        info = (struct transport_info *)tmp;
#line 846
        last_fd = fd;
#line 846
        last_info = info;
#line 846
        last_tick = transport_map_modified_tick;
        }
      }
    } else {
      {
#line 846
      tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 846
      info = (struct transport_info *)tmp;
#line 846
      last_fd = fd;
#line 846
      last_info = info;
#line 846
      last_tick = transport_map_modified_tick;
      }
    }
#line 846
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  tmp___0 = poll_internal(fd, info, 1, timeout);
  }
#line 847
  if (! tmp___0) {
#line 848
    return (-1);
  }
#line 849
  if (info) {
#line 849
    if ((info->imp)->reader) {
      {
#line 850
      tmp___1 = (*((info->imp)->reader))(fd, buf___4, bufsize, info->ctx);
      }
#line 850
      return (tmp___1);
    } else {
      {
#line 852
      tmp___2 = sock_read(fd, buf___4, bufsize);
      }
#line 852
      return (tmp___2);
    }
  } else {
    {
#line 852
    tmp___2 = sock_read(fd, buf___4, bufsize);
    }
#line 852
    return (tmp___2);
  }
}
}
#line 871 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static struct transport_info *last_info___0  ;
#line 871 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int last_fd___0  =    -1;
#line 871 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static unsigned int last_tick___0  ;
#line 867 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int fd_peek(int fd , char *buf___4 , int bufsize , double timeout ) 
{ 
  struct transport_info *info ;
  void *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! transport_map) {
#line 871
      info = (struct transport_info *)((void *)0);
    } else
#line 871
    if (last_fd___0 == fd) {
#line 871
      if (last_tick___0 == transport_map_modified_tick) {
#line 871
        info = last_info___0;
      } else {
        {
#line 871
        tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 871
        info = (struct transport_info *)tmp;
#line 871
        last_fd___0 = fd;
#line 871
        last_info___0 = info;
#line 871
        last_tick___0 = transport_map_modified_tick;
        }
      }
    } else {
      {
#line 871
      tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 871
      info = (struct transport_info *)tmp;
#line 871
      last_fd___0 = fd;
#line 871
      last_info___0 = info;
#line 871
      last_tick___0 = transport_map_modified_tick;
      }
    }
#line 871
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 872
  tmp___0 = poll_internal(fd, info, 1, timeout);
  }
#line 872
  if (! tmp___0) {
#line 873
    return (-1);
  }
#line 874
  if (info) {
#line 874
    if ((info->imp)->peeker) {
      {
#line 875
      tmp___1 = (*((info->imp)->peeker))(fd, buf___4, bufsize, info->ctx);
      }
#line 875
      return (tmp___1);
    } else {
      {
#line 877
      tmp___2 = sock_peek(fd, buf___4, bufsize);
      }
#line 877
      return (tmp___2);
    }
  } else {
    {
#line 877
    tmp___2 = sock_peek(fd, buf___4, bufsize);
    }
#line 877
    return (tmp___2);
  }
}
}
#line 890 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static struct transport_info *last_info___1  ;
#line 890 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static int last_fd___1  =    -1;
#line 890 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
static unsigned int last_tick___1  ;
#line 885 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
int fd_write(int fd , char *buf___4 , int bufsize , double timeout ) 
{ 
  int res___0 ;
  struct transport_info *info ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! transport_map) {
#line 890
      info = (struct transport_info *)((void *)0);
    } else
#line 890
    if (last_fd___1 == fd) {
#line 890
      if (last_tick___1 == transport_map_modified_tick) {
#line 890
        info = last_info___1;
      } else {
        {
#line 890
        tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 890
        info = (struct transport_info *)tmp;
#line 890
        last_fd___1 = fd;
#line 890
        last_info___1 = info;
#line 890
        last_tick___1 = transport_map_modified_tick;
        }
      }
    } else {
      {
#line 890
      tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 890
      info = (struct transport_info *)tmp;
#line 890
      last_fd___1 = fd;
#line 890
      last_info___1 = info;
#line 890
      last_tick___1 = transport_map_modified_tick;
      }
    }
#line 890
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 894
  res___0 = 0;
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 895
    if (! (bufsize > 0)) {
#line 895
      goto while_break___0;
    }
    {
#line 897
    tmp___0 = poll_internal(fd, info, 2, timeout);
    }
#line 897
    if (! tmp___0) {
#line 898
      return (-1);
    }
#line 899
    if (info) {
#line 899
      if ((info->imp)->writer) {
        {
#line 900
        res___0 = (*((info->imp)->writer))(fd, buf___4, bufsize, info->ctx);
        }
      } else {
        {
#line 902
        res___0 = sock_write(fd, buf___4, bufsize);
        }
      }
    } else {
      {
#line 902
      res___0 = sock_write(fd, buf___4, bufsize);
      }
    }
#line 903
    if (res___0 <= 0) {
#line 904
      goto while_break___0;
    }
#line 905
    buf___4 += res___0;
#line 906
    bufsize -= res___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 908
  return (res___0);
}
}
#line 921 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
char const   *fd_errstr(int fd ) 
{ 
  struct transport_info *info ;
  void *tmp ;
  char const   *err ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 926
  info = (struct transport_info *)((void *)0);
#line 927
  if (transport_map) {
    {
#line 928
    tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 928
    info = (struct transport_info *)tmp;
    }
  }
#line 930
  if (info) {
#line 930
    if ((info->imp)->errstr) {
      {
#line 932
      tmp___0 = (*((info->imp)->errstr))(fd, info->ctx);
#line 932
      err = tmp___0;
      }
#line 933
      if (err) {
#line 934
        return (err);
      }
    }
  }
  {
#line 937
  tmp___1 = __errno_location();
#line 937
  tmp___2 = strerror(*tmp___1);
  }
#line 937
  return ((char const   *)tmp___2);
}
}
#line 942 "/home/khheo/project/benchmark/wget-1.11.4/src/connect.c"
void fd_close(int fd ) 
{ 
  struct transport_info *info ;
  void *tmp ;

  {
#line 946
  if (fd < 0) {
#line 947
    return;
  }
#line 951
  info = (struct transport_info *)((void *)0);
#line 952
  if (transport_map) {
    {
#line 953
    tmp = hash_table_get((struct hash_table  const  *)transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 953
    info = (struct transport_info *)tmp;
    }
  }
#line 955
  if (info) {
#line 955
    if ((info->imp)->closer) {
      {
#line 956
      (*((info->imp)->closer))(fd, info->ctx);
      }
    } else {
      {
#line 958
      sock_close(fd);
      }
    }
  } else {
    {
#line 958
    sock_close(fd);
    }
  }
#line 960
  if (info) {
    {
#line 962
    hash_table_remove(transport_map, (void const   *)((void *)((intptr_t )fd)));
#line 963
    checking_free((void *)info);
#line 964
    transport_map_modified_tick ++;
    }
  }
#line 966
  return;
}
}
