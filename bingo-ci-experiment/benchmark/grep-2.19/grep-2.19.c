/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 25 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_168976440 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_168976440 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 169 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 181 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 108 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 203 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 63 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options ;
#line 55 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 723 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 117 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 210 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 43 "/home/khheo/project/benchmark/grep-2.19/lib/memchr2.c"
typedef unsigned long longword;
#line 52 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 275 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.h"
typedef struct I_ring I_ring;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 53 "/home/khheo/project/benchmark/grep-2.19/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/khheo/project/benchmark/grep-2.19/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "/home/khheo/project/benchmark/grep-2.19/lib/hash.h"
typedef struct hash_table Hash_table;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
struct _ftsent ;
#line 74
struct cycle_check_state ;
#line 74 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
struct __anonstruct_FTS_765389224 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
typedef struct __anonstruct_FTS_765389224 FTS;
#line 195 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 195 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 7 "/home/khheo/project/benchmark/grep-2.19/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 743 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 63 "./regex.h"
typedef unsigned long __re_long_size_t;
#line 79 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 423
struct re_dfa_t ;
#line 423 "./regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 488 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 499 "./regex.h"
typedef int regoff_t;
#line 526 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 526 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 47 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.h"
struct exclude ;
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
union __anonunion_v_827610566 {
   char const   *pattern ;
   regex_t re ;
};
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct patopts {
   int options ;
   union __anonunion_v_827610566 v ;
};
#line 88 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 95
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 101 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 101 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 113 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct pattern_buffer {
   struct pattern_buffer *next ;
   char *base ;
};
#line 121 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct pattern_buffer *patbuf ;
};
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 63 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.c"
union __anonunion_tmp_771759453___0 {
   unsigned int align ;
   char buf[4096] ;
};
#line 324 "/usr/include/pcre.h"
struct real_pcre ;
#line 325 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 333
struct real_pcre_jit_stack ;
#line 334 "/usr/include/pcre.h"
typedef struct real_pcre_jit_stack pcre_jit_stack;
#line 376 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 26 "/home/khheo/project/benchmark/grep-2.19/src/kwset.h"
struct kwsmatch {
   size_t index ;
   size_t offset[1] ;
   size_t size[1] ;
};
#line 35
struct kwset ;
#line 36 "/home/khheo/project/benchmark/grep-2.19/src/kwset.h"
typedef struct kwset *kwset_t;
#line 41 "/home/khheo/project/benchmark/grep-2.19/src/search.h"
typedef signed char mb_len_map_t;
#line 823 "/usr/include/stdio.h"
struct obstack ;
#line 146 "../lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 153 "../lib/obstack.h"
union __anonunion_temp_267926141 {
   long tempint ;
   void *tempptr ;
};
#line 153 "../lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_267926141 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 61 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
struct trie ;
#line 61 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
#line 71 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
struct trie {
   size_t accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   int depth ;
   int shift ;
   int maxshift ;
};
#line 84 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
struct kwset {
   struct obstack obstack ;
   ptrdiff_t words ;
   struct trie *trie ;
   int mind ;
   int maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   int *shift ;
   char const   *trans ;
   char gc1 ;
   char gc2 ;
   int gc1help ;
};
#line 173
enum __anonenum_dirs_744895363 {
    L = 0,
    R = 1
} ;
#line 61 "../lib/regex.h"
typedef int __re_idx_t;
#line 62 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 506 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 27 "/home/khheo/project/benchmark/grep-2.19/src/dfa.h"
struct dfamust {
   _Bool exact ;
   _Bool begline ;
   _Bool endline ;
   char *must ;
   struct dfamust *next ;
};
#line 37
struct dfa ;
#line 41 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
struct patterns {
   struct re_pattern_buffer regexbuf ;
   struct re_registers regs ;
};
#line 75
enum __anonenum_mode_962123750 {
    DW_NONE = 0,
    DW_POSIX = 1,
    DW_GNU = 2
} ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
typedef unsigned long wctype_t;
#line 68 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef unsigned int charclass_word;
#line 85 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef charclass_word charclass[8];
#line 163 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef ptrdiff_t token;
#line 258 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 258 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 265 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_position_set_1029076553 {
   position *elems ;
   size_t nelem ;
   size_t alloc ;
};
#line 265 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef struct __anonstruct_position_set_1029076553 position_set;
#line 273 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 273 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 282 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_dfa_state_38687240 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   _Bool has_backref ;
   _Bool has_mbcset ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
};
#line 282 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef struct __anonstruct_dfa_state_38687240 dfa_state;
#line 298 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef ptrdiff_t state_num;
#line 302 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_ranges_154351087 {
   wchar_t beg ;
   wchar_t end ;
};
#line 302 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   _Bool invert ;
   wchar_t *chars ;
   size_t nchars ;
   wctype_t *ch_classes ;
   size_t nch_classes ;
   struct __anonstruct_ranges_154351087 *ranges ;
   size_t nranges ;
   char **equivs ;
   size_t nequivs ;
   char **coll_elems ;
   size_t ncoll_elems ;
};
#line 323 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct dfa {
   charclass *charclasses ;
   size_t cindex ;
   size_t calloc ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   _Bool fast ;
   _Bool multibyte ;
   token utf8_anychar_classes[5] ;
   mbstate_t mbs ;
   int *multibyte_prop ;
   wint_t mbrtowc_cache[256] ;
   struct mb_char_classes *mbcsets ;
   size_t nmbcsets ;
   size_t mbcsets_alloc ;
   struct dfa *superset ;
   dfa_state *states ;
   state_num sindex ;
   size_t salloc ;
   position_set *follows ;
   _Bool searchflag ;
   state_num tralloc ;
   int trcount ;
   state_num **trans ;
   state_num **fails ;
   int *success ;
   state_num *newlines ;
   struct dfamust *musts ;
   position_set mb_follows ;
   int *mb_match_lens ;
};
#line 930 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef int predicate(int  );
#line 936 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 2327 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct __anonstruct_stkalloc_360611398 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 2919
enum __anonenum_status_transit_state_270105753 {
    TRANSIT_STATE_IN_PROGRESS = 0,
    TRANSIT_STATE_DONE = 1,
    TRANSIT_STATE_END_BUFFER = 2
} ;
#line 2919 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef enum __anonenum_status_transit_state_270105753 status_transit_state;
#line 3876
struct must ;
#line 3876 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
typedef struct must must;
#line 3878 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct must {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
   _Bool begline ;
   _Bool endline ;
   must *prev ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 228 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
struct color_cap {
   char const   *name ;
   char const   **var ;
   void (*fct)(void) ;
};
#line 364
enum directories_type {
    READ_DIRECTORIES = 2,
    RECURSE_DIRECTORIES = 3,
    SKIP_DIRECTORIES = 4
} ;
#line 388
enum __anonenum_devices_473526324 {
    READ_COMMAND_LINE_DEVICES = 0,
    READ_DEVICES = 1,
    SKIP_DEVICES = 2
} ;
#line 657
enum __anonenum_binary_files_601436154 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
#line 33 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
enum __anonenum_File_type_103687233 {
    UNKNOWN = 0,
    DOS_BINARY = 1,
    DOS_TEXT = 2,
    UNIX_TEXT = 3
} ;
#line 33 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
typedef enum __anonenum_File_type_103687233 File_type;
#line 37 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
struct dos_map {
   off_t pos ;
   off_t add ;
};
#line 1666 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
struct matcher {
   char const   name[16] ;
   void (*compile)(char const   * , size_t  ) ;
   size_t (*execute)(char const   * , size_t  , size_t * , char const   * ) ;
};
#line 45 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale(unsigned long *x , int scale_factor )
{


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(unsigned long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                    96U, "xstrtoul");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                  96U, "xstrtoul");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
#line 102
  q = s;
#line 103
  ch = (unsigned char )*q;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp___1 = __ctype_b_loc();
    }
#line 104
    if (! ((int const   )*(*tmp___1 + (int )ch) & 8192)) {
#line 104
      goto while_break;
    }
#line 105
    q ++;
#line 105
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if ((int )ch == 45) {
#line 107
    return ((strtol_error )4);
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = 1UL;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */
      case_66: /* CIL Label */
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */
    {
#line 177
    overflow = bkm_scale(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */
    {
#line 181
    overflow = bkm_scale(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */
    {
#line 189
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */
    case_71: /* CIL Label */
    {
#line 194
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */
    case_107: /* CIL Label */
    {
#line 199
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */
    case_77: /* CIL Label */
    {
#line 204
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */
    {
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */
    case_84: /* CIL Label */
    {
#line 213
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */
    {
#line 217
    overflow = bkm_scale(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */
    {
#line 221
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */
    {
#line 225
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 44 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor )
{


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___0(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                    96U, "xstrtol");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                  96U, "xstrtol");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = 1L;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */
      case_66: /* CIL Label */
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */
    {
#line 177
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */
    {
#line 181
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */
    {
#line 189
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */
    case_71: /* CIL Label */
    {
#line 194
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */
    case_107: /* CIL Label */
    {
#line 199
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */
    case_77: /* CIL Label */
    {
#line 204
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */
    {
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */
    case_84: /* CIL Label */
    {
#line 213
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */
    {
#line 217
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */
    {
#line 221
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */
    {
#line 225
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/grep-2.19/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                          char const   *arg , int exit_status )
{
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */
  case_2: /* CIL Label */
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 91 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg )
{


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale___1(intmax_t *x , int scale_factor )
{


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(intmax_t *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___1(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes )
{
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                    96U, "xstrtoimax");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c",
                  96U, "xstrtoimax");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtoimax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = (intmax_t )1;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */
      case_66: /* CIL Label */
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */
    {
#line 177
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */
    {
#line 181
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */
    {
#line 189
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */
    case_71: /* CIL Label */
    {
#line 194
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */
    case_107: /* CIL Label */
    {
#line 199
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */
    case_77: /* CIL Label */
    {
#line 204
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */
    {
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */
    case_84: /* CIL Label */
    {
#line 213
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */
    {
#line 217
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */
    {
#line 221
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */
    {
#line 225
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/grep-2.19/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 44 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 55
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 66
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 55
void xalloc_die(void) ;
#line 57
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 100
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 102 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s )
{
  int tmp ;
  void *tmp___0 ;

  {
#line 105
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 105
    tmp = -1;
  } else {
#line 105
    tmp = -2;
  }
#line 105
  if ((size_t )tmp / s < n) {
    {
#line 106
    xalloc_die();
    }
  }
  {
#line 107
  tmp___0 = xmalloc(n * s);
  }
#line 107
  return (tmp___0);
}
}
#line 113
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 115 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s )
{
  int tmp ;
  void *tmp___0 ;

  {
#line 118
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 118
    tmp = -1;
  } else {
#line 118
    tmp = -2;
  }
#line 118
  if ((size_t )tmp / s < n) {
    {
#line 119
    xalloc_die();
    }
  }
  {
#line 120
  tmp___0 = xrealloc(p, n * s);
  }
#line 120
  return (tmp___0);
}
}
#line 177 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s )
{
  size_t n ;
  void *tmp ;

  {
#line 180
  n = *pn;
#line 182
  if (! p) {
#line 184
    if (! n) {
#line 192
      n = 128UL / s;
#line 193
      n += (size_t )(! n);
    }
  } else {
#line 202
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 203
      xalloc_die();
      }
    }
#line 204
    n += n / 2UL + 1UL;
  }
  {
#line 207
  *pn = n;
#line 208
  tmp = xrealloc(p, n * s);
  }
#line 208
  return (tmp);
}
}
#line 214
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 216
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 216 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
__inline char *xcharalloc(size_t n )
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 219
  if (sizeof(char ) == 1UL) {
    {
#line 219
    tmp = xmalloc(n);
#line 219
    tmp___1 = tmp;
    }
  } else {
    {
#line 219
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 219
    tmp___1 = tmp___0;
    }
  }
#line 219
  return ((char *)tmp___1);
}
}
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp )
{
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/khheo/project/benchmark/grep-2.19/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 59
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 61
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 65
void *x2realloc(void *p , size_t *pn ) ;
#line 66
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 68
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xmalloc(size_t n )
{
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xrealloc(void *p , size_t n )
{


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn )
{
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xzalloc(size_t s )
{
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s )
{
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s )
{
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/grep-2.19/lib/xmalloc.c"
char *xstrdup(char const   *string )
{
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc-die.c"
void xalloc_die(void)
{
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 20 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1728]  =
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191,
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191,
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251,
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20,
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0,
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7,
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27,
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127,
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31,
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195,
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0,
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63,
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127,
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23,
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0,
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255,
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0,
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32,
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255,
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 280 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  =
#line 280
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3,
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7,
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10,
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1,
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1,
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17,
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21,
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 314
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 314 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding )
{
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 318
  if (uc >> 9 < 240U) {
#line 320
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 321
    if (ind >= 0) {
#line 322
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 324
        if (uc > 0U) {
#line 324
          if (uc < 160U) {
#line 325
            return (-1);
          } else {
#line 327
            return (0);
          }
        } else {
#line 327
          return (0);
        }
      }
    }
  } else
#line 330
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 332
    if (uc >= 917760U) {
#line 334
      if (uc <= 917999U) {
#line 335
        return (0);
      }
    } else {
#line 339
      if (uc >= 917536U) {
#line 339
        tmp = uc <= 917631U;
      } else {
#line 339
        tmp = uc == 917505U;
      }
#line 339
      if (tmp) {
#line 340
        return (0);
      }
    }
  }
#line 347
  if (uc >= 4352U) {
#line 347
    if (uc < 4448U) {
#line 361
      return (2);
    } else
#line 347
    if (uc >= 9001U) {
#line 347
      if (uc < 9003U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */
#line 347
    if (uc >= 11904U) {
#line 347
      if (uc < 42192U) {
#line 347
        if (! (uc == 12351U)) {
#line 347
          if (uc >= 19904U) {
#line 347
            if (uc < 19968U) {
#line 347
              goto _L___8;
            } else {
#line 361
              return (2);
            }
          } else {
#line 361
            return (2);
          }
        } else {
#line 347
          goto _L___8;
        }
      } else {
#line 347
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */
#line 347
    if (uc >= 44032U) {
#line 347
      if (uc < 55204U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */
#line 347
    if (uc >= 63744U) {
#line 347
      if (uc < 64256U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */
#line 347
    if (uc >= 65040U) {
#line 347
      if (uc < 65056U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */
#line 347
    if (uc >= 65072U) {
#line 347
      if (uc < 65136U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */
#line 347
    if (uc >= 65280U) {
#line 347
      if (uc < 65377U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */
#line 347
    if (uc >= 65504U) {
#line 347
      if (uc < 65511U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
#line 347
    if (uc >= 131072U) {
#line 347
      if (uc <= 196607U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 347
    if (uc >= 196608U) {
#line 347
      if (uc <= 262143U) {
#line 361
        return (2);
      }
    }
  }
#line 364
  if (uc >= 161U) {
#line 364
    if (uc < 65377U) {
#line 364
      if (uc != 8361U) {
        {
#line 364
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 364
        if (tmp___0) {
#line 366
          return (2);
        }
      }
    }
  }
#line 367
  return (1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2014);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors )
{
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors )
{
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)
{
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc.c"
void emit_bug_reporting_address(void)
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-grep@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU grep", "http://www.gnu.org/software/grep/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  =
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y',
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h',
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s',
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ',
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e',
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f',
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r',
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o',
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a',
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n',
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n',
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 137 "/home/khheo/project/benchmark/grep-2.19/lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 312 "./unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 23 "/home/khheo/project/benchmark/grep-2.19/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n )
{
  int count ;

  {
#line 28
  if (uc < 128U) {
#line 30
    return (-2);
  } else
#line 31
  if (uc < 2048U) {
#line 32
    count = 2;
  } else
#line 33
  if (uc < 65536U) {
#line 35
    if (uc < 55296U) {
#line 36
      count = 3;
    } else
#line 35
    if (uc >= 57344U) {
#line 36
      count = 3;
    } else {
#line 38
      return (-1);
    }
  } else
#line 48
  if (uc < 1114112U) {
#line 49
    count = 4;
  } else {
#line 52
    return (-1);
  }
#line 54
  if (n < count) {
#line 55
    return (-2);
  }
  {
#line 63
  if (count == 4) {
#line 63
    goto case_4;
  }
#line 64
  if (count == 3) {
#line 64
    goto case_3;
  }
#line 65
  if (count == 2) {
#line 65
    goto case_2;
  }
#line 57
  goto switch_break;
  case_4: /* CIL Label */
#line 63
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 63
  uc >>= 6;
#line 63
  uc |= 65536U;
  case_3: /* CIL Label */
#line 64
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 64
  uc >>= 6;
#line 64
  uc |= 2048U;
  case_2: /* CIL Label */
#line 65
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 192U;
#line 66
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 68
  return (count);
}
}
#line 290 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 23 "/home/khheo/project/benchmark/grep-2.19/lib/unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n )
{
  uint8_t c ;

  {
#line 26
  c = (uint8_t )*s;
#line 28
  if ((int )c < 128) {
#line 30
    *puc = (ucs4_t )c;
#line 31
    return (1);
  } else
#line 33
  if ((int )c >= 194) {
#line 35
    if ((int )c < 224) {
#line 37
      if (n >= 2UL) {
#line 39
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 41
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 43
          return (2);
        }
      } else {
#line 50
        *puc = (ucs4_t )65533;
#line 51
        return (-2);
      }
    } else
#line 54
    if ((int )c < 240) {
#line 56
      if (n >= 2UL) {
#line 58
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 58
          if ((int )c >= 225) {
#line 58
            goto _L___0;
          } else
#line 58
          if ((int const   )*(s + 1) >= 160) {
            _L___0: /* CIL Label */
#line 58
            if ((int )c != 237) {
#line 58
              goto _L;
            } else
#line 58
            if ((int const   )*(s + 1) < 160) {
              _L: /* CIL Label */
#line 62
              if (n >= 3UL) {
#line 64
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 66
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 69
                  return (3);
                }
              } else {
#line 76
                *puc = (ucs4_t )65533;
#line 77
                return (-2);
              }
            }
          }
        }
      } else {
#line 85
        *puc = (ucs4_t )65533;
#line 86
        return (-2);
      }
    } else
#line 89
    if ((int )c < 248) {
#line 91
      if (n >= 2UL) {
#line 93
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 93
          if ((int )c >= 241) {
#line 93
            goto _L___2;
          } else
#line 93
          if ((int const   )*(s + 1) >= 144) {
            _L___2: /* CIL Label */
#line 93
            if ((int )c < 244) {
#line 93
              goto _L___1;
            } else
#line 93
            if ((int )c == 244) {
#line 93
              if ((int const   )*(s + 1) < 144) {
                _L___1: /* CIL Label */
#line 100
                if (n >= 3UL) {
#line 102
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 104
                    if (n >= 4UL) {
#line 106
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 108
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 112
                        return (4);
                      }
                    } else {
#line 119
                      *puc = (ucs4_t )65533;
#line 120
                      return (-2);
                    }
                  }
                } else {
#line 128
                  *puc = (ucs4_t )65533;
#line 129
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 137
        *puc = (ucs4_t )65533;
#line 138
        return (-2);
      }
    }
  }
#line 283
  *puc = (ucs4_t )65533;
#line 284
  return (-1);
}
}
#line 33 "/home/khheo/project/benchmark/grep-2.19/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 367
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 246 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
__inline int mb_width_aux(wint_t wc )
{
  int w ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 249
  tmp = wcwidth((wchar_t )wc);
#line 249
  w = tmp;
  }
#line 252
  if (w >= 0) {
#line 252
    tmp___3 = w;
  } else {
    {
#line 252
    tmp___2 = iswcntrl(wc);
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 0;
    } else {
#line 252
      tmp___1 = 1;
    }
#line 252
    tmp___3 = tmp___1;
  }
#line 252
  return (tmp___3);
}
}
#line 267 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
__inline void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc )
{
  _Bool tmp ;

  {
#line 270
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 272
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 273
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 276
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 277
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 278
  tmp = (_Bool )old_mbc->wc_valid;
#line 278
  new_mbc->wc_valid = tmp;
#line 278
  if (tmp) {
#line 279
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 280
  return;
}
}
#line 313
unsigned int const   is_basic_table[8] ;
#line 315 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
__inline _Bool is_basic(char c )
{


  {
#line 318
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 123 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
__inline void mbiter_multi_next(struct mbiter_multi *iter )
{
  int tmp___2 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___6 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___6) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp___2) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h",
                    142U, "mbiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift:
    {
#line 145
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 147
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 150
      iter->cur.bytes = (size_t )1;
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 155
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 158
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 159
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 165
      if (iter->cur.bytes == 0UL) {
#line 168
        iter->cur.bytes = (size_t )1;
#line 169
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 169
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h",
                        169U, "mbiter_multi_next");
          }
        }
#line 170
        if (! (iter->cur.wc == 0)) {
          {
#line 170
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h",
                        170U, "mbiter_multi_next");
          }
        }
      }
      {
#line 172
      iter->cur.wc_valid = (_Bool)1;
#line 176
      tmp___5 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 176
      if (tmp___5) {
#line 177
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 180
  iter->next_done = (_Bool)1;
#line 181
  return;
}
}
#line 183 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
__inline void mbiter_multi_reloc(struct mbiter_multi *iter , ptrdiff_t ptrdiff )
{


  {
#line 186
  iter->cur.ptr += ptrdiff;
#line 187
  iter->limit += ptrdiff;
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
__inline void mbiter_multi_copy(struct mbiter_multi *new_iter , struct mbiter_multi  const  *old_iter )
{
  _Bool tmp ;

  {
#line 193
  new_iter->limit = (char const   *)old_iter->limit;
#line 194
  tmp = (_Bool )old_iter->in_shift;
#line 194
  new_iter->in_shift = tmp;
#line 194
  if (tmp) {
    {
#line 195
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 197
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 198
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 199
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 200
  return;
}
}
#line 223
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/trim.c"
char *trim2(char const   *s , int how )
{
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
            {
#line 78
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 78
            if (! tmp___4) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
            {
#line 84
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 84
            if (! tmp___5) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (tmp___7) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: /* CIL Label */
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
            {
#line 92
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 92
            if (! tmp___6) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: /* CIL Label */
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*p) {
          {
#line 113
          tmp___8 = __ctype_b_loc();
          }
#line 113
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
#line 113
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___9 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 120
    if (how != 1) {
      {
#line 122
      tmp___10 = strlen((char const   *)d);
#line 122
      p = (d + tmp___10) - 1;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 122
          tmp___11 = __ctype_b_loc();
          }
#line 122
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            goto while_break___2;
          }
        } else {
#line 122
          goto while_break___2;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (d);
}
}
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-2.19/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-2.19/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )
{
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 42
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/grep-2.19/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file )
{
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp )
{
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 55
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (insize > 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 72
    res = tmp___0;
    }
#line 76
    if (res == 0xffffffffffffffffUL) {
      {
#line 78
      tmp___2 = __errno_location();
      }
#line 78
      if (! (*tmp___2 == 7)) {
        {
#line 80
        tmp___1 = __errno_location();
        }
#line 80
        if (*tmp___1 == 22) {
#line 81
          goto while_break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  outptr___0 = tmp.buf;
#line 104
  outsize___0 = (size_t )4096;
#line 105
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 105
  res___0 = tmp___3;
  }
#line 107
  if (res___0 == 0xffffffffffffffffUL) {
#line 108
    return (-1);
  }
#line 109
  count += (size_t )(outptr___0 - tmp.buf);
#line 112
  length = count;
#line 116
  if (length == 0UL) {
#line 118
    *lengthp = (size_t )0;
#line 119
    return (0);
  }
#line 121
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 121
    if (*lengthp >= length) {
#line 122
      result = *resultp;
    } else {
#line 121
      goto _L;
    }
  } else {
    _L: /* CIL Label */
    {
#line 125
    tmp___4 = malloc(length);
#line 125
    result = (char *)tmp___4;
    }
#line 126
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 128
      tmp___5 = __errno_location();
#line 128
      *tmp___5 = 12;
      }
#line 129
      return (-1);
    }
  }
  {
#line 138
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 143
  inptr___0 = src;
#line 144
  insize___0 = srclen;
#line 145
  outptr___1 = result;
#line 146
  outsize___1 = length;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (insize___0 > 0UL)) {
#line 148
      goto while_break___0;
    }
    {
#line 150
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 150
    res___1 = tmp___6;
    }
#line 154
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 156
      tmp___7 = __errno_location();
      }
#line 156
      if (*tmp___7 == 22) {
#line 157
        goto while_break___0;
      } else {
#line 159
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 178
  res___2 = tmp___8;
  }
#line 180
  if (res___2 == 0xffffffffffffffffUL) {
#line 181
    goto fail;
  }
#line 184
  if (outsize___1 != 0UL) {
    {
#line 185
    abort();
    }
  }
#line 188
  *resultp = result;
#line 189
  *lengthp = length;
#line 191
  return (0);
  fail:
#line 195
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 197
    tmp___9 = __errno_location();
#line 197
    saved_errno = *tmp___9;
#line 198
    free((void *)result);
#line 199
    tmp___10 = __errno_location();
#line 199
    *tmp___10 = saved_errno;
    }
  }
#line 201
  return (-1);
}
}
#line 206 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd )
{
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used___0 ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___1 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 255
  inptr = src;
#line 256
  tmp = strlen(src);
#line 256
  inbytes_remaining = tmp;
#line 261
  result_size = inbytes_remaining;
#line 263
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 264
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 265
    result_size *= 16UL;
  }
  {
#line 267
  result_size ++;
#line 269
  tmp___0 = malloc(result_size);
#line 269
  result = (char *)tmp___0;
  }
#line 270
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 12;
    }
#line 273
    return ((char *)((void *)0));
  }
  {
#line 281
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 286
  outptr = result;
#line 287
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 293
    res = tmp___2;
    }
#line 297
    if (res == 0xffffffffffffffffUL) {
      {
#line 299
      tmp___7 = __errno_location();
      }
#line 299
      if (*tmp___7 == 22) {
#line 300
        goto while_break;
      } else {
        {
#line 301
        tmp___6 = __errno_location();
        }
#line 301
        if (*tmp___6 == 7) {
#line 303
          used___0 = (size_t )(outptr - result);
#line 304
          newsize = result_size * 2UL;
#line 307
          if (! (newsize > result_size)) {
            {
#line 309
            tmp___3 = __errno_location();
#line 309
            *tmp___3 = 12;
            }
#line 310
            goto failed;
          }
          {
#line 312
          tmp___4 = realloc((void *)result, newsize);
#line 312
          newresult = (char *)tmp___4;
          }
#line 313
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 315
            tmp___5 = __errno_location();
#line 315
            *tmp___5 = 12;
            }
#line 316
            goto failed;
          }
#line 318
          result = newresult;
#line 319
          result_size = newsize;
#line 320
          outptr = result + used___0;
#line 321
          outbytes_remaining = (result_size - 1UL) - used___0;
        } else {
#line 324
          goto failed;
        }
      }
    } else {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 336
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 336
    res___0 = tmp___8;
    }
#line 338
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 340
      tmp___12 = __errno_location();
      }
#line 340
      if (*tmp___12 == 7) {
#line 342
        used___1 = (size_t )(outptr - result);
#line 343
        newsize___0 = result_size * 2UL;
#line 346
        if (! (newsize___0 > result_size)) {
          {
#line 348
          tmp___9 = __errno_location();
#line 348
          *tmp___9 = 12;
          }
#line 349
          goto failed;
        }
        {
#line 351
        tmp___10 = realloc((void *)result, newsize___0);
#line 351
        newresult___0 = (char *)tmp___10;
        }
#line 352
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 354
          tmp___11 = __errno_location();
#line 354
          *tmp___11 = 12;
          }
#line 355
          goto failed;
        }
#line 357
        result = newresult___0;
#line 358
        result_size = newsize___0;
#line 359
        outptr = result + used___1;
#line 360
        outbytes_remaining = (result_size - 1UL) - used___1;
      } else {
#line 363
        goto failed;
      }
    } else {
#line 366
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  tmp___13 = outptr;
#line 371
  outptr ++;
#line 371
  *tmp___13 = (char )'\000';
#line 373
  length = (size_t )(outptr - result);
#line 377
  if (length < result_size) {
    {
#line 379
    tmp___14 = realloc((void *)result, length);
#line 379
    smaller_result = (char *)tmp___14;
    }
#line 381
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 382
      result = smaller_result;
    }
  }
#line 385
  return (result);
  failed:
  {
#line 389
  tmp___15 = __errno_location();
#line 389
  saved_errno = *tmp___15;
#line 390
  free((void *)result);
#line 391
  tmp___16 = __errno_location();
#line 391
  *tmp___16 = saved_errno;
  }
#line 392
  return ((char *)((void *)0));
}
}
#line 400 "/home/khheo/project/benchmark/grep-2.19/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset )
{
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 403
  if ((int const   )*src == 0) {
#line 403
    goto _L;
  } else {
    {
#line 403
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 403
    if (tmp___6 == 0) {
      _L: /* CIL Label */
      {
#line 405
      tmp = strdup(src);
#line 405
      result = tmp;
      }
#line 407
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 408
        tmp___0 = __errno_location();
#line 408
        *tmp___0 = 12;
        }
      }
#line 409
      return (result);
    } else {
      {
#line 427
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 428
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 429
        return ((char *)((void *)0));
      }
      {
#line 431
      result___0 = str_cd_iconv(src, cd);
      }
#line 433
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 436
        tmp___1 = __errno_location();
#line 436
        saved_errno = *tmp___1;
#line 437
        iconv_close(cd);
#line 438
        tmp___2 = __errno_location();
#line 438
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 442
        tmp___5 = iconv_close(cd);
        }
#line 442
        if (tmp___5 < 0) {
          {
#line 446
          tmp___3 = __errno_location();
#line 446
          saved_errno___0 = *tmp___3;
#line 447
          free((void *)result___0);
#line 448
          tmp___4 = __errno_location();
#line 448
          *tmp___4 = saved_errno___0;
          }
#line 449
          return ((char *)((void *)0));
        }
      }
#line 452
      return (result___0);
    }
  }
}
}
#line 30 "/home/khheo/project/benchmark/grep-2.19/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 32
void free_cwd(struct saved_cwd *cwd ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 514
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 22 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 62 "/home/khheo/project/benchmark/grep-2.19/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd )
{
  int tmp ;

  {
  {
#line 65
  cwd->name = (char *)((void *)0);
#line 67
  cwd->desc = open_safer(".", 0);
  }
#line 70
  if (cwd->desc < 0) {
    {
#line 72
    cwd->name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 73
    if (cwd->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
  {
#line 76
  set_cloexec_flag(cwd->desc, (_Bool)1);
  }
#line 77
  return (0);
}
}
#line 84 "/home/khheo/project/benchmark/grep-2.19/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd )
{
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd->desc) {
    {
#line 88
    tmp = fchdir((int )cwd->desc);
    }
#line 88
    return (tmp);
  } else {
    {
#line 90
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 90
    return (tmp___0);
  }
}
}
#line 93 "/home/khheo/project/benchmark/grep-2.19/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd )
{


  {
#line 96
  if (cwd->desc >= 0) {
    {
#line 97
    close(cwd->desc);
    }
  }
  {
#line 98
  free((void *)cwd->name);
  }
#line 99
  return;
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/grep-2.19/lib/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count )
{
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 236 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg ) ;
#line 324
char *quotearg(char const   *arg ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg ) ;
#line 363
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/grep-2.19/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 44
char const   *quote(char const   *arg ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 75 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char const   * const  quoting_style_args[9]  =
#line 75 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c",
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",
        (char const   */* const  */)0};
#line 89 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  =
#line 89
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3,
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 102 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 107 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o )
{
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  e = *tmp;
  }
#line 111
  if (o) {
#line 111
    tmp___0 = o;
  } else {
#line 111
    tmp___0 = & default_quoting_options;
  }
  {
#line 111
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 111
  p = (struct quoting_options *)tmp___1;
#line 113
  tmp___2 = __errno_location();
#line 113
  *tmp___2 = e;
  }
#line 114
  return (p);
}
}
#line 118 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o )
{
  struct quoting_options *tmp ;

  {
#line 121
  if (o) {
#line 121
    tmp = o;
  } else {
#line 121
    tmp = & default_quoting_options;
  }
#line 121
  return (tmp->style);
}
}
#line 126 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s )
{
  struct quoting_options *tmp ;

  {
#line 129
  if (o) {
#line 129
    tmp = o;
  } else {
#line 129
    tmp = & default_quoting_options;
  }
#line 129
  tmp->style = s;
#line 130
  return;
}
}
#line 137 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i )
{
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  if (o) {
#line 141
    tmp = o;
  } else {
#line 141
    tmp = & default_quoting_options;
  }
#line 141
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 153 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i )
{
  int r ;

  {
#line 157
  if (! o) {
#line 158
    o = & default_quoting_options;
  }
#line 159
  r = o->flags;
#line 160
  o->flags = i;
#line 161
  return (r);
}
}
#line 164 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote )
{


  {
#line 168
  if (! o) {
#line 169
    o = & default_quoting_options;
  }
#line 170
  o->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
#line 172
    abort();
    }
  } else
#line 171
  if (! right_quote) {
    {
#line 172
    abort();
    }
  }
#line 173
  o->left_quote = left_quote;
#line 174
  o->right_quote = right_quote;
#line 175
  return;
}
}
#line 178 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style )
{
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s )
{
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote )
{
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___0 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */
  case_7: /* CIL Label */
  case_6: /* CIL Label */
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote("`", quoting_style);
#line 313
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___0 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___7 = i == argsize;
    }
#line 343
    if (tmp___7) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (argsize == 0xffffffffffffffffUL) {
#line 349
          if (1UL < quote_string_len) {
            {
#line 349
            argsize = strlen(arg);
#line 349
            tmp___0 = argsize;
            }
          } else {
#line 349
            tmp___0 = argsize;
          }
        } else {
#line 349
          tmp___0 = argsize;
        }
#line 349
        if (i + quote_string_len <= tmp___0) {
          {
#line 349
          tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___1 == 0) {
#line 359
            if (elide_outer_quotes) {
#line 360
              goto force_outer_quoting_style;
            }
#line 361
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 364
    c = (unsigned char )*(arg + i);
    {
#line 367
    if ((int )c == 0) {
#line 367
      goto case_0___0;
    }
#line 393
    if ((int )c == 63) {
#line 393
      goto case_63;
    }
#line 431
    if ((int )c == 7) {
#line 431
      goto case_7___0;
    }
#line 432
    if ((int )c == 8) {
#line 432
      goto case_8___0;
    }
#line 433
    if ((int )c == 12) {
#line 433
      goto case_12;
    }
#line 434
    if ((int )c == 10) {
#line 434
      goto case_10;
    }
#line 435
    if ((int )c == 13) {
#line 435
      goto case_13;
    }
#line 436
    if ((int )c == 9) {
#line 436
      goto case_9;
    }
#line 437
    if ((int )c == 11) {
#line 437
      goto case_11;
    }
#line 438
    if ((int )c == 92) {
#line 438
      goto case_92;
    }
#line 457
    if ((int )c == 125) {
#line 457
      goto case_125;
    }
#line 457
    if ((int )c == 123) {
#line 457
      goto case_125;
    }
#line 461
    if ((int )c == 126) {
#line 461
      goto case_126;
    }
#line 461
    if ((int )c == 35) {
#line 461
      goto case_126;
    }
#line 473
    if ((int )c == 124) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 96) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 94) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 91) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 62) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 61) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 60) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 59) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 42) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 41) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 40) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 38) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 36) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 34) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 33) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 32) {
#line 473
      goto case_124;
    }
#line 483
    if ((int )c == 39) {
#line 483
      goto case_39___0;
    }
#line 505
    if ((int )c == 122) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 121) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 120) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 119) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 118) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 117) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 116) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 115) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 114) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 113) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 112) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 111) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 110) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 109) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 108) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 107) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 106) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 105) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 104) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 103) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 102) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 101) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 100) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 99) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 98) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 97) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 95) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 93) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 90) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 89) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 88) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 87) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 86) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 85) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 84) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 83) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 82) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 81) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 80) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 79) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 78) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 77) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 76) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 75) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 74) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 73) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 72) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 71) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 70) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 69) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 68) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 67) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 66) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 65) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 58) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 57) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 56) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 55) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 54) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 53) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 52) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 51) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 50) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 49) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 48) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 47) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 46) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 45) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 44) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 43) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 37) {
#line 505
      goto case_122;
    }
#line 518
    goto switch_default___2;
    case_0___0: /* CIL Label */
#line 368
    if (backslash_escapes) {
#line 370
      if (elide_outer_quotes) {
#line 371
        goto force_outer_quoting_style;
      }
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 372
        if (len < buffersize) {
#line 372
          *(buffer___0 + len) = (char )'\\';
        }
#line 372
        len ++;
#line 372
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (i + 1UL < argsize) {
#line 378
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 378
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 380
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 380
              if (len < buffersize) {
#line 380
                *(buffer___0 + len) = (char )'0';
              }
#line 380
              len ++;
#line 380
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 381
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 381
              if (len < buffersize) {
#line 381
                *(buffer___0 + len) = (char )'0';
              }
#line 381
              len ++;
#line 381
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 383
      c = (unsigned char )'0';
    } else
#line 389
    if (flags & 1) {
#line 390
      goto __Cont;
    }
#line 391
    goto switch_break___0;
    case_63: /* CIL Label */
    {
#line 396
    if ((unsigned int )quoting_style == 2U) {
#line 396
      goto case_2___0;
    }
#line 401
    if ((unsigned int )quoting_style == 3U) {
#line 401
      goto case_3___0;
    }
#line 426
    goto switch_default___1;
    case_2___0: /* CIL Label */
#line 397
    if (elide_outer_quotes) {
#line 398
      goto force_outer_quoting_style;
    }
#line 399
    goto switch_break___1;
    case_3___0: /* CIL Label */
#line 402
    if (flags & 4) {
#line 402
      if (i + 2UL < argsize) {
#line 402
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 408
            goto case_62;
          }
#line 421
          goto switch_default___0;
          case_62: /* CIL Label */
          case_61: /* CIL Label */
          case_60: /* CIL Label */
          case_47: /* CIL Label */
          case_45: /* CIL Label */
          case_41: /* CIL Label */
          case_40: /* CIL Label */
          case_39: /* CIL Label */
          case_33: /* CIL Label */
#line 411
          if (elide_outer_quotes) {
#line 412
            goto force_outer_quoting_style;
          }
#line 413
          c = (unsigned char )*(arg + (i + 2UL));
#line 414
          i += 2UL;
          {
#line 415
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 415
            if (len < buffersize) {
#line 415
              *(buffer___0 + len) = (char )'?';
            }
#line 415
            len ++;
#line 415
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 416
            if (len < buffersize) {
#line 416
              *(buffer___0 + len) = (char )'\"';
            }
#line 416
            len ++;
#line 416
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 417
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 417
            if (len < buffersize) {
#line 417
              *(buffer___0 + len) = (char )'\"';
            }
#line 417
            len ++;
#line 417
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 418
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 418
            if (len < buffersize) {
#line 418
              *(buffer___0 + len) = (char )'?';
            }
#line 418
            len ++;
#line 418
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 419
          goto switch_break___2;
          switch_default___0: /* CIL Label */
#line 422
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 424
    goto switch_break___1;
    switch_default___1: /* CIL Label */
#line 427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 429
    goto switch_break___0;
    case_7___0: /* CIL Label */
#line 431
    esc = (unsigned char )'a';
#line 431
    goto c_escape;
    case_8___0: /* CIL Label */
#line 432
    esc = (unsigned char )'b';
#line 432
    goto c_escape;
    case_12: /* CIL Label */
#line 433
    esc = (unsigned char )'f';
#line 433
    goto c_escape;
    case_10: /* CIL Label */
#line 434
    esc = (unsigned char )'n';
#line 434
    goto c_and_shell_escape;
    case_13: /* CIL Label */
#line 435
    esc = (unsigned char )'r';
#line 435
    goto c_and_shell_escape;
    case_9: /* CIL Label */
#line 436
    esc = (unsigned char )'t';
#line 436
    goto c_and_shell_escape;
    case_11: /* CIL Label */
#line 437
    esc = (unsigned char )'v';
#line 437
    goto c_escape;
    case_92: /* CIL Label */
#line 438
    esc = c;
#line 441
    if (backslash_escapes) {
#line 441
      if (elide_outer_quotes) {
#line 441
        if (quote_string_len) {
#line 442
          goto store_c;
        }
      }
    }
    c_and_shell_escape:
#line 445
    if ((unsigned int )quoting_style == 2U) {
#line 445
      if (elide_outer_quotes) {
#line 447
        goto force_outer_quoting_style;
      }
    }
    c_escape:
#line 450
    if (backslash_escapes) {
#line 452
      c = esc;
#line 453
      goto store_escape;
    }
#line 455
    goto switch_break___0;
    case_125: /* CIL Label */
    case_123: /* CIL Label */
#line 458
    if (argsize == 0xffffffffffffffffUL) {
#line 458
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 458
      tmp___2 = argsize == 1UL;
    }
#line 458
    if (! tmp___2) {
#line 459
      goto switch_break___0;
    }
    case_126: /* CIL Label */
    case_35: /* CIL Label */
#line 462
    if (i != 0UL) {
#line 463
      goto switch_break___0;
    }
    case_124: /* CIL Label */
    case_96: /* CIL Label */
    case_94: /* CIL Label */
    case_91: /* CIL Label */
    case_62___0: /* CIL Label */
    case_61___0: /* CIL Label */
    case_60___0: /* CIL Label */
    case_59: /* CIL Label */
    case_42: /* CIL Label */
    case_41___0: /* CIL Label */
    case_40___0: /* CIL Label */
    case_38: /* CIL Label */
    case_36: /* CIL Label */
    case_34: /* CIL Label */
    case_33___0: /* CIL Label */
    case_32: /* CIL Label */
#line 478
    if ((unsigned int )quoting_style == 2U) {
#line 478
      if (elide_outer_quotes) {
#line 480
        goto force_outer_quoting_style;
      }
    }
#line 481
    goto switch_break___0;
    case_39___0: /* CIL Label */
#line 484
    if ((unsigned int )quoting_style == 2U) {
#line 486
      if (elide_outer_quotes) {
#line 487
        goto force_outer_quoting_style;
      }
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (len < buffersize) {
#line 488
          *(buffer___0 + len) = (char )'\'';
        }
#line 488
        len ++;
#line 488
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 489
        if (len < buffersize) {
#line 489
          *(buffer___0 + len) = (char )'\\';
        }
#line 489
        len ++;
#line 489
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___0 + len) = (char )'\'';
        }
#line 490
        len ++;
#line 490
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 492
    goto switch_break___0;
    case_122: /* CIL Label */
    case_121: /* CIL Label */
    case_120: /* CIL Label */
    case_119: /* CIL Label */
    case_118: /* CIL Label */
    case_117: /* CIL Label */
    case_116: /* CIL Label */
    case_115: /* CIL Label */
    case_114: /* CIL Label */
    case_113: /* CIL Label */
    case_112: /* CIL Label */
    case_111: /* CIL Label */
    case_110: /* CIL Label */
    case_109: /* CIL Label */
    case_108: /* CIL Label */
    case_107: /* CIL Label */
    case_106: /* CIL Label */
    case_105: /* CIL Label */
    case_104: /* CIL Label */
    case_103: /* CIL Label */
    case_102: /* CIL Label */
    case_101: /* CIL Label */
    case_100: /* CIL Label */
    case_99: /* CIL Label */
    case_98: /* CIL Label */
    case_97: /* CIL Label */
    case_95: /* CIL Label */
    case_93: /* CIL Label */
    case_90: /* CIL Label */
    case_89: /* CIL Label */
    case_88: /* CIL Label */
    case_87: /* CIL Label */
    case_86: /* CIL Label */
    case_85: /* CIL Label */
    case_84: /* CIL Label */
    case_83: /* CIL Label */
    case_82: /* CIL Label */
    case_81: /* CIL Label */
    case_80: /* CIL Label */
    case_79: /* CIL Label */
    case_78: /* CIL Label */
    case_77: /* CIL Label */
    case_76: /* CIL Label */
    case_75: /* CIL Label */
    case_74: /* CIL Label */
    case_73: /* CIL Label */
    case_72: /* CIL Label */
    case_71: /* CIL Label */
    case_70: /* CIL Label */
    case_69: /* CIL Label */
    case_68: /* CIL Label */
    case_67: /* CIL Label */
    case_66: /* CIL Label */
    case_65: /* CIL Label */
    case_58: /* CIL Label */
    case_57: /* CIL Label */
    case_56: /* CIL Label */
    case_55: /* CIL Label */
    case_54: /* CIL Label */
    case_53: /* CIL Label */
    case_52: /* CIL Label */
    case_51: /* CIL Label */
    case_50: /* CIL Label */
    case_49: /* CIL Label */
    case_48: /* CIL Label */
    case_47___0: /* CIL Label */
    case_46: /* CIL Label */
    case_45___0: /* CIL Label */
    case_44: /* CIL Label */
    case_43: /* CIL Label */
    case_37: /* CIL Label */
#line 516
    goto switch_break___0;
    switch_default___2: /* CIL Label */
#line 530
    if (unibyte_locale) {
      {
#line 532
      m = (size_t )1;
#line 533
      tmp___3 = __ctype_b_loc();
#line 533
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 538
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 540
      m = (size_t )0;
#line 541
      printable = (_Bool)1;
      }
#line 542
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 543
        argsize = strlen(arg);
        }
      }
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 548
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 548
        bytes = tmp___4;
        }
#line 550
        if (bytes == 0UL) {
#line 551
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xffffffffffffffffUL) {
#line 554
          printable = (_Bool)0;
#line 555
          goto while_break___14;
        } else
#line 557
        if (bytes == 0xfffffffffffffffeUL) {
#line 559
          printable = (_Bool)0;
          {
#line 560
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 560
            if (i + m < argsize) {
#line 560
              if (! *(arg + (i + m))) {
#line 560
                goto while_break___15;
              }
            } else {
#line 560
              goto while_break___15;
            }
#line 561
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 562
          goto while_break___14;
        } else {
#line 570
          if (elide_outer_quotes) {
#line 570
            if ((unsigned int )quoting_style == 2U) {
#line 574
              j = (size_t )1;
              {
#line 574
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 574
                if (! (j < bytes)) {
#line 574
                  goto while_break___16;
                }
                {
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 578
                  goto case_124___0;
                }
#line 581
                goto switch_default___3;
                case_124___0: /* CIL Label */
                case_96___0: /* CIL Label */
                case_94___0: /* CIL Label */
                case_92___0: /* CIL Label */
                case_91___0: /* CIL Label */
#line 579
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */
#line 582
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 574
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 586
          tmp___5 = iswprint((wint_t )w);
          }
#line 586
          if (! tmp___5) {
#line 587
            printable = (_Bool)0;
          }
#line 588
          m += bytes;
        }
        {
#line 545
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 545
        if (tmp___6) {
#line 545
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 594
    if (1UL < m) {
#line 594
      goto _L___0;
    } else
#line 594
    if (backslash_escapes) {
#line 594
      if (! printable) {
        _L___0: /* CIL Label */
#line 598
        ilim = i + m;
        {
#line 600
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 602
          if (backslash_escapes) {
#line 602
            if (! printable) {
#line 604
              if (elide_outer_quotes) {
#line 605
                goto force_outer_quoting_style;
              }
              {
#line 606
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 606
                if (len < buffersize) {
#line 606
                  *(buffer___0 + len) = (char )'\\';
                }
#line 606
                len ++;
#line 606
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 607
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 607
                if (len < buffersize) {
#line 607
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 607
                len ++;
#line 607
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 608
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 608
                if (len < buffersize) {
#line 608
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 608
                len ++;
#line 608
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 609
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 602
              goto _L;
            }
          } else
          _L: /* CIL Label */
#line 611
          if (is_right_quote) {
            {
#line 613
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 613
              if (len < buffersize) {
#line 613
                *(buffer___0 + len) = (char )'\\';
              }
#line 613
              len ++;
#line 613
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 614
            is_right_quote = (_Bool)0;
          }
#line 616
          if (ilim <= i + 1UL) {
#line 617
            goto while_break___17;
          }
          {
#line 618
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 618
            if (len < buffersize) {
#line 618
              *(buffer___0 + len) = (char )c;
            }
#line 618
            len ++;
#line 618
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 619
          i ++;
#line 619
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 622
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (backslash_escapes) {
#line 627
      goto _L___3;
    } else
#line 627
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */
#line 627
      if (quote_these_too) {
#line 627
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 627
          goto _L___2;
        }
      } else {
#line 627
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */
#line 627
    if (! is_right_quote) {
#line 631
      goto store_c;
    }
    store_escape:
#line 634
    if (elide_outer_quotes) {
#line 635
      goto force_outer_quoting_style;
    }
    {
#line 636
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 636
      if (len < buffersize) {
#line 636
        *(buffer___0 + len) = (char )'\\';
      }
#line 636
      len ++;
#line 636
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c:
    {
#line 639
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 639
      if (len < buffersize) {
#line 639
        *(buffer___0 + len) = (char )c;
      }
#line 639
      len ++;
#line 639
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 642
  if (len == 0UL) {
#line 642
    if ((unsigned int )quoting_style == 2U) {
#line 642
      if (elide_outer_quotes) {
#line 644
        goto force_outer_quoting_style;
      }
    }
  }
#line 646
  if (quote_string) {
#line 646
    if (! elide_outer_quotes) {
      {
#line 647
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 647
        if (! *quote_string) {
#line 647
          goto while_break___25;
        }
        {
#line 648
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 648
          if (len < buffersize) {
#line 648
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 648
          len ++;
#line 648
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 647
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 650
  if (len < buffersize) {
#line 651
    *(buffer___0 + len) = (char )'\000';
  }
#line 652
  return (len);
  force_outer_quoting_style:
  {
#line 657
  tmp___8 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 657
  return (tmp___8);
}
}
#line 672 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o )
{
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 677
  if (o) {
#line 677
    tmp = o;
  } else {
#line 677
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 677
  p = tmp;
#line 678
  tmp___0 = __errno_location();
#line 678
  e = *tmp___0;
#line 679
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 679
  r = tmp___1;
#line 682
  tmp___2 = __errno_location();
#line 682
  *tmp___2 = e;
  }
#line 683
  return (r);
}
}
#line 687 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o )
{
  char *tmp ;

  {
  {
#line 691
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 691
  return (tmp);
}
}
#line 700 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o )
{
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 704
  if (o) {
#line 704
    tmp = o;
  } else {
#line 704
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 704
  p = tmp;
#line 705
  tmp___0 = __errno_location();
#line 705
  e = *tmp___0;
  }
#line 707
  if (size) {
#line 707
    tmp___1 = 0;
  } else {
#line 707
    tmp___1 = 1;
  }
  {
#line 707
  flags = (int )(p->flags | (int const   )tmp___1);
#line 708
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 708
  bufsize = tmp___2 + 1UL;
#line 712
  tmp___3 = xcharalloc(bufsize);
#line 712
  buf = tmp___3;
#line 713
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 716
  tmp___4 = __errno_location();
#line 716
  *tmp___4 = e;
  }
#line 717
  if (size) {
#line 718
    *size = bufsize - 1UL;
  }
#line 719
  return (buf);
}
}
#line 731 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char slot0[256]  ;
#line 732 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 733 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 734 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 736 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
void quotearg_free(void)
{
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 739
  sv = slotvec;
#line 741
  i = 1U;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! (i < nslots)) {
#line 741
      goto while_break;
    }
    {
#line 742
    free((void *)(sv + i)->val);
#line 741
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 745
    free((void *)(sv + 0)->val);
#line 746
    slotvec0.size = sizeof(slot0);
#line 747
    slotvec0.val = slot0;
    }
  }
#line 749
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 751
    free((void *)sv);
#line 752
    slotvec = & slotvec0;
    }
  }
#line 754
  nslots = 1U;
#line 755
  return;
}
}
#line 765 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options )
{
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 769
  tmp = __errno_location();
#line 769
  e = *tmp;
#line 771
  n0 = (unsigned int )n;
#line 772
  sv = slotvec;
  }
#line 774
  if (n < 0) {
    {
#line 775
    abort();
    }
  }
#line 777
  if (nslots <= n0) {
#line 784
    n1 = (size_t )(n0 + 1U);
#line 785
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 787
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 787
      tmp___0 = -1;
    } else {
#line 787
      tmp___0 = -2;
    }
#line 787
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 788
      xalloc_die();
      }
    }
#line 790
    if (preallocated) {
#line 790
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 790
      tmp___1 = sv;
    }
    {
#line 790
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 790
    sv = (struct slotvec *)tmp___2;
#line 790
    slotvec = sv;
    }
#line 791
    if (preallocated) {
#line 792
      *sv = slotvec0;
    }
    {
#line 793
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 794
    nslots = (unsigned int )n1;
    }
  }
  {
#line 798
  size = (sv + n)->size;
#line 799
  val = (sv + n)->val;
#line 801
  flags = (int )(options->flags | 1);
#line 802
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 802
  qsize = tmp___3;
  }
#line 808
  if (size <= qsize) {
#line 810
    size = qsize + 1UL;
#line 810
    (sv + n)->size = size;
#line 811
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 812
      free((void *)val);
      }
    }
    {
#line 813
    val = xcharalloc(size);
#line 813
    (sv + n)->val = val;
#line 814
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 820
  tmp___4 = __errno_location();
#line 820
  *tmp___4 = e;
  }
#line 821
  return (val);
}
}
#line 825 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg )
{
  char *tmp ;

  {
  {
#line 828
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 828
  return (tmp);
}
}
#line 831 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize )
{
  char *tmp ;

  {
  {
#line 834
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 834
  return (tmp);
}
}
#line 837 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg(char const   *arg )
{
  char *tmp ;

  {
  {
#line 840
  tmp = quotearg_n(0, arg);
  }
#line 840
  return (tmp);
}
}
#line 843 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize )
{
  char *tmp ;

  {
  {
#line 846
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 846
  return (tmp);
}
}
#line 849 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg )
{
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 852
  tmp = quoting_options_from_style(s);
#line 852
  o = tmp;
#line 853
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 853
  return (tmp___0);
}
}
#line 856 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize )
{
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 860
  tmp = quoting_options_from_style(s);
#line 860
  o = tmp;
#line 861
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 861
  return (tmp___0);
}
}
#line 864 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg )
{
  char *tmp ;

  {
  {
#line 867
  tmp = quotearg_n_style(0, s, arg);
  }
#line 867
  return (tmp);
}
}
#line 870 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize )
{
  char *tmp ;

  {
  {
#line 873
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 873
  return (tmp);
}
}
#line 876 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch )
{
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 880
  options = default_quoting_options;
#line 881
  set_char_quoting(& options, ch, 1);
#line 882
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 882
  return (tmp);
}
}
#line 885 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch )
{
  char *tmp ;

  {
  {
#line 888
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 888
  return (tmp);
}
}
#line 891 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_colon(char const   *arg )
{
  char *tmp ;

  {
  {
#line 894
  tmp = quotearg_char(arg, (char )':');
  }
#line 894
  return (tmp);
}
}
#line 897 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize )
{
  char *tmp ;

  {
  {
#line 900
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 900
  return (tmp);
}
}
#line 903 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg )
{
  char *tmp ;

  {
  {
#line 907
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 907
  return (tmp);
}
}
#line 911 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize )
{
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 916
  o = default_quoting_options;
#line 917
  set_custom_quoting(& o, left_quote, right_quote);
#line 918
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 918
  return (tmp);
}
}
#line 921 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg )
{
  char *tmp ;

  {
  {
#line 925
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 925
  return (tmp);
}
}
#line 928 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize )
{
  char *tmp ;

  {
  {
#line 932
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 932
  return (tmp);
}
}
#line 938 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 946 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize )
{
  char *tmp ;

  {
  {
#line 949
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 949
  return ((char const   *)tmp);
}
}
#line 952 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize )
{
  char const   *tmp ;

  {
  {
#line 955
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 955
  return (tmp);
}
}
#line 958 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg )
{
  char const   *tmp ;

  {
  {
#line 961
  tmp = quote_n_mem(n, arg, (size_t )-1);
  }
#line 961
  return (tmp);
}
}
#line 964 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
char const   *quote(char const   *arg )
{
  char const   *tmp ;

  {
  {
#line 967
  tmp = quote_n(0, arg);
  }
#line 967
  return (tmp);
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 92 "/home/khheo/project/benchmark/grep-2.19/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
#line 1109 "./string.h"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
__inline void mbuiter_multi_next(struct mbuiter_multi *iter )
{
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 134
  if (iter->next_done) {
#line 135
    return;
  }
#line 136
  if (iter->in_shift) {
#line 137
    goto with_shift;
  }
  {
#line 139
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 139
  if (tmp___8) {
#line 144
    iter->cur.bytes = (size_t )1;
#line 145
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 146
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 150
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 150
    if (! tmp___2) {
      {
#line 150
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h",
                    150U, "mbuiter_multi_next");
      }
    }
#line 151
    iter->in_shift = (_Bool)1;
    with_shift:
    {
#line 153
    tmp___3 = __ctype_get_mb_cur_max();
#line 153
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 153
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___4, (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 156
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 159
      iter->cur.bytes = (size_t )1;
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 164
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 167
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 168
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 174
      if (iter->cur.bytes == 0UL) {
#line 177
        iter->cur.bytes = (size_t )1;
#line 178
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 178
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h",
                        178U, "mbuiter_multi_next");
          }
        }
#line 179
        if (! (iter->cur.wc == 0)) {
          {
#line 179
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h",
                        179U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 181
      iter->cur.wc_valid = (_Bool)1;
#line 185
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 185
      if (tmp___7) {
#line 186
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 189
  iter->next_done = (_Bool)1;
#line 190
  return;
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
__inline void mbuiter_multi_reloc(struct mbuiter_multi *iter , ptrdiff_t ptrdiff )
{


  {
#line 195
  iter->cur.ptr += ptrdiff;
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
__inline void mbuiter_multi_copy(struct mbuiter_multi *new_iter , struct mbuiter_multi  const  *old_iter )
{
  _Bool tmp ;

  {
#line 201
  tmp = (_Bool )old_iter->in_shift;
#line 201
  new_iter->in_shift = tmp;
#line 201
  if (tmp) {
    {
#line 202
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 204
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 205
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 206
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 207
  return;
}
}
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub )
{
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 157 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
char const   *proper_name(char const   *name )
{
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 161
  tmp = gettext(name);
#line 161
  translation = (char const   *)tmp;
  }
#line 163
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 166
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 166
    if (tmp___7) {
#line 167
      return (translation);
    } else {
#line 171
      if (sizeof(char ) == 1UL) {
        {
#line 171
        tmp___0 = strlen(translation);
#line 171
        tmp___1 = strlen(name);
#line 171
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 171
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 171
        tmp___3 = strlen(translation);
#line 171
        tmp___4 = strlen(name);
#line 171
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 171
        tmp___6 = tmp___5;
        }
      }
      {
#line 171
      result = (char *)tmp___6;
#line 174
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 175
      return ((char const   *)result);
    }
  } else {
#line 179
    return (name);
  }
}
}
#line 187 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 )
{
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;

  {
  {
#line 191
  tmp = gettext(name_ascii);
#line 191
  translation = (char const   *)tmp;
#line 194
  tmp___0 = locale_charset();
#line 194
  locale_code = tmp___0;
#line 195
  alloc_name_converted = (char *)((void *)0);
#line 196
  alloc_name_converted_translit = (char *)((void *)0);
#line 197
  name_converted = (char const   *)((void *)0);
#line 198
  name_converted_translit = (char const   *)((void *)0);
#line 201
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 201
  if (tmp___6 != 0) {
    {
#line 204
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 204
    name_converted = (char const   *)alloc_name_converted;
#line 213
    tmp___1 = strlen(locale_code);
#line 213
    len = tmp___1;
    }
#line 214
    if (sizeof(char ) == 1UL) {
      {
#line 214
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 214
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 214
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 214
      tmp___4 = tmp___3;
      }
    }
    {
#line 214
    locale_code_translit = (char *)tmp___4;
#line 215
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 216
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 218
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 221
    free((void *)locale_code_translit);
    }
#line 223
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 230
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 230
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 231
        free((void *)converted_translit);
        }
      } else {
#line 234
        alloc_name_converted_translit = converted_translit;
#line 234
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 243
    name_converted = name_utf8;
#line 244
    name_converted_translit = name_utf8;
  }
#line 248
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 248
    name = name_converted;
  } else {
#line 248
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 248
      tmp___7 = name_converted_translit;
    } else {
#line 248
      tmp___7 = name_ascii;
    }
#line 248
    name = tmp___7;
  }
  {
#line 255
  tmp___18 = strcmp(translation, name_ascii);
  }
#line 255
  if (tmp___18 != 0) {
    {
#line 258
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 258
    if (tmp___15) {
#line 258
      goto _L;
    } else
#line 258
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 258
      if (tmp___16) {
#line 258
        goto _L;
      } else {
#line 258
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */
#line 258
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 258
      if (tmp___17) {
        _L: /* CIL Label */
#line 264
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 265
          free((void *)alloc_name_converted);
          }
        }
#line 266
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 267
          free((void *)alloc_name_converted_translit);
          }
        }
#line 268
        return (translation);
      } else {
#line 258
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */
#line 273
      if (sizeof(char ) == 1UL) {
        {
#line 273
        tmp___8 = strlen(translation);
#line 273
        tmp___9 = strlen(name);
#line 273
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 273
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 273
        tmp___11 = strlen(translation);
#line 273
        tmp___12 = strlen(name);
#line 273
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 273
        tmp___14 = tmp___13;
        }
      }
      {
#line 273
      result = (char *)tmp___14;
#line 276
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 278
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 279
        free((void *)alloc_name_converted);
        }
      }
#line 280
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 281
        free((void *)alloc_name_converted_translit);
        }
      }
#line 282
      return ((char const   *)result);
    }
  } else {
#line 287
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 287
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 288
        free((void *)alloc_name_converted);
        }
      }
    }
#line 289
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 289
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 291
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 292
    return (name);
  }
}
}
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/khheo/project/benchmark/grep-2.19/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/progname.c"
void set_program_name(char const   *argv0 )
{
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.19/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-2.19/lib/pipe-safer.c"
int pipe_safer(int *fd )
{
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 22 "/home/khheo/project/benchmark/grep-2.19/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-2.19/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/khheo/project/benchmark/grep-2.19/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name )
{
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl-safer.h"
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...)
{
  mode_t mode___0 ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode___0 = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode___0 = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = openat(fd, file, flags, mode___0);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.19/lib/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag
                                                   , ...) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 58 "/home/khheo/project/benchmark/grep-2.19/lib/openat-proc.c"
static int proc_status  =    0;
#line 55 "/home/khheo/project/benchmark/grep-2.19/lib/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file )
{
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;

  {
#line 61
  if (! *file) {
#line 63
    *(buf + 0) = (char )'\000';
#line 64
    return ((char *)buf);
  }
#line 67
  if (! proc_status) {
    {
#line 77
    tmp = open("/proc/self/fd", 67840);
#line 77
    proc_self_fd = tmp;
    }
#line 79
    if (proc_self_fd < 0) {
#line 80
      proc_status = -1;
    } else {
      {
#line 89
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
              proc_self_fd, "../fd");
#line 90
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      }
#line 90
      if (tmp___1) {
#line 90
        proc_status = -1;
      } else {
#line 90
        proc_status = 1;
      }
      {
#line 91
      close(proc_self_fd);
      }
    }
  }
#line 95
  if (proc_status < 0) {
#line 96
    return ((char *)((void *)0));
  } else {
    {
#line 99
    tmp___2 = strlen(file);
#line 99
    bufsize = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
#line 100
    result = (char *)buf;
    }
#line 101
    if (4032UL < bufsize) {
      {
#line 103
      tmp___3 = malloc(bufsize);
#line 103
      result = (char *)tmp___3;
      }
#line 104
      if (! result) {
#line 105
        return ((char *)((void *)0));
      }
    }
    {
#line 107
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
            fd, file);
    }
#line 108
    return (result);
  }
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 48
void openat_restore_fail(int errnum ) ;
#line 49
void openat_save_fail(int errnum ) ;
#line 121
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/grep-2.19/lib/openat-die.c"
void openat_save_fail(int errnum )
{
  char *tmp ;

  {
  {
#line 37
  tmp = gettext("unable to record current working directory");
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
  }
}
}
#line 52 "/home/khheo/project/benchmark/grep-2.19/lib/openat-die.c"
void openat_restore_fail(int errnum )
{
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("failed to return to initial working directory");
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...)
{
  mode_t mode___0 ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode___0 = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode___0 = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = open(file, flags, mode___0);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 27 "/home/khheo/project/benchmark/grep-2.19/lib/memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )
{
  unsigned char const   *char_ptr ;
  void const   *void_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 54
  c1 = (unsigned char )c1_in;
#line 55
  c2 = (unsigned char )c2_in;
#line 57
  if ((int )c1 == (int )c2) {
    {
#line 58
    tmp = memchr(s, (int )c1, n);
    }
#line 58
    return (tmp);
  }
#line 62
  void_ptr = s;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (n > 0UL) {
#line 62
      if (! ((uintptr_t )void_ptr % sizeof(longword ) != 0UL)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 66
    char_ptr = (unsigned char const   *)void_ptr;
#line 67
    if ((int const   )*char_ptr == (int const   )c1) {
#line 68
      return ((void *)void_ptr);
    } else
#line 67
    if ((int const   )*char_ptr == (int const   )c2) {
#line 68
      return ((void *)void_ptr);
    }
#line 69
    void_ptr = (void const   *)(char_ptr + 1);
#line 62
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  longword_ptr = (longword const   *)void_ptr;
#line 81
  repeated_one = (longword )16843009;
#line 82
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 83
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 84
  repeated_c1 |= repeated_c1 << 16;
#line 85
  repeated_c2 |= repeated_c2 << 16;
#line 88
  repeated_one |= (repeated_one << 31) << 1;
#line 89
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 90
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 91
  if (8UL < sizeof(longword )) {
#line 95
    i = (size_t )64;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! (i < sizeof(longword ) * 8UL)) {
#line 95
        goto while_break___0;
      }
#line 97
      repeated_one |= repeated_one << i;
#line 98
      repeated_c1 |= repeated_c1 << i;
#line 99
      repeated_c2 |= repeated_c2 << i;
#line 95
      i *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if (! (n >= sizeof(longword ))) {
#line 140
      goto while_break___1;
    }
#line 142
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 143
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 145
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 148
      goto while_break___1;
    }
#line 149
    longword_ptr ++;
#line 150
    n -= sizeof(longword );
  }
  while_break___1: /* CIL Label */ ;
  }
#line 153
  char_ptr = (unsigned char const   *)longword_ptr;
  {
#line 162
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 162
    if (! (n > 0UL)) {
#line 162
      goto while_break___2;
    }
#line 164
    if ((int const   )*char_ptr == (int const   )c1) {
#line 165
      return ((void *)char_ptr);
    } else
#line 164
    if ((int const   )*char_ptr == (int const   )c2) {
#line 165
      return ((void *)char_ptr);
    }
#line 162
    n --;
#line 162
    char_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 168
  return ((void *)0);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
/* compiler builtin:
   void *__builtin_alloca(unsigned long  ) ;  */
#line 390 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 1044 "./string.h"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 63 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 67
void freea(void *p ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-2.19/lib/str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp )
{
  size_t m ;
  size_t *table ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 42
    tmp___4 = -1;
  } else {
#line 42
    tmp___4 = -2;
  }
#line 42
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 42
    tmp___3 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 42
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___2 = tmp___1;
      }
    }
#line 42
    tmp___3 = tmp___2;
  }
#line 42
  table = (size_t *)tmp___3;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.19/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp )
{
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
      }
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = tmp___4;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 53
  table = (size_t *)table_memory;
#line 60
  j = (size_t )0;
#line 61
  iter.cur.ptr = needle;
#line 61
  iter.in_shift = (_Bool)0;
#line 61
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 61
  iter.next_done = (_Bool)0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    mbuiter_multi_next(& iter);
    }
#line 61
    if (iter.cur.wc_valid) {
#line 61
      if (iter.cur.wc == 0) {
#line 61
        tmp___6 = 0;
      } else {
#line 61
        tmp___6 = 1;
      }
    } else {
#line 61
      tmp___6 = 1;
    }
#line 61
    if (! tmp___6) {
#line 61
      goto while_break;
    }
    {
#line 62
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 61
    iter.cur.ptr += iter.cur.bytes;
#line 61
    iter.next_done = (_Bool)0;
#line 61
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(table + 1) = (size_t )1;
#line 85
  j___0 = (size_t )0;
#line 87
  i = (size_t )2;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < m)) {
#line 87
      goto while_break___0;
    }
#line 93
    b = needle_mbchars + (i - 1UL);
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 100
      if (b->wc_valid) {
#line 100
        if ((needle_mbchars + j___0)->wc_valid) {
#line 100
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 100
          goto _L;
        }
      } else {
        _L: /* CIL Label */
#line 100
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 100
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 100
          if (tmp___7 == 0) {
#line 100
            tmp___8 = 1;
          } else {
#line 100
            tmp___8 = 0;
          }
        } else {
#line 100
          tmp___8 = 0;
        }
#line 100
        tmp___9 = tmp___8;
      }
#line 100
      if (tmp___9) {
#line 103
        j___0 ++;
#line 103
        *(table + i) = i - j___0;
#line 104
        goto while_break___1;
      }
#line 109
      if (j___0 == 0UL) {
#line 112
        *(table + i) = i;
#line 113
        goto while_break___1;
      }
#line 126
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 87
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  *resultp = (char const   *)((void *)0);
#line 139
  j___1 = (size_t )0;
#line 140
  rhaystack.cur.ptr = haystack;
#line 140
  rhaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  rhaystack.next_done = (_Bool)0;
#line 141
  phaystack.cur.ptr = haystack;
#line 141
  phaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  phaystack.next_done = (_Bool)0;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 143
    mbuiter_multi_next(& phaystack);
    }
#line 143
    if (phaystack.cur.wc_valid) {
#line 143
      if (phaystack.cur.wc == 0) {
#line 143
        tmp___15 = 0;
      } else {
#line 143
        tmp___15 = 1;
      }
    } else {
#line 143
      tmp___15 = 1;
    }
#line 143
    if (! tmp___15) {
#line 143
      goto while_break___2;
    }
#line 144
    if ((needle_mbchars + j___1)->wc_valid) {
#line 144
      if (phaystack.cur.wc_valid) {
#line 144
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 144
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */
#line 144
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 144
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 144
        if (tmp___12 == 0) {
#line 144
          tmp___13 = 1;
        } else {
#line 144
          tmp___13 = 0;
        }
      } else {
#line 144
        tmp___13 = 0;
      }
#line 144
      tmp___14 = tmp___13;
    }
#line 144
    if (tmp___14) {
#line 146
      j___1 ++;
#line 147
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 147
      phaystack.next_done = (_Bool)0;
#line 148
      if (j___1 == m) {
#line 151
        *resultp = rhaystack.cur.ptr;
#line 152
        goto while_break___2;
      }
    } else
#line 155
    if (j___1 > 0UL) {
#line 158
      count = *(table + j___1);
#line 159
      j___1 -= count;
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (count > 0UL)) {
#line 160
          goto while_break___3;
        }
        {
#line 162
        mbuiter_multi_next(& rhaystack);
        }
#line 162
        if (rhaystack.cur.wc_valid) {
#line 162
          if (rhaystack.cur.wc == 0) {
#line 162
            tmp___10 = 0;
          } else {
#line 162
            tmp___10 = 1;
          }
        } else {
#line 162
          tmp___10 = 1;
        }
#line 162
        if (! tmp___10) {
          {
#line 163
          abort();
          }
        }
#line 164
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 164
        rhaystack.next_done = (_Bool)0;
#line 160
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 170
      mbuiter_multi_next(& rhaystack);
      }
#line 170
      if (rhaystack.cur.wc_valid) {
#line 170
        if (rhaystack.cur.wc == 0) {
#line 170
          tmp___11 = 0;
        } else {
#line 170
          tmp___11 = 1;
        }
      } else {
#line 170
        tmp___11 = 1;
      }
#line 170
      if (! tmp___11) {
        {
#line 171
        abort();
        }
      }
#line 172
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 172
      rhaystack.next_done = (_Bool)0;
#line 173
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 173
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 177
  freea(memory);
  }
#line 178
  return ((_Bool)1);
}
}
#line 183
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 183 "/home/khheo/project/benchmark/grep-2.19/lib/mbsstr.c"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )
{
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
  {
#line 191
  tmp___17 = __ctype_get_mb_cur_max();
  }
#line 191
  if (tmp___17 > 1UL) {
    {
#line 195
    iter_needle.cur.ptr = needle;
#line 195
    iter_needle.in_shift = (_Bool)0;
#line 195
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 195
    iter_needle.next_done = (_Bool)0;
#line 196
    mbuiter_multi_next(& iter_needle);
    }
#line 196
    if (iter_needle.cur.wc_valid) {
#line 196
      if (iter_needle.cur.wc == 0) {
#line 196
        tmp___12 = 0;
      } else {
#line 196
        tmp___12 = 1;
      }
    } else {
#line 196
      tmp___12 = 1;
    }
#line 196
    if (tmp___12) {
      {
#line 212
      try_kmp = (_Bool)1;
#line 213
      outer_loop_count = (size_t )0;
#line 214
      comparison_count = (size_t )0;
#line 215
      last_ccount = (size_t )0;
#line 220
      iter_needle_last_ccount.cur.ptr = needle;
#line 220
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 220
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 220
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 221
      iter_haystack.cur.ptr = haystack;
#line 221
      iter_haystack.in_shift = (_Bool)0;
#line 221
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 221
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 222
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 224
        mbuiter_multi_next(& iter_haystack);
        }
#line 224
        if (iter_haystack.cur.wc_valid) {
#line 224
          if (iter_haystack.cur.wc == 0) {
#line 224
            tmp = 0;
          } else {
#line 224
            tmp = 1;
          }
        } else {
#line 224
          tmp = 1;
        }
#line 224
        if (! tmp) {
#line 226
          return ((char *)((void *)0));
        }
#line 230
        if (try_kmp) {
#line 230
          if (outer_loop_count >= 10UL) {
#line 230
            if (comparison_count >= 5UL * outer_loop_count) {
#line 236
              count = comparison_count - last_ccount;
              {
#line 237
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 237
                if (count > 0UL) {
                  {
#line 237
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 237
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 237
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 237
                      tmp___0 = 0;
                    } else {
#line 237
                      tmp___0 = 1;
                    }
                  } else {
#line 237
                    tmp___0 = 1;
                  }
#line 237
                  if (! tmp___0) {
#line 237
                    goto while_break___0;
                  }
                } else {
#line 237
                  goto while_break___0;
                }
#line 240
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 240
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 237
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 241
              last_ccount = comparison_count;
#line 242
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 242
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 242
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 242
                  tmp___2 = 0;
                } else {
#line 242
                  tmp___2 = 1;
                }
              } else {
#line 242
                tmp___2 = 1;
              }
#line 242
              if (! tmp___2) {
                {
#line 246
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 246
                success = tmp___1;
                }
#line 249
                if (success) {
#line 250
                  return ((char *)result);
                }
#line 251
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 255
        outer_loop_count ++;
#line 256
        comparison_count ++;
#line 257
        if (iter_haystack.cur.wc_valid) {
#line 257
          if (iter_needle.cur.wc_valid) {
#line 257
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 257
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */
#line 257
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 257
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 257
            if (tmp___9 == 0) {
#line 257
              tmp___10 = 1;
            } else {
#line 257
              tmp___10 = 0;
            }
          } else {
#line 257
            tmp___10 = 0;
          }
#line 257
          tmp___11 = tmp___10;
        }
#line 257
        if (tmp___11) {
          {
#line 263
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 264
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 264
          rhaystack.next_done = (_Bool)0;
#line 266
          rneedle.cur.ptr = needle;
#line 266
          rneedle.in_shift = (_Bool)0;
#line 266
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 266
          rneedle.next_done = (_Bool)0;
#line 267
          mbuiter_multi_next(& rneedle);
          }
#line 267
          if (rneedle.cur.wc_valid) {
#line 267
            if (rneedle.cur.wc == 0) {
#line 267
              tmp___3 = 0;
            } else {
#line 267
              tmp___3 = 1;
            }
          } else {
#line 267
            tmp___3 = 1;
          }
#line 267
          if (! tmp___3) {
            {
#line 268
            abort();
            }
          }
#line 269
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 269
          rneedle.next_done = (_Bool)0;
          {
#line 271
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 273
            mbuiter_multi_next(& rneedle);
            }
#line 273
            if (rneedle.cur.wc_valid) {
#line 273
              if (rneedle.cur.wc == 0) {
#line 273
                tmp___4 = 0;
              } else {
#line 273
                tmp___4 = 1;
              }
            } else {
#line 273
              tmp___4 = 1;
            }
#line 273
            if (! tmp___4) {
#line 275
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 276
            mbuiter_multi_next(& rhaystack);
            }
#line 276
            if (rhaystack.cur.wc_valid) {
#line 276
              if (rhaystack.cur.wc == 0) {
#line 276
                tmp___5 = 0;
              } else {
#line 276
                tmp___5 = 1;
              }
            } else {
#line 276
              tmp___5 = 1;
            }
#line 276
            if (! tmp___5) {
#line 278
              return ((char *)((void *)0));
            }
#line 279
            comparison_count ++;
#line 280
            if (rhaystack.cur.wc_valid) {
#line 280
              if (rneedle.cur.wc_valid) {
#line 280
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 280
                goto _L;
              }
            } else {
              _L: /* CIL Label */
#line 280
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 280
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 280
                if (tmp___6 == 0) {
#line 280
                  tmp___7 = 1;
                } else {
#line 280
                  tmp___7 = 0;
                }
              } else {
#line 280
                tmp___7 = 0;
              }
#line 280
              tmp___8 = tmp___7;
            }
#line 280
            if (! tmp___8) {
#line 282
              goto while_break___1;
            }
#line 271
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 271
            rhaystack.next_done = (_Bool)0;
#line 271
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 271
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 222
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 222
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 288
      return ((char *)haystack);
    }
  } else
#line 292
  if ((int const   )*needle != 0) {
#line 308
    try_kmp___0 = (_Bool)1;
#line 309
    outer_loop_count___0 = (size_t )0;
#line 310
    comparison_count___0 = (size_t )0;
#line 311
    last_ccount___0 = (size_t )0;
#line 312
    needle_last_ccount = needle;
#line 316
    tmp___13 = needle;
#line 316
    needle ++;
#line 316
    b = (char )*tmp___13;
    {
#line 318
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 320
      if ((int const   )*haystack == 0) {
#line 322
        return ((char *)((void *)0));
      }
#line 326
      if (try_kmp___0) {
#line 326
        if (outer_loop_count___0 >= 10UL) {
#line 326
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 332
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 334
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 334
              needle_last_ccount += tmp___14;
              }
#line 337
              if ((int const   )*needle_last_ccount == 0) {
#line 338
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 339
              last_ccount___0 = comparison_count___0;
            }
#line 341
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 345
              tmp___15 = strlen(needle - 1);
#line 345
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 345
              success___0 = tmp___16;
              }
#line 350
              if (success___0) {
#line 351
                return ((char *)result___0);
              }
#line 352
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 356
      outer_loop_count___0 ++;
#line 357
      comparison_count___0 ++;
#line 358
      if ((int const   )*haystack == (int const   )b) {
#line 361
        rhaystack___0 = haystack + 1;
#line 362
        rneedle___0 = needle;
        {
#line 364
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 366
          if ((int const   )*rneedle___0 == 0) {
#line 368
            return ((char *)haystack);
          }
#line 369
          if ((int const   )*rhaystack___0 == 0) {
#line 371
            return ((char *)((void *)0));
          }
#line 372
          comparison_count___0 ++;
#line 373
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 375
            goto while_break___3;
          }
#line 364
          rhaystack___0 ++;
#line 364
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 318
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 381
    return ((char *)haystack);
  }
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )
{
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 1121 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )
{
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 69 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
void *mmalloca(size_t n )
{
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
void freea(void *p )
{
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 750 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 807
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 811
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 834
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 143
#pragma weak pthread_self
#line 147
#pragma weak pthread_cancel
#line 295
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 369
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 283 "/home/khheo/project/benchmark/grep-2.19/lib/glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock )
{
  pthread_mutexattr_t attributes ;
  int err ;

  {
  {
#line 289
  err = pthread_mutexattr_init(& attributes);
  }
#line 290
  if (err != 0) {
#line 291
    return (err);
  }
  {
#line 292
  err = pthread_mutexattr_settype(& attributes, 1);
  }
#line 293
  if (err != 0) {
    {
#line 295
    pthread_mutexattr_destroy(& attributes);
    }
#line 296
    return (err);
  }
  {
#line 298
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  }
#line 299
  if (err != 0) {
    {
#line 301
    pthread_mutexattr_destroy(& attributes);
    }
#line 302
    return (err);
  }
  {
#line 304
  err = pthread_mutexattr_destroy(& attributes);
  }
#line 305
  if (err != 0) {
#line 306
    return (err);
  }
#line 307
  return (0);
}
}
#line 454 "/home/khheo/project/benchmark/grep-2.19/lib/glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 456 "/home/khheo/project/benchmark/grep-2.19/lib/glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control )
{
  char *firstbyte ;

  {
#line 461
  firstbyte = (char *)once_control;
#line 462
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 465
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 466
    return (1);
  } else {
#line 469
    return (0);
  }
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 119 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 122 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.c"
static char const   *get_charset_aliases(void)
{
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 127
  cp = (char const   *)charset_aliases;
#line 128
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 132
    base = "charset.alias";
#line 137
    tmp = getenv("CHARSETALIASDIR");
#line 137
    dir = (char const   *)tmp;
    }
#line 138
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 139
      dir = "/usr/local/lib";
    } else
#line 138
    if ((int const   )*(dir + 0) == 0) {
#line 139
      dir = "/usr/local/lib";
    }
    {
#line 143
    tmp___0 = strlen(dir);
#line 143
    dir_len___0 = tmp___0;
#line 144
    tmp___1 = strlen(base);
#line 144
    base_len___0 = tmp___1;
    }
#line 145
    if (dir_len___0 > 0UL) {
#line 145
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 145
        tmp___2 = 1;
      } else {
#line 145
        tmp___2 = 0;
      }
    } else {
#line 145
      tmp___2 = 0;
    }
    {
#line 145
    add_slash = tmp___2;
#line 146
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 146
    file_name___1 = (char *)tmp___3;
    }
#line 147
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 149
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 150
      if (add_slash) {
#line 151
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 152
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 156
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 158
      cp = "";
    } else {
      {
#line 170
      fd = open((char const   *)file_name___1, 131072);
      }
#line 172
      if (fd < 0) {
#line 174
        cp = "";
      } else {
        {
#line 179
        fp = fdopen(fd, "r");
        }
#line 180
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 183
          close(fd);
#line 184
          cp = "";
          }
        } else {
#line 189
          res_ptr = (char *)((void *)0);
#line 190
          res_size = (size_t )0;
          {
#line 192
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 200
            c = getc_unlocked(fp);
            }
#line 201
            if (c == -1) {
#line 202
              goto while_break;
            }
#line 203
            if (c == 10) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 32) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 9) {
#line 204
              goto __Cont;
            }
#line 205
            if (c == 35) {
              {
#line 208
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 209
                c = getc_unlocked(fp);
                }
#line 208
                if (c == -1) {
#line 208
                  goto while_break___0;
                } else
#line 208
                if (c == 10) {
#line 208
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 211
              if (c == -1) {
#line 212
                goto while_break;
              }
#line 213
              goto __Cont;
            }
            {
#line 215
            ungetc(c, fp);
#line 216
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 216
            if (tmp___4 < 2) {
#line 217
              goto while_break;
            }
            {
#line 218
            l1 = strlen((char const   *)(buf1));
#line 219
            l2 = strlen((char const   *)(buf2));
#line 220
            old_res_ptr = res_ptr;
            }
#line 221
            if (res_size == 0UL) {
              {
#line 223
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 224
              tmp___5 = malloc(res_size + 1UL);
#line 224
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 228
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___6;
              }
            }
#line 231
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 234
              res_size = (size_t )0;
#line 235
              free((void *)old_res_ptr);
              }
#line 236
              goto while_break;
            }
            {
#line 238
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 239
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 241
          fclose(fp);
          }
#line 242
          if (res_size == 0UL) {
#line 243
            cp = "";
          } else {
#line 246
            *(res_ptr + res_size) = (char )'\000';
#line 247
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 252
      free((void *)file_name___1);
      }
    }
#line 346
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 349
  return (cp);
}
}
#line 361 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.c"
char const   *locale_charset(void)
{
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 372
  tmp = nl_langinfo(14);
#line 372
  codeset = (char const   *)tmp;
  }
#line 529
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 531
    codeset = "";
  }
  {
#line 534
  aliases = get_charset_aliases();
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! ((int const   )*aliases != 0)) {
#line 534
      goto while_break;
    }
    {
#line 537
    tmp___3 = strcmp(codeset, aliases);
    }
#line 537
    if (tmp___3 == 0) {
      {
#line 540
      tmp___2 = strlen(aliases);
#line 540
      codeset = (aliases + tmp___2) + 1;
      }
#line 541
      goto while_break;
    } else
#line 537
    if ((int const   )*(aliases + 0) == 42) {
#line 537
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 540
        tmp___2 = strlen(aliases);
#line 540
        codeset = (aliases + tmp___2) + 1;
        }
#line 541
        goto while_break;
      }
    }
    {
#line 534
    tmp___0 = strlen(aliases);
#line 534
    aliases += tmp___0 + 1UL;
#line 534
    tmp___1 = strlen(aliases);
#line 534
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  if ((int const   )*(codeset + 0) == 0) {
#line 548
    codeset = "ASCII";
  }
#line 557
  return (codeset);
}
}
#line 41 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val )
{
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 4)) {
#line 31
      goto while_break;
    }
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir )
{


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val )
{
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/khheo/project/benchmark/grep-2.19/lib/i-ring.c"
int i_ring_pop(I_ring *ir )
{
  int top_val ;
  _Bool tmp ;

  {
  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
  }
#line 59
  if (tmp) {
    {
#line 60
    abort();
    }
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 72 "/home/khheo/project/benchmark/grep-2.19/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 100
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 103
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 105
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n )
{


  {
#line 41
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n )
{


  {
#line 50
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n )
{


  {
#line 60
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 66 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n )
{


  {
#line 69
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 75 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n )
{


  {
#line 78
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 84 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n )
{


  {
#line 87
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 95 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n )
{


  {
#line 98
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 106 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n )
{


  {
#line 109
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 117 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n )
{


  {
#line 120
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 128 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n )
{


  {
#line 131
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table )
{


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table )
{


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table )
{


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table )
{
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table )
{
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream )
{
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key )
{
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry )
{
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void *hash_get_first(Hash_table const   *table )
{
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry )
{
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size )
{
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer___0 + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data )
{
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets )
{
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool is_prime(size_t candidate )
{
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t next_prime(size_t candidate )
{
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning )
{


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n )
{
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b )
{


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool check_tuning(Hash_table *table )
{
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning )
{
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) )
{
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail:
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void hash_clear(Hash_table *table )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void hash_free(Hash_table *table )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table )
{
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry )
{


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete___0 )
{
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */
#line 805
      data = bucket->data;
#line 807
      if (delete___0) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___0) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate )
{
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent )
{
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1121
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 1121 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )
{
  int tmp ;

  {
  {
#line 1124
  tmp = hash_insert_if_absent(table, entry, matched_ent);
  }
#line 1124
  return (tmp);
}
}
#line 1133 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry )
{
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1137
  tmp = hash_insert_if_absent(table, entry, & matched_ent);
#line 1137
  err = tmp;
  }
#line 1138
  if (err == -1) {
#line 1138
    tmp___1 = (void *)0;
  } else {
#line 1138
    if (err == 0) {
#line 1138
      tmp___0 = matched_ent;
    } else {
#line 1138
      tmp___0 = entry;
    }
#line 1138
    tmp___1 = (void *)tmp___0;
  }
#line 1138
  return (tmp___1);
}
}
#line 1147 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry )
{
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1153
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1154
  if (! data) {
#line 1155
    return ((void *)0);
  }
#line 1157
  (table->n_entries) --;
#line 1158
  if (! bucket->data) {
#line 1160
    (table->n_buckets_used) --;
#line 1165
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1170
      check_tuning(table);
      }
#line 1171
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1174
        tuning = table->tuning;
#line 1175
        if (tuning->is_n_buckets) {
#line 1175
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1175
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1175
        candidate = (size_t )tmp;
#line 1181
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1181
        if (! tmp___0) {
#line 1189
          cursor = table->free_entry_list;
          {
#line 1191
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1191
            if (! cursor) {
#line 1191
              goto while_break;
            }
            {
#line 1193
            next = cursor->next;
#line 1194
            free((void *)cursor);
#line 1195
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1197
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1204
  return (data);
}
}
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 267 "/home/khheo/project/benchmark/grep-2.19/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 268
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 269
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 272
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 273
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 204
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 205
static void fts_lfree(FTSENT *head ) ;
#line 206
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 207
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) ;
#line 208
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 209
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 210
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 211
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 212
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y )
{
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size )
{
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts )
{
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent )
{
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent )
{
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static void free_dir(FTS *sp )
{


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 268 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring )
{
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 271
    if (tmp___0) {
#line 271
      goto while_break;
    }
    {
#line 273
    tmp = i_ring_pop(fd_ring);
#line 273
    fd = tmp;
    }
#line 274
    if (0 <= fd) {
      {
#line 275
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 282 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required )
{


  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )p->fts_info == 11)) {
      {
#line 285
      abort();
      }
    }
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (required) {
#line 286
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 286
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 289
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd )
{
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 297
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 297
  new_fd = tmp;
  }
#line 302
  if (new_fd < 0) {
#line 303
    return ((DIR *)((void *)0));
  }
  {
#line 304
  set_cloexec_flag(new_fd, (_Bool)1);
#line 305
  dirp = fdopendir(new_fd);
  }
#line 306
  if (dirp) {
#line 307
    *pdir_fd = new_fd;
  } else {
    {
#line 310
    tmp___0 = __errno_location();
#line 310
    saved_errno = *tmp___0;
#line 311
    close(new_fd);
#line 312
    tmp___1 = __errno_location();
#line 312
    *tmp___1 = saved_errno;
    }
  }
#line 314
  return (dirp);
}
}
#line 322 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one )
{
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 326
  old = sp->fts_cwd_fd;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (old != fd)) {
#line 327
      if (! (old == -100)) {
        {
#line 327
        abort();
        }
      }
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (chdir_down_one) {
    {
#line 333
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 333
    prev_fd_in_slot = tmp;
    }
#line 335
    if (0 <= prev_fd_in_slot) {
      {
#line 336
      close(prev_fd_in_slot);
      }
    }
  } else
#line 338
  if (! (sp->fts_options & 4)) {
#line 340
    if (0 <= old) {
      {
#line 341
      close(old);
      }
    }
  }
#line 344
  sp->fts_cwd_fd = fd;
#line 345
  return;
}
}
#line 351 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int restore_initial_cwd(FTS *sp )
{
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 354
  if (! (sp->fts_options & 4)) {
#line 354
    if (sp->fts_options & 512) {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp = -100;
      } else {
#line 354
        tmp = sp->fts_rfd;
      }
      {
#line 354
      cwd_advance_fd(sp, tmp, (_Bool)1);
#line 354
      tmp___2 = 0;
      }
    } else {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp___0 = -100;
      } else {
#line 354
        tmp___0 = sp->fts_rfd;
      }
      {
#line 354
      tmp___1 = fchdir(tmp___0);
#line 354
      tmp___2 = tmp___1;
      }
    }
#line 354
    if (tmp___2) {
#line 354
      tmp___3 = 1;
    } else {
#line 354
      tmp___3 = 0;
    }
  } else {
#line 354
    tmp___3 = 0;
  }
  {
#line 354
  fail = tmp___3;
#line 355
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 356
  return (fail);
}
}
#line 363 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int diropen(FTS const   *sp , char const   *dir )
{
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 367
  if (sp->fts_options & 16) {
#line 367
    tmp = 131072;
  } else {
#line 367
    tmp = 0;
  }
#line 367
  if (sp->fts_options & 2048) {
#line 367
    tmp___0 = 262144;
  } else {
#line 367
    tmp___0 = 0;
  }
#line 367
  open_flags = (67840 | tmp) | tmp___0;
#line 371
  if (sp->fts_options & 512) {
    {
#line 371
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 371
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 371
    tmp___2 = open_safer(dir, open_flags);
#line 371
    tmp___3 = tmp___2;
    }
  }
#line 371
  fd = tmp___3;
#line 374
  if (0 <= fd) {
    {
#line 375
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 376
  return (fd);
}
}
#line 379
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 379 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                   int options , int (*compar)(FTSENT const   ** ,
                                                                                               FTSENT const   ** ) )
{
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  char const   *v ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
#line 387
  parent = (FTSENT *)((void *)0);
#line 388
  tmp = (FTSENT *)((void *)0);
#line 392
  if (options & -8192) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    *tmp___0 = 22;
    }
#line 394
    return ((FTS *)((void *)0));
  }
#line 396
  if (options & 4) {
#line 396
    if (options & 512) {
      {
#line 397
      tmp___1 = __errno_location();
#line 397
      *tmp___1 = 22;
      }
#line 398
      return ((FTS *)((void *)0));
    }
  }
#line 400
  if (! (options & 18)) {
    {
#line 401
    tmp___2 = __errno_location();
#line 401
    *tmp___2 = 22;
    }
#line 402
    return ((FTS *)((void *)0));
  }
  {
#line 406
  tmp___3 = malloc(sizeof(FTS ));
#line 406
  sp = (FTS *)tmp___3;
  }
#line 406
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 407
    return ((FTS *)((void *)0));
  }
  {
#line 408
  memset((void *)sp, 0, sizeof(FTS ));
#line 409
  sp->fts_compar = compar;
#line 410
  sp->fts_options = options;
  }
#line 413
  if (sp->fts_options & 2) {
#line 414
    sp->fts_options |= 4;
#line 415
    sp->fts_options &= -513;
  }
#line 419
  sp->fts_cwd_fd = -100;
#line 420
  if (sp->fts_options & 512) {

  }
  {
#line 461
  tmp___6 = (size_t )fts_maxarglen(argv);
#line 461
  maxarglen = tmp___6;
  }
#line 462
  if (maxarglen > 4096UL) {
#line 462
    tmp___7 = maxarglen;
  } else {
#line 462
    tmp___7 = (size_t )4096;
  }
  {
#line 462
  tmp___8 = fts_palloc(sp, tmp___7);
  }
#line 462
  if (! tmp___8) {
#line 463
    goto mem1;
  }
#line 467
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
#line 468
    parent = fts_alloc(sp, "", (size_t )0);
    }
#line 468
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 469
      goto mem2;
    }
#line 470
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 484
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 484
    tmp___9 = 1;
  } else
#line 484
  if (sp->fts_options & 1024) {
#line 484
    tmp___9 = 1;
  } else {
#line 484
    tmp___9 = 0;
  }
#line 484
  defer_stat = (_Bool )tmp___9;
#line 487
  root = (FTSENT *)((void *)0);
#line 487
  nitems = (size_t )0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 487
      goto while_break;
    }
    {
#line 489
    tmp___10 = strlen((char const   *)*argv);
#line 489
    len = tmp___10;
    }
#line 491
    if (! (options & 4096)) {
#line 495
      v = (char const   *)*argv;
#line 496
      if (2UL < len) {
#line 496
        if ((int const   )*(v + (len - 1UL)) == 47) {
          {
#line 497
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 497
            if (1UL < len) {
#line 497
              if (! ((int const   )*(v + (len - 2UL)) == 47)) {
#line 497
                goto while_break___0;
              }
            } else {
#line 497
              goto while_break___0;
            }
#line 498
            len --;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 501
    p = fts_alloc(sp, (char const   *)*argv, len);
    }
#line 501
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 502
      goto mem3;
    }
#line 503
    p->fts_level = (ptrdiff_t )0;
#line 504
    p->fts_parent = parent;
#line 505
    p->fts_accpath = p->fts_name;
#line 509
    if (defer_stat) {
#line 509
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
#line 510
        p->fts_info = (unsigned short)11;
#line 511
        fts_set_stat_required(p, (_Bool)1);
        }
      } else {
        {
#line 513
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
      }
    } else {
      {
#line 513
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    }
#line 520
    if (compar) {
#line 521
      p->fts_link = root;
#line 522
      root = p;
    } else {
#line 524
      p->fts_link = (struct _ftsent *)((void *)0);
#line 525
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 526
        root = p;
#line 526
        tmp = root;
      } else {
#line 528
        tmp->fts_link = p;
#line 529
        tmp = p;
      }
    }
#line 487
    argv ++;
#line 487
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  if (compar) {
#line 533
    if (nitems > 1UL) {
      {
#line 534
      root = fts_sort(sp, root, nitems);
      }
    }
  }
  {
#line 541
  tmp___11 = fts_alloc(sp, "", (size_t )0);
#line 541
  sp->fts_cur = tmp___11;
  }
#line 541
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 542
    goto mem3;
  }
  {
#line 543
  (sp->fts_cur)->fts_link = root;
#line 544
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 545
  tmp___12 = setup_dir(sp);
  }
#line 545
  if (! tmp___12) {
#line 546
    goto mem3;
  }
#line 555
  if (! (sp->fts_options & 4)) {
#line 555
    if (! (sp->fts_options & 512)) {
      {
#line 555
      tmp___13 = diropen((FTS const   *)sp, ".");
#line 555
      sp->fts_rfd = tmp___13;
      }
#line 555
      if (tmp___13 < 0) {
#line 557
        sp->fts_options |= 4;
      }
    }
  }
  {
#line 559
  i_ring_init(& sp->fts_fd_ring, -1);
  }
#line 560
  return (sp);
  mem3:
  {
#line 562
  fts_lfree(root);
#line 563
  free((void *)parent);
  }
  mem2:
  {
#line 564
  free((void *)sp->fts_path);
  }
  mem1:
  {
#line 565
  free((void *)sp);
  }
#line 566
  return ((FTS *)((void *)0));
}
}
#line 569 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p )
{
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 583
  tmp = p->fts_namelen;
#line 583
  p->fts_pathlen = tmp;
#line 583
  len = tmp;
#line 584
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 585
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 585
  if (cp) {
#line 585
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    } else
#line 585
    if (*(cp + 1)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    }
  }
#line 590
  tmp___0 = sp->fts_path;
#line 590
  p->fts_path = tmp___0;
#line 590
  p->fts_accpath = tmp___0;
#line 591
  return;
}
}
#line 593
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 593 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp )
{
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 597
  saved_errno = 0;
#line 604
  if (sp->fts_cur) {
#line 605
    p = sp->fts_cur;
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (! (p->fts_level >= 0L)) {
#line 605
        goto while_break;
      }
#line 606
      freep = p;
#line 607
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 607
        p = p->fts_link;
      } else {
#line 607
        p = p->fts_parent;
      }
      {
#line 608
      free((void *)freep);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 610
    free((void *)p);
    }
  }
#line 614
  if (sp->fts_child) {
    {
#line 615
    fts_lfree(sp->fts_child);
    }
  }
  {
#line 616
  free((void *)sp->fts_array);
#line 617
  free((void *)sp->fts_path);
  }
#line 619
  if (sp->fts_options & 512) {
#line 621
    if (0 <= sp->fts_cwd_fd) {
      {
#line 622
      tmp___0 = close(sp->fts_cwd_fd);
      }
#line 622
      if (tmp___0) {
        {
#line 623
        tmp = __errno_location();
#line 623
        saved_errno = *tmp;
        }
      }
    }
  } else
#line 625
  if (! (sp->fts_options & 4)) {
    {
#line 628
    tmp___2 = fchdir(sp->fts_rfd);
    }
#line 628
    if (tmp___2) {
      {
#line 629
      tmp___1 = __errno_location();
#line 629
      saved_errno = *tmp___1;
      }
    }
    {
#line 633
    tmp___4 = close(sp->fts_rfd);
    }
#line 633
    if (tmp___4) {
#line 634
      if (saved_errno == 0) {
        {
#line 635
        tmp___3 = __errno_location();
#line 635
        saved_errno = *tmp___3;
        }
      }
    }
  }
  {
#line 638
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 640
  if (sp->fts_leaf_optimization_works_ht) {
    {
#line 641
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
  }
  {
#line 643
  free_dir(sp);
#line 646
  free((void *)sp);
  }
#line 649
  if (saved_errno) {
    {
#line 650
    tmp___5 = __errno_location();
#line 650
    *tmp___5 = saved_errno;
    }
#line 651
    return (-1);
  }
#line 654
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 672 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 683
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 683
  if (tmp != 0) {
#line 684
    return ((_Bool)1);
  }
  {
#line 691
  if (fs_buf.f_type == 26985L) {
#line 691
    goto case_26985;
  }
#line 691
  if (fs_buf.f_type == 16914836L) {
#line 691
    goto case_26985;
  }
#line 696
  goto switch_default;
  case_26985: /* CIL Label */
  case_16914836: /* CIL Label */
#line 694
  return ((_Bool)0);
  switch_default: /* CIL Label */
#line 697
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 704 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 710
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 710
  if (tmp != 0) {
#line 711
    return ((_Bool)0);
  }
  {
#line 720
  if (fs_buf.f_type == 1382369651L) {
#line 720
    goto case_1382369651;
  }
#line 729
  goto switch_default;
  case_1382369651: /* CIL Label */
#line 721
  return ((_Bool)1);
  switch_default: /* CIL Label */
#line 730
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 754 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size )
{
  struct LCO_ent  const  *ax ;

  {
#line 757
  ax = (struct LCO_ent  const  *)x;
#line 758
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 761 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y )
{
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 764
  ax = (struct LCO_ent  const  *)x;
#line 765
  ay = (struct LCO_ent  const  *)y;
#line 766
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 772 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p )
{
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 775
  sp = (FTS *)p->fts_fts;
#line 776
  h = sp->fts_leaf_optimization_works_ht;
#line 784
  if (! (sp->fts_options & 512)) {
#line 785
    return ((_Bool)0);
  }
#line 788
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 790
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 790
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 790
    h = tmp___0;
    }
#line 793
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 794
      return ((_Bool)0);
    }
  }
  {
#line 796
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 797
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 797
  ent = (struct LCO_ent *)tmp___1;
  }
#line 798
  if (ent) {
#line 799
    return (ent->opt_ok);
  }
  {
#line 802
  tmp___2 = malloc(sizeof(*t2));
#line 802
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 803
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 804
    return ((_Bool)0);
  }
  {
#line 807
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 808
  t2->opt_ok = opt_ok;
#line 809
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 811
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 811
  ent = (struct LCO_ent *)tmp___3;
  }
#line 812
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 815
    free((void *)t2);
    }
#line 816
    return ((_Bool)0);
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 818
      abort();
      }
    }
#line 818
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (opt_ok);
}
}
#line 831
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 831 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp )
{
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  FTSENT *parent ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  _Bool tmp___12 ;
  int *tmp___13 ;
  struct _ftsent *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int saved_errno ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  FTSENT *tmp___24 ;

  {
#line 839
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 840
    return ((FTSENT *)((void *)0));
  } else
#line 839
  if (sp->fts_options & 16384) {
#line 840
    return ((FTSENT *)((void *)0));
  }
#line 843
  p = sp->fts_cur;
#line 846
  instr = p->fts_instr;
#line 847
  p->fts_instr = (unsigned short)3;
#line 850
  if ((int )instr == 1) {
    {
#line 851
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 852
    return (p);
  }
#line 863
  if ((int )instr == 2) {
#line 863
    if ((int )p->fts_info == 12) {
#line 863
      goto _L;
    } else
#line 863
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */
      {
#line 865
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 866
      if ((int )p->fts_info == 1) {
#line 866
        if (! (sp->fts_options & 4)) {
          {
#line 867
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 867
          p->fts_symfd = tmp___1;
          }
#line 867
          if (tmp___1 < 0) {
            {
#line 868
            tmp___0 = __errno_location();
#line 868
            p->fts_errno = *tmp___0;
#line 869
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 871
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 873
      goto check_for_dir;
    }
  }
#line 877
  if ((int )p->fts_info == 1) {
#line 879
    if ((int )instr == 4) {
#line 879
      goto _L___0;
    } else
#line 879
    if (sp->fts_options & 64) {
#line 879
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */
#line 881
        if ((int )p->fts_flags & 2) {
          {
#line 882
          close(p->fts_symfd);
          }
        }
#line 883
        if (sp->fts_child) {
          {
#line 884
          fts_lfree(sp->fts_child);
#line 885
          sp->fts_child = (struct _ftsent *)((void *)0);
          }
        }
#line 887
        p->fts_info = (unsigned short)6;
        {
#line 888
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 888
          leave_dir(sp, p);
          }
#line 888
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 889
        return (p);
      }
    }
#line 893
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 893
      if (sp->fts_options & 8192) {
        {
#line 894
        sp->fts_options &= -8193;
#line 895
        fts_lfree(sp->fts_child);
#line 896
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
      }
    }
#line 911
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
#line 912
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      }
#line 912
      if (tmp___3) {
        {
#line 913
        tmp___2 = __errno_location();
#line 913
        p->fts_errno = *tmp___2;
#line 914
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 915
        p = sp->fts_child;
        }
        {
#line 915
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 915
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 915
            goto while_break___0;
          }
#line 917
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 915
          p = p->fts_link;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 920
      tmp___4 = fts_build(sp, 3);
#line 920
      sp->fts_child = tmp___4;
      }
#line 920
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 921
        if (sp->fts_options & 16384) {
#line 922
          return ((FTSENT *)((void *)0));
        }
#line 926
        if (p->fts_errno) {
#line 926
          if ((int )p->fts_info != 4) {
#line 927
            p->fts_info = (unsigned short)7;
          }
        }
        {
#line 928
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 928
          leave_dir(sp, p);
          }
#line 928
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 929
        return (p);
      }
    }
#line 931
    p = sp->fts_child;
#line 932
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 933
    goto name;
  }
  next:
#line 937
  tmp = p;
#line 942
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
#line 942
    if ((p->fts_parent)->fts_dirp) {
      {
#line 944
      p = tmp->fts_parent;
#line 945
      sp->fts_cur = p;
#line 946
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 948
      p = fts_build(sp, 3);
      }
#line 948
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 950
        if (sp->fts_options & 16384) {
#line 951
          return ((FTSENT *)((void *)0));
        }
#line 952
        goto cd_dot_dot;
      }
      {
#line 955
      free((void *)tmp);
      }
#line 956
      goto name;
    }
  }
#line 959
  p = p->fts_link;
#line 959
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 960
    sp->fts_cur = p;
#line 961
    free((void *)tmp);
    }
#line 968
    if (p->fts_level == 0L) {
      {
#line 969
      tmp___5 = restore_initial_cwd(sp);
      }
#line 969
      if (tmp___5) {
#line 970
        sp->fts_options |= 16384;
#line 971
        return ((FTSENT *)((void *)0));
      }
      {
#line 973
      free_dir(sp);
#line 974
      fts_load(sp, p);
#line 975
      setup_dir(sp);
      }
#line 976
      goto check_for_dir;
    }
#line 984
    if ((int )p->fts_instr == 4) {
#line 985
      goto next;
    }
#line 986
    if ((int )p->fts_instr == 2) {
      {
#line 987
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 988
      if ((int )p->fts_info == 1) {
#line 988
        if (! (sp->fts_options & 4)) {
          {
#line 989
          tmp___7 = diropen((FTS const   *)sp, ".");
#line 989
          p->fts_symfd = tmp___7;
          }
#line 989
          if (tmp___7 < 0) {
            {
#line 990
            tmp___6 = __errno_location();
#line 990
            p->fts_errno = *tmp___6;
#line 991
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 993
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 995
      p->fts_instr = (unsigned short)3;
    }
    name:
#line 998
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 998
      tmp___8 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 998
      tmp___8 = (p->fts_parent)->fts_pathlen;
    }
    {
#line 998
    t = sp->fts_path + tmp___8;
#line 999
    tmp___9 = t;
#line 999
    t ++;
#line 999
    *tmp___9 = (char )'/';
#line 1000
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir:
#line 1002
    sp->fts_cur = p;
#line 1003
    if ((int )p->fts_info == 11) {
#line 1005
      if (p->fts_statp[0].st_size == 2L) {
#line 1007
        parent = p->fts_parent;
#line 1008
        if (0L < p->fts_level) {
#line 1008
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 1008
            if (sp->fts_options & 8) {
#line 1008
              if (sp->fts_options & 16) {
                {
#line 1008
                tmp___10 = link_count_optimize_ok((FTSENT const   *)parent);
                }
#line 1008
                if (! tmp___10) {
#line 1008
                  goto _L___4;
                }
              } else {
#line 1008
                goto _L___4;
              }
            } else {
#line 1008
              goto _L___4;
            }
          } else {
#line 1008
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */
          {
#line 1020
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
#line 1021
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 1021
            if (p->fts_level != 0L) {
#line 1021
              if (parent->fts_n_dirs_remaining) {
#line 1024
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        {
#line 1028
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1028
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
#line 1028
            abort();
            }
          }
#line 1028
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1031
    if ((int )p->fts_info == 1) {
#line 1036
      if (p->fts_level == 0L) {
#line 1037
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      {
#line 1039
      tmp___12 = enter_dir(sp, p);
      }
#line 1039
      if (! tmp___12) {
        {
#line 1041
        tmp___11 = __errno_location();
#line 1041
        *tmp___11 = 12;
        }
#line 1042
        return ((FTSENT *)((void *)0));
      }
    }
#line 1045
    return (p);
  }
  cd_dot_dot:
  {
#line 1050
  p = tmp->fts_parent;
#line 1051
  sp->fts_cur = p;
#line 1052
  free((void *)tmp);
  }
#line 1054
  if (p->fts_level == -1L) {
    {
#line 1059
    free((void *)p);
#line 1060
    tmp___13 = __errno_location();
#line 1060
    *tmp___13 = 0;
#line 1061
    tmp___14 = (struct _ftsent *)((void *)0);
#line 1061
    sp->fts_cur = tmp___14;
    }
#line 1061
    return (tmp___14);
  }
  {
#line 1064
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1064
    if (! ((int )p->fts_info != 11)) {
      {
#line 1064
      abort();
      }
    }
#line 1064
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1067
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1075
  if (p->fts_level == 0L) {
    {
#line 1076
    tmp___16 = restore_initial_cwd(sp);
    }
#line 1076
    if (tmp___16) {
      {
#line 1077
      tmp___15 = __errno_location();
#line 1077
      p->fts_errno = *tmp___15;
#line 1078
      sp->fts_options |= 16384;
      }
    }
  } else
#line 1080
  if ((int )p->fts_flags & 2) {
#line 1081
    if (! (sp->fts_options & 4)) {
#line 1081
      if (sp->fts_options & 512) {
        {
#line 1081
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1081
        tmp___21 = 0;
        }
      } else {
        {
#line 1081
        tmp___20 = fchdir(p->fts_symfd);
#line 1081
        tmp___21 = tmp___20;
        }
      }
#line 1081
      if (tmp___21) {
        {
#line 1082
        tmp___17 = __errno_location();
#line 1082
        saved_errno = *tmp___17;
#line 1083
        close(p->fts_symfd);
#line 1084
        tmp___18 = __errno_location();
#line 1084
        *tmp___18 = saved_errno;
#line 1085
        tmp___19 = __errno_location();
#line 1085
        p->fts_errno = *tmp___19;
#line 1086
        sp->fts_options |= 16384;
        }
      }
    }
    {
#line 1088
    close(p->fts_symfd);
    }
  } else
#line 1089
  if (! ((int )p->fts_flags & 1)) {
    {
#line 1089
    tmp___23 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    }
#line 1089
    if (tmp___23) {
      {
#line 1091
      tmp___22 = __errno_location();
#line 1091
      p->fts_errno = *tmp___22;
#line 1092
      sp->fts_options |= 16384;
      }
    }
  }
#line 1094
  if (p->fts_errno) {
#line 1094
    p->fts_info = (unsigned short)7;
  } else {
#line 1094
    p->fts_info = (unsigned short)6;
  }
#line 1095
  if (p->fts_errno == 0) {
    {
#line 1096
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1096
      leave_dir(sp, p);
      }
#line 1096
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1097
  if (sp->fts_options & 16384) {
#line 1097
    tmp___24 = (FTSENT *)((void *)0);
  } else {
#line 1097
    tmp___24 = p;
  }
#line 1097
  return (tmp___24);
}
}
#line 1107
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1107 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr )
{
  int *tmp ;

  {
#line 1110
  if (instr != 0) {
#line 1110
    if (instr != 1) {
#line 1110
      if (instr != 2) {
#line 1110
        if (instr != 3) {
#line 1110
          if (instr != 4) {
            {
#line 1112
            tmp = __errno_location();
#line 1112
            *tmp = 22;
            }
#line 1113
            return (1);
          }
        }
      }
    }
  }
#line 1115
  p->fts_instr = (unsigned short )instr;
#line 1116
  return (0);
}
}
#line 1119
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 1119 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                          int instr )
{
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1125
  if (instr != 0) {
#line 1125
    if (instr != 8192) {
      {
#line 1126
      tmp = __errno_location();
#line 1126
      *tmp = 22;
      }
#line 1127
      return ((FTSENT *)((void *)0));
    }
  }
  {
#line 1131
  p = sp->fts_cur;
#line 1137
  tmp___0 = __errno_location();
#line 1137
  *tmp___0 = 0;
  }
#line 1140
  if (sp->fts_options & 16384) {
#line 1141
    return ((FTSENT *)((void *)0));
  }
#line 1144
  if ((int )p->fts_info == 9) {
#line 1145
    return (p->fts_link);
  }
#line 1152
  if ((int )p->fts_info != 1) {
#line 1153
    return ((FTSENT *)((void *)0));
  }
#line 1156
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
#line 1157
    fts_lfree(sp->fts_child);
    }
  }
#line 1159
  if (instr == 8192) {
#line 1160
    sp->fts_options |= 8192;
#line 1161
    instr = 2;
  } else {
#line 1163
    instr = 1;
  }
#line 1172
  if (p->fts_level != 0L) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  } else
#line 1172
  if ((int )*(p->fts_accpath + 0) == 47) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  } else
#line 1172
  if (sp->fts_options & 4) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  }
  {
#line 1176
  fd = diropen((FTS const   *)sp, ".");
  }
#line 1176
  if (fd < 0) {
#line 1177
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1177
    sp->fts_child = tmp___2;
#line 1177
    return (tmp___2);
  }
  {
#line 1178
  sp->fts_child = fts_build(sp, instr);
  }
#line 1179
  if (sp->fts_options & 512) {
    {
#line 1181
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
  } else {
    {
#line 1185
    tmp___5 = fchdir(fd);
    }
#line 1185
    if (tmp___5) {
      {
#line 1187
      tmp___3 = __errno_location();
#line 1187
      saved_errno = *tmp___3;
#line 1188
      close(fd);
#line 1189
      tmp___4 = __errno_location();
#line 1189
      *tmp___4 = saved_errno;
      }
#line 1190
      return ((FTSENT *)((void *)0));
    }
    {
#line 1192
    close(fd);
    }
  }
#line 1194
  return (sp->fts_child);
}
}
#line 1202 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b )
{
  int tmp ;
  int tmp___0 ;

  {
#line 1205
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1205
    tmp___0 = -1;
  } else {
#line 1205
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1205
      tmp = 1;
    } else {
#line 1205
      tmp = 0;
    }
#line 1205
    tmp___0 = tmp;
  }
#line 1205
  return (tmp___0);
}
}
#line 1211 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype )
{
  mode_t type ;

  {
  {
#line 1217
  if (dtype == 6U) {
#line 1217
    goto case_6;
  }
#line 1220
  if (dtype == 2U) {
#line 1220
    goto case_2;
  }
#line 1223
  if (dtype == 4U) {
#line 1223
    goto case_4;
  }
#line 1226
  if (dtype == 1U) {
#line 1226
    goto case_1;
  }
#line 1229
  if (dtype == 10U) {
#line 1229
    goto case_10;
  }
#line 1232
  if (dtype == 8U) {
#line 1232
    goto case_8;
  }
#line 1235
  if (dtype == 12U) {
#line 1235
    goto case_12;
  }
#line 1238
  goto switch_default;
  case_6: /* CIL Label */
#line 1218
  type = (mode_t )24576;
#line 1219
  goto switch_break;
  case_2: /* CIL Label */
#line 1221
  type = (mode_t )8192;
#line 1222
  goto switch_break;
  case_4: /* CIL Label */
#line 1224
  type = (mode_t )16384;
#line 1225
  goto switch_break;
  case_1: /* CIL Label */
#line 1227
  type = (mode_t )4096;
#line 1228
  goto switch_break;
  case_10: /* CIL Label */
#line 1230
  type = (mode_t )40960;
#line 1231
  goto switch_break;
  case_8: /* CIL Label */
#line 1233
  type = (mode_t )32768;
#line 1234
  goto switch_break;
  case_12: /* CIL Label */
#line 1236
  type = (mode_t )49152;
#line 1237
  goto switch_break;
  switch_default: /* CIL Label */
#line 1239
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1241
  st->st_mode = type;
#line 1242
  return;
}
}
#line 1277 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type )
{
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  size_t d_namelen ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  _Bool tmp___15 ;
  int *tmp___16 ;
  _Bool skip_stat ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  _Bool tmp___23 ;

  {
#line 1294
  cur = sp->fts_cur;
#line 1295
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1300
  if (continue_readdir) {
    {
#line 1302
    dp = cur->fts_dirp;
#line 1303
    dir_fd = dirfd(dp);
    }
#line 1304
    if (dir_fd < 0) {
      {
#line 1306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1306
        closedir(cur->fts_dirp);
#line 1306
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1306
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1307
      if (type == 3) {
        {
#line 1309
        cur->fts_info = (unsigned short)4;
#line 1310
        tmp = __errno_location();
#line 1310
        cur->fts_errno = *tmp;
        }
      }
#line 1312
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1319
    if (sp->fts_options & 16) {
#line 1319
      if (sp->fts_options & 1) {
#line 1319
        if (cur->fts_level == 0L) {
#line 1319
          tmp___2 = 0;
        } else {
#line 1319
          tmp___2 = 131072;
        }
      } else {
#line 1319
        tmp___2 = 131072;
      }
    } else {
#line 1319
      tmp___2 = 0;
    }
#line 1319
    if (sp->fts_options & 2048) {
#line 1319
      tmp___3 = 262144;
    } else {
#line 1319
      tmp___3 = 0;
    }
#line 1319
    if (! (sp->fts_options & 4)) {
#line 1319
      if (sp->fts_options & 512) {
#line 1319
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1319
        tmp___4 = -100;
      }
    } else {
#line 1319
      tmp___4 = -100;
    }
    {
#line 1319
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
#line 1319
    cur->fts_dirp = tmp___1;
    }
#line 1319
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1321
      if (type == 3) {
        {
#line 1323
        cur->fts_info = (unsigned short)4;
#line 1324
        tmp___0 = __errno_location();
#line 1324
        cur->fts_errno = *tmp___0;
        }
      }
#line 1326
      return ((FTSENT *)((void *)0));
    }
#line 1331
    if ((int )cur->fts_info == 11) {
      {
#line 1332
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
      }
    } else
#line 1333
    if (sp->fts_options & 256) {
      {
#line 1340
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1340
        leave_dir(sp, cur);
        }
#line 1340
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1341
      fts_stat(sp, cur, (_Bool)0);
#line 1342
      tmp___6 = enter_dir(sp, cur);
      }
#line 1342
      if (! tmp___6) {
        {
#line 1344
        tmp___5 = __errno_location();
#line 1344
        *tmp___5 = 12;
        }
#line 1345
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1357
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1357
    tmp___7 = 100000UL;
  } else {
#line 1357
    tmp___7 = 0xffffffffffffffffUL;
  }
#line 1357
  max_entries = tmp___7;
#line 1365
  if (type == 2) {
#line 1366
    nlinks = (nlink_t )0;
#line 1368
    nostat = (_Bool)0;
  } else
#line 1369
  if (sp->fts_options & 8) {
#line 1369
    if (sp->fts_options & 16) {
#line 1370
      if (sp->fts_options & 32) {
#line 1370
        tmp___8 = 0;
      } else {
#line 1370
        tmp___8 = 2;
      }
#line 1370
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
#line 1372
      nostat = (_Bool)1;
    } else {
#line 1374
      nlinks = (nlink_t )-1;
#line 1375
      nostat = (_Bool)0;
    }
  } else {
#line 1374
    nlinks = (nlink_t )-1;
#line 1375
    nostat = (_Bool)0;
  }
#line 1393
  if (continue_readdir) {
#line 1397
    descend = (_Bool)1;
  } else
#line 1399
  if (nlinks) {
#line 1399
    goto _L___0;
  } else
#line 1399
  if (type == 3) {
    _L___0: /* CIL Label */
#line 1400
    if (sp->fts_options & 512) {
      {
#line 1402
      dir_fd = dup_safer(dir_fd);
      }
#line 1403
      if (0 <= dir_fd) {
        {
#line 1404
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1406
    if (dir_fd < 0) {
#line 1406
      goto _L;
    } else {
      {
#line 1406
      tmp___10 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1406
      if (tmp___10) {
        _L: /* CIL Label */
#line 1407
        if (nlinks) {
#line 1407
          if (type == 3) {
            {
#line 1408
            tmp___9 = __errno_location();
#line 1408
            cur->fts_errno = *tmp___9;
            }
          }
        }
#line 1409
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1410
        descend = (_Bool)0;
        {
#line 1411
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1411
          closedir(cur->fts_dirp);
#line 1411
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1411
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1412
        if (sp->fts_options & 512) {
#line 1412
          if (0 <= dir_fd) {
            {
#line 1413
            close(dir_fd);
            }
          }
        }
#line 1414
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1416
        descend = (_Bool)1;
      }
    }
  } else {
#line 1418
    descend = (_Bool)0;
  }
#line 1430
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1430
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1430
    len = cur->fts_pathlen;
  }
#line 1431
  if (sp->fts_options & 4) {
#line 1432
    cp = sp->fts_path + len;
#line 1433
    tmp___11 = cp;
#line 1433
    cp ++;
#line 1433
    *tmp___11 = (char )'/';
  } else {
#line 1436
    cp = (char *)((void *)0);
  }
#line 1438
  len ++;
#line 1439
  maxlen = sp->fts_pathlen - len;
#line 1441
  level = cur->fts_level + 1L;
#line 1444
  doadjust = (_Bool)0;
#line 1445
  head = (FTSENT *)((void *)0);
#line 1446
  tail = (FTSENT *)((void *)0);
#line 1447
  nitems = (size_t )0;
  {
#line 1448
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1448
    if (! cur->fts_dirp) {
#line 1448
      goto while_break___2;
    }
    {
#line 1451
    tmp___12 = readdir(cur->fts_dirp);
#line 1451
    dp___0 = tmp___12;
    }
#line 1452
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
#line 1453
      goto while_break___2;
    }
#line 1454
    if (! (sp->fts_options & 32)) {
#line 1454
      if ((int )dp___0->d_name[0] == 46) {
#line 1454
        if (! dp___0->d_name[1]) {
#line 1455
          goto while_continue___2;
        } else
#line 1454
        if ((int )dp___0->d_name[1] == 46) {
#line 1454
          if (! dp___0->d_name[2]) {
#line 1455
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1457
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1458
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1459
    if (! p) {
#line 1460
      goto mem1;
    }
#line 1461
    if (d_namelen >= maxlen) {
      {
#line 1463
      oldaddr = (void *)sp->fts_path;
#line 1464
      tmp___15 = fts_palloc(sp, (d_namelen + len) + 1UL);
      }
#line 1464
      if (! tmp___15) {
        mem1:
        {
#line 1470
        tmp___13 = __errno_location();
#line 1470
        saved_errno = *tmp___13;
#line 1471
        free((void *)p);
#line 1472
        fts_lfree(head);
        }
        {
#line 1473
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1473
          closedir(cur->fts_dirp);
#line 1473
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1473
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1474
        cur->fts_info = (unsigned short)7;
#line 1475
        sp->fts_options |= 16384;
#line 1476
        tmp___14 = __errno_location();
#line 1476
        *tmp___14 = saved_errno;
        }
#line 1477
        return ((FTSENT *)((void *)0));
      }
#line 1480
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1481
        doadjust = (_Bool)1;
#line 1482
        if (sp->fts_options & 4) {
#line 1483
          cp = sp->fts_path + len;
        }
      }
#line 1485
      maxlen = sp->fts_pathlen - len;
    }
#line 1488
    new_len = len + d_namelen;
#line 1489
    if (new_len < len) {
      {
#line 1496
      free((void *)p);
#line 1497
      fts_lfree(head);
      }
      {
#line 1498
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1498
        closedir(cur->fts_dirp);
#line 1498
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1498
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1499
      cur->fts_info = (unsigned short)7;
#line 1500
      sp->fts_options |= 16384;
#line 1501
      tmp___16 = __errno_location();
#line 1501
      *tmp___16 = 36;
      }
#line 1502
      return ((FTSENT *)((void *)0));
    }
#line 1504
    p->fts_level = level;
#line 1505
    p->fts_parent = sp->fts_cur;
#line 1506
    p->fts_pathlen = new_len;
#line 1510
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1513
    if (sp->fts_options & 4) {
      {
#line 1514
      p->fts_accpath = p->fts_path;
#line 1515
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1517
      p->fts_accpath = p->fts_name;
    }
#line 1519
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1519
      goto _L___1;
    } else
#line 1519
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */
#line 1532
      if (sp->fts_options & 16) {
#line 1532
        if (sp->fts_options & 8) {
#line 1532
          if ((int )dp___0->d_type != 0) {
#line 1532
            if (! ((int )dp___0->d_type == 4)) {
#line 1532
              tmp___17 = 1;
            } else {
#line 1532
              tmp___17 = 0;
            }
          } else {
#line 1532
            tmp___17 = 0;
          }
        } else {
#line 1532
          tmp___17 = 0;
        }
      } else {
#line 1532
        tmp___17 = 0;
      }
      {
#line 1532
      skip_stat = (_Bool )tmp___17;
#line 1536
      p->fts_info = (unsigned short)11;
#line 1539
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1540
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      }
#line 1541
      if (sp->fts_options & 16) {
#line 1541
        if ((int )dp___0->d_type == 4) {
#line 1541
          tmp___18 = 1;
        } else {
#line 1541
          tmp___18 = 0;
        }
      } else {
#line 1541
        tmp___18 = 0;
      }
#line 1541
      is_dir = (_Bool )tmp___18;
    } else {
      {
#line 1544
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
#line 1545
      if ((int )p->fts_info == 1) {
#line 1545
        tmp___19 = 1;
      } else
#line 1545
      if ((int )p->fts_info == 2) {
#line 1545
        tmp___19 = 1;
      } else
#line 1545
      if ((int )p->fts_info == 5) {
#line 1545
        tmp___19 = 1;
      } else {
#line 1545
        tmp___19 = 0;
      }
#line 1545
      is_dir = (_Bool )tmp___19;
    }
#line 1551
    if (nlinks > 0UL) {
#line 1551
      if (is_dir) {
#line 1552
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1555
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1556
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1557
      tail = p;
#line 1557
      head = tail;
    } else {
#line 1559
      tail->fts_link = p;
#line 1560
      tail = p;
    }
#line 1562
    nitems ++;
#line 1563
    if (max_entries <= nitems) {
#line 1567
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1571
  if (cur->fts_dirp) {
    {
#line 1572
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1572
      closedir(cur->fts_dirp);
#line 1572
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1572
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir:
#line 1580
  if (doadjust) {
    {
#line 1581
    fts_padjust(sp, head);
    }
  }
#line 1587
  if (sp->fts_options & 4) {
#line 1588
    if (len == sp->fts_pathlen) {
#line 1589
      cp --;
    } else
#line 1588
    if (nitems == 0UL) {
#line 1589
      cp --;
    }
#line 1590
    *cp = (char )'\000';
  }
#line 1600
  if (! continue_readdir) {
#line 1600
    if (descend) {
#line 1600
      if (type == 1) {
#line 1600
        goto _L___2;
      } else
#line 1600
      if (! nitems) {
        _L___2: /* CIL Label */
#line 1600
        if (cur->fts_level == 0L) {
          {
#line 1600
          tmp___20 = restore_initial_cwd(sp);
#line 1600
          tmp___22 = tmp___20;
          }
        } else {
          {
#line 1600
          tmp___21 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1600
          tmp___22 = tmp___21;
          }
        }
#line 1600
        if (tmp___22) {
          {
#line 1604
          cur->fts_info = (unsigned short)7;
#line 1605
          sp->fts_options |= 16384;
#line 1606
          fts_lfree(head);
          }
#line 1607
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1611
  if (! nitems) {
#line 1612
    if (type == 3) {
#line 1613
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1614
    fts_lfree(head);
    }
#line 1615
    return ((FTSENT *)((void *)0));
  }
#line 1622
  if (nitems > 10000UL) {
#line 1622
    if (! sp->fts_compar) {
#line 1622
      if (sp->fts_options & 512) {
        {
#line 1622
        tmp___23 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
#line 1622
        if (tmp___23) {
          {
#line 1626
          sp->fts_compar = & fts_compare_ino;
#line 1627
          head = fts_sort(sp, head, nitems);
#line 1628
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1632
  if (sp->fts_compar) {
#line 1632
    if (nitems > 1UL) {
      {
#line 1633
      head = fts_sort(sp, head, nitems);
      }
    }
  }
#line 1634
  return (head);
}
}
#line 1781 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow )
{
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1785
  sbp = p->fts_statp;
#line 1788
  if (p->fts_level == 0L) {
#line 1788
    if (sp->fts_options & 1) {
#line 1789
      follow = (_Bool)1;
    }
  }
#line 1796
  if (sp->fts_options & 2) {
#line 1796
    goto _L;
  } else
#line 1796
  if (follow) {
    _L: /* CIL Label */
    {
#line 1797
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1797
    if (tmp___3) {
      {
#line 1798
      tmp = __errno_location();
#line 1798
      saved_errno = *tmp;
#line 1799
      tmp___1 = __errno_location();
      }
#line 1799
      if (*tmp___1 == 2) {
        {
#line 1799
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1799
        if (tmp___2 == 0) {
          {
#line 1801
          tmp___0 = __errno_location();
#line 1801
          *tmp___0 = 0;
          }
#line 1802
          return ((unsigned short)13);
        }
      }
#line 1804
      p->fts_errno = saved_errno;
#line 1805
      goto err;
    }
  } else {
    {
#line 1807
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1807
    if (tmp___5) {
      {
#line 1809
      tmp___4 = __errno_location();
#line 1809
      p->fts_errno = *tmp___4;
      }
      err:
      {
#line 1810
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1811
      return ((unsigned short)10);
    }
  }
#line 1814
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1815
    if (sp->fts_options & 32) {
#line 1815
      tmp___6 = 0;
    } else {
#line 1815
      tmp___6 = 2;
    }
#line 1815
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1817
    if ((int )p->fts_name[0] == 46) {
#line 1817
      if (! p->fts_name[1]) {
#line 1817
        goto _L___0;
      } else
#line 1817
      if ((int )p->fts_name[1] == 46) {
#line 1817
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */
#line 1819
          if (p->fts_level == 0L) {
#line 1819
            tmp___7 = 1;
          } else {
#line 1819
            tmp___7 = 5;
          }
#line 1819
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1822
    return ((unsigned short)1);
  }
#line 1824
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1825
    return ((unsigned short)12);
  }
#line 1826
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1827
    return ((unsigned short)8);
  }
#line 1828
  return ((unsigned short)3);
}
}
#line 1831 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_compar(void const   *a , void const   *b )
{
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1839
  pa = (FTSENT const   **)a;
#line 1840
  pb = (FTSENT const   **)b;
#line 1841
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1841
  return (tmp);
}
}
#line 1844 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems )
{
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1858
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1858
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1858
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1858
      tmp = & fts_compar;
    }
  } else {
#line 1858
    tmp = & fts_compar;
  }
#line 1858
  compare = tmp;
#line 1871
  if (nitems > sp->fts_nitems) {
#line 1874
    sp->fts_nitems = nitems + 40UL;
#line 1875
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1878
      free((void *)sp->fts_array);
#line 1879
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1880
      sp->fts_nitems = (size_t )0;
      }
#line 1881
      return (head);
    } else {
      {
#line 1875
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1875
      a = (FTSENT **)tmp___0;
      }
#line 1875
      if (! a) {
        {
#line 1878
        free((void *)sp->fts_array);
#line 1879
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1880
        sp->fts_nitems = (size_t )0;
        }
#line 1881
        return (head);
      }
    }
#line 1883
    sp->fts_array = a;
  }
#line 1885
  ap = sp->fts_array;
#line 1885
  p = head;
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    if (! p) {
#line 1885
      goto while_break;
    }
#line 1886
    tmp___1 = ap;
#line 1886
    ap ++;
#line 1886
    *tmp___1 = p;
#line 1885
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1887
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1888
  ap = sp->fts_array;
#line 1888
  head = *ap;
  }
  {
#line 1888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1888
    nitems --;
#line 1888
    if (! nitems) {
#line 1888
      goto while_break___0;
    }
#line 1889
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1888
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1890
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1891
  return (head);
}
}
#line 1894 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen )
{
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1905
  len = sizeof(FTSENT ) + namelen;
#line 1906
  tmp = malloc(len);
#line 1906
  p = (FTSENT *)tmp;
  }
#line 1906
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1907
    return ((FTSENT *)((void *)0));
  }
  {
#line 1910
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1911
  p->fts_name[namelen] = (char )'\000';
#line 1913
  p->fts_namelen = namelen;
#line 1914
  p->fts_fts = sp;
#line 1915
  p->fts_path = sp->fts_path;
#line 1916
  p->fts_errno = 0;
#line 1917
  p->fts_dirp = (DIR *)((void *)0);
#line 1918
  p->fts_flags = (unsigned short)0;
#line 1919
  p->fts_instr = (unsigned short)3;
#line 1920
  p->fts_number = 0L;
#line 1921
  p->fts_pointer = (void *)0;
  }
#line 1922
  return (p);
}
}
#line 1925 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_lfree(FTSENT *head )
{
  register FTSENT *p ;

  {
  {
#line 1932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1932
    p = head;
#line 1932
    if (! p) {
#line 1932
      goto while_break;
    }
#line 1933
    head = head->fts_link;
#line 1934
    if (p->fts_dirp) {
      {
#line 1935
      closedir(p->fts_dirp);
      }
    }
    {
#line 1936
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1938
  return;
}
}
#line 1947 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more )
{
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1952
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1957
  if (new_len < sp->fts_pathlen) {
    {
#line 1958
    free((void *)sp->fts_path);
#line 1959
    sp->fts_path = (char *)((void *)0);
#line 1960
    tmp = __errno_location();
#line 1960
    *tmp = 36;
    }
#line 1961
    return ((_Bool)0);
  }
  {
#line 1963
  sp->fts_pathlen = new_len;
#line 1964
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1964
  p = (char *)tmp___0;
  }
#line 1965
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1966
    free((void *)sp->fts_path);
#line 1967
    sp->fts_path = (char *)((void *)0);
    }
#line 1968
    return ((_Bool)0);
  }
#line 1970
  sp->fts_path = p;
#line 1971
  return ((_Bool)1);
}
}
#line 1978 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head )
{
  FTSENT *p ;
  char *addr ;

  {
#line 1983
  addr = sp->fts_path;
#line 1993
  p = sp->fts_child;
  {
#line 1993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1993
    if (! p) {
#line 1993
      goto while_break;
    }
    {
#line 1994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1994
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1994
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1994
      p->fts_path = addr;
#line 1994
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1993
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1997
  p = head;
  {
#line 1997
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1997
    if (! (p->fts_level >= 0L)) {
#line 1997
      goto while_break___1;
    }
    {
#line 1998
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1998
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1998
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1998
      p->fts_path = addr;
#line 1998
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1999
    if (p->fts_link) {
#line 1999
      p = p->fts_link;
    } else {
#line 1999
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2001
  return;
}
}
#line 2003 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv )
{
  size_t len ;
  size_t max ;

  {
#line 2009
  max = (size_t )0;
  {
#line 2009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2009
    if (! *argv) {
#line 2009
      goto while_break;
    }
    {
#line 2010
    len = strlen((char const   *)*argv);
    }
#line 2010
    if (len > max) {
#line 2011
      max = len;
    }
#line 2009
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2012
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2024 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir )
{
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2029
  if (dir) {
    {
#line 2029
    tmp = strcmp(dir, "..");
    }
#line 2029
    if (tmp == 0) {
#line 2029
      tmp___0 = 1;
    } else {
#line 2029
      tmp___0 = 0;
    }
  } else {
#line 2029
    tmp___0 = 0;
  }
#line 2029
  is_dotdot = (_Bool )tmp___0;
#line 2036
  if (sp->fts_options & 4) {
#line 2038
    if (sp->fts_options & 512) {
#line 2038
      if (0 <= fd) {
        {
#line 2039
        close(fd);
        }
      }
    }
#line 2040
    return (0);
  }
#line 2043
  if (fd < 0) {
#line 2043
    if (is_dotdot) {
#line 2043
      if (sp->fts_options & 512) {
        {
#line 2050
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2050
        if (! tmp___1) {
          {
#line 2054
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2055
          is_dotdot = (_Bool)1;
          }
#line 2056
          if (0 <= parent_fd) {
#line 2058
            fd = parent_fd;
#line 2059
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2064
  newfd = fd;
#line 2065
  if (fd < 0) {
    {
#line 2065
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 2065
    if (newfd < 0) {
#line 2066
      return (-1);
    }
  }
#line 2075
  if (sp->fts_options & 2) {
#line 2075
    goto _L;
  } else
#line 2075
  if (dir) {
    {
#line 2075
    tmp___4 = strcmp(dir, "..");
    }
#line 2075
    if (tmp___4 == 0) {
      _L: /* CIL Label */
      {
#line 2079
      tmp___2 = fstat(newfd, & sb);
      }
#line 2079
      if (tmp___2) {
#line 2081
        ret = -1;
#line 2082
        goto bail;
      }
#line 2084
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2087
        tmp___3 = __errno_location();
#line 2087
        *tmp___3 = 2;
#line 2088
        ret = -1;
        }
#line 2089
        goto bail;
      } else
#line 2084
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2087
        tmp___3 = __errno_location();
#line 2087
        *tmp___3 = 2;
#line 2088
        ret = -1;
        }
#line 2089
        goto bail;
      }
    }
  }
#line 2093
  if (sp->fts_options & 512) {
    {
#line 2095
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2096
    return (0);
  }
  {
#line 2099
  ret = fchdir(newfd);
  }
  bail:
#line 2101
  if (fd < 0) {
    {
#line 2103
    tmp___5 = __errno_location();
#line 2103
    oerrno = *tmp___5;
#line 2104
    close(newfd);
#line 2105
    tmp___6 = __errno_location();
#line 2105
    *tmp___6 = oerrno;
    }
  }
#line 2107
  return (ret);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/khheo/project/benchmark/grep-2.19/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix(char const   *f )
{


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 60 "/home/khheo/project/benchmark/grep-2.19/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result )
{
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = (char const   *)tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/fd-safer.c"
int fd_safer(int fd )
{
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 403 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 232 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 168 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...)
{
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 172
  result = -1;
#line 173
  __builtin_va_start(arg, action);
  }
  {
#line 217
  if (action == 1030) {
#line 217
    goto case_1030;
  }
#line 298
  goto switch_default;
  case_1030: /* CIL Label */
  {
#line 219
  tmp___0 = __builtin_va_arg(arg, int );
#line 219
  target = tmp___0;
  }
#line 233
  if (0 <= have_dupfd_cloexec) {
    {
#line 235
    result = fcntl(fd, action, target);
    }
#line 236
    if (0 <= result) {
#line 238
      have_dupfd_cloexec = 1;
    } else {
      {
#line 236
      tmp___1 = __errno_location();
      }
#line 236
      if (*tmp___1 != 22) {
#line 238
        have_dupfd_cloexec = 1;
      } else {
        {
#line 246
        result = rpl_fcntl(fd, 0, target);
        }
#line 247
        if (result < 0) {
#line 248
          goto switch_break;
        }
#line 249
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 253
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 254
  if (0 <= result) {
#line 254
    if (have_dupfd_cloexec == -1) {
      {
#line 256
      tmp___2 = fcntl(result, 1);
#line 256
      flags = tmp___2;
      }
#line 257
      if (flags < 0) {
#line 257
        goto _L;
      } else {
        {
#line 257
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 257
        if (tmp___5 == -1) {
          _L: /* CIL Label */
          {
#line 259
          tmp___3 = __errno_location();
#line 259
          saved_errno = *tmp___3;
#line 260
          close(result);
#line 261
          tmp___4 = __errno_location();
#line 261
          *tmp___4 = saved_errno;
#line 262
          result = -1;
          }
        }
      }
    }
  }
#line 265
  goto switch_break;
  switch_default: /* CIL Label */
  {
#line 301
  tmp___7 = __builtin_va_arg(arg, void *);
#line 301
  p = tmp___7;
#line 302
  result = fcntl(fd, action, p);
  }
#line 306
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 309
  __builtin_va_end(arg);
  }
#line 310
  return (result);
}
}
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 648 "./regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 652
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 660
extern void regfree(regex_t *__preg ) ;
#line 49 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 51
struct exclude *new_exclude(void) ;
#line 52
void free_exclude(struct exclude *ex ) ;
#line 53
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 54
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 56
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data ) ;
#line 58
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 59
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) ;
#line 60
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
void exclude_add_pattern_buffer(struct exclude *ex , char *buf )
{
  struct pattern_buffer *pbuf ;
  void *tmp ;

  {
  {
#line 134
  tmp = xmalloc(sizeof(*pbuf));
#line 134
  pbuf = (struct pattern_buffer *)tmp;
#line 135
  pbuf->base = buf;
#line 136
  pbuf->next = ex->patbuf;
#line 137
  ex->patbuf = pbuf;
  }
#line 138
  return;
}
}
#line 142
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 142 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )
{
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    tmp = str;
#line 147
    str ++;
    {
#line 153
    if ((int const   )*tmp == 41) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 40) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 125) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 123) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 46) {
#line 153
      goto case_41;
    }
#line 158
    if ((int const   )*tmp == 92) {
#line 158
      goto case_92;
    }
#line 165
    if ((int const   )*tmp == 33) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 64) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 43) {
#line 165
      goto case_33;
    }
#line 170
    if ((int const   )*tmp == 91) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 42) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 63) {
#line 170
      goto case_91;
    }
#line 173
    if ((int const   )*tmp == 0) {
#line 173
      goto case_0;
    }
#line 147
    goto switch_break;
    case_41: /* CIL Label */
    case_40: /* CIL Label */
    case_125: /* CIL Label */
    case_123: /* CIL Label */
    case_46: /* CIL Label */
#line 154
    if (options & (1 << 27)) {
#line 155
      return ((_Bool)1);
    }
#line 156
    goto switch_break;
    case_92: /* CIL Label */
#line 159
    if (options & (1 << 27)) {
#line 160
      goto while_continue;
    } else {
#line 162
      if (! (options & (1 << 1))) {
#line 162
        if (*str) {
#line 162
          tmp___0 = 1;
        } else {
#line 162
          tmp___0 = 0;
        }
      } else {
#line 162
        tmp___0 = 0;
      }
#line 162
      str += tmp___0;
    }
#line 163
    goto switch_break;
    case_33: /* CIL Label */
    case_64: /* CIL Label */
    case_43: /* CIL Label */
#line 166
    if (options & (1 << 5)) {
#line 166
      if ((int const   )*str == 40) {
#line 167
        return ((_Bool)1);
      }
    }
#line 168
    goto switch_break;
    case_91: /* CIL Label */
    case_42: /* CIL Label */
    case_63: /* CIL Label */
#line 171
    return ((_Bool)1);
    case_0: /* CIL Label */
#line 174
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 179 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void unescape_pattern(char *str )
{
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
struct exclude *new_exclude(void)
{
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 193
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 193
  return ((struct exclude *)tmp___0);
}
}
#line 197 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets )
{
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets )
{
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 )
{
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 )
{
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void string_free(void *data )
{


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void new_exclude_segment(struct exclude *ex , enum exclude_type type , int options )
{
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */
#line 263
  goto switch_break;
  case_0: /* CIL Label */
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci;
  } else {
#line 266
    tmp___0 = & string_compare;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci;
  } else {
#line 266
    tmp___1 = & string_hasher;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg )
{
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 305 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
void free_exclude(struct exclude *ex )
{
  struct exclude_segment *seg ;
  struct pattern_buffer *pbuf ;
  struct exclude_segment *next ;
  struct pattern_buffer *next___0 ;

  {
#line 311
  seg = ex->head;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! seg) {
#line 311
      goto while_break;
    }
    {
#line 313
    next = seg->next;
#line 314
    free_exclude_segment(seg);
#line 315
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  pbuf = ex->patbuf;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! pbuf) {
#line 318
      goto while_break___0;
    }
    {
#line 320
    next___0 = pbuf->next;
#line 321
    free((void *)pbuf->base);
#line 322
    free((void *)pbuf);
#line 323
    pbuf = next___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  free((void *)ex);
  }
#line 327
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 377 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options )
{
  int (*matcher___0)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 380
  if (options & (1 << 28)) {
#line 380
    tmp = & fnmatch;
  } else {
#line 380
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 380
  matcher___0 = tmp;
#line 384
  tmp___0 = (*matcher___0)(pattern, f, options);
#line 384
  matched = (_Bool )(tmp___0 == 0);
  }
#line 387
  if (! (options & (1 << 30))) {
#line 388
    p = f;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (*p) {
#line 388
        if (! (! matched)) {
#line 388
          goto while_break;
        }
      } else {
#line 388
        goto while_break;
      }
#line 389
      if ((int const   )*p == 47) {
#line 389
        if ((int const   )*(p + 1) != 47) {
          {
#line 390
          tmp___1 = (*matcher___0)(pattern, p + 1, options);
#line 390
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 388
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 392
  return (matched);
}
}
#line 395 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
_Bool exclude_patopts(struct patopts  const  *opts , char const   *f )
{
  int options ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options = (int )opts->options;
#line 400
  if (options & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool file_pattern_matches(struct exclude_segment  const  *seg , char const   *f )
{
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool file_name_matches(struct exclude_segment  const  *seg , char const   *f ,
                               char *buffer___0 )
{
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 469 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f )
{
  struct exclude_segment *seg ;
  _Bool invert ;
  char *filename___0 ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 473
  invert = (_Bool)0;
#line 474
  filename___0 = (char *)((void *)0);
#line 477
  if (! ex->head) {
#line 478
    return ((_Bool)0);
  }
#line 483
  seg = (struct exclude_segment *)ex->head;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if ((unsigned int )seg->type == 0U) {
#line 487
      if (! filename___0) {
        {
#line 488
        tmp = strlen(f);
#line 488
        tmp___0 = xmalloc(tmp + 1UL);
#line 488
        filename___0 = (char *)tmp___0;
        }
      }
      {
#line 489
      tmp___1 = file_name_matches((struct exclude_segment  const  *)seg, f, filename___0);
      }
#line 489
      if (tmp___1) {
#line 490
        goto while_break;
      }
    } else {
      {
#line 494
      tmp___2 = file_pattern_matches((struct exclude_segment  const  *)seg, f);
      }
#line 494
      if (tmp___2) {
#line 495
        goto while_break;
      }
    }
#line 498
    if (! seg->next) {
#line 506
      invert = (_Bool)1;
#line 507
      goto while_break;
    }
#line 483
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  free((void *)filename___0);
  }
#line 512
  return ((_Bool )((int )invert ^ ! (seg->options & (1 << 29))));
}
}
#line 517 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options )
{
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  int rc ;
  int cflags ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t len ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *str ;
  char *p ;
  int exclude_hash_flags ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 524
  if (options & ((1 << 27) | (1 << 28))) {
    {
#line 524
    tmp___7 = fnmatch_pattern_has_wildcards(pattern, options);
    }
#line 524
    if (tmp___7) {
#line 527
      if (ex->head) {
#line 527
        if ((unsigned int )(ex->head)->type == 1U) {
#line 527
          if (! (((ex->head)->options & (1 << 29)) == (options & (1 << 29)))) {
            {
#line 530
            new_exclude_segment(ex, (enum exclude_type )1, options);
            }
          }
        } else {
          {
#line 530
          new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        }
      } else {
        {
#line 530
        new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      }
#line 532
      seg = ex->head;
#line 534
      pat = & seg->v.pat;
#line 535
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 536
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 536
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 538
      tmp___0 = pat->exclude_count;
#line 538
      (pat->exclude_count) ++;
#line 538
      patopts = pat->exclude + tmp___0;
#line 540
      patopts->options = options;
#line 541
      if (options & (1 << 27)) {
#line 544
        if (options & (1 << 4)) {
#line 544
          tmp___1 = 1 << 1;
        } else {
#line 544
          tmp___1 = 0;
        }
#line 544
        cflags = ((1 << 3) | 1) | tmp___1;
#line 547
        if (options & (1 << 3)) {
          {
#line 550
          tmp___3 = strlen(pattern);
#line 550
          len = tmp___3;
          }
          {
#line 552
          while (1) {
            while_continue: /* CIL Label */ ;
#line 552
            if (len > 0UL) {
#line 552
              if (! ((int const   )*(pattern + (len - 1UL)) == 47)) {
#line 552
                goto while_break;
              }
            } else {
#line 552
              goto while_break;
            }
#line 553
            len --;
          }
          while_break: /* CIL Label */ ;
          }
#line 555
          if (len == 0UL) {
#line 556
            rc = 1;
          } else {
            {
#line 559
            tmp___4 = xmalloc(len + 7UL);
#line 559
            tmp___2 = (char *)tmp___4;
#line 560
            memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)pattern,
                   len);
#line 561
            strcpy((char */* __restrict  */)(tmp___2 + len), (char const   */* __restrict  */)"(/.*)?");
#line 562
            rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)tmp___2,
                         cflags);
#line 563
            free((void *)tmp___2);
            }
          }
        } else {
          {
#line 567
          rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)pattern,
                       cflags);
          }
        }
#line 569
        if (rc) {
#line 571
          (pat->exclude_count) --;
#line 572
          return;
        }
      } else {
#line 577
        if (options & (1 << 26)) {
          {
#line 579
          tmp___5 = xstrdup(pattern);
#line 579
          pattern = (char const   *)tmp___5;
#line 580
          exclude_add_pattern_buffer(ex, (char *)pattern);
          }
        }
#line 582
        patopts->v.pattern = pattern;
      }
    } else {
#line 524
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 588
    exclude_hash_flags = (((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4);
#line 590
    if (ex->head) {
#line 590
      if ((unsigned int )(ex->head)->type == 0U) {
#line 590
        if (! (((ex->head)->options & exclude_hash_flags) == (options & exclude_hash_flags))) {
          {
#line 593
          new_exclude_segment(ex, (enum exclude_type )0, options);
          }
        }
      } else {
        {
#line 593
        new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      }
    } else {
      {
#line 593
      new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    }
    {
#line 594
    seg = ex->head;
#line 596
    str = xstrdup(pattern);
    }
#line 597
    if ((options & ((1 << 28) | (1 << 1))) == 1 << 28) {
      {
#line 598
      unescape_pattern(str);
      }
    }
    {
#line 599
    tmp___6 = hash_insert(seg->v.table, (void const   *)str);
#line 599
    p = (char *)tmp___6;
    }
#line 600
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 601
      free((void *)str);
      }
    }
  }
#line 603
  return;
}
}
#line 610 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data )
{
  char *buf ;
  char *p ;
  char *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *pattern_end ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 616
  buf = (char *)((void *)0);
#line 620
  buf_alloc = (size_t )0;
#line 621
  buf_count = (size_t )0;
#line 623
  e = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    c = getc_unlocked(fp);
    }
#line 625
    if (! (c != -1)) {
#line 625
      goto while_break;
    }
#line 627
    if (buf_count == buf_alloc) {
      {
#line 628
      tmp = x2realloc((void *)buf, & buf_alloc);
#line 628
      buf = (char *)tmp;
      }
    }
#line 629
    tmp___0 = buf_count;
#line 629
    buf_count ++;
#line 629
    *(buf + tmp___0) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  tmp___2 = ferror_unlocked(fp);
  }
#line 632
  if (tmp___2) {
    {
#line 633
    tmp___1 = __errno_location();
#line 633
    e = *tmp___1;
    }
  }
  {
#line 635
  tmp___3 = xrealloc((void *)buf, buf_count + 1UL);
#line 635
  buf = (char *)tmp___3;
#line 636
  *(buf + buf_count) = line_end;
  }
#line 637
  if (buf_count == 0UL) {
#line 637
    tmp___4 = 0;
  } else
#line 637
  if ((int )*(buf + (buf_count - 1UL)) == (int )line_end) {
#line 637
    tmp___4 = 0;
  } else {
#line 637
    tmp___4 = 1;
  }
  {
#line 637
  lim = (char const   *)((buf + buf_count) + tmp___4);
#line 639
  exclude_add_pattern_buffer(ex, buf);
#line 641
  pattern = buf;
#line 643
  p = buf;
  }
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 643
      goto while_break___0;
    }
#line 644
    if ((int )*p == (int )line_end) {
      {
#line 646
      pattern_end = p;
#line 648
      tmp___6 = __ctype_b_loc();
      }
#line 648
      if ((int const   )*(*tmp___6 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 650
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 651
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 652
            goto next_pattern;
          } else {
            {
#line 653
            tmp___5 = __ctype_b_loc();
            }
#line 653
            if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 654
              goto while_break___1;
            }
          }
#line 650
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 657
      *pattern_end = (char )'\000';
#line 658
      (*add_func)(ex, (char const   *)pattern, options, data);
      }
      next_pattern:
#line 661
      pattern = p + 1;
    }
#line 643
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 664
  tmp___7 = __errno_location();
#line 664
  *tmp___7 = e;
  }
#line 665
  if (e) {
#line 665
    tmp___8 = -1;
  } else {
#line 665
    tmp___8 = 0;
  }
#line 665
  return (tmp___8);
}
}
#line 668 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void call_addfn(struct exclude *ex , char const   *pattern , int options ,
                       void *data )
{
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 675 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end )
{
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  int rc ;
  int tmp___0 ;

  {
#line 680
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 680
    if (! *(file_name___1 + 1)) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 680
  use_stdin = (_Bool )tmp;
#line 682
  rc = 0;
#line 684
  if (use_stdin) {
#line 685
    in = stdin;
  } else {
    {
#line 686
    in = fopen((char const   */* __restrict  */)file_name___1, (char const   */* __restrict  */)"r");
    }
#line 686
    if (! in) {
#line 687
      return (-1);
    }
  }
  {
#line 689
  rc = add_exclude_fp(& call_addfn, ex, in, options, line_end, (void *)(& add_func));
  }
#line 691
  if (! use_stdin) {
    {
#line 691
    tmp___0 = fclose(in);
    }
#line 691
    if (tmp___0 != 0) {
#line 692
      rc = -1;
    }
  }
#line 694
  return (rc);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-2.19/lib/dup-safer.c"
int dup_safer(int fd )
{
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.19/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 41
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )
{
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/grep-2.19/lib/dirname-lgpl.c"
char *mdir_name(char const   *file )
{
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two(uintmax_t i )
{


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state )
{


  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb )
{
  _Bool tmp___0 ;

  {
#line 60
  if (! (state->magic == 9827862)) {
    {
#line 60
    __assert_fail("state->magic == CC_MAGIC", "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.c",
                  60U, "cycle_check");
    }
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
  {
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp___0 = is_zero_or_power_of_two(state->chdir_counter);
  }
#line 70
  if (tmp___0) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 23 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode___0 ) ;
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 27 "/home/khheo/project/benchmark/grep-2.19/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode___0 )
{
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = creat(file, mode___0);
#line 30
  tmp___0 = fd_safer(tmp);
  }
#line 30
  return (tmp___0);
}
}
#line 22 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 19 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.h"
int should_colorize(void) ;
#line 20
void init_colorize(void) ;
#line 21
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) ;
#line 22
void print_end_colorize(char const   *sgr_end___0 ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
int should_colorize(void)
{
  char const   *t ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = getenv("TERM");
#line 39
  t = (char const   *)tmp;
  }
#line 40
  if (t) {
    {
#line 40
    tmp___0 = strcmp(t, "dumb");
    }
#line 40
    if (tmp___0 != 0) {
#line 40
      tmp___1 = 1;
    } else {
#line 40
      tmp___1 = 0;
    }
  } else {
#line 40
    tmp___1 = 0;
  }
#line 40
  return (tmp___1);
}
}
#line 43 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
void init_colorize(void)
{


  {
#line 43
  return;
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq )
{


  {
  {
#line 50
  printf((char const   */* __restrict  */)sgr_start___0, sgr_seq);
  }
#line 51
  return;
}
}
#line 54 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
void print_end_colorize(char const   *sgr_end___0 )
{


  {
  {
#line 57
  fputs((char const   */* __restrict  */)sgr_end___0, (FILE */* __restrict  */)stdout);
  }
#line 58
  return;
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/grep-2.19/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
void close_stdout_set_file_name(char const   *file )
{


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore )
{


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
void close_stdout(void)
{
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/grep-2.19/lib/close-stream.c"
int close_stream(FILE *stream )
{
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/cloexec.h"
int dup_cloexec(int fd ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/grep-2.19/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value )
{
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/khheo/project/benchmark/grep-2.19/lib/cloexec.c"
int dup_cloexec(int fd )
{
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 114 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 45 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static void cdb_init(struct cd_buf *cdb )
{


  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static int cdb_fchdir(struct cd_buf  const  *cdb )
{
  int tmp ;

  {
  {
#line 54
  tmp = fchdir((int )cdb->fd);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static void cdb_free(struct cd_buf  const  *cdb )
{
  _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
    {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
    }
#line 63
    if (! (! close_fail)) {
      {
#line 63
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                    63U, "cdb_free");
      }
    }
  }
#line 65
  return;
}
}
#line 71 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir )
{
  int new_fd ;
  int tmp ;

  {
  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = tmp;
  }
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
  {
#line 79
  cdb_free((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
  }
#line 82
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash(char const   *s )
{
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 89
  tmp = strspn(s, "/");
#line 89
  n_slash = tmp;
  }
#line 90
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 108 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
int chdir_long(char *dir )
{
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  char * __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char * __attribute__((__pure__)) tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int saved_errno ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 111
  tmp = chdir((char const   *)dir);
#line 111
  e = tmp;
  }
#line 112
  if (e == 0) {
#line 113
    return (e);
  } else {
    {
#line 112
    tmp___0 = __errno_location();
    }
#line 112
    if (*tmp___0 != 36) {
#line 113
      return (e);
    }
  }
  {
#line 116
  tmp___1 = strlen((char const   *)dir);
#line 116
  len = tmp___1;
#line 117
  dir_end = dir + len;
#line 121
  cdb_init(& cdb);
  }
#line 125
  if (! (0UL < len)) {
    {
#line 125
    __assert_fail("0 < len", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                  125U, "chdir_long");
    }
  }
#line 126
  if (! (4096UL <= len)) {
    {
#line 126
    __assert_fail("PATH_MAX <= len", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                  126U, "chdir_long");
    }
  }
  {
#line 129
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 136
  if (n_leading_slash == 2UL) {
    {
#line 141
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 141
    slash = (char *)tmp___4;
    }
#line 142
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 144
      tmp___5 = __errno_location();
#line 144
      *tmp___5 = 36;
      }
#line 145
      return (-1);
    }
    {
#line 147
    *slash = (char )'\000';
#line 148
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 149
    *slash = (char )'/';
    }
#line 150
    if (err != 0) {
#line 151
      goto Fail;
    }
    {
#line 152
    tmp___6 = find_non_slash((char const   *)(slash + 1));
#line 152
    dir = (char *)tmp___6;
    }
  } else
#line 154
  if (n_leading_slash) {
    {
#line 156
    tmp___7 = cdb_advance_fd(& cdb, "/");
    }
#line 156
    if (tmp___7 != 0) {
#line 157
      goto Fail;
    }
#line 158
    dir += n_leading_slash;
  }
#line 161
  if (! ((int )*dir != 47)) {
    {
#line 161
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                  161U, "chdir_long");
    }
  }
#line 162
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 162
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                  162U, "chdir_long");
    }
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (4096L <= dir_end - dir)) {
#line 164
      goto while_break;
    }
    {
#line 170
    tmp___10 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 170
    slash___0 = (char *)tmp___10;
    }
#line 171
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 173
      tmp___11 = __errno_location();
#line 173
      *tmp___11 = 36;
      }
#line 174
      return (-1);
    }
#line 177
    *slash___0 = (char )'\000';
#line 178
    if (! (slash___0 - dir < 4096L)) {
      {
#line 178
      __assert_fail("slash - dir < PATH_MAX", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                    178U, "chdir_long");
      }
    }
    {
#line 179
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 180
    *slash___0 = (char )'/';
    }
#line 181
    if (err___0 != 0) {
#line 182
      goto Fail;
    }
    {
#line 184
    tmp___13 = find_non_slash((char const   *)(slash___0 + 1));
#line 184
    dir = (char *)tmp___13;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 189
    tmp___14 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 189
    if (tmp___14 != 0) {
#line 190
      goto Fail;
    }
  }
  {
#line 193
  tmp___15 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 193
  if (tmp___15 != 0) {
#line 194
    goto Fail;
  }
  {
#line 196
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 197
  return (0);
  Fail:
  {
#line 201
  tmp___16 = __errno_location();
#line 201
  saved_errno = *tmp___16;
#line 202
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 203
  tmp___17 = __errno_location();
#line 203
  *tmp___17 = saved_errno;
  }
#line 204
  return (-1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.19/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 135 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.h"
int c_tolower(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )
{
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )
{
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 120 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.h"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 122
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 123
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 124
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 125
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 126
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 127
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 128
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 129
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 130
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 131
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 132
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 133
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 136
int c_toupper(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isascii(int c )
{
  int tmp ;

  {
#line 29
  if (c >= 0) {
#line 29
    if (c <= 127) {
#line 29
      tmp = 1;
    } else {
#line 29
      tmp = 0;
    }
  } else {
#line 29
    tmp = 0;
  }
#line 29
  return ((_Bool )tmp);
}
}
#line 32
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isalnum(int c )
{
  int tmp ;

  {
#line 38
  if (c >= 48) {
#line 38
    if (c <= 57) {
#line 38
      tmp = 1;
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 38
  if ((c & -33) >= 65) {
#line 38
    if ((c & -33) <= 90) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
  } else {
#line 38
    tmp = 0;
  }
#line 38
  return ((_Bool )tmp);
}
}
#line 67
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 67 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isalpha(int c )
{
  int tmp ;

  {
#line 72
  if ((c & -33) >= 65) {
#line 72
    if ((c & -33) <= 90) {
#line 72
      tmp = 1;
    } else {
#line 72
      tmp = 0;
    }
  } else {
#line 72
    tmp = 0;
  }
#line 72
  return ((_Bool )tmp);
}
}
#line 96
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 96 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isblank(int c )
{
  int tmp ;

  {
#line 99
  if (c == 32) {
#line 99
    tmp = 1;
  } else
#line 99
  if (c == 9) {
#line 99
    tmp = 1;
  } else {
#line 99
    tmp = 0;
  }
#line 99
  return ((_Bool )tmp);
}
}
#line 102
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 102 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_iscntrl(int c )
{
  int tmp ;

  {
#line 106
  if ((c & -32) == 0) {
#line 106
    tmp = 1;
  } else
#line 106
  if (c == 127) {
#line 106
    tmp = 1;
  } else {
#line 106
    tmp = 0;
  }
#line 106
  return ((_Bool )tmp);
}
}
#line 136
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 136 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isdigit(int c )
{
  int tmp ;

  {
#line 140
  if (c >= 48) {
#line 140
    if (c <= 57) {
#line 140
      tmp = 1;
    } else {
#line 140
      tmp = 0;
    }
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return ((_Bool )tmp);
}
}
#line 153
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 153 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_islower(int c )
{
  int tmp ;

  {
#line 157
  if (c >= 97) {
#line 157
    if (c <= 122) {
#line 157
      tmp = 1;
    } else {
#line 157
      tmp = 0;
    }
  } else {
#line 157
    tmp = 0;
  }
#line 157
  return ((_Bool )tmp);
}
}
#line 173
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 173 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isgraph(int c )
{
  int tmp ;

  {
#line 177
  if (c >= 33) {
#line 177
    if (c <= 126) {
#line 177
      tmp = 1;
    } else {
#line 177
      tmp = 0;
    }
  } else {
#line 177
    tmp = 0;
  }
#line 177
  return ((_Bool )tmp);
}
}
#line 207
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 207 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isprint(int c )
{
  int tmp ;

  {
#line 211
  if (c >= 32) {
#line 211
    if (c <= 126) {
#line 211
      tmp = 1;
    } else {
#line 211
      tmp = 0;
    }
  } else {
#line 211
    tmp = 0;
  }
#line 211
  return ((_Bool )tmp);
}
}
#line 241
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 241 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_ispunct(int c )
{
  int tmp ;

  {
#line 245
  if (c >= 33) {
#line 245
    if (c <= 126) {
#line 245
      if (c >= 48) {
#line 245
        if (c <= 57) {
#line 245
          tmp = 0;
        } else {
#line 245
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 245
      if ((c & -33) >= 65) {
#line 245
        if ((c & -33) <= 90) {
#line 245
          tmp = 0;
        } else {
#line 245
          tmp = 1;
        }
      } else {
#line 245
        tmp = 1;
      }
    } else {
#line 245
      tmp = 0;
    }
  } else {
#line 245
    tmp = 0;
  }
#line 245
  return ((_Bool )tmp);
}
}
#line 265
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 265 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isspace(int c )
{
  int tmp ;

  {
#line 268
  if (c == 32) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 9) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 10) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 11) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 12) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 13) {
#line 268
    tmp = 1;
  } else {
#line 268
    tmp = 0;
  }
#line 268
  return ((_Bool )tmp);
}
}
#line 272
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 272 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isupper(int c )
{
  int tmp ;

  {
#line 276
  if (c >= 65) {
#line 276
    if (c <= 90) {
#line 276
      tmp = 1;
    } else {
#line 276
      tmp = 0;
    }
  } else {
#line 276
    tmp = 0;
  }
#line 276
  return ((_Bool )tmp);
}
}
#line 292
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 292 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
_Bool c_isxdigit(int c )
{
  int tmp ;

  {
#line 298
  if (c >= 48) {
#line 298
    if (c <= 57) {
#line 298
      tmp = 1;
    } else {
#line 298
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 298
  if ((c & -33) >= 65) {
#line 298
    if ((c & -33) <= 70) {
#line 298
      tmp = 1;
    } else {
#line 298
      tmp = 0;
    }
  } else {
#line 298
    tmp = 0;
  }
#line 298
  return ((_Bool )tmp);
}
}
#line 319
int c_tolower(int c )  __attribute__((__const__)) ;
#line 319 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
int c_tolower(int c )
{
  int tmp ;

  {
#line 323
  if (c >= 65) {
#line 323
    if (c <= 90) {
#line 323
      tmp = (c - 65) + 97;
    } else {
#line 323
      tmp = c;
    }
  } else {
#line 323
    tmp = c;
  }
#line 323
  return (tmp);
}
}
#line 358
int c_toupper(int c )  __attribute__((__const__)) ;
#line 358 "/home/khheo/project/benchmark/grep-2.19/lib/c-ctype.c"
int c_toupper(int c )
{
  int tmp ;

  {
#line 362
  if (c >= 97) {
#line 362
    if (c <= 122) {
#line 362
      tmp = (c - 97) + 65;
    } else {
#line 362
      tmp = c;
    }
  } else {
#line 362
    tmp = c;
  }
#line 362
  return (tmp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 52 "/home/khheo/project/benchmark/grep-2.19/lib/binary-io.h"
__inline int set_binary_mode(int fd , int mode___0 )
{


  {
#line 57
  return (0);
}
}
#line 73
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/basename-lgpl.c"
char *last_component(char const   *name )
{
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/basename-lgpl.c"
size_t base_len(char const   *name )
{
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 56
void (*argmatch_die)(void) ;
#line 60
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 72
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 83
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 98
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 545 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
void usage(int status ) ;
#line 60 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
static void __argmatch_die(void)
{


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 68 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 82 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )
{
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem )
{
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize )
{
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0UL) {
      {
#line 158
      tmp___0 = quote((char const   *)*(arglist + i));
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp___0);
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___2 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___2) {
        {
#line 158
        tmp___0 = quote((char const   *)*(arglist + i));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp___0);
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        tmp___1 = quote((char const   *)*(arglist + i));
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___1);
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  putc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) )
{
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 195 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )
{
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale___2(unsigned long *x , int scale_factor )
{


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(unsigned long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___2(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale___3(long *x , int scale_factor )
{


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___3(long *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___3(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol-error.c"
static void xstrtol_error___0(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                              char const   *arg , int exit_status )
{
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */
  case_2: /* CIL Label */
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale___4(intmax_t *x , int scale_factor )
{


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.19/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___4(intmax_t *x , int base , int power )
{
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___4(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 28
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 28
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 20 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/cjk.h"
static int is_cjk_encoding___0(char const   *encoding )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data___0[1728]  =
#line 35 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191,
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191,
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251,
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20,
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0,
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7,
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27,
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127,
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31,
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195,
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0,
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63,
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127,
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23,
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0,
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255,
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240,
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0,
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32,
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255,
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 280 "/home/khheo/project/benchmark/grep-2.19/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind___0[240]  =
#line 280
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3,
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7,
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10,
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1,
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1,
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17,
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21,
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 137 "/home/khheo/project/benchmark/grep-2.19/lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 102 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct quoting_options default_quoting_options___0  ;
#line 178 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct quoting_options quoting_options_from_style___0(enum quoting_style style )
{
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char const   *gettext_quote___0(char const   *msgid , enum quoting_style s )
{
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static size_t quotearg_buffer_restyled___0(char *buffer___0 , size_t buffersize ,
                                           char const   *arg , size_t argsize , enum quoting_style quoting_style ,
                                           int flags , unsigned int const   *quote_these_too ,
                                           char const   *left_quote , char const   *right_quote )
{
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___0 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */
  case_7: /* CIL Label */
  case_6: /* CIL Label */
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote___0("`", quoting_style);
#line 313
    right_quote = gettext_quote___0("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___0 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___7 = i == argsize;
    }
#line 343
    if (tmp___7) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (argsize == 0xffffffffffffffffUL) {
#line 349
          if (1UL < quote_string_len) {
            {
#line 349
            argsize = strlen(arg);
#line 349
            tmp___0 = argsize;
            }
          } else {
#line 349
            tmp___0 = argsize;
          }
        } else {
#line 349
          tmp___0 = argsize;
        }
#line 349
        if (i + quote_string_len <= tmp___0) {
          {
#line 349
          tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___1 == 0) {
#line 359
            if (elide_outer_quotes) {
#line 360
              goto force_outer_quoting_style;
            }
#line 361
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 364
    c = (unsigned char )*(arg + i);
    {
#line 367
    if ((int )c == 0) {
#line 367
      goto case_0___0;
    }
#line 393
    if ((int )c == 63) {
#line 393
      goto case_63;
    }
#line 431
    if ((int )c == 7) {
#line 431
      goto case_7___0;
    }
#line 432
    if ((int )c == 8) {
#line 432
      goto case_8___0;
    }
#line 433
    if ((int )c == 12) {
#line 433
      goto case_12;
    }
#line 434
    if ((int )c == 10) {
#line 434
      goto case_10;
    }
#line 435
    if ((int )c == 13) {
#line 435
      goto case_13;
    }
#line 436
    if ((int )c == 9) {
#line 436
      goto case_9;
    }
#line 437
    if ((int )c == 11) {
#line 437
      goto case_11;
    }
#line 438
    if ((int )c == 92) {
#line 438
      goto case_92;
    }
#line 457
    if ((int )c == 125) {
#line 457
      goto case_125;
    }
#line 457
    if ((int )c == 123) {
#line 457
      goto case_125;
    }
#line 461
    if ((int )c == 126) {
#line 461
      goto case_126;
    }
#line 461
    if ((int )c == 35) {
#line 461
      goto case_126;
    }
#line 473
    if ((int )c == 124) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 96) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 94) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 91) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 62) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 61) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 60) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 59) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 42) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 41) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 40) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 38) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 36) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 34) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 33) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 32) {
#line 473
      goto case_124;
    }
#line 483
    if ((int )c == 39) {
#line 483
      goto case_39___0;
    }
#line 505
    if ((int )c == 122) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 121) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 120) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 119) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 118) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 117) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 116) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 115) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 114) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 113) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 112) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 111) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 110) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 109) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 108) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 107) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 106) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 105) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 104) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 103) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 102) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 101) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 100) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 99) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 98) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 97) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 95) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 93) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 90) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 89) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 88) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 87) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 86) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 85) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 84) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 83) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 82) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 81) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 80) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 79) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 78) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 77) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 76) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 75) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 74) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 73) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 72) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 71) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 70) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 69) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 68) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 67) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 66) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 65) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 58) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 57) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 56) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 55) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 54) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 53) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 52) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 51) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 50) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 49) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 48) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 47) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 46) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 45) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 44) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 43) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 37) {
#line 505
      goto case_122;
    }
#line 518
    goto switch_default___2;
    case_0___0: /* CIL Label */
#line 368
    if (backslash_escapes) {
#line 370
      if (elide_outer_quotes) {
#line 371
        goto force_outer_quoting_style;
      }
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 372
        if (len < buffersize) {
#line 372
          *(buffer___0 + len) = (char )'\\';
        }
#line 372
        len ++;
#line 372
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (i + 1UL < argsize) {
#line 378
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 378
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 380
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 380
              if (len < buffersize) {
#line 380
                *(buffer___0 + len) = (char )'0';
              }
#line 380
              len ++;
#line 380
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 381
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 381
              if (len < buffersize) {
#line 381
                *(buffer___0 + len) = (char )'0';
              }
#line 381
              len ++;
#line 381
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 383
      c = (unsigned char )'0';
    } else
#line 389
    if (flags & 1) {
#line 390
      goto __Cont;
    }
#line 391
    goto switch_break___0;
    case_63: /* CIL Label */
    {
#line 396
    if ((unsigned int )quoting_style == 2U) {
#line 396
      goto case_2___0;
    }
#line 401
    if ((unsigned int )quoting_style == 3U) {
#line 401
      goto case_3___0;
    }
#line 426
    goto switch_default___1;
    case_2___0: /* CIL Label */
#line 397
    if (elide_outer_quotes) {
#line 398
      goto force_outer_quoting_style;
    }
#line 399
    goto switch_break___1;
    case_3___0: /* CIL Label */
#line 402
    if (flags & 4) {
#line 402
      if (i + 2UL < argsize) {
#line 402
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 408
            goto case_62;
          }
#line 421
          goto switch_default___0;
          case_62: /* CIL Label */
          case_61: /* CIL Label */
          case_60: /* CIL Label */
          case_47: /* CIL Label */
          case_45: /* CIL Label */
          case_41: /* CIL Label */
          case_40: /* CIL Label */
          case_39: /* CIL Label */
          case_33: /* CIL Label */
#line 411
          if (elide_outer_quotes) {
#line 412
            goto force_outer_quoting_style;
          }
#line 413
          c = (unsigned char )*(arg + (i + 2UL));
#line 414
          i += 2UL;
          {
#line 415
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 415
            if (len < buffersize) {
#line 415
              *(buffer___0 + len) = (char )'?';
            }
#line 415
            len ++;
#line 415
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 416
            if (len < buffersize) {
#line 416
              *(buffer___0 + len) = (char )'\"';
            }
#line 416
            len ++;
#line 416
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 417
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 417
            if (len < buffersize) {
#line 417
              *(buffer___0 + len) = (char )'\"';
            }
#line 417
            len ++;
#line 417
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 418
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 418
            if (len < buffersize) {
#line 418
              *(buffer___0 + len) = (char )'?';
            }
#line 418
            len ++;
#line 418
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 419
          goto switch_break___2;
          switch_default___0: /* CIL Label */
#line 422
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 424
    goto switch_break___1;
    switch_default___1: /* CIL Label */
#line 427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 429
    goto switch_break___0;
    case_7___0: /* CIL Label */
#line 431
    esc = (unsigned char )'a';
#line 431
    goto c_escape;
    case_8___0: /* CIL Label */
#line 432
    esc = (unsigned char )'b';
#line 432
    goto c_escape;
    case_12: /* CIL Label */
#line 433
    esc = (unsigned char )'f';
#line 433
    goto c_escape;
    case_10: /* CIL Label */
#line 434
    esc = (unsigned char )'n';
#line 434
    goto c_and_shell_escape;
    case_13: /* CIL Label */
#line 435
    esc = (unsigned char )'r';
#line 435
    goto c_and_shell_escape;
    case_9: /* CIL Label */
#line 436
    esc = (unsigned char )'t';
#line 436
    goto c_and_shell_escape;
    case_11: /* CIL Label */
#line 437
    esc = (unsigned char )'v';
#line 437
    goto c_escape;
    case_92: /* CIL Label */
#line 438
    esc = c;
#line 441
    if (backslash_escapes) {
#line 441
      if (elide_outer_quotes) {
#line 441
        if (quote_string_len) {
#line 442
          goto store_c;
        }
      }
    }
    c_and_shell_escape:
#line 445
    if ((unsigned int )quoting_style == 2U) {
#line 445
      if (elide_outer_quotes) {
#line 447
        goto force_outer_quoting_style;
      }
    }
    c_escape:
#line 450
    if (backslash_escapes) {
#line 452
      c = esc;
#line 453
      goto store_escape;
    }
#line 455
    goto switch_break___0;
    case_125: /* CIL Label */
    case_123: /* CIL Label */
#line 458
    if (argsize == 0xffffffffffffffffUL) {
#line 458
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 458
      tmp___2 = argsize == 1UL;
    }
#line 458
    if (! tmp___2) {
#line 459
      goto switch_break___0;
    }
    case_126: /* CIL Label */
    case_35: /* CIL Label */
#line 462
    if (i != 0UL) {
#line 463
      goto switch_break___0;
    }
    case_124: /* CIL Label */
    case_96: /* CIL Label */
    case_94: /* CIL Label */
    case_91: /* CIL Label */
    case_62___0: /* CIL Label */
    case_61___0: /* CIL Label */
    case_60___0: /* CIL Label */
    case_59: /* CIL Label */
    case_42: /* CIL Label */
    case_41___0: /* CIL Label */
    case_40___0: /* CIL Label */
    case_38: /* CIL Label */
    case_36: /* CIL Label */
    case_34: /* CIL Label */
    case_33___0: /* CIL Label */
    case_32: /* CIL Label */
#line 478
    if ((unsigned int )quoting_style == 2U) {
#line 478
      if (elide_outer_quotes) {
#line 480
        goto force_outer_quoting_style;
      }
    }
#line 481
    goto switch_break___0;
    case_39___0: /* CIL Label */
#line 484
    if ((unsigned int )quoting_style == 2U) {
#line 486
      if (elide_outer_quotes) {
#line 487
        goto force_outer_quoting_style;
      }
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (len < buffersize) {
#line 488
          *(buffer___0 + len) = (char )'\'';
        }
#line 488
        len ++;
#line 488
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 489
        if (len < buffersize) {
#line 489
          *(buffer___0 + len) = (char )'\\';
        }
#line 489
        len ++;
#line 489
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___0 + len) = (char )'\'';
        }
#line 490
        len ++;
#line 490
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 492
    goto switch_break___0;
    case_122: /* CIL Label */
    case_121: /* CIL Label */
    case_120: /* CIL Label */
    case_119: /* CIL Label */
    case_118: /* CIL Label */
    case_117: /* CIL Label */
    case_116: /* CIL Label */
    case_115: /* CIL Label */
    case_114: /* CIL Label */
    case_113: /* CIL Label */
    case_112: /* CIL Label */
    case_111: /* CIL Label */
    case_110: /* CIL Label */
    case_109: /* CIL Label */
    case_108: /* CIL Label */
    case_107: /* CIL Label */
    case_106: /* CIL Label */
    case_105: /* CIL Label */
    case_104: /* CIL Label */
    case_103: /* CIL Label */
    case_102: /* CIL Label */
    case_101: /* CIL Label */
    case_100: /* CIL Label */
    case_99: /* CIL Label */
    case_98: /* CIL Label */
    case_97: /* CIL Label */
    case_95: /* CIL Label */
    case_93: /* CIL Label */
    case_90: /* CIL Label */
    case_89: /* CIL Label */
    case_88: /* CIL Label */
    case_87: /* CIL Label */
    case_86: /* CIL Label */
    case_85: /* CIL Label */
    case_84: /* CIL Label */
    case_83: /* CIL Label */
    case_82: /* CIL Label */
    case_81: /* CIL Label */
    case_80: /* CIL Label */
    case_79: /* CIL Label */
    case_78: /* CIL Label */
    case_77: /* CIL Label */
    case_76: /* CIL Label */
    case_75: /* CIL Label */
    case_74: /* CIL Label */
    case_73: /* CIL Label */
    case_72: /* CIL Label */
    case_71: /* CIL Label */
    case_70: /* CIL Label */
    case_69: /* CIL Label */
    case_68: /* CIL Label */
    case_67: /* CIL Label */
    case_66: /* CIL Label */
    case_65: /* CIL Label */
    case_58: /* CIL Label */
    case_57: /* CIL Label */
    case_56: /* CIL Label */
    case_55: /* CIL Label */
    case_54: /* CIL Label */
    case_53: /* CIL Label */
    case_52: /* CIL Label */
    case_51: /* CIL Label */
    case_50: /* CIL Label */
    case_49: /* CIL Label */
    case_48: /* CIL Label */
    case_47___0: /* CIL Label */
    case_46: /* CIL Label */
    case_45___0: /* CIL Label */
    case_44: /* CIL Label */
    case_43: /* CIL Label */
    case_37: /* CIL Label */
#line 516
    goto switch_break___0;
    switch_default___2: /* CIL Label */
#line 530
    if (unibyte_locale) {
      {
#line 532
      m = (size_t )1;
#line 533
      tmp___3 = __ctype_b_loc();
#line 533
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 538
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 540
      m = (size_t )0;
#line 541
      printable = (_Bool)1;
      }
#line 542
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 543
        argsize = strlen(arg);
        }
      }
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 548
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 548
        bytes = tmp___4;
        }
#line 550
        if (bytes == 0UL) {
#line 551
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xffffffffffffffffUL) {
#line 554
          printable = (_Bool)0;
#line 555
          goto while_break___14;
        } else
#line 557
        if (bytes == 0xfffffffffffffffeUL) {
#line 559
          printable = (_Bool)0;
          {
#line 560
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 560
            if (i + m < argsize) {
#line 560
              if (! *(arg + (i + m))) {
#line 560
                goto while_break___15;
              }
            } else {
#line 560
              goto while_break___15;
            }
#line 561
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 562
          goto while_break___14;
        } else {
#line 570
          if (elide_outer_quotes) {
#line 570
            if ((unsigned int )quoting_style == 2U) {
#line 574
              j = (size_t )1;
              {
#line 574
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 574
                if (! (j < bytes)) {
#line 574
                  goto while_break___16;
                }
                {
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 578
                  goto case_124___0;
                }
#line 581
                goto switch_default___3;
                case_124___0: /* CIL Label */
                case_96___0: /* CIL Label */
                case_94___0: /* CIL Label */
                case_92___0: /* CIL Label */
                case_91___0: /* CIL Label */
#line 579
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */
#line 582
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 574
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 586
          tmp___5 = iswprint((wint_t )w);
          }
#line 586
          if (! tmp___5) {
#line 587
            printable = (_Bool)0;
          }
#line 588
          m += bytes;
        }
        {
#line 545
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 545
        if (tmp___6) {
#line 545
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 594
    if (1UL < m) {
#line 594
      goto _L___0;
    } else
#line 594
    if (backslash_escapes) {
#line 594
      if (! printable) {
        _L___0: /* CIL Label */
#line 598
        ilim = i + m;
        {
#line 600
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 602
          if (backslash_escapes) {
#line 602
            if (! printable) {
#line 604
              if (elide_outer_quotes) {
#line 605
                goto force_outer_quoting_style;
              }
              {
#line 606
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 606
                if (len < buffersize) {
#line 606
                  *(buffer___0 + len) = (char )'\\';
                }
#line 606
                len ++;
#line 606
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 607
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 607
                if (len < buffersize) {
#line 607
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 607
                len ++;
#line 607
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 608
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 608
                if (len < buffersize) {
#line 608
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 608
                len ++;
#line 608
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 609
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 602
              goto _L;
            }
          } else
          _L: /* CIL Label */
#line 611
          if (is_right_quote) {
            {
#line 613
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 613
              if (len < buffersize) {
#line 613
                *(buffer___0 + len) = (char )'\\';
              }
#line 613
              len ++;
#line 613
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 614
            is_right_quote = (_Bool)0;
          }
#line 616
          if (ilim <= i + 1UL) {
#line 617
            goto while_break___17;
          }
          {
#line 618
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 618
            if (len < buffersize) {
#line 618
              *(buffer___0 + len) = (char )c;
            }
#line 618
            len ++;
#line 618
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 619
          i ++;
#line 619
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 622
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (backslash_escapes) {
#line 627
      goto _L___3;
    } else
#line 627
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */
#line 627
      if (quote_these_too) {
#line 627
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 627
          goto _L___2;
        }
      } else {
#line 627
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */
#line 627
    if (! is_right_quote) {
#line 631
      goto store_c;
    }
    store_escape:
#line 634
    if (elide_outer_quotes) {
#line 635
      goto force_outer_quoting_style;
    }
    {
#line 636
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 636
      if (len < buffersize) {
#line 636
        *(buffer___0 + len) = (char )'\\';
      }
#line 636
      len ++;
#line 636
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c:
    {
#line 639
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 639
      if (len < buffersize) {
#line 639
        *(buffer___0 + len) = (char )c;
      }
#line 639
      len ++;
#line 639
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 642
  if (len == 0UL) {
#line 642
    if ((unsigned int )quoting_style == 2U) {
#line 642
      if (elide_outer_quotes) {
#line 644
        goto force_outer_quoting_style;
      }
    }
  }
#line 646
  if (quote_string) {
#line 646
    if (! elide_outer_quotes) {
      {
#line 647
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 647
        if (! *quote_string) {
#line 647
          goto while_break___25;
        }
        {
#line 648
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 648
          if (len < buffersize) {
#line 648
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 648
          len ++;
#line 648
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 647
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 650
  if (len < buffersize) {
#line 651
    *(buffer___0 + len) = (char )'\000';
  }
#line 652
  return (len);
  force_outer_quoting_style:
  {
#line 657
  tmp___8 = quotearg_buffer_restyled___0(buffer___0, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0),
                                         left_quote, right_quote);
  }
#line 657
  return (tmp___8);
}
}
#line 731 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char slot0___0[256]  ;
#line 732 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static unsigned int nslots___0  =    1U;
#line 733 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct slotvec slotvec0___0  =    {sizeof(slot0___0), slot0___0};
#line 734 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static struct slotvec *slotvec___0  =    & slotvec0___0;
#line 765 "/home/khheo/project/benchmark/grep-2.19/lib/quotearg.c"
static char *quotearg_n_options___0(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options )
{
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 769
  tmp = __errno_location();
#line 769
  e = *tmp;
#line 771
  n0 = (unsigned int )n;
#line 772
  sv = slotvec___0;
  }
#line 774
  if (n < 0) {
    {
#line 775
    abort();
    }
  }
#line 777
  if (nslots___0 <= n0) {
#line 784
    n1 = (size_t )(n0 + 1U);
#line 785
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0___0));
#line 787
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 787
      tmp___0 = -1;
    } else {
#line 787
      tmp___0 = -2;
    }
#line 787
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 788
      xalloc_die();
      }
    }
#line 790
    if (preallocated) {
#line 790
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 790
      tmp___1 = sv;
    }
    {
#line 790
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 790
    sv = (struct slotvec *)tmp___2;
#line 790
    slotvec___0 = sv;
    }
#line 791
    if (preallocated) {
#line 792
      *sv = slotvec0___0;
    }
    {
#line 793
    memset((void *)(sv + nslots___0), 0, (n1 - (size_t )nslots___0) * sizeof(*sv));
#line 794
    nslots___0 = (unsigned int )n1;
    }
  }
  {
#line 798
  size = (sv + n)->size;
#line 799
  val = (sv + n)->val;
#line 801
  flags = (int )(options->flags | 1);
#line 802
  tmp___3 = quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                         flags, (unsigned int const   *)(options->quote_these_too),
                                         (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 802
  qsize = tmp___3;
  }
#line 808
  if (size <= qsize) {
#line 810
    size = qsize + 1UL;
#line 810
    (sv + n)->size = size;
#line 811
    if ((unsigned long )val != (unsigned long )(slot0___0)) {
      {
#line 812
      free((void *)val);
      }
    }
    {
#line 813
    val = xcharalloc(size);
#line 813
    (sv + n)->val = val;
#line 814
    quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                 flags, (unsigned int const   *)(options->quote_these_too),
                                 (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 820
  tmp___4 = __errno_location();
#line 820
  *tmp___4 = e;
  }
#line 821
  return (val);
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54 "/home/khheo/project/benchmark/grep-2.19/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded___0(char const   *string , char const   *sub )
{
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 58 "/home/khheo/project/benchmark/grep-2.19/lib/openat-proc.c"
static int proc_status___0  =    0;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-2.19/lib/str-kmp.h"
static _Bool knuth_morris_pratt___0(unsigned char const   *haystack , unsigned char const   *needle ,
                                    size_t needle_len , unsigned char const   **resultp )
{
  size_t m ;
  size_t *table ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 42
    tmp___4 = -1;
  } else {
#line 42
    tmp___4 = -2;
  }
#line 42
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 42
    tmp___3 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 42
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___2 = tmp___1;
      }
    }
#line 42
    tmp___3 = tmp___2;
  }
#line 42
  table = (size_t *)tmp___3;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.19/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte___0(char const   *haystack , char const   *needle ,
                                              char const   **resultp )
{
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
      }
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = tmp___4;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 53
  table = (size_t *)table_memory;
#line 60
  j = (size_t )0;
#line 61
  iter.cur.ptr = needle;
#line 61
  iter.in_shift = (_Bool)0;
#line 61
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 61
  iter.next_done = (_Bool)0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    mbuiter_multi_next(& iter);
    }
#line 61
    if (iter.cur.wc_valid) {
#line 61
      if (iter.cur.wc == 0) {
#line 61
        tmp___6 = 0;
      } else {
#line 61
        tmp___6 = 1;
      }
    } else {
#line 61
      tmp___6 = 1;
    }
#line 61
    if (! tmp___6) {
#line 61
      goto while_break;
    }
    {
#line 62
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 61
    iter.cur.ptr += iter.cur.bytes;
#line 61
    iter.next_done = (_Bool)0;
#line 61
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(table + 1) = (size_t )1;
#line 85
  j___0 = (size_t )0;
#line 87
  i = (size_t )2;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < m)) {
#line 87
      goto while_break___0;
    }
#line 93
    b = needle_mbchars + (i - 1UL);
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 100
      if (b->wc_valid) {
#line 100
        if ((needle_mbchars + j___0)->wc_valid) {
#line 100
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 100
          goto _L;
        }
      } else {
        _L: /* CIL Label */
#line 100
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 100
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 100
          if (tmp___7 == 0) {
#line 100
            tmp___8 = 1;
          } else {
#line 100
            tmp___8 = 0;
          }
        } else {
#line 100
          tmp___8 = 0;
        }
#line 100
        tmp___9 = tmp___8;
      }
#line 100
      if (tmp___9) {
#line 103
        j___0 ++;
#line 103
        *(table + i) = i - j___0;
#line 104
        goto while_break___1;
      }
#line 109
      if (j___0 == 0UL) {
#line 112
        *(table + i) = i;
#line 113
        goto while_break___1;
      }
#line 126
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 87
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  *resultp = (char const   *)((void *)0);
#line 139
  j___1 = (size_t )0;
#line 140
  rhaystack.cur.ptr = haystack;
#line 140
  rhaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  rhaystack.next_done = (_Bool)0;
#line 141
  phaystack.cur.ptr = haystack;
#line 141
  phaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  phaystack.next_done = (_Bool)0;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 143
    mbuiter_multi_next(& phaystack);
    }
#line 143
    if (phaystack.cur.wc_valid) {
#line 143
      if (phaystack.cur.wc == 0) {
#line 143
        tmp___15 = 0;
      } else {
#line 143
        tmp___15 = 1;
      }
    } else {
#line 143
      tmp___15 = 1;
    }
#line 143
    if (! tmp___15) {
#line 143
      goto while_break___2;
    }
#line 144
    if ((needle_mbchars + j___1)->wc_valid) {
#line 144
      if (phaystack.cur.wc_valid) {
#line 144
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 144
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */
#line 144
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 144
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 144
        if (tmp___12 == 0) {
#line 144
          tmp___13 = 1;
        } else {
#line 144
          tmp___13 = 0;
        }
      } else {
#line 144
        tmp___13 = 0;
      }
#line 144
      tmp___14 = tmp___13;
    }
#line 144
    if (tmp___14) {
#line 146
      j___1 ++;
#line 147
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 147
      phaystack.next_done = (_Bool)0;
#line 148
      if (j___1 == m) {
#line 151
        *resultp = rhaystack.cur.ptr;
#line 152
        goto while_break___2;
      }
    } else
#line 155
    if (j___1 > 0UL) {
#line 158
      count = *(table + j___1);
#line 159
      j___1 -= count;
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (count > 0UL)) {
#line 160
          goto while_break___3;
        }
        {
#line 162
        mbuiter_multi_next(& rhaystack);
        }
#line 162
        if (rhaystack.cur.wc_valid) {
#line 162
          if (rhaystack.cur.wc == 0) {
#line 162
            tmp___10 = 0;
          } else {
#line 162
            tmp___10 = 1;
          }
        } else {
#line 162
          tmp___10 = 1;
        }
#line 162
        if (! tmp___10) {
          {
#line 163
          abort();
          }
        }
#line 164
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 164
        rhaystack.next_done = (_Bool)0;
#line 160
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 170
      mbuiter_multi_next(& rhaystack);
      }
#line 170
      if (rhaystack.cur.wc_valid) {
#line 170
        if (rhaystack.cur.wc == 0) {
#line 170
          tmp___11 = 0;
        } else {
#line 170
          tmp___11 = 1;
        }
      } else {
#line 170
        tmp___11 = 1;
      }
#line 170
      if (! tmp___11) {
        {
#line 171
        abort();
        }
      }
#line 172
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 172
      rhaystack.next_done = (_Bool)0;
#line 173
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 173
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 177
  freea(memory);
  }
#line 178
  return ((_Bool)1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.19/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 69 "/home/khheo/project/benchmark/grep-2.19/lib/malloca.c"
static void *mmalloca_results___0[257]  ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 143
#pragma weak pthread_self
#line 147
#pragma weak pthread_cancel
#line 454 "/home/khheo/project/benchmark/grep-2.19/lib/glthread/lock.c"
static int const   fresh_once___0  =    (pthread_once_t const   )0;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 119 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.c"
static char const   * volatile  charset_aliases___0  ;
#line 122 "/home/khheo/project/benchmark/grep-2.19/lib/localcharset.c"
static char const   *get_charset_aliases___0(void)
{
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 127
  cp = (char const   *)charset_aliases___0;
#line 128
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 132
    base = "charset.alias";
#line 137
    tmp = getenv("CHARSETALIASDIR");
#line 137
    dir = (char const   *)tmp;
    }
#line 138
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 139
      dir = "/usr/local/lib";
    } else
#line 138
    if ((int const   )*(dir + 0) == 0) {
#line 139
      dir = "/usr/local/lib";
    }
    {
#line 143
    tmp___0 = strlen(dir);
#line 143
    dir_len___0 = tmp___0;
#line 144
    tmp___1 = strlen(base);
#line 144
    base_len___0 = tmp___1;
    }
#line 145
    if (dir_len___0 > 0UL) {
#line 145
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 145
        tmp___2 = 1;
      } else {
#line 145
        tmp___2 = 0;
      }
    } else {
#line 145
      tmp___2 = 0;
    }
    {
#line 145
    add_slash = tmp___2;
#line 146
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 146
    file_name___1 = (char *)tmp___3;
    }
#line 147
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 149
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 150
      if (add_slash) {
#line 151
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 152
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 156
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 158
      cp = "";
    } else {
      {
#line 170
      fd = open((char const   *)file_name___1, 131072);
      }
#line 172
      if (fd < 0) {
#line 174
        cp = "";
      } else {
        {
#line 179
        fp = fdopen(fd, "r");
        }
#line 180
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 183
          close(fd);
#line 184
          cp = "";
          }
        } else {
#line 189
          res_ptr = (char *)((void *)0);
#line 190
          res_size = (size_t )0;
          {
#line 192
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 200
            c = getc_unlocked(fp);
            }
#line 201
            if (c == -1) {
#line 202
              goto while_break;
            }
#line 203
            if (c == 10) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 32) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 9) {
#line 204
              goto __Cont;
            }
#line 205
            if (c == 35) {
              {
#line 208
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 209
                c = getc_unlocked(fp);
                }
#line 208
                if (c == -1) {
#line 208
                  goto while_break___0;
                } else
#line 208
                if (c == 10) {
#line 208
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 211
              if (c == -1) {
#line 212
                goto while_break;
              }
#line 213
              goto __Cont;
            }
            {
#line 215
            ungetc(c, fp);
#line 216
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 216
            if (tmp___4 < 2) {
#line 217
              goto while_break;
            }
            {
#line 218
            l1 = strlen((char const   *)(buf1));
#line 219
            l2 = strlen((char const   *)(buf2));
#line 220
            old_res_ptr = res_ptr;
            }
#line 221
            if (res_size == 0UL) {
              {
#line 223
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 224
              tmp___5 = malloc(res_size + 1UL);
#line 224
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 228
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___6;
              }
            }
#line 231
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 234
              res_size = (size_t )0;
#line 235
              free((void *)old_res_ptr);
              }
#line 236
              goto while_break;
            }
            {
#line 238
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 239
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 241
          fclose(fp);
          }
#line 242
          if (res_size == 0UL) {
#line 243
            cp = "";
          } else {
#line 246
            *(res_ptr + res_size) = (char )'\000';
#line 247
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 252
      free((void *)file_name___1);
      }
    }
#line 346
    charset_aliases___0 = (char const   */* volatile  */)cp;
  }
#line 349
  return (cp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_tuning  const  default_tuning___0  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 248 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_entry *safe_hasher___0(Hash_table const   *table , void const   *key )
{
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 443
static _Bool is_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool is_prime___0(size_t candidate )
{
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t next_prime___0(size_t candidate )
{
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime___0(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 485 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t raw_hasher___0(void const   *data , size_t n )
{
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool raw_comparator___0(void const   *a , void const   *b )
{


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool check_tuning___0(Hash_table *table )
{
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning___0)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning___0;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size___0(size_t candidate ,
                                                                 Hash_tuning const   *tuning )
{
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime___0(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 750 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static struct hash_entry *allocate_entry___0(Hash_table *table )
{
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static void free_entry___0(Hash_table *table , struct hash_entry *entry )
{


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static void *hash_find_entry___0(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                                 _Bool delete___0 )
{
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher___0((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */
#line 805
      data = bucket->data;
#line 807
      if (delete___0) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry___0(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___0) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry___0(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-2.19/lib/hash.c"
static _Bool transfer_entries___0(Hash_table *dst , Hash_table *src , _Bool safe )
{
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry___0(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry___0(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.19/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) ;
#line 204
static FTSENT *fts_build___0(FTS *sp , int type ) ;
#line 205
static void fts_lfree___0(FTSENT *head ) ;
#line 206
static void fts_load___0(FTS *sp , FTSENT *p ) ;
#line 207
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) ;
#line 208
static void fts_padjust___0(FTS *sp , FTSENT *head ) ;
#line 209
static _Bool fts_palloc___0(FTS *sp , size_t more ) ;
#line 210
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 211
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 212
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool AD_compare___0(void const   *x , void const   *y )
{
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static size_t AD_hash___0(void const   *x , size_t table_size )
{
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool setup_dir___0(FTS *fts )
{
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash___0, & AD_compare___0, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static _Bool enter_dir___0(FTS *fts , FTSENT *ent )
{
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static void leave_dir___0(FTS *fts , FTSENT *ent )
{
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-2.19/lib/fts-cycle.c"
static void free_dir___0(FTS *sp )
{


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 268 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fd_ring_clear___0(I_ring *fd_ring )
{
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 271
    if (tmp___0) {
#line 271
      goto while_break;
    }
    {
#line 273
    tmp = i_ring_pop(fd_ring);
#line 273
    fd = tmp;
    }
#line 274
    if (0 <= fd) {
      {
#line 275
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 282 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_set_stat_required___0(FTSENT *p , _Bool required )
{


  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )p->fts_info == 11)) {
      {
#line 285
      abort();
      }
    }
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (required) {
#line 286
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 286
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 289
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static DIR *opendirat___0(int fd , char const   *dir , int extra_flags , int *pdir_fd )
{
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 297
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 297
  new_fd = tmp;
  }
#line 302
  if (new_fd < 0) {
#line 303
    return ((DIR *)((void *)0));
  }
  {
#line 304
  set_cloexec_flag(new_fd, (_Bool)1);
#line 305
  dirp = fdopendir(new_fd);
  }
#line 306
  if (dirp) {
#line 307
    *pdir_fd = new_fd;
  } else {
    {
#line 310
    tmp___0 = __errno_location();
#line 310
    saved_errno = *tmp___0;
#line 311
    close(new_fd);
#line 312
    tmp___1 = __errno_location();
#line 312
    *tmp___1 = saved_errno;
    }
  }
#line 314
  return (dirp);
}
}
#line 322 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void cwd_advance_fd___0(FTS *sp , int fd , _Bool chdir_down_one )
{
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 326
  old = sp->fts_cwd_fd;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (old != fd)) {
#line 327
      if (! (old == -100)) {
        {
#line 327
        abort();
        }
      }
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (chdir_down_one) {
    {
#line 333
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 333
    prev_fd_in_slot = tmp;
    }
#line 335
    if (0 <= prev_fd_in_slot) {
      {
#line 336
      close(prev_fd_in_slot);
      }
    }
  } else
#line 338
  if (! (sp->fts_options & 4)) {
#line 340
    if (0 <= old) {
      {
#line 341
      close(old);
      }
    }
  }
#line 344
  sp->fts_cwd_fd = fd;
#line 345
  return;
}
}
#line 351 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int restore_initial_cwd___0(FTS *sp )
{
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 354
  if (! (sp->fts_options & 4)) {
#line 354
    if (sp->fts_options & 512) {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp = -100;
      } else {
#line 354
        tmp = sp->fts_rfd;
      }
      {
#line 354
      cwd_advance_fd___0(sp, tmp, (_Bool)1);
#line 354
      tmp___2 = 0;
      }
    } else {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp___0 = -100;
      } else {
#line 354
        tmp___0 = sp->fts_rfd;
      }
      {
#line 354
      tmp___1 = fchdir(tmp___0);
#line 354
      tmp___2 = tmp___1;
      }
    }
#line 354
    if (tmp___2) {
#line 354
      tmp___3 = 1;
    } else {
#line 354
      tmp___3 = 0;
    }
  } else {
#line 354
    tmp___3 = 0;
  }
  {
#line 354
  fail = tmp___3;
#line 355
  fd_ring_clear___0(& sp->fts_fd_ring);
  }
#line 356
  return (fail);
}
}
#line 363 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int diropen___0(FTS const   *sp , char const   *dir )
{
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 367
  if (sp->fts_options & 16) {
#line 367
    tmp = 131072;
  } else {
#line 367
    tmp = 0;
  }
#line 367
  if (sp->fts_options & 2048) {
#line 367
    tmp___0 = 262144;
  } else {
#line 367
    tmp___0 = 0;
  }
#line 367
  open_flags = (67840 | tmp) | tmp___0;
#line 371
  if (sp->fts_options & 512) {
    {
#line 371
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 371
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 371
    tmp___2 = open_safer(dir, open_flags);
#line 371
    tmp___3 = tmp___2;
    }
  }
#line 371
  fd = tmp___3;
#line 374
  if (0 <= fd) {
    {
#line 375
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 376
  return (fd);
}
}
#line 569 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_load___0(FTS *sp , FTSENT *p )
{
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 583
  tmp = p->fts_namelen;
#line 583
  p->fts_pathlen = tmp;
#line 583
  len = tmp;
#line 584
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 585
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 585
  if (cp) {
#line 585
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    } else
#line 585
    if (*(cp + 1)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    }
  }
#line 590
  tmp___0 = sp->fts_path;
#line 590
  p->fts_path = tmp___0;
#line 590
  p->fts_accpath = tmp___0;
#line 591
  return;
}
}
#line 672 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful___0(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 683
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 683
  if (tmp != 0) {
#line 684
    return ((_Bool)1);
  }
  {
#line 691
  if (fs_buf.f_type == 26985L) {
#line 691
    goto case_26985;
  }
#line 691
  if (fs_buf.f_type == 16914836L) {
#line 691
    goto case_26985;
  }
#line 696
  goto switch_default;
  case_26985: /* CIL Label */
  case_16914836: /* CIL Label */
#line 694
  return ((_Bool)0);
  switch_default: /* CIL Label */
#line 697
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 704 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool leaf_optimization_applies___0(int dir_fd )
{
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 710
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 710
  if (tmp != 0) {
#line 711
    return ((_Bool)0);
  }
  {
#line 720
  if (fs_buf.f_type == 1382369651L) {
#line 720
    goto case_1382369651;
  }
#line 729
  goto switch_default;
  case_1382369651: /* CIL Label */
#line 721
  return ((_Bool)1);
  switch_default: /* CIL Label */
#line 730
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 754 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static size_t LCO_hash___0(void const   *x , size_t table_size )
{
  struct LCO_ent  const  *ax ;

  {
#line 757
  ax = (struct LCO_ent  const  *)x;
#line 758
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 761 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool LCO_compare___0(void const   *x , void const   *y )
{
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 764
  ax = (struct LCO_ent  const  *)x;
#line 765
  ay = (struct LCO_ent  const  *)y;
#line 766
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 772 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool link_count_optimize_ok___0(FTSENT const   *p )
{
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 775
  sp = (FTS *)p->fts_fts;
#line 776
  h = sp->fts_leaf_optimization_works_ht;
#line 784
  if (! (sp->fts_options & 512)) {
#line 785
    return ((_Bool)0);
  }
#line 788
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 790
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash___0,
                              & LCO_compare___0, (void (*)(void * ))(& free));
#line 790
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 790
    h = tmp___0;
    }
#line 793
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 794
      return ((_Bool)0);
    }
  }
  {
#line 796
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 797
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 797
  ent = (struct LCO_ent *)tmp___1;
  }
#line 798
  if (ent) {
#line 799
    return (ent->opt_ok);
  }
  {
#line 802
  tmp___2 = malloc(sizeof(*t2));
#line 802
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 803
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 804
    return ((_Bool)0);
  }
  {
#line 807
  opt_ok = leaf_optimization_applies___0(sp->fts_cwd_fd);
#line 808
  t2->opt_ok = opt_ok;
#line 809
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 811
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 811
  ent = (struct LCO_ent *)tmp___3;
  }
#line 812
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 815
    free((void *)t2);
    }
#line 816
    return ((_Bool)0);
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 818
      abort();
      }
    }
#line 818
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (opt_ok);
}
}
#line 1202 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_compare_ino___0(struct _ftsent  const  **a , struct _ftsent  const  **b )
{
  int tmp ;
  int tmp___0 ;

  {
#line 1205
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1205
    tmp___0 = -1;
  } else {
#line 1205
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1205
      tmp = 1;
    } else {
#line 1205
      tmp = 0;
    }
#line 1205
    tmp___0 = tmp;
  }
#line 1205
  return (tmp___0);
}
}
#line 1211 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void set_stat_type___0(struct stat *st , unsigned int dtype )
{
  mode_t type ;

  {
  {
#line 1217
  if (dtype == 6U) {
#line 1217
    goto case_6;
  }
#line 1220
  if (dtype == 2U) {
#line 1220
    goto case_2;
  }
#line 1223
  if (dtype == 4U) {
#line 1223
    goto case_4;
  }
#line 1226
  if (dtype == 1U) {
#line 1226
    goto case_1;
  }
#line 1229
  if (dtype == 10U) {
#line 1229
    goto case_10;
  }
#line 1232
  if (dtype == 8U) {
#line 1232
    goto case_8;
  }
#line 1235
  if (dtype == 12U) {
#line 1235
    goto case_12;
  }
#line 1238
  goto switch_default;
  case_6: /* CIL Label */
#line 1218
  type = (mode_t )24576;
#line 1219
  goto switch_break;
  case_2: /* CIL Label */
#line 1221
  type = (mode_t )8192;
#line 1222
  goto switch_break;
  case_4: /* CIL Label */
#line 1224
  type = (mode_t )16384;
#line 1225
  goto switch_break;
  case_1: /* CIL Label */
#line 1227
  type = (mode_t )4096;
#line 1228
  goto switch_break;
  case_10: /* CIL Label */
#line 1230
  type = (mode_t )40960;
#line 1231
  goto switch_break;
  case_8: /* CIL Label */
#line 1233
  type = (mode_t )32768;
#line 1234
  goto switch_break;
  case_12: /* CIL Label */
#line 1236
  type = (mode_t )49152;
#line 1237
  goto switch_break;
  switch_default: /* CIL Label */
#line 1239
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1241
  st->st_mode = type;
#line 1242
  return;
}
}
#line 1277 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_build___0(FTS *sp , int type )
{
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  size_t d_namelen ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  _Bool tmp___15 ;
  int *tmp___16 ;
  _Bool skip_stat ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  _Bool tmp___23 ;

  {
#line 1294
  cur = sp->fts_cur;
#line 1295
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1300
  if (continue_readdir) {
    {
#line 1302
    dp = cur->fts_dirp;
#line 1303
    dir_fd = dirfd(dp);
    }
#line 1304
    if (dir_fd < 0) {
      {
#line 1306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1306
        closedir(cur->fts_dirp);
#line 1306
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1306
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1307
      if (type == 3) {
        {
#line 1309
        cur->fts_info = (unsigned short)4;
#line 1310
        tmp = __errno_location();
#line 1310
        cur->fts_errno = *tmp;
        }
      }
#line 1312
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1319
    if (sp->fts_options & 16) {
#line 1319
      if (sp->fts_options & 1) {
#line 1319
        if (cur->fts_level == 0L) {
#line 1319
          tmp___2 = 0;
        } else {
#line 1319
          tmp___2 = 131072;
        }
      } else {
#line 1319
        tmp___2 = 131072;
      }
    } else {
#line 1319
      tmp___2 = 0;
    }
#line 1319
    if (sp->fts_options & 2048) {
#line 1319
      tmp___3 = 262144;
    } else {
#line 1319
      tmp___3 = 0;
    }
#line 1319
    if (! (sp->fts_options & 4)) {
#line 1319
      if (sp->fts_options & 512) {
#line 1319
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1319
        tmp___4 = -100;
      }
    } else {
#line 1319
      tmp___4 = -100;
    }
    {
#line 1319
    tmp___1 = opendirat___0(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                            & dir_fd);
#line 1319
    cur->fts_dirp = tmp___1;
    }
#line 1319
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1321
      if (type == 3) {
        {
#line 1323
        cur->fts_info = (unsigned short)4;
#line 1324
        tmp___0 = __errno_location();
#line 1324
        cur->fts_errno = *tmp___0;
        }
      }
#line 1326
      return ((FTSENT *)((void *)0));
    }
#line 1331
    if ((int )cur->fts_info == 11) {
      {
#line 1332
      cur->fts_info = fts_stat___0(sp, cur, (_Bool)0);
      }
    } else
#line 1333
    if (sp->fts_options & 256) {
      {
#line 1340
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1340
        leave_dir___0(sp, cur);
        }
#line 1340
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1341
      fts_stat___0(sp, cur, (_Bool)0);
#line 1342
      tmp___6 = enter_dir___0(sp, cur);
      }
#line 1342
      if (! tmp___6) {
        {
#line 1344
        tmp___5 = __errno_location();
#line 1344
        *tmp___5 = 12;
        }
#line 1345
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1357
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1357
    tmp___7 = 100000UL;
  } else {
#line 1357
    tmp___7 = 0xffffffffffffffffUL;
  }
#line 1357
  max_entries = tmp___7;
#line 1365
  if (type == 2) {
#line 1366
    nlinks = (nlink_t )0;
#line 1368
    nostat = (_Bool)0;
  } else
#line 1369
  if (sp->fts_options & 8) {
#line 1369
    if (sp->fts_options & 16) {
#line 1370
      if (sp->fts_options & 32) {
#line 1370
        tmp___8 = 0;
      } else {
#line 1370
        tmp___8 = 2;
      }
#line 1370
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
#line 1372
      nostat = (_Bool)1;
    } else {
#line 1374
      nlinks = (nlink_t )-1;
#line 1375
      nostat = (_Bool)0;
    }
  } else {
#line 1374
    nlinks = (nlink_t )-1;
#line 1375
    nostat = (_Bool)0;
  }
#line 1393
  if (continue_readdir) {
#line 1397
    descend = (_Bool)1;
  } else
#line 1399
  if (nlinks) {
#line 1399
    goto _L___0;
  } else
#line 1399
  if (type == 3) {
    _L___0: /* CIL Label */
#line 1400
    if (sp->fts_options & 512) {
      {
#line 1402
      dir_fd = dup_safer(dir_fd);
      }
#line 1403
      if (0 <= dir_fd) {
        {
#line 1404
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1406
    if (dir_fd < 0) {
#line 1406
      goto _L;
    } else {
      {
#line 1406
      tmp___10 = fts_safe_changedir___0(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1406
      if (tmp___10) {
        _L: /* CIL Label */
#line 1407
        if (nlinks) {
#line 1407
          if (type == 3) {
            {
#line 1408
            tmp___9 = __errno_location();
#line 1408
            cur->fts_errno = *tmp___9;
            }
          }
        }
#line 1409
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1410
        descend = (_Bool)0;
        {
#line 1411
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1411
          closedir(cur->fts_dirp);
#line 1411
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1411
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1412
        if (sp->fts_options & 512) {
#line 1412
          if (0 <= dir_fd) {
            {
#line 1413
            close(dir_fd);
            }
          }
        }
#line 1414
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1416
        descend = (_Bool)1;
      }
    }
  } else {
#line 1418
    descend = (_Bool)0;
  }
#line 1430
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1430
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1430
    len = cur->fts_pathlen;
  }
#line 1431
  if (sp->fts_options & 4) {
#line 1432
    cp = sp->fts_path + len;
#line 1433
    tmp___11 = cp;
#line 1433
    cp ++;
#line 1433
    *tmp___11 = (char )'/';
  } else {
#line 1436
    cp = (char *)((void *)0);
  }
#line 1438
  len ++;
#line 1439
  maxlen = sp->fts_pathlen - len;
#line 1441
  level = cur->fts_level + 1L;
#line 1444
  doadjust = (_Bool)0;
#line 1445
  head = (FTSENT *)((void *)0);
#line 1446
  tail = (FTSENT *)((void *)0);
#line 1447
  nitems = (size_t )0;
  {
#line 1448
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1448
    if (! cur->fts_dirp) {
#line 1448
      goto while_break___2;
    }
    {
#line 1451
    tmp___12 = readdir(cur->fts_dirp);
#line 1451
    dp___0 = tmp___12;
    }
#line 1452
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
#line 1453
      goto while_break___2;
    }
#line 1454
    if (! (sp->fts_options & 32)) {
#line 1454
      if ((int )dp___0->d_name[0] == 46) {
#line 1454
        if (! dp___0->d_name[1]) {
#line 1455
          goto while_continue___2;
        } else
#line 1454
        if ((int )dp___0->d_name[1] == 46) {
#line 1454
          if (! dp___0->d_name[2]) {
#line 1455
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1457
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1458
    p = fts_alloc___0(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1459
    if (! p) {
#line 1460
      goto mem1;
    }
#line 1461
    if (d_namelen >= maxlen) {
      {
#line 1463
      oldaddr = (void *)sp->fts_path;
#line 1464
      tmp___15 = fts_palloc___0(sp, (d_namelen + len) + 1UL);
      }
#line 1464
      if (! tmp___15) {
        mem1:
        {
#line 1470
        tmp___13 = __errno_location();
#line 1470
        saved_errno = *tmp___13;
#line 1471
        free((void *)p);
#line 1472
        fts_lfree___0(head);
        }
        {
#line 1473
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1473
          closedir(cur->fts_dirp);
#line 1473
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1473
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1474
        cur->fts_info = (unsigned short)7;
#line 1475
        sp->fts_options |= 16384;
#line 1476
        tmp___14 = __errno_location();
#line 1476
        *tmp___14 = saved_errno;
        }
#line 1477
        return ((FTSENT *)((void *)0));
      }
#line 1480
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1481
        doadjust = (_Bool)1;
#line 1482
        if (sp->fts_options & 4) {
#line 1483
          cp = sp->fts_path + len;
        }
      }
#line 1485
      maxlen = sp->fts_pathlen - len;
    }
#line 1488
    new_len = len + d_namelen;
#line 1489
    if (new_len < len) {
      {
#line 1496
      free((void *)p);
#line 1497
      fts_lfree___0(head);
      }
      {
#line 1498
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1498
        closedir(cur->fts_dirp);
#line 1498
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1498
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1499
      cur->fts_info = (unsigned short)7;
#line 1500
      sp->fts_options |= 16384;
#line 1501
      tmp___16 = __errno_location();
#line 1501
      *tmp___16 = 36;
      }
#line 1502
      return ((FTSENT *)((void *)0));
    }
#line 1504
    p->fts_level = level;
#line 1505
    p->fts_parent = sp->fts_cur;
#line 1506
    p->fts_pathlen = new_len;
#line 1510
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1513
    if (sp->fts_options & 4) {
      {
#line 1514
      p->fts_accpath = p->fts_path;
#line 1515
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1517
      p->fts_accpath = p->fts_name;
    }
#line 1519
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1519
      goto _L___1;
    } else
#line 1519
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */
#line 1532
      if (sp->fts_options & 16) {
#line 1532
        if (sp->fts_options & 8) {
#line 1532
          if ((int )dp___0->d_type != 0) {
#line 1532
            if (! ((int )dp___0->d_type == 4)) {
#line 1532
              tmp___17 = 1;
            } else {
#line 1532
              tmp___17 = 0;
            }
          } else {
#line 1532
            tmp___17 = 0;
          }
        } else {
#line 1532
          tmp___17 = 0;
        }
      } else {
#line 1532
        tmp___17 = 0;
      }
      {
#line 1532
      skip_stat = (_Bool )tmp___17;
#line 1536
      p->fts_info = (unsigned short)11;
#line 1539
      set_stat_type___0(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1540
      fts_set_stat_required___0(p, (_Bool )(! skip_stat));
      }
#line 1541
      if (sp->fts_options & 16) {
#line 1541
        if ((int )dp___0->d_type == 4) {
#line 1541
          tmp___18 = 1;
        } else {
#line 1541
          tmp___18 = 0;
        }
      } else {
#line 1541
        tmp___18 = 0;
      }
#line 1541
      is_dir = (_Bool )tmp___18;
    } else {
      {
#line 1544
      p->fts_info = fts_stat___0(sp, p, (_Bool)0);
      }
#line 1545
      if ((int )p->fts_info == 1) {
#line 1545
        tmp___19 = 1;
      } else
#line 1545
      if ((int )p->fts_info == 2) {
#line 1545
        tmp___19 = 1;
      } else
#line 1545
      if ((int )p->fts_info == 5) {
#line 1545
        tmp___19 = 1;
      } else {
#line 1545
        tmp___19 = 0;
      }
#line 1545
      is_dir = (_Bool )tmp___19;
    }
#line 1551
    if (nlinks > 0UL) {
#line 1551
      if (is_dir) {
#line 1552
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1555
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1556
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1557
      tail = p;
#line 1557
      head = tail;
    } else {
#line 1559
      tail->fts_link = p;
#line 1560
      tail = p;
    }
#line 1562
    nitems ++;
#line 1563
    if (max_entries <= nitems) {
#line 1567
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1571
  if (cur->fts_dirp) {
    {
#line 1572
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1572
      closedir(cur->fts_dirp);
#line 1572
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1572
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir:
#line 1580
  if (doadjust) {
    {
#line 1581
    fts_padjust___0(sp, head);
    }
  }
#line 1587
  if (sp->fts_options & 4) {
#line 1588
    if (len == sp->fts_pathlen) {
#line 1589
      cp --;
    } else
#line 1588
    if (nitems == 0UL) {
#line 1589
      cp --;
    }
#line 1590
    *cp = (char )'\000';
  }
#line 1600
  if (! continue_readdir) {
#line 1600
    if (descend) {
#line 1600
      if (type == 1) {
#line 1600
        goto _L___2;
      } else
#line 1600
      if (! nitems) {
        _L___2: /* CIL Label */
#line 1600
        if (cur->fts_level == 0L) {
          {
#line 1600
          tmp___20 = restore_initial_cwd___0(sp);
#line 1600
          tmp___22 = tmp___20;
          }
        } else {
          {
#line 1600
          tmp___21 = fts_safe_changedir___0(sp, cur->fts_parent, -1, "..");
#line 1600
          tmp___22 = tmp___21;
          }
        }
#line 1600
        if (tmp___22) {
          {
#line 1604
          cur->fts_info = (unsigned short)7;
#line 1605
          sp->fts_options |= 16384;
#line 1606
          fts_lfree___0(head);
          }
#line 1607
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1611
  if (! nitems) {
#line 1612
    if (type == 3) {
#line 1613
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1614
    fts_lfree___0(head);
    }
#line 1615
    return ((FTSENT *)((void *)0));
  }
#line 1622
  if (nitems > 10000UL) {
#line 1622
    if (! sp->fts_compar) {
#line 1622
      if (sp->fts_options & 512) {
        {
#line 1622
        tmp___23 = dirent_inode_sort_may_be_useful___0(sp->fts_cwd_fd);
        }
#line 1622
        if (tmp___23) {
          {
#line 1626
          sp->fts_compar = & fts_compare_ino___0;
#line 1627
          head = fts_sort___0(sp, head, nitems);
#line 1628
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1632
  if (sp->fts_compar) {
#line 1632
    if (nitems > 1UL) {
      {
#line 1633
      head = fts_sort___0(sp, head, nitems);
      }
    }
  }
#line 1634
  return (head);
}
}
#line 1781 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow )
{
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1785
  sbp = p->fts_statp;
#line 1788
  if (p->fts_level == 0L) {
#line 1788
    if (sp->fts_options & 1) {
#line 1789
      follow = (_Bool)1;
    }
  }
#line 1796
  if (sp->fts_options & 2) {
#line 1796
    goto _L;
  } else
#line 1796
  if (follow) {
    _L: /* CIL Label */
    {
#line 1797
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1797
    if (tmp___3) {
      {
#line 1798
      tmp = __errno_location();
#line 1798
      saved_errno = *tmp;
#line 1799
      tmp___1 = __errno_location();
      }
#line 1799
      if (*tmp___1 == 2) {
        {
#line 1799
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1799
        if (tmp___2 == 0) {
          {
#line 1801
          tmp___0 = __errno_location();
#line 1801
          *tmp___0 = 0;
          }
#line 1802
          return ((unsigned short)13);
        }
      }
#line 1804
      p->fts_errno = saved_errno;
#line 1805
      goto err;
    }
  } else {
    {
#line 1807
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1807
    if (tmp___5) {
      {
#line 1809
      tmp___4 = __errno_location();
#line 1809
      p->fts_errno = *tmp___4;
      }
      err:
      {
#line 1810
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1811
      return ((unsigned short)10);
    }
  }
#line 1814
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1815
    if (sp->fts_options & 32) {
#line 1815
      tmp___6 = 0;
    } else {
#line 1815
      tmp___6 = 2;
    }
#line 1815
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1817
    if ((int )p->fts_name[0] == 46) {
#line 1817
      if (! p->fts_name[1]) {
#line 1817
        goto _L___0;
      } else
#line 1817
      if ((int )p->fts_name[1] == 46) {
#line 1817
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */
#line 1819
          if (p->fts_level == 0L) {
#line 1819
            tmp___7 = 1;
          } else {
#line 1819
            tmp___7 = 5;
          }
#line 1819
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1822
    return ((unsigned short)1);
  }
#line 1824
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1825
    return ((unsigned short)12);
  }
#line 1826
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1827
    return ((unsigned short)8);
  }
#line 1828
  return ((unsigned short)3);
}
}
#line 1831 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_compar___0(void const   *a , void const   *b )
{
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1839
  pa = (FTSENT const   **)a;
#line 1840
  pb = (FTSENT const   **)b;
#line 1841
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1841
  return (tmp);
}
}
#line 1844 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems )
{
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1858
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1858
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1858
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1858
      tmp = & fts_compar___0;
    }
  } else {
#line 1858
    tmp = & fts_compar___0;
  }
#line 1858
  compare = tmp;
#line 1871
  if (nitems > sp->fts_nitems) {
#line 1874
    sp->fts_nitems = nitems + 40UL;
#line 1875
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1878
      free((void *)sp->fts_array);
#line 1879
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1880
      sp->fts_nitems = (size_t )0;
      }
#line 1881
      return (head);
    } else {
      {
#line 1875
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1875
      a = (FTSENT **)tmp___0;
      }
#line 1875
      if (! a) {
        {
#line 1878
        free((void *)sp->fts_array);
#line 1879
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1880
        sp->fts_nitems = (size_t )0;
        }
#line 1881
        return (head);
      }
    }
#line 1883
    sp->fts_array = a;
  }
#line 1885
  ap = sp->fts_array;
#line 1885
  p = head;
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    if (! p) {
#line 1885
      goto while_break;
    }
#line 1886
    tmp___1 = ap;
#line 1886
    ap ++;
#line 1886
    *tmp___1 = p;
#line 1885
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1887
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1888
  ap = sp->fts_array;
#line 1888
  head = *ap;
  }
  {
#line 1888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1888
    nitems --;
#line 1888
    if (! nitems) {
#line 1888
      goto while_break___0;
    }
#line 1889
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1888
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1890
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1891
  return (head);
}
}
#line 1894 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen )
{
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1905
  len = sizeof(FTSENT ) + namelen;
#line 1906
  tmp = malloc(len);
#line 1906
  p = (FTSENT *)tmp;
  }
#line 1906
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1907
    return ((FTSENT *)((void *)0));
  }
  {
#line 1910
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1911
  p->fts_name[namelen] = (char )'\000';
#line 1913
  p->fts_namelen = namelen;
#line 1914
  p->fts_fts = sp;
#line 1915
  p->fts_path = sp->fts_path;
#line 1916
  p->fts_errno = 0;
#line 1917
  p->fts_dirp = (DIR *)((void *)0);
#line 1918
  p->fts_flags = (unsigned short)0;
#line 1919
  p->fts_instr = (unsigned short)3;
#line 1920
  p->fts_number = 0L;
#line 1921
  p->fts_pointer = (void *)0;
  }
#line 1922
  return (p);
}
}
#line 1925 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_lfree___0(FTSENT *head )
{
  register FTSENT *p ;

  {
  {
#line 1932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1932
    p = head;
#line 1932
    if (! p) {
#line 1932
      goto while_break;
    }
#line 1933
    head = head->fts_link;
#line 1934
    if (p->fts_dirp) {
      {
#line 1935
      closedir(p->fts_dirp);
      }
    }
    {
#line 1936
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1938
  return;
}
}
#line 1947 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static _Bool fts_palloc___0(FTS *sp , size_t more )
{
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1952
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1957
  if (new_len < sp->fts_pathlen) {
    {
#line 1958
    free((void *)sp->fts_path);
#line 1959
    sp->fts_path = (char *)((void *)0);
#line 1960
    tmp = __errno_location();
#line 1960
    *tmp = 36;
    }
#line 1961
    return ((_Bool)0);
  }
  {
#line 1963
  sp->fts_pathlen = new_len;
#line 1964
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1964
  p = (char *)tmp___0;
  }
#line 1965
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1966
    free((void *)sp->fts_path);
#line 1967
    sp->fts_path = (char *)((void *)0);
    }
#line 1968
    return ((_Bool)0);
  }
#line 1970
  sp->fts_path = p;
#line 1971
  return ((_Bool)1);
}
}
#line 1978 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static void fts_padjust___0(FTS *sp , FTSENT *head )
{
  FTSENT *p ;
  char *addr ;

  {
#line 1983
  addr = sp->fts_path;
#line 1993
  p = sp->fts_child;
  {
#line 1993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1993
    if (! p) {
#line 1993
      goto while_break;
    }
    {
#line 1994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1994
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1994
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1994
      p->fts_path = addr;
#line 1994
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1993
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1997
  p = head;
  {
#line 1997
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1997
    if (! (p->fts_level >= 0L)) {
#line 1997
      goto while_break___1;
    }
    {
#line 1998
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1998
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1998
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1998
      p->fts_path = addr;
#line 1998
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1999
    if (p->fts_link) {
#line 1999
      p = p->fts_link;
    } else {
#line 1999
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2001
  return;
}
}
#line 2003 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv )
{
  size_t len ;
  size_t max ;

  {
#line 2009
  max = (size_t )0;
  {
#line 2009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2009
    if (! *argv) {
#line 2009
      goto while_break;
    }
    {
#line 2010
    len = strlen((char const   *)*argv);
    }
#line 2010
    if (len > max) {
#line 2011
      max = len;
    }
#line 2009
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2012
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2024 "/home/khheo/project/benchmark/grep-2.19/lib/fts.c"
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir )
{
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2029
  if (dir) {
    {
#line 2029
    tmp = strcmp(dir, "..");
    }
#line 2029
    if (tmp == 0) {
#line 2029
      tmp___0 = 1;
    } else {
#line 2029
      tmp___0 = 0;
    }
  } else {
#line 2029
    tmp___0 = 0;
  }
#line 2029
  is_dotdot = (_Bool )tmp___0;
#line 2036
  if (sp->fts_options & 4) {
#line 2038
    if (sp->fts_options & 512) {
#line 2038
      if (0 <= fd) {
        {
#line 2039
        close(fd);
        }
      }
    }
#line 2040
    return (0);
  }
#line 2043
  if (fd < 0) {
#line 2043
    if (is_dotdot) {
#line 2043
      if (sp->fts_options & 512) {
        {
#line 2050
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2050
        if (! tmp___1) {
          {
#line 2054
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2055
          is_dotdot = (_Bool)1;
          }
#line 2056
          if (0 <= parent_fd) {
#line 2058
            fd = parent_fd;
#line 2059
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2064
  newfd = fd;
#line 2065
  if (fd < 0) {
    {
#line 2065
    newfd = diropen___0((FTS const   *)sp, dir);
    }
#line 2065
    if (newfd < 0) {
#line 2066
      return (-1);
    }
  }
#line 2075
  if (sp->fts_options & 2) {
#line 2075
    goto _L;
  } else
#line 2075
  if (dir) {
    {
#line 2075
    tmp___4 = strcmp(dir, "..");
    }
#line 2075
    if (tmp___4 == 0) {
      _L: /* CIL Label */
      {
#line 2079
      tmp___2 = fstat(newfd, & sb);
      }
#line 2079
      if (tmp___2) {
#line 2081
        ret = -1;
#line 2082
        goto bail;
      }
#line 2084
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2087
        tmp___3 = __errno_location();
#line 2087
        *tmp___3 = 2;
#line 2088
        ret = -1;
        }
#line 2089
        goto bail;
      } else
#line 2084
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2087
        tmp___3 = __errno_location();
#line 2087
        *tmp___3 = 2;
#line 2088
        ret = -1;
        }
#line 2089
        goto bail;
      }
    }
  }
#line 2093
  if (sp->fts_options & 512) {
    {
#line 2095
    cwd_advance_fd___0(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2096
    return (0);
  }
  {
#line 2099
  ret = fchdir(newfd);
  }
  bail:
#line 2101
  if (fd < 0) {
    {
#line 2103
    tmp___5 = __errno_location();
#line 2103
    oerrno = *tmp___5;
#line 2104
    close(newfd);
#line 2105
    tmp___6 = __errno_location();
#line 2105
    *tmp___6 = oerrno;
    }
  }
#line 2107
  return (ret);
}
}
#line 37 "/home/khheo/project/benchmark/grep-2.19/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix___0(char const   *f )
{


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 232 "/home/khheo/project/benchmark/grep-2.19/lib/fcntl.c"
static int have_dupfd_cloexec___0  =    0;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.19/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.19/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.19/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 179 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void unescape_pattern___0(char *str )
{
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 197 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static size_t string_hasher___0(void const   *data , size_t n_buckets )
{
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static size_t string_hasher_ci___0(void const   *data , size_t n_buckets )
{
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool string_compare___0(void const   *data1 , void const   *data2 )
{
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool string_compare_ci___0(void const   *data1 , void const   *data2 )
{
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void string_free___0(void *data )
{


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void new_exclude_segment___0(struct exclude *ex , enum exclude_type type ,
                                    int options )
{
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */
#line 263
  goto switch_break;
  case_0: /* CIL Label */
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci___0;
  } else {
#line 266
    tmp___0 = & string_compare___0;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci___0;
  } else {
#line 266
    tmp___1 = & string_hasher___0;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free___0);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void free_exclude_segment___0(struct exclude_segment *seg )
{
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static int fnmatch_no_wildcards___0(char const   *pattern , char const   *f , int options )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 407 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool file_pattern_matches___0(struct exclude_segment  const  *seg , char const   *f )
{
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static _Bool file_name_matches___0(struct exclude_segment  const  *seg , char const   *f ,
                                   char *buffer___0 )
{
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 668 "/home/khheo/project/benchmark/grep-2.19/lib/exclude.c"
static void call_addfn___0(struct exclude *ex , char const   *pattern , int options ,
                           void *data )
{
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two___0(uintmax_t i )
{


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 22 "/home/khheo/project/benchmark/grep-2.19/lib/colorize.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
static char const   *file_name___0  ;
#line 46 "/home/khheo/project/benchmark/grep-2.19/lib/closeout.c"
static _Bool ignore_EPIPE___0  ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 137
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 45 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static void cdb_init___0(struct cd_buf *cdb )
{


  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static int cdb_fchdir___0(struct cd_buf  const  *cdb )
{
  int tmp ;

  {
  {
#line 54
  tmp = fchdir((int )cdb->fd);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static void cdb_free___0(struct cd_buf  const  *cdb )
{
  _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
    {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
    }
#line 63
    if (! (! close_fail)) {
      {
#line 63
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c",
                    63U, "cdb_free");
      }
    }
  }
#line 65
  return;
}
}
#line 71 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static int cdb_advance_fd___0(struct cd_buf *cdb , char const   *dir )
{
  int new_fd ;
  int tmp ;

  {
  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = tmp;
  }
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
  {
#line 79
  cdb_free___0((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
  }
#line 82
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/grep-2.19/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash___0(char const   *s )
{
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 89
  tmp = strspn(s, "/");
#line 89
  n_slash = tmp;
  }
#line 90
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.19/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-2.19/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 60 "/home/khheo/project/benchmark/grep-2.19/lib/argmatch.c"
static void __argmatch_die___0(void)
{


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 25 "/home/khheo/project/benchmark/grep-2.19/src/grep.h"
int match_icase ;
#line 26
int match_words ;
#line 27
int match_lines ;
#line 28
unsigned char eolbyte ;
#line 115 "/home/khheo/project/benchmark/grep-2.19/src/dfa.h"
int using_utf8(void) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 61 "/home/khheo/project/benchmark/grep-2.19/src/search.h"
void Pcompile(char const   *pattern , size_t size ) ;
#line 62
size_t Pexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 540 "/usr/include/pcre.h"
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 573
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 627
extern unsigned char const   *pcre_maketables(void) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 657
extern pcre_jit_stack *pcre_jit_stack_alloc(int  , int  ) ;
#line 663
extern void pcre_assign_jit_stack(pcre_extra * , pcre_jit_stack *(*)(void * ) , void * ) ;
#line 31 "/home/khheo/project/benchmark/grep-2.19/src/pcresearch.c"
static pcre *cre  ;
#line 34 "/home/khheo/project/benchmark/grep-2.19/src/pcresearch.c"
static pcre_extra *extra  ;
#line 37 "/home/khheo/project/benchmark/grep-2.19/src/pcresearch.c"
static pcre_jit_stack *jit_stack  ;
#line 43 "/home/khheo/project/benchmark/grep-2.19/src/pcresearch.c"
void Pcompile(char const   *pattern , size_t size )
{
  int e ;
  char const   *ep ;
  char *re ;
  void *tmp ;
  int flags ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *patlim ;
  char *n ;
  char const   *p ;
  char const   *pnul ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  unsigned char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 53
  tmp = xnmalloc((size_t )4, size + 7UL);
#line 53
  re = (char *)tmp;
  }
#line 54
  if (match_icase) {
#line 54
    tmp___0 = 1;
  } else {
#line 54
    tmp___0 = 0;
  }
  {
#line 54
  tmp___3 = using_utf8();
  }
#line 54
  if (tmp___3) {
#line 54
    tmp___2 = 2048;
  } else {
#line 54
    tmp___2 = 0;
  }
  {
#line 54
  flags = (2 | tmp___0) | tmp___2;
#line 57
  patlim = pattern + size;
#line 58
  n = re;
#line 63
  tmp___5 = memchr((void const   *)pattern, '\n', size);
  }
#line 63
  if (tmp___5) {
    {
#line 64
    tmp___4 = gettext("the -P option only supports a single pattern");
#line 64
    error(2, 0, (char const   *)tmp___4);
    }
  }
#line 66
  *n = (char )'\000';
#line 67
  if (match_lines) {
    {
#line 68
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"^(?:");
    }
  }
#line 69
  if (match_words) {
    {
#line 70
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"(?<!\\w)(?:");
    }
  }
  {
#line 71
  tmp___6 = strlen((char const   *)n);
#line 71
  n += tmp___6;
#line 81
  p = pattern;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    tmp___7 = memchr((void const   *)p, '\000', (size_t )(patlim - p));
#line 81
    pnul = (char const   *)tmp___7;
    }
#line 81
    if (! pnul) {
#line 81
      goto while_break;
    }
    {
#line 83
    memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(pnul - p));
#line 84
    n += pnul - p;
#line 85
    p = pnul;
    }
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 85
      if ((unsigned long )pattern < (unsigned long )p) {
#line 85
        if (! ((int const   )*(p + -1) == 92)) {
#line 85
          goto while_break___0;
        }
      } else {
#line 85
        goto while_break___0;
      }
#line 86
      goto __Cont;
      __Cont: /* CIL Label */
#line 85
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 87
    n -= (pnul - p) & 1L;
#line 88
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\000");
#line 89
    n += 4;
#line 81
    p = pnul + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(patlim - p));
#line 93
  n += patlim - p;
#line 94
  *n = (char )'\000';
  }
#line 95
  if (match_words) {
    {
#line 96
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")(?!\\w)");
    }
  }
#line 97
  if (match_lines) {
    {
#line 98
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")$");
    }
  }
  {
#line 100
  tmp___8 = pcre_maketables();
#line 100
  cre = pcre_compile((char const   *)re, flags, & ep, & e, tmp___8);
  }
#line 101
  if (! cre) {
    {
#line 102
    error(2, 0, "%s", ep);
    }
  }
  {
#line 104
  extra = pcre_study((pcre const   *)cre, 1, & ep);
  }
#line 105
  if (ep) {
    {
#line 106
    error(2, 0, "%s", ep);
    }
  }
  {
#line 109
  tmp___10 = pcre_fullinfo((pcre const   *)cre, (pcre_extra const   *)extra, 16, (void *)(& e));
  }
#line 109
  if (tmp___10) {
    {
#line 110
    tmp___9 = gettext("internal error (should never happen)");
#line 110
    error(2, 0, (char const   *)tmp___9);
    }
  }
#line 112
  if (e) {
    {
#line 117
    jit_stack = pcre_jit_stack_alloc(32768, 524288);
    }
#line 118
    if (! jit_stack) {
      {
#line 119
      tmp___11 = gettext("failed to allocate memory for the PCRE JIT stack");
#line 119
      error(2, 0, (char const   *)tmp___11);
      }
    }
    {
#line 121
    pcre_assign_jit_stack(extra, (pcre_jit_stack *(*)(void * ))((void *)0), (void *)jit_stack);
    }
  }
  {
#line 124
  free((void *)re);
  }
#line 126
  return;
}
}
#line 128 "/home/khheo/project/benchmark/grep-2.19/src/pcresearch.c"
size_t Pexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr )
{
  int sub[300] ;
  char const   *line_buf ;
  char const   *line_end ;
  char const   *line_next ;
  int e ;
  ptrdiff_t start_ofs ;
  long tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  ptrdiff_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *beg ;
  char const   *end ;
  char const   *buflim___0 ;
  char eol ;
  void *tmp___7 ;

  {
#line 142
  e = -1;
#line 143
  if (start_ptr) {
#line 143
    tmp = start_ptr - buf;
  } else {
#line 143
    tmp = 0L;
  }
#line 143
  start_ofs = tmp;
#line 147
  line_next = buf;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (e == -1) {
#line 147
      if (! ((unsigned long )line_next < (unsigned long )(buf + size))) {
#line 147
        goto while_break;
      }
    } else {
#line 147
      goto while_break;
    }
    {
#line 151
    line_buf = line_next;
#line 152
    tmp___0 = memchr((void const   *)line_buf, (int )eolbyte, (size_t )((buf + size) - line_buf));
#line 152
    line_end = (char const   *)tmp___0;
    }
#line 153
    if ((unsigned long )line_end == (unsigned long )((void *)0)) {
#line 154
      line_end = buf + size;
#line 154
      line_next = line_end;
    } else {
#line 156
      line_next = line_end + 1;
    }
#line 158
    if (start_ptr) {
#line 158
      if ((unsigned long )start_ptr >= (unsigned long )line_end) {
#line 159
        goto __Cont;
      }
    }
#line 161
    if (2147483647L < line_end - line_buf) {
      {
#line 162
      tmp___1 = gettext("exceeded PCRE\'s line length limit");
#line 162
      error(2, 0, (char const   *)tmp___1);
      }
    }
#line 164
    if (start_ofs < 0L) {
#line 164
      tmp___2 = (ptrdiff_t )0;
    } else {
#line 164
      tmp___2 = start_ofs;
    }
    {
#line 164
    e = pcre_exec((pcre const   *)cre, (pcre_extra const   *)extra, line_buf, (int )(line_end - line_buf),
                  (int )tmp___2, 0, sub, (int )(sizeof(sub) / sizeof(sub[0])));
    }
    __Cont: /* CIL Label */
#line 147
    start_ofs -= line_next - line_buf;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (e <= 0) {
    {
#line 173
    if (e == -1) {
#line 173
      goto case_neg_1;
    }
#line 176
    if (e == -6) {
#line 176
      goto case_neg_6;
    }
#line 179
    if (e == -8) {
#line 179
      goto case_neg_8;
    }
#line 183
    if (e == -10) {
#line 183
      goto case_neg_10;
    }
#line 187
    goto switch_default;
    case_neg_1: /* CIL Label */
#line 174
    return ((size_t )-1);
    case_neg_6: /* CIL Label */
    {
#line 177
    tmp___3 = gettext("memory exhausted");
#line 177
    error(2, 0, (char const   *)tmp___3);
    }
    case_neg_8: /* CIL Label */
    {
#line 180
    tmp___4 = gettext("exceeded PCRE\'s backtracking limit");
#line 180
    error(2, 0, (char const   *)tmp___4);
    }
    case_neg_10: /* CIL Label */
    {
#line 184
    tmp___5 = gettext("invalid UTF-8 byte sequence in input");
#line 184
    error(2, 0, (char const   *)tmp___5);
    }
    switch_default: /* CIL Label */
    {
#line 192
    tmp___6 = gettext("internal PCRE error: %d");
#line 192
    error(2, 0, (char const   *)tmp___6, e);
    }
    switch_break: /* CIL Label */ ;
    }
#line 196
    return ((size_t )-1);
  } else {
#line 201
    beg = line_buf + sub[0];
#line 202
    end = line_buf + sub[1];
#line 203
    buflim___0 = buf + size;
#line 204
    eol = (char )eolbyte;
#line 205
    if (! start_ptr) {
      {
#line 211
      tmp___7 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
#line 211
      end = (char const   *)tmp___7;
      }
#line 211
      if (end) {
#line 214
        end ++;
      } else {
#line 212
        end = buflim___0;
      }
      {
#line 215
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 215
        if ((unsigned long )buf < (unsigned long )beg) {
#line 215
          if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 215
            goto while_break___0;
          }
        } else {
#line 215
          goto while_break___0;
        }
#line 216
        beg --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 219
    *match_size = (size_t )(end - beg);
#line 220
    return ((size_t )(beg - buf));
  }
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 45 "/home/khheo/project/benchmark/grep-2.19/src/kwset.h"
void kwsincr(kwset_t kwset___1 , char const   *text , size_t len ) ;
#line 48
void kwsprep(kwset_t kwset___1 ) ;
#line 56
size_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset___1 , char const   *text ,
                                                  size_t size , struct kwsmatch *kwsmatch ) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 44 "/home/khheo/project/benchmark/grep-2.19/src/search.h"
void kwsinit(kwset_t *kwset___1 ) ;
#line 46
char *mbtoupper(char const   *beg , size_t *n , mb_len_map_t **len_map_p ) ;
#line 48
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end ) ;
#line 49
wint_t mb_prev_wc(char const   *buf , char const   *cur , char const   *end ) ;
#line 50
wint_t mb_next_wc(char const   *cur , char const   *end ) ;
#line 57
void Fcompile(char const   *pattern , size_t size ) ;
#line 58
size_t Fexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 25 "/home/khheo/project/benchmark/grep-2.19/src/kwsearch.c"
static _Bool wordchar(wint_t wc )
{
  int tmp ;
  int tmp___0 ;

  {
#line 28
  if (wc == 95U) {
#line 28
    tmp___0 = 1;
  } else {
    {
#line 28
    tmp = iswalnum(wc);
    }
#line 28
    if (tmp) {
#line 28
      tmp___0 = 1;
    } else {
#line 28
      tmp___0 = 0;
    }
  }
#line 28
  return ((_Bool )tmp___0);
}
}
#line 34 "/home/khheo/project/benchmark/grep-2.19/src/kwsearch.c"
static kwset_t kwset  ;
#line 36 "/home/khheo/project/benchmark/grep-2.19/src/kwsearch.c"
void Fcompile(char const   *pattern , size_t size )
{
  size_t total ;
  mb_len_map_t *map ;
  char const   *pat ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char const   *p ;
  size_t len ;
  char const   *sep ;
  void *tmp___3 ;
  char *buf ;
  void *tmp___4 ;

  {
#line 39
  total = size;
#line 40
  map = (mb_len_map_t *)((void *)0);
#line 41
  if (match_icase) {
    {
#line 41
    tmp___2 = __ctype_get_mb_cur_max();
    }
#line 41
    if (tmp___2 > 1UL) {
      {
#line 41
      tmp___0 = mbtoupper(pattern, & total, & map);
#line 41
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 41
      tmp___1 = pattern;
    }
  } else {
#line 41
    tmp___1 = pattern;
  }
  {
#line 41
  pat = tmp___1;
#line 45
  kwsinit(& kwset);
#line 47
  p = pat;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___3 = memchr((void const   *)p, '\n', total);
#line 51
    sep = (char const   *)tmp___3;
    }
#line 52
    if (sep) {
#line 54
      len = (size_t )(sep - p);
#line 55
      sep ++;
#line 56
      total -= len + 1UL;
    } else {
#line 60
      len = total;
#line 61
      total = (size_t )0;
    }
#line 64
    buf = (char *)((void *)0);
#line 65
    if (match_lines) {
      {
#line 67
      tmp___4 = xmalloc(len + 2UL);
#line 67
      buf = (char *)tmp___4;
#line 68
      *(buf + 0) = (char )eolbyte;
#line 69
      memcpy((void */* __restrict  */)(buf + 1), (void const   */* __restrict  */)p,
             len);
#line 70
      *(buf + (len + 1UL)) = (char )eolbyte;
#line 71
      p = (char const   *)buf;
#line 72
      len += 2UL;
      }
    }
    {
#line 74
    kwsincr(kwset, p, len);
#line 75
    free((void *)buf);
#line 77
    p = sep;
    }
#line 48
    if (! p) {
#line 48
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  kwsprep(kwset);
  }
#line 82
  return;
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.19/src/kwsearch.c"
static void mb_case_map_apply(mb_len_map_t const   *map , size_t *off , size_t *len )
{
  size_t off_incr ;
  size_t len_incr ;
  size_t k ;

  {
#line 90
  if (map) {
#line 92
    off_incr = (size_t )0;
#line 93
    len_incr = (size_t )0;
#line 95
    k = (size_t )0;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! (k < *off)) {
#line 95
        goto while_break;
      }
#line 96
      off_incr += (size_t )*(map + k);
#line 95
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! (k < *off + *len)) {
#line 97
        goto while_break___0;
      }
#line 98
      len_incr += (size_t )*(map + k);
#line 97
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    *off += off_incr;
#line 100
    *len += len_incr;
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/grep-2.19/src/kwsearch.c"
size_t Fexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr )
{
  char const   *beg ;
  char const   *try ;
  char const   *end ;
  char const   *mb_start ;
  size_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  size_t ret_val ;
  mb_len_map_t *map ;
  char *case_buf ;
  char *tmp ;
  size_t tmp___0 ;
  size_t offset ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  ptrdiff_t tmp___4 ;
  wint_t tmp___5 ;
  _Bool tmp___6 ;
  wint_t tmp___7 ;
  _Bool tmp___8 ;
  void *tmp___9 ;
  size_t off ;

  {
  {
#line 110
  eol = (char )eolbyte;
#line 113
  map = (mb_len_map_t *)((void *)0);
#line 115
  tmp___0 = __ctype_get_mb_cur_max();
  }
#line 115
  if (tmp___0 > 1UL) {
#line 117
    if (match_icase) {
      {
#line 119
      tmp = mbtoupper(buf, & size, & map);
#line 119
      case_buf = tmp;
      }
#line 120
      if (start_ptr) {
#line 121
        start_ptr = (char const   *)(case_buf + (start_ptr - buf));
      }
#line 122
      buf = (char const   *)case_buf;
    }
  }
#line 126
  if (start_ptr) {
#line 126
    beg = start_ptr;
  } else {
#line 126
    beg = buf;
  }
#line 126
  mb_start = beg;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
#line 126
      goto while_break;
    }
    {
#line 128
    tmp___1 = kwsexec(kwset, beg - match_lines, (size_t )(((buf + size) - beg) + (long )match_lines),
                      & kwsmatch);
#line 128
    offset = tmp___1;
    }
#line 130
    if (offset == 0xffffffffffffffffUL) {
#line 131
      goto failure;
    }
#line 132
    len = kwsmatch.size[0] - (size_t )match_lines;
#line 133
    if (! match_lines) {
      {
#line 133
      tmp___2 = __ctype_get_mb_cur_max();
      }
#line 133
      if (tmp___2 > 1UL) {
        {
#line 133
        tmp___3 = using_utf8();
        }
#line 133
        if (! tmp___3) {
          {
#line 133
          tmp___4 = mb_goback(& mb_start, beg + offset, buf + size);
          }
#line 133
          if (tmp___4 != 0L) {
#line 138
            beg = mb_start;
#line 139
            goto __Cont;
          }
        }
      }
    }
#line 141
    beg += offset;
#line 142
    if (start_ptr) {
#line 142
      if (! match_words) {
#line 143
        goto success_in_beg_and_len;
      }
    }
#line 144
    if (match_lines) {
#line 145
      goto success_in_beg_and_len;
    }
#line 146
    if (match_words) {
#line 147
      try = beg;
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 149
        tmp___5 = mb_prev_wc(buf, try, buf + size);
#line 149
        tmp___6 = wordchar(tmp___5);
        }
#line 149
        if (tmp___6) {
#line 150
          goto while_break___0;
        }
        {
#line 151
        tmp___7 = mb_next_wc(try + len, buf + size);
#line 151
        tmp___8 = wordchar(tmp___7);
        }
#line 151
        if (tmp___8) {
#line 153
          if (! len) {
#line 154
            goto while_break___0;
          }
          {
#line 155
          len --;
#line 155
          offset = kwsexec(kwset, beg, len, & kwsmatch);
          }
#line 156
          if (offset == 0xffffffffffffffffUL) {
#line 157
            goto while_break___0;
          }
#line 158
          try = beg + offset;
#line 159
          len = kwsmatch.size[0];
        } else
#line 161
        if (! start_ptr) {
#line 162
          goto success;
        } else {
#line 164
          goto success_in_beg_and_len;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 167
      goto success;
    }
    __Cont: /* CIL Label */
#line 126
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  failure:
#line 171
  return ((size_t )-1);
  success:
  {
#line 174
  tmp___9 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
#line 174
  end = (char const   *)tmp___9;
  }
#line 174
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 175
    end ++;
  } else {
#line 177
    end = buf + size;
  }
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if ((unsigned long )buf < (unsigned long )beg) {
#line 178
      if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 178
        goto while_break___1;
      }
    } else {
#line 178
      goto while_break___1;
    }
#line 179
    beg --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 180
  len = (size_t )(end - beg);
  success_in_beg_and_len:
  {
#line 182
  off = (size_t )(beg - buf);
#line 183
  mb_case_map_apply((mb_len_map_t const   *)map, & off, & len);
#line 185
  *match_size = len;
#line 186
  ret_val = off;
  }
#line 187
  return (ret_val);
}
}
#line 41 "/home/khheo/project/benchmark/grep-2.19/src/kwset.h"
kwset_t kwsalloc(char const   *trans___0 ) ;
#line 60
void kwsfree(kwset_t kwset___1 ) ;
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 57 "/home/khheo/project/benchmark/grep-2.19/src/system.h"
__inline static unsigned char to_uchar(char ch )
{


  {
#line 60
  return ((unsigned char )ch);
}
}
#line 184 "../lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 185
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 197
extern void obstack_free(struct obstack * , void * ) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 117 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
__inline static char tr(char const   *trans___0 , char c )
{
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 120
  if (trans___0) {
    {
#line 120
    tmp = to_uchar(c);
#line 120
    tmp___0 = (int const   )*(trans___0 + tmp);
    }
  } else {
#line 120
    tmp___0 = (int const   )c;
  }
#line 120
  return ((char )tmp___0);
}
}
#line 125 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
kwset_t kwsalloc(char const   *trans___0 )
{
  struct kwset *kwset___1 ;
  void *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 128
  tmp = xmalloc(sizeof(*kwset___1));
#line 128
  kwset___1 = (struct kwset *)tmp;
#line 130
  _obstack_begin(& kwset___1->obstack, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
#line 131
  kwset___1->words = (ptrdiff_t )0;
#line 132
  __h = & kwset___1->obstack;
#line 132
  __o = __h;
#line 132
  __len = (int )sizeof(*(kwset___1->trie));
  }
#line 132
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 132
    _obstack_newchunk(__o, __len);
    }
  }
#line 132
  __o->next_free += __len;
#line 132
  __o1 = __h;
#line 132
  __value = (void *)__o1->object_base;
#line 132
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 132
    __o1->maybe_empty_object = 1U;
  }
#line 132
  if (sizeof(long ) < sizeof(void *)) {
#line 132
    tmp___0 = __o1->object_base;
  } else {
#line 132
    tmp___0 = (char *)0;
  }
#line 132
  if (sizeof(long ) < sizeof(void *)) {
#line 132
    tmp___1 = __o1->object_base;
  } else {
#line 132
    tmp___1 = (char *)0;
  }
#line 132
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 132
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 132
    __o1->next_free = __o1->chunk_limit;
  }
#line 132
  __o1->object_base = __o1->next_free;
#line 132
  kwset___1->trie = (struct trie *)__value;
#line 133
  (kwset___1->trie)->accepting = (size_t )0;
#line 134
  (kwset___1->trie)->links = (struct tree *)((void *)0);
#line 135
  (kwset___1->trie)->parent = (struct trie *)((void *)0);
#line 136
  (kwset___1->trie)->next = (struct trie *)((void *)0);
#line 137
  (kwset___1->trie)->fail = (struct trie *)((void *)0);
#line 138
  (kwset___1->trie)->depth = 0;
#line 139
  (kwset___1->trie)->shift = 0;
#line 140
  kwset___1->mind = 2147483647;
#line 141
  kwset___1->maxd = -1;
#line 142
  kwset___1->target = (char *)((void *)0);
#line 143
  kwset___1->trans = trans___0;
#line 145
  return (kwset___1);
}
}
#line 153 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
void kwsincr(kwset_t kwset___1 , char const   *text , size_t len )
{
  struct trie *trie ;
  char const   *trans___0 ;
  unsigned char uc ;
  unsigned char label___0 ;
  int tmp ;
  struct tree *kwset_link ;
  struct tree *links[12] ;
  enum __anonenum_dirs_744895363 dirs[12] ;
  int depth___0 ;
  int tmp___0 ;
  int tmp___1 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  char tmp___6 ;
  char tmp___7 ;
  size_t tmp___8 ;

  {
#line 156
  trie = kwset___1->trie;
#line 157
  trans___0 = kwset___1->trans;
#line 159
  text += len;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    tmp___8 = len;
#line 163
    len --;
#line 163
    if (! tmp___8) {
#line 163
      goto while_break;
    }
#line 165
    text --;
#line 165
    uc = (unsigned char )*text;
#line 166
    if (trans___0) {
#line 166
      tmp = (int const   )*(trans___0 + uc);
    } else {
#line 166
      tmp = (int const   )uc;
    }
#line 166
    label___0 = (unsigned char )tmp;
#line 171
    kwset_link = trie->links;
#line 174
    links[0] = (struct tree *)(& trie->links);
#line 175
    dirs[0] = (enum __anonenum_dirs_744895363 )0;
#line 176
    depth___0 = 1;
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 178
      if (kwset_link) {
#line 178
        if (! ((int )label___0 != (int )kwset_link->label)) {
#line 178
          goto while_break___0;
        }
      } else {
#line 178
        goto while_break___0;
      }
#line 180
      links[depth___0] = kwset_link;
#line 181
      if ((int )label___0 < (int )kwset_link->label) {
#line 182
        tmp___0 = depth___0;
#line 182
        depth___0 ++;
#line 182
        dirs[tmp___0] = (enum __anonenum_dirs_744895363 )0;
#line 182
        kwset_link = kwset_link->llink;
      } else {
#line 184
        tmp___1 = depth___0;
#line 184
        depth___0 ++;
#line 184
        dirs[tmp___1] = (enum __anonenum_dirs_744895363 )1;
#line 184
        kwset_link = kwset_link->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 190
    if (! kwset_link) {
#line 192
      __h = & kwset___1->obstack;
#line 192
      __o = __h;
#line 192
      __len = (int )sizeof(*kwset_link);
#line 192
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
#line 192
        _obstack_newchunk(__o, __len);
        }
      }
#line 192
      __o->next_free += __len;
#line 192
      __o1 = __h;
#line 192
      __value = (void *)__o1->object_base;
#line 192
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 192
        __o1->maybe_empty_object = 1U;
      }
#line 192
      if (sizeof(long ) < sizeof(void *)) {
#line 192
        tmp___2 = __o1->object_base;
      } else {
#line 192
        tmp___2 = (char *)0;
      }
#line 192
      if (sizeof(long ) < sizeof(void *)) {
#line 192
        tmp___3 = __o1->object_base;
      } else {
#line 192
        tmp___3 = (char *)0;
      }
#line 192
      __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 192
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 192
        __o1->next_free = __o1->chunk_limit;
      }
#line 192
      __o1->object_base = __o1->next_free;
#line 192
      kwset_link = (struct tree *)__value;
#line 193
      kwset_link->llink = (struct tree *)((void *)0);
#line 194
      kwset_link->rlink = (struct tree *)((void *)0);
#line 195
      __h___0 = & kwset___1->obstack;
#line 195
      __o___0 = __h___0;
#line 195
      __len___0 = (int )sizeof(*(kwset_link->trie));
#line 195
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
#line 195
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 195
      __o___0->next_free += __len___0;
#line 195
      __o1___0 = __h___0;
#line 195
      __value___0 = (void *)__o1___0->object_base;
#line 195
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 195
        __o1___0->maybe_empty_object = 1U;
      }
#line 195
      if (sizeof(long ) < sizeof(void *)) {
#line 195
        tmp___4 = __o1___0->object_base;
      } else {
#line 195
        tmp___4 = (char *)0;
      }
#line 195
      if (sizeof(long ) < sizeof(void *)) {
#line 195
        tmp___5 = __o1___0->object_base;
      } else {
#line 195
        tmp___5 = (char *)0;
      }
#line 195
      __o1___0->next_free = tmp___4 + (((__o1___0->next_free - tmp___5) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 195
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 195
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 195
      __o1___0->object_base = __o1___0->next_free;
#line 195
      kwset_link->trie = (struct trie *)__value___0;
#line 196
      (kwset_link->trie)->accepting = (size_t )0;
#line 197
      (kwset_link->trie)->links = (struct tree *)((void *)0);
#line 198
      (kwset_link->trie)->parent = trie;
#line 199
      (kwset_link->trie)->next = (struct trie *)((void *)0);
#line 200
      (kwset_link->trie)->fail = (struct trie *)((void *)0);
#line 201
      (kwset_link->trie)->depth = trie->depth + 1;
#line 202
      (kwset_link->trie)->shift = 0;
#line 203
      kwset_link->label = label___0;
#line 204
      kwset_link->balance = (char)0;
#line 207
      depth___0 --;
#line 207
      if ((unsigned int )dirs[depth___0] == 0U) {
#line 208
        (links[depth___0])->llink = kwset_link;
      } else {
#line 210
        (links[depth___0])->rlink = kwset_link;
      }
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 213
        if (depth___0) {
#line 213
          if (! (! (links[depth___0])->balance)) {
#line 213
            goto while_break___1;
          }
        } else {
#line 213
          goto while_break___1;
        }
#line 215
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 216
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
        } else {
#line 218
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
        }
#line 219
        depth___0 --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 223
      if (depth___0) {
#line 223
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 223
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
#line 223
          if ((links[depth___0])->balance) {
#line 223
            goto _L;
          } else {
#line 223
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */
#line 223
        if ((unsigned int )dirs[depth___0] == 1U) {
#line 223
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
#line 223
          if ((links[depth___0])->balance) {
            _L: /* CIL Label */
            {
#line 230
            if ((int )(links[depth___0])->balance == -2) {
#line 230
              goto case_neg_2;
            }
#line 250
            if ((int )(links[depth___0])->balance == 2) {
#line 250
              goto case_2;
            }
#line 270
            goto switch_default___1;
            case_neg_2: /* CIL Label */
            {
#line 233
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 233
              goto case_0;
            }
#line 238
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 238
              goto case_1;
            }
#line 246
            goto switch_default;
            case_0: /* CIL Label */
#line 234
            r = links[depth___0];
#line 234
            t = r->llink;
#line 234
            rl = t->rlink;
#line 235
            t->rlink = r;
#line 235
            r->llink = rl;
#line 236
            tmp___6 = (char)0;
#line 236
            r->balance = tmp___6;
#line 236
            t->balance = tmp___6;
#line 237
            goto switch_break___0;
            case_1: /* CIL Label */
#line 239
            r = links[depth___0];
#line 239
            l = r->llink;
#line 239
            t = l->rlink;
#line 240
            rl = t->rlink;
#line 240
            lr = t->llink;
#line 241
            t->llink = l;
#line 241
            l->rlink = lr;
#line 241
            t->rlink = r;
#line 241
            r->llink = rl;
#line 242
            if ((int )t->balance != 1) {
#line 242
              l->balance = (char)0;
            } else {
#line 242
              l->balance = (char)-1;
            }
#line 243
            if ((int )t->balance != -1) {
#line 243
              r->balance = (char)0;
            } else {
#line 243
              r->balance = (char)1;
            }
#line 244
            t->balance = (char)0;
#line 245
            goto switch_break___0;
            switch_default: /* CIL Label */
            {
#line 247
            abort();
            }
            switch_break___0: /* CIL Label */ ;
            }
#line 249
            goto switch_break;
            case_2: /* CIL Label */
            {
#line 253
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 253
              goto case_1___0;
            }
#line 258
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 258
              goto case_0___0;
            }
#line 266
            goto switch_default___0;
            case_1___0: /* CIL Label */
#line 254
            l = links[depth___0];
#line 254
            t = l->rlink;
#line 254
            lr = t->llink;
#line 255
            t->llink = l;
#line 255
            l->rlink = lr;
#line 256
            tmp___7 = (char)0;
#line 256
            l->balance = tmp___7;
#line 256
            t->balance = tmp___7;
#line 257
            goto switch_break___1;
            case_0___0: /* CIL Label */
#line 259
            l = links[depth___0];
#line 259
            r = l->rlink;
#line 259
            t = r->llink;
#line 260
            lr = t->llink;
#line 260
            rl = t->rlink;
#line 261
            t->llink = l;
#line 261
            l->rlink = lr;
#line 261
            t->rlink = r;
#line 261
            r->llink = rl;
#line 262
            if ((int )t->balance != 1) {
#line 262
              l->balance = (char)0;
            } else {
#line 262
              l->balance = (char)-1;
            }
#line 263
            if ((int )t->balance != -1) {
#line 263
              r->balance = (char)0;
            } else {
#line 263
              r->balance = (char)1;
            }
#line 264
            t->balance = (char)0;
#line 265
            goto switch_break___1;
            switch_default___0: /* CIL Label */
            {
#line 267
            abort();
            }
            switch_break___1: /* CIL Label */ ;
            }
#line 269
            goto switch_break;
            switch_default___1: /* CIL Label */
            {
#line 271
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
#line 274
            if ((unsigned int )dirs[depth___0 - 1] == 0U) {
#line 275
              (links[depth___0 - 1])->llink = t;
            } else {
#line 277
              (links[depth___0 - 1])->rlink = t;
            }
          }
        }
      }
    }
#line 281
    trie = kwset_link->trie;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (! trie->accepting) {
#line 287
    trie->accepting = (size_t )(1L + 2L * kwset___1->words);
  }
#line 288
  (kwset___1->words) ++;
#line 291
  if (trie->depth < kwset___1->mind) {
#line 292
    kwset___1->mind = trie->depth;
  }
#line 293
  if (trie->depth > kwset___1->maxd) {
#line 294
    kwset___1->maxd = trie->depth;
  }
#line 295
  return;
}
}
#line 299 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static void enqueue(struct tree *tree , struct trie **last )
{
  struct trie *tmp ;

  {
#line 302
  if (! tree) {
#line 303
    return;
  }
  {
#line 304
  enqueue(tree->llink, last);
#line 305
  enqueue(tree->rlink, last);
#line 306
  tmp = tree->trie;
#line 306
  (*last)->next = tmp;
#line 306
  *last = tmp;
  }
#line 307
  return;
}
}
#line 312 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static void treefails(struct tree  const  *tree , struct trie  const  *fail , struct trie *recourse )
{
  struct tree *kwset_link ;

  {
#line 318
  if (! tree) {
#line 319
    return;
  }
  {
#line 321
  treefails((struct tree  const  *)tree->llink, fail, recourse);
#line 322
  treefails((struct tree  const  *)tree->rlink, fail, recourse);
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! fail) {
#line 326
      goto while_break;
    }
#line 328
    kwset_link = (struct tree *)fail->links;
    {
#line 329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 329
      if (kwset_link) {
#line 329
        if (! ((int const   )tree->label != (int const   )kwset_link->label)) {
#line 329
          goto while_break___0;
        }
      } else {
#line 329
        goto while_break___0;
      }
#line 330
      if ((int const   )tree->label < (int const   )kwset_link->label) {
#line 331
        kwset_link = kwset_link->llink;
      } else {
#line 333
        kwset_link = kwset_link->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    if (kwset_link) {
#line 336
      (tree->trie)->fail = kwset_link->trie;
#line 337
      return;
    }
#line 339
    fail = (struct trie  const  *)fail->fail;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  (tree->trie)->fail = recourse;
#line 343
  return;
}
}
#line 347 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static void treedelta(struct tree  const  *tree , unsigned int depth___0 , unsigned char *delta )
{


  {
#line 352
  if (! tree) {
#line 353
    return;
  }
  {
#line 354
  treedelta((struct tree  const  *)tree->llink, depth___0, delta);
#line 355
  treedelta((struct tree  const  *)tree->rlink, depth___0, delta);
  }
#line 356
  if (depth___0 < (unsigned int )*(delta + tree->label)) {
#line 357
    *(delta + tree->label) = (unsigned char )depth___0;
  }
#line 358
  return;
}
}
#line 361 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static int __attribute__((__pure__))  hasevery(struct tree  const  *a , struct tree  const  *b )
{
  int __attribute__((__pure__))  tmp ;
  int __attribute__((__pure__))  tmp___0 ;

  {
#line 364
  if (! b) {
#line 365
    return ((int __attribute__((__pure__))  )1);
  }
  {
#line 366
  tmp = hasevery(a, (struct tree  const  *)b->llink);
  }
#line 366
  if (! tmp) {
#line 367
    return ((int __attribute__((__pure__))  )0);
  }
  {
#line 368
  tmp___0 = hasevery(a, (struct tree  const  *)b->rlink);
  }
#line 368
  if (! tmp___0) {
#line 369
    return ((int __attribute__((__pure__))  )0);
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (a) {
#line 370
      if (! ((int const   )b->label != (int const   )a->label)) {
#line 370
        goto while_break;
      }
    } else {
#line 370
      goto while_break;
    }
#line 371
    if ((int const   )b->label < (int const   )a->label) {
#line 372
      a = (struct tree  const  *)a->llink;
    } else {
#line 374
      a = (struct tree  const  *)a->rlink;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return ((int __attribute__((__pure__))  )(! (! a)));
}
}
#line 380 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static void treenext(struct tree  const  *tree , struct trie **next )
{


  {
#line 383
  if (! tree) {
#line 384
    return;
  }
  {
#line 385
  treenext((struct tree  const  *)tree->llink, next);
#line 386
  treenext((struct tree  const  *)tree->rlink, next);
#line 387
  *(next + tree->label) = (struct trie *)tree->trie;
  }
#line 388
  return;
}
}
#line 392 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
void kwsprep(kwset_t kwset___1 )
{
  char const   *trans___0 ;
  int i ;
  unsigned char deltabuf[256] ;
  unsigned char *delta ;
  unsigned char *tmp ;
  int tmp___0 ;
  struct trie *curr ;
  struct trie *last ;
  struct trie *fail ;
  int __attribute__((__pure__))  tmp___1 ;
  struct trie *nextbuf[256] ;
  struct trie **next ;
  struct trie **tmp___2 ;
  unsigned char tmp___3 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char gc1 ;
  char tmp___8 ;
  int gc1help ;
  char const   *equiv1 ;
  void *tmp___9 ;
  char const   *equiv2 ;
  void *tmp___10 ;
  unsigned char tmp___12 ;
  void *tmp___13 ;
  unsigned char tmp___14 ;

  {
#line 395
  trans___0 = kwset___1->trans;
#line 398
  if (trans___0) {
#line 398
    tmp = deltabuf;
  } else {
#line 398
    tmp = kwset___1->delta;
  }
#line 398
  delta = tmp;
#line 403
  if (kwset___1->mind < 255) {
#line 403
    tmp___0 = kwset___1->mind;
  } else {
#line 403
    tmp___0 = 255;
  }
  {
#line 403
  memset((void *)delta, tmp___0, sizeof(deltabuf));
#line 408
  last = kwset___1->trie;
#line 408
  curr = last;
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! curr) {
#line 408
      goto while_break;
    }
    {
#line 411
    enqueue(curr->links, & last);
#line 413
    curr->shift = kwset___1->mind;
#line 414
    curr->maxshift = kwset___1->mind;
#line 417
    treedelta((struct tree  const  *)curr->links, (unsigned int )curr->depth, delta);
#line 420
    treefails((struct tree  const  *)curr->links, (struct trie  const  *)curr->fail,
              kwset___1->trie);
#line 425
    fail = curr->fail;
    }
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! fail) {
#line 425
        goto while_break___0;
      }
      {
#line 430
      tmp___1 = hasevery((struct tree  const  *)fail->links, (struct tree  const  *)curr->links);
      }
#line 430
      if (! tmp___1) {
#line 431
        if (curr->depth - fail->depth < fail->shift) {
#line 432
          fail->shift = curr->depth - fail->depth;
        }
      }
#line 437
      if (curr->accepting) {
#line 437
        if (fail->maxshift > curr->depth - fail->depth) {
#line 438
          fail->maxshift = curr->depth - fail->depth;
        }
      }
#line 425
      fail = fail->fail;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 408
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  curr = (kwset___1->trie)->next;
  {
#line 444
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 444
    if (! curr) {
#line 444
      goto while_break___1;
    }
#line 446
    if (curr->maxshift > (curr->parent)->maxshift) {
#line 447
      curr->maxshift = (curr->parent)->maxshift;
    }
#line 448
    if (curr->shift > curr->maxshift) {
#line 449
      curr->shift = curr->maxshift;
    }
#line 444
    curr = curr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 455
  if (trans___0) {
#line 455
    tmp___2 = nextbuf;
  } else {
#line 455
    tmp___2 = kwset___1->next;
  }
  {
#line 455
  next = tmp___2;
#line 456
  memset((void *)next, 0, sizeof(nextbuf));
#line 457
  treenext((struct tree  const  *)(kwset___1->trie)->links, next);
  }
#line 458
  if (trans___0) {
#line 459
    i = 0;
    {
#line 459
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 459
      if (! (i < 256)) {
#line 459
        goto while_break___2;
      }
      {
#line 460
      tmp___3 = to_uchar((char )*(trans___0 + i));
#line 460
      kwset___1->next[i] = *(next + tmp___3);
#line 459
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 464
  if (kwset___1->words == 1L) {
#line 467
    __h = & kwset___1->obstack;
#line 467
    __o = __h;
#line 467
    __len = kwset___1->mind;
#line 467
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 467
      _obstack_newchunk(__o, __len);
      }
    }
#line 467
    __o->next_free += __len;
#line 467
    __o1 = __h;
#line 467
    __value = (void *)__o1->object_base;
#line 467
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 467
      __o1->maybe_empty_object = 1U;
    }
#line 467
    if (sizeof(long ) < sizeof(void *)) {
#line 467
      tmp___4 = __o1->object_base;
    } else {
#line 467
      tmp___4 = (char *)0;
    }
#line 467
    if (sizeof(long ) < sizeof(void *)) {
#line 467
      tmp___5 = __o1->object_base;
    } else {
#line 467
      tmp___5 = (char *)0;
    }
#line 467
    __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 467
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 467
      __o1->next_free = __o1->chunk_limit;
    }
#line 467
    __o1->object_base = __o1->next_free;
#line 467
    kwset___1->target = (char *)__value;
#line 468
    i = kwset___1->mind - 1;
#line 468
    curr = kwset___1->trie;
    {
#line 468
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 468
      if (! (i >= 0)) {
#line 468
        goto while_break___3;
      }
#line 470
      *(kwset___1->target + i) = (char )(curr->links)->label;
#line 471
      curr = curr->next;
#line 468
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 475
    if (kwset___1->mind > 1) {
#line 478
      __h___0 = & kwset___1->obstack;
#line 478
      __o___0 = __h___0;
#line 478
      __len___0 = (int )(sizeof(*(kwset___1->shift)) * (unsigned long )(kwset___1->mind - 1));
#line 478
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
#line 478
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 478
      __o___0->next_free += __len___0;
#line 478
      __o1___0 = __h___0;
#line 478
      __value___0 = (void *)__o1___0->object_base;
#line 478
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 478
        __o1___0->maybe_empty_object = 1U;
      }
#line 478
      if (sizeof(long ) < sizeof(void *)) {
#line 478
        tmp___6 = __o1___0->object_base;
      } else {
#line 478
        tmp___6 = (char *)0;
      }
#line 478
      if (sizeof(long ) < sizeof(void *)) {
#line 478
        tmp___7 = __o1___0->object_base;
      } else {
#line 478
        tmp___7 = (char *)0;
      }
#line 478
      __o1___0->next_free = tmp___6 + (((__o1___0->next_free - tmp___7) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 478
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 478
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 478
      __o1___0->object_base = __o1___0->next_free;
#line 478
      kwset___1->shift = (int *)__value___0;
#line 480
      i = 0;
#line 480
      curr = (kwset___1->trie)->next;
      {
#line 480
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 480
        if (! (i < kwset___1->mind - 1)) {
#line 480
          goto while_break___4;
        }
#line 482
        *(kwset___1->shift + i) = curr->shift;
#line 483
        curr = curr->next;
#line 480
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 487
    tmp___8 = tr(trans___0, *(kwset___1->target + (kwset___1->mind - 1)));
#line 487
    gc1 = tmp___8;
#line 491
    gc1help = -1;
    }
#line 492
    if (trans___0) {
      {
#line 494
      tmp___9 = memchr((void const   *)trans___0, (int )gc1, (size_t )256);
#line 494
      equiv1 = (char const   *)tmp___9;
#line 495
      tmp___10 = memchr((void const   *)(equiv1 + 1), (int )gc1, (size_t )((trans___0 + 256) - (equiv1 + 1)));
#line 495
      equiv2 = (char const   *)tmp___10;
      }
#line 497
      if (equiv2) {
        {
#line 498
        tmp___13 = memchr((void const   *)(equiv2 + 1), (int )gc1, (size_t )((trans___0 + 256) - (equiv2 + 1)));
        }
#line 498
        if (tmp___13) {
#line 498
          gc1help = 256;
        } else {
          {
#line 498
          tmp___12 = to_uchar(gc1);
#line 498
          gc1help = (int )(((long )tmp___12 ^ (equiv1 - trans___0)) ^ (equiv2 - trans___0));
          }
        }
      }
    }
#line 503
    kwset___1->gc1 = gc1;
#line 504
    kwset___1->gc1help = gc1help;
#line 505
    if (kwset___1->mind > 1) {
      {
#line 506
      kwset___1->gc2 = tr(trans___0, *(kwset___1->target + (kwset___1->mind - 2)));
      }
    }
  }
#line 510
  if (trans___0) {
#line 511
    i = 0;
    {
#line 511
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 511
      if (! (i < 256)) {
#line 511
        goto while_break___5;
      }
      {
#line 512
      tmp___14 = to_uchar((char )*(trans___0 + i));
#line 512
      kwset___1->delta[i] = *(delta + tmp___14);
#line 511
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 513
  return;
}
}
#line 523 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
__inline static _Bool bm_delta2_search(char const   **tpp , char const   *ep , char const   *sp ,
                                       int len , char const   *trans___0 , char gc1 ,
                                       char gc2 , unsigned char const   *d1 , kwset_t kwset___1 )
{
  char const   *tp ;
  int d ;
  int skip ;
  int i ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  unsigned char tmp___4 ;
  char tmp___5 ;

  {
#line 528
  tp = *tpp;
#line 529
  d = len;
#line 529
  skip = 0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 533
    i = 2;
#line 534
    tmp___3 = tr(trans___0, (char )*(tp + -2));
    }
#line 534
    if ((int )tmp___3 == (int )gc2) {
      {
#line 536
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 536
        i ++;
#line 536
        if (! (i <= d)) {
#line 536
          goto while_break___0;
        }
        {
#line 537
        tmp = tr(trans___0, (char )*(tp + - i));
#line 537
        tmp___0 = tr(trans___0, (char )*(sp + - i));
        }
#line 537
        if ((int )tmp != (int )tmp___0) {
#line 538
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 539
      if (i > d) {
#line 541
        i = (d + skip) + 1;
        {
#line 541
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 541
          if (! (i <= len)) {
#line 541
            goto while_break___1;
          }
          {
#line 542
          tmp___1 = tr(trans___0, (char )*(tp + - i));
#line 542
          tmp___2 = tr(trans___0, (char )*(sp + - i));
          }
#line 542
          if ((int )tmp___1 != (int )tmp___2) {
#line 543
            goto while_break___1;
          }
#line 541
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 544
        if (i > len) {
#line 546
          *tpp = tp - len;
#line 547
          return ((_Bool)1);
        }
      }
    }
#line 552
    d = *(kwset___1->shift + (i - 2));
#line 552
    tp += d;
#line 553
    if ((unsigned long )tp > (unsigned long )ep) {
#line 554
      goto while_break;
    }
    {
#line 555
    tmp___5 = tr(trans___0, (char )*(tp + -1));
    }
#line 555
    if ((int )tmp___5 != (int )gc1) {
#line 557
      if (d1) {
        {
#line 558
        tmp___4 = to_uchar((char )*(tp + -1));
#line 558
        tp += (int const   )*(d1 + tmp___4);
        }
      }
#line 559
      goto while_break;
    }
#line 561
    skip = i - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  *tpp = tp;
#line 565
  return ((_Bool)0);
}
}
#line 570 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static char const   *memchr_kwset(char const   *s , size_t n , kwset_t kwset___1 )
{
  void *tmp ;
  int small_heuristic ;
  int small ;
  size_t ntrans ;
  size_t tmp___0 ;
  char const   *slim ;
  unsigned char tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 573
  if (kwset___1->gc1help < 0) {
    {
#line 574
    tmp = memchr((void const   *)s, (int )kwset___1->gc1, n);
    }
#line 574
    return ((char const   *)tmp);
  }
#line 575
  small_heuristic = 2;
#line 576
  small = (int )(- ((uintptr_t )s) % sizeof(long ) + (unsigned long )small_heuristic * sizeof(long ));
#line 578
  if (kwset___1->gc1help < 256) {
#line 578
    if ((size_t )small < n) {
#line 578
      tmp___0 = (size_t )small;
    } else {
#line 578
      tmp___0 = n;
    }
  } else {
#line 578
    tmp___0 = n;
  }
#line 578
  ntrans = tmp___0;
#line 579
  slim = s + ntrans;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! ((unsigned long )s < (unsigned long )slim)) {
#line 580
      goto while_break;
    }
    {
#line 581
    tmp___1 = to_uchar((char )*s);
    }
#line 581
    if ((int const   )*(kwset___1->trans + tmp___1) == (int const   )kwset___1->gc1) {
#line 582
      return (s);
    }
#line 580
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  n -= ntrans;
#line 584
  if (n == 0UL) {
#line 584
    tmp___3 = (void *)0;
  } else {
    {
#line 584
    tmp___2 = memchr2((void const   *)s, (int )kwset___1->gc1, kwset___1->gc1help,
                      n);
#line 584
    tmp___3 = tmp___2;
    }
  }
#line 584
  return ((char const   *)tmp___3);
}
}
#line 588 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
__inline static size_t __attribute__((__pure__))  bmexec_trans(kwset_t kwset___1 ,
                                                               char const   *text ,
                                                               size_t size )
{
  unsigned char const   *d1 ;
  char const   *ep ;
  char const   *sp ;
  char const   *tp ;
  int d ;
  int len ;
  char const   *trans___0 ;
  long tmp ;
  char gc1 ;
  char gc2 ;
  char const   *tp0 ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  int advance_heuristic ;
  _Bool tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  _Bool tmp___13 ;

  {
#line 594
  len = kwset___1->mind;
#line 595
  trans___0 = kwset___1->trans;
#line 597
  if (len == 0) {
#line 598
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 599
  if ((size_t )len > size) {
#line 600
    return ((size_t __attribute__((__pure__))  )-1);
  }
#line 601
  if (len == 1) {
    {
#line 603
    tp = memchr_kwset(text, size, kwset___1);
    }
#line 604
    if (tp) {
#line 604
      tmp = tp - text;
    } else {
#line 604
      tmp = -1L;
    }
#line 604
    return ((size_t __attribute__((__pure__))  )tmp);
  }
#line 607
  d1 = (unsigned char const   *)(kwset___1->delta);
#line 608
  sp = (char const   *)(kwset___1->target + len);
#line 609
  tp = text + len;
#line 610
  gc1 = kwset___1->gc1;
#line 611
  gc2 = kwset___1->gc2;
#line 614
  if (size > (size_t )(12 * len)) {
#line 616
    ep = (text + size) - 11 * len;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;
#line 616
      if (! ((unsigned long )tp <= (unsigned long )ep)) {
#line 616
        goto while_break;
      }
      {
#line 618
      tp0 = tp;
#line 619
      tmp___0 = to_uchar((char )*(tp + -1));
#line 619
      d = (int )*(d1 + tmp___0);
#line 619
      tp += d;
#line 620
      tmp___1 = to_uchar((char )*(tp + -1));
#line 620
      d = (int )*(d1 + tmp___1);
#line 620
      tp += d;
      }
#line 621
      if (d != 0) {
        {
#line 623
        tmp___2 = to_uchar((char )*(tp + -1));
#line 623
        d = (int )*(d1 + tmp___2);
#line 623
        tp += d;
#line 624
        tmp___3 = to_uchar((char )*(tp + -1));
#line 624
        d = (int )*(d1 + tmp___3);
#line 624
        tp += d;
#line 625
        tmp___4 = to_uchar((char )*(tp + -1));
#line 625
        d = (int )*(d1 + tmp___4);
#line 625
        tp += d;
        }
#line 626
        if (d != 0) {
          {
#line 628
          tmp___5 = to_uchar((char )*(tp + -1));
#line 628
          d = (int )*(d1 + tmp___5);
#line 628
          tp += d;
#line 629
          tmp___6 = to_uchar((char )*(tp + -1));
#line 629
          d = (int )*(d1 + tmp___6);
#line 629
          tp += d;
#line 630
          tmp___7 = to_uchar((char )*(tp + -1));
#line 630
          d = (int )*(d1 + tmp___7);
#line 630
          tp += d;
          }
#line 631
          if (d != 0) {
            {
#line 633
            tmp___8 = to_uchar((char )*(tp + -1));
#line 633
            d = (int )*(d1 + tmp___8);
#line 633
            tp += d;
#line 634
            tmp___9 = to_uchar((char )*(tp + -1));
#line 634
            d = (int )*(d1 + tmp___9);
#line 634
            tp += d;
#line 638
            advance_heuristic = (int )(16UL * sizeof(long ));
            }
#line 639
            if ((long )advance_heuristic <= tp - tp0) {
#line 640
              goto big_advance;
            }
            {
#line 641
            tp --;
#line 642
            tp = memchr_kwset(tp, (size_t )((text + size) - tp), kwset___1);
            }
#line 643
            if (! tp) {
#line 644
              return ((size_t __attribute__((__pure__))  )-1);
            }
#line 645
            tp ++;
          }
        }
      }
      {
#line 649
      tmp___10 = bm_delta2_search(& tp, ep, sp, len, trans___0, gc1, gc2, d1, kwset___1);
      }
#line 649
      if (tmp___10) {
#line 650
        return ((size_t __attribute__((__pure__))  )(tp - text));
      }
      big_advance: ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 656
  ep = text + size;
#line 657
  tmp___11 = to_uchar((char )*(tp + -1));
#line 657
  d = (int )*(d1 + tmp___11);
  }
  {
#line 658
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 658
    if (! ((long )d <= ep - tp)) {
#line 658
      goto while_break___0;
    }
    {
#line 660
    tp += d;
#line 660
    tmp___12 = to_uchar((char )*(tp + -1));
#line 660
    d = (int )*(d1 + tmp___12);
    }
#line 661
    if (d != 0) {
#line 662
      goto while_continue___0;
    }
    {
#line 663
    tmp___13 = bm_delta2_search(& tp, ep, sp, len, trans___0, gc1, gc2, (unsigned char const   *)((void *)0),
                                kwset___1);
    }
#line 663
    if (tmp___13) {
#line 664
      return ((size_t __attribute__((__pure__))  )(tp - text));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 667
  return ((size_t __attribute__((__pure__))  )-1);
}
}
#line 671 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static size_t bmexec(kwset_t kwset___1 , char const   *text , size_t size )
{
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
#line 676
  if (kwset___1->trans) {
    {
#line 676
    tmp = bmexec_trans(kwset___1, text, size);
#line 676
    tmp___1 = tmp;
    }
  } else {
    {
#line 676
    tmp___0 = bmexec_trans(kwset___1, text, size);
#line 676
    tmp___1 = tmp___0;
    }
  }
#line 676
  return ((size_t )tmp___1);
}
}
#line 682 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
static size_t ( __attribute__((__nonnull__(4))) cwexec)(kwset_t kwset___1 , char const   *text ,
                                                        size_t len , struct kwsmatch *kwsmatch )
{
  struct trie * const  *next ;
  struct trie  const  *trie ;
  struct trie  const  *accept ;
  char const   *beg ;
  char const   *lim ;
  char const   *mch ;
  char const   *lmch ;
  unsigned char c ;
  unsigned char const   *delta ;
  int d ;
  char const   *end ;
  char const   *qlim ;
  struct tree  const  *tree ;
  char const   *trans___0 ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char uc ;
  unsigned char uc___0 ;

  {
#line 701
  if (len < (size_t )kwset___1->mind) {
#line 702
    return ((size_t )-1);
  }
#line 703
  next = (struct trie * const  *)(kwset___1->next);
#line 704
  delta = (unsigned char const   *)(kwset___1->delta);
#line 705
  trans___0 = kwset___1->trans;
#line 706
  lim = text + len;
#line 707
  end = text;
#line 708
  d = kwset___1->mind;
#line 708
  if (d != 0) {
#line 709
    mch = (char const   *)((void *)0);
  } else {
#line 712
    mch = text;
#line 712
    accept = (struct trie  const  *)kwset___1->trie;
#line 713
    goto match;
  }
#line 716
  if (len >= (size_t )(4 * kwset___1->mind)) {
#line 717
    qlim = lim - 4 * kwset___1->mind;
  } else {
#line 719
    qlim = (char const   *)((void *)0);
  }
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (lim - end >= (long )d)) {
#line 721
      goto while_break;
    }
#line 723
    if (qlim) {
#line 723
      if ((unsigned long )end <= (unsigned long )qlim) {
#line 725
        end += d - 1;
        {
#line 726
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 726
          c = (unsigned char )*end;
#line 726
          d = (int )*(delta + c);
#line 726
          if (d) {
#line 726
            if (! ((unsigned long )end < (unsigned long )qlim)) {
#line 726
              goto while_break___0;
            }
          } else {
#line 726
            goto while_break___0;
          }
          {
#line 728
          end += d;
#line 729
          tmp = to_uchar((char )*end);
#line 729
          end += (int const   )*(delta + tmp);
#line 730
          tmp___0 = to_uchar((char )*end);
#line 730
          end += (int const   )*(delta + tmp___0);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 732
        end ++;
      } else {
#line 735
        end += d;
#line 735
        c = (unsigned char )*(end + -1);
#line 735
        d = (int )*(delta + c);
      }
    } else {
#line 735
      end += d;
#line 735
      c = (unsigned char )*(end + -1);
#line 735
      d = (int )*(delta + c);
    }
#line 736
    if (d) {
#line 737
      goto while_continue;
    }
#line 738
    beg = end - 1;
#line 739
    trie = (struct trie  const  *)*(next + c);
#line 740
    if (trie->accepting) {
#line 742
      mch = beg;
#line 743
      accept = trie;
    }
#line 745
    d = (int )trie->shift;
    {
#line 746
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 746
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 746
        goto while_break___1;
      }
#line 748
      beg --;
#line 748
      uc = (unsigned char )*beg;
#line 749
      if (trans___0) {
#line 749
        c = (unsigned char )*(trans___0 + uc);
      } else {
#line 749
        c = uc;
      }
#line 750
      tree = (struct tree  const  *)trie->links;
      {
#line 751
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 751
        if (tree) {
#line 751
          if (! ((int )c != (int )tree->label)) {
#line 751
            goto while_break___2;
          }
        } else {
#line 751
          goto while_break___2;
        }
#line 752
        if ((int )c < (int )tree->label) {
#line 753
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 755
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 756
      if (tree) {
#line 758
        trie = (struct trie  const  *)tree->trie;
#line 759
        if (trie->accepting) {
#line 761
          mch = beg;
#line 762
          accept = trie;
        }
      } else {
#line 766
        goto while_break___1;
      }
#line 767
      d = (int )trie->shift;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 769
    if (mch) {
#line 770
      goto match;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  return ((size_t )-1);
  match:
#line 778
  if (lim - mch > (long )kwset___1->maxd) {
#line 779
    lim = mch + kwset___1->maxd;
  }
#line 780
  lmch = (char const   *)0;
#line 781
  d = 1;
  {
#line 782
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 782
    if (! (lim - end >= (long )d)) {
#line 782
      goto while_break___3;
    }
#line 784
    end += d;
#line 784
    c = (unsigned char )*(end + -1);
#line 784
    d = (int )*(delta + c);
#line 784
    if (d != 0) {
#line 785
      goto while_continue___3;
    }
#line 786
    beg = end - 1;
#line 787
    trie = (struct trie  const  *)*(next + c);
#line 787
    if (! trie) {
#line 789
      d = 1;
#line 790
      goto while_continue___3;
    }
#line 792
    if (trie->accepting) {
#line 792
      if ((unsigned long )beg <= (unsigned long )mch) {
#line 794
        lmch = beg;
#line 795
        accept = trie;
      }
    }
#line 797
    d = (int )trie->shift;
    {
#line 798
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 798
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 798
        goto while_break___4;
      }
#line 800
      beg --;
#line 800
      uc___0 = (unsigned char )*beg;
#line 801
      if (trans___0) {
#line 801
        c = (unsigned char )*(trans___0 + uc___0);
      } else {
#line 801
        c = uc___0;
      }
#line 802
      tree = (struct tree  const  *)trie->links;
      {
#line 803
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 803
        if (tree) {
#line 803
          if (! ((int )c != (int )tree->label)) {
#line 803
            goto while_break___5;
          }
        } else {
#line 803
          goto while_break___5;
        }
#line 804
        if ((int )c < (int )tree->label) {
#line 805
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 807
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 808
      if (tree) {
#line 810
        trie = (struct trie  const  *)tree->trie;
#line 811
        if (trie->accepting) {
#line 811
          if ((unsigned long )beg <= (unsigned long )mch) {
#line 813
            lmch = beg;
#line 814
            accept = trie;
          }
        }
      } else {
#line 818
        goto while_break___4;
      }
#line 819
      d = (int )trie->shift;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 821
    if (lmch) {
#line 823
      mch = lmch;
#line 824
      goto match;
    }
#line 826
    if (! d) {
#line 827
      d = 1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 830
  kwsmatch->index = (size_t )(accept->accepting / 2UL);
#line 831
  kwsmatch->offset[0] = (size_t )(mch - text);
#line 832
  kwsmatch->size[0] = (size_t )accept->depth;
#line 834
  return ((size_t )(mch - text));
}
}
#line 842 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
size_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset___1 , char const   *text ,
                                                  size_t size , struct kwsmatch *kwsmatch )
{
  size_t ret ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 846
  if (kwset___1->words == 1L) {
    {
#line 848
    tmp = bmexec(kwset___1, text, size);
#line 848
    ret = tmp;
    }
#line 849
    if (ret != 0xffffffffffffffffUL) {
#line 851
      kwsmatch->index = (size_t )0;
#line 852
      kwsmatch->offset[0] = ret;
#line 853
      kwsmatch->size[0] = (size_t )kwset___1->mind;
    }
#line 855
    return (ret);
  } else {
    {
#line 858
    tmp___0 = cwexec(kwset___1, text, size, kwsmatch);
    }
#line 858
    return (tmp___0);
  }
}
}
#line 862 "/home/khheo/project/benchmark/grep-2.19/src/kwset.c"
void kwsfree(kwset_t kwset___1 )
{
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 865
  __o = & kwset___1->obstack;
#line 865
  __obj = (void *)0;
#line 865
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 865
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 865
      tmp = (char *)__obj;
#line 865
      __o->object_base = tmp;
#line 865
      __o->next_free = tmp;
    } else {
      {
#line 865
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 865
    obstack_free(__o, __obj);
    }
  }
  {
#line 866
  free((void *)kwset___1);
  }
#line 867
  return;
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 537 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 547
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 562
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__string ,
                          __re_idx_t __length , __re_idx_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 580
extern regoff_t re_match(struct re_pattern_buffer *__buffer , char const   *__string ,
                         __re_idx_t __length , __re_idx_t __start , struct re_registers *__regs ) ;
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 44 "/home/khheo/project/benchmark/grep-2.19/src/dfa.h"
struct dfa *dfaalloc(void) ;
#line 47
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d ) ;
#line 52
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) ;
#line 57
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag ) ;
#line 71
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref ) ;
#line 78
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 81
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 108
void dfawarn(char const   *mesg ) ;
#line 113
void dfaerror(char const   *mesg ) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 53 "/home/khheo/project/benchmark/grep-2.19/src/search.h"
void GEAcompile(char const   *pattern , size_t size , reg_syntax_t syntax_bits___0 ) ;
#line 54
size_t EGexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static _Bool wordchar___0(wint_t wc )
{
  int tmp ;
  int tmp___0 ;

  {
#line 29
  if (wc == 95U) {
#line 29
    tmp___0 = 1;
  } else {
    {
#line 29
    tmp = iswalnum(wc);
    }
#line 29
    if (tmp) {
#line 29
      tmp___0 = 1;
    } else {
#line 29
      tmp___0 = 0;
    }
  }
#line 29
  return ((_Bool )tmp___0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static kwset_t kwset___0  ;
#line 38 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static struct dfa *dfa  ;
#line 41 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static struct patterns patterns0  ;
#line 49 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static struct patterns *patterns  ;
#line 50 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static size_t pcount  ;
#line 55 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static size_t kwset_exact_matches  ;
#line 57 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static _Bool begline  ;
#line 59 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
void dfaerror(char const   *mesg )
{


  {
  {
#line 62
  error(2, 0, "%s", mesg);
#line 66
  abort();
  }
}
}
#line 75 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static enum __anonenum_mode_962123750 mode  ;
#line 72 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
void dfawarn(char const   *mesg )
{
  char *tmp___0 ;

  {
#line 76
  if ((unsigned int )mode == 0U) {
    {
#line 77
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 77
    if (tmp___0) {
#line 77
      mode = (enum __anonenum_mode_962123750 )1;
    } else {
#line 77
      mode = (enum __anonenum_mode_962123750 )2;
    }
  }
#line 78
  if ((unsigned int )mode == 2U) {
    {
#line 79
    dfaerror(mesg);
    }
  }
#line 80
  return;
}
}
#line 86 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static void kwsmusts(void)
{
  struct dfamust  const  *dm ;
  struct dfamust *tmp ;
  size_t old_len ;
  size_t tmp___0 ;
  size_t new_len ;
  char *must ;
  void *tmp___1 ;
  char *mp ;
  struct dfamust *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 89
  tmp = (struct dfamust *)dfamusts((struct dfa  const  *)dfa);
#line 89
  dm = (struct dfamust  const  *)tmp;
  }
#line 90
  if (dm) {
    {
#line 92
    kwsinit(& kwset___0);
    }
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
#line 96
      if (! dm) {
#line 96
        goto while_break;
      }
#line 98
      if (! dm->exact) {
#line 99
        goto __Cont;
      }
      {
#line 100
      kwset_exact_matches ++;
#line 101
      tmp___0 = strlen((char const   *)dm->must);
#line 101
      old_len = tmp___0;
#line 102
      new_len = (old_len + (size_t )dm->begline) + (size_t )dm->endline;
#line 103
      tmp___1 = xmalloc(new_len);
#line 103
      must = (char *)tmp___1;
#line 104
      mp = must;
#line 105
      *mp = (char )eolbyte;
#line 106
      mp += (int const   )dm->begline;
#line 107
      begline = (_Bool )((int )begline | (int )dm->begline);
#line 108
      memcpy((void */* __restrict  */)mp, (void const   */* __restrict  */)dm->must,
             old_len);
      }
#line 109
      if (dm->endline) {
#line 110
        *(mp + old_len) = (char )eolbyte;
      }
      {
#line 111
      kwsincr(kwset___0, (char const   *)must, new_len);
#line 112
      free((void *)must);
      }
      __Cont: /* CIL Label */
#line 96
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 116
    tmp___2 = (struct dfamust *)dfamusts((struct dfa  const  *)dfa);
#line 116
    dm = (struct dfamust  const  *)tmp___2;
    }
    {
#line 116
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 116
      if (! dm) {
#line 116
        goto while_break___0;
      }
#line 118
      if (dm->exact) {
#line 119
        goto __Cont___0;
      }
      {
#line 120
      tmp___3 = strlen((char const   *)dm->must);
#line 120
      kwsincr(kwset___0, (char const   *)dm->must, tmp___3);
      }
      __Cont___0: /* CIL Label */
#line 116
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 122
    kwsprep(kwset___0);
    }
  }
#line 124
  return;
}
}
#line 176 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   line_beg_no_bk[3]  = {      (char const   )'^',      (char const   )'(',      (char const   )'\000'};
#line 177 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   line_end_no_bk[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 178 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   word_beg_no_bk[19]  =
#line 178
  {      (char const   )'(',      (char const   )'^',      (char const   )'|',      (char const   )'[',
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'a',
        (char const   )'l',      (char const   )'n',      (char const   )'u',      (char const   )'m',
        (char const   )':',      (char const   )']',      (char const   )'_',      (char const   )']',
        (char const   )')',      (char const   )'(',      (char const   )'\000'};
#line 179 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   word_end_no_bk[19]  =
#line 179
  {      (char const   )')',      (char const   )'(',      (char const   )'[',      (char const   )'^',
        (char const   )'[',      (char const   )':',      (char const   )'a',      (char const   )'l',
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )':',
        (char const   )']',      (char const   )'_',      (char const   )']',      (char const   )'|',
        (char const   )'$',      (char const   )')',      (char const   )'\000'};
#line 180 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   line_beg_bk[4]  = {      (char const   )'^',      (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 181 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   line_end_bk[4]  = {      (char const   )'\\',      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 182 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   word_beg_bk[23]  =
#line 182
  {      (char const   )'\\',      (char const   )'(',      (char const   )'^',      (char const   )'\\',
        (char const   )'|',      (char const   )'[',      (char const   )'^',      (char const   )'[',
        (char const   )':',      (char const   )'a',      (char const   )'l',      (char const   )'n',
        (char const   )'u',      (char const   )'m',      (char const   )':',      (char const   )']',
        (char const   )'_',      (char const   )']',      (char const   )'\\',      (char const   )')',
        (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 183 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
static char const   word_end_bk[23]  =
#line 183
  {      (char const   )'\\',      (char const   )')',      (char const   )'\\',      (char const   )'(',
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':',
        (char const   )'a',      (char const   )'l',      (char const   )'n',      (char const   )'u',
        (char const   )'m',      (char const   )':',      (char const   )']',      (char const   )'_',
        (char const   )']',      (char const   )'\\',      (char const   )'|',      (char const   )'$',
        (char const   )'\\',      (char const   )')',      (char const   )'\000'};
#line 126 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
void GEAcompile(char const   *pattern , size_t size , reg_syntax_t syntax_bits___0 )
{
  size_t total ;
  char *motif ;
  char const   *p ;
  size_t len ;
  char const   *sep ;
  void *tmp ;
  void *tmp___0 ;
  char const   *err ;
  char const   *tmp___1 ;
  int bk ;
  char *n ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;

  {
#line 129
  total = size;
#line 132
  if (match_icase) {
#line 133
    syntax_bits___0 |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 134
  re_set_syntax(syntax_bits___0);
#line 135
  dfasyntax(syntax_bits___0, match_icase, eolbyte);
#line 141
  p = pattern;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp = memchr((void const   *)p, '\n', total);
#line 145
    sep = (char const   *)tmp;
    }
#line 146
    if (sep) {
#line 148
      len = (size_t )(sep - p);
#line 149
      sep ++;
#line 150
      total -= len + 1UL;
    } else {
#line 154
      len = total;
#line 155
      total = (size_t )0;
    }
    {
#line 158
    tmp___0 = xnrealloc((void *)patterns, pcount + 1UL, sizeof(*patterns));
#line 158
    patterns = (struct patterns *)tmp___0;
#line 159
    *(patterns + pcount) = patterns0;
#line 161
    tmp___1 = re_compile_pattern(p, len, & (patterns + pcount)->regexbuf);
#line 161
    err = tmp___1;
    }
#line 163
    if (err) {
      {
#line 164
      error(2, 0, "%s", err);
      }
    }
#line 165
    pcount ++;
#line 166
    p = sep;
#line 142
    if (! p) {
#line 142
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (match_words) {
#line 174
    goto _L;
  } else
#line 174
  if (match_lines) {
    _L: /* CIL Label */
    {
#line 184
    bk = ! (syntax_bits___0 & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 185
    tmp___2 = xmalloc(((sizeof(word_beg_bk) - 1UL) + size) + sizeof(word_end_bk));
#line 185
    n = (char *)tmp___2;
    }
#line 187
    if (match_lines) {
#line 187
      if (bk) {
#line 187
        tmp___3 = line_beg_bk;
      } else {
#line 187
        tmp___3 = line_beg_no_bk;
      }
#line 187
      tmp___5 = tmp___3;
    } else {
#line 187
      if (bk) {
#line 187
        tmp___4 = word_beg_bk;
      } else {
#line 187
        tmp___4 = word_beg_no_bk;
      }
#line 187
      tmp___5 = tmp___4;
    }
    {
#line 187
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___5);
#line 189
    total = strlen((char const   *)n);
#line 190
    memcpy((void */* __restrict  */)(n + total), (void const   */* __restrict  */)pattern,
           size);
#line 191
    total += size;
    }
#line 192
    if (match_lines) {
#line 192
      if (bk) {
#line 192
        tmp___6 = line_end_bk;
      } else {
#line 192
        tmp___6 = line_end_no_bk;
      }
#line 192
      tmp___8 = tmp___6;
    } else {
#line 192
      if (bk) {
#line 192
        tmp___7 = word_end_bk;
      } else {
#line 192
        tmp___7 = word_end_no_bk;
      }
#line 192
      tmp___8 = tmp___7;
    }
    {
#line 192
    strcpy((char */* __restrict  */)(n + total), (char const   */* __restrict  */)tmp___8);
#line 194
    tmp___9 = strlen((char const   *)(n + total));
#line 194
    total += tmp___9;
#line 195
    motif = n;
#line 195
    pattern = (char const   *)motif;
#line 196
    size = total;
    }
  } else {
#line 199
    motif = (char *)((void *)0);
  }
  {
#line 201
  dfa = dfaalloc();
#line 202
  dfacomp(pattern, size, dfa, 1);
#line 203
  kwsmusts();
#line 205
  free((void *)motif);
  }
#line 206
  return;
}
}
#line 208 "/home/khheo/project/benchmark/grep-2.19/src/dfasearch.c"
size_t EGexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr )
{
  char const   *buflim___0 ;
  char const   *beg ;
  char const   *end ;
  char const   *ptr ;
  char const   *match ;
  char const   *best_match ;
  char const   *mb_start ;
  char eol ;
  int backref ;
  regoff_t start ;
  size_t len ;
  size_t best_len ;
  struct kwsmatch kwsm ;
  size_t i ;
  struct dfa *superset ;
  struct dfa *tmp ;
  _Bool dfafast ;
  _Bool tmp___0 ;
  char const   *next_beg ;
  char const   *dfa_beg ;
  size_t count ;
  _Bool exact_kwset_match ;
  char const   *prev_beg ;
  size_t offset ;
  size_t tmp___1 ;
  void *tmp___2 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  ptrdiff_t tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  regoff_t shorter_len ;
  wint_t tmp___19 ;
  _Bool tmp___20 ;
  wint_t tmp___21 ;
  _Bool tmp___22 ;
  size_t off ;

  {
  {
#line 213
  eol = (char )eolbyte;
#line 219
  tmp = dfasuperset((struct dfa  const  *)dfa);
#line 219
  superset = tmp;
#line 220
  tmp___0 = dfaisfast((struct dfa  const  *)dfa);
#line 220
  dfafast = tmp___0;
#line 222
  mb_start = buf;
#line 223
  buflim___0 = buf + size;
#line 225
  end = buf;
#line 225
  beg = end;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
#line 225
      goto while_break;
    }
#line 227
    end = buflim___0;
#line 229
    if (! start_ptr) {
#line 231
      dfa_beg = beg;
#line 232
      count = (size_t )0;
#line 233
      exact_kwset_match = (_Bool)0;
#line 236
      if (kwset___0) {
        {
#line 241
        tmp___1 = kwsexec(kwset___0, beg - (int )begline, (size_t )((buflim___0 - beg) + (long )begline),
                          & kwsm);
#line 241
        offset = tmp___1;
        }
#line 243
        if (offset == 0xffffffffffffffffUL) {
#line 244
          goto failure;
        }
        {
#line 245
        match = beg + offset;
#line 246
        prev_beg = beg;
#line 249
        tmp___2 = memrchr((void const   *)buf, (int )eol, (size_t )(match - buf));
#line 249
        beg = (char const   *)tmp___2;
        }
#line 250
        if (beg) {
#line 250
          beg ++;
        } else {
#line 250
          beg = buf;
        }
#line 251
        dfa_beg = beg;
#line 259
        exact_kwset_match = (_Bool )(kwsm.index < kwset_exact_matches);
#line 260
        if (exact_kwset_match) {
#line 260
          end = match;
        } else
#line 260
        if (! dfafast) {
#line 260
          end = match;
        } else {
#line 260
          if (16L > match - beg) {
#line 260
            tmp___8 = 16L;
          } else {
#line 260
            tmp___8 = match - beg;
          }
#line 260
          if (tmp___8 < (match - prev_beg) >> 2) {
#line 260
            end = match;
          } else {
#line 260
            if (16L > match - beg) {
#line 260
              tmp___7 = 16L;
            } else {
#line 260
              tmp___7 = match - beg;
            }
#line 260
            if (tmp___7 < (buflim___0 - prev_beg) >> 2) {
#line 260
              if (16L > match - beg) {
#line 260
                tmp___5 = 16L;
              } else {
#line 260
                tmp___5 = match - beg;
              }
#line 260
              tmp___6 = prev_beg + 4L * tmp___5;
            } else {
#line 260
              tmp___6 = buflim___0;
            }
#line 260
            end = tmp___6;
          }
        }
        {
#line 266
        tmp___9 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
#line 266
        end = (char const   *)tmp___9;
        }
#line 267
        if (end) {
#line 267
          end ++;
        } else {
#line 267
          end = buflim___0;
        }
#line 269
        if (exact_kwset_match) {
          {
#line 271
          tmp___10 = __ctype_get_mb_cur_max();
          }
#line 271
          if (tmp___10 == 1UL) {
#line 272
            goto success;
          } else {
            {
#line 271
            tmp___11 = using_utf8();
            }
#line 271
            if (tmp___11) {
#line 272
              goto success;
            }
          }
#line 273
          if ((unsigned long )mb_start < (unsigned long )beg) {
#line 274
            mb_start = beg;
          }
          {
#line 275
          tmp___12 = mb_goback(& mb_start, match, buflim___0);
          }
#line 275
          if (tmp___12 == 0L) {
#line 276
            goto success;
          }
#line 280
          dfa_beg = mb_start;
        }
      }
#line 285
      if (superset) {
#line 285
        if (! exact_kwset_match) {
          {
#line 290
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 290
            tmp___14 = dfaexec(superset, dfa_beg, (char *)end, 1, & count, (int *)((void *)0));
#line 290
            next_beg = (char const   *)tmp___14;
            }
#line 290
            if (next_beg) {
#line 290
              if ((unsigned long )next_beg != (unsigned long )end) {
#line 290
                if (! (count != 0UL)) {
#line 290
                  goto while_break___0;
                }
              } else {
#line 290
                goto while_break___0;
              }
            } else {
#line 290
              goto while_break___0;
            }
            {
#line 296
            count = (size_t )0;
#line 297
            tmp___13 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 297
            beg = (char const   *)tmp___13;
#line 298
            beg ++;
#line 299
            dfa_beg = beg;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 301
          if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 302
            goto __Cont;
          } else
#line 301
          if ((unsigned long )next_beg == (unsigned long )end) {
#line 302
            goto __Cont;
          }
          {
#line 305
          tmp___15 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 305
          end = (char const   *)tmp___15;
          }
#line 306
          if (end) {
#line 306
            end ++;
          } else {
#line 306
            end = buflim___0;
          }
        }
      }
      {
#line 310
      tmp___16 = dfaexec(dfa, dfa_beg, (char *)end, 0, & count, & backref);
#line 310
      next_beg = (char const   *)tmp___16;
      }
#line 314
      if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 315
        goto __Cont;
      } else
#line 314
      if ((unsigned long )next_beg == (unsigned long )end) {
#line 315
        goto __Cont;
      }
#line 318
      if (count != 0UL) {
        {
#line 320
        tmp___17 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 320
        beg = (char const   *)tmp___17;
#line 321
        beg ++;
        }
      }
      {
#line 323
      tmp___18 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 323
      end = (char const   *)tmp___18;
      }
#line 324
      if (end) {
#line 324
        end ++;
      } else {
#line 324
        end = buflim___0;
      }
#line 327
      if (! backref) {
#line 328
        goto success;
      }
#line 329
      ptr = beg;
    } else {
#line 335
      ptr = start_ptr;
    }
#line 340
    if ((long )(((1 << (sizeof(regoff_t ) * 8UL - 2UL)) - 1) * 2 + 1) < (end - beg) - 1L) {
      {
#line 341
      xalloc_die();
      }
    }
#line 344
    best_match = end;
#line 345
    best_len = (size_t )0;
#line 346
    i = (size_t )0;
    {
#line 346
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 346
      if (! (i < pcount)) {
#line 346
        goto while_break___1;
      }
      {
#line 348
      (patterns + i)->regexbuf.not_eol = 0U;
#line 349
      start = re_search(& (patterns + i)->regexbuf, beg, (__re_idx_t )((end - beg) - 1L),
                        (__re_idx_t )(ptr - beg), (regoff_t )((end - ptr) - 1L), & (patterns + i)->regs);
      }
#line 353
      if (start < -1) {
        {
#line 354
        xalloc_die();
        }
      } else
#line 355
      if (0 <= start) {
#line 357
        len = (size_t )(*((patterns + i)->regs.end + 0) - start);
#line 358
        match = beg + start;
#line 359
        if ((unsigned long )match > (unsigned long )best_match) {
#line 360
          goto __Cont___0;
        }
#line 361
        if (start_ptr) {
#line 361
          if (! match_words) {
#line 362
            goto assess_pattern_match;
          }
        }
#line 363
        if (! match_lines) {
#line 363
          if (! match_words) {
#line 366
            match = ptr;
#line 367
            len = (size_t )(end - ptr);
#line 368
            goto assess_pattern_match;
          } else {
#line 363
            goto _L;
          }
        } else
        _L: /* CIL Label */
#line 363
        if (match_lines) {
#line 363
          if (len == (size_t )((end - ptr) - 1L)) {
#line 366
            match = ptr;
#line 367
            len = (size_t )(end - ptr);
#line 368
            goto assess_pattern_match;
          }
        }
#line 377
        if (match_words) {
          {
#line 378
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 378
            if (! ((unsigned long )match <= (unsigned long )best_match)) {
#line 378
              goto while_break___2;
            }
            {
#line 380
            shorter_len = 0;
#line 381
            tmp___19 = mb_prev_wc(beg, match, end - 1);
#line 381
            tmp___20 = wordchar___0(tmp___19);
            }
#line 381
            if (! tmp___20) {
              {
#line 381
              tmp___21 = mb_next_wc(match + len, end - 1);
#line 381
              tmp___22 = wordchar___0(tmp___21);
              }
#line 381
              if (! tmp___22) {
#line 383
                goto assess_pattern_match;
              }
            }
#line 384
            if (len > 0UL) {
              {
#line 387
              len --;
#line 388
              (patterns + i)->regexbuf.not_eol = 1U;
#line 389
              shorter_len = re_match(& (patterns + i)->regexbuf, beg, (__re_idx_t )((match + len) - ptr),
                                     (__re_idx_t )(match - beg), & (patterns + i)->regs);
              }
#line 393
              if (shorter_len < -1) {
                {
#line 394
                xalloc_die();
                }
              }
            }
#line 396
            if (0 < shorter_len) {
#line 397
              len = (size_t )shorter_len;
            } else {
#line 401
              if ((unsigned long )match == (unsigned long )(end - 1)) {
#line 402
                goto while_break___2;
              }
              {
#line 403
              match ++;
#line 404
              (patterns + i)->regexbuf.not_eol = 0U;
#line 405
              start = re_search(& (patterns + i)->regexbuf, beg, (__re_idx_t )((end - beg) - 1L),
                                (__re_idx_t )(match - beg), (regoff_t )((end - match) - 1L),
                                & (patterns + i)->regs);
              }
#line 409
              if (start < 0) {
#line 411
                if (start < -1) {
                  {
#line 412
                  xalloc_die();
                  }
                }
#line 413
                goto while_break___2;
              }
#line 415
              len = (size_t )(*((patterns + i)->regs.end + 0) - start);
#line 416
              match = beg + start;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 419
        goto __Cont___0;
        assess_pattern_match:
#line 421
        if (! start_ptr) {
#line 425
          goto success;
        }
#line 427
        if ((unsigned long )match < (unsigned long )best_match) {
#line 430
          best_match = match;
#line 431
          best_len = len;
        } else
#line 427
        if ((unsigned long )match == (unsigned long )best_match) {
#line 427
          if (len > best_len) {
#line 430
            best_match = match;
#line 431
            best_len = len;
          }
        }
      }
      __Cont___0: /* CIL Label */
#line 346
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 435
    if ((unsigned long )best_match < (unsigned long )end) {
#line 439
      beg = best_match;
#line 440
      len = best_len;
#line 441
      goto success_in_len;
    }
    __Cont: /* CIL Label */
#line 225
    beg = end;
  }
  while_break: /* CIL Label */ ;
  }
  failure:
#line 446
  return ((size_t )-1);
  success:
#line 449
  len = (size_t )(end - beg);
  success_in_len:
#line 451
  off = (size_t )(beg - buf);
#line 452
  *match_size = len;
#line 453
  return (off);
}
}
#line 84 "/home/khheo/project/benchmark/grep-2.19/src/dfa.h"
void dfafree(struct dfa *d ) ;
#line 89
void dfainit(struct dfa *d ) ;
#line 92
void dfaparse(char const   *s , size_t len , struct dfa *d ) ;
#line 96
void dfaanalyze(struct dfa *d , int searchflag ) ;
#line 100
void dfastate(ptrdiff_t s , struct dfa *d , ptrdiff_t *trans___0 ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 288 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalpha)(wint_t __wc ) ;
#line 155
extern  __attribute__((__nothrow__)) wctype_t ( __attribute__((__leaf__)) wctype)(char const   *__property ) ;
#line 159
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswctype)(wint_t __wc ,
                                                                               wctype_t __desc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 90 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static unsigned char to_uchar___0(char ch )
{


  {
#line 93
  return ((unsigned char )ch);
}
}
#line 442
static void dfamust(struct dfa *d ) ;
#line 443
static void regexp(void) ;
#line 445 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void dfambcache(struct dfa *d )
{
  int i ;
  char c ;
  unsigned char uc ;
  mbstate_t s ;
  wchar_t wc ;
  size_t tmp___0 ;

  {
#line 449
  i = -128;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (i <= 127)) {
#line 449
      goto while_break;
    }
    {
#line 451
    c = (char )i;
#line 452
    uc = (unsigned char )i;
#line 453
    s.__count = 0;
#line 453
    s.__value.__wch = 0U;
#line 455
    tmp___0 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(& c),
                      (size_t )1, (mbstate_t */* __restrict  */)(& s));
    }
#line 455
    if (tmp___0 <= 1UL) {
#line 455
      d->mbrtowc_cache[uc] = (wint_t )wc;
    } else {
#line 455
      d->mbrtowc_cache[uc] = 4294967295U;
    }
#line 449
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return;
}
}
#line 476 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t mbs_to_wchar(wint_t *pwc , char const   *s , size_t n , struct dfa *d )
{
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 479
  uc = (unsigned char )*(s + 0);
#line 480
  wc = d->mbrtowc_cache[uc];
#line 482
  if (wc == 4294967295U) {
    {
#line 485
    tmp = mbrtowc((wchar_t */* __restrict  */)(& wch), (char const   */* __restrict  */)s,
                  n, (mbstate_t */* __restrict  */)(& d->mbs));
#line 485
    nbytes = tmp;
    }
#line 486
    if (0UL < nbytes) {
#line 486
      if (nbytes < 0xfffffffffffffffeUL) {
#line 488
        *pwc = (wint_t )wch;
#line 489
        return (nbytes);
      }
    }
    {
#line 491
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 494
  *pwc = wc;
#line 495
  return ((size_t )1);
}
}
#line 578 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool tstbit(unsigned int b , charclass_word * const  c )
{


  {
#line 581
  return ((_Bool )((*(c + b / 32U) >> b % 32U) & 1U));
}
}
#line 584 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void setbit(unsigned int b , charclass_word *c )
{


  {
#line 587
  *(c + b / 32U) |= 1U << b % 32U;
#line 588
  return;
}
}
#line 590 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void clrbit(unsigned int b , charclass_word *c )
{


  {
#line 593
  *(c + b / 32U) &= ~ (1U << b % 32U);
#line 595
  return;
}
}
#line 597 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void copyset(charclass_word * const  src , charclass_word *dst )
{


  {
  {
#line 600
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(charclass ));
  }
#line 601
  return;
}
}
#line 603 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void zeroset(charclass_word *s )
{


  {
  {
#line 606
  memset((void *)s, 0, sizeof(charclass ));
  }
#line 607
  return;
}
}
#line 609 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void notset(charclass_word *s )
{
  int i ;

  {
#line 614
  i = 0;
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    if (! (i < 8)) {
#line 614
      goto while_break;
    }
#line 615
    *(s + i) = (((1U << 31) << 1) - 1U) & ~ *(s + i);
#line 614
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return;
}
}
#line 618 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool equal(charclass_word * const  s1 , charclass_word * const  s2 )
{
  int tmp ;

  {
  {
#line 621
  tmp = memcmp((void const   *)s1, (void const   *)s2, sizeof(charclass ));
  }
#line 621
  return ((_Bool )(tmp == 0));
}
}
#line 632 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void *maybe_realloc(void *ptr , size_t nitems , size_t *nalloc , size_t itemsize )
{
  void *tmp ;

  {
#line 635
  if (nitems < *nalloc) {
#line 636
    return (ptr);
  }
  {
#line 637
  *nalloc = nitems;
#line 638
  tmp = x2nrealloc(ptr, nalloc, itemsize);
  }
#line 638
  return (tmp);
}
}
#line 642 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t dfa_charclass_index(struct dfa *d , charclass_word * const  s )
{
  size_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 647
  i = (size_t )0;
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! (i < d->cindex)) {
#line 647
      goto while_break;
    }
    {
#line 648
    tmp = equal(s, (charclass_word */* const  */)(*(d->charclasses + i)));
    }
#line 648
    if (tmp) {
#line 649
      return (i);
    }
#line 647
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  tmp___0 = maybe_realloc((void *)d->charclasses, d->cindex, & d->calloc, sizeof(*(d->charclasses)));
#line 650
  d->charclasses = (charclass *)tmp___0;
#line 652
  (d->cindex) ++;
#line 653
  copyset(s, (charclass_word *)(*(d->charclasses + i)));
  }
#line 654
  return (i);
}
}
#line 658 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static struct dfa *dfa___0  ;
#line 661 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t charclass_index(charclass_word * const  s )
{
  size_t tmp ;

  {
  {
#line 664
  tmp = dfa_charclass_index(dfa___0, s);
  }
#line 664
  return (tmp);
}
}
#line 668 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static reg_syntax_t syntax_bits  ;
#line 668 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static reg_syntax_t syntax_bits_set  ;
#line 671 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool case_fold  ;
#line 674 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static unsigned char eolbyte___0  ;
#line 677 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int sbit[256]  ;
#line 680 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static charclass letters  ;
#line 683 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static charclass newline  ;
#line 698 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int char_context(unsigned char c )
{
  unsigned short const   **tmp ;

  {
#line 701
  if ((int )c == (int )eolbyte___0) {
#line 702
    return (4);
  }
  {
#line 703
  tmp = __ctype_b_loc();
  }
#line 703
  if ((int const   )*(*tmp + (int )c) & 8) {
#line 704
    return (2);
  } else
#line 703
  if ((int )c == 95) {
#line 704
    return (2);
  }
#line 705
  return (1);
}
}
#line 708 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int wchar_context(wint_t wc )
{
  int tmp ;

  {
#line 711
  if (wc == (wint_t )((wchar_t )eolbyte___0)) {
#line 712
    return (4);
  } else
#line 711
  if (wc == 0U) {
#line 712
    return (4);
  }
#line 713
  if (wc == 95U) {
#line 714
    return (2);
  } else {
    {
#line 713
    tmp = iswalnum(wc);
    }
#line 713
    if (tmp) {
#line 714
      return (2);
    }
  }
#line 715
  return (1);
}
}
#line 719 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol )
{
  unsigned int i ;

  {
#line 724
  syntax_bits_set = (reg_syntax_t )1;
#line 725
  syntax_bits = bits;
#line 726
  case_fold = (_Bool )(fold != 0);
#line 727
  eolbyte___0 = eol;
#line 729
  i = 0U;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (i < 256U)) {
#line 729
      goto while_break;
    }
    {
#line 731
    sbit[i] = char_context((unsigned char )i);
    }
    {
#line 734
    if (sbit[i] == 2) {
#line 734
      goto case_2;
    }
#line 737
    if (sbit[i] == 4) {
#line 737
      goto case_4;
    }
#line 732
    goto switch_break;
    case_2: /* CIL Label */
    {
#line 735
    setbit(i, (charclass_word *)(letters));
    }
#line 736
    goto switch_break;
    case_4: /* CIL Label */
    {
#line 738
    setbit(i, (charclass_word *)(newline));
    }
#line 739
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 729
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return;
}
}
#line 749 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool setbit_wc(wint_t wc , charclass_word *c )
{
  int b ;
  int tmp ;

  {
  {
#line 752
  tmp = wctob(wc);
#line 752
  b = tmp;
  }
#line 753
  if (b == -1) {
#line 754
    return ((_Bool)0);
  }
  {
#line 756
  setbit((unsigned int )b, c);
  }
#line 757
  return ((_Bool)1);
}
}
#line 762 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void setbit_case_fold_c(int b , charclass_word *c )
{
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 765
  tmp = toupper(b);
#line 765
  ub = tmp;
#line 767
  i = 0;
  }
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i < 256)) {
#line 767
      goto while_break;
    }
    {
#line 768
    tmp___0 = toupper(i);
    }
#line 768
    if (tmp___0 == ub) {
      {
#line 769
      setbit((unsigned int )i, c);
      }
    }
#line 767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  return;
}
}
#line 779 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int utf8  =    -1;
#line 776 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
int using_utf8(void)
{
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 780
  if (utf8 < 0) {
    {
#line 783
    mbs.__count = 0;
#line 783
    mbs.__value.__wch = 0U;
#line 784
    tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)"\304\200",
                  (size_t )2, (mbstate_t */* __restrict  */)(& mbs));
    }
#line 784
    if (tmp == 2UL) {
#line 784
      if (wc == 256) {
#line 784
        tmp___0 = 1;
      } else {
#line 784
        tmp___0 = 0;
      }
    } else {
#line 784
      tmp___0 = 0;
    }
#line 784
    utf8 = tmp___0;
  }
#line 786
  return (utf8);
}
}
#line 817
static _Bool using_simple_locale(void) ;
#line 817 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int unibyte_c  =    -1;
#line 794 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool using_simple_locale(void)
{
  char const   *locale ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 813
  if (dfa___0->multibyte) {
#line 814
    return ((_Bool)0);
  } else {
#line 818
    if (unibyte_c < 0) {
      {
#line 820
      tmp = setlocale(6, (char const   *)((void *)0));
#line 820
      locale = (char const   *)tmp;
      }
#line 821
      if (! locale) {
#line 821
        tmp___2 = 1;
      } else {
        {
#line 821
        tmp___0 = strcmp(locale, "C");
        }
#line 821
        if (tmp___0 == 0) {
#line 821
          tmp___2 = 1;
        } else {
          {
#line 821
          tmp___1 = strcmp(locale, "POSIX");
          }
#line 821
          if (tmp___1 == 0) {
#line 821
            tmp___2 = 1;
          } else {
#line 821
            tmp___2 = 0;
          }
        }
      }
#line 821
      unibyte_c = tmp___2;
    }
#line 825
    return ((_Bool )unibyte_c);
  }
}
}
#line 834 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char const   *lexptr  ;
#line 835 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t lexleft  ;
#line 836 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static token lasttok  ;
#line 837 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static _Bool laststart  ;
#line 839 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t parens  ;
#line 840 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int minrep  ;
#line 840 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int maxrep  ;
#line 842 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int cur_mb_len  =    1;
#line 845 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static wint_t wctok  ;
#line 888 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static short const   lonesome_lower[19]  =
#line 888
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453,
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837,
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981,
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010,
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 910 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int case_folded_counterparts(wchar_t c , wchar_t *folded )
{
  int i ;
  int n ;
  wint_t uc ;
  wint_t tmp ;
  wint_t lc ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  wint_t tmp___3 ;
  wint_t li ;
  int tmp___4 ;
  wint_t tmp___5 ;

  {
  {
#line 914
  n = 0;
#line 915
  tmp = towupper((wint_t )c);
#line 915
  uc = tmp;
#line 916
  tmp___0 = towlower(uc);
#line 916
  lc = tmp___0;
  }
#line 917
  if (uc != (wint_t )c) {
#line 918
    tmp___1 = n;
#line 918
    n ++;
#line 918
    *(folded + tmp___1) = (wchar_t )uc;
  }
#line 919
  if (lc != uc) {
#line 919
    if (lc != (wint_t )c) {
      {
#line 919
      tmp___3 = towupper(lc);
      }
#line 919
      if (tmp___3 == uc) {
#line 920
        tmp___2 = n;
#line 920
        n ++;
#line 920
        *(folded + tmp___2) = (wchar_t )lc;
      }
    }
  }
#line 921
  i = 0;
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 921
    if (! ((unsigned long )i < sizeof(lonesome_lower) / sizeof(lonesome_lower[0]))) {
#line 921
      goto while_break;
    }
#line 923
    li = (wint_t )lonesome_lower[i];
#line 924
    if (li != lc) {
#line 924
      if (li != uc) {
#line 924
        if (li != (wint_t )c) {
          {
#line 924
          tmp___5 = towupper(li);
          }
#line 924
          if (tmp___5 == uc) {
#line 925
            tmp___4 = n;
#line 925
            n ++;
#line 925
            *(folded + tmp___4) = (wchar_t )li;
          }
        }
      }
    }
#line 921
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 927
  return (n);
}
}
#line 943 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static struct dfa_ctype  const  prednames[13]  =
#line 943
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0},
        {"upper", (predicate *)(& isupper), (_Bool)0},
        {"lower", (predicate *)(& islower), (_Bool)0},
        {"digit", (predicate *)(& isdigit), (_Bool)1},
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0},
        {"space", (predicate *)(& isspace), (_Bool)0},
        {"punct", (predicate *)(& ispunct), (_Bool)0},
        {"alnum", (predicate *)(& isalnum), (_Bool)0},
        {"print", (predicate *)(& isprint), (_Bool)0},
        {"graph", (predicate *)(& isgraph), (_Bool)0},
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0},
        {"blank", (predicate *)(& isblank), (_Bool)0},
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 959 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str )
{
  unsigned int i ;
  int tmp ;

  {
#line 963
  i = 0U;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    if (! prednames[i].name) {
#line 963
      goto while_break;
    }
    {
#line 964
    tmp = strcmp(str, (char const   *)prednames[i].name);
    }
#line 964
    if (tmp == 0) {
#line 965
      goto while_break;
    }
#line 963
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
}
}
#line 1224 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static charclass zeroclass  ;
#line 972 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static token parse_bracket_exp(void)
{
  _Bool invert ;
  int c ;
  int c1 ;
  int c2 ;
  charclass ccl ;
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  wint_t wc ;
  wint_t wc2 ;
  wint_t wc1 ;
  struct mb_char_classes *work_mbc ;
  size_t chars_al ;
  size_t ranges_al ;
  size_t ch_classes_al ;
  size_t equivs_al ;
  size_t coll_elems_al ;
  void *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  wint_t _wc ;
  size_t nbytes ;
  size_t tmp___3 ;
  unsigned char tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  wint_t _wc___0 ;
  size_t nbytes___0 ;
  size_t tmp___7 ;
  unsigned char tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  wint_t _wc___1 ;
  size_t nbytes___1 ;
  size_t tmp___11 ;
  unsigned char tmp___12 ;
  char str[33] ;
  size_t len ;
  char *tmp___13 ;
  char *tmp___14 ;
  wint_t _wc___2 ;
  size_t nbytes___2 ;
  size_t tmp___15 ;
  unsigned char tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  wint_t _wc___3 ;
  size_t nbytes___3 ;
  size_t tmp___20 ;
  unsigned char tmp___21 ;
  char const   *class ;
  char const   *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___27 ;
  char *tmp___28 ;
  wctype_t wt ;
  wctype_t tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  wint_t _wc___4 ;
  size_t nbytes___4 ;
  size_t tmp___35 ;
  unsigned char tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  wint_t _wc___5 ;
  size_t nbytes___5 ;
  size_t tmp___39 ;
  unsigned char tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  wint_t _wc___6 ;
  size_t nbytes___6 ;
  size_t tmp___43 ;
  unsigned char tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  wint_t _wc___7 ;
  size_t nbytes___7 ;
  size_t tmp___47 ;
  unsigned char tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  wint_t _wc___8 ;
  size_t nbytes___8 ;
  size_t tmp___51 ;
  unsigned char tmp___52 ;
  void *tmp___53 ;
  wint_t tmp___54 ;
  size_t tmp___55 ;
  wint_t tmp___56 ;
  wint_t tmp___57 ;
  size_t tmp___58 ;
  wint_t tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int uc ;
  int tmp___62 ;
  int uc2 ;
  int tmp___63 ;
  int uc1 ;
  int tmp___64 ;
  _Bool tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  wint_t _wc___9 ;
  size_t nbytes___9 ;
  size_t tmp___68 ;
  unsigned char tmp___69 ;
  int tmp___70 ;
  wchar_t folded[22] ;
  int i ;
  int n ;
  int tmp___71 ;
  int tmp___72 ;
  void *tmp___73 ;
  size_t tmp___74 ;
  _Bool tmp___75 ;
  char *tmp___76 ;
  size_t tmp___78 ;
  _Bool tmp___79 ;
  size_t tmp___81 ;

  {
#line 981
  known_bracket_exp = (_Bool)1;
#line 992
  wc1 = (wint_t )0;
#line 998
  coll_elems_al = (size_t )0;
#line 998
  equivs_al = coll_elems_al;
#line 998
  ch_classes_al = equivs_al;
#line 998
  ranges_al = ch_classes_al;
#line 998
  chars_al = ranges_al;
#line 999
  if (dfa___0->multibyte) {
    {
#line 1001
    tmp = maybe_realloc((void *)dfa___0->mbcsets, dfa___0->nmbcsets, & dfa___0->mbcsets_alloc,
                        sizeof(*(dfa___0->mbcsets)));
#line 1001
    dfa___0->mbcsets = (struct mb_char_classes *)tmp;
#line 1010
    tmp___0 = dfa___0->nmbcsets;
#line 1010
    (dfa___0->nmbcsets) ++;
#line 1010
    work_mbc = dfa___0->mbcsets + tmp___0;
#line 1011
    memset((void *)work_mbc, 0, sizeof(*work_mbc));
    }
  } else {
#line 1014
    work_mbc = (struct mb_char_classes *)((void *)0);
  }
  {
#line 1016
  memset((void *)(ccl), 0, sizeof(ccl));
  }
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    if (! lexleft) {
      {
#line 1017
      tmp___2 = gettext("unbalanced [");
      }
#line 1017
      if ((unsigned long )tmp___2 != (unsigned long )((char *)0)) {
        {
#line 1017
        tmp___1 = gettext("unbalanced [");
#line 1017
        dfaerror((char const   *)tmp___1);
        }
      } else {
#line 1017
        lasttok = (token )-1;
#line 1017
        return (lasttok);
      }
    } else {
      {
#line 1017
      tmp___3 = mbs_to_wchar(& _wc, lexptr, lexleft, dfa___0);
#line 1017
      nbytes = tmp___3;
#line 1017
      cur_mb_len = (int )nbytes;
#line 1017
      wc = _wc;
      }
#line 1017
      if (nbytes == 1UL) {
        {
#line 1017
        tmp___4 = to_uchar___0((char )*lexptr);
#line 1017
        c = (int )tmp___4;
        }
      } else {
#line 1017
        c = -1;
      }
#line 1017
      lexptr += nbytes;
#line 1017
      lexleft -= nbytes;
    }
#line 1017
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1018
  if (c == 94) {
    {
#line 1020
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1020
      if (! lexleft) {
        {
#line 1020
        tmp___6 = gettext("unbalanced [");
        }
#line 1020
        if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
          {
#line 1020
          tmp___5 = gettext("unbalanced [");
#line 1020
          dfaerror((char const   *)tmp___5);
          }
        } else {
#line 1020
          lasttok = (token )-1;
#line 1020
          return (lasttok);
        }
      } else {
        {
#line 1020
        tmp___7 = mbs_to_wchar(& _wc___0, lexptr, lexleft, dfa___0);
#line 1020
        nbytes___0 = tmp___7;
#line 1020
        cur_mb_len = (int )nbytes___0;
#line 1020
        wc = _wc___0;
        }
#line 1020
        if (nbytes___0 == 1UL) {
          {
#line 1020
          tmp___8 = to_uchar___0((char )*lexptr);
#line 1020
          c = (int )tmp___8;
          }
        } else {
#line 1020
          c = -1;
        }
#line 1020
        lexptr += nbytes___0;
#line 1020
        lexleft -= nbytes___0;
      }
#line 1020
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1021
    invert = (_Bool)1;
#line 1022
    known_bracket_exp = using_simple_locale();
    }
  } else {
#line 1025
    invert = (_Bool)0;
  }
#line 1027
  colon_warning_state = c == 58;
  {
#line 1028
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1030
    c1 = 256;
#line 1031
    colon_warning_state &= -3;
#line 1037
    if (c == 91) {
      {
#line 1039
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1039
        if (! lexleft) {
          {
#line 1039
          tmp___10 = gettext("unbalanced [");
          }
#line 1039
          if ((unsigned long )tmp___10 != (unsigned long )((char *)0)) {
            {
#line 1039
            tmp___9 = gettext("unbalanced [");
#line 1039
            dfaerror((char const   *)tmp___9);
            }
          } else {
#line 1039
            lasttok = (token )-1;
#line 1039
            return (lasttok);
          }
        } else {
          {
#line 1039
          tmp___11 = mbs_to_wchar(& _wc___1, lexptr, lexleft, dfa___0);
#line 1039
          nbytes___1 = tmp___11;
#line 1039
          cur_mb_len = (int )nbytes___1;
#line 1039
          wc1 = _wc___1;
          }
#line 1039
          if (nbytes___1 == 1UL) {
            {
#line 1039
            tmp___12 = to_uchar___0((char )*lexptr);
#line 1039
            c1 = (int )tmp___12;
            }
          } else {
#line 1039
            c1 = -1;
          }
#line 1039
          lexptr += nbytes___1;
#line 1039
          lexleft -= nbytes___1;
        }
#line 1039
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1041
      if (c1 == 58) {
#line 1041
        if (syntax_bits & ((1UL << 1) << 1)) {
#line 1041
          goto _L___0;
        } else {
#line 1041
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */
#line 1041
      if (c1 == 46) {
#line 1041
        goto _L___0;
      } else
#line 1041
      if (c1 == 61) {
        _L___0: /* CIL Label */
#line 1046
        len = (size_t )0;
        {
#line 1047
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1049
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1049
            if (! lexleft) {
              {
#line 1049
              tmp___14 = gettext("unbalanced [");
              }
#line 1049
              if ((unsigned long )tmp___14 != (unsigned long )((char *)0)) {
                {
#line 1049
                tmp___13 = gettext("unbalanced [");
#line 1049
                dfaerror((char const   *)tmp___13);
                }
              } else {
#line 1049
                lasttok = (token )-1;
#line 1049
                return (lasttok);
              }
            } else {
              {
#line 1049
              tmp___15 = mbs_to_wchar(& _wc___2, lexptr, lexleft, dfa___0);
#line 1049
              nbytes___2 = tmp___15;
#line 1049
              cur_mb_len = (int )nbytes___2;
#line 1049
              wc = _wc___2;
              }
#line 1049
              if (nbytes___2 == 1UL) {
                {
#line 1049
                tmp___16 = to_uchar___0((char )*lexptr);
#line 1049
                c = (int )tmp___16;
                }
              } else {
#line 1049
                c = -1;
              }
#line 1049
              lexptr += nbytes___2;
#line 1049
              lexleft -= nbytes___2;
            }
#line 1049
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1050
          if (c == c1) {
#line 1050
            if ((int const   )*lexptr == 93) {
#line 1051
              goto while_break___3;
            } else {
#line 1050
              goto _L;
            }
          } else
          _L: /* CIL Label */
#line 1050
          if (lexleft == 0UL) {
#line 1051
            goto while_break___3;
          }
#line 1052
          if (len < 32UL) {
#line 1053
            tmp___17 = len;
#line 1053
            len ++;
#line 1053
            str[tmp___17] = (char )c;
          } else {
#line 1056
            str[0] = (char )'\000';
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1058
        str[len] = (char )'\000';
        {
#line 1061
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1061
          if (! lexleft) {
            {
#line 1061
            tmp___19 = gettext("unbalanced [");
            }
#line 1061
            if ((unsigned long )tmp___19 != (unsigned long )((char *)0)) {
              {
#line 1061
              tmp___18 = gettext("unbalanced [");
#line 1061
              dfaerror((char const   *)tmp___18);
              }
            } else {
#line 1061
              lasttok = (token )-1;
#line 1061
              return (lasttok);
            }
          } else {
            {
#line 1061
            tmp___20 = mbs_to_wchar(& _wc___3, lexptr, lexleft, dfa___0);
#line 1061
            nbytes___3 = tmp___20;
#line 1061
            cur_mb_len = (int )nbytes___3;
#line 1061
            wc = _wc___3;
            }
#line 1061
            if (nbytes___3 == 1UL) {
              {
#line 1061
              tmp___21 = to_uchar___0((char )*lexptr);
#line 1061
              c = (int )tmp___21;
              }
            } else {
#line 1061
              c = -1;
            }
#line 1061
            lexptr += nbytes___3;
#line 1061
            lexleft -= nbytes___3;
          }
#line 1061
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1062
        if (c1 == 58) {
#line 1068
          if (case_fold) {
            {
#line 1068
            tmp___25 = strcmp((char const   *)(str), "upper");
            }
#line 1068
            if (tmp___25 == 0) {
#line 1068
              tmp___24 = "alpha";
            } else {
              {
#line 1068
              tmp___26 = strcmp((char const   *)(str), "lower");
              }
#line 1068
              if (tmp___26 == 0) {
#line 1068
                tmp___24 = "alpha";
              } else {
#line 1068
                tmp___24 = (char const   *)(str);
              }
            }
          } else {
#line 1068
            tmp___24 = (char const   *)(str);
          }
          {
#line 1068
          class = tmp___24;
#line 1071
          tmp___27 = find_pred(class);
#line 1071
          pred = (struct dfa_ctype  const  *)tmp___27;
          }
#line 1072
          if (! pred) {
            {
#line 1073
            tmp___28 = gettext("invalid character class");
#line 1073
            dfaerror((char const   *)tmp___28);
            }
          }
#line 1075
          if (dfa___0->multibyte) {
#line 1075
            if (! pred->single_byte_only) {
              {
#line 1078
              tmp___29 = wctype(class);
#line 1078
              wt = tmp___29;
#line 1080
              tmp___30 = maybe_realloc((void *)work_mbc->ch_classes, work_mbc->nch_classes,
                                       & ch_classes_al, sizeof(*(work_mbc->ch_classes)));
#line 1080
              work_mbc->ch_classes = (wctype_t *)tmp___30;
#line 1084
              tmp___31 = work_mbc->nch_classes;
#line 1084
              (work_mbc->nch_classes) ++;
#line 1084
              *(work_mbc->ch_classes + tmp___31) = wt;
              }
            }
          }
#line 1087
          c2 = 0;
          {
#line 1087
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1087
            if (! (c2 < 256)) {
#line 1087
              goto while_break___6;
            }
            {
#line 1088
            tmp___32 = (*(pred->func))(c2);
            }
#line 1088
            if (tmp___32) {
              {
#line 1089
              setbit((unsigned int )c2, (charclass_word *)(ccl));
              }
            }
#line 1087
            c2 ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
#line 1092
          known_bracket_exp = (_Bool)0;
        }
#line 1094
        colon_warning_state |= 8;
        {
#line 1097
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1097
          if (! lexleft) {
            {
#line 1097
            tmp___34 = gettext("unbalanced [");
            }
#line 1097
            if ((unsigned long )tmp___34 != (unsigned long )((char *)0)) {
              {
#line 1097
              tmp___33 = gettext("unbalanced [");
#line 1097
              dfaerror((char const   *)tmp___33);
              }
            } else {
#line 1097
              lasttok = (token )-1;
#line 1097
              return (lasttok);
            }
          } else {
            {
#line 1097
            tmp___35 = mbs_to_wchar(& _wc___4, lexptr, lexleft, dfa___0);
#line 1097
            nbytes___4 = tmp___35;
#line 1097
            cur_mb_len = (int )nbytes___4;
#line 1097
            wc1 = _wc___4;
            }
#line 1097
            if (nbytes___4 == 1UL) {
              {
#line 1097
              tmp___36 = to_uchar___0((char )*lexptr);
#line 1097
              c1 = (int )tmp___36;
              }
            } else {
#line 1097
              c1 = -1;
            }
#line 1097
            lexptr += nbytes___4;
#line 1097
            lexleft -= nbytes___4;
          }
#line 1097
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1098
        goto __Cont;
      }
    }
#line 1105
    if (c == 92) {
#line 1105
      if (syntax_bits & 1UL) {
        {
#line 1106
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1106
          if (! lexleft) {
            {
#line 1106
            tmp___38 = gettext("unbalanced [");
            }
#line 1106
            if ((unsigned long )tmp___38 != (unsigned long )((char *)0)) {
              {
#line 1106
              tmp___37 = gettext("unbalanced [");
#line 1106
              dfaerror((char const   *)tmp___37);
              }
            } else {
#line 1106
              lasttok = (token )-1;
#line 1106
              return (lasttok);
            }
          } else {
            {
#line 1106
            tmp___39 = mbs_to_wchar(& _wc___5, lexptr, lexleft, dfa___0);
#line 1106
            nbytes___5 = tmp___39;
#line 1106
            cur_mb_len = (int )nbytes___5;
#line 1106
            wc = _wc___5;
            }
#line 1106
            if (nbytes___5 == 1UL) {
              {
#line 1106
              tmp___40 = to_uchar___0((char )*lexptr);
#line 1106
              c = (int )tmp___40;
              }
            } else {
#line 1106
              c = -1;
            }
#line 1106
            lexptr += nbytes___5;
#line 1106
            lexleft -= nbytes___5;
          }
#line 1106
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 1108
    if (c1 == 256) {
      {
#line 1109
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1109
        if (! lexleft) {
          {
#line 1109
          tmp___42 = gettext("unbalanced [");
          }
#line 1109
          if ((unsigned long )tmp___42 != (unsigned long )((char *)0)) {
            {
#line 1109
            tmp___41 = gettext("unbalanced [");
#line 1109
            dfaerror((char const   *)tmp___41);
            }
          } else {
#line 1109
            lasttok = (token )-1;
#line 1109
            return (lasttok);
          }
        } else {
          {
#line 1109
          tmp___43 = mbs_to_wchar(& _wc___6, lexptr, lexleft, dfa___0);
#line 1109
          nbytes___6 = tmp___43;
#line 1109
          cur_mb_len = (int )nbytes___6;
#line 1109
          wc1 = _wc___6;
          }
#line 1109
          if (nbytes___6 == 1UL) {
            {
#line 1109
            tmp___44 = to_uchar___0((char )*lexptr);
#line 1109
            c1 = (int )tmp___44;
            }
          } else {
#line 1109
            c1 = -1;
          }
#line 1109
          lexptr += nbytes___6;
#line 1109
          lexleft -= nbytes___6;
        }
#line 1109
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 1111
    if (c1 == 45) {
      {
#line 1114
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1114
        if (! lexleft) {
          {
#line 1114
          tmp___46 = gettext("unbalanced [");
          }
#line 1114
          if ((unsigned long )tmp___46 != (unsigned long )((char *)0)) {
            {
#line 1114
            tmp___45 = gettext("unbalanced [");
#line 1114
            dfaerror((char const   *)tmp___45);
            }
          } else {
#line 1114
            lasttok = (token )-1;
#line 1114
            return (lasttok);
          }
        } else {
          {
#line 1114
          tmp___47 = mbs_to_wchar(& _wc___7, lexptr, lexleft, dfa___0);
#line 1114
          nbytes___7 = tmp___47;
#line 1114
          cur_mb_len = (int )nbytes___7;
#line 1114
          wc2 = _wc___7;
          }
#line 1114
          if (nbytes___7 == 1UL) {
            {
#line 1114
            tmp___48 = to_uchar___0((char )*lexptr);
#line 1114
            c2 = (int )tmp___48;
            }
          } else {
#line 1114
            c2 = -1;
          }
#line 1114
          lexptr += nbytes___7;
#line 1114
          lexleft -= nbytes___7;
        }
#line 1114
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1119
      if (c2 == 91) {
#line 1119
        if ((int const   )*lexptr == 46) {
#line 1121
          known_bracket_exp = (_Bool)0;
#line 1122
          c2 = ']';
        }
      }
#line 1125
      if (c2 != 93) {
#line 1127
        if (c2 == 92) {
#line 1127
          if (syntax_bits & 1UL) {
            {
#line 1128
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 1128
              if (! lexleft) {
                {
#line 1128
                tmp___50 = gettext("unbalanced [");
                }
#line 1128
                if ((unsigned long )tmp___50 != (unsigned long )((char *)0)) {
                  {
#line 1128
                  tmp___49 = gettext("unbalanced [");
#line 1128
                  dfaerror((char const   *)tmp___49);
                  }
                } else {
#line 1128
                  lasttok = (token )-1;
#line 1128
                  return (lasttok);
                }
              } else {
                {
#line 1128
                tmp___51 = mbs_to_wchar(& _wc___8, lexptr, lexleft, dfa___0);
#line 1128
                nbytes___8 = tmp___51;
#line 1128
                cur_mb_len = (int )nbytes___8;
#line 1128
                wc2 = _wc___8;
                }
#line 1128
                if (nbytes___8 == 1UL) {
                  {
#line 1128
                  tmp___52 = to_uchar___0((char )*lexptr);
#line 1128
                  c2 = (int )tmp___52;
                  }
                } else {
#line 1128
                  c2 = -1;
                }
#line 1128
                lexptr += nbytes___8;
#line 1128
                lexleft -= nbytes___8;
              }
#line 1128
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        }
#line 1130
        if (dfa___0->multibyte) {
#line 1136
          if (wc != 4294967295U) {
#line 1136
            if (wc2 != 4294967295U) {
              {
#line 1138
              tmp___53 = maybe_realloc((void *)work_mbc->ranges, work_mbc->nranges + 2UL,
                                       & ranges_al, sizeof(*(work_mbc->ranges)));
#line 1138
              work_mbc->ranges = (struct __anonstruct_ranges_154351087 *)tmp___53;
              }
#line 1141
              if (case_fold) {
                {
#line 1141
                tmp___54 = towlower(wc);
#line 1141
                (work_mbc->ranges + work_mbc->nranges)->beg = (wchar_t )tmp___54;
                }
              } else {
#line 1141
                (work_mbc->ranges + work_mbc->nranges)->beg = (wchar_t )wc;
              }
#line 1143
              tmp___55 = work_mbc->nranges;
#line 1143
              (work_mbc->nranges) ++;
#line 1143
              if (case_fold) {
                {
#line 1143
                tmp___56 = towlower(wc2);
#line 1143
                (work_mbc->ranges + tmp___55)->end = (wchar_t )tmp___56;
                }
              } else {
#line 1143
                (work_mbc->ranges + tmp___55)->end = (wchar_t )wc2;
              }
#line 1146
              if (case_fold) {
                {
#line 1146
                tmp___60 = iswalpha(wc);
                }
#line 1146
                if (tmp___60) {
#line 1146
                  goto _L___2;
                } else {
                  {
#line 1146
                  tmp___61 = iswalpha(wc2);
                  }
#line 1146
                  if (tmp___61) {
                    _L___2: /* CIL Label */
                    {
#line 1148
                    tmp___57 = towupper(wc);
#line 1148
                    (work_mbc->ranges + work_mbc->nranges)->beg = (wchar_t )tmp___57;
#line 1149
                    tmp___58 = work_mbc->nranges;
#line 1149
                    (work_mbc->nranges) ++;
#line 1149
                    tmp___59 = towupper(wc2);
#line 1149
                    (work_mbc->ranges + tmp___58)->end = (wchar_t )tmp___59;
                    }
                  }
                }
              }
            }
          }
        } else {
          {
#line 1154
          tmp___65 = using_simple_locale();
          }
#line 1154
          if (tmp___65) {
#line 1156
            c1 = c;
            {
#line 1156
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 1156
              if (! (c1 <= c2)) {
#line 1156
                goto while_break___12;
              }
              {
#line 1157
              setbit((unsigned int )c1, (charclass_word *)(ccl));
#line 1156
              c1 ++;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
#line 1158
            if (case_fold) {
              {
#line 1160
              tmp___62 = toupper(c);
#line 1160
              uc = tmp___62;
#line 1161
              tmp___63 = toupper(c2);
#line 1161
              uc2 = tmp___63;
#line 1162
              c1 = 0;
              }
              {
#line 1162
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 1162
                if (! (c1 < 256)) {
#line 1162
                  goto while_break___13;
                }
                {
#line 1164
                tmp___64 = toupper(c1);
#line 1164
                uc1 = tmp___64;
                }
#line 1165
                if (uc <= uc1) {
#line 1165
                  if (uc1 <= uc2) {
                    {
#line 1166
                    setbit((unsigned int )c1, (charclass_word *)(ccl));
                    }
                  }
                }
#line 1162
                c1 ++;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          } else {
#line 1171
            known_bracket_exp = (_Bool)0;
          }
        }
#line 1173
        colon_warning_state |= 8;
        {
#line 1174
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1174
          if (! lexleft) {
            {
#line 1174
            tmp___67 = gettext("unbalanced [");
            }
#line 1174
            if ((unsigned long )tmp___67 != (unsigned long )((char *)0)) {
              {
#line 1174
              tmp___66 = gettext("unbalanced [");
#line 1174
              dfaerror((char const   *)tmp___66);
              }
            } else {
#line 1174
              lasttok = (token )-1;
#line 1174
              return (lasttok);
            }
          } else {
            {
#line 1174
            tmp___68 = mbs_to_wchar(& _wc___9, lexptr, lexleft, dfa___0);
#line 1174
            nbytes___9 = tmp___68;
#line 1174
            cur_mb_len = (int )nbytes___9;
#line 1174
            wc1 = _wc___9;
            }
#line 1174
            if (nbytes___9 == 1UL) {
              {
#line 1174
              tmp___69 = to_uchar___0((char )*lexptr);
#line 1174
              c1 = (int )tmp___69;
              }
            } else {
#line 1174
              c1 = -1;
            }
#line 1174
            lexptr += nbytes___9;
#line 1174
            lexleft -= nbytes___9;
          }
#line 1174
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 1175
        goto __Cont;
      }
#line 1180
      lexptr -= cur_mb_len;
#line 1181
      lexleft += (size_t )cur_mb_len;
    }
#line 1184
    if (c == 58) {
#line 1184
      tmp___70 = 2;
    } else {
#line 1184
      tmp___70 = 4;
    }
#line 1184
    colon_warning_state |= tmp___70;
#line 1186
    if (! dfa___0->multibyte) {
#line 1188
      if (case_fold) {
        {
#line 1189
        setbit_case_fold_c(c, (charclass_word *)(ccl));
        }
      } else {
        {
#line 1191
        setbit((unsigned int )c, (charclass_word *)(ccl));
        }
      }
#line 1192
      goto __Cont;
    }
#line 1195
    if (wc == 4294967295U) {
#line 1196
      known_bracket_exp = (_Bool)0;
    } else {
#line 1201
      if (case_fold) {
        {
#line 1201
        tmp___71 = case_folded_counterparts((wchar_t )wc, (wchar_t *)(folded + 1));
#line 1201
        tmp___72 = tmp___71 + 1;
        }
      } else {
#line 1201
        tmp___72 = 1;
      }
#line 1201
      n = tmp___72;
#line 1203
      folded[0] = (wchar_t )wc;
#line 1204
      i = 0;
      {
#line 1204
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1204
        if (! (i < n)) {
#line 1204
          goto while_break___15;
        }
        {
#line 1205
        tmp___75 = setbit_wc((wint_t )folded[i], (charclass_word *)(ccl));
        }
#line 1205
        if (! tmp___75) {
          {
#line 1207
          tmp___73 = maybe_realloc((void *)work_mbc->chars, work_mbc->nchars, & chars_al,
                                   sizeof(*(work_mbc->chars)));
#line 1207
          work_mbc->chars = (wchar_t *)tmp___73;
#line 1210
          tmp___74 = work_mbc->nchars;
#line 1210
          (work_mbc->nchars) ++;
#line 1210
          *(work_mbc->chars + tmp___74) = folded[i];
          }
        }
#line 1204
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */
#line 1028
    wc = wc1;
#line 1028
    c = c1;
#line 1028
    if (! (c != 93)) {
#line 1028
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1216
  if (colon_warning_state == 7) {
    {
#line 1217
    tmp___76 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1217
    dfawarn((char const   *)tmp___76);
    }
  }
#line 1219
  if (! known_bracket_exp) {
#line 1220
    return ((token )257);
  }
#line 1222
  if (dfa___0->multibyte) {
    {
#line 1225
    work_mbc->invert = invert;
#line 1226
    tmp___79 = equal((charclass_word */* const  */)(ccl), (charclass_word */* const  */)(zeroclass));
    }
#line 1226
    if (tmp___79) {
#line 1226
      work_mbc->cset = (ptrdiff_t )-1;
    } else {
      {
#line 1226
      tmp___78 = charclass_index((charclass_word */* const  */)(ccl));
#line 1226
      work_mbc->cset = (ptrdiff_t )tmp___78;
      }
    }
#line 1227
    return ((token )273);
  }
#line 1230
  if (invert) {
#line 1232
    if (! (! dfa___0->multibyte)) {
      {
#line 1232
      __assert_fail("!dfa->multibyte", "/home/khheo/project/benchmark/grep-2.19/src/dfa.c",
                    1232U, "parse_bracket_exp");
      }
    }
    {
#line 1233
    notset((charclass_word *)(ccl));
    }
#line 1234
    if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1235
      clrbit((unsigned int )eolbyte___0, (charclass_word *)(ccl));
      }
    }
  }
  {
#line 1238
  tmp___81 = charclass_index((charclass_word */* const  */)(ccl));
  }
#line 1238
  return ((token )(275UL + tmp___81));
}
}
#line 1241 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static token lex(void)
{
  int c ;
  int c2 ;
  _Bool backslash ;
  charclass ccl ;
  int i ;
  wint_t _wc ;
  size_t nbytes ;
  size_t tmp ;
  unsigned char tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *p ;
  char const   *lim ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  unsigned short const   **tmp___13 ;
  size_t tmp___14 ;
  char const   *lexptr_saved ;
  size_t lexleft_saved ;
  unsigned short const   **tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  unsigned short const   **tmp___18 ;

  {
#line 1245
  backslash = (_Bool)0;
#line 1255
  i = 0;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! (i < 2)) {
#line 1255
      goto while_break;
    }
    {
#line 1257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1257
      if (! lexleft) {
#line 1257
        lasttok = (token )-1;
#line 1257
        return (lasttok);
      } else {
        {
#line 1257
        tmp = mbs_to_wchar(& _wc, lexptr, lexleft, dfa___0);
#line 1257
        nbytes = tmp;
#line 1257
        cur_mb_len = (int )nbytes;
#line 1257
        wctok = _wc;
        }
#line 1257
        if (nbytes == 1UL) {
          {
#line 1257
          tmp___0 = to_uchar___0((char )*lexptr);
#line 1257
          c = (int )tmp___0;
          }
        } else {
#line 1257
          c = -1;
        }
#line 1257
        lexptr += nbytes;
#line 1257
        lexleft -= nbytes;
      }
#line 1257
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1261
    if (c == 92) {
#line 1261
      goto case_92;
    }
#line 1269
    if (c == 94) {
#line 1269
      goto case_94;
    }
#line 1277
    if (c == 36) {
#line 1277
      goto case_36;
    }
#line 1301
    if (c == 57) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 56) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 55) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 54) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 53) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 52) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 51) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 50) {
#line 1301
      goto case_57;
    }
#line 1301
    if (c == 49) {
#line 1301
      goto case_57;
    }
#line 1309
    if (c == 96) {
#line 1309
      goto case_96;
    }
#line 1314
    if (c == 39) {
#line 1314
      goto case_39;
    }
#line 1319
    if (c == 60) {
#line 1319
      goto case_60;
    }
#line 1324
    if (c == 62) {
#line 1324
      goto case_62;
    }
#line 1329
    if (c == 98) {
#line 1329
      goto case_98;
    }
#line 1334
    if (c == 66) {
#line 1334
      goto case_66;
    }
#line 1339
    if (c == 63) {
#line 1339
      goto case_63;
    }
#line 1348
    if (c == 42) {
#line 1348
      goto case_42;
    }
#line 1355
    if (c == 43) {
#line 1355
      goto case_43;
    }
#line 1364
    if (c == 123) {
#line 1364
      goto case_123;
    }
#line 1422
    if (c == 124) {
#line 1422
      goto case_124;
    }
#line 1430
    if (c == 10) {
#line 1430
      goto case_10;
    }
#line 1437
    if (c == 40) {
#line 1437
      goto case_40;
    }
#line 1444
    if (c == 41) {
#line 1444
      goto case_41;
    }
#line 1453
    if (c == 46) {
#line 1453
      goto case_46;
    }
#line 1473
    if (c == 83) {
#line 1473
      goto case_83;
    }
#line 1473
    if (c == 115) {
#line 1473
      goto case_83;
    }
#line 1518
    if (c == 87) {
#line 1518
      goto case_87;
    }
#line 1518
    if (c == 119) {
#line 1518
      goto case_87;
    }
#line 1530
    if (c == 91) {
#line 1530
      goto case_91;
    }
#line 1536
    goto normal_char;
    case_92: /* CIL Label */
#line 1262
    if (backslash) {
#line 1263
      goto normal_char;
    }
#line 1264
    if (lexleft == 0UL) {
      {
#line 1265
      tmp___1 = gettext("unfinished \\ escape");
#line 1265
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1266
    backslash = (_Bool)1;
#line 1267
    goto switch_break;
    case_94: /* CIL Label */
#line 1270
    if (backslash) {
#line 1271
      goto normal_char;
    }
#line 1272
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1274
      lasttok = (token )258;
#line 1274
      return (lasttok);
    } else
#line 1272
    if (lasttok == -1L) {
#line 1274
      lasttok = (token )258;
#line 1274
      return (lasttok);
    } else
#line 1272
    if (lasttok == 270L) {
#line 1274
      lasttok = (token )258;
#line 1274
      return (lasttok);
    } else
#line 1272
    if (lasttok == 269L) {
#line 1274
      lasttok = (token )258;
#line 1274
      return (lasttok);
    }
#line 1275
    goto normal_char;
    case_36: /* CIL Label */
#line 1278
    if (backslash) {
#line 1279
      goto normal_char;
    }
#line 1280
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1290
      lasttok = (token )259;
#line 1290
      return (lasttok);
    } else
#line 1280
    if (lexleft == 0UL) {
#line 1290
      lasttok = (token )259;
#line 1290
      return (lasttok);
    } else {
#line 1280
      if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1280
        if (lexleft > 0UL) {
#line 1280
          if ((int const   )*lexptr == 41) {
#line 1280
            tmp___2 = 1;
          } else {
#line 1280
            tmp___2 = 0;
          }
        } else {
#line 1280
          tmp___2 = 0;
        }
#line 1280
        tmp___4 = tmp___2;
      } else {
#line 1280
        if (lexleft > 1UL) {
#line 1280
          if ((int const   )*(lexptr + 0) == 92) {
#line 1280
            if ((int const   )*(lexptr + 1) == 41) {
#line 1280
              tmp___3 = 1;
            } else {
#line 1280
              tmp___3 = 0;
            }
          } else {
#line 1280
            tmp___3 = 0;
          }
        } else {
#line 1280
          tmp___3 = 0;
        }
#line 1280
        tmp___4 = tmp___3;
      }
#line 1280
      if (tmp___4) {
#line 1290
        lasttok = (token )259;
#line 1290
        return (lasttok);
      } else {
#line 1280
        if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1280
          if (lexleft > 0UL) {
#line 1280
            if ((int const   )*lexptr == 124) {
#line 1280
              tmp___5 = 1;
            } else {
#line 1280
              tmp___5 = 0;
            }
          } else {
#line 1280
            tmp___5 = 0;
          }
#line 1280
          tmp___7 = tmp___5;
        } else {
#line 1280
          if (lexleft > 1UL) {
#line 1280
            if ((int const   )*(lexptr + 0) == 92) {
#line 1280
              if ((int const   )*(lexptr + 1) == 124) {
#line 1280
                tmp___6 = 1;
              } else {
#line 1280
                tmp___6 = 0;
              }
            } else {
#line 1280
              tmp___6 = 0;
            }
          } else {
#line 1280
            tmp___6 = 0;
          }
#line 1280
          tmp___7 = tmp___6;
        }
#line 1280
        if (tmp___7) {
#line 1290
          lasttok = (token )259;
#line 1290
          return (lasttok);
        } else
#line 1280
        if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1280
          if (lexleft > 0UL) {
#line 1280
            if ((int const   )*lexptr == 10) {
#line 1290
              lasttok = (token )259;
#line 1290
              return (lasttok);
            }
          }
        }
      }
    }
#line 1291
    goto normal_char;
    case_57: /* CIL Label */
    case_56: /* CIL Label */
    case_55: /* CIL Label */
    case_54: /* CIL Label */
    case_53: /* CIL Label */
    case_52: /* CIL Label */
    case_51: /* CIL Label */
    case_50: /* CIL Label */
    case_49: /* CIL Label */
#line 1302
    if (backslash) {
#line 1302
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1304
        laststart = (_Bool)0;
#line 1305
        lasttok = (token )257;
#line 1305
        return (lasttok);
      }
    }
#line 1307
    goto normal_char;
    case_96: /* CIL Label */
#line 1310
    if (backslash) {
#line 1310
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1311
        lasttok = (token )258;
#line 1311
        return (lasttok);
      }
    }
#line 1312
    goto normal_char;
    case_39: /* CIL Label */
#line 1315
    if (backslash) {
#line 1315
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1316
        lasttok = (token )259;
#line 1316
        return (lasttok);
      }
    }
#line 1317
    goto normal_char;
    case_60: /* CIL Label */
#line 1320
    if (backslash) {
#line 1320
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1321
        lasttok = (token )260;
#line 1321
        return (lasttok);
      }
    }
#line 1322
    goto normal_char;
    case_62: /* CIL Label */
#line 1325
    if (backslash) {
#line 1325
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1326
        lasttok = (token )261;
#line 1326
        return (lasttok);
      }
    }
#line 1327
    goto normal_char;
    case_98: /* CIL Label */
#line 1330
    if (backslash) {
#line 1330
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1331
        lasttok = (token )262;
#line 1331
        return (lasttok);
      }
    }
#line 1332
    goto normal_char;
    case_66: /* CIL Label */
#line 1335
    if (backslash) {
#line 1335
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1336
        lasttok = (token )263;
#line 1336
        return (lasttok);
      }
    }
#line 1337
    goto normal_char;
    case_63: /* CIL Label */
#line 1340
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1341
      goto normal_char;
    }
#line 1342
    if ((int )backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1343
      goto normal_char;
    }
#line 1344
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1344
      if (laststart) {
#line 1345
        goto normal_char;
      }
    }
#line 1346
    lasttok = (token )264;
#line 1346
    return (lasttok);
    case_42: /* CIL Label */
#line 1349
    if (backslash) {
#line 1350
      goto normal_char;
    }
#line 1351
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1351
      if (laststart) {
#line 1352
        goto normal_char;
      }
    }
#line 1353
    lasttok = (token )265;
#line 1353
    return (lasttok);
    case_43: /* CIL Label */
#line 1356
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1357
      goto normal_char;
    }
#line 1358
    if ((int )backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1359
      goto normal_char;
    }
#line 1360
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1360
      if (laststart) {
#line 1361
        goto normal_char;
      }
    }
#line 1362
    lasttok = (token )266;
#line 1362
    return (lasttok);
    case_123: /* CIL Label */
#line 1365
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1366
      goto normal_char;
    }
#line 1367
    if ((int )backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1368
      goto normal_char;
    }
#line 1369
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1369
      if (laststart) {
#line 1370
        goto normal_char;
      }
    }
#line 1379
    p = lexptr;
#line 1380
    lim = p + lexleft;
#line 1381
    maxrep = -1;
#line 1381
    minrep = maxrep;
    {
#line 1382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1382
      if ((unsigned long )p != (unsigned long )lim) {
#line 1382
        if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1382
          goto while_break___1;
        }
      } else {
#line 1382
        goto while_break___1;
      }
#line 1384
      if (minrep < 0) {
#line 1385
        minrep = (int )((int const   )*p - 48);
      } else
#line 1387
      if (32768 < (minrep * 10 + (int )*p) - 48) {
#line 1387
        minrep = 32768;
      } else {
#line 1387
        minrep = (minrep * 10 + (int )*p) - 48;
      }
#line 1382
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1389
    if ((unsigned long )p != (unsigned long )lim) {
#line 1391
      if ((int const   )*p != 44) {
#line 1392
        maxrep = minrep;
      } else {
#line 1395
        if (minrep < 0) {
#line 1396
          minrep = 0;
        }
        {
#line 1397
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1397
          p ++;
#line 1397
          if ((unsigned long )p != (unsigned long )lim) {
#line 1397
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1397
              goto while_break___2;
            }
          } else {
#line 1397
            goto while_break___2;
          }
#line 1399
          if (maxrep < 0) {
#line 1400
            maxrep = (int )((int const   )*p - 48);
          } else
#line 1402
          if (32768 < (maxrep * 10 + (int )*p) - 48) {
#line 1402
            maxrep = 32768;
          } else {
#line 1402
            maxrep = (maxrep * 10 + (int )*p) - 48;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1406
    if (! backslash) {
#line 1406
      goto _L___3;
    } else
#line 1406
    if ((unsigned long )p != (unsigned long )lim) {
#line 1406
      tmp___9 = p;
#line 1406
      p ++;
#line 1406
      if ((int const   )*tmp___9 == 92) {
        _L___3: /* CIL Label */
#line 1406
        if ((unsigned long )p != (unsigned long )lim) {
#line 1406
          tmp___10 = p;
#line 1406
          p ++;
#line 1406
          if ((int const   )*tmp___10 == 125) {
#line 1406
            if (0 <= minrep) {
#line 1406
              if (! (maxrep < 0)) {
#line 1406
                if (! (minrep <= maxrep)) {
#line 1406
                  goto _L___4;
                }
              }
            } else {
#line 1406
              goto _L___4;
            }
          } else {
#line 1406
            goto _L___4;
          }
        } else {
#line 1406
          goto _L___4;
        }
      } else {
#line 1406
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */
#line 1410
      if (syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1411
        goto normal_char;
      }
      {
#line 1412
      tmp___8 = gettext("Invalid content of \\{\\}");
#line 1412
      dfaerror((char const   *)tmp___8);
      }
    }
#line 1414
    if (32767 < maxrep) {
      {
#line 1415
      tmp___11 = gettext("Regular expression too big");
#line 1415
      dfaerror((char const   *)tmp___11);
      }
    }
#line 1416
    lexptr = p;
#line 1417
    lexleft = (size_t )(lim - p);
#line 1419
    laststart = (_Bool)0;
#line 1420
    lasttok = (token )267;
#line 1420
    return (lasttok);
    case_124: /* CIL Label */
#line 1423
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1424
      goto normal_char;
    }
#line 1425
    if ((int )backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1426
      goto normal_char;
    }
#line 1427
    laststart = (_Bool)1;
#line 1428
    lasttok = (token )269;
#line 1428
    return (lasttok);
    case_10: /* CIL Label */
#line 1431
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1433
      goto normal_char;
    } else
#line 1431
    if (backslash) {
#line 1433
      goto normal_char;
    } else
#line 1431
    if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1433
      goto normal_char;
    }
#line 1434
    laststart = (_Bool)1;
#line 1435
    lasttok = (token )269;
#line 1435
    return (lasttok);
    case_40: /* CIL Label */
#line 1438
    if ((int )backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1439
      goto normal_char;
    }
#line 1440
    parens ++;
#line 1441
    laststart = (_Bool)1;
#line 1442
    lasttok = (token )270;
#line 1442
    return (lasttok);
    case_41: /* CIL Label */
#line 1445
    if ((int )backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1446
      goto normal_char;
    }
#line 1447
    if (parens == 0UL) {
#line 1447
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1448
        goto normal_char;
      }
    }
#line 1449
    parens --;
#line 1450
    laststart = (_Bool)0;
#line 1451
    lasttok = (token )271;
#line 1451
    return (lasttok);
    case_46: /* CIL Label */
#line 1454
    if (backslash) {
#line 1455
      goto normal_char;
    }
#line 1456
    if (dfa___0->multibyte) {
#line 1460
      laststart = (_Bool)0;
#line 1461
      lasttok = (token )272;
#line 1461
      return (lasttok);
    }
    {
#line 1463
    zeroset((charclass_word *)(ccl));
#line 1464
    notset((charclass_word *)(ccl));
    }
#line 1465
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
#line 1466
      clrbit((unsigned int )eolbyte___0, (charclass_word *)(ccl));
      }
    }
#line 1467
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1468
      clrbit((unsigned int )'\000', (charclass_word *)(ccl));
      }
    }
    {
#line 1469
    laststart = (_Bool)0;
#line 1470
    tmp___12 = charclass_index((charclass_word */* const  */)(ccl));
#line 1470
    lasttok = (token )(275UL + tmp___12);
    }
#line 1470
    return (lasttok);
    case_83: /* CIL Label */
    case_115: /* CIL Label */
#line 1474
    if (! backslash) {
#line 1475
      goto normal_char;
    } else
#line 1474
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1475
      goto normal_char;
    }
#line 1476
    if (! dfa___0->multibyte) {
      {
#line 1478
      zeroset((charclass_word *)(ccl));
#line 1479
      c2 = 0;
      }
      {
#line 1479
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1479
        if (! (c2 < 256)) {
#line 1479
          goto while_break___3;
        }
        {
#line 1480
        tmp___13 = __ctype_b_loc();
        }
#line 1480
        if ((int const   )*(*tmp___13 + c2) & 8192) {
          {
#line 1481
          setbit((unsigned int )c2, (charclass_word *)(ccl));
          }
        }
#line 1479
        c2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1482
      if (c == 83) {
        {
#line 1483
        notset((charclass_word *)(ccl));
        }
      }
      {
#line 1484
      laststart = (_Bool)0;
#line 1485
      tmp___14 = charclass_index((charclass_word */* const  */)(ccl));
#line 1485
      lasttok = (token )(275UL + tmp___14);
      }
#line 1485
      return (lasttok);
    }
    {
#line 1508
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1508
      lexptr_saved = lexptr;
#line 1508
      lexleft_saved = lexleft;
#line 1508
      if (c == 115) {
#line 1508
        lexptr = "[:space:]]";
      } else {
#line 1508
        lexptr = "^[:space:]]";
      }
      {
#line 1508
      lexleft = strlen(lexptr);
#line 1510
      lasttok = parse_bracket_exp();
#line 1512
      lexptr = lexptr_saved;
#line 1512
      lexleft = lexleft_saved;
      }
#line 1508
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1514
    laststart = (_Bool)0;
#line 1515
    return (lasttok);
    case_87: /* CIL Label */
    case_119: /* CIL Label */
#line 1519
    if (! backslash) {
#line 1520
      goto normal_char;
    } else
#line 1519
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1520
      goto normal_char;
    }
    {
#line 1521
    zeroset((charclass_word *)(ccl));
#line 1522
    c2 = 0;
    }
    {
#line 1522
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1522
      if (! (c2 < 256)) {
#line 1522
        goto while_break___5;
      }
      {
#line 1523
      tmp___15 = __ctype_b_loc();
      }
#line 1523
      if ((int const   )*(*tmp___15 + c2) & 8) {
        {
#line 1524
        setbit((unsigned int )c2, (charclass_word *)(ccl));
        }
      } else
#line 1523
      if (c2 == 95) {
        {
#line 1524
        setbit((unsigned int )c2, (charclass_word *)(ccl));
        }
      }
#line 1522
      c2 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1525
    if (c == 87) {
      {
#line 1526
      notset((charclass_word *)(ccl));
      }
    }
    {
#line 1527
    laststart = (_Bool)0;
#line 1528
    tmp___16 = charclass_index((charclass_word */* const  */)(ccl));
#line 1528
    lasttok = (token )(275UL + tmp___16);
    }
#line 1528
    return (lasttok);
    case_91: /* CIL Label */
#line 1531
    if (backslash) {
#line 1532
      goto normal_char;
    }
    {
#line 1533
    laststart = (_Bool)0;
#line 1534
    lasttok = parse_bracket_exp();
    }
#line 1534
    return (lasttok);
    normal_char:
    switch_default: /* CIL Label */
#line 1538
    laststart = (_Bool)0;
#line 1541
    if (dfa___0->multibyte) {
#line 1542
      lasttok = (token )274;
#line 1542
      return (lasttok);
    }
#line 1544
    if (case_fold) {
      {
#line 1544
      tmp___18 = __ctype_b_loc();
      }
#line 1544
      if ((int const   )*(*tmp___18 + c) & 1024) {
        {
#line 1546
        zeroset((charclass_word *)(ccl));
#line 1547
        setbit_case_fold_c(c, (charclass_word *)(ccl));
#line 1548
        tmp___17 = charclass_index((charclass_word */* const  */)(ccl));
#line 1548
        lasttok = (token )(275UL + tmp___17);
        }
#line 1548
        return (lasttok);
      }
    }
#line 1551
    lasttok = (token )c;
#line 1551
    return (lasttok);
    switch_break: /* CIL Label */ ;
    }
#line 1255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1557
  abort();
  }
#line 1558
  return ((token )-1);
}
}
#line 1563 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static token tok  ;
#line 1564 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t depth  ;
#line 1570 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void addtok_mb(token t , int mbprop )
{
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1573
  if (dfa___0->talloc == dfa___0->tindex) {
    {
#line 1575
    tmp = x2nrealloc((void *)dfa___0->tokens, & dfa___0->talloc, sizeof(*(dfa___0->tokens)));
#line 1575
    dfa___0->tokens = (token *)tmp;
    }
#line 1577
    if (dfa___0->multibyte) {
      {
#line 1578
      tmp___0 = xnrealloc((void *)dfa___0->multibyte_prop, dfa___0->talloc, sizeof(*(dfa___0->multibyte_prop)));
#line 1578
      dfa___0->multibyte_prop = (int *)tmp___0;
      }
    }
  }
#line 1581
  if (dfa___0->multibyte) {
#line 1582
    *(dfa___0->multibyte_prop + dfa___0->tindex) = mbprop;
  }
#line 1583
  tmp___1 = dfa___0->tindex;
#line 1583
  (dfa___0->tindex) ++;
#line 1583
  *(dfa___0->tokens + tmp___1) = t;
  {
#line 1589
  if (t == 266L) {
#line 1589
    goto case_266;
  }
#line 1589
  if (t == 265L) {
#line 1589
    goto case_266;
  }
#line 1589
  if (t == 264L) {
#line 1589
    goto case_266;
  }
#line 1593
  if (t == 269L) {
#line 1593
    goto case_269;
  }
#line 1593
  if (t == 268L) {
#line 1593
    goto case_269;
  }
#line 1597
  if (t == 257L) {
#line 1597
    goto case_257;
  }
#line 1603
  if (t == 256L) {
#line 1603
    goto case_256;
  }
#line 1600
  goto switch_default;
  case_266: /* CIL Label */
  case_265: /* CIL Label */
  case_264: /* CIL Label */
#line 1590
  goto switch_break;
  case_269: /* CIL Label */
  case_268: /* CIL Label */
#line 1594
  depth --;
#line 1595
  goto switch_break;
  case_257: /* CIL Label */
#line 1598
  dfa___0->fast = (_Bool)0;
  switch_default: /* CIL Label */
#line 1601
  (dfa___0->nleaves) ++;
  case_256: /* CIL Label */
#line 1604
  depth ++;
#line 1605
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1607
  if (depth > dfa___0->depth) {
#line 1608
    dfa___0->depth = depth;
  }
#line 1609
  return;
}
}
#line 1611
static void addtok_wc(wint_t wc ) ;
#line 1615 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void addtok(token t )
{
  _Bool need_or ;
  struct mb_char_classes *work_mbc ;
  size_t i ;

  {
#line 1618
  if (dfa___0->multibyte) {
#line 1618
    if (t == 273L) {
#line 1620
      need_or = (_Bool)0;
#line 1621
      work_mbc = dfa___0->mbcsets + (dfa___0->nmbcsets - 1UL);
#line 1625
      if (! work_mbc->invert) {
#line 1628
        i = (size_t )0;
        {
#line 1628
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1628
          if (! (i < work_mbc->nchars)) {
#line 1628
            goto while_break;
          }
          {
#line 1630
          addtok_wc((wint_t )*(work_mbc->chars + i));
          }
#line 1631
          if (need_or) {
            {
#line 1632
            addtok((token )269);
            }
          }
#line 1633
          need_or = (_Bool)1;
#line 1628
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1635
        work_mbc->nchars = (size_t )0;
      }
#line 1642
      if (work_mbc->invert) {
#line 1642
        goto _L;
      } else
#line 1642
      if (work_mbc->nch_classes != 0UL) {
#line 1642
        goto _L;
      } else
#line 1642
      if (work_mbc->nranges != 0UL) {
#line 1642
        goto _L;
      } else
#line 1642
      if (work_mbc->nequivs != 0UL) {
#line 1642
        goto _L;
      } else
#line 1642
      if (work_mbc->ncoll_elems != 0UL) {
        _L: /* CIL Label */
        {
#line 1647
        addtok_mb((token )273, (int )(((dfa___0->nmbcsets - 1UL) << 2) + 3UL));
        }
#line 1648
        if (need_or) {
          {
#line 1649
          addtok((token )269);
          }
        }
      } else
#line 1655
      if (work_mbc->cset != -1L) {
        {
#line 1657
        addtok(275L + work_mbc->cset);
        }
#line 1658
        if (need_or) {
          {
#line 1659
          addtok((token )269);
          }
        }
      }
    } else {
      {
#line 1665
      addtok_mb(t, 3);
      }
    }
  } else {
    {
#line 1665
    addtok_mb(t, 3);
    }
  }
#line 1667
  return;
}
}
#line 1675 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void addtok_wc(wint_t wc )
{
  unsigned char buf[16] ;
  mbstate_t s ;
  int i ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1679
  s.__count = 0;
#line 1679
  s.__value.__wch = 0U;
#line 1681
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1681
  stored_bytes = tmp;
  }
#line 1683
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1684
    cur_mb_len = (int )stored_bytes;
  } else {
#line 1689
    cur_mb_len = 1;
#line 1690
    buf[0] = (unsigned char)0;
  }
#line 1693
  if (cur_mb_len == 1) {
#line 1693
    tmp___0 = 3;
  } else {
#line 1693
    tmp___0 = 1;
  }
  {
#line 1693
  addtok_mb((token )buf[0], tmp___0);
#line 1694
  i = 1;
  }
  {
#line 1694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1694
    if (! (i < cur_mb_len)) {
#line 1694
      goto while_break;
    }
#line 1696
    if (i == cur_mb_len - 1) {
#line 1696
      tmp___1 = 2;
    } else {
#line 1696
      tmp___1 = 0;
    }
    {
#line 1696
    addtok_mb((token )buf[i], tmp___1);
#line 1697
    addtok((token )268);
#line 1694
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1699
  return;
}
}
#line 1704
static void add_utf8_anychar(void) ;
#line 1704 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static charclass const   utf8_classes[5]  = { {        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,
            ((1U << 31) << 1) - 1U,        ((1U << 31) << 1) - 1U,        (charclass_word )0,        (charclass_word )0},
   {        ((1U << 31) << 1) - 1U,        ((1U << 31) << 1) - 1U,        ((1U << 31) << 1) - 1U,        ((1U << 31) << 1) - 1U,
            (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )0},
   {        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,
            (charclass_word )0,        (charclass_word )0,        4294967292U & (((1U << 31) << 1) - 1U),        (charclass_word )0},
   {        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,
            (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )65535},
   {        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )0,
            (charclass_word )0,        (charclass_word )0,        (charclass_word )0,        (charclass_word )16711680}};
#line 1701 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void add_utf8_anychar(void)
{
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  size_t tmp ;

  {
#line 1721
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1725
  if (dfa___0->utf8_anychar_classes[0] == 0L) {
#line 1726
    i = 0U;
    {
#line 1726
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1726
      if (! (i < n)) {
#line 1726
        goto while_break;
      }
      {
#line 1729
      copyset((charclass_word */* const  */)(utf8_classes[i]), (charclass_word *)(c));
      }
#line 1730
      if (i == 1U) {
#line 1732
        if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1733
          clrbit((unsigned int )eolbyte___0, (charclass_word *)(c));
          }
        }
#line 1734
        if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1735
          clrbit((unsigned int )'\000', (charclass_word *)(c));
          }
        }
      }
      {
#line 1737
      tmp = charclass_index((charclass_word */* const  */)(c));
#line 1737
      dfa___0->utf8_anychar_classes[i] = (token )(275UL + tmp);
#line 1726
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1750
  i = 1U;
  {
#line 1750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1750
    if (! (i < n)) {
#line 1750
      goto while_break___0;
    }
    {
#line 1751
    addtok(dfa___0->utf8_anychar_classes[i]);
#line 1750
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1752
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1752
    i --;
#line 1752
    if (! (i > 1U)) {
#line 1752
      goto while_break___1;
    }
    {
#line 1754
    addtok(dfa___0->utf8_anychar_classes[0]);
#line 1755
    addtok((token )268);
#line 1756
    addtok((token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1758
  return;
}
}
#line 1795 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void atom(void)
{
  wchar_t folded[21] ;
  int i ;
  int n ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1798
  if (tok == 274L) {
#line 1800
    if (wctok == 4294967295U) {
      {
#line 1801
      addtok((token )257);
      }
    } else {
      {
#line 1804
      addtok_wc(wctok);
      }
#line 1806
      if (case_fold) {
        {
#line 1809
        tmp = case_folded_counterparts((wchar_t )wctok, (wchar_t *)(folded));
#line 1809
        n = tmp;
#line 1810
        i = 0;
        }
        {
#line 1810
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1810
          if (! (i < n)) {
#line 1810
            goto while_break;
          }
          {
#line 1812
          addtok_wc((wint_t )folded[i]);
#line 1813
          addtok((token )269);
#line 1810
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1818
    tok = lex();
    }
  } else
#line 1820
  if (tok == 272L) {
    {
#line 1820
    tmp___1 = using_utf8();
    }
#line 1820
    if (tmp___1) {
      {
#line 1829
      add_utf8_anychar();
#line 1830
      tok = lex();
      }
    } else {
#line 1820
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 1832
  if (tok >= 0L) {
#line 1832
    if (tok < 256L) {
      {
#line 1837
      addtok(tok);
#line 1838
      tok = lex();
      }
    } else {
#line 1832
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1832
  if (tok >= 275L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 257L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 258L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 259L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 260L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 272L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 273L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 261L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 262L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1832
  if (tok == 263L) {
    {
#line 1837
    addtok(tok);
#line 1838
    tok = lex();
    }
  } else
#line 1840
  if (tok == 270L) {
    {
#line 1842
    tok = lex();
#line 1843
    regexp();
    }
#line 1844
    if (tok != 271L) {
      {
#line 1845
      tmp___0 = gettext("unbalanced (");
#line 1845
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1846
    tok = lex();
    }
  } else {
    {
#line 1849
    addtok((token )256);
    }
  }
#line 1850
  return;
}
}
#line 1853 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(size_t tindex )
{
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1864
  if (*(dfa___0->tokens + (tindex - 1UL)) == 266L) {
#line 1864
    goto case_266;
  }
#line 1864
  if (*(dfa___0->tokens + (tindex - 1UL)) == 265L) {
#line 1864
    goto case_266;
  }
#line 1864
  if (*(dfa___0->tokens + (tindex - 1UL)) == 264L) {
#line 1864
    goto case_266;
  }
#line 1867
  if (*(dfa___0->tokens + (tindex - 1UL)) == 269L) {
#line 1867
    goto case_269;
  }
#line 1867
  if (*(dfa___0->tokens + (tindex - 1UL)) == 268L) {
#line 1867
    goto case_269;
  }
#line 1860
  goto switch_default;
  switch_default: /* CIL Label */
#line 1861
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */
  case_265: /* CIL Label */
  case_264: /* CIL Label */
  {
#line 1865
  tmp = nsubtoks(tindex - 1UL);
  }
#line 1865
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */
  case_268: /* CIL Label */
  {
#line 1868
  tmp___0 = nsubtoks(tindex - 1UL);
#line 1868
  ntoks1 = (size_t )tmp___0;
#line 1869
  tmp___1 = nsubtoks((tindex - 1UL) - ntoks1);
  }
#line 1869
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1874 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void copytoks(size_t tindex , size_t ntokens )
{
  size_t i ;

  {
#line 1879
  if (dfa___0->multibyte) {
#line 1880
    i = (size_t )0;
    {
#line 1880
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1880
      if (! (i < ntokens)) {
#line 1880
        goto while_break;
      }
      {
#line 1881
      addtok_mb(*(dfa___0->tokens + (tindex + i)), *(dfa___0->multibyte_prop + (tindex + i)));
#line 1880
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1883
    i = (size_t )0;
    {
#line 1883
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1883
      if (! (i < ntokens)) {
#line 1883
        goto while_break___0;
      }
      {
#line 1884
      addtok_mb(*(dfa___0->tokens + (tindex + i)), 3);
#line 1883
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1885
  return;
}
}
#line 1887 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void closure(void)
{
  int i ;
  size_t tindex ;
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1893
  atom();
  }
  {
#line 1894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1894
    if (! (tok == 264L)) {
#line 1894
      if (! (tok == 265L)) {
#line 1894
        if (! (tok == 266L)) {
#line 1894
          if (! (tok == 267L)) {
#line 1894
            goto while_break;
          }
        }
      }
    }
#line 1895
    if (tok == 267L) {
#line 1895
      if (minrep) {
#line 1895
        goto _L___0;
      } else
#line 1895
      if (maxrep) {
        _L___0: /* CIL Label */
        {
#line 1897
        tmp = nsubtoks(dfa___0->tindex);
#line 1897
        ntokens = (size_t )tmp;
#line 1898
        tindex = dfa___0->tindex - ntokens;
        }
#line 1899
        if (maxrep < 0) {
          {
#line 1900
          addtok((token )266);
          }
        }
#line 1901
        if (minrep == 0) {
          {
#line 1902
          addtok((token )264);
          }
        }
#line 1903
        i = 1;
        {
#line 1903
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1903
          if (! (i < minrep)) {
#line 1903
            goto while_break___0;
          }
          {
#line 1905
          copytoks(tindex, ntokens);
#line 1906
          addtok((token )268);
#line 1903
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1908
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1908
          if (! (i < maxrep)) {
#line 1908
            goto while_break___1;
          }
          {
#line 1910
          copytoks(tindex, ntokens);
#line 1911
          addtok((token )264);
#line 1912
          addtok((token )268);
#line 1908
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1914
        tok = lex();
        }
      } else {
#line 1895
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 1916
    if (tok == 267L) {
      {
#line 1918
      tmp___0 = nsubtoks(dfa___0->tindex);
#line 1918
      dfa___0->tindex -= (size_t )tmp___0;
#line 1919
      tok = lex();
#line 1920
      closure();
      }
    } else {
      {
#line 1924
      addtok(tok);
#line 1925
      tok = lex();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1927
  return;
}
}
#line 1929 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void branch(void)
{


  {
  {
#line 1932
  closure();
  }
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    if (tok != 271L) {
#line 1933
      if (tok != 269L) {
#line 1933
        if (! (tok >= 0L)) {
#line 1933
          goto while_break;
        }
      } else {
#line 1933
        goto while_break;
      }
    } else {
#line 1933
      goto while_break;
    }
    {
#line 1935
    closure();
#line 1936
    addtok((token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1938
  return;
}
}
#line 1940 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void regexp(void)
{


  {
  {
#line 1943
  branch();
  }
  {
#line 1944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1944
    if (! (tok == 269L)) {
#line 1944
      goto while_break;
    }
    {
#line 1946
    tok = lex();
#line 1947
    branch();
#line 1948
    addtok((token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1950
  return;
}
}
#line 1955 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfaparse(char const   *s , size_t len , struct dfa *d )
{
  char *tmp ;
  char *tmp___0 ;

  {
#line 1958
  dfa___0 = d;
#line 1959
  lexptr = s;
#line 1960
  lexleft = len;
#line 1961
  lasttok = (token )-1;
#line 1962
  laststart = (_Bool)1;
#line 1963
  parens = (size_t )0;
#line 1964
  if (dfa___0->multibyte) {
    {
#line 1966
    cur_mb_len = 0;
#line 1967
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 1970
  if (! syntax_bits_set) {
    {
#line 1971
    tmp = gettext("no syntax specified");
#line 1971
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1973
  tok = lex();
#line 1974
  depth = d->depth;
#line 1976
  regexp();
  }
#line 1978
  if (tok != -1L) {
    {
#line 1979
    tmp___0 = gettext("unbalanced )");
#line 1979
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1981
  addtok((token )(0xffffffffffffffffUL - d->nregexps));
#line 1982
  addtok((token )268);
  }
#line 1984
  if (d->nregexps) {
    {
#line 1985
    addtok((token )269);
    }
  }
#line 1987
  (d->nregexps) ++;
#line 1988
  return;
}
}
#line 1993 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void copy(position_set const   *src , position_set *dst )
{
  void *tmp ;

  {
#line 1996
  if (dst->alloc < (size_t )src->nelem) {
    {
#line 1998
    free((void *)dst->elems);
#line 1999
    dst->alloc = (size_t )src->nelem;
#line 2000
    tmp = x2nrealloc((void *)0, & dst->alloc, sizeof(*(dst->elems)));
#line 2000
    dst->elems = (position *)tmp;
    }
  }
  {
#line 2002
  memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
         (size_t )(src->nelem * (size_t const   )sizeof(*(dst->elems))));
#line 2003
  dst->nelem = (size_t )src->nelem;
  }
#line 2004
  return;
}
}
#line 2006 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void alloc_position_set(position_set *s , size_t size )
{
  void *tmp ;

  {
  {
#line 2009
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2009
  s->elems = (position *)tmp;
#line 2010
  s->alloc = size;
#line 2011
  s->nelem = (size_t )0;
  }
#line 2012
  return;
}
}
#line 2018 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void insert(position p , position_set *s )
{
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t i ;
  size_t mid ;
  void *tmp ;

  {
#line 2021
  count = s->nelem;
#line 2022
  lo = (size_t )0;
#line 2022
  hi = count;
  {
#line 2024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2024
    if (! (lo < hi)) {
#line 2024
      goto while_break;
    }
#line 2026
    mid = (lo + hi) >> 1;
#line 2027
    if ((s->elems + mid)->index > p.index) {
#line 2028
      lo = mid + 1UL;
    } else {
#line 2030
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2033
  if (lo < count) {
#line 2033
    if (p.index == (s->elems + lo)->index) {
#line 2035
      (s->elems + lo)->constraint |= p.constraint;
#line 2036
      return;
    }
  }
  {
#line 2039
  tmp = maybe_realloc((void *)s->elems, count, & s->alloc, sizeof(*(s->elems)));
#line 2039
  s->elems = (position *)tmp;
#line 2040
  i = count;
  }
  {
#line 2040
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2040
    if (! (i > lo)) {
#line 2040
      goto while_break___0;
    }
#line 2041
    *(s->elems + i) = *(s->elems + (i - 1UL));
#line 2040
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2042
  *(s->elems + lo) = p;
#line 2043
  (s->nelem) ++;
#line 2044
  return;
}
}
#line 2048 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m )
{
  size_t i ;
  size_t j ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 2051
  i = (size_t )0;
#line 2051
  j = (size_t )0;
#line 2053
  if (m->alloc < (size_t )(s1->nelem + s2->nelem)) {
    {
#line 2055
    free((void *)m->elems);
#line 2056
    tmp = maybe_realloc((void *)0, (size_t )(s1->nelem + s2->nelem), & m->alloc, sizeof(*(m->elems)));
#line 2056
    m->elems = (position *)tmp;
    }
  }
#line 2059
  m->nelem = (size_t )0;
  {
#line 2060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2060
    if (i < (size_t )s1->nelem) {
#line 2060
      if (! (j < (size_t )s2->nelem)) {
#line 2060
        goto while_break;
      }
    } else {
#line 2060
      goto while_break;
    }
#line 2061
    if ((s1->elems + i)->index > (s2->elems + j)->index) {
#line 2062
      tmp___0 = m->nelem;
#line 2062
      (m->nelem) ++;
#line 2062
      tmp___1 = i;
#line 2062
      i ++;
#line 2062
      *(m->elems + tmp___0) = *(s1->elems + tmp___1);
    } else
#line 2063
    if ((s1->elems + i)->index < (s2->elems + j)->index) {
#line 2064
      tmp___2 = m->nelem;
#line 2064
      (m->nelem) ++;
#line 2064
      tmp___3 = j;
#line 2064
      j ++;
#line 2064
      *(m->elems + tmp___2) = *(s2->elems + tmp___3);
    } else {
#line 2067
      tmp___4 = i;
#line 2067
      i ++;
#line 2067
      *(m->elems + m->nelem) = *(s1->elems + tmp___4);
#line 2068
      tmp___5 = m->nelem;
#line 2068
      (m->nelem) ++;
#line 2068
      tmp___6 = j;
#line 2068
      j ++;
#line 2068
      (m->elems + tmp___5)->constraint |= (s2->elems + tmp___6)->constraint;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2070
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2070
    if (! (i < (size_t )s1->nelem)) {
#line 2070
      goto while_break___0;
    }
#line 2071
    tmp___7 = m->nelem;
#line 2071
    (m->nelem) ++;
#line 2071
    tmp___8 = i;
#line 2071
    i ++;
#line 2071
    *(m->elems + tmp___7) = *(s1->elems + tmp___8);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2072
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2072
    if (! (j < (size_t )s2->nelem)) {
#line 2072
      goto while_break___1;
    }
#line 2073
    tmp___9 = m->nelem;
#line 2073
    (m->nelem) ++;
#line 2073
    tmp___10 = j;
#line 2073
    j ++;
#line 2073
    *(m->elems + tmp___9) = *(s2->elems + tmp___10);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2074
  return;
}
}
#line 2077 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void delete(position p , position_set *s )
{
  size_t i ;

  {
#line 2082
  i = (size_t )0;
  {
#line 2082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2082
    if (! (i < s->nelem)) {
#line 2082
      goto while_break;
    }
#line 2083
    if (p.index == (s->elems + i)->index) {
#line 2084
      goto while_break;
    }
#line 2082
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  if (i < s->nelem) {
#line 2086
    (s->nelem) --;
    {
#line 2086
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2086
      if (! (i < s->nelem)) {
#line 2086
        goto while_break___0;
      }
#line 2087
      *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2086
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2088
  return;
}
}
#line 2093 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context )
{
  size_t hash ;
  int constraint ;
  state_num i ;
  state_num j ;
  void *tmp ;

  {
#line 2096
  hash = (size_t )0;
#line 2100
  i = (state_num )0;
  {
#line 2100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2100
    if (! ((size_t const   )i < s->nelem)) {
#line 2100
      goto while_break;
    }
#line 2101
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2104
  i = (state_num )0;
  {
#line 2104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2104
    if (! (i < d->sindex)) {
#line 2104
      goto while_break___0;
    }
#line 2106
    if (hash != (d->states + i)->hash) {
#line 2108
      goto __Cont;
    } else
#line 2106
    if (s->nelem != (size_t const   )(d->states + i)->elems.nelem) {
#line 2108
      goto __Cont;
    } else
#line 2106
    if (context != (int )(d->states + i)->context) {
#line 2108
      goto __Cont;
    }
#line 2109
    j = (state_num )0;
    {
#line 2109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2109
      if (! ((size_t const   )j < s->nelem)) {
#line 2109
        goto while_break___1;
      }
#line 2110
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2113
        goto while_break___1;
      } else
#line 2110
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2113
        goto while_break___1;
      }
#line 2109
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2114
    if ((size_t const   )j == s->nelem) {
#line 2115
      return (i);
    }
    __Cont: /* CIL Label */
#line 2104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2119
  tmp = maybe_realloc((void *)d->states, (size_t )d->sindex, & d->salloc, sizeof(*(d->states)));
#line 2119
  d->states = (dfa_state *)tmp;
#line 2121
  (d->states + i)->hash = hash;
#line 2122
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2123
  copy(s, & (d->states + i)->elems);
#line 2124
  (d->states + i)->context = (unsigned char )context;
#line 2125
  (d->states + i)->has_backref = (_Bool)0;
#line 2126
  (d->states + i)->has_mbcset = (_Bool)0;
#line 2127
  (d->states + i)->constraint = (unsigned short)0;
#line 2128
  (d->states + i)->first_end = (token )0;
#line 2129
  (d->states + i)->mbps.nelem = (size_t )0;
#line 2130
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2132
  j = (state_num )0;
  }
  {
#line 2132
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2132
    if (! ((size_t const   )j < s->nelem)) {
#line 2132
      goto while_break___2;
    }
#line 2133
    if (*(d->tokens + (s->elems + j)->index) < 0L) {
#line 2135
      constraint = (int )(s->elems + j)->constraint;
#line 2136
      if ((((constraint & 15) | ((constraint >> 4) & 15)) | ((constraint >> 8) & 15)) & context) {
#line 2137
        (d->states + i)->constraint = (unsigned short )((int )(d->states + i)->constraint | constraint);
      }
#line 2138
      if (! (d->states + i)->first_end) {
#line 2139
        (d->states + i)->first_end = *(d->tokens + (s->elems + j)->index);
      }
    } else
#line 2141
    if (*(d->tokens + (s->elems + j)->index) == 257L) {
#line 2143
      (d->states + i)->constraint = (unsigned short)1911;
#line 2144
      (d->states + i)->has_backref = (_Bool)1;
    }
#line 2132
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2147
  (d->sindex) ++;
#line 2149
  return (i);
}
}
#line 2157 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void epsclosure(position_set *s , struct dfa  const  *d , char *visited )
{
  size_t i ;
  size_t j ;
  position p ;
  position old ;
  _Bool initialized ;

  {
#line 2162
  initialized = (_Bool)0;
#line 2164
  i = (size_t )0;
  {
#line 2164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2164
    if (! (i < s->nelem)) {
#line 2164
      goto while_break;
    }
#line 2165
    if (*(d->tokens + (s->elems + i)->index) >= 256L) {
#line 2165
      if (*(d->tokens + (s->elems + i)->index) != 257L) {
#line 2165
        if (*(d->tokens + (s->elems + i)->index) != 272L) {
#line 2165
          if (*(d->tokens + (s->elems + i)->index) != 273L) {
#line 2165
            if (*(d->tokens + (s->elems + i)->index) < 275L) {
#line 2171
              if (! initialized) {
                {
#line 2173
                memset((void *)visited, 0, (size_t )(d->tindex * (size_t const   )sizeof(*visited)));
#line 2174
                initialized = (_Bool)1;
                }
              }
              {
#line 2176
              old = *(s->elems + i);
#line 2177
              p.constraint = old.constraint;
#line 2178
              delete(*(s->elems + i), s);
              }
#line 2179
              if (*(visited + old.index)) {
#line 2181
                i --;
#line 2182
                goto __Cont;
              }
#line 2184
              *(visited + old.index) = (char)1;
              {
#line 2187
              if (*(d->tokens + old.index) == 258L) {
#line 2187
                goto case_258;
              }
#line 2190
              if (*(d->tokens + old.index) == 259L) {
#line 2190
                goto case_259;
              }
#line 2193
              if (*(d->tokens + old.index) == 260L) {
#line 2193
                goto case_260;
              }
#line 2196
              if (*(d->tokens + old.index) == 261L) {
#line 2196
                goto case_261;
              }
#line 2199
              if (*(d->tokens + old.index) == 262L) {
#line 2199
                goto case_262;
              }
#line 2202
              if (*(d->tokens + old.index) == 263L) {
#line 2202
                goto case_263;
              }
#line 2205
              goto switch_default;
              case_258: /* CIL Label */
#line 2188
              p.constraint &= 1092U;
#line 2189
              goto switch_break;
              case_259: /* CIL Label */
#line 2191
              p.constraint &= 1792U;
#line 2192
              goto switch_break;
              case_260: /* CIL Label */
#line 2194
              p.constraint &= 80U;
#line 2195
              goto switch_break;
              case_261: /* CIL Label */
#line 2197
              p.constraint &= 514U;
#line 2198
              goto switch_break;
              case_262: /* CIL Label */
#line 2200
              p.constraint &= 594U;
#line 2201
              goto switch_break;
              case_263: /* CIL Label */
#line 2203
              p.constraint &= 1317U;
#line 2204
              goto switch_break;
              switch_default: /* CIL Label */
#line 2206
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 2208
              j = (size_t )0;
              {
#line 2208
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 2208
                if (! (j < (d->follows + old.index)->nelem)) {
#line 2208
                  goto while_break___0;
                }
                {
#line 2210
                p.index = ((d->follows + old.index)->elems + j)->index;
#line 2211
                insert(p, s);
#line 2208
                j ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 2214
              i = (size_t )-1;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */
#line 2164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2216
  return;
}
}
#line 2221 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int charclass_context(charclass_word *c )
{
  int context ;
  unsigned int j ;
  _Bool tmp ;

  {
  {
#line 2224
  context = 0;
#line 2227
  tmp = tstbit((unsigned int )eolbyte___0, (charclass_word */* const  */)c);
  }
#line 2227
  if (tmp) {
#line 2228
    context |= 4;
  }
#line 2230
  j = 0U;
  {
#line 2230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2230
    if (! (j < 8U)) {
#line 2230
      goto while_break;
    }
#line 2232
    if (*(c + j) & letters[j]) {
#line 2233
      context |= 2;
    }
#line 2234
    if (*(c + j) & ~ (letters[j] | newline[j])) {
#line 2235
      context |= 1;
    }
#line 2230
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2238
  return (context);
}
}
#line 2247 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s )
{
  int separate_contexts ;
  size_t j ;

  {
#line 2250
  separate_contexts = 0;
#line 2253
  j = (size_t )0;
  {
#line 2253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2253
    if (! (j < (size_t )s->nelem)) {
#line 2253
      goto while_break;
    }
#line 2255
    if ((((s->elems + j)->constraint >> 2) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2256
      separate_contexts |= 4;
    }
#line 2257
    if ((((s->elems + j)->constraint >> 1) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2258
      separate_contexts |= 2;
    }
#line 2253
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2261
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2317 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfaanalyze(struct dfa *d , int searchflag )
{
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398 *stk ;
  position_set tmp___1 ;
  position_set merged ;
  int separate_contexts ;
  size_t i ;
  size_t j ;
  position *pos ;
  char *visited ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2321
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2321
  posalloc = (position *)tmp;
#line 2323
  firstpos = posalloc + d->nleaves;
#line 2324
  lastpos = firstpos + d->nleaves;
#line 2327
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2327
  stkalloc = (struct __anonstruct_stkalloc_360611398 *)tmp___0;
#line 2327
  stk = stkalloc;
#line 2342
  tmp___2 = xnmalloc(d->tindex, sizeof(*visited));
#line 2342
  visited = (char *)tmp___2;
#line 2354
  d->searchflag = (_Bool )(searchflag != 0);
#line 2355
  alloc_position_set(& merged, d->nleaves);
#line 2356
  tmp___3 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2356
  d->follows = (position_set *)tmp___3;
#line 2358
  i = (size_t )0;
  }
  {
#line 2358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2358
    if (! (i < d->tindex)) {
#line 2358
      goto while_break;
    }
    {
#line 2362
    if (*(d->tokens + i) == 256L) {
#line 2362
      goto case_256;
    }
#line 2372
    if (*(d->tokens + i) == 266L) {
#line 2372
      goto case_266;
    }
#line 2372
    if (*(d->tokens + i) == 265L) {
#line 2372
      goto case_266;
    }
#line 2385
    if (*(d->tokens + i) == 264L) {
#line 2385
      goto case_264;
    }
#line 2391
    if (*(d->tokens + i) == 268L) {
#line 2391
      goto case_268;
    }
#line 2428
    if (*(d->tokens + i) == 269L) {
#line 2428
      goto case_269;
    }
#line 2440
    goto switch_default;
    case_256: /* CIL Label */
#line 2364
    stk->nullable = (_Bool)1;
#line 2367
    tmp___4 = (size_t )0;
#line 2367
    stk->nlastpos = tmp___4;
#line 2367
    stk->nfirstpos = tmp___4;
#line 2368
    stk ++;
#line 2369
    goto switch_break;
    case_266: /* CIL Label */
    case_265: /* CIL Label */
#line 2375
    tmp___1.nelem = (stk + -1)->nfirstpos;
#line 2376
    tmp___1.elems = firstpos;
#line 2377
    pos = lastpos;
#line 2378
    j = (size_t )0;
    {
#line 2378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2378
      if (! (j < (stk + -1)->nlastpos)) {
#line 2378
        goto while_break___0;
      }
      {
#line 2380
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2381
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2378
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */
#line 2387
    if (*(d->tokens + i) != 266L) {
#line 2388
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2389
    goto switch_break;
    case_268: /* CIL Label */
#line 2394
    tmp___1.nelem = (stk + -1)->nfirstpos;
#line 2395
    tmp___1.elems = firstpos;
#line 2396
    pos = lastpos + (stk + -1)->nlastpos;
#line 2397
    j = (size_t )0;
    {
#line 2397
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2397
      if (! (j < (stk + -2)->nlastpos)) {
#line 2397
        goto while_break___1;
      }
      {
#line 2399
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2400
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2397
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2405
    if ((stk + -2)->nullable) {
#line 2406
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2408
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2412
    if ((stk + -1)->nullable) {
#line 2413
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2416
      pos = lastpos + (stk + -2)->nlastpos;
#line 2417
      j = (stk + -1)->nlastpos;
      {
#line 2417
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2417
        tmp___5 = j;
#line 2417
        j --;
#line 2417
        if (! (tmp___5 > 0UL)) {
#line 2417
          goto while_break___2;
        }
#line 2418
        *(pos + j) = *(lastpos + j);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2419
      lastpos += (stk + -2)->nlastpos;
#line 2420
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2424
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2425
    stk --;
#line 2426
    goto switch_break;
    case_269: /* CIL Label */
#line 2430
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2433
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2436
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2437
    stk --;
#line 2438
    goto switch_break;
    switch_default: /* CIL Label */
    {
#line 2446
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2449
    tmp___6 = (size_t )1;
#line 2449
    stk->nlastpos = tmp___6;
#line 2449
    stk->nfirstpos = tmp___6;
#line 2450
    stk ++;
#line 2452
    firstpos --;
#line 2452
    lastpos --;
#line 2453
    tmp___7 = i;
#line 2453
    lastpos->index = tmp___7;
#line 2453
    firstpos->index = tmp___7;
#line 2454
    tmp___8 = 1911U;
#line 2454
    lastpos->constraint = tmp___8;
#line 2454
    firstpos->constraint = tmp___8;
#line 2457
    alloc_position_set(d->follows + i, (size_t )1);
    }
#line 2458
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2485
  i = (size_t )0;
  {
#line 2485
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2485
    if (! (i < d->tindex)) {
#line 2485
      goto while_break___3;
    }
#line 2486
    if (*(d->tokens + i) < 256L) {
      {
#line 2501
      copy((position_set const   *)(d->follows + i), & merged);
#line 2502
      epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2503
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2486
    if (*(d->tokens + i) == 257L) {
      {
#line 2501
      copy((position_set const   *)(d->follows + i), & merged);
#line 2502
      epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2503
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2486
    if (*(d->tokens + i) == 272L) {
      {
#line 2501
      copy((position_set const   *)(d->follows + i), & merged);
#line 2502
      epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2503
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2486
    if (*(d->tokens + i) == 273L) {
      {
#line 2501
      copy((position_set const   *)(d->follows + i), & merged);
#line 2502
      epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2503
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2486
    if (*(d->tokens + i) >= 275L) {
      {
#line 2501
      copy((position_set const   *)(d->follows + i), & merged);
#line 2502
      epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2503
      copy((position_set const   *)(& merged), d->follows + i);
      }
    }
#line 2485
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2508
  merged.nelem = (size_t )0;
#line 2509
  i = (size_t )0;
  {
#line 2509
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2509
    if (! (i < (stk + -1)->nfirstpos)) {
#line 2509
      goto while_break___4;
    }
    {
#line 2510
    insert(*(firstpos + i), & merged);
#line 2509
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2511
  epsclosure(& merged, (struct dfa  const  *)d, visited);
#line 2514
  tmp___9 = state_separate_contexts((position_set const   *)(& merged));
#line 2514
  separate_contexts = (int )tmp___9;
  }
#line 2515
  if (separate_contexts & 4) {
#line 2515
    tmp___10 = 4;
  } else {
#line 2515
    tmp___10 = separate_contexts ^ 7;
  }
  {
#line 2515
  state_index(d, (position_set const   *)(& merged), tmp___10);
#line 2519
  free((void *)posalloc);
#line 2520
  free((void *)stkalloc);
#line 2521
  free((void *)merged.elems);
#line 2522
  free((void *)visited);
  }
#line 2523
  return;
}
}
#line 2556 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfastate(ptrdiff_t s , struct dfa *d , ptrdiff_t *trans___0 )
{
  leaf_set grps[256] ;
  charclass labels[256] ;
  size_t ngrps ;
  position pos ;
  charclass matches ;
  charclass_word matchesf ;
  charclass intersect ;
  charclass_word intersectf ;
  charclass leftovers ;
  charclass_word leftoversf ;
  position_set follows ;
  position_set tmp ;
  int possible_contexts ;
  int separate_contexts ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  _Bool next_isnt_1st_byte ;
  size_t i ;
  size_t j ;
  size_t k ;
  _Bool tmp___0 ;
  charclass_word tmp___1 ;
  charclass_word match ;
  charclass_word label___0 ;
  charclass_word tmp___2 ;
  charclass_word tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int __attribute__((__pure__))  tmp___7 ;
  unsigned short const   **tmp___9 ;
  int __attribute__((__pure__))  tmp___10 ;
  int c ;
  unsigned short const   **tmp___11 ;

  {
  {
#line 2561
  ngrps = (size_t )0;
#line 2576
  next_isnt_1st_byte = (_Bool)0;
#line 2579
  zeroset((charclass_word *)(matches));
#line 2581
  i = (size_t )0;
  }
  {
#line 2581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2581
    if (! (i < (d->states + s)->elems.nelem)) {
#line 2581
      goto while_break;
    }
#line 2583
    pos = *((d->states + s)->elems.elems + i);
#line 2584
    if (*(d->tokens + pos.index) >= 0L) {
#line 2584
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2585
        setbit((unsigned int )*(d->tokens + pos.index), (charclass_word *)(matches));
        }
      } else {
#line 2584
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
#line 2586
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2587
      copyset((charclass_word */* const  */)(*(d->charclasses + (*(d->tokens + pos.index) - 275L))),
              (charclass_word *)(matches));
      }
    } else {
#line 2590
      if (*(d->tokens + pos.index) == 273L) {
#line 2590
        goto _L;
      } else
#line 2590
      if (*(d->tokens + pos.index) == 272L) {
        _L: /* CIL Label */
#line 2594
        if (*(d->tokens + pos.index) == 273L) {
#line 2595
          (d->states + s)->has_mbcset = (_Bool)1;
        }
#line 2599
        if ((d->states + s)->mbps.nelem == 0UL) {
          {
#line 2600
          alloc_position_set(& (d->states + s)->mbps, (size_t )1);
          }
        }
        {
#line 2601
        insert(pos, & (d->states + s)->mbps);
        }
      }
#line 2603
      goto __Cont;
    }
#line 2608
    if (pos.constraint != 1911U) {
#line 2610
      if (! (((pos.constraint >> 8) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2612
        j = (size_t )0;
        {
#line 2612
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2612
          if (! (j < 8UL)) {
#line 2612
            goto while_break___0;
          }
#line 2613
          matches[j] &= ~ newline[j];
#line 2612
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2614
      if (! (((pos.constraint >> 4) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2616
        j = (size_t )0;
        {
#line 2616
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2616
          if (! (j < 8UL)) {
#line 2616
            goto while_break___1;
          }
#line 2617
          matches[j] &= ~ letters[j];
#line 2616
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2618
      if (! ((pos.constraint & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2620
        j = (size_t )0;
        {
#line 2620
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2620
          if (! (j < 8UL)) {
#line 2620
            goto while_break___2;
          }
#line 2621
          matches[j] &= letters[j] | newline[j];
#line 2620
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2624
      j = (size_t )0;
      {
#line 2624
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2624
        if (j < 8UL) {
#line 2624
          if (! (! matches[j])) {
#line 2624
            goto while_break___3;
          }
        } else {
#line 2624
          goto while_break___3;
        }
#line 2625
        goto __Cont___0;
        __Cont___0: /* CIL Label */
#line 2624
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2626
      if (j == 8UL) {
#line 2627
        goto __Cont;
      }
    }
#line 2630
    j = (size_t )0;
    {
#line 2630
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2630
      if (! (j < ngrps)) {
#line 2630
        goto while_break___4;
      }
#line 2635
      if (*(d->tokens + pos.index) >= 0L) {
#line 2635
        if (*(d->tokens + pos.index) < 256L) {
          {
#line 2635
          tmp___0 = tstbit((unsigned int )*(d->tokens + pos.index), (charclass_word */* const  */)(labels[j]));
          }
#line 2635
          if (! tmp___0) {
#line 2637
            goto __Cont___1;
          }
        }
      }
#line 2641
      intersectf = (charclass_word )0;
#line 2642
      k = (size_t )0;
      {
#line 2642
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2642
        if (! (k < 8UL)) {
#line 2642
          goto while_break___5;
        }
#line 2643
        tmp___1 = matches[k] & labels[j][k];
#line 2643
        intersect[k] = tmp___1;
#line 2643
        intersectf |= tmp___1;
#line 2642
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2644
      if (! intersectf) {
#line 2645
        goto __Cont___1;
      }
#line 2648
      matchesf = (charclass_word )0;
#line 2648
      leftoversf = matchesf;
#line 2649
      k = (size_t )0;
      {
#line 2649
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2649
        if (! (k < 8UL)) {
#line 2649
          goto while_break___6;
        }
#line 2652
        match = matches[k];
#line 2652
        label___0 = labels[j][k];
#line 2654
        tmp___2 = ~ match & label___0;
#line 2654
        leftovers[k] = tmp___2;
#line 2654
        leftoversf |= tmp___2;
#line 2655
        tmp___3 = match & ~ label___0;
#line 2655
        matches[k] = tmp___3;
#line 2655
        matchesf |= tmp___3;
#line 2649
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2659
      if (leftoversf) {
        {
#line 2661
        copyset((charclass_word */* const  */)(leftovers), (charclass_word *)(labels[ngrps]));
#line 2662
        copyset((charclass_word */* const  */)(intersect), (charclass_word *)(labels[j]));
#line 2663
        tmp___4 = xnmalloc(d->nleaves, sizeof(*(grps[ngrps].elems)));
#line 2663
        grps[ngrps].elems = (size_t *)tmp___4;
#line 2665
        memcpy((void */* __restrict  */)grps[ngrps].elems, (void const   */* __restrict  */)grps[j].elems,
               sizeof(*(grps[j].elems + 0)) * grps[j].nelem);
#line 2667
        grps[ngrps].nelem = grps[j].nelem;
#line 2668
        ngrps ++;
        }
      }
#line 2673
      tmp___5 = grps[j].nelem;
#line 2673
      (grps[j].nelem) ++;
#line 2673
      *(grps[j].elems + tmp___5) = pos.index;
#line 2677
      if (! matchesf) {
#line 2678
        goto while_break___4;
      }
      __Cont___1: /* CIL Label */
#line 2630
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2683
    if (j == ngrps) {
      {
#line 2685
      copyset((charclass_word */* const  */)(matches), (charclass_word *)(labels[ngrps]));
#line 2686
      zeroset((charclass_word *)(matches));
#line 2687
      tmp___6 = xnmalloc(d->nleaves, sizeof(*(grps[ngrps].elems)));
#line 2687
      grps[ngrps].elems = (size_t *)tmp___6;
#line 2688
      grps[ngrps].nelem = (size_t )1;
#line 2689
      *(grps[ngrps].elems + 0) = pos.index;
#line 2690
      ngrps ++;
      }
    }
    __Cont: /* CIL Label */
#line 2581
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2694
  alloc_position_set(& follows, d->nleaves);
#line 2695
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2700
  if (d->searchflag) {
    {
#line 2703
    copy((position_set const   *)(& (d->states + 0)->elems), & follows);
#line 2704
    tmp___7 = state_separate_contexts((position_set const   *)(& follows));
#line 2704
    separate_contexts = (int )tmp___7;
#line 2705
    state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
    }
#line 2706
    if (separate_contexts & 4) {
      {
#line 2707
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2709
      state_newline = state;
    }
#line 2710
    if (separate_contexts & 2) {
      {
#line 2711
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2713
      state_letter = state;
    }
#line 2715
    i = (size_t )0;
    {
#line 2715
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2715
      if (! (i < 256UL)) {
#line 2715
        goto while_break___7;
      }
      {
#line 2716
      tmp___9 = __ctype_b_loc();
      }
#line 2716
      if ((int const   )*(*tmp___9 + (int )i) & 8) {
#line 2716
        *(trans___0 + i) = state_letter;
      } else
#line 2716
      if (i == 95UL) {
#line 2716
        *(trans___0 + i) = state_letter;
      } else {
#line 2716
        *(trans___0 + i) = state;
      }
#line 2715
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2717
    *(trans___0 + eolbyte___0) = state_newline;
  } else {
#line 2720
    i = (size_t )0;
    {
#line 2720
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2720
      if (! (i < 256UL)) {
#line 2720
        goto while_break___8;
      }
#line 2721
      *(trans___0 + i) = (ptrdiff_t )-1;
#line 2720
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 2723
  i = (size_t )0;
  {
#line 2723
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2723
    if (! (i < ngrps)) {
#line 2723
      goto while_break___9;
    }
#line 2725
    follows.nelem = (size_t )0;
#line 2729
    j = (size_t )0;
    {
#line 2729
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2729
      if (! (j < grps[i].nelem)) {
#line 2729
        goto while_break___10;
      }
#line 2730
      k = (size_t )0;
      {
#line 2730
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2730
        if (! (k < (d->follows + *(grps[i].elems + j))->nelem)) {
#line 2730
          goto while_break___11;
        }
        {
#line 2731
        insert(*((d->follows + *(grps[i].elems + j))->elems + k), & follows);
#line 2730
        k ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 2729
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2733
    if (d->multibyte) {
#line 2753
      next_isnt_1st_byte = (_Bool)0;
#line 2754
      j = (size_t )0;
      {
#line 2754
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 2754
        if (! (j < follows.nelem)) {
#line 2754
          goto while_break___12;
        }
#line 2756
        if (! (*(d->multibyte_prop + (follows.elems + j)->index) & 1)) {
#line 2758
          next_isnt_1st_byte = (_Bool)1;
#line 2759
          goto while_break___12;
        }
#line 2754
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 2766
    if (d->searchflag) {
#line 2766
      if (! d->multibyte) {
        {
#line 2768
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2769
        copy((position_set const   *)(& tmp), & follows);
        }
      } else
#line 2766
      if (! next_isnt_1st_byte) {
        {
#line 2768
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2769
        copy((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2773
    possible_contexts = charclass_context((charclass_word *)(labels[i]));
#line 2774
    tmp___10 = state_separate_contexts((position_set const   *)(& follows));
#line 2774
    separate_contexts = (int )tmp___10;
    }
#line 2777
    if ((separate_contexts & possible_contexts) != possible_contexts) {
      {
#line 2778
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2780
      state = (state_num )-1;
    }
#line 2781
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2782
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2784
      state_newline = state;
    }
#line 2785
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2786
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2788
      state_letter = state;
    }
#line 2791
    j = (size_t )0;
    {
#line 2791
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2791
      if (! (j < 8UL)) {
#line 2791
        goto while_break___13;
      }
#line 2792
      k = (size_t )0;
      {
#line 2792
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2792
        if (! (k < 32UL)) {
#line 2792
          goto while_break___14;
        }
#line 2793
        if ((labels[i][j] >> k) & 1U) {
#line 2795
          c = (int )(j * 32UL + k);
#line 2797
          if (c == (int )eolbyte___0) {
#line 2798
            *(trans___0 + c) = state_newline;
          } else {
            {
#line 2799
            tmp___11 = __ctype_b_loc();
            }
#line 2799
            if ((int const   )*(*tmp___11 + c) & 8) {
#line 2800
              *(trans___0 + c) = state_letter;
            } else
#line 2799
            if (c == 95) {
#line 2800
              *(trans___0 + c) = state_letter;
            } else
#line 2801
            if (c < 256) {
#line 2802
              *(trans___0 + c) = state;
            }
          }
        }
#line 2792
        k ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 2791
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 2723
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2806
  i = (size_t )0;
  {
#line 2806
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2806
    if (! (i < ngrps)) {
#line 2806
      goto while_break___15;
    }
    {
#line 2807
    free((void *)grps[i].elems);
#line 2806
    i ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2808
  free((void *)follows.elems);
#line 2809
  free((void *)tmp.elems);
  }
#line 2810
  return;
}
}
#line 2813 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d , state_num new_state )
{
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  size_t newalloc ;
  size_t newalloc1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 2816
  oldalloc = d->tralloc;
#line 2817
  if (oldalloc <= new_state) {
#line 2819
    if (d->trans) {
#line 2819
      tmp = d->trans - 1;
    } else {
#line 2819
      tmp = (state_num **)((void *)0);
    }
    {
#line 2819
    realtrans = tmp;
#line 2821
    newalloc1 = (size_t )(new_state + 1L);
#line 2822
    tmp___0 = x2nrealloc((void *)realtrans, & newalloc1, sizeof(*realtrans));
#line 2822
    realtrans = (state_num **)tmp___0;
#line 2823
    *(realtrans + 0) = (state_num *)((void *)0);
#line 2824
    d->trans = realtrans + 1;
#line 2825
    newalloc = newalloc1 - 1UL;
#line 2825
    d->tralloc = (state_num )newalloc;
#line 2826
    tmp___1 = xnrealloc((void *)d->fails, newalloc, sizeof(*(d->fails)));
#line 2826
    d->fails = (state_num **)tmp___1;
#line 2827
    tmp___2 = xnrealloc((void *)d->success, newalloc, sizeof(*(d->success)));
#line 2827
    d->success = (int *)tmp___2;
#line 2828
    tmp___3 = xnrealloc((void *)d->newlines, newalloc, sizeof(*(d->newlines)));
#line 2828
    d->newlines = (state_num *)tmp___3;
    }
    {
#line 2829
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2829
      if (! ((size_t )oldalloc < newalloc)) {
#line 2829
        goto while_break;
      }
#line 2831
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2832
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2829
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2835
  return;
}
}
#line 2844 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void build_state(state_num s , struct dfa *d )
{
  state_num *trans___0 ;
  state_num i ;
  state_num maxstate ;
  state_num *tmp ;
  void *tmp___0 ;

  {
#line 2854
  if (d->trcount >= 1024) {
#line 2856
    i = (state_num )0;
    {
#line 2856
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2856
      if (! (i < d->tralloc)) {
#line 2856
        goto while_break;
      }
      {
#line 2858
      free((void *)*(d->trans + i));
#line 2859
      free((void *)*(d->fails + i));
#line 2860
      tmp = (state_num *)((void *)0);
#line 2860
      *(d->fails + i) = tmp;
#line 2860
      *(d->trans + i) = tmp;
#line 2856
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2862
    d->trcount = 0;
  }
#line 2865
  (d->trcount) ++;
#line 2868
  *(d->success + s) = 0;
#line 2869
  if ((((int )(d->states + s)->constraint >> 8) & 15) & (int )(d->states + s)->context) {
#line 2870
    *(d->success + s) |= 4;
  }
#line 2871
  if ((((int )(d->states + s)->constraint >> 4) & 15) & (int )(d->states + s)->context) {
#line 2872
    *(d->success + s) |= 2;
  }
#line 2873
  if (((int )(d->states + s)->constraint & 15) & (int )(d->states + s)->context) {
#line 2874
    *(d->success + s) |= 1;
  }
  {
#line 2876
  tmp___0 = xmalloc(256UL * sizeof(*trans___0));
#line 2876
  trans___0 = (state_num *)tmp___0;
#line 2877
  dfastate(s, d, trans___0);
#line 2882
  maxstate = (state_num )-1;
#line 2883
  i = (state_num )0;
  }
  {
#line 2883
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2883
    if (! (i < 256L)) {
#line 2883
      goto while_break___0;
    }
#line 2884
    if (maxstate < *(trans___0 + i)) {
#line 2885
      maxstate = *(trans___0 + i);
    }
#line 2883
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2886
  realloc_trans_if_necessary(d, maxstate);
#line 2890
  *(d->newlines + s) = *(trans___0 + eolbyte___0);
#line 2891
  *(trans___0 + eolbyte___0) = (state_num )-1;
  }
#line 2893
  if ((d->states + s)->constraint) {
#line 2894
    *(d->fails + s) = trans___0;
  } else {
#line 2896
    *(d->trans + s) = trans___0;
  }
#line 2897
  return;
}
}
#line 2899 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void build_state_zero(struct dfa *d )
{
  int initial_tab_size ;

  {
  {
#line 2903
  initial_tab_size = 1;
#line 2905
  d->tralloc = (state_num )0;
#line 2906
  d->trcount = 0;
#line 2907
  d->trans = (state_num **)((void *)0);
#line 2908
  d->fails = (state_num **)((void *)0);
#line 2909
  d->success = (int *)((void *)0);
#line 2910
  d->newlines = (state_num *)((void *)0);
#line 2911
  realloc_trans_if_necessary(d, (state_num )initial_tab_size);
#line 2912
  build_state((state_num )0, d);
  }
#line 2913
  return;
}
}
#line 2930 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static status_transit_state transit_state_singlebyte(struct dfa *d , state_num s ,
                                                     unsigned char const   *p , state_num *next_state )
{
  state_num *t ;
  state_num works ;
  status_transit_state rval ;

  {
#line 2935
  works = s;
#line 2937
  rval = (status_transit_state )0;
  {
#line 2939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2939
    if (! ((unsigned int )rval == 0U)) {
#line 2939
      goto while_break;
    }
#line 2941
    t = *(d->trans + works);
#line 2941
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2943
      works = *(t + *p);
#line 2944
      rval = (status_transit_state )1;
#line 2945
      if (works < 0L) {
#line 2946
        works = (state_num )0;
      }
    } else
#line 2948
    if (works < 0L) {
#line 2949
      works = (state_num )0;
    } else
#line 2950
    if (*(d->fails + works)) {
#line 2952
      works = *(*(d->fails + works) + *p);
#line 2953
      rval = (status_transit_state )1;
    } else {
      {
#line 2957
      build_state(works, d);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2960
  *next_state = works;
#line 2961
  return (rval);
}
}
#line 2966 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int match_anychar(struct dfa *d , state_num s , position pos , wint_t wc ,
                         size_t mbclen )
{
  int context ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2973
  if (wc == (wint_t )((wchar_t )eolbyte___0)) {
#line 2975
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2976
      return (0);
    }
  } else
#line 2978
  if (wc == 0U) {
#line 2980
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2981
      return (0);
    }
  } else
#line 2983
  if (wc == 4294967295U) {
#line 2984
    return (0);
  }
  {
#line 2986
  context = wchar_context(wc);
  }
#line 2987
  if (context & 1) {
#line 2987
    tmp = pos.constraint & 15U;
  } else {
#line 2987
    tmp = 0U;
  }
#line 2987
  if (context & 2) {
#line 2987
    tmp___0 = (pos.constraint >> 4) & 15U;
  } else {
#line 2987
    tmp___0 = 0U;
  }
#line 2987
  if (context & 4) {
#line 2987
    tmp___1 = (pos.constraint >> 8) & 15U;
  } else {
#line 2987
    tmp___1 = 0U;
  }
#line 2987
  if (! (((tmp | tmp___0) | tmp___1) & (unsigned int )(d->states + s)->context)) {
#line 2988
    return (0);
  }
#line 2990
  return ((int )mbclen);
}
}
#line 2996 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int match_mb_charset(struct dfa *d , state_num s , position pos , char const   *p ,
                            wint_t wc , size_t match_len )
{
  size_t i ;
  _Bool match ;
  int op_len ;
  char buffer___0[128] ;
  struct mb_char_classes *work_mbc ;
  int context ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
#line 3011
  if (wc == (wint_t )((wchar_t )eolbyte___0)) {
#line 3013
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3014
      return (0);
    }
  } else
#line 3016
  if (wc == 0U) {
#line 3018
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3019
      return (0);
    }
  } else
#line 3021
  if (wc == 4294967295U) {
#line 3022
    return (0);
  }
  {
#line 3024
  context = wchar_context(wc);
  }
#line 3025
  if (context & 1) {
#line 3025
    tmp = pos.constraint & 15U;
  } else {
#line 3025
    tmp = 0U;
  }
#line 3025
  if (context & 2) {
#line 3025
    tmp___0 = (pos.constraint >> 4) & 15U;
  } else {
#line 3025
    tmp___0 = 0U;
  }
#line 3025
  if (context & 4) {
#line 3025
    tmp___1 = (pos.constraint >> 8) & 15U;
  } else {
#line 3025
    tmp___1 = 0U;
  }
#line 3025
  if (! (((tmp | tmp___0) | tmp___1) & (unsigned int )(d->states + s)->context)) {
#line 3026
    return (0);
  }
#line 3029
  work_mbc = d->mbcsets + (*(d->multibyte_prop + pos.index) >> 2);
#line 3030
  match = (_Bool )(! work_mbc->invert);
#line 3033
  if (wc < 256U) {
#line 3033
    if (work_mbc->cset != -1L) {
      {
#line 3033
      tmp___2 = to_uchar___0((char )wc);
#line 3033
      tmp___3 = tstbit((unsigned int )tmp___2, (charclass_word */* const  */)(*(d->charclasses + work_mbc->cset)));
      }
#line 3033
      if (tmp___3) {
#line 3035
        goto charset_matched;
      }
    }
  }
#line 3038
  i = (size_t )0;
  {
#line 3038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3038
    if (! (i < work_mbc->nch_classes)) {
#line 3038
      goto while_break;
    }
    {
#line 3040
    tmp___4 = iswctype(wc, *(work_mbc->ch_classes + i));
    }
#line 3040
    if (tmp___4) {
#line 3041
      goto charset_matched;
    }
#line 3038
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3044
  strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)p,
          match_len);
#line 3045
  buffer___0[match_len] = (char )'\000';
#line 3048
  i = (size_t )0;
  }
  {
#line 3048
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3048
    if (! (i < work_mbc->nequivs)) {
#line 3048
      goto while_break___0;
    }
    {
#line 3050
    tmp___5 = strlen((char const   *)*(work_mbc->equivs + i));
#line 3050
    op_len = (int )tmp___5;
#line 3051
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)p,
            (size_t )op_len);
#line 3052
    buffer___0[op_len] = (char )'\000';
#line 3053
    tmp___6 = strcoll((char const   *)*(work_mbc->equivs + i), (char const   *)(buffer___0));
    }
#line 3053
    if (tmp___6 == 0) {
#line 3055
      match_len = (size_t )op_len;
#line 3056
      goto charset_matched;
    }
#line 3048
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3061
  i = (size_t )0;
  {
#line 3061
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3061
    if (! (i < work_mbc->ncoll_elems)) {
#line 3061
      goto while_break___1;
    }
    {
#line 3063
    tmp___7 = strlen((char const   *)*(work_mbc->coll_elems + i));
#line 3063
    op_len = (int )tmp___7;
#line 3064
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)p,
            (size_t )op_len);
#line 3065
    buffer___0[op_len] = (char )'\000';
#line 3067
    tmp___8 = strcoll((char const   *)*(work_mbc->coll_elems + i), (char const   *)(buffer___0));
    }
#line 3067
    if (tmp___8 == 0) {
#line 3069
      match_len = (size_t )op_len;
#line 3070
      goto charset_matched;
    }
#line 3061
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3075
  i = (size_t )0;
  {
#line 3075
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3075
    if (! (i < work_mbc->nranges)) {
#line 3075
      goto while_break___2;
    }
#line 3077
    if ((wint_t )(work_mbc->ranges + i)->beg <= wc) {
#line 3077
      if (wc <= (wint_t )(work_mbc->ranges + i)->end) {
#line 3078
        goto charset_matched;
      }
    }
#line 3075
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3082
  i = (size_t )0;
  {
#line 3082
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3082
    if (! (i < work_mbc->nchars)) {
#line 3082
      goto while_break___3;
    }
#line 3084
    if (wc == (wint_t )*(work_mbc->chars + i)) {
#line 3085
      goto charset_matched;
    }
#line 3082
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3088
  match = (_Bool )(! match);
  charset_matched:
#line 3091
  if (match) {
#line 3091
    tmp___9 = match_len;
  } else {
#line 3091
    tmp___9 = (size_t )0;
  }
#line 3091
  return ((int )tmp___9);
}
}
#line 3099 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static int *check_matching_with_multibyte_ops(struct dfa *d , state_num s , char const   *p ,
                                              wint_t wc , size_t mbclen )
{
  size_t i ;
  int *rarray ;
  position pos ;

  {
#line 3106
  rarray = d->mb_match_lens;
#line 3107
  i = (size_t )0;
  {
#line 3107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3107
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 3107
      goto while_break;
    }
#line 3109
    pos = *((d->states + s)->mbps.elems + i);
    {
#line 3112
    if (*(d->tokens + pos.index) == 272L) {
#line 3112
      goto case_272;
    }
#line 3115
    if (*(d->tokens + pos.index) == 273L) {
#line 3115
      goto case_273;
    }
#line 3118
    goto switch_default;
    case_272: /* CIL Label */
    {
#line 3113
    *(rarray + i) = match_anychar(d, s, pos, wc, mbclen);
    }
#line 3114
    goto switch_break;
    case_273: /* CIL Label */
    {
#line 3116
    *(rarray + i) = match_mb_charset(d, s, pos, p, wc, mbclen);
    }
#line 3117
    goto switch_break;
    switch_default: /* CIL Label */
#line 3119
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3122
  return (rarray);
}
}
#line 3133 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static status_transit_state transit_state_consume_1char(struct dfa *d , state_num s ,
                                                        unsigned char const   **pp ,
                                                        wint_t wc , size_t mbclen ,
                                                        int *match_lens )
{
  size_t i ;
  size_t j ;
  int k ;
  state_num s1 ;
  state_num s2 ;
  status_transit_state rs ;
  unsigned char const   *tmp ;

  {
#line 3142
  rs = (status_transit_state )1;
#line 3144
  if (! match_lens) {
#line 3144
    if ((d->states + s)->mbps.nelem != 0UL) {
      {
#line 3145
      match_lens = check_matching_with_multibyte_ops(d, s, (char const   *)*pp, wc,
                                                     mbclen);
      }
    }
  }
#line 3150
  s1 = s;
#line 3151
  k = 0;
  {
#line 3151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3151
    if (! ((size_t )k < mbclen)) {
#line 3151
      goto while_break;
    }
    {
#line 3153
    s2 = s1;
#line 3154
    tmp = *pp;
#line 3154
    (*pp) ++;
#line 3154
    rs = transit_state_singlebyte(d, s2, tmp, & s1);
#line 3151
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3156
  copy((position_set const   *)(& (d->states + s1)->elems), & d->mb_follows);
#line 3160
  i = (size_t )0;
  }
  {
#line 3160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3160
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 3160
      goto while_break___0;
    }
#line 3162
    if ((size_t )*(match_lens + i) == mbclen) {
#line 3163
      j = (size_t )0;
      {
#line 3163
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3163
        if (! (j < (d->follows + ((d->states + s)->mbps.elems + i)->index)->nelem)) {
#line 3163
          goto while_break___1;
        }
        {
#line 3165
        insert(*((d->follows + ((d->states + s)->mbps.elems + i)->index)->elems + j),
               & d->mb_follows);
#line 3163
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3160
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3170
  return (rs);
}
}
#line 3176 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ,
                               unsigned char const   *end )
{
  state_num s1 ;
  int mbclen ;
  int maxlen ;
  size_t i ;
  size_t j ;
  int *match_lens ;
  size_t nelem ;
  unsigned char const   *p1 ;
  wint_t wc ;
  size_t tmp ;
  status_transit_state rs ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 3182
  maxlen = 0;
#line 3184
  match_lens = (int *)((void *)0);
#line 3185
  nelem = (d->states + s)->mbps.nelem;
#line 3186
  p1 = *pp;
#line 3189
  if (nelem > 0UL) {
    {
#line 3194
    tmp = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 3194
    mbclen = (int )tmp;
#line 3195
    match_lens = check_matching_with_multibyte_ops(d, s, (char const   *)*pp, wc,
                                                   (size_t )mbclen);
#line 3198
    i = (size_t )0;
    }
    {
#line 3198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3198
      if (! (i < nelem)) {
#line 3198
        goto while_break;
      }
#line 3202
      if (*(match_lens + i) > maxlen) {
#line 3203
        maxlen = *(match_lens + i);
      }
#line 3198
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3207
  if (nelem == 0UL) {
#line 3207
    goto _L;
  } else
#line 3207
  if (maxlen == 0) {
    _L: /* CIL Label */
    {
#line 3212
    rs = transit_state_singlebyte(d, s, *pp, & s1);
    }
#line 3215
    if ((unsigned int )rs == 1U) {
#line 3216
      (*pp) ++;
    }
#line 3218
    return (s1);
  }
  {
#line 3222
  d->mb_follows.nelem = (size_t )0;
#line 3228
  transit_state_consume_1char(d, s, pp, wc, (size_t )mbclen, match_lens);
#line 3230
  tmp___0 = wchar_context(wc);
#line 3230
  s1 = state_index(d, (position_set const   *)(& d->mb_follows), tmp___0);
#line 3231
  realloc_trans_if_necessary(d, s1);
  }
  {
#line 3233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3233
    if (! (*pp - p1 < (long )maxlen)) {
#line 3233
      goto while_break___0;
    }
    {
#line 3235
    tmp___1 = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 3235
    mbclen = (int )tmp___1;
#line 3236
    transit_state_consume_1char(d, s1, pp, wc, (size_t )mbclen, (int *)((void *)0));
#line 3238
    i = (size_t )0;
    }
    {
#line 3238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3238
      if (! (i < nelem)) {
#line 3238
        goto while_break___1;
      }
#line 3240
      if ((long )*(match_lens + i) == *pp - p1) {
#line 3241
        j = (size_t )0;
        {
#line 3241
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3241
          if (! (j < (d->follows + ((d->states + s1)->mbps.elems + i)->index)->nelem)) {
#line 3241
            goto while_break___2;
          }
          {
#line 3243
          insert(*((d->follows + ((d->states + s1)->mbps.elems + i)->index)->elems + j),
                 & d->mb_follows);
#line 3241
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 3238
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3247
    tmp___2 = wchar_context(wc);
#line 3247
    s1 = state_index(d, (position_set const   *)(& d->mb_follows), tmp___2);
#line 3248
    realloc_trans_if_necessary(d, s1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3250
  return (s1);
}
}
#line 3265 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref )
{
  state_num s ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans___0 ;
  state_num *t ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  void *tmp ;
  wint_t wc ;
  size_t tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  state_num tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;

  {
#line 3273
  eol = eolbyte___0;
#line 3275
  nlcount = (size_t )0;
#line 3277
  if (! d->tralloc) {
    {
#line 3278
    build_state_zero(d);
    }
  }
#line 3280
  s1 = (state_num )0;
#line 3280
  s = s1;
#line 3281
  mbp = (unsigned char const   *)begin;
#line 3281
  p = mbp;
#line 3282
  trans___0 = d->trans;
#line 3283
  saved_end = *((unsigned char *)end);
#line 3284
  *end = (char )eol;
#line 3286
  if (d->multibyte) {
    {
#line 3288
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3289
    if (! d->mb_match_lens) {
      {
#line 3291
      tmp = xnmalloc(d->nleaves, sizeof(*(d->mb_match_lens)));
#line 3291
      d->mb_match_lens = (int *)tmp;
#line 3292
      alloc_position_set(& d->mb_follows, d->nleaves);
      }
    }
  }
  {
#line 3296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3298
    if (d->multibyte) {
      {
#line 3300
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3300
        t = *(trans___0 + s);
#line 3300
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3300
          goto while_break___0;
        }
#line 3302
        s1 = s;
#line 3304
        if (s == 0L) {
          {
#line 3317
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3317
            if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3317
              goto while_break___1;
            }
            {
#line 3318
            tmp___0 = mbs_to_wchar(& wc, (char const   *)mbp, (size_t )(end - (char *)((char const   *)mbp)),
                                   d);
#line 3318
            mbp += tmp___0;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3320
          p = mbp;
#line 3322
          if ((unsigned long )((char *)p) > (unsigned long )end) {
#line 3324
            p = (unsigned char const   *)((void *)0);
#line 3325
            goto done;
          }
        }
#line 3329
        if ((d->states + s)->mbps.nelem == 0UL) {
#line 3331
          tmp___1 = p;
#line 3331
          p ++;
#line 3331
          s = *(t + *tmp___1);
#line 3332
          goto while_continue___0;
        }
#line 3339
        if ((d->states + s)->has_mbcset) {
#line 3339
          if (backref) {
#line 3341
            *backref = 1;
#line 3342
            goto done;
          }
        }
        {
#line 3347
        s = transit_state(d, s, & p, (unsigned char const   *)((unsigned char *)end));
#line 3348
        mbp = p;
#line 3349
        trans___0 = d->trans;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 3354
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3354
        t = *(trans___0 + s);
#line 3354
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3354
          goto while_break___2;
        }
#line 3356
        tmp___2 = p;
#line 3356
        p ++;
#line 3356
        s1 = *(t + *tmp___2);
#line 3357
        t = *(trans___0 + s1);
#line 3357
        if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 3359
          tmp___3 = s;
#line 3360
          s = s1;
#line 3361
          s1 = tmp___3;
#line 3362
          goto while_break___2;
        }
#line 3364
        tmp___4 = p;
#line 3364
        p ++;
#line 3364
        s = *(t + *tmp___4);
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 3368
    if ((unsigned long )((char *)p) > (unsigned long )end) {
#line 3370
      p = (unsigned char const   *)((void *)0);
#line 3371
      goto done;
    }
#line 3374
    if (s >= 0L) {
#line 3374
      if (*(d->fails + s)) {
#line 3376
        if (*(d->success + s) & sbit[*p]) {
#line 3378
          if (backref) {
#line 3379
            *backref = (int )(d->states + s)->has_backref;
          }
#line 3380
          goto done;
        }
#line 3383
        s1 = s;
#line 3384
        if (d->multibyte) {
          {
#line 3388
          s = transit_state(d, s, & p, (unsigned char const   *)((unsigned char *)end));
#line 3389
          mbp = p;
#line 3390
          trans___0 = d->trans;
          }
        } else {
#line 3393
          tmp___5 = p;
#line 3393
          p ++;
#line 3393
          s = *(*(d->fails + s) + *tmp___5);
        }
#line 3394
        goto __Cont;
      }
    }
#line 3399
    if ((int const   )*(p + -1) == (int const   )eol) {
#line 3399
      if ((unsigned long )((char *)p) != (unsigned long )begin) {
#line 3401
        nlcount ++;
#line 3402
        mbp = p;
      }
    }
#line 3405
    if (s >= 0L) {
#line 3407
      if (! *(d->trans + s)) {
        {
#line 3408
        build_state(s, d);
        }
      }
#line 3409
      trans___0 = d->trans;
#line 3410
      goto __Cont;
    }
#line 3413
    if ((int const   )*(p + -1) == (int const   )eol) {
#line 3413
      if (allow_nl) {
#line 3415
        s = *(d->newlines + s1);
#line 3416
        goto __Cont;
      }
    }
#line 3419
    s = (state_num )0;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done:
#line 3423
  if (count) {
#line 3424
    *count += nlcount;
  }
#line 3425
  *end = (char )saved_end;
#line 3426
  return ((char *)p);
}
}
#line 3429
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3429 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct dfa *dfasuperset(struct dfa  const  *d )
{


  {
#line 3432
  return ((struct dfa *)d->superset);
}
}
#line 3435
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3435 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
_Bool dfaisfast(struct dfa  const  *d )
{


  {
#line 3438
  return ((_Bool )d->fast);
}
}
#line 3441 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void free_mbdata(struct dfa *d )
{
  size_t i ;
  size_t j ;
  struct mb_char_classes *p ;

  {
  {
#line 3446
  free((void *)d->multibyte_prop);
#line 3448
  i = (size_t )0;
  }
  {
#line 3448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3448
    if (! (i < d->nmbcsets)) {
#line 3448
      goto while_break;
    }
    {
#line 3451
    p = d->mbcsets + i;
#line 3452
    free((void *)p->chars);
#line 3453
    free((void *)p->ch_classes);
#line 3454
    free((void *)p->ranges);
#line 3456
    j = (size_t )0;
    }
    {
#line 3456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3456
      if (! (j < p->nequivs)) {
#line 3456
        goto while_break___0;
      }
      {
#line 3457
      free((void *)*(p->equivs + j));
#line 3456
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3458
    free((void *)p->equivs);
#line 3460
    j = (size_t )0;
    }
    {
#line 3460
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3460
      if (! (j < p->ncoll_elems)) {
#line 3460
        goto while_break___1;
      }
      {
#line 3461
      free((void *)*(p->coll_elems + j));
#line 3460
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3462
    free((void *)p->coll_elems);
#line 3448
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3465
  free((void *)d->mbcsets);
#line 3466
  free((void *)d->mb_follows.elems);
#line 3467
  free((void *)d->mb_match_lens);
#line 3468
  d->mb_match_lens = (int *)((void *)0);
  }
#line 3469
  return;
}
}
#line 3473 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfainit(struct dfa *d )
{
  size_t tmp ;

  {
  {
#line 3476
  memset((void *)d, 0, sizeof(*d));
#line 3477
  tmp = __ctype_get_mb_cur_max();
#line 3477
  d->multibyte = (_Bool )(tmp > 1UL);
#line 3478
  d->fast = (_Bool )(! d->multibyte);
  }
#line 3479
  return;
}
}
#line 3481 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void dfaoptimize(struct dfa *d )
{
  size_t i ;
  _Bool have_backref ;
  int tmp ;

  {
  {
#line 3485
  have_backref = (_Bool)0;
#line 3487
  tmp = using_utf8();
  }
#line 3487
  if (! tmp) {
#line 3488
    return;
  }
#line 3490
  i = (size_t )0;
  {
#line 3490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3490
    if (! (i < d->tindex)) {
#line 3490
      goto while_break;
    }
    {
#line 3494
    if (*(d->tokens + i) == 272L) {
#line 3494
      goto case_272;
    }
#line 3497
    if (*(d->tokens + i) == 257L) {
#line 3497
      goto case_257;
    }
#line 3500
    if (*(d->tokens + i) == 273L) {
#line 3500
      goto case_273;
    }
#line 3503
    goto switch_default;
    case_272: /* CIL Label */
    {
#line 3496
    abort();
    }
    case_257: /* CIL Label */
#line 3498
    have_backref = (_Bool)1;
#line 3499
    goto switch_break;
    case_273: /* CIL Label */
#line 3502
    return;
    switch_default: /* CIL Label */
#line 3504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3508
  if (! have_backref) {
#line 3508
    if (d->superset) {
      {
#line 3511
      dfafree(d->superset);
#line 3512
      free((void *)d->superset);
#line 3513
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3516
  free_mbdata(d);
#line 3517
  d->multibyte = (_Bool)0;
  }
#line 3518
  return;
}
}
#line 3520 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void dfassbuild(struct dfa *d )
{
  size_t i ;
  size_t j ;
  charclass ccl ;
  _Bool have_achar ;
  _Bool have_nchar ;
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3525
  have_achar = (_Bool)0;
#line 3526
  have_nchar = (_Bool)0;
#line 3527
  tmp = dfaalloc();
#line 3527
  sup = tmp;
#line 3529
  *sup = *d;
#line 3530
  sup->multibyte = (_Bool)0;
#line 3531
  sup->multibyte_prop = (int *)((void *)0);
#line 3532
  sup->mbcsets = (struct mb_char_classes *)((void *)0);
#line 3533
  sup->superset = (struct dfa *)((void *)0);
#line 3534
  sup->states = (dfa_state *)((void *)0);
#line 3535
  sup->sindex = (state_num )0;
#line 3536
  sup->follows = (position_set *)((void *)0);
#line 3537
  sup->tralloc = (state_num )0;
#line 3538
  sup->trans = (state_num **)((void *)0);
#line 3539
  sup->fails = (state_num **)((void *)0);
#line 3540
  sup->success = (int *)((void *)0);
#line 3541
  sup->newlines = (state_num *)((void *)0);
#line 3542
  sup->musts = (struct dfamust *)((void *)0);
#line 3544
  tmp___0 = xnmalloc(sup->calloc, sizeof(*(sup->charclasses)));
#line 3544
  sup->charclasses = (charclass *)tmp___0;
#line 3545
  memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
         d->cindex * sizeof(*(sup->charclasses)));
#line 3548
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3548
  sup->tokens = (token *)tmp___1;
#line 3549
  sup->talloc = d->tindex * 2UL;
#line 3551
  j = (size_t )0;
#line 3551
  i = j;
  }
  {
#line 3551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3551
    if (! (i < d->tindex)) {
#line 3551
      goto while_break;
    }
    {
#line 3557
    if (*(d->tokens + i) == 257L) {
#line 3557
      goto case_257;
    }
#line 3557
    if (*(d->tokens + i) == 273L) {
#line 3557
      goto case_257;
    }
#line 3557
    if (*(d->tokens + i) == 272L) {
#line 3557
      goto case_257;
    }
#line 3570
    if (*(d->tokens + i) == 263L) {
#line 3570
      goto case_263;
    }
#line 3570
    if (*(d->tokens + i) == 262L) {
#line 3570
      goto case_263;
    }
#line 3570
    if (*(d->tokens + i) == 261L) {
#line 3570
      goto case_263;
    }
#line 3570
    if (*(d->tokens + i) == 260L) {
#line 3570
      goto case_263;
    }
#line 3580
    goto switch_default;
    case_257: /* CIL Label */
    case_273: /* CIL Label */
    case_272: /* CIL Label */
    {
#line 3558
    zeroset((charclass_word *)(ccl));
#line 3559
    notset((charclass_word *)(ccl));
#line 3560
    tmp___2 = j;
#line 3560
    j ++;
#line 3560
    tmp___3 = dfa_charclass_index(sup, (charclass_word */* const  */)(ccl));
#line 3560
    *(sup->tokens + tmp___2) = (token )(275UL + tmp___3);
#line 3561
    tmp___4 = j;
#line 3561
    j ++;
#line 3561
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3562
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3564
      i ++;
    } else
#line 3562
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3564
      i ++;
    } else
#line 3562
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3564
      i ++;
    }
#line 3565
    have_achar = (_Bool)1;
#line 3566
    goto switch_break;
    case_263: /* CIL Label */
    case_262: /* CIL Label */
    case_261: /* CIL Label */
    case_260: /* CIL Label */
#line 3571
    if (d->multibyte) {
#line 3576
      tmp___5 = j;
#line 3576
      j ++;
#line 3576
      *(sup->tokens + tmp___5) = (token )256;
#line 3577
      *(d->tokens + i) = (token )257;
#line 3578
      goto switch_break;
    }
    switch_default: /* CIL Label */
#line 3581
    tmp___6 = j;
#line 3581
    j ++;
#line 3581
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3582
    if (0L <= *(d->tokens + i)) {
#line 3582
      if (*(d->tokens + i) < 256L) {
#line 3584
        have_nchar = (_Bool)1;
      } else {
#line 3582
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 3582
    if (*(d->tokens + i) >= 275L) {
#line 3584
      have_nchar = (_Bool)1;
    }
#line 3585
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3551
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3588
  sup->tindex = j;
#line 3590
  if (have_nchar) {
#line 3590
    if (have_achar) {
#line 3591
      d->superset = sup;
    } else
#line 3590
    if (d->multibyte) {
#line 3591
      d->superset = sup;
    } else {
      {
#line 3594
      dfafree(sup);
#line 3595
      free((void *)sup);
      }
    }
  } else {
    {
#line 3594
    dfafree(sup);
#line 3595
    free((void *)sup);
    }
  }
#line 3597
  return;
}
}
#line 3600 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag )
{


  {
  {
#line 3603
  dfainit(d);
#line 3604
  dfambcache(d);
#line 3605
  dfaparse(s, len, d);
#line 3606
  dfamust(d);
#line 3607
  dfassbuild(d);
#line 3608
  dfaoptimize(d);
#line 3609
  dfaanalyze(d, searchflag);
  }
#line 3610
  if (d->superset) {
    {
#line 3612
    d->fast = (_Bool)1;
#line 3613
    dfaanalyze(d->superset, searchflag);
    }
  }
#line 3615
  return;
}
}
#line 3618 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
void dfafree(struct dfa *d )
{
  size_t i ;
  struct dfamust *dm ;
  struct dfamust *ndm ;

  {
  {
#line 3624
  free((void *)d->charclasses);
#line 3625
  free((void *)d->tokens);
  }
#line 3627
  if (d->multibyte) {
    {
#line 3628
    free_mbdata(d);
    }
  }
#line 3630
  i = (size_t )0;
  {
#line 3630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3630
    if (! (i < (size_t )d->sindex)) {
#line 3630
      goto while_break;
    }
    {
#line 3632
    free((void *)(d->states + i)->elems.elems);
#line 3633
    free((void *)(d->states + i)->mbps.elems);
#line 3630
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3635
  free((void *)d->states);
  }
#line 3637
  if (d->follows) {
#line 3639
    i = (size_t )0;
    {
#line 3639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3639
      if (! (i < d->tindex)) {
#line 3639
        goto while_break___0;
      }
      {
#line 3640
      free((void *)(d->follows + i)->elems);
#line 3639
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3641
    free((void *)d->follows);
    }
  }
#line 3644
  if (d->trans) {
#line 3646
    i = (size_t )0;
    {
#line 3646
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3646
      if (! (i < (size_t )d->tralloc)) {
#line 3646
        goto while_break___1;
      }
      {
#line 3648
      free((void *)*(d->trans + i));
#line 3649
      free((void *)*(d->fails + i));
#line 3646
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3652
    free((void *)(d->trans - 1));
#line 3653
    free((void *)d->fails);
#line 3654
    free((void *)d->newlines);
#line 3655
    free((void *)d->success);
    }
  }
#line 3658
  dm = d->musts;
  {
#line 3658
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3658
    if (! dm) {
#line 3658
      goto while_break___2;
    }
    {
#line 3660
    ndm = dm->next;
#line 3661
    free((void *)dm->must);
#line 3662
    free((void *)dm);
#line 3658
    dm = ndm;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3665
  if (d->superset) {
    {
#line 3666
    dfafree(d->superset);
    }
  }
#line 3667
  return;
}
}
#line 3753 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char *icatalloc(char *old , char const   *new )
{
  char *result ;
  size_t oldsize ;
  size_t newsize ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 3758
  tmp = strlen(new);
#line 3758
  newsize = tmp;
  }
#line 3759
  if (newsize == 0UL) {
#line 3760
    return (old);
  }
  {
#line 3761
  oldsize = strlen((char const   *)old);
#line 3762
  tmp___0 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3762
  result = (char *)tmp___0;
#line 3763
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3764
  return (result);
}
}
#line 3767 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char * __attribute__((__pure__)) istrstr(char const   *lookin , char const   *lookfor )
{
  char const   *cp ;
  size_t len ;
  int tmp ;

  {
  {
#line 3773
  len = strlen(lookfor);
#line 3774
  cp = lookin;
  }
  {
#line 3774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3774
    if (! ((int const   )*cp != 0)) {
#line 3774
      goto while_break;
    }
    {
#line 3775
    tmp = strncmp(cp, lookfor, len);
    }
#line 3775
    if (tmp == 0) {
#line 3776
      return ((char */* __attribute__((__pure__)) */)((char *)cp));
    }
#line 3774
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3777
  return ((char */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 3780 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void freelist(char **cpp )
{
  char **tmp ;

  {
  {
#line 3783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3783
    if (! *cpp) {
#line 3783
      goto while_break;
    }
    {
#line 3784
    tmp = cpp;
#line 3784
    cpp ++;
#line 3784
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3785
  return;
}
}
#line 3787 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char **enlist(char **cpp , char *new , size_t len )
{
  size_t i ;
  size_t j ;
  void *tmp ;
  void *tmp___0 ;
  char * __attribute__((__pure__)) tmp___1 ;
  char * __attribute__((__pure__)) tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3791
  tmp = xmalloc(len + 1UL);
#line 3791
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3791
  new = (char *)tmp___0;
#line 3792
  *(new + len) = (char )'\000';
#line 3794
  i = (size_t )0;
  }
  {
#line 3794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3794
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3794
      goto while_break;
    }
    {
#line 3795
    tmp___1 = istrstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3795
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3797
      free((void *)new);
      }
#line 3798
      return (cpp);
    }
#line 3794
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3801
  j = (size_t )0;
  {
#line 3802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3802
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3802
      goto while_break___0;
    }
    {
#line 3803
    tmp___2 = istrstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3803
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3804
      j ++;
    } else {
      {
#line 3807
      free((void *)*(cpp + j));
#line 3808
      i --;
      }
#line 3808
      if (i == j) {
#line 3809
        goto while_break___0;
      }
#line 3810
      *(cpp + j) = *(cpp + i);
#line 3811
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3814
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3814
  cpp = (char **)tmp___3;
#line 3815
  *(cpp + i) = new;
#line 3816
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3817
  return (cpp);
}
}
#line 3822 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char **comsubs(char *left , char const   *right )
{
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3825
  tmp = xzalloc(sizeof(*cpp));
#line 3825
  cpp = (char **)tmp;
#line 3828
  lcp = left;
  }
  {
#line 3828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3828
    if (! ((int )*lcp != 0)) {
#line 3828
      goto while_break;
    }
    {
#line 3830
    len = (size_t )0;
#line 3831
    tmp___0 = strchr(right, (int )*lcp);
#line 3831
    rcp = tmp___0;
    }
    {
#line 3832
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3832
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3832
        goto while_break___0;
      }
#line 3835
      i = (size_t )1;
      {
#line 3835
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3835
        if ((int )*(lcp + i) != 0) {
#line 3835
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3835
            goto while_break___1;
          }
        } else {
#line 3835
          goto while_break___1;
        }
#line 3836
        goto __Cont;
        __Cont: /* CIL Label */
#line 3835
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3837
      if (i > len) {
#line 3838
        len = i;
      }
      {
#line 3839
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3841
    if (len != 0UL) {
      {
#line 3842
      cpp = enlist(cpp, lcp, len);
      }
    }
#line 3828
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3844
  return (cpp);
}
}
#line 3847 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char **addlists(char **old , char **new )
{
  size_t tmp ;

  {
  {
#line 3850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3850
    if (! *new) {
#line 3850
      goto while_break;
    }
    {
#line 3851
    tmp = strlen((char const   *)*new);
#line 3851
    old = enlist(old, *new, tmp);
#line 3850
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3852
  return (old);
}
}
#line 3857 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static char **inboth(char **left , char **right )
{
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3860
  tmp = xzalloc(sizeof(*both));
#line 3860
  both = (char **)tmp;
#line 3863
  lnum = (size_t )0;
  }
  {
#line 3863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3863
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3863
      goto while_break;
    }
#line 3865
    rnum = (size_t )0;
    {
#line 3865
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3865
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3865
        goto while_break___0;
      }
      {
#line 3867
      tmp___0 = comsubs(*(left + lnum), (char const   *)*(right + rnum));
#line 3867
      temp = tmp___0;
#line 3868
      both = addlists(both, temp);
#line 3869
      freelist(temp);
#line 3870
      free((void *)temp);
#line 3865
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3863
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3873
  return (both);
}
}
#line 3889 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static must *allocmust(must *mp )
{
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3892
  tmp = xmalloc(sizeof(*new_mp));
#line 3892
  new_mp = (must *)tmp;
#line 3893
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3893
  new_mp->in = (char **)tmp___0;
#line 3894
  tmp___1 = xzalloc((size_t )2);
#line 3894
  new_mp->left = (char *)tmp___1;
#line 3895
  tmp___2 = xzalloc((size_t )2);
#line 3895
  new_mp->right = (char *)tmp___2;
#line 3896
  tmp___3 = xzalloc((size_t )2);
#line 3896
  new_mp->is = (char *)tmp___3;
#line 3897
  new_mp->begline = (_Bool)0;
#line 3898
  new_mp->endline = (_Bool)0;
#line 3899
  new_mp->prev = mp;
  }
#line 3900
  return (new_mp);
}
}
#line 3903 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void resetmust(must *mp )
{
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3906
  freelist(mp->in);
#line 3907
  *(mp->in + 0) = (char *)((void *)0);
#line 3908
  tmp___0 = (char )'\000';
#line 3908
  *(mp->is + 0) = tmp___0;
#line 3908
  tmp = tmp___0;
#line 3908
  *(mp->right + 0) = tmp;
#line 3908
  *(mp->left + 0) = tmp;
#line 3909
  mp->begline = (_Bool)0;
#line 3910
  mp->endline = (_Bool)0;
  }
#line 3911
  return;
}
}
#line 3913 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void freemust(must *mp )
{


  {
  {
#line 3916
  freelist(mp->in);
#line 3917
  free((void *)mp->in);
#line 3918
  free((void *)mp->left);
#line 3919
  free((void *)mp->right);
#line 3920
  free((void *)mp->is);
#line 3921
  free((void *)mp);
  }
#line 3922
  return;
}
}
#line 3924 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
static void dfamust(struct dfa *d )
{
  must *mp ;
  char const   *result ;
  size_t ri ;
  size_t i ;
  _Bool exact ;
  _Bool begline___0 ;
  _Bool endline ;
  struct dfamust *dm ;
  token t ;
  char **new ;
  must *rmp ;
  must *lmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  int tmp ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  must *rmp___0 ;
  must *lmp___0 ;
  size_t lrlen ;
  size_t tmp___4 ;
  size_t rllen ;
  size_t tmp___5 ;
  char *tp ;
  void *tmp___6 ;
  charclass *ccl ;
  int j___0 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char tmp___11 ;
  char tmp___12 ;
  int tmp___13 ;
  char tmp___14 ;
  char tmp___15 ;
  void *tmp___16 ;
  must *prev ;

  {
#line 3927
  mp = (must *)((void *)0);
#line 3928
  result = "";
#line 3931
  exact = (_Bool)0;
#line 3932
  begline___0 = (_Bool)0;
#line 3933
  endline = (_Bool)0;
#line 3936
  ri = (size_t )0;
  {
#line 3936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3936
    if (! (ri < d->tindex)) {
#line 3936
      goto while_break;
    }
#line 3938
    t = *(d->tokens + ri);
    {
#line 3941
    if (t == 258L) {
#line 3941
      goto case_258;
    }
#line 3945
    if (t == 259L) {
#line 3945
      goto case_259;
    }
#line 3950
    if (t == 271L) {
#line 3950
      goto case_271;
    }
#line 3950
    if (t == 270L) {
#line 3950
      goto case_271;
    }
#line 3960
    if (t == 273L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 272L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 257L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 263L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 262L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 261L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 260L) {
#line 3960
      goto case_273;
    }
#line 3960
    if (t == 256L) {
#line 3960
      goto case_273;
    }
#line 3965
    if (t == 264L) {
#line 3965
      goto case_264;
    }
#line 3965
    if (t == 265L) {
#line 3965
      goto case_264;
    }
#line 3969
    if (t == 269L) {
#line 3969
      goto case_269;
    }
#line 4006
    if (t == 266L) {
#line 4006
      goto case_266;
    }
#line 4010
    if (t == -1L) {
#line 4010
      goto case_neg_1;
    }
#line 4023
    if (t == 268L) {
#line 4023
      goto case_268;
    }
#line 4066
    if (t == 0L) {
#line 4066
      goto case_0;
    }
#line 4070
    goto switch_default;
    case_258: /* CIL Label */
    {
#line 3942
    mp = allocmust(mp);
#line 3943
    mp->begline = (_Bool)1;
    }
#line 3944
    goto switch_break;
    case_259: /* CIL Label */
    {
#line 3946
    mp = allocmust(mp);
#line 3947
    mp->endline = (_Bool)1;
    }
#line 3948
    goto switch_break;
    case_271: /* CIL Label */
    case_270: /* CIL Label */
    {
#line 3951
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/grep-2.19/src/dfa.c",
                  3951U, "dfamust");
    }
    case_273: /* CIL Label */
    case_272: /* CIL Label */
    case_257: /* CIL Label */
    case_263: /* CIL Label */
    case_262: /* CIL Label */
    case_261: /* CIL Label */
    case_260: /* CIL Label */
    case_256: /* CIL Label */
    {
#line 3961
    mp = allocmust(mp);
    }
#line 3962
    goto switch_break;
    case_264: /* CIL Label */
    case_265: /* CIL Label */
    {
#line 3966
    resetmust(mp);
    }
#line 3967
    goto switch_break;
    case_269: /* CIL Label */
    {
#line 3972
    rmp = mp;
#line 3973
    mp = mp->prev;
#line 3973
    lmp = mp;
#line 3977
    tmp = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3977
    if (! (tmp == 0)) {
#line 3978
      *(lmp->is + 0) = (char )'\000';
    }
#line 3979
    lmp->begline = (_Bool )((int )lmp->begline & (int )rmp->begline);
#line 3980
    lmp->endline = (_Bool )((int )lmp->endline & (int )rmp->endline);
#line 3982
    i = (size_t )0;
    {
#line 3983
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3983
      if ((int )*(lmp->left + i) != 0) {
#line 3983
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3983
          goto while_break___0;
        }
      } else {
#line 3983
        goto while_break___0;
      }
#line 3984
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3985
    *(lmp->left + i) = (char )'\000';
#line 3987
    ln = strlen((char const   *)lmp->right);
#line 3988
    rn = strlen((char const   *)rmp->right);
#line 3989
    n = ln;
    }
#line 3990
    if (n > rn) {
#line 3991
      n = rn;
    }
#line 3992
    i = (size_t )0;
    {
#line 3992
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3992
      if (! (i < n)) {
#line 3992
        goto while_break___1;
      }
#line 3993
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3994
        goto while_break___1;
      }
#line 3992
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3995
    j = (size_t )0;
    {
#line 3995
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3995
      if (! (j < i)) {
#line 3995
        goto while_break___2;
      }
#line 3996
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3995
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3997
    *(lmp->right + j) = (char )'\000';
#line 3998
    new = inboth(lmp->in, rmp->in);
#line 3999
    freelist(lmp->in);
#line 4000
    free((void *)lmp->in);
#line 4001
    lmp->in = new;
#line 4002
    freemust(rmp);
    }
#line 4004
    goto switch_break;
    case_266: /* CIL Label */
#line 4007
    *(mp->is + 0) = (char )'\000';
#line 4008
    goto switch_break;
    case_neg_1: /* CIL Label */
#line 4011
    if (! (! mp->prev)) {
      {
#line 4011
      __assert_fail("!mp->prev", "/home/khheo/project/benchmark/grep-2.19/src/dfa.c",
                    4011U, "dfamust");
      }
    }
#line 4012
    i = (size_t )0;
    {
#line 4012
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4012
      if (! ((unsigned long )*(mp->in + i) != (unsigned long )((void *)0))) {
#line 4012
        goto while_break___3;
      }
      {
#line 4013
      tmp___1 = strlen((char const   *)*(mp->in + i));
#line 4013
      tmp___2 = strlen(result);
      }
#line 4013
      if (tmp___1 > tmp___2) {
#line 4014
        result = (char const   *)*(mp->in + i);
      }
#line 4012
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 4015
    tmp___3 = strcmp(result, (char const   *)mp->is);
    }
#line 4015
    if (tmp___3 == 0) {
#line 4017
      exact = (_Bool)1;
#line 4018
      begline___0 = mp->begline;
#line 4019
      endline = mp->endline;
    }
#line 4021
    goto done;
    case_268: /* CIL Label */
    {
#line 4025
    rmp___0 = mp;
#line 4026
    mp = mp->prev;
#line 4026
    lmp___0 = mp;
#line 4031
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 4032
    if ((int )*(lmp___0->right + 0) != 0) {
#line 4032
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 4034
        tmp___4 = strlen((char const   *)lmp___0->right);
#line 4034
        lrlen = tmp___4;
#line 4035
        tmp___5 = strlen((char const   *)rmp___0->left);
#line 4035
        rllen = tmp___5;
#line 4036
        tmp___6 = xmalloc(lrlen + rllen);
#line 4036
        tp = (char *)tmp___6;
#line 4037
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)lmp___0->right,
               lrlen);
#line 4038
        memcpy((void */* __restrict  */)(tp + lrlen), (void const   */* __restrict  */)rmp___0->left,
               rllen);
#line 4039
        lmp___0->in = enlist(lmp___0->in, tp, lrlen + rllen);
#line 4040
        free((void *)tp);
        }
      }
    }
#line 4043
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 4044
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
    }
#line 4046
    if ((int )*(rmp___0->is + 0) == 0) {
#line 4047
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 4048
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 4050
    if ((int )*(lmp___0->is + 0) != 0) {
#line 4050
      goto _L;
    } else
#line 4050
    if (lmp___0->begline) {
      _L: /* CIL Label */
#line 4050
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 4053
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 4054
        lmp___0->endline = rmp___0->endline;
        }
      } else
#line 4050
      if (rmp___0->endline) {
        {
#line 4053
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 4054
        lmp___0->endline = rmp___0->endline;
        }
      } else {
#line 4058
        *(lmp___0->is + 0) = (char )'\000';
#line 4059
        lmp___0->begline = (_Bool)0;
#line 4060
        lmp___0->endline = (_Bool)0;
      }
    } else {
#line 4058
      *(lmp___0->is + 0) = (char )'\000';
#line 4059
      lmp___0->begline = (_Bool)0;
#line 4060
      lmp___0->endline = (_Bool)0;
    }
    {
#line 4062
    freemust(rmp___0);
    }
#line 4064
    goto switch_break;
    case_0: /* CIL Label */
#line 4068
    goto done;
    switch_default: /* CIL Label */
    {
#line 4071
    mp = allocmust(mp);
    }
#line 4072
    if (275L <= t) {
#line 4078
      ccl = d->charclasses + (t - 275L);
#line 4080
      j___0 = 0;
      {
#line 4080
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4080
        if (! (j___0 < 256)) {
#line 4080
          goto while_break___4;
        }
        {
#line 4081
        tmp___7 = tstbit((unsigned int )j___0, (charclass_word */* const  */)(*ccl));
        }
#line 4081
        if (tmp___7) {
#line 4082
          goto while_break___4;
        }
#line 4080
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4083
      if (! (j___0 < 256)) {
#line 4084
        goto switch_break;
      }
#line 4085
      t = (token )j___0;
      {
#line 4086
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 4086
        j___0 ++;
#line 4086
        if (! (j___0 < 256)) {
#line 4086
          goto while_break___5;
        }
        {
#line 4087
        tmp___8 = tstbit((unsigned int )j___0, (charclass_word */* const  */)(*ccl));
        }
#line 4087
        if (tmp___8) {
#line 4087
          if (case_fold) {
#line 4087
            if (! d->multibyte) {
              {
#line 4087
              tmp___9 = toupper(j___0);
#line 4087
              tmp___10 = toupper((int )t);
              }
#line 4087
              if (! (tmp___9 == tmp___10)) {
#line 4090
                goto while_break___5;
              }
            } else {
#line 4090
              goto while_break___5;
            }
          } else {
#line 4090
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 4091
      if (j___0 < 256) {
#line 4092
        goto switch_break;
      }
    }
#line 4094
    if (case_fold) {
#line 4094
      if (! d->multibyte) {
        {
#line 4094
        tmp___13 = toupper((int )t);
#line 4094
        tmp___12 = (char )tmp___13;
        }
      } else {
#line 4094
        tmp___12 = (char )t;
      }
    } else {
#line 4094
      tmp___12 = (char )t;
    }
    {
#line 4094
    *(mp->right + 0) = tmp___12;
#line 4094
    tmp___11 = tmp___12;
#line 4094
    *(mp->left + 0) = tmp___11;
#line 4094
    *(mp->is + 0) = tmp___11;
#line 4096
    tmp___15 = (char )'\000';
#line 4096
    *(mp->right + 1) = tmp___15;
#line 4096
    tmp___14 = tmp___15;
#line 4096
    *(mp->left + 1) = tmp___14;
#line 4096
    *(mp->is + 1) = tmp___14;
#line 4097
    mp->in = enlist(mp->in, mp->is, (size_t )1);
    }
#line 4098
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3936
    ri ++;
  }
  while_break: /* CIL Label */ ;
  }
  done:
#line 4102
  if (*result) {
    {
#line 4104
    tmp___16 = xmalloc(sizeof(*dm));
#line 4104
    dm = (struct dfamust *)tmp___16;
#line 4105
    dm->exact = exact;
#line 4106
    dm->begline = begline___0;
#line 4107
    dm->endline = endline;
#line 4108
    dm->must = xstrdup(result);
#line 4109
    dm->next = d->musts;
#line 4110
    d->musts = dm;
    }
  }
  {
#line 4113
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 4113
    if (! mp) {
#line 4113
      goto while_break___6;
    }
    {
#line 4115
    prev = mp->prev;
#line 4116
    freemust(mp);
#line 4117
    mp = prev;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 4119
  return;
}
}
#line 4121 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct dfa *dfaalloc(void)
{
  void *tmp ;

  {
  {
#line 4124
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4124
  return ((struct dfa *)tmp);
}
}
#line 4127 "/home/khheo/project/benchmark/grep-2.19/src/dfa.c"
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d )
{


  {
#line 4130
  return ((struct dfamust */* __attribute__((__pure__)) */)d->musts);
}
}
#line 307 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrlen)(char const   * __restrict  __s ,
                                                                                size_t __n ,
                                                                                mbstate_t * __restrict  __ps ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 47 "/home/khheo/project/benchmark/grep-2.19/src/search.h"
void build_mbclen_cache(void) ;
#line 25 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
static size_t mbclen_cache[256]  ;
#line 30 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
static char trans[256]  ;
#line 27 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
void kwsinit(kwset_t *kwset___1 )
{
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 33
  if (match_icase) {
    {
#line 33
    tmp___0 = __ctype_get_mb_cur_max();
    }
#line 33
    if (tmp___0 == 1UL) {
#line 35
      i = 0;
      {
#line 35
      while (1) {
        while_continue: /* CIL Label */ ;
#line 35
        if (! (i < 256)) {
#line 35
          goto while_break;
        }
        {
#line 36
        tmp = toupper(i);
#line 36
        trans[i] = (char )tmp;
#line 35
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 38
      *kwset___1 = kwsalloc((char const   *)(trans));
      }
    } else {
      {
#line 41
      *kwset___1 = kwsalloc((char const   *)((void *)0));
      }
    }
  } else {
    {
#line 41
    *kwset___1 = kwsalloc((char const   *)((void *)0));
    }
  }
#line 43
  if (! *kwset___1) {
    {
#line 44
    xalloc_die();
    }
  }
#line 45
  return;
}
}
#line 79 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
static char *out  ;
#line 80 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
static mb_len_map_t *len_map  ;
#line 81 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
static size_t outalloc  ;
#line 76 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
char *mbtoupper(char const   *beg , size_t *n , mb_len_map_t **len_map_p )
{
  size_t outlen ;
  size_t mb_cur_max ;
  mbstate_t is ;
  mbstate_t os ;
  char const   *end ;
  char *p ;
  mb_len_map_t *m ;
  _Bool lengths_differ ;
  void *tmp ;
  void *tmp___0 ;
  wchar_t wc ;
  size_t mbclen ;
  size_t tmp___3 ;
  size_t dm ;
  void *tmp___4 ;
  void *tmp___5 ;
  mb_len_map_t *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  size_t ombclen ;
  wint_t tmp___9 ;

  {
#line 87
  lengths_differ = (_Bool)0;
#line 89
  if (*n > outalloc) {
#line 89
    goto _L;
  } else
#line 89
  if (outalloc == 0UL) {
    _L: /* CIL Label */
#line 91
    if (1UL > *n) {
#line 91
      outalloc = (size_t )1;
    } else {
#line 91
      outalloc = *n;
    }
    {
#line 92
    tmp = xrealloc((void *)out, outalloc);
#line 92
    out = (char *)tmp;
#line 93
    tmp___0 = xrealloc((void *)len_map, outalloc);
#line 93
    len_map = (mb_len_map_t *)tmp___0;
    }
  }
#line 97
  if (! out) {
    {
#line 97
    __assert_fail("out", "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c",
                  97U, "mbtoupper");
    }
  }
#line 98
  if (! len_map) {
    {
#line 98
    __assert_fail("len_map", "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c",
                  98U, "mbtoupper");
    }
  }
#line 99
  if (*n == 0UL) {
#line 100
    return (out);
  }
  {
#line 102
  memset((void *)(& is), 0, sizeof(is));
#line 103
  memset((void *)(& os), 0, sizeof(os));
#line 104
  end = beg + *n;
#line 106
  mb_cur_max = __ctype_get_mb_cur_max();
#line 107
  p = out;
#line 108
  m = len_map;
#line 109
  outlen = (size_t )0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 110
      goto while_break;
    }
    {
#line 113
    tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)beg,
                      (size_t )(end - beg), (mbstate_t */* __restrict  */)(& is));
#line 113
    mbclen = tmp___3;
    }
#line 145
    if (outlen + mb_cur_max >= outalloc) {
      {
#line 147
      dm = (size_t )(m - len_map);
#line 148
      tmp___4 = x2nrealloc((void *)out, & outalloc, (size_t )1);
#line 148
      out = (char *)tmp___4;
#line 149
      tmp___5 = xrealloc((void *)len_map, outalloc);
#line 149
      len_map = (mb_len_map_t *)tmp___5;
#line 150
      p = out + outlen;
#line 151
      m = len_map + dm;
      }
    }
#line 154
    if (mbclen == 0xffffffffffffffffUL) {
#line 154
      goto _L___0;
    } else
#line 154
    if (mbclen == 0xfffffffffffffffeUL) {
#line 154
      goto _L___0;
    } else
#line 154
    if (mbclen == 0UL) {
      _L___0: /* CIL Label */
      {
#line 158
      tmp___6 = m;
#line 158
      m ++;
#line 158
      *tmp___6 = (mb_len_map_t )0;
#line 159
      tmp___7 = p;
#line 159
      p ++;
#line 159
      tmp___8 = beg;
#line 159
      beg ++;
#line 159
      *tmp___7 = (char )*tmp___8;
#line 160
      outlen ++;
#line 161
      memset((void *)(& is), 0, sizeof(is));
#line 162
      memset((void *)(& os), 0, sizeof(os));
      }
    } else {
      {
#line 167
      beg += mbclen;
#line 194
      tmp___9 = towupper((wint_t )wc);
#line 194
      ombclen = wcrtomb((char */* __restrict  */)p, (wchar_t )tmp___9, (mbstate_t */* __restrict  */)(& os));
#line 195
      *m = (mb_len_map_t )(mbclen - ombclen);
#line 196
      memset((void *)(m + 1), 0, ombclen - 1UL);
#line 197
      m += ombclen;
#line 198
      p += ombclen;
#line 199
      outlen += ombclen;
#line 200
      lengths_differ = (_Bool )((int )lengths_differ | (mbclen != ombclen));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (lengths_differ) {
#line 204
    *len_map_p = len_map;
  } else {
#line 204
    *len_map_p = (mb_len_map_t *)((void *)0);
  }
#line 205
  *n = (size_t )(p - out);
#line 206
  *p = (char)0;
#line 207
  return (out);
}
}
#line 211 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
void build_mbclen_cache(void)
{
  int i ;
  char c ;
  unsigned char uc ;
  mbstate_t mbs ;

  {
#line 216
  i = -128;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i <= 127)) {
#line 216
      goto while_break;
    }
    {
#line 218
    c = (char )i;
#line 219
    uc = (unsigned char )i;
#line 220
    mbs.__count = 0;
#line 220
    mbs.__value.__wch = 0U;
#line 221
    mbclen_cache[uc] = mbrlen((char const   */* __restrict  */)(& c), (size_t )1,
                              (mbstate_t */* __restrict  */)(& mbs));
#line 216
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 236 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end )
{
  char const   *p ;
  char const   *p0 ;
  mbstate_t cur_state ;
  size_t mbclen ;
  unsigned char tmp ;
  long tmp___0 ;

  {
  {
#line 239
  p = *mb_start;
#line 240
  p0 = p;
#line 243
  memset((void *)(& cur_state), 0, sizeof(cur_state));
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )p < (unsigned long )cur)) {
#line 245
      goto while_break;
    }
    {
#line 247
    tmp = to_uchar((char )*p);
#line 247
    mbclen = mbclen_cache[tmp];
    }
#line 249
    if (mbclen == 0xfffffffffffffffeUL) {
      {
#line 250
      mbclen = mbrlen((char const   */* __restrict  */)p, (size_t )(end - p), (mbstate_t */* __restrict  */)(& cur_state));
      }
    }
#line 252
    if (0UL < mbclen) {
#line 252
      if (! (mbclen < 0xfffffffffffffffeUL)) {
        {
#line 256
        mbclen = (size_t )1;
#line 257
        memset((void *)(& cur_state), 0, sizeof(cur_state));
        }
      }
    } else {
      {
#line 256
      mbclen = (size_t )1;
#line 257
      memset((void *)(& cur_state), 0, sizeof(cur_state));
      }
    }
#line 259
    p0 = p;
#line 260
    p += mbclen;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  *mb_start = p;
#line 264
  if ((unsigned long )p == (unsigned long )cur) {
#line 264
    tmp___0 = 0L;
  } else {
#line 264
    tmp___0 = cur - p0;
  }
#line 264
  return (tmp___0);
}
}
#line 270 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
wint_t mb_prev_wc(char const   *buf , char const   *cur , char const   *end )
{
  char const   *p ;
  ptrdiff_t tmp ;
  wint_t tmp___0 ;

  {
#line 273
  if ((unsigned long )cur == (unsigned long )buf) {
#line 274
    return (4294967295U);
  }
  {
#line 275
  p = buf;
#line 276
  cur --;
#line 277
  tmp = mb_goback(& p, cur, end);
#line 277
  cur -= tmp;
#line 278
  tmp___0 = mb_next_wc(cur, end);
  }
#line 278
  return (tmp___0);
}
}
#line 283 "/home/khheo/project/benchmark/grep-2.19/src/searchutils.c"
wint_t mb_next_wc(char const   *cur , char const   *end )
{
  wchar_t wc ;
  mbstate_t mbs ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;

  {
#line 287
  mbs.__count = 0;
#line 287
  mbs.__value.__wch = 0U;
#line 288
  if (end - cur != 0L) {
    {
#line 288
    tmp___1 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)cur,
                      (size_t )(end - cur), (mbstate_t */* __restrict  */)(& mbs));
    }
#line 288
    if (tmp___1 < 0xfffffffffffffffeUL) {
#line 288
      tmp___0 = (unsigned int )wc;
    } else {
#line 288
      tmp___0 = 4294967295U;
    }
  } else {
#line 288
    tmp___0 = 4294967295U;
  }
#line 288
  return (tmp___0);
}
}
#line 213 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 537
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 979 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 137 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1865
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 592 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc , char * const  *___argv ,
                                                            char const   *__shortopts ,
                                                            struct option  const  *__longopts ,
                                                            int *__longind ) ;
#line 25 "/home/khheo/project/benchmark/grep-2.19/src/grep.h"
int match_icase  ;
#line 26 "/home/khheo/project/benchmark/grep-2.19/src/grep.h"
int match_words  ;
#line 27 "/home/khheo/project/benchmark/grep-2.19/src/grep.h"
int match_lines  ;
#line 28 "/home/khheo/project/benchmark/grep-2.19/src/grep.h"
unsigned char eolbyte  ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 63 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct stat out_stat  ;
#line 66 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int show_help  ;
#line 69 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int show_version  ;
#line 72 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int suppress_errors  ;
#line 75 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int color_option  ;
#line 78 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int only_matching  ;
#line 81 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int align_tabs  ;
#line 84 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *group_separator  =    "--";
#line 131 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *selected_match_color  =    "01;31";
#line 132 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *context_match_color  =    "01;31";
#line 135 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *filename_color  =    "35";
#line 136 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *line_num_color  =    "32";
#line 137 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *byte_num_color  =    "32";
#line 138 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *sep_color  =    "36";
#line 139 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *selected_line_color  =    "";
#line 140 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *context_line_color  =    "";
#line 199 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *sgr_start  =    "\033[%sm\033[K";
#line 200 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *sgr_end  =    "\033[m\033[K";
#line 203 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void pr_sgr_start(char const   *s )
{


  {
#line 206
  if (*s) {
    {
#line 207
    print_start_colorize(sgr_start, s);
    }
  }
#line 208
  return;
}
}
#line 209 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void pr_sgr_end(char const   *s )
{


  {
#line 212
  if (*s) {
    {
#line 213
    print_end_colorize(sgr_end);
    }
  }
#line 214
  return;
}
}
#line 215 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void pr_sgr_start_if(char const   *s )
{


  {
#line 218
  if (color_option) {
    {
#line 219
    pr_sgr_start(s);
    }
  }
#line 220
  return;
}
}
#line 221 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void pr_sgr_end_if(char const   *s )
{


  {
#line 224
  if (color_option) {
    {
#line 225
    pr_sgr_end(s);
    }
  }
#line 226
  return;
}
}
#line 235 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void color_cap_mt_fct(void)
{


  {
#line 239
  context_match_color = selected_match_color;
#line 240
  return;
}
}
#line 242 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void color_cap_rv_fct(void)
{


  {
#line 246
  color_option = -1;
#line 247
  return;
}
}
#line 249 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void color_cap_ne_fct(void)
{


  {
#line 252
  sgr_start = "\033[%sm";
#line 253
  sgr_end = "\033[m";
#line 254
  return;
}
}
#line 257 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct color_cap  const  color_dict[12]  =
#line 257
  {      {"mt", & selected_match_color, & color_cap_mt_fct},
        {"ms", & selected_match_color, (void (*)(void))((void *)0)},
        {"mc", & context_match_color, (void (*)(void))((void *)0)},
        {"fn", & filename_color, (void (*)(void))((void *)0)},
        {"ln", & line_num_color, (void (*)(void))((void *)0)},
        {"bn", & byte_num_color, (void (*)(void))((void *)0)},
        {"se", & sep_color, (void (*)(void))((void *)0)},
        {"sl", & selected_line_color, (void (*)(void))((void *)0)},
        {"cx", & context_line_color, (void (*)(void))((void *)0)},
        {"rv", (char const   **)((void *)0), & color_cap_rv_fct},
        {"ne", (char const   **)((void *)0), & color_cap_ne_fct},
        {(char const   *)((void *)0), (char const   **)((void *)0), (void (*)(void))((void *)0)}};
#line 273 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct exclude *excluded_patterns  ;
#line 274 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct exclude *excluded_directory_patterns  ;
#line 276 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   short_options[58]  =
#line 276
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3',
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7',
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':',
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':',
        (char const   )'D',      (char const   )':',      (char const   )'E',      (char const   )'F',
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'P',
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'X',
        (char const   )':',      (char const   )'a',      (char const   )'b',      (char const   )'c',
        (char const   )'d',      (char const   )':',      (char const   )'e',      (char const   )':',
        (char const   )'f',      (char const   )':',      (char const   )'h',      (char const   )'i',
        (char const   )'L',      (char const   )'l',      (char const   )'m',      (char const   )':',
        (char const   )'n',      (char const   )'o',      (char const   )'q',      (char const   )'R',
        (char const   )'r',      (char const   )'s',      (char const   )'u',      (char const   )'v',
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'Z',
        (char const   )'z',      (char const   )'\000'};
#line 294 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct option  const  long_options[50]  =
#line 294
  {      {"basic-regexp", 0, (int *)((void *)0), 'G'},
        {"extended-regexp", 0, (int *)((void *)0), 'E'},
        {"fixed-regexp", 0, (int *)((void *)0), 'F'},
        {"fixed-strings", 0, (int *)((void *)0), 'F'},
        {"perl-regexp", 0, (int *)((void *)0), 'P'},
        {"after-context", 1, (int *)((void *)0), 'A'},
        {"before-context", 1, (int *)((void *)0), 'B'},
        {"binary-files", 1, (int *)((void *)0), 128},
        {"byte-offset", 0, (int *)((void *)0), 'b'},
        {"context", 1, (int *)((void *)0), 'C'},
        {"color", 2, (int *)((void *)0), 129},
        {"colour", 2, (int *)((void *)0), 129},
        {"count", 0, (int *)((void *)0), 'c'},
        {"devices", 1, (int *)((void *)0), 'D'},
        {"directories", 1, (int *)((void *)0), 'd'},
        {"exclude", 1, (int *)((void *)0), 131},
        {"exclude-from", 1, (int *)((void *)0), 132},
        {"exclude-dir", 1, (int *)((void *)0), 135},
        {"file", 1, (int *)((void *)0), 'f'},
        {"files-with-matches", 0, (int *)((void *)0), 'l'},
        {"files-without-match", 0, (int *)((void *)0), 'L'},
        {"group-separator", 1, (int *)((void *)0), 136},
        {"help", 0, & show_help, 1},
        {"include", 1, (int *)((void *)0), 130},
        {"ignore-case", 0, (int *)((void *)0), 'i'},
        {"initial-tab", 0, (int *)((void *)0), 'T'},
        {"label", 1, (int *)((void *)0), 134},
        {"line-buffered", 0, (int *)((void *)0), 133},
        {"line-number", 0, (int *)((void *)0), 'n'},
        {"line-regexp", 0, (int *)((void *)0), 'x'},
        {"max-count", 1, (int *)((void *)0), 'm'},
        {"no-filename", 0, (int *)((void *)0), 'h'},
        {"no-group-separator", 0, (int *)((void *)0), 136},
        {"no-messages", 0, (int *)((void *)0), 's'},
        {"null", 0, (int *)((void *)0), 'Z'},
        {"null-data", 0, (int *)((void *)0), 'z'},
        {"only-matching", 0, (int *)((void *)0), 'o'},
        {"quiet", 0, (int *)((void *)0), 'q'},
        {"recursive", 0, (int *)((void *)0), 'r'},
        {"dereference-recursive", 0, (int *)((void *)0), 'R'},
        {"regexp", 1, (int *)((void *)0), 'e'},
        {"invert-match", 0, (int *)((void *)0), 'v'},
        {"silent", 0, (int *)((void *)0), 'q'},
        {"text", 0, (int *)((void *)0), 'a'},
        {"binary", 0, (int *)((void *)0), 'U'},
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'},
        {"version", 0, (int *)((void *)0), 'V'},
        {"with-filename", 0, (int *)((void *)0), 'H'},
        {"word-regexp", 0, (int *)((void *)0), 'w'},
        {(char const   *)0, 0, (int *)0, 0}};
#line 355 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *matcher  ;
#line 359 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *filename  ;
#line 360 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t filename_prefix_len  ;
#line 361 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int errseen  ;
#line 362 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int write_error_seen  ;
#line 372 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   * const  directories_args[4]  = {      (char const   */* const  */)"read",      (char const   */* const  */)"recurse",      (char const   */* const  */)"skip",      (char const   */* const  */)((void *)0)};
#line 376 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static enum directories_type  const  directories_types[3]  = {      (enum directories_type  const  )2,      (enum directories_type  const  )3,      (enum directories_type  const  )4};
#line 382 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static enum directories_type directories  =    (enum directories_type )2;
#line 385 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int fts_options  =    793;
#line 388 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static enum __anonenum_devices_473526324 devices  =    (enum __anonenum_devices_473526324 )0;
#line 395
static int grepfile(int dirdesc , char const   *name , int follow , int command_line ) ;
#line 396
static int grepdesc(int desc , int command_line ) ;
#line 398
static void dos_binary(void) ;
#line 399
static void dos_unix_byte_offsets(void) ;
#line 400
static int undossify_input(char *buf , size_t buflen ) ;
#line 402 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int is_device_mode(mode_t m )
{
  int tmp ;

  {
#line 405
  if ((m & 61440U) == 8192U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 24576U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 49152U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 4096U) {
#line 405
    tmp = 1;
  } else {
#line 405
    tmp = 0;
  }
#line 405
  return (tmp);
}
}
#line 410 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int usable_st_size(struct stat  const  *st )
{
  int tmp ;

  {
#line 413
  if ((st->st_mode & 61440U) == 32768U) {
#line 413
    tmp = 1;
  } else
#line 413
  if (st->st_mode - st->st_mode) {
#line 413
    tmp = 1;
  } else {
#line 413
    tmp = 0;
  }
#line 413
  return (tmp);
}
}
#line 419 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void (*compile)(char const   * , size_t  )  ;
#line 420 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t (*execute)(char const   * , size_t  , size_t * , char const   * )  ;
#line 423 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void suppressible_error(char const   *mesg , int errnum )
{


  {
#line 426
  if (! suppress_errors) {
    {
#line 427
    error(0, errnum, "%s", mesg);
    }
  }
#line 428
  errseen = 1;
#line 429
  return;
}
}
#line 433 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void clean_up_stdout(void)
{


  {
#line 436
  if (! write_error_seen) {
    {
#line 437
    close_stdout();
    }
  }
#line 438
  return;
}
}
#line 443 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int file_is_binary(char const   *buf , size_t bufsize , int fd , struct stat  const  *st )
{
  void *tmp ;
  void *tmp___0 ;
  off_t cur ;
  off_t hole_start ;
  __off_t tmp___1 ;
  int *tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;

  {
#line 452
  if (! eolbyte) {
    {
#line 453
    tmp = memchr((void const   *)buf, '\200', bufsize);
    }
#line 453
    return ((unsigned long )tmp != (unsigned long )((void *)0));
  }
  {
#line 457
  tmp___0 = memchr((void const   *)buf, '\000', bufsize);
  }
#line 457
  if (tmp___0) {
#line 458
    return (1);
  }
  {
#line 461
  tmp___4 = usable_st_size(st);
  }
#line 461
  if (tmp___4) {
#line 463
    cur = (off_t )bufsize;
#line 464
    if (fd == 0) {
      {
#line 466
      cur = lseek(fd, (__off_t )0, 1);
      }
#line 467
      if (cur < 0L) {
#line 468
        return (0);
      }
    }
    {
#line 472
    tmp___1 = lseek(fd, cur, 4);
#line 472
    hole_start = tmp___1;
    }
#line 473
    if (0L <= hole_start) {
      {
#line 475
      tmp___3 = lseek(fd, cur, 0);
      }
#line 475
      if (tmp___3 < 0L) {
        {
#line 476
        tmp___2 = __errno_location();
#line 476
        suppressible_error(filename, *tmp___2);
        }
      }
#line 477
      if (hole_start < (off_t )st->st_size) {
#line 478
        return (1);
      }
    }
  }
#line 483
  return (0);
}
}
#line 490 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void context_length_arg(char const   *str , intmax_t *out___0 )
{
  strtol_error tmp ;
  char *tmp___0 ;

  {
  {
#line 493
  tmp = xstrtoimax(str, (char **)0, 10, out___0, "");
  }
  {
#line 496
  if ((unsigned int )tmp == 1U) {
#line 496
    goto case_1;
  }
#line 496
  if ((unsigned int )tmp == 0U) {
#line 496
    goto case_1;
  }
#line 500
  goto switch_default;
  case_1: /* CIL Label */
  case_0: /* CIL Label */
#line 497
  if (0L <= *out___0) {
#line 498
    goto switch_break;
  }
  switch_default: /* CIL Label */
  {
#line 501
  tmp___0 = gettext("invalid context length argument");
#line 501
  error(2, 0, "%s: %s", str, tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 504
  return;
}
}
#line 509 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int skipped_file(char const   *name , int command_line , int is_dir )
{
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 512
  if (is_dir) {
#line 512
    if ((unsigned int )directories == 4U) {
#line 512
      tmp___0 = 1;
    } else
#line 512
    if (command_line) {
#line 512
      if (filename_prefix_len != 0UL) {
#line 512
        tmp___0 = 0;
      } else {
#line 512
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 512
    if (excluded_directory_patterns) {
      {
#line 512
      tmp = excluded_file_name((struct exclude  const  *)excluded_directory_patterns,
                               name);
      }
#line 512
      if (tmp) {
#line 512
        tmp___0 = 1;
      } else {
#line 512
        tmp___0 = 0;
      }
    } else {
#line 512
      tmp___0 = 0;
    }
#line 512
    tmp___3 = tmp___0;
  } else {
#line 512
    if (excluded_patterns) {
      {
#line 512
      tmp___1 = excluded_file_name((struct exclude  const  *)excluded_patterns, name);
      }
#line 512
      if (tmp___1) {
#line 512
        tmp___2 = 1;
      } else {
#line 512
        tmp___2 = 0;
      }
    } else {
#line 512
      tmp___2 = 0;
    }
#line 512
    tmp___3 = tmp___2;
  }
#line 512
  return (tmp___3);
}
}
#line 525 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char *buffer  ;
#line 526 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t bufalloc  ;
#line 528 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int bufdesc  ;
#line 529 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char *bufbeg  ;
#line 530 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char *buflim  ;
#line 531 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t pagesize  ;
#line 532 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static off_t bufoffset  ;
#line 533 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static off_t after_last_match  ;
#line 546 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int reset(int fd , struct stat  const  *st )
{
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 549
  if (! pagesize) {
    {
#line 551
    tmp = getpagesize();
#line 551
    pagesize = (size_t )tmp;
    }
#line 552
    if (pagesize == 0UL) {
      {
#line 553
      abort();
      }
    } else
#line 552
    if (2UL * pagesize + 1UL <= pagesize) {
      {
#line 553
      abort();
      }
    }
#line 554
    if (32768UL % pagesize == 0UL) {
#line 554
      tmp___0 = (size_t )32768;
    } else {
#line 554
      tmp___0 = 32768UL + (pagesize - 32768UL % pagesize);
    }
    {
#line 554
    bufalloc = (tmp___0 + pagesize) + 1UL;
#line 555
    tmp___1 = xmalloc(bufalloc);
#line 555
    buffer = (char *)tmp___1;
    }
  }
#line 558
  if ((size_t )(buffer + 1) % pagesize == 0UL) {
#line 558
    buflim = buffer + 1;
  } else {
#line 558
    buflim = (buffer + 1) + (pagesize - (size_t )(buffer + 1) % pagesize);
  }
#line 558
  bufbeg = buflim;
#line 559
  *(bufbeg + -1) = (char )eolbyte;
#line 560
  bufdesc = fd;
#line 562
  if ((st->st_mode & 61440U) == 32768U) {
#line 564
    if (fd != 0) {
#line 565
      bufoffset = (off_t )0;
    } else {
      {
#line 568
      bufoffset = lseek(fd, (__off_t )0, 1);
      }
#line 569
      if (bufoffset < 0L) {
        {
#line 571
        tmp___2 = __errno_location();
#line 571
        tmp___3 = gettext("lseek failed");
#line 571
        suppressible_error((char const   *)tmp___3, *tmp___2);
        }
#line 572
        return (0);
      }
    }
  }
#line 576
  return (1);
}
}
#line 583 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int fillbuf(size_t save , struct stat  const  *st )
{
  ssize_t fillsize ;
  int cc ;
  char *readbuf ;
  size_t readsize ;
  size_t saved_offset ;
  size_t minsize ;
  size_t newsize ;
  size_t newalloc ;
  char *newbuf ;
  off_t to_be_read ;
  off_t maxsize_off ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 587
  cc = 1;
#line 593
  saved_offset = (size_t )((buflim - save) - buffer);
#line 595
  if (pagesize <= (size_t )((buffer + bufalloc) - buflim)) {
#line 597
    readbuf = buflim;
#line 598
    bufbeg = buflim - save;
  } else {
#line 602
    minsize = save + pagesize;
#line 608
    newsize = (bufalloc - pagesize) - 1UL;
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 608
      if (! (newsize < minsize)) {
#line 608
        goto while_break;
      }
#line 609
      if (newsize * 2UL < newsize) {
        {
#line 610
        xalloc_die();
        }
      } else
#line 609
      if ((newsize * 2UL + pagesize) + 1UL < newsize * 2UL) {
        {
#line 610
        xalloc_die();
        }
      }
#line 608
      newsize *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 617
    tmp = usable_st_size(st);
    }
#line 617
    if (tmp) {
#line 619
      to_be_read = (off_t )(st->st_size - (__off_t const   )bufoffset);
#line 620
      maxsize_off = (off_t )(save + (size_t )to_be_read);
#line 621
      if (0L <= to_be_read) {
#line 621
        if (to_be_read <= maxsize_off) {
#line 621
          if ((size_t )maxsize_off == (size_t )maxsize_off) {
#line 621
            if (minsize <= (size_t )maxsize_off) {
#line 621
              if ((size_t )maxsize_off < newsize) {
#line 625
                newsize = (size_t )maxsize_off;
              }
            }
          }
        }
      }
    }
#line 630
    newalloc = (newsize + pagesize) + 1UL;
#line 632
    if (bufalloc < newalloc) {
      {
#line 632
      bufalloc = newalloc;
#line 632
      tmp___0 = xmalloc(bufalloc);
#line 632
      newbuf = (char *)tmp___0;
      }
    } else {
#line 632
      newbuf = buffer;
    }
#line 633
    if ((size_t )((newbuf + 1) + save) % pagesize == 0UL) {
#line 633
      readbuf = (newbuf + 1) + save;
    } else {
#line 633
      readbuf = ((newbuf + 1) + save) + (pagesize - (size_t )((newbuf + 1) + save) % pagesize);
    }
    {
#line 634
    bufbeg = readbuf - save;
#line 635
    memmove((void *)bufbeg, (void const   *)(buffer + saved_offset), save);
#line 636
    *(bufbeg + -1) = (char )eolbyte;
    }
#line 637
    if ((unsigned long )newbuf != (unsigned long )buffer) {
      {
#line 639
      free((void *)buffer);
#line 640
      buffer = newbuf;
      }
    }
  }
  {
#line 644
  readsize = (size_t )((buffer + bufalloc) - readbuf);
#line 645
  readsize -= readsize % pagesize;
#line 647
  tmp___1 = safe_read(bufdesc, (void *)readbuf, readsize);
#line 647
  fillsize = (ssize_t )tmp___1;
  }
#line 648
  if (fillsize < 0L) {
#line 649
    cc = 0;
#line 649
    fillsize = (ssize_t )cc;
  }
  {
#line 650
  bufoffset += fillsize;
#line 651
  tmp___2 = undossify_input(readbuf, (size_t )fillsize);
#line 651
  fillsize = (ssize_t )tmp___2;
#line 652
  buflim = readbuf + fillsize;
  }
#line 653
  return (cc);
}
}
#line 657 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static enum __anonenum_binary_files_601436154 binary_files  ;
#line 664 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int filename_mask  ;
#line 665 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int out_quiet  ;
#line 666 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static _Bool out_invert  ;
#line 667 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int out_file  ;
#line 668 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int out_line  ;
#line 669 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int out_byte  ;
#line 670 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t out_before  ;
#line 671 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t out_after  ;
#line 672 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int count_matches  ;
#line 673 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int list_files  ;
#line 674 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int no_filenames  ;
#line 675 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t max_count  ;
#line 677 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int line_buffered  ;
#line 679 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char *label  =    (char *)((void *)0);
#line 683 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static uintmax_t totalcc  ;
#line 684 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *lastnl  ;
#line 685 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *lastout  ;
#line 688 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static uintmax_t totalnl  ;
#line 689 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t outleft  ;
#line 690 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t pending  ;
#line 692 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int done_on_match  ;
#line 693 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int exit_on_match  ;
#line 42 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int dos_report_unix_offset  =    0;
#line 44 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static File_type dos_file_type  =    (File_type )0;
#line 45 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static File_type dos_use_file_type  =    (File_type )0;
#line 46 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static off_t dos_stripped_crs  =    (off_t )0;
#line 47 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static struct dos_map *dos_pos_map  ;
#line 48 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int dos_pos_map_size  =    0;
#line 49 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int dos_pos_map_used  =    0;
#line 50 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int inp_map_idx  =    0;
#line 50 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int out_map_idx  =    1;
#line 53 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static void dos_binary(void)
{


  {
#line 58
  return;
}
}
#line 61 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static void dos_unix_byte_offsets(void)
{


  {
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static File_type guess_type(char *buf , size_t buflen )
{
  int crlf_seen ;
  char *bp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 72
  crlf_seen = 0;
#line 73
  bp = buf;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    tmp = buflen;
#line 75
    buflen --;
#line 75
    if (! tmp) {
#line 75
      goto while_break;
    }
#line 78
    if (! *bp) {
#line 79
      return ((File_type )1);
    } else
#line 83
    if ((int )*bp == 13) {
#line 83
      if (buflen) {
#line 83
        if ((int )*(bp + 1) == 10) {
#line 84
          crlf_seen = 1;
        }
      }
    }
#line 86
    bp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  if (crlf_seen) {
#line 89
    tmp___0 = 2;
  } else {
#line 89
    tmp___0 = 3;
  }
#line 89
  return ((File_type )tmp___0);
}
}
#line 95 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static int undossify_input(char *buf , size_t buflen )
{
  int chars_left ;
  char *destp ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 99
  return ((int )buflen);
#line 101
  chars_left = 0;
#line 103
  if (totalcc == 0UL) {
#line 107
    inp_map_idx = 0;
#line 108
    out_map_idx = 1;
#line 109
    dos_pos_map_used = 0;
#line 110
    dos_stripped_crs = (off_t )0;
#line 111
    dos_file_type = dos_use_file_type;
  }
#line 115
  if ((unsigned int )dos_file_type == 0U) {
    {
#line 116
    dos_file_type = guess_type(buf, buflen);
    }
  }
#line 120
  if ((unsigned int )dos_file_type == 2U) {
#line 122
    destp = buf;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      tmp___4 = buflen;
#line 124
      buflen --;
#line 124
      if (! tmp___4) {
#line 124
        goto while_break;
      }
#line 126
      if ((int )*buf != 13) {
#line 128
        tmp = destp;
#line 128
        destp ++;
#line 128
        tmp___0 = buf;
#line 128
        buf ++;
#line 128
        *tmp = *tmp___0;
#line 129
        chars_left ++;
      } else {
#line 133
        buf ++;
#line 134
        if (out_byte) {
#line 134
          if (! dos_report_unix_offset) {
#line 136
            dos_stripped_crs ++;
            {
#line 137
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 137
              if (buflen) {
#line 137
                if (! ((int )*buf == 13)) {
#line 137
                  goto while_break___0;
                }
              } else {
#line 137
                goto while_break___0;
              }
#line 139
              dos_stripped_crs ++;
#line 140
              buflen --;
#line 141
              buf ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 143
            if (inp_map_idx >= dos_pos_map_size - 1) {
#line 145
              if (inp_map_idx) {
#line 145
                dos_pos_map_size = inp_map_idx * 2;
              } else {
#line 145
                dos_pos_map_size = 1000;
              }
              {
#line 146
              tmp___1 = xrealloc((void *)dos_pos_map, (unsigned long )dos_pos_map_size * sizeof(struct dos_map ));
#line 146
              dos_pos_map = (struct dos_map *)tmp___1;
              }
            }
#line 151
            if (! inp_map_idx) {
#line 154
              (dos_pos_map + inp_map_idx)->pos = (off_t )0;
#line 155
              tmp___2 = inp_map_idx;
#line 155
              inp_map_idx ++;
#line 155
              (dos_pos_map + tmp___2)->add = (off_t )0;
#line 158
              (dos_pos_map + inp_map_idx)->add = (off_t )0;
            }
#line 167
            inp_map_idx ++;
#line 168
            if ((int )*buf == 10) {
#line 168
              tmp___3 = destp + 1;
            } else {
#line 168
              tmp___3 = destp;
            }
#line 168
            (dos_pos_map + (inp_map_idx - 1))->pos = (off_t )((uintmax_t )(tmp___3 - bufbeg) + totalcc);
#line 170
            (dos_pos_map + inp_map_idx)->add = dos_stripped_crs;
#line 171
            dos_pos_map_used = inp_map_idx;
#line 174
            (dos_pos_map + inp_map_idx)->pos = (off_t )(((uintmax_t )(destp - bufbeg) + totalcc) + 1UL);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 179
    return (chars_left);
  }
#line 182
  return ((int )buflen);
}
}
#line 186 "/home/khheo/project/benchmark/grep-2.19/src/dosbuf.c"
static off_t dossified_pos(off_t byteno )
{
  off_t pos_lo ;
  off_t pos_hi ;

  {
#line 190
  return (byteno);
#line 195
  if ((unsigned int )dos_file_type != 2U) {
#line 196
    return (byteno);
  } else
#line 195
  if (dos_report_unix_offset) {
#line 196
    return (byteno);
  }
#line 201
  pos_lo = (dos_pos_map + (out_map_idx - 1))->pos;
#line 202
  pos_hi = (dos_pos_map + out_map_idx)->pos;
#line 206
  if (byteno >= pos_hi) {
#line 208
    out_map_idx ++;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      if (out_map_idx < dos_pos_map_used) {
#line 209
        if (! (byteno >= (dos_pos_map + out_map_idx)->pos)) {
#line 209
          goto while_break;
        }
      } else {
#line 209
        goto while_break;
      }
#line 211
      out_map_idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 214
  if (byteno < pos_lo) {
#line 216
    out_map_idx --;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (out_map_idx > 1) {
#line 217
        if (! (byteno < (dos_pos_map + (out_map_idx - 1))->pos)) {
#line 217
          goto while_break___0;
        }
      } else {
#line 217
        goto while_break___0;
      }
#line 218
      out_map_idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 221
  return (byteno + (dos_pos_map + out_map_idx)->add);
}
}
#line 699 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static uintmax_t add_count(uintmax_t a , uintmax_t b )
{
  uintmax_t sum ;
  char *tmp ;

  {
#line 702
  sum = a + b;
#line 703
  if (sum < a) {
    {
#line 704
    tmp = gettext("input is too large to count");
#line 704
    error(2, 0, (char const   *)tmp);
    }
  }
#line 705
  return (sum);
}
}
#line 708 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void nlscan(char const   *lim )
{
  size_t newlines ;
  char const   *beg ;
  void *tmp ;

  {
#line 711
  newlines = (size_t )0;
#line 713
  beg = lastnl;
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! ((unsigned long )beg < (unsigned long )lim)) {
#line 713
      goto while_break;
    }
    {
#line 715
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
#line 715
    beg = (char const   *)tmp;
    }
#line 716
    if (! beg) {
#line 717
      goto while_break;
    }
#line 718
    newlines ++;
#line 713
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 720
  totalnl = add_count(totalnl, newlines);
#line 721
  lastnl = lim;
  }
#line 722
  return;
}
}
#line 725 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void print_filename(void)
{


  {
  {
#line 728
  pr_sgr_start_if(filename_color);
#line 729
  fputs_unlocked((char const   */* __restrict  */)filename, (FILE */* __restrict  */)stdout);
#line 730
  pr_sgr_end_if(filename_color);
  }
#line 731
  return;
}
}
#line 734 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void print_sep(char sep )
{


  {
  {
#line 737
  pr_sgr_start_if(sep_color);
#line 738
  fputc_unlocked((int )sep, stdout);
#line 739
  pr_sgr_end_if(sep_color);
  }
#line 740
  return;
}
}
#line 743 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void print_offset(uintmax_t pos , int min_width , char const   *color )
{
  char buf[sizeof(pos) * 8UL] ;
  char *p ;

  {
#line 750
  p = buf + sizeof(buf);
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    p --;
#line 754
    *p = (char )(48UL + pos % 10UL);
#line 755
    min_width --;
#line 752
    pos /= 10UL;
#line 752
    if (! (pos != 0UL)) {
#line 752
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if (align_tabs) {
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 761
      min_width --;
#line 761
      if (! (min_width >= 0)) {
#line 761
        goto while_break___0;
      }
#line 762
      p --;
#line 762
      *p = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 764
  pr_sgr_start_if(color);
#line 765
  fwrite_unlocked((void const   */* __restrict  */)p, (size_t )1, (size_t )((buf + sizeof(buf)) - p),
                  (FILE */* __restrict  */)stdout);
#line 766
  pr_sgr_end_if(color);
  }
#line 767
  return;
}
}
#line 770 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void print_line_head(char const   *beg , char const   *lim , int sep )
{
  int pending_sep ;
  uintmax_t pos ;
  uintmax_t tmp ;
  off_t tmp___0 ;

  {
#line 773
  pending_sep = 0;
#line 775
  if (out_file) {
    {
#line 777
    print_filename();
    }
#line 778
    if (filename_mask) {
#line 779
      pending_sep = 1;
    } else {
      {
#line 781
      fputc_unlocked(0, stdout);
      }
    }
  }
#line 784
  if (out_line) {
#line 786
    if ((unsigned long )lastnl < (unsigned long )lim) {
      {
#line 788
      nlscan(beg);
#line 789
      totalnl = add_count(totalnl, (uintmax_t )1);
#line 790
      lastnl = lim;
      }
    }
#line 792
    if (pending_sep) {
      {
#line 793
      print_sep((char )sep);
      }
    }
    {
#line 794
    print_offset(totalnl, 4, line_num_color);
#line 795
    pending_sep = 1;
    }
  }
#line 798
  if (out_byte) {
    {
#line 800
    tmp = add_count(totalcc, (uintmax_t )(beg - (char const   *)bufbeg));
#line 800
    pos = tmp;
#line 801
    tmp___0 = dossified_pos((off_t )pos);
#line 801
    pos = (uintmax_t )tmp___0;
    }
#line 802
    if (pending_sep) {
      {
#line 803
      print_sep((char )sep);
      }
    }
    {
#line 804
    print_offset(pos, 6, byte_num_color);
#line 805
    pending_sep = 1;
    }
  }
#line 808
  if (pending_sep) {
#line 814
    if (align_tabs) {
      {
#line 815
      fputs_unlocked((char const   */* __restrict  */)"\t\b", (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 817
    print_sep((char )sep);
    }
  }
#line 819
  return;
}
}
#line 821 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *print_line_middle(char const   *beg , char const   *lim , char const   *line_color ,
                                       char const   *match_color )
{
  size_t match_size ;
  size_t match_offset ;
  char const   *cur ;
  char const   *mid ;
  char const   *b ;
  int tmp ;

  {
#line 827
  cur = beg;
#line 828
  mid = (char const   *)((void *)0);
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if ((unsigned long )cur < (unsigned long )lim) {
      {
#line 830
      match_offset = (*execute)(beg, (size_t )(lim - beg), & match_size, beg + (cur - beg));
      }
#line 830
      if (! (match_offset != 0xffffffffffffffffUL)) {
#line 830
        goto while_break;
      }
    } else {
#line 830
      goto while_break;
    }
#line 834
    b = beg + match_offset;
#line 837
    if ((unsigned long )b == (unsigned long )lim) {
#line 838
      goto while_break;
    }
#line 841
    if (match_size == 0UL) {
#line 845
      match_size = (size_t )1;
#line 846
      if (! mid) {
#line 847
        mid = cur;
      }
    } else {
#line 853
      if (only_matching) {
#line 854
        if (out_invert) {
#line 854
          tmp = '-';
        } else {
#line 854
          tmp = ':';
        }
        {
#line 854
        print_line_head(b, lim, tmp);
        }
      } else {
        {
#line 858
        pr_sgr_start(line_color);
        }
#line 859
        if (mid) {
#line 861
          cur = mid;
#line 862
          mid = (char const   *)((void *)0);
        }
        {
#line 864
        fwrite_unlocked((void const   */* __restrict  */)cur, sizeof(char ), (size_t )(b - cur),
                        (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 867
      pr_sgr_start_if(match_color);
#line 868
      fwrite_unlocked((void const   */* __restrict  */)b, sizeof(char ), match_size,
                      (FILE */* __restrict  */)stdout);
#line 869
      pr_sgr_end_if(match_color);
      }
#line 870
      if (only_matching) {
        {
#line 871
        fputs_unlocked((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
        }
      }
    }
#line 873
    cur = b + match_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  if (only_matching) {
#line 877
    cur = lim;
  } else
#line 878
  if (mid) {
#line 879
    cur = mid;
  }
#line 881
  return (cur);
}
}
#line 884 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static char const   *print_line_tail(char const   *beg , char const   *lim , char const   *line_color )
{
  size_t eol_size ;
  size_t tail_size ;
  int tmp ;
  int tmp___0 ;

  {
#line 890
  if ((unsigned long )lim > (unsigned long )beg) {
#line 890
    if ((int const   )*(lim + -1) == (int const   )eolbyte) {
#line 890
      tmp = 1;
    } else {
#line 890
      tmp = 0;
    }
  } else {
#line 890
    tmp = 0;
  }
#line 890
  eol_size = (size_t )tmp;
#line 891
  if ((unsigned long )(lim - eol_size) > (unsigned long )beg) {
#line 891
    if ((int const   )*(lim + - (1UL + eol_size)) == 13) {
#line 891
      tmp___0 = 1;
    } else {
#line 891
      tmp___0 = 0;
    }
  } else {
#line 891
    tmp___0 = 0;
  }
#line 891
  eol_size += (size_t )tmp___0;
#line 892
  tail_size = (size_t )((lim - eol_size) - beg);
#line 894
  if (tail_size > 0UL) {
    {
#line 896
    pr_sgr_start(line_color);
#line 897
    fwrite_unlocked((void const   */* __restrict  */)beg, (size_t )1, tail_size, (FILE */* __restrict  */)stdout);
#line 898
    beg += tail_size;
#line 899
    pr_sgr_end(line_color);
    }
  }
#line 902
  return (beg);
}
}
#line 905 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void prline(char const   *beg , char const   *lim , int sep )
{
  int matching ;
  char const   *line_color ;
  char const   *match_color ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 912
  if (! only_matching) {
    {
#line 913
    print_line_head(beg, lim, sep);
    }
  }
#line 915
  matching = (sep == 58) ^ (int )out_invert;
#line 917
  if (color_option) {
#line 919
    if (out_invert) {
#line 919
      if (color_option < 0) {
#line 919
        tmp___0 = 1;
      } else {
#line 919
        tmp___0 = 0;
      }
    } else {
#line 919
      tmp___0 = 0;
    }
#line 919
    if ((sep == 58) ^ tmp___0) {
#line 919
      line_color = selected_line_color;
    } else {
#line 919
      line_color = context_line_color;
    }
#line 922
    if (sep == 58) {
#line 922
      match_color = selected_match_color;
    } else {
#line 922
      match_color = context_match_color;
    }
  } else {
#line 926
    match_color = (char const   *)((void *)0);
#line 926
    line_color = match_color;
  }
#line 928
  if (only_matching) {
#line 928
    if (matching) {
#line 928
      goto _L___0;
    } else {
#line 928
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
#line 928
  if (color_option) {
#line 928
    if (*line_color) {
#line 928
      goto _L___0;
    } else
#line 928
    if (*match_color) {
      _L___0: /* CIL Label */
#line 932
      if (matching) {
#line 932
        if (only_matching) {
          {
#line 933
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
        } else
#line 932
        if (*match_color) {
          {
#line 933
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
        }
      }
#line 935
      if (! only_matching) {
#line 935
        if (*line_color) {
          {
#line 939
          beg = print_line_tail(beg, lim, line_color);
          }
        }
      }
    }
  }
#line 943
  if (! only_matching) {
#line 943
    if ((unsigned long )lim > (unsigned long )beg) {
      {
#line 944
      fwrite_unlocked((void const   */* __restrict  */)beg, (size_t )1, (size_t )(lim - beg),
                      (FILE */* __restrict  */)stdout);
      }
    }
  }
  {
#line 946
  tmp___2 = ferror_unlocked(stdout);
  }
#line 946
  if (tmp___2) {
    {
#line 948
    write_error_seen = 1;
#line 949
    tmp___1 = gettext("write error");
#line 949
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 952
  lastout = lim;
#line 954
  if (line_buffered) {
    {
#line 955
    fflush_unlocked(stdout);
    }
  }
#line 956
  return;
}
}
#line 960 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void prpending(char const   *lim )
{
  char const   *nl ;
  void *tmp ;
  size_t match_size ;
  size_t tmp___0 ;

  {
#line 963
  if (! lastout) {
#line 964
    lastout = (char const   *)bufbeg;
  }
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (pending > 0L) {
#line 965
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
#line 965
        goto while_break;
      }
    } else {
#line 965
      goto while_break;
    }
    {
#line 967
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - lastout));
#line 967
    nl = (char const   *)tmp;
#line 969
    pending --;
    }
#line 970
    if (outleft) {
      {
#line 974
      prline(lastout, nl + 1, '-');
      }
    } else {
      {
#line 970
      tmp___0 = (*execute)(lastout, (size_t )((nl + 1) - lastout), & match_size, (char const   *)((void *)0));
      }
#line 970
      if ((tmp___0 == 0xffffffffffffffffUL) == ! out_invert) {
        {
#line 974
        prline(lastout, nl + 1, '-');
        }
      } else {
#line 976
        pending = (intmax_t )0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 978
  return;
}
}
#line 984 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static _Bool used  ;
#line 981 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void prtext(char const   *beg , char const   *lim )
{
  char eol ;
  char const   *p ;
  char const   *bp ;
  char const   *tmp ;
  intmax_t i ;
  char const   *nl ;
  void *tmp___0 ;
  intmax_t n ;
  char const   *nl___0 ;
  void *tmp___1 ;

  {
#line 985
  eol = (char )eolbyte;
#line 987
  if (! out_quiet) {
#line 987
    if (pending > 0L) {
      {
#line 988
      prpending(beg);
      }
    }
  }
#line 990
  p = beg;
#line 992
  if (! out_quiet) {
#line 995
    if (lastout) {
#line 995
      tmp = lastout;
    } else {
#line 995
      tmp = (char const   *)bufbeg;
    }
#line 995
    bp = tmp;
#line 997
    i = (intmax_t )0;
    {
#line 997
    while (1) {
      while_continue: /* CIL Label */ ;
#line 997
      if (! (i < out_before)) {
#line 997
        goto while_break;
      }
#line 998
      if ((unsigned long )p > (unsigned long )bp) {
        {
#line 999
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1000
          p --;
#line 999
          if (! ((int const   )*(p + -1) != (int const   )eol)) {
#line 999
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 997
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1005
    if (0L <= out_before) {
#line 1005
      goto _L;
    } else
#line 1005
    if (0L <= out_after) {
      _L: /* CIL Label */
#line 1005
      if (used) {
#line 1005
        if ((unsigned long )p != (unsigned long )lastout) {
#line 1005
          if (group_separator) {
            {
#line 1008
            pr_sgr_start_if(sep_color);
#line 1009
            fputs_unlocked((char const   */* __restrict  */)group_separator, (FILE */* __restrict  */)stdout);
#line 1010
            pr_sgr_end_if(sep_color);
#line 1011
            fputc_unlocked('\n', stdout);
            }
          }
        }
      }
    }
    {
#line 1014
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )p < (unsigned long )beg)) {
#line 1014
        goto while_break___1;
      }
      {
#line 1016
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
#line 1016
      nl = (char const   *)tmp___0;
#line 1017
      nl ++;
#line 1018
      prline(p, nl, '-');
#line 1019
      p = nl;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1024
  if (out_invert) {
#line 1027
    n = (intmax_t )0;
    {
#line 1027
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1027
      if ((unsigned long )p < (unsigned long )lim) {
#line 1027
        if (! (n < outleft)) {
#line 1027
          goto while_break___2;
        }
      } else {
#line 1027
        goto while_break___2;
      }
      {
#line 1029
      tmp___1 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
#line 1029
      nl___0 = (char const   *)tmp___1;
#line 1030
      nl___0 ++;
      }
#line 1031
      if (! out_quiet) {
        {
#line 1032
        prline(p, nl___0, ':');
        }
      }
#line 1033
      p = nl___0;
#line 1027
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1039
    if (! out_quiet) {
      {
#line 1040
      prline(beg, lim, ':');
      }
    }
#line 1041
    n = (intmax_t )1;
#line 1042
    p = lim;
  }
#line 1045
  after_last_match = bufoffset - (buflim - (char *)p);
#line 1046
  if (out_quiet) {
#line 1046
    pending = (intmax_t )0;
  } else {
#line 1046
    pending = out_after;
  }
#line 1047
  used = (_Bool)1;
#line 1048
  outleft -= n;
#line 1049
  return;
}
}
#line 1054 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t do_execute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr )
{
  size_t result ;
  char const   *line_next ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *line_buf ;
  char const   *line_end ;
  void *tmp___1 ;

  {
#line 1073
  if ((unsigned long )execute == (unsigned long )(& Fexecute)) {
#line 1073
    goto _L;
  } else
#line 1073
  if ((unsigned long )execute == (unsigned long )(& Pexecute)) {
    _L: /* CIL Label */
    {
#line 1073
    tmp___0 = __ctype_get_mb_cur_max();
    }
#line 1073
    if (tmp___0 == 1UL) {
      {
#line 1075
      tmp = (*execute)(buf, size, match_size, start_ptr);
      }
#line 1075
      return (tmp);
    } else
#line 1073
    if (! match_icase) {
      {
#line 1075
      tmp = (*execute)(buf, size, match_size, start_ptr);
      }
#line 1075
      return (tmp);
    }
  } else {
    {
#line 1075
    tmp = (*execute)(buf, size, match_size, start_ptr);
    }
#line 1075
    return (tmp);
  }
#line 1077
  line_next = buf;
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1077
    if (! ((unsigned long )line_next < (unsigned long )(buf + size))) {
#line 1077
      goto while_break;
    }
    {
#line 1079
    line_buf = line_next;
#line 1080
    tmp___1 = memchr((void const   *)line_buf, (int )eolbyte, (size_t )((buf + size) - line_buf));
#line 1080
    line_end = (char const   *)tmp___1;
    }
#line 1082
    if ((unsigned long )line_end == (unsigned long )((void *)0)) {
#line 1083
      line_end = buf + size;
#line 1083
      line_next = line_end;
    } else {
#line 1085
      line_next = line_end + 1;
    }
#line 1087
    if (start_ptr) {
#line 1087
      if ((unsigned long )start_ptr >= (unsigned long )line_end) {
#line 1088
        goto __Cont;
      }
    }
    {
#line 1090
    result = (*execute)(line_buf, (size_t )(line_next - line_buf), match_size, start_ptr);
    }
#line 1091
    if (result != 0xffffffffffffffffUL) {
#line 1092
      return ((size_t )(line_buf - buf) + result);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return ((size_t )-1);
}
}
#line 1101 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t grepbuf(char const   *beg , char const   *lim )
{
  intmax_t outleft0 ;
  char const   *p ;
  char const   *endp ;
  size_t match_size ;
  size_t match_offset ;
  size_t tmp ;
  char const   *b ;
  char const   *prbeg ;
  char const   *tmp___0 ;
  char const   *prend ;
  char const   *tmp___1 ;

  {
#line 1104
  outleft0 = outleft;
#line 1108
  p = beg;
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 1108
      goto while_break;
    }
    {
#line 1111
    tmp = do_execute(p, (size_t )(lim - p), & match_size, (char const   *)((void *)0));
#line 1111
    match_offset = tmp;
    }
#line 1112
    if (match_offset == 0xffffffffffffffffUL) {
#line 1114
      if (! out_invert) {
#line 1115
        goto while_break;
      }
#line 1116
      match_offset = (size_t )(lim - p);
#line 1117
      match_size = (size_t )0;
    }
#line 1119
    b = p + match_offset;
#line 1120
    endp = b + match_size;
#line 1122
    if (! out_invert) {
#line 1122
      if ((unsigned long )b == (unsigned long )lim) {
#line 1123
        goto while_break;
      }
    }
#line 1124
    if (! out_invert) {
#line 1124
      goto _L___0;
    } else
#line 1124
    if ((unsigned long )p < (unsigned long )b) {
      _L___0: /* CIL Label */
#line 1126
      if (out_invert) {
#line 1126
        tmp___0 = p;
      } else {
#line 1126
        tmp___0 = b;
      }
#line 1126
      prbeg = tmp___0;
#line 1127
      if (out_invert) {
#line 1127
        tmp___1 = b;
      } else {
#line 1127
        tmp___1 = endp;
      }
      {
#line 1127
      prend = tmp___1;
#line 1128
      prtext(prbeg, prend);
      }
#line 1129
      if (! outleft) {
#line 1129
        goto _L;
      } else
#line 1129
      if (done_on_match) {
        _L: /* CIL Label */
#line 1131
        if (exit_on_match) {
          {
#line 1132
          exit(0);
          }
        }
#line 1133
        goto while_break;
      }
    }
#line 1108
    p = endp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1138
  return (outleft0 - outleft);
}
}
#line 1144 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static intmax_t grep(int fd , struct stat  const  *st )
{
  intmax_t nlines ;
  intmax_t i ;
  int not_text ;
  size_t residue ;
  size_t save ;
  char oldc ;
  char *beg ;
  char *lim ;
  char eol ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  intmax_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  intmax_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1153
  eol = (char )eolbyte;
#line 1155
  tmp = reset(fd, st);
  }
#line 1155
  if (! tmp) {
#line 1156
    return ((intmax_t )0);
  }
  {
#line 1158
  totalcc = (uintmax_t )0;
#line 1159
  lastout = (char const   *)0;
#line 1160
  totalnl = (uintmax_t )0;
#line 1161
  outleft = max_count;
#line 1162
  after_last_match = (off_t )0;
#line 1163
  pending = (intmax_t )0;
#line 1165
  nlines = (intmax_t )0;
#line 1166
  residue = (size_t )0;
#line 1167
  save = (size_t )0;
#line 1169
  tmp___1 = fillbuf(save, st);
  }
#line 1169
  if (! tmp___1) {
    {
#line 1171
    tmp___0 = __errno_location();
#line 1171
    suppressible_error(filename, *tmp___0);
    }
#line 1172
    return ((intmax_t )0);
  }
#line 1175
  if ((unsigned int )binary_files == 0U) {
#line 1175
    if (! out_quiet) {
#line 1175
      goto _L;
    } else {
#line 1175
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 1175
  if ((unsigned int )binary_files == 2U) {
    _L: /* CIL Label */
    {
#line 1175
    tmp___2 = file_is_binary((char const   *)bufbeg, (size_t )(buflim - bufbeg), fd,
                             st);
    }
#line 1175
    if (tmp___2) {
#line 1175
      tmp___3 = 1;
    } else {
#line 1175
      tmp___3 = 0;
    }
  } else {
#line 1175
    tmp___3 = 0;
  }
#line 1175
  not_text = tmp___3;
#line 1178
  if (not_text) {
#line 1178
    if ((unsigned int )binary_files == 2U) {
#line 1179
      return ((intmax_t )0);
    }
  }
#line 1180
  done_on_match += not_text;
#line 1181
  out_quiet += not_text;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    lastnl = (char const   *)bufbeg;
#line 1186
    if (lastout) {
#line 1187
      lastout = (char const   *)bufbeg;
    }
#line 1189
    beg = bufbeg + save;
#line 1192
    if ((unsigned long )beg == (unsigned long )buflim) {
#line 1193
      goto while_break;
    }
    {
#line 1197
    oldc = *(beg + -1);
#line 1198
    *(beg + -1) = eol;
#line 1201
    tmp___4 = memrchr((void const   *)(beg - 1), (int )eol, (size_t )((buflim - beg) + 1L));
#line 1201
    lim = (char *)tmp___4;
#line 1202
    lim ++;
#line 1203
    *(beg + -1) = oldc;
    }
#line 1204
    if ((unsigned long )lim == (unsigned long )beg) {
#line 1205
      lim = beg - residue;
    }
#line 1206
    beg -= residue;
#line 1207
    residue = (size_t )(buflim - lim);
#line 1209
    if ((unsigned long )beg < (unsigned long )lim) {
#line 1211
      if (outleft) {
        {
#line 1212
        tmp___5 = grepbuf((char const   *)beg, (char const   *)lim);
#line 1212
        nlines += tmp___5;
        }
      }
#line 1213
      if (pending) {
        {
#line 1214
        prpending((char const   *)lim);
        }
      }
#line 1215
      if (! outleft) {
#line 1215
        if (! pending) {
#line 1216
          goto finish_grep;
        } else {
#line 1215
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */
#line 1215
      if (nlines) {
#line 1215
        if (done_on_match) {
#line 1216
          goto finish_grep;
        }
      }
    }
#line 1222
    i = (intmax_t )0;
#line 1223
    beg = lim;
    {
#line 1224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1224
      if (i < out_before) {
#line 1224
        if ((unsigned long )beg > (unsigned long )bufbeg) {
#line 1224
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
#line 1224
            goto while_break___0;
          }
        } else {
#line 1224
          goto while_break___0;
        }
      } else {
#line 1224
        goto while_break___0;
      }
#line 1226
      i ++;
      {
#line 1227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1228
        beg --;
#line 1227
        if (! ((int )*(beg + -1) != (int )eol)) {
#line 1227
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1233
    if ((unsigned long )beg != (unsigned long )lastout) {
#line 1234
      lastout = (char const   *)0;
    }
#line 1237
    save = (size_t )((lim + residue) - beg);
#line 1238
    if (out_byte) {
      {
#line 1239
      totalcc = add_count(totalcc, (size_t )(buflim - bufbeg) - save);
      }
    }
#line 1240
    if (out_line) {
      {
#line 1241
      nlscan((char const   *)beg);
      }
    }
    {
#line 1242
    tmp___7 = fillbuf(save, st);
    }
#line 1242
    if (! tmp___7) {
      {
#line 1244
      tmp___6 = __errno_location();
#line 1244
      suppressible_error(filename, *tmp___6);
      }
#line 1245
      goto finish_grep;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  if (residue) {
#line 1250
    tmp___8 = buflim;
#line 1250
    buflim ++;
#line 1250
    *tmp___8 = eol;
#line 1251
    if (outleft) {
      {
#line 1252
      tmp___9 = grepbuf((char const   *)((bufbeg + save) - residue), (char const   *)buflim);
#line 1252
      nlines += tmp___9;
      }
    }
#line 1253
    if (pending) {
      {
#line 1254
      prpending((char const   *)buflim);
      }
    }
  }
  finish_grep:
#line 1258
  done_on_match -= not_text;
#line 1259
  out_quiet -= not_text;
#line 1260
  if (not_text & ~ out_quiet) {
#line 1260
    if (nlines != 0L) {
      {
#line 1261
      tmp___10 = gettext("Binary file %s matches\n");
#line 1261
      printf((char const   */* __restrict  */)tmp___10, filename);
      }
    }
  }
#line 1262
  return (nlines);
}
}
#line 1265 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int grepdirent(FTS *fts , FTSENT *ent , int command_line )
{
  int follow ;
  int dirdesc ;
  struct stat *st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat st1 ;
  int flag ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1269
  st = ent->fts_statp;
#line 1270
  command_line &= ent->fts_level == 0L;
#line 1272
  if ((int )ent->fts_info == 6) {
#line 1274
    if ((unsigned int )directories == 3U) {
#line 1274
      if (command_line) {
#line 1275
        out_file &= ~ (2 * ! no_filenames);
      }
    }
#line 1276
    return (1);
  }
#line 1279
  if ((int )ent->fts_info == 1) {
#line 1279
    tmp = 1;
  } else
#line 1279
  if ((int )ent->fts_info == 2) {
#line 1279
    tmp = 1;
  } else
#line 1279
  if ((int )ent->fts_info == 4) {
#line 1279
    tmp = 1;
  } else {
#line 1279
    tmp = 0;
  }
  {
#line 1279
  tmp___0 = skipped_file((char const   *)(ent->fts_name), command_line, tmp);
  }
#line 1279
  if (tmp___0) {
    {
#line 1283
    fts_set(fts, ent, 4);
    }
#line 1284
    return (1);
  }
#line 1287
  filename = (char const   *)(ent->fts_path + filename_prefix_len);
#line 1288
  if (fts->fts_options & 2) {
#line 1288
    tmp___1 = 1;
  } else
#line 1288
  if (fts->fts_options & 1) {
#line 1288
    if (command_line) {
#line 1288
      tmp___1 = 1;
    } else {
#line 1288
      tmp___1 = 0;
    }
  } else {
#line 1288
    tmp___1 = 0;
  }
#line 1288
  follow = tmp___1;
  {
#line 1293
  if ((int )ent->fts_info == 1) {
#line 1293
    goto case_1;
  }
#line 1302
  if ((int )ent->fts_info == 2) {
#line 1302
    goto case_2;
  }
#line 1310
  if ((int )ent->fts_info == 10) {
#line 1310
    goto case_10;
  }
#line 1310
  if ((int )ent->fts_info == 7) {
#line 1310
    goto case_10;
  }
#line 1310
  if ((int )ent->fts_info == 4) {
#line 1310
    goto case_10;
  }
#line 1315
  if ((int )ent->fts_info == 11) {
#line 1315
    goto case_11;
  }
#line 1315
  if ((int )ent->fts_info == 3) {
#line 1315
    goto case_11;
  }
#line 1339
  if ((int )ent->fts_info == 13) {
#line 1339
    goto case_13;
  }
#line 1339
  if ((int )ent->fts_info == 8) {
#line 1339
    goto case_13;
  }
#line 1343
  if ((int )ent->fts_info == 14) {
#line 1343
    goto case_14;
  }
#line 1343
  if ((int )ent->fts_info == 12) {
#line 1343
    goto case_14;
  }
#line 1346
  goto switch_default;
  case_1: /* CIL Label */
#line 1294
  if ((unsigned int )directories == 3U) {
#line 1296
    out_file |= 2 * ! no_filenames;
#line 1297
    return (1);
  }
  {
#line 1299
  fts_set(fts, ent, 4);
  }
#line 1300
  goto switch_break;
  case_2: /* CIL Label */
#line 1303
  if (! suppress_errors) {
    {
#line 1304
    tmp___2 = gettext("recursive directory loop");
#line 1304
    tmp___3 = gettext("warning: %s: %s");
#line 1304
    error(0, 0, (char const   *)tmp___3, filename, tmp___2);
    }
  }
#line 1306
  return (1);
  case_10: /* CIL Label */
  case_7: /* CIL Label */
  case_4: /* CIL Label */
  {
#line 1311
  suppressible_error(filename, ent->fts_errno);
  }
#line 1312
  return (1);
  case_11: /* CIL Label */
  case_3: /* CIL Label */
#line 1316
  if ((unsigned int )devices == 2U) {
#line 1316
    goto _L;
  } else
#line 1316
  if ((unsigned int )devices == 0U) {
#line 1316
    if (! command_line) {
      _L: /* CIL Label */
#line 1320
      if (! st->st_mode) {
#line 1325
        if (follow) {
#line 1325
          tmp___4 = 0;
        } else {
#line 1325
          tmp___4 = 256;
        }
        {
#line 1325
        flag = tmp___4;
#line 1326
        tmp___6 = fstatat(fts->fts_cwd_fd, (char const   */* __restrict  */)ent->fts_accpath,
                          (struct stat */* __restrict  */)(& st1), flag);
        }
#line 1326
        if (tmp___6 != 0) {
          {
#line 1328
          tmp___5 = __errno_location();
#line 1328
          suppressible_error(filename, *tmp___5);
          }
#line 1329
          return (1);
        }
#line 1331
        st = & st1;
      }
      {
#line 1333
      tmp___7 = is_device_mode(st->st_mode);
      }
#line 1333
      if (tmp___7) {
#line 1334
        return (1);
      }
    }
  }
#line 1336
  goto switch_break;
  case_13: /* CIL Label */
  case_8: /* CIL Label */
#line 1340
  goto switch_break;
  case_14: /* CIL Label */
  case_12: /* CIL Label */
#line 1344
  return (1);
  switch_default: /* CIL Label */
  {
#line 1347
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1350
  if ((fts->fts_options & 516) == 512) {
#line 1350
    dirdesc = fts->fts_cwd_fd;
  } else {
#line 1350
    dirdesc = -100;
  }
  {
#line 1353
  tmp___8 = grepfile(dirdesc, (char const   *)ent->fts_accpath, follow, command_line);
  }
#line 1353
  return (tmp___8);
}
}
#line 1356 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int grepfile(int dirdesc , char const   *name , int follow , int command_line )
{
  int desc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1359
  if (follow) {
#line 1359
    tmp = 0;
  } else {
#line 1359
    tmp = 131072;
  }
  {
#line 1359
  tmp___0 = openat_safer(dirdesc, name, tmp);
#line 1359
  desc = tmp___0;
  }
#line 1360
  if (desc < 0) {
#line 1362
    if (follow) {
      {
#line 1363
      tmp___1 = __errno_location();
#line 1363
      suppressible_error(filename, *tmp___1);
      }
    } else {
      {
#line 1362
      tmp___2 = __errno_location();
      }
#line 1362
      if (*tmp___2 != 40) {
        {
#line 1362
        tmp___3 = __errno_location();
        }
#line 1362
        if (*tmp___3 != 31) {
          {
#line 1363
          tmp___1 = __errno_location();
#line 1363
          suppressible_error(filename, *tmp___1);
          }
        }
      }
    }
#line 1364
    return (1);
  }
  {
#line 1366
  tmp___4 = grepdesc(desc, command_line);
  }
#line 1366
  return (tmp___4);
}
}
#line 1369 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int grepdesc(int desc , int command_line )
{
  intmax_t count ;
  int status ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FTS *fts ;
  FTSENT *ent ;
  int opts ;
  int tmp___2 ;
  char *fts_arg[2] ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  off_t required_offset ;
  off_t tmp___14 ;
  int *tmp___15 ;
  __off_t tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1373
  status = 1;
#line 1382
  tmp___0 = fstat(desc, & st);
  }
#line 1382
  if (tmp___0 != 0) {
    {
#line 1384
    tmp = __errno_location();
#line 1384
    suppressible_error(filename, *tmp);
    }
#line 1385
    goto closeout;
  }
#line 1388
  if (desc != 0) {
#line 1388
    if (command_line) {
      {
#line 1388
      tmp___1 = skipped_file(filename, 1, (st.st_mode & 61440U) == 16384U);
      }
#line 1388
      if (tmp___1) {
#line 1390
        goto closeout;
      }
    }
  }
#line 1392
  if (desc != 0) {
#line 1392
    if ((unsigned int )directories == 3U) {
#line 1392
      if ((st.st_mode & 61440U) == 16384U) {
#line 1401
        if (command_line) {
#line 1401
          tmp___2 = 0;
        } else {
#line 1401
          tmp___2 = 1;
        }
        {
#line 1401
        opts = fts_options & ~ tmp___2;
#line 1406
        tmp___4 = close(desc);
        }
#line 1406
        if (tmp___4 != 0) {
          {
#line 1407
          tmp___3 = __errno_location();
#line 1407
          suppressible_error(filename, *tmp___3);
          }
        }
        {
#line 1409
        fts_arg[0] = (char *)filename;
#line 1410
        fts_arg[1] = (char *)((void *)0);
#line 1411
        fts = fts_open((char * const  *)(fts_arg), opts, (int (*)(FTSENT const   ** ,
                                                                  FTSENT const   ** ))((void *)0));
        }
#line 1413
        if (! fts) {
          {
#line 1414
          xalloc_die();
          }
        }
        {
#line 1415
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1415
          ent = fts_read(fts);
          }
#line 1415
          if (! ent) {
#line 1415
            goto while_break;
          }
          {
#line 1416
          tmp___5 = grepdirent(fts, ent, command_line);
#line 1416
          status &= tmp___5;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1417
        tmp___7 = __errno_location();
        }
#line 1417
        if (*tmp___7) {
          {
#line 1418
          tmp___6 = __errno_location();
#line 1418
          suppressible_error(filename, *tmp___6);
          }
        }
        {
#line 1419
        tmp___9 = fts_close(fts);
        }
#line 1419
        if (tmp___9 != 0) {
          {
#line 1420
          tmp___8 = __errno_location();
#line 1420
          suppressible_error(filename, *tmp___8);
          }
        }
#line 1421
        return (status);
      }
    }
  }
#line 1423
  if (desc != 0) {
#line 1423
    if ((unsigned int )directories == 4U) {
#line 1423
      if ((st.st_mode & 61440U) == 16384U) {
#line 1428
        goto closeout;
      } else {
#line 1423
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
#line 1423
    if ((unsigned int )devices == 2U) {
#line 1423
      goto _L;
    } else
#line 1423
    if ((unsigned int )devices == 0U) {
#line 1423
      if (! command_line) {
        _L: /* CIL Label */
        {
#line 1423
        tmp___10 = is_device_mode(st.st_mode);
        }
#line 1423
        if (tmp___10) {
#line 1428
          goto closeout;
        }
      }
    }
  }
#line 1448
  if (! out_quiet) {
#line 1448
    if (list_files == 0) {
#line 1448
      if (1L < max_count) {
#line 1448
        if ((out_stat.st_mode & 61440U) == 32768U) {
#line 1448
          if (out_stat.st_ino) {
#line 1448
            if (st.st_ino == out_stat.st_ino) {
#line 1448
              if (st.st_dev == out_stat.st_dev) {
#line 1452
                if (! suppress_errors) {
                  {
#line 1453
                  tmp___11 = quote(filename);
#line 1453
                  tmp___12 = gettext("input file %s is also the output");
#line 1453
                  error(0, 0, (char const   *)tmp___12, tmp___11);
                  }
                }
#line 1454
                errseen = 1;
#line 1455
                goto closeout;
              }
            }
          }
        }
      }
    }
  }
  {
#line 1461
  tmp___13 = isatty(desc);
  }
#line 1461
  if (! tmp___13) {
    {
#line 1462
    set_binary_mode(desc, 0);
    }
  }
  {
#line 1465
  count = grep(desc, (struct stat  const  *)(& st));
  }
#line 1466
  if (count < 0L) {
#line 1467
    status = (int )(count + 2L);
  } else {
#line 1470
    if (count_matches) {
#line 1472
      if (out_file) {
        {
#line 1474
        print_filename();
        }
#line 1475
        if (filename_mask) {
          {
#line 1476
          print_sep((char )':');
          }
        } else {
          {
#line 1478
          fputc_unlocked(0, stdout);
          }
        }
      }
      {
#line 1480
      printf((char const   */* __restrict  */)"%ld\n", count);
      }
    }
#line 1483
    status = ! count;
#line 1484
    if (list_files == 1 - 2 * status) {
      {
#line 1486
      print_filename();
#line 1487
      fputc_unlocked(10 & filename_mask, stdout);
      }
    }
#line 1490
    if (desc == 0) {
#line 1492
      if (outleft) {
#line 1492
        tmp___14 = bufoffset;
      } else {
#line 1492
        tmp___14 = after_last_match;
      }
#line 1492
      required_offset = tmp___14;
#line 1493
      if (required_offset != bufoffset) {
        {
#line 1493
        tmp___16 = lseek(desc, required_offset, 0);
        }
#line 1493
        if (tmp___16 < 0L) {
#line 1493
          if ((st.st_mode & 61440U) == 32768U) {
            {
#line 1496
            tmp___15 = __errno_location();
#line 1496
            suppressible_error(filename, *tmp___15);
            }
          }
        }
      }
    }
  }
  closeout:
#line 1501
  if (desc != 0) {
    {
#line 1501
    tmp___18 = close(desc);
    }
#line 1501
    if (tmp___18 != 0) {
      {
#line 1502
      tmp___17 = __errno_location();
#line 1502
      suppressible_error(filename, *tmp___17);
      }
    }
  }
#line 1503
  return (status);
}
}
#line 1506 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int grep_command_line_arg(char const   *arg )
{
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1509
  tmp___2 = strcmp(arg, "-");
  }
#line 1509
  if (tmp___2 == 0) {
#line 1511
    if (label) {
#line 1511
      filename = (char const   *)label;
    } else {
      {
#line 1511
      tmp = gettext("(standard input)");
#line 1511
      filename = (char const   *)tmp;
      }
    }
    {
#line 1512
    tmp___0 = grepdesc(0, 1);
    }
#line 1512
    return (tmp___0);
  } else {
    {
#line 1516
    filename = arg;
#line 1517
    tmp___1 = grepfile(-100, arg, 1, 1);
    }
#line 1517
    return (tmp___1);
  }
}
}
#line 1522 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
void usage(int status )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 1525
  if (status != 0) {
    {
#line 1527
    tmp = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
#line 1529
    tmp___0 = gettext("Try \'%s --help\' for more information.\n");
#line 1529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name);
    }
  } else {
    {
#line 1534
    tmp___1 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1534
    printf((char const   */* __restrict  */)tmp___1, program_name);
#line 1535
    tmp___2 = gettext("Search for PATTERN in each FILE or standard input.\n");
#line 1535
    printf((char const   */* __restrict  */)tmp___2);
#line 1536
    tmp___3 = gettext("PATTERN is, by default, a basic regular expression (BRE).\n");
#line 1536
    printf((char const   */* __restrict  */)tmp___3);
#line 1537
    tmp___4 = gettext("Example: %s -i \'hello world\' menu.h main.c\n\nRegexp selection and interpretation:\n");
#line 1537
    printf((char const   */* __restrict  */)tmp___4, program_name);
#line 1541
    tmp___5 = gettext("  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n");
#line 1541
    printf((char const   */* __restrict  */)tmp___5);
#line 1547
    tmp___6 = gettext("  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n");
#line 1547
    printf((char const   */* __restrict  */)tmp___6);
#line 1554
    tmp___7 = gettext("\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             display version information and exit\n      --help                display this help text and exit\n");
#line 1554
    printf((char const   */* __restrict  */)tmp___7);
#line 1561
    tmp___8 = gettext("\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the file name for each match\n  -h, --no-filename         suppress the file name prefix on output\n      --label=LABEL         use LABEL as the standard input file name prefix\n");
#line 1561
    printf((char const   */* __restrict  */)tmp___8);
#line 1572
    tmp___9 = gettext("  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is \'binary\', \'text\', or \'without-match\'\n  -a, --text                equivalent to --binary-files=text\n");
#line 1572
    printf((char const   */* __restrict  */)tmp___9);
#line 1579
    tmp___10 = gettext("  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is \'read\', \'recurse\', or \'skip\'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is \'read\' or \'skip\'\n  -r, --recursive           like --directories=recurse\n  -R, --dereference-recursive  likewise, but follow all symlinks\n");
#line 1579
    printf((char const   */* __restrict  */)tmp___10);
#line 1588
    tmp___11 = gettext("      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n");
#line 1588
    printf((char const   */* __restrict  */)tmp___11);
#line 1594
    tmp___12 = gettext("  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n");
#line 1594
    printf((char const   */* __restrict  */)tmp___12);
#line 1600
    tmp___13 = gettext("\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n");
#line 1600
    printf((char const   */* __restrict  */)tmp___13);
#line 1607
    tmp___14 = gettext("  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is \'always\', \'never\', or \'auto\'\n  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there\n                            (MSDOS/Windows)\n\n");
#line 1607
    printf((char const   */* __restrict  */)tmp___14);
#line 1616
    tmp___15 = gettext("\'egrep\' means \'grep -E\'.  \'fgrep\' means \'grep -F\'.\nDirect invocation as either \'egrep\' or \'fgrep\' is deprecated.\n");
#line 1616
    printf((char const   */* __restrict  */)tmp___15);
#line 1619
    tmp___16 = gettext("When FILE is -, read standard input.  With no FILE, read . if a command-line\n-r is given, - otherwise.  If fewer than two FILEs are given, assume -h.\nExit status is 0 if any line is selected, 1 otherwise;\nif any error occurs and -q is not given, the exit status is 2.\n");
#line 1619
    printf((char const   */* __restrict  */)tmp___16);
#line 1624
    tmp___17 = gettext("\nReport bugs to: %s\n");
#line 1624
    printf((char const   */* __restrict  */)tmp___17, "bug-grep@gnu.org");
#line 1625
    tmp___18 = gettext("GNU Grep home page: <%s>\n");
#line 1625
    printf((char const   */* __restrict  */)tmp___18, "http://www.gnu.org/software/grep/");
#line 1627
    tmp___19 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 1627
    fputs_unlocked((char const   */* __restrict  */)tmp___19, (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 1631
  exit(status);
  }
}
}
#line 1636 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void Gcompile(char const   *pattern , size_t size )
{


  {
  {
#line 1639
  GEAcompile(pattern, size, (((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 1640
  return;
}
}
#line 1642 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void Ecompile(char const   *pattern , size_t size )
{


  {
  {
#line 1645
  GEAcompile(pattern, size, (((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 1646
  return;
}
}
#line 1648 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void Acompile(char const   *pattern , size_t size )
{


  {
  {
#line 1651
  GEAcompile(pattern, size, (((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((1UL << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 1652
  return;
}
}
#line 1654 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void GAcompile(char const   *pattern , size_t size )
{


  {
  {
#line 1657
  GEAcompile(pattern, size, (((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((1UL << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)));
  }
#line 1658
  return;
}
}
#line 1660 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void PAcompile(char const   *pattern , size_t size )
{


  {
  {
#line 1663
  GEAcompile(pattern, size, ((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 1664
  return;
}
}
#line 1672 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static struct matcher  const  matchers[8]  =
#line 1672
  {      {{(char const   )'g', (char const   )'r', (char const   )'e', (char const   )'p',
       (char const   )'\000'}, & Gcompile, & EGexecute},
        {{(char const   )'e', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, & Ecompile, & EGexecute},
        {{(char const   )'f', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, & Fcompile, & Fexecute},
        {{(char const   )'a', (char const   )'w', (char const   )'k', (char const   )'\000'},
      & Acompile, & EGexecute},
        {{(char const   )'g', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, & GAcompile, & EGexecute},
        {{(char const   )'p', (char const   )'o', (char const   )'s', (char const   )'i',
       (char const   )'x', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, & PAcompile, & EGexecute},
        {{(char const   )'p', (char const   )'e', (char const   )'r', (char const   )'l',
       (char const   )'\000'}, & Pcompile, & Pexecute},
        {{(char const   )'\000'}, (void (*)(char const   * , size_t  ))((void *)0), (size_t (*)(char const   * ,
                                                                                             size_t  ,
                                                                                             size_t * ,
                                                                                             char const   * ))((void *)0)}};
#line 1685 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void setmatcher(char const   *m )
{
  struct matcher  const  *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 1690
  if (matcher) {
    {
#line 1690
    tmp___0 = strcmp(matcher, m);
    }
#line 1690
    if (! (tmp___0 == 0)) {
      {
#line 1691
      tmp = gettext("conflicting matchers specified");
#line 1691
      error(2, 0, (char const   *)tmp);
      }
    }
  }
#line 1693
  p = matchers;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! p->compile) {
#line 1693
      goto while_break;
    }
    {
#line 1694
    tmp___1 = strcmp(m, (char const   *)(p->name));
    }
#line 1694
    if (tmp___1 == 0) {
#line 1696
      matcher = (char const   *)(p->name);
#line 1697
      compile = (void (*)(char const   * , size_t  ))p->compile;
#line 1698
      execute = (size_t (*)(char const   * , size_t  , size_t * , char const   * ))p->execute;
#line 1699
      return;
    }
#line 1693
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1702
  tmp___2 = gettext("invalid matcher %s");
#line 1702
  error(2, 0, (char const   *)tmp___2, m);
  }
#line 1703
  return;
}
}
#line 1710 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static size_t prepend_args(char const   *options , char *buf , char **argv )
{
  char const   *o ;
  char *b ;
  size_t n ;
  unsigned char tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___4 ;
  unsigned char tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;

  {
#line 1713
  o = options;
#line 1714
  b = buf;
#line 1715
  n = (size_t )0;
  {
#line 1717
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1719
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1719
      tmp = to_uchar((char )*o);
#line 1719
      tmp___0 = c_isspace((int )tmp);
      }
#line 1719
      if (! tmp___0) {
#line 1719
        goto while_break___0;
      }
#line 1720
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1721
    if (! *o) {
#line 1722
      return (n);
    }
#line 1723
    if (argv) {
#line 1724
      *(argv + n) = b;
    }
#line 1725
    n ++;
    {
#line 1727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1728
      tmp___2 = b;
#line 1728
      b ++;
#line 1728
      tmp___4 = o;
#line 1728
      o ++;
#line 1728
      tmp___3 = (char )*tmp___4;
#line 1728
      *tmp___2 = tmp___3;
#line 1728
      if ((int )tmp___3 == 92) {
#line 1728
        if (*o) {
#line 1729
          tmp___1 = o;
#line 1729
          o ++;
#line 1729
          *(b + -1) = (char )*tmp___1;
        }
      }
#line 1727
      if (*o) {
        {
#line 1727
        tmp___5 = to_uchar((char )*o);
#line 1727
        tmp___6 = c_isspace((int )tmp___5);
        }
#line 1727
        if (tmp___6) {
#line 1727
          goto while_break___1;
        }
      } else {
#line 1727
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1732
    tmp___7 = b;
#line 1732
    b ++;
#line 1732
    *tmp___7 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1739 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int prepend_default_options(char const   *options , int *pargc , char ***pargv )
{
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t prepended ;
  size_t tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  size_t tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 1742
  if (options) {
#line 1742
    if (*options) {
      {
#line 1744
      tmp = strlen(options);
#line 1744
      tmp___0 = xmalloc(tmp + 1UL);
#line 1744
      buf = (char *)tmp___0;
#line 1745
      tmp___1 = prepend_args(options, buf, (char **)((void *)0));
#line 1745
      prepended = tmp___1;
#line 1746
      argc = *pargc;
#line 1747
      argv = (char * const  *)*pargv;
      }
#line 1750
      if ((size_t )(2147483647 - argc) < prepended) {
        {
#line 1751
        xalloc_die();
        }
      }
      {
#line 1752
      tmp___2 = xmalloc(((prepended + (size_t )argc) + 1UL) * sizeof(*pp));
#line 1752
      pp = (char **)tmp___2;
#line 1753
      *pargc = (int )(prepended + (size_t )argc);
#line 1754
      *pargv = pp;
#line 1755
      tmp___3 = pp;
#line 1755
      pp ++;
#line 1755
      tmp___4 = argv;
#line 1755
      argv ++;
#line 1755
      *tmp___3 = (char *)*tmp___4;
#line 1756
      tmp___5 = prepend_args(options, buf, pp);
#line 1756
      pp += tmp___5;
      }
      {
#line 1757
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1757
        tmp___6 = pp;
#line 1757
        pp ++;
#line 1757
        tmp___8 = argv;
#line 1757
        argv ++;
#line 1757
        tmp___7 = (char *)*tmp___8;
#line 1757
        *tmp___6 = tmp___7;
#line 1757
        if (! tmp___7) {
#line 1757
          goto while_break;
        }
#line 1758
        goto while_continue;
      }
      while_break: /* CIL Label */ ;
      }
#line 1759
      return ((int )prepended);
    }
  }
#line 1762
  return (0);
}
}
#line 1772
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) ;
#line 1772 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int prev_digit_optind  =    -1;
#line 1769 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context )
{
  int this_digit_optind ;
  int was_digit ;
  char buf[((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL) + 4UL] ;
  char *p ;
  int opt ;
  char *tmp ;

  {
#line 1775
  p = buf;
#line 1778
  was_digit = 0;
#line 1779
  this_digit_optind = optind;
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1782
    opt = getopt_long(argc, (char * const  *)((char **)argv), short_options, long_options,
                      (int *)((void *)0));
    }
#line 1784
    if (48 <= opt) {
#line 1784
      if (! (opt <= 57)) {
#line 1785
        goto while_break;
      }
    } else {
#line 1785
      goto while_break;
    }
#line 1787
    if (prev_digit_optind != this_digit_optind) {
#line 1790
      p = buf;
    } else
#line 1787
    if (! was_digit) {
#line 1790
      p = buf;
    } else {
#line 1796
      p -= (int )buf[0] == 48;
    }
#line 1799
    if ((unsigned long )p == (unsigned long )((buf + sizeof(buf)) - 4)) {
      {
#line 1804
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"...");
#line 1805
      p += 3;
      }
#line 1806
      goto while_break;
    }
#line 1808
    tmp = p;
#line 1808
    p ++;
#line 1808
    *tmp = (char )opt;
#line 1810
    was_digit = 1;
#line 1811
    prev_digit_optind = this_digit_optind;
#line 1812
    this_digit_optind = optind;
  }
  while_break: /* CIL Label */ ;
  }
#line 1814
  if ((unsigned long )p != (unsigned long )(buf)) {
    {
#line 1816
    *p = (char )'\000';
#line 1817
    context_length_arg((char const   *)(buf), default_context);
    }
  }
#line 1820
  return (opt);
}
}
#line 1827 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void parse_grep_colors(void)
{
  char const   *p ;
  char *q ;
  char *name ;
  char *val ;
  char *tmp ;
  char c ;
  struct color_cap  const  *cap ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1835
  tmp = getenv("GREP_COLORS");
#line 1835
  p = (char const   *)tmp;
  }
#line 1836
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1837
    return;
  } else
#line 1836
  if ((int const   )*p == 0) {
#line 1837
    return;
  }
  {
#line 1840
  q = xstrdup(p);
#line 1842
  name = q;
#line 1843
  val = (char *)((void *)0);
  }
  {
#line 1845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1846
    if ((int )*q == 58) {
#line 1846
      goto _L;
    } else
#line 1846
    if ((int )*q == 0) {
      _L: /* CIL Label */
#line 1848
      c = *q;
#line 1851
      tmp___0 = q;
#line 1851
      q ++;
#line 1851
      *tmp___0 = (char )'\000';
#line 1854
      cap = color_dict;
      {
#line 1854
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1854
        if (! cap->name) {
#line 1854
          goto while_break___0;
        }
        {
#line 1855
        tmp___1 = strcmp((char const   *)cap->name, (char const   *)name);
        }
#line 1855
        if (tmp___1 == 0) {
#line 1856
          goto while_break___0;
        }
#line 1854
        cap ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1858
      if (cap->var) {
#line 1858
        if (val) {
#line 1859
          *(cap->var) = (char const   *)val;
        }
      }
#line 1860
      if (cap->fct) {
        {
#line 1861
        (*(cap->fct))();
        }
      }
#line 1862
      if ((int )c == 0) {
#line 1863
        return;
      }
#line 1864
      name = q;
#line 1865
      val = (char *)((void *)0);
    } else
#line 1867
    if ((int )*q == 61) {
#line 1869
      if ((unsigned long )q == (unsigned long )name) {
#line 1870
        return;
      } else
#line 1869
      if (val) {
#line 1870
        return;
      }
#line 1871
      tmp___2 = q;
#line 1871
      q ++;
#line 1871
      *tmp___2 = (char )'\000';
#line 1872
      val = q;
    } else
#line 1874
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1875
      q ++;
    } else
#line 1876
    if ((int )*q == 59) {
#line 1877
      q ++;
    } else
#line 1876
    if ((int )*q >= 48) {
#line 1876
      if ((int )*q <= 57) {
#line 1877
        q ++;
      } else {
#line 1879
        return;
      }
    } else {
#line 1879
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1883 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static _Bool contains_encoding_error(char const   *pat , size_t patlen )
{
  mbstate_t mbs ;
  size_t i ;
  size_t charlen ;

  {
#line 1886
  mbs.__count = 0;
#line 1886
  mbs.__value.__wch = 0U;
#line 1889
  i = (size_t )0;
  {
#line 1889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1889
    if (! (i < patlen)) {
#line 1889
      goto while_break;
    }
    {
#line 1891
    charlen = mbrlen((char const   */* __restrict  */)(pat + i), patlen - i, (mbstate_t */* __restrict  */)(& mbs));
    }
#line 1892
    if (0xfffffffffffffffeUL <= charlen) {
#line 1893
      return ((_Bool)1);
    }
#line 1889
    i += charlen + (size_t )(charlen == 0UL);
  }
  while_break: /* CIL Label */ ;
  }
#line 1895
  return ((_Bool)0);
}
}
#line 1899 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
static void fgrep_to_grep_pattern(size_t len , char const   *keys , size_t *new_len ,
                                  char **new_keys )
{
  char *p ;
  char *tmp ;
  void *tmp___0 ;
  mbstate_t mb_state ;
  size_t n ;
  wchar_t wc ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1903
  tmp___0 = xnmalloc(len + 1UL, (size_t )2);
#line 1903
  tmp = (char *)tmp___0;
#line 1903
  *new_keys = tmp;
#line 1903
  p = tmp;
#line 1904
  mb_state.__count = 0;
#line 1904
  mb_state.__value.__wch = 0U;
  }
  {
#line 1907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1907
    if (! len) {
#line 1907
      goto while_break;
    }
    {
#line 1910
    n = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)keys,
                len, (mbstate_t */* __restrict  */)(& mb_state));
    }
    {
#line 1913
    if (n == 0xfffffffffffffffeUL) {
#line 1913
      goto case_18446744073709551614;
    }
#line 1920
    if (n == 0xffffffffffffffffUL) {
#line 1920
      goto case_18446744073709551615;
    }
#line 1923
    if (n == 1UL) {
#line 1923
      goto case_1;
    }
#line 1927
    if (n == 0UL) {
#line 1927
      goto case_0;
    }
#line 1916
    goto switch_default;
    case_18446744073709551614: /* CIL Label */
#line 1914
    n = len;
    switch_default: /* CIL Label */
    {
#line 1917
    tmp___1 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)keys,
                      n);
#line 1917
    p = (char *)tmp___1;
    }
#line 1918
    goto switch_break;
    case_18446744073709551615: /* CIL Label */
    {
#line 1921
    memset((void *)(& mb_state), 0, sizeof(mb_state));
    }
    case_1: /* CIL Label */
    {
#line 1924
    *p = (char )'\\';
#line 1925
    tmp___2 = strchr("$*.[\\^", (int )*keys);
#line 1925
    p += (unsigned long )tmp___2 != (unsigned long )((void *)0);
    }
    case_0: /* CIL Label */
#line 1928
    tmp___3 = p;
#line 1928
    p ++;
#line 1928
    *tmp___3 = (char )*keys;
#line 1929
    n = (size_t )1;
#line 1930
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1907
    keys += n;
#line 1907
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1934
  *new_len = (size_t )(p - *new_keys);
#line 1935
  return;
}
}
#line 1937 "/home/khheo/project/benchmark/grep-2.19/src/grep.c"
int main(int argc , char **argv )
{
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int with_filenames ;
  size_t cc ;
  int opt ;
  int status ;
  int prepended ;
  int prev_optind ;
  int last_recursive ;
  int fread_errno ;
  intmax_t default_context ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ptrdiff_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  FILE *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  strtol_error tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *userval ;
  char *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  struct stat tmp_stat ;
  int tmp___39 ;
  int tmp___40 ;
  void *tmp___41 ;
  size_t new_keycc ;
  char *new_keys ;
  size_t tmp___42 ;
  _Bool tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;

  {
  {
#line 1949
  exit_failure = (int volatile   )2;
#line 1951
  set_program_name((char const   *)*(argv + 0));
#line 1952
  program_name = (char const   *)*(argv + 0);
#line 1954
  keys = (char *)((void *)0);
#line 1955
  keycc = (size_t )0;
#line 1956
  with_filenames = 0;
#line 1957
  eolbyte = (unsigned char )'\n';
#line 1958
  filename_mask = ~ 0;
#line 1960
  max_count = 9223372036854775807L;
#line 1963
  out_before = (intmax_t )-1;
#line 1963
  out_after = out_before;
#line 1965
  default_context = (intmax_t )-1;
#line 1967
  only_matching = 0;
#line 1971
  setlocale(6, "");
#line 1974
  bindtextdomain("grep", "/usr/local/share/locale");
#line 1975
  textdomain("grep");
#line 1978
  exit_failure = (int volatile   )2;
#line 1979
  atexit(& clean_up_stdout);
#line 1981
  last_recursive = 0;
#line 1982
  tmp = getenv("GREP_OPTIONS");
#line 1982
  prepended = prepend_default_options((char const   *)tmp, & argc, & argv);
#line 1983
  compile = (void (*)(char const   * , size_t  ))matchers[0].compile;
#line 1984
  execute = (size_t (*)(char const   * , size_t  , size_t * , char const   * ))matchers[0].execute;
  }
  {
#line 1986
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1986
    prev_optind = optind;
#line 1986
    opt = get_nondigit_option(argc, (char * const  *)argv, & default_context);
    }
#line 1986
    if (! (opt != -1)) {
#line 1986
      goto while_break;
    }
    {
#line 1990
    if (opt == 65) {
#line 1990
      goto case_65;
    }
#line 1994
    if (opt == 66) {
#line 1994
      goto case_66;
    }
#line 1998
    if (opt == 67) {
#line 1998
      goto case_67;
    }
#line 2004
    if (opt == 68) {
#line 2004
      goto case_68;
    }
#line 2013
    if (opt == 69) {
#line 2013
      goto case_69;
    }
#line 2017
    if (opt == 70) {
#line 2017
      goto case_70;
    }
#line 2021
    if (opt == 80) {
#line 2021
      goto case_80;
    }
#line 2025
    if (opt == 71) {
#line 2025
      goto case_71;
    }
#line 2029
    if (opt == 88) {
#line 2029
      goto case_88;
    }
#line 2033
    if (opt == 72) {
#line 2033
      goto case_72;
    }
#line 2038
    if (opt == 73) {
#line 2038
      goto case_73;
    }
#line 2042
    if (opt == 84) {
#line 2042
      goto case_84;
    }
#line 2046
    if (opt == 85) {
#line 2046
      goto case_85;
    }
#line 2050
    if (opt == 117) {
#line 2050
      goto case_117;
    }
#line 2054
    if (opt == 86) {
#line 2054
      goto case_86;
    }
#line 2058
    if (opt == 97) {
#line 2058
      goto case_97;
    }
#line 2062
    if (opt == 98) {
#line 2062
      goto case_98;
    }
#line 2066
    if (opt == 99) {
#line 2066
      goto case_99;
    }
#line 2070
    if (opt == 100) {
#line 2070
      goto case_100;
    }
#line 2077
    if (opt == 101) {
#line 2077
      goto case_101;
    }
#line 2085
    if (opt == 102) {
#line 2085
      goto case_102;
    }
#line 2109
    if (opt == 104) {
#line 2109
      goto case_104;
    }
#line 2115
    if (opt == 121) {
#line 2115
      goto case_121;
    }
#line 2115
    if (opt == 105) {
#line 2115
      goto case_121;
    }
#line 2119
    if (opt == 76) {
#line 2119
      goto case_76;
    }
#line 2125
    if (opt == 108) {
#line 2125
      goto case_108;
    }
#line 2129
    if (opt == 109) {
#line 2129
      goto case_109;
    }
#line 2141
    if (opt == 110) {
#line 2141
      goto case_110;
    }
#line 2145
    if (opt == 111) {
#line 2145
      goto case_111;
    }
#line 2149
    if (opt == 113) {
#line 2149
      goto case_113;
    }
#line 2154
    if (opt == 82) {
#line 2154
      goto case_82;
    }
#line 2157
    if (opt == 114) {
#line 2157
      goto case_114;
    }
#line 2162
    if (opt == 115) {
#line 2162
      goto case_115;
    }
#line 2166
    if (opt == 118) {
#line 2166
      goto case_118;
    }
#line 2170
    if (opt == 119) {
#line 2170
      goto case_119;
    }
#line 2174
    if (opt == 120) {
#line 2174
      goto case_120;
    }
#line 2178
    if (opt == 90) {
#line 2178
      goto case_90;
    }
#line 2182
    if (opt == 122) {
#line 2182
      goto case_122;
    }
#line 2186
    if (opt == 128) {
#line 2186
      goto case_128;
    }
#line 2197
    if (opt == 129) {
#line 2197
      goto case_129;
    }
#line 2217
    if (opt == 130) {
#line 2217
      goto case_130;
    }
#line 2217
    if (opt == 131) {
#line 2217
      goto case_130;
    }
#line 2224
    if (opt == 132) {
#line 2224
      goto case_132;
    }
#line 2234
    if (opt == 135) {
#line 2234
      goto case_135;
    }
#line 2240
    if (opt == 136) {
#line 2240
      goto case_136;
    }
#line 2244
    if (opt == 133) {
#line 2244
      goto case_133;
    }
#line 2248
    if (opt == 134) {
#line 2248
      goto case_134;
    }
#line 2252
    if (opt == 0) {
#line 2252
      goto case_0___0;
    }
#line 2256
    goto switch_default___0;
    case_65: /* CIL Label */
    {
#line 1991
    context_length_arg((char const   *)optarg, & out_after);
    }
#line 1992
    goto switch_break;
    case_66: /* CIL Label */
    {
#line 1995
    context_length_arg((char const   *)optarg, & out_before);
    }
#line 1996
    goto switch_break;
    case_67: /* CIL Label */
    {
#line 2001
    context_length_arg((char const   *)optarg, & default_context);
    }
#line 2002
    goto switch_break;
    case_68: /* CIL Label */
    {
#line 2005
    tmp___2 = strcmp((char const   *)optarg, "read");
    }
#line 2005
    if (tmp___2 == 0) {
#line 2006
      devices = (enum __anonenum_devices_473526324 )1;
    } else {
      {
#line 2007
      tmp___1 = strcmp((char const   *)optarg, "skip");
      }
#line 2007
      if (tmp___1 == 0) {
#line 2008
        devices = (enum __anonenum_devices_473526324 )2;
      } else {
        {
#line 2010
        tmp___0 = gettext("unknown devices method");
#line 2010
        error(2, 0, (char const   *)tmp___0);
        }
      }
    }
#line 2011
    goto switch_break;
    case_69: /* CIL Label */
    {
#line 2014
    setmatcher("egrep");
    }
#line 2015
    goto switch_break;
    case_70: /* CIL Label */
    {
#line 2018
    setmatcher("fgrep");
    }
#line 2019
    goto switch_break;
    case_80: /* CIL Label */
    {
#line 2022
    setmatcher("perl");
    }
#line 2023
    goto switch_break;
    case_71: /* CIL Label */
    {
#line 2026
    setmatcher("grep");
    }
#line 2027
    goto switch_break;
    case_88: /* CIL Label */
    {
#line 2030
    setmatcher((char const   *)optarg);
    }
#line 2031
    goto switch_break;
    case_72: /* CIL Label */
#line 2034
    with_filenames = 1;
#line 2035
    no_filenames = 0;
#line 2036
    goto switch_break;
    case_73: /* CIL Label */
#line 2039
    binary_files = (enum __anonenum_binary_files_601436154 )2;
#line 2040
    goto switch_break;
    case_84: /* CIL Label */
#line 2043
    align_tabs = 1;
#line 2044
    goto switch_break;
    case_85: /* CIL Label */
    {
#line 2047
    dos_binary();
    }
#line 2048
    goto switch_break;
    case_117: /* CIL Label */
    {
#line 2051
    dos_unix_byte_offsets();
    }
#line 2052
    goto switch_break;
    case_86: /* CIL Label */
#line 2055
    show_version = 1;
#line 2056
    goto switch_break;
    case_97: /* CIL Label */
#line 2059
    binary_files = (enum __anonenum_binary_files_601436154 )1;
#line 2060
    goto switch_break;
    case_98: /* CIL Label */
#line 2063
    out_byte = 1;
#line 2064
    goto switch_break;
    case_99: /* CIL Label */
#line 2067
    count_matches = 1;
#line 2068
    goto switch_break;
    case_100: /* CIL Label */
    {
#line 2071
    tmp___3 = __xargmatch_internal("--directories", (char const   *)optarg, directories_args,
                                   (char const   *)(directories_types), sizeof(directories_types[0]),
                                   argmatch_die);
#line 2071
    directories = (enum directories_type )directories_types[tmp___3];
    }
#line 2073
    if ((unsigned int )directories == 3U) {
#line 2074
      last_recursive = prev_optind;
    }
#line 2075
    goto switch_break;
    case_101: /* CIL Label */
    {
#line 2078
    cc = strlen((char const   *)optarg);
#line 2079
    tmp___4 = xrealloc((void *)keys, (keycc + cc) + 1UL);
#line 2079
    keys = (char *)tmp___4;
#line 2080
    strcpy((char */* __restrict  */)(keys + keycc), (char const   */* __restrict  */)optarg);
#line 2081
    keycc += cc;
#line 2082
    tmp___5 = keycc;
#line 2082
    keycc ++;
#line 2082
    *(keys + tmp___5) = (char )'\n';
    }
#line 2083
    goto switch_break;
    case_102: /* CIL Label */
    {
#line 2086
    tmp___8 = strcmp((char const   *)optarg, "-");
    }
#line 2086
    if (tmp___8 == 0) {
#line 2086
      fp = stdin;
    } else {
      {
#line 2086
      tmp___7 = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
#line 2086
      fp = tmp___7;
      }
    }
#line 2087
    if (! fp) {
      {
#line 2088
      tmp___9 = __errno_location();
#line 2088
      error(2, *tmp___9, "%s", optarg);
      }
    }
#line 2089
    keyalloc = (size_t )1;
    {
#line 2089
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2089
      if (! (keyalloc <= keycc + 1UL)) {
#line 2089
        goto while_break___0;
      }
#line 2089
      keyalloc *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2091
    tmp___10 = xrealloc((void *)keys, keyalloc);
#line 2091
    keys = (char *)tmp___10;
#line 2092
    oldcc = keycc;
    }
    {
#line 2093
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2093
      cc = fread_unlocked((void */* __restrict  */)(keys + keycc), (size_t )1, (keyalloc - 1UL) - keycc,
                          (FILE */* __restrict  */)fp);
      }
#line 2093
      if (! (cc != 0UL)) {
#line 2093
        goto while_break___1;
      }
#line 2095
      keycc += cc;
#line 2096
      if (keycc == keyalloc - 1UL) {
        {
#line 2097
        tmp___11 = x2nrealloc((void *)keys, & keyalloc, sizeof(*keys));
#line 2097
        keys = (char *)tmp___11;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2099
    tmp___12 = __errno_location();
#line 2099
    fread_errno = *tmp___12;
#line 2100
    tmp___13 = ferror_unlocked(fp);
    }
#line 2100
    if (tmp___13) {
      {
#line 2101
      error(2, fread_errno, "%s", optarg);
      }
    }
#line 2102
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 2103
      fclose(fp);
      }
    }
#line 2105
    if (oldcc != keycc) {
#line 2105
      if ((int )*(keys + (keycc - 1UL)) != 10) {
#line 2106
        tmp___14 = keycc;
#line 2106
        keycc ++;
#line 2106
        *(keys + tmp___14) = (char )'\n';
      }
    }
#line 2107
    goto switch_break;
    case_104: /* CIL Label */
#line 2110
    with_filenames = 0;
#line 2111
    no_filenames = 1;
#line 2112
    goto switch_break;
    case_121: /* CIL Label */
    case_105: /* CIL Label */
#line 2116
    match_icase = 1;
#line 2117
    goto switch_break;
    case_76: /* CIL Label */
#line 2122
    list_files = -1;
#line 2123
    goto switch_break;
    case_108: /* CIL Label */
#line 2126
    list_files = 1;
#line 2127
    goto switch_break;
    case_109: /* CIL Label */
    {
#line 2130
    tmp___15 = xstrtoimax((char const   *)optarg, (char **)0, 10, & max_count, "");
    }
    {
#line 2133
    if ((unsigned int )tmp___15 == 1U) {
#line 2133
      goto case_1;
    }
#line 2133
    if ((unsigned int )tmp___15 == 0U) {
#line 2133
      goto case_1;
    }
#line 2136
    goto switch_default;
    case_1: /* CIL Label */
    case_0: /* CIL Label */
#line 2134
    goto switch_break___0;
    switch_default: /* CIL Label */
    {
#line 2137
    tmp___16 = gettext("invalid max count");
#line 2137
    error(2, 0, (char const   *)tmp___16);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2139
    goto switch_break;
    case_110: /* CIL Label */
#line 2142
    out_line = 1;
#line 2143
    goto switch_break;
    case_111: /* CIL Label */
#line 2146
    only_matching = 1;
#line 2147
    goto switch_break;
    case_113: /* CIL Label */
#line 2150
    exit_on_match = 1;
#line 2151
    exit_failure = (int volatile   )0;
#line 2152
    goto switch_break;
    case_82: /* CIL Label */
#line 2155
    fts_options = 778;
    case_114: /* CIL Label */
#line 2158
    directories = (enum directories_type )3;
#line 2159
    last_recursive = prev_optind;
#line 2160
    goto switch_break;
    case_115: /* CIL Label */
#line 2163
    suppress_errors = 1;
#line 2164
    goto switch_break;
    case_118: /* CIL Label */
#line 2167
    out_invert = (_Bool)1;
#line 2168
    goto switch_break;
    case_119: /* CIL Label */
#line 2171
    match_words = 1;
#line 2172
    goto switch_break;
    case_120: /* CIL Label */
#line 2175
    match_lines = 1;
#line 2176
    goto switch_break;
    case_90: /* CIL Label */
#line 2179
    filename_mask = 0;
#line 2180
    goto switch_break;
    case_122: /* CIL Label */
#line 2183
    eolbyte = (unsigned char )'\000';
#line 2184
    goto switch_break;
    case_128: /* CIL Label */
    {
#line 2187
    tmp___20 = strcmp((char const   *)optarg, "binary");
    }
#line 2187
    if (tmp___20 == 0) {
#line 2188
      binary_files = (enum __anonenum_binary_files_601436154 )0;
    } else {
      {
#line 2189
      tmp___19 = strcmp((char const   *)optarg, "text");
      }
#line 2189
      if (tmp___19 == 0) {
#line 2190
        binary_files = (enum __anonenum_binary_files_601436154 )1;
      } else {
        {
#line 2191
        tmp___18 = strcmp((char const   *)optarg, "without-match");
        }
#line 2191
        if (tmp___18 == 0) {
#line 2192
          binary_files = (enum __anonenum_binary_files_601436154 )2;
        } else {
          {
#line 2194
          tmp___17 = gettext("unknown binary-files type");
#line 2194
          error(2, 0, (char const   *)tmp___17);
          }
        }
      }
    }
#line 2195
    goto switch_break;
    case_129: /* CIL Label */
#line 2198
    if (optarg) {
      {
#line 2200
      tmp___27 = strcasecmp((char const   *)optarg, "always");
      }
#line 2200
      if (tmp___27) {
        {
#line 2200
        tmp___28 = strcasecmp((char const   *)optarg, "yes");
        }
#line 2200
        if (tmp___28) {
          {
#line 2200
          tmp___29 = strcasecmp((char const   *)optarg, "force");
          }
#line 2200
          if (tmp___29) {
            {
#line 2203
            tmp___24 = strcasecmp((char const   *)optarg, "never");
            }
#line 2203
            if (tmp___24) {
              {
#line 2203
              tmp___25 = strcasecmp((char const   *)optarg, "no");
              }
#line 2203
              if (tmp___25) {
                {
#line 2203
                tmp___26 = strcasecmp((char const   *)optarg, "none");
                }
#line 2203
                if (tmp___26) {
                  {
#line 2206
                  tmp___21 = strcasecmp((char const   *)optarg, "auto");
                  }
#line 2206
                  if (tmp___21) {
                    {
#line 2206
                    tmp___22 = strcasecmp((char const   *)optarg, "tty");
                    }
#line 2206
                    if (tmp___22) {
                      {
#line 2206
                      tmp___23 = strcasecmp((char const   *)optarg, "if-tty");
                      }
#line 2206
                      if (tmp___23) {
#line 2210
                        show_help = 1;
                      } else {
#line 2208
                        color_option = 2;
                      }
                    } else {
#line 2208
                      color_option = 2;
                    }
                  } else {
#line 2208
                    color_option = 2;
                  }
                } else {
#line 2205
                  color_option = 0;
                }
              } else {
#line 2205
                color_option = 0;
              }
            } else {
#line 2205
              color_option = 0;
            }
          } else {
#line 2202
            color_option = 1;
          }
        } else {
#line 2202
          color_option = 1;
        }
      } else {
#line 2202
        color_option = 1;
      }
    } else {
#line 2213
      color_option = 2;
    }
#line 2214
    goto switch_break;
    case_130: /* CIL Label */
    case_131: /* CIL Label */
#line 2218
    if (! excluded_patterns) {
      {
#line 2219
      excluded_patterns = new_exclude();
      }
    }
#line 2220
    if (opt == 130) {
#line 2220
      tmp___30 = 1 << 29;
    } else {
#line 2220
      tmp___30 = 0;
    }
    {
#line 2220
    add_exclude(excluded_patterns, (char const   *)optarg, (1 << 28) | tmp___30);
    }
#line 2223
    goto switch_break;
    case_132: /* CIL Label */
#line 2225
    if (! excluded_patterns) {
      {
#line 2226
      excluded_patterns = new_exclude();
      }
    }
    {
#line 2227
    tmp___32 = add_exclude_file(& add_exclude, excluded_patterns, (char const   *)optarg,
                                1 << 28, (char )'\n');
    }
#line 2227
    if (tmp___32 != 0) {
      {
#line 2230
      tmp___31 = __errno_location();
#line 2230
      error(2, *tmp___31, "%s", optarg);
      }
    }
#line 2232
    goto switch_break;
    case_135: /* CIL Label */
#line 2235
    if (! excluded_directory_patterns) {
      {
#line 2236
      excluded_directory_patterns = new_exclude();
      }
    }
    {
#line 2237
    add_exclude(excluded_directory_patterns, (char const   *)optarg, 1 << 28);
    }
#line 2238
    goto switch_break;
    case_136: /* CIL Label */
#line 2241
    group_separator = (char const   *)optarg;
#line 2242
    goto switch_break;
    case_133: /* CIL Label */
#line 2245
    line_buffered = 1;
#line 2246
    goto switch_break;
    case_134: /* CIL Label */
#line 2249
    label = optarg;
#line 2250
    goto switch_break;
    case_0___0: /* CIL Label */
#line 2254
    goto switch_break;
    switch_default___0: /* CIL Label */
    {
#line 2257
    usage(2);
    }
#line 2258
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2262
  if (color_option == 2) {
    {
#line 2263
    tmp___33 = isatty(1);
    }
#line 2263
    if (tmp___33) {
      {
#line 2263
      tmp___34 = should_colorize();
      }
#line 2263
      if (tmp___34) {
#line 2263
        tmp___35 = 1;
      } else {
#line 2263
        tmp___35 = 0;
      }
    } else {
#line 2263
      tmp___35 = 0;
    }
#line 2263
    color_option = tmp___35;
  }
  {
#line 2264
  init_colorize();
  }
#line 2268
  if (exit_on_match) {
#line 2269
    list_files = 0;
  }
#line 2270
  if (exit_on_match | list_files) {
#line 2272
    count_matches = 0;
#line 2273
    done_on_match = 1;
  }
#line 2275
  out_quiet = count_matches | done_on_match;
#line 2277
  if (out_after < 0L) {
#line 2278
    out_after = default_context;
  }
#line 2279
  if (out_before < 0L) {
#line 2280
    out_before = default_context;
  }
#line 2282
  if (color_option) {
    {
#line 2285
    tmp___36 = getenv("GREP_COLOR");
#line 2285
    userval = tmp___36;
    }
#line 2286
    if ((unsigned long )userval != (unsigned long )((void *)0)) {
#line 2286
      if ((int )*userval != 0) {
#line 2287
        context_match_color = (char const   *)userval;
#line 2287
        selected_match_color = context_match_color;
      }
    }
    {
#line 2290
    parse_grep_colors();
    }
  }
#line 2293
  if (show_version) {
    {
#line 2295
    tmp___37 = gettext("others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>");
#line 2295
    tmp___38 = proper_name("Mike Haertel");
#line 2295
    version_etc(stdout, program_name, "GNU grep", "2.19", tmp___38, tmp___37, (char *)((void *)0));
#line 2297
    exit(0);
    }
  }
#line 2300
  if (show_help) {
    {
#line 2301
    usage(0);
    }
  }
  {
#line 2304
  tmp___39 = fstat(1, & tmp_stat);
  }
#line 2304
  if (tmp___39 == 0) {
#line 2304
    if ((tmp_stat.st_mode & 61440U) == 32768U) {
#line 2305
      out_stat = tmp_stat;
    }
  }
#line 2307
  if (keys) {
#line 2309
    if (keycc == 0UL) {
#line 2312
      out_invert = (_Bool )((int )out_invert ^ 1);
#line 2313
      match_words = 0;
#line 2313
      match_lines = match_words;
    } else {
#line 2317
      keycc --;
    }
  } else
#line 2319
  if (optind < argc) {
    {
#line 2322
    keycc = strlen((char const   *)*(argv + optind));
#line 2323
    tmp___40 = optind;
#line 2323
    optind ++;
#line 2323
    tmp___41 = xmemdup((void const   *)*(argv + tmp___40), keycc + 1UL);
#line 2323
    keys = (char *)tmp___41;
    }
  } else {
    {
#line 2326
    usage(2);
    }
  }
#line 2331
  if ((unsigned long )compile == (unsigned long )(& Fcompile)) {
    {
#line 2331
    tmp___42 = __ctype_get_mb_cur_max();
    }
#line 2331
    if (tmp___42 > 1UL) {
#line 2331
      if (match_icase) {
#line 2331
        goto _L;
      } else {
        {
#line 2331
        tmp___43 = contains_encoding_error((char const   *)keys, keycc);
        }
#line 2331
        if (tmp___43) {
          _L: /* CIL Label */
          {
#line 2336
          fgrep_to_grep_pattern(keycc, (char const   *)keys, & new_keycc, & new_keys);
#line 2337
          free((void *)keys);
#line 2338
          keys = new_keys;
#line 2339
          keycc = new_keycc;
#line 2340
          matcher = "grep";
#line 2341
          compile = & Gcompile;
#line 2342
          execute = & EGexecute;
          }
        }
      }
    }
  }
  {
#line 2345
  tmp___44 = __ctype_get_mb_cur_max();
  }
#line 2345
  if (tmp___44 > 1UL) {
    {
#line 2346
    build_mbclen_cache();
    }
  }
  {
#line 2348
  (*compile)((char const   *)keys, keycc);
#line 2349
  free((void *)keys);
  }
#line 2351
  if (argc - optind > 1) {
#line 2351
    if (! no_filenames) {
#line 2352
      out_file = 1;
    } else {
#line 2351
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 2351
  if (with_filenames) {
#line 2352
    out_file = 1;
  }
  {
#line 2357
  tmp___45 = isatty(1);
  }
#line 2357
  if (! tmp___45) {
    {
#line 2358
    set_binary_mode(1, 0);
    }
  }
#line 2361
  if (max_count == 0L) {
    {
#line 2362
    exit(1);
    }
  }
#line 2364
  if (fts_options & 2) {
#line 2364
    if ((unsigned int )devices == 0U) {
#line 2365
      devices = (enum __anonenum_devices_473526324 )1;
    }
  }
#line 2367
  if (optind < argc) {
#line 2369
    status = 1;
    {
#line 2370
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2371
      tmp___46 = grep_command_line_arg((char const   *)*(argv + optind));
#line 2371
      status &= tmp___46;
#line 2370
      optind ++;
      }
#line 2370
      if (! (optind < argc)) {
#line 2370
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 2374
  if ((unsigned int )directories == 3U) {
#line 2374
    if (prepended < last_recursive) {
      {
#line 2377
      filename_prefix_len = (size_t )2;
#line 2378
      status = grep_command_line_arg(".");
      }
    } else {
      {
#line 2381
      status = grep_command_line_arg("-");
      }
    }
  } else {
    {
#line 2381
    status = grep_command_line_arg("-");
    }
  }
#line 2384
  if (errseen) {
#line 2384
    tmp___47 = 2;
  } else {
#line 2384
    tmp___47 = status;
  }
  {
#line 2384
  exit(tmp___47);
  }
}
}
