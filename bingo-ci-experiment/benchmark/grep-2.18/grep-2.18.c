/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 25 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_1012844490 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_1012844490 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 169 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 181 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 108 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 203 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 63 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options ;
#line 55 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 723 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 117 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 210 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 52 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 275 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.h"
typedef struct I_ring I_ring;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 53 "/home/khheo/project/benchmark/grep-2.18/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/khheo/project/benchmark/grep-2.18/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "/home/khheo/project/benchmark/grep-2.18/lib/hash.h"
typedef struct hash_table Hash_table;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
struct _ftsent ;
#line 74
struct cycle_check_state ;
#line 74 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
struct __anonstruct_FTS_696447632 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 74 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
typedef struct __anonstruct_FTS_696447632 FTS;
#line 195 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 195 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 7 "/home/khheo/project/benchmark/grep-2.18/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 743 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.h"
struct exclude ;
#line 74 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 82 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 89
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 95 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 95 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 109 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
};
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 63 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.c"
union __anonunion_tmp_771759453___0 {
   unsigned int align ;
   char buf[4096] ;
};
#line 33 "/home/khheo/project/benchmark/grep-2.18/src/kwset.h"
struct kwset ;
#line 34 "/home/khheo/project/benchmark/grep-2.18/src/kwset.h"
typedef struct kwset *kwset_t;
#line 43 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
typedef signed char mb_len_map_t;
#line 324 "/usr/include/pcre.h"
struct real_pcre ;
#line 325 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 333
struct real_pcre_jit_stack ;
#line 334 "/usr/include/pcre.h"
typedef struct real_pcre_jit_stack pcre_jit_stack;
#line 376 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 29 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
struct matcher {
   char const   *name ;
   void (*compile)(char const   * , size_t  ) ;
   size_t (*execute)(char const   * , size_t  , size_t * , char const   * ) ;
};
#line 231 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
struct color_cap {
   char const   *name ;
   char const   **var ;
   void (*fct)(void) ;
};
#line 365
enum directories_type {
    READ_DIRECTORIES = 2,
    RECURSE_DIRECTORIES = 3,
    SKIP_DIRECTORIES = 4
} ;
#line 389
enum __anonenum_devices_473526324 {
    READ_COMMAND_LINE_DEVICES = 0,
    READ_DEVICES = 1,
    SKIP_DEVICES = 2
} ;
#line 658
enum __anonenum_binary_files_601436154 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
#line 823 "/usr/include/stdio.h"
struct obstack ;
#line 24 "/home/khheo/project/benchmark/grep-2.18/src/kwset.h"
struct kwsmatch {
   size_t index ;
   size_t offset[1] ;
   size_t size[1] ;
};
#line 142 "../lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "../lib/obstack.h"
union __anonunion_temp_267926141 {
   long tempint ;
   void *tempptr ;
};
#line 149 "../lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_267926141 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 53 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
struct trie ;
#line 53 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
#line 63 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
struct trie {
   size_t accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   int depth ;
   int shift ;
   int maxshift ;
};
#line 76 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
struct kwset {
   struct obstack obstack ;
   ptrdiff_t words ;
   struct trie *trie ;
   int mind ;
   int maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   int mind2 ;
   char const   *trans ;
};
#line 140
enum __anonenum_dirs_744895363 {
    L = 0,
    R = 1
} ;
#line 61 "../lib/regex.h"
typedef int __re_idx_t;
#line 62 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 63 "../lib/regex.h"
typedef unsigned long __re_long_size_t;
#line 79 "../lib/regex.h"
typedef unsigned long reg_syntax_t;
#line 423
struct re_dfa_t ;
#line 423 "../lib/regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 499 "../lib/regex.h"
typedef int regoff_t;
#line 506 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 26 "/home/khheo/project/benchmark/grep-2.18/src/dfa.h"
struct dfamust {
   int exact ;
   char *must ;
   struct dfamust *next ;
};
#line 34
struct dfa ;
#line 38 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
struct patterns {
   struct re_pattern_buffer regexbuf ;
   struct re_registers regs ;
};
#line 70
enum __anonenum_mode_962123750 {
    DW_NONE = 0,
    DW_POSIX = 1,
    DW_GNU = 2
} ;
#line 488 "../lib/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
typedef unsigned long wctype_t;
#line 91 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef unsigned int charclass[(((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))];
#line 169 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef ptrdiff_t token;
#line 265 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 265 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 272 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct __anonstruct_position_set_1029076553 {
   position *elems ;
   size_t nelem ;
   size_t alloc ;
};
#line 272 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef struct __anonstruct_position_set_1029076553 position_set;
#line 280 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 280 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 289 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct __anonstruct_dfa_state_766514293 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   char backref ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
};
#line 289 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef struct __anonstruct_dfa_state_766514293 dfa_state;
#line 304 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef ptrdiff_t state_num;
#line 308 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   int invert ;
   wchar_t *chars ;
   size_t nchars ;
   wctype_t *ch_classes ;
   size_t nch_classes ;
   wchar_t *range_sts ;
   wchar_t *range_ends ;
   size_t nranges ;
   char **equivs ;
   size_t nequivs ;
   char **coll_elems ;
   size_t ncoll_elems ;
};
#line 326 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct dfa {
   charclass *charclasses ;
   size_t cindex ;
   size_t calloc ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   unsigned int mb_cur_max ;
   token utf8_anychar_classes[5] ;
   size_t nmultibyte_prop ;
   int *multibyte_prop ;
   struct mb_char_classes *mbcsets ;
   size_t nmbcsets ;
   size_t mbcsets_alloc ;
   dfa_state *states ;
   state_num sindex ;
   state_num salloc ;
   position_set *follows ;
   int searchflag ;
   state_num tralloc ;
   int trcount ;
   state_num **trans ;
   state_num **realtrans ;
   state_num **fails ;
   int *success ;
   state_num *newlines ;
   struct dfamust *musts ;
};
#line 871 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef int predicate(int  );
#line 877 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 2896
enum __anonenum_status_transit_state_270105753 {
    TRANSIT_STATE_IN_PROGRESS = 0,
    TRANSIT_STATE_DONE = 1,
    TRANSIT_STATE_END_BUFFER = 2
} ;
#line 2896 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef enum __anonenum_status_transit_state_270105753 status_transit_state;
#line 3865 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct __anonstruct_must_343724373 {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
};
#line 3865 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
typedef struct __anonstruct_must_343724373 must;
#line 45 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                    96U, "xstrtoul");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                  96U, "xstrtoul");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
#line 102
  q = s;
#line 103
  ch = (unsigned char )*q;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp___1 = __ctype_b_loc();
    }
#line 104
    if (! ((int const   )*(*tmp___1 + (int )ch) & 8192)) {
#line 104
      goto while_break;
    }
#line 105
    q ++;
#line 105
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if ((int )ch == 45) {
#line 107
    return ((strtol_error )4);
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = 1UL;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */ 
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 177
    overflow = bkm_scale(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 194
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 199
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 213
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 217
    overflow = bkm_scale(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 44 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___0(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                    96U, "xstrtol");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                  96U, "xstrtol");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = 1L;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */ 
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 177
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 194
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 199
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 213
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 217
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/grep-2.18/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 91 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale___1(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___1(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                    96U, "xstrtoimax");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c",
                  96U, "xstrtoimax");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 110
  tmp___2 = __errno_location();
#line 110
  *tmp___2 = 0;
#line 111
  tmp = strtoimax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 113
  if ((unsigned long )*p == (unsigned long )s) {
#line 117
    if (valid_suffixes) {
#line 117
      if (*(*p)) {
        {
#line 117
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 117
        if (tmp___3) {
#line 118
          tmp = (intmax_t )1;
        } else {
#line 120
          return ((strtol_error )4);
        }
      } else {
#line 120
        return ((strtol_error )4);
      }
    } else {
#line 120
      return ((strtol_error )4);
    }
  } else {
    {
#line 122
    tmp___5 = __errno_location();
    }
#line 122
    if (*tmp___5 != 0) {
      {
#line 124
      tmp___4 = __errno_location();
      }
#line 124
      if (*tmp___4 != 34) {
#line 125
        return ((strtol_error )4);
      }
#line 126
      err = (strtol_error )1;
    }
  }
#line 132
  if (! valid_suffixes) {
#line 134
    *val = tmp;
#line 135
    return (err);
  }
#line 138
  if ((int )*(*p) != 0) {
    {
#line 140
    base = 1024;
#line 141
    suffixes = 1;
#line 144
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 144
    if (! tmp___6) {
#line 146
      *val = tmp;
#line 147
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 150
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 150
    if (tmp___7) {
      {
#line 161
      if ((int )*(*(p + 0) + 1) == 105) {
#line 161
        goto case_105;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 68) {
#line 167
        goto case_68;
      }
#line 167
      if ((int )*(*(p + 0) + 1) == 66) {
#line 167
        goto case_68;
      }
#line 159
      goto switch_break;
      case_105: /* CIL Label */ 
#line 162
      if ((int )*(*(p + 0) + 2) == 66) {
#line 163
        suffixes += 2;
      }
#line 164
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 168
      base = 1000;
#line 169
      suffixes ++;
#line 170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 176
    if ((int )*(*p) == 98) {
#line 176
      goto case_98;
    }
#line 180
    if ((int )*(*p) == 66) {
#line 180
      goto case_66___0;
    }
#line 184
    if ((int )*(*p) == 99) {
#line 184
      goto case_99;
    }
#line 188
    if ((int )*(*p) == 69) {
#line 188
      goto case_69;
    }
#line 193
    if ((int )*(*p) == 103) {
#line 193
      goto case_103;
    }
#line 193
    if ((int )*(*p) == 71) {
#line 193
      goto case_103;
    }
#line 198
    if ((int )*(*p) == 75) {
#line 198
      goto case_75;
    }
#line 198
    if ((int )*(*p) == 107) {
#line 198
      goto case_75;
    }
#line 203
    if ((int )*(*p) == 109) {
#line 203
      goto case_109;
    }
#line 203
    if ((int )*(*p) == 77) {
#line 203
      goto case_109;
    }
#line 207
    if ((int )*(*p) == 80) {
#line 207
      goto case_80;
    }
#line 212
    if ((int )*(*p) == 116) {
#line 212
      goto case_116;
    }
#line 212
    if ((int )*(*p) == 84) {
#line 212
      goto case_116;
    }
#line 216
    if ((int )*(*p) == 119) {
#line 216
      goto case_119;
    }
#line 220
    if ((int )*(*p) == 89) {
#line 220
      goto case_89;
    }
#line 224
    if ((int )*(*p) == 90) {
#line 224
      goto case_90;
    }
#line 228
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 177
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 178
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 182
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 185
    overflow = (strtol_error )0;
#line 186
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 190
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 194
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 195
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 199
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 200
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 205
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 209
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 213
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 214
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 217
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 218
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 222
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 226
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 229
    *val = tmp;
#line 230
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 233
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 234
    *p += suffixes;
#line 235
    if (*(*p)) {
#line 236
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 239
  *val = tmp;
#line 240
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/grep-2.18/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 44 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 55
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 66
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 55
void xalloc_die(void) ;
#line 57
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 100
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 102 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 105
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 105
    tmp = -1;
  } else {
#line 105
    tmp = -2;
  }
#line 105
  if ((size_t )tmp / s < n) {
    {
#line 106
    xalloc_die();
    }
  }
  {
#line 107
  tmp___0 = xmalloc(n * s);
  }
#line 107
  return (tmp___0);
}
}
#line 113
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 115 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 118
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 118
    tmp = -1;
  } else {
#line 118
    tmp = -2;
  }
#line 118
  if ((size_t )tmp / s < n) {
    {
#line 119
    xalloc_die();
    }
  }
  {
#line 120
  tmp___0 = xrealloc(p, n * s);
  }
#line 120
  return (tmp___0);
}
}
#line 178 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 181
  n = *pn;
#line 183
  if (! p) {
#line 185
    if (! n) {
#line 193
      n = 128UL / s;
#line 194
      n += (size_t )(! n);
    }
  } else {
#line 203
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 204
      xalloc_die();
      }
    }
#line 205
    n += (n + 1UL) / 2UL;
  }
  {
#line 208
  *pn = n;
#line 209
  tmp = xrealloc(p, n * s);
  }
#line 209
  return (tmp);
}
}
#line 215
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 217
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 217 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 220
  if (sizeof(char ) == 1UL) {
    {
#line 220
    tmp = xmalloc(n);
#line 220
    tmp___1 = tmp;
    }
  } else {
    {
#line 220
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 220
    tmp___1 = tmp___0;
    }
  }
#line 220
  return ((char *)tmp___1);
}
}
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/khheo/project/benchmark/grep-2.18/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 59
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 61
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 65
void *x2realloc(void *p , size_t *pn ) ;
#line 66
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 68
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/grep-2.18/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 20 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1728]  = 
#line 35 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 280 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 280
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 314
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 314 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 318
  if (uc >> 9 < 240U) {
#line 320
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 321
    if (ind >= 0) {
#line 322
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 324
        if (uc > 0U) {
#line 324
          if (uc < 160U) {
#line 325
            return (-1);
          } else {
#line 327
            return (0);
          }
        } else {
#line 327
          return (0);
        }
      }
    }
  } else
#line 330
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 332
    if (uc >= 917760U) {
#line 334
      if (uc <= 917999U) {
#line 335
        return (0);
      }
    } else {
#line 339
      if (uc >= 917536U) {
#line 339
        tmp = uc <= 917631U;
      } else {
#line 339
        tmp = uc == 917505U;
      }
#line 339
      if (tmp) {
#line 340
        return (0);
      }
    }
  }
#line 347
  if (uc >= 4352U) {
#line 347
    if (uc < 4448U) {
#line 361
      return (2);
    } else
#line 347
    if (uc >= 9001U) {
#line 347
      if (uc < 9003U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 347
    if (uc >= 11904U) {
#line 347
      if (uc < 42192U) {
#line 347
        if (! (uc == 12351U)) {
#line 347
          if (uc >= 19904U) {
#line 347
            if (uc < 19968U) {
#line 347
              goto _L___8;
            } else {
#line 361
              return (2);
            }
          } else {
#line 361
            return (2);
          }
        } else {
#line 347
          goto _L___8;
        }
      } else {
#line 347
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 347
    if (uc >= 44032U) {
#line 347
      if (uc < 55204U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 347
    if (uc >= 63744U) {
#line 347
      if (uc < 64256U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 347
    if (uc >= 65040U) {
#line 347
      if (uc < 65056U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 347
    if (uc >= 65072U) {
#line 347
      if (uc < 65136U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 347
    if (uc >= 65280U) {
#line 347
      if (uc < 65377U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 347
    if (uc >= 65504U) {
#line 347
      if (uc < 65511U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 347
    if (uc >= 131072U) {
#line 347
      if (uc <= 196607U) {
#line 361
        return (2);
      } else {
#line 347
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 347
    if (uc >= 196608U) {
#line 347
      if (uc <= 262143U) {
#line 361
        return (2);
      }
    }
  }
#line 364
  if (uc >= 161U) {
#line 364
    if (uc < 65377U) {
#line 364
      if (uc != 8361U) {
        {
#line 364
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 364
        if (tmp___0) {
#line 366
          return (2);
        }
      }
    }
  }
#line 367
  return (1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2014);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-grep@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU grep", "http://www.gnu.org/software/grep/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 312 "./unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 23 "/home/khheo/project/benchmark/grep-2.18/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 28
  if (uc < 128U) {
#line 30
    return (-2);
  } else
#line 31
  if (uc < 2048U) {
#line 32
    count = 2;
  } else
#line 33
  if (uc < 65536U) {
#line 35
    if (uc < 55296U) {
#line 36
      count = 3;
    } else
#line 35
    if (uc >= 57344U) {
#line 36
      count = 3;
    } else {
#line 38
      return (-1);
    }
  } else
#line 48
  if (uc < 1114112U) {
#line 49
    count = 4;
  } else {
#line 52
    return (-1);
  }
#line 54
  if (n < count) {
#line 55
    return (-2);
  }
  {
#line 63
  if (count == 4) {
#line 63
    goto case_4;
  }
#line 64
  if (count == 3) {
#line 64
    goto case_3;
  }
#line 65
  if (count == 2) {
#line 65
    goto case_2;
  }
#line 57
  goto switch_break;
  case_4: /* CIL Label */ 
#line 63
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 63
  uc >>= 6;
#line 63
  uc |= 65536U;
  case_3: /* CIL Label */ 
#line 64
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 64
  uc >>= 6;
#line 64
  uc |= 2048U;
  case_2: /* CIL Label */ 
#line 65
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 192U;
#line 66
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 68
  return (count);
}
}
#line 290 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 23 "/home/khheo/project/benchmark/grep-2.18/lib/unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ 
  uint8_t c ;

  {
#line 26
  c = (uint8_t )*s;
#line 28
  if ((int )c < 128) {
#line 30
    *puc = (ucs4_t )c;
#line 31
    return (1);
  } else
#line 33
  if ((int )c >= 194) {
#line 35
    if ((int )c < 224) {
#line 37
      if (n >= 2UL) {
#line 39
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 41
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 43
          return (2);
        }
      } else {
#line 50
        *puc = (ucs4_t )65533;
#line 51
        return (-2);
      }
    } else
#line 54
    if ((int )c < 240) {
#line 56
      if (n >= 2UL) {
#line 58
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 58
          if ((int )c >= 225) {
#line 58
            goto _L___0;
          } else
#line 58
          if ((int const   )*(s + 1) >= 160) {
            _L___0: /* CIL Label */ 
#line 58
            if ((int )c != 237) {
#line 58
              goto _L;
            } else
#line 58
            if ((int const   )*(s + 1) < 160) {
              _L: /* CIL Label */ 
#line 62
              if (n >= 3UL) {
#line 64
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 66
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 69
                  return (3);
                }
              } else {
#line 76
                *puc = (ucs4_t )65533;
#line 77
                return (-2);
              }
            }
          }
        }
      } else {
#line 85
        *puc = (ucs4_t )65533;
#line 86
        return (-2);
      }
    } else
#line 89
    if ((int )c < 248) {
#line 91
      if (n >= 2UL) {
#line 93
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 93
          if ((int )c >= 241) {
#line 93
            goto _L___2;
          } else
#line 93
          if ((int const   )*(s + 1) >= 144) {
            _L___2: /* CIL Label */ 
#line 93
            if ((int )c < 244) {
#line 93
              goto _L___1;
            } else
#line 93
            if ((int )c == 244) {
#line 93
              if ((int const   )*(s + 1) < 144) {
                _L___1: /* CIL Label */ 
#line 100
                if (n >= 3UL) {
#line 102
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 104
                    if (n >= 4UL) {
#line 106
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 108
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 112
                        return (4);
                      }
                    } else {
#line 119
                      *puc = (ucs4_t )65533;
#line 120
                      return (-2);
                    }
                  }
                } else {
#line 128
                  *puc = (ucs4_t )65533;
#line 129
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 137
        *puc = (ucs4_t )65533;
#line 138
        return (-2);
      }
    }
  }
#line 283
  *puc = (ucs4_t )65533;
#line 284
  return (-1);
}
}
#line 33 "/home/khheo/project/benchmark/grep-2.18/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 367
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 246 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
__inline int mb_width_aux(wint_t wc ) 
{ 
  int w ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 249
  tmp = wcwidth((wchar_t )wc);
#line 249
  w = tmp;
  }
#line 252
  if (w >= 0) {
#line 252
    tmp___3 = w;
  } else {
    {
#line 252
    tmp___2 = iswcntrl(wc);
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 0;
    } else {
#line 252
      tmp___1 = 1;
    }
#line 252
    tmp___3 = tmp___1;
  }
#line 252
  return (tmp___3);
}
}
#line 267 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
__inline void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 270
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 272
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 273
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 276
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 277
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 278
  tmp = (_Bool )old_mbc->wc_valid;
#line 278
  new_mbc->wc_valid = tmp;
#line 278
  if (tmp) {
#line 279
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 280
  return;
}
}
#line 313
unsigned int const   is_basic_table[8] ;
#line 315 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
__inline _Bool is_basic(char c ) 
{ 


  {
#line 318
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 123 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
__inline void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp___2 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___6 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___6) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp___2) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h",
                    142U, "mbiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 147
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 150
      iter->cur.bytes = (size_t )1;
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 155
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 158
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 159
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 165
      if (iter->cur.bytes == 0UL) {
#line 168
        iter->cur.bytes = (size_t )1;
#line 169
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 169
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h",
                        169U, "mbiter_multi_next");
          }
        }
#line 170
        if (! (iter->cur.wc == 0)) {
          {
#line 170
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h",
                        170U, "mbiter_multi_next");
          }
        }
      }
      {
#line 172
      iter->cur.wc_valid = (_Bool)1;
#line 176
      tmp___5 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 176
      if (tmp___5) {
#line 177
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 180
  iter->next_done = (_Bool)1;
#line 181
  return;
}
}
#line 183 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
__inline void mbiter_multi_reloc(struct mbiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 186
  iter->cur.ptr += ptrdiff;
#line 187
  iter->limit += ptrdiff;
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
__inline void mbiter_multi_copy(struct mbiter_multi *new_iter , struct mbiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 193
  new_iter->limit = (char const   *)old_iter->limit;
#line 194
  tmp = (_Bool )old_iter->in_shift;
#line 194
  new_iter->in_shift = tmp;
#line 194
  if (tmp) {
    {
#line 195
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 197
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 198
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 199
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 200
  return;
}
}
#line 223
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
            {
#line 78
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 78
            if (! tmp___4) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
            {
#line 84
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 84
            if (! tmp___5) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (tmp___7) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
            {
#line 92
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 92
            if (! tmp___6) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*p) {
          {
#line 113
          tmp___8 = __ctype_b_loc();
          }
#line 113
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
#line 113
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___9 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 120
    if (how != 1) {
      {
#line 122
      tmp___10 = strlen((char const   *)d);
#line 122
      p = (d + tmp___10) - 1;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 122
          tmp___11 = __ctype_b_loc();
          }
#line 122
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            goto while_break___2;
          }
        } else {
#line 122
          goto while_break___2;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (d);
}
}
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-2.18/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-2.18/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 42
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/grep-2.18/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 55
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (insize > 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 72
    res = tmp___0;
    }
#line 76
    if (res == 0xffffffffffffffffUL) {
      {
#line 78
      tmp___2 = __errno_location();
      }
#line 78
      if (! (*tmp___2 == 7)) {
        {
#line 80
        tmp___1 = __errno_location();
        }
#line 80
        if (*tmp___1 == 22) {
#line 81
          goto while_break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  outptr___0 = tmp.buf;
#line 104
  outsize___0 = (size_t )4096;
#line 105
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 105
  res___0 = tmp___3;
  }
#line 107
  if (res___0 == 0xffffffffffffffffUL) {
#line 108
    return (-1);
  }
#line 109
  count += (size_t )(outptr___0 - tmp.buf);
#line 112
  length = count;
#line 116
  if (length == 0UL) {
#line 118
    *lengthp = (size_t )0;
#line 119
    return (0);
  }
#line 121
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 121
    if (*lengthp >= length) {
#line 122
      result = *resultp;
    } else {
#line 121
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 125
    tmp___4 = malloc(length);
#line 125
    result = (char *)tmp___4;
    }
#line 126
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 128
      tmp___5 = __errno_location();
#line 128
      *tmp___5 = 12;
      }
#line 129
      return (-1);
    }
  }
  {
#line 138
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 143
  inptr___0 = src;
#line 144
  insize___0 = srclen;
#line 145
  outptr___1 = result;
#line 146
  outsize___1 = length;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (insize___0 > 0UL)) {
#line 148
      goto while_break___0;
    }
    {
#line 150
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 150
    res___1 = tmp___6;
    }
#line 154
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 156
      tmp___7 = __errno_location();
      }
#line 156
      if (*tmp___7 == 22) {
#line 157
        goto while_break___0;
      } else {
#line 159
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 178
  res___2 = tmp___8;
  }
#line 180
  if (res___2 == 0xffffffffffffffffUL) {
#line 181
    goto fail;
  }
#line 184
  if (outsize___1 != 0UL) {
    {
#line 185
    abort();
    }
  }
#line 188
  *resultp = result;
#line 189
  *lengthp = length;
#line 191
  return (0);
  fail: 
#line 195
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 197
    tmp___9 = __errno_location();
#line 197
    saved_errno = *tmp___9;
#line 198
    free((void *)result);
#line 199
    tmp___10 = __errno_location();
#line 199
    *tmp___10 = saved_errno;
    }
  }
#line 201
  return (-1);
}
}
#line 206 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used___0 ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___1 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 255
  inptr = src;
#line 256
  tmp = strlen(src);
#line 256
  inbytes_remaining = tmp;
#line 261
  result_size = inbytes_remaining;
#line 263
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 264
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 265
    result_size *= 16UL;
  }
  {
#line 267
  result_size ++;
#line 269
  tmp___0 = malloc(result_size);
#line 269
  result = (char *)tmp___0;
  }
#line 270
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 12;
    }
#line 273
    return ((char *)((void *)0));
  }
  {
#line 281
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 286
  outptr = result;
#line 287
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 293
    res = tmp___2;
    }
#line 297
    if (res == 0xffffffffffffffffUL) {
      {
#line 299
      tmp___7 = __errno_location();
      }
#line 299
      if (*tmp___7 == 22) {
#line 300
        goto while_break;
      } else {
        {
#line 301
        tmp___6 = __errno_location();
        }
#line 301
        if (*tmp___6 == 7) {
#line 303
          used___0 = (size_t )(outptr - result);
#line 304
          newsize = result_size * 2UL;
#line 307
          if (! (newsize > result_size)) {
            {
#line 309
            tmp___3 = __errno_location();
#line 309
            *tmp___3 = 12;
            }
#line 310
            goto failed;
          }
          {
#line 312
          tmp___4 = realloc((void *)result, newsize);
#line 312
          newresult = (char *)tmp___4;
          }
#line 313
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 315
            tmp___5 = __errno_location();
#line 315
            *tmp___5 = 12;
            }
#line 316
            goto failed;
          }
#line 318
          result = newresult;
#line 319
          result_size = newsize;
#line 320
          outptr = result + used___0;
#line 321
          outbytes_remaining = (result_size - 1UL) - used___0;
        } else {
#line 324
          goto failed;
        }
      }
    } else {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 336
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 336
    res___0 = tmp___8;
    }
#line 338
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 340
      tmp___12 = __errno_location();
      }
#line 340
      if (*tmp___12 == 7) {
#line 342
        used___1 = (size_t )(outptr - result);
#line 343
        newsize___0 = result_size * 2UL;
#line 346
        if (! (newsize___0 > result_size)) {
          {
#line 348
          tmp___9 = __errno_location();
#line 348
          *tmp___9 = 12;
          }
#line 349
          goto failed;
        }
        {
#line 351
        tmp___10 = realloc((void *)result, newsize___0);
#line 351
        newresult___0 = (char *)tmp___10;
        }
#line 352
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 354
          tmp___11 = __errno_location();
#line 354
          *tmp___11 = 12;
          }
#line 355
          goto failed;
        }
#line 357
        result = newresult___0;
#line 358
        result_size = newsize___0;
#line 359
        outptr = result + used___1;
#line 360
        outbytes_remaining = (result_size - 1UL) - used___1;
      } else {
#line 363
        goto failed;
      }
    } else {
#line 366
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  tmp___13 = outptr;
#line 371
  outptr ++;
#line 371
  *tmp___13 = (char )'\000';
#line 373
  length = (size_t )(outptr - result);
#line 377
  if (length < result_size) {
    {
#line 379
    tmp___14 = realloc((void *)result, length);
#line 379
    smaller_result = (char *)tmp___14;
    }
#line 381
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 382
      result = smaller_result;
    }
  }
#line 385
  return (result);
  failed: 
  {
#line 389
  tmp___15 = __errno_location();
#line 389
  saved_errno = *tmp___15;
#line 390
  free((void *)result);
#line 391
  tmp___16 = __errno_location();
#line 391
  *tmp___16 = saved_errno;
  }
#line 392
  return ((char *)((void *)0));
}
}
#line 400 "/home/khheo/project/benchmark/grep-2.18/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 403
  if ((int const   )*src == 0) {
#line 403
    goto _L;
  } else {
    {
#line 403
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 403
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 405
      tmp = strdup(src);
#line 405
      result = tmp;
      }
#line 407
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 408
        tmp___0 = __errno_location();
#line 408
        *tmp___0 = 12;
        }
      }
#line 409
      return (result);
    } else {
      {
#line 427
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 428
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 429
        return ((char *)((void *)0));
      }
      {
#line 431
      result___0 = str_cd_iconv(src, cd);
      }
#line 433
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 436
        tmp___1 = __errno_location();
#line 436
        saved_errno = *tmp___1;
#line 437
        iconv_close(cd);
#line 438
        tmp___2 = __errno_location();
#line 438
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 442
        tmp___5 = iconv_close(cd);
        }
#line 442
        if (tmp___5 < 0) {
          {
#line 446
          tmp___3 = __errno_location();
#line 446
          saved_errno___0 = *tmp___3;
#line 447
          free((void *)result___0);
#line 448
          tmp___4 = __errno_location();
#line 448
          *tmp___4 = saved_errno___0;
          }
#line 449
          return ((char *)((void *)0));
        }
      }
#line 452
      return (result___0);
    }
  }
}
}
#line 30 "/home/khheo/project/benchmark/grep-2.18/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 32
void free_cwd(struct saved_cwd *cwd ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 514
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 22 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 62 "/home/khheo/project/benchmark/grep-2.18/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;

  {
  {
#line 65
  cwd->name = (char *)((void *)0);
#line 67
  cwd->desc = open_safer(".", 0);
  }
#line 70
  if (cwd->desc < 0) {
    {
#line 72
    cwd->name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 73
    if (cwd->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
  {
#line 76
  set_cloexec_flag(cwd->desc, (_Bool)1);
  }
#line 77
  return (0);
}
}
#line 84 "/home/khheo/project/benchmark/grep-2.18/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd->desc) {
    {
#line 88
    tmp = fchdir((int )cwd->desc);
    }
#line 88
    return (tmp);
  } else {
    {
#line 90
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 90
    return (tmp___0);
  }
}
}
#line 93 "/home/khheo/project/benchmark/grep-2.18/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 96
  if (cwd->desc >= 0) {
    {
#line 97
    close(cwd->desc);
    }
  }
  {
#line 98
  free((void *)cwd->name);
  }
#line 99
  return;
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/grep-2.18/lib/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 236 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg ) ;
#line 324
char *quotearg(char const   *arg ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg ) ;
#line 363
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/grep-2.18/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 44
char const   *quote(char const   *arg ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 75 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 75 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 89 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 89
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 102 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 107 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  e = *tmp;
  }
#line 111
  if (o) {
#line 111
    tmp___0 = o;
  } else {
#line 111
    tmp___0 = & default_quoting_options;
  }
  {
#line 111
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 111
  p = (struct quoting_options *)tmp___1;
#line 113
  tmp___2 = __errno_location();
#line 113
  *tmp___2 = e;
  }
#line 114
  return (p);
}
}
#line 118 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 121
  if (o) {
#line 121
    tmp = o;
  } else {
#line 121
    tmp = & default_quoting_options;
  }
#line 121
  return (tmp->style);
}
}
#line 126 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 129
  if (o) {
#line 129
    tmp = o;
  } else {
#line 129
    tmp = & default_quoting_options;
  }
#line 129
  tmp->style = s;
#line 130
  return;
}
}
#line 137 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  if (o) {
#line 141
    tmp = o;
  } else {
#line 141
    tmp = & default_quoting_options;
  }
#line 141
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 153 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 157
  if (! o) {
#line 158
    o = & default_quoting_options;
  }
#line 159
  r = o->flags;
#line 160
  o->flags = i;
#line 161
  return (r);
}
}
#line 164 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 168
  if (! o) {
#line 169
    o = & default_quoting_options;
  }
#line 170
  o->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
#line 172
    abort();
    }
  } else
#line 171
  if (! right_quote) {
    {
#line 172
    abort();
    }
  }
#line 173
  o->left_quote = left_quote;
#line 174
  o->right_quote = right_quote;
#line 175
  return;
}
}
#line 178 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___0 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote("`", quoting_style);
#line 313
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___0 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___7 = i == argsize;
    }
#line 343
    if (tmp___7) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (argsize == 0xffffffffffffffffUL) {
#line 349
          if (1UL < quote_string_len) {
            {
#line 349
            argsize = strlen(arg);
#line 349
            tmp___0 = argsize;
            }
          } else {
#line 349
            tmp___0 = argsize;
          }
        } else {
#line 349
          tmp___0 = argsize;
        }
#line 349
        if (i + quote_string_len <= tmp___0) {
          {
#line 349
          tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___1 == 0) {
#line 359
            if (elide_outer_quotes) {
#line 360
              goto force_outer_quoting_style;
            }
#line 361
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 364
    c = (unsigned char )*(arg + i);
    {
#line 367
    if ((int )c == 0) {
#line 367
      goto case_0___0;
    }
#line 393
    if ((int )c == 63) {
#line 393
      goto case_63;
    }
#line 431
    if ((int )c == 7) {
#line 431
      goto case_7___0;
    }
#line 432
    if ((int )c == 8) {
#line 432
      goto case_8___0;
    }
#line 433
    if ((int )c == 12) {
#line 433
      goto case_12;
    }
#line 434
    if ((int )c == 10) {
#line 434
      goto case_10;
    }
#line 435
    if ((int )c == 13) {
#line 435
      goto case_13;
    }
#line 436
    if ((int )c == 9) {
#line 436
      goto case_9;
    }
#line 437
    if ((int )c == 11) {
#line 437
      goto case_11;
    }
#line 438
    if ((int )c == 92) {
#line 438
      goto case_92;
    }
#line 457
    if ((int )c == 125) {
#line 457
      goto case_125;
    }
#line 457
    if ((int )c == 123) {
#line 457
      goto case_125;
    }
#line 461
    if ((int )c == 126) {
#line 461
      goto case_126;
    }
#line 461
    if ((int )c == 35) {
#line 461
      goto case_126;
    }
#line 473
    if ((int )c == 124) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 96) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 94) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 91) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 62) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 61) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 60) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 59) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 42) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 41) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 40) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 38) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 36) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 34) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 33) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 32) {
#line 473
      goto case_124;
    }
#line 483
    if ((int )c == 39) {
#line 483
      goto case_39___0;
    }
#line 505
    if ((int )c == 122) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 121) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 120) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 119) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 118) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 117) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 116) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 115) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 114) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 113) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 112) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 111) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 110) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 109) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 108) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 107) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 106) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 105) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 104) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 103) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 102) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 101) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 100) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 99) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 98) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 97) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 95) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 93) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 90) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 89) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 88) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 87) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 86) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 85) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 84) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 83) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 82) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 81) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 80) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 79) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 78) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 77) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 76) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 75) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 74) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 73) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 72) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 71) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 70) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 69) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 68) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 67) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 66) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 65) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 58) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 57) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 56) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 55) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 54) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 53) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 52) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 51) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 50) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 49) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 48) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 47) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 46) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 45) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 44) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 43) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 37) {
#line 505
      goto case_122;
    }
#line 518
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 368
    if (backslash_escapes) {
#line 370
      if (elide_outer_quotes) {
#line 371
        goto force_outer_quoting_style;
      }
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 372
        if (len < buffersize) {
#line 372
          *(buffer___0 + len) = (char )'\\';
        }
#line 372
        len ++;
#line 372
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (i + 1UL < argsize) {
#line 378
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 378
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 380
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 380
              if (len < buffersize) {
#line 380
                *(buffer___0 + len) = (char )'0';
              }
#line 380
              len ++;
#line 380
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 381
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 381
              if (len < buffersize) {
#line 381
                *(buffer___0 + len) = (char )'0';
              }
#line 381
              len ++;
#line 381
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 383
      c = (unsigned char )'0';
    } else
#line 389
    if (flags & 1) {
#line 390
      goto __Cont;
    }
#line 391
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 396
    if ((unsigned int )quoting_style == 2U) {
#line 396
      goto case_2___0;
    }
#line 401
    if ((unsigned int )quoting_style == 3U) {
#line 401
      goto case_3___0;
    }
#line 426
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 397
    if (elide_outer_quotes) {
#line 398
      goto force_outer_quoting_style;
    }
#line 399
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 402
    if (flags & 4) {
#line 402
      if (i + 2UL < argsize) {
#line 402
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 408
            goto case_62;
          }
#line 421
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 411
          if (elide_outer_quotes) {
#line 412
            goto force_outer_quoting_style;
          }
#line 413
          c = (unsigned char )*(arg + (i + 2UL));
#line 414
          i += 2UL;
          {
#line 415
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 415
            if (len < buffersize) {
#line 415
              *(buffer___0 + len) = (char )'?';
            }
#line 415
            len ++;
#line 415
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 416
            if (len < buffersize) {
#line 416
              *(buffer___0 + len) = (char )'\"';
            }
#line 416
            len ++;
#line 416
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 417
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 417
            if (len < buffersize) {
#line 417
              *(buffer___0 + len) = (char )'\"';
            }
#line 417
            len ++;
#line 417
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 418
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 418
            if (len < buffersize) {
#line 418
              *(buffer___0 + len) = (char )'?';
            }
#line 418
            len ++;
#line 418
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 419
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 422
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 424
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 429
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 431
    esc = (unsigned char )'a';
#line 431
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 432
    esc = (unsigned char )'b';
#line 432
    goto c_escape;
    case_12: /* CIL Label */ 
#line 433
    esc = (unsigned char )'f';
#line 433
    goto c_escape;
    case_10: /* CIL Label */ 
#line 434
    esc = (unsigned char )'n';
#line 434
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 435
    esc = (unsigned char )'r';
#line 435
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 436
    esc = (unsigned char )'t';
#line 436
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 437
    esc = (unsigned char )'v';
#line 437
    goto c_escape;
    case_92: /* CIL Label */ 
#line 438
    esc = c;
#line 441
    if (backslash_escapes) {
#line 441
      if (elide_outer_quotes) {
#line 441
        if (quote_string_len) {
#line 442
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 445
    if ((unsigned int )quoting_style == 2U) {
#line 445
      if (elide_outer_quotes) {
#line 447
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 450
    if (backslash_escapes) {
#line 452
      c = esc;
#line 453
      goto store_escape;
    }
#line 455
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 458
    if (argsize == 0xffffffffffffffffUL) {
#line 458
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 458
      tmp___2 = argsize == 1UL;
    }
#line 458
    if (! tmp___2) {
#line 459
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 462
    if (i != 0UL) {
#line 463
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 478
    if ((unsigned int )quoting_style == 2U) {
#line 478
      if (elide_outer_quotes) {
#line 480
        goto force_outer_quoting_style;
      }
    }
#line 481
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 484
    if ((unsigned int )quoting_style == 2U) {
#line 486
      if (elide_outer_quotes) {
#line 487
        goto force_outer_quoting_style;
      }
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (len < buffersize) {
#line 488
          *(buffer___0 + len) = (char )'\'';
        }
#line 488
        len ++;
#line 488
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 489
        if (len < buffersize) {
#line 489
          *(buffer___0 + len) = (char )'\\';
        }
#line 489
        len ++;
#line 489
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___0 + len) = (char )'\'';
        }
#line 490
        len ++;
#line 490
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 492
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 516
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 530
    if (unibyte_locale) {
      {
#line 532
      m = (size_t )1;
#line 533
      tmp___3 = __ctype_b_loc();
#line 533
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 538
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 540
      m = (size_t )0;
#line 541
      printable = (_Bool)1;
      }
#line 542
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 543
        argsize = strlen(arg);
        }
      }
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 548
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 548
        bytes = tmp___4;
        }
#line 550
        if (bytes == 0UL) {
#line 551
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xffffffffffffffffUL) {
#line 554
          printable = (_Bool)0;
#line 555
          goto while_break___14;
        } else
#line 557
        if (bytes == 0xfffffffffffffffeUL) {
#line 559
          printable = (_Bool)0;
          {
#line 560
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 560
            if (i + m < argsize) {
#line 560
              if (! *(arg + (i + m))) {
#line 560
                goto while_break___15;
              }
            } else {
#line 560
              goto while_break___15;
            }
#line 561
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 562
          goto while_break___14;
        } else {
#line 570
          if (elide_outer_quotes) {
#line 570
            if ((unsigned int )quoting_style == 2U) {
#line 574
              j = (size_t )1;
              {
#line 574
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 574
                if (! (j < bytes)) {
#line 574
                  goto while_break___16;
                }
                {
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 578
                  goto case_124___0;
                }
#line 581
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 579
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 582
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 574
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 586
          tmp___5 = iswprint((wint_t )w);
          }
#line 586
          if (! tmp___5) {
#line 587
            printable = (_Bool)0;
          }
#line 588
          m += bytes;
        }
        {
#line 545
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 545
        if (tmp___6) {
#line 545
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 594
    if (1UL < m) {
#line 594
      goto _L___0;
    } else
#line 594
    if (backslash_escapes) {
#line 594
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 598
        ilim = i + m;
        {
#line 600
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 602
          if (backslash_escapes) {
#line 602
            if (! printable) {
#line 604
              if (elide_outer_quotes) {
#line 605
                goto force_outer_quoting_style;
              }
              {
#line 606
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 606
                if (len < buffersize) {
#line 606
                  *(buffer___0 + len) = (char )'\\';
                }
#line 606
                len ++;
#line 606
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 607
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 607
                if (len < buffersize) {
#line 607
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 607
                len ++;
#line 607
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 608
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 608
                if (len < buffersize) {
#line 608
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 608
                len ++;
#line 608
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 609
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 602
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 611
          if (is_right_quote) {
            {
#line 613
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 613
              if (len < buffersize) {
#line 613
                *(buffer___0 + len) = (char )'\\';
              }
#line 613
              len ++;
#line 613
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 614
            is_right_quote = (_Bool)0;
          }
#line 616
          if (ilim <= i + 1UL) {
#line 617
            goto while_break___17;
          }
          {
#line 618
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 618
            if (len < buffersize) {
#line 618
              *(buffer___0 + len) = (char )c;
            }
#line 618
            len ++;
#line 618
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 619
          i ++;
#line 619
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 622
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (backslash_escapes) {
#line 627
      goto _L___3;
    } else
#line 627
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 627
      if (quote_these_too) {
#line 627
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 627
          goto _L___2;
        }
      } else {
#line 627
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 627
    if (! is_right_quote) {
#line 631
      goto store_c;
    }
    store_escape: 
#line 634
    if (elide_outer_quotes) {
#line 635
      goto force_outer_quoting_style;
    }
    {
#line 636
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 636
      if (len < buffersize) {
#line 636
        *(buffer___0 + len) = (char )'\\';
      }
#line 636
      len ++;
#line 636
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 639
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 639
      if (len < buffersize) {
#line 639
        *(buffer___0 + len) = (char )c;
      }
#line 639
      len ++;
#line 639
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 642
  if (len == 0UL) {
#line 642
    if ((unsigned int )quoting_style == 2U) {
#line 642
      if (elide_outer_quotes) {
#line 644
        goto force_outer_quoting_style;
      }
    }
  }
#line 646
  if (quote_string) {
#line 646
    if (! elide_outer_quotes) {
      {
#line 647
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 647
        if (! *quote_string) {
#line 647
          goto while_break___25;
        }
        {
#line 648
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 648
          if (len < buffersize) {
#line 648
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 648
          len ++;
#line 648
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 647
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 650
  if (len < buffersize) {
#line 651
    *(buffer___0 + len) = (char )'\000';
  }
#line 652
  return (len);
  force_outer_quoting_style: 
  {
#line 657
  tmp___8 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 657
  return (tmp___8);
}
}
#line 672 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 677
  if (o) {
#line 677
    tmp = o;
  } else {
#line 677
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 677
  p = tmp;
#line 678
  tmp___0 = __errno_location();
#line 678
  e = *tmp___0;
#line 679
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 679
  r = tmp___1;
#line 682
  tmp___2 = __errno_location();
#line 682
  *tmp___2 = e;
  }
#line 683
  return (r);
}
}
#line 687 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 691
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 691
  return (tmp);
}
}
#line 700 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 704
  if (o) {
#line 704
    tmp = o;
  } else {
#line 704
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 704
  p = tmp;
#line 705
  tmp___0 = __errno_location();
#line 705
  e = *tmp___0;
  }
#line 707
  if (size) {
#line 707
    tmp___1 = 0;
  } else {
#line 707
    tmp___1 = 1;
  }
  {
#line 707
  flags = (int )(p->flags | (int const   )tmp___1);
#line 708
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 708
  bufsize = tmp___2 + 1UL;
#line 712
  tmp___3 = xcharalloc(bufsize);
#line 712
  buf = tmp___3;
#line 713
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 716
  tmp___4 = __errno_location();
#line 716
  *tmp___4 = e;
  }
#line 717
  if (size) {
#line 718
    *size = bufsize - 1UL;
  }
#line 719
  return (buf);
}
}
#line 731 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char slot0[256]  ;
#line 732 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 733 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 734 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 736 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 739
  sv = slotvec;
#line 741
  i = 1U;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! (i < nslots)) {
#line 741
      goto while_break;
    }
    {
#line 742
    free((void *)(sv + i)->val);
#line 741
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 745
    free((void *)(sv + 0)->val);
#line 746
    slotvec0.size = sizeof(slot0);
#line 747
    slotvec0.val = slot0;
    }
  }
#line 749
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 751
    free((void *)sv);
#line 752
    slotvec = & slotvec0;
    }
  }
#line 754
  nslots = 1U;
#line 755
  return;
}
}
#line 765 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 769
  tmp = __errno_location();
#line 769
  e = *tmp;
#line 771
  n0 = (unsigned int )n;
#line 772
  sv = slotvec;
  }
#line 774
  if (n < 0) {
    {
#line 775
    abort();
    }
  }
#line 777
  if (nslots <= n0) {
#line 784
    n1 = (size_t )(n0 + 1U);
#line 785
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 787
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 787
      tmp___0 = -1;
    } else {
#line 787
      tmp___0 = -2;
    }
#line 787
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 788
      xalloc_die();
      }
    }
#line 790
    if (preallocated) {
#line 790
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 790
      tmp___1 = sv;
    }
    {
#line 790
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 790
    sv = (struct slotvec *)tmp___2;
#line 790
    slotvec = sv;
    }
#line 791
    if (preallocated) {
#line 792
      *sv = slotvec0;
    }
    {
#line 793
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 794
    nslots = (unsigned int )n1;
    }
  }
  {
#line 798
  size = (sv + n)->size;
#line 799
  val = (sv + n)->val;
#line 801
  flags = (int )(options->flags | 1);
#line 802
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 802
  qsize = tmp___3;
  }
#line 808
  if (size <= qsize) {
#line 810
    size = qsize + 1UL;
#line 810
    (sv + n)->size = size;
#line 811
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 812
      free((void *)val);
      }
    }
    {
#line 813
    val = xcharalloc(size);
#line 813
    (sv + n)->val = val;
#line 814
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 820
  tmp___4 = __errno_location();
#line 820
  *tmp___4 = e;
  }
#line 821
  return (val);
}
}
#line 825 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 828
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 828
  return (tmp);
}
}
#line 831 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 834
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 834
  return (tmp);
}
}
#line 837 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 840
  tmp = quotearg_n(0, arg);
  }
#line 840
  return (tmp);
}
}
#line 843 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 846
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 846
  return (tmp);
}
}
#line 849 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 852
  tmp = quoting_options_from_style(s);
#line 852
  o = tmp;
#line 853
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 853
  return (tmp___0);
}
}
#line 856 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 860
  tmp = quoting_options_from_style(s);
#line 860
  o = tmp;
#line 861
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 861
  return (tmp___0);
}
}
#line 864 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 867
  tmp = quotearg_n_style(0, s, arg);
  }
#line 867
  return (tmp);
}
}
#line 870 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 873
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 873
  return (tmp);
}
}
#line 876 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 880
  options = default_quoting_options;
#line 881
  set_char_quoting(& options, ch, 1);
#line 882
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 882
  return (tmp);
}
}
#line 885 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 888
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 888
  return (tmp);
}
}
#line 891 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 894
  tmp = quotearg_char(arg, (char )':');
  }
#line 894
  return (tmp);
}
}
#line 897 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 900
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 900
  return (tmp);
}
}
#line 903 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 907
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 907
  return (tmp);
}
}
#line 911 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 916
  o = default_quoting_options;
#line 917
  set_custom_quoting(& o, left_quote, right_quote);
#line 918
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 918
  return (tmp);
}
}
#line 921 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 925
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 925
  return (tmp);
}
}
#line 928 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 932
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 932
  return (tmp);
}
}
#line 938 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 946 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 949
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 949
  return ((char const   *)tmp);
}
}
#line 952 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 955
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 955
  return (tmp);
}
}
#line 958 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 961
  tmp = quote_n_mem(n, arg, (size_t )-1);
  }
#line 961
  return (tmp);
}
}
#line 964 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 967
  tmp = quote_n(0, arg);
  }
#line 967
  return (tmp);
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 92 "/home/khheo/project/benchmark/grep-2.18/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 1109 "./string.h"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
__inline void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 134
  if (iter->next_done) {
#line 135
    return;
  }
#line 136
  if (iter->in_shift) {
#line 137
    goto with_shift;
  }
  {
#line 139
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 139
  if (tmp___8) {
#line 144
    iter->cur.bytes = (size_t )1;
#line 145
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 146
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 150
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 150
    if (! tmp___2) {
      {
#line 150
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h",
                    150U, "mbuiter_multi_next");
      }
    }
#line 151
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 153
    tmp___3 = __ctype_get_mb_cur_max();
#line 153
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 153
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___4, (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 156
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 159
      iter->cur.bytes = (size_t )1;
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 164
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 167
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 168
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 174
      if (iter->cur.bytes == 0UL) {
#line 177
        iter->cur.bytes = (size_t )1;
#line 178
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 178
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h",
                        178U, "mbuiter_multi_next");
          }
        }
#line 179
        if (! (iter->cur.wc == 0)) {
          {
#line 179
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h",
                        179U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 181
      iter->cur.wc_valid = (_Bool)1;
#line 185
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 185
      if (tmp___7) {
#line 186
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 189
  iter->next_done = (_Bool)1;
#line 190
  return;
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
__inline void mbuiter_multi_reloc(struct mbuiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 195
  iter->cur.ptr += ptrdiff;
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
__inline void mbuiter_multi_copy(struct mbuiter_multi *new_iter , struct mbuiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 201
  tmp = (_Bool )old_iter->in_shift;
#line 201
  new_iter->in_shift = tmp;
#line 201
  if (tmp) {
    {
#line 202
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 204
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 205
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 206
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 207
  return;
}
}
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 157 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 161
  tmp = gettext(name);
#line 161
  translation = (char const   *)tmp;
  }
#line 163
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 166
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 166
    if (tmp___7) {
#line 167
      return (translation);
    } else {
#line 171
      if (sizeof(char ) == 1UL) {
        {
#line 171
        tmp___0 = strlen(translation);
#line 171
        tmp___1 = strlen(name);
#line 171
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 171
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 171
        tmp___3 = strlen(translation);
#line 171
        tmp___4 = strlen(name);
#line 171
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 171
        tmp___6 = tmp___5;
        }
      }
      {
#line 171
      result = (char *)tmp___6;
#line 174
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 175
      return ((char const   *)result);
    }
  } else {
#line 179
    return (name);
  }
}
}
#line 187 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;

  {
  {
#line 191
  tmp = gettext(name_ascii);
#line 191
  translation = (char const   *)tmp;
#line 194
  tmp___0 = locale_charset();
#line 194
  locale_code = tmp___0;
#line 195
  alloc_name_converted = (char *)((void *)0);
#line 196
  alloc_name_converted_translit = (char *)((void *)0);
#line 197
  name_converted = (char const   *)((void *)0);
#line 198
  name_converted_translit = (char const   *)((void *)0);
#line 201
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 201
  if (tmp___6 != 0) {
    {
#line 204
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 204
    name_converted = (char const   *)alloc_name_converted;
#line 213
    tmp___1 = strlen(locale_code);
#line 213
    len = tmp___1;
    }
#line 214
    if (sizeof(char ) == 1UL) {
      {
#line 214
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 214
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 214
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 214
      tmp___4 = tmp___3;
      }
    }
    {
#line 214
    locale_code_translit = (char *)tmp___4;
#line 215
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 216
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 218
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 221
    free((void *)locale_code_translit);
    }
#line 223
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 230
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 230
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 231
        free((void *)converted_translit);
        }
      } else {
#line 234
        alloc_name_converted_translit = converted_translit;
#line 234
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 243
    name_converted = name_utf8;
#line 244
    name_converted_translit = name_utf8;
  }
#line 248
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 248
    name = name_converted;
  } else {
#line 248
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 248
      tmp___7 = name_converted_translit;
    } else {
#line 248
      tmp___7 = name_ascii;
    }
#line 248
    name = tmp___7;
  }
  {
#line 255
  tmp___18 = strcmp(translation, name_ascii);
  }
#line 255
  if (tmp___18 != 0) {
    {
#line 258
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 258
    if (tmp___15) {
#line 258
      goto _L;
    } else
#line 258
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 258
      if (tmp___16) {
#line 258
        goto _L;
      } else {
#line 258
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 258
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 258
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 264
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 265
          free((void *)alloc_name_converted);
          }
        }
#line 266
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 267
          free((void *)alloc_name_converted_translit);
          }
        }
#line 268
        return (translation);
      } else {
#line 258
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 273
      if (sizeof(char ) == 1UL) {
        {
#line 273
        tmp___8 = strlen(translation);
#line 273
        tmp___9 = strlen(name);
#line 273
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 273
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 273
        tmp___11 = strlen(translation);
#line 273
        tmp___12 = strlen(name);
#line 273
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 273
        tmp___14 = tmp___13;
        }
      }
      {
#line 273
      result = (char *)tmp___14;
#line 276
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 278
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 279
        free((void *)alloc_name_converted);
        }
      }
#line 280
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 281
        free((void *)alloc_name_converted_translit);
        }
      }
#line 282
      return ((char const   *)result);
    }
  } else {
#line 287
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 287
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 288
        free((void *)alloc_name_converted);
        }
      }
    }
#line 289
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 289
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 291
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 292
    return (name);
  }
}
}
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/khheo/project/benchmark/grep-2.18/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.18/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-2.18/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 22 "/home/khheo/project/benchmark/grep-2.18/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-2.18/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/khheo/project/benchmark/grep-2.18/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl-safer.h"
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ 
  mode_t mode___0 ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode___0 = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode___0 = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = openat(fd, file, flags, mode___0);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.18/lib/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 58 "/home/khheo/project/benchmark/grep-2.18/lib/openat-proc.c"
static int proc_status  =    0;
#line 55 "/home/khheo/project/benchmark/grep-2.18/lib/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file ) 
{ 
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;

  {
#line 61
  if (! *file) {
#line 63
    *(buf + 0) = (char )'\000';
#line 64
    return ((char *)buf);
  }
#line 67
  if (! proc_status) {
    {
#line 77
    tmp = open("/proc/self/fd", 67840);
#line 77
    proc_self_fd = tmp;
    }
#line 79
    if (proc_self_fd < 0) {
#line 80
      proc_status = -1;
    } else {
      {
#line 89
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
              proc_self_fd, "../fd");
#line 90
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      }
#line 90
      if (tmp___1) {
#line 90
        proc_status = -1;
      } else {
#line 90
        proc_status = 1;
      }
      {
#line 91
      close(proc_self_fd);
      }
    }
  }
#line 95
  if (proc_status < 0) {
#line 96
    return ((char *)((void *)0));
  } else {
    {
#line 99
    tmp___2 = strlen(file);
#line 99
    bufsize = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
#line 100
    result = (char *)buf;
    }
#line 101
    if (4032UL < bufsize) {
      {
#line 103
      tmp___3 = malloc(bufsize);
#line 103
      result = (char *)tmp___3;
      }
#line 104
      if (! result) {
#line 105
        return ((char *)((void *)0));
      }
    }
    {
#line 107
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
            fd, file);
    }
#line 108
    return (result);
  }
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 48
void openat_restore_fail(int errnum ) ;
#line 49
void openat_save_fail(int errnum ) ;
#line 121
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/grep-2.18/lib/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 37
  tmp = gettext("unable to record current working directory");
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
  }
}
}
#line 52 "/home/khheo/project/benchmark/grep-2.18/lib/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("failed to return to initial working directory");
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ 
  mode_t mode___0 ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode___0 = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode___0 = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = open(file, flags, mode___0);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 390 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 1044 "./string.h"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 63 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 67
void freea(void *p ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-2.18/lib/str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 42
    tmp___4 = -1;
  } else {
#line 42
    tmp___4 = -2;
  }
#line 42
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 42
    tmp___3 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 42
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___2 = tmp___1;
      }
    }
#line 42
    tmp___3 = tmp___2;
  }
#line 42
  table = (size_t *)tmp___3;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.18/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
      }
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = tmp___4;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 53
  table = (size_t *)table_memory;
#line 60
  j = (size_t )0;
#line 61
  iter.cur.ptr = needle;
#line 61
  iter.in_shift = (_Bool)0;
#line 61
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 61
  iter.next_done = (_Bool)0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    mbuiter_multi_next(& iter);
    }
#line 61
    if (iter.cur.wc_valid) {
#line 61
      if (iter.cur.wc == 0) {
#line 61
        tmp___6 = 0;
      } else {
#line 61
        tmp___6 = 1;
      }
    } else {
#line 61
      tmp___6 = 1;
    }
#line 61
    if (! tmp___6) {
#line 61
      goto while_break;
    }
    {
#line 62
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 61
    iter.cur.ptr += iter.cur.bytes;
#line 61
    iter.next_done = (_Bool)0;
#line 61
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(table + 1) = (size_t )1;
#line 85
  j___0 = (size_t )0;
#line 87
  i = (size_t )2;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < m)) {
#line 87
      goto while_break___0;
    }
#line 93
    b = needle_mbchars + (i - 1UL);
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 100
      if (b->wc_valid) {
#line 100
        if ((needle_mbchars + j___0)->wc_valid) {
#line 100
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 100
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 100
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 100
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 100
          if (tmp___7 == 0) {
#line 100
            tmp___8 = 1;
          } else {
#line 100
            tmp___8 = 0;
          }
        } else {
#line 100
          tmp___8 = 0;
        }
#line 100
        tmp___9 = tmp___8;
      }
#line 100
      if (tmp___9) {
#line 103
        j___0 ++;
#line 103
        *(table + i) = i - j___0;
#line 104
        goto while_break___1;
      }
#line 109
      if (j___0 == 0UL) {
#line 112
        *(table + i) = i;
#line 113
        goto while_break___1;
      }
#line 126
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 87
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  *resultp = (char const   *)((void *)0);
#line 139
  j___1 = (size_t )0;
#line 140
  rhaystack.cur.ptr = haystack;
#line 140
  rhaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  rhaystack.next_done = (_Bool)0;
#line 141
  phaystack.cur.ptr = haystack;
#line 141
  phaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  phaystack.next_done = (_Bool)0;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 143
    mbuiter_multi_next(& phaystack);
    }
#line 143
    if (phaystack.cur.wc_valid) {
#line 143
      if (phaystack.cur.wc == 0) {
#line 143
        tmp___15 = 0;
      } else {
#line 143
        tmp___15 = 1;
      }
    } else {
#line 143
      tmp___15 = 1;
    }
#line 143
    if (! tmp___15) {
#line 143
      goto while_break___2;
    }
#line 144
    if ((needle_mbchars + j___1)->wc_valid) {
#line 144
      if (phaystack.cur.wc_valid) {
#line 144
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 144
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 144
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 144
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 144
        if (tmp___12 == 0) {
#line 144
          tmp___13 = 1;
        } else {
#line 144
          tmp___13 = 0;
        }
      } else {
#line 144
        tmp___13 = 0;
      }
#line 144
      tmp___14 = tmp___13;
    }
#line 144
    if (tmp___14) {
#line 146
      j___1 ++;
#line 147
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 147
      phaystack.next_done = (_Bool)0;
#line 148
      if (j___1 == m) {
#line 151
        *resultp = rhaystack.cur.ptr;
#line 152
        goto while_break___2;
      }
    } else
#line 155
    if (j___1 > 0UL) {
#line 158
      count = *(table + j___1);
#line 159
      j___1 -= count;
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (count > 0UL)) {
#line 160
          goto while_break___3;
        }
        {
#line 162
        mbuiter_multi_next(& rhaystack);
        }
#line 162
        if (rhaystack.cur.wc_valid) {
#line 162
          if (rhaystack.cur.wc == 0) {
#line 162
            tmp___10 = 0;
          } else {
#line 162
            tmp___10 = 1;
          }
        } else {
#line 162
          tmp___10 = 1;
        }
#line 162
        if (! tmp___10) {
          {
#line 163
          abort();
          }
        }
#line 164
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 164
        rhaystack.next_done = (_Bool)0;
#line 160
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 170
      mbuiter_multi_next(& rhaystack);
      }
#line 170
      if (rhaystack.cur.wc_valid) {
#line 170
        if (rhaystack.cur.wc == 0) {
#line 170
          tmp___11 = 0;
        } else {
#line 170
          tmp___11 = 1;
        }
      } else {
#line 170
        tmp___11 = 1;
      }
#line 170
      if (! tmp___11) {
        {
#line 171
        abort();
        }
      }
#line 172
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 172
      rhaystack.next_done = (_Bool)0;
#line 173
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 173
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 177
  freea(memory);
  }
#line 178
  return ((_Bool)1);
}
}
#line 183
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 183 "/home/khheo/project/benchmark/grep-2.18/lib/mbsstr.c"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
  {
#line 191
  tmp___17 = __ctype_get_mb_cur_max();
  }
#line 191
  if (tmp___17 > 1UL) {
    {
#line 195
    iter_needle.cur.ptr = needle;
#line 195
    iter_needle.in_shift = (_Bool)0;
#line 195
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 195
    iter_needle.next_done = (_Bool)0;
#line 196
    mbuiter_multi_next(& iter_needle);
    }
#line 196
    if (iter_needle.cur.wc_valid) {
#line 196
      if (iter_needle.cur.wc == 0) {
#line 196
        tmp___12 = 0;
      } else {
#line 196
        tmp___12 = 1;
      }
    } else {
#line 196
      tmp___12 = 1;
    }
#line 196
    if (tmp___12) {
      {
#line 212
      try_kmp = (_Bool)1;
#line 213
      outer_loop_count = (size_t )0;
#line 214
      comparison_count = (size_t )0;
#line 215
      last_ccount = (size_t )0;
#line 220
      iter_needle_last_ccount.cur.ptr = needle;
#line 220
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 220
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 220
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 221
      iter_haystack.cur.ptr = haystack;
#line 221
      iter_haystack.in_shift = (_Bool)0;
#line 221
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 221
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 222
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 224
        mbuiter_multi_next(& iter_haystack);
        }
#line 224
        if (iter_haystack.cur.wc_valid) {
#line 224
          if (iter_haystack.cur.wc == 0) {
#line 224
            tmp = 0;
          } else {
#line 224
            tmp = 1;
          }
        } else {
#line 224
          tmp = 1;
        }
#line 224
        if (! tmp) {
#line 226
          return ((char *)((void *)0));
        }
#line 230
        if (try_kmp) {
#line 230
          if (outer_loop_count >= 10UL) {
#line 230
            if (comparison_count >= 5UL * outer_loop_count) {
#line 236
              count = comparison_count - last_ccount;
              {
#line 237
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 237
                if (count > 0UL) {
                  {
#line 237
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 237
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 237
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 237
                      tmp___0 = 0;
                    } else {
#line 237
                      tmp___0 = 1;
                    }
                  } else {
#line 237
                    tmp___0 = 1;
                  }
#line 237
                  if (! tmp___0) {
#line 237
                    goto while_break___0;
                  }
                } else {
#line 237
                  goto while_break___0;
                }
#line 240
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 240
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 237
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 241
              last_ccount = comparison_count;
#line 242
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 242
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 242
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 242
                  tmp___2 = 0;
                } else {
#line 242
                  tmp___2 = 1;
                }
              } else {
#line 242
                tmp___2 = 1;
              }
#line 242
              if (! tmp___2) {
                {
#line 246
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 246
                success = tmp___1;
                }
#line 249
                if (success) {
#line 250
                  return ((char *)result);
                }
#line 251
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 255
        outer_loop_count ++;
#line 256
        comparison_count ++;
#line 257
        if (iter_haystack.cur.wc_valid) {
#line 257
          if (iter_needle.cur.wc_valid) {
#line 257
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 257
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 257
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 257
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 257
            if (tmp___9 == 0) {
#line 257
              tmp___10 = 1;
            } else {
#line 257
              tmp___10 = 0;
            }
          } else {
#line 257
            tmp___10 = 0;
          }
#line 257
          tmp___11 = tmp___10;
        }
#line 257
        if (tmp___11) {
          {
#line 263
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 264
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 264
          rhaystack.next_done = (_Bool)0;
#line 266
          rneedle.cur.ptr = needle;
#line 266
          rneedle.in_shift = (_Bool)0;
#line 266
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 266
          rneedle.next_done = (_Bool)0;
#line 267
          mbuiter_multi_next(& rneedle);
          }
#line 267
          if (rneedle.cur.wc_valid) {
#line 267
            if (rneedle.cur.wc == 0) {
#line 267
              tmp___3 = 0;
            } else {
#line 267
              tmp___3 = 1;
            }
          } else {
#line 267
            tmp___3 = 1;
          }
#line 267
          if (! tmp___3) {
            {
#line 268
            abort();
            }
          }
#line 269
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 269
          rneedle.next_done = (_Bool)0;
          {
#line 271
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 273
            mbuiter_multi_next(& rneedle);
            }
#line 273
            if (rneedle.cur.wc_valid) {
#line 273
              if (rneedle.cur.wc == 0) {
#line 273
                tmp___4 = 0;
              } else {
#line 273
                tmp___4 = 1;
              }
            } else {
#line 273
              tmp___4 = 1;
            }
#line 273
            if (! tmp___4) {
#line 275
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 276
            mbuiter_multi_next(& rhaystack);
            }
#line 276
            if (rhaystack.cur.wc_valid) {
#line 276
              if (rhaystack.cur.wc == 0) {
#line 276
                tmp___5 = 0;
              } else {
#line 276
                tmp___5 = 1;
              }
            } else {
#line 276
              tmp___5 = 1;
            }
#line 276
            if (! tmp___5) {
#line 278
              return ((char *)((void *)0));
            }
#line 279
            comparison_count ++;
#line 280
            if (rhaystack.cur.wc_valid) {
#line 280
              if (rneedle.cur.wc_valid) {
#line 280
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 280
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 280
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 280
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 280
                if (tmp___6 == 0) {
#line 280
                  tmp___7 = 1;
                } else {
#line 280
                  tmp___7 = 0;
                }
              } else {
#line 280
                tmp___7 = 0;
              }
#line 280
              tmp___8 = tmp___7;
            }
#line 280
            if (! tmp___8) {
#line 282
              goto while_break___1;
            }
#line 271
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 271
            rhaystack.next_done = (_Bool)0;
#line 271
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 271
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 222
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 222
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 288
      return ((char *)haystack);
    }
  } else
#line 292
  if ((int const   )*needle != 0) {
#line 308
    try_kmp___0 = (_Bool)1;
#line 309
    outer_loop_count___0 = (size_t )0;
#line 310
    comparison_count___0 = (size_t )0;
#line 311
    last_ccount___0 = (size_t )0;
#line 312
    needle_last_ccount = needle;
#line 316
    tmp___13 = needle;
#line 316
    needle ++;
#line 316
    b = (char )*tmp___13;
    {
#line 318
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 320
      if ((int const   )*haystack == 0) {
#line 322
        return ((char *)((void *)0));
      }
#line 326
      if (try_kmp___0) {
#line 326
        if (outer_loop_count___0 >= 10UL) {
#line 326
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 332
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 334
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 334
              needle_last_ccount += tmp___14;
              }
#line 337
              if ((int const   )*needle_last_ccount == 0) {
#line 338
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 339
              last_ccount___0 = comparison_count___0;
            }
#line 341
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 345
              tmp___15 = strlen(needle - 1);
#line 345
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 345
              success___0 = tmp___16;
              }
#line 350
              if (success___0) {
#line 351
                return ((char *)result___0);
              }
#line 352
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 356
      outer_loop_count___0 ++;
#line 357
      comparison_count___0 ++;
#line 358
      if ((int const   )*haystack == (int const   )b) {
#line 361
        rhaystack___0 = haystack + 1;
#line 362
        rneedle___0 = needle;
        {
#line 364
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 366
          if ((int const   )*rneedle___0 == 0) {
#line 368
            return ((char *)haystack);
          }
#line 369
          if ((int const   )*rhaystack___0 == 0) {
#line 371
            return ((char *)((void *)0));
          }
#line 372
          comparison_count___0 ++;
#line 373
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 375
            goto while_break___3;
          }
#line 364
          rhaystack___0 ++;
#line 364
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 318
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 381
    return ((char *)haystack);
  }
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 1121 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 69 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 750 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 807
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 811
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 834
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 143
#pragma weak pthread_self
#line 147
#pragma weak pthread_cancel
#line 295
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 369
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 283 "/home/khheo/project/benchmark/grep-2.18/lib/glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ 
  pthread_mutexattr_t attributes ;
  int err ;

  {
  {
#line 289
  err = pthread_mutexattr_init(& attributes);
  }
#line 290
  if (err != 0) {
#line 291
    return (err);
  }
  {
#line 292
  err = pthread_mutexattr_settype(& attributes, 1);
  }
#line 293
  if (err != 0) {
    {
#line 295
    pthread_mutexattr_destroy(& attributes);
    }
#line 296
    return (err);
  }
  {
#line 298
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  }
#line 299
  if (err != 0) {
    {
#line 301
    pthread_mutexattr_destroy(& attributes);
    }
#line 302
    return (err);
  }
  {
#line 304
  err = pthread_mutexattr_destroy(& attributes);
  }
#line 305
  if (err != 0) {
#line 306
    return (err);
  }
#line 307
  return (0);
}
}
#line 454 "/home/khheo/project/benchmark/grep-2.18/lib/glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 456 "/home/khheo/project/benchmark/grep-2.18/lib/glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ 
  char *firstbyte ;

  {
#line 461
  firstbyte = (char *)once_control;
#line 462
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 465
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 466
    return (1);
  } else {
#line 469
    return (0);
  }
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 119 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 122 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 127
  cp = (char const   *)charset_aliases;
#line 128
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 132
    base = "charset.alias";
#line 137
    tmp = getenv("CHARSETALIASDIR");
#line 137
    dir = (char const   *)tmp;
    }
#line 138
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 139
      dir = "/usr/local/lib";
    } else
#line 138
    if ((int const   )*(dir + 0) == 0) {
#line 139
      dir = "/usr/local/lib";
    }
    {
#line 143
    tmp___0 = strlen(dir);
#line 143
    dir_len___0 = tmp___0;
#line 144
    tmp___1 = strlen(base);
#line 144
    base_len___0 = tmp___1;
    }
#line 145
    if (dir_len___0 > 0UL) {
#line 145
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 145
        tmp___2 = 1;
      } else {
#line 145
        tmp___2 = 0;
      }
    } else {
#line 145
      tmp___2 = 0;
    }
    {
#line 145
    add_slash = tmp___2;
#line 146
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 146
    file_name___1 = (char *)tmp___3;
    }
#line 147
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 149
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 150
      if (add_slash) {
#line 151
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 152
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 156
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 158
      cp = "";
    } else {
      {
#line 170
      fd = open((char const   *)file_name___1, 131072);
      }
#line 172
      if (fd < 0) {
#line 174
        cp = "";
      } else {
        {
#line 179
        fp = fdopen(fd, "r");
        }
#line 180
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 183
          close(fd);
#line 184
          cp = "";
          }
        } else {
#line 189
          res_ptr = (char *)((void *)0);
#line 190
          res_size = (size_t )0;
          {
#line 192
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 200
            c = getc_unlocked(fp);
            }
#line 201
            if (c == -1) {
#line 202
              goto while_break;
            }
#line 203
            if (c == 10) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 32) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 9) {
#line 204
              goto __Cont;
            }
#line 205
            if (c == 35) {
              {
#line 208
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 209
                c = getc_unlocked(fp);
                }
#line 208
                if (c == -1) {
#line 208
                  goto while_break___0;
                } else
#line 208
                if (c == 10) {
#line 208
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 211
              if (c == -1) {
#line 212
                goto while_break;
              }
#line 213
              goto __Cont;
            }
            {
#line 215
            ungetc(c, fp);
#line 216
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 216
            if (tmp___4 < 2) {
#line 217
              goto while_break;
            }
            {
#line 218
            l1 = strlen((char const   *)(buf1));
#line 219
            l2 = strlen((char const   *)(buf2));
#line 220
            old_res_ptr = res_ptr;
            }
#line 221
            if (res_size == 0UL) {
              {
#line 223
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 224
              tmp___5 = malloc(res_size + 1UL);
#line 224
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 228
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___6;
              }
            }
#line 231
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 234
              res_size = (size_t )0;
#line 235
              free((void *)old_res_ptr);
              }
#line 236
              goto while_break;
            }
            {
#line 238
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 239
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 241
          fclose(fp);
          }
#line 242
          if (res_size == 0UL) {
#line 243
            cp = "";
          } else {
#line 246
            *(res_ptr + res_size) = (char )'\000';
#line 247
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 252
      free((void *)file_name___1);
      }
    }
#line 346
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 349
  return (cp);
}
}
#line 361 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 372
  tmp = nl_langinfo(14);
#line 372
  codeset = (char const   *)tmp;
  }
#line 529
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 531
    codeset = "";
  }
  {
#line 534
  aliases = get_charset_aliases();
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! ((int const   )*aliases != 0)) {
#line 534
      goto while_break;
    }
    {
#line 537
    tmp___3 = strcmp(codeset, aliases);
    }
#line 537
    if (tmp___3 == 0) {
      {
#line 540
      tmp___2 = strlen(aliases);
#line 540
      codeset = (aliases + tmp___2) + 1;
      }
#line 541
      goto while_break;
    } else
#line 537
    if ((int const   )*(aliases + 0) == 42) {
#line 537
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 540
        tmp___2 = strlen(aliases);
#line 540
        codeset = (aliases + tmp___2) + 1;
        }
#line 541
        goto while_break;
      }
    }
    {
#line 534
    tmp___0 = strlen(aliases);
#line 534
    aliases += tmp___0 + 1UL;
#line 534
    tmp___1 = strlen(aliases);
#line 534
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  if ((int const   )*(codeset + 0) == 0) {
#line 548
    codeset = "ASCII";
  }
#line 557
  return (codeset);
}
}
#line 41 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ 
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 4)) {
#line 31
      goto while_break;
    }
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ 
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/khheo/project/benchmark/grep-2.18/lib/i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ 
  int top_val ;
  _Bool tmp ;

  {
  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
  }
#line 59
  if (tmp) {
    {
#line 60
    abort();
    }
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 72 "/home/khheo/project/benchmark/grep-2.18/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 100
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 103
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 105
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n ) 
{ 


  {
#line 41
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n ) 
{ 


  {
#line 50
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n ) 
{ 


  {
#line 60
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 66 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n ) 
{ 


  {
#line 69
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 75 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n ) 
{ 


  {
#line 78
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 84 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 87
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 95 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n ) 
{ 


  {
#line 98
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 106 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n ) 
{ 


  {
#line 109
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 117 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n ) 
{ 


  {
#line 120
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 128 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n ) 
{ 


  {
#line 131
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer___0 + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___0) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___0) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1121
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 1121 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  int tmp ;

  {
  {
#line 1124
  tmp = hash_insert_if_absent(table, entry, matched_ent);
  }
#line 1124
  return (tmp);
}
}
#line 1133 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1137
  tmp = hash_insert_if_absent(table, entry, & matched_ent);
#line 1137
  err = tmp;
  }
#line 1138
  if (err == -1) {
#line 1138
    tmp___1 = (void *)0;
  } else {
#line 1138
    if (err == 0) {
#line 1138
      tmp___0 = matched_ent;
    } else {
#line 1138
      tmp___0 = entry;
    }
#line 1138
    tmp___1 = (void *)tmp___0;
  }
#line 1138
  return (tmp___1);
}
}
#line 1147 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1153
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1154
  if (! data) {
#line 1155
    return ((void *)0);
  }
#line 1157
  (table->n_entries) --;
#line 1158
  if (! bucket->data) {
#line 1160
    (table->n_buckets_used) --;
#line 1165
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1170
      check_tuning(table);
      }
#line 1171
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1174
        tuning = table->tuning;
#line 1175
        if (tuning->is_n_buckets) {
#line 1175
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1175
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1175
        candidate = (size_t )tmp;
#line 1181
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1181
        if (! tmp___0) {
#line 1189
          cursor = table->free_entry_list;
          {
#line 1191
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1191
            if (! cursor) {
#line 1191
              goto while_break;
            }
            {
#line 1193
            next = cursor->next;
#line 1194
            free((void *)cursor);
#line 1195
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1197
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1204
  return (data);
}
}
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 267 "/home/khheo/project/benchmark/grep-2.18/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 268
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 269
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 272
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 273
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 204
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 205
static void fts_lfree(FTSENT *head ) ;
#line 206
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 207
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) ;
#line 208
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 209
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 210
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 211
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 212
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 35 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 268 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 271
    if (tmp___0) {
#line 271
      goto while_break;
    }
    {
#line 273
    tmp = i_ring_pop(fd_ring);
#line 273
    fd = tmp;
    }
#line 274
    if (0 <= fd) {
      {
#line 275
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 282 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )p->fts_info == 11)) {
      {
#line 285
      abort();
      }
    }
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (required) {
#line 286
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 286
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 289
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 297
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 297
  new_fd = tmp;
  }
#line 302
  if (new_fd < 0) {
#line 303
    return ((DIR *)((void *)0));
  }
  {
#line 304
  set_cloexec_flag(new_fd, (_Bool)1);
#line 305
  dirp = fdopendir(new_fd);
  }
#line 306
  if (dirp) {
#line 307
    *pdir_fd = new_fd;
  } else {
    {
#line 310
    tmp___0 = __errno_location();
#line 310
    saved_errno = *tmp___0;
#line 311
    close(new_fd);
#line 312
    tmp___1 = __errno_location();
#line 312
    *tmp___1 = saved_errno;
    }
  }
#line 314
  return (dirp);
}
}
#line 322 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 326
  old = sp->fts_cwd_fd;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (old != fd)) {
#line 327
      if (! (old == -100)) {
        {
#line 327
        abort();
        }
      }
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (chdir_down_one) {
    {
#line 333
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 333
    prev_fd_in_slot = tmp;
    }
#line 335
    if (0 <= prev_fd_in_slot) {
      {
#line 336
      close(prev_fd_in_slot);
      }
    }
  } else
#line 338
  if (! (sp->fts_options & 4)) {
#line 340
    if (0 <= old) {
      {
#line 341
      close(old);
      }
    }
  }
#line 344
  sp->fts_cwd_fd = fd;
#line 345
  return;
}
}
#line 351 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int restore_initial_cwd(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 354
  if (! (sp->fts_options & 4)) {
#line 354
    if (sp->fts_options & 512) {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp = -100;
      } else {
#line 354
        tmp = sp->fts_rfd;
      }
      {
#line 354
      cwd_advance_fd(sp, tmp, (_Bool)1);
#line 354
      tmp___2 = 0;
      }
    } else {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp___0 = -100;
      } else {
#line 354
        tmp___0 = sp->fts_rfd;
      }
      {
#line 354
      tmp___1 = fchdir(tmp___0);
#line 354
      tmp___2 = tmp___1;
      }
    }
#line 354
    if (tmp___2) {
#line 354
      tmp___3 = 1;
    } else {
#line 354
      tmp___3 = 0;
    }
  } else {
#line 354
    tmp___3 = 0;
  }
  {
#line 354
  fail = tmp___3;
#line 355
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 356
  return (fail);
}
}
#line 363 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int diropen(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 367
  if (sp->fts_options & 16) {
#line 367
    tmp = 131072;
  } else {
#line 367
    tmp = 0;
  }
#line 367
  if (sp->fts_options & 2048) {
#line 367
    tmp___0 = 262144;
  } else {
#line 367
    tmp___0 = 0;
  }
#line 367
  open_flags = (67840 | tmp) | tmp___0;
#line 371
  if (sp->fts_options & 512) {
    {
#line 371
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 371
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 371
    tmp___2 = open_safer(dir, open_flags);
#line 371
    tmp___3 = tmp___2;
    }
  }
#line 371
  fd = tmp___3;
#line 374
  if (0 <= fd) {
    {
#line 375
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 376
  return (fd);
}
}
#line 379
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 379 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                   int options , int (*compar)(FTSENT const   ** ,
                                                                                               FTSENT const   ** ) ) 
{ 
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  char const   *v ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
#line 387
  parent = (FTSENT *)((void *)0);
#line 388
  tmp = (FTSENT *)((void *)0);
#line 392
  if (options & -8192) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    *tmp___0 = 22;
    }
#line 394
    return ((FTS *)((void *)0));
  }
#line 396
  if (options & 4) {
#line 396
    if (options & 512) {
      {
#line 397
      tmp___1 = __errno_location();
#line 397
      *tmp___1 = 22;
      }
#line 398
      return ((FTS *)((void *)0));
    }
  }
#line 400
  if (! (options & 18)) {
    {
#line 401
    tmp___2 = __errno_location();
#line 401
    *tmp___2 = 22;
    }
#line 402
    return ((FTS *)((void *)0));
  }
  {
#line 406
  tmp___3 = malloc(sizeof(FTS ));
#line 406
  sp = (FTS *)tmp___3;
  }
#line 406
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 407
    return ((FTS *)((void *)0));
  }
  {
#line 408
  memset((void *)sp, 0, sizeof(FTS ));
#line 409
  sp->fts_compar = compar;
#line 410
  sp->fts_options = options;
  }
#line 413
  if (sp->fts_options & 2) {
#line 414
    sp->fts_options |= 4;
#line 415
    sp->fts_options &= -513;
  }
#line 419
  sp->fts_cwd_fd = -100;
#line 420
  if (sp->fts_options & 512) {

  }
  {
#line 461
  tmp___6 = (size_t )fts_maxarglen(argv);
#line 461
  maxarglen = tmp___6;
  }
#line 462
  if (maxarglen > 4096UL) {
#line 462
    tmp___7 = maxarglen;
  } else {
#line 462
    tmp___7 = (size_t )4096;
  }
  {
#line 462
  tmp___8 = fts_palloc(sp, tmp___7);
  }
#line 462
  if (! tmp___8) {
#line 463
    goto mem1;
  }
#line 467
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
#line 468
    parent = fts_alloc(sp, "", (size_t )0);
    }
#line 468
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 469
      goto mem2;
    }
#line 470
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 484
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 484
    tmp___9 = 1;
  } else
#line 484
  if (sp->fts_options & 1024) {
#line 484
    tmp___9 = 1;
  } else {
#line 484
    tmp___9 = 0;
  }
#line 484
  defer_stat = (_Bool )tmp___9;
#line 487
  root = (FTSENT *)((void *)0);
#line 487
  nitems = (size_t )0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 487
      goto while_break;
    }
    {
#line 489
    tmp___10 = strlen((char const   *)*argv);
#line 489
    len = tmp___10;
    }
#line 491
    if (! (options & 4096)) {
#line 495
      v = (char const   *)*argv;
#line 496
      if (2UL < len) {
#line 496
        if ((int const   )*(v + (len - 1UL)) == 47) {
          {
#line 497
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 497
            if (1UL < len) {
#line 497
              if (! ((int const   )*(v + (len - 2UL)) == 47)) {
#line 497
                goto while_break___0;
              }
            } else {
#line 497
              goto while_break___0;
            }
#line 498
            len --;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 501
    p = fts_alloc(sp, (char const   *)*argv, len);
    }
#line 501
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 502
      goto mem3;
    }
#line 503
    p->fts_level = (ptrdiff_t )0;
#line 504
    p->fts_parent = parent;
#line 505
    p->fts_accpath = p->fts_name;
#line 509
    if (defer_stat) {
#line 509
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
#line 510
        p->fts_info = (unsigned short)11;
#line 511
        fts_set_stat_required(p, (_Bool)1);
        }
      } else {
        {
#line 513
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
      }
    } else {
      {
#line 513
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    }
#line 520
    if (compar) {
#line 521
      p->fts_link = root;
#line 522
      root = p;
    } else {
#line 524
      p->fts_link = (struct _ftsent *)((void *)0);
#line 525
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 526
        root = p;
#line 526
        tmp = root;
      } else {
#line 528
        tmp->fts_link = p;
#line 529
        tmp = p;
      }
    }
#line 487
    argv ++;
#line 487
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  if (compar) {
#line 533
    if (nitems > 1UL) {
      {
#line 534
      root = fts_sort(sp, root, nitems);
      }
    }
  }
  {
#line 541
  tmp___11 = fts_alloc(sp, "", (size_t )0);
#line 541
  sp->fts_cur = tmp___11;
  }
#line 541
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 542
    goto mem3;
  }
  {
#line 543
  (sp->fts_cur)->fts_link = root;
#line 544
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 545
  tmp___12 = setup_dir(sp);
  }
#line 545
  if (! tmp___12) {
#line 546
    goto mem3;
  }
#line 555
  if (! (sp->fts_options & 4)) {
#line 555
    if (! (sp->fts_options & 512)) {
      {
#line 555
      tmp___13 = diropen((FTS const   *)sp, ".");
#line 555
      sp->fts_rfd = tmp___13;
      }
#line 555
      if (tmp___13 < 0) {
#line 557
        sp->fts_options |= 4;
      }
    }
  }
  {
#line 559
  i_ring_init(& sp->fts_fd_ring, -1);
  }
#line 560
  return (sp);
  mem3: 
  {
#line 562
  fts_lfree(root);
#line 563
  free((void *)parent);
  }
  mem2: 
  {
#line 564
  free((void *)sp->fts_path);
  }
  mem1: 
  {
#line 565
  free((void *)sp);
  }
#line 566
  return ((FTS *)((void *)0));
}
}
#line 569 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 583
  tmp = p->fts_namelen;
#line 583
  p->fts_pathlen = tmp;
#line 583
  len = tmp;
#line 584
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 585
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 585
  if (cp) {
#line 585
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    } else
#line 585
    if (*(cp + 1)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    }
  }
#line 590
  tmp___0 = sp->fts_path;
#line 590
  p->fts_path = tmp___0;
#line 590
  p->fts_accpath = tmp___0;
#line 591
  return;
}
}
#line 593
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 593 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) 
{ 
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 597
  saved_errno = 0;
#line 604
  if (sp->fts_cur) {
#line 605
    p = sp->fts_cur;
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (! (p->fts_level >= 0L)) {
#line 605
        goto while_break;
      }
#line 606
      freep = p;
#line 607
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 607
        p = p->fts_link;
      } else {
#line 607
        p = p->fts_parent;
      }
      {
#line 608
      free((void *)freep);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 610
    free((void *)p);
    }
  }
#line 614
  if (sp->fts_child) {
    {
#line 615
    fts_lfree(sp->fts_child);
    }
  }
  {
#line 616
  free((void *)sp->fts_array);
#line 617
  free((void *)sp->fts_path);
  }
#line 619
  if (sp->fts_options & 512) {
#line 621
    if (0 <= sp->fts_cwd_fd) {
      {
#line 622
      tmp___0 = close(sp->fts_cwd_fd);
      }
#line 622
      if (tmp___0) {
        {
#line 623
        tmp = __errno_location();
#line 623
        saved_errno = *tmp;
        }
      }
    }
  } else
#line 625
  if (! (sp->fts_options & 4)) {
    {
#line 628
    tmp___2 = fchdir(sp->fts_rfd);
    }
#line 628
    if (tmp___2) {
      {
#line 629
      tmp___1 = __errno_location();
#line 629
      saved_errno = *tmp___1;
      }
    }
    {
#line 633
    tmp___4 = close(sp->fts_rfd);
    }
#line 633
    if (tmp___4) {
#line 634
      if (saved_errno == 0) {
        {
#line 635
        tmp___3 = __errno_location();
#line 635
        saved_errno = *tmp___3;
        }
      }
    }
  }
  {
#line 638
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 640
  if (sp->fts_leaf_optimization_works_ht) {
    {
#line 641
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
  }
  {
#line 643
  free_dir(sp);
#line 646
  free((void *)sp);
  }
#line 649
  if (saved_errno) {
    {
#line 650
    tmp___5 = __errno_location();
#line 650
    *tmp___5 = saved_errno;
    }
#line 651
    return (-1);
  }
#line 654
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 672 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 683
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 683
  if (tmp != 0) {
#line 684
    return ((_Bool)1);
  }
  {
#line 691
  if (fs_buf.f_type == 26985L) {
#line 691
    goto case_26985;
  }
#line 691
  if (fs_buf.f_type == 16914836L) {
#line 691
    goto case_26985;
  }
#line 696
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 694
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 697
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 704 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 710
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 710
  if (tmp != 0) {
#line 711
    return ((_Bool)0);
  }
  {
#line 720
  if (fs_buf.f_type == 1382369651L) {
#line 720
    goto case_1382369651;
  }
#line 729
  goto switch_default;
  case_1382369651: /* CIL Label */ 
#line 721
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 730
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 754 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 757
  ax = (struct LCO_ent  const  *)x;
#line 758
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 761 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 764
  ax = (struct LCO_ent  const  *)x;
#line 765
  ay = (struct LCO_ent  const  *)y;
#line 766
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 772 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 775
  sp = (FTS *)p->fts_fts;
#line 776
  h = sp->fts_leaf_optimization_works_ht;
#line 784
  if (! (sp->fts_options & 512)) {
#line 785
    return ((_Bool)0);
  }
#line 788
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 790
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 790
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 790
    h = tmp___0;
    }
#line 793
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 794
      return ((_Bool)0);
    }
  }
  {
#line 796
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 797
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 797
  ent = (struct LCO_ent *)tmp___1;
  }
#line 798
  if (ent) {
#line 799
    return (ent->opt_ok);
  }
  {
#line 802
  tmp___2 = malloc(sizeof(*t2));
#line 802
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 803
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 804
    return ((_Bool)0);
  }
  {
#line 807
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 808
  t2->opt_ok = opt_ok;
#line 809
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 811
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 811
  ent = (struct LCO_ent *)tmp___3;
  }
#line 812
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 815
    free((void *)t2);
    }
#line 816
    return ((_Bool)0);
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 818
      abort();
      }
    }
#line 818
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (opt_ok);
}
}
#line 831
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 831 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) 
{ 
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  FTSENT *parent ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  _Bool tmp___12 ;
  int *tmp___13 ;
  struct _ftsent *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int saved_errno ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  FTSENT *tmp___24 ;

  {
#line 839
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 840
    return ((FTSENT *)((void *)0));
  } else
#line 839
  if (sp->fts_options & 16384) {
#line 840
    return ((FTSENT *)((void *)0));
  }
#line 843
  p = sp->fts_cur;
#line 846
  instr = p->fts_instr;
#line 847
  p->fts_instr = (unsigned short)3;
#line 850
  if ((int )instr == 1) {
    {
#line 851
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 852
    return (p);
  }
#line 863
  if ((int )instr == 2) {
#line 863
    if ((int )p->fts_info == 12) {
#line 863
      goto _L;
    } else
#line 863
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */ 
      {
#line 865
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 866
      if ((int )p->fts_info == 1) {
#line 866
        if (! (sp->fts_options & 4)) {
          {
#line 867
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 867
          p->fts_symfd = tmp___1;
          }
#line 867
          if (tmp___1 < 0) {
            {
#line 868
            tmp___0 = __errno_location();
#line 868
            p->fts_errno = *tmp___0;
#line 869
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 871
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 873
      goto check_for_dir;
    }
  }
#line 877
  if ((int )p->fts_info == 1) {
#line 879
    if ((int )instr == 4) {
#line 879
      goto _L___0;
    } else
#line 879
    if (sp->fts_options & 64) {
#line 879
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */ 
#line 881
        if ((int )p->fts_flags & 2) {
          {
#line 882
          close(p->fts_symfd);
          }
        }
#line 883
        if (sp->fts_child) {
          {
#line 884
          fts_lfree(sp->fts_child);
#line 885
          sp->fts_child = (struct _ftsent *)((void *)0);
          }
        }
#line 887
        p->fts_info = (unsigned short)6;
        {
#line 888
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 888
          leave_dir(sp, p);
          }
#line 888
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 889
        return (p);
      }
    }
#line 893
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 893
      if (sp->fts_options & 8192) {
        {
#line 894
        sp->fts_options &= -8193;
#line 895
        fts_lfree(sp->fts_child);
#line 896
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
      }
    }
#line 911
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
#line 912
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      }
#line 912
      if (tmp___3) {
        {
#line 913
        tmp___2 = __errno_location();
#line 913
        p->fts_errno = *tmp___2;
#line 914
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 915
        p = sp->fts_child;
        }
        {
#line 915
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 915
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 915
            goto while_break___0;
          }
#line 917
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 915
          p = p->fts_link;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 920
      tmp___4 = fts_build(sp, 3);
#line 920
      sp->fts_child = tmp___4;
      }
#line 920
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 921
        if (sp->fts_options & 16384) {
#line 922
          return ((FTSENT *)((void *)0));
        }
#line 926
        if (p->fts_errno) {
#line 926
          if ((int )p->fts_info != 4) {
#line 927
            p->fts_info = (unsigned short)7;
          }
        }
        {
#line 928
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 928
          leave_dir(sp, p);
          }
#line 928
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 929
        return (p);
      }
    }
#line 931
    p = sp->fts_child;
#line 932
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 933
    goto name;
  }
  next: 
#line 937
  tmp = p;
#line 942
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
#line 942
    if ((p->fts_parent)->fts_dirp) {
      {
#line 944
      p = tmp->fts_parent;
#line 945
      sp->fts_cur = p;
#line 946
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 948
      p = fts_build(sp, 3);
      }
#line 948
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 950
        if (sp->fts_options & 16384) {
#line 951
          return ((FTSENT *)((void *)0));
        }
#line 952
        goto cd_dot_dot;
      }
      {
#line 955
      free((void *)tmp);
      }
#line 956
      goto name;
    }
  }
#line 959
  p = p->fts_link;
#line 959
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 960
    sp->fts_cur = p;
#line 961
    free((void *)tmp);
    }
#line 968
    if (p->fts_level == 0L) {
      {
#line 969
      tmp___5 = restore_initial_cwd(sp);
      }
#line 969
      if (tmp___5) {
#line 970
        sp->fts_options |= 16384;
#line 971
        return ((FTSENT *)((void *)0));
      }
      {
#line 973
      free_dir(sp);
#line 974
      fts_load(sp, p);
#line 975
      setup_dir(sp);
      }
#line 976
      goto check_for_dir;
    }
#line 984
    if ((int )p->fts_instr == 4) {
#line 985
      goto next;
    }
#line 986
    if ((int )p->fts_instr == 2) {
      {
#line 987
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 988
      if ((int )p->fts_info == 1) {
#line 988
        if (! (sp->fts_options & 4)) {
          {
#line 989
          tmp___7 = diropen((FTS const   *)sp, ".");
#line 989
          p->fts_symfd = tmp___7;
          }
#line 989
          if (tmp___7 < 0) {
            {
#line 990
            tmp___6 = __errno_location();
#line 990
            p->fts_errno = *tmp___6;
#line 991
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 993
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 995
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 998
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 998
      tmp___8 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 998
      tmp___8 = (p->fts_parent)->fts_pathlen;
    }
    {
#line 998
    t = sp->fts_path + tmp___8;
#line 999
    tmp___9 = t;
#line 999
    t ++;
#line 999
    *tmp___9 = (char )'/';
#line 1000
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir: 
#line 1002
    sp->fts_cur = p;
#line 1003
    if ((int )p->fts_info == 11) {
#line 1005
      if (p->fts_statp[0].st_size == 2L) {
#line 1007
        parent = p->fts_parent;
#line 1008
        if (0L < p->fts_level) {
#line 1008
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 1008
            if (sp->fts_options & 8) {
#line 1008
              if (sp->fts_options & 16) {
                {
#line 1008
                tmp___10 = link_count_optimize_ok((FTSENT const   *)parent);
                }
#line 1008
                if (! tmp___10) {
#line 1008
                  goto _L___4;
                }
              } else {
#line 1008
                goto _L___4;
              }
            } else {
#line 1008
              goto _L___4;
            }
          } else {
#line 1008
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 1020
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
#line 1021
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 1021
            if (p->fts_level != 0L) {
#line 1021
              if (parent->fts_n_dirs_remaining) {
#line 1024
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        {
#line 1028
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1028
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
#line 1028
            abort();
            }
          }
#line 1028
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1031
    if ((int )p->fts_info == 1) {
#line 1036
      if (p->fts_level == 0L) {
#line 1037
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      {
#line 1039
      tmp___12 = enter_dir(sp, p);
      }
#line 1039
      if (! tmp___12) {
        {
#line 1041
        tmp___11 = __errno_location();
#line 1041
        *tmp___11 = 12;
        }
#line 1042
        return ((FTSENT *)((void *)0));
      }
    }
#line 1045
    return (p);
  }
  cd_dot_dot: 
  {
#line 1050
  p = tmp->fts_parent;
#line 1051
  sp->fts_cur = p;
#line 1052
  free((void *)tmp);
  }
#line 1054
  if (p->fts_level == -1L) {
    {
#line 1059
    free((void *)p);
#line 1060
    tmp___13 = __errno_location();
#line 1060
    *tmp___13 = 0;
#line 1061
    tmp___14 = (struct _ftsent *)((void *)0);
#line 1061
    sp->fts_cur = tmp___14;
    }
#line 1061
    return (tmp___14);
  }
  {
#line 1064
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1064
    if (! ((int )p->fts_info != 11)) {
      {
#line 1064
      abort();
      }
    }
#line 1064
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1067
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1075
  if (p->fts_level == 0L) {
    {
#line 1076
    tmp___16 = restore_initial_cwd(sp);
    }
#line 1076
    if (tmp___16) {
      {
#line 1077
      tmp___15 = __errno_location();
#line 1077
      p->fts_errno = *tmp___15;
#line 1078
      sp->fts_options |= 16384;
      }
    }
  } else
#line 1080
  if ((int )p->fts_flags & 2) {
#line 1081
    if (! (sp->fts_options & 4)) {
#line 1081
      if (sp->fts_options & 512) {
        {
#line 1081
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1081
        tmp___21 = 0;
        }
      } else {
        {
#line 1081
        tmp___20 = fchdir(p->fts_symfd);
#line 1081
        tmp___21 = tmp___20;
        }
      }
#line 1081
      if (tmp___21) {
        {
#line 1082
        tmp___17 = __errno_location();
#line 1082
        saved_errno = *tmp___17;
#line 1083
        close(p->fts_symfd);
#line 1084
        tmp___18 = __errno_location();
#line 1084
        *tmp___18 = saved_errno;
#line 1085
        tmp___19 = __errno_location();
#line 1085
        p->fts_errno = *tmp___19;
#line 1086
        sp->fts_options |= 16384;
        }
      }
    }
    {
#line 1088
    close(p->fts_symfd);
    }
  } else
#line 1089
  if (! ((int )p->fts_flags & 1)) {
    {
#line 1089
    tmp___23 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    }
#line 1089
    if (tmp___23) {
      {
#line 1091
      tmp___22 = __errno_location();
#line 1091
      p->fts_errno = *tmp___22;
#line 1092
      sp->fts_options |= 16384;
      }
    }
  }
#line 1094
  if (p->fts_errno) {
#line 1094
    p->fts_info = (unsigned short)7;
  } else {
#line 1094
    p->fts_info = (unsigned short)6;
  }
#line 1095
  if (p->fts_errno == 0) {
    {
#line 1096
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1096
      leave_dir(sp, p);
      }
#line 1096
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1097
  if (sp->fts_options & 16384) {
#line 1097
    tmp___24 = (FTSENT *)((void *)0);
  } else {
#line 1097
    tmp___24 = p;
  }
#line 1097
  return (tmp___24);
}
}
#line 1107
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1107 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr ) 
{ 
  int *tmp ;

  {
#line 1110
  if (instr != 0) {
#line 1110
    if (instr != 1) {
#line 1110
      if (instr != 2) {
#line 1110
        if (instr != 3) {
#line 1110
          if (instr != 4) {
            {
#line 1112
            tmp = __errno_location();
#line 1112
            *tmp = 22;
            }
#line 1113
            return (1);
          }
        }
      }
    }
  }
#line 1115
  p->fts_instr = (unsigned short )instr;
#line 1116
  return (0);
}
}
#line 1119
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 1119 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                          int instr ) 
{ 
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1125
  if (instr != 0) {
#line 1125
    if (instr != 8192) {
      {
#line 1126
      tmp = __errno_location();
#line 1126
      *tmp = 22;
      }
#line 1127
      return ((FTSENT *)((void *)0));
    }
  }
  {
#line 1131
  p = sp->fts_cur;
#line 1137
  tmp___0 = __errno_location();
#line 1137
  *tmp___0 = 0;
  }
#line 1140
  if (sp->fts_options & 16384) {
#line 1141
    return ((FTSENT *)((void *)0));
  }
#line 1144
  if ((int )p->fts_info == 9) {
#line 1145
    return (p->fts_link);
  }
#line 1152
  if ((int )p->fts_info != 1) {
#line 1153
    return ((FTSENT *)((void *)0));
  }
#line 1156
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
#line 1157
    fts_lfree(sp->fts_child);
    }
  }
#line 1159
  if (instr == 8192) {
#line 1160
    sp->fts_options |= 8192;
#line 1161
    instr = 2;
  } else {
#line 1163
    instr = 1;
  }
#line 1172
  if (p->fts_level != 0L) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  } else
#line 1172
  if ((int )*(p->fts_accpath + 0) == 47) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  } else
#line 1172
  if (sp->fts_options & 4) {
    {
#line 1174
    tmp___1 = fts_build(sp, instr);
#line 1174
    sp->fts_child = tmp___1;
    }
#line 1174
    return (tmp___1);
  }
  {
#line 1176
  fd = diropen((FTS const   *)sp, ".");
  }
#line 1176
  if (fd < 0) {
#line 1177
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1177
    sp->fts_child = tmp___2;
#line 1177
    return (tmp___2);
  }
  {
#line 1178
  sp->fts_child = fts_build(sp, instr);
  }
#line 1179
  if (sp->fts_options & 512) {
    {
#line 1181
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
  } else {
    {
#line 1185
    tmp___5 = fchdir(fd);
    }
#line 1185
    if (tmp___5) {
      {
#line 1187
      tmp___3 = __errno_location();
#line 1187
      saved_errno = *tmp___3;
#line 1188
      close(fd);
#line 1189
      tmp___4 = __errno_location();
#line 1189
      *tmp___4 = saved_errno;
      }
#line 1190
      return ((FTSENT *)((void *)0));
    }
    {
#line 1192
    close(fd);
    }
  }
#line 1194
  return (sp->fts_child);
}
}
#line 1202 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1205
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1205
    tmp___0 = -1;
  } else {
#line 1205
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1205
      tmp = 1;
    } else {
#line 1205
      tmp = 0;
    }
#line 1205
    tmp___0 = tmp;
  }
#line 1205
  return (tmp___0);
}
}
#line 1211 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1217
  if (dtype == 6U) {
#line 1217
    goto case_6;
  }
#line 1220
  if (dtype == 2U) {
#line 1220
    goto case_2;
  }
#line 1223
  if (dtype == 4U) {
#line 1223
    goto case_4;
  }
#line 1226
  if (dtype == 1U) {
#line 1226
    goto case_1;
  }
#line 1229
  if (dtype == 10U) {
#line 1229
    goto case_10;
  }
#line 1232
  if (dtype == 8U) {
#line 1232
    goto case_8;
  }
#line 1235
  if (dtype == 12U) {
#line 1235
    goto case_12;
  }
#line 1238
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1218
  type = (mode_t )24576;
#line 1219
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1221
  type = (mode_t )8192;
#line 1222
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1224
  type = (mode_t )16384;
#line 1225
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1227
  type = (mode_t )4096;
#line 1228
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1230
  type = (mode_t )40960;
#line 1231
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1233
  type = (mode_t )32768;
#line 1234
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1236
  type = (mode_t )49152;
#line 1237
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1239
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1241
  st->st_mode = type;
#line 1242
  return;
}
}
#line 1277 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  _Bool skip_stat ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  _Bool tmp___27 ;

  {
#line 1294
  cur = sp->fts_cur;
#line 1295
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1300
  if (continue_readdir) {
    {
#line 1302
    dp = cur->fts_dirp;
#line 1303
    dir_fd = dirfd(dp);
    }
#line 1304
    if (dir_fd < 0) {
      {
#line 1306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1306
        closedir(cur->fts_dirp);
#line 1306
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1306
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1307
      if (type == 3) {
        {
#line 1309
        cur->fts_info = (unsigned short)4;
#line 1310
        tmp = __errno_location();
#line 1310
        cur->fts_errno = *tmp;
        }
      }
#line 1312
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1319
    if (sp->fts_options & 16) {
#line 1319
      if (sp->fts_options & 1) {
#line 1319
        if (cur->fts_level == 0L) {
#line 1319
          tmp___2 = 0;
        } else {
#line 1319
          tmp___2 = 131072;
        }
      } else {
#line 1319
        tmp___2 = 131072;
      }
    } else {
#line 1319
      tmp___2 = 0;
    }
#line 1319
    if (sp->fts_options & 2048) {
#line 1319
      tmp___3 = 262144;
    } else {
#line 1319
      tmp___3 = 0;
    }
#line 1319
    if (! (sp->fts_options & 4)) {
#line 1319
      if (sp->fts_options & 512) {
#line 1319
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1319
        tmp___4 = -100;
      }
    } else {
#line 1319
      tmp___4 = -100;
    }
    {
#line 1319
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
#line 1319
    cur->fts_dirp = tmp___1;
    }
#line 1319
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1321
      if (type == 3) {
        {
#line 1323
        cur->fts_info = (unsigned short)4;
#line 1324
        tmp___0 = __errno_location();
#line 1324
        cur->fts_errno = *tmp___0;
        }
      }
#line 1326
      return ((FTSENT *)((void *)0));
    }
#line 1331
    if ((int )cur->fts_info == 11) {
      {
#line 1332
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
      }
    } else
#line 1333
    if (sp->fts_options & 256) {
      {
#line 1340
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1340
        leave_dir(sp, cur);
        }
#line 1340
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1341
      fts_stat(sp, cur, (_Bool)0);
#line 1342
      tmp___6 = enter_dir(sp, cur);
      }
#line 1342
      if (! tmp___6) {
        {
#line 1344
        tmp___5 = __errno_location();
#line 1344
        *tmp___5 = 12;
        }
#line 1345
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1357
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1357
    tmp___7 = 100000UL;
  } else {
#line 1357
    tmp___7 = 0xffffffffffffffffUL;
  }
#line 1357
  max_entries = tmp___7;
#line 1365
  if (type == 2) {
#line 1366
    nlinks = (nlink_t )0;
#line 1368
    nostat = (_Bool)0;
  } else
#line 1369
  if (sp->fts_options & 8) {
#line 1369
    if (sp->fts_options & 16) {
#line 1370
      if (sp->fts_options & 32) {
#line 1370
        tmp___8 = 0;
      } else {
#line 1370
        tmp___8 = 2;
      }
#line 1370
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
#line 1372
      nostat = (_Bool)1;
    } else {
#line 1374
      nlinks = (nlink_t )-1;
#line 1375
      nostat = (_Bool)0;
    }
  } else {
#line 1374
    nlinks = (nlink_t )-1;
#line 1375
    nostat = (_Bool)0;
  }
#line 1393
  if (continue_readdir) {
#line 1397
    descend = (_Bool)1;
  } else
#line 1399
  if (nlinks) {
#line 1399
    goto _L___0;
  } else
#line 1399
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1400
    if (sp->fts_options & 512) {
      {
#line 1402
      dir_fd = dup_safer(dir_fd);
      }
#line 1403
      if (0 <= dir_fd) {
        {
#line 1404
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1406
    if (dir_fd < 0) {
#line 1406
      goto _L;
    } else {
      {
#line 1406
      tmp___10 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1406
      if (tmp___10) {
        _L: /* CIL Label */ 
#line 1407
        if (nlinks) {
#line 1407
          if (type == 3) {
            {
#line 1408
            tmp___9 = __errno_location();
#line 1408
            cur->fts_errno = *tmp___9;
            }
          }
        }
#line 1409
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1410
        descend = (_Bool)0;
        {
#line 1411
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1411
          closedir(cur->fts_dirp);
#line 1411
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1411
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1412
        if (sp->fts_options & 512) {
#line 1412
          if (0 <= dir_fd) {
            {
#line 1413
            close(dir_fd);
            }
          }
        }
#line 1414
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1416
        descend = (_Bool)1;
      }
    }
  } else {
#line 1418
    descend = (_Bool)0;
  }
#line 1430
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1430
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1430
    len = cur->fts_pathlen;
  }
#line 1431
  if (sp->fts_options & 4) {
#line 1432
    cp = sp->fts_path + len;
#line 1433
    tmp___11 = cp;
#line 1433
    cp ++;
#line 1433
    *tmp___11 = (char )'/';
  } else {
#line 1436
    cp = (char *)((void *)0);
  }
#line 1438
  len ++;
#line 1439
  maxlen = sp->fts_pathlen - len;
#line 1441
  level = cur->fts_level + 1L;
#line 1444
  doadjust = (_Bool)0;
#line 1445
  head = (FTSENT *)((void *)0);
#line 1446
  tail = (FTSENT *)((void *)0);
#line 1447
  nitems = (size_t )0;
  {
#line 1448
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1448
    if (! cur->fts_dirp) {
#line 1448
      goto while_break___2;
    }
    {
#line 1450
    tmp___12 = readdir(cur->fts_dirp);
#line 1450
    dp___0 = tmp___12;
    }
#line 1451
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
#line 1452
      goto while_break___2;
    }
#line 1453
    if (! (sp->fts_options & 32)) {
#line 1453
      if ((int )dp___0->d_name[0] == 46) {
#line 1453
        if (! dp___0->d_name[1]) {
#line 1454
          goto while_continue___2;
        } else
#line 1453
        if ((int )dp___0->d_name[1] == 46) {
#line 1453
          if (! dp___0->d_name[2]) {
#line 1454
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1456
    tmp___13 = strlen((char const   *)(dp___0->d_name));
#line 1456
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), tmp___13);
    }
#line 1456
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1458
      goto mem1;
    }
    {
#line 1459
    tmp___18 = strlen((char const   *)(dp___0->d_name));
    }
#line 1459
    if (tmp___18 >= maxlen) {
      {
#line 1461
      oldaddr = (void *)sp->fts_path;
#line 1462
      tmp___16 = strlen((char const   *)(dp___0->d_name));
#line 1462
      tmp___17 = fts_palloc(sp, (tmp___16 + len) + 1UL);
      }
#line 1462
      if (! tmp___17) {
        mem1: 
        {
#line 1468
        tmp___14 = __errno_location();
#line 1468
        saved_errno = *tmp___14;
#line 1469
        free((void *)p);
#line 1470
        fts_lfree(head);
        }
        {
#line 1471
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1471
          closedir(cur->fts_dirp);
#line 1471
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1471
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1472
        cur->fts_info = (unsigned short)7;
#line 1473
        sp->fts_options |= 16384;
#line 1474
        tmp___15 = __errno_location();
#line 1474
        *tmp___15 = saved_errno;
        }
#line 1475
        return ((FTSENT *)((void *)0));
      }
#line 1478
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1479
        doadjust = (_Bool)1;
#line 1480
        if (sp->fts_options & 4) {
#line 1481
          cp = sp->fts_path + len;
        }
      }
#line 1483
      maxlen = sp->fts_pathlen - len;
    }
    {
#line 1486
    tmp___19 = strlen((char const   *)(dp___0->d_name));
#line 1486
    new_len = len + tmp___19;
    }
#line 1487
    if (new_len < len) {
      {
#line 1494
      free((void *)p);
#line 1495
      fts_lfree(head);
      }
      {
#line 1496
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1496
        closedir(cur->fts_dirp);
#line 1496
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1496
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1497
      cur->fts_info = (unsigned short)7;
#line 1498
      sp->fts_options |= 16384;
#line 1499
      tmp___20 = __errno_location();
#line 1499
      *tmp___20 = 36;
      }
#line 1500
      return ((FTSENT *)((void *)0));
    }
#line 1502
    p->fts_level = level;
#line 1503
    p->fts_parent = sp->fts_cur;
#line 1504
    p->fts_pathlen = new_len;
#line 1508
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1511
    if (sp->fts_options & 4) {
      {
#line 1512
      p->fts_accpath = p->fts_path;
#line 1513
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1515
      p->fts_accpath = p->fts_name;
    }
#line 1517
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1517
      goto _L___1;
    } else
#line 1517
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1530
      if (sp->fts_options & 16) {
#line 1530
        if (sp->fts_options & 8) {
#line 1530
          if ((int )dp___0->d_type != 0) {
#line 1530
            if (! ((int )dp___0->d_type == 4)) {
#line 1530
              tmp___21 = 1;
            } else {
#line 1530
              tmp___21 = 0;
            }
          } else {
#line 1530
            tmp___21 = 0;
          }
        } else {
#line 1530
          tmp___21 = 0;
        }
      } else {
#line 1530
        tmp___21 = 0;
      }
      {
#line 1530
      skip_stat = (_Bool )tmp___21;
#line 1534
      p->fts_info = (unsigned short)11;
#line 1537
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1538
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      }
#line 1539
      if (sp->fts_options & 16) {
#line 1539
        if ((int )dp___0->d_type == 4) {
#line 1539
          tmp___22 = 1;
        } else {
#line 1539
          tmp___22 = 0;
        }
      } else {
#line 1539
        tmp___22 = 0;
      }
#line 1539
      is_dir = (_Bool )tmp___22;
    } else {
      {
#line 1542
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
#line 1543
      if ((int )p->fts_info == 1) {
#line 1543
        tmp___23 = 1;
      } else
#line 1543
      if ((int )p->fts_info == 2) {
#line 1543
        tmp___23 = 1;
      } else
#line 1543
      if ((int )p->fts_info == 5) {
#line 1543
        tmp___23 = 1;
      } else {
#line 1543
        tmp___23 = 0;
      }
#line 1543
      is_dir = (_Bool )tmp___23;
    }
#line 1549
    if (nlinks > 0UL) {
#line 1549
      if (is_dir) {
#line 1550
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1553
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1554
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1555
      tail = p;
#line 1555
      head = tail;
    } else {
#line 1557
      tail->fts_link = p;
#line 1558
      tail = p;
    }
#line 1560
    nitems ++;
#line 1561
    if (max_entries <= nitems) {
#line 1565
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1569
  if (cur->fts_dirp) {
    {
#line 1570
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1570
      closedir(cur->fts_dirp);
#line 1570
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1570
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1578
  if (doadjust) {
    {
#line 1579
    fts_padjust(sp, head);
    }
  }
#line 1585
  if (sp->fts_options & 4) {
#line 1586
    if (len == sp->fts_pathlen) {
#line 1587
      cp --;
    } else
#line 1586
    if (nitems == 0UL) {
#line 1587
      cp --;
    }
#line 1588
    *cp = (char )'\000';
  }
#line 1598
  if (! continue_readdir) {
#line 1598
    if (descend) {
#line 1598
      if (type == 1) {
#line 1598
        goto _L___2;
      } else
#line 1598
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1598
        if (cur->fts_level == 0L) {
          {
#line 1598
          tmp___24 = restore_initial_cwd(sp);
#line 1598
          tmp___26 = tmp___24;
          }
        } else {
          {
#line 1598
          tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1598
          tmp___26 = tmp___25;
          }
        }
#line 1598
        if (tmp___26) {
          {
#line 1602
          cur->fts_info = (unsigned short)7;
#line 1603
          sp->fts_options |= 16384;
#line 1604
          fts_lfree(head);
          }
#line 1605
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1609
  if (! nitems) {
#line 1610
    if (type == 3) {
#line 1611
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1612
    fts_lfree(head);
    }
#line 1613
    return ((FTSENT *)((void *)0));
  }
#line 1620
  if (nitems > 10000UL) {
#line 1620
    if (! sp->fts_compar) {
#line 1620
      if (sp->fts_options & 512) {
        {
#line 1620
        tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
#line 1620
        if (tmp___27) {
          {
#line 1624
          sp->fts_compar = & fts_compare_ino;
#line 1625
          head = fts_sort(sp, head, nitems);
#line 1626
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1630
  if (sp->fts_compar) {
#line 1630
    if (nitems > 1UL) {
      {
#line 1631
      head = fts_sort(sp, head, nitems);
      }
    }
  }
#line 1632
  return (head);
}
}
#line 1779 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1783
  sbp = p->fts_statp;
#line 1786
  if (p->fts_level == 0L) {
#line 1786
    if (sp->fts_options & 1) {
#line 1787
      follow = (_Bool)1;
    }
  }
#line 1794
  if (sp->fts_options & 2) {
#line 1794
    goto _L;
  } else
#line 1794
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1795
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1795
    if (tmp___3) {
      {
#line 1796
      tmp = __errno_location();
#line 1796
      saved_errno = *tmp;
#line 1797
      tmp___1 = __errno_location();
      }
#line 1797
      if (*tmp___1 == 2) {
        {
#line 1797
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1797
        if (tmp___2 == 0) {
          {
#line 1799
          tmp___0 = __errno_location();
#line 1799
          *tmp___0 = 0;
          }
#line 1800
          return ((unsigned short)13);
        }
      }
#line 1802
      p->fts_errno = saved_errno;
#line 1803
      goto err;
    }
  } else {
    {
#line 1805
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1805
    if (tmp___5) {
      {
#line 1807
      tmp___4 = __errno_location();
#line 1807
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1808
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1809
      return ((unsigned short)10);
    }
  }
#line 1812
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1813
    if (sp->fts_options & 32) {
#line 1813
      tmp___6 = 0;
    } else {
#line 1813
      tmp___6 = 2;
    }
#line 1813
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1815
    if ((int )p->fts_name[0] == 46) {
#line 1815
      if (! p->fts_name[1]) {
#line 1815
        goto _L___0;
      } else
#line 1815
      if ((int )p->fts_name[1] == 46) {
#line 1815
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1817
          if (p->fts_level == 0L) {
#line 1817
            tmp___7 = 1;
          } else {
#line 1817
            tmp___7 = 5;
          }
#line 1817
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1820
    return ((unsigned short)1);
  }
#line 1822
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1823
    return ((unsigned short)12);
  }
#line 1824
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1825
    return ((unsigned short)8);
  }
#line 1826
  return ((unsigned short)3);
}
}
#line 1829 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1837
  pa = (FTSENT const   **)a;
#line 1838
  pb = (FTSENT const   **)b;
#line 1839
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1839
  return (tmp);
}
}
#line 1842 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1856
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1856
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1856
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1856
      tmp = & fts_compar;
    }
  } else {
#line 1856
    tmp = & fts_compar;
  }
#line 1856
  compare = tmp;
#line 1869
  if (nitems > sp->fts_nitems) {
#line 1872
    sp->fts_nitems = nitems + 40UL;
#line 1873
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1876
      free((void *)sp->fts_array);
#line 1877
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1878
      sp->fts_nitems = (size_t )0;
      }
#line 1879
      return (head);
    } else {
      {
#line 1873
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1873
      a = (FTSENT **)tmp___0;
      }
#line 1873
      if (! a) {
        {
#line 1876
        free((void *)sp->fts_array);
#line 1877
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1878
        sp->fts_nitems = (size_t )0;
        }
#line 1879
        return (head);
      }
    }
#line 1881
    sp->fts_array = a;
  }
#line 1883
  ap = sp->fts_array;
#line 1883
  p = head;
  {
#line 1883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1883
    if (! p) {
#line 1883
      goto while_break;
    }
#line 1884
    tmp___1 = ap;
#line 1884
    ap ++;
#line 1884
    *tmp___1 = p;
#line 1883
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1885
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1886
  ap = sp->fts_array;
#line 1886
  head = *ap;
  }
  {
#line 1886
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1886
    nitems --;
#line 1886
    if (! nitems) {
#line 1886
      goto while_break___0;
    }
#line 1887
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1886
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1888
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1889
  return (head);
}
}
#line 1892 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1903
  len = sizeof(FTSENT ) + namelen;
#line 1904
  tmp = malloc(len);
#line 1904
  p = (FTSENT *)tmp;
  }
#line 1904
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1905
    return ((FTSENT *)((void *)0));
  }
  {
#line 1908
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1909
  p->fts_name[namelen] = (char )'\000';
#line 1911
  p->fts_namelen = namelen;
#line 1912
  p->fts_fts = sp;
#line 1913
  p->fts_path = sp->fts_path;
#line 1914
  p->fts_errno = 0;
#line 1915
  p->fts_dirp = (DIR *)((void *)0);
#line 1916
  p->fts_flags = (unsigned short)0;
#line 1917
  p->fts_instr = (unsigned short)3;
#line 1918
  p->fts_number = 0L;
#line 1919
  p->fts_pointer = (void *)0;
  }
#line 1920
  return (p);
}
}
#line 1923 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_lfree(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    p = head;
#line 1930
    if (! p) {
#line 1930
      goto while_break;
    }
#line 1931
    head = head->fts_link;
#line 1932
    if (p->fts_dirp) {
      {
#line 1933
      closedir(p->fts_dirp);
      }
    }
    {
#line 1934
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1936
  return;
}
}
#line 1945 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1950
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1955
  if (new_len < sp->fts_pathlen) {
    {
#line 1956
    free((void *)sp->fts_path);
#line 1957
    sp->fts_path = (char *)((void *)0);
#line 1958
    tmp = __errno_location();
#line 1958
    *tmp = 36;
    }
#line 1959
    return ((_Bool)0);
  }
  {
#line 1961
  sp->fts_pathlen = new_len;
#line 1962
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1962
  p = (char *)tmp___0;
  }
#line 1963
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1964
    free((void *)sp->fts_path);
#line 1965
    sp->fts_path = (char *)((void *)0);
    }
#line 1966
    return ((_Bool)0);
  }
#line 1968
  sp->fts_path = p;
#line 1969
  return ((_Bool)1);
}
}
#line 1976 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 1981
  addr = sp->fts_path;
#line 1991
  p = sp->fts_child;
  {
#line 1991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1991
    if (! p) {
#line 1991
      goto while_break;
    }
    {
#line 1992
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1992
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1992
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1992
      p->fts_path = addr;
#line 1992
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1991
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1995
  p = head;
  {
#line 1995
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1995
    if (! (p->fts_level >= 0L)) {
#line 1995
      goto while_break___1;
    }
    {
#line 1996
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1996
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1996
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1996
      p->fts_path = addr;
#line 1996
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1997
    if (p->fts_link) {
#line 1997
      p = p->fts_link;
    } else {
#line 1997
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1999
  return;
}
}
#line 2001 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2007
  max = (size_t )0;
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    if (! *argv) {
#line 2007
      goto while_break;
    }
    {
#line 2008
    len = strlen((char const   *)*argv);
    }
#line 2008
    if (len > max) {
#line 2009
      max = len;
    }
#line 2007
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2022 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2027
  if (dir) {
    {
#line 2027
    tmp = strcmp(dir, "..");
    }
#line 2027
    if (tmp == 0) {
#line 2027
      tmp___0 = 1;
    } else {
#line 2027
      tmp___0 = 0;
    }
  } else {
#line 2027
    tmp___0 = 0;
  }
#line 2027
  is_dotdot = (_Bool )tmp___0;
#line 2034
  if (sp->fts_options & 4) {
#line 2036
    if (sp->fts_options & 512) {
#line 2036
      if (0 <= fd) {
        {
#line 2037
        close(fd);
        }
      }
    }
#line 2038
    return (0);
  }
#line 2041
  if (fd < 0) {
#line 2041
    if (is_dotdot) {
#line 2041
      if (sp->fts_options & 512) {
        {
#line 2048
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2048
        if (! tmp___1) {
          {
#line 2052
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2053
          is_dotdot = (_Bool)1;
          }
#line 2054
          if (0 <= parent_fd) {
#line 2056
            fd = parent_fd;
#line 2057
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2062
  newfd = fd;
#line 2063
  if (fd < 0) {
    {
#line 2063
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 2063
    if (newfd < 0) {
#line 2064
      return (-1);
    }
  }
#line 2073
  if (sp->fts_options & 2) {
#line 2073
    goto _L;
  } else
#line 2073
  if (dir) {
    {
#line 2073
    tmp___4 = strcmp(dir, "..");
    }
#line 2073
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2077
      tmp___2 = fstat(newfd, & sb);
      }
#line 2077
      if (tmp___2) {
#line 2079
        ret = -1;
#line 2080
        goto bail;
      }
#line 2082
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2085
        tmp___3 = __errno_location();
#line 2085
        *tmp___3 = 2;
#line 2086
        ret = -1;
        }
#line 2087
        goto bail;
      } else
#line 2082
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2085
        tmp___3 = __errno_location();
#line 2085
        *tmp___3 = 2;
#line 2086
        ret = -1;
        }
#line 2087
        goto bail;
      }
    }
  }
#line 2091
  if (sp->fts_options & 512) {
    {
#line 2093
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2094
    return (0);
  }
  {
#line 2097
  ret = fchdir(newfd);
  }
  bail: 
#line 2099
  if (fd < 0) {
    {
#line 2101
    tmp___5 = __errno_location();
#line 2101
    oerrno = *tmp___5;
#line 2102
    close(newfd);
#line 2103
    tmp___6 = __errno_location();
#line 2103
    *tmp___6 = oerrno;
    }
  }
#line 2105
  return (ret);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/khheo/project/benchmark/grep-2.18/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 60 "/home/khheo/project/benchmark/grep-2.18/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = (char const   *)tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 403 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 232 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 168 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 172
  result = -1;
#line 173
  __builtin_va_start(arg, action);
  }
  {
#line 217
  if (action == 1030) {
#line 217
    goto case_1030;
  }
#line 298
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 219
  tmp___0 = __builtin_va_arg(arg, int );
#line 219
  target = tmp___0;
  }
#line 233
  if (0 <= have_dupfd_cloexec) {
    {
#line 235
    result = fcntl(fd, action, target);
    }
#line 236
    if (0 <= result) {
#line 238
      have_dupfd_cloexec = 1;
    } else {
      {
#line 236
      tmp___1 = __errno_location();
      }
#line 236
      if (*tmp___1 != 22) {
#line 238
        have_dupfd_cloexec = 1;
      } else {
        {
#line 246
        result = rpl_fcntl(fd, 0, target);
        }
#line 247
        if (result < 0) {
#line 248
          goto switch_break;
        }
#line 249
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 253
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 254
  if (0 <= result) {
#line 254
    if (have_dupfd_cloexec == -1) {
      {
#line 256
      tmp___2 = fcntl(result, 1);
#line 256
      flags = tmp___2;
      }
#line 257
      if (flags < 0) {
#line 257
        goto _L;
      } else {
        {
#line 257
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 257
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 259
          tmp___3 = __errno_location();
#line 259
          saved_errno = *tmp___3;
#line 260
          close(result);
#line 261
          tmp___4 = __errno_location();
#line 261
          *tmp___4 = saved_errno;
#line 262
          result = -1;
          }
        }
      }
    }
  }
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  tmp___7 = __builtin_va_arg(arg, void *);
#line 301
  p = tmp___7;
#line 302
  result = fcntl(fd, action, p);
  }
#line 306
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 309
  __builtin_va_end(arg);
  }
#line 310
  return (result);
}
}
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 44
struct exclude *new_exclude(void) ;
#line 45
void free_exclude(struct exclude *ex ) ;
#line 46
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 47
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 49
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 50
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 116 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 116 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    tmp = str;
#line 121
    str ++;
    {
#line 123
    if ((int const   )*tmp == 92) {
#line 123
      goto case_92;
    }
#line 127
    if ((int const   )*tmp == 33) {
#line 127
      goto case_33;
    }
#line 127
    if ((int const   )*tmp == 64) {
#line 127
      goto case_33;
    }
#line 127
    if ((int const   )*tmp == 43) {
#line 127
      goto case_33;
    }
#line 132
    if ((int const   )*tmp == 91) {
#line 132
      goto case_91;
    }
#line 132
    if ((int const   )*tmp == 42) {
#line 132
      goto case_91;
    }
#line 132
    if ((int const   )*tmp == 63) {
#line 132
      goto case_91;
    }
#line 135
    if ((int const   )*tmp == 0) {
#line 135
      goto case_0;
    }
#line 121
    goto switch_break;
    case_92: /* CIL Label */ 
#line 124
    if (! (options & (1 << 1))) {
#line 124
      if (*str) {
#line 124
        tmp___0 = 1;
      } else {
#line 124
        tmp___0 = 0;
      }
    } else {
#line 124
      tmp___0 = 0;
    }
#line 124
    str += tmp___0;
#line 125
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 128
    if (options & (1 << 5)) {
#line 128
      if ((int const   )*str == 40) {
#line 129
        return ((_Bool)1);
      }
    }
#line 130
    goto switch_break;
    case_91: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 133
    return ((_Bool)1);
    case_0: /* CIL Label */ 
#line 136
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 141 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void unescape_pattern(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 144
  q = (char const   *)str;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if ((int const   )*q == 92) {
#line 146
      if (*(q + 1)) {
#line 146
        tmp = 1;
      } else {
#line 146
        tmp = 0;
      }
    } else {
#line 146
      tmp = 0;
    }
#line 146
    q += tmp;
#line 145
    tmp___0 = str;
#line 145
    str ++;
#line 145
    tmp___2 = q;
#line 145
    q ++;
#line 145
    tmp___1 = (char )*tmp___2;
#line 145
    *tmp___0 = tmp___1;
#line 145
    if (! tmp___1) {
#line 145
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 152 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 155
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 155
  return ((struct exclude *)tmp___0);
}
}
#line 159 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 162
  p = (char const   *)data;
#line 163
  tmp = hash_string(p, n_buckets);
  }
#line 163
  return (tmp);
}
}
#line 167 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 170
  p = (char const   *)data;
#line 172
  value = (size_t )0;
#line 174
  iter.cur.ptr = p;
#line 174
  iter.in_shift = (_Bool)0;
#line 174
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 174
  iter.next_done = (_Bool)0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    mbuiter_multi_next(& iter);
    }
#line 174
    if (iter.cur.wc_valid) {
#line 174
      if (iter.cur.wc == 0) {
#line 174
        tmp___0 = 0;
      } else {
#line 174
        tmp___0 = 1;
      }
    } else {
#line 174
      tmp___0 = 1;
    }
#line 174
    if (! tmp___0) {
#line 174
      goto while_break;
    }
#line 176
    m = iter.cur;
#line 179
    if (m.wc_valid) {
      {
#line 180
      tmp = towlower((wint_t )m.wc);
#line 180
      wc = (wchar_t )tmp;
      }
    } else {
#line 182
      wc = (wchar_t )*(m.ptr);
    }
#line 184
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 174
    iter.cur.ptr += iter.cur.bytes;
#line 174
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (value);
}
}
#line 191 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 194
  p1 = (char const   *)data1;
#line 195
  p2 = (char const   *)data2;
#line 196
  tmp = strcmp(p1, p2);
  }
#line 196
  return ((_Bool )(tmp == 0));
}
}
#line 200 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 203
  p1 = (char const   *)data1;
#line 204
  p2 = (char const   *)data2;
#line 205
  tmp = mbscasecmp(p1, p2);
  }
#line 205
  return ((_Bool )(tmp == 0));
}
}
#line 208 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void string_free(void *data ) 
{ 


  {
  {
#line 211
  free(data);
  }
#line 212
  return;
}
}
#line 216 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void new_exclude_segment(struct exclude *ex , enum exclude_type type , int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 219
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 219
  sp = (struct exclude_segment *)tmp;
#line 220
  sp->type = type;
#line 221
  sp->options = options;
  }
  {
#line 224
  if ((unsigned int )type == 1U) {
#line 224
    goto case_1;
  }
#line 227
  if ((unsigned int )type == 0U) {
#line 227
    goto case_0;
  }
#line 222
  goto switch_break;
  case_1: /* CIL Label */ 
#line 225
  goto switch_break;
  case_0: /* CIL Label */ 
#line 228
  if (options & (1 << 4)) {
#line 228
    tmp___0 = & string_compare_ci;
  } else {
#line 228
    tmp___0 = & string_compare;
  }
#line 228
  if (options & (1 << 4)) {
#line 228
    tmp___1 = & string_hasher_ci;
  } else {
#line 228
    tmp___1 = & string_hasher;
  }
  {
#line 228
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 236
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  sp->next = ex->head;
#line 239
  ex->head = sp;
#line 240
  return;
}
}
#line 243 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 


  {
  {
#line 248
  if ((unsigned int )seg->type == 1U) {
#line 248
    goto case_1;
  }
#line 252
  if ((unsigned int )seg->type == 0U) {
#line 252
    goto case_0;
  }
#line 246
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 249
  free((void *)seg->v.pat.exclude);
  }
#line 250
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 253
  hash_free(seg->v.table);
  }
#line 254
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 256
  free((void *)seg);
  }
#line 257
  return;
}
}
#line 260 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_segment *next ;

  {
#line 264
  seg = ex->head;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! seg) {
#line 264
      goto while_break;
    }
    {
#line 266
    next = seg->next;
#line 267
    free_exclude_segment(seg);
#line 268
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  free((void *)ex);
  }
#line 271
  return;
}
}
#line 276 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 279
  if (! (options & (1 << 3))) {
#line 280
    if (options & (1 << 4)) {
      {
#line 280
      tmp = mbscasecmp(pattern, f);
#line 280
      tmp___1 = tmp;
      }
    } else {
      {
#line 280
      tmp___0 = strcmp(pattern, f);
#line 280
      tmp___1 = tmp___0;
      }
    }
#line 280
    return (tmp___1);
  } else
#line 283
  if (! (options & (1 << 4))) {
    {
#line 285
    tmp___2 = strlen(pattern);
#line 285
    patlen = tmp___2;
#line 286
    tmp___3 = strncmp(pattern, f, patlen);
#line 286
    r = tmp___3;
    }
#line 287
    if (! r) {
#line 289
      r = (int )*(f + patlen);
#line 290
      if (r == 47) {
#line 291
        r = 0;
      }
    }
#line 293
    return (r);
  } else {
    {
#line 304
    tmp___4 = xstrdup(f);
#line 304
    fcopy = tmp___4;
#line 307
    p = fcopy;
    }
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 309
      p = strchr((char const   *)p, '/');
      }
#line 310
      if (p) {
#line 311
        *p = (char )'\000';
      }
      {
#line 312
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 313
      if (! p) {
#line 314
        goto while_break;
      } else
#line 313
      if (r___0 <= 0) {
#line 314
        goto while_break;
      }
#line 307
      tmp___5 = p;
#line 307
      p ++;
#line 307
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 316
    free((void *)fcopy);
    }
#line 317
    return (r___0);
  }
}
}
#line 321 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher___0)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 324
  if (options & (1 << 28)) {
#line 324
    tmp = & fnmatch;
  } else {
#line 324
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 324
  matcher___0 = tmp;
#line 328
  tmp___0 = (*matcher___0)(pattern, f, options);
#line 328
  matched = (_Bool )(tmp___0 == 0);
  }
#line 331
  if (! (options & (1 << 30))) {
#line 332
    p = f;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (*p) {
#line 332
        if (! (! matched)) {
#line 332
          goto while_break;
        }
      } else {
#line 332
        goto while_break;
      }
#line 333
      if ((int const   )*p == 47) {
#line 333
        if ((int const   )*(p + 1) != 47) {
          {
#line 334
          tmp___1 = (*matcher___0)(pattern, p + 1, options);
#line 334
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 332
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 336
  return (matched);
}
}
#line 341 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool file_pattern_matches(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 344
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 345
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 348
  i = (size_t )0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i < exclude_count)) {
#line 348
      goto while_break;
    }
    {
#line 350
    pattern = (char const   *)(exclude + i)->pattern;
#line 351
    options = (int )(exclude + i)->options;
#line 352
    tmp = exclude_fnmatch(pattern, f, options);
    }
#line 352
    if (tmp) {
#line 353
      return ((_Bool)1);
    }
#line 348
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return ((_Bool)0);
}
}
#line 361 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool file_name_matches(struct exclude_segment  const  *seg , char const   *f ,
                               char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 365
  options = (int )seg->options;
#line 366
  table = (Hash_table *)seg->v.table;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 375
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 375
      if (tmp) {
#line 376
        return ((_Bool)1);
      }
#line 377
      if (options & (1 << 3)) {
        {
#line 379
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 379
        p = tmp___0;
        }
#line 380
        if (p) {
#line 382
          *p = (char)0;
#line 383
          goto while_continue___0;
        }
      }
#line 386
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    if (! (options & (1 << 30))) {
      {
#line 391
      tmp___1 = strchr(f, '/');
#line 391
      f = (char const   *)tmp___1;
      }
#line 392
      if (f) {
#line 393
        f ++;
      }
    } else {
#line 396
      goto while_break;
    }
#line 368
    if (! f) {
#line 368
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((_Bool)0);
}
}
#line 405 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool invert ;
  char *filename___0 ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 409
  invert = (_Bool)0;
#line 410
  filename___0 = (char *)((void *)0);
#line 413
  if (! ex->head) {
#line 414
    return ((_Bool)0);
  }
#line 419
  seg = (struct exclude_segment *)ex->head;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if ((unsigned int )seg->type == 0U) {
#line 423
      if (! filename___0) {
        {
#line 424
        tmp = strlen(f);
#line 424
        tmp___0 = xmalloc(tmp + 1UL);
#line 424
        filename___0 = (char *)tmp___0;
        }
      }
      {
#line 425
      tmp___1 = file_name_matches((struct exclude_segment  const  *)seg, f, filename___0);
      }
#line 425
      if (tmp___1) {
#line 426
        goto while_break;
      }
    } else {
      {
#line 430
      tmp___2 = file_pattern_matches((struct exclude_segment  const  *)seg, f);
      }
#line 430
      if (tmp___2) {
#line 431
        goto while_break;
      }
    }
#line 434
    if (! seg->next) {
#line 442
      invert = (_Bool)1;
#line 443
      goto while_break;
    }
#line 419
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  free((void *)filename___0);
  }
#line 448
  return ((_Bool )((int )invert ^ ! (seg->options & (1 << 29))));
}
}
#line 453 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  int exclude_hash_flags ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 458
  if (options & (1 << 28)) {
    {
#line 458
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
    }
#line 458
    if (tmp___2) {
#line 464
      if (ex->head) {
#line 464
        if ((unsigned int )(ex->head)->type == 1U) {
#line 464
          if (! (((ex->head)->options & (1 << 29)) == (options & (1 << 29)))) {
            {
#line 467
            new_exclude_segment(ex, (enum exclude_type )1, options);
            }
          }
        } else {
          {
#line 467
          new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        }
      } else {
        {
#line 467
        new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      }
#line 468
      seg = ex->head;
#line 470
      pat = & seg->v.pat;
#line 471
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 472
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 472
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 474
      tmp___0 = pat->exclude_count;
#line 474
      (pat->exclude_count) ++;
#line 474
      patopts = pat->exclude + tmp___0;
#line 475
      patopts->pattern = pattern;
#line 476
      patopts->options = options;
    } else {
#line 458
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 481
    exclude_hash_flags = (((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4);
#line 483
    if (ex->head) {
#line 483
      if ((unsigned int )(ex->head)->type == 0U) {
#line 483
        if (! (((ex->head)->options & exclude_hash_flags) == (options & exclude_hash_flags))) {
          {
#line 486
          new_exclude_segment(ex, (enum exclude_type )0, options);
          }
        }
      } else {
        {
#line 486
        new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      }
    } else {
      {
#line 486
      new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    }
    {
#line 487
    seg = ex->head;
#line 489
    str = xstrdup(pattern);
    }
#line 490
    if ((options & ((1 << 28) | (1 << 1))) == 1 << 28) {
      {
#line 491
      unescape_pattern(str);
      }
    }
    {
#line 492
    tmp___1 = hash_insert(seg->v.table, (void const   *)str);
#line 492
    p = (char *)tmp___1;
    }
#line 493
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 494
      free((void *)str);
      }
    }
  }
#line 496
  return;
}
}
#line 503 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 508
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 508
    if (! *(file_name___1 + 1)) {
#line 508
      tmp = 1;
    } else {
#line 508
      tmp = 0;
    }
  } else {
#line 508
    tmp = 0;
  }
#line 508
  use_stdin = (_Bool )tmp;
#line 510
  buf = (char *)((void *)0);
#line 514
  buf_alloc = (size_t )0;
#line 515
  buf_count = (size_t )0;
#line 517
  e = 0;
#line 519
  if (use_stdin) {
#line 520
    in = stdin;
  } else {
    {
#line 521
    in = fopen((char const   */* __restrict  */)file_name___1, (char const   */* __restrict  */)"r");
    }
#line 521
    if (! in) {
#line 522
      return (-1);
    }
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 524
    c = getc_unlocked(in);
    }
#line 524
    if (! (c != -1)) {
#line 524
      goto while_break;
    }
#line 526
    if (buf_count == buf_alloc) {
      {
#line 527
      tmp___0 = x2realloc((void *)buf, & buf_alloc);
#line 527
      buf = (char *)tmp___0;
      }
    }
#line 528
    tmp___1 = buf_count;
#line 528
    buf_count ++;
#line 528
    *(buf + tmp___1) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 531
  tmp___3 = ferror_unlocked(in);
  }
#line 531
  if (tmp___3) {
    {
#line 532
    tmp___2 = __errno_location();
#line 532
    e = *tmp___2;
    }
  }
#line 534
  if (! use_stdin) {
    {
#line 534
    tmp___5 = fclose(in);
    }
#line 534
    if (tmp___5 != 0) {
      {
#line 535
      tmp___4 = __errno_location();
#line 535
      e = *tmp___4;
      }
    }
  }
  {
#line 537
  tmp___6 = xrealloc((void *)buf, buf_count + 1UL);
#line 537
  buf = (char *)tmp___6;
#line 538
  *(buf + buf_count) = line_end;
  }
#line 539
  if (buf_count == 0UL) {
#line 539
    tmp___7 = 0;
  } else
#line 539
  if ((int )*(buf + (buf_count - 1UL)) == (int )line_end) {
#line 539
    tmp___7 = 0;
  } else {
#line 539
    tmp___7 = 1;
  }
#line 539
  lim = (char const   *)((buf + buf_count) + tmp___7);
#line 540
  pattern = (char const   *)buf;
#line 542
  p = buf;
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 542
      goto while_break___0;
    }
#line 543
    if ((int )*p == (int )line_end) {
      {
#line 545
      pattern_end = p;
#line 547
      tmp___9 = __ctype_b_loc();
      }
#line 547
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 549
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 550
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 551
            goto next_pattern;
          } else {
            {
#line 552
            tmp___8 = __ctype_b_loc();
            }
#line 552
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 553
              goto while_break___1;
            }
          }
#line 549
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 556
      *pattern_end = (char )'\000';
#line 557
      (*add_func)(ex, pattern, options);
      }
      next_pattern: 
#line 560
      pattern = (char const   *)(p + 1);
    }
#line 542
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 563
  tmp___10 = __errno_location();
#line 563
  *tmp___10 = e;
  }
#line 564
  if (e) {
#line 564
    tmp___11 = -1;
  } else {
#line 564
    tmp___11 = 0;
  }
#line 564
  return (tmp___11);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-2.18/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.18/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 41
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/grep-2.18/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 


  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ 
  _Bool tmp___0 ;

  {
#line 60
  if (! (state->magic == 9827862)) {
    {
#line 60
    __assert_fail("state->magic == CC_MAGIC", "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.c",
                  60U, "cycle_check");
    }
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
  {
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp___0 = is_zero_or_power_of_two(state->chdir_counter);
  }
#line 70
  if (tmp___0) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 23 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode___0 ) ;
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 27 "/home/khheo/project/benchmark/grep-2.18/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = creat(file, mode___0);
#line 30
  tmp___0 = fd_safer(tmp);
  }
#line 30
  return (tmp___0);
}
}
#line 22 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 19 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.h"
int should_colorize(void) ;
#line 20
void init_colorize(void) ;
#line 21
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) ;
#line 22
void print_end_colorize(char const   *sgr_end___0 ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
int should_colorize(void) 
{ 
  char const   *t ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = getenv("TERM");
#line 39
  t = (char const   *)tmp;
  }
#line 40
  if (t) {
    {
#line 40
    tmp___0 = strcmp(t, "dumb");
    }
#line 40
    if (tmp___0 != 0) {
#line 40
      tmp___1 = 1;
    } else {
#line 40
      tmp___1 = 0;
    }
  } else {
#line 40
    tmp___1 = 0;
  }
#line 40
  return (tmp___1);
}
}
#line 43 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
void init_colorize(void) 
{ 


  {
#line 43
  return;
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) 
{ 


  {
  {
#line 50
  printf((char const   */* __restrict  */)sgr_start___0, sgr_seq);
  }
#line 51
  return;
}
}
#line 54 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
void print_end_colorize(char const   *sgr_end___0 ) 
{ 


  {
  {
#line 57
  fputs((char const   */* __restrict  */)sgr_end___0, (FILE */* __restrict  */)stdout);
  }
#line 58
  return;
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/grep-2.18/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/grep-2.18/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/cloexec.h"
int dup_cloexec(int fd ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/grep-2.18/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/khheo/project/benchmark/grep-2.18/lib/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 114 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 45 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = fchdir((int )cdb->fd);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
    {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
    }
#line 63
    if (! (! close_fail)) {
      {
#line 63
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                    63U, "cdb_free");
      }
    }
  }
#line 65
  return;
}
}
#line 71 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = tmp;
  }
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
  {
#line 79
  cdb_free((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
  }
#line 82
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 89
  tmp = strspn(s, "/");
#line 89
  n_slash = tmp;
  }
#line 90
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 108 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  char * __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char * __attribute__((__pure__)) tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int saved_errno ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 111
  tmp = chdir((char const   *)dir);
#line 111
  e = tmp;
  }
#line 112
  if (e == 0) {
#line 113
    return (e);
  } else {
    {
#line 112
    tmp___0 = __errno_location();
    }
#line 112
    if (*tmp___0 != 36) {
#line 113
      return (e);
    }
  }
  {
#line 116
  tmp___1 = strlen((char const   *)dir);
#line 116
  len = tmp___1;
#line 117
  dir_end = dir + len;
#line 121
  cdb_init(& cdb);
  }
#line 125
  if (! (0UL < len)) {
    {
#line 125
    __assert_fail("0 < len", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                  125U, "chdir_long");
    }
  }
#line 126
  if (! (4096UL <= len)) {
    {
#line 126
    __assert_fail("PATH_MAX <= len", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                  126U, "chdir_long");
    }
  }
  {
#line 129
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 136
  if (n_leading_slash == 2UL) {
    {
#line 141
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 141
    slash = (char *)tmp___4;
    }
#line 142
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 144
      tmp___5 = __errno_location();
#line 144
      *tmp___5 = 36;
      }
#line 145
      return (-1);
    }
    {
#line 147
    *slash = (char )'\000';
#line 148
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 149
    *slash = (char )'/';
    }
#line 150
    if (err != 0) {
#line 151
      goto Fail;
    }
    {
#line 152
    tmp___6 = find_non_slash((char const   *)(slash + 1));
#line 152
    dir = (char *)tmp___6;
    }
  } else
#line 154
  if (n_leading_slash) {
    {
#line 156
    tmp___7 = cdb_advance_fd(& cdb, "/");
    }
#line 156
    if (tmp___7 != 0) {
#line 157
      goto Fail;
    }
#line 158
    dir += n_leading_slash;
  }
#line 161
  if (! ((int )*dir != 47)) {
    {
#line 161
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                  161U, "chdir_long");
    }
  }
#line 162
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 162
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                  162U, "chdir_long");
    }
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (4096L <= dir_end - dir)) {
#line 164
      goto while_break;
    }
    {
#line 170
    tmp___10 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 170
    slash___0 = (char *)tmp___10;
    }
#line 171
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 173
      tmp___11 = __errno_location();
#line 173
      *tmp___11 = 36;
      }
#line 174
      return (-1);
    }
#line 177
    *slash___0 = (char )'\000';
#line 178
    if (! (slash___0 - dir < 4096L)) {
      {
#line 178
      __assert_fail("slash - dir < PATH_MAX", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                    178U, "chdir_long");
      }
    }
    {
#line 179
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 180
    *slash___0 = (char )'/';
    }
#line 181
    if (err___0 != 0) {
#line 182
      goto Fail;
    }
    {
#line 184
    tmp___13 = find_non_slash((char const   *)(slash___0 + 1));
#line 184
    dir = (char *)tmp___13;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 189
    tmp___14 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 189
    if (tmp___14 != 0) {
#line 190
      goto Fail;
    }
  }
  {
#line 193
  tmp___15 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 193
  if (tmp___15 != 0) {
#line 194
    goto Fail;
  }
  {
#line 196
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 197
  return (0);
  Fail: 
  {
#line 201
  tmp___16 = __errno_location();
#line 201
  saved_errno = *tmp___16;
#line 202
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 203
  tmp___17 = __errno_location();
#line 203
  *tmp___17 = saved_errno;
  }
#line 204
  return (-1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-2.18/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 135 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.h"
int c_tolower(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 120 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.h"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 122
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 123
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 124
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 125
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 126
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 127
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 128
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 129
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 130
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 131
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 132
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 133
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 136
int c_toupper(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 29
  if (c >= 0) {
#line 29
    if (c <= 127) {
#line 29
      tmp = 1;
    } else {
#line 29
      tmp = 0;
    }
  } else {
#line 29
    tmp = 0;
  }
#line 29
  return ((_Bool )tmp);
}
}
#line 32
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 38
  if (c >= 48) {
#line 38
    if (c <= 57) {
#line 38
      tmp = 1;
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 38
  if ((c & -33) >= 65) {
#line 38
    if ((c & -33) <= 90) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
  } else {
#line 38
    tmp = 0;
  }
#line 38
  return ((_Bool )tmp);
}
}
#line 67
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 67 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 72
  if ((c & -33) >= 65) {
#line 72
    if ((c & -33) <= 90) {
#line 72
      tmp = 1;
    } else {
#line 72
      tmp = 0;
    }
  } else {
#line 72
    tmp = 0;
  }
#line 72
  return ((_Bool )tmp);
}
}
#line 96
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 96 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 99
  if (c == 32) {
#line 99
    tmp = 1;
  } else
#line 99
  if (c == 9) {
#line 99
    tmp = 1;
  } else {
#line 99
    tmp = 0;
  }
#line 99
  return ((_Bool )tmp);
}
}
#line 102
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 102 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 106
  if ((c & -32) == 0) {
#line 106
    tmp = 1;
  } else
#line 106
  if (c == 127) {
#line 106
    tmp = 1;
  } else {
#line 106
    tmp = 0;
  }
#line 106
  return ((_Bool )tmp);
}
}
#line 136
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 136 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 140
  if (c >= 48) {
#line 140
    if (c <= 57) {
#line 140
      tmp = 1;
    } else {
#line 140
      tmp = 0;
    }
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return ((_Bool )tmp);
}
}
#line 153
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 153 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 157
  if (c >= 97) {
#line 157
    if (c <= 122) {
#line 157
      tmp = 1;
    } else {
#line 157
      tmp = 0;
    }
  } else {
#line 157
    tmp = 0;
  }
#line 157
  return ((_Bool )tmp);
}
}
#line 173
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 173 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 177
  if (c >= 33) {
#line 177
    if (c <= 126) {
#line 177
      tmp = 1;
    } else {
#line 177
      tmp = 0;
    }
  } else {
#line 177
    tmp = 0;
  }
#line 177
  return ((_Bool )tmp);
}
}
#line 207
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 207 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 211
  if (c >= 32) {
#line 211
    if (c <= 126) {
#line 211
      tmp = 1;
    } else {
#line 211
      tmp = 0;
    }
  } else {
#line 211
    tmp = 0;
  }
#line 211
  return ((_Bool )tmp);
}
}
#line 241
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 241 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 245
  if (c >= 33) {
#line 245
    if (c <= 126) {
#line 245
      if (c >= 48) {
#line 245
        if (c <= 57) {
#line 245
          tmp = 0;
        } else {
#line 245
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 245
      if ((c & -33) >= 65) {
#line 245
        if ((c & -33) <= 90) {
#line 245
          tmp = 0;
        } else {
#line 245
          tmp = 1;
        }
      } else {
#line 245
        tmp = 1;
      }
    } else {
#line 245
      tmp = 0;
    }
  } else {
#line 245
    tmp = 0;
  }
#line 245
  return ((_Bool )tmp);
}
}
#line 265
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 265 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 268
  if (c == 32) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 9) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 10) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 11) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 12) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 13) {
#line 268
    tmp = 1;
  } else {
#line 268
    tmp = 0;
  }
#line 268
  return ((_Bool )tmp);
}
}
#line 272
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 272 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 276
  if (c >= 65) {
#line 276
    if (c <= 90) {
#line 276
      tmp = 1;
    } else {
#line 276
      tmp = 0;
    }
  } else {
#line 276
    tmp = 0;
  }
#line 276
  return ((_Bool )tmp);
}
}
#line 292
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 292 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 298
  if (c >= 48) {
#line 298
    if (c <= 57) {
#line 298
      tmp = 1;
    } else {
#line 298
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 298
  if ((c & -33) >= 65) {
#line 298
    if ((c & -33) <= 70) {
#line 298
      tmp = 1;
    } else {
#line 298
      tmp = 0;
    }
  } else {
#line 298
    tmp = 0;
  }
#line 298
  return ((_Bool )tmp);
}
}
#line 319
int c_tolower(int c )  __attribute__((__const__)) ;
#line 319 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 323
  if (c >= 65) {
#line 323
    if (c <= 90) {
#line 323
      tmp = (c - 65) + 97;
    } else {
#line 323
      tmp = c;
    }
  } else {
#line 323
    tmp = c;
  }
#line 323
  return (tmp);
}
}
#line 358
int c_toupper(int c )  __attribute__((__const__)) ;
#line 358 "/home/khheo/project/benchmark/grep-2.18/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 362
  if (c >= 97) {
#line 362
    if (c <= 122) {
#line 362
      tmp = (c - 97) + 65;
    } else {
#line 362
      tmp = c;
    }
  } else {
#line 362
    tmp = c;
  }
#line 362
  return (tmp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 52 "/home/khheo/project/benchmark/grep-2.18/lib/binary-io.h"
__inline int set_binary_mode(int fd , int mode___0 ) 
{ 


  {
#line 57
  return (0);
}
}
#line 73
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 56
void (*argmatch_die)(void) ;
#line 60
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 72
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 83
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 98
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 545 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
void usage(int status ) ;
#line 60 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 68 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 82 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0UL) {
      {
#line 158
      tmp___0 = quote((char const   *)*(arglist + i));
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp___0);
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___2 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___2) {
        {
#line 158
        tmp___0 = quote((char const   *)*(arglist + i));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp___0);
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        tmp___1 = quote((char const   *)*(arglist + i));
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___1);
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  putc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 195 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale___2(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___2(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale___3(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___3(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___3(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol-error.c"
static void xstrtol_error___0(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                              char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 59 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale___4(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-2.18/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___4(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___4(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 28
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 28
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 20 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/cjk.h"
static int is_cjk_encoding___0(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data___0[1728]  = 
#line 35 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 280 "/home/khheo/project/benchmark/grep-2.18/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind___0[240]  = 
#line 280
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 102 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct quoting_options default_quoting_options___0  ;
#line 178 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct quoting_options quoting_options_from_style___0(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char const   *gettext_quote___0(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static size_t quotearg_buffer_restyled___0(char *buffer___0 , size_t buffersize ,
                                           char const   *arg , size_t argsize , enum quoting_style quoting_style ,
                                           int flags , unsigned int const   *quote_these_too ,
                                           char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___0 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote___0("`", quoting_style);
#line 313
    right_quote = gettext_quote___0("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___0 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___7 = i == argsize;
    }
#line 343
    if (tmp___7) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (argsize == 0xffffffffffffffffUL) {
#line 349
          if (1UL < quote_string_len) {
            {
#line 349
            argsize = strlen(arg);
#line 349
            tmp___0 = argsize;
            }
          } else {
#line 349
            tmp___0 = argsize;
          }
        } else {
#line 349
          tmp___0 = argsize;
        }
#line 349
        if (i + quote_string_len <= tmp___0) {
          {
#line 349
          tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___1 == 0) {
#line 359
            if (elide_outer_quotes) {
#line 360
              goto force_outer_quoting_style;
            }
#line 361
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 364
    c = (unsigned char )*(arg + i);
    {
#line 367
    if ((int )c == 0) {
#line 367
      goto case_0___0;
    }
#line 393
    if ((int )c == 63) {
#line 393
      goto case_63;
    }
#line 431
    if ((int )c == 7) {
#line 431
      goto case_7___0;
    }
#line 432
    if ((int )c == 8) {
#line 432
      goto case_8___0;
    }
#line 433
    if ((int )c == 12) {
#line 433
      goto case_12;
    }
#line 434
    if ((int )c == 10) {
#line 434
      goto case_10;
    }
#line 435
    if ((int )c == 13) {
#line 435
      goto case_13;
    }
#line 436
    if ((int )c == 9) {
#line 436
      goto case_9;
    }
#line 437
    if ((int )c == 11) {
#line 437
      goto case_11;
    }
#line 438
    if ((int )c == 92) {
#line 438
      goto case_92;
    }
#line 457
    if ((int )c == 125) {
#line 457
      goto case_125;
    }
#line 457
    if ((int )c == 123) {
#line 457
      goto case_125;
    }
#line 461
    if ((int )c == 126) {
#line 461
      goto case_126;
    }
#line 461
    if ((int )c == 35) {
#line 461
      goto case_126;
    }
#line 473
    if ((int )c == 124) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 96) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 94) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 91) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 62) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 61) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 60) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 59) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 42) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 41) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 40) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 38) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 36) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 34) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 33) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 32) {
#line 473
      goto case_124;
    }
#line 483
    if ((int )c == 39) {
#line 483
      goto case_39___0;
    }
#line 505
    if ((int )c == 122) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 121) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 120) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 119) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 118) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 117) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 116) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 115) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 114) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 113) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 112) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 111) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 110) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 109) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 108) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 107) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 106) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 105) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 104) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 103) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 102) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 101) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 100) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 99) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 98) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 97) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 95) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 93) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 90) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 89) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 88) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 87) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 86) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 85) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 84) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 83) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 82) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 81) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 80) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 79) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 78) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 77) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 76) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 75) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 74) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 73) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 72) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 71) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 70) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 69) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 68) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 67) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 66) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 65) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 58) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 57) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 56) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 55) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 54) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 53) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 52) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 51) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 50) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 49) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 48) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 47) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 46) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 45) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 44) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 43) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 37) {
#line 505
      goto case_122;
    }
#line 518
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 368
    if (backslash_escapes) {
#line 370
      if (elide_outer_quotes) {
#line 371
        goto force_outer_quoting_style;
      }
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 372
        if (len < buffersize) {
#line 372
          *(buffer___0 + len) = (char )'\\';
        }
#line 372
        len ++;
#line 372
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (i + 1UL < argsize) {
#line 378
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 378
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 380
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 380
              if (len < buffersize) {
#line 380
                *(buffer___0 + len) = (char )'0';
              }
#line 380
              len ++;
#line 380
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 381
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 381
              if (len < buffersize) {
#line 381
                *(buffer___0 + len) = (char )'0';
              }
#line 381
              len ++;
#line 381
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 383
      c = (unsigned char )'0';
    } else
#line 389
    if (flags & 1) {
#line 390
      goto __Cont;
    }
#line 391
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 396
    if ((unsigned int )quoting_style == 2U) {
#line 396
      goto case_2___0;
    }
#line 401
    if ((unsigned int )quoting_style == 3U) {
#line 401
      goto case_3___0;
    }
#line 426
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 397
    if (elide_outer_quotes) {
#line 398
      goto force_outer_quoting_style;
    }
#line 399
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 402
    if (flags & 4) {
#line 402
      if (i + 2UL < argsize) {
#line 402
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 408
            goto case_62;
          }
#line 421
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 411
          if (elide_outer_quotes) {
#line 412
            goto force_outer_quoting_style;
          }
#line 413
          c = (unsigned char )*(arg + (i + 2UL));
#line 414
          i += 2UL;
          {
#line 415
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 415
            if (len < buffersize) {
#line 415
              *(buffer___0 + len) = (char )'?';
            }
#line 415
            len ++;
#line 415
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 416
            if (len < buffersize) {
#line 416
              *(buffer___0 + len) = (char )'\"';
            }
#line 416
            len ++;
#line 416
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 417
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 417
            if (len < buffersize) {
#line 417
              *(buffer___0 + len) = (char )'\"';
            }
#line 417
            len ++;
#line 417
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 418
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 418
            if (len < buffersize) {
#line 418
              *(buffer___0 + len) = (char )'?';
            }
#line 418
            len ++;
#line 418
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 419
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 422
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 424
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 429
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 431
    esc = (unsigned char )'a';
#line 431
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 432
    esc = (unsigned char )'b';
#line 432
    goto c_escape;
    case_12: /* CIL Label */ 
#line 433
    esc = (unsigned char )'f';
#line 433
    goto c_escape;
    case_10: /* CIL Label */ 
#line 434
    esc = (unsigned char )'n';
#line 434
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 435
    esc = (unsigned char )'r';
#line 435
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 436
    esc = (unsigned char )'t';
#line 436
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 437
    esc = (unsigned char )'v';
#line 437
    goto c_escape;
    case_92: /* CIL Label */ 
#line 438
    esc = c;
#line 441
    if (backslash_escapes) {
#line 441
      if (elide_outer_quotes) {
#line 441
        if (quote_string_len) {
#line 442
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 445
    if ((unsigned int )quoting_style == 2U) {
#line 445
      if (elide_outer_quotes) {
#line 447
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 450
    if (backslash_escapes) {
#line 452
      c = esc;
#line 453
      goto store_escape;
    }
#line 455
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 458
    if (argsize == 0xffffffffffffffffUL) {
#line 458
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 458
      tmp___2 = argsize == 1UL;
    }
#line 458
    if (! tmp___2) {
#line 459
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 462
    if (i != 0UL) {
#line 463
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 478
    if ((unsigned int )quoting_style == 2U) {
#line 478
      if (elide_outer_quotes) {
#line 480
        goto force_outer_quoting_style;
      }
    }
#line 481
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 484
    if ((unsigned int )quoting_style == 2U) {
#line 486
      if (elide_outer_quotes) {
#line 487
        goto force_outer_quoting_style;
      }
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (len < buffersize) {
#line 488
          *(buffer___0 + len) = (char )'\'';
        }
#line 488
        len ++;
#line 488
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 489
        if (len < buffersize) {
#line 489
          *(buffer___0 + len) = (char )'\\';
        }
#line 489
        len ++;
#line 489
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___0 + len) = (char )'\'';
        }
#line 490
        len ++;
#line 490
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 492
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 516
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 530
    if (unibyte_locale) {
      {
#line 532
      m = (size_t )1;
#line 533
      tmp___3 = __ctype_b_loc();
#line 533
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 538
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 540
      m = (size_t )0;
#line 541
      printable = (_Bool)1;
      }
#line 542
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 543
        argsize = strlen(arg);
        }
      }
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 548
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 548
        bytes = tmp___4;
        }
#line 550
        if (bytes == 0UL) {
#line 551
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xffffffffffffffffUL) {
#line 554
          printable = (_Bool)0;
#line 555
          goto while_break___14;
        } else
#line 557
        if (bytes == 0xfffffffffffffffeUL) {
#line 559
          printable = (_Bool)0;
          {
#line 560
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 560
            if (i + m < argsize) {
#line 560
              if (! *(arg + (i + m))) {
#line 560
                goto while_break___15;
              }
            } else {
#line 560
              goto while_break___15;
            }
#line 561
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 562
          goto while_break___14;
        } else {
#line 570
          if (elide_outer_quotes) {
#line 570
            if ((unsigned int )quoting_style == 2U) {
#line 574
              j = (size_t )1;
              {
#line 574
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 574
                if (! (j < bytes)) {
#line 574
                  goto while_break___16;
                }
                {
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 578
                  goto case_124___0;
                }
#line 581
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 579
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 582
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 574
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 586
          tmp___5 = iswprint((wint_t )w);
          }
#line 586
          if (! tmp___5) {
#line 587
            printable = (_Bool)0;
          }
#line 588
          m += bytes;
        }
        {
#line 545
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 545
        if (tmp___6) {
#line 545
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 594
    if (1UL < m) {
#line 594
      goto _L___0;
    } else
#line 594
    if (backslash_escapes) {
#line 594
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 598
        ilim = i + m;
        {
#line 600
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 602
          if (backslash_escapes) {
#line 602
            if (! printable) {
#line 604
              if (elide_outer_quotes) {
#line 605
                goto force_outer_quoting_style;
              }
              {
#line 606
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 606
                if (len < buffersize) {
#line 606
                  *(buffer___0 + len) = (char )'\\';
                }
#line 606
                len ++;
#line 606
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 607
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 607
                if (len < buffersize) {
#line 607
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 607
                len ++;
#line 607
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 608
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 608
                if (len < buffersize) {
#line 608
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 608
                len ++;
#line 608
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 609
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 602
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 611
          if (is_right_quote) {
            {
#line 613
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 613
              if (len < buffersize) {
#line 613
                *(buffer___0 + len) = (char )'\\';
              }
#line 613
              len ++;
#line 613
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 614
            is_right_quote = (_Bool)0;
          }
#line 616
          if (ilim <= i + 1UL) {
#line 617
            goto while_break___17;
          }
          {
#line 618
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 618
            if (len < buffersize) {
#line 618
              *(buffer___0 + len) = (char )c;
            }
#line 618
            len ++;
#line 618
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 619
          i ++;
#line 619
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 622
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (backslash_escapes) {
#line 627
      goto _L___3;
    } else
#line 627
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 627
      if (quote_these_too) {
#line 627
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 627
          goto _L___2;
        }
      } else {
#line 627
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 627
    if (! is_right_quote) {
#line 631
      goto store_c;
    }
    store_escape: 
#line 634
    if (elide_outer_quotes) {
#line 635
      goto force_outer_quoting_style;
    }
    {
#line 636
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 636
      if (len < buffersize) {
#line 636
        *(buffer___0 + len) = (char )'\\';
      }
#line 636
      len ++;
#line 636
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 639
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 639
      if (len < buffersize) {
#line 639
        *(buffer___0 + len) = (char )c;
      }
#line 639
      len ++;
#line 639
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 642
  if (len == 0UL) {
#line 642
    if ((unsigned int )quoting_style == 2U) {
#line 642
      if (elide_outer_quotes) {
#line 644
        goto force_outer_quoting_style;
      }
    }
  }
#line 646
  if (quote_string) {
#line 646
    if (! elide_outer_quotes) {
      {
#line 647
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 647
        if (! *quote_string) {
#line 647
          goto while_break___25;
        }
        {
#line 648
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 648
          if (len < buffersize) {
#line 648
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 648
          len ++;
#line 648
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 647
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 650
  if (len < buffersize) {
#line 651
    *(buffer___0 + len) = (char )'\000';
  }
#line 652
  return (len);
  force_outer_quoting_style: 
  {
#line 657
  tmp___8 = quotearg_buffer_restyled___0(buffer___0, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0),
                                         left_quote, right_quote);
  }
#line 657
  return (tmp___8);
}
}
#line 731 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char slot0___0[256]  ;
#line 732 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static unsigned int nslots___0  =    1U;
#line 733 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct slotvec slotvec0___0  =    {sizeof(slot0___0), slot0___0};
#line 734 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static struct slotvec *slotvec___0  =    & slotvec0___0;
#line 765 "/home/khheo/project/benchmark/grep-2.18/lib/quotearg.c"
static char *quotearg_n_options___0(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 769
  tmp = __errno_location();
#line 769
  e = *tmp;
#line 771
  n0 = (unsigned int )n;
#line 772
  sv = slotvec___0;
  }
#line 774
  if (n < 0) {
    {
#line 775
    abort();
    }
  }
#line 777
  if (nslots___0 <= n0) {
#line 784
    n1 = (size_t )(n0 + 1U);
#line 785
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0___0));
#line 787
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 787
      tmp___0 = -1;
    } else {
#line 787
      tmp___0 = -2;
    }
#line 787
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 788
      xalloc_die();
      }
    }
#line 790
    if (preallocated) {
#line 790
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 790
      tmp___1 = sv;
    }
    {
#line 790
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 790
    sv = (struct slotvec *)tmp___2;
#line 790
    slotvec___0 = sv;
    }
#line 791
    if (preallocated) {
#line 792
      *sv = slotvec0___0;
    }
    {
#line 793
    memset((void *)(sv + nslots___0), 0, (n1 - (size_t )nslots___0) * sizeof(*sv));
#line 794
    nslots___0 = (unsigned int )n1;
    }
  }
  {
#line 798
  size = (sv + n)->size;
#line 799
  val = (sv + n)->val;
#line 801
  flags = (int )(options->flags | 1);
#line 802
  tmp___3 = quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                         flags, (unsigned int const   *)(options->quote_these_too),
                                         (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 802
  qsize = tmp___3;
  }
#line 808
  if (size <= qsize) {
#line 810
    size = qsize + 1UL;
#line 810
    (sv + n)->size = size;
#line 811
    if ((unsigned long )val != (unsigned long )(slot0___0)) {
      {
#line 812
      free((void *)val);
      }
    }
    {
#line 813
    val = xcharalloc(size);
#line 813
    (sv + n)->val = val;
#line 814
    quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                 flags, (unsigned int const   *)(options->quote_these_too),
                                 (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 820
  tmp___4 = __errno_location();
#line 820
  *tmp___4 = e;
  }
#line 821
  return (val);
}
}
#line 21 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54 "/home/khheo/project/benchmark/grep-2.18/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded___0(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 58 "/home/khheo/project/benchmark/grep-2.18/lib/openat-proc.c"
static int proc_status___0  =    0;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-2.18/lib/str-kmp.h"
static _Bool knuth_morris_pratt___0(unsigned char const   *haystack , unsigned char const   *needle ,
                                    size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 42
    tmp___4 = -1;
  } else {
#line 42
    tmp___4 = -2;
  }
#line 42
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 42
    tmp___3 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 42
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___2 = tmp___1;
      }
    }
#line 42
    tmp___3 = tmp___2;
  }
#line 42
  table = (size_t *)tmp___3;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-2.18/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte___0(char const   *haystack , char const   *needle ,
                                              char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
      }
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = tmp___4;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 53
  table = (size_t *)table_memory;
#line 60
  j = (size_t )0;
#line 61
  iter.cur.ptr = needle;
#line 61
  iter.in_shift = (_Bool)0;
#line 61
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 61
  iter.next_done = (_Bool)0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    mbuiter_multi_next(& iter);
    }
#line 61
    if (iter.cur.wc_valid) {
#line 61
      if (iter.cur.wc == 0) {
#line 61
        tmp___6 = 0;
      } else {
#line 61
        tmp___6 = 1;
      }
    } else {
#line 61
      tmp___6 = 1;
    }
#line 61
    if (! tmp___6) {
#line 61
      goto while_break;
    }
    {
#line 62
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 61
    iter.cur.ptr += iter.cur.bytes;
#line 61
    iter.next_done = (_Bool)0;
#line 61
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(table + 1) = (size_t )1;
#line 85
  j___0 = (size_t )0;
#line 87
  i = (size_t )2;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < m)) {
#line 87
      goto while_break___0;
    }
#line 93
    b = needle_mbchars + (i - 1UL);
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 100
      if (b->wc_valid) {
#line 100
        if ((needle_mbchars + j___0)->wc_valid) {
#line 100
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 100
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 100
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 100
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 100
          if (tmp___7 == 0) {
#line 100
            tmp___8 = 1;
          } else {
#line 100
            tmp___8 = 0;
          }
        } else {
#line 100
          tmp___8 = 0;
        }
#line 100
        tmp___9 = tmp___8;
      }
#line 100
      if (tmp___9) {
#line 103
        j___0 ++;
#line 103
        *(table + i) = i - j___0;
#line 104
        goto while_break___1;
      }
#line 109
      if (j___0 == 0UL) {
#line 112
        *(table + i) = i;
#line 113
        goto while_break___1;
      }
#line 126
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 87
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  *resultp = (char const   *)((void *)0);
#line 139
  j___1 = (size_t )0;
#line 140
  rhaystack.cur.ptr = haystack;
#line 140
  rhaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  rhaystack.next_done = (_Bool)0;
#line 141
  phaystack.cur.ptr = haystack;
#line 141
  phaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  phaystack.next_done = (_Bool)0;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 143
    mbuiter_multi_next(& phaystack);
    }
#line 143
    if (phaystack.cur.wc_valid) {
#line 143
      if (phaystack.cur.wc == 0) {
#line 143
        tmp___15 = 0;
      } else {
#line 143
        tmp___15 = 1;
      }
    } else {
#line 143
      tmp___15 = 1;
    }
#line 143
    if (! tmp___15) {
#line 143
      goto while_break___2;
    }
#line 144
    if ((needle_mbchars + j___1)->wc_valid) {
#line 144
      if (phaystack.cur.wc_valid) {
#line 144
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 144
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 144
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 144
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 144
        if (tmp___12 == 0) {
#line 144
          tmp___13 = 1;
        } else {
#line 144
          tmp___13 = 0;
        }
      } else {
#line 144
        tmp___13 = 0;
      }
#line 144
      tmp___14 = tmp___13;
    }
#line 144
    if (tmp___14) {
#line 146
      j___1 ++;
#line 147
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 147
      phaystack.next_done = (_Bool)0;
#line 148
      if (j___1 == m) {
#line 151
        *resultp = rhaystack.cur.ptr;
#line 152
        goto while_break___2;
      }
    } else
#line 155
    if (j___1 > 0UL) {
#line 158
      count = *(table + j___1);
#line 159
      j___1 -= count;
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (count > 0UL)) {
#line 160
          goto while_break___3;
        }
        {
#line 162
        mbuiter_multi_next(& rhaystack);
        }
#line 162
        if (rhaystack.cur.wc_valid) {
#line 162
          if (rhaystack.cur.wc == 0) {
#line 162
            tmp___10 = 0;
          } else {
#line 162
            tmp___10 = 1;
          }
        } else {
#line 162
          tmp___10 = 1;
        }
#line 162
        if (! tmp___10) {
          {
#line 163
          abort();
          }
        }
#line 164
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 164
        rhaystack.next_done = (_Bool)0;
#line 160
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 170
      mbuiter_multi_next(& rhaystack);
      }
#line 170
      if (rhaystack.cur.wc_valid) {
#line 170
        if (rhaystack.cur.wc == 0) {
#line 170
          tmp___11 = 0;
        } else {
#line 170
          tmp___11 = 1;
        }
      } else {
#line 170
        tmp___11 = 1;
      }
#line 170
      if (! tmp___11) {
        {
#line 171
        abort();
        }
      }
#line 172
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 172
      rhaystack.next_done = (_Bool)0;
#line 173
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 173
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 177
  freea(memory);
  }
#line 178
  return ((_Bool)1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-2.18/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 69 "/home/khheo/project/benchmark/grep-2.18/lib/malloca.c"
static void *mmalloca_results___0[257]  ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 143
#pragma weak pthread_self
#line 147
#pragma weak pthread_cancel
#line 454 "/home/khheo/project/benchmark/grep-2.18/lib/glthread/lock.c"
static int const   fresh_once___0  =    (pthread_once_t const   )0;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 119 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.c"
static char const   * volatile  charset_aliases___0  ;
#line 122 "/home/khheo/project/benchmark/grep-2.18/lib/localcharset.c"
static char const   *get_charset_aliases___0(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 127
  cp = (char const   *)charset_aliases___0;
#line 128
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 132
    base = "charset.alias";
#line 137
    tmp = getenv("CHARSETALIASDIR");
#line 137
    dir = (char const   *)tmp;
    }
#line 138
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 139
      dir = "/usr/local/lib";
    } else
#line 138
    if ((int const   )*(dir + 0) == 0) {
#line 139
      dir = "/usr/local/lib";
    }
    {
#line 143
    tmp___0 = strlen(dir);
#line 143
    dir_len___0 = tmp___0;
#line 144
    tmp___1 = strlen(base);
#line 144
    base_len___0 = tmp___1;
    }
#line 145
    if (dir_len___0 > 0UL) {
#line 145
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 145
        tmp___2 = 1;
      } else {
#line 145
        tmp___2 = 0;
      }
    } else {
#line 145
      tmp___2 = 0;
    }
    {
#line 145
    add_slash = tmp___2;
#line 146
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 146
    file_name___1 = (char *)tmp___3;
    }
#line 147
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 149
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 150
      if (add_slash) {
#line 151
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 152
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 156
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 158
      cp = "";
    } else {
      {
#line 170
      fd = open((char const   *)file_name___1, 131072);
      }
#line 172
      if (fd < 0) {
#line 174
        cp = "";
      } else {
        {
#line 179
        fp = fdopen(fd, "r");
        }
#line 180
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 183
          close(fd);
#line 184
          cp = "";
          }
        } else {
#line 189
          res_ptr = (char *)((void *)0);
#line 190
          res_size = (size_t )0;
          {
#line 192
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 200
            c = getc_unlocked(fp);
            }
#line 201
            if (c == -1) {
#line 202
              goto while_break;
            }
#line 203
            if (c == 10) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 32) {
#line 204
              goto __Cont;
            } else
#line 203
            if (c == 9) {
#line 204
              goto __Cont;
            }
#line 205
            if (c == 35) {
              {
#line 208
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 209
                c = getc_unlocked(fp);
                }
#line 208
                if (c == -1) {
#line 208
                  goto while_break___0;
                } else
#line 208
                if (c == 10) {
#line 208
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 211
              if (c == -1) {
#line 212
                goto while_break;
              }
#line 213
              goto __Cont;
            }
            {
#line 215
            ungetc(c, fp);
#line 216
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 216
            if (tmp___4 < 2) {
#line 217
              goto while_break;
            }
            {
#line 218
            l1 = strlen((char const   *)(buf1));
#line 219
            l2 = strlen((char const   *)(buf2));
#line 220
            old_res_ptr = res_ptr;
            }
#line 221
            if (res_size == 0UL) {
              {
#line 223
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 224
              tmp___5 = malloc(res_size + 1UL);
#line 224
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 228
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 229
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 229
              res_ptr = (char *)tmp___6;
              }
            }
#line 231
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 234
              res_size = (size_t )0;
#line 235
              free((void *)old_res_ptr);
              }
#line 236
              goto while_break;
            }
            {
#line 238
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 239
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 241
          fclose(fp);
          }
#line 242
          if (res_size == 0UL) {
#line 243
            cp = "";
          } else {
#line 246
            *(res_ptr + res_size) = (char )'\000';
#line 247
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 252
      free((void *)file_name___1);
      }
    }
#line 346
    charset_aliases___0 = (char const   */* volatile  */)cp;
  }
#line 349
  return (cp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_tuning  const  default_tuning___0  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 248 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_entry *safe_hasher___0(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 443
static _Bool is_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool is_prime___0(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t next_prime___0(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime___0(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 485 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t raw_hasher___0(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool raw_comparator___0(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool check_tuning___0(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning___0)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning___0;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size___0(size_t candidate ,
                                                                 Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime___0(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 750 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static struct hash_entry *allocate_entry___0(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static void free_entry___0(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static void *hash_find_entry___0(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                                 _Bool delete___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher___0((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___0) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry___0(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___0) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry___0(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-2.18/lib/hash.c"
static _Bool transfer_entries___0(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry___0(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry___0(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-2.18/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) ;
#line 204
static FTSENT *fts_build___0(FTS *sp , int type ) ;
#line 205
static void fts_lfree___0(FTSENT *head ) ;
#line 206
static void fts_load___0(FTS *sp , FTSENT *p ) ;
#line 207
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) ;
#line 208
static void fts_padjust___0(FTS *sp , FTSENT *head ) ;
#line 209
static _Bool fts_palloc___0(FTS *sp , size_t more ) ;
#line 210
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 211
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 212
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool AD_compare___0(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static size_t AD_hash___0(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool setup_dir___0(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash___0, & AD_compare___0, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static _Bool enter_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static void leave_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-2.18/lib/fts-cycle.c"
static void free_dir___0(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 268 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fd_ring_clear___0(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 271
    if (tmp___0) {
#line 271
      goto while_break;
    }
    {
#line 273
    tmp = i_ring_pop(fd_ring);
#line 273
    fd = tmp;
    }
#line 274
    if (0 <= fd) {
      {
#line 275
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 282 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_set_stat_required___0(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )p->fts_info == 11)) {
      {
#line 285
      abort();
      }
    }
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (required) {
#line 286
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 286
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 289
  return;
}
}
#line 293 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static DIR *opendirat___0(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 297
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 297
  new_fd = tmp;
  }
#line 302
  if (new_fd < 0) {
#line 303
    return ((DIR *)((void *)0));
  }
  {
#line 304
  set_cloexec_flag(new_fd, (_Bool)1);
#line 305
  dirp = fdopendir(new_fd);
  }
#line 306
  if (dirp) {
#line 307
    *pdir_fd = new_fd;
  } else {
    {
#line 310
    tmp___0 = __errno_location();
#line 310
    saved_errno = *tmp___0;
#line 311
    close(new_fd);
#line 312
    tmp___1 = __errno_location();
#line 312
    *tmp___1 = saved_errno;
    }
  }
#line 314
  return (dirp);
}
}
#line 322 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void cwd_advance_fd___0(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 326
  old = sp->fts_cwd_fd;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (old != fd)) {
#line 327
      if (! (old == -100)) {
        {
#line 327
        abort();
        }
      }
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (chdir_down_one) {
    {
#line 333
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 333
    prev_fd_in_slot = tmp;
    }
#line 335
    if (0 <= prev_fd_in_slot) {
      {
#line 336
      close(prev_fd_in_slot);
      }
    }
  } else
#line 338
  if (! (sp->fts_options & 4)) {
#line 340
    if (0 <= old) {
      {
#line 341
      close(old);
      }
    }
  }
#line 344
  sp->fts_cwd_fd = fd;
#line 345
  return;
}
}
#line 351 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int restore_initial_cwd___0(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 354
  if (! (sp->fts_options & 4)) {
#line 354
    if (sp->fts_options & 512) {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp = -100;
      } else {
#line 354
        tmp = sp->fts_rfd;
      }
      {
#line 354
      cwd_advance_fd___0(sp, tmp, (_Bool)1);
#line 354
      tmp___2 = 0;
      }
    } else {
#line 354
      if (sp->fts_options & 512) {
#line 354
        tmp___0 = -100;
      } else {
#line 354
        tmp___0 = sp->fts_rfd;
      }
      {
#line 354
      tmp___1 = fchdir(tmp___0);
#line 354
      tmp___2 = tmp___1;
      }
    }
#line 354
    if (tmp___2) {
#line 354
      tmp___3 = 1;
    } else {
#line 354
      tmp___3 = 0;
    }
  } else {
#line 354
    tmp___3 = 0;
  }
  {
#line 354
  fail = tmp___3;
#line 355
  fd_ring_clear___0(& sp->fts_fd_ring);
  }
#line 356
  return (fail);
}
}
#line 363 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int diropen___0(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 367
  if (sp->fts_options & 16) {
#line 367
    tmp = 131072;
  } else {
#line 367
    tmp = 0;
  }
#line 367
  if (sp->fts_options & 2048) {
#line 367
    tmp___0 = 262144;
  } else {
#line 367
    tmp___0 = 0;
  }
#line 367
  open_flags = (67840 | tmp) | tmp___0;
#line 371
  if (sp->fts_options & 512) {
    {
#line 371
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 371
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 371
    tmp___2 = open_safer(dir, open_flags);
#line 371
    tmp___3 = tmp___2;
    }
  }
#line 371
  fd = tmp___3;
#line 374
  if (0 <= fd) {
    {
#line 375
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 376
  return (fd);
}
}
#line 569 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_load___0(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 583
  tmp = p->fts_namelen;
#line 583
  p->fts_pathlen = tmp;
#line 583
  len = tmp;
#line 584
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 585
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 585
  if (cp) {
#line 585
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    } else
#line 585
    if (*(cp + 1)) {
      {
#line 586
      cp ++;
#line 586
      len = strlen((char const   *)cp);
#line 587
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 588
      p->fts_namelen = len;
      }
    }
  }
#line 590
  tmp___0 = sp->fts_path;
#line 590
  p->fts_path = tmp___0;
#line 590
  p->fts_accpath = tmp___0;
#line 591
  return;
}
}
#line 672 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 683
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 683
  if (tmp != 0) {
#line 684
    return ((_Bool)1);
  }
  {
#line 691
  if (fs_buf.f_type == 26985L) {
#line 691
    goto case_26985;
  }
#line 691
  if (fs_buf.f_type == 16914836L) {
#line 691
    goto case_26985;
  }
#line 696
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 694
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 697
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 704 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool leaf_optimization_applies___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 710
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 710
  if (tmp != 0) {
#line 711
    return ((_Bool)0);
  }
  {
#line 720
  if (fs_buf.f_type == 1382369651L) {
#line 720
    goto case_1382369651;
  }
#line 729
  goto switch_default;
  case_1382369651: /* CIL Label */ 
#line 721
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 730
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 754 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static size_t LCO_hash___0(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 757
  ax = (struct LCO_ent  const  *)x;
#line 758
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 761 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool LCO_compare___0(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 764
  ax = (struct LCO_ent  const  *)x;
#line 765
  ay = (struct LCO_ent  const  *)y;
#line 766
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 772 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool link_count_optimize_ok___0(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 775
  sp = (FTS *)p->fts_fts;
#line 776
  h = sp->fts_leaf_optimization_works_ht;
#line 784
  if (! (sp->fts_options & 512)) {
#line 785
    return ((_Bool)0);
  }
#line 788
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 790
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash___0,
                              & LCO_compare___0, (void (*)(void * ))(& free));
#line 790
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 790
    h = tmp___0;
    }
#line 793
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 794
      return ((_Bool)0);
    }
  }
  {
#line 796
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 797
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 797
  ent = (struct LCO_ent *)tmp___1;
  }
#line 798
  if (ent) {
#line 799
    return (ent->opt_ok);
  }
  {
#line 802
  tmp___2 = malloc(sizeof(*t2));
#line 802
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 803
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 804
    return ((_Bool)0);
  }
  {
#line 807
  opt_ok = leaf_optimization_applies___0(sp->fts_cwd_fd);
#line 808
  t2->opt_ok = opt_ok;
#line 809
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 811
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 811
  ent = (struct LCO_ent *)tmp___3;
  }
#line 812
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 815
    free((void *)t2);
    }
#line 816
    return ((_Bool)0);
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 818
      abort();
      }
    }
#line 818
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (opt_ok);
}
}
#line 1202 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_compare_ino___0(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1205
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1205
    tmp___0 = -1;
  } else {
#line 1205
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1205
      tmp = 1;
    } else {
#line 1205
      tmp = 0;
    }
#line 1205
    tmp___0 = tmp;
  }
#line 1205
  return (tmp___0);
}
}
#line 1211 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void set_stat_type___0(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1217
  if (dtype == 6U) {
#line 1217
    goto case_6;
  }
#line 1220
  if (dtype == 2U) {
#line 1220
    goto case_2;
  }
#line 1223
  if (dtype == 4U) {
#line 1223
    goto case_4;
  }
#line 1226
  if (dtype == 1U) {
#line 1226
    goto case_1;
  }
#line 1229
  if (dtype == 10U) {
#line 1229
    goto case_10;
  }
#line 1232
  if (dtype == 8U) {
#line 1232
    goto case_8;
  }
#line 1235
  if (dtype == 12U) {
#line 1235
    goto case_12;
  }
#line 1238
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1218
  type = (mode_t )24576;
#line 1219
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1221
  type = (mode_t )8192;
#line 1222
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1224
  type = (mode_t )16384;
#line 1225
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1227
  type = (mode_t )4096;
#line 1228
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1230
  type = (mode_t )40960;
#line 1231
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1233
  type = (mode_t )32768;
#line 1234
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1236
  type = (mode_t )49152;
#line 1237
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1239
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1241
  st->st_mode = type;
#line 1242
  return;
}
}
#line 1277 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_build___0(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  _Bool skip_stat ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  _Bool tmp___27 ;

  {
#line 1294
  cur = sp->fts_cur;
#line 1295
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1300
  if (continue_readdir) {
    {
#line 1302
    dp = cur->fts_dirp;
#line 1303
    dir_fd = dirfd(dp);
    }
#line 1304
    if (dir_fd < 0) {
      {
#line 1306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1306
        closedir(cur->fts_dirp);
#line 1306
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1306
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1307
      if (type == 3) {
        {
#line 1309
        cur->fts_info = (unsigned short)4;
#line 1310
        tmp = __errno_location();
#line 1310
        cur->fts_errno = *tmp;
        }
      }
#line 1312
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1319
    if (sp->fts_options & 16) {
#line 1319
      if (sp->fts_options & 1) {
#line 1319
        if (cur->fts_level == 0L) {
#line 1319
          tmp___2 = 0;
        } else {
#line 1319
          tmp___2 = 131072;
        }
      } else {
#line 1319
        tmp___2 = 131072;
      }
    } else {
#line 1319
      tmp___2 = 0;
    }
#line 1319
    if (sp->fts_options & 2048) {
#line 1319
      tmp___3 = 262144;
    } else {
#line 1319
      tmp___3 = 0;
    }
#line 1319
    if (! (sp->fts_options & 4)) {
#line 1319
      if (sp->fts_options & 512) {
#line 1319
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1319
        tmp___4 = -100;
      }
    } else {
#line 1319
      tmp___4 = -100;
    }
    {
#line 1319
    tmp___1 = opendirat___0(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                            & dir_fd);
#line 1319
    cur->fts_dirp = tmp___1;
    }
#line 1319
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1321
      if (type == 3) {
        {
#line 1323
        cur->fts_info = (unsigned short)4;
#line 1324
        tmp___0 = __errno_location();
#line 1324
        cur->fts_errno = *tmp___0;
        }
      }
#line 1326
      return ((FTSENT *)((void *)0));
    }
#line 1331
    if ((int )cur->fts_info == 11) {
      {
#line 1332
      cur->fts_info = fts_stat___0(sp, cur, (_Bool)0);
      }
    } else
#line 1333
    if (sp->fts_options & 256) {
      {
#line 1340
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1340
        leave_dir___0(sp, cur);
        }
#line 1340
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1341
      fts_stat___0(sp, cur, (_Bool)0);
#line 1342
      tmp___6 = enter_dir___0(sp, cur);
      }
#line 1342
      if (! tmp___6) {
        {
#line 1344
        tmp___5 = __errno_location();
#line 1344
        *tmp___5 = 12;
        }
#line 1345
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1357
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1357
    tmp___7 = 100000UL;
  } else {
#line 1357
    tmp___7 = 0xffffffffffffffffUL;
  }
#line 1357
  max_entries = tmp___7;
#line 1365
  if (type == 2) {
#line 1366
    nlinks = (nlink_t )0;
#line 1368
    nostat = (_Bool)0;
  } else
#line 1369
  if (sp->fts_options & 8) {
#line 1369
    if (sp->fts_options & 16) {
#line 1370
      if (sp->fts_options & 32) {
#line 1370
        tmp___8 = 0;
      } else {
#line 1370
        tmp___8 = 2;
      }
#line 1370
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
#line 1372
      nostat = (_Bool)1;
    } else {
#line 1374
      nlinks = (nlink_t )-1;
#line 1375
      nostat = (_Bool)0;
    }
  } else {
#line 1374
    nlinks = (nlink_t )-1;
#line 1375
    nostat = (_Bool)0;
  }
#line 1393
  if (continue_readdir) {
#line 1397
    descend = (_Bool)1;
  } else
#line 1399
  if (nlinks) {
#line 1399
    goto _L___0;
  } else
#line 1399
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1400
    if (sp->fts_options & 512) {
      {
#line 1402
      dir_fd = dup_safer(dir_fd);
      }
#line 1403
      if (0 <= dir_fd) {
        {
#line 1404
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1406
    if (dir_fd < 0) {
#line 1406
      goto _L;
    } else {
      {
#line 1406
      tmp___10 = fts_safe_changedir___0(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1406
      if (tmp___10) {
        _L: /* CIL Label */ 
#line 1407
        if (nlinks) {
#line 1407
          if (type == 3) {
            {
#line 1408
            tmp___9 = __errno_location();
#line 1408
            cur->fts_errno = *tmp___9;
            }
          }
        }
#line 1409
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1410
        descend = (_Bool)0;
        {
#line 1411
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1411
          closedir(cur->fts_dirp);
#line 1411
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1411
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1412
        if (sp->fts_options & 512) {
#line 1412
          if (0 <= dir_fd) {
            {
#line 1413
            close(dir_fd);
            }
          }
        }
#line 1414
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1416
        descend = (_Bool)1;
      }
    }
  } else {
#line 1418
    descend = (_Bool)0;
  }
#line 1430
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1430
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1430
    len = cur->fts_pathlen;
  }
#line 1431
  if (sp->fts_options & 4) {
#line 1432
    cp = sp->fts_path + len;
#line 1433
    tmp___11 = cp;
#line 1433
    cp ++;
#line 1433
    *tmp___11 = (char )'/';
  } else {
#line 1436
    cp = (char *)((void *)0);
  }
#line 1438
  len ++;
#line 1439
  maxlen = sp->fts_pathlen - len;
#line 1441
  level = cur->fts_level + 1L;
#line 1444
  doadjust = (_Bool)0;
#line 1445
  head = (FTSENT *)((void *)0);
#line 1446
  tail = (FTSENT *)((void *)0);
#line 1447
  nitems = (size_t )0;
  {
#line 1448
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1448
    if (! cur->fts_dirp) {
#line 1448
      goto while_break___2;
    }
    {
#line 1450
    tmp___12 = readdir(cur->fts_dirp);
#line 1450
    dp___0 = tmp___12;
    }
#line 1451
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
#line 1452
      goto while_break___2;
    }
#line 1453
    if (! (sp->fts_options & 32)) {
#line 1453
      if ((int )dp___0->d_name[0] == 46) {
#line 1453
        if (! dp___0->d_name[1]) {
#line 1454
          goto while_continue___2;
        } else
#line 1453
        if ((int )dp___0->d_name[1] == 46) {
#line 1453
          if (! dp___0->d_name[2]) {
#line 1454
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1456
    tmp___13 = strlen((char const   *)(dp___0->d_name));
#line 1456
    p = fts_alloc___0(sp, (char const   *)(dp___0->d_name), tmp___13);
    }
#line 1456
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1458
      goto mem1;
    }
    {
#line 1459
    tmp___18 = strlen((char const   *)(dp___0->d_name));
    }
#line 1459
    if (tmp___18 >= maxlen) {
      {
#line 1461
      oldaddr = (void *)sp->fts_path;
#line 1462
      tmp___16 = strlen((char const   *)(dp___0->d_name));
#line 1462
      tmp___17 = fts_palloc___0(sp, (tmp___16 + len) + 1UL);
      }
#line 1462
      if (! tmp___17) {
        mem1: 
        {
#line 1468
        tmp___14 = __errno_location();
#line 1468
        saved_errno = *tmp___14;
#line 1469
        free((void *)p);
#line 1470
        fts_lfree___0(head);
        }
        {
#line 1471
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1471
          closedir(cur->fts_dirp);
#line 1471
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1471
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1472
        cur->fts_info = (unsigned short)7;
#line 1473
        sp->fts_options |= 16384;
#line 1474
        tmp___15 = __errno_location();
#line 1474
        *tmp___15 = saved_errno;
        }
#line 1475
        return ((FTSENT *)((void *)0));
      }
#line 1478
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1479
        doadjust = (_Bool)1;
#line 1480
        if (sp->fts_options & 4) {
#line 1481
          cp = sp->fts_path + len;
        }
      }
#line 1483
      maxlen = sp->fts_pathlen - len;
    }
    {
#line 1486
    tmp___19 = strlen((char const   *)(dp___0->d_name));
#line 1486
    new_len = len + tmp___19;
    }
#line 1487
    if (new_len < len) {
      {
#line 1494
      free((void *)p);
#line 1495
      fts_lfree___0(head);
      }
      {
#line 1496
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1496
        closedir(cur->fts_dirp);
#line 1496
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1496
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1497
      cur->fts_info = (unsigned short)7;
#line 1498
      sp->fts_options |= 16384;
#line 1499
      tmp___20 = __errno_location();
#line 1499
      *tmp___20 = 36;
      }
#line 1500
      return ((FTSENT *)((void *)0));
    }
#line 1502
    p->fts_level = level;
#line 1503
    p->fts_parent = sp->fts_cur;
#line 1504
    p->fts_pathlen = new_len;
#line 1508
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1511
    if (sp->fts_options & 4) {
      {
#line 1512
      p->fts_accpath = p->fts_path;
#line 1513
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1515
      p->fts_accpath = p->fts_name;
    }
#line 1517
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1517
      goto _L___1;
    } else
#line 1517
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1530
      if (sp->fts_options & 16) {
#line 1530
        if (sp->fts_options & 8) {
#line 1530
          if ((int )dp___0->d_type != 0) {
#line 1530
            if (! ((int )dp___0->d_type == 4)) {
#line 1530
              tmp___21 = 1;
            } else {
#line 1530
              tmp___21 = 0;
            }
          } else {
#line 1530
            tmp___21 = 0;
          }
        } else {
#line 1530
          tmp___21 = 0;
        }
      } else {
#line 1530
        tmp___21 = 0;
      }
      {
#line 1530
      skip_stat = (_Bool )tmp___21;
#line 1534
      p->fts_info = (unsigned short)11;
#line 1537
      set_stat_type___0(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1538
      fts_set_stat_required___0(p, (_Bool )(! skip_stat));
      }
#line 1539
      if (sp->fts_options & 16) {
#line 1539
        if ((int )dp___0->d_type == 4) {
#line 1539
          tmp___22 = 1;
        } else {
#line 1539
          tmp___22 = 0;
        }
      } else {
#line 1539
        tmp___22 = 0;
      }
#line 1539
      is_dir = (_Bool )tmp___22;
    } else {
      {
#line 1542
      p->fts_info = fts_stat___0(sp, p, (_Bool)0);
      }
#line 1543
      if ((int )p->fts_info == 1) {
#line 1543
        tmp___23 = 1;
      } else
#line 1543
      if ((int )p->fts_info == 2) {
#line 1543
        tmp___23 = 1;
      } else
#line 1543
      if ((int )p->fts_info == 5) {
#line 1543
        tmp___23 = 1;
      } else {
#line 1543
        tmp___23 = 0;
      }
#line 1543
      is_dir = (_Bool )tmp___23;
    }
#line 1549
    if (nlinks > 0UL) {
#line 1549
      if (is_dir) {
#line 1550
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1553
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1554
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1555
      tail = p;
#line 1555
      head = tail;
    } else {
#line 1557
      tail->fts_link = p;
#line 1558
      tail = p;
    }
#line 1560
    nitems ++;
#line 1561
    if (max_entries <= nitems) {
#line 1565
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1569
  if (cur->fts_dirp) {
    {
#line 1570
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1570
      closedir(cur->fts_dirp);
#line 1570
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1570
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1578
  if (doadjust) {
    {
#line 1579
    fts_padjust___0(sp, head);
    }
  }
#line 1585
  if (sp->fts_options & 4) {
#line 1586
    if (len == sp->fts_pathlen) {
#line 1587
      cp --;
    } else
#line 1586
    if (nitems == 0UL) {
#line 1587
      cp --;
    }
#line 1588
    *cp = (char )'\000';
  }
#line 1598
  if (! continue_readdir) {
#line 1598
    if (descend) {
#line 1598
      if (type == 1) {
#line 1598
        goto _L___2;
      } else
#line 1598
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1598
        if (cur->fts_level == 0L) {
          {
#line 1598
          tmp___24 = restore_initial_cwd___0(sp);
#line 1598
          tmp___26 = tmp___24;
          }
        } else {
          {
#line 1598
          tmp___25 = fts_safe_changedir___0(sp, cur->fts_parent, -1, "..");
#line 1598
          tmp___26 = tmp___25;
          }
        }
#line 1598
        if (tmp___26) {
          {
#line 1602
          cur->fts_info = (unsigned short)7;
#line 1603
          sp->fts_options |= 16384;
#line 1604
          fts_lfree___0(head);
          }
#line 1605
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1609
  if (! nitems) {
#line 1610
    if (type == 3) {
#line 1611
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1612
    fts_lfree___0(head);
    }
#line 1613
    return ((FTSENT *)((void *)0));
  }
#line 1620
  if (nitems > 10000UL) {
#line 1620
    if (! sp->fts_compar) {
#line 1620
      if (sp->fts_options & 512) {
        {
#line 1620
        tmp___27 = dirent_inode_sort_may_be_useful___0(sp->fts_cwd_fd);
        }
#line 1620
        if (tmp___27) {
          {
#line 1624
          sp->fts_compar = & fts_compare_ino___0;
#line 1625
          head = fts_sort___0(sp, head, nitems);
#line 1626
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1630
  if (sp->fts_compar) {
#line 1630
    if (nitems > 1UL) {
      {
#line 1631
      head = fts_sort___0(sp, head, nitems);
      }
    }
  }
#line 1632
  return (head);
}
}
#line 1779 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1783
  sbp = p->fts_statp;
#line 1786
  if (p->fts_level == 0L) {
#line 1786
    if (sp->fts_options & 1) {
#line 1787
      follow = (_Bool)1;
    }
  }
#line 1794
  if (sp->fts_options & 2) {
#line 1794
    goto _L;
  } else
#line 1794
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1795
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1795
    if (tmp___3) {
      {
#line 1796
      tmp = __errno_location();
#line 1796
      saved_errno = *tmp;
#line 1797
      tmp___1 = __errno_location();
      }
#line 1797
      if (*tmp___1 == 2) {
        {
#line 1797
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1797
        if (tmp___2 == 0) {
          {
#line 1799
          tmp___0 = __errno_location();
#line 1799
          *tmp___0 = 0;
          }
#line 1800
          return ((unsigned short)13);
        }
      }
#line 1802
      p->fts_errno = saved_errno;
#line 1803
      goto err;
    }
  } else {
    {
#line 1805
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1805
    if (tmp___5) {
      {
#line 1807
      tmp___4 = __errno_location();
#line 1807
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1808
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1809
      return ((unsigned short)10);
    }
  }
#line 1812
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1813
    if (sp->fts_options & 32) {
#line 1813
      tmp___6 = 0;
    } else {
#line 1813
      tmp___6 = 2;
    }
#line 1813
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1815
    if ((int )p->fts_name[0] == 46) {
#line 1815
      if (! p->fts_name[1]) {
#line 1815
        goto _L___0;
      } else
#line 1815
      if ((int )p->fts_name[1] == 46) {
#line 1815
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1817
          if (p->fts_level == 0L) {
#line 1817
            tmp___7 = 1;
          } else {
#line 1817
            tmp___7 = 5;
          }
#line 1817
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1820
    return ((unsigned short)1);
  }
#line 1822
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1823
    return ((unsigned short)12);
  }
#line 1824
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1825
    return ((unsigned short)8);
  }
#line 1826
  return ((unsigned short)3);
}
}
#line 1829 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_compar___0(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1837
  pa = (FTSENT const   **)a;
#line 1838
  pb = (FTSENT const   **)b;
#line 1839
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1839
  return (tmp);
}
}
#line 1842 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1856
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1856
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1856
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1856
      tmp = & fts_compar___0;
    }
  } else {
#line 1856
    tmp = & fts_compar___0;
  }
#line 1856
  compare = tmp;
#line 1869
  if (nitems > sp->fts_nitems) {
#line 1872
    sp->fts_nitems = nitems + 40UL;
#line 1873
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1876
      free((void *)sp->fts_array);
#line 1877
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1878
      sp->fts_nitems = (size_t )0;
      }
#line 1879
      return (head);
    } else {
      {
#line 1873
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1873
      a = (FTSENT **)tmp___0;
      }
#line 1873
      if (! a) {
        {
#line 1876
        free((void *)sp->fts_array);
#line 1877
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1878
        sp->fts_nitems = (size_t )0;
        }
#line 1879
        return (head);
      }
    }
#line 1881
    sp->fts_array = a;
  }
#line 1883
  ap = sp->fts_array;
#line 1883
  p = head;
  {
#line 1883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1883
    if (! p) {
#line 1883
      goto while_break;
    }
#line 1884
    tmp___1 = ap;
#line 1884
    ap ++;
#line 1884
    *tmp___1 = p;
#line 1883
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1885
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1886
  ap = sp->fts_array;
#line 1886
  head = *ap;
  }
  {
#line 1886
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1886
    nitems --;
#line 1886
    if (! nitems) {
#line 1886
      goto while_break___0;
    }
#line 1887
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1886
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1888
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1889
  return (head);
}
}
#line 1892 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1903
  len = sizeof(FTSENT ) + namelen;
#line 1904
  tmp = malloc(len);
#line 1904
  p = (FTSENT *)tmp;
  }
#line 1904
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1905
    return ((FTSENT *)((void *)0));
  }
  {
#line 1908
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1909
  p->fts_name[namelen] = (char )'\000';
#line 1911
  p->fts_namelen = namelen;
#line 1912
  p->fts_fts = sp;
#line 1913
  p->fts_path = sp->fts_path;
#line 1914
  p->fts_errno = 0;
#line 1915
  p->fts_dirp = (DIR *)((void *)0);
#line 1916
  p->fts_flags = (unsigned short)0;
#line 1917
  p->fts_instr = (unsigned short)3;
#line 1918
  p->fts_number = 0L;
#line 1919
  p->fts_pointer = (void *)0;
  }
#line 1920
  return (p);
}
}
#line 1923 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_lfree___0(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    p = head;
#line 1930
    if (! p) {
#line 1930
      goto while_break;
    }
#line 1931
    head = head->fts_link;
#line 1932
    if (p->fts_dirp) {
      {
#line 1933
      closedir(p->fts_dirp);
      }
    }
    {
#line 1934
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1936
  return;
}
}
#line 1945 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static _Bool fts_palloc___0(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1950
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1955
  if (new_len < sp->fts_pathlen) {
    {
#line 1956
    free((void *)sp->fts_path);
#line 1957
    sp->fts_path = (char *)((void *)0);
#line 1958
    tmp = __errno_location();
#line 1958
    *tmp = 36;
    }
#line 1959
    return ((_Bool)0);
  }
  {
#line 1961
  sp->fts_pathlen = new_len;
#line 1962
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1962
  p = (char *)tmp___0;
  }
#line 1963
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1964
    free((void *)sp->fts_path);
#line 1965
    sp->fts_path = (char *)((void *)0);
    }
#line 1966
    return ((_Bool)0);
  }
#line 1968
  sp->fts_path = p;
#line 1969
  return ((_Bool)1);
}
}
#line 1976 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static void fts_padjust___0(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 1981
  addr = sp->fts_path;
#line 1991
  p = sp->fts_child;
  {
#line 1991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1991
    if (! p) {
#line 1991
      goto while_break;
    }
    {
#line 1992
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1992
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1992
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1992
      p->fts_path = addr;
#line 1992
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1991
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1995
  p = head;
  {
#line 1995
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1995
    if (! (p->fts_level >= 0L)) {
#line 1995
      goto while_break___1;
    }
    {
#line 1996
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1996
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1996
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1996
      p->fts_path = addr;
#line 1996
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1997
    if (p->fts_link) {
#line 1997
      p = p->fts_link;
    } else {
#line 1997
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1999
  return;
}
}
#line 2001 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2007
  max = (size_t )0;
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    if (! *argv) {
#line 2007
      goto while_break;
    }
    {
#line 2008
    len = strlen((char const   *)*argv);
    }
#line 2008
    if (len > max) {
#line 2009
      max = len;
    }
#line 2007
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2022 "/home/khheo/project/benchmark/grep-2.18/lib/fts.c"
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2027
  if (dir) {
    {
#line 2027
    tmp = strcmp(dir, "..");
    }
#line 2027
    if (tmp == 0) {
#line 2027
      tmp___0 = 1;
    } else {
#line 2027
      tmp___0 = 0;
    }
  } else {
#line 2027
    tmp___0 = 0;
  }
#line 2027
  is_dotdot = (_Bool )tmp___0;
#line 2034
  if (sp->fts_options & 4) {
#line 2036
    if (sp->fts_options & 512) {
#line 2036
      if (0 <= fd) {
        {
#line 2037
        close(fd);
        }
      }
    }
#line 2038
    return (0);
  }
#line 2041
  if (fd < 0) {
#line 2041
    if (is_dotdot) {
#line 2041
      if (sp->fts_options & 512) {
        {
#line 2048
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2048
        if (! tmp___1) {
          {
#line 2052
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2053
          is_dotdot = (_Bool)1;
          }
#line 2054
          if (0 <= parent_fd) {
#line 2056
            fd = parent_fd;
#line 2057
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2062
  newfd = fd;
#line 2063
  if (fd < 0) {
    {
#line 2063
    newfd = diropen___0((FTS const   *)sp, dir);
    }
#line 2063
    if (newfd < 0) {
#line 2064
      return (-1);
    }
  }
#line 2073
  if (sp->fts_options & 2) {
#line 2073
    goto _L;
  } else
#line 2073
  if (dir) {
    {
#line 2073
    tmp___4 = strcmp(dir, "..");
    }
#line 2073
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2077
      tmp___2 = fstat(newfd, & sb);
      }
#line 2077
      if (tmp___2) {
#line 2079
        ret = -1;
#line 2080
        goto bail;
      }
#line 2082
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2085
        tmp___3 = __errno_location();
#line 2085
        *tmp___3 = 2;
#line 2086
        ret = -1;
        }
#line 2087
        goto bail;
      } else
#line 2082
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2085
        tmp___3 = __errno_location();
#line 2085
        *tmp___3 = 2;
#line 2086
        ret = -1;
        }
#line 2087
        goto bail;
      }
    }
  }
#line 2091
  if (sp->fts_options & 512) {
    {
#line 2093
    cwd_advance_fd___0(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2094
    return (0);
  }
  {
#line 2097
  ret = fchdir(newfd);
  }
  bail: 
#line 2099
  if (fd < 0) {
    {
#line 2101
    tmp___5 = __errno_location();
#line 2101
    oerrno = *tmp___5;
#line 2102
    close(newfd);
#line 2103
    tmp___6 = __errno_location();
#line 2103
    *tmp___6 = oerrno;
    }
  }
#line 2105
  return (ret);
}
}
#line 37 "/home/khheo/project/benchmark/grep-2.18/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix___0(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 232 "/home/khheo/project/benchmark/grep-2.18/lib/fcntl.c"
static int have_dupfd_cloexec___0  =    0;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-2.18/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-2.18/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-2.18/lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 141 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void unescape_pattern___0(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 144
  q = (char const   *)str;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if ((int const   )*q == 92) {
#line 146
      if (*(q + 1)) {
#line 146
        tmp = 1;
      } else {
#line 146
        tmp = 0;
      }
    } else {
#line 146
      tmp = 0;
    }
#line 146
    q += tmp;
#line 145
    tmp___0 = str;
#line 145
    str ++;
#line 145
    tmp___2 = q;
#line 145
    q ++;
#line 145
    tmp___1 = (char )*tmp___2;
#line 145
    *tmp___0 = tmp___1;
#line 145
    if (! tmp___1) {
#line 145
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 159 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static size_t string_hasher___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 162
  p = (char const   *)data;
#line 163
  tmp = hash_string(p, n_buckets);
  }
#line 163
  return (tmp);
}
}
#line 167 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static size_t string_hasher_ci___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 170
  p = (char const   *)data;
#line 172
  value = (size_t )0;
#line 174
  iter.cur.ptr = p;
#line 174
  iter.in_shift = (_Bool)0;
#line 174
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 174
  iter.next_done = (_Bool)0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    mbuiter_multi_next(& iter);
    }
#line 174
    if (iter.cur.wc_valid) {
#line 174
      if (iter.cur.wc == 0) {
#line 174
        tmp___0 = 0;
      } else {
#line 174
        tmp___0 = 1;
      }
    } else {
#line 174
      tmp___0 = 1;
    }
#line 174
    if (! tmp___0) {
#line 174
      goto while_break;
    }
#line 176
    m = iter.cur;
#line 179
    if (m.wc_valid) {
      {
#line 180
      tmp = towlower((wint_t )m.wc);
#line 180
      wc = (wchar_t )tmp;
      }
    } else {
#line 182
      wc = (wchar_t )*(m.ptr);
    }
#line 184
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 174
    iter.cur.ptr += iter.cur.bytes;
#line 174
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (value);
}
}
#line 191 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool string_compare___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 194
  p1 = (char const   *)data1;
#line 195
  p2 = (char const   *)data2;
#line 196
  tmp = strcmp(p1, p2);
  }
#line 196
  return ((_Bool )(tmp == 0));
}
}
#line 200 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool string_compare_ci___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 203
  p1 = (char const   *)data1;
#line 204
  p2 = (char const   *)data2;
#line 205
  tmp = mbscasecmp(p1, p2);
  }
#line 205
  return ((_Bool )(tmp == 0));
}
}
#line 208 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void string_free___0(void *data ) 
{ 


  {
  {
#line 211
  free(data);
  }
#line 212
  return;
}
}
#line 216 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void new_exclude_segment___0(struct exclude *ex , enum exclude_type type ,
                                    int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 219
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 219
  sp = (struct exclude_segment *)tmp;
#line 220
  sp->type = type;
#line 221
  sp->options = options;
  }
  {
#line 224
  if ((unsigned int )type == 1U) {
#line 224
    goto case_1;
  }
#line 227
  if ((unsigned int )type == 0U) {
#line 227
    goto case_0;
  }
#line 222
  goto switch_break;
  case_1: /* CIL Label */ 
#line 225
  goto switch_break;
  case_0: /* CIL Label */ 
#line 228
  if (options & (1 << 4)) {
#line 228
    tmp___0 = & string_compare_ci___0;
  } else {
#line 228
    tmp___0 = & string_compare___0;
  }
#line 228
  if (options & (1 << 4)) {
#line 228
    tmp___1 = & string_hasher_ci___0;
  } else {
#line 228
    tmp___1 = & string_hasher___0;
  }
  {
#line 228
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free___0);
  }
#line 236
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  sp->next = ex->head;
#line 239
  ex->head = sp;
#line 240
  return;
}
}
#line 243 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static void free_exclude_segment___0(struct exclude_segment *seg ) 
{ 


  {
  {
#line 248
  if ((unsigned int )seg->type == 1U) {
#line 248
    goto case_1;
  }
#line 252
  if ((unsigned int )seg->type == 0U) {
#line 252
    goto case_0;
  }
#line 246
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 249
  free((void *)seg->v.pat.exclude);
  }
#line 250
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 253
  hash_free(seg->v.table);
  }
#line 254
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 256
  free((void *)seg);
  }
#line 257
  return;
}
}
#line 276 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static int fnmatch_no_wildcards___0(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 279
  if (! (options & (1 << 3))) {
#line 280
    if (options & (1 << 4)) {
      {
#line 280
      tmp = mbscasecmp(pattern, f);
#line 280
      tmp___1 = tmp;
      }
    } else {
      {
#line 280
      tmp___0 = strcmp(pattern, f);
#line 280
      tmp___1 = tmp___0;
      }
    }
#line 280
    return (tmp___1);
  } else
#line 283
  if (! (options & (1 << 4))) {
    {
#line 285
    tmp___2 = strlen(pattern);
#line 285
    patlen = tmp___2;
#line 286
    tmp___3 = strncmp(pattern, f, patlen);
#line 286
    r = tmp___3;
    }
#line 287
    if (! r) {
#line 289
      r = (int )*(f + patlen);
#line 290
      if (r == 47) {
#line 291
        r = 0;
      }
    }
#line 293
    return (r);
  } else {
    {
#line 304
    tmp___4 = xstrdup(f);
#line 304
    fcopy = tmp___4;
#line 307
    p = fcopy;
    }
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 309
      p = strchr((char const   *)p, '/');
      }
#line 310
      if (p) {
#line 311
        *p = (char )'\000';
      }
      {
#line 312
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 313
      if (! p) {
#line 314
        goto while_break;
      } else
#line 313
      if (r___0 <= 0) {
#line 314
        goto while_break;
      }
#line 307
      tmp___5 = p;
#line 307
      p ++;
#line 307
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 316
    free((void *)fcopy);
    }
#line 317
    return (r___0);
  }
}
}
#line 341 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool file_pattern_matches___0(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 344
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 345
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 348
  i = (size_t )0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i < exclude_count)) {
#line 348
      goto while_break;
    }
    {
#line 350
    pattern = (char const   *)(exclude + i)->pattern;
#line 351
    options = (int )(exclude + i)->options;
#line 352
    tmp = exclude_fnmatch(pattern, f, options);
    }
#line 352
    if (tmp) {
#line 353
      return ((_Bool)1);
    }
#line 348
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return ((_Bool)0);
}
}
#line 361 "/home/khheo/project/benchmark/grep-2.18/lib/exclude.c"
static _Bool file_name_matches___0(struct exclude_segment  const  *seg , char const   *f ,
                                   char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 365
  options = (int )seg->options;
#line 366
  table = (Hash_table *)seg->v.table;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 375
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 375
      if (tmp) {
#line 376
        return ((_Bool)1);
      }
#line 377
      if (options & (1 << 3)) {
        {
#line 379
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 379
        p = tmp___0;
        }
#line 380
        if (p) {
#line 382
          *p = (char)0;
#line 383
          goto while_continue___0;
        }
      }
#line 386
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    if (! (options & (1 << 30))) {
      {
#line 391
      tmp___1 = strchr(f, '/');
#line 391
      f = (char const   *)tmp___1;
      }
#line 392
      if (f) {
#line 393
        f ++;
      }
    } else {
#line 396
      goto while_break;
    }
#line 368
    if (! f) {
#line 368
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((_Bool)0);
}
}
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two___0(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 22 "/home/khheo/project/benchmark/grep-2.18/lib/colorize.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
static char const   *file_name___0  ;
#line 46 "/home/khheo/project/benchmark/grep-2.18/lib/closeout.c"
static _Bool ignore_EPIPE___0  ;
#line 123 "./unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 123
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 45 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static void cdb_init___0(struct cd_buf *cdb ) 
{ 


  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static int cdb_fchdir___0(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = fchdir((int )cdb->fd);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static void cdb_free___0(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
    {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
    }
#line 63
    if (! (! close_fail)) {
      {
#line 63
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c",
                    63U, "cdb_free");
      }
    }
  }
#line 65
  return;
}
}
#line 71 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static int cdb_advance_fd___0(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = tmp;
  }
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
  {
#line 79
  cdb_free___0((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
  }
#line 82
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/grep-2.18/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash___0(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 89
  tmp = strspn(s, "/");
#line 89
  n_slash = tmp;
  }
#line 90
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 29 "/home/khheo/project/benchmark/grep-2.18/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-2.18/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 60 "/home/khheo/project/benchmark/grep-2.18/lib/argmatch.c"
static void __argmatch_die___0(void) 
{ 


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 301 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 307
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrlen)(char const   * __restrict  __s ,
                                                                                size_t __n ,
                                                                                mbstate_t * __restrict  __ps ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 61 "/home/khheo/project/benchmark/grep-2.18/src/system.h"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 64
  return ((unsigned char )ch);
}
}
#line 42 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
int match_icase ;
#line 40 "/home/khheo/project/benchmark/grep-2.18/src/kwset.h"
kwset_t kwsalloc(char const   *trans___0 ) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 46 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
void kwsinit(kwset_t *kwset___1 ) ;
#line 48
char *mbtolower(char const   *beg , size_t *n , mb_len_map_t **len_map_p ) ;
#line 49
void build_mbclen_cache(void) ;
#line 50
_Bool is_mb_middle(char const   **good , char const   *buf , char const   *end , size_t match_len ) ;
#line 103 "/home/khheo/project/benchmark/grep-2.18/src/dfa.h"
int using_utf8(void) ;
#line 29 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
static size_t mbclen_cache[256]  ;
#line 34 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
static char trans[256]  ;
#line 31 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
void kwsinit(kwset_t *kwset___1 ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 37
  if (match_icase) {
    {
#line 37
    tmp___0 = __ctype_get_mb_cur_max();
    }
#line 37
    if (tmp___0 == 1UL) {
#line 39
      i = 0;
      {
#line 39
      while (1) {
        while_continue: /* CIL Label */ ;
#line 39
        if (! (i < 256)) {
#line 39
          goto while_break;
        }
        {
#line 40
        tmp = tolower(i);
#line 40
        trans[i] = (char )tmp;
#line 39
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 42
      *kwset___1 = kwsalloc((char const   *)(trans));
      }
    } else {
      {
#line 45
      *kwset___1 = kwsalloc((char const   *)((void *)0));
      }
    }
  } else {
    {
#line 45
    *kwset___1 = kwsalloc((char const   *)((void *)0));
    }
  }
#line 47
  if (! *kwset___1) {
    {
#line 48
    xalloc_die();
    }
  }
#line 49
  return;
}
}
#line 85 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
static char *out  ;
#line 86 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
static mb_len_map_t *len_map  ;
#line 87 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
static size_t outalloc  ;
#line 82 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
char *mbtolower(char const   *beg , size_t *n , mb_len_map_t **len_map_p ) 
{ 
  size_t outlen ;
  size_t mb_cur_max ;
  mbstate_t is ;
  mbstate_t os ;
  char const   *end ;
  char *p ;
  mb_len_map_t *m ;
  _Bool lengths_differ ;
  void *tmp ;
  void *tmp___0 ;
  wchar_t wc ;
  size_t mbclen ;
  size_t tmp___3 ;
  size_t dm ;
  void *tmp___4 ;
  void *tmp___5 ;
  mb_len_map_t *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  size_t ombclen ;
  wint_t tmp___9 ;

  {
#line 93
  lengths_differ = (_Bool)0;
#line 95
  if (*n > outalloc) {
#line 95
    goto _L;
  } else
#line 95
  if (outalloc == 0UL) {
    _L: /* CIL Label */ 
#line 97
    if (1UL > *n) {
#line 97
      outalloc = (size_t )1;
    } else {
#line 97
      outalloc = *n;
    }
    {
#line 98
    tmp = xrealloc((void *)out, outalloc);
#line 98
    out = (char *)tmp;
#line 99
    tmp___0 = xrealloc((void *)len_map, outalloc);
#line 99
    len_map = (mb_len_map_t *)tmp___0;
    }
  }
#line 103
  if (! out) {
    {
#line 103
    __assert_fail("out", "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c",
                  103U, "mbtolower");
    }
  }
#line 104
  if (! len_map) {
    {
#line 104
    __assert_fail("len_map", "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c",
                  104U, "mbtolower");
    }
  }
#line 105
  if (*n == 0UL) {
#line 106
    return (out);
  }
  {
#line 108
  memset((void *)(& is), 0, sizeof(is));
#line 109
  memset((void *)(& os), 0, sizeof(os));
#line 110
  end = beg + *n;
#line 112
  mb_cur_max = __ctype_get_mb_cur_max();
#line 113
  p = out;
#line 114
  m = len_map;
#line 115
  outlen = (size_t )0;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 116
      goto while_break;
    }
    {
#line 119
    tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)beg,
                      (size_t )(end - beg), (mbstate_t */* __restrict  */)(& is));
#line 119
    mbclen = tmp___3;
    }
#line 151
    if (outlen + mb_cur_max >= outalloc) {
      {
#line 153
      dm = (size_t )(m - len_map);
#line 154
      tmp___4 = x2nrealloc((void *)out, & outalloc, (size_t )1);
#line 154
      out = (char *)tmp___4;
#line 155
      tmp___5 = xrealloc((void *)len_map, outalloc);
#line 155
      len_map = (mb_len_map_t *)tmp___5;
#line 156
      p = out + outlen;
#line 157
      m = len_map + dm;
      }
    }
#line 160
    if (mbclen == 0xffffffffffffffffUL) {
#line 160
      goto _L___0;
    } else
#line 160
    if (mbclen == 0xfffffffffffffffeUL) {
#line 160
      goto _L___0;
    } else
#line 160
    if (mbclen == 0UL) {
      _L___0: /* CIL Label */ 
      {
#line 164
      tmp___6 = m;
#line 164
      m ++;
#line 164
      *tmp___6 = (mb_len_map_t )0;
#line 165
      tmp___7 = p;
#line 165
      p ++;
#line 165
      tmp___8 = beg;
#line 165
      beg ++;
#line 165
      *tmp___7 = (char )*tmp___8;
#line 166
      outlen ++;
#line 167
      memset((void *)(& is), 0, sizeof(is));
#line 168
      memset((void *)(& os), 0, sizeof(os));
      }
    } else {
      {
#line 173
      beg += mbclen;
#line 200
      tmp___9 = towlower((wint_t )wc);
#line 200
      ombclen = wcrtomb((char */* __restrict  */)p, (wchar_t )tmp___9, (mbstate_t */* __restrict  */)(& os));
#line 201
      *m = (mb_len_map_t )(mbclen - ombclen);
#line 202
      memset((void *)(m + 1), 0, ombclen - 1UL);
#line 203
      m += ombclen;
#line 204
      p += ombclen;
#line 205
      outlen += ombclen;
#line 206
      lengths_differ = (_Bool )((int )lengths_differ | (mbclen != ombclen));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (lengths_differ) {
#line 210
    *len_map_p = len_map;
  } else {
#line 210
    *len_map_p = (mb_len_map_t *)((void *)0);
  }
#line 211
  *n = (size_t )(p - out);
#line 212
  *p = (char)0;
#line 213
  return (out);
}
}
#line 217 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
void build_mbclen_cache(void) 
{ 
  int i ;
  char c ;
  unsigned char uc ;
  mbstate_t mbs___0 ;

  {
#line 222
  i = -128;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (i <= 127)) {
#line 222
      goto while_break;
    }
    {
#line 224
    c = (char )i;
#line 225
    uc = (unsigned char )i;
#line 226
    mbs___0.__count = 0;
#line 226
    mbs___0.__value.__wch = 0U;
#line 227
    mbclen_cache[uc] = mbrlen((char const   */* __restrict  */)(& c), (size_t )1,
                              (mbstate_t */* __restrict  */)(& mbs___0));
#line 222
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 231 "/home/khheo/project/benchmark/grep-2.18/src/searchutils.c"
_Bool is_mb_middle(char const   **good , char const   *buf , char const   *end , size_t match_len ) 
{ 
  char const   *p ;
  char const   *prev ;
  mbstate_t cur_state ;
  unsigned char tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t mbclen ;
  unsigned char tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 235
  p = *good;
#line 236
  prev = p;
#line 239
  tmp___2 = using_utf8();
  }
#line 239
  if (tmp___2) {
    {
#line 239
    tmp___3 = __ctype_get_mb_cur_max();
    }
#line 239
    if ((size_t )(buf - p) > tmp___3) {
#line 241
      p = buf;
      {
#line 241
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 241
        tmp___0 = __ctype_get_mb_cur_max();
        }
#line 241
        if (! ((size_t )(buf - p) > tmp___0)) {
#line 241
          goto while_break;
        }
        {
#line 242
        tmp = to_uchar((char )*p);
        }
#line 242
        if (mbclen_cache[tmp] != 0xffffffffffffffffUL) {
#line 243
          goto while_break;
        }
#line 241
        p --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 245
      tmp___1 = __ctype_get_mb_cur_max();
      }
#line 245
      if ((size_t )(buf - p) == tmp___1) {
#line 246
        p = buf;
      }
    }
  }
  {
#line 249
  memset((void *)(& cur_state), 0, sizeof(cur_state));
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )p < (unsigned long )buf)) {
#line 251
      goto while_break___0;
    }
    {
#line 253
    tmp___4 = to_uchar((char )*p);
#line 253
    mbclen = mbclen_cache[tmp___4];
    }
#line 255
    if (mbclen == 0xfffffffffffffffeUL) {
      {
#line 256
      mbclen = mbrlen((char const   */* __restrict  */)p, (size_t )(end - p), (mbstate_t */* __restrict  */)(& cur_state));
      }
    }
#line 259
    if (mbclen != 0xfffffffffffffffeUL) {
#line 260
      prev = p;
    }
#line 262
    if (mbclen == 0xffffffffffffffffUL) {
      {
#line 266
      mbclen = (size_t )1;
#line 267
      memset((void *)(& cur_state), 0, sizeof(cur_state));
      }
    } else
#line 262
    if (mbclen == 0xfffffffffffffffeUL) {
      {
#line 266
      mbclen = (size_t )1;
#line 267
      memset((void *)(& cur_state), 0, sizeof(cur_state));
      }
    } else
#line 262
    if (mbclen == 0UL) {
      {
#line 266
      mbclen = (size_t )1;
#line 267
      memset((void *)(& cur_state), 0, sizeof(cur_state));
      }
    }
#line 269
    p += mbclen;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  *good = prev;
#line 274
  if ((unsigned long )p > (unsigned long )buf) {
#line 275
    return ((_Bool)1);
  }
#line 278
  if (0UL < match_len) {
    {
#line 278
    tmp___5 = mbrlen((char const   */* __restrict  */)p, (size_t )(end - p), (mbstate_t */* __restrict  */)(& cur_state));
    }
#line 278
    if (match_len < tmp___5) {
#line 278
      tmp___6 = 1;
    } else {
#line 278
      tmp___6 = 0;
    }
  } else {
#line 278
    tmp___6 = 0;
  }
#line 278
  return ((_Bool )tmp___6);
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 43 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
int match_words ;
#line 44
int match_lines ;
#line 45
unsigned char eolbyte ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 61 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
void Pcompile(char const   *pattern , size_t size ) ;
#line 62
size_t Pexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 540 "/usr/include/pcre.h"
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 573
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 627
extern unsigned char const   *pcre_maketables(void) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 657
extern pcre_jit_stack *pcre_jit_stack_alloc(int  , int  ) ;
#line 663
extern void pcre_assign_jit_stack(pcre_extra * , pcre_jit_stack *(*)(void * ) , void * ) ;
#line 34 "/home/khheo/project/benchmark/grep-2.18/src/pcresearch.c"
static pcre *cre  ;
#line 37 "/home/khheo/project/benchmark/grep-2.18/src/pcresearch.c"
static pcre_extra *extra  ;
#line 40 "/home/khheo/project/benchmark/grep-2.18/src/pcresearch.c"
static pcre_jit_stack *jit_stack  ;
#line 46 "/home/khheo/project/benchmark/grep-2.18/src/pcresearch.c"
void Pcompile(char const   *pattern , size_t size ) 
{ 
  int e ;
  char const   *ep ;
  char *re ;
  void *tmp ;
  int flags ;
  int tmp___0 ;
  char const   *patlim ;
  char *n ;
  char const   *p ;
  char const   *pnul ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 56
  tmp = xnmalloc((size_t )4, size + 7UL);
#line 56
  re = (char *)tmp;
  }
#line 57
  if (match_icase) {
#line 57
    tmp___0 = 1;
  } else {
#line 57
    tmp___0 = 0;
  }
  {
#line 57
  flags = 2 | tmp___0;
#line 58
  patlim = pattern + size;
#line 59
  n = re;
#line 64
  tmp___1 = nl_langinfo(14);
#line 64
  tmp___2 = strcmp((char const   *)tmp___1, "UTF-8");
  }
#line 64
  if (tmp___2 == 0) {
#line 68
    flags |= 2048;
  }
  {
#line 73
  tmp___4 = memchr((void const   *)pattern, '\n', size);
  }
#line 73
  if (tmp___4) {
    {
#line 74
    tmp___3 = gettext("the -P option only supports a single pattern");
#line 74
    error(2, 0, (char const   *)tmp___3);
    }
  }
#line 76
  *n = (char )'\000';
#line 77
  if (match_lines) {
    {
#line 78
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"^(");
    }
  }
#line 79
  if (match_words) {
    {
#line 80
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\b(");
    }
  }
  {
#line 81
  tmp___5 = strlen((char const   *)n);
#line 81
  n += tmp___5;
#line 91
  p = pattern;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___6 = memchr((void const   *)p, '\000', (size_t )(patlim - p));
#line 91
    pnul = (char const   *)tmp___6;
    }
#line 91
    if (! pnul) {
#line 91
      goto while_break;
    }
    {
#line 93
    memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(pnul - p));
#line 94
    n += pnul - p;
#line 95
    p = pnul;
    }
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if ((unsigned long )pattern < (unsigned long )p) {
#line 95
        if (! ((int const   )*(p + -1) == 92)) {
#line 95
          goto while_break___0;
        }
      } else {
#line 95
        goto while_break___0;
      }
#line 96
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 95
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 97
    n -= (pnul - p) & 1L;
#line 98
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\000");
#line 99
    n += 4;
#line 91
    p = pnul + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(patlim - p));
#line 103
  n += patlim - p;
#line 104
  *n = (char )'\000';
  }
#line 105
  if (match_words) {
    {
#line 106
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")\\b");
    }
  }
#line 107
  if (match_lines) {
    {
#line 108
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")$");
    }
  }
  {
#line 110
  tmp___7 = pcre_maketables();
#line 110
  cre = pcre_compile((char const   *)re, flags, & ep, & e, tmp___7);
  }
#line 111
  if (! cre) {
    {
#line 112
    error(2, 0, "%s", ep);
    }
  }
  {
#line 114
  extra = pcre_study((pcre const   *)cre, 1, & ep);
  }
#line 115
  if (ep) {
    {
#line 116
    error(2, 0, "%s", ep);
    }
  }
  {
#line 119
  tmp___9 = pcre_fullinfo((pcre const   *)cre, (pcre_extra const   *)extra, 16, (void *)(& e));
  }
#line 119
  if (tmp___9) {
    {
#line 120
    tmp___8 = gettext("internal error (should never happen)");
#line 120
    error(2, 0, (char const   *)tmp___8);
    }
  }
#line 122
  if (e) {
    {
#line 127
    jit_stack = pcre_jit_stack_alloc(32768, 524288);
    }
#line 128
    if (! jit_stack) {
      {
#line 129
      tmp___10 = gettext("failed to allocate memory for the PCRE JIT stack");
#line 129
      error(2, 0, (char const   *)tmp___10);
      }
    }
    {
#line 131
    pcre_assign_jit_stack(extra, (pcre_jit_stack *(*)(void * ))((void *)0), (void *)jit_stack);
    }
  }
  {
#line 134
  free((void *)re);
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/benchmark/grep-2.18/src/pcresearch.c"
size_t Pexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) 
{ 
  int sub[300] ;
  char const   *line_buf ;
  char const   *line_end ;
  char const   *line_next ;
  int e ;
  ptrdiff_t start_ofs ;
  long tmp ;
  int options ;
  void *tmp___0 ;
  char *tmp___1 ;
  ptrdiff_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *beg ;
  char const   *end ;
  char const   *buflim___0 ;
  char eol ;
  void *tmp___7 ;

  {
#line 152
  e = -1;
#line 153
  if (start_ptr) {
#line 153
    tmp = start_ptr - buf;
  } else {
#line 153
    tmp = 0L;
  }
#line 153
  start_ofs = tmp;
#line 157
  line_next = buf;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (e == -1) {
#line 157
      if (! ((unsigned long )line_next < (unsigned long )(buf + size))) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
    {
#line 163
    options = 8192;
#line 165
    line_buf = line_next;
#line 166
    tmp___0 = memchr((void const   *)line_buf, (int )eolbyte, (size_t )((buf + size) - line_buf));
#line 166
    line_end = (char const   *)tmp___0;
    }
#line 167
    if ((unsigned long )line_end == (unsigned long )((void *)0)) {
#line 168
      line_end = buf + size;
#line 168
      line_next = line_end;
    } else {
#line 170
      line_next = line_end + 1;
    }
#line 172
    if (start_ptr) {
#line 172
      if ((unsigned long )start_ptr >= (unsigned long )line_end) {
#line 173
        goto __Cont;
      }
    }
#line 175
    if (2147483647L < line_end - line_buf) {
      {
#line 176
      tmp___1 = gettext("exceeded PCRE\'s line length limit");
#line 176
      error(2, 0, (char const   *)tmp___1);
      }
    }
#line 178
    if (start_ofs < 0L) {
#line 178
      tmp___2 = (ptrdiff_t )0;
    } else {
#line 178
      tmp___2 = start_ofs;
    }
    {
#line 178
    e = pcre_exec((pcre const   *)cre, (pcre_extra const   *)extra, line_buf, (int )(line_end - line_buf),
                  (int )tmp___2, options, sub, (int )(sizeof(sub) / sizeof(sub[0])));
    }
    __Cont: /* CIL Label */ 
#line 157
    start_ofs -= line_next - line_buf;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (e <= 0) {
    {
#line 187
    if (e == -1) {
#line 187
      goto case_neg_1;
    }
#line 190
    if (e == -6) {
#line 190
      goto case_neg_6;
    }
#line 193
    if (e == -8) {
#line 193
      goto case_neg_8;
    }
#line 197
    if (e == -10) {
#line 197
      goto case_neg_10;
    }
#line 201
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 188
    return ((size_t )-1);
    case_neg_6: /* CIL Label */ 
    {
#line 191
    tmp___3 = gettext("memory exhausted");
#line 191
    error(2, 0, (char const   *)tmp___3);
    }
    case_neg_8: /* CIL Label */ 
    {
#line 194
    tmp___4 = gettext("exceeded PCRE\'s backtracking limit");
#line 194
    error(2, 0, (char const   *)tmp___4);
    }
    case_neg_10: /* CIL Label */ 
    {
#line 198
    tmp___5 = gettext("invalid UTF-8 byte sequence in input");
#line 198
    error(2, 0, (char const   *)tmp___5);
    }
    switch_default: /* CIL Label */ 
    {
#line 206
    tmp___6 = gettext("internal PCRE error: %d");
#line 206
    error(2, 0, (char const   *)tmp___6, e);
    }
    switch_break: /* CIL Label */ ;
    }
#line 210
    return ((size_t )-1);
  } else {
#line 215
    beg = line_buf + sub[0];
#line 216
    end = line_buf + sub[1];
#line 217
    buflim___0 = buf + size;
#line 218
    eol = (char )eolbyte;
#line 219
    if (! start_ptr) {
      {
#line 225
      tmp___7 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
#line 225
      end = (char const   *)tmp___7;
      }
#line 225
      if (end) {
#line 228
        end ++;
      } else {
#line 226
        end = buflim___0;
      }
      {
#line 229
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 229
        if ((unsigned long )buf < (unsigned long )beg) {
#line 229
          if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 229
            goto while_break___0;
          }
        } else {
#line 229
          goto while_break___0;
        }
#line 230
        beg --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 233
    *match_size = (size_t )(end - beg);
#line 234
    return ((size_t )(beg - buf));
  }
}
}
#line 592 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 284 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 288
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 213 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 537
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalpha)(wint_t __wc ) ;
#line 135
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswupper)(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 979 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc , char * const  *___argv ,
                                                            char const   *__shortopts ,
                                                            struct option  const  *__longopts ,
                                                            int *__longind ) ;
#line 35 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
struct matcher  const  matchers[8] ;
#line 37
char const   before_options[59] ;
#line 38
char const   after_options[114] ;
#line 42 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
int match_icase  ;
#line 43 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
int match_words  ;
#line 44 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
int match_lines  ;
#line 45 "/home/khheo/project/benchmark/grep-2.18/src/grep.h"
unsigned char eolbyte  ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 66 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static struct stat out_stat  ;
#line 69 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int show_help  ;
#line 72 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int show_version  ;
#line 75 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int suppress_errors  ;
#line 78 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int color_option  ;
#line 81 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int only_matching  ;
#line 84 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int align_tabs  ;
#line 87 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *group_separator  =    "--";
#line 134 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *selected_match_color  =    "01;31";
#line 135 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *context_match_color  =    "01;31";
#line 138 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *filename_color  =    "35";
#line 139 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *line_num_color  =    "32";
#line 140 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *byte_num_color  =    "32";
#line 141 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *sep_color  =    "36";
#line 142 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *selected_line_color  =    "";
#line 143 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *context_line_color  =    "";
#line 202 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *sgr_start  =    "\033[%sm\033[K";
#line 203 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *sgr_end  =    "\033[m\033[K";
#line 206 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void pr_sgr_start(char const   *s ) 
{ 


  {
#line 209
  if (*s) {
    {
#line 210
    print_start_colorize(sgr_start, s);
    }
  }
#line 211
  return;
}
}
#line 212 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void pr_sgr_end(char const   *s ) 
{ 


  {
#line 215
  if (*s) {
    {
#line 216
    print_end_colorize(sgr_end);
    }
  }
#line 217
  return;
}
}
#line 218 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void pr_sgr_start_if(char const   *s ) 
{ 


  {
#line 221
  if (color_option) {
    {
#line 222
    pr_sgr_start(s);
    }
  }
#line 223
  return;
}
}
#line 224 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void pr_sgr_end_if(char const   *s ) 
{ 


  {
#line 227
  if (color_option) {
    {
#line 228
    pr_sgr_end(s);
    }
  }
#line 229
  return;
}
}
#line 238 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void color_cap_mt_fct(void) 
{ 


  {
#line 242
  context_match_color = selected_match_color;
#line 243
  return;
}
}
#line 245 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void color_cap_rv_fct(void) 
{ 


  {
#line 249
  color_option = -1;
#line 250
  return;
}
}
#line 252 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void color_cap_ne_fct(void) 
{ 


  {
#line 255
  sgr_start = "\033[%sm";
#line 256
  sgr_end = "\033[m";
#line 257
  return;
}
}
#line 260 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static struct color_cap  const  color_dict[12]  = 
#line 260
  {      {"mt", & selected_match_color, & color_cap_mt_fct}, 
        {"ms", & selected_match_color, (void (*)(void))((void *)0)}, 
        {"mc", & context_match_color, (void (*)(void))((void *)0)}, 
        {"fn", & filename_color, (void (*)(void))((void *)0)}, 
        {"ln", & line_num_color, (void (*)(void))((void *)0)}, 
        {"bn", & byte_num_color, (void (*)(void))((void *)0)}, 
        {"se", & sep_color, (void (*)(void))((void *)0)}, 
        {"sl", & selected_line_color, (void (*)(void))((void *)0)}, 
        {"cx", & context_line_color, (void (*)(void))((void *)0)}, 
        {"rv", (char const   **)((void *)0), & color_cap_rv_fct}, 
        {"ne", (char const   **)((void *)0), & color_cap_ne_fct}, 
        {(char const   *)((void *)0), (char const   **)((void *)0), (void (*)(void))((void *)0)}};
#line 276 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static struct exclude *excluded_patterns  ;
#line 277 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static struct exclude *excluded_directory_patterns  ;
#line 279 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   short_options[58]  = 
#line 279
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':', 
        (char const   )'D',      (char const   )':',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'P', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'X', 
        (char const   )':',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )':',      (char const   )'e',      (char const   )':', 
        (char const   )'f',      (char const   )':',      (char const   )'h',      (char const   )'i', 
        (char const   )'L',      (char const   )'l',      (char const   )'m',      (char const   )':', 
        (char const   )'n',      (char const   )'o',      (char const   )'q',      (char const   )'R', 
        (char const   )'r',      (char const   )'s',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'Z', 
        (char const   )'z',      (char const   )'\000'};
#line 297 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static struct option  const  long_options[50]  = 
#line 297
  {      {"basic-regexp", 0, (int *)((void *)0), 'G'}, 
        {"extended-regexp", 0, (int *)((void *)0), 'E'}, 
        {"fixed-regexp", 0, (int *)((void *)0), 'F'}, 
        {"fixed-strings", 0, (int *)((void *)0), 'F'}, 
        {"perl-regexp", 0, (int *)((void *)0), 'P'}, 
        {"after-context", 1, (int *)((void *)0), 'A'}, 
        {"before-context", 1, (int *)((void *)0), 'B'}, 
        {"binary-files", 1, (int *)((void *)0), 128}, 
        {"byte-offset", 0, (int *)((void *)0), 'b'}, 
        {"context", 1, (int *)((void *)0), 'C'}, 
        {"color", 2, (int *)((void *)0), 129}, 
        {"colour", 2, (int *)((void *)0), 129}, 
        {"count", 0, (int *)((void *)0), 'c'}, 
        {"devices", 1, (int *)((void *)0), 'D'}, 
        {"directories", 1, (int *)((void *)0), 'd'}, 
        {"exclude", 1, (int *)((void *)0), 131}, 
        {"exclude-from", 1, (int *)((void *)0), 132}, 
        {"exclude-dir", 1, (int *)((void *)0), 135}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-with-matches", 0, (int *)((void *)0), 'l'}, 
        {"files-without-match", 0, (int *)((void *)0), 'L'}, 
        {"group-separator", 1, (int *)((void *)0), 136}, 
        {"help", 0, & show_help, 1}, 
        {"include", 1, (int *)((void *)0), 130}, 
        {"ignore-case", 0, (int *)((void *)0), 'i'}, 
        {"initial-tab", 0, (int *)((void *)0), 'T'}, 
        {"label", 1, (int *)((void *)0), 134}, 
        {"line-buffered", 0, (int *)((void *)0), 133}, 
        {"line-number", 0, (int *)((void *)0), 'n'}, 
        {"line-regexp", 0, (int *)((void *)0), 'x'}, 
        {"max-count", 1, (int *)((void *)0), 'm'}, 
        {"no-filename", 0, (int *)((void *)0), 'h'}, 
        {"no-group-separator", 0, (int *)((void *)0), 136}, 
        {"no-messages", 0, (int *)((void *)0), 's'}, 
        {"null", 0, (int *)((void *)0), 'Z'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"only-matching", 0, (int *)((void *)0), 'o'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"dereference-recursive", 0, (int *)((void *)0), 'R'}, 
        {"regexp", 1, (int *)((void *)0), 'e'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"silent", 0, (int *)((void *)0), 'q'}, 
        {"text", 0, (int *)((void *)0), 'a'}, 
        {"binary", 0, (int *)((void *)0), 'U'}, 
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"with-filename", 0, (int *)((void *)0), 'H'}, 
        {"word-regexp", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 360 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *filename  ;
#line 361 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t filename_prefix_len  ;
#line 362 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int errseen  ;
#line 363 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int write_error_seen  ;
#line 373 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   * const  directories_args[4]  = {      (char const   */* const  */)"read",      (char const   */* const  */)"recurse",      (char const   */* const  */)"skip",      (char const   */* const  */)((void *)0)};
#line 377 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static enum directories_type  const  directories_types[3]  = {      (enum directories_type  const  )2,      (enum directories_type  const  )3,      (enum directories_type  const  )4};
#line 383 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static enum directories_type directories  =    (enum directories_type )2;
#line 386 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int fts_options  =    793;
#line 389 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static enum __anonenum_devices_473526324 devices  =    (enum __anonenum_devices_473526324 )0;
#line 396
static int grepfile(int dirdesc , char const   *name , int follow , int command_line ) ;
#line 397
static int grepdesc(int desc , int command_line ) ;
#line 402 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int is_device_mode(mode_t m ) 
{ 
  int tmp ;

  {
#line 405
  if ((m & 61440U) == 8192U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 24576U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 49152U) {
#line 405
    tmp = 1;
  } else
#line 405
  if ((m & 61440U) == 4096U) {
#line 405
    tmp = 1;
  } else {
#line 405
    tmp = 0;
  }
#line 405
  return (tmp);
}
}
#line 410 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int usable_st_size(struct stat  const  *st ) 
{ 
  int tmp ;

  {
#line 413
  if ((st->st_mode & 61440U) == 32768U) {
#line 413
    tmp = 1;
  } else
#line 413
  if (st->st_mode - st->st_mode) {
#line 413
    tmp = 1;
  } else {
#line 413
    tmp = 0;
  }
#line 413
  return (tmp);
}
}
#line 417 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void (*compile)(char const   * , size_t  )  ;
#line 418 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t (*execute)(char const   * , size_t  , size_t * , char const   * )  ;
#line 421 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void suppressible_error(char const   *mesg , int errnum ) 
{ 


  {
#line 424
  if (! suppress_errors) {
    {
#line 425
    error(0, errnum, "%s", mesg);
    }
  }
#line 426
  errseen = 1;
#line 427
  return;
}
}
#line 431 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void clean_up_stdout(void) 
{ 


  {
#line 434
  if (! write_error_seen) {
    {
#line 435
    close_stdout();
    }
  }
#line 436
  return;
}
}
#line 441 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int file_is_binary(char const   *buf , size_t bufsize , int fd , struct stat  const  *st ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  off_t cur ;
  off_t hole_start ;
  __off_t tmp___1 ;
  int *tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;

  {
#line 450
  if (! eolbyte) {
    {
#line 451
    tmp = memchr((void const   *)buf, '\200', bufsize);
    }
#line 451
    return ((unsigned long )tmp != (unsigned long )((void *)0));
  }
  {
#line 455
  tmp___0 = memchr((void const   *)buf, '\000', bufsize);
  }
#line 455
  if (tmp___0) {
#line 456
    return (1);
  }
  {
#line 459
  tmp___4 = usable_st_size(st);
  }
#line 459
  if (tmp___4) {
#line 461
    cur = (off_t )bufsize;
#line 462
    if (fd == 0) {
      {
#line 464
      cur = lseek(fd, (__off_t )0, 1);
      }
#line 465
      if (cur < 0L) {
#line 466
        return (0);
      }
    }
    {
#line 470
    tmp___1 = lseek(fd, cur, 4);
#line 470
    hole_start = tmp___1;
    }
#line 471
    if (0L <= hole_start) {
      {
#line 473
      tmp___3 = lseek(fd, cur, 0);
      }
#line 473
      if (tmp___3 < 0L) {
        {
#line 474
        tmp___2 = __errno_location();
#line 474
        suppressible_error(filename, *tmp___2);
        }
      }
#line 475
      if (hole_start < (off_t )st->st_size) {
#line 476
        return (1);
      }
    }
  }
#line 481
  return (0);
}
}
#line 488 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void context_length_arg(char const   *str , intmax_t *out___0 ) 
{ 
  strtol_error tmp ;
  char *tmp___0 ;

  {
  {
#line 491
  tmp = xstrtoimax(str, (char **)0, 10, out___0, "");
  }
  {
#line 494
  if ((unsigned int )tmp == 1U) {
#line 494
    goto case_1;
  }
#line 494
  if ((unsigned int )tmp == 0U) {
#line 494
    goto case_1;
  }
#line 498
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 495
  if (0L <= *out___0) {
#line 496
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 499
  tmp___0 = gettext("invalid context length argument");
#line 499
  error(2, 0, "%s: %s", str, tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 507 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int skipped_file(char const   *name , int command_line , int is_dir ) 
{ 
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 510
  if (is_dir) {
#line 510
    if ((unsigned int )directories == 4U) {
#line 510
      tmp___0 = 1;
    } else
#line 510
    if (command_line) {
#line 510
      if (filename_prefix_len != 0UL) {
#line 510
        tmp___0 = 0;
      } else {
#line 510
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 510
    if (excluded_directory_patterns) {
      {
#line 510
      tmp = excluded_file_name((struct exclude  const  *)excluded_directory_patterns,
                               name);
      }
#line 510
      if (tmp) {
#line 510
        tmp___0 = 1;
      } else {
#line 510
        tmp___0 = 0;
      }
    } else {
#line 510
      tmp___0 = 0;
    }
#line 510
    tmp___3 = tmp___0;
  } else {
#line 510
    if (excluded_patterns) {
      {
#line 510
      tmp___1 = excluded_file_name((struct exclude  const  *)excluded_patterns, name);
      }
#line 510
      if (tmp___1) {
#line 510
        tmp___2 = 1;
      } else {
#line 510
        tmp___2 = 0;
      }
    } else {
#line 510
      tmp___2 = 0;
    }
#line 510
    tmp___3 = tmp___2;
  }
#line 510
  return (tmp___3);
}
}
#line 523 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char *buffer  ;
#line 524 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t bufalloc  ;
#line 526 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int bufdesc  ;
#line 527 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char *bufbeg  ;
#line 528 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char *buflim  ;
#line 529 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t pagesize  ;
#line 530 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static off_t bufoffset  ;
#line 531 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static off_t after_last_match  ;
#line 544 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int reset(int fd , struct stat  const  *st ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 547
  if (! pagesize) {
    {
#line 549
    tmp = getpagesize();
#line 549
    pagesize = (size_t )tmp;
    }
#line 550
    if (pagesize == 0UL) {
      {
#line 551
      abort();
      }
    } else
#line 550
    if (2UL * pagesize + 1UL <= pagesize) {
      {
#line 551
      abort();
      }
    }
#line 552
    if (32768UL % pagesize == 0UL) {
#line 552
      tmp___0 = (size_t )32768;
    } else {
#line 552
      tmp___0 = 32768UL + (pagesize - 32768UL % pagesize);
    }
    {
#line 552
    bufalloc = (tmp___0 + pagesize) + 1UL;
#line 553
    tmp___1 = xmalloc(bufalloc);
#line 553
    buffer = (char *)tmp___1;
    }
  }
#line 556
  if ((size_t )(buffer + 1) % pagesize == 0UL) {
#line 556
    buflim = buffer + 1;
  } else {
#line 556
    buflim = (buffer + 1) + (pagesize - (size_t )(buffer + 1) % pagesize);
  }
#line 556
  bufbeg = buflim;
#line 557
  *(bufbeg + -1) = (char )eolbyte;
#line 558
  bufdesc = fd;
#line 560
  if ((st->st_mode & 61440U) == 32768U) {
#line 562
    if (fd != 0) {
#line 563
      bufoffset = (off_t )0;
    } else {
      {
#line 566
      bufoffset = lseek(fd, (__off_t )0, 1);
      }
#line 567
      if (bufoffset < 0L) {
        {
#line 569
        tmp___2 = __errno_location();
#line 569
        tmp___3 = gettext("lseek failed");
#line 569
        suppressible_error((char const   *)tmp___3, *tmp___2);
        }
#line 570
        return (0);
      }
    }
  }
#line 574
  return (1);
}
}
#line 581 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int fillbuf(size_t save , struct stat  const  *st ) 
{ 
  ssize_t fillsize ;
  int cc ;
  char *readbuf ;
  size_t readsize ;
  size_t saved_offset ;
  size_t minsize ;
  size_t newsize ;
  size_t newalloc ;
  char *newbuf ;
  off_t to_be_read ;
  off_t maxsize_off ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 585
  cc = 1;
#line 591
  saved_offset = (size_t )((buflim - save) - buffer);
#line 593
  if (pagesize <= (size_t )((buffer + bufalloc) - buflim)) {
#line 595
    readbuf = buflim;
#line 596
    bufbeg = buflim - save;
  } else {
#line 600
    minsize = save + pagesize;
#line 606
    newsize = (bufalloc - pagesize) - 1UL;
    {
#line 606
    while (1) {
      while_continue: /* CIL Label */ ;
#line 606
      if (! (newsize < minsize)) {
#line 606
        goto while_break;
      }
#line 607
      if (newsize * 2UL < newsize) {
        {
#line 608
        xalloc_die();
        }
      } else
#line 607
      if ((newsize * 2UL + pagesize) + 1UL < newsize * 2UL) {
        {
#line 608
        xalloc_die();
        }
      }
#line 606
      newsize *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 615
    tmp = usable_st_size(st);
    }
#line 615
    if (tmp) {
#line 617
      to_be_read = (off_t )(st->st_size - (__off_t const   )bufoffset);
#line 618
      maxsize_off = (off_t )(save + (size_t )to_be_read);
#line 619
      if (0L <= to_be_read) {
#line 619
        if (to_be_read <= maxsize_off) {
#line 619
          if ((size_t )maxsize_off == (size_t )maxsize_off) {
#line 619
            if (minsize <= (size_t )maxsize_off) {
#line 619
              if ((size_t )maxsize_off < newsize) {
#line 623
                newsize = (size_t )maxsize_off;
              }
            }
          }
        }
      }
    }
#line 628
    newalloc = (newsize + pagesize) + 1UL;
#line 630
    if (bufalloc < newalloc) {
      {
#line 630
      bufalloc = newalloc;
#line 630
      tmp___0 = xmalloc(bufalloc);
#line 630
      newbuf = (char *)tmp___0;
      }
    } else {
#line 630
      newbuf = buffer;
    }
#line 631
    if ((size_t )((newbuf + 1) + save) % pagesize == 0UL) {
#line 631
      readbuf = (newbuf + 1) + save;
    } else {
#line 631
      readbuf = ((newbuf + 1) + save) + (pagesize - (size_t )((newbuf + 1) + save) % pagesize);
    }
    {
#line 632
    bufbeg = readbuf - save;
#line 633
    memmove((void *)bufbeg, (void const   *)(buffer + saved_offset), save);
#line 634
    *(bufbeg + -1) = (char )eolbyte;
    }
#line 635
    if ((unsigned long )newbuf != (unsigned long )buffer) {
      {
#line 637
      free((void *)buffer);
#line 638
      buffer = newbuf;
      }
    }
  }
  {
#line 642
  readsize = (size_t )((buffer + bufalloc) - readbuf);
#line 643
  readsize -= readsize % pagesize;
#line 645
  tmp___1 = safe_read(bufdesc, (void *)readbuf, readsize);
#line 645
  fillsize = (ssize_t )tmp___1;
  }
#line 646
  if (fillsize < 0L) {
#line 647
    cc = 0;
#line 647
    fillsize = (ssize_t )cc;
  }
#line 648
  bufoffset += fillsize;
#line 653
  buflim = readbuf + fillsize;
#line 654
  return (cc);
}
}
#line 658 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static enum __anonenum_binary_files_601436154 binary_files  ;
#line 665 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int filename_mask  ;
#line 666 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int out_quiet  ;
#line 667 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int out_invert  ;
#line 668 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int out_file  ;
#line 669 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int out_line  ;
#line 670 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int out_byte  ;
#line 671 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t out_before  ;
#line 672 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t out_after  ;
#line 673 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int count_matches  ;
#line 674 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int list_files  ;
#line 675 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int no_filenames  ;
#line 676 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t max_count  ;
#line 678 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int line_buffered  ;
#line 680 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char *label  =    (char *)((void *)0);
#line 684 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static uintmax_t totalcc  ;
#line 685 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *lastnl  ;
#line 686 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *lastout  ;
#line 689 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static uintmax_t totalnl  ;
#line 690 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t outleft  ;
#line 691 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t pending  ;
#line 693 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int done_on_match  ;
#line 694 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int exit_on_match  ;
#line 702 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static uintmax_t add_count(uintmax_t a , uintmax_t b ) 
{ 
  uintmax_t sum ;
  char *tmp ;

  {
#line 705
  sum = a + b;
#line 706
  if (sum < a) {
    {
#line 707
    tmp = gettext("input is too large to count");
#line 707
    error(2, 0, (char const   *)tmp);
    }
  }
#line 708
  return (sum);
}
}
#line 711 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void nlscan(char const   *lim ) 
{ 
  size_t newlines ;
  char const   *beg ;
  void *tmp ;

  {
#line 714
  newlines = (size_t )0;
#line 716
  beg = lastnl;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! ((unsigned long )beg < (unsigned long )lim)) {
#line 716
      goto while_break;
    }
    {
#line 718
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
#line 718
    beg = (char const   *)tmp;
    }
#line 719
    if (! beg) {
#line 720
      goto while_break;
    }
#line 721
    newlines ++;
#line 716
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  totalnl = add_count(totalnl, newlines);
#line 724
  lastnl = lim;
  }
#line 725
  return;
}
}
#line 728 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void print_filename(void) 
{ 


  {
  {
#line 731
  pr_sgr_start_if(filename_color);
#line 732
  fputs_unlocked((char const   */* __restrict  */)filename, (FILE */* __restrict  */)stdout);
#line 733
  pr_sgr_end_if(filename_color);
  }
#line 734
  return;
}
}
#line 737 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void print_sep(char sep ) 
{ 


  {
  {
#line 740
  pr_sgr_start_if(sep_color);
#line 741
  fputc_unlocked((int )sep, stdout);
#line 742
  pr_sgr_end_if(sep_color);
  }
#line 743
  return;
}
}
#line 746 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void print_offset(uintmax_t pos , int min_width , char const   *color ) 
{ 
  char buf[sizeof(pos) * 8UL] ;
  char *p ;

  {
#line 753
  p = buf + sizeof(buf);
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    p --;
#line 757
    *p = (char )(48UL + pos % 10UL);
#line 758
    min_width --;
#line 755
    pos /= 10UL;
#line 755
    if (! (pos != 0UL)) {
#line 755
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  if (align_tabs) {
    {
#line 764
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 764
      min_width --;
#line 764
      if (! (min_width >= 0)) {
#line 764
        goto while_break___0;
      }
#line 765
      p --;
#line 765
      *p = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 767
  pr_sgr_start_if(color);
#line 768
  fwrite_unlocked((void const   */* __restrict  */)p, (size_t )1, (size_t )((buf + sizeof(buf)) - p),
                  (FILE */* __restrict  */)stdout);
#line 769
  pr_sgr_end_if(color);
  }
#line 770
  return;
}
}
#line 773 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void print_line_head(char const   *beg , char const   *lim , int sep ) 
{ 
  int pending_sep ;
  uintmax_t pos ;
  uintmax_t tmp ;

  {
#line 776
  pending_sep = 0;
#line 778
  if (out_file) {
    {
#line 780
    print_filename();
    }
#line 781
    if (filename_mask) {
#line 782
      pending_sep = 1;
    } else {
      {
#line 784
      fputc_unlocked(0, stdout);
      }
    }
  }
#line 787
  if (out_line) {
#line 789
    if ((unsigned long )lastnl < (unsigned long )lim) {
      {
#line 791
      nlscan(beg);
#line 792
      totalnl = add_count(totalnl, (uintmax_t )1);
#line 793
      lastnl = lim;
      }
    }
#line 795
    if (pending_sep) {
      {
#line 796
      print_sep((char )sep);
      }
    }
    {
#line 797
    print_offset(totalnl, 4, line_num_color);
#line 798
    pending_sep = 1;
    }
  }
#line 801
  if (out_byte) {
    {
#line 803
    tmp = add_count(totalcc, (uintmax_t )(beg - (char const   *)bufbeg));
#line 803
    pos = tmp;
    }
#line 807
    if (pending_sep) {
      {
#line 808
      print_sep((char )sep);
      }
    }
    {
#line 809
    print_offset(pos, 6, byte_num_color);
#line 810
    pending_sep = 1;
    }
  }
#line 813
  if (pending_sep) {
#line 819
    if (align_tabs) {
      {
#line 820
      fputs_unlocked((char const   */* __restrict  */)"\t\b", (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 822
    print_sep((char )sep);
    }
  }
#line 824
  return;
}
}
#line 826 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *print_line_middle(char const   *beg , char const   *lim , char const   *line_color ,
                                       char const   *match_color ) 
{ 
  size_t match_size ;
  size_t match_offset ;
  char const   *cur ;
  char const   *mid ;
  char const   *b ;
  int tmp ;

  {
#line 832
  cur = beg;
#line 833
  mid = (char const   *)((void *)0);
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if ((unsigned long )cur < (unsigned long )lim) {
      {
#line 835
      match_offset = (*execute)(beg, (size_t )(lim - beg), & match_size, beg + (cur - beg));
      }
#line 835
      if (! (match_offset != 0xffffffffffffffffUL)) {
#line 835
        goto while_break;
      }
    } else {
#line 835
      goto while_break;
    }
#line 839
    b = beg + match_offset;
#line 842
    if ((unsigned long )b == (unsigned long )lim) {
#line 843
      goto while_break;
    }
#line 846
    if (match_size == 0UL) {
#line 850
      match_size = (size_t )1;
#line 851
      if (! mid) {
#line 852
        mid = cur;
      }
    } else {
#line 858
      if (only_matching) {
#line 859
        if (out_invert) {
#line 859
          tmp = '-';
        } else {
#line 859
          tmp = ':';
        }
        {
#line 859
        print_line_head(b, lim, tmp);
        }
      } else {
        {
#line 863
        pr_sgr_start(line_color);
        }
#line 864
        if (mid) {
#line 866
          cur = mid;
#line 867
          mid = (char const   *)((void *)0);
        }
        {
#line 869
        fwrite_unlocked((void const   */* __restrict  */)cur, sizeof(char ), (size_t )(b - cur),
                        (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 872
      pr_sgr_start_if(match_color);
#line 873
      fwrite_unlocked((void const   */* __restrict  */)b, sizeof(char ), match_size,
                      (FILE */* __restrict  */)stdout);
#line 874
      pr_sgr_end_if(match_color);
      }
#line 875
      if (only_matching) {
        {
#line 876
        fputs_unlocked((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
        }
      }
    }
#line 878
    cur = b + match_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 881
  if (only_matching) {
#line 882
    cur = lim;
  } else
#line 883
  if (mid) {
#line 884
    cur = mid;
  }
#line 886
  return (cur);
}
}
#line 889 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *print_line_tail(char const   *beg , char const   *lim , char const   *line_color ) 
{ 
  size_t eol_size ;
  size_t tail_size ;
  int tmp ;
  int tmp___0 ;

  {
#line 895
  if ((unsigned long )lim > (unsigned long )beg) {
#line 895
    if ((int const   )*(lim + -1) == (int const   )eolbyte) {
#line 895
      tmp = 1;
    } else {
#line 895
      tmp = 0;
    }
  } else {
#line 895
    tmp = 0;
  }
#line 895
  eol_size = (size_t )tmp;
#line 896
  if ((unsigned long )(lim - eol_size) > (unsigned long )beg) {
#line 896
    if ((int const   )*(lim + - (1UL + eol_size)) == 13) {
#line 896
      tmp___0 = 1;
    } else {
#line 896
      tmp___0 = 0;
    }
  } else {
#line 896
    tmp___0 = 0;
  }
#line 896
  eol_size += (size_t )tmp___0;
#line 897
  tail_size = (size_t )((lim - eol_size) - beg);
#line 899
  if (tail_size > 0UL) {
    {
#line 901
    pr_sgr_start(line_color);
#line 902
    fwrite_unlocked((void const   */* __restrict  */)beg, (size_t )1, tail_size, (FILE */* __restrict  */)stdout);
#line 903
    beg += tail_size;
#line 904
    pr_sgr_end(line_color);
    }
  }
#line 907
  return (beg);
}
}
#line 910 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void prline(char const   *beg , char const   *lim , int sep ) 
{ 
  int matching ;
  char const   *line_color ;
  char const   *match_color ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 917
  if (! only_matching) {
    {
#line 918
    print_line_head(beg, lim, sep);
    }
  }
#line 920
  matching = (sep == 58) ^ ! (! out_invert);
#line 922
  if (color_option) {
#line 924
    if (out_invert) {
#line 924
      if (color_option < 0) {
#line 924
        tmp___0 = 1;
      } else {
#line 924
        tmp___0 = 0;
      }
    } else {
#line 924
      tmp___0 = 0;
    }
#line 924
    if ((sep == 58) ^ tmp___0) {
#line 924
      line_color = selected_line_color;
    } else {
#line 924
      line_color = context_line_color;
    }
#line 927
    if (sep == 58) {
#line 927
      match_color = selected_match_color;
    } else {
#line 927
      match_color = context_match_color;
    }
  } else {
#line 931
    match_color = (char const   *)((void *)0);
#line 931
    line_color = match_color;
  }
#line 933
  if (only_matching) {
#line 933
    if (matching) {
#line 933
      goto _L___0;
    } else {
#line 933
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 933
  if (color_option) {
#line 933
    if (*line_color) {
#line 933
      goto _L___0;
    } else
#line 933
    if (*match_color) {
      _L___0: /* CIL Label */ 
#line 937
      if (matching) {
#line 937
        if (only_matching) {
          {
#line 938
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
        } else
#line 937
        if (*match_color) {
          {
#line 938
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
        }
      }
#line 940
      if (! only_matching) {
#line 940
        if (*line_color) {
          {
#line 944
          beg = print_line_tail(beg, lim, line_color);
          }
        }
      }
    }
  }
#line 948
  if (! only_matching) {
#line 948
    if ((unsigned long )lim > (unsigned long )beg) {
      {
#line 949
      fwrite_unlocked((void const   */* __restrict  */)beg, (size_t )1, (size_t )(lim - beg),
                      (FILE */* __restrict  */)stdout);
      }
    }
  }
  {
#line 951
  tmp___2 = ferror_unlocked(stdout);
  }
#line 951
  if (tmp___2) {
    {
#line 953
    write_error_seen = 1;
#line 954
    tmp___1 = gettext("write error");
#line 954
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 957
  lastout = lim;
#line 959
  if (line_buffered) {
    {
#line 960
    fflush_unlocked(stdout);
    }
  }
#line 961
  return;
}
}
#line 965 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void prpending(char const   *lim ) 
{ 
  char const   *nl ;
  void *tmp ;
  size_t match_size ;
  size_t tmp___0 ;

  {
#line 968
  if (! lastout) {
#line 969
    lastout = (char const   *)bufbeg;
  }
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    if (pending > 0L) {
#line 970
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
#line 970
        goto while_break;
      }
    } else {
#line 970
      goto while_break;
    }
    {
#line 972
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - lastout));
#line 972
    nl = (char const   *)tmp;
#line 974
    pending --;
    }
#line 975
    if (outleft) {
      {
#line 979
      prline(lastout, nl + 1, '-');
      }
    } else {
      {
#line 975
      tmp___0 = (*execute)(lastout, (size_t )((nl + 1) - lastout), & match_size, (char const   *)((void *)0));
      }
#line 975
      if ((tmp___0 == 0xffffffffffffffffUL) == ! out_invert) {
        {
#line 979
        prline(lastout, nl + 1, '-');
        }
      } else {
#line 981
        pending = (intmax_t )0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  return;
}
}
#line 990 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int used  ;
#line 987 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void prtext(char const   *beg , char const   *lim , intmax_t *nlinesp ) 
{ 
  char const   *bp ;
  char const   *p ;
  char eol ;
  intmax_t i ;
  intmax_t n ;
  char const   *nl ;
  void *tmp ;
  char const   *nl___0 ;
  void *tmp___0 ;

  {
#line 992
  eol = (char )eolbyte;
#line 995
  if (! out_quiet) {
#line 995
    if (pending > 0L) {
      {
#line 996
      prpending(beg);
      }
    }
  }
#line 998
  p = beg;
#line 1000
  if (! out_quiet) {
#line 1004
    if (lastout) {
#line 1004
      bp = lastout;
    } else {
#line 1004
      bp = (char const   *)bufbeg;
    }
#line 1005
    i = (intmax_t )0;
    {
#line 1005
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1005
      if (! (i < out_before)) {
#line 1005
        goto while_break;
      }
#line 1006
      if ((unsigned long )p > (unsigned long )bp) {
        {
#line 1007
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1008
          p --;
#line 1007
          if (! ((int const   )*(p + -1) != (int const   )eol)) {
#line 1007
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1005
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1013
    if (out_before) {
#line 1013
      goto _L;
    } else
#line 1013
    if (out_after) {
      _L: /* CIL Label */ 
#line 1013
      if (used) {
#line 1013
        if ((unsigned long )p != (unsigned long )lastout) {
#line 1013
          if (group_separator) {
            {
#line 1015
            pr_sgr_start_if(sep_color);
#line 1016
            fputs_unlocked((char const   */* __restrict  */)group_separator, (FILE */* __restrict  */)stdout);
#line 1017
            pr_sgr_end_if(sep_color);
#line 1018
            fputc_unlocked('\n', stdout);
            }
          }
        }
      }
    }
    {
#line 1021
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1021
      if (! ((unsigned long )p < (unsigned long )beg)) {
#line 1021
        goto while_break___1;
      }
      {
#line 1023
      tmp = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
#line 1023
      nl = (char const   *)tmp;
#line 1024
      nl ++;
#line 1025
      prline(p, nl, '-');
#line 1026
      p = nl;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1030
  if (nlinesp) {
#line 1033
    n = (intmax_t )0;
    {
#line 1033
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1033
      if ((unsigned long )p < (unsigned long )lim) {
#line 1033
        if (! (n < outleft)) {
#line 1033
          goto while_break___2;
        }
      } else {
#line 1033
        goto while_break___2;
      }
      {
#line 1035
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
#line 1035
      nl___0 = (char const   *)tmp___0;
#line 1036
      nl___0 ++;
      }
#line 1037
      if (! out_quiet) {
        {
#line 1038
        prline(p, nl___0, ':');
        }
      }
#line 1039
      p = nl___0;
#line 1033
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1041
    *nlinesp = n;
#line 1044
    after_last_match = bufoffset - (buflim - (char *)p);
  } else
#line 1046
  if (! out_quiet) {
    {
#line 1047
    prline(beg, lim, ':');
    }
  }
#line 1049
  if (out_quiet) {
#line 1049
    pending = (intmax_t )0;
  } else {
#line 1049
    pending = out_after;
  }
#line 1050
  used = 1;
#line 1051
  return;
}
}
#line 1056 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t do_execute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) 
{ 
  size_t result ;
  char const   *line_next ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *line_buf ;
  char const   *line_end ;
  void *tmp___1 ;

  {
  {
#line 1075
  tmp___0 = __ctype_get_mb_cur_max();
  }
#line 1075
  if (tmp___0 == 1UL) {
    {
#line 1076
    tmp = (*execute)(buf, size, match_size, start_ptr);
    }
#line 1076
    return (tmp);
  } else
#line 1075
  if (! match_icase) {
    {
#line 1076
    tmp = (*execute)(buf, size, match_size, start_ptr);
    }
#line 1076
    return (tmp);
  }
#line 1078
  line_next = buf;
  {
#line 1078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (! ((unsigned long )line_next < (unsigned long )(buf + size))) {
#line 1078
      goto while_break;
    }
    {
#line 1080
    line_buf = line_next;
#line 1081
    tmp___1 = memchr((void const   *)line_buf, (int )eolbyte, (size_t )((buf + size) - line_buf));
#line 1081
    line_end = (char const   *)tmp___1;
    }
#line 1083
    if ((unsigned long )line_end == (unsigned long )((void *)0)) {
#line 1084
      line_end = buf + size;
#line 1084
      line_next = line_end;
    } else {
#line 1086
      line_next = line_end + 1;
    }
#line 1088
    if (start_ptr) {
#line 1088
      if ((unsigned long )start_ptr >= (unsigned long )line_end) {
#line 1089
        goto __Cont;
      }
    }
    {
#line 1091
    result = (*execute)(line_buf, (size_t )(line_next - line_buf), match_size, start_ptr);
    }
#line 1092
    if (result != 0xffffffffffffffffUL) {
#line 1093
      return ((size_t )(line_buf - buf) + result);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  return ((size_t )-1);
}
}
#line 1102 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t grepbuf(char const   *beg , char const   *lim ) 
{ 
  intmax_t nlines ;
  intmax_t n ;
  char const   *p ;
  size_t match_offset ;
  size_t match_size ;
  char const   *b ;
  char const   *endp ;

  {
#line 1110
  nlines = (intmax_t )0;
#line 1111
  p = beg;
  {
#line 1112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1112
    match_offset = do_execute(p, (size_t )(lim - p), & match_size, (char const   *)((void *)0));
    }
#line 1112
    if (! (match_offset != 0xffffffffffffffffUL)) {
#line 1112
      goto while_break;
    }
#line 1115
    b = p + match_offset;
#line 1116
    endp = b + match_size;
#line 1118
    if ((unsigned long )b == (unsigned long )lim) {
#line 1119
      goto while_break;
    }
#line 1120
    if (! out_invert) {
      {
#line 1122
      prtext(b, endp, (intmax_t *)((void *)0));
#line 1123
      nlines ++;
#line 1124
      outleft --;
      }
#line 1125
      if (! outleft) {
#line 1125
        goto _L;
      } else
#line 1125
      if (done_on_match) {
        _L: /* CIL Label */ 
#line 1127
        if (exit_on_match) {
          {
#line 1128
          exit(0);
          }
        }
#line 1129
        after_last_match = bufoffset - (buflim - (char *)endp);
#line 1130
        return (nlines);
      }
    } else
#line 1133
    if ((unsigned long )p < (unsigned long )b) {
      {
#line 1135
      prtext(p, b, & n);
#line 1136
      nlines += n;
#line 1137
      outleft -= n;
      }
#line 1138
      if (! outleft) {
#line 1139
        return (nlines);
      }
    }
#line 1141
    p = endp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1143
  if (out_invert) {
#line 1143
    if ((unsigned long )p < (unsigned long )lim) {
      {
#line 1145
      prtext(p, lim, & n);
#line 1146
      nlines += n;
#line 1147
      outleft -= n;
      }
    }
  }
#line 1149
  return (nlines);
}
}
#line 1155 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static intmax_t grep(int fd , struct stat  const  *st ) 
{ 
  intmax_t nlines ;
  intmax_t i ;
  int not_text ;
  size_t residue ;
  size_t save ;
  char oldc ;
  char *beg ;
  char *lim ;
  char eol ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  intmax_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  intmax_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1164
  eol = (char )eolbyte;
#line 1166
  tmp = reset(fd, st);
  }
#line 1166
  if (! tmp) {
#line 1167
    return ((intmax_t )0);
  }
  {
#line 1169
  totalcc = (uintmax_t )0;
#line 1170
  lastout = (char const   *)0;
#line 1171
  totalnl = (uintmax_t )0;
#line 1172
  outleft = max_count;
#line 1173
  after_last_match = (off_t )0;
#line 1174
  pending = (intmax_t )0;
#line 1176
  nlines = (intmax_t )0;
#line 1177
  residue = (size_t )0;
#line 1178
  save = (size_t )0;
#line 1180
  tmp___1 = fillbuf(save, st);
  }
#line 1180
  if (! tmp___1) {
    {
#line 1182
    tmp___0 = __errno_location();
#line 1182
    suppressible_error(filename, *tmp___0);
    }
#line 1183
    return ((intmax_t )0);
  }
#line 1186
  if ((unsigned int )binary_files == 0U) {
#line 1186
    if (! out_quiet) {
#line 1186
      goto _L;
    } else {
#line 1186
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1186
  if ((unsigned int )binary_files == 2U) {
    _L: /* CIL Label */ 
    {
#line 1186
    tmp___2 = file_is_binary((char const   *)bufbeg, (size_t )(buflim - bufbeg), fd,
                             st);
    }
#line 1186
    if (tmp___2) {
#line 1186
      tmp___3 = 1;
    } else {
#line 1186
      tmp___3 = 0;
    }
  } else {
#line 1186
    tmp___3 = 0;
  }
#line 1186
  not_text = tmp___3;
#line 1189
  if (not_text) {
#line 1189
    if ((unsigned int )binary_files == 2U) {
#line 1190
      return ((intmax_t )0);
    }
  }
#line 1191
  done_on_match += not_text;
#line 1192
  out_quiet += not_text;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    lastnl = (char const   *)bufbeg;
#line 1197
    if (lastout) {
#line 1198
      lastout = (char const   *)bufbeg;
    }
#line 1200
    beg = bufbeg + save;
#line 1203
    if ((unsigned long )beg == (unsigned long )buflim) {
#line 1204
      goto while_break;
    }
    {
#line 1208
    oldc = *(beg + -1);
#line 1209
    *(beg + -1) = eol;
#line 1212
    tmp___4 = memrchr((void const   *)(beg - 1), (int )eol, (size_t )((buflim - beg) + 1L));
#line 1212
    lim = (char *)tmp___4;
#line 1213
    lim ++;
#line 1214
    *(beg + -1) = oldc;
    }
#line 1215
    if ((unsigned long )lim == (unsigned long )beg) {
#line 1216
      lim = beg - residue;
    }
#line 1217
    beg -= residue;
#line 1218
    residue = (size_t )(buflim - lim);
#line 1220
    if ((unsigned long )beg < (unsigned long )lim) {
#line 1222
      if (outleft) {
        {
#line 1223
        tmp___5 = grepbuf((char const   *)beg, (char const   *)lim);
#line 1223
        nlines += tmp___5;
        }
      }
#line 1224
      if (pending) {
        {
#line 1225
        prpending((char const   *)lim);
        }
      }
#line 1226
      if (! outleft) {
#line 1226
        if (! pending) {
#line 1228
          goto finish_grep;
        } else {
#line 1226
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1226
      if (nlines) {
#line 1226
        if (done_on_match) {
#line 1226
          if (! out_invert) {
#line 1228
            goto finish_grep;
          }
        }
      }
    }
#line 1234
    i = (intmax_t )0;
#line 1235
    beg = lim;
    {
#line 1236
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1236
      if (i < out_before) {
#line 1236
        if ((unsigned long )beg > (unsigned long )bufbeg) {
#line 1236
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
#line 1236
            goto while_break___0;
          }
        } else {
#line 1236
          goto while_break___0;
        }
      } else {
#line 1236
        goto while_break___0;
      }
#line 1238
      i ++;
      {
#line 1239
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1240
        beg --;
#line 1239
        if (! ((int )*(beg + -1) != (int )eol)) {
#line 1239
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1245
    if ((unsigned long )beg != (unsigned long )lastout) {
#line 1246
      lastout = (char const   *)0;
    }
#line 1249
    save = (size_t )((lim + residue) - beg);
#line 1250
    if (out_byte) {
      {
#line 1251
      totalcc = add_count(totalcc, (size_t )(buflim - bufbeg) - save);
      }
    }
#line 1252
    if (out_line) {
      {
#line 1253
      nlscan((char const   *)beg);
      }
    }
    {
#line 1254
    tmp___7 = fillbuf(save, st);
    }
#line 1254
    if (! tmp___7) {
      {
#line 1256
      tmp___6 = __errno_location();
#line 1256
      suppressible_error(filename, *tmp___6);
      }
#line 1257
      goto finish_grep;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1260
  if (residue) {
#line 1262
    tmp___8 = buflim;
#line 1262
    buflim ++;
#line 1262
    *tmp___8 = eol;
#line 1263
    if (outleft) {
      {
#line 1264
      tmp___9 = grepbuf((char const   *)((bufbeg + save) - residue), (char const   *)buflim);
#line 1264
      nlines += tmp___9;
      }
    }
#line 1265
    if (pending) {
      {
#line 1266
      prpending((char const   *)buflim);
      }
    }
  }
  finish_grep: 
#line 1270
  done_on_match -= not_text;
#line 1271
  out_quiet -= not_text;
#line 1272
  if (not_text & ~ out_quiet) {
#line 1272
    if (nlines != 0L) {
      {
#line 1273
      tmp___10 = gettext("Binary file %s matches\n");
#line 1273
      printf((char const   */* __restrict  */)tmp___10, filename);
      }
    }
  }
#line 1274
  return (nlines);
}
}
#line 1277 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int grepdirent(FTS *fts , FTSENT *ent , int command_line ) 
{ 
  int follow ;
  int dirdesc ;
  struct stat *st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat st1 ;
  int flag ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1281
  st = ent->fts_statp;
#line 1282
  command_line &= ent->fts_level == 0L;
#line 1284
  if ((int )ent->fts_info == 6) {
#line 1286
    if ((unsigned int )directories == 3U) {
#line 1286
      if (command_line) {
#line 1287
        out_file &= ~ (2 * ! no_filenames);
      }
    }
#line 1288
    return (1);
  }
#line 1291
  if ((int )ent->fts_info == 1) {
#line 1291
    tmp = 1;
  } else
#line 1291
  if ((int )ent->fts_info == 2) {
#line 1291
    tmp = 1;
  } else
#line 1291
  if ((int )ent->fts_info == 4) {
#line 1291
    tmp = 1;
  } else {
#line 1291
    tmp = 0;
  }
  {
#line 1291
  tmp___0 = skipped_file((char const   *)(ent->fts_name), command_line, tmp);
  }
#line 1291
  if (tmp___0) {
    {
#line 1295
    fts_set(fts, ent, 4);
    }
#line 1296
    return (1);
  }
#line 1299
  filename = (char const   *)(ent->fts_path + filename_prefix_len);
#line 1300
  if (fts->fts_options & 2) {
#line 1300
    tmp___1 = 1;
  } else
#line 1300
  if (fts->fts_options & 1) {
#line 1300
    if (command_line) {
#line 1300
      tmp___1 = 1;
    } else {
#line 1300
      tmp___1 = 0;
    }
  } else {
#line 1300
    tmp___1 = 0;
  }
#line 1300
  follow = tmp___1;
  {
#line 1305
  if ((int )ent->fts_info == 1) {
#line 1305
    goto case_1;
  }
#line 1314
  if ((int )ent->fts_info == 2) {
#line 1314
    goto case_2;
  }
#line 1322
  if ((int )ent->fts_info == 10) {
#line 1322
    goto case_10;
  }
#line 1322
  if ((int )ent->fts_info == 7) {
#line 1322
    goto case_10;
  }
#line 1322
  if ((int )ent->fts_info == 4) {
#line 1322
    goto case_10;
  }
#line 1327
  if ((int )ent->fts_info == 11) {
#line 1327
    goto case_11;
  }
#line 1327
  if ((int )ent->fts_info == 3) {
#line 1327
    goto case_11;
  }
#line 1351
  if ((int )ent->fts_info == 13) {
#line 1351
    goto case_13;
  }
#line 1351
  if ((int )ent->fts_info == 8) {
#line 1351
    goto case_13;
  }
#line 1355
  if ((int )ent->fts_info == 14) {
#line 1355
    goto case_14;
  }
#line 1355
  if ((int )ent->fts_info == 12) {
#line 1355
    goto case_14;
  }
#line 1358
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1306
  if ((unsigned int )directories == 3U) {
#line 1308
    out_file |= 2 * ! no_filenames;
#line 1309
    return (1);
  }
  {
#line 1311
  fts_set(fts, ent, 4);
  }
#line 1312
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1315
  if (! suppress_errors) {
    {
#line 1316
    tmp___2 = gettext("recursive directory loop");
#line 1316
    tmp___3 = gettext("warning: %s: %s");
#line 1316
    error(0, 0, (char const   *)tmp___3, filename, tmp___2);
    }
  }
#line 1318
  return (1);
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1323
  suppressible_error(filename, ent->fts_errno);
  }
#line 1324
  return (1);
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1328
  if ((unsigned int )devices == 2U) {
#line 1328
    goto _L;
  } else
#line 1328
  if ((unsigned int )devices == 0U) {
#line 1328
    if (! command_line) {
      _L: /* CIL Label */ 
#line 1332
      if (! st->st_mode) {
#line 1337
        if (follow) {
#line 1337
          tmp___4 = 0;
        } else {
#line 1337
          tmp___4 = 256;
        }
        {
#line 1337
        flag = tmp___4;
#line 1338
        tmp___6 = fstatat(fts->fts_cwd_fd, (char const   */* __restrict  */)ent->fts_accpath,
                          (struct stat */* __restrict  */)(& st1), flag);
        }
#line 1338
        if (tmp___6 != 0) {
          {
#line 1340
          tmp___5 = __errno_location();
#line 1340
          suppressible_error(filename, *tmp___5);
          }
#line 1341
          return (1);
        }
#line 1343
        st = & st1;
      }
      {
#line 1345
      tmp___7 = is_device_mode(st->st_mode);
      }
#line 1345
      if (tmp___7) {
#line 1346
        return (1);
      }
    }
  }
#line 1348
  goto switch_break;
  case_13: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 1352
  goto switch_break;
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 1356
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 1359
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1362
  if ((fts->fts_options & 516) == 512) {
#line 1362
    dirdesc = fts->fts_cwd_fd;
  } else {
#line 1362
    dirdesc = -100;
  }
  {
#line 1365
  tmp___8 = grepfile(dirdesc, (char const   *)ent->fts_accpath, follow, command_line);
  }
#line 1365
  return (tmp___8);
}
}
#line 1368 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int grepfile(int dirdesc , char const   *name , int follow , int command_line ) 
{ 
  int desc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1371
  if (follow) {
#line 1371
    tmp = 0;
  } else {
#line 1371
    tmp = 131072;
  }
  {
#line 1371
  tmp___0 = openat_safer(dirdesc, name, tmp);
#line 1371
  desc = tmp___0;
  }
#line 1372
  if (desc < 0) {
#line 1374
    if (follow) {
      {
#line 1375
      tmp___1 = __errno_location();
#line 1375
      suppressible_error(filename, *tmp___1);
      }
    } else {
      {
#line 1374
      tmp___2 = __errno_location();
      }
#line 1374
      if (*tmp___2 != 40) {
        {
#line 1374
        tmp___3 = __errno_location();
        }
#line 1374
        if (*tmp___3 != 31) {
          {
#line 1375
          tmp___1 = __errno_location();
#line 1375
          suppressible_error(filename, *tmp___1);
          }
        }
      }
    }
#line 1376
    return (1);
  }
  {
#line 1378
  tmp___4 = grepdesc(desc, command_line);
  }
#line 1378
  return (tmp___4);
}
}
#line 1381 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int grepdesc(int desc , int command_line ) 
{ 
  intmax_t count ;
  int status ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FTS *fts ;
  FTSENT *ent ;
  int opts ;
  int tmp___2 ;
  char *fts_arg[2] ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  off_t required_offset ;
  off_t tmp___14 ;
  int *tmp___15 ;
  __off_t tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1385
  status = 1;
#line 1394
  tmp___0 = fstat(desc, & st);
  }
#line 1394
  if (tmp___0 != 0) {
    {
#line 1396
    tmp = __errno_location();
#line 1396
    suppressible_error(filename, *tmp);
    }
#line 1397
    goto closeout;
  }
#line 1400
  if (desc != 0) {
#line 1400
    if (command_line) {
      {
#line 1400
      tmp___1 = skipped_file(filename, 1, (st.st_mode & 61440U) == 16384U);
      }
#line 1400
      if (tmp___1) {
#line 1402
        goto closeout;
      }
    }
  }
#line 1404
  if (desc != 0) {
#line 1404
    if ((unsigned int )directories == 3U) {
#line 1404
      if ((st.st_mode & 61440U) == 16384U) {
#line 1413
        if (command_line) {
#line 1413
          tmp___2 = 0;
        } else {
#line 1413
          tmp___2 = 1;
        }
        {
#line 1413
        opts = fts_options & ~ tmp___2;
#line 1418
        tmp___4 = close(desc);
        }
#line 1418
        if (tmp___4 != 0) {
          {
#line 1419
          tmp___3 = __errno_location();
#line 1419
          suppressible_error(filename, *tmp___3);
          }
        }
        {
#line 1421
        fts_arg[0] = (char *)filename;
#line 1422
        fts_arg[1] = (char *)((void *)0);
#line 1423
        fts = fts_open((char * const  *)(fts_arg), opts, (int (*)(FTSENT const   ** ,
                                                                  FTSENT const   ** ))((void *)0));
        }
#line 1425
        if (! fts) {
          {
#line 1426
          xalloc_die();
          }
        }
        {
#line 1427
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1427
          ent = fts_read(fts);
          }
#line 1427
          if (! ent) {
#line 1427
            goto while_break;
          }
          {
#line 1428
          tmp___5 = grepdirent(fts, ent, command_line);
#line 1428
          status &= tmp___5;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1429
        tmp___7 = __errno_location();
        }
#line 1429
        if (*tmp___7) {
          {
#line 1430
          tmp___6 = __errno_location();
#line 1430
          suppressible_error(filename, *tmp___6);
          }
        }
        {
#line 1431
        tmp___9 = fts_close(fts);
        }
#line 1431
        if (tmp___9 != 0) {
          {
#line 1432
          tmp___8 = __errno_location();
#line 1432
          suppressible_error(filename, *tmp___8);
          }
        }
#line 1433
        return (status);
      }
    }
  }
#line 1435
  if (desc != 0) {
#line 1435
    if ((unsigned int )directories == 4U) {
#line 1435
      if ((st.st_mode & 61440U) == 16384U) {
#line 1440
        goto closeout;
      } else {
#line 1435
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1435
    if ((unsigned int )devices == 2U) {
#line 1435
      goto _L;
    } else
#line 1435
    if ((unsigned int )devices == 0U) {
#line 1435
      if (! command_line) {
        _L: /* CIL Label */ 
        {
#line 1435
        tmp___10 = is_device_mode(st.st_mode);
        }
#line 1435
        if (tmp___10) {
#line 1440
          goto closeout;
        }
      }
    }
  }
#line 1460
  if (! out_quiet) {
#line 1460
    if (list_files == 0) {
#line 1460
      if (1L < max_count) {
#line 1460
        if ((out_stat.st_mode & 61440U) == 32768U) {
#line 1460
          if (out_stat.st_ino) {
#line 1460
            if (st.st_ino == out_stat.st_ino) {
#line 1460
              if (st.st_dev == out_stat.st_dev) {
#line 1464
                if (! suppress_errors) {
                  {
#line 1465
                  tmp___11 = quote(filename);
#line 1465
                  tmp___12 = gettext("input file %s is also the output");
#line 1465
                  error(0, 0, (char const   *)tmp___12, tmp___11);
                  }
                }
#line 1466
                errseen = 1;
#line 1467
                goto closeout;
              }
            }
          }
        }
      }
    }
  }
  {
#line 1473
  tmp___13 = isatty(desc);
  }
#line 1473
  if (! tmp___13) {
    {
#line 1474
    set_binary_mode(desc, 0);
    }
  }
  {
#line 1477
  count = grep(desc, (struct stat  const  *)(& st));
  }
#line 1478
  if (count < 0L) {
#line 1479
    status = (int )(count + 2L);
  } else {
#line 1482
    if (count_matches) {
#line 1484
      if (out_file) {
        {
#line 1486
        print_filename();
        }
#line 1487
        if (filename_mask) {
          {
#line 1488
          print_sep((char )':');
          }
        } else {
          {
#line 1490
          fputc_unlocked(0, stdout);
          }
        }
      }
      {
#line 1492
      printf((char const   */* __restrict  */)"%ld\n", count);
      }
    }
#line 1495
    status = ! count;
#line 1496
    if (list_files == 1 - 2 * status) {
      {
#line 1498
      print_filename();
#line 1499
      fputc_unlocked(10 & filename_mask, stdout);
      }
    }
#line 1502
    if (desc == 0) {
#line 1504
      if (outleft) {
#line 1504
        tmp___14 = bufoffset;
      } else {
#line 1504
        tmp___14 = after_last_match;
      }
#line 1504
      required_offset = tmp___14;
#line 1505
      if (required_offset != bufoffset) {
        {
#line 1505
        tmp___16 = lseek(desc, required_offset, 0);
        }
#line 1505
        if (tmp___16 < 0L) {
#line 1505
          if ((st.st_mode & 61440U) == 32768U) {
            {
#line 1508
            tmp___15 = __errno_location();
#line 1508
            suppressible_error(filename, *tmp___15);
            }
          }
        }
      }
    }
  }
  closeout: 
#line 1513
  if (desc != 0) {
    {
#line 1513
    tmp___18 = close(desc);
    }
#line 1513
    if (tmp___18 != 0) {
      {
#line 1514
      tmp___17 = __errno_location();
#line 1514
      suppressible_error(filename, *tmp___17);
      }
    }
  }
#line 1515
  return (status);
}
}
#line 1518 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int grep_command_line_arg(char const   *arg ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1521
  tmp___2 = strcmp(arg, "-");
  }
#line 1521
  if (tmp___2 == 0) {
#line 1523
    if (label) {
#line 1523
      filename = (char const   *)label;
    } else {
      {
#line 1523
      tmp = gettext("(standard input)");
#line 1523
      filename = (char const   *)tmp;
      }
    }
    {
#line 1524
    tmp___0 = grepdesc(0, 1);
    }
#line 1524
    return (tmp___0);
  } else {
    {
#line 1528
    filename = arg;
#line 1529
    tmp___1 = grepfile(-100, arg, 1, 1);
    }
#line 1529
    return (tmp___1);
  }
}
}
#line 1534 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 1537
  if (status != 0) {
    {
#line 1539
    tmp = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1539
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
#line 1541
    tmp___0 = gettext("Try \'%s --help\' for more information.\n");
#line 1541
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name);
    }
  } else {
    {
#line 1546
    tmp___1 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1546
    printf((char const   */* __restrict  */)tmp___1, program_name);
#line 1547
    tmp___2 = gettext("Search for PATTERN in each FILE or standard input.\n");
#line 1547
    printf((char const   */* __restrict  */)tmp___2);
#line 1549
    tmp___3 = gettext(before_options);
#line 1549
    fputs_unlocked((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 1550
    tmp___4 = gettext("Example: %s -i \'hello world\' menu.h main.c\n\nRegexp selection and interpretation:\n");
#line 1550
    printf((char const   */* __restrict  */)tmp___4, program_name);
    }
#line 1554
    if (matchers[1].name) {
      {
#line 1555
      tmp___5 = gettext("  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n");
#line 1555
      printf((char const   */* __restrict  */)tmp___5);
      }
    }
    {
#line 1561
    tmp___6 = gettext("  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n");
#line 1561
    printf((char const   */* __restrict  */)tmp___6);
#line 1568
    tmp___7 = gettext("\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             display version information and exit\n      --help                display this help text and exit\n");
#line 1568
    printf((char const   */* __restrict  */)tmp___7);
#line 1575
    tmp___8 = gettext("\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the file name for each match\n  -h, --no-filename         suppress the file name prefix on output\n      --label=LABEL         use LABEL as the standard input file name prefix\n");
#line 1575
    printf((char const   */* __restrict  */)tmp___8);
#line 1586
    tmp___9 = gettext("  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is \'binary\', \'text\', or \'without-match\'\n  -a, --text                equivalent to --binary-files=text\n");
#line 1586
    printf((char const   */* __restrict  */)tmp___9);
#line 1593
    tmp___10 = gettext("  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is \'read\', \'recurse\', or \'skip\'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is \'read\' or \'skip\'\n  -r, --recursive           like --directories=recurse\n  -R, --dereference-recursive  likewise, but follow all symlinks\n");
#line 1593
    printf((char const   */* __restrict  */)tmp___10);
#line 1602
    tmp___11 = gettext("      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n");
#line 1602
    printf((char const   */* __restrict  */)tmp___11);
#line 1608
    tmp___12 = gettext("  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n");
#line 1608
    printf((char const   */* __restrict  */)tmp___12);
#line 1614
    tmp___13 = gettext("\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n");
#line 1614
    printf((char const   */* __restrict  */)tmp___13);
#line 1621
    tmp___14 = gettext("  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is \'always\', \'never\', or \'auto\'\n  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there\n                            (MSDOS/Windows)\n\n");
#line 1621
    printf((char const   */* __restrict  */)tmp___14);
#line 1630
    tmp___15 = gettext(after_options);
#line 1630
    fputs_unlocked((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)stdout);
#line 1631
    tmp___16 = gettext("When FILE is -, read standard input.  With no FILE, read . if a command-line\n-r is given, - otherwise.  If fewer than two FILEs are given, assume -h.\nExit status is 0 if any line is selected, 1 otherwise;\nif any error occurs and -q is not given, the exit status is 2.\n");
#line 1631
    printf((char const   */* __restrict  */)tmp___16);
#line 1636
    tmp___17 = gettext("\nReport bugs to: %s\n");
#line 1636
    printf((char const   */* __restrict  */)tmp___17, "bug-grep@gnu.org");
#line 1637
    tmp___18 = gettext("GNU Grep home page: <%s>\n");
#line 1637
    printf((char const   */* __restrict  */)tmp___18, "http://www.gnu.org/software/grep/");
#line 1639
    tmp___19 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 1639
    fputs_unlocked((char const   */* __restrict  */)tmp___19, (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 1643
  exit(status);
  }
}
}
#line 1646 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static char const   *matcher  ;
#line 1651 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void setmatcher(char const   *m ) 
{ 
  unsigned int i ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 1656
  if (! m) {
#line 1658
    compile = (void (*)(char const   * , size_t  ))matchers[0].compile;
#line 1659
    execute = (size_t (*)(char const   * , size_t  , size_t * , char const   * ))matchers[0].execute;
#line 1660
    if (! matchers[1].name) {
#line 1661
      matcher = (char const   *)matchers[0].name;
    }
  } else
#line 1664
  if (matcher) {
#line 1666
    if (matcher) {
      {
#line 1666
      tmp___1 = strcmp(matcher, m);
      }
#line 1666
      if (! (tmp___1 == 0)) {
#line 1666
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1669
    if (! matchers[1].name) {
      {
#line 1670
      tmp = gettext("%s can only use the %s pattern syntax");
#line 1670
      error(2, 0, (char const   *)tmp, program_name, matcher);
      }
    } else {
      {
#line 1673
      tmp___0 = gettext("conflicting matchers specified");
#line 1673
      error(2, 0, (char const   *)tmp___0);
      }
    }
  } else {
#line 1678
    i = 0U;
    {
#line 1678
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1678
      if (! matchers[i].name) {
#line 1678
        goto while_break;
      }
      {
#line 1679
      tmp___2 = strcmp(m, (char const   *)matchers[i].name);
      }
#line 1679
      if (tmp___2 == 0) {
#line 1681
        compile = (void (*)(char const   * , size_t  ))matchers[i].compile;
#line 1682
        execute = (size_t (*)(char const   * , size_t  , size_t * , char const   * ))matchers[i].execute;
#line 1683
        matcher = m;
#line 1684
        return;
      }
#line 1678
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1687
    tmp___3 = gettext("invalid matcher %s");
#line 1687
    error(2, 0, (char const   *)tmp___3, m);
    }
  }
#line 1689
  return;
}
}
#line 1696 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static size_t prepend_args(char const   *options , char *buf , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  size_t n ;
  unsigned char tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___4 ;
  unsigned char tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;

  {
#line 1699
  o = options;
#line 1700
  b = buf;
#line 1701
  n = (size_t )0;
  {
#line 1703
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1705
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1705
      tmp = to_uchar((char )*o);
#line 1705
      tmp___0 = c_isspace((int )tmp);
      }
#line 1705
      if (! tmp___0) {
#line 1705
        goto while_break___0;
      }
#line 1706
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1707
    if (! *o) {
#line 1708
      return (n);
    }
#line 1709
    if (argv) {
#line 1710
      *(argv + n) = b;
    }
#line 1711
    n ++;
    {
#line 1713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1714
      tmp___2 = b;
#line 1714
      b ++;
#line 1714
      tmp___4 = o;
#line 1714
      o ++;
#line 1714
      tmp___3 = (char )*tmp___4;
#line 1714
      *tmp___2 = tmp___3;
#line 1714
      if ((int )tmp___3 == 92) {
#line 1714
        if (*o) {
#line 1715
          tmp___1 = o;
#line 1715
          o ++;
#line 1715
          *(b + -1) = (char )*tmp___1;
        }
      }
#line 1713
      if (*o) {
        {
#line 1713
        tmp___5 = to_uchar((char )*o);
#line 1713
        tmp___6 = c_isspace((int )tmp___5);
        }
#line 1713
        if (tmp___6) {
#line 1713
          goto while_break___1;
        }
      } else {
#line 1713
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1718
    tmp___7 = b;
#line 1718
    b ++;
#line 1718
    *tmp___7 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t prepended ;
  size_t tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  size_t tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 1728
  if (options) {
#line 1728
    if (*options) {
      {
#line 1730
      tmp = strlen(options);
#line 1730
      tmp___0 = xmalloc(tmp + 1UL);
#line 1730
      buf = (char *)tmp___0;
#line 1731
      tmp___1 = prepend_args(options, buf, (char **)((void *)0));
#line 1731
      prepended = tmp___1;
#line 1732
      argc = *pargc;
#line 1733
      argv = (char * const  *)*pargv;
      }
#line 1736
      if ((size_t )(2147483647 - argc) < prepended) {
        {
#line 1737
        xalloc_die();
        }
      }
      {
#line 1738
      tmp___2 = xmalloc(((prepended + (size_t )argc) + 1UL) * sizeof(*pp));
#line 1738
      pp = (char **)tmp___2;
#line 1739
      *pargc = (int )(prepended + (size_t )argc);
#line 1740
      *pargv = pp;
#line 1741
      tmp___3 = pp;
#line 1741
      pp ++;
#line 1741
      tmp___4 = argv;
#line 1741
      argv ++;
#line 1741
      *tmp___3 = (char *)*tmp___4;
#line 1742
      tmp___5 = prepend_args(options, buf, pp);
#line 1742
      pp += tmp___5;
      }
      {
#line 1743
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1743
        tmp___6 = pp;
#line 1743
        pp ++;
#line 1743
        tmp___8 = argv;
#line 1743
        argv ++;
#line 1743
        tmp___7 = (char *)*tmp___8;
#line 1743
        *tmp___6 = tmp___7;
#line 1743
        if (! tmp___7) {
#line 1743
          goto while_break;
        }
#line 1744
        goto while_continue;
      }
      while_break: /* CIL Label */ ;
      }
#line 1745
      return ((int )prepended);
    }
  }
#line 1748
  return (0);
}
}
#line 1758
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) ;
#line 1758 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int prev_digit_optind  =    -1;
#line 1755 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) 
{ 
  int this_digit_optind ;
  int was_digit ;
  char buf[((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL) + 4UL] ;
  char *p ;
  int opt ;
  char *tmp ;

  {
#line 1761
  p = buf;
#line 1764
  was_digit = 0;
#line 1765
  this_digit_optind = optind;
  {
#line 1766
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1768
    opt = getopt_long(argc, (char * const  *)((char **)argv), short_options, long_options,
                      (int *)((void *)0));
    }
#line 1770
    if (48 <= opt) {
#line 1770
      if (! (opt <= 57)) {
#line 1771
        goto while_break;
      }
    } else {
#line 1771
      goto while_break;
    }
#line 1773
    if (prev_digit_optind != this_digit_optind) {
#line 1776
      p = buf;
    } else
#line 1773
    if (! was_digit) {
#line 1776
      p = buf;
    } else {
#line 1782
      p -= (int )buf[0] == 48;
    }
#line 1785
    if ((unsigned long )p == (unsigned long )((buf + sizeof(buf)) - 4)) {
      {
#line 1790
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"...");
#line 1791
      p += 3;
      }
#line 1792
      goto while_break;
    }
#line 1794
    tmp = p;
#line 1794
    p ++;
#line 1794
    *tmp = (char )opt;
#line 1796
    was_digit = 1;
#line 1797
    prev_digit_optind = this_digit_optind;
#line 1798
    this_digit_optind = optind;
  }
  while_break: /* CIL Label */ ;
  }
#line 1800
  if ((unsigned long )p != (unsigned long )(buf)) {
    {
#line 1802
    *p = (char )'\000';
#line 1803
    context_length_arg((char const   *)(buf), default_context);
    }
  }
#line 1806
  return (opt);
}
}
#line 1813 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static void parse_grep_colors(void) 
{ 
  char const   *p ;
  char *q ;
  char *name ;
  char *val ;
  char *tmp ;
  char c ;
  struct color_cap  const  *cap ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1821
  tmp = getenv("GREP_COLORS");
#line 1821
  p = (char const   *)tmp;
  }
#line 1822
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1823
    return;
  } else
#line 1822
  if ((int const   )*p == 0) {
#line 1823
    return;
  }
  {
#line 1826
  q = xstrdup(p);
#line 1828
  name = q;
#line 1829
  val = (char *)((void *)0);
  }
  {
#line 1831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1832
    if ((int )*q == 58) {
#line 1832
      goto _L;
    } else
#line 1832
    if ((int )*q == 0) {
      _L: /* CIL Label */ 
#line 1834
      c = *q;
#line 1837
      tmp___0 = q;
#line 1837
      q ++;
#line 1837
      *tmp___0 = (char )'\000';
#line 1840
      cap = color_dict;
      {
#line 1840
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1840
        if (! cap->name) {
#line 1840
          goto while_break___0;
        }
        {
#line 1841
        tmp___1 = strcmp((char const   *)cap->name, (char const   *)name);
        }
#line 1841
        if (tmp___1 == 0) {
#line 1842
          goto while_break___0;
        }
#line 1840
        cap ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1844
      if (cap->var) {
#line 1844
        if (val) {
#line 1845
          *(cap->var) = (char const   *)val;
        }
      }
#line 1846
      if (cap->fct) {
        {
#line 1847
        (*(cap->fct))();
        }
      }
#line 1848
      if ((int )c == 0) {
#line 1849
        return;
      }
#line 1850
      name = q;
#line 1851
      val = (char *)((void *)0);
    } else
#line 1853
    if ((int )*q == 61) {
#line 1855
      if ((unsigned long )q == (unsigned long )name) {
#line 1856
        return;
      } else
#line 1855
      if (val) {
#line 1856
        return;
      }
#line 1857
      tmp___2 = q;
#line 1857
      q ++;
#line 1857
      *tmp___2 = (char )'\000';
#line 1858
      val = q;
    } else
#line 1860
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1861
      q ++;
    } else
#line 1862
    if ((int )*q == 59) {
#line 1863
      q ++;
    } else
#line 1862
    if ((int )*q >= 48) {
#line 1862
      if ((int )*q <= 57) {
#line 1863
        q ++;
      } else {
#line 1865
        return;
      }
    } else {
#line 1865
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1883 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
static _Bool trivial_case_ignore(size_t len , char const   *keys , size_t *new_len ,
                                 char **new_keys ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *p ;
  mbstate_t mb_state ;
  wchar_t wc ;
  int n ;
  wint_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char const   *orig ;
  char *tmp___9 ;
  wchar_t wc2 ;
  wint_t tmp___11 ;
  wint_t tmp___12 ;
  wint_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___16 ;
  int n2 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;

  {
  {
#line 1889
  tmp = using_utf8();
  }
#line 1889
  if (! tmp) {
#line 1890
    return ((_Bool)0);
  }
  {
#line 1894
  tmp___0 = memchr((void const   *)keys, '\\', len);
  }
#line 1894
  if (tmp___0) {
#line 1895
    return ((_Bool)0);
  } else {
    {
#line 1894
    tmp___1 = memchr((void const   *)keys, '[', len);
    }
#line 1894
    if (tmp___1) {
#line 1895
      return ((_Bool)0);
    }
  }
  {
#line 1900
  tmp___2 = __ctype_get_mb_cur_max();
#line 1900
  tmp___3 = xnmalloc(tmp___2 + 3UL, len + 1UL);
#line 1900
  *new_keys = (char *)tmp___3;
#line 1901
  p = *new_keys;
#line 1904
  memset((void *)(& mb_state), 0, sizeof(mb_state));
  }
  {
#line 1905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1905
    if (! len) {
#line 1905
      goto while_break;
    }
    {
#line 1908
    tmp___8 = __ctype_get_mb_cur_max();
    }
#line 1908
    if (tmp___8 == 1UL) {
      {
#line 1908
      tmp___5 = btowc((int )*((unsigned char *)keys));
#line 1908
      wc = (wchar_t )tmp___5;
#line 1908
      tmp___7 = (size_t )1;
      }
    } else {
      {
#line 1908
      tmp___6 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)keys,
                        len, (mbstate_t */* __restrict  */)(& mb_state));
#line 1908
      tmp___7 = tmp___6;
      }
    }
#line 1908
    n = (int )tmp___7;
#line 1911
    if (n <= 0) {
      skip_case_ignore_optimization: 
      {
#line 1914
      free((void *)*new_keys);
      }
#line 1915
      return ((_Bool)0);
    }
    {
#line 1918
    orig = keys;
#line 1919
    keys += n;
#line 1920
    len -= (size_t )n;
#line 1922
    tmp___27 = iswalpha((wint_t )wc);
    }
#line 1922
    if (tmp___27) {
      {
#line 1929
      tmp___9 = p;
#line 1929
      p ++;
#line 1929
      *tmp___9 = (char )'[';
#line 1930
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)orig, (size_t )n);
#line 1931
      p += n;
#line 1933
      tmp___14 = iswupper((wint_t )wc);
      }
#line 1933
      if (tmp___14) {
        {
#line 1933
        tmp___11 = towlower((wint_t )wc);
#line 1933
        tmp___13 = tmp___11;
        }
      } else {
        {
#line 1933
        tmp___12 = towupper((wint_t )wc);
#line 1933
        tmp___13 = tmp___12;
        }
      }
      {
#line 1933
      wc2 = (wchar_t )tmp___13;
#line 1934
      tmp___15 = __ctype_get_mb_cur_max();
#line 1934
      __lengthofbuf = tmp___15;
#line 1934
      tmp___16 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 1934
      buf = (char *)tmp___16;
#line 1935
      tmp___21 = __ctype_get_mb_cur_max();
      }
#line 1935
      if (tmp___21 == 1UL) {
        {
#line 1935
        tmp___18 = wctob((wint_t )wc2);
#line 1935
        *buf = (char )tmp___18;
#line 1935
        tmp___20 = (size_t )1;
        }
      } else {
        {
#line 1935
        tmp___19 = wcrtomb((char */* __restrict  */)buf, wc2, (mbstate_t */* __restrict  */)(& mb_state));
#line 1935
        tmp___20 = tmp___19;
        }
      }
#line 1935
      n2 = (int )tmp___20;
#line 1936
      if (n2 <= 0) {
#line 1937
        goto skip_case_ignore_optimization;
      }
      {
#line 1938
      tmp___25 = __ctype_get_mb_cur_max();
      }
#line 1938
      if (! ((size_t )n2 <= tmp___25)) {
        {
#line 1938
        __assert_fail("n2 <= MB_CUR_MAX", "/home/khheo/project/benchmark/grep-2.18/src/main.c",
                      1938U, "trivial_case_ignore");
        }
      }
      {
#line 1939
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, (size_t )n2);
#line 1940
      p += n2;
#line 1942
      tmp___26 = p;
#line 1942
      p ++;
#line 1942
      *tmp___26 = (char )']';
      }
    } else {
      {
#line 1924
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)orig, (size_t )n);
#line 1925
      p += n;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1946
  *new_len = (size_t )(p - *new_keys);
#line 1948
  return ((_Bool)1);
}
}
#line 1951 "/home/khheo/project/benchmark/grep-2.18/src/main.c"
int main(int argc , char **argv ) 
{ 
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int with_filenames ;
  size_t cc ;
  int opt ;
  int status ;
  int prepended ;
  int prev_optind ;
  int last_recursive ;
  int fread_errno ;
  intmax_t default_context ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ptrdiff_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  FILE *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  strtol_error tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *userval ;
  char *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  struct stat tmp_stat ;
  int tmp___39 ;
  int tmp___40 ;
  void *tmp___41 ;
  size_t new_keycc ;
  char *new_keys ;
  int tmp___42 ;
  int tmp___43 ;
  _Bool tmp___44 ;
  size_t tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
  {
#line 1963
  exit_failure = (int volatile   )2;
#line 1965
  set_program_name((char const   *)*(argv + 0));
#line 1966
  program_name = (char const   *)*(argv + 0);
#line 1968
  keys = (char *)((void *)0);
#line 1969
  keycc = (size_t )0;
#line 1970
  with_filenames = 0;
#line 1971
  eolbyte = (unsigned char )'\n';
#line 1972
  filename_mask = ~ 0;
#line 1974
  max_count = 9223372036854775807L;
#line 1977
  out_before = (intmax_t )-1;
#line 1977
  out_after = out_before;
#line 1979
  default_context = (intmax_t )0;
#line 1981
  only_matching = 0;
#line 1985
  setlocale(6, "");
#line 1988
  bindtextdomain("grep", "/usr/local/share/locale");
#line 1989
  textdomain("grep");
#line 1992
  exit_failure = (int volatile   )2;
#line 1993
  atexit(& clean_up_stdout);
#line 1995
  last_recursive = 0;
#line 1996
  tmp = getenv("GREP_OPTIONS");
#line 1996
  prepended = prepend_default_options((char const   *)tmp, & argc, & argv);
#line 1997
  setmatcher((char const   *)((void *)0));
  }
  {
#line 1999
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1999
    prev_optind = optind;
#line 1999
    opt = get_nondigit_option(argc, (char * const  *)argv, & default_context);
    }
#line 1999
    if (! (opt != -1)) {
#line 1999
      goto while_break;
    }
    {
#line 2003
    if (opt == 65) {
#line 2003
      goto case_65;
    }
#line 2007
    if (opt == 66) {
#line 2007
      goto case_66;
    }
#line 2011
    if (opt == 67) {
#line 2011
      goto case_67;
    }
#line 2017
    if (opt == 68) {
#line 2017
      goto case_68;
    }
#line 2026
    if (opt == 69) {
#line 2026
      goto case_69;
    }
#line 2030
    if (opt == 70) {
#line 2030
      goto case_70;
    }
#line 2034
    if (opt == 80) {
#line 2034
      goto case_80;
    }
#line 2038
    if (opt == 71) {
#line 2038
      goto case_71;
    }
#line 2042
    if (opt == 88) {
#line 2042
      goto case_88;
    }
#line 2046
    if (opt == 72) {
#line 2046
      goto case_72;
    }
#line 2051
    if (opt == 73) {
#line 2051
      goto case_73;
    }
#line 2055
    if (opt == 84) {
#line 2055
      goto case_84;
    }
#line 2059
    if (opt == 85) {
#line 2059
      goto case_85;
    }
#line 2065
    if (opt == 117) {
#line 2065
      goto case_117;
    }
#line 2071
    if (opt == 86) {
#line 2071
      goto case_86;
    }
#line 2075
    if (opt == 97) {
#line 2075
      goto case_97;
    }
#line 2079
    if (opt == 98) {
#line 2079
      goto case_98;
    }
#line 2083
    if (opt == 99) {
#line 2083
      goto case_99;
    }
#line 2087
    if (opt == 100) {
#line 2087
      goto case_100;
    }
#line 2094
    if (opt == 101) {
#line 2094
      goto case_101;
    }
#line 2102
    if (opt == 102) {
#line 2102
      goto case_102;
    }
#line 2126
    if (opt == 104) {
#line 2126
      goto case_104;
    }
#line 2132
    if (opt == 121) {
#line 2132
      goto case_121;
    }
#line 2132
    if (opt == 105) {
#line 2132
      goto case_121;
    }
#line 2136
    if (opt == 76) {
#line 2136
      goto case_76;
    }
#line 2142
    if (opt == 108) {
#line 2142
      goto case_108;
    }
#line 2146
    if (opt == 109) {
#line 2146
      goto case_109;
    }
#line 2158
    if (opt == 110) {
#line 2158
      goto case_110;
    }
#line 2162
    if (opt == 111) {
#line 2162
      goto case_111;
    }
#line 2166
    if (opt == 113) {
#line 2166
      goto case_113;
    }
#line 2171
    if (opt == 82) {
#line 2171
      goto case_82;
    }
#line 2174
    if (opt == 114) {
#line 2174
      goto case_114;
    }
#line 2179
    if (opt == 115) {
#line 2179
      goto case_115;
    }
#line 2183
    if (opt == 118) {
#line 2183
      goto case_118;
    }
#line 2187
    if (opt == 119) {
#line 2187
      goto case_119;
    }
#line 2191
    if (opt == 120) {
#line 2191
      goto case_120;
    }
#line 2195
    if (opt == 90) {
#line 2195
      goto case_90;
    }
#line 2199
    if (opt == 122) {
#line 2199
      goto case_122;
    }
#line 2203
    if (opt == 128) {
#line 2203
      goto case_128;
    }
#line 2214
    if (opt == 129) {
#line 2214
      goto case_129;
    }
#line 2234
    if (opt == 130) {
#line 2234
      goto case_130;
    }
#line 2234
    if (opt == 131) {
#line 2234
      goto case_130;
    }
#line 2241
    if (opt == 132) {
#line 2241
      goto case_132;
    }
#line 2251
    if (opt == 135) {
#line 2251
      goto case_135;
    }
#line 2257
    if (opt == 136) {
#line 2257
      goto case_136;
    }
#line 2261
    if (opt == 133) {
#line 2261
      goto case_133;
    }
#line 2265
    if (opt == 134) {
#line 2265
      goto case_134;
    }
#line 2269
    if (opt == 0) {
#line 2269
      goto case_0___0;
    }
#line 2273
    goto switch_default___0;
    case_65: /* CIL Label */ 
    {
#line 2004
    context_length_arg((char const   *)optarg, & out_after);
    }
#line 2005
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 2008
    context_length_arg((char const   *)optarg, & out_before);
    }
#line 2009
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 2014
    context_length_arg((char const   *)optarg, & default_context);
    }
#line 2015
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 2018
    tmp___2 = strcmp((char const   *)optarg, "read");
    }
#line 2018
    if (tmp___2 == 0) {
#line 2019
      devices = (enum __anonenum_devices_473526324 )1;
    } else {
      {
#line 2020
      tmp___1 = strcmp((char const   *)optarg, "skip");
      }
#line 2020
      if (tmp___1 == 0) {
#line 2021
        devices = (enum __anonenum_devices_473526324 )2;
      } else {
        {
#line 2023
        tmp___0 = gettext("unknown devices method");
#line 2023
        error(2, 0, (char const   *)tmp___0);
        }
      }
    }
#line 2024
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 2027
    setmatcher("egrep");
    }
#line 2028
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 2031
    setmatcher("fgrep");
    }
#line 2032
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 2035
    setmatcher("perl");
    }
#line 2036
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 2039
    setmatcher("grep");
    }
#line 2040
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 2043
    setmatcher((char const   *)optarg);
    }
#line 2044
    goto switch_break;
    case_72: /* CIL Label */ 
#line 2047
    with_filenames = 1;
#line 2048
    no_filenames = 0;
#line 2049
    goto switch_break;
    case_73: /* CIL Label */ 
#line 2052
    binary_files = (enum __anonenum_binary_files_601436154 )2;
#line 2053
    goto switch_break;
    case_84: /* CIL Label */ 
#line 2056
    align_tabs = 1;
#line 2057
    goto switch_break;
    case_85: /* CIL Label */ 
#line 2063
    goto switch_break;
    case_117: /* CIL Label */ 
#line 2069
    goto switch_break;
    case_86: /* CIL Label */ 
#line 2072
    show_version = 1;
#line 2073
    goto switch_break;
    case_97: /* CIL Label */ 
#line 2076
    binary_files = (enum __anonenum_binary_files_601436154 )1;
#line 2077
    goto switch_break;
    case_98: /* CIL Label */ 
#line 2080
    out_byte = 1;
#line 2081
    goto switch_break;
    case_99: /* CIL Label */ 
#line 2084
    count_matches = 1;
#line 2085
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 2088
    tmp___3 = __xargmatch_internal("--directories", (char const   *)optarg, directories_args,
                                   (char const   *)(directories_types), sizeof(directories_types[0]),
                                   argmatch_die);
#line 2088
    directories = (enum directories_type )directories_types[tmp___3];
    }
#line 2090
    if ((unsigned int )directories == 3U) {
#line 2091
      last_recursive = prev_optind;
    }
#line 2092
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 2095
    cc = strlen((char const   *)optarg);
#line 2096
    tmp___4 = xrealloc((void *)keys, (keycc + cc) + 1UL);
#line 2096
    keys = (char *)tmp___4;
#line 2097
    strcpy((char */* __restrict  */)(keys + keycc), (char const   */* __restrict  */)optarg);
#line 2098
    keycc += cc;
#line 2099
    tmp___5 = keycc;
#line 2099
    keycc ++;
#line 2099
    *(keys + tmp___5) = (char )'\n';
    }
#line 2100
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 2103
    tmp___8 = strcmp((char const   *)optarg, "-");
    }
#line 2103
    if (tmp___8 == 0) {
#line 2103
      fp = stdin;
    } else {
      {
#line 2103
      tmp___7 = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
#line 2103
      fp = tmp___7;
      }
    }
#line 2104
    if (! fp) {
      {
#line 2105
      tmp___9 = __errno_location();
#line 2105
      error(2, *tmp___9, "%s", optarg);
      }
    }
#line 2106
    keyalloc = (size_t )1;
    {
#line 2106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2106
      if (! (keyalloc <= keycc + 1UL)) {
#line 2106
        goto while_break___0;
      }
#line 2106
      keyalloc *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2108
    tmp___10 = xrealloc((void *)keys, keyalloc);
#line 2108
    keys = (char *)tmp___10;
#line 2109
    oldcc = keycc;
    }
    {
#line 2110
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2110
      cc = fread_unlocked((void */* __restrict  */)(keys + keycc), (size_t )1, (keyalloc - 1UL) - keycc,
                          (FILE */* __restrict  */)fp);
      }
#line 2110
      if (! (cc != 0UL)) {
#line 2110
        goto while_break___1;
      }
#line 2112
      keycc += cc;
#line 2113
      if (keycc == keyalloc - 1UL) {
        {
#line 2114
        tmp___11 = x2nrealloc((void *)keys, & keyalloc, sizeof(*keys));
#line 2114
        keys = (char *)tmp___11;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2116
    tmp___12 = __errno_location();
#line 2116
    fread_errno = *tmp___12;
#line 2117
    tmp___13 = ferror_unlocked(fp);
    }
#line 2117
    if (tmp___13) {
      {
#line 2118
      error(2, fread_errno, "%s", optarg);
      }
    }
#line 2119
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 2120
      fclose(fp);
      }
    }
#line 2122
    if (oldcc != keycc) {
#line 2122
      if ((int )*(keys + (keycc - 1UL)) != 10) {
#line 2123
        tmp___14 = keycc;
#line 2123
        keycc ++;
#line 2123
        *(keys + tmp___14) = (char )'\n';
      }
    }
#line 2124
    goto switch_break;
    case_104: /* CIL Label */ 
#line 2127
    with_filenames = 0;
#line 2128
    no_filenames = 1;
#line 2129
    goto switch_break;
    case_121: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 2133
    match_icase = 1;
#line 2134
    goto switch_break;
    case_76: /* CIL Label */ 
#line 2139
    list_files = -1;
#line 2140
    goto switch_break;
    case_108: /* CIL Label */ 
#line 2143
    list_files = 1;
#line 2144
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 2147
    tmp___15 = xstrtoimax((char const   *)optarg, (char **)0, 10, & max_count, "");
    }
    {
#line 2150
    if ((unsigned int )tmp___15 == 1U) {
#line 2150
      goto case_1;
    }
#line 2150
    if ((unsigned int )tmp___15 == 0U) {
#line 2150
      goto case_1;
    }
#line 2153
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 2151
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2154
    tmp___16 = gettext("invalid max count");
#line 2154
    error(2, 0, (char const   *)tmp___16);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2156
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2159
    out_line = 1;
#line 2160
    goto switch_break;
    case_111: /* CIL Label */ 
#line 2163
    only_matching = 1;
#line 2164
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2167
    exit_on_match = 1;
#line 2168
    exit_failure = (int volatile   )0;
#line 2169
    goto switch_break;
    case_82: /* CIL Label */ 
#line 2172
    fts_options = 778;
    case_114: /* CIL Label */ 
#line 2175
    directories = (enum directories_type )3;
#line 2176
    last_recursive = prev_optind;
#line 2177
    goto switch_break;
    case_115: /* CIL Label */ 
#line 2180
    suppress_errors = 1;
#line 2181
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2184
    out_invert = 1;
#line 2185
    goto switch_break;
    case_119: /* CIL Label */ 
#line 2188
    match_words = 1;
#line 2189
    goto switch_break;
    case_120: /* CIL Label */ 
#line 2192
    match_lines = 1;
#line 2193
    goto switch_break;
    case_90: /* CIL Label */ 
#line 2196
    filename_mask = 0;
#line 2197
    goto switch_break;
    case_122: /* CIL Label */ 
#line 2200
    eolbyte = (unsigned char )'\000';
#line 2201
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 2204
    tmp___20 = strcmp((char const   *)optarg, "binary");
    }
#line 2204
    if (tmp___20 == 0) {
#line 2205
      binary_files = (enum __anonenum_binary_files_601436154 )0;
    } else {
      {
#line 2206
      tmp___19 = strcmp((char const   *)optarg, "text");
      }
#line 2206
      if (tmp___19 == 0) {
#line 2207
        binary_files = (enum __anonenum_binary_files_601436154 )1;
      } else {
        {
#line 2208
        tmp___18 = strcmp((char const   *)optarg, "without-match");
        }
#line 2208
        if (tmp___18 == 0) {
#line 2209
          binary_files = (enum __anonenum_binary_files_601436154 )2;
        } else {
          {
#line 2211
          tmp___17 = gettext("unknown binary-files type");
#line 2211
          error(2, 0, (char const   *)tmp___17);
          }
        }
      }
    }
#line 2212
    goto switch_break;
    case_129: /* CIL Label */ 
#line 2215
    if (optarg) {
      {
#line 2217
      tmp___27 = strcasecmp((char const   *)optarg, "always");
      }
#line 2217
      if (tmp___27) {
        {
#line 2217
        tmp___28 = strcasecmp((char const   *)optarg, "yes");
        }
#line 2217
        if (tmp___28) {
          {
#line 2217
          tmp___29 = strcasecmp((char const   *)optarg, "force");
          }
#line 2217
          if (tmp___29) {
            {
#line 2220
            tmp___24 = strcasecmp((char const   *)optarg, "never");
            }
#line 2220
            if (tmp___24) {
              {
#line 2220
              tmp___25 = strcasecmp((char const   *)optarg, "no");
              }
#line 2220
              if (tmp___25) {
                {
#line 2220
                tmp___26 = strcasecmp((char const   *)optarg, "none");
                }
#line 2220
                if (tmp___26) {
                  {
#line 2223
                  tmp___21 = strcasecmp((char const   *)optarg, "auto");
                  }
#line 2223
                  if (tmp___21) {
                    {
#line 2223
                    tmp___22 = strcasecmp((char const   *)optarg, "tty");
                    }
#line 2223
                    if (tmp___22) {
                      {
#line 2223
                      tmp___23 = strcasecmp((char const   *)optarg, "if-tty");
                      }
#line 2223
                      if (tmp___23) {
#line 2227
                        show_help = 1;
                      } else {
#line 2225
                        color_option = 2;
                      }
                    } else {
#line 2225
                      color_option = 2;
                    }
                  } else {
#line 2225
                    color_option = 2;
                  }
                } else {
#line 2222
                  color_option = 0;
                }
              } else {
#line 2222
                color_option = 0;
              }
            } else {
#line 2222
              color_option = 0;
            }
          } else {
#line 2219
            color_option = 1;
          }
        } else {
#line 2219
          color_option = 1;
        }
      } else {
#line 2219
        color_option = 1;
      }
    } else {
#line 2230
      color_option = 2;
    }
#line 2231
    goto switch_break;
    case_130: /* CIL Label */ 
    case_131: /* CIL Label */ 
#line 2235
    if (! excluded_patterns) {
      {
#line 2236
      excluded_patterns = new_exclude();
      }
    }
#line 2237
    if (opt == 130) {
#line 2237
      tmp___30 = 1 << 29;
    } else {
#line 2237
      tmp___30 = 0;
    }
    {
#line 2237
    add_exclude(excluded_patterns, (char const   *)optarg, (1 << 28) | tmp___30);
    }
#line 2240
    goto switch_break;
    case_132: /* CIL Label */ 
#line 2242
    if (! excluded_patterns) {
      {
#line 2243
      excluded_patterns = new_exclude();
      }
    }
    {
#line 2244
    tmp___32 = add_exclude_file(& add_exclude, excluded_patterns, (char const   *)optarg,
                                1 << 28, (char )'\n');
    }
#line 2244
    if (tmp___32 != 0) {
      {
#line 2247
      tmp___31 = __errno_location();
#line 2247
      error(2, *tmp___31, "%s", optarg);
      }
    }
#line 2249
    goto switch_break;
    case_135: /* CIL Label */ 
#line 2252
    if (! excluded_directory_patterns) {
      {
#line 2253
      excluded_directory_patterns = new_exclude();
      }
    }
    {
#line 2254
    add_exclude(excluded_directory_patterns, (char const   *)optarg, 1 << 28);
    }
#line 2255
    goto switch_break;
    case_136: /* CIL Label */ 
#line 2258
    group_separator = (char const   *)optarg;
#line 2259
    goto switch_break;
    case_133: /* CIL Label */ 
#line 2262
    line_buffered = 1;
#line 2263
    goto switch_break;
    case_134: /* CIL Label */ 
#line 2266
    label = optarg;
#line 2267
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 2271
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 2274
    usage(2);
    }
#line 2275
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2279
  if (color_option == 2) {
    {
#line 2280
    tmp___33 = isatty(1);
    }
#line 2280
    if (tmp___33) {
      {
#line 2280
      tmp___34 = should_colorize();
      }
#line 2280
      if (tmp___34) {
#line 2280
        tmp___35 = 1;
      } else {
#line 2280
        tmp___35 = 0;
      }
    } else {
#line 2280
      tmp___35 = 0;
    }
#line 2280
    color_option = tmp___35;
  }
  {
#line 2281
  init_colorize();
  }
#line 2285
  if (exit_on_match) {
#line 2286
    list_files = 0;
  }
#line 2287
  if (exit_on_match | list_files) {
#line 2289
    count_matches = 0;
#line 2290
    done_on_match = 1;
  }
#line 2292
  out_quiet = count_matches | done_on_match;
#line 2294
  if (out_after < 0L) {
#line 2295
    out_after = default_context;
  }
#line 2296
  if (out_before < 0L) {
#line 2297
    out_before = default_context;
  }
#line 2299
  if (color_option) {
    {
#line 2302
    tmp___36 = getenv("GREP_COLOR");
#line 2302
    userval = tmp___36;
    }
#line 2303
    if ((unsigned long )userval != (unsigned long )((void *)0)) {
#line 2303
      if ((int )*userval != 0) {
#line 2304
        context_match_color = (char const   *)userval;
#line 2304
        selected_match_color = context_match_color;
      }
    }
    {
#line 2307
    parse_grep_colors();
    }
  }
#line 2310
  if (show_version) {
    {
#line 2312
    tmp___37 = gettext("others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>");
#line 2312
    tmp___38 = proper_name("Mike Haertel");
#line 2312
    version_etc(stdout, program_name, "GNU grep", "2.18", tmp___38, tmp___37, (char *)((void *)0));
#line 2314
    exit(0);
    }
  }
#line 2317
  if (show_help) {
    {
#line 2318
    usage(0);
    }
  }
  {
#line 2321
  tmp___39 = fstat(1, & tmp_stat);
  }
#line 2321
  if (tmp___39 == 0) {
#line 2321
    if ((tmp_stat.st_mode & 61440U) == 32768U) {
#line 2322
      out_stat = tmp_stat;
    }
  }
#line 2324
  if (keys) {
#line 2326
    if (keycc == 0UL) {
#line 2329
      out_invert ^= 1;
#line 2330
      match_words = 0;
#line 2330
      match_lines = match_words;
    } else {
#line 2334
      keycc --;
    }
  } else
#line 2336
  if (optind < argc) {
    {
#line 2339
    keycc = strlen((char const   *)*(argv + optind));
#line 2340
    tmp___40 = optind;
#line 2340
    optind ++;
#line 2340
    tmp___41 = xmemdup((void const   *)*(argv + tmp___40), keycc + 1UL);
#line 2340
    keys = (char *)tmp___41;
    }
  } else {
    {
#line 2343
    usage(2);
    }
  }
#line 2355
  if (match_icase) {
#line 2362
    if (keycc) {
#line 2362
      if (matcher) {
        {
#line 2362
        tmp___42 = strcmp(matcher, "fgrep");
        }
#line 2362
        if (! (tmp___42 == 0)) {
          {
#line 2362
          tmp___43 = strcmp(matcher, "pcre");
          }
#line 2362
          if (! (tmp___43 == 0)) {
#line 2362
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2362
        tmp___44 = trivial_case_ignore(keycc, (char const   *)keys, & new_keycc, & new_keys);
        }
#line 2362
        if (tmp___44) {
          {
#line 2367
          match_icase = 0;
#line 2368
          free((void *)keys);
#line 2369
          keys = new_keys;
#line 2370
          keycc = new_keycc;
          }
        }
      }
    }
  }
  {
#line 2375
  tmp___45 = __ctype_get_mb_cur_max();
  }
#line 2375
  if (tmp___45 > 1UL) {
    {
#line 2376
    build_mbclen_cache();
    }
  }
  {
#line 2379
  (*compile)((char const   *)keys, keycc);
#line 2380
  free((void *)keys);
  }
#line 2382
  if (argc - optind > 1) {
#line 2382
    if (! no_filenames) {
#line 2383
      out_file = 1;
    } else {
#line 2382
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2382
  if (with_filenames) {
#line 2383
    out_file = 1;
  }
  {
#line 2388
  tmp___46 = isatty(1);
  }
#line 2388
  if (! tmp___46) {
    {
#line 2389
    set_binary_mode(1, 0);
    }
  }
#line 2392
  if (max_count == 0L) {
    {
#line 2393
    exit(1);
    }
  }
#line 2395
  if (fts_options & 2) {
#line 2395
    if ((unsigned int )devices == 0U) {
#line 2396
      devices = (enum __anonenum_devices_473526324 )1;
    }
  }
#line 2398
  if (optind < argc) {
#line 2400
    status = 1;
    {
#line 2401
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2402
      tmp___47 = grep_command_line_arg((char const   *)*(argv + optind));
#line 2402
      status &= tmp___47;
#line 2401
      optind ++;
      }
#line 2401
      if (! (optind < argc)) {
#line 2401
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 2405
  if ((unsigned int )directories == 3U) {
#line 2405
    if (prepended < last_recursive) {
      {
#line 2408
      filename_prefix_len = (size_t )2;
#line 2409
      status = grep_command_line_arg(".");
      }
    } else {
      {
#line 2412
      status = grep_command_line_arg("-");
      }
    }
  } else {
    {
#line 2412
    status = grep_command_line_arg("-");
    }
  }
#line 2415
  if (errseen) {
#line 2415
    tmp___48 = 2;
  } else {
#line 2415
    tmp___48 = status;
  }
  {
#line 2415
  exit(tmp___48);
  }
}
}
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 45 "/home/khheo/project/benchmark/grep-2.18/src/kwset.h"
char const   *kwsincr(kwset_t kws , char const   *text , size_t len ) ;
#line 49
char const   *kwsprep(kwset_t kws ) ;
#line 57
size_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kws , char const   *text ,
                                                  size_t size , struct kwsmatch *kwsmatch ) ;
#line 61
void kwsfree(kwset_t kws ) ;
#line 180 "../lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 92 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
kwset_t kwsalloc(char const   *trans___0 ) 
{ 
  struct kwset *kwset___1 ;
  void *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 97
  tmp = xmalloc(sizeof(struct kwset ));
#line 97
  kwset___1 = (struct kwset *)tmp;
  }
#line 98
  if (! kwset___1) {
#line 99
    return ((kwset_t )((void *)0));
  }
  {
#line 101
  _obstack_begin(& kwset___1->obstack, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
#line 102
  kwset___1->words = (ptrdiff_t )0;
#line 104
  __h = & kwset___1->obstack;
#line 104
  __o = __h;
#line 104
  __len = (int )sizeof(struct trie );
  }
#line 104
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 104
    _obstack_newchunk(__o, __len);
    }
  }
#line 104
  __o->next_free += __len;
#line 104
  __o1 = __h;
#line 104
  __value = (void *)__o1->object_base;
#line 104
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 104
    __o1->maybe_empty_object = 1U;
  }
#line 104
  if (sizeof(long ) < sizeof(void *)) {
#line 104
    tmp___0 = __o1->object_base;
  } else {
#line 104
    tmp___0 = (char *)0;
  }
#line 104
  if (sizeof(long ) < sizeof(void *)) {
#line 104
    tmp___1 = __o1->object_base;
  } else {
#line 104
    tmp___1 = (char *)0;
  }
#line 104
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 104
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 104
    __o1->next_free = __o1->chunk_limit;
  }
#line 104
  __o1->object_base = __o1->next_free;
#line 104
  kwset___1->trie = (struct trie *)__value;
#line 105
  if (! kwset___1->trie) {
    {
#line 107
    kwsfree(kwset___1);
    }
#line 108
    return ((kwset_t )((void *)0));
  }
#line 110
  (kwset___1->trie)->accepting = (size_t )0;
#line 111
  (kwset___1->trie)->links = (struct tree *)((void *)0);
#line 112
  (kwset___1->trie)->parent = (struct trie *)((void *)0);
#line 113
  (kwset___1->trie)->next = (struct trie *)((void *)0);
#line 114
  (kwset___1->trie)->fail = (struct trie *)((void *)0);
#line 115
  (kwset___1->trie)->depth = 0;
#line 116
  (kwset___1->trie)->shift = 0;
#line 117
  kwset___1->mind = 2147483647;
#line 118
  kwset___1->maxd = -1;
#line 119
  kwset___1->target = (char *)((void *)0);
#line 120
  kwset___1->trans = trans___0;
#line 122
  return (kwset___1);
}
}
#line 131 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
char const   *kwsincr(kwset_t kws , char const   *text , size_t len ) 
{ 
  struct kwset *kwset___1 ;
  struct trie *trie ;
  unsigned char label___0 ;
  struct tree *kwset_link ;
  int depth___0 ;
  struct tree *links[12] ;
  enum __anonenum_dirs_744895363 dirs[12] ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o___1 ;
  void *__obj ;
  char *tmp___7 ;
  char *tmp___8 ;
  char tmp___9 ;
  char tmp___10 ;
  size_t tmp___11 ;

  {
#line 143
  kwset___1 = kws;
#line 144
  trie = kwset___1->trie;
#line 145
  text += len;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    tmp___11 = len;
#line 149
    len --;
#line 149
    if (! tmp___11) {
#line 149
      goto while_break;
    }
#line 151
    if (kwset___1->trans) {
      {
#line 151
      text --;
#line 151
      tmp = to_uchar((char )*text);
#line 151
      label___0 = (unsigned char )*(kwset___1->trans + tmp);
      }
    } else {
#line 151
      text --;
#line 151
      label___0 = (unsigned char )*text;
    }
#line 156
    kwset_link = trie->links;
#line 157
    links[0] = (struct tree *)(& trie->links);
#line 158
    dirs[0] = (enum __anonenum_dirs_744895363 )0;
#line 159
    depth___0 = 1;
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 161
      if (kwset_link) {
#line 161
        if (! ((int )label___0 != (int )kwset_link->label)) {
#line 161
          goto while_break___0;
        }
      } else {
#line 161
        goto while_break___0;
      }
#line 163
      links[depth___0] = kwset_link;
#line 164
      if ((int )label___0 < (int )kwset_link->label) {
#line 165
        tmp___0 = depth___0;
#line 165
        depth___0 ++;
#line 165
        dirs[tmp___0] = (enum __anonenum_dirs_744895363 )0;
#line 165
        kwset_link = kwset_link->llink;
      } else {
#line 167
        tmp___1 = depth___0;
#line 167
        depth___0 ++;
#line 167
        dirs[tmp___1] = (enum __anonenum_dirs_744895363 )1;
#line 167
        kwset_link = kwset_link->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    if (! kwset_link) {
#line 175
      __h = & kwset___1->obstack;
#line 175
      __o = __h;
#line 175
      __len = (int )sizeof(struct tree );
#line 175
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
#line 175
        _obstack_newchunk(__o, __len);
        }
      }
#line 175
      __o->next_free += __len;
#line 175
      __o1 = __h;
#line 175
      __value = (void *)__o1->object_base;
#line 175
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 175
        __o1->maybe_empty_object = 1U;
      }
#line 175
      if (sizeof(long ) < sizeof(void *)) {
#line 175
        tmp___2 = __o1->object_base;
      } else {
#line 175
        tmp___2 = (char *)0;
      }
#line 175
      if (sizeof(long ) < sizeof(void *)) {
#line 175
        tmp___3 = __o1->object_base;
      } else {
#line 175
        tmp___3 = (char *)0;
      }
#line 175
      __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 175
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 175
        __o1->next_free = __o1->chunk_limit;
      }
#line 175
      __o1->object_base = __o1->next_free;
#line 175
      kwset_link = (struct tree *)__value;
#line 177
      if (! kwset_link) {
        {
#line 178
        tmp___4 = gettext("memory exhausted");
        }
#line 178
        return ((char const   *)tmp___4);
      }
#line 179
      kwset_link->llink = (struct tree *)((void *)0);
#line 180
      kwset_link->rlink = (struct tree *)((void *)0);
#line 181
      __h___0 = & kwset___1->obstack;
#line 181
      __o___0 = __h___0;
#line 181
      __len___0 = (int )sizeof(struct trie );
#line 181
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
#line 181
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 181
      __o___0->next_free += __len___0;
#line 181
      __o1___0 = __h___0;
#line 181
      __value___0 = (void *)__o1___0->object_base;
#line 181
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 181
        __o1___0->maybe_empty_object = 1U;
      }
#line 181
      if (sizeof(long ) < sizeof(void *)) {
#line 181
        tmp___5 = __o1___0->object_base;
      } else {
#line 181
        tmp___5 = (char *)0;
      }
#line 181
      if (sizeof(long ) < sizeof(void *)) {
#line 181
        tmp___6 = __o1___0->object_base;
      } else {
#line 181
        tmp___6 = (char *)0;
      }
#line 181
      __o1___0->next_free = tmp___5 + (((__o1___0->next_free - tmp___6) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 181
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 181
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 181
      __o1___0->object_base = __o1___0->next_free;
#line 181
      kwset_link->trie = (struct trie *)__value___0;
#line 183
      if (! kwset_link->trie) {
#line 185
        __o___1 = & kwset___1->obstack;
#line 185
        __obj = (void *)kwset_link;
#line 185
        if ((unsigned long )__obj > (unsigned long )((void *)__o___1->chunk)) {
#line 185
          if ((unsigned long )__obj < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 185
            tmp___7 = (char *)__obj;
#line 185
            __o___1->object_base = tmp___7;
#line 185
            __o___1->next_free = tmp___7;
          } else {
            {
#line 185
            obstack_free(__o___1, __obj);
            }
          }
        } else {
          {
#line 185
          obstack_free(__o___1, __obj);
          }
        }
        {
#line 186
        tmp___8 = gettext("memory exhausted");
        }
#line 186
        return ((char const   *)tmp___8);
      }
#line 188
      (kwset_link->trie)->accepting = (size_t )0;
#line 189
      (kwset_link->trie)->links = (struct tree *)((void *)0);
#line 190
      (kwset_link->trie)->parent = trie;
#line 191
      (kwset_link->trie)->next = (struct trie *)((void *)0);
#line 192
      (kwset_link->trie)->fail = (struct trie *)((void *)0);
#line 193
      (kwset_link->trie)->depth = trie->depth + 1;
#line 194
      (kwset_link->trie)->shift = 0;
#line 195
      kwset_link->label = label___0;
#line 196
      kwset_link->balance = (char)0;
#line 199
      depth___0 --;
#line 199
      if ((unsigned int )dirs[depth___0] == 0U) {
#line 200
        (links[depth___0])->llink = kwset_link;
      } else {
#line 202
        (links[depth___0])->rlink = kwset_link;
      }
      {
#line 205
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 205
        if (depth___0) {
#line 205
          if (! (! (links[depth___0])->balance)) {
#line 205
            goto while_break___1;
          }
        } else {
#line 205
          goto while_break___1;
        }
#line 207
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 208
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
        } else {
#line 210
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
        }
#line 211
        depth___0 --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 215
      if (depth___0) {
#line 215
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 215
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
#line 215
          if ((links[depth___0])->balance) {
#line 215
            goto _L;
          } else {
#line 215
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 215
        if ((unsigned int )dirs[depth___0] == 1U) {
#line 215
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
#line 215
          if ((links[depth___0])->balance) {
            _L: /* CIL Label */ 
            {
#line 220
            if ((int )(links[depth___0])->balance == -2) {
#line 220
              goto case_neg_2;
            }
#line 240
            if ((int )(links[depth___0])->balance == 2) {
#line 240
              goto case_2;
            }
#line 260
            goto switch_default___1;
            case_neg_2: /* CIL Label */ 
            {
#line 223
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 223
              goto case_0;
            }
#line 228
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 228
              goto case_1;
            }
#line 236
            goto switch_default;
            case_0: /* CIL Label */ 
#line 224
            r = links[depth___0];
#line 224
            t = r->llink;
#line 224
            rl = t->rlink;
#line 225
            t->rlink = r;
#line 225
            r->llink = rl;
#line 226
            tmp___9 = (char)0;
#line 226
            r->balance = tmp___9;
#line 226
            t->balance = tmp___9;
#line 227
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 229
            r = links[depth___0];
#line 229
            l = r->llink;
#line 229
            t = l->rlink;
#line 230
            rl = t->rlink;
#line 230
            lr = t->llink;
#line 231
            t->llink = l;
#line 231
            l->rlink = lr;
#line 231
            t->rlink = r;
#line 231
            r->llink = rl;
#line 232
            if ((int )t->balance != 1) {
#line 232
              l->balance = (char)0;
            } else {
#line 232
              l->balance = (char)-1;
            }
#line 233
            if ((int )t->balance != -1) {
#line 233
              r->balance = (char)0;
            } else {
#line 233
              r->balance = (char)1;
            }
#line 234
            t->balance = (char)0;
#line 235
            goto switch_break___0;
            switch_default: /* CIL Label */ 
            {
#line 237
            abort();
            }
            switch_break___0: /* CIL Label */ ;
            }
#line 239
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 243
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 243
              goto case_1___0;
            }
#line 248
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 248
              goto case_0___0;
            }
#line 256
            goto switch_default___0;
            case_1___0: /* CIL Label */ 
#line 244
            l = links[depth___0];
#line 244
            t = l->rlink;
#line 244
            lr = t->llink;
#line 245
            t->llink = l;
#line 245
            l->rlink = lr;
#line 246
            tmp___10 = (char)0;
#line 246
            l->balance = tmp___10;
#line 246
            t->balance = tmp___10;
#line 247
            goto switch_break___1;
            case_0___0: /* CIL Label */ 
#line 249
            l = links[depth___0];
#line 249
            r = l->rlink;
#line 249
            t = r->llink;
#line 250
            lr = t->llink;
#line 250
            rl = t->rlink;
#line 251
            t->llink = l;
#line 251
            l->rlink = lr;
#line 251
            t->rlink = r;
#line 251
            r->llink = rl;
#line 252
            if ((int )t->balance != 1) {
#line 252
              l->balance = (char)0;
            } else {
#line 252
              l->balance = (char)-1;
            }
#line 253
            if ((int )t->balance != -1) {
#line 253
              r->balance = (char)0;
            } else {
#line 253
              r->balance = (char)1;
            }
#line 254
            t->balance = (char)0;
#line 255
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
            {
#line 257
            abort();
            }
            switch_break___1: /* CIL Label */ ;
            }
#line 259
            goto switch_break;
            switch_default___1: /* CIL Label */ 
            {
#line 261
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
#line 264
            if ((unsigned int )dirs[depth___0 - 1] == 0U) {
#line 265
              (links[depth___0 - 1])->llink = t;
            } else {
#line 267
              (links[depth___0 - 1])->rlink = t;
            }
          }
        }
      }
    }
#line 271
    trie = kwset_link->trie;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (! trie->accepting) {
#line 277
    trie->accepting = (size_t )(1L + 2L * kwset___1->words);
  }
#line 278
  (kwset___1->words) ++;
#line 281
  if (trie->depth < kwset___1->mind) {
#line 282
    kwset___1->mind = trie->depth;
  }
#line 283
  if (trie->depth > kwset___1->maxd) {
#line 284
    kwset___1->maxd = trie->depth;
  }
#line 286
  return ((char const   *)((void *)0));
}
}
#line 291 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static void enqueue(struct tree *tree , struct trie **last ) 
{ 
  struct trie *tmp ;

  {
#line 294
  if (! tree) {
#line 295
    return;
  }
  {
#line 296
  enqueue(tree->llink, last);
#line 297
  enqueue(tree->rlink, last);
#line 298
  tmp = tree->trie;
#line 298
  (*last)->next = tmp;
#line 298
  *last = tmp;
  }
#line 299
  return;
}
}
#line 304 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static void treefails(struct tree  const  *tree , struct trie  const  *fail , struct trie *recourse ) 
{ 
  struct tree *kwset_link ;

  {
#line 310
  if (! tree) {
#line 311
    return;
  }
  {
#line 313
  treefails((struct tree  const  *)tree->llink, fail, recourse);
#line 314
  treefails((struct tree  const  *)tree->rlink, fail, recourse);
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! fail) {
#line 318
      goto while_break;
    }
#line 320
    kwset_link = (struct tree *)fail->links;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (kwset_link) {
#line 321
        if (! ((int const   )tree->label != (int const   )kwset_link->label)) {
#line 321
          goto while_break___0;
        }
      } else {
#line 321
        goto while_break___0;
      }
#line 322
      if ((int const   )tree->label < (int const   )kwset_link->label) {
#line 323
        kwset_link = kwset_link->llink;
      } else {
#line 325
        kwset_link = kwset_link->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 326
    if (kwset_link) {
#line 328
      (tree->trie)->fail = kwset_link->trie;
#line 329
      return;
    }
#line 331
    fail = (struct trie  const  *)fail->fail;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  (tree->trie)->fail = recourse;
#line 335
  return;
}
}
#line 339 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static void treedelta(struct tree  const  *tree , unsigned int depth___0 , unsigned char *delta ) 
{ 


  {
#line 344
  if (! tree) {
#line 345
    return;
  }
  {
#line 346
  treedelta((struct tree  const  *)tree->llink, depth___0, delta);
#line 347
  treedelta((struct tree  const  *)tree->rlink, depth___0, delta);
  }
#line 348
  if (depth___0 < (unsigned int )*(delta + tree->label)) {
#line 349
    *(delta + tree->label) = (unsigned char )depth___0;
  }
#line 350
  return;
}
}
#line 353 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static int __attribute__((__pure__))  hasevery(struct tree  const  *a , struct tree  const  *b ) 
{ 
  int __attribute__((__pure__))  tmp ;
  int __attribute__((__pure__))  tmp___0 ;

  {
#line 356
  if (! b) {
#line 357
    return ((int __attribute__((__pure__))  )1);
  }
  {
#line 358
  tmp = hasevery(a, (struct tree  const  *)b->llink);
  }
#line 358
  if (! tmp) {
#line 359
    return ((int __attribute__((__pure__))  )0);
  }
  {
#line 360
  tmp___0 = hasevery(a, (struct tree  const  *)b->rlink);
  }
#line 360
  if (! tmp___0) {
#line 361
    return ((int __attribute__((__pure__))  )0);
  }
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (a) {
#line 362
      if (! ((int const   )b->label != (int const   )a->label)) {
#line 362
        goto while_break;
      }
    } else {
#line 362
      goto while_break;
    }
#line 363
    if ((int const   )b->label < (int const   )a->label) {
#line 364
      a = (struct tree  const  *)a->llink;
    } else {
#line 366
      a = (struct tree  const  *)a->rlink;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return ((int __attribute__((__pure__))  )(! (! a)));
}
}
#line 372 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static void treenext(struct tree  const  *tree , struct trie **next ) 
{ 


  {
#line 375
  if (! tree) {
#line 376
    return;
  }
  {
#line 377
  treenext((struct tree  const  *)tree->llink, next);
#line 378
  treenext((struct tree  const  *)tree->rlink, next);
#line 379
  *(next + tree->label) = (struct trie *)tree->trie;
  }
#line 380
  return;
}
}
#line 384 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
char const   *kwsprep(kwset_t kws ) 
{ 
  struct kwset *kwset___1 ;
  int i ;
  struct trie *curr ;
  char const   *trans___0 ;
  unsigned char delta[256] ;
  int tmp ;
  char c ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned char tmp___3 ;
  struct trie *fail ;
  struct trie *last ;
  struct trie *next[256] ;
  int __attribute__((__pure__))  tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;

  {
#line 393
  kwset___1 = kws;
#line 398
  if (kwset___1->mind < 255) {
#line 398
    tmp = kwset___1->mind;
  } else {
#line 398
    tmp = 255;
  }
  {
#line 398
  memset((void *)(delta), tmp, (size_t )256);
  }
#line 402
  if (kwset___1->words == 1L) {
#line 402
    if ((unsigned long )kwset___1->trans == (unsigned long )((void *)0)) {
#line 407
      __h = & kwset___1->obstack;
#line 407
      __o = __h;
#line 407
      __len = kwset___1->mind;
#line 407
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
#line 407
        _obstack_newchunk(__o, __len);
        }
      }
#line 407
      __o->next_free += __len;
#line 407
      __o1 = __h;
#line 407
      __value = (void *)__o1->object_base;
#line 407
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 407
        __o1->maybe_empty_object = 1U;
      }
#line 407
      if (sizeof(long ) < sizeof(void *)) {
#line 407
        tmp___0 = __o1->object_base;
      } else {
#line 407
        tmp___0 = (char *)0;
      }
#line 407
      if (sizeof(long ) < sizeof(void *)) {
#line 407
        tmp___1 = __o1->object_base;
      } else {
#line 407
        tmp___1 = (char *)0;
      }
#line 407
      __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 407
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 407
        __o1->next_free = __o1->chunk_limit;
      }
#line 407
      __o1->object_base = __o1->next_free;
#line 407
      kwset___1->target = (char *)__value;
#line 408
      if (! kwset___1->target) {
        {
#line 409
        tmp___2 = gettext("memory exhausted");
        }
#line 409
        return ((char const   *)tmp___2);
      }
#line 410
      i = kwset___1->mind - 1;
#line 410
      curr = kwset___1->trie;
      {
#line 410
      while (1) {
        while_continue: /* CIL Label */ ;
#line 410
        if (! (i >= 0)) {
#line 410
          goto while_break;
        }
#line 412
        *(kwset___1->target + i) = (char )(curr->links)->label;
#line 413
        curr = (curr->links)->trie;
#line 410
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 416
      i = 0;
      {
#line 416
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 416
        if (! (i < kwset___1->mind)) {
#line 416
          goto while_break___0;
        }
        {
#line 417
        tmp___3 = to_uchar(*(kwset___1->target + i));
#line 417
        delta[tmp___3] = (unsigned char )(kwset___1->mind - (i + 1));
#line 416
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 420
      c = *(kwset___1->target + (kwset___1->mind - 1));
#line 421
      i = kwset___1->mind - 2;
      {
#line 421
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 421
        if (! (i >= 0)) {
#line 421
          goto while_break___1;
        }
#line 422
        if ((int )*(kwset___1->target + i) == (int )c) {
#line 423
          goto while_break___1;
        }
#line 421
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 424
      kwset___1->mind2 = kwset___1->mind - (i + 1);
    } else {
#line 402
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 433
    last = kwset___1->trie;
#line 433
    curr = last;
    {
#line 433
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 433
      if (! curr) {
#line 433
        goto while_break___2;
      }
      {
#line 436
      enqueue(curr->links, & last);
#line 438
      curr->shift = kwset___1->mind;
#line 439
      curr->maxshift = kwset___1->mind;
#line 442
      treedelta((struct tree  const  *)curr->links, (unsigned int )curr->depth, delta);
#line 445
      treefails((struct tree  const  *)curr->links, (struct trie  const  *)curr->fail,
                kwset___1->trie);
#line 449
      fail = curr->fail;
      }
      {
#line 449
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 449
        if (! fail) {
#line 449
          goto while_break___3;
        }
        {
#line 454
        tmp___4 = hasevery((struct tree  const  *)fail->links, (struct tree  const  *)curr->links);
        }
#line 454
        if (! tmp___4) {
#line 455
          if (curr->depth - fail->depth < fail->shift) {
#line 456
            fail->shift = curr->depth - fail->depth;
          }
        }
#line 461
        if (curr->accepting) {
#line 461
          if (fail->maxshift > curr->depth - fail->depth) {
#line 462
            fail->maxshift = curr->depth - fail->depth;
          }
        }
#line 449
        fail = fail->fail;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 433
      curr = curr->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 468
    curr = (kwset___1->trie)->next;
    {
#line 468
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 468
      if (! curr) {
#line 468
        goto while_break___4;
      }
#line 470
      if (curr->maxshift > (curr->parent)->maxshift) {
#line 471
        curr->maxshift = (curr->parent)->maxshift;
      }
#line 472
      if (curr->shift > curr->maxshift) {
#line 473
        curr->shift = curr->maxshift;
      }
#line 468
      curr = curr->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 478
    i = 0;
    {
#line 478
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 478
      if (! (i < 256)) {
#line 478
        goto while_break___5;
      }
#line 479
      next[i] = (struct trie *)((void *)0);
#line 478
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 480
    treenext((struct tree  const  *)(kwset___1->trie)->links, next);
#line 482
    trans___0 = kwset___1->trans;
    }
#line 482
    if ((unsigned long )trans___0 != (unsigned long )((void *)0)) {
#line 483
      i = 0;
      {
#line 483
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 483
        if (! (i < 256)) {
#line 483
          goto while_break___6;
        }
        {
#line 484
        tmp___5 = to_uchar((char )*(trans___0 + i));
#line 484
        kwset___1->next[i] = next[tmp___5];
#line 483
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
      {
#line 486
      memcpy((void */* __restrict  */)(kwset___1->next), (void const   */* __restrict  */)(next),
             256UL * sizeof(struct trie *));
      }
    }
  }
#line 490
  trans___0 = kwset___1->trans;
#line 490
  if ((unsigned long )trans___0 != (unsigned long )((void *)0)) {
#line 491
    i = 0;
    {
#line 491
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 491
      if (! (i < 256)) {
#line 491
        goto while_break___7;
      }
      {
#line 492
      tmp___6 = to_uchar((char )*(trans___0 + i));
#line 492
      kwset___1->delta[i] = delta[tmp___6];
#line 491
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 494
    memcpy((void */* __restrict  */)(kwset___1->delta), (void const   */* __restrict  */)(delta),
           (size_t )256);
    }
  }
#line 496
  return ((char const   *)((void *)0));
}
}
#line 500 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static size_t __attribute__((__pure__))  bmexec(kwset_t kws , char const   *text ,
                                                size_t size ) 
{ 
  struct kwset  const  *kwset___1 ;
  unsigned char const   *d1 ;
  char const   *ep ;
  char const   *sp ;
  char const   *tp ;
  int d ;
  int gc ;
  int i ;
  int len ;
  int md2 ;
  void *tmp ;
  long tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned char tmp___19 ;

  {
#line 508
  kwset___1 = (struct kwset  const  *)kws;
#line 509
  len = (int )kwset___1->mind;
#line 511
  if (len == 0) {
#line 512
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 513
  if ((size_t )len > size) {
#line 514
    return ((size_t __attribute__((__pure__))  )-1);
  }
#line 515
  if (len == 1) {
    {
#line 517
    tmp = memchr((void const   *)text, (int )*(kwset___1->target + 0), size);
#line 517
    tp = (char const   *)tmp;
    }
#line 518
    if (tp) {
#line 518
      tmp___0 = tp - text;
    } else {
#line 518
      tmp___0 = -1L;
    }
#line 518
    return ((size_t __attribute__((__pure__))  )tmp___0);
  }
  {
#line 521
  d1 = (unsigned char const   *)(kwset___1->delta);
#line 522
  sp = (char const   *)(kwset___1->target + len);
#line 523
  tmp___1 = to_uchar((char )*(sp + -2));
#line 523
  gc = (int )tmp___1;
#line 524
  md2 = (int )kwset___1->mind2;
#line 525
  tp = text + len;
  }
#line 528
  if (size > (size_t )(12 * len)) {
#line 530
    ep = (text + size) - 11 * len;
    {
#line 530
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 532
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 532
        if (! ((unsigned long )tp <= (unsigned long )ep)) {
#line 532
          goto while_break___0;
        }
        {
#line 534
        tmp___2 = to_uchar((char )*(tp + -1));
#line 534
        d = (int )*(d1 + tmp___2);
#line 534
        tp += d;
#line 535
        tmp___3 = to_uchar((char )*(tp + -1));
#line 535
        d = (int )*(d1 + tmp___3);
#line 535
        tp += d;
        }
#line 536
        if (d == 0) {
#line 537
          goto found;
        }
        {
#line 538
        tmp___4 = to_uchar((char )*(tp + -1));
#line 538
        d = (int )*(d1 + tmp___4);
#line 538
        tp += d;
#line 539
        tmp___5 = to_uchar((char )*(tp + -1));
#line 539
        d = (int )*(d1 + tmp___5);
#line 539
        tp += d;
#line 540
        tmp___6 = to_uchar((char )*(tp + -1));
#line 540
        d = (int )*(d1 + tmp___6);
#line 540
        tp += d;
        }
#line 541
        if (d == 0) {
#line 542
          goto found;
        }
        {
#line 543
        tmp___7 = to_uchar((char )*(tp + -1));
#line 543
        d = (int )*(d1 + tmp___7);
#line 543
        tp += d;
#line 544
        tmp___8 = to_uchar((char )*(tp + -1));
#line 544
        d = (int )*(d1 + tmp___8);
#line 544
        tp += d;
#line 545
        tmp___9 = to_uchar((char )*(tp + -1));
#line 545
        d = (int )*(d1 + tmp___9);
#line 545
        tp += d;
        }
#line 546
        if (d == 0) {
#line 547
          goto found;
        }
        {
#line 548
        tmp___10 = to_uchar((char )*(tp + -1));
#line 548
        d = (int )*(d1 + tmp___10);
#line 548
        tp += d;
#line 549
        tmp___11 = to_uchar((char )*(tp + -1));
#line 549
        d = (int )*(d1 + tmp___11);
#line 549
        tp += d;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 551
      goto while_break;
      found: 
      {
#line 553
      tmp___14 = to_uchar((char )*(tp + -2));
      }
#line 553
      if ((int )tmp___14 == gc) {
#line 555
        i = 3;
        {
#line 555
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 555
          if (i <= len) {
            {
#line 555
            tmp___12 = to_uchar((char )*(tp + - i));
#line 555
            tmp___13 = to_uchar((char )*(sp + - i));
            }
#line 555
            if (! ((int )tmp___12 == (int )tmp___13)) {
#line 555
              goto while_break___1;
            }
          } else {
#line 555
            goto while_break___1;
          }
#line 555
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 557
        if (i > len) {
#line 558
          return ((size_t __attribute__((__pure__))  )((tp - len) - text));
        }
      }
#line 560
      tp += md2;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 565
  ep = text + size;
#line 566
  tmp___15 = to_uchar((char )*(tp + -1));
#line 566
  d = (int )*(d1 + tmp___15);
  }
  {
#line 567
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 567
    if (! ((long )d <= ep - tp)) {
#line 567
      goto while_break___2;
    }
    {
#line 569
    tp += d;
#line 569
    tmp___16 = to_uchar((char )*(tp + -1));
#line 569
    d = (int )*(d1 + tmp___16);
    }
#line 570
    if (d != 0) {
#line 571
      goto while_continue___2;
    }
    {
#line 572
    tmp___19 = to_uchar((char )*(tp + -2));
    }
#line 572
    if ((int )tmp___19 == gc) {
#line 574
      i = 3;
      {
#line 574
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 574
        if (i <= len) {
          {
#line 574
          tmp___17 = to_uchar((char )*(tp + - i));
#line 574
          tmp___18 = to_uchar((char )*(sp + - i));
          }
#line 574
          if (! ((int )tmp___17 == (int )tmp___18)) {
#line 574
            goto while_break___3;
          }
        } else {
#line 574
          goto while_break___3;
        }
#line 574
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 576
      if (i > len) {
#line 577
        return ((size_t __attribute__((__pure__))  )((tp - len) - text));
      }
    }
#line 579
    d = md2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 582
  return ((size_t __attribute__((__pure__))  )-1);
}
}
#line 586 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
static size_t ( __attribute__((__nonnull__(4))) cwexec)(kwset_t kws , char const   *text ,
                                                        size_t len , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset  const  *kwset___1 ;
  struct trie * const  *next ;
  struct trie  const  *trie ;
  struct trie  const  *accept ;
  char const   *beg ;
  char const   *lim ;
  char const   *mch ;
  char const   *lmch ;
  unsigned char c ;
  unsigned char const   *delta ;
  int d ;
  char const   *end ;
  char const   *qlim ;
  struct tree  const  *tree ;
  char const   *trans___0 ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 606
  kwset___1 = (struct kwset  const  *)kws;
#line 607
  if (len < (size_t )kwset___1->mind) {
#line 608
    return ((size_t )-1);
  }
#line 609
  next = (struct trie * const  *)(kwset___1->next);
#line 610
  delta = (unsigned char const   *)(kwset___1->delta);
#line 611
  trans___0 = (char const   *)kwset___1->trans;
#line 612
  lim = text + len;
#line 613
  end = text;
#line 614
  d = (int )kwset___1->mind;
#line 614
  if (d != 0) {
#line 615
    mch = (char const   *)((void *)0);
  } else {
#line 618
    mch = text;
#line 618
    accept = (struct trie  const  *)kwset___1->trie;
#line 619
    goto match;
  }
#line 622
  if (len >= (size_t )(4 * (int )kwset___1->mind)) {
#line 623
    qlim = lim - 4 * (int )kwset___1->mind;
  } else {
#line 625
    qlim = (char const   *)((void *)0);
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (lim - end >= (long )d)) {
#line 627
      goto while_break;
    }
#line 629
    if (qlim) {
#line 629
      if ((unsigned long )end <= (unsigned long )qlim) {
#line 631
        end += d - 1;
        {
#line 632
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 632
          c = (unsigned char )*end;
#line 632
          d = (int )*(delta + c);
#line 632
          if (d) {
#line 632
            if (! ((unsigned long )end < (unsigned long )qlim)) {
#line 632
              goto while_break___0;
            }
          } else {
#line 632
            goto while_break___0;
          }
          {
#line 634
          end += d;
#line 635
          tmp = to_uchar((char )*end);
#line 635
          end += (int const   )*(delta + tmp);
#line 636
          tmp___0 = to_uchar((char )*end);
#line 636
          end += (int const   )*(delta + tmp___0);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 638
        end ++;
      } else {
#line 641
        end += d;
#line 641
        c = (unsigned char )*(end + -1);
#line 641
        d = (int )*(delta + c);
      }
    } else {
#line 641
      end += d;
#line 641
      c = (unsigned char )*(end + -1);
#line 641
      d = (int )*(delta + c);
    }
#line 642
    if (d) {
#line 643
      goto while_continue;
    }
#line 644
    beg = end - 1;
#line 645
    trie = (struct trie  const  *)*(next + c);
#line 646
    if (trie->accepting) {
#line 648
      mch = beg;
#line 649
      accept = trie;
    }
#line 651
    d = (int )trie->shift;
    {
#line 652
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 652
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 652
        goto while_break___1;
      }
#line 654
      if (trans___0) {
        {
#line 654
        beg --;
#line 654
        tmp___1 = to_uchar((char )*beg);
#line 654
        c = (unsigned char )*(trans___0 + tmp___1);
        }
      } else {
#line 654
        beg --;
#line 654
        c = (unsigned char )*beg;
      }
#line 655
      tree = (struct tree  const  *)trie->links;
      {
#line 656
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 656
        if (tree) {
#line 656
          if (! ((int )c != (int )tree->label)) {
#line 656
            goto while_break___2;
          }
        } else {
#line 656
          goto while_break___2;
        }
#line 657
        if ((int )c < (int )tree->label) {
#line 658
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 660
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 661
      if (tree) {
#line 663
        trie = (struct trie  const  *)tree->trie;
#line 664
        if (trie->accepting) {
#line 666
          mch = beg;
#line 667
          accept = trie;
        }
      } else {
#line 671
        goto while_break___1;
      }
#line 672
      d = (int )trie->shift;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 674
    if (mch) {
#line 675
      goto match;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return ((size_t )-1);
  match: 
#line 683
  if (lim - mch > (long )kwset___1->maxd) {
#line 684
    lim = mch + kwset___1->maxd;
  }
#line 685
  lmch = (char const   *)0;
#line 686
  d = 1;
  {
#line 687
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 687
    if (! (lim - end >= (long )d)) {
#line 687
      goto while_break___3;
    }
#line 689
    end += d;
#line 689
    c = (unsigned char )*(end + -1);
#line 689
    d = (int )*(delta + c);
#line 689
    if (d != 0) {
#line 690
      goto while_continue___3;
    }
#line 691
    beg = end - 1;
#line 692
    trie = (struct trie  const  *)*(next + c);
#line 692
    if (! trie) {
#line 694
      d = 1;
#line 695
      goto while_continue___3;
    }
#line 697
    if (trie->accepting) {
#line 697
      if ((unsigned long )beg <= (unsigned long )mch) {
#line 699
        lmch = beg;
#line 700
        accept = trie;
      }
    }
#line 702
    d = (int )trie->shift;
    {
#line 703
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 703
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 703
        goto while_break___4;
      }
#line 705
      if (trans___0) {
        {
#line 705
        beg --;
#line 705
        tmp___2 = to_uchar((char )*beg);
#line 705
        c = (unsigned char )*(trans___0 + tmp___2);
        }
      } else {
#line 705
        beg --;
#line 705
        c = (unsigned char )*beg;
      }
#line 706
      tree = (struct tree  const  *)trie->links;
      {
#line 707
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 707
        if (tree) {
#line 707
          if (! ((int )c != (int )tree->label)) {
#line 707
            goto while_break___5;
          }
        } else {
#line 707
          goto while_break___5;
        }
#line 708
        if ((int )c < (int )tree->label) {
#line 709
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 711
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 712
      if (tree) {
#line 714
        trie = (struct trie  const  *)tree->trie;
#line 715
        if (trie->accepting) {
#line 715
          if ((unsigned long )beg <= (unsigned long )mch) {
#line 717
            lmch = beg;
#line 718
            accept = trie;
          }
        }
      } else {
#line 722
        goto while_break___4;
      }
#line 723
      d = (int )trie->shift;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 725
    if (lmch) {
#line 727
      mch = lmch;
#line 728
      goto match;
    }
#line 730
    if (! d) {
#line 731
      d = 1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 734
  kwsmatch->index = (size_t )(accept->accepting / 2UL);
#line 735
  kwsmatch->offset[0] = (size_t )(mch - text);
#line 736
  kwsmatch->size[0] = (size_t )accept->depth;
#line 738
  return ((size_t )(mch - text));
}
}
#line 746 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
size_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kws , char const   *text ,
                                                  size_t size , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset  const  *kwset___1 ;
  size_t ret ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tmp___0 ;

  {
#line 749
  kwset___1 = (struct kwset  const  *)kws;
#line 750
  if (kwset___1->words == 1L) {
#line 750
    if ((unsigned long )kwset___1->trans == (unsigned long )((void *)0)) {
      {
#line 752
      tmp = bmexec(kws, text, size);
#line 752
      ret = (size_t )tmp;
      }
#line 753
      if (ret != 0xffffffffffffffffUL) {
#line 755
        kwsmatch->index = (size_t )0;
#line 756
        kwsmatch->offset[0] = ret;
#line 757
        kwsmatch->size[0] = (size_t )kwset___1->mind;
      }
#line 759
      return (ret);
    } else {
      {
#line 762
      tmp___0 = cwexec(kws, text, size, kwsmatch);
      }
#line 762
      return (tmp___0);
    }
  } else {
    {
#line 762
    tmp___0 = cwexec(kws, text, size, kwsmatch);
    }
#line 762
    return (tmp___0);
  }
}
}
#line 766 "/home/khheo/project/benchmark/grep-2.18/src/kwset.c"
void kwsfree(kwset_t kws ) 
{ 
  struct kwset *kwset___1 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 771
  kwset___1 = kws;
#line 772
  __o = & kwset___1->obstack;
#line 772
  __obj = (void *)0;
#line 772
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 772
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 772
      tmp = (char *)__obj;
#line 772
      __o->object_base = tmp;
#line 772
      __o->next_free = tmp;
    } else {
      {
#line 772
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 772
    obstack_free(__o, __obj);
    }
  }
  {
#line 773
  free((void *)kws);
  }
#line 774
  return;
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
void Fcompile(char const   *pattern , size_t size ) ;
#line 58
size_t Fexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 66 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
__inline static void mb_case_map_apply(mb_len_map_t const   *map , size_t *off , size_t *len ) 
{ 
  intmax_t off_incr ;
  intmax_t len_incr ;
  size_t k ;

  {
#line 69
  if (map) {
#line 71
    off_incr = (intmax_t )0;
#line 72
    len_incr = (intmax_t )0;
#line 74
    k = (size_t )0;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (k < *off)) {
#line 74
        goto while_break;
      }
#line 75
      off_incr += (intmax_t )*(map + k);
#line 74
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 76
    k = *off;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! (k < *off + *len)) {
#line 76
        goto while_break___0;
      }
#line 77
      len_incr += (intmax_t )*(map + k);
#line 76
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    *off += (size_t )off_incr;
#line 79
    *len += (size_t )len_incr;
  }
#line 81
  return;
}
}
#line 30 "/home/khheo/project/benchmark/grep-2.18/src/kwsearch.c"
static kwset_t kwset  ;
#line 32 "/home/khheo/project/benchmark/grep-2.18/src/kwsearch.c"
void Fcompile(char const   *pattern , size_t size ) 
{ 
  char const   *err ;
  size_t psize ;
  mb_len_map_t *map ;
  char const   *pat ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char const   *beg ;
  char const   *lim ;
  char const   *end ;

  {
#line 36
  psize = size;
#line 37
  map = (mb_len_map_t *)((void *)0);
#line 38
  if (match_icase) {
    {
#line 38
    tmp___2 = __ctype_get_mb_cur_max();
    }
#line 38
    if (tmp___2 > 1UL) {
      {
#line 38
      tmp___0 = mbtolower(pattern, & psize, & map);
#line 38
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 38
      tmp___1 = pattern;
    }
  } else {
#line 38
    tmp___1 = pattern;
  }
  {
#line 38
  pat = tmp___1;
#line 42
  kwsinit(& kwset);
#line 44
  beg = pat;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    lim = beg;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      end = lim;
#line 52
      if ((unsigned long )lim >= (unsigned long )(pat + psize)) {
#line 53
        goto while_break___0;
      }
#line 54
      if ((int const   )*lim == 10) {
#line 56
        lim ++;
#line 57
        goto while_break___0;
      }
#line 49
      lim ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 68
    err = kwsincr(kwset, beg, (size_t )(end - beg));
    }
#line 68
    if ((unsigned long )err != (unsigned long )((void *)0)) {
      {
#line 69
      error(2, 0, "%s", err);
      }
    }
#line 70
    beg = lim;
#line 45
    if (! ((unsigned long )beg < (unsigned long )(pat + psize))) {
#line 45
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  err = kwsprep(kwset);
  }
#line 74
  if ((unsigned long )err != (unsigned long )((void *)0)) {
    {
#line 75
    error(2, 0, "%s", err);
    }
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/grep-2.18/src/kwsearch.c"
size_t Fexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) 
{ 
  char const   *beg ;
  char const   *try ;
  char const   *end ;
  char const   *mb_start ;
  size_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  size_t ret_val ;
  mb_len_map_t *map ;
  char *case_buf ;
  char *tmp ;
  size_t tmp___0 ;
  size_t offset ;
  size_t tmp___1 ;
  mbstate_t s ;
  size_t mb_len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  _Bool tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  void *tmp___11 ;
  size_t off ;

  {
  {
#line 84
  eol = (char )eolbyte;
#line 87
  map = (mb_len_map_t *)((void *)0);
#line 89
  tmp___0 = __ctype_get_mb_cur_max();
  }
#line 89
  if (tmp___0 > 1UL) {
#line 91
    if (match_icase) {
      {
#line 93
      tmp = mbtolower(buf, & size, & map);
#line 93
      case_buf = tmp;
      }
#line 94
      if (start_ptr) {
#line 95
        start_ptr = (char const   *)(case_buf + (start_ptr - buf));
      }
#line 96
      buf = (char const   *)case_buf;
    }
  }
#line 100
  if (start_ptr) {
#line 100
    beg = start_ptr;
  } else {
#line 100
    beg = buf;
  }
#line 100
  mb_start = beg;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
#line 100
      goto while_break;
    }
    {
#line 102
    tmp___1 = kwsexec(kwset, beg, (size_t )((buf + size) - beg), & kwsmatch);
#line 102
    offset = tmp___1;
    }
#line 103
    if (offset == 0xffffffffffffffffUL) {
#line 104
      goto failure;
    }
    {
#line 105
    len = kwsmatch.size[0];
#line 106
    tmp___3 = __ctype_get_mb_cur_max();
    }
#line 106
    if (tmp___3 > 1UL) {
      {
#line 106
      tmp___4 = is_mb_middle(& mb_start, beg + offset, buf + size, len);
      }
#line 106
      if (tmp___4) {
        {
#line 112
        memset((void *)(& s), 0, sizeof(s));
#line 113
        tmp___2 = mbrlen((char const   */* __restrict  */)mb_start, (size_t )((buf + size) - (beg + offset)),
                         (mbstate_t */* __restrict  */)(& s));
#line 113
        mb_len = tmp___2;
        }
#line 114
        if (mb_len == 0xfffffffffffffffeUL) {
#line 115
          goto failure;
        } else
#line 114
        if (mb_len == 0xffffffffffffffffUL) {
#line 115
          goto failure;
        }
#line 116
        beg = (mb_start + mb_len) - 1;
#line 117
        goto __Cont;
      }
    }
#line 119
    beg += offset;
#line 120
    if (start_ptr) {
#line 120
      if (! match_words) {
#line 121
        goto success_in_beg_and_len;
      }
    }
#line 122
    if (match_lines) {
#line 124
      if ((unsigned long )beg > (unsigned long )buf) {
#line 124
        if ((int const   )*(beg + -1) != (int const   )eol) {
#line 125
          goto __Cont;
        }
      }
#line 126
      if ((unsigned long )(beg + len) < (unsigned long )(buf + size)) {
#line 126
        if ((int const   )*(beg + len) != (int const   )eol) {
#line 127
          goto __Cont;
        }
      }
#line 128
      goto success;
    } else
#line 130
    if (match_words) {
#line 131
      try = beg;
      {
#line 131
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 133
        if ((unsigned long )try > (unsigned long )buf) {
          {
#line 133
          tmp___5 = __ctype_b_loc();
#line 133
          tmp___6 = to_uchar((char )*(try + -1));
          }
#line 133
          if ((int const   )*(*tmp___5 + (int )tmp___6) & 8) {
#line 134
            goto while_break___0;
          } else {
            {
#line 133
            tmp___7 = to_uchar((char )*(try + -1));
            }
#line 133
            if ((int )tmp___7 == 95) {
#line 134
              goto while_break___0;
            }
          }
        }
#line 135
        if ((unsigned long )(try + len) < (unsigned long )(buf + size)) {
          {
#line 135
          tmp___8 = __ctype_b_loc();
#line 135
          tmp___9 = to_uchar((char )*(try + len));
          }
#line 135
          if ((int const   )*(*tmp___8 + (int )tmp___9) & 8) {
#line 135
            goto _L___0;
          } else {
            {
#line 135
            tmp___10 = to_uchar((char )*(try + len));
            }
#line 135
            if ((int )tmp___10 == 95) {
              _L___0: /* CIL Label */ 
#line 137
              if (! len) {
#line 138
                goto while_break___0;
              }
              {
#line 139
              len --;
#line 139
              offset = kwsexec(kwset, beg, len, & kwsmatch);
              }
#line 140
              if (offset == 0xffffffffffffffffUL) {
#line 141
                goto while_break___0;
              }
#line 142
              try = beg + offset;
#line 143
              len = kwsmatch.size[0];
            } else {
#line 135
              goto _L;
            }
          }
        } else
        _L: /* CIL Label */ 
#line 145
        if (! start_ptr) {
#line 146
          goto success;
        } else {
#line 148
          goto success_in_beg_and_len;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 151
      goto success;
    }
    __Cont: /* CIL Label */ 
#line 100
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  failure: 
#line 155
  return ((size_t )-1);
  success: 
  {
#line 158
  tmp___11 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
#line 158
  end = (char const   *)tmp___11;
  }
#line 158
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 159
    end ++;
  } else {
#line 161
    end = buf + size;
  }
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 162
    if ((unsigned long )buf < (unsigned long )beg) {
#line 162
      if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 162
        goto while_break___1;
      }
    } else {
#line 162
      goto while_break___1;
    }
#line 163
    beg --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 164
  len = (size_t )(end - beg);
  success_in_beg_and_len: 
  {
#line 166
  off = (size_t )(beg - buf);
#line 167
  mb_case_map_apply((mb_len_map_t const   *)map, & off, & len);
#line 169
  *match_size = len;
#line 170
  ret_val = off;
  }
#line 171
  return (ret_val);
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 537 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 547
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 562
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__string ,
                          __re_idx_t __length , __re_idx_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 580
extern regoff_t re_match(struct re_pattern_buffer *__buffer , char const   *__string ,
                         __re_idx_t __length , __re_idx_t __start , struct re_registers *__regs ) ;
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 53 "/home/khheo/project/benchmark/grep-2.18/src/search.h"
void GEAcompile(char const   *pattern , size_t size , reg_syntax_t syntax_bits___0 ) ;
#line 54
size_t EGexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) ;
#line 41 "/home/khheo/project/benchmark/grep-2.18/src/dfa.h"
struct dfa *dfaalloc(void) ;
#line 44
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d ) ;
#line 49
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) ;
#line 54
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag ) ;
#line 68
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref ) ;
#line 96
void dfawarn(char const   *mesg ) ;
#line 101
void dfaerror(char const   *mesg ) ;
#line 32 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static kwset_t kwset___0  ;
#line 35 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static struct dfa *dfa  ;
#line 38 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static struct patterns patterns0  ;
#line 46 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static struct patterns *patterns  ;
#line 47 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static size_t pcount  ;
#line 52 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static size_t kwset_exact_matches  ;
#line 54 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
#line 57
  error(2, 0, "%s", mesg);
#line 61
  abort();
  }
}
}
#line 70 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static enum __anonenum_mode_962123750 mode  ;
#line 67 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
void dfawarn(char const   *mesg ) 
{ 
  char *tmp___0 ;

  {
#line 71
  if ((unsigned int )mode == 0U) {
    {
#line 72
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 72
    if (tmp___0) {
#line 72
      mode = (enum __anonenum_mode_962123750 )1;
    } else {
#line 72
      mode = (enum __anonenum_mode_962123750 )2;
    }
  }
#line 73
  if ((unsigned int )mode == 2U) {
    {
#line 74
    dfaerror(mesg);
    }
  }
#line 75
  return;
}
}
#line 81 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static void kwsmusts(void) 
{ 
  size_t tmp ;
  struct dfamust  const  *dm ;
  struct dfamust *tmp___0 ;
  char const   *err ;
  size_t tmp___1 ;
  struct dfamust *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 87
  tmp = __ctype_get_mb_cur_max();
  }
#line 87
  if (tmp > 1UL) {
#line 87
    if (match_icase) {
#line 88
      return;
    }
  }
  {
#line 90
  tmp___0 = (struct dfamust *)dfamusts((struct dfa  const  *)dfa);
#line 90
  dm = (struct dfamust  const  *)tmp___0;
  }
#line 91
  if (dm) {
    {
#line 94
    kwsinit(& kwset___0);
    }
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! dm) {
#line 98
        goto while_break;
      }
#line 100
      if (! dm->exact) {
#line 101
        goto __Cont;
      }
      {
#line 102
      kwset_exact_matches ++;
#line 103
      tmp___1 = strlen((char const   *)dm->must);
#line 103
      err = kwsincr(kwset___0, (char const   *)dm->must, tmp___1);
      }
#line 103
      if ((unsigned long )err != (unsigned long )((void *)0)) {
        {
#line 104
        error(2, 0, "%s", err);
        }
      }
      __Cont: /* CIL Label */ 
#line 98
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    tmp___2 = (struct dfamust *)dfamusts((struct dfa  const  *)dfa);
#line 108
    dm = (struct dfamust  const  *)tmp___2;
    }
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 108
      if (! dm) {
#line 108
        goto while_break___0;
      }
#line 110
      if (dm->exact) {
#line 111
        goto __Cont___0;
      }
      {
#line 112
      tmp___3 = strlen((char const   *)dm->must);
#line 112
      err = kwsincr(kwset___0, (char const   *)dm->must, tmp___3);
      }
#line 112
      if ((unsigned long )err != (unsigned long )((void *)0)) {
        {
#line 113
        error(2, 0, "%s", err);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 108
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 115
    err = kwsprep(kwset___0);
    }
#line 115
    if ((unsigned long )err != (unsigned long )((void *)0)) {
      {
#line 116
      error(2, 0, "%s", err);
      }
    }
  }
#line 118
  return;
}
}
#line 171 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   line_beg_no_bk[3]  = {      (char const   )'^',      (char const   )'(',      (char const   )'\000'};
#line 172 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   line_end_no_bk[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 173 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   word_beg_no_bk[19]  = 
#line 173
  {      (char const   )'(',      (char const   )'^',      (char const   )'|',      (char const   )'[', 
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'a', 
        (char const   )'l',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )':',      (char const   )']',      (char const   )'_',      (char const   )']', 
        (char const   )')',      (char const   )'(',      (char const   )'\000'};
#line 174 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   word_end_no_bk[19]  = 
#line 174
  {      (char const   )')',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'a',      (char const   )'l', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )':', 
        (char const   )']',      (char const   )'_',      (char const   )']',      (char const   )'|', 
        (char const   )'$',      (char const   )')',      (char const   )'\000'};
#line 175 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   line_beg_bk[4]  = {      (char const   )'^',      (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 176 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   line_end_bk[4]  = {      (char const   )'\\',      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 177 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   word_beg_bk[23]  = 
#line 177
  {      (char const   )'\\',      (char const   )'(',      (char const   )'^',      (char const   )'\\', 
        (char const   )'|',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'a',      (char const   )'l',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )':',      (char const   )']', 
        (char const   )'_',      (char const   )']',      (char const   )'\\',      (char const   )')', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 178 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
static char const   word_end_bk[23]  = 
#line 178
  {      (char const   )'\\',      (char const   )')',      (char const   )'\\',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'a',      (char const   )'l',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )':',      (char const   )']',      (char const   )'_', 
        (char const   )']',      (char const   )'\\',      (char const   )'|',      (char const   )'$', 
        (char const   )'\\',      (char const   )')',      (char const   )'\000'};
#line 120 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
void GEAcompile(char const   *pattern , size_t size , reg_syntax_t syntax_bits___0 ) 
{ 
  char const   *err ;
  char const   *p ;
  char const   *sep ;
  size_t total ;
  char *motif ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  int bk ;
  char *n ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;

  {
#line 125
  total = size;
#line 128
  if (match_icase) {
#line 129
    syntax_bits___0 |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 130
  re_set_syntax(syntax_bits___0);
#line 131
  dfasyntax(syntax_bits___0, match_icase, eolbyte);
#line 137
  p = pattern;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    tmp = memchr((void const   *)p, '\n', total);
#line 141
    sep = (char const   *)tmp;
    }
#line 142
    if (sep) {
#line 144
      len = (size_t )(sep - p);
#line 145
      sep ++;
#line 146
      total -= len + 1UL;
    } else {
#line 150
      len = total;
#line 151
      total = (size_t )0;
    }
    {
#line 154
    tmp___0 = xnrealloc((void *)patterns, pcount + 1UL, sizeof(*patterns));
#line 154
    patterns = (struct patterns *)tmp___0;
#line 155
    *(patterns + pcount) = patterns0;
#line 157
    err = re_compile_pattern(p, len, & (patterns + pcount)->regexbuf);
    }
#line 157
    if ((unsigned long )err != (unsigned long )((void *)0)) {
      {
#line 159
      error(2, 0, "%s", err);
      }
    }
#line 160
    pcount ++;
#line 162
    p = sep;
#line 138
    if (sep) {
#line 138
      if (! (total != 0UL)) {
#line 138
        goto while_break;
      }
    } else {
#line 138
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (match_words) {
#line 169
    goto _L;
  } else
#line 169
  if (match_lines) {
    _L: /* CIL Label */ 
    {
#line 179
    bk = ! (syntax_bits___0 & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 180
    tmp___1 = xmalloc(((sizeof(word_beg_bk) - 1UL) + size) + sizeof(word_end_bk));
#line 180
    n = (char *)tmp___1;
    }
#line 182
    if (match_lines) {
#line 182
      if (bk) {
#line 182
        tmp___2 = line_beg_bk;
      } else {
#line 182
        tmp___2 = line_beg_no_bk;
      }
#line 182
      tmp___4 = tmp___2;
    } else {
#line 182
      if (bk) {
#line 182
        tmp___3 = word_beg_bk;
      } else {
#line 182
        tmp___3 = word_beg_no_bk;
      }
#line 182
      tmp___4 = tmp___3;
    }
    {
#line 182
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___4);
#line 184
    total = strlen((char const   *)n);
#line 185
    memcpy((void */* __restrict  */)(n + total), (void const   */* __restrict  */)pattern,
           size);
#line 186
    total += size;
    }
#line 187
    if (match_lines) {
#line 187
      if (bk) {
#line 187
        tmp___5 = line_end_bk;
      } else {
#line 187
        tmp___5 = line_end_no_bk;
      }
#line 187
      tmp___7 = tmp___5;
    } else {
#line 187
      if (bk) {
#line 187
        tmp___6 = word_end_bk;
      } else {
#line 187
        tmp___6 = word_end_no_bk;
      }
#line 187
      tmp___7 = tmp___6;
    }
    {
#line 187
    strcpy((char */* __restrict  */)(n + total), (char const   */* __restrict  */)tmp___7);
#line 189
    tmp___8 = strlen((char const   *)(n + total));
#line 189
    total += tmp___8;
#line 190
    motif = n;
#line 190
    pattern = (char const   *)motif;
#line 191
    size = total;
    }
  } else {
#line 194
    motif = (char *)((void *)0);
  }
  {
#line 196
  dfa = dfaalloc();
#line 197
  dfacomp(pattern, size, dfa, 1);
#line 198
  kwsmusts();
#line 200
  free((void *)motif);
  }
#line 201
  return;
}
}
#line 203 "/home/khheo/project/benchmark/grep-2.18/src/dfasearch.c"
size_t EGexecute(char const   *buf , size_t size , size_t *match_size , char const   *start_ptr ) 
{ 
  char const   *buflim___0 ;
  char const   *beg ;
  char const   *end ;
  char const   *match ;
  char const   *best_match ;
  char const   *mb_start ;
  char eol ;
  int backref ;
  regoff_t start ;
  size_t len ;
  size_t best_len ;
  struct kwsmatch kwsm ;
  size_t i ;
  size_t offset ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  char const   *next_beg ;
  char *tmp___4 ;
  void *tmp___5 ;
  regoff_t shorter_len ;
  unsigned short const   **tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  size_t off ;

  {
#line 208
  eol = (char )eolbyte;
#line 215
  mb_start = buf;
#line 216
  buflim___0 = buf + size;
#line 218
  end = buf;
#line 218
  beg = end;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
#line 218
      goto while_break;
    }
#line 220
    if (! start_ptr) {
#line 223
      if (kwset___0) {
        {
#line 226
        tmp = kwsexec(kwset___0, beg, (size_t )(buflim___0 - beg), & kwsm);
#line 226
        offset = tmp;
        }
#line 227
        if (offset == 0xffffffffffffffffUL) {
#line 228
          goto failure;
        }
        {
#line 229
        beg += offset;
#line 232
        tmp___0 = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
#line 232
        end = (char const   *)tmp___0;
        }
#line 232
        if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 233
          end ++;
        } else {
#line 235
          end = buflim___0;
        }
#line 236
        match = beg;
        {
#line 237
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 237
          if ((unsigned long )beg > (unsigned long )buf) {
#line 237
            if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 237
              goto while_break___0;
            }
          } else {
#line 237
            goto while_break___0;
          }
#line 238
          beg --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 239
        if (kwsm.index < kwset_exact_matches) {
#line 244
          if ((unsigned long )mb_start < (unsigned long )beg) {
#line 245
            mb_start = beg;
          }
          {
#line 246
          tmp___1 = __ctype_get_mb_cur_max();
          }
#line 246
          if (tmp___1 == 1UL) {
#line 249
            goto success;
          } else {
            {
#line 246
            tmp___2 = is_mb_middle(& mb_start, match, buflim___0, kwsm.size[0]);
            }
#line 246
            if (! tmp___2) {
#line 249
              goto success;
            }
          }
        }
        {
#line 251
        tmp___3 = dfaexec(dfa, beg, (char *)end, 0, (size_t *)((void *)0), & backref);
        }
#line 251
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 252
          goto __Cont;
        }
      } else {
        {
#line 257
        tmp___4 = dfaexec(dfa, beg, (char *)buflim___0, 0, (size_t *)((void *)0),
                          & backref);
#line 257
        next_beg = (char const   *)tmp___4;
        }
#line 261
        if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 262
          goto while_break;
        } else
#line 261
        if ((unsigned long )next_beg == (unsigned long )buflim___0) {
#line 262
          goto while_break;
        }
        {
#line 264
        beg = next_beg;
#line 265
        tmp___5 = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
#line 265
        end = (char const   *)tmp___5;
        }
#line 265
        if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 266
          end ++;
        } else {
#line 268
          end = buflim___0;
        }
        {
#line 269
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 269
          if ((unsigned long )beg > (unsigned long )buf) {
#line 269
            if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 269
              goto while_break___1;
            }
          } else {
#line 269
            goto while_break___1;
          }
#line 270
          beg --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 273
      if (! backref) {
#line 274
        goto success;
      }
    } else {
#line 280
      beg = start_ptr;
#line 281
      end = buflim___0;
    }
#line 286
    if ((long )(((1 << (sizeof(regoff_t ) * 8UL - 2UL)) - 1) * 2 + 1) < (end - buf) - 1L) {
      {
#line 287
      xalloc_die();
      }
    }
#line 291
    best_match = end;
#line 292
    best_len = (size_t )0;
#line 293
    i = (size_t )0;
    {
#line 293
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 293
      if (! (i < pcount)) {
#line 293
        goto while_break___2;
      }
      {
#line 295
      (patterns + i)->regexbuf.not_eol = 0U;
#line 296
      start = re_search(& (patterns + i)->regexbuf, buf, (__re_idx_t )((end - buf) - 1L),
                        (__re_idx_t )(beg - buf), (regoff_t )((end - beg) - 1L), & (patterns + i)->regs);
      }
#line 300
      if (start < -1) {
        {
#line 301
        xalloc_die();
        }
      } else
#line 302
      if (0 <= start) {
#line 304
        len = (size_t )(*((patterns + i)->regs.end + 0) - start);
#line 305
        match = buf + start;
#line 306
        if ((unsigned long )match > (unsigned long )best_match) {
#line 307
          goto __Cont___0;
        }
#line 308
        if (start_ptr) {
#line 308
          if (! match_words) {
#line 309
            goto assess_pattern_match;
          }
        }
#line 310
        if (! match_lines) {
#line 310
          if (! match_words) {
#line 313
            match = beg;
#line 314
            len = (size_t )(end - beg);
#line 315
            goto assess_pattern_match;
          } else {
#line 310
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 310
        if (match_lines) {
#line 310
          if (len == (size_t )((end - beg) - 1L)) {
#line 313
            match = beg;
#line 314
            len = (size_t )(end - beg);
#line 315
            goto assess_pattern_match;
          }
        }
#line 324
        if (match_words) {
          {
#line 325
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 325
            if (! ((unsigned long )match <= (unsigned long )best_match)) {
#line 325
              goto while_break___3;
            }
#line 327
            shorter_len = 0;
#line 328
            if ((unsigned long )match == (unsigned long )buf) {
#line 328
              goto _L___0;
            } else {
              {
#line 328
              tmp___6 = __ctype_b_loc();
#line 328
              tmp___7 = to_uchar((char )*(match + -1));
              }
#line 328
              if (! ((int const   )*(*tmp___6 + (int )tmp___7) & 8)) {
                {
#line 328
                tmp___8 = to_uchar((char )*(match + -1));
                }
#line 328
                if (! ((int )tmp___8 == 95)) {
                  _L___0: /* CIL Label */ 
#line 328
                  if ((size_t )start + len == (size_t )((end - buf) - 1L)) {
#line 331
                    goto assess_pattern_match;
                  } else {
                    {
#line 328
                    tmp___9 = __ctype_b_loc();
#line 328
                    tmp___10 = to_uchar((char )*(match + len));
                    }
#line 328
                    if (! ((int const   )*(*tmp___9 + (int )tmp___10) & 8)) {
                      {
#line 328
                      tmp___11 = to_uchar((char )*(match + len));
                      }
#line 328
                      if (! ((int )tmp___11 == 95)) {
#line 331
                        goto assess_pattern_match;
                      }
                    }
                  }
                }
              }
            }
#line 332
            if (len > 0UL) {
              {
#line 335
              len --;
#line 336
              (patterns + i)->regexbuf.not_eol = 1U;
#line 337
              shorter_len = re_match(& (patterns + i)->regexbuf, buf, (__re_idx_t )((match + len) - beg),
                                     (__re_idx_t )(match - buf), & (patterns + i)->regs);
              }
#line 341
              if (shorter_len < -1) {
                {
#line 342
                xalloc_die();
                }
              }
            }
#line 344
            if (0 < shorter_len) {
#line 345
              len = (size_t )shorter_len;
            } else {
#line 349
              if ((unsigned long )match == (unsigned long )(end - 1)) {
#line 350
                goto while_break___3;
              }
              {
#line 351
              match ++;
#line 352
              (patterns + i)->regexbuf.not_eol = 0U;
#line 353
              start = re_search(& (patterns + i)->regexbuf, buf, (__re_idx_t )((end - buf) - 1L),
                                (__re_idx_t )(match - buf), (regoff_t )((end - match) - 1L),
                                & (patterns + i)->regs);
              }
#line 357
              if (start < 0) {
#line 359
                if (start < -1) {
                  {
#line 360
                  xalloc_die();
                  }
                }
#line 361
                goto while_break___3;
              }
#line 363
              len = (size_t )(*((patterns + i)->regs.end + 0) - start);
#line 364
              match = buf + start;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 367
        goto __Cont___0;
        assess_pattern_match: 
#line 369
        if (! start_ptr) {
#line 373
          goto success;
        }
#line 375
        if ((unsigned long )match < (unsigned long )best_match) {
#line 378
          best_match = match;
#line 379
          best_len = len;
        } else
#line 375
        if ((unsigned long )match == (unsigned long )best_match) {
#line 375
          if (len > best_len) {
#line 378
            best_match = match;
#line 379
            best_len = len;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 293
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 383
    if ((unsigned long )best_match < (unsigned long )end) {
#line 387
      beg = best_match;
#line 388
      len = best_len;
#line 389
      goto success_in_len;
    }
    __Cont: /* CIL Label */ 
#line 218
    beg = end;
  }
  while_break: /* CIL Label */ ;
  }
  failure: 
#line 394
  return ((size_t )-1);
  success: 
#line 397
  len = (size_t )(end - beg);
  success_in_len: 
#line 399
  off = (size_t )(beg - buf);
#line 400
  *match_size = len;
#line 401
  return (off);
}
}
#line 660 "../lib/regex.h"
extern void regfree(regex_t *__preg ) ;
#line 72 "/home/khheo/project/benchmark/grep-2.18/src/dfa.h"
void dfafree(struct dfa *d ) ;
#line 77
void dfainit(struct dfa *d ) ;
#line 80
void dfaparse(char const   *s , size_t len , struct dfa *d ) ;
#line 84
void dfaanalyze(struct dfa *d , int searchflag ) ;
#line 88
void dfastate(ptrdiff_t s , struct dfa *d , ptrdiff_t *trans___0 ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wctype_t ( __attribute__((__leaf__)) wctype)(char const   *__property ) ;
#line 159
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswctype)(wint_t __wc ,
                                                                               wctype_t __desc ) ;
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 432 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void dfamust(struct dfa *d ) ;
#line 433
static void regexp(void) ;
#line 550 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static _Bool tstbit(unsigned int b , unsigned int * const  c ) 
{ 


  {
#line 553
  return ((_Bool )((*(c + (unsigned long )b / (8UL * sizeof(int ))) >> (unsigned long )b % (8UL * sizeof(int ))) & 1U));
}
}
#line 556 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void setbit(unsigned int b , unsigned int *c ) 
{ 


  {
#line 559
  *(c + (unsigned long )b / (8UL * sizeof(int ))) |= 1U << (unsigned long )b % (8UL * sizeof(int ));
#line 560
  return;
}
}
#line 562 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void clrbit(unsigned int b , unsigned int *c ) 
{ 


  {
#line 565
  *(c + (unsigned long )b / (8UL * sizeof(int ))) &= ~ (1U << (unsigned long )b % (8UL * sizeof(int )));
#line 566
  return;
}
}
#line 568 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void copyset(unsigned int * const  src , unsigned int *dst ) 
{ 


  {
  {
#line 571
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(charclass ));
  }
#line 572
  return;
}
}
#line 574 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void zeroset(unsigned int *s ) 
{ 


  {
  {
#line 577
  memset((void *)s, 0, sizeof(charclass ));
  }
#line 578
  return;
}
}
#line 580 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void notset(unsigned int *s ) 
{ 
  int i ;

  {
#line 585
  i = 0;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 585
      goto while_break;
    }
#line 586
    *(s + i) = ~ *(s + i);
#line 585
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  return;
}
}
#line 589 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int equal(unsigned int * const  s1 , unsigned int * const  s2 ) 
{ 
  int tmp ;

  {
  {
#line 592
  tmp = memcmp((void const   *)s1, (void const   *)s2, sizeof(charclass ));
  }
#line 592
  return (tmp == 0);
}
}
#line 596 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static struct dfa *dfa___0  ;
#line 600 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static size_t charclass_index(unsigned int * const  s ) 
{ 
  size_t i ;
  int tmp ;
  size_t new_n_alloc ;
  void *tmp___0 ;

  {
#line 605
  i = (size_t )0;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < dfa___0->cindex)) {
#line 605
      goto while_break;
    }
    {
#line 606
    tmp = equal(s, (unsigned int */* const  */)(*(dfa___0->charclasses + i)));
    }
#line 606
    if (tmp) {
#line 607
      return (i);
    }
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 608
    if (dfa___0->calloc <= dfa___0->cindex + 1UL) {
      {
#line 608
      new_n_alloc = (dfa___0->cindex + 1UL) + (size_t )(! dfa___0->charclasses);
#line 608
      tmp___0 = x2nrealloc((void *)dfa___0->charclasses, & new_n_alloc, sizeof(*(dfa___0->charclasses)));
#line 608
      dfa___0->charclasses = (charclass *)tmp___0;
#line 608
      dfa___0->calloc = new_n_alloc;
      }
    }
#line 608
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 609
  (dfa___0->cindex) ++;
#line 610
  copyset(s, *(dfa___0->charclasses + i));
  }
#line 611
  return (i);
}
}
#line 615 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static reg_syntax_t syntax_bits  ;
#line 615 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static reg_syntax_t syntax_bits_set  ;
#line 618 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int case_fold  ;
#line 621 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static unsigned char eolbyte___0  ;
#line 624 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int sbit[1 << 8]  ;
#line 627 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static charclass letters  ;
#line 630 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static charclass newline  ;
#line 645 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int char_context(unsigned char c ) 
{ 
  unsigned short const   **tmp ;

  {
#line 648
  if ((int )c == (int )eolbyte___0) {
#line 649
    return (4);
  } else
#line 648
  if ((int )c == 0) {
#line 649
    return (4);
  }
  {
#line 650
  tmp = __ctype_b_loc();
  }
#line 650
  if ((int const   )*(*tmp + (int )c) & 8) {
#line 651
    return (2);
  } else
#line 650
  if ((int )c == 95) {
#line 651
    return (2);
  }
#line 652
  return (1);
}
}
#line 655 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int wchar_context(wint_t wc ) 
{ 
  int tmp ;

  {
#line 658
  if (wc == (wint_t )((wchar_t )eolbyte___0)) {
#line 659
    return (4);
  } else
#line 658
  if (wc == 0U) {
#line 659
    return (4);
  }
#line 660
  if (wc == 95U) {
#line 661
    return (2);
  } else {
    {
#line 660
    tmp = iswalnum(wc);
    }
#line 660
    if (tmp) {
#line 661
      return (2);
    }
  }
#line 662
  return (1);
}
}
#line 666 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) 
{ 
  unsigned int i ;

  {
#line 671
  syntax_bits_set = (reg_syntax_t )1;
#line 672
  syntax_bits = bits;
#line 673
  case_fold = fold;
#line 674
  eolbyte___0 = eol;
#line 676
  i = 0U;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < (unsigned int )(1 << 8))) {
#line 676
      goto while_break;
    }
    {
#line 678
    sbit[i] = char_context((unsigned char )i);
    }
    {
#line 681
    if (sbit[i] == 2) {
#line 681
      goto case_2;
    }
#line 684
    if (sbit[i] == 4) {
#line 684
      goto case_4;
    }
#line 679
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 682
    setbit(i, letters);
    }
#line 683
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 685
    setbit(i, newline);
    }
#line 686
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return;
}
}
#line 697 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static _Bool setbit_wc(wint_t wc , unsigned int *c ) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 700
  tmp = wctob(wc);
#line 700
  b = tmp;
  }
#line 701
  if (b == -1) {
#line 702
    return ((_Bool)0);
  }
  {
#line 704
  setbit((unsigned int )b, c);
  }
#line 705
  return ((_Bool)1);
}
}
#line 710 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void setbit_c(int b , unsigned int *c ) 
{ 
  size_t tmp ;
  wint_t tmp___0 ;

  {
  {
#line 714
  tmp = __ctype_get_mb_cur_max();
  }
#line 714
  if (tmp > 1UL) {
    {
#line 714
    tmp___0 = btowc(b);
    }
#line 714
    if (tmp___0 == 4294967295U) {
#line 715
      return;
    }
  }
  {
#line 716
  setbit((unsigned int )b, c);
  }
#line 717
  return;
}
}
#line 732 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void setbit_case_fold_c(int b , unsigned int *c ) 
{ 
  wint_t wc ;
  wint_t tmp ;
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 735
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 735
  if (tmp___12 > 1UL) {
    {
#line 737
    tmp = btowc(b);
#line 737
    wc = tmp;
    }
#line 738
    if (wc == 4294967295U) {
#line 739
      return;
    }
    {
#line 740
    setbit((unsigned int )b, c);
    }
#line 741
    if (case_fold) {
      {
#line 741
      tmp___5 = iswalpha(wc);
      }
#line 741
      if (tmp___5) {
        {
#line 742
        tmp___4 = iswupper(wc);
        }
#line 742
        if (tmp___4) {
          {
#line 742
          tmp___1 = towlower(wc);
#line 742
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 742
          tmp___2 = towupper(wc);
#line 742
          tmp___3 = tmp___2;
          }
        }
        {
#line 742
        setbit_wc(tmp___3, c);
        }
      }
    }
  } else {
    {
#line 746
    setbit((unsigned int )b, c);
    }
#line 747
    if (case_fold) {
      {
#line 747
      tmp___11 = __ctype_b_loc();
      }
#line 747
      if ((int const   )*(*tmp___11 + b) & 1024) {
        {
#line 748
        tmp___10 = __ctype_b_loc();
        }
#line 748
        if ((int const   )*(*tmp___10 + b) & 256) {
          {
#line 748
          tmp___7 = tolower(b);
#line 748
          tmp___9 = tmp___7;
          }
        } else {
          {
#line 748
          tmp___8 = toupper(b);
#line 748
          tmp___9 = tmp___8;
          }
        }
        {
#line 748
        setbit_c(tmp___9, c);
        }
      }
    }
  }
#line 750
  return;
}
}
#line 759 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int utf8  =    -1;
#line 756 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
int using_utf8(void) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 760
  if (utf8 == -1) {
    {
#line 763
    tmp = nl_langinfo(14);
#line 763
    tmp___0 = strcmp((char const   *)tmp, "UTF-8");
#line 763
    utf8 = tmp___0 == 0;
    }
  }
#line 769
  return (utf8);
}
}
#line 777 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char const   *lexptr  ;
#line 778 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static size_t lexleft  ;
#line 779 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static token lasttok  ;
#line 780 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int laststart  ;
#line 782 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static size_t parens  ;
#line 783 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int minrep  ;
#line 783 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int maxrep  ;
#line 785 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int cur_mb_len  =    1;
#line 788 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static mbstate_t mbs  ;
#line 789 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static wchar_t wctok  ;
#line 791 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static unsigned char *mblen_buf  ;
#line 800 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static wchar_t *inputwcs  ;
#line 807 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static unsigned char const   *buf_begin  ;
#line 808 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static unsigned char const   *buf_end  ;
#line 884 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 884
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)1}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 900 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 904
  i = 0U;
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 904
    if (! prednames[i].name) {
#line 904
      goto while_break;
    }
    {
#line 905
    tmp = strcmp(str, (char const   *)prednames[i].name);
    }
#line 905
    if (tmp == 0) {
#line 906
      goto while_break;
    }
#line 904
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 908
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
}
}
#line 1176 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static charclass zeroclass  ;
#line 913 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static token parse_bracket_exp(void) 
{ 
  int invert ;
  int c ;
  int c1 ;
  int c2 ;
  charclass ccl ;
  int colon_warning_state ;
  wint_t wc ;
  wint_t wc2 ;
  wint_t wc1 ;
  struct mb_char_classes *work_mbc ;
  size_t chars_al ;
  size_t range_sts_al ;
  size_t range_ends_al ;
  size_t ch_classes_al ;
  size_t equivs_al ;
  size_t coll_elems_al ;
  size_t new_n_alloc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  wchar_t _wc ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  unsigned char tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  wchar_t _wc___0 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  unsigned char tmp___11 ;
  char str[33] ;
  char *tmp___12 ;
  char *tmp___13 ;
  wchar_t _wc___1 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  unsigned char tmp___16 ;
  size_t len ;
  char *tmp___17 ;
  char *tmp___18 ;
  wchar_t _wc___2 ;
  size_t tmp___19 ;
  char const   *tmp___20 ;
  unsigned char tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  wchar_t _wc___3 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  unsigned char tmp___27 ;
  char const   *class ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___33 ;
  char *tmp___34 ;
  wctype_t wt ;
  wctype_t tmp___35 ;
  size_t new_n_alloc___0 ;
  void *tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  char *elem ;
  void *tmp___40 ;
  size_t new_n_alloc___1 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  size_t new_n_alloc___2 ;
  void *tmp___43 ;
  size_t tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  wchar_t _wc___4 ;
  size_t tmp___47 ;
  char const   *tmp___48 ;
  unsigned char tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  wchar_t _wc___5 ;
  size_t tmp___53 ;
  char const   *tmp___54 ;
  unsigned char tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  wchar_t _wc___6 ;
  size_t tmp___58 ;
  char const   *tmp___59 ;
  unsigned char tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  wchar_t _wc___7 ;
  size_t tmp___63 ;
  char const   *tmp___64 ;
  unsigned char tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  wchar_t _wc___8 ;
  size_t tmp___68 ;
  char const   *tmp___69 ;
  unsigned char tmp___70 ;
  size_t new_n_alloc___3 ;
  void *tmp___71 ;
  size_t new_n_alloc___4 ;
  void *tmp___72 ;
  wint_t tmp___73 ;
  size_t tmp___74 ;
  wint_t tmp___75 ;
  size_t new_n_alloc___5 ;
  void *tmp___76 ;
  wint_t tmp___77 ;
  size_t new_n_alloc___6 ;
  void *tmp___78 ;
  size_t tmp___79 ;
  wint_t tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  struct re_pattern_buffer re ;
  char const   *compile_msg ;
  char pattern[7] ;
  char subject ;
  regoff_t tmp___83 ;
  size_t tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  wchar_t _wc___9 ;
  size_t tmp___87 ;
  char const   *tmp___88 ;
  unsigned char tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  size_t new_n_alloc___7 ;
  void *tmp___92 ;
  size_t tmp___93 ;
  _Bool tmp___94 ;
  int tmp___95 ;
  size_t new_n_alloc___8 ;
  void *tmp___96 ;
  size_t tmp___97 ;
  _Bool tmp___98 ;
  char *tmp___99 ;
  size_t tmp___101 ;
  int tmp___102 ;
  size_t tmp___103 ;
  size_t tmp___107 ;
  size_t tmp___108 ;

  {
  {
#line 929
  wc1 = (wint_t )0;
#line 936
  chars_al = (size_t )0;
#line 937
  range_ends_al = (size_t )0;
#line 937
  range_sts_al = range_ends_al;
#line 938
  coll_elems_al = (size_t )0;
#line 938
  equivs_al = coll_elems_al;
#line 938
  ch_classes_al = equivs_al;
#line 939
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 939
  if (tmp___1 > 1UL) {
    {
#line 941
    while (1) {
      while_continue: /* CIL Label */ ;
#line 941
      if (dfa___0->mbcsets_alloc <= dfa___0->nmbcsets + 1UL) {
        {
#line 941
        new_n_alloc = (dfa___0->nmbcsets + 1UL) + (size_t )(! dfa___0->mbcsets);
#line 941
        tmp = x2nrealloc((void *)dfa___0->mbcsets, & new_n_alloc, sizeof(*(dfa___0->mbcsets)));
#line 941
        dfa___0->mbcsets = (struct mb_char_classes *)tmp;
#line 941
        dfa___0->mbcsets_alloc = new_n_alloc;
        }
      }
#line 941
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 949
    tmp___0 = dfa___0->nmbcsets;
#line 949
    (dfa___0->nmbcsets) ++;
#line 949
    work_mbc = dfa___0->mbcsets + tmp___0;
#line 950
    memset((void *)work_mbc, 0, sizeof(*work_mbc));
    }
  } else {
#line 953
    work_mbc = (struct mb_char_classes *)((void *)0);
  }
  {
#line 955
  memset((void *)(ccl), 0, sizeof(ccl));
  }
  {
#line 956
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 956
    if (! lexleft) {
      {
#line 956
      tmp___3 = gettext("unbalanced [");
      }
#line 956
      if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
        {
#line 956
        tmp___2 = gettext("unbalanced [");
#line 956
        dfaerror((char const   *)tmp___2);
        }
      } else {
#line 956
        lasttok = (token )-1;
#line 956
        return (lasttok);
      }
    } else {
      {
#line 956
      tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& _wc), (char const   */* __restrict  */)lexptr,
                        lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 956
      cur_mb_len = (int )tmp___4;
      }
#line 956
      if (cur_mb_len <= 0) {
        {
#line 956
        cur_mb_len = 1;
#line 956
        lexleft --;
#line 956
        tmp___5 = lexptr;
#line 956
        lexptr ++;
#line 956
        tmp___6 = to_uchar((char )*tmp___5);
#line 956
        c = (int )tmp___6;
#line 956
        wc = (wint_t )c;
        }
      } else {
        {
#line 956
        lexptr += cur_mb_len;
#line 956
        lexleft -= (size_t )cur_mb_len;
#line 956
        wc = (wint_t )_wc;
#line 956
        c = wctob(wc);
        }
      }
    }
#line 956
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 957
  if (c == 94) {
    {
#line 959
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 959
      if (! lexleft) {
        {
#line 959
        tmp___8 = gettext("unbalanced [");
        }
#line 959
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          {
#line 959
          tmp___7 = gettext("unbalanced [");
#line 959
          dfaerror((char const   *)tmp___7);
          }
        } else {
#line 959
          lasttok = (token )-1;
#line 959
          return (lasttok);
        }
      } else {
        {
#line 959
        tmp___9 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0), (char const   */* __restrict  */)lexptr,
                          lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 959
        cur_mb_len = (int )tmp___9;
        }
#line 959
        if (cur_mb_len <= 0) {
          {
#line 959
          cur_mb_len = 1;
#line 959
          lexleft --;
#line 959
          tmp___10 = lexptr;
#line 959
          lexptr ++;
#line 959
          tmp___11 = to_uchar((char )*tmp___10);
#line 959
          c = (int )tmp___11;
#line 959
          wc = (wint_t )c;
          }
        } else {
          {
#line 959
          lexptr += cur_mb_len;
#line 959
          lexleft -= (size_t )cur_mb_len;
#line 959
          wc = (wint_t )_wc___0;
#line 959
          c = wctob(wc);
          }
        }
      }
#line 959
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 960
    invert = 1;
  } else {
#line 963
    invert = 0;
  }
#line 965
  colon_warning_state = c == 58;
  {
#line 966
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 968
    c1 = -1;
#line 969
    colon_warning_state &= -3;
#line 975
    if (c == 91) {
#line 975
      if (syntax_bits & ((1UL << 1) << 1)) {
        {
#line 979
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 979
          if (! lexleft) {
            {
#line 979
            tmp___13 = gettext("unbalanced [");
            }
#line 979
            if ((unsigned long )tmp___13 != (unsigned long )((char *)0)) {
              {
#line 979
              tmp___12 = gettext("unbalanced [");
#line 979
              dfaerror((char const   *)tmp___12);
              }
            } else {
#line 979
              lasttok = (token )-1;
#line 979
              return (lasttok);
            }
          } else {
            {
#line 979
            tmp___14 = mbrtowc((wchar_t */* __restrict  */)(& _wc___1), (char const   */* __restrict  */)lexptr,
                               lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 979
            cur_mb_len = (int )tmp___14;
            }
#line 979
            if (cur_mb_len <= 0) {
              {
#line 979
              cur_mb_len = 1;
#line 979
              lexleft --;
#line 979
              tmp___15 = lexptr;
#line 979
              lexptr ++;
#line 979
              tmp___16 = to_uchar((char )*tmp___15);
#line 979
              c1 = (int )tmp___16;
#line 979
              wc1 = (wint_t )c1;
              }
            } else {
              {
#line 979
              lexptr += cur_mb_len;
#line 979
              lexleft -= (size_t )cur_mb_len;
#line 979
              wc1 = (wint_t )_wc___1;
#line 979
              c1 = wctob(wc1);
              }
            }
          }
#line 979
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 982
        if (c1 == 58) {
#line 982
          goto _L___2;
        } else {
          {
#line 982
          tmp___50 = __ctype_get_mb_cur_max();
          }
#line 982
          if (tmp___50 > 1UL) {
#line 982
            if (c1 == 46) {
#line 982
              goto _L___2;
            } else
#line 982
            if (c1 == 61) {
              _L___2: /* CIL Label */ 
#line 986
              len = (size_t )0;
              {
#line 987
              while (1) {
                while_continue___4: /* CIL Label */ ;
                {
#line 989
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 989
                  if (! lexleft) {
                    {
#line 989
                    tmp___18 = gettext("unbalanced [");
                    }
#line 989
                    if ((unsigned long )tmp___18 != (unsigned long )((char *)0)) {
                      {
#line 989
                      tmp___17 = gettext("unbalanced [");
#line 989
                      dfaerror((char const   *)tmp___17);
                      }
                    } else {
#line 989
                      lasttok = (token )-1;
#line 989
                      return (lasttok);
                    }
                  } else {
                    {
#line 989
                    tmp___19 = mbrtowc((wchar_t */* __restrict  */)(& _wc___2), (char const   */* __restrict  */)lexptr,
                                       lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 989
                    cur_mb_len = (int )tmp___19;
                    }
#line 989
                    if (cur_mb_len <= 0) {
                      {
#line 989
                      cur_mb_len = 1;
#line 989
                      lexleft --;
#line 989
                      tmp___20 = lexptr;
#line 989
                      lexptr ++;
#line 989
                      tmp___21 = to_uchar((char )*tmp___20);
#line 989
                      c = (int )tmp___21;
#line 989
                      wc = (wint_t )c;
                      }
                    } else {
                      {
#line 989
                      lexptr += cur_mb_len;
#line 989
                      lexleft -= (size_t )cur_mb_len;
#line 989
                      wc = (wint_t )_wc___2;
#line 989
                      c = wctob(wc);
                      }
                    }
                  }
#line 989
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 990
                if (c == c1) {
#line 990
                  if ((int const   )*lexptr == 93) {
#line 991
                    goto while_break___4;
                  } else {
#line 990
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 990
                if (lexleft == 0UL) {
#line 991
                  goto while_break___4;
                }
#line 992
                if (len < 32UL) {
#line 993
                  tmp___22 = len;
#line 993
                  len ++;
#line 993
                  str[tmp___22] = (char )c;
                } else {
#line 996
                  str[0] = (char )'\000';
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 998
              str[len] = (char )'\000';
              {
#line 1001
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1001
                if (! lexleft) {
                  {
#line 1001
                  tmp___24 = gettext("unbalanced [");
                  }
#line 1001
                  if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
                    {
#line 1001
                    tmp___23 = gettext("unbalanced [");
#line 1001
                    dfaerror((char const   *)tmp___23);
                    }
                  } else {
#line 1001
                    lasttok = (token )-1;
#line 1001
                    return (lasttok);
                  }
                } else {
                  {
#line 1001
                  tmp___25 = mbrtowc((wchar_t */* __restrict  */)(& _wc___3), (char const   */* __restrict  */)lexptr,
                                     lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1001
                  cur_mb_len = (int )tmp___25;
                  }
#line 1001
                  if (cur_mb_len <= 0) {
                    {
#line 1001
                    cur_mb_len = 1;
#line 1001
                    lexleft --;
#line 1001
                    tmp___26 = lexptr;
#line 1001
                    lexptr ++;
#line 1001
                    tmp___27 = to_uchar((char )*tmp___26);
#line 1001
                    c = (int )tmp___27;
#line 1001
                    wc = (wint_t )c;
                    }
                  } else {
                    {
#line 1001
                    lexptr += cur_mb_len;
#line 1001
                    lexleft -= (size_t )cur_mb_len;
#line 1001
                    wc = (wint_t )_wc___3;
#line 1001
                    c = wctob(wc);
                    }
                  }
                }
#line 1001
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1002
              if (c1 == 58) {
#line 1005
                if (case_fold) {
                  {
#line 1005
                  tmp___31 = strcmp((char const   *)(str), "upper");
                  }
#line 1005
                  if (tmp___31 == 0) {
#line 1005
                    tmp___30 = "alpha";
                  } else {
                    {
#line 1005
                    tmp___32 = strcmp((char const   *)(str), "lower");
                    }
#line 1005
                    if (tmp___32 == 0) {
#line 1005
                      tmp___30 = "alpha";
                    } else {
#line 1005
                      tmp___30 = (char const   *)(str);
                    }
                  }
                } else {
#line 1005
                  tmp___30 = (char const   *)(str);
                }
                {
#line 1005
                class = tmp___30;
#line 1008
                tmp___33 = find_pred(class);
#line 1008
                pred = (struct dfa_ctype  const  *)tmp___33;
                }
#line 1009
                if (! pred) {
                  {
#line 1010
                  tmp___34 = gettext("invalid character class");
#line 1010
                  dfaerror((char const   *)tmp___34);
                  }
                }
                {
#line 1012
                tmp___38 = __ctype_get_mb_cur_max();
                }
#line 1012
                if (tmp___38 > 1UL) {
#line 1012
                  if (! pred->single_byte_only) {
                    {
#line 1015
                    tmp___35 = wctype(class);
#line 1015
                    wt = tmp___35;
                    }
                    {
#line 1017
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
#line 1017
                      if (ch_classes_al <= work_mbc->nch_classes + 1UL) {
                        {
#line 1017
                        new_n_alloc___0 = (work_mbc->nch_classes + 1UL) + (size_t )(! work_mbc->ch_classes);
#line 1017
                        tmp___36 = x2nrealloc((void *)work_mbc->ch_classes, & new_n_alloc___0,
                                              sizeof(*(work_mbc->ch_classes)));
#line 1017
                        work_mbc->ch_classes = (wctype_t *)tmp___36;
#line 1017
                        ch_classes_al = new_n_alloc___0;
                        }
                      }
#line 1017
                      goto while_break___7;
                    }
                    while_break___7: /* CIL Label */ ;
                    }
#line 1020
                    tmp___37 = work_mbc->nch_classes;
#line 1020
                    (work_mbc->nch_classes) ++;
#line 1020
                    *(work_mbc->ch_classes + tmp___37) = wt;
                  }
                }
#line 1023
                c2 = 0;
                {
#line 1023
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 1023
                  if (! (c2 < 1 << 8)) {
#line 1023
                    goto while_break___8;
                  }
                  {
#line 1024
                  tmp___39 = (*(pred->func))(c2);
                  }
#line 1024
                  if (tmp___39) {
                    {
#line 1025
                    setbit_case_fold_c(c2, ccl);
                    }
                  }
#line 1023
                  c2 ++;
                }
                while_break___8: /* CIL Label */ ;
                }
              } else
#line 1028
              if (c1 == 61) {
#line 1028
                goto _L___0;
              } else
#line 1028
              if (c1 == 46) {
                _L___0: /* CIL Label */ 
                {
#line 1030
                tmp___40 = xmemdup((void const   *)(str), len + 1UL);
#line 1030
                elem = (char *)tmp___40;
                }
#line 1032
                if (c1 == 61) {
                  {
#line 1035
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 1035
                    if (equivs_al <= work_mbc->nequivs + 1UL) {
                      {
#line 1035
                      new_n_alloc___1 = (work_mbc->nequivs + 1UL) + (size_t )(! work_mbc->equivs);
#line 1035
                      tmp___41 = x2nrealloc((void *)work_mbc->equivs, & new_n_alloc___1,
                                            sizeof(*(work_mbc->equivs)));
#line 1035
                      work_mbc->equivs = (char **)tmp___41;
#line 1035
                      equivs_al = new_n_alloc___1;
                      }
                    }
#line 1035
                    goto while_break___9;
                  }
                  while_break___9: /* CIL Label */ ;
                  }
#line 1037
                  tmp___42 = work_mbc->nequivs;
#line 1037
                  (work_mbc->nequivs) ++;
#line 1037
                  *(work_mbc->equivs + tmp___42) = elem;
                }
#line 1040
                if (c1 == 46) {
                  {
#line 1043
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 1043
                    if (coll_elems_al <= work_mbc->ncoll_elems + 1UL) {
                      {
#line 1043
                      new_n_alloc___2 = (work_mbc->ncoll_elems + 1UL) + (size_t )(! work_mbc->coll_elems);
#line 1043
                      tmp___43 = x2nrealloc((void *)work_mbc->coll_elems, & new_n_alloc___2,
                                            sizeof(*(work_mbc->coll_elems)));
#line 1043
                      work_mbc->coll_elems = (char **)tmp___43;
#line 1043
                      coll_elems_al = new_n_alloc___2;
                      }
                    }
#line 1043
                    goto while_break___10;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
#line 1046
                  tmp___44 = work_mbc->ncoll_elems;
#line 1046
                  (work_mbc->ncoll_elems) ++;
#line 1046
                  *(work_mbc->coll_elems + tmp___44) = elem;
                }
              }
#line 1049
              colon_warning_state |= 8;
              {
#line 1052
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 1052
                if (! lexleft) {
                  {
#line 1052
                  tmp___46 = gettext("unbalanced [");
                  }
#line 1052
                  if ((unsigned long )tmp___46 != (unsigned long )((char *)0)) {
                    {
#line 1052
                    tmp___45 = gettext("unbalanced [");
#line 1052
                    dfaerror((char const   *)tmp___45);
                    }
                  } else {
#line 1052
                    lasttok = (token )-1;
#line 1052
                    return (lasttok);
                  }
                } else {
                  {
#line 1052
                  tmp___47 = mbrtowc((wchar_t */* __restrict  */)(& _wc___4), (char const   */* __restrict  */)lexptr,
                                     lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1052
                  cur_mb_len = (int )tmp___47;
                  }
#line 1052
                  if (cur_mb_len <= 0) {
                    {
#line 1052
                    cur_mb_len = 1;
#line 1052
                    lexleft --;
#line 1052
                    tmp___48 = lexptr;
#line 1052
                    lexptr ++;
#line 1052
                    tmp___49 = to_uchar((char )*tmp___48);
#line 1052
                    c1 = (int )tmp___49;
#line 1052
                    wc1 = (wint_t )c1;
                    }
                  } else {
                    {
#line 1052
                    lexptr += cur_mb_len;
#line 1052
                    lexleft -= (size_t )cur_mb_len;
#line 1052
                    wc1 = (wint_t )_wc___4;
#line 1052
                    c1 = wctob(wc1);
                    }
                  }
                }
#line 1052
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 1053
              goto __Cont;
            }
          }
        }
      }
    }
#line 1060
    if (c == 92) {
#line 1060
      if (syntax_bits & 1UL) {
        {
#line 1061
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1061
          if (! lexleft) {
            {
#line 1061
            tmp___52 = gettext("unbalanced [");
            }
#line 1061
            if ((unsigned long )tmp___52 != (unsigned long )((char *)0)) {
              {
#line 1061
              tmp___51 = gettext("unbalanced [");
#line 1061
              dfaerror((char const   *)tmp___51);
              }
            } else {
#line 1061
              lasttok = (token )-1;
#line 1061
              return (lasttok);
            }
          } else {
            {
#line 1061
            tmp___53 = mbrtowc((wchar_t */* __restrict  */)(& _wc___5), (char const   */* __restrict  */)lexptr,
                               lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1061
            cur_mb_len = (int )tmp___53;
            }
#line 1061
            if (cur_mb_len <= 0) {
              {
#line 1061
              cur_mb_len = 1;
#line 1061
              lexleft --;
#line 1061
              tmp___54 = lexptr;
#line 1061
              lexptr ++;
#line 1061
              tmp___55 = to_uchar((char )*tmp___54);
#line 1061
              c = (int )tmp___55;
#line 1061
              wc = (wint_t )c;
              }
            } else {
              {
#line 1061
              lexptr += cur_mb_len;
#line 1061
              lexleft -= (size_t )cur_mb_len;
#line 1061
              wc = (wint_t )_wc___5;
#line 1061
              c = wctob(wc);
              }
            }
          }
#line 1061
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 1063
    if (c1 == -1) {
      {
#line 1064
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1064
        if (! lexleft) {
          {
#line 1064
          tmp___57 = gettext("unbalanced [");
          }
#line 1064
          if ((unsigned long )tmp___57 != (unsigned long )((char *)0)) {
            {
#line 1064
            tmp___56 = gettext("unbalanced [");
#line 1064
            dfaerror((char const   *)tmp___56);
            }
          } else {
#line 1064
            lasttok = (token )-1;
#line 1064
            return (lasttok);
          }
        } else {
          {
#line 1064
          tmp___58 = mbrtowc((wchar_t */* __restrict  */)(& _wc___6), (char const   */* __restrict  */)lexptr,
                             lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1064
          cur_mb_len = (int )tmp___58;
          }
#line 1064
          if (cur_mb_len <= 0) {
            {
#line 1064
            cur_mb_len = 1;
#line 1064
            lexleft --;
#line 1064
            tmp___59 = lexptr;
#line 1064
            lexptr ++;
#line 1064
            tmp___60 = to_uchar((char )*tmp___59);
#line 1064
            c1 = (int )tmp___60;
#line 1064
            wc1 = (wint_t )c1;
            }
          } else {
            {
#line 1064
            lexptr += cur_mb_len;
#line 1064
            lexleft -= (size_t )cur_mb_len;
#line 1064
            wc1 = (wint_t )_wc___6;
#line 1064
            c1 = wctob(wc1);
            }
          }
        }
#line 1064
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 1066
    if (c1 == 45) {
      {
#line 1069
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1069
        if (! lexleft) {
          {
#line 1069
          tmp___62 = gettext("unbalanced [");
          }
#line 1069
          if ((unsigned long )tmp___62 != (unsigned long )((char *)0)) {
            {
#line 1069
            tmp___61 = gettext("unbalanced [");
#line 1069
            dfaerror((char const   *)tmp___61);
            }
          } else {
#line 1069
            lasttok = (token )-1;
#line 1069
            return (lasttok);
          }
        } else {
          {
#line 1069
          tmp___63 = mbrtowc((wchar_t */* __restrict  */)(& _wc___7), (char const   */* __restrict  */)lexptr,
                             lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1069
          cur_mb_len = (int )tmp___63;
          }
#line 1069
          if (cur_mb_len <= 0) {
            {
#line 1069
            cur_mb_len = 1;
#line 1069
            lexleft --;
#line 1069
            tmp___64 = lexptr;
#line 1069
            lexptr ++;
#line 1069
            tmp___65 = to_uchar((char )*tmp___64);
#line 1069
            c2 = (int )tmp___65;
#line 1069
            wc2 = (wint_t )c2;
            }
          } else {
            {
#line 1069
            lexptr += cur_mb_len;
#line 1069
            lexleft -= (size_t )cur_mb_len;
#line 1069
            wc2 = (wint_t )_wc___7;
#line 1069
            c2 = wctob(wc2);
            }
          }
        }
#line 1069
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1070
      if (c2 == 93) {
#line 1074
        lexptr -= cur_mb_len;
#line 1075
        lexleft += (size_t )cur_mb_len;
      }
    }
#line 1079
    if (c1 == 45) {
#line 1079
      if (c2 != 93) {
#line 1081
        if (c2 == 92) {
#line 1081
          if (syntax_bits & 1UL) {
            {
#line 1082
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1082
              if (! lexleft) {
                {
#line 1082
                tmp___67 = gettext("unbalanced [");
                }
#line 1082
                if ((unsigned long )tmp___67 != (unsigned long )((char *)0)) {
                  {
#line 1082
                  tmp___66 = gettext("unbalanced [");
#line 1082
                  dfaerror((char const   *)tmp___66);
                  }
                } else {
#line 1082
                  lasttok = (token )-1;
#line 1082
                  return (lasttok);
                }
              } else {
                {
#line 1082
                tmp___68 = mbrtowc((wchar_t */* __restrict  */)(& _wc___8), (char const   */* __restrict  */)lexptr,
                                   lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1082
                cur_mb_len = (int )tmp___68;
                }
#line 1082
                if (cur_mb_len <= 0) {
                  {
#line 1082
                  cur_mb_len = 1;
#line 1082
                  lexleft --;
#line 1082
                  tmp___69 = lexptr;
#line 1082
                  lexptr ++;
#line 1082
                  tmp___70 = to_uchar((char )*tmp___69);
#line 1082
                  c2 = (int )tmp___70;
#line 1082
                  wc2 = (wint_t )c2;
                  }
                } else {
                  {
#line 1082
                  lexptr += cur_mb_len;
#line 1082
                  lexleft -= (size_t )cur_mb_len;
#line 1082
                  wc2 = (wint_t )_wc___8;
#line 1082
                  c2 = wctob(wc2);
                  }
                }
              }
#line 1082
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
        {
#line 1084
        tmp___84 = __ctype_get_mb_cur_max();
        }
#line 1084
        if (tmp___84 > 1UL) {
          {
#line 1088
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1088
            if (range_sts_al <= work_mbc->nranges + 1UL) {
              {
#line 1088
              new_n_alloc___3 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_sts);
#line 1088
              tmp___71 = x2nrealloc((void *)work_mbc->range_sts, & new_n_alloc___3,
                                    sizeof(*(work_mbc->range_sts)));
#line 1088
              work_mbc->range_sts = (wchar_t *)tmp___71;
#line 1088
              range_sts_al = new_n_alloc___3;
              }
            }
#line 1088
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
          {
#line 1090
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1090
            if (range_ends_al <= work_mbc->nranges + 1UL) {
              {
#line 1090
              new_n_alloc___4 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_ends);
#line 1090
              tmp___72 = x2nrealloc((void *)work_mbc->range_ends, & new_n_alloc___4,
                                    sizeof(*(work_mbc->range_ends)));
#line 1090
              work_mbc->range_ends = (wchar_t *)tmp___72;
#line 1090
              range_ends_al = new_n_alloc___4;
              }
            }
#line 1090
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1092
          if (case_fold) {
            {
#line 1092
            tmp___73 = towlower(wc);
#line 1092
            *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )tmp___73;
            }
          } else {
#line 1092
            *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )wc;
          }
#line 1094
          tmp___74 = work_mbc->nranges;
#line 1094
          (work_mbc->nranges) ++;
#line 1094
          if (case_fold) {
            {
#line 1094
            tmp___75 = towlower(wc2);
#line 1094
            *(work_mbc->range_ends + tmp___74) = (wchar_t )tmp___75;
            }
          } else {
#line 1094
            *(work_mbc->range_ends + tmp___74) = (wchar_t )wc2;
          }
#line 1097
          if (case_fold) {
            {
#line 1097
            tmp___81 = iswalpha(wc);
            }
#line 1097
            if (tmp___81) {
#line 1097
              goto _L___3;
            } else {
              {
#line 1097
              tmp___82 = iswalpha(wc2);
              }
#line 1097
              if (tmp___82) {
                _L___3: /* CIL Label */ 
                {
#line 1099
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 1099
                  if (range_sts_al <= work_mbc->nranges + 1UL) {
                    {
#line 1099
                    new_n_alloc___5 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_sts);
#line 1099
                    tmp___76 = x2nrealloc((void *)work_mbc->range_sts, & new_n_alloc___5,
                                          sizeof(*(work_mbc->range_sts)));
#line 1099
                    work_mbc->range_sts = (wchar_t *)tmp___76;
#line 1099
                    range_sts_al = new_n_alloc___5;
                    }
                  }
#line 1099
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
                {
#line 1101
                tmp___77 = towupper(wc);
#line 1101
                *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )tmp___77;
                }
                {
#line 1102
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 1102
                  if (range_ends_al <= work_mbc->nranges + 1UL) {
                    {
#line 1102
                    new_n_alloc___6 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_ends);
#line 1102
                    tmp___78 = x2nrealloc((void *)work_mbc->range_ends, & new_n_alloc___6,
                                          sizeof(*(work_mbc->range_ends)));
#line 1102
                    work_mbc->range_ends = (wchar_t *)tmp___78;
#line 1102
                    range_ends_al = new_n_alloc___6;
                    }
                  }
#line 1102
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
                {
#line 1104
                tmp___79 = work_mbc->nranges;
#line 1104
                (work_mbc->nranges) ++;
#line 1104
                tmp___80 = towupper(wc2);
#line 1104
                *(work_mbc->range_ends + tmp___79) = (wchar_t )tmp___80;
                }
              }
            }
          }
        } else {
          {
#line 1111
          re.buffer = (struct re_dfa_t *)0;
#line 1111
          re.allocated = 0UL;
#line 1111
          re.used = 0UL;
#line 1111
          re.syntax = 0UL;
#line 1111
          re.fastmap = (char *)0;
#line 1111
          re.translate = (unsigned char *)0;
#line 1111
          re.re_nsub = 0UL;
#line 1111
          re.can_be_null = 0U;
#line 1111
          re.regs_allocated = 0U;
#line 1111
          re.fastmap_accurate = 0U;
#line 1111
          re.no_sub = 0U;
#line 1111
          re.not_bol = 0U;
#line 1111
          re.not_eol = 0U;
#line 1111
          re.newline_anchor = 0U;
#line 1114
          pattern[0] = (char )'[';
#line 1114
          pattern[1] = (char )'\\';
#line 1114
          pattern[2] = (char )c;
#line 1114
          pattern[3] = (char )'-';
#line 1114
          pattern[4] = (char )'\\';
#line 1114
          pattern[5] = (char )c2;
#line 1114
          pattern[6] = (char )']';
#line 1120
          re_set_syntax(syntax_bits | 1UL);
#line 1121
          compile_msg = re_compile_pattern((char const   *)(pattern), sizeof(pattern),
                                           & re);
          }
#line 1122
          if (compile_msg) {
            {
#line 1123
            dfaerror(compile_msg);
            }
          }
#line 1124
          c = 0;
          {
#line 1124
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 1124
            if (! (c < 1 << 8)) {
#line 1124
              goto while_break___20;
            }
            {
#line 1126
            subject = (char )c;
#line 1127
            tmp___83 = re_match(& re, (char const   *)(& subject), 1, 0, (struct re_registers *)((void *)0));
            }
            {
#line 1129
            if (tmp___83 == 1) {
#line 1129
              goto case_1;
            }
#line 1130
            if (tmp___83 == -1) {
#line 1130
              goto case_neg_1;
            }
#line 1131
            goto switch_default;
            case_1: /* CIL Label */ 
            {
#line 1129
            setbit((unsigned int )c, ccl);
            }
#line 1129
            goto switch_break;
            case_neg_1: /* CIL Label */ 
#line 1130
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 1131
            xalloc_die();
            }
            switch_break: /* CIL Label */ ;
            }
#line 1124
            c ++;
          }
          while_break___20: /* CIL Label */ ;
          }
          {
#line 1134
          regfree(& re);
#line 1135
          re_set_syntax(syntax_bits);
          }
        }
#line 1138
        colon_warning_state |= 8;
        {
#line 1139
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1139
          if (! lexleft) {
            {
#line 1139
            tmp___86 = gettext("unbalanced [");
            }
#line 1139
            if ((unsigned long )tmp___86 != (unsigned long )((char *)0)) {
              {
#line 1139
              tmp___85 = gettext("unbalanced [");
#line 1139
              dfaerror((char const   *)tmp___85);
              }
            } else {
#line 1139
              lasttok = (token )-1;
#line 1139
              return (lasttok);
            }
          } else {
            {
#line 1139
            tmp___87 = mbrtowc((wchar_t */* __restrict  */)(& _wc___9), (char const   */* __restrict  */)lexptr,
                               lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1139
            cur_mb_len = (int )tmp___87;
            }
#line 1139
            if (cur_mb_len <= 0) {
              {
#line 1139
              cur_mb_len = 1;
#line 1139
              lexleft --;
#line 1139
              tmp___88 = lexptr;
#line 1139
              lexptr ++;
#line 1139
              tmp___89 = to_uchar((char )*tmp___88);
#line 1139
              c1 = (int )tmp___89;
#line 1139
              wc1 = (wint_t )c1;
              }
            } else {
              {
#line 1139
              lexptr += cur_mb_len;
#line 1139
              lexleft -= (size_t )cur_mb_len;
#line 1139
              wc1 = (wint_t )_wc___9;
#line 1139
              c1 = wctob(wc1);
              }
            }
          }
#line 1139
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 1140
        goto __Cont;
      }
    }
#line 1143
    if (c == 58) {
#line 1143
      tmp___90 = 2;
    } else {
#line 1143
      tmp___90 = 4;
    }
    {
#line 1143
    colon_warning_state |= tmp___90;
#line 1145
    tmp___91 = __ctype_get_mb_cur_max();
    }
#line 1145
    if (tmp___91 == 1UL) {
      {
#line 1147
      setbit_case_fold_c(c, ccl);
      }
#line 1148
      goto __Cont;
    }
#line 1151
    if (case_fold) {
      {
#line 1151
      tmp___95 = iswalpha(wc);
      }
#line 1151
      if (tmp___95) {
        {
#line 1153
        wc = towlower(wc);
#line 1154
        tmp___94 = setbit_wc(wc, ccl);
        }
#line 1154
        if (! tmp___94) {
          {
#line 1156
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 1156
            if (chars_al <= work_mbc->nchars + 1UL) {
              {
#line 1156
              new_n_alloc___7 = (work_mbc->nchars + 1UL) + (size_t )(! work_mbc->chars);
#line 1156
              tmp___92 = x2nrealloc((void *)work_mbc->chars, & new_n_alloc___7, sizeof(*(work_mbc->chars)));
#line 1156
              work_mbc->chars = (wchar_t *)tmp___92;
#line 1156
              chars_al = new_n_alloc___7;
              }
            }
#line 1156
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 1158
          tmp___93 = work_mbc->nchars;
#line 1158
          (work_mbc->nchars) ++;
#line 1158
          *(work_mbc->chars + tmp___93) = (wchar_t )wc;
        }
        {
#line 1160
        wc = towupper(wc);
        }
      }
    }
    {
#line 1162
    tmp___98 = setbit_wc(wc, ccl);
    }
#line 1162
    if (! tmp___98) {
      {
#line 1164
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 1164
        if (chars_al <= work_mbc->nchars + 1UL) {
          {
#line 1164
          new_n_alloc___8 = (work_mbc->nchars + 1UL) + (size_t )(! work_mbc->chars);
#line 1164
          tmp___96 = x2nrealloc((void *)work_mbc->chars, & new_n_alloc___8, sizeof(*(work_mbc->chars)));
#line 1164
          work_mbc->chars = (wchar_t *)tmp___96;
#line 1164
          chars_al = new_n_alloc___8;
          }
        }
#line 1164
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 1166
      tmp___97 = work_mbc->nchars;
#line 1166
      (work_mbc->nchars) ++;
#line 1166
      *(work_mbc->chars + tmp___97) = (wchar_t )wc;
    }
    __Cont: /* CIL Label */ 
#line 966
    wc = wc1;
#line 966
    c = c1;
#line 966
    if (! (c != 93)) {
#line 966
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1171
  if (colon_warning_state == 7) {
    {
#line 1172
    tmp___99 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1172
    dfawarn((char const   *)tmp___99);
    }
  }
  {
#line 1174
  tmp___103 = __ctype_get_mb_cur_max();
  }
#line 1174
  if (tmp___103 > 1UL) {
    {
#line 1177
    work_mbc->invert = invert;
#line 1178
    tmp___102 = equal((unsigned int */* const  */)(ccl), (unsigned int */* const  */)(zeroclass));
    }
#line 1178
    if (tmp___102) {
#line 1178
      work_mbc->cset = (ptrdiff_t )-1;
    } else {
      {
#line 1178
      tmp___101 = charclass_index((unsigned int */* const  */)(ccl));
#line 1178
      work_mbc->cset = (ptrdiff_t )tmp___101;
      }
    }
#line 1179
    return ((token )273);
  }
#line 1182
  if (invert) {
    {
#line 1184
    tmp___107 = __ctype_get_mb_cur_max();
    }
#line 1184
    if (! (tmp___107 == 1UL)) {
      {
#line 1184
      __assert_fail("MB_CUR_MAX == 1", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    1184U, "parse_bracket_exp");
      }
    }
    {
#line 1185
    notset(ccl);
    }
#line 1186
    if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1187
      clrbit((unsigned int )eolbyte___0, ccl);
      }
    }
  }
  {
#line 1190
  tmp___108 = charclass_index((unsigned int */* const  */)(ccl));
  }
#line 1190
  return ((token )(275UL + tmp___108));
}
}
#line 1193 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static token lex(void) 
{ 
  unsigned int c ;
  unsigned int c2 ;
  int backslash ;
  charclass ccl ;
  int i ;
  wchar_t _wc ;
  size_t tmp ;
  char const   *tmp___0 ;
  unsigned char tmp___1 ;
  int tmp___2 ;
  wint_t wc ;
  wchar_t _wc___0 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *p ;
  char const   *lim ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  unsigned short const   **tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char const   *lexptr_saved ;
  size_t lexleft_saved ;
  unsigned short const   **tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  unsigned short const   **tmp___28 ;

  {
#line 1197
  backslash = 0;
#line 1207
  i = 0;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! (i < 2)) {
#line 1207
      goto while_break;
    }
    {
#line 1209
    tmp___7 = __ctype_get_mb_cur_max();
    }
#line 1209
    if (tmp___7 > 1UL) {
      {
#line 1211
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1211
        if (! lexleft) {
#line 1211
          lasttok = (token )-1;
#line 1211
          return (lasttok);
        } else {
          {
#line 1211
          tmp = mbrtowc((wchar_t */* __restrict  */)(& _wc), (char const   */* __restrict  */)lexptr,
                        lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1211
          cur_mb_len = (int )tmp;
          }
#line 1211
          if (cur_mb_len <= 0) {
            {
#line 1211
            cur_mb_len = 1;
#line 1211
            lexleft --;
#line 1211
            tmp___0 = lexptr;
#line 1211
            lexptr ++;
#line 1211
            tmp___1 = to_uchar((char )*tmp___0);
#line 1211
            c = (unsigned int )tmp___1;
#line 1211
            wctok = (wchar_t )c;
            }
          } else {
            {
#line 1211
            lexptr += cur_mb_len;
#line 1211
            lexleft -= (size_t )cur_mb_len;
#line 1211
            wctok = _wc;
#line 1211
            tmp___2 = wctob((wint_t )wctok);
#line 1211
            c = (unsigned int )tmp___2;
            }
          }
        }
#line 1211
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1212
      if ((int )c == -1) {
#line 1213
        goto normal_char;
      }
    } else {
      {
#line 1216
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1216
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1216
          if (! lexleft) {
#line 1216
            lasttok = (token )-1;
#line 1216
            return (lasttok);
          } else {
            {
#line 1216
            tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0), (char const   */* __restrict  */)lexptr,
                              lexleft, (mbstate_t */* __restrict  */)(& mbs));
#line 1216
            cur_mb_len = (int )tmp___3;
            }
#line 1216
            if (cur_mb_len <= 0) {
              {
#line 1216
              cur_mb_len = 1;
#line 1216
              lexleft --;
#line 1216
              tmp___4 = lexptr;
#line 1216
              lexptr ++;
#line 1216
              tmp___5 = to_uchar((char )*tmp___4);
#line 1216
              c = (unsigned int )tmp___5;
#line 1216
              wc = c;
              }
            } else {
              {
#line 1216
              lexptr += cur_mb_len;
#line 1216
              lexleft -= (size_t )cur_mb_len;
#line 1216
              wc = (wint_t )_wc___0;
#line 1216
              tmp___6 = wctob(wc);
#line 1216
              c = (unsigned int )tmp___6;
              }
            }
          }
#line 1216
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1216
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1220
    if (c == 92U) {
#line 1220
      goto case_92;
    }
#line 1228
    if (c == 94U) {
#line 1228
      goto case_94;
    }
#line 1236
    if (c == 36U) {
#line 1236
      goto case_36;
    }
#line 1260
    if (c == 57U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 56U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 55U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 54U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 53U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 52U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 51U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 50U) {
#line 1260
      goto case_57;
    }
#line 1260
    if (c == 49U) {
#line 1260
      goto case_57;
    }
#line 1268
    if (c == 96U) {
#line 1268
      goto case_96;
    }
#line 1273
    if (c == 39U) {
#line 1273
      goto case_39;
    }
#line 1278
    if (c == 60U) {
#line 1278
      goto case_60;
    }
#line 1283
    if (c == 62U) {
#line 1283
      goto case_62;
    }
#line 1288
    if (c == 98U) {
#line 1288
      goto case_98;
    }
#line 1293
    if (c == 66U) {
#line 1293
      goto case_66;
    }
#line 1298
    if (c == 63U) {
#line 1298
      goto case_63;
    }
#line 1307
    if (c == 42U) {
#line 1307
      goto case_42;
    }
#line 1314
    if (c == 43U) {
#line 1314
      goto case_43;
    }
#line 1323
    if (c == 123U) {
#line 1323
      goto case_123;
    }
#line 1381
    if (c == 124U) {
#line 1381
      goto case_124;
    }
#line 1389
    if (c == 10U) {
#line 1389
      goto case_10;
    }
#line 1396
    if (c == 40U) {
#line 1396
      goto case_40;
    }
#line 1403
    if (c == 41U) {
#line 1403
      goto case_41;
    }
#line 1412
    if (c == 46U) {
#line 1412
      goto case_46;
    }
#line 1432
    if (c == 83U) {
#line 1432
      goto case_83;
    }
#line 1432
    if (c == 115U) {
#line 1432
      goto case_83;
    }
#line 1477
    if (c == 87U) {
#line 1477
      goto case_87;
    }
#line 1477
    if (c == 119U) {
#line 1477
      goto case_87;
    }
#line 1489
    if (c == 91U) {
#line 1489
      goto case_91;
    }
#line 1495
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1221
    if (backslash) {
#line 1222
      goto normal_char;
    }
#line 1223
    if (lexleft == 0UL) {
      {
#line 1224
      tmp___8 = gettext("unfinished \\ escape");
#line 1224
      dfaerror((char const   *)tmp___8);
      }
    }
#line 1225
    backslash = 1;
#line 1226
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1229
    if (backslash) {
#line 1230
      goto normal_char;
    }
#line 1231
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1233
      lasttok = (token )258;
#line 1233
      return (lasttok);
    } else
#line 1231
    if (lasttok == -1L) {
#line 1233
      lasttok = (token )258;
#line 1233
      return (lasttok);
    } else
#line 1231
    if (lasttok == 270L) {
#line 1233
      lasttok = (token )258;
#line 1233
      return (lasttok);
    } else
#line 1231
    if (lasttok == 269L) {
#line 1233
      lasttok = (token )258;
#line 1233
      return (lasttok);
    }
#line 1234
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1237
    if (backslash) {
#line 1238
      goto normal_char;
    }
#line 1239
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1249
      lasttok = (token )259;
#line 1249
      return (lasttok);
    } else
#line 1239
    if (lexleft == 0UL) {
#line 1249
      lasttok = (token )259;
#line 1249
      return (lasttok);
    } else {
#line 1239
      if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1239
        if (lexleft > 0UL) {
#line 1239
          if ((int const   )*lexptr == 41) {
#line 1239
            tmp___9 = 1;
          } else {
#line 1239
            tmp___9 = 0;
          }
        } else {
#line 1239
          tmp___9 = 0;
        }
#line 1239
        tmp___11 = tmp___9;
      } else {
#line 1239
        if (lexleft > 1UL) {
#line 1239
          if ((int const   )*(lexptr + 0) == 92) {
#line 1239
            if ((int const   )*(lexptr + 1) == 41) {
#line 1239
              tmp___10 = 1;
            } else {
#line 1239
              tmp___10 = 0;
            }
          } else {
#line 1239
            tmp___10 = 0;
          }
        } else {
#line 1239
          tmp___10 = 0;
        }
#line 1239
        tmp___11 = tmp___10;
      }
#line 1239
      if (tmp___11) {
#line 1249
        lasttok = (token )259;
#line 1249
        return (lasttok);
      } else {
#line 1239
        if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1239
          if (lexleft > 0UL) {
#line 1239
            if ((int const   )*lexptr == 124) {
#line 1239
              tmp___12 = 1;
            } else {
#line 1239
              tmp___12 = 0;
            }
          } else {
#line 1239
            tmp___12 = 0;
          }
#line 1239
          tmp___14 = tmp___12;
        } else {
#line 1239
          if (lexleft > 1UL) {
#line 1239
            if ((int const   )*(lexptr + 0) == 92) {
#line 1239
              if ((int const   )*(lexptr + 1) == 124) {
#line 1239
                tmp___13 = 1;
              } else {
#line 1239
                tmp___13 = 0;
              }
            } else {
#line 1239
              tmp___13 = 0;
            }
          } else {
#line 1239
            tmp___13 = 0;
          }
#line 1239
          tmp___14 = tmp___13;
        }
#line 1239
        if (tmp___14) {
#line 1249
          lasttok = (token )259;
#line 1249
          return (lasttok);
        } else
#line 1239
        if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1239
          if (lexleft > 0UL) {
#line 1239
            if ((int const   )*lexptr == 10) {
#line 1249
              lasttok = (token )259;
#line 1249
              return (lasttok);
            }
          }
        }
      }
    }
#line 1250
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1261
    if (backslash) {
#line 1261
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1263
        laststart = 0;
#line 1264
        lasttok = (token )257;
#line 1264
        return (lasttok);
      }
    }
#line 1266
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1269
    if (backslash) {
#line 1269
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1270
        lasttok = (token )258;
#line 1270
        return (lasttok);
      }
    }
#line 1271
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1274
    if (backslash) {
#line 1274
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1275
        lasttok = (token )259;
#line 1275
        return (lasttok);
      }
    }
#line 1276
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1279
    if (backslash) {
#line 1279
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1280
        lasttok = (token )260;
#line 1280
        return (lasttok);
      }
    }
#line 1281
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1284
    if (backslash) {
#line 1284
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1285
        lasttok = (token )261;
#line 1285
        return (lasttok);
      }
    }
#line 1286
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1289
    if (backslash) {
#line 1289
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1290
        lasttok = (token )262;
#line 1290
        return (lasttok);
      }
    }
#line 1291
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1294
    if (backslash) {
#line 1294
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1295
        lasttok = (token )263;
#line 1295
        return (lasttok);
      }
    }
#line 1296
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1299
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1300
      goto normal_char;
    }
#line 1301
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1302
      goto normal_char;
    }
#line 1303
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1303
      if (laststart) {
#line 1304
        goto normal_char;
      }
    }
#line 1305
    lasttok = (token )264;
#line 1305
    return (lasttok);
    case_42: /* CIL Label */ 
#line 1308
    if (backslash) {
#line 1309
      goto normal_char;
    }
#line 1310
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1310
      if (laststart) {
#line 1311
        goto normal_char;
      }
    }
#line 1312
    lasttok = (token )265;
#line 1312
    return (lasttok);
    case_43: /* CIL Label */ 
#line 1315
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1316
      goto normal_char;
    }
#line 1317
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1318
      goto normal_char;
    }
#line 1319
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1319
      if (laststart) {
#line 1320
        goto normal_char;
      }
    }
#line 1321
    lasttok = (token )266;
#line 1321
    return (lasttok);
    case_123: /* CIL Label */ 
#line 1324
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1325
      goto normal_char;
    }
#line 1326
    if (backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1327
      goto normal_char;
    }
#line 1328
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1328
      if (laststart) {
#line 1329
        goto normal_char;
      }
    }
#line 1338
    p = lexptr;
#line 1339
    lim = p + lexleft;
#line 1340
    maxrep = -1;
#line 1340
    minrep = maxrep;
    {
#line 1341
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1341
      if ((unsigned long )p != (unsigned long )lim) {
#line 1341
        if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1341
          goto while_break___3;
        }
      } else {
#line 1341
        goto while_break___3;
      }
#line 1343
      if (minrep < 0) {
#line 1344
        minrep = (int )((int const   )*p - 48);
      } else
#line 1346
      if (32768 < (minrep * 10 + (int )*p) - 48) {
#line 1346
        minrep = 32768;
      } else {
#line 1346
        minrep = (minrep * 10 + (int )*p) - 48;
      }
#line 1341
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1348
    if ((unsigned long )p != (unsigned long )lim) {
#line 1350
      if ((int const   )*p != 44) {
#line 1351
        maxrep = minrep;
      } else {
#line 1354
        if (minrep < 0) {
#line 1355
          minrep = 0;
        }
        {
#line 1356
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1356
          p ++;
#line 1356
          if ((unsigned long )p != (unsigned long )lim) {
#line 1356
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1356
              goto while_break___4;
            }
          } else {
#line 1356
            goto while_break___4;
          }
#line 1358
          if (maxrep < 0) {
#line 1359
            maxrep = (int )((int const   )*p - 48);
          } else
#line 1361
          if (32768 < (maxrep * 10 + (int )*p) - 48) {
#line 1361
            maxrep = 32768;
          } else {
#line 1361
            maxrep = (maxrep * 10 + (int )*p) - 48;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 1365
    if (! backslash) {
#line 1365
      goto _L___3;
    } else
#line 1365
    if ((unsigned long )p != (unsigned long )lim) {
#line 1365
      tmp___16 = p;
#line 1365
      p ++;
#line 1365
      if ((int const   )*tmp___16 == 92) {
        _L___3: /* CIL Label */ 
#line 1365
        if ((unsigned long )p != (unsigned long )lim) {
#line 1365
          tmp___17 = p;
#line 1365
          p ++;
#line 1365
          if ((int const   )*tmp___17 == 125) {
#line 1365
            if (0 <= minrep) {
#line 1365
              if (! (maxrep < 0)) {
#line 1365
                if (! (minrep <= maxrep)) {
#line 1365
                  goto _L___4;
                }
              }
            } else {
#line 1365
              goto _L___4;
            }
          } else {
#line 1365
            goto _L___4;
          }
        } else {
#line 1365
          goto _L___4;
        }
      } else {
#line 1365
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 1369
      if (syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1370
        goto normal_char;
      }
      {
#line 1371
      tmp___15 = gettext("Invalid content of \\{\\}");
#line 1371
      dfaerror((char const   *)tmp___15);
      }
    }
#line 1373
    if (32767 < maxrep) {
      {
#line 1374
      tmp___18 = gettext("Regular expression too big");
#line 1374
      dfaerror((char const   *)tmp___18);
      }
    }
#line 1375
    lexptr = p;
#line 1376
    lexleft = (size_t )(lim - p);
#line 1378
    laststart = 0;
#line 1379
    lasttok = (token )267;
#line 1379
    return (lasttok);
    case_124: /* CIL Label */ 
#line 1382
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1383
      goto normal_char;
    }
#line 1384
    if (backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1385
      goto normal_char;
    }
#line 1386
    laststart = 1;
#line 1387
    lasttok = (token )269;
#line 1387
    return (lasttok);
    case_10: /* CIL Label */ 
#line 1390
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1392
      goto normal_char;
    } else
#line 1390
    if (backslash) {
#line 1392
      goto normal_char;
    } else
#line 1390
    if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1392
      goto normal_char;
    }
#line 1393
    laststart = 1;
#line 1394
    lasttok = (token )269;
#line 1394
    return (lasttok);
    case_40: /* CIL Label */ 
#line 1397
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1398
      goto normal_char;
    }
#line 1399
    parens ++;
#line 1400
    laststart = 1;
#line 1401
    lasttok = (token )270;
#line 1401
    return (lasttok);
    case_41: /* CIL Label */ 
#line 1404
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1405
      goto normal_char;
    }
#line 1406
    if (parens == 0UL) {
#line 1406
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1407
        goto normal_char;
      }
    }
#line 1408
    parens --;
#line 1409
    laststart = 0;
#line 1410
    lasttok = (token )271;
#line 1410
    return (lasttok);
    case_46: /* CIL Label */ 
#line 1413
    if (backslash) {
#line 1414
      goto normal_char;
    }
    {
#line 1415
    tmp___19 = __ctype_get_mb_cur_max();
    }
#line 1415
    if (tmp___19 > 1UL) {
#line 1419
      laststart = 0;
#line 1420
      lasttok = (token )272;
#line 1420
      return (lasttok);
    }
    {
#line 1422
    zeroset(ccl);
#line 1423
    notset(ccl);
    }
#line 1424
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
#line 1425
      clrbit((unsigned int )eolbyte___0, ccl);
      }
    }
#line 1426
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1427
      clrbit((unsigned int )'\000', ccl);
      }
    }
    {
#line 1428
    laststart = 0;
#line 1429
    tmp___20 = charclass_index((unsigned int */* const  */)(ccl));
#line 1429
    lasttok = (token )(275UL + tmp___20);
    }
#line 1429
    return (lasttok);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1433
    if (! backslash) {
#line 1434
      goto normal_char;
    } else
#line 1433
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1434
      goto normal_char;
    }
    {
#line 1435
    tmp___23 = __ctype_get_mb_cur_max();
    }
#line 1435
    if (tmp___23 == 1UL) {
      {
#line 1437
      zeroset(ccl);
#line 1438
      c2 = 0U;
      }
      {
#line 1438
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1438
        if (! (c2 < (unsigned int )(1 << 8))) {
#line 1438
          goto while_break___5;
        }
        {
#line 1439
        tmp___21 = __ctype_b_loc();
        }
#line 1439
        if ((int const   )*(*tmp___21 + (int )c2) & 8192) {
          {
#line 1440
          setbit(c2, ccl);
          }
        }
#line 1438
        c2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1441
      if (c == 83U) {
        {
#line 1442
        notset(ccl);
        }
      }
      {
#line 1443
      laststart = 0;
#line 1444
      tmp___22 = charclass_index((unsigned int */* const  */)(ccl));
#line 1444
      lasttok = (token )(275UL + tmp___22);
      }
#line 1444
      return (lasttok);
    }
    {
#line 1467
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1467
      lexptr_saved = lexptr;
#line 1467
      lexleft_saved = lexleft;
#line 1467
      if (c == 115U) {
#line 1467
        lexptr = "[:space:]]";
      } else {
#line 1467
        lexptr = "^[:space:]]";
      }
      {
#line 1467
      lexleft = strlen(lexptr);
#line 1469
      lasttok = parse_bracket_exp();
#line 1471
      lexptr = lexptr_saved;
#line 1471
      lexleft = lexleft_saved;
      }
#line 1467
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1473
    laststart = 0;
#line 1474
    return (lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1478
    if (! backslash) {
#line 1479
      goto normal_char;
    } else
#line 1478
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1479
      goto normal_char;
    }
    {
#line 1480
    zeroset(ccl);
#line 1481
    c2 = 0U;
    }
    {
#line 1481
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1481
      if (! (c2 < (unsigned int )(1 << 8))) {
#line 1481
        goto while_break___7;
      }
      {
#line 1482
      tmp___24 = __ctype_b_loc();
      }
#line 1482
      if ((int const   )*(*tmp___24 + (int )c2) & 8) {
        {
#line 1483
        setbit(c2, ccl);
        }
      } else
#line 1482
      if (c2 == 95U) {
        {
#line 1483
        setbit(c2, ccl);
        }
      }
#line 1481
      c2 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1484
    if (c == 87U) {
      {
#line 1485
      notset(ccl);
      }
    }
    {
#line 1486
    laststart = 0;
#line 1487
    tmp___25 = charclass_index((unsigned int */* const  */)(ccl));
#line 1487
    lasttok = (token )(275UL + tmp___25);
    }
#line 1487
    return (lasttok);
    case_91: /* CIL Label */ 
#line 1490
    if (backslash) {
#line 1491
      goto normal_char;
    }
    {
#line 1492
    laststart = 0;
#line 1493
    lasttok = parse_bracket_exp();
    }
#line 1493
    return (lasttok);
    normal_char: 
    switch_default: /* CIL Label */ 
    {
#line 1497
    laststart = 0;
#line 1500
    tmp___26 = __ctype_get_mb_cur_max();
    }
#line 1500
    if (tmp___26 > 1UL) {
#line 1501
      lasttok = (token )274;
#line 1501
      return (lasttok);
    }
#line 1503
    if (case_fold) {
      {
#line 1503
      tmp___28 = __ctype_b_loc();
      }
#line 1503
      if ((int const   )*(*tmp___28 + (int )c) & 1024) {
        {
#line 1505
        zeroset(ccl);
#line 1506
        setbit_case_fold_c((int )c, ccl);
#line 1507
        tmp___27 = charclass_index((unsigned int */* const  */)(ccl));
#line 1507
        lasttok = (token )(275UL + tmp___27);
        }
#line 1507
        return (lasttok);
      }
    }
#line 1510
    lasttok = (token )c;
#line 1510
    return (lasttok);
    switch_break: /* CIL Label */ ;
    }
#line 1207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1516
  abort();
  }
#line 1517
  return ((token )-1);
}
}
#line 1522 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static token tok  ;
#line 1523 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static size_t depth  ;
#line 1529 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void addtok_mb(token t , int mbprop ) 
{ 
  size_t new_n_alloc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t new_n_alloc___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1532
  tmp___0 = __ctype_get_mb_cur_max();
  }
#line 1532
  if (tmp___0 > 1UL) {
    {
#line 1534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1534
      if (dfa___0->nmultibyte_prop <= dfa___0->tindex + 1UL) {
        {
#line 1534
        new_n_alloc = (dfa___0->tindex + 1UL) + (size_t )(! dfa___0->multibyte_prop);
#line 1534
        tmp = x2nrealloc((void *)dfa___0->multibyte_prop, & new_n_alloc, sizeof(*(dfa___0->multibyte_prop)));
#line 1534
        dfa___0->multibyte_prop = (int *)tmp;
#line 1534
        dfa___0->nmultibyte_prop = new_n_alloc;
        }
      }
#line 1534
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1536
    *(dfa___0->multibyte_prop + dfa___0->tindex) = mbprop;
  }
  {
#line 1539
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1539
    if (dfa___0->talloc <= dfa___0->tindex + 1UL) {
      {
#line 1539
      new_n_alloc___0 = (dfa___0->tindex + 1UL) + (size_t )(! dfa___0->tokens);
#line 1539
      tmp___1 = x2nrealloc((void *)dfa___0->tokens, & new_n_alloc___0, sizeof(*(dfa___0->tokens)));
#line 1539
      dfa___0->tokens = (token *)tmp___1;
#line 1539
      dfa___0->talloc = new_n_alloc___0;
      }
    }
#line 1539
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1540
  tmp___2 = dfa___0->tindex;
#line 1540
  (dfa___0->tindex) ++;
#line 1540
  *(dfa___0->tokens + tmp___2) = t;
  {
#line 1546
  if (t == 266L) {
#line 1546
    goto case_266;
  }
#line 1546
  if (t == 265L) {
#line 1546
    goto case_266;
  }
#line 1546
  if (t == 264L) {
#line 1546
    goto case_266;
  }
#line 1550
  if (t == 269L) {
#line 1550
    goto case_269;
  }
#line 1550
  if (t == 268L) {
#line 1550
    goto case_269;
  }
#line 1556
  if (t == 256L) {
#line 1556
    goto case_256;
  }
#line 1554
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1547
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1551
  depth --;
#line 1552
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1555
  (dfa___0->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1557
  depth ++;
#line 1558
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1560
  if (depth > dfa___0->depth) {
#line 1561
    dfa___0->depth = depth;
  }
#line 1562
  return;
}
}
#line 1564
static void addtok_wc(wint_t wc ) ;
#line 1568 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void addtok(token t ) 
{ 
  _Bool need_or ;
  struct mb_char_classes *work_mbc ;
  size_t i ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 1571
  tmp___4 = __ctype_get_mb_cur_max();
  }
#line 1571
  if (tmp___4 > 1UL) {
#line 1571
    if (t == 273L) {
#line 1573
      need_or = (_Bool)0;
#line 1574
      work_mbc = dfa___0->mbcsets + (dfa___0->nmbcsets - 1UL);
#line 1578
      if (! work_mbc->invert) {
#line 1581
        i = (size_t )0;
        {
#line 1581
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1581
          if (! (i < work_mbc->nchars)) {
#line 1581
            goto while_break;
          }
          {
#line 1583
          addtok_wc((wint_t )*(work_mbc->chars + i));
          }
#line 1584
          if (need_or) {
            {
#line 1585
            addtok((token )269);
            }
          }
#line 1586
          need_or = (_Bool)1;
#line 1581
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1588
        work_mbc->nchars = (size_t )0;
      }
#line 1592
      if (work_mbc->invert) {
#line 1592
        goto _L;
      } else {
        {
#line 1592
        tmp___3 = using_utf8();
        }
#line 1592
        if (tmp___3) {
          _L___0: /* CIL Label */ 
#line 1592
          if (work_mbc->nchars != 0UL) {
#line 1592
            goto _L;
          } else
#line 1592
          if (work_mbc->nch_classes != 0UL) {
#line 1592
            goto _L;
          } else
#line 1592
          if (work_mbc->nranges != 0UL) {
#line 1592
            goto _L;
          } else
#line 1592
          if (work_mbc->nequivs != 0UL) {
#line 1592
            goto _L;
          } else
#line 1592
          if (work_mbc->ncoll_elems != 0UL) {
            _L: /* CIL Label */ 
            {
#line 1599
            addtok_mb((token )273, (int )(((dfa___0->nmbcsets - 1UL) << 2) + 3UL));
            }
#line 1600
            if (need_or) {
              {
#line 1601
              addtok((token )269);
              }
            }
          } else
#line 1607
          if (work_mbc->cset != -1L) {
            {
#line 1609
            tmp___2 = using_utf8();
            }
#line 1609
            if (! tmp___2) {
              {
#line 1609
              __assert_fail("using_utf8 ()", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                            1609U, "addtok");
              }
            }
            {
#line 1610
            addtok(275L + work_mbc->cset);
            }
#line 1611
            if (need_or) {
              {
#line 1612
              addtok((token )269);
              }
            }
          }
        } else
#line 1592
        if (work_mbc->cset != -1L) {
#line 1592
          goto _L;
        } else {
#line 1592
          goto _L___0;
        }
      }
    } else {
      {
#line 1618
      addtok_mb(t, 3);
      }
    }
  } else {
    {
#line 1618
    addtok_mb(t, 3);
    }
  }
#line 1620
  return;
}
}
#line 1629 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void addtok_wc(wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1635
  memset((void *)(& s), 0, sizeof(s));
#line 1636
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1636
  cur_mb_len = (int )tmp;
  }
#line 1641
  if (cur_mb_len <= 0) {
#line 1642
    buf[0] = (unsigned char)0;
  }
#line 1644
  if (cur_mb_len == 1) {
#line 1644
    tmp___0 = 3;
  } else {
#line 1644
    tmp___0 = 1;
  }
  {
#line 1644
  addtok_mb((token )buf[0], tmp___0);
#line 1645
  i = 1;
  }
  {
#line 1645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1645
    if (! (i < cur_mb_len)) {
#line 1645
      goto while_break;
    }
#line 1647
    if (i == cur_mb_len - 1) {
#line 1647
      tmp___1 = 2;
    } else {
#line 1647
      tmp___1 = 0;
    }
    {
#line 1647
    addtok_mb((token )buf[i], tmp___1);
#line 1648
    addtok((token )268);
#line 1645
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1650
  return;
}
}
#line 1662
static void add_utf8_anychar(void) ;
#line 1662 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static charclass const   utf8_classes[5]  = { {        0U,        0U,        0U,        0U, 
            (unsigned int )(~ 0),        (unsigned int )(~ 0),        0U,        0U}, 
   {        (unsigned int )(~ 0),        (unsigned int )(~ 0),        (unsigned int )(~ 0),        (unsigned int )(~ 0), 
            0U,        0U,        0U,        0U}, 
   {        0U,        0U,        0U,        0U, 
            0U,        0U,        (unsigned int )(~ 3),        0U}, 
   {        0U,        0U,        0U,        0U, 
            0U,        0U,        0U,        65535U}, 
   {        0U,        0U,        0U,        0U, 
            0U,        0U,        0U,        16711680U}};
#line 1658 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void add_utf8_anychar(void) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  size_t tmp ;

  {
#line 1669
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1673
  if (dfa___0->utf8_anychar_classes[0] == 0L) {
#line 1674
    i = 0U;
    {
#line 1674
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1674
      if (! (i < n)) {
#line 1674
        goto while_break;
      }
      {
#line 1677
      copyset(utf8_classes[i], c);
      }
#line 1678
      if (i == 1U) {
#line 1680
        if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1681
          clrbit((unsigned int )eolbyte___0, c);
          }
        }
#line 1682
        if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1683
          clrbit((unsigned int )'\000', c);
          }
        }
      }
      {
#line 1685
      tmp = charclass_index((unsigned int */* const  */)(c));
#line 1685
      dfa___0->utf8_anychar_classes[i] = (token )(275UL + tmp);
#line 1674
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1698
  i = 1U;
  {
#line 1698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1698
    if (! (i < n)) {
#line 1698
      goto while_break___0;
    }
    {
#line 1699
    addtok(dfa___0->utf8_anychar_classes[i]);
#line 1698
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1700
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1700
    i --;
#line 1700
    if (! (i > 1U)) {
#line 1700
      goto while_break___1;
    }
    {
#line 1702
    addtok(dfa___0->utf8_anychar_classes[0]);
#line 1703
    addtok((token )268);
#line 1704
    addtok((token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1707
  return;
}
}
#line 1744 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void atom(void) 
{ 
  wint_t tmp ;
  wint_t tmp___0 ;
  wint_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1751
  if (tok == 274L) {
#line 1753
    if (case_fold) {
      {
#line 1753
      tmp = towlower((wint_t )wctok);
#line 1753
      tmp___0 = tmp;
      }
    } else {
#line 1753
      tmp___0 = (wint_t )wctok;
    }
    {
#line 1753
    addtok_wc(tmp___0);
    }
#line 1754
    if (case_fold) {
      {
#line 1754
      tmp___2 = iswalpha((wint_t )wctok);
      }
#line 1754
      if (tmp___2) {
        {
#line 1756
        tmp___1 = towupper((wint_t )wctok);
#line 1756
        addtok_wc(tmp___1);
#line 1757
        addtok((token )269);
        }
      }
    }
    {
#line 1760
    tok = lex();
    }
  } else
#line 1762
  if (tok == 272L) {
    {
#line 1762
    tmp___4 = using_utf8();
    }
#line 1762
    if (tmp___4) {
      {
#line 1771
      add_utf8_anychar();
#line 1772
      tok = lex();
      }
    } else {
#line 1762
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1774
  if (tok >= 0L) {
#line 1774
    if (tok < (token )(1 << 8)) {
      {
#line 1781
      addtok(tok);
#line 1782
      tok = lex();
      }
    } else {
#line 1774
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1774
  if (tok >= 275L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 257L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 258L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 259L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 260L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 272L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 273L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 261L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 262L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1774
  if (tok == 263L) {
    {
#line 1781
    addtok(tok);
#line 1782
    tok = lex();
    }
  } else
#line 1784
  if (tok == 270L) {
    {
#line 1786
    tok = lex();
#line 1787
    regexp();
    }
#line 1788
    if (tok != 271L) {
      {
#line 1789
      tmp___3 = gettext("unbalanced (");
#line 1789
      dfaerror((char const   *)tmp___3);
      }
    }
    {
#line 1790
    tok = lex();
    }
  } else {
    {
#line 1793
    addtok((token )256);
    }
  }
#line 1794
  return;
}
}
#line 1797 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(size_t tindex ) 
{ 
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1808
  if (*(dfa___0->tokens + (tindex - 1UL)) == 266L) {
#line 1808
    goto case_266;
  }
#line 1808
  if (*(dfa___0->tokens + (tindex - 1UL)) == 265L) {
#line 1808
    goto case_266;
  }
#line 1808
  if (*(dfa___0->tokens + (tindex - 1UL)) == 264L) {
#line 1808
    goto case_266;
  }
#line 1811
  if (*(dfa___0->tokens + (tindex - 1UL)) == 269L) {
#line 1811
    goto case_269;
  }
#line 1811
  if (*(dfa___0->tokens + (tindex - 1UL)) == 268L) {
#line 1811
    goto case_269;
  }
#line 1804
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1805
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1809
  tmp = nsubtoks(tindex - 1UL);
  }
#line 1809
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1812
  tmp___0 = nsubtoks(tindex - 1UL);
#line 1812
  ntoks1 = (size_t )tmp___0;
#line 1813
  tmp___1 = nsubtoks((tindex - 1UL) - ntoks1);
  }
#line 1813
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1818 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void copytoks(size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t tmp ;

  {
  {
#line 1823
  tmp = __ctype_get_mb_cur_max();
  }
#line 1823
  if (tmp > 1UL) {
#line 1824
    i = (size_t )0;
    {
#line 1824
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1824
      if (! (i < ntokens)) {
#line 1824
        goto while_break;
      }
      {
#line 1825
      addtok_mb(*(dfa___0->tokens + (tindex + i)), *(dfa___0->multibyte_prop + (tindex + i)));
#line 1824
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1827
    i = (size_t )0;
    {
#line 1827
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1827
      if (! (i < ntokens)) {
#line 1827
        goto while_break___0;
      }
      {
#line 1828
      addtok_mb(*(dfa___0->tokens + (tindex + i)), 3);
#line 1827
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1829
  return;
}
}
#line 1831 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void closure(void) 
{ 
  int i ;
  size_t tindex ;
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1837
  atom();
  }
  {
#line 1838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1838
    if (! (tok == 264L)) {
#line 1838
      if (! (tok == 265L)) {
#line 1838
        if (! (tok == 266L)) {
#line 1838
          if (! (tok == 267L)) {
#line 1838
            goto while_break;
          }
        }
      }
    }
#line 1839
    if (tok == 267L) {
#line 1839
      if (minrep) {
#line 1839
        goto _L___0;
      } else
#line 1839
      if (maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1841
        tmp = nsubtoks(dfa___0->tindex);
#line 1841
        ntokens = (size_t )tmp;
#line 1842
        tindex = dfa___0->tindex - ntokens;
        }
#line 1843
        if (maxrep < 0) {
          {
#line 1844
          addtok((token )266);
          }
        }
#line 1845
        if (minrep == 0) {
          {
#line 1846
          addtok((token )264);
          }
        }
#line 1847
        i = 1;
        {
#line 1847
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1847
          if (! (i < minrep)) {
#line 1847
            goto while_break___0;
          }
          {
#line 1849
          copytoks(tindex, ntokens);
#line 1850
          addtok((token )268);
#line 1847
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1852
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1852
          if (! (i < maxrep)) {
#line 1852
            goto while_break___1;
          }
          {
#line 1854
          copytoks(tindex, ntokens);
#line 1855
          addtok((token )264);
#line 1856
          addtok((token )268);
#line 1852
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1858
        tok = lex();
        }
      } else {
#line 1839
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1860
    if (tok == 267L) {
      {
#line 1862
      tmp___0 = nsubtoks(dfa___0->tindex);
#line 1862
      dfa___0->tindex -= (size_t )tmp___0;
#line 1863
      tok = lex();
#line 1864
      closure();
      }
    } else {
      {
#line 1868
      addtok(tok);
#line 1869
      tok = lex();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1871
  return;
}
}
#line 1873 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void branch(void) 
{ 


  {
  {
#line 1876
  closure();
  }
  {
#line 1877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1877
    if (tok != 271L) {
#line 1877
      if (tok != 269L) {
#line 1877
        if (! (tok >= 0L)) {
#line 1877
          goto while_break;
        }
      } else {
#line 1877
        goto while_break;
      }
    } else {
#line 1877
      goto while_break;
    }
    {
#line 1879
    closure();
#line 1880
    addtok((token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1882
  return;
}
}
#line 1884 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void regexp(void) 
{ 


  {
  {
#line 1887
  branch();
  }
  {
#line 1888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1888
    if (! (tok == 269L)) {
#line 1888
      goto while_break;
    }
    {
#line 1890
    tok = lex();
#line 1891
    branch();
#line 1892
    addtok((token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1894
  return;
}
}
#line 1899 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1902
  dfa___0 = d;
#line 1903
  lexptr = s;
#line 1904
  lexleft = len;
#line 1905
  lasttok = (token )-1;
#line 1906
  laststart = 1;
#line 1907
  parens = (size_t )0;
#line 1908
  tmp = __ctype_get_mb_cur_max();
  }
#line 1908
  if (tmp > 1UL) {
    {
#line 1910
    cur_mb_len = 0;
#line 1911
    memset((void *)(& mbs), 0, sizeof(mbs));
    }
  }
#line 1914
  if (! syntax_bits_set) {
    {
#line 1915
    tmp___0 = gettext("no syntax specified");
#line 1915
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1917
  tok = lex();
#line 1918
  depth = d->depth;
#line 1920
  regexp();
  }
#line 1922
  if (tok != -1L) {
    {
#line 1923
    tmp___1 = gettext("unbalanced )");
#line 1923
    dfaerror((char const   *)tmp___1);
    }
  }
  {
#line 1925
  addtok((token )(0xffffffffffffffffUL - d->nregexps));
#line 1926
  addtok((token )268);
  }
#line 1928
  if (d->nregexps) {
    {
#line 1929
    addtok((token )269);
    }
  }
#line 1931
  (d->nregexps) ++;
#line 1932
  return;
}
}
#line 1937 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  size_t new_n_alloc ;
  void *tmp ;

  {
  {
#line 1940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1940
    if (dst->alloc <= (size_t )src->nelem) {
      {
#line 1940
      new_n_alloc = (size_t )(src->nelem + (size_t const   )(! dst->elems));
#line 1940
      tmp = x2nrealloc((void *)dst->elems, & new_n_alloc, sizeof(*(dst->elems)));
#line 1940
      dst->elems = (position *)tmp;
#line 1940
      dst->alloc = new_n_alloc;
      }
    }
#line 1940
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1941
  memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
         sizeof(*(dst->elems + 0)) * (unsigned long )src->nelem);
#line 1942
  dst->nelem = (size_t )src->nelem;
  }
#line 1943
  return;
}
}
#line 1945 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void alloc_position_set(position_set *s , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (sizeof(*(s->elems)) == 1UL) {
      {
#line 1948
      tmp = xmalloc(size);
#line 1948
      s->elems = (position *)tmp;
      }
    } else {
      {
#line 1948
      tmp___0 = xnmalloc(size, sizeof(*(s->elems)));
#line 1948
      s->elems = (position *)tmp___0;
      }
    }
#line 1948
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1949
  s->alloc = size;
#line 1950
  s->nelem = (size_t )0;
#line 1951
  return;
}
}
#line 1957 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void insert(position p , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t i ;
  size_t mid ;
  size_t new_n_alloc ;
  void *tmp ;

  {
#line 1960
  count = s->nelem;
#line 1961
  lo = (size_t )0;
#line 1961
  hi = count;
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if (! (lo < hi)) {
#line 1963
      goto while_break;
    }
#line 1965
    mid = (lo + hi) >> 1;
#line 1966
    if ((s->elems + mid)->index > p.index) {
#line 1967
      lo = mid + 1UL;
    } else {
#line 1969
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1972
  if (lo < count) {
#line 1972
    if (p.index == (s->elems + lo)->index) {
#line 1974
      (s->elems + lo)->constraint |= p.constraint;
#line 1975
      return;
    }
  }
  {
#line 1978
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1978
    if (s->alloc <= count + 1UL) {
      {
#line 1978
      new_n_alloc = (count + 1UL) + (size_t )(! s->elems);
#line 1978
      tmp = x2nrealloc((void *)s->elems, & new_n_alloc, sizeof(*(s->elems)));
#line 1978
      s->elems = (position *)tmp;
#line 1978
      s->alloc = new_n_alloc;
      }
    }
#line 1978
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1979
  i = count;
  {
#line 1979
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1979
    if (! (i > lo)) {
#line 1979
      goto while_break___1;
    }
#line 1980
    *(s->elems + i) = *(s->elems + (i - 1UL));
#line 1979
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1981
  *(s->elems + lo) = p;
#line 1982
  (s->nelem) ++;
#line 1983
  return;
}
}
#line 1987 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 
  size_t i ;
  size_t j ;
  size_t new_n_alloc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 1990
  i = (size_t )0;
#line 1990
  j = (size_t )0;
  {
#line 1992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1992
    if (m->alloc <= (size_t )(s1->nelem + s2->nelem)) {
      {
#line 1992
      new_n_alloc = (size_t )((s1->nelem + s2->nelem) + (size_t const   )(! m->elems));
#line 1992
      tmp = x2nrealloc((void *)m->elems, & new_n_alloc, sizeof(*(m->elems)));
#line 1992
      m->elems = (position *)tmp;
#line 1992
      m->alloc = new_n_alloc;
      }
    }
#line 1992
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  m->nelem = (size_t )0;
  {
#line 1994
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1994
    if (i < (size_t )s1->nelem) {
#line 1994
      if (! (j < (size_t )s2->nelem)) {
#line 1994
        goto while_break___0;
      }
    } else {
#line 1994
      goto while_break___0;
    }
#line 1995
    if ((s1->elems + i)->index > (s2->elems + j)->index) {
#line 1996
      tmp___0 = m->nelem;
#line 1996
      (m->nelem) ++;
#line 1996
      tmp___1 = i;
#line 1996
      i ++;
#line 1996
      *(m->elems + tmp___0) = *(s1->elems + tmp___1);
    } else
#line 1997
    if ((s1->elems + i)->index < (s2->elems + j)->index) {
#line 1998
      tmp___2 = m->nelem;
#line 1998
      (m->nelem) ++;
#line 1998
      tmp___3 = j;
#line 1998
      j ++;
#line 1998
      *(m->elems + tmp___2) = *(s2->elems + tmp___3);
    } else {
#line 2001
      tmp___4 = i;
#line 2001
      i ++;
#line 2001
      *(m->elems + m->nelem) = *(s1->elems + tmp___4);
#line 2002
      tmp___5 = m->nelem;
#line 2002
      (m->nelem) ++;
#line 2002
      tmp___6 = j;
#line 2002
      j ++;
#line 2002
      (m->elems + tmp___5)->constraint |= (s2->elems + tmp___6)->constraint;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2004
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2004
    if (! (i < (size_t )s1->nelem)) {
#line 2004
      goto while_break___1;
    }
#line 2005
    tmp___7 = m->nelem;
#line 2005
    (m->nelem) ++;
#line 2005
    tmp___8 = i;
#line 2005
    i ++;
#line 2005
    *(m->elems + tmp___7) = *(s1->elems + tmp___8);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2006
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2006
    if (! (j < (size_t )s2->nelem)) {
#line 2006
      goto while_break___2;
    }
#line 2007
    tmp___9 = m->nelem;
#line 2007
    (m->nelem) ++;
#line 2007
    tmp___10 = j;
#line 2007
    j ++;
#line 2007
    *(m->elems + tmp___9) = *(s2->elems + tmp___10);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2008
  return;
}
}
#line 2011 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void delete(position p , position_set *s ) 
{ 
  size_t i ;

  {
#line 2016
  i = (size_t )0;
  {
#line 2016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2016
    if (! (i < s->nelem)) {
#line 2016
      goto while_break;
    }
#line 2017
    if (p.index == (s->elems + i)->index) {
#line 2018
      goto while_break;
    }
#line 2016
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2019
  if (i < s->nelem) {
#line 2020
    (s->nelem) --;
    {
#line 2020
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2020
      if (! (i < s->nelem)) {
#line 2020
        goto while_break___0;
      }
#line 2021
      *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2020
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2022
  return;
}
}
#line 2027 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  state_num j ;
  size_t new_n_alloc ;
  void *tmp ;

  {
#line 2030
  hash = (size_t )0;
#line 2034
  i = (state_num )0;
  {
#line 2034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2034
    if (! ((size_t const   )i < s->nelem)) {
#line 2034
      goto while_break;
    }
#line 2035
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2034
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2038
  i = (state_num )0;
  {
#line 2038
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2038
    if (! (i < d->sindex)) {
#line 2038
      goto while_break___0;
    }
#line 2040
    if (hash != (d->states + i)->hash) {
#line 2042
      goto __Cont;
    } else
#line 2040
    if (s->nelem != (size_t const   )(d->states + i)->elems.nelem) {
#line 2042
      goto __Cont;
    } else
#line 2040
    if (context != (int )(d->states + i)->context) {
#line 2042
      goto __Cont;
    }
#line 2043
    j = (state_num )0;
    {
#line 2043
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2043
      if (! ((size_t const   )j < s->nelem)) {
#line 2043
        goto while_break___1;
      }
#line 2044
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2047
        goto while_break___1;
      } else
#line 2044
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2047
        goto while_break___1;
      }
#line 2043
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2048
    if ((size_t const   )j == s->nelem) {
#line 2049
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2038
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2053
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2053
    if (d->salloc <= d->sindex + 1L) {
      {
#line 2053
      new_n_alloc = (size_t )((d->sindex + 1L) + (state_num )(! d->states));
#line 2053
      tmp = x2nrealloc((void *)d->states, & new_n_alloc, sizeof(*(d->states)));
#line 2053
      d->states = (dfa_state *)tmp;
#line 2053
      d->salloc = (state_num )new_n_alloc;
      }
    }
#line 2053
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2054
  (d->states + i)->hash = hash;
#line 2055
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2056
  copy(s, & (d->states + i)->elems);
#line 2057
  (d->states + i)->context = (unsigned char )context;
#line 2058
  (d->states + i)->backref = (char)0;
#line 2059
  (d->states + i)->constraint = (unsigned short)0;
#line 2060
  (d->states + i)->first_end = (token )0;
#line 2063
  (d->states + i)->mbps.nelem = (size_t )0;
#line 2064
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2066
  j = (state_num )0;
  }
  {
#line 2066
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2066
    if (! ((size_t const   )j < s->nelem)) {
#line 2066
      goto while_break___3;
    }
#line 2067
    if (*(d->tokens + (s->elems + j)->index) < 0L) {
#line 2069
      constraint = (int )(s->elems + j)->constraint;
#line 2070
      if ((((constraint & 15) | ((constraint >> 4) & 15)) | ((constraint >> 8) & 15)) & context) {
#line 2071
        (d->states + i)->constraint = (unsigned short )((int )(d->states + i)->constraint | constraint);
      }
#line 2072
      if (! (d->states + i)->first_end) {
#line 2073
        (d->states + i)->first_end = *(d->tokens + (s->elems + j)->index);
      }
    } else
#line 2075
    if (*(d->tokens + (s->elems + j)->index) == 257L) {
#line 2077
      (d->states + i)->constraint = (unsigned short)1911;
#line 2078
      (d->states + i)->backref = (char)1;
    }
#line 2066
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2081
  (d->sindex) ++;
#line 2083
  return (i);
}
}
#line 2091 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void epsclosure(position_set *s , struct dfa  const  *d ) 
{ 
  size_t i ;
  size_t j ;
  char *visited ;
  position p ;
  position old ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2098
    if (sizeof(*visited) == 1UL) {
      {
#line 2098
      tmp = xzalloc((size_t )d->tindex);
#line 2098
      visited = (char *)tmp;
      }
    } else {
      {
#line 2098
      tmp___0 = xcalloc((size_t )d->tindex, sizeof(*visited));
#line 2098
      visited = (char *)tmp___0;
      }
    }
#line 2098
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2100
  i = (size_t )0;
  {
#line 2100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2100
    if (! (i < s->nelem)) {
#line 2100
      goto while_break___0;
    }
#line 2101
    if (*(d->tokens + (s->elems + i)->index) >= (token )(1 << 8)) {
#line 2101
      if (*(d->tokens + (s->elems + i)->index) != 257L) {
#line 2101
        if (*(d->tokens + (s->elems + i)->index) != 272L) {
#line 2101
          if (*(d->tokens + (s->elems + i)->index) != 273L) {
#line 2101
            if (*(d->tokens + (s->elems + i)->index) < 275L) {
              {
#line 2109
              old = *(s->elems + i);
#line 2110
              p.constraint = old.constraint;
#line 2111
              delete(*(s->elems + i), s);
              }
#line 2112
              if (*(visited + old.index)) {
#line 2114
                i --;
#line 2115
                goto __Cont;
              }
#line 2117
              *(visited + old.index) = (char)1;
              {
#line 2120
              if (*(d->tokens + old.index) == 258L) {
#line 2120
                goto case_258;
              }
#line 2123
              if (*(d->tokens + old.index) == 259L) {
#line 2123
                goto case_259;
              }
#line 2126
              if (*(d->tokens + old.index) == 260L) {
#line 2126
                goto case_260;
              }
#line 2129
              if (*(d->tokens + old.index) == 261L) {
#line 2129
                goto case_261;
              }
#line 2132
              if (*(d->tokens + old.index) == 262L) {
#line 2132
                goto case_262;
              }
#line 2135
              if (*(d->tokens + old.index) == 263L) {
#line 2135
                goto case_263;
              }
#line 2138
              goto switch_default;
              case_258: /* CIL Label */ 
#line 2121
              p.constraint &= 1092U;
#line 2122
              goto switch_break;
              case_259: /* CIL Label */ 
#line 2124
              p.constraint &= 1792U;
#line 2125
              goto switch_break;
              case_260: /* CIL Label */ 
#line 2127
              p.constraint &= 80U;
#line 2128
              goto switch_break;
              case_261: /* CIL Label */ 
#line 2130
              p.constraint &= 514U;
#line 2131
              goto switch_break;
              case_262: /* CIL Label */ 
#line 2133
              p.constraint &= 594U;
#line 2134
              goto switch_break;
              case_263: /* CIL Label */ 
#line 2136
              p.constraint &= 1317U;
#line 2137
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 2139
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 2141
              j = (size_t )0;
              {
#line 2141
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2141
                if (! (j < (d->follows + old.index)->nelem)) {
#line 2141
                  goto while_break___1;
                }
                {
#line 2143
                p.index = ((d->follows + old.index)->elems + j)->index;
#line 2144
                insert(p, s);
#line 2141
                j ++;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 2147
              i = (size_t )-1;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2100
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2150
  free((void *)visited);
  }
#line 2151
  return;
}
}
#line 2156 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int charclass_context(unsigned int *c ) 
{ 
  int context ;
  unsigned int j ;
  _Bool tmp ;

  {
  {
#line 2159
  context = 0;
#line 2162
  tmp = tstbit((unsigned int )eolbyte___0, (unsigned int */* const  */)c);
  }
#line 2162
  if (tmp) {
#line 2163
    context |= 4;
  }
#line 2165
  j = 0U;
  {
#line 2165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2165
    if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2165
      goto while_break;
    }
#line 2167
    if (*(c + j) & letters[j]) {
#line 2168
      context |= 2;
    }
#line 2169
    if (*(c + j) & ~ (letters[j] | newline[j])) {
#line 2170
      context |= 1;
    }
#line 2165
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2173
  return (context);
}
}
#line 2182 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;

  {
#line 2185
  separate_contexts = 0;
#line 2188
  j = (size_t )0;
  {
#line 2188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2188
    if (! (j < (size_t )s->nelem)) {
#line 2188
      goto while_break;
    }
#line 2190
    if ((((s->elems + j)->constraint >> 2) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2191
      separate_contexts |= 4;
    }
#line 2192
    if ((((s->elems + j)->constraint >> 1) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2193
      separate_contexts |= 2;
    }
#line 2188
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2196
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2252 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfaanalyze(struct dfa *d , int searchflag ) 
{ 
  int *nullable ;
  size_t *nfirstpos ;
  position *firstpos ;
  size_t *nlastpos ;
  position *lastpos ;
  position_set tmp ;
  position_set merged ;
  int separate_contexts ;
  int *o_nullable ;
  size_t *o_nfirst ;
  size_t *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  size_t i ;
  size_t j ;
  position *pos ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  size_t *tmp___13 ;
  size_t *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  size_t *tmp___20 ;
  size_t *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  unsigned int tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  int __attribute__((__pure__))  tmp___27 ;
  int tmp___28 ;

  {
#line 2279
  d->searchflag = searchflag;
  {
#line 2281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2281
    if (sizeof(*nullable) == 1UL) {
      {
#line 2281
      tmp___0 = xmalloc(d->depth);
#line 2281
      nullable = (int *)tmp___0;
      }
    } else {
      {
#line 2281
      tmp___1 = xnmalloc(d->depth, sizeof(*nullable));
#line 2281
      nullable = (int *)tmp___1;
      }
    }
#line 2281
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2282
  o_nullable = nullable;
  {
#line 2283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2283
    if (sizeof(*nfirstpos) == 1UL) {
      {
#line 2283
      tmp___2 = xmalloc(d->depth);
#line 2283
      nfirstpos = (size_t *)tmp___2;
      }
    } else {
      {
#line 2283
      tmp___3 = xnmalloc(d->depth, sizeof(*nfirstpos));
#line 2283
      nfirstpos = (size_t *)tmp___3;
      }
    }
#line 2283
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2284
  o_nfirst = nfirstpos;
  {
#line 2285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2285
    if (sizeof(*firstpos) == 1UL) {
      {
#line 2285
      tmp___4 = xmalloc(d->nleaves);
#line 2285
      firstpos = (position *)tmp___4;
      }
    } else {
      {
#line 2285
      tmp___5 = xnmalloc(d->nleaves, sizeof(*firstpos));
#line 2285
      firstpos = (position *)tmp___5;
      }
    }
#line 2285
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2286
  o_firstpos = firstpos;
#line 2286
  firstpos += d->nleaves;
  {
#line 2287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2287
    if (sizeof(*nlastpos) == 1UL) {
      {
#line 2287
      tmp___6 = xmalloc(d->depth);
#line 2287
      nlastpos = (size_t *)tmp___6;
      }
    } else {
      {
#line 2287
      tmp___7 = xnmalloc(d->depth, sizeof(*nlastpos));
#line 2287
      nlastpos = (size_t *)tmp___7;
      }
    }
#line 2287
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2288
  o_nlast = nlastpos;
  {
#line 2289
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2289
    if (sizeof(*lastpos) == 1UL) {
      {
#line 2289
      tmp___8 = xmalloc(d->nleaves);
#line 2289
      lastpos = (position *)tmp___8;
      }
    } else {
      {
#line 2289
      tmp___9 = xnmalloc(d->nleaves, sizeof(*lastpos));
#line 2289
      lastpos = (position *)tmp___9;
      }
    }
#line 2289
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2290
  o_lastpos = lastpos;
#line 2290
  lastpos += d->nleaves;
#line 2291
  alloc_position_set(& merged, d->nleaves);
  }
  {
#line 2293
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2293
    if (sizeof(*(d->follows)) == 1UL) {
      {
#line 2293
      tmp___10 = xzalloc(d->tindex);
#line 2293
      d->follows = (position_set *)tmp___10;
      }
    } else {
      {
#line 2293
      tmp___11 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2293
      d->follows = (position_set *)tmp___11;
      }
    }
#line 2293
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2295
  i = (size_t )0;
  {
#line 2295
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2295
    if (! (i < d->tindex)) {
#line 2295
      goto while_break___5;
    }
    {
#line 2299
    if (*(d->tokens + i) == 256L) {
#line 2299
      goto case_256;
    }
#line 2308
    if (*(d->tokens + i) == 266L) {
#line 2308
      goto case_266;
    }
#line 2308
    if (*(d->tokens + i) == 265L) {
#line 2308
      goto case_266;
    }
#line 2320
    if (*(d->tokens + i) == 264L) {
#line 2320
      goto case_264;
    }
#line 2326
    if (*(d->tokens + i) == 268L) {
#line 2326
      goto case_268;
    }
#line 2365
    if (*(d->tokens + i) == 269L) {
#line 2365
      goto case_269;
    }
#line 2379
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2301
    tmp___12 = nullable;
#line 2301
    nullable ++;
#line 2301
    *tmp___12 = 1;
#line 2304
    tmp___13 = nfirstpos;
#line 2304
    nfirstpos ++;
#line 2304
    tmp___14 = nlastpos;
#line 2304
    nlastpos ++;
#line 2304
    tmp___15 = (size_t )0;
#line 2304
    *tmp___14 = tmp___15;
#line 2304
    *tmp___13 = tmp___15;
#line 2305
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2311
    tmp.nelem = *(nfirstpos + -1);
#line 2312
    tmp.elems = firstpos;
#line 2313
    pos = lastpos;
#line 2314
    j = (size_t )0;
    {
#line 2314
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2314
      if (! (j < *(nlastpos + -1))) {
#line 2314
        goto while_break___6;
      }
      {
#line 2316
      merge((position_set const   *)(& tmp), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2317
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2314
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2322
    if (*(d->tokens + i) != 266L) {
#line 2323
      *(nullable + -1) = 1;
    }
#line 2324
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2329
    tmp.nelem = *(nfirstpos + -1);
#line 2330
    tmp.elems = firstpos;
#line 2331
    pos = lastpos + *(nlastpos + -1);
#line 2332
    j = (size_t )0;
    {
#line 2332
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2332
      if (! (j < *(nlastpos + -2))) {
#line 2332
        goto while_break___7;
      }
      {
#line 2334
      merge((position_set const   *)(& tmp), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2335
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2332
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2340
    if (*(nullable + -2)) {
#line 2341
      *(nfirstpos + -2) += *(nfirstpos + -1);
    } else {
#line 2343
      firstpos += *(nfirstpos + -1);
    }
#line 2344
    nfirstpos --;
#line 2348
    if (*(nullable + -1)) {
#line 2349
      *(nlastpos + -2) += *(nlastpos + -1);
    } else {
#line 2352
      pos = lastpos + *(nlastpos + -2);
#line 2353
      j = *(nlastpos + -1);
      {
#line 2353
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2353
        tmp___16 = j;
#line 2353
        j --;
#line 2353
        if (! (tmp___16 > 0UL)) {
#line 2353
          goto while_break___8;
        }
#line 2354
        *(pos + j) = *(lastpos + j);
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2355
      lastpos += *(nlastpos + -2);
#line 2356
      *(nlastpos + -2) = *(nlastpos + -1);
    }
#line 2358
    nlastpos --;
#line 2361
    if (*(nullable + -1)) {
#line 2361
      if (*(nullable + -2)) {
#line 2361
        tmp___17 = 1;
      } else {
#line 2361
        tmp___17 = 0;
      }
    } else {
#line 2361
      tmp___17 = 0;
    }
#line 2361
    *(nullable + -2) = tmp___17;
#line 2362
    nullable --;
#line 2363
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2367
    *(nfirstpos + -2) += *(nfirstpos + -1);
#line 2368
    nfirstpos --;
#line 2371
    *(nlastpos + -2) += *(nlastpos + -1);
#line 2372
    nlastpos --;
#line 2375
    if (*(nullable + -1)) {
#line 2375
      tmp___18 = 1;
    } else
#line 2375
    if (*(nullable + -2)) {
#line 2375
      tmp___18 = 1;
    } else {
#line 2375
      tmp___18 = 0;
    }
#line 2375
    *(nullable + -2) = tmp___18;
#line 2376
    nullable --;
#line 2377
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2385
    tmp___19 = nullable;
#line 2385
    nullable ++;
#line 2385
    *tmp___19 = *(d->tokens + i) == 257L;
#line 2388
    tmp___20 = nfirstpos;
#line 2388
    nfirstpos ++;
#line 2388
    tmp___21 = nlastpos;
#line 2388
    nlastpos ++;
#line 2388
    tmp___22 = (size_t )1;
#line 2388
    *tmp___21 = tmp___22;
#line 2388
    *tmp___20 = tmp___22;
#line 2389
    firstpos --;
#line 2389
    lastpos --;
#line 2390
    tmp___23 = i;
#line 2390
    lastpos->index = tmp___23;
#line 2390
    firstpos->index = tmp___23;
#line 2391
    tmp___24 = 1911U;
#line 2391
    lastpos->constraint = tmp___24;
#line 2391
    firstpos->constraint = tmp___24;
#line 2394
    alloc_position_set(d->follows + i, (size_t )1);
    }
#line 2395
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2295
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2421
  i = (size_t )0;
  {
#line 2421
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2421
    if (! (i < d->tindex)) {
#line 2421
      goto while_break___9;
    }
#line 2422
    if (*(d->tokens + i) < (token )(1 << 8)) {
      {
#line 2439
      copy((position_set const   *)(d->follows + i), & merged);
#line 2440
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2441
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2422
    if (*(d->tokens + i) == 257L) {
      {
#line 2439
      copy((position_set const   *)(d->follows + i), & merged);
#line 2440
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2441
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2422
    if (*(d->tokens + i) == 272L) {
      {
#line 2439
      copy((position_set const   *)(d->follows + i), & merged);
#line 2440
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2441
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2422
    if (*(d->tokens + i) == 273L) {
      {
#line 2439
      copy((position_set const   *)(d->follows + i), & merged);
#line 2440
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2441
      copy((position_set const   *)(& merged), d->follows + i);
      }
    } else
#line 2422
    if (*(d->tokens + i) >= 275L) {
      {
#line 2439
      copy((position_set const   *)(d->follows + i), & merged);
#line 2440
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2441
      copy((position_set const   *)(& merged), d->follows + i);
      }
    }
#line 2421
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2446
  merged.nelem = (size_t )0;
#line 2447
  i = (size_t )0;
  {
#line 2447
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2447
    if (! (i < *(nfirstpos + -1))) {
#line 2447
      goto while_break___10;
    }
    {
#line 2448
    insert(*(firstpos + i), & merged);
#line 2447
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 2449
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2452
  d->salloc = (state_num )1;
#line 2453
  d->sindex = (state_num )0;
  }
  {
#line 2454
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2454
    if (sizeof(*(d->states)) == 1UL) {
      {
#line 2454
      tmp___25 = xmalloc((size_t )d->salloc);
#line 2454
      d->states = (dfa_state *)tmp___25;
      }
    } else {
      {
#line 2454
      tmp___26 = xnmalloc((size_t )d->salloc, sizeof(*(d->states)));
#line 2454
      d->states = (dfa_state *)tmp___26;
      }
    }
#line 2454
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2456
  tmp___27 = state_separate_contexts((position_set const   *)(& merged));
#line 2456
  separate_contexts = (int )tmp___27;
  }
#line 2457
  if (separate_contexts & 4) {
#line 2457
    tmp___28 = 4;
  } else {
#line 2457
    tmp___28 = separate_contexts ^ 7;
  }
  {
#line 2457
  state_index(d, (position_set const   *)(& merged), tmp___28);
#line 2461
  free((void *)o_nullable);
#line 2462
  free((void *)o_nfirst);
#line 2463
  free((void *)o_firstpos);
#line 2464
  free((void *)o_nlast);
#line 2465
  free((void *)o_lastpos);
#line 2466
  free((void *)merged.elems);
  }
#line 2467
  return;
}
}
#line 2500 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfastate(ptrdiff_t s , struct dfa *d , ptrdiff_t *trans___0 ) 
{ 
  leaf_set *grps ;
  charclass *labels ;
  size_t ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp ;
  int possible_contexts ;
  int separate_contexts ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  int next_isnt_1st_byte ;
  size_t i ;
  size_t j ;
  size_t k ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  unsigned int tmp___5 ;
  int match ;
  int label___0 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int __attribute__((__pure__))  tmp___13 ;
  unsigned short const   **tmp___15 ;
  int __attribute__((__pure__))  tmp___16 ;
  int c ;
  unsigned short const   **tmp___17 ;

  {
#line 2505
  ngrps = (size_t )0;
#line 2520
  next_isnt_1st_byte = 0;
  {
#line 2523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2523
    if (sizeof(*grps) == 1UL) {
      {
#line 2523
      tmp___0 = xmalloc((size_t )(1 << 8));
#line 2523
      grps = (leaf_set *)tmp___0;
      }
    } else {
      {
#line 2523
      tmp___1 = xnmalloc((size_t )(1 << 8), sizeof(*grps));
#line 2523
      grps = (leaf_set *)tmp___1;
      }
    }
#line 2523
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2524
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2524
    if (sizeof(*labels) == 1UL) {
      {
#line 2524
      tmp___2 = xmalloc((size_t )(1 << 8));
#line 2524
      labels = (charclass *)tmp___2;
      }
    } else {
      {
#line 2524
      tmp___3 = xnmalloc((size_t )(1 << 8), sizeof(*labels));
#line 2524
      labels = (charclass *)tmp___3;
      }
    }
#line 2524
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2526
  zeroset(matches);
#line 2528
  i = (size_t )0;
  }
  {
#line 2528
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2528
    if (! (i < (d->states + s)->elems.nelem)) {
#line 2528
      goto while_break___1;
    }
#line 2530
    pos = *((d->states + s)->elems.elems + i);
#line 2531
    if (*(d->tokens + pos.index) >= 0L) {
#line 2531
      if (*(d->tokens + pos.index) < (token )(1 << 8)) {
        {
#line 2532
        setbit((unsigned int )*(d->tokens + pos.index), matches);
        }
      } else {
#line 2531
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2533
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2534
      copyset((unsigned int */* const  */)(*(d->charclasses + (*(d->tokens + pos.index) - 275L))),
              matches);
      }
    } else
#line 2535
    if (*(d->tokens + pos.index) == 272L) {
#line 2535
      goto _L;
    } else
#line 2535
    if (*(d->tokens + pos.index) == 273L) {
      _L: /* CIL Label */ 
#line 2543
      if ((d->states + s)->mbps.nelem == 0UL) {
        {
#line 2544
        alloc_position_set(& (d->states + s)->mbps, (size_t )1);
        }
      }
      {
#line 2545
      insert(pos, & (d->states + s)->mbps);
      }
#line 2546
      goto __Cont;
    } else {
#line 2549
      goto __Cont;
    }
#line 2553
    if (pos.constraint != 1911U) {
#line 2555
      if (! (((pos.constraint >> 8) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2557
        j = (size_t )0;
        {
#line 2557
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2557
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2557
            goto while_break___2;
          }
#line 2558
          matches[j] &= ~ newline[j];
#line 2557
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2559
      if (! (((pos.constraint >> 4) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2561
        j = (size_t )0;
        {
#line 2561
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2561
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2561
            goto while_break___3;
          }
#line 2562
          matches[j] &= ~ letters[j];
#line 2561
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2563
      if (! ((pos.constraint & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2565
        j = (size_t )0;
        {
#line 2565
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2565
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2565
            goto while_break___4;
          }
#line 2566
          matches[j] &= letters[j] | newline[j];
#line 2565
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 2569
      j = (size_t )0;
      {
#line 2569
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2569
        if (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2569
          if (! (! matches[j])) {
#line 2569
            goto while_break___5;
          }
        } else {
#line 2569
          goto while_break___5;
        }
#line 2570
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2569
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2571
      if (j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2572
        goto __Cont;
      }
    }
#line 2575
    j = (size_t )0;
    {
#line 2575
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2575
      if (! (j < ngrps)) {
#line 2575
        goto while_break___6;
      }
#line 2580
      if (*(d->tokens + pos.index) >= 0L) {
#line 2580
        if (*(d->tokens + pos.index) < (token )(1 << 8)) {
          {
#line 2580
          tmp___4 = tstbit((unsigned int )*(d->tokens + pos.index), (unsigned int */* const  */)(*(labels + j)));
          }
#line 2580
          if (! tmp___4) {
#line 2582
            goto __Cont___1;
          }
        }
      }
#line 2586
      intersectf = 0;
#line 2587
      k = (size_t )0;
      {
#line 2587
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2587
        if (! (k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2587
          goto while_break___7;
        }
#line 2588
        tmp___5 = matches[k] & (*(labels + j))[k];
#line 2588
        intersect[k] = tmp___5;
#line 2588
        if (tmp___5) {
#line 2588
          intersectf = 1;
        }
#line 2587
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2589
      if (! intersectf) {
#line 2590
        goto __Cont___1;
      }
#line 2593
      matchesf = 0;
#line 2593
      leftoversf = matchesf;
#line 2594
      k = (size_t )0;
      {
#line 2594
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2594
        if (! (k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2594
          goto while_break___8;
        }
#line 2597
        match = (int )matches[k];
#line 2597
        label___0 = (int )(*(labels + j))[k];
#line 2599
        tmp___6 = (unsigned int )(~ match & label___0);
#line 2599
        leftovers[k] = tmp___6;
#line 2599
        if (tmp___6) {
#line 2599
          leftoversf = 1;
        }
#line 2600
        tmp___7 = (unsigned int )(match & ~ label___0);
#line 2600
        matches[k] = tmp___7;
#line 2600
        if (tmp___7) {
#line 2600
          matchesf = 1;
        }
#line 2594
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2604
      if (leftoversf) {
        {
#line 2606
        copyset((unsigned int */* const  */)(leftovers), *(labels + ngrps));
#line 2607
        copyset((unsigned int */* const  */)(intersect), *(labels + j));
        }
        {
#line 2608
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2608
          if (sizeof(*((grps + ngrps)->elems)) == 1UL) {
            {
#line 2608
            tmp___8 = xmalloc(d->nleaves);
#line 2608
            (grps + ngrps)->elems = (size_t *)tmp___8;
            }
          } else {
            {
#line 2608
            tmp___9 = xnmalloc(d->nleaves, sizeof(*((grps + ngrps)->elems)));
#line 2608
            (grps + ngrps)->elems = (size_t *)tmp___9;
            }
          }
#line 2608
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 2609
        memcpy((void */* __restrict  */)(grps + ngrps)->elems, (void const   */* __restrict  */)(grps + j)->elems,
               sizeof(*((grps + j)->elems + 0)) * (grps + j)->nelem);
#line 2611
        (grps + ngrps)->nelem = (grps + j)->nelem;
#line 2612
        ngrps ++;
        }
      }
#line 2617
      tmp___10 = (grps + j)->nelem;
#line 2617
      ((grps + j)->nelem) ++;
#line 2617
      *((grps + j)->elems + tmp___10) = pos.index;
#line 2621
      if (! matchesf) {
#line 2622
        goto while_break___6;
      }
      __Cont___1: /* CIL Label */ 
#line 2575
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2627
    if (j == ngrps) {
      {
#line 2629
      copyset((unsigned int */* const  */)(matches), *(labels + ngrps));
#line 2630
      zeroset(matches);
      }
      {
#line 2631
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2631
        if (sizeof(*((grps + ngrps)->elems)) == 1UL) {
          {
#line 2631
          tmp___11 = xmalloc(d->nleaves);
#line 2631
          (grps + ngrps)->elems = (size_t *)tmp___11;
          }
        } else {
          {
#line 2631
          tmp___12 = xnmalloc(d->nleaves, sizeof(*((grps + ngrps)->elems)));
#line 2631
          (grps + ngrps)->elems = (size_t *)tmp___12;
          }
        }
#line 2631
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2632
      (grps + ngrps)->nelem = (size_t )1;
#line 2633
      *((grps + ngrps)->elems + 0) = pos.index;
#line 2634
      ngrps ++;
    }
    __Cont: /* CIL Label */ 
#line 2528
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2638
  alloc_position_set(& follows, d->nleaves);
#line 2639
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2644
  if (d->searchflag) {
    {
#line 2647
    copy((position_set const   *)(& (d->states + 0)->elems), & follows);
#line 2648
    tmp___13 = state_separate_contexts((position_set const   *)(& follows));
#line 2648
    separate_contexts = (int )tmp___13;
#line 2649
    state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
    }
#line 2650
    if (separate_contexts & 4) {
      {
#line 2651
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2653
      state_newline = state;
    }
#line 2654
    if (separate_contexts & 2) {
      {
#line 2655
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2657
      state_letter = state;
    }
#line 2659
    i = (size_t )0;
    {
#line 2659
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2659
      if (! (i < (size_t )(1 << 8))) {
#line 2659
        goto while_break___11;
      }
      {
#line 2660
      tmp___15 = __ctype_b_loc();
      }
#line 2660
      if ((int const   )*(*tmp___15 + (int )i) & 8) {
#line 2660
        *(trans___0 + i) = state_letter;
      } else
#line 2660
      if (i == 95UL) {
#line 2660
        *(trans___0 + i) = state_letter;
      } else {
#line 2660
        *(trans___0 + i) = state;
      }
#line 2659
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2661
    *(trans___0 + eolbyte___0) = state_newline;
  } else {
#line 2664
    i = (size_t )0;
    {
#line 2664
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2664
      if (! (i < (size_t )(1 << 8))) {
#line 2664
        goto while_break___12;
      }
#line 2665
      *(trans___0 + i) = (ptrdiff_t )-1;
#line 2664
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 2667
  i = (size_t )0;
  {
#line 2667
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2667
    if (! (i < ngrps)) {
#line 2667
      goto while_break___13;
    }
#line 2669
    follows.nelem = (size_t )0;
#line 2673
    j = (size_t )0;
    {
#line 2673
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2673
      if (! (j < (grps + i)->nelem)) {
#line 2673
        goto while_break___14;
      }
#line 2674
      k = (size_t )0;
      {
#line 2674
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 2674
        if (! (k < (d->follows + *((grps + i)->elems + j))->nelem)) {
#line 2674
          goto while_break___15;
        }
        {
#line 2675
        insert(*((d->follows + *((grps + i)->elems + j))->elems + k), & follows);
#line 2674
        k ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 2673
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 2677
    if (d->mb_cur_max > 1U) {
#line 2697
      next_isnt_1st_byte = 0;
#line 2698
      j = (size_t )0;
      {
#line 2698
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 2698
        if (! (j < follows.nelem)) {
#line 2698
          goto while_break___16;
        }
#line 2700
        if (! (*(d->multibyte_prop + (follows.elems + j)->index) & 1)) {
#line 2702
          next_isnt_1st_byte = 1;
#line 2703
          goto while_break___16;
        }
#line 2698
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 2710
    if (d->searchflag) {
#line 2710
      if (d->mb_cur_max == 1U) {
#line 2710
        goto _L___1;
      } else
#line 2710
      if (! next_isnt_1st_byte) {
        _L___1: /* CIL Label */ 
#line 2712
        j = (size_t )0;
        {
#line 2712
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 2712
          if (! (j < (d->states + 0)->elems.nelem)) {
#line 2712
            goto while_break___17;
          }
          {
#line 2713
          insert(*((d->states + 0)->elems.elems + j), & follows);
#line 2712
          j ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
    {
#line 2716
    possible_contexts = charclass_context(*(labels + i));
#line 2717
    tmp___16 = state_separate_contexts((position_set const   *)(& follows));
#line 2717
    separate_contexts = (int )tmp___16;
    }
#line 2720
    if ((separate_contexts & possible_contexts) != possible_contexts) {
      {
#line 2721
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2723
      state = (state_num )-1;
    }
#line 2724
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2725
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2727
      state_newline = state;
    }
#line 2728
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2729
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2731
      state_letter = state;
    }
#line 2734
    j = (size_t )0;
    {
#line 2734
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2734
      if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2734
        goto while_break___18;
      }
#line 2735
      k = (size_t )0;
      {
#line 2735
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 2735
        if (! (k < 8UL * sizeof(int ))) {
#line 2735
          goto while_break___19;
        }
#line 2736
        if ((*(labels + i))[j] & (1U << k)) {
#line 2738
          c = (int )(j * (8UL * sizeof(int )) + k);
#line 2740
          if (c == (int )eolbyte___0) {
#line 2741
            *(trans___0 + c) = state_newline;
          } else {
            {
#line 2742
            tmp___17 = __ctype_b_loc();
            }
#line 2742
            if ((int const   )*(*tmp___17 + c) & 8) {
#line 2743
              *(trans___0 + c) = state_letter;
            } else
#line 2742
            if (c == 95) {
#line 2743
              *(trans___0 + c) = state_letter;
            } else
#line 2744
            if (c < 1 << 8) {
#line 2745
              *(trans___0 + c) = state;
            }
          }
        }
#line 2735
        k ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 2734
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2667
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2749
  i = (size_t )0;
  {
#line 2749
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2749
    if (! (i < ngrps)) {
#line 2749
      goto while_break___20;
    }
    {
#line 2750
    free((void *)(grps + i)->elems);
#line 2749
    i ++;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 2751
  free((void *)follows.elems);
#line 2752
  free((void *)tmp.elems);
#line 2753
  free((void *)grps);
#line 2754
  free((void *)labels);
  }
#line 2755
  return;
}
}
#line 2764 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void build_state(state_num s , struct dfa *d ) 
{ 
  state_num *trans___0 ;
  state_num i ;
  state_num *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  state_num oldalloc ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  state_num tmp___6 ;

  {
#line 2774
  if (d->trcount >= 1024) {
#line 2776
    i = (state_num )0;
    {
#line 2776
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2776
      if (! (i < d->tralloc)) {
#line 2776
        goto while_break;
      }
      {
#line 2778
      free((void *)*(d->trans + i));
#line 2779
      free((void *)*(d->fails + i));
#line 2780
      tmp = (state_num *)((void *)0);
#line 2780
      *(d->fails + i) = tmp;
#line 2780
      *(d->trans + i) = tmp;
#line 2776
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2782
    d->trcount = 0;
  }
#line 2785
  (d->trcount) ++;
#line 2788
  *(d->success + s) = 0;
#line 2789
  if ((((int )(d->states + s)->constraint >> 8) & 15) & (int )(d->states + s)->context) {
#line 2790
    *(d->success + s) |= 4;
  }
#line 2791
  if ((((int )(d->states + s)->constraint >> 4) & 15) & (int )(d->states + s)->context) {
#line 2792
    *(d->success + s) |= 2;
  }
#line 2793
  if (((int )(d->states + s)->constraint & 15) & (int )(d->states + s)->context) {
#line 2794
    *(d->success + s) |= 1;
  }
  {
#line 2796
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2796
    if (sizeof(*trans___0) == 1UL) {
      {
#line 2796
      tmp___0 = xmalloc((size_t )(1 << 8));
#line 2796
      trans___0 = (state_num *)tmp___0;
      }
    } else {
      {
#line 2796
      tmp___1 = xnmalloc((size_t )(1 << 8), sizeof(*trans___0));
#line 2796
      trans___0 = (state_num *)tmp___1;
      }
    }
#line 2796
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2797
  dfastate(s, d, trans___0);
#line 2802
  i = (state_num )0;
  }
  {
#line 2802
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2802
    if (! (i < (state_num )(1 << 8))) {
#line 2802
      goto while_break___1;
    }
#line 2803
    if (*(trans___0 + i) >= d->tralloc) {
#line 2805
      oldalloc = d->tralloc;
      {
#line 2807
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2807
        if (! (*(trans___0 + i) >= d->tralloc)) {
#line 2807
          goto while_break___2;
        }
#line 2808
        d->tralloc *= 2L;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2809
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 2809
        tmp___2 = xnrealloc((void *)d->realtrans, (size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2809
        d->realtrans = (state_num **)tmp___2;
        }
#line 2809
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2810
      d->trans = d->realtrans + 1;
      {
#line 2811
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2811
        tmp___3 = xnrealloc((void *)d->fails, (size_t )d->tralloc, sizeof(*(d->fails)));
#line 2811
        d->fails = (state_num **)tmp___3;
        }
#line 2811
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2812
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2812
        tmp___4 = xnrealloc((void *)d->success, (size_t )d->tralloc, sizeof(*(d->success)));
#line 2812
        d->success = (int *)tmp___4;
        }
#line 2812
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2813
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 2813
        tmp___5 = xnrealloc((void *)d->newlines, (size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2813
        d->newlines = (state_num *)tmp___5;
        }
#line 2813
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2814
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2814
        if (! (oldalloc < d->tralloc)) {
#line 2814
          goto while_break___7;
        }
#line 2816
        *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2817
        tmp___6 = oldalloc;
#line 2817
        oldalloc ++;
#line 2817
        *(d->fails + tmp___6) = (state_num *)((void *)0);
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2802
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2823
  *(d->newlines + s) = *(trans___0 + eolbyte___0);
#line 2824
  *(trans___0 + eolbyte___0) = (state_num )-1;
#line 2826
  if ((d->states + s)->constraint) {
#line 2827
    *(d->fails + s) = trans___0;
  } else {
#line 2829
    *(d->trans + s) = trans___0;
  }
#line 2830
  return;
}
}
#line 2832 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void build_state_zero(struct dfa *d ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 2835
  d->tralloc = (state_num )1;
#line 2836
  d->trcount = 0;
  {
#line 2837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2837
    if (sizeof(*(d->realtrans)) == 1UL) {
      {
#line 2837
      tmp = xzalloc((size_t )(d->tralloc + 1L));
#line 2837
      d->realtrans = (state_num **)tmp;
      }
    } else {
      {
#line 2837
      tmp___0 = xcalloc((size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2837
      d->realtrans = (state_num **)tmp___0;
      }
    }
#line 2837
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2838
  d->trans = d->realtrans + 1;
  {
#line 2839
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2839
    if (sizeof(*(d->fails)) == 1UL) {
      {
#line 2839
      tmp___1 = xzalloc((size_t )d->tralloc);
#line 2839
      d->fails = (state_num **)tmp___1;
      }
    } else {
      {
#line 2839
      tmp___2 = xcalloc((size_t )d->tralloc, sizeof(*(d->fails)));
#line 2839
      d->fails = (state_num **)tmp___2;
      }
    }
#line 2839
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2840
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2840
    if (sizeof(*(d->success)) == 1UL) {
      {
#line 2840
      tmp___3 = xmalloc((size_t )d->tralloc);
#line 2840
      d->success = (int *)tmp___3;
      }
    } else {
      {
#line 2840
      tmp___4 = xnmalloc((size_t )d->tralloc, sizeof(*(d->success)));
#line 2840
      d->success = (int *)tmp___4;
      }
    }
#line 2840
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2841
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2841
    if (sizeof(*(d->newlines)) == 1UL) {
      {
#line 2841
      tmp___5 = xmalloc((size_t )d->tralloc);
#line 2841
      d->newlines = (state_num *)tmp___5;
      }
    } else {
      {
#line 2841
      tmp___6 = xnmalloc((size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2841
      d->newlines = (state_num *)tmp___6;
      }
    }
#line 2841
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2842
  build_state((state_num )0, d);
  }
#line 2843
  return;
}
}
#line 2870 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d , state_num new_state ) 
{ 
  state_num oldalloc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  state_num tmp___3 ;

  {
#line 2875
  if (new_state >= d->tralloc) {
#line 2877
    oldalloc = d->tralloc;
    {
#line 2879
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2879
      if (! (new_state >= d->tralloc)) {
#line 2879
        goto while_break;
      }
#line 2880
      d->tralloc *= 2L;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2881
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2881
      tmp = xnrealloc((void *)d->realtrans, (size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2881
      d->realtrans = (state_num **)tmp;
      }
#line 2881
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2882
    d->trans = d->realtrans + 1;
    {
#line 2883
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2883
      tmp___0 = xnrealloc((void *)d->fails, (size_t )d->tralloc, sizeof(*(d->fails)));
#line 2883
      d->fails = (state_num **)tmp___0;
      }
#line 2883
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2884
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2884
      tmp___1 = xnrealloc((void *)d->success, (size_t )d->tralloc, sizeof(*(d->success)));
#line 2884
      d->success = (int *)tmp___1;
      }
#line 2884
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2885
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 2885
      tmp___2 = xnrealloc((void *)d->newlines, (size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2885
      d->newlines = (state_num *)tmp___2;
      }
#line 2885
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2886
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2886
      if (! (oldalloc < d->tralloc)) {
#line 2886
        goto while_break___4;
      }
#line 2888
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2889
      tmp___3 = oldalloc;
#line 2889
      oldalloc ++;
#line 2889
      *(d->fails + tmp___3) = (state_num *)((void *)0);
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 2892
  return;
}
}
#line 2907 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static status_transit_state transit_state_singlebyte(struct dfa *d , state_num s ,
                                                     unsigned char const   *p , state_num *next_state ) 
{ 
  state_num *t ;
  state_num works ;
  status_transit_state rval ;

  {
#line 2912
  works = s;
#line 2914
  rval = (status_transit_state )0;
  {
#line 2916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2916
    if (! ((unsigned int )rval == 0U)) {
#line 2916
      goto while_break;
    }
#line 2918
    t = *(d->trans + works);
#line 2918
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2920
      works = *(t + *p);
#line 2921
      rval = (status_transit_state )1;
#line 2922
      if (works < 0L) {
#line 2923
        works = (state_num )0;
      }
    } else
#line 2925
    if (works < 0L) {
#line 2927
      if ((unsigned long )p == (unsigned long )buf_end) {
        {
#line 2930
        abort();
        }
      }
#line 2932
      works = (state_num )0;
    } else
#line 2934
    if (*(d->fails + works)) {
#line 2936
      works = *(*(d->fails + works) + *p);
#line 2937
      rval = (status_transit_state )1;
    } else {
      {
#line 2941
      build_state(works, d);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2944
  *next_state = works;
#line 2945
  return (rval);
}
}
#line 2951 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int match_anychar(struct dfa *d , state_num s , position pos , size_t idx ) 
{ 
  int context ;
  wchar_t wc ;
  int mbclen ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2958
  wc = *(inputwcs + idx);
#line 2959
  if ((int )*(mblen_buf + idx) == 0) {
#line 2959
    mbclen = 1;
  } else {
#line 2959
    mbclen = (int )*(mblen_buf + idx);
  }
#line 2962
  if (wc == (wchar_t )eolbyte___0) {
#line 2964
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2965
      return (0);
    }
  } else
#line 2967
  if (wc == 0) {
#line 2969
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2970
      return (0);
    }
  }
  {
#line 2973
  context = wchar_context((wint_t )wc);
  }
#line 2974
  if (context & 1) {
#line 2974
    tmp = pos.constraint & 15U;
  } else {
#line 2974
    tmp = 0U;
  }
#line 2974
  if (context & 2) {
#line 2974
    tmp___0 = (pos.constraint >> 4) & 15U;
  } else {
#line 2974
    tmp___0 = 0U;
  }
#line 2974
  if (context & 4) {
#line 2974
    tmp___1 = (pos.constraint >> 8) & 15U;
  } else {
#line 2974
    tmp___1 = 0U;
  }
#line 2974
  if (! (((tmp | tmp___0) | tmp___1) & (unsigned int )(d->states + s)->context)) {
#line 2975
    return (0);
  }
#line 2977
  return (mbclen);
}
}
#line 2984 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int match_mb_charset(struct dfa *d , state_num s , position pos , size_t idx ) 
{ 
  size_t i ;
  int match ;
  int match_len ;
  int op_len ;
  char buffer___0[128] ;
  struct mb_char_classes *work_mbc ;
  int context ;
  wchar_t wc ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 3000
  wc = *(inputwcs + idx);
#line 3003
  if (wc == (wchar_t )eolbyte___0) {
#line 3005
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3006
      return (0);
    }
  } else
#line 3008
  if (wc == 0) {
#line 3010
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3011
      return (0);
    }
  }
  {
#line 3014
  context = wchar_context((wint_t )wc);
  }
#line 3015
  if (context & 1) {
#line 3015
    tmp = pos.constraint & 15U;
  } else {
#line 3015
    tmp = 0U;
  }
#line 3015
  if (context & 2) {
#line 3015
    tmp___0 = (pos.constraint >> 4) & 15U;
  } else {
#line 3015
    tmp___0 = 0U;
  }
#line 3015
  if (context & 4) {
#line 3015
    tmp___1 = (pos.constraint >> 8) & 15U;
  } else {
#line 3015
    tmp___1 = 0U;
  }
#line 3015
  if (! (((tmp | tmp___0) | tmp___1) & (unsigned int )(d->states + s)->context)) {
#line 3016
    return (0);
  }
#line 3019
  work_mbc = d->mbcsets + (*(d->multibyte_prop + pos.index) >> 2);
#line 3020
  match = ! work_mbc->invert;
#line 3021
  if ((int )*(mblen_buf + idx) == 0) {
#line 3021
    match_len = 1;
  } else {
#line 3021
    match_len = (int )*(mblen_buf + idx);
  }
#line 3024
  if (wc < 1 << 8) {
#line 3024
    if (work_mbc->cset != -1L) {
      {
#line 3024
      tmp___2 = to_uchar((char )wc);
#line 3024
      tmp___3 = tstbit((unsigned int )tmp___2, (unsigned int */* const  */)(*(d->charclasses + work_mbc->cset)));
      }
#line 3024
      if (tmp___3) {
#line 3026
        goto charset_matched;
      }
    }
  }
#line 3029
  i = (size_t )0;
  {
#line 3029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3029
    if (! (i < work_mbc->nch_classes)) {
#line 3029
      goto while_break;
    }
    {
#line 3031
    tmp___4 = iswctype((wint_t )wc, *(work_mbc->ch_classes + i));
    }
#line 3031
    if (tmp___4) {
#line 3032
      goto charset_matched;
    }
#line 3029
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3035
  strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx),
          (size_t )match_len);
#line 3036
  buffer___0[match_len] = (char )'\000';
#line 3039
  i = (size_t )0;
  }
  {
#line 3039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3039
    if (! (i < work_mbc->nequivs)) {
#line 3039
      goto while_break___0;
    }
    {
#line 3041
    tmp___5 = strlen((char const   *)*(work_mbc->equivs + i));
#line 3041
    op_len = (int )tmp___5;
#line 3042
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx),
            (size_t )op_len);
#line 3043
    buffer___0[op_len] = (char )'\000';
#line 3044
    tmp___6 = strcoll((char const   *)*(work_mbc->equivs + i), (char const   *)(buffer___0));
    }
#line 3044
    if (tmp___6 == 0) {
#line 3046
      match_len = op_len;
#line 3047
      goto charset_matched;
    }
#line 3039
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3052
  i = (size_t )0;
  {
#line 3052
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3052
    if (! (i < work_mbc->ncoll_elems)) {
#line 3052
      goto while_break___1;
    }
    {
#line 3054
    tmp___7 = strlen((char const   *)*(work_mbc->coll_elems + i));
#line 3054
    op_len = (int )tmp___7;
#line 3055
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx),
            (size_t )op_len);
#line 3056
    buffer___0[op_len] = (char )'\000';
#line 3058
    tmp___8 = strcoll((char const   *)*(work_mbc->coll_elems + i), (char const   *)(buffer___0));
    }
#line 3058
    if (tmp___8 == 0) {
#line 3060
      match_len = op_len;
#line 3061
      goto charset_matched;
    }
#line 3052
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3066
  i = (size_t )0;
  {
#line 3066
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3066
    if (! (i < work_mbc->nranges)) {
#line 3066
      goto while_break___2;
    }
#line 3068
    if (*(work_mbc->range_sts + i) <= wc) {
#line 3068
      if (wc <= *(work_mbc->range_ends + i)) {
#line 3069
        goto charset_matched;
      }
    }
#line 3066
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3073
  i = (size_t )0;
  {
#line 3073
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3073
    if (! (i < work_mbc->nchars)) {
#line 3073
      goto while_break___3;
    }
#line 3075
    if (wc == *(work_mbc->chars + i)) {
#line 3076
      goto charset_matched;
    }
#line 3073
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3079
  match = ! match;
  charset_matched: 
#line 3082
  if (match) {
#line 3082
    tmp___9 = match_len;
  } else {
#line 3082
    tmp___9 = 0;
  }
#line 3082
  return (tmp___9);
}
}
#line 3093 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static int *check_matching_with_multibyte_ops(struct dfa *d , state_num s , size_t idx ) 
{ 
  size_t i ;
  int *rarray ;
  void *tmp ;
  void *tmp___0 ;
  position pos ;

  {
  {
#line 3099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3099
    if (sizeof(*rarray) == 1UL) {
      {
#line 3099
      tmp = xmalloc((d->states + s)->mbps.nelem);
#line 3099
      rarray = (int *)tmp;
      }
    } else {
      {
#line 3099
      tmp___0 = xnmalloc((d->states + s)->mbps.nelem, sizeof(*rarray));
#line 3099
      rarray = (int *)tmp___0;
      }
    }
#line 3099
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3100
  i = (size_t )0;
  {
#line 3100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3100
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 3100
      goto while_break___0;
    }
#line 3102
    pos = *((d->states + s)->mbps.elems + i);
    {
#line 3105
    if (*(d->tokens + pos.index) == 272L) {
#line 3105
      goto case_272;
    }
#line 3108
    if (*(d->tokens + pos.index) == 273L) {
#line 3108
      goto case_273;
    }
#line 3111
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3106
    *(rarray + i) = match_anychar(d, s, pos, idx);
    }
#line 3107
    goto switch_break;
    case_273: /* CIL Label */ 
    {
#line 3109
    *(rarray + i) = match_mb_charset(d, s, pos, idx);
    }
#line 3110
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3112
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3100
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3115
  return (rarray);
}
}
#line 3126 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static status_transit_state transit_state_consume_1char(struct dfa *d , state_num s ,
                                                        unsigned char const   **pp ,
                                                        int *match_lens , int *mbclen ,
                                                        position_set *pps ) 
{ 
  size_t i ;
  size_t j ;
  int k ;
  state_num s1 ;
  state_num s2 ;
  int *work_mbls ;
  status_transit_state rs ;
  unsigned char const   *tmp ;

  {
#line 3135
  rs = (status_transit_state )1;
#line 3139
  if ((int )*(mblen_buf + (*pp - buf_begin)) == 0) {
#line 3139
    *mbclen = 1;
  } else {
#line 3139
    *mbclen = (int )*(mblen_buf + (*pp - buf_begin));
  }
#line 3143
  s1 = s;
#line 3144
  k = 0;
  {
#line 3144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3144
    if (! (k < *mbclen)) {
#line 3144
      goto while_break;
    }
    {
#line 3146
    s2 = s1;
#line 3147
    tmp = *pp;
#line 3147
    (*pp) ++;
#line 3147
    rs = transit_state_singlebyte(d, s2, tmp, & s1);
#line 3144
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3150
  copy((position_set const   *)(& (d->states + s1)->elems), pps);
  }
#line 3153
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 3153
    if ((d->states + s)->mbps.nelem != 0UL) {
      {
#line 3154
      work_mbls = check_matching_with_multibyte_ops(d, s, (size_t )(*pp - buf_begin));
      }
    } else {
#line 3156
      work_mbls = match_lens;
    }
  } else {
#line 3156
    work_mbls = match_lens;
  }
#line 3160
  i = (size_t )0;
  {
#line 3160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3160
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 3160
      goto while_break___0;
    }
#line 3162
    if (*(work_mbls + i) == *mbclen) {
#line 3163
      j = (size_t )0;
      {
#line 3163
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3163
        if (! (j < (d->follows + ((d->states + s)->mbps.elems + i)->index)->nelem)) {
#line 3163
          goto while_break___1;
        }
        {
#line 3165
        insert(*((d->follows + ((d->states + s)->mbps.elems + i)->index)->elems + j),
               pps);
#line 3163
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3160
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3168
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 3168
    if ((unsigned long )work_mbls != (unsigned long )((void *)0)) {
      {
#line 3169
      free((void *)work_mbls);
      }
    }
  }
#line 3172
  return (rs);
}
}
#line 3178 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num s1 ;
  int mbclen ;
  int maxlen ;
  size_t i ;
  size_t j ;
  int *match_lens ;
  size_t nelem ;
  position_set follows ;
  unsigned char const   *p1 ;
  wchar_t wc ;
  status_transit_state rs ;
  int tmp ;
  int tmp___0 ;

  {
#line 3183
  maxlen = 0;
#line 3185
  match_lens = (int *)((void *)0);
#line 3186
  nelem = (d->states + s)->mbps.nelem;
#line 3188
  p1 = *pp;
#line 3191
  if (nelem > 0UL) {
    {
#line 3196
    match_lens = check_matching_with_multibyte_ops(d, s, (size_t )(*pp - buf_begin));
#line 3198
    i = (size_t )0;
    }
    {
#line 3198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3198
      if (! (i < nelem)) {
#line 3198
        goto while_break;
      }
#line 3202
      if (*(match_lens + i) > maxlen) {
#line 3203
        maxlen = *(match_lens + i);
      }
#line 3198
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3207
  if (nelem == 0UL) {
#line 3207
    goto _L;
  } else
#line 3207
  if (maxlen == 0) {
    _L: /* CIL Label */ 
    {
#line 3212
    rs = transit_state_singlebyte(d, s, *pp, & s1);
    }
#line 3215
    if ((unsigned int )rs == 1U) {
#line 3216
      (*pp) ++;
    }
    {
#line 3218
    free((void *)match_lens);
    }
#line 3219
    return (s1);
  }
  {
#line 3223
  alloc_position_set(& follows, d->nleaves);
#line 3229
  transit_state_consume_1char(d, s, pp, match_lens, & mbclen, & follows);
#line 3231
  wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
#line 3232
  tmp = wchar_context((wint_t )wc);
#line 3232
  s1 = state_index(d, (position_set const   *)(& follows), tmp);
#line 3233
  realloc_trans_if_necessary(d, s1);
  }
  {
#line 3235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3235
    if (! (*pp - p1 < (long )maxlen)) {
#line 3235
      goto while_break___0;
    }
    {
#line 3237
    transit_state_consume_1char(d, s1, pp, (int *)((void *)0), & mbclen, & follows);
#line 3239
    i = (size_t )0;
    }
    {
#line 3239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3239
      if (! (i < nelem)) {
#line 3239
        goto while_break___1;
      }
#line 3241
      if ((long )*(match_lens + i) == *pp - p1) {
#line 3242
        j = (size_t )0;
        {
#line 3242
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3242
          if (! (j < (d->follows + ((d->states + s1)->mbps.elems + i)->index)->nelem)) {
#line 3242
            goto while_break___2;
          }
          {
#line 3244
          insert(*((d->follows + ((d->states + s1)->mbps.elems + i)->index)->elems + j),
                 & follows);
#line 3242
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 3239
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3248
    wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
#line 3249
    tmp___0 = wchar_context((wint_t )wc);
#line 3249
    s1 = state_index(d, (position_set const   *)(& follows), tmp___0);
#line 3250
    realloc_trans_if_necessary(d, s1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3252
  free((void *)match_lens);
#line 3253
  free((void *)follows.elems);
  }
#line 3254
  return (s1);
}
}
#line 3260 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void prepare_wc_buf(char const   *begin , char const   *end ) 
{ 
  unsigned char eol ;
  size_t remain_bytes ;
  size_t i ;

  {
#line 3264
  eol = eolbyte___0;
#line 3267
  buf_begin = (unsigned char const   *)((unsigned char *)begin);
#line 3269
  remain_bytes = (size_t )0;
#line 3270
  i = (size_t )0;
  {
#line 3270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3270
    if (! (i < (size_t )((end - begin) + 1L))) {
#line 3270
      goto while_break;
    }
#line 3272
    if (remain_bytes == 0UL) {
      {
#line 3274
      remain_bytes = mbrtowc((wchar_t */* __restrict  */)(inputwcs + i), (char const   */* __restrict  */)(begin + i),
                             ((size_t )(end - begin) - i) + 1UL, (mbstate_t */* __restrict  */)(& mbs));
      }
#line 3276
      if (remain_bytes < 1UL) {
#line 3276
        goto _L;
      } else
#line 3276
      if (remain_bytes == 0xffffffffffffffffUL) {
#line 3276
        goto _L;
      } else
#line 3276
      if (remain_bytes == 0xfffffffffffffffeUL) {
#line 3276
        goto _L;
      } else
#line 3276
      if (remain_bytes == 1UL) {
#line 3276
        if (*(inputwcs + i) == (wchar_t )*(begin + i)) {
          _L: /* CIL Label */ 
#line 3281
          remain_bytes = (size_t )0;
#line 3282
          *(inputwcs + i) = (wchar_t )*(begin + i);
#line 3283
          *(mblen_buf + i) = (unsigned char)0;
#line 3284
          if ((int const   )*(begin + i) == (int const   )eol) {
#line 3285
            goto while_break;
          }
        } else {
#line 3289
          *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3290
          remain_bytes --;
        }
      } else {
#line 3289
        *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3290
        remain_bytes --;
      }
    } else {
#line 3295
      *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3296
      *(inputwcs + i) = 0;
#line 3297
      remain_bytes --;
    }
#line 3270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3301
  buf_end = (unsigned char const   *)((unsigned char *)(begin + i));
#line 3302
  *(mblen_buf + i) = (unsigned char)0;
#line 3303
  *(inputwcs + i) = 0;
#line 3305
  return;
}
}
#line 3319 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref ) 
{ 
  state_num s ;
  state_num s1 ;
  unsigned char const   *p ;
  state_num **trans___0 ;
  state_num *t ;
  unsigned char eol ;
  unsigned char saved_end ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  state_num tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3327
  eol = eolbyte___0;
#line 3330
  if (! d->tralloc) {
    {
#line 3331
    build_state_zero(d);
    }
  }
#line 3333
  s1 = (state_num )0;
#line 3333
  s = s1;
#line 3334
  p = (unsigned char const   *)begin;
#line 3335
  trans___0 = d->trans;
#line 3336
  saved_end = *((unsigned char *)end);
#line 3337
  *end = (char )eol;
#line 3339
  if (d->mb_cur_max > 1U) {
    {
#line 3341
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3341
      if (sizeof(*mblen_buf) == 1UL) {
        {
#line 3341
        tmp = xmalloc((size_t )((end - (char *)begin) + 2L));
#line 3341
        mblen_buf = (unsigned char *)tmp;
        }
      } else {
        {
#line 3341
        tmp___0 = xnmalloc((size_t )((end - (char *)begin) + 2L), sizeof(*mblen_buf));
#line 3341
        mblen_buf = (unsigned char *)tmp___0;
        }
      }
#line 3341
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3342
      if (sizeof(*inputwcs) == 1UL) {
        {
#line 3342
        tmp___1 = xmalloc((size_t )((end - (char *)begin) + 2L));
#line 3342
        inputwcs = (wchar_t *)tmp___1;
        }
      } else {
        {
#line 3342
        tmp___2 = xnmalloc((size_t )((end - (char *)begin) + 2L), sizeof(*inputwcs));
#line 3342
        inputwcs = (wchar_t *)tmp___2;
        }
      }
#line 3342
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3343
    memset((void *)(& mbs), 0, sizeof(mbstate_t ));
#line 3344
    prepare_wc_buf((char const   *)p, (char const   *)end);
    }
  }
  {
#line 3347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3349
    if (d->mb_cur_max > 1U) {
      {
#line 3351
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3351
        t = *(trans___0 + s);
#line 3351
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3351
          goto while_break___2;
        }
#line 3353
        if ((unsigned long )p > (unsigned long )buf_end) {
#line 3354
          goto while_break___2;
        }
#line 3355
        s1 = s;
#line 3356
        if (s == 0L) {
          {
#line 3356
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3356
            if (*(inputwcs + (p - buf_begin)) == 0) {
#line 3356
              if ((int )*(mblen_buf + (p - buf_begin)) > 0) {
#line 3356
                if (! ((unsigned long )p < (unsigned long )buf_end)) {
#line 3356
                  goto while_break___3;
                }
              } else {
#line 3356
                goto while_break___3;
              }
            } else {
#line 3356
              goto while_break___3;
            }
#line 3356
            p ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 3356
          if ((unsigned long )((char *)p) >= (unsigned long )end) {
            {
#line 3356
            free((void *)mblen_buf);
#line 3356
            free((void *)inputwcs);
#line 3356
            *end = (char )saved_end;
            }
#line 3356
            return ((char *)((void *)0));
          }
        }
#line 3358
        if ((d->states + s)->mbps.nelem == 0UL) {
#line 3360
          tmp___3 = p;
#line 3360
          p ++;
#line 3360
          s = *(t + *tmp___3);
#line 3361
          goto while_continue___2;
        }
#line 3368
        if (backref) {
          {
#line 3370
          *backref = 1;
#line 3371
          free((void *)mblen_buf);
#line 3372
          free((void *)inputwcs);
#line 3373
          *end = (char )saved_end;
          }
#line 3374
          return ((char *)p);
        }
        {
#line 3379
        s = transit_state(d, s, & p);
#line 3380
        trans___0 = d->trans;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3385
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3385
        t = *(trans___0 + s);
#line 3385
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3385
          goto while_break___4;
        }
#line 3387
        tmp___4 = p;
#line 3387
        p ++;
#line 3387
        s1 = *(t + *tmp___4);
#line 3388
        t = *(trans___0 + s1);
#line 3388
        if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 3390
          tmp___5 = s;
#line 3391
          s = s1;
#line 3392
          s1 = tmp___5;
#line 3393
          goto while_break___4;
        }
#line 3395
        tmp___6 = p;
#line 3395
        p ++;
#line 3395
        s = *(t + *tmp___6);
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 3399
    if (s >= 0L) {
#line 3399
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3399
        if (*(d->fails + s)) {
#line 3401
          if (*(d->success + s) & sbit[*p]) {
#line 3403
            if (backref) {
#line 3404
              *backref = (int )(d->states + s)->backref != 0;
            }
#line 3405
            if (d->mb_cur_max > 1U) {
              {
#line 3407
              free((void *)mblen_buf);
#line 3408
              free((void *)inputwcs);
              }
            }
#line 3410
            *end = (char )saved_end;
#line 3411
            return ((char *)p);
          }
#line 3414
          s1 = s;
#line 3415
          if (d->mb_cur_max > 1U) {
            {
#line 3419
            s = transit_state(d, s, & p);
#line 3420
            trans___0 = d->trans;
            }
          } else {
#line 3423
            tmp___7 = p;
#line 3423
            p ++;
#line 3423
            s = *(*(d->fails + s) + *tmp___7);
          }
#line 3424
          goto __Cont;
        }
      }
    }
#line 3428
    if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3428
      if ((int const   )*(p + -1) == (int const   )eol) {
#line 3430
        if (count) {
#line 3431
          (*count) ++;
        }
#line 3433
        if (d->mb_cur_max > 1U) {
          {
#line 3434
          prepare_wc_buf((char const   *)p, (char const   *)end);
          }
        }
      }
    }
#line 3438
    if ((unsigned long )((char *)p) > (unsigned long )end) {
#line 3440
      if (d->mb_cur_max > 1U) {
        {
#line 3442
        free((void *)mblen_buf);
#line 3443
        free((void *)inputwcs);
        }
      }
#line 3445
      *end = (char )saved_end;
#line 3446
      return ((char *)((void *)0));
    }
#line 3449
    if (s >= 0L) {
      {
#line 3451
      build_state(s, d);
#line 3452
      trans___0 = d->trans;
      }
#line 3453
      goto __Cont;
    }
#line 3456
    if ((int const   )*(p + -1) == (int const   )eol) {
#line 3456
      if (allow_nl) {
#line 3458
        s = *(d->newlines + s1);
#line 3459
        goto __Cont;
      }
    }
#line 3462
    s = (state_num )0;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 3466 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  size_t i ;
  size_t j ;
  struct mb_char_classes *p ;

  {
  {
#line 3471
  free((void *)d->multibyte_prop);
#line 3472
  d->multibyte_prop = (int *)((void *)0);
#line 3474
  i = (size_t )0;
  }
  {
#line 3474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3474
    if (! (i < d->nmbcsets)) {
#line 3474
      goto while_break;
    }
    {
#line 3477
    p = d->mbcsets + i;
#line 3478
    free((void *)p->chars);
#line 3479
    free((void *)p->ch_classes);
#line 3480
    free((void *)p->range_sts);
#line 3481
    free((void *)p->range_ends);
#line 3483
    j = (size_t )0;
    }
    {
#line 3483
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3483
      if (! (j < p->nequivs)) {
#line 3483
        goto while_break___0;
      }
      {
#line 3484
      free((void *)*(p->equivs + j));
#line 3483
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3485
    free((void *)p->equivs);
#line 3487
    j = (size_t )0;
    }
    {
#line 3487
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3487
      if (! (j < p->ncoll_elems)) {
#line 3487
        goto while_break___1;
      }
      {
#line 3488
      free((void *)*(p->coll_elems + j));
#line 3487
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3489
    free((void *)p->coll_elems);
#line 3474
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3492
  free((void *)d->mbcsets);
#line 3493
  d->mbcsets = (struct mb_char_classes *)((void *)0);
#line 3494
  d->nmbcsets = (size_t )0;
  }
#line 3495
  return;
}
}
#line 3499 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfainit(struct dfa *d ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 3502
  memset((void *)d, 0, sizeof(*d));
#line 3504
  d->calloc = (size_t )1;
  }
  {
#line 3505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3505
    if (sizeof(*(d->charclasses)) == 1UL) {
      {
#line 3505
      tmp = xmalloc(d->calloc);
#line 3505
      d->charclasses = (charclass *)tmp;
      }
    } else {
      {
#line 3505
      tmp___0 = xnmalloc(d->calloc, sizeof(*(d->charclasses)));
#line 3505
      d->charclasses = (charclass *)tmp___0;
      }
    }
#line 3505
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3507
  d->talloc = (size_t )1;
  {
#line 3508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3508
    if (sizeof(*(d->tokens)) == 1UL) {
      {
#line 3508
      tmp___1 = xmalloc(d->talloc);
#line 3508
      d->tokens = (token *)tmp___1;
      }
    } else {
      {
#line 3508
      tmp___2 = xnmalloc(d->talloc, sizeof(*(d->tokens)));
#line 3508
      d->tokens = (token *)tmp___2;
      }
    }
#line 3508
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3510
  tmp___3 = __ctype_get_mb_cur_max();
#line 3510
  d->mb_cur_max = (unsigned int )tmp___3;
  }
#line 3512
  if (d->mb_cur_max > 1U) {
#line 3514
    d->nmultibyte_prop = (size_t )1;
    {
#line 3515
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3515
      if (sizeof(*(d->multibyte_prop)) == 1UL) {
        {
#line 3515
        tmp___4 = xmalloc(d->nmultibyte_prop);
#line 3515
        d->multibyte_prop = (int *)tmp___4;
        }
      } else {
        {
#line 3515
        tmp___5 = xnmalloc(d->nmultibyte_prop, sizeof(*(d->multibyte_prop)));
#line 3515
        d->multibyte_prop = (int *)tmp___5;
        }
      }
#line 3515
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3516
    d->mbcsets_alloc = (size_t )1;
    {
#line 3517
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3517
      if (sizeof(*(d->mbcsets)) == 1UL) {
        {
#line 3517
        tmp___6 = xmalloc(d->mbcsets_alloc);
#line 3517
        d->mbcsets = (struct mb_char_classes *)tmp___6;
        }
      } else {
        {
#line 3517
        tmp___7 = xnmalloc(d->mbcsets_alloc, sizeof(*(d->mbcsets)));
#line 3517
        d->mbcsets = (struct mb_char_classes *)tmp___7;
        }
      }
#line 3517
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 3519
  return;
}
}
#line 3521 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  size_t i ;
  int tmp ;

  {
  {
#line 3526
  tmp = using_utf8();
  }
#line 3526
  if (! tmp) {
#line 3527
    return;
  }
#line 3529
  i = (size_t )0;
  {
#line 3529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3529
    if (! (i < d->tindex)) {
#line 3529
      goto while_break;
    }
    {
#line 3533
    if (*(d->tokens + i) == 272L) {
#line 3533
      goto case_272;
    }
#line 3536
    if (*(d->tokens + i) == 273L) {
#line 3536
      goto case_273;
    }
#line 3539
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3535
    abort();
    }
    case_273: /* CIL Label */ 
#line 3538
    return;
    switch_default: /* CIL Label */ 
#line 3540
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3529
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3544
  free_mbdata(d);
#line 3545
  d->mb_cur_max = 1U;
  }
#line 3546
  return;
}
}
#line 3549 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag ) 
{ 


  {
  {
#line 3552
  dfainit(d);
#line 3553
  dfaparse(s, len, d);
#line 3554
  dfamust(d);
#line 3555
  dfaoptimize(d);
#line 3556
  dfaanalyze(d, searchflag);
  }
#line 3557
  return;
}
}
#line 3560 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i ;
  struct dfamust *dm ;
  struct dfamust *ndm ;

  {
  {
#line 3566
  free((void *)d->charclasses);
#line 3567
  free((void *)d->tokens);
  }
#line 3569
  if (d->mb_cur_max > 1U) {
    {
#line 3570
    free_mbdata(d);
    }
  }
#line 3572
  i = (size_t )0;
  {
#line 3572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3572
    if (! (i < (size_t )d->sindex)) {
#line 3572
      goto while_break;
    }
    {
#line 3574
    free((void *)(d->states + i)->elems.elems);
#line 3576
    free((void *)(d->states + i)->mbps.elems);
#line 3572
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3578
  free((void *)d->states);
#line 3579
  i = (size_t )0;
  }
  {
#line 3579
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3579
    if (! (i < d->tindex)) {
#line 3579
      goto while_break___0;
    }
    {
#line 3580
    free((void *)(d->follows + i)->elems);
#line 3579
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3581
  free((void *)d->follows);
#line 3582
  i = (size_t )0;
  }
  {
#line 3582
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3582
    if (! (i < (size_t )d->tralloc)) {
#line 3582
      goto while_break___1;
    }
    {
#line 3584
    free((void *)*(d->trans + i));
#line 3585
    free((void *)*(d->fails + i));
#line 3582
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3587
  free((void *)d->realtrans);
#line 3588
  free((void *)d->fails);
#line 3589
  free((void *)d->newlines);
#line 3590
  free((void *)d->success);
#line 3591
  dm = d->musts;
  }
  {
#line 3591
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3591
    if (! dm) {
#line 3591
      goto while_break___2;
    }
    {
#line 3593
    ndm = dm->next;
#line 3594
    free((void *)dm->must);
#line 3595
    free((void *)dm);
#line 3591
    dm = ndm;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3597
  return;
}
}
#line 3683 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  char *result ;
  size_t oldsize ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 3687
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3687
    tmp___0 = (size_t )0;
  } else {
    {
#line 3687
    tmp = strlen((char const   *)old);
#line 3687
    tmp___0 = tmp;
    }
  }
#line 3687
  oldsize = tmp___0;
#line 3688
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3688
    tmp___2 = (size_t )0;
  } else {
    {
#line 3688
    tmp___1 = strlen(new);
#line 3688
    tmp___2 = tmp___1;
    }
  }
#line 3688
  newsize = tmp___2;
#line 3689
  if (newsize == 0UL) {
#line 3690
    return (old);
  }
  {
#line 3691
  tmp___3 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3691
  result = (char *)tmp___3;
#line 3692
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3693
  return (result);
}
}
#line 3696 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char *icpyalloc(char const   *string ) 
{ 
  char *tmp ;

  {
  {
#line 3699
  tmp = icatalloc((char *)((void *)0), string);
  }
#line 3699
  return (tmp);
}
}
#line 3702 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char * __attribute__((__pure__)) istrstr(char const   *lookin , char const   *lookfor ) 
{ 
  char const   *cp ;
  size_t len ;
  int tmp ;

  {
  {
#line 3708
  len = strlen(lookfor);
#line 3709
  cp = lookin;
  }
  {
#line 3709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3709
    if (! ((int const   )*cp != 0)) {
#line 3709
      goto while_break;
    }
    {
#line 3710
    tmp = strncmp(cp, lookfor, len);
    }
#line 3710
    if (tmp == 0) {
#line 3711
      return ((char */* __attribute__((__pure__)) */)((char *)cp));
    }
#line 3709
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3712
  return ((char */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 3715 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void freelist(char **cpp ) 
{ 
  size_t i ;

  {
#line 3720
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3721
    return;
  }
#line 3722
  i = (size_t )0;
  {
#line 3722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3722
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3722
      goto while_break;
    }
    {
#line 3724
    free((void *)*(cpp + i));
#line 3725
    *(cpp + i) = (char *)((void *)0);
#line 3722
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3727
  return;
}
}
#line 3729 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  size_t i ;
  size_t j ;
  char * __attribute__((__pure__)) tmp ;
  char * __attribute__((__pure__)) tmp___0 ;
  void *tmp___1 ;

  {
#line 3734
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3735
    return ((char **)((void *)0));
  }
  {
#line 3736
  new = icpyalloc((char const   *)new);
  }
#line 3736
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 3738
    freelist(cpp);
    }
#line 3739
    return ((char **)((void *)0));
  }
#line 3741
  *(new + len) = (char )'\000';
#line 3743
  i = (size_t )0;
  {
#line 3743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3743
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3743
      goto while_break;
    }
    {
#line 3744
    tmp = istrstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3744
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 3746
      free((void *)new);
      }
#line 3747
      return (cpp);
    }
#line 3743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3750
  j = (size_t )0;
  {
#line 3751
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3751
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3751
      goto while_break___0;
    }
    {
#line 3752
    tmp___0 = istrstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3752
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 3753
      j ++;
    } else {
      {
#line 3756
      free((void *)*(cpp + j));
#line 3757
      i --;
      }
#line 3757
      if (i == j) {
#line 3758
        goto while_break___0;
      }
#line 3759
      *(cpp + j) = *(cpp + i);
#line 3760
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3763
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3763
    tmp___1 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3763
    cpp = (char **)tmp___1;
    }
#line 3763
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3764
  *(cpp + i) = new;
#line 3765
  *(cpp + (i + 1UL)) = (char *)((void *)0);
#line 3766
  return (cpp);
}
}
#line 3772 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  char *lcp ;
  char *rcp ;
  size_t i ;
  size_t len ;
  void *tmp ;
  char **p ;
  char **tmp___0 ;

  {
#line 3780
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3781
    return ((char **)((void *)0));
  } else
#line 3780
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3781
    return ((char **)((void *)0));
  }
  {
#line 3782
  tmp = malloc(sizeof(*cpp));
#line 3782
  cpp = (char **)tmp;
  }
#line 3783
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3784
    return ((char **)((void *)0));
  }
#line 3785
  *(cpp + 0) = (char *)((void *)0);
#line 3786
  lcp = left;
  {
#line 3786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3786
    if (! ((int )*lcp != 0)) {
#line 3786
      goto while_break;
    }
    {
#line 3788
    len = (size_t )0;
#line 3789
    rcp = strchr(right, (int )*lcp);
    }
    {
#line 3790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3790
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3790
        goto while_break___0;
      }
#line 3792
      i = (size_t )1;
      {
#line 3792
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3792
        if ((int )*(lcp + i) != 0) {
#line 3792
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3792
            goto while_break___1;
          }
        } else {
#line 3792
          goto while_break___1;
        }
#line 3793
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3792
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3794
      if (i > len) {
#line 3795
        len = i;
      }
      {
#line 3796
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3798
    if (len == 0UL) {
#line 3799
      goto __Cont___0;
    }
    {
#line 3801
    tmp___0 = enlist(cpp, lcp, len);
#line 3801
    p = tmp___0;
    }
#line 3802
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 3804
      freelist(cpp);
#line 3805
      cpp = (char **)((void *)0);
      }
#line 3806
      goto while_break;
    }
#line 3808
    cpp = p;
    __Cont___0: /* CIL Label */ 
#line 3786
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3811
  return (cpp);
}
}
#line 3814 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t i ;
  size_t tmp ;

  {
#line 3819
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3820
    return ((char **)((void *)0));
  } else
#line 3819
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3820
    return ((char **)((void *)0));
  }
#line 3821
  i = (size_t )0;
  {
#line 3821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3821
    if (! ((unsigned long )*(new + i) != (unsigned long )((void *)0))) {
#line 3821
      goto while_break;
    }
    {
#line 3823
    tmp = strlen((char const   *)*(new + i));
#line 3823
    old = enlist(old, *(new + i), tmp);
    }
#line 3824
    if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3825
      goto while_break;
    }
#line 3821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3827
  return (old);
}
}
#line 3832 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  char **temp ;
  size_t lnum ;
  size_t rnum ;
  void *tmp ;

  {
#line 3839
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3840
    return ((char **)((void *)0));
  } else
#line 3839
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3840
    return ((char **)((void *)0));
  }
  {
#line 3841
  tmp = malloc(sizeof(*both));
#line 3841
  both = (char **)tmp;
  }
#line 3842
  if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3843
    return ((char **)((void *)0));
  }
#line 3844
  *(both + 0) = (char *)((void *)0);
#line 3845
  lnum = (size_t )0;
  {
#line 3845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3845
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3845
      goto while_break;
    }
#line 3847
    rnum = (size_t )0;
    {
#line 3847
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3847
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3847
        goto while_break___0;
      }
      {
#line 3849
      temp = comsubs(*(left + lnum), (char const   *)*(right + rnum));
      }
#line 3850
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 3852
        freelist(both);
        }
#line 3853
        return ((char **)((void *)0));
      }
      {
#line 3855
      both = addlists(both, temp);
#line 3856
      freelist(temp);
#line 3857
      free((void *)temp);
      }
#line 3858
      if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3859
        return ((char **)((void *)0));
      }
#line 3847
      rnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3845
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3862
  return (both);
}
}
#line 3873 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3876
  tmp___0 = (char )'\000';
#line 3876
  *(mp->is + 0) = tmp___0;
#line 3876
  tmp = tmp___0;
#line 3876
  *(mp->right + 0) = tmp;
#line 3876
  *(mp->left + 0) = tmp;
#line 3877
  freelist(mp->in);
  }
#line 3878
  return;
}
}
#line 3890 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static must must0  ;
#line 3892 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static char empty_string[1]  = {      (char )'\000'};
#line 3880 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
static void dfamust(struct dfa *d ) 
{ 
  must *musts ;
  must *mp ;
  char *result ;
  size_t ri ;
  size_t i ;
  int exact ;
  token t ;
  struct dfamust *dm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char tmp___5 ;
  char tmp___6 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  int tmp___9 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t tmp___16 ;
  char tmp___17 ;
  char tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;

  {
#line 3894
  result = empty_string;
#line 3895
  exact = 0;
  {
#line 3896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3896
    if (sizeof(*musts) == 1UL) {
      {
#line 3896
      tmp = xmalloc(d->tindex + 1UL);
#line 3896
      musts = (must *)tmp;
      }
    } else {
      {
#line 3896
      tmp___0 = xnmalloc(d->tindex + 1UL, sizeof(*musts));
#line 3896
      musts = (must *)tmp___0;
      }
    }
#line 3896
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3897
  mp = musts;
#line 3898
  i = (size_t )0;
  {
#line 3898
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3898
    if (! (i <= d->tindex)) {
#line 3898
      goto while_break___0;
    }
#line 3899
    *(mp + i) = must0;
#line 3898
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3900
  i = (size_t )0;
  {
#line 3900
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3900
    if (! (i <= d->tindex)) {
#line 3900
      goto while_break___1;
    }
    {
#line 3902
    tmp___1 = xmalloc(sizeof(*((mp + i)->in)));
#line 3902
    (mp + i)->in = (char **)tmp___1;
#line 3903
    tmp___2 = xmalloc((size_t )2);
#line 3903
    (mp + i)->left = (char *)tmp___2;
#line 3904
    tmp___3 = xmalloc((size_t )2);
#line 3904
    (mp + i)->right = (char *)tmp___3;
#line 3905
    tmp___4 = xmalloc((size_t )2);
#line 3905
    (mp + i)->is = (char *)tmp___4;
#line 3906
    tmp___6 = (char )'\000';
#line 3906
    *((mp + i)->is + 0) = tmp___6;
#line 3906
    tmp___5 = tmp___6;
#line 3906
    *((mp + i)->right + 0) = tmp___5;
#line 3906
    *((mp + i)->left + 0) = tmp___5;
#line 3907
    *((mp + i)->in + 0) = (char *)((void *)0);
#line 3900
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3918
  ri = (size_t )0;
  {
#line 3918
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3918
    if (! (ri < d->tindex)) {
#line 3918
      goto while_break___2;
    }
#line 3920
    t = *(d->tokens + ri);
    {
#line 3923
    if (t == 271L) {
#line 3923
      goto case_271;
    }
#line 3923
    if (t == 270L) {
#line 3923
      goto case_271;
    }
#line 3932
    if (t == 257L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 263L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 262L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 261L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 260L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 259L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 258L) {
#line 3932
      goto case_257;
    }
#line 3932
    if (t == 256L) {
#line 3932
      goto case_257;
    }
#line 3936
    if (t == 264L) {
#line 3936
      goto case_264;
    }
#line 3936
    if (t == 265L) {
#line 3936
      goto case_264;
    }
#line 3941
    if (t == 269L) {
#line 3941
      goto case_269;
    }
#line 3979
    if (t == 266L) {
#line 3979
      goto case_266;
    }
#line 3984
    if (t == -1L) {
#line 3984
      goto case_neg_1;
    }
#line 3992
    if (t == 268L) {
#line 3992
      goto case_268;
    }
#line 4041
    goto switch_default;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 3924
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                  3924U, "dfamust");
    }
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_259: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3933
    resetmust(mp);
    }
#line 3934
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 3937
    if (! ((unsigned long )musts < (unsigned long )mp)) {
      {
#line 3937
      __assert_fail("musts < mp", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    3937U, "dfamust");
      }
    }
    {
#line 3938
    mp --;
#line 3939
    resetmust(mp);
    }
#line 3940
    goto switch_break;
    case_269: /* CIL Label */ 
#line 3942
    if (! ((unsigned long )(musts + 2) <= (unsigned long )mp)) {
      {
#line 3942
      __assert_fail("&musts[2] <= mp", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    3942U, "dfamust");
      }
    }
    {
#line 3949
    mp --;
#line 3949
    rmp = mp;
#line 3950
    mp --;
#line 3950
    lmp = mp;
#line 3952
    tmp___9 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3952
    if (! (tmp___9 == 0)) {
#line 3953
      *(lmp->is + 0) = (char )'\000';
    }
#line 3955
    i = (size_t )0;
    {
#line 3956
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3956
      if ((int )*(lmp->left + i) != 0) {
#line 3956
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3956
          goto while_break___3;
        }
      } else {
#line 3956
        goto while_break___3;
      }
#line 3957
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3958
    *(lmp->left + i) = (char )'\000';
#line 3960
    ln = strlen((char const   *)lmp->right);
#line 3961
    rn = strlen((char const   *)rmp->right);
#line 3962
    n = ln;
    }
#line 3963
    if (n > rn) {
#line 3964
      n = rn;
    }
#line 3965
    i = (size_t )0;
    {
#line 3965
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3965
      if (! (i < n)) {
#line 3965
        goto while_break___4;
      }
#line 3966
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3967
        goto while_break___4;
      }
#line 3965
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3968
    j = (size_t )0;
    {
#line 3968
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3968
      if (! (j < i)) {
#line 3968
        goto while_break___5;
      }
#line 3969
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3968
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 3970
    *(lmp->right + j) = (char )'\000';
#line 3971
    new = inboth(lmp->in, rmp->in);
    }
#line 3972
    if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3973
      goto done;
    }
    {
#line 3974
    freelist(lmp->in);
#line 3975
    free((void *)lmp->in);
#line 3976
    lmp->in = new;
    }
#line 3978
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3980
    if (! ((unsigned long )musts < (unsigned long )mp)) {
      {
#line 3980
      __assert_fail("musts < mp", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    3980U, "dfamust");
      }
    }
#line 3981
    mp --;
#line 3982
    *(mp->is + 0) = (char )'\000';
#line 3983
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3985
    if (! ((unsigned long )mp == (unsigned long )(musts + 1))) {
      {
#line 3985
      __assert_fail("mp == &musts[1]", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    3985U, "dfamust");
      }
    }
#line 3986
    i = (size_t )0;
    {
#line 3986
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3986
      if (! ((unsigned long )*((musts + 0)->in + i) != (unsigned long )((void *)0))) {
#line 3986
        goto while_break___6;
      }
      {
#line 3987
      tmp___12 = strlen((char const   *)*((musts + 0)->in + i));
#line 3987
      tmp___13 = strlen((char const   *)result);
      }
#line 3987
      if (tmp___12 > tmp___13) {
#line 3988
        result = *((musts + 0)->in + i);
      }
#line 3986
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 3989
    tmp___14 = strcmp((char const   *)result, (char const   *)(musts + 0)->is);
    }
#line 3989
    if (tmp___14 == 0) {
#line 3990
      exact = 1;
    }
#line 3991
    goto done;
    case_268: /* CIL Label */ 
#line 3993
    if (! ((unsigned long )(musts + 2) <= (unsigned long )mp)) {
      {
#line 3993
      __assert_fail("&musts[2] <= mp", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    3993U, "dfamust");
      }
    }
    {
#line 3998
    mp --;
#line 3998
    rmp___0 = mp;
#line 3999
    mp --;
#line 3999
    lmp___0 = mp;
#line 4003
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 4004
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 4005
      goto done;
    }
#line 4006
    if ((int )*(lmp___0->right + 0) != 0) {
#line 4006
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 4010
        tp = icpyalloc((char const   *)lmp___0->right);
#line 4011
        tp = icatalloc(tp, (char const   *)rmp___0->left);
#line 4012
        tmp___16 = strlen((char const   *)tp);
#line 4012
        lmp___0->in = enlist(lmp___0->in, tp, tmp___16);
#line 4013
        free((void *)tp);
        }
#line 4014
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 4015
          goto done;
        }
      }
    }
#line 4018
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 4020
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
#line 4021
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
#line 4022
        goto done;
      }
    }
#line 4025
    if ((int )*(rmp___0->is + 0) == 0) {
#line 4026
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 4027
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 4028
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
#line 4029
      goto done;
    }
#line 4031
    if ((int )*(lmp___0->is + 0) != 0) {
#line 4031
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 4033
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
        }
#line 4034
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
#line 4035
          goto done;
        }
      } else {
#line 4038
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
#line 4038
      *(lmp___0->is + 0) = (char )'\000';
    }
#line 4040
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 4042
    if (t < -1L) {
      {
#line 4044
      __assert_fail("!\"oops! t >= END\"", "/home/khheo/project/benchmark/grep-2.18/src/dfa.c",
                    4044U, "dfamust");
      }
    } else
#line 4046
    if (t == 0L) {
#line 4049
      goto done;
    } else
#line 4051
    if (t >= 275L) {
      {
#line 4054
      resetmust(mp);
      }
    } else
#line 4051
    if (t == 272L) {
      {
#line 4054
      resetmust(mp);
      }
    } else
#line 4051
    if (t == 273L) {
      {
#line 4054
      resetmust(mp);
      }
    } else {
      {
#line 4059
      resetmust(mp);
#line 4060
      tmp___18 = (char )t;
#line 4060
      *(mp->right + 0) = tmp___18;
#line 4060
      tmp___17 = tmp___18;
#line 4060
      *(mp->left + 0) = tmp___17;
#line 4060
      *(mp->is + 0) = tmp___17;
#line 4061
      tmp___20 = (char )'\000';
#line 4061
      *(mp->right + 1) = tmp___20;
#line 4061
      tmp___19 = tmp___20;
#line 4061
      *(mp->left + 1) = tmp___19;
#line 4061
      *(mp->is + 1) = tmp___19;
#line 4062
      mp->in = enlist(mp->in, mp->is, (size_t )1);
      }
#line 4063
      if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
#line 4064
        goto done;
      }
    }
#line 4066
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4078
    mp ++;
#line 3918
    ri ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  done: 
  {
#line 4081
  tmp___25 = strlen((char const   *)result);
  }
#line 4081
  if (tmp___25) {
    {
#line 4083
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 4083
      if (sizeof(*dm) == 1UL) {
        {
#line 4083
        tmp___21 = xmalloc((size_t )1);
#line 4083
        dm = (struct dfamust *)tmp___21;
        }
      } else {
        {
#line 4083
        tmp___22 = xnmalloc((size_t )1, sizeof(*dm));
#line 4083
        dm = (struct dfamust *)tmp___22;
        }
      }
#line 4083
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 4084
    dm->exact = exact;
#line 4085
    tmp___23 = strlen((char const   *)result);
#line 4085
    tmp___24 = xmemdup((void const   *)result, tmp___23 + 1UL);
#line 4085
    dm->must = (char *)tmp___24;
#line 4086
    dm->next = d->musts;
#line 4087
    d->musts = dm;
    }
  }
#line 4089
  mp = musts;
#line 4090
  i = (size_t )0;
  {
#line 4090
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 4090
    if (! (i <= d->tindex)) {
#line 4090
      goto while_break___8;
    }
    {
#line 4092
    freelist((mp + i)->in);
#line 4093
    free((void *)(mp + i)->in);
#line 4094
    free((void *)(mp + i)->left);
#line 4095
    free((void *)(mp + i)->right);
#line 4096
    free((void *)(mp + i)->is);
#line 4090
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 4098
  free((void *)mp);
  }
#line 4099
  return;
}
}
#line 4101 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp ;

  {
  {
#line 4104
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4104
  return ((struct dfa *)tmp);
}
}
#line 4107 "/home/khheo/project/benchmark/grep-2.18/src/dfa.c"
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d ) 
{ 


  {
#line 4110
  return ((struct dfamust */* __attribute__((__pure__)) */)d->musts);
}
}
#line 68 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 123 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 123
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 123
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1851
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 28 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 4 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
static void Gcompile(char const   *pattern , size_t size ) 
{ 


  {
  {
#line 7
  GEAcompile(pattern, size, (((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 8
  return;
}
}
#line 10 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
static void Ecompile(char const   *pattern , size_t size ) 
{ 


  {
  {
#line 13
  GEAcompile(pattern, size, (((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 14
  return;
}
}
#line 16 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
static void Acompile(char const   *pattern , size_t size ) 
{ 


  {
  {
#line 19
  GEAcompile(pattern, size, (((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((1UL << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 20
  return;
}
}
#line 22 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
static void GAcompile(char const   *pattern , size_t size ) 
{ 


  {
  {
#line 25
  GEAcompile(pattern, size, (((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((1UL << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)));
  }
#line 26
  return;
}
}
#line 28 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
static void PAcompile(char const   *pattern , size_t size ) 
{ 


  {
  {
#line 31
  GEAcompile(pattern, size, ((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 32
  return;
}
}
#line 34 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
struct matcher  const  matchers[8]  = 
#line 34
  {      {"grep", & Gcompile, & EGexecute}, 
        {"egrep", & Ecompile, & EGexecute}, 
        {"awk", & Acompile, & EGexecute}, 
        {"gawk", & GAcompile, & EGexecute}, 
        {"posixawk", & PAcompile, & EGexecute}, 
        {"fgrep", & Fcompile, & Fexecute}, 
        {"perl", & Pcompile, & Pexecute}, 
        {(char const   *)((void *)0), (void (*)(char const   * , size_t  ))((void *)0),
      (size_t (*)(char const   * , size_t  , size_t * , char const   * ))((void *)0)}};
#line 45 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
char const   before_options[59]  = 
#line 45
  {      (char const   )'P',      (char const   )'A',      (char const   )'T',      (char const   )'T', 
        (char const   )'E',      (char const   )'R',      (char const   )'N',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )',',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )',',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'s',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'(', 
        (char const   )'B',      (char const   )'R',      (char const   )'E',      (char const   )')', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 47 "/home/khheo/project/benchmark/grep-2.18/src/grep.c"
char const   after_options[114]  = 
#line 47
  {      (char const   )'\'',      (char const   )'e',      (char const   )'g',      (char const   )'r', 
        (char const   )'e',      (char const   )'p',      (char const   )'\'',      (char const   )' ', 
        (char const   )'m',      (char const   )'e',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'\'',      (char const   )'g', 
        (char const   )'r',      (char const   )'e',      (char const   )'p',      (char const   )' ', 
        (char const   )'-',      (char const   )'E',      (char const   )'\'',      (char const   )'.', 
        (char const   )' ',      (char const   )' ',      (char const   )'\'',      (char const   )'f', 
        (char const   )'g',      (char const   )'r',      (char const   )'e',      (char const   )'p', 
        (char const   )'\'',      (char const   )' ',      (char const   )'m',      (char const   )'e', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'\'',      (char const   )'g',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )' ',      (char const   )'-',      (char const   )'F', 
        (char const   )'\'',      (char const   )'.',      (char const   )'\n',      (char const   )'D', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'v',      (char const   )'o',      (char const   )'c',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'e',      (char const   )'i',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'\'', 
        (char const   )'e',      (char const   )'g',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\'',      (char const   )'f', 
        (char const   )'g',      (char const   )'r',      (char const   )'e',      (char const   )'p', 
        (char const   )'\'',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
