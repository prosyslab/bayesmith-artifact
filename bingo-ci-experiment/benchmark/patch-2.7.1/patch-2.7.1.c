/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 32 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 46 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 35 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef long ptrdiff_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 805 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 74 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef int wchar_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_87 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_88 {
   int __count ;
   union __anonunion_87 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_88 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 88 "./printf-args.h"
typedef int arg_type;
#line 94 "./printf-args.h"
union __anonunion_109 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 91 "./printf-args.h"
struct __anonstruct_110 {
   arg_type type ;
   union __anonunion_109 a ;
};
#line 136 "./printf-args.h"
typedef struct __anonstruct_110 argument;
#line 141 "./printf-args.h"
struct __anonstruct_111 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 147 "./printf-args.h"
typedef struct __anonstruct_111 arguments;
#line 53 "./printf-parse.h"
struct __anonstruct_112 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 67 "./printf-parse.h"
typedef struct __anonstruct_112 char_directive;
#line 70 "./printf-parse.h"
struct __anonstruct_113 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 78 "./printf-parse.h"
typedef struct __anonstruct_113 char_directives;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone *__timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "./quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 55 "/tmp/0/patch-2.7.1/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[8] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 718 "/tmp/0/patch-2.7.1/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 111 "parse-datetime.y"
typedef long long_time_t;
#line 131 "parse-datetime.y"
struct __anonstruct_311 {
   int negative ;
   long value ;
   size_t digits ;
};
#line 136 "parse-datetime.y"
typedef struct __anonstruct_311 textint;
#line 139 "parse-datetime.y"
struct __anonstruct_312 {
   char const   *name ;
   int type ;
   int value ;
};
#line 144 "parse-datetime.y"
typedef struct __anonstruct_312 table;
#line 152 "parse-datetime.y"
struct __anonstruct_313 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 162 "parse-datetime.y"
typedef struct __anonstruct_313 relative_time;
#line 171 "parse-datetime.y"
struct __anonstruct_314 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   int timespec_seen ;
   int rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 214 "parse-datetime.y"
typedef struct __anonstruct_314 parser_control;
#line 216
union YYSTYPE ;
#line 432 "parse-datetime.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 447 "parse-datetime.c"
typedef union YYSTYPE YYSTYPE;
#line 467 "parse-datetime.c"
typedef unsigned char yytype_uint8;
#line 474 "parse-datetime.c"
typedef signed char yytype_int8;
#line 488 "parse-datetime.c"
typedef short yytype_int16;
#line 619 "parse-datetime.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 52 "/tmp/0/patch-2.7.1/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[4] ;
};
#line 56 "/tmp/0/patch-2.7.1/lib/malloca.c"
struct header {
   void *next ;
   char room[4] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 48 "./hash.h"
typedef size_t (*Hash_hasher)(void const   * , size_t  );
#line 49 "./hash.h"
typedef int (*Hash_comparator)(void const   * , void const   * );
#line 50 "./hash.h"
typedef void (*Hash_data_freer)(void * );
#line 51 "./hash.h"
typedef int (*Hash_processor)(void * , void * );
#line 53 "./hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   int is_n_buckets ;
};
#line 65 "./hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "./hash.h"
typedef struct hash_table Hash_table;
#line 46 "/tmp/0/patch-2.7.1/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/tmp/0/patch-2.7.1/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning *tuning ;
   Hash_hasher hasher ;
   Hash_comparator comparator ;
   Hash_data_freer data_freer ;
   struct hash_entry *free_entry_list ;
};
#line 99 "./gl_list.h"
typedef int (*gl_listelement_equals_fn)(void const   * , void const   * );
#line 103 "./gl_list.h"
typedef size_t (*gl_listelement_hashcode_fn)(void const   * );
#line 107 "./gl_list.h"
typedef void (*gl_listelement_dispose_fn)(void const   * );
#line 109
struct gl_list_impl ;
#line 111 "./gl_list.h"
typedef struct gl_list_impl *gl_list_t;
#line 113
struct gl_list_node_impl ;
#line 117 "./gl_list.h"
typedef struct gl_list_node_impl *gl_list_node_t;
#line 119
struct gl_list_implementation ;
#line 121 "./gl_list.h"
typedef struct gl_list_implementation *gl_list_implementation_t;
#line 345 "./gl_list.h"
struct __anonstruct_404 {
   struct gl_list_implementation *vtable ;
   gl_list_t list ;
   size_t count ;
   void *p ;
   void *q ;
   size_t i ;
   size_t j ;
};
#line 355 "./gl_list.h"
typedef struct __anonstruct_404 gl_list_iterator_t;
#line 386 "./gl_list.h"
typedef int (*gl_listelement_compar_fn)(void const   * , void const   * );
#line 462 "./gl_list.h"
struct gl_list_implementation {
   gl_list_t (*nx_create_empty)(gl_list_implementation_t implementation , gl_listelement_equals_fn equals_fn ,
                                gl_listelement_hashcode_fn hashcode_fn , gl_listelement_dispose_fn dispose_fn ,
                                int allow_duplicates ) ;
   gl_list_t (*nx_create)(gl_list_implementation_t implementation , gl_listelement_equals_fn equals_fn ,
                          gl_listelement_hashcode_fn hashcode_fn , gl_listelement_dispose_fn dispose_fn ,
                          int allow_duplicates , size_t count , void const   **contents ) ;
   size_t (*size)(gl_list_t list ) ;
   void const   *(*node_value)(gl_list_t list , gl_list_node_t node ) ;
   int (*node_nx_set_value)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*next_node)(gl_list_t list , gl_list_node_t node ) ;
   gl_list_node_t (*previous_node)(gl_list_t list , gl_list_node_t node ) ;
   void const   *(*get_at)(gl_list_t list , size_t position ) ;
   gl_list_node_t (*nx_set_at)(gl_list_t list , size_t position , void const   *elt ) ;
   gl_list_node_t (*search_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                                    void const   *elt ) ;
   size_t (*indexof_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                             void const   *elt ) ;
   gl_list_node_t (*nx_add_first)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_last)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_before)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_after)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_at)(gl_list_t list , size_t position , void const   *elt ) ;
   int (*remove_node)(gl_list_t list , gl_list_node_t node ) ;
   int (*remove_at)(gl_list_t list , size_t position ) ;
   int (*remove_elt)(gl_list_t list , void const   *elt ) ;
   void (*list_free)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator_from_to)(gl_list_t list , size_t start_index , size_t end_index ) ;
   int (*iterator_next)(gl_list_iterator_t *iterator , void const   **eltp , gl_list_node_t *nodep ) ;
   void (*iterator_free)(gl_list_iterator_t *iterator ) ;
   gl_list_node_t (*sortedlist_search)(gl_list_t list , gl_listelement_compar_fn compar ,
                                       void const   *elt ) ;
   gl_list_node_t (*sortedlist_search_from_to)(gl_list_t list , gl_listelement_compar_fn compar ,
                                               size_t start_index , size_t end_index ,
                                               void const   *elt ) ;
   size_t (*sortedlist_indexof)(gl_list_t list , gl_listelement_compar_fn compar ,
                                void const   *elt ) ;
   size_t (*sortedlist_indexof_from_to)(gl_list_t list , gl_listelement_compar_fn compar ,
                                        size_t start_index , size_t end_index , void const   *elt ) ;
   gl_list_node_t (*sortedlist_nx_add)(gl_list_t list , gl_listelement_compar_fn compar ,
                                       void const   *elt ) ;
   int (*sortedlist_remove)(gl_list_t list , gl_listelement_compar_fn compar , void const   *elt ) ;
};
#line 533 "./gl_list.h"
struct gl_list_impl_base {
   struct gl_list_implementation *vtable ;
   gl_listelement_equals_fn equals_fn ;
   gl_listelement_hashcode_fn hashcode_fn ;
   gl_listelement_dispose_fn dispose_fn ;
   int allow_duplicates ;
};
#line 23 "./gl_anylinked_list1.h"
struct gl_list_node_impl {
   struct gl_list_node_impl *next ;
   struct gl_list_node_impl *prev ;
   void const   *value ;
};
#line 34 "./gl_anylinked_list1.h"
struct gl_list_impl {
   struct gl_list_impl_base base ;
   struct gl_list_node_impl root ;
   size_t count ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 28 "./backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 51 "./argmatch.h"
typedef void (*argmatch_exit_fn)(void);
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 146 "/tmp/0/patch-2.7.1/lib/backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 57 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 69 "./common.h"
typedef off_t lin;
#line 116
enum diff {
    NO_DIFF = 0,
    CONTEXT_DIFF = 1,
    NORMAL_DIFF = 2,
    ED_DIFF = 3,
    NEW_CONTEXT_DIFF = 4,
    UNI_DIFF = 5,
    GIT_BINARY_DIFF = 6
} ;
#line 192 "./common.h"
struct outstate {
   FILE *ofp ;
   int after_newline ;
   int zero_output ;
};
#line 210
enum conflict_style {
    MERGE_MERGE = 0,
    MERGE_DIFF3 = 1
} ;
#line 101 "../lib/diffseq.h"
struct context {
   char *xchar ;
   char *ychar ;
   lin *fdiag ;
   lin *bdiag ;
   int heuristic ;
   lin too_expensive ;
};
#line 136 "../lib/diffseq.h"
struct partition {
   lin xmid ;
   lin ymid ;
   int lo_minimal ;
   int hi_minimal ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_679 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_679 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 159 "./common.h"
typedef long file_offset;
#line 30 "./util.h"
enum file_id_type {
    UNKNOWN = 0,
    CREATED = 1,
    DELETE_LATER = 2,
    OVERWRITTEN = 3
} ;
#line 73
enum file_attributes {
    FA_TIMES = 1,
    FA_IDS = 2,
    FA_MODE = 4,
    FA_XATTRS = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_698 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_699 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_700 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_701 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_702 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_703 {
   struct __anonstruct_702 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_704 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_703 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_705 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_706 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_707 {
   int _pad[28] ;
   struct __anonstruct_698 _kill ;
   struct __anonstruct_699 _timer ;
   struct __anonstruct_700 _rt ;
   struct __anonstruct_701 _sigchld ;
   struct __anonstruct_704 _sigfault ;
   struct __anonstruct_705 _sigpoll ;
   struct __anonstruct_706 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_708 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_707 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_708 siginfo_t;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_711 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_711 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 56 "/tmp/0/patch-2.7.1/src/util.c"
struct __anonstruct_715 {
   dev_t dev ;
   ino_t ino ;
   enum file_id_type type ;
   int queued_output ;
};
#line 62 "/tmp/0/patch-2.7.1/src/util.c"
typedef struct __anonstruct_715 file_id;
#line 20 "./pch.h"
enum nametype {
    OLD = 0,
    NEW = 1,
    INDEX = 2,
    NONE = 3
} ;
#line 1379 "/tmp/0/patch-2.7.1/src/patch.c"
enum __anonenum__769 {
    OUTSIDE = 0,
    IN_IFNDEF = 1,
    IN_IFDEF = 2,
    IN_ELSE = 3
} ;
#line 1730 "/tmp/0/patch-2.7.1/src/patch.c"
struct file_to_delete {
   char *name ;
   struct stat st ;
   int backup ;
};
#line 1793 "/tmp/0/patch-2.7.1/src/patch.c"
struct file_to_output {
   char *from ;
   struct stat from_st ;
   char *to ;
   mode_t mode ;
   int backup ;
};
#line 48 "./xvasprintf.h"
char *xvasprintf(char const   *format , va_list args ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s ) ;
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern _IO_FILE *stdin ;
#line 136
extern _IO_FILE *stdout ;
#line 327
extern int vfprintf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 333
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 352
extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__f ,
                                                   __gnuc_va_list __arg ) ;
#line 484
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 495
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 496
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 506
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 524
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp3 = vfprintf(stdout, __fmt, __arg);
  }
#line 38
  return (__cil_tmp3);
}
}
#line 44
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 46
  __cil_tmp1 = _IO_getc(stdin);
  }
#line 46
  return (__cil_tmp1);
}
}
#line 53
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 55
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 55
  if (__cil_tmp2) {
    {
#line 55
    __cil_tmp3 = __uflow(__fp);
#line 55
    tmp = __cil_tmp3;
    }
  } else {
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 55
  return (tmp);
}
}
#line 70
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 72
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 72
  if (__cil_tmp1) {
    {
#line 72
    __cil_tmp2 = __uflow(stdin);
#line 72
    tmp = __cil_tmp2;
    }
  } else {
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 72
  return (tmp);
}
}
#line 79
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _IO_putc(__c, stdout);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 88
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 90
  if (__cil_tmp3) {
    {
#line 90
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp = __cil_tmp4;
    }
  } else {
#line 90
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    *__cil_tmp5 = (char )__c;
#line 90
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 90
  return (tmp);
}
}
#line 105
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 107
  if (__cil_tmp2) {
    {
#line 107
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp = __cil_tmp3;
    }
  } else {
#line 107
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    *__cil_tmp4 = (char )__c;
#line 107
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 107
  return (tmp);
}
}
#line 115
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 117
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (__cil_tmp4);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major |= 0UL;
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor |= (__dev & 17592184995840UL) >> 12;
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 47 "./xalloc.h"
void xalloc_die(void) ;
#line 49
void *xmalloc(size_t n ) ;
#line 106
__inline static void *xnmalloc(size_t n , size_t s ) ;
#line 109 "./xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *__cil_tmp4 ;

  {
#line 111
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 111
    tmp = - 1;
  } else {
#line 111
    tmp = - 2;
  }
#line 111
  if ((size_t )tmp / s < n) {
    {
#line 112
    xalloc_die();
    }
  }
  {
#line 113
  __cil_tmp4 = xmalloc(n * s);
  }
#line 113
  return (__cil_tmp4);
}
}
#line 60 "./xsize.h"
__inline size_t xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 62
  sum = size1 + size2;
#line 63
  if (sum >= size1) {
#line 63
    tmp = sum;
  } else {
#line 63
    tmp = 0xffffffffffffffffUL;
  }
#line 63
  return (tmp);
}
}
#line 71 "./xsize.h"
__inline size_t xsum3(size_t size1 , size_t size2 , size_t size3 ) 
{ 
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
  {
#line 73
  __cil_tmp4 = xsum(size1, size2);
#line 73
  __cil_tmp5 = xsum(__cil_tmp4, size3);
  }
#line 73
  return (__cil_tmp5);
}
}
#line 81 "./xsize.h"
__inline size_t xsum4(size_t size1 , size_t size2 , size_t size3 , size_t size4 ) 
{ 
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
  {
#line 83
  __cil_tmp5 = xsum(size1, size2);
#line 83
  __cil_tmp6 = xsum(__cil_tmp5, size3);
#line 83
  __cil_tmp7 = xsum(__cil_tmp6, size4);
  }
#line 83
  return (__cil_tmp7);
}
}
#line 91 "./xsize.h"
__inline size_t xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 95
  if (size1 >= size2) {
#line 95
    tmp = size1;
  } else {
#line 95
    tmp = size2;
  }
#line 95
  return (tmp);
}
}
#line 33 "/tmp/0/patch-2.7.1/lib/xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *tmp ;
  char const   *next___0 ;
  size_t len ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;

  {
  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy((__builtin_va_list *)ap, args);
#line 44
  i = argcount;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i > 0UL)) {
#line 44
      goto while_break;
    }
    {
#line 46
    next = 0;
#line 47
    __cil_tmp9 = strlen(next);
#line 47
    __cil_tmp10 = xsum(totalsize, __cil_tmp9);
#line 47
    totalsize = __cil_tmp10;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  __cil_tmp11 = i;
#line 44
  i --;
#line 49
  __builtin_va_end((__builtin_va_list *)ap);
  }
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
    {
    {
#line 56
    __cil_tmp12 = __errno_location();
    }
#line 56
    *__cil_tmp12 = 75;
    }
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
    {
    {
#line 56
    __cil_tmp12 = __errno_location();
    }
#line 56
    *__cil_tmp12 = 75;
    }
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
    {
#line 61
    __cil_tmp13 = xmalloc(totalsize + 1UL);
#line 61
    tmp = __cil_tmp13;
    }
  } else {
    {
#line 61
    __cil_tmp14 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp = __cil_tmp14;
    }
  }
#line 61
  result = (char *)tmp;
#line 62
  p = result;
#line 63
  i = argcount;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (i > 0UL)) {
#line 63
      goto while_break___0;
    }
    {
#line 65
    next___0 = 0;
#line 66
    __cil_tmp18 = strlen(next___0);
#line 66
    len = __cil_tmp18;
#line 67
    memcpy((void *)p, (void const   *)next___0, len);
#line 68
    p += len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  __cil_tmp19 = i;
#line 63
  i --;
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 76 "/tmp/0/patch-2.7.1/lib/xvasprintf.c"
char *xvasprintf(char const   *format , va_list args ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *__cil_tmp6 ;
  int __cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! 1) {
#line 87
      goto while_break;
    }
#line 89
    if ((int )((char )*f) == 0) {
      {
#line 91
      __cil_tmp6 = xstrcat(argcount, args);
      }
#line 91
      return (__cil_tmp6);
    }
#line 92
    if ((int )((char )*f) != 37) {
#line 93
      goto while_break;
    }
#line 94
    f ++;
#line 95
    if ((int )((char )*f) != 115) {
#line 96
      goto while_break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  __cil_tmp10 = vasprintf(& result, format, args);
  }
#line 102
  if (__cil_tmp10 < 0) {
    {
#line 104
    __cil_tmp11 = __errno_location();
    }
#line 104
    if (*__cil_tmp11 == 12) {
      {
#line 105
      xalloc_die();
      }
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 23 "./xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 174 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 30 "/tmp/0/patch-2.7.1/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *__cil_tmp4 ;

  {
  {
#line 32
  __cil_tmp4 = strndup(string, n);
#line 32
  s = __cil_tmp4;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 51 "./xalloc.h"
void *xzalloc(size_t s ) ;
#line 53
void *xcalloc(size_t n , size_t s ) ;
#line 55
void *xrealloc(void *p , size_t n ) ;
#line 57
void *x2realloc(void *p , size_t *pn ) ;
#line 58
void *xmemdup(void const   *p , size_t s ) ;
#line 60
char *xstrdup(char const   *string ) ;
#line 185 "./xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *__cil_tmp5 ;

  {
#line 187
  n = *pn;
#line 189
  if (! p) {
#line 191
    if (! n) {
#line 199
      n = 128UL / s;
#line 200
      n += (unsigned long )(! n);
    }
  } else {
#line 209
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 210
      xalloc_die();
      }
    }
#line 211
    n += (n + 1UL) / 2UL;
  }
  {
#line 214
  *pn = n;
#line 215
  __cil_tmp5 = xrealloc(p, n * s);
  }
#line 215
  return (__cil_tmp5);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 541
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 549
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 817
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = ((int (*)(void const   * , void const   * ))*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 41 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *__cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp3 = malloc(n);
#line 43
  p = __cil_tmp3;
  }
#line 44
  if (! p) {
#line 44
    if (n != 0UL) {
      {
#line 45
      xalloc_die();
      }
    }
  }
#line 46
  return (p);
}
}
#line 53 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 55
  if (! n) {
#line 55
    if (p) {
      {
#line 59
      free(p);
      }
#line 60
      return ((void *)0);
    }
  }
  {
#line 63
  p = realloc(p, n);
  }
#line 64
  if (! p) {
#line 64
    if (n) {
      {
#line 65
      xalloc_die();
      }
    }
  }
#line 66
  return (p);
}
}
#line 76 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 78
  __cil_tmp3 = x2nrealloc(p, pn, (size_t )1);
  }
#line 78
  return (__cil_tmp3);
}
}
#line 86 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 88
  __cil_tmp2 = xmalloc(s);
#line 88
  __cil_tmp3 = memset(__cil_tmp2, 0, s);
  }
#line 88
  return (__cil_tmp3);
}
}
#line 95 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;
  int tmp ;

  {
  {
#line 102
  p = calloc(n, s);
  }
#line 102
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 102
    tmp = - 1;
  } else {
#line 102
    tmp = - 2;
  }
#line 102
  if (! p) {
    {
#line 104
    xalloc_die();
    }
  }
#line 105
  return (p);
}
}
#line 113 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 115
  __cil_tmp3 = xmalloc(s);
#line 115
  __cil_tmp4 = memcpy(__cil_tmp3, p, s);
  }
#line 115
  return (__cil_tmp4);
}
}
#line 121 "/tmp/0/patch-2.7.1/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t __cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 123
  __cil_tmp2 = strlen(string);
#line 123
  __cil_tmp3 = xmemdup((void const   *)string, __cil_tmp2 + 1UL);
  }
#line 123
  return ((char *)__cil_tmp3);
}
}
#line 46 "./xvasprintf.h"
char *xasprintf(char const   *format  , ...) ;
#line 24 "/tmp/0/patch-2.7.1/lib/xasprintf.c"
char *xasprintf(char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 29
  __builtin_va_start((__builtin_va_list *)args, format);
#line 30
  result = xvasprintf(format, (__builtin_va_list *)args);
#line 31
  __builtin_va_end((__builtin_va_list *)args);
  }
#line 33
  return (result);
}
}
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 42 "./error.h"
extern void error(int __status , int __errnum , char const   *__format  , ...) ;
#line 18 "./exitfail.h"
int exit_failure ;
#line 32 "/tmp/0/patch-2.7.1/lib/xalloc-die.c"
void xalloc_die(void) 
{ 


  {
  {
#line 34
  error(exit_failure, 0, (char const   *)((char *)"%s"), (char const   *)((char *)"memory exhausted"));
#line 40
  abort();
  }
}
}
#line 45 "./error.h"
extern void error_at_line(int __status , int __errnum , char const   *__fname , unsigned int __lineno ,
                          char const   *__format  , ...) ;
#line 34 "./verror.h"
void verror(int status , int errnum , char const   *format , va_list args ) ;
#line 45
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) ;
#line 43 "/tmp/0/patch-2.7.1/lib/verror.c"
void verror(int status , int errnum , char const   *format , va_list args ) 
{ 


  {
  {
#line 45
  verror_at_line(status, errnum, (char const   *)((void *)0), (unsigned int )0, format,
                 args);
  }
}
}
#line 55 "/tmp/0/patch-2.7.1/lib/verror.c"
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) 
{ 
  char *message ;
  char *__cil_tmp8 ;
  int *__cil_tmp9 ;

  {
  {
#line 58
  __cil_tmp8 = xvasprintf(format, args);
#line 58
  message = __cil_tmp8;
  }
#line 59
  if (message) {
#line 64
    if (file) {
      {
#line 65
      error_at_line(status, errnum, file, line_number, (char const   *)((char *)"%s"),
                    message);
      }
    } else {
      {
#line 67
      error(status, errnum, (char const   *)((char *)"%s"), message);
      }
    }
  } else {
    {
#line 73
    __cil_tmp9 = __errno_location();
#line 73
    error(0, *__cil_tmp9, (char const   *)((char *)"unable to display error message"));
#line 74
    abort();
    }
  }
  {
#line 76
  free((void *)message);
  }
}
}
#line 72 "./vasnprintf.h"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) ;
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __maxlen , char const   *__format 
                                                  , ...) ;
#line 284 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 288
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t *__pwc , char const   *__s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 305
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   *__s , size_t __n ,
                                                     mbstate_t *__ps ) ;
#line 307
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 316
extern wint_t __btowc_alias(int __c ) ;
#line 318
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 318 "/usr/include/wchar.h"
__inline extern wint_t btowc(int __c ) 
{ 
  int __cil_tmp2 ;
  wint_t __cil_tmp3 ;
  wint_t tmp ;

  {
  {
#line 319
  __cil_tmp2 = __builtin_constant_p(__c);
  }
#line 319
  if ((__cil_tmp2 && __c >= 0) && __c <= 127) {
#line 319
    tmp = (wint_t )__c;
  } else {
    {
#line 319
    __cil_tmp3 = __btowc_alias(__c);
#line 319
    tmp = __cil_tmp3;
    }
  }
#line 319
  return (tmp);
}
}
#line 322
extern int __wctob_alias(wint_t __c ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/wchar.h"
__inline extern int wctob(wint_t __wc ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 325
  __cil_tmp2 = __builtin_constant_p(__wc);
  }
#line 325
  if ((__cil_tmp2 && __wc >= 0U) && __wc <= 127U) {
#line 325
    tmp = (int )__wc;
  } else {
    {
#line 325
    __cil_tmp3 = __wctob_alias(__wc);
#line 325
    tmp = __cil_tmp3;
    }
  }
#line 325
  return (tmp);
}
}
#line 329
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 329 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   *__s , size_t __n , mbstate_t *__ps ) 
{ 
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  size_t tmp ;

  {
#line 331
  if (__ps != (mbstate_t *)((void *)0)) {
    {
#line 331
    __cil_tmp4 = mbrtowc((wchar_t *)((void *)0), __s, __n, __ps);
#line 331
    tmp = __cil_tmp4;
    }
  } else {
    {
#line 331
    __cil_tmp5 = __mbrlen(__s, __n, (mbstate_t *)((void *)0));
#line 331
    tmp = __cil_tmp5;
    }
  }
#line 331
  return (tmp);
}
}
#line 156 "./printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 190 "./printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 1773 "/tmp/0/patch-2.7.1/lib/vasnprintf.c"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  size_t buf_neededlength ;
  char *buf___0 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  void *__cil_tmp20 ;
  size_t buf_memsize ;
  unsigned long tmp ;
  void *__cil_tmp23 ;
  size_t n ;
  size_t augmented_length ;
  size_t __cil_tmp26 ;
  size_t memory_size ;
  char *memory ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  size_t __cil_tmp34 ;
  char const   *__cil_tmp35 ;
  size_t augmented_length___0 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  size_t n___0 ;
  char const   *mp ;
  char *__cil_tmp61 ;
  char const   *__cil_tmp62 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *__cil_tmp65 ;
  char const   *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  size_t __cil_tmp72 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  size_t __cil_tmp77 ;
  unsigned long tmp___8 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int *__cil_tmp86 ;
  int arg ;
  unsigned int arg___0 ;
  int arg___1 ;
  unsigned int arg___2 ;
  int arg___3 ;
  unsigned int arg___4 ;
  long arg___5 ;
  unsigned long arg___6 ;
  long long arg___7 ;
  unsigned long long arg___8 ;
  double arg___9 ;
  long double arg___10 ;
  int arg___11 ;
  wint_t arg___12 ;
  char const   *arg___13 ;
  wchar_t *arg___14 ;
  void *arg___15 ;
  int saved_errno ;
  int *__cil_tmp156 ;
  int *__cil_tmp157 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t n___2 ;
  size_t __cil_tmp161 ;
  unsigned long tmp___11 ;
  size_t __cil_tmp163 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  void *__cil_tmp169 ;
  void *__cil_tmp170 ;
  int *__cil_tmp171 ;
  size_t __cil_tmp172 ;
  char_directive *__cil_tmp173 ;
  size_t __cil_tmp174 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  size_t __cil_tmp179 ;
  unsigned long tmp___17 ;
  void *__cil_tmp182 ;
  void *__cil_tmp183 ;
  char *memory___4 ;
  void *__cil_tmp185 ;
  int *__cil_tmp186 ;
  int *__cil_tmp187 ;

  {
  {
#line 1779
  __cil_tmp7 = printf_parse(format, & d, & a);
  }
#line 1779
  if (__cil_tmp7 < 0) {
#line 1781
    return ((char *)((void *)0));
  }
  {
#line 1789
  __cil_tmp8 = printf_fetchargs(args, & a);
  }
#line 1789
  if (__cil_tmp8 < 0) {
#line 1791
    if (d.dir != (char_directive *)d.direct_alloc_dir) {
      {
#line 1791
      free((void *)d.dir);
      }
    }
#line 1791
    if (a.arg != (argument *)a.direct_alloc_arg) {
      {
#line 1791
      free((void *)a.arg);
      }
    }
    {
#line 1792
    __cil_tmp9 = __errno_location();
#line 1792
    *__cil_tmp9 = 22;
    }
#line 1793
    return ((char *)((void *)0));
  }
  {
#line 1810
  buf_neededlength = xsum4((size_t )7, d.max_width_length, d.max_precision_length,
                           (size_t )6);
  }
#line 1813
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1815
    __cil_tmp20 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1815
    buf___0 = (char *)__cil_tmp20;
#line 1816
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1821
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1821
      tmp = buf_neededlength * sizeof(char );
    } else {
#line 1821
      tmp = 0xffffffffffffffffUL;
    }
#line 1821
    buf_memsize = tmp;
#line 1822
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1823
      goto out_of_memory_1;
    }
    {
#line 1824
    __cil_tmp23 = malloc(buf_memsize);
#line 1824
    buf___0 = (char *)__cil_tmp23;
    }
#line 1825
    if (buf___0 == (char *)((void *)0)) {
#line 1826
      goto out_of_memory_1;
    }
#line 1827
    buf_malloced = buf___0;
  }
#line 1830
  if (resultbuf != (char *)((void *)0)) {
#line 1832
    result = resultbuf;
#line 1833
    allocated = *lengthp;
  } else {
#line 1837
    result = (char *)((void *)0);
#line 1838
    allocated = (size_t )0;
  }
#line 1840
  length = (size_t )0;
#line 1870
  dp = & *(d.dir + 0);
#line 1870
  i = (size_t )0;
#line 1870
  cp = format;
  {
#line 1870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1870
    if (! 1) {
#line 1870
      goto while_break;
    }
#line 1872
    if (cp != dp->dir_start) {
      {
#line 1874
      n = (size_t )(dp->dir_start - cp);
#line 1875
      __cil_tmp26 = xsum(length, n);
#line 1875
      augmented_length = __cil_tmp26;
      }
#line 1877
      if (augmented_length > allocated) {
#line 1877
        if (allocated > 0UL) {
#line 1877
          if (allocated <= 9223372036854775807UL) {
#line 1877
            tmp___0 = allocated * 2UL;
          } else {
#line 1877
            tmp___0 = 0xffffffffffffffffUL;
          }
#line 1877
          tmp___1 = tmp___0;
        } else {
#line 1877
          tmp___1 = (unsigned long )12;
        }
#line 1877
        allocated = tmp___1;
#line 1877
        if (augmented_length > allocated) {
#line 1877
          allocated = augmented_length;
        }
#line 1877
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1877
          tmp___2 = allocated * sizeof(char );
        } else {
#line 1877
          tmp___2 = 0xffffffffffffffffUL;
        }
#line 1877
        memory_size = tmp___2;
#line 1877
        if (memory_size == 0xffffffffffffffffUL) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if (result == resultbuf) {
          {
          {
#line 1877
          __cil_tmp32 = malloc(memory_size);
          }
#line 1877
          memory = (char *)__cil_tmp32;
          }
        } else
#line 1877
        if (result == (char *)((void *)0)) {
          {
          {
#line 1877
          __cil_tmp32 = malloc(memory_size);
          }
#line 1877
          memory = (char *)__cil_tmp32;
          }
        } else {
          {
#line 1877
          __cil_tmp33 = realloc((void *)result, memory_size);
#line 1877
          memory = (char *)__cil_tmp33;
          }
        }
#line 1877
        if (memory == (char *)((void *)0)) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if (result == resultbuf) {
#line 1877
          if (length > 0UL) {
            {
#line 1877
            memcpy((void *)memory, (void const   *)result, length);
            }
          }
        }
#line 1877
        result = memory;
      }

#line 1881
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1883
        memcpy((void *)(result + length), (void const   *)cp, n);
#line 1884
        length = augmented_length;
        }
      } else {
        {
#line 1888
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1889
          __cil_tmp35 = cp;
#line 1889
          cp ++;
#line 1889
          __cil_tmp34 = length;
#line 1889
          length ++;
#line 1889
          *(result + __cil_tmp34) = (char )((unsigned char )((char )*__cil_tmp35));
#line 1888
          if (! (n > 0UL)) {
#line 1888
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1893
    if (i == d.count) {
#line 1894
      goto while_break;
    }
#line 1897
    if ((int )dp->conversion == 37) {
#line 1901
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1902
        abort();
        }
      }
      {
#line 1903
      augmented_length___0 = xsum(length, (size_t )1);
      }
#line 1904
      if (augmented_length___0 > allocated) {
#line 1904
        if (allocated > 0UL) {
#line 1904
          if (allocated <= 9223372036854775807UL) {
#line 1904
            tmp___3 = allocated * 2UL;
          } else {
#line 1904
            tmp___3 = 0xffffffffffffffffUL;
          }
#line 1904
          tmp___4 = tmp___3;
        } else {
#line 1904
          tmp___4 = (unsigned long )12;
        }
#line 1904
        allocated = tmp___4;
#line 1904
        if (augmented_length___0 > allocated) {
#line 1904
          allocated = augmented_length___0;
        }
#line 1904
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1904
          tmp___5 = allocated * sizeof(char );
        } else {
#line 1904
          tmp___5 = 0xffffffffffffffffUL;
        }
#line 1904
        memory_size___0 = tmp___5;
#line 1904
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if (result == resultbuf) {
          {
          {
#line 1904
          __cil_tmp43 = malloc(memory_size___0);
          }
#line 1904
          memory___0 = (char *)__cil_tmp43;
          }
        } else
#line 1904
        if (result == (char *)((void *)0)) {
          {
          {
#line 1904
          __cil_tmp43 = malloc(memory_size___0);
          }
#line 1904
          memory___0 = (char *)__cil_tmp43;
          }
        } else {
          {
#line 1904
          __cil_tmp44 = realloc((void *)result, memory_size___0);
#line 1904
          memory___0 = (char *)__cil_tmp44;
          }
        }
#line 1904
        if (memory___0 == (char *)((void *)0)) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if (result == resultbuf) {
#line 1904
          if (length > 0UL) {
            {
#line 1904
            memcpy((void *)memory___0, (void const   *)result, length);
            }
          }
        }
#line 1904
        result = memory___0;
      }
#line 1905
      *(result + length) = (char )'%';
#line 1906
      length = augmented_length___0;
    } else {
#line 1910
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1911
        abort();
        }
      }
#line 1913
      if ((int )dp->conversion == 110) {
        {
#line 1917
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )18) {
#line 1917
          goto case_18;
        }
#line 1920
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )19) {
#line 1920
          goto case_19;
        }
#line 1923
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )20) {
#line 1923
          goto case_20;
        }
#line 1926
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )21) {
#line 1926
          goto case_21;
        }
#line 1930
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )22) {
#line 1930
          goto case_22;
        }
#line 1934
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1918
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1919
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1921
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1922
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1924
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1925
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1927
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1928
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1931
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1932
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1935
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4606
        type = (a.arg + dp->arg_index)->type;
#line 4607
        flags = dp->flags;
#line 4768
        fbp = buf___0;
#line 4769
        __cil_tmp51 = fbp;
#line 4769
        fbp ++;
#line 4769
        *__cil_tmp51 = (char )'%';
#line 4775
        if (flags & 1) {
#line 4776
          __cil_tmp52 = fbp;
#line 4776
          fbp ++;
#line 4776
          *__cil_tmp52 = (char )'\'';
        }
#line 4778
        if (flags & 2) {
#line 4779
          __cil_tmp53 = fbp;
#line 4779
          fbp ++;
#line 4779
          *__cil_tmp53 = (char )'-';
        }
#line 4780
        if (flags & 4) {
#line 4781
          __cil_tmp54 = fbp;
#line 4781
          fbp ++;
#line 4781
          *__cil_tmp54 = (char )'+';
        }
#line 4782
        if (flags & 8) {
#line 4783
          __cil_tmp55 = fbp;
#line 4783
          fbp ++;
#line 4783
          *__cil_tmp55 = (char )' ';
        }
#line 4784
        if (flags & 16) {
#line 4785
          __cil_tmp56 = fbp;
#line 4785
          fbp ++;
#line 4785
          *__cil_tmp56 = (char )'#';
        }
#line 4787
        if (flags & 64) {
#line 4788
          __cil_tmp57 = fbp;
#line 4788
          fbp ++;
#line 4788
          *__cil_tmp57 = (char )'I';
        }
#line 4790
        if (! 0) {
#line 4792
          if (flags & 32) {
#line 4793
            __cil_tmp58 = fbp;
#line 4793
            fbp ++;
#line 4793
            *__cil_tmp58 = (char )'0';
          }
#line 4794
          if (dp->width_start != dp->width_end) {
#line 4796
            n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4799
            if (sizeof(char ) == sizeof(char )) {
              {
#line 4801
              memcpy((void *)fbp, (void const   *)dp->width_start, n___0 * sizeof(char ));
#line 4802
              fbp += n___0;
              }
            } else {
#line 4806
              mp = dp->width_start;
              {
#line 4807
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 4808
                __cil_tmp62 = mp;
#line 4808
                mp ++;
#line 4808
                __cil_tmp61 = fbp;
#line 4808
                fbp ++;
#line 4808
                *__cil_tmp61 = (char )((unsigned char )((char )*__cil_tmp62));
#line 4807
                if (! (n___0 > 0UL)) {
#line 4807
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
        }
#line 4813
        if (! 0) {
#line 4815
          if (dp->precision_start != dp->precision_end) {
#line 4817
            n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4820
            if (sizeof(char ) == sizeof(char )) {
              {
#line 4822
              memcpy((void *)fbp, (void const   *)dp->precision_start, n___1 * sizeof(char ));
#line 4823
              fbp += n___1;
              }
            } else {
#line 4827
              mp___0 = dp->precision_start;
              {
#line 4828
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4829
                __cil_tmp66 = mp___0;
#line 4829
                mp___0 ++;
#line 4829
                __cil_tmp65 = fbp;
#line 4829
                fbp ++;
#line 4829
                *__cil_tmp65 = (char )((unsigned char )((char )*__cil_tmp66));
#line 4828
                if (! (n___1 > 0UL)) {
#line 4828
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 4839
        if ((unsigned int )type == (unsigned int )10) {
#line 4839
          goto case_10;
        }
#line 4839
        if ((unsigned int )type == (unsigned int )9) {
#line 4839
          goto case_10;
        }
#line 4856
        if ((unsigned int )type == (unsigned int )16) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == (unsigned int )14) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == (unsigned int )8) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == (unsigned int )7) {
#line 4856
          goto case_16;
        }
#line 4860
        if ((unsigned int )type == (unsigned int )12) {
#line 4860
          goto case_12;
        }
#line 4863
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4846
        __cil_tmp67 = fbp;
#line 4846
        fbp ++;
#line 4846
        *__cil_tmp67 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4858
        __cil_tmp68 = fbp;
#line 4858
        fbp ++;
#line 4858
        *__cil_tmp68 = (char )'l';
#line 4859
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4861
        __cil_tmp69 = fbp;
#line 4861
        fbp ++;
#line 4861
        *__cil_tmp69 = (char )'L';
#line 4862
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4864
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4871
        *fbp = dp->conversion;
#line 4902
        *(fbp + 1) = (char )'\000';
#line 4909
        prefix_count = (unsigned int )0;
#line 4910
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4912
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4913
            abort();
            }
          }
#line 4914
          __cil_tmp70 = prefix_count;
#line 4914
          prefix_count ++;
#line 4914
          prefixes[__cil_tmp70] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4916
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4918
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4919
            abort();
            }
          }
#line 4920
          __cil_tmp71 = prefix_count;
#line 4920
          prefix_count ++;
#line 4920
          prefixes[__cil_tmp71] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4932
        __cil_tmp72 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4932
        if (__cil_tmp72 > allocated) {
#line 4932
          if (allocated > 0UL) {
#line 4932
            if (allocated <= 9223372036854775807UL) {
#line 4932
              tmp___6 = allocated * 2UL;
            } else {
#line 4932
              tmp___6 = 0xffffffffffffffffUL;
            }
#line 4932
            tmp___7 = tmp___6;
          } else {
#line 4932
            tmp___7 = (unsigned long )12;
          }
          {
#line 4932
          allocated = tmp___7;
#line 4932
          __cil_tmp77 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4932
          if (__cil_tmp77 > allocated) {
            {
#line 4932
            allocated = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
            }
          }
#line 4932
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4932
            tmp___8 = allocated * sizeof(char );
          } else {
#line 4932
            tmp___8 = 0xffffffffffffffffUL;
          }
#line 4932
          memory_size___1 = tmp___8;
#line 4932
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4932
            goto out_of_memory;
          }
#line 4932
          if (result == resultbuf) {
            {
            {
#line 4932
            __cil_tmp80 = malloc(memory_size___1);
            }
#line 4932
            memory___1 = (char *)__cil_tmp80;
            }
          } else
#line 4932
          if (result == (char *)((void *)0)) {
            {
            {
#line 4932
            __cil_tmp80 = malloc(memory_size___1);
            }
#line 4932
            memory___1 = (char *)__cil_tmp80;
            }
          } else {
            {
#line 4932
            __cil_tmp81 = realloc((void *)result, memory_size___1);
#line 4932
            memory___1 = (char *)__cil_tmp81;
            }
          }
#line 4932
          if (memory___1 == (char *)((void *)0)) {
#line 4932
            goto out_of_memory;
          }
#line 4932
          if (result == resultbuf) {
#line 4932
            if (length > 0UL) {
              {
#line 4932
              memcpy((void *)memory___1, (void const   *)result, length);
              }
            }
          }
#line 4932
          result = memory___1;
        }
        {
#line 4937
        *(result + length) = (char )'\000';
#line 4940
        orig_errno = (int )__errno_location();
        }
        {
#line 4942
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4942
          if (! 1) {
#line 4942
            goto while_break___3;
          }
#line 4944
          count = - 1;
#line 4947
          retcount = 0;
#line 4948
          maxlen = allocated - length;
#line 4951
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4952
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          {
#line 4953
          maxlen *= sizeof(char ) / sizeof(char );
#line 4995
          __cil_tmp86 = __errno_location();
#line 4995
          *__cil_tmp86 = 0;
          }
          {
#line 4998
          if ((unsigned int )type == (unsigned int )1) {
#line 4998
            goto case_1;
          }
#line 5001
          if ((unsigned int )type == (unsigned int )0) {
#line 5001
            goto case_0;
          }
#line 5001
          if ((unsigned int )type == (unsigned int )1) {
#line 5001
            goto case_1___0;
          }
#line 5001
          if ((unsigned int )type == (unsigned int )2) {
#line 5001
            goto case_2;
          }
#line 5004
          if ((unsigned int )type == (unsigned int )2) {
#line 5004
            goto case_2___0;
          }
#line 5007
          if ((unsigned int )type == (unsigned int )0) {
#line 5007
            goto case_0___0;
          }
#line 5007
          if ((unsigned int )type == (unsigned int )1) {
#line 5007
            goto case_1___1;
          }
#line 5007
          if ((unsigned int )type == (unsigned int )2) {
#line 5007
            goto case_2___1;
          }
#line 5010
          if ((unsigned int )type == (unsigned int )3) {
#line 5010
            goto case_3;
          }
#line 5013
          if ((unsigned int )type == (unsigned int )0) {
#line 5013
            goto case_0___1;
          }
#line 5013
          if ((unsigned int )type == (unsigned int )1) {
#line 5013
            goto case_1___2;
          }
#line 5013
          if ((unsigned int )type == (unsigned int )2) {
#line 5013
            goto case_2___2;
          }
#line 5016
          if ((unsigned int )type == (unsigned int )4) {
#line 5016
            goto case_4;
          }
#line 5019
          if ((unsigned int )type == (unsigned int )0) {
#line 5019
            goto case_0___2;
          }
#line 5019
          if ((unsigned int )type == (unsigned int )1) {
#line 5019
            goto case_1___3;
          }
#line 5019
          if ((unsigned int )type == (unsigned int )2) {
#line 5019
            goto case_2___3;
          }
#line 5022
          if ((unsigned int )type == (unsigned int )5) {
#line 5022
            goto case_5;
          }
#line 5025
          if ((unsigned int )type == (unsigned int )0) {
#line 5025
            goto case_0___3;
          }
#line 5025
          if ((unsigned int )type == (unsigned int )1) {
#line 5025
            goto case_1___4;
          }
#line 5025
          if ((unsigned int )type == (unsigned int )2) {
#line 5025
            goto case_2___4;
          }
#line 5028
          if ((unsigned int )type == (unsigned int )6) {
#line 5028
            goto case_6;
          }
#line 5031
          if ((unsigned int )type == (unsigned int )0) {
#line 5031
            goto case_0___4;
          }
#line 5031
          if ((unsigned int )type == (unsigned int )1) {
#line 5031
            goto case_1___5;
          }
#line 5031
          if ((unsigned int )type == (unsigned int )2) {
#line 5031
            goto case_2___5;
          }
#line 5034
          if ((unsigned int )type == (unsigned int )7) {
#line 5034
            goto case_7___0;
          }
#line 5037
          if ((unsigned int )type == (unsigned int )0) {
#line 5037
            goto case_0___5;
          }
#line 5037
          if ((unsigned int )type == (unsigned int )1) {
#line 5037
            goto case_1___6;
          }
#line 5037
          if ((unsigned int )type == (unsigned int )2) {
#line 5037
            goto case_2___6;
          }
#line 5040
          if ((unsigned int )type == (unsigned int )8) {
#line 5040
            goto case_8___0;
          }
#line 5043
          if ((unsigned int )type == (unsigned int )0) {
#line 5043
            goto case_0___6;
          }
#line 5043
          if ((unsigned int )type == (unsigned int )1) {
#line 5043
            goto case_1___7;
          }
#line 5043
          if ((unsigned int )type == (unsigned int )2) {
#line 5043
            goto case_2___7;
          }
#line 5047
          if ((unsigned int )type == (unsigned int )9) {
#line 5047
            goto case_9___0;
          }
#line 5050
          if ((unsigned int )type == (unsigned int )0) {
#line 5050
            goto case_0___7;
          }
#line 5050
          if ((unsigned int )type == (unsigned int )1) {
#line 5050
            goto case_1___8;
          }
#line 5050
          if ((unsigned int )type == (unsigned int )2) {
#line 5050
            goto case_2___8;
          }
#line 5053
          if ((unsigned int )type == (unsigned int )10) {
#line 5053
            goto case_10___0;
          }
#line 5056
          if ((unsigned int )type == (unsigned int )0) {
#line 5056
            goto case_0___8;
          }
#line 5056
          if ((unsigned int )type == (unsigned int )1) {
#line 5056
            goto case_1___9;
          }
#line 5056
          if ((unsigned int )type == (unsigned int )2) {
#line 5056
            goto case_2___9;
          }
#line 5060
          if ((unsigned int )type == (unsigned int )11) {
#line 5060
            goto case_11;
          }
#line 5063
          if ((unsigned int )type == (unsigned int )0) {
#line 5063
            goto case_0___9;
          }
#line 5063
          if ((unsigned int )type == (unsigned int )1) {
#line 5063
            goto case_1___10;
          }
#line 5063
          if ((unsigned int )type == (unsigned int )2) {
#line 5063
            goto case_2___10;
          }
#line 5066
          if ((unsigned int )type == (unsigned int )12) {
#line 5066
            goto case_12___0;
          }
#line 5069
          if ((unsigned int )type == (unsigned int )0) {
#line 5069
            goto case_0___10;
          }
#line 5069
          if ((unsigned int )type == (unsigned int )1) {
#line 5069
            goto case_1___11;
          }
#line 5069
          if ((unsigned int )type == (unsigned int )2) {
#line 5069
            goto case_2___11;
          }
#line 5072
          if ((unsigned int )type == (unsigned int )13) {
#line 5072
            goto case_13;
          }
#line 5075
          if ((unsigned int )type == (unsigned int )0) {
#line 5075
            goto case_0___11;
          }
#line 5075
          if ((unsigned int )type == (unsigned int )1) {
#line 5075
            goto case_1___12;
          }
#line 5075
          if ((unsigned int )type == (unsigned int )2) {
#line 5075
            goto case_2___12;
          }
#line 5079
          if ((unsigned int )type == (unsigned int )14) {
#line 5079
            goto case_14___0;
          }
#line 5082
          if ((unsigned int )type == (unsigned int )0) {
#line 5082
            goto case_0___12;
          }
#line 5082
          if ((unsigned int )type == (unsigned int )1) {
#line 5082
            goto case_1___13;
          }
#line 5082
          if ((unsigned int )type == (unsigned int )2) {
#line 5082
            goto case_2___13;
          }
#line 5086
          if ((unsigned int )type == (unsigned int )15) {
#line 5086
            goto case_15;
          }
#line 5089
          if ((unsigned int )type == (unsigned int )0) {
#line 5089
            goto case_0___13;
          }
#line 5089
          if ((unsigned int )type == (unsigned int )1) {
#line 5089
            goto case_1___14;
          }
#line 5089
          if ((unsigned int )type == (unsigned int )2) {
#line 5089
            goto case_2___14;
          }
#line 5093
          if ((unsigned int )type == (unsigned int )16) {
#line 5093
            goto case_16___0;
          }
#line 5096
          if ((unsigned int )type == (unsigned int )0) {
#line 5096
            goto case_0___14;
          }
#line 5096
          if ((unsigned int )type == (unsigned int )1) {
#line 5096
            goto case_1___15;
          }
#line 5096
          if ((unsigned int )type == (unsigned int )2) {
#line 5096
            goto case_2___15;
          }
#line 5100
          if ((unsigned int )type == (unsigned int )17) {
#line 5100
            goto case_17;
          }
#line 5103
          if ((unsigned int )type == (unsigned int )0) {
#line 5103
            goto case_0___15;
          }
#line 5103
          if ((unsigned int )type == (unsigned int )1) {
#line 5103
            goto case_1___16;
          }
#line 5103
          if ((unsigned int )type == (unsigned int )2) {
#line 5103
            goto case_2___16;
          }
#line 5106
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 5000
          arg = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 5001
          if (prefix_count == (unsigned int )0) {
#line 5001
            goto case_0;
          }
#line 5001
          if (prefix_count == (unsigned int )1) {
#line 5001
            goto case_1___0;
          }
#line 5001
          if (prefix_count == (unsigned int )2) {
#line 5001
            goto case_2;
          }
#line 5001
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg,
                              & count);
          }
#line 5001
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg, & count);
          }
#line 5001
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg, & count);
          }
#line 5001
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 5001
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }

#line 5003
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 5006
          arg___0 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 5007
          if (prefix_count == (unsigned int )0) {
#line 5007
            goto case_0___0;
          }
#line 5007
          if (prefix_count == (unsigned int )1) {
#line 5007
            goto case_1___1;
          }
#line 5007
          if (prefix_count == (unsigned int )2) {
#line 5007
            goto case_2___1;
          }
#line 5007
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___0,
                              & count);
          }
#line 5007
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___0, & count);
          }
#line 5007
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___0, & count);
          }
#line 5007
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 5007
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }

#line 5009
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 5012
          arg___1 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 5013
          if (prefix_count == (unsigned int )0) {
#line 5013
            goto case_0___1;
          }
#line 5013
          if (prefix_count == (unsigned int )1) {
#line 5013
            goto case_1___2;
          }
#line 5013
          if (prefix_count == (unsigned int )2) {
#line 5013
            goto case_2___2;
          }
#line 5013
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___1,
                              & count);
          }
#line 5013
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___1, & count);
          }
#line 5013
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___1, & count);
          }
#line 5013
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 5013
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }

#line 5015
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 5018
          arg___2 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 5019
          if (prefix_count == (unsigned int )0) {
#line 5019
            goto case_0___2;
          }
#line 5019
          if (prefix_count == (unsigned int )1) {
#line 5019
            goto case_1___3;
          }
#line 5019
          if (prefix_count == (unsigned int )2) {
#line 5019
            goto case_2___3;
          }
#line 5019
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___2,
                              & count);
          }
#line 5019
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___2, & count);
          }
#line 5019
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___2, & count);
          }
#line 5019
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 5019
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }

#line 5021
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 5024
          arg___3 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 5025
          if (prefix_count == (unsigned int )0) {
#line 5025
            goto case_0___3;
          }
#line 5025
          if (prefix_count == (unsigned int )1) {
#line 5025
            goto case_1___4;
          }
#line 5025
          if (prefix_count == (unsigned int )2) {
#line 5025
            goto case_2___4;
          }
#line 5025
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___3,
                              & count);
          }
#line 5025
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___3, & count);
          }
#line 5025
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___3, & count);
          }
#line 5025
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 5025
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }

#line 5027
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5030
          arg___4 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5031
          if (prefix_count == (unsigned int )0) {
#line 5031
            goto case_0___4;
          }
#line 5031
          if (prefix_count == (unsigned int )1) {
#line 5031
            goto case_1___5;
          }
#line 5031
          if (prefix_count == (unsigned int )2) {
#line 5031
            goto case_2___5;
          }
#line 5031
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___4,
                              & count);
          }
#line 5031
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___4, & count);
          }
#line 5031
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___4, & count);
          }
#line 5031
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5031
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }

#line 5033
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5036
          arg___5 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5037
          if (prefix_count == (unsigned int )0) {
#line 5037
            goto case_0___5;
          }
#line 5037
          if (prefix_count == (unsigned int )1) {
#line 5037
            goto case_1___6;
          }
#line 5037
          if (prefix_count == (unsigned int )2) {
#line 5037
            goto case_2___6;
          }
#line 5037
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___5,
                              & count);
          }
#line 5037
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___5, & count);
          }
#line 5037
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___5, & count);
          }
#line 5037
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5037
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }

#line 5039
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5042
          arg___6 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5043
          if (prefix_count == (unsigned int )0) {
#line 5043
            goto case_0___6;
          }
#line 5043
          if (prefix_count == (unsigned int )1) {
#line 5043
            goto case_1___7;
          }
#line 5043
          if (prefix_count == (unsigned int )2) {
#line 5043
            goto case_2___7;
          }
#line 5043
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___6,
                              & count);
          }
#line 5043
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___6, & count);
          }
#line 5043
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___6, & count);
          }
#line 5043
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5043
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }

#line 5045
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5049
          arg___7 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5050
          if (prefix_count == (unsigned int )0) {
#line 5050
            goto case_0___7;
          }
#line 5050
          if (prefix_count == (unsigned int )1) {
#line 5050
            goto case_1___8;
          }
#line 5050
          if (prefix_count == (unsigned int )2) {
#line 5050
            goto case_2___8;
          }
#line 5050
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___7,
                              & count);
          }
#line 5050
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___7, & count);
          }
#line 5050
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___7, & count);
          }
#line 5050
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5050
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }

#line 5052
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5055
          arg___8 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5056
          if (prefix_count == (unsigned int )0) {
#line 5056
            goto case_0___8;
          }
#line 5056
          if (prefix_count == (unsigned int )1) {
#line 5056
            goto case_1___9;
          }
#line 5056
          if (prefix_count == (unsigned int )2) {
#line 5056
            goto case_2___9;
          }
#line 5056
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___8,
                              & count);
          }
#line 5056
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___8, & count);
          }
#line 5056
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___8, & count);
          }
#line 5056
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5056
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }

#line 5058
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5062
          arg___9 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5063
          if (prefix_count == (unsigned int )0) {
#line 5063
            goto case_0___9;
          }
#line 5063
          if (prefix_count == (unsigned int )1) {
#line 5063
            goto case_1___10;
          }
#line 5063
          if (prefix_count == (unsigned int )2) {
#line 5063
            goto case_2___10;
          }
#line 5063
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___9,
                              & count);
          }
#line 5063
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___9, & count);
          }
#line 5063
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___9, & count);
          }
#line 5063
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5063
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }

#line 5065
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5068
          arg___10 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5069
          if (prefix_count == (unsigned int )0) {
#line 5069
            goto case_0___10;
          }
#line 5069
          if (prefix_count == (unsigned int )1) {
#line 5069
            goto case_1___11;
          }
#line 5069
          if (prefix_count == (unsigned int )2) {
#line 5069
            goto case_2___11;
          }
#line 5069
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___10,
                              & count);
          }
#line 5069
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___10, & count);
          }
#line 5069
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___10, & count);
          }
#line 5069
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5069
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }

#line 5071
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5074
          arg___11 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5075
          if (prefix_count == (unsigned int )0) {
#line 5075
            goto case_0___11;
          }
#line 5075
          if (prefix_count == (unsigned int )1) {
#line 5075
            goto case_1___12;
          }
#line 5075
          if (prefix_count == (unsigned int )2) {
#line 5075
            goto case_2___12;
          }
#line 5075
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___11,
                              & count);
          }
#line 5075
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___11, & count);
          }
#line 5075
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___11, & count);
          }
#line 5075
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5075
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }

#line 5077
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5081
          arg___12 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5082
          if (prefix_count == (unsigned int )0) {
#line 5082
            goto case_0___12;
          }
#line 5082
          if (prefix_count == (unsigned int )1) {
#line 5082
            goto case_1___13;
          }
#line 5082
          if (prefix_count == (unsigned int )2) {
#line 5082
            goto case_2___13;
          }
#line 5082
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___12,
                              & count);
          }
#line 5082
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___12, & count);
          }
#line 5082
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___12, & count);
          }
#line 5082
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5082
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }

#line 5084
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5088
          arg___13 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5089
          if (prefix_count == (unsigned int )0) {
#line 5089
            goto case_0___13;
          }
#line 5089
          if (prefix_count == (unsigned int )1) {
#line 5089
            goto case_1___14;
          }
#line 5089
          if (prefix_count == (unsigned int )2) {
#line 5089
            goto case_2___14;
          }
#line 5089
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___13,
                              & count);
          }
#line 5089
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___13, & count);
          }
#line 5089
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___13, & count);
          }
#line 5089
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5089
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }

#line 5091
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5095
          arg___14 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5096
          if (prefix_count == (unsigned int )0) {
#line 5096
            goto case_0___14;
          }
#line 5096
          if (prefix_count == (unsigned int )1) {
#line 5096
            goto case_1___15;
          }
#line 5096
          if (prefix_count == (unsigned int )2) {
#line 5096
            goto case_2___15;
          }
#line 5096
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___14,
                              & count);
          }
#line 5096
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___14, & count);
          }
#line 5096
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___14, & count);
          }
#line 5096
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5096
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }

#line 5098
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5102
          arg___15 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5103
          if (prefix_count == (unsigned int )0) {
#line 5103
            goto case_0___15;
          }
#line 5103
          if (prefix_count == (unsigned int )1) {
#line 5103
            goto case_1___16;
          }
#line 5103
          if (prefix_count == (unsigned int )2) {
#line 5103
            goto case_2___16;
          }
#line 5103
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, arg___15,
                              & count);
          }
#line 5103
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              arg___15, & count);
          }
#line 5103
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf(result + length, maxlen, (char const   *)buf___0, prefixes[0],
                              prefixes[1], arg___15, & count);
          }
#line 5103
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5103
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }

#line 5105
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5107
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5115
          if (count >= 0) {
#line 5119
            if ((unsigned long )count < maxlen) {
#line 5119
              if ((int )*((result + length) + count) != 0) {
                {
#line 5121
                abort();
                }
              }
            }
#line 5123
            if (retcount > count) {
#line 5124
              count = retcount;
            }
          } else
#line 5130
          if ((int )*(fbp + 1) != 0) {
#line 5134
            *(fbp + 1) = (char )'\000';
#line 5135
            goto while_continue___3;
          } else
#line 5140
          if (! (retcount < 0)) {
#line 5182
            count = retcount;
          }
#line 5188
          if (count < 0) {
            {
#line 5192
            __cil_tmp156 = __errno_location();
#line 5192
            saved_errno = *__cil_tmp156;
            }
#line 5194
            if (! (result == resultbuf || result == (char *)((void *)0))) {
              {
#line 5195
              free((void *)result);
              }
            }
#line 5196
            if (buf_malloced != (char *)((void *)0)) {
              {
#line 5197
              free((void *)buf_malloced);
              }
            }
#line 5198
            if (d.dir != (char_directive *)d.direct_alloc_dir) {
              {
#line 5198
              free((void *)d.dir);
              }
            }
#line 5198
            if (a.arg != (argument *)a.direct_alloc_arg) {
              {
#line 5198
              free((void *)a.arg);
              }
            }

#line 5199
            if (saved_errno != 0) {
#line 5199
              tmp___10 = saved_errno;
            } else {
#line 5199
              if ((int )dp->conversion == 99 || (int )dp->conversion == 115) {
#line 5199
                tmp___9 = 84;
              } else {
#line 5199
                tmp___9 = 22;
              }
#line 5199
              tmp___10 = tmp___9;
            }
            {
#line 5199
            __cil_tmp157 = __errno_location();
#line 5199
            *__cil_tmp157 = tmp___10;
            }
#line 5205
            return ((char *)((void *)0));
          }
#line 5214
          if ((unsigned long )((unsigned int )count + 1U) >= maxlen) {
#line 5219
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5220
              goto overflow;
            } else {
              {
#line 5232
              __cil_tmp161 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
              }
#line 5232
              if (allocated <= 9223372036854775807UL) {
#line 5232
                tmp___11 = allocated * 2UL;
              } else {
#line 5232
                tmp___11 = 0xffffffffffffffffUL;
              }
              {
#line 5232
              __cil_tmp163 = xmax(__cil_tmp161, tmp___11);
#line 5232
              n___2 = __cil_tmp163;
              }
#line 5239
              if (n___2 > allocated) {
#line 5239
                if (allocated > 0UL) {
#line 5239
                  if (allocated <= 9223372036854775807UL) {
#line 5239
                    tmp___12 = allocated * 2UL;
                  } else {
#line 5239
                    tmp___12 = 0xffffffffffffffffUL;
                  }
#line 5239
                  tmp___13 = tmp___12;
                } else {
#line 5239
                  tmp___13 = (unsigned long )12;
                }
#line 5239
                allocated = tmp___13;
#line 5239
                if (n___2 > allocated) {
#line 5239
                  allocated = n___2;
                }
#line 5239
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5239
                  tmp___14 = allocated * sizeof(char );
                } else {
#line 5239
                  tmp___14 = 0xffffffffffffffffUL;
                }
#line 5239
                memory_size___2 = tmp___14;
#line 5239
                if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5239
                  goto out_of_memory;
                }
#line 5239
                if (result == resultbuf) {
                  {
                  {
#line 5239
                  __cil_tmp169 = malloc(memory_size___2);
                  }
#line 5239
                  memory___2 = (char *)__cil_tmp169;
                  }
                } else
#line 5239
                if (result == (char *)((void *)0)) {
                  {
                  {
#line 5239
                  __cil_tmp169 = malloc(memory_size___2);
                  }
#line 5239
                  memory___2 = (char *)__cil_tmp169;
                  }
                } else {
                  {
#line 5239
                  __cil_tmp170 = realloc((void *)result, memory_size___2);
#line 5239
                  memory___2 = (char *)__cil_tmp170;
                  }
                }
#line 5239
                if (memory___2 == (char *)((void *)0)) {
#line 5239
                  goto out_of_memory;
                }
#line 5239
                if (result == resultbuf) {
#line 5239
                  if (length > 0UL) {
                    {
#line 5239
                    memcpy((void *)memory___2, (void const   *)result, length);
                    }
                  }
                }
#line 5239
                result = memory___2;
              }

#line 5240
              goto while_continue___3;
            }
          }
#line 5536
          length += (unsigned long )count;
#line 5537
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 5539
        __cil_tmp171 = __errno_location();
#line 5539
        *__cil_tmp171 = orig_errno;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1870
  __cil_tmp173 = dp;
#line 1870
  dp ++;
#line 1870
  __cil_tmp172 = i;
#line 1870
  i ++;
  {
#line 1870
  cp = dp->dir_end;
#line 5547
  __cil_tmp174 = xsum(length, (size_t )1);
  }
#line 5547
  if (__cil_tmp174 > allocated) {
#line 5547
    if (allocated > 0UL) {
#line 5547
      if (allocated <= 9223372036854775807UL) {
#line 5547
        tmp___15 = allocated * 2UL;
      } else {
#line 5547
        tmp___15 = 0xffffffffffffffffUL;
      }
#line 5547
      tmp___16 = tmp___15;
    } else {
#line 5547
      tmp___16 = (unsigned long )12;
    }
    {
#line 5547
    allocated = tmp___16;
#line 5547
    __cil_tmp179 = xsum(length, (size_t )1);
    }
#line 5547
    if (__cil_tmp179 > allocated) {
      {
#line 5547
      allocated = xsum(length, (size_t )1);
      }
    }
#line 5547
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5547
      tmp___17 = allocated * sizeof(char );
    } else {
#line 5547
      tmp___17 = 0xffffffffffffffffUL;
    }
#line 5547
    memory_size___3 = tmp___17;
#line 5547
    if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5547
      goto out_of_memory;
    }
#line 5547
    if (result == resultbuf) {
      {
      {
#line 5547
      __cil_tmp182 = malloc(memory_size___3);
      }
#line 5547
      memory___3 = (char *)__cil_tmp182;
      }
    } else
#line 5547
    if (result == (char *)((void *)0)) {
      {
      {
#line 5547
      __cil_tmp182 = malloc(memory_size___3);
      }
#line 5547
      memory___3 = (char *)__cil_tmp182;
      }
    } else {
      {
#line 5547
      __cil_tmp183 = realloc((void *)result, memory_size___3);
#line 5547
      memory___3 = (char *)__cil_tmp183;
      }
    }
#line 5547
    if (memory___3 == (char *)((void *)0)) {
#line 5547
      goto out_of_memory;
    }
#line 5547
    if (result == resultbuf) {
#line 5547
      if (length > 0UL) {
        {
#line 5547
        memcpy((void *)memory___3, (void const   *)result, length);
        }
      }
    }
#line 5547
    result = memory___3;
  }
#line 5548
  *(result + length) = (char )'\000';
#line 5550
  if (result != resultbuf) {
#line 5550
    if (length + 1UL < allocated) {
      {
#line 5555
      __cil_tmp185 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5555
      memory___4 = (char *)__cil_tmp185;
      }
#line 5556
      if (memory___4 != (char *)((void *)0)) {
#line 5557
        result = memory___4;
      }
    }
  }
#line 5560
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5561
    free((void *)buf_malloced);
    }
  }
#line 5562
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5562
    free((void *)d.dir);
    }
  }
#line 5562
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5562
    free((void *)a.arg);
    }
  }
#line 5563
  *lengthp = length;
#line 5568
  return (result);
  overflow: 
#line 5572
  if (! (result == resultbuf || result == (char *)((void *)0))) {
    {
#line 5573
    free((void *)result);
    }
  }
#line 5574
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5575
    free((void *)buf_malloced);
    }
  }
#line 5576
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5576
    free((void *)d.dir);
    }
  }
#line 5576
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5576
    free((void *)a.arg);
    }
  }
  {
#line 5577
  __cil_tmp186 = __errno_location();
#line 5577
  *__cil_tmp186 = 75;
  }
#line 5578
  return ((char *)((void *)0));
  out_of_memory: 
#line 5582
  if (! (result == resultbuf || result == (char *)((void *)0))) {
    {
#line 5583
    free((void *)result);
    }
  }
#line 5584
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5585
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5587
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5587
    free((void *)d.dir);
    }
  }
#line 5587
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5587
    free((void *)a.arg);
    }
  }
  {
#line 5588
  __cil_tmp187 = __errno_location();
#line 5588
  *__cil_tmp187 = 12;
  }
#line 5589
  return ((char *)((void *)0));
}
}
#line 21 "./utimens.h"
int fdutimens(int fd , char const   *file , struct timespec timespec[2] ) ;
#line 22
int utimens(char const   *file , struct timespec timespec[2] ) ;
#line 23
int lutimens(char const   *file , struct timespec timespec[2] ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 360
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 449
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 449 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 451
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 451
  return (__cil_tmp3);
}
}
#line 456
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 456 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 458
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 458
  return (__cil_tmp3);
}
}
#line 463
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 463 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 465
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (__cil_tmp3);
}
}
#line 470
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 470 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 473
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 473
  return (__cil_tmp5);
}
}
#line 479
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 479 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 481
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (__cil_tmp4);
}
}
#line 487
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 487 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 490
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (__cil_tmp5);
}
}
#line 498
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 498 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 500
  __cil_tmp3 = __xstat64(1, __path, __statbuf);
  }
#line 500
  return (__cil_tmp3);
}
}
#line 505
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 505 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 507
  __cil_tmp3 = __lxstat64(1, __path, __statbuf);
  }
#line 507
  return (__cil_tmp3);
}
}
#line 512
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 512 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 514
  __cil_tmp3 = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (__cil_tmp3);
}
}
#line 519
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 519 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat64(int __fd , char const   *__filename , struct stat64 *__statbuf ,
                              int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 522
  __cil_tmp5 = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
#line 522
  return (__cil_tmp5);
}
}
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 151
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval __tvp[2] ) ;
#line 55 "./stat-time.h"
__inline long get_stat_atime_ns(struct stat *st ) 
{ 


  {
#line 58
  return (st->st_atim.tv_nsec);
}
}
#line 68 "./stat-time.h"
__inline long get_stat_ctime_ns(struct stat *st ) 
{ 


  {
#line 71
  return (st->st_ctim.tv_nsec);
}
}
#line 81 "./stat-time.h"
__inline long get_stat_mtime_ns(struct stat *st ) 
{ 


  {
#line 84
  return (st->st_mtim.tv_nsec);
}
}
#line 94 "./stat-time.h"
__inline long get_stat_birthtime_ns(struct stat *st ) 
{ 


  {
#line 103
  return ((long )0);
}
}
#line 109 "./stat-time.h"
__inline struct timespec get_stat_atime(struct stat *st ) 
{ 


  {
#line 112
  return (st->st_atim);
}
}
#line 123 "./stat-time.h"
__inline struct timespec get_stat_ctime(struct stat *st ) 
{ 


  {
#line 126
  return (st->st_ctim);
}
}
#line 137 "./stat-time.h"
__inline struct timespec get_stat_mtime(struct stat *st ) 
{ 


  {
#line 140
  return (st->st_mtim);
}
}
#line 152 "./stat-time.h"
__inline struct timespec get_stat_birthtime(struct stat *st ) 
{ 
  struct timespec t ;

  {
#line 170
  t.tv_sec = (__time_t )(- 1);
#line 171
  t.tv_nsec = (__syscall_slong_t )(- 1);
#line 191
  return (t);
}
}
#line 58 "./timespec.h"
__inline int timespec_cmp(struct timespec a , struct timespec b ) 
{ 
  int tmp ;
  int tmp___13 ;

  {
#line 60
  if (a.tv_sec < b.tv_sec) {
#line 60
    tmp___13 = - 1;
  } else {
#line 60
    if (a.tv_sec > b.tv_sec) {
#line 60
      tmp = 1;
    } else {
#line 60
      tmp = (int )(a.tv_nsec - b.tv_nsec);
    }
#line 60
    tmp___13 = tmp;
  }
#line 60
  return (tmp___13);
}
}
#line 68 "./timespec.h"
__inline int timespec_sign(struct timespec a ) 
{ 
  int tmp ;

  {
#line 70
  if (a.tv_sec < 0L) {
#line 70
    tmp = - 1;
  } else {
#line 70
    tmp = a.tv_sec || a.tv_nsec;
  }
#line 70
  return (tmp);
}
}
#line 82 "./timespec.h"
__inline double timespectod(struct timespec a ) 
{ 


  {
#line 84
  return ((double )a.tv_sec + (double )a.tv_nsec / 1000000000.);
}
}
#line 87
void gettime(struct timespec *ts ) ;
#line 74 "/tmp/0/patch-2.7.1/lib/utimens.c"
static int utimensat_works_really ;
#line 75
static int lutimensat_works_really ;
#line 86 "/tmp/0/patch-2.7.1/lib/utimens.c"
static int validate_timespec(struct timespec timespec[2] ) 
{ 
  int result ;
  int utime_omit_count ;
  int *__cil_tmp5 ;

  {
#line 88
  result = 0;
#line 89
  utime_omit_count = 0;
#line 91
  if (timespec[0].tv_nsec != (1L << 30) - 1L) {
#line 91
    if (timespec[0].tv_nsec != (1L << 30) - 2L) {
#line 91
      if (timespec[0].tv_nsec < 0L) {
        {
        {
        {
        {
#line 98
        __cil_tmp5 = __errno_location();
        }
        }
        }
#line 98
        *__cil_tmp5 = 22;
        }
#line 99
        return (- 1);
      } else
#line 91
      if (1000000000L <= timespec[0].tv_nsec) {
        {
        {
        {
        {
#line 98
        __cil_tmp5 = __errno_location();
        }
        }
        }
#line 98
        *__cil_tmp5 = 22;
        }
#line 99
        return (- 1);
      } else {
#line 91
        goto _L;
      }
    } else {
#line 91
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 91
  if (timespec[1].tv_nsec != (1L << 30) - 1L) {
#line 91
    if (timespec[1].tv_nsec != (1L << 30) - 2L) {
#line 91
      if (timespec[1].tv_nsec < 0L) {
        {
        {
        {
        {
#line 98
        __cil_tmp5 = __errno_location();
        }
        }
        }
#line 98
        *__cil_tmp5 = 22;
        }
#line 99
        return (- 1);
      } else
#line 91
      if (1000000000L <= timespec[1].tv_nsec) {
        {
        {
        {
        {
#line 98
        __cil_tmp5 = __errno_location();
        }
        }
        }
#line 98
        *__cil_tmp5 = 22;
        }
#line 99
        return (- 1);
      }
    }
  }
#line 105
  if (timespec[0].tv_nsec == (1L << 30) - 1L) {
    _L___15: /* CIL Label */ 
#line 108
    timespec[0].tv_sec = (__time_t )0;
#line 109
    result = 1;
#line 110
    if (timespec[0].tv_nsec == (1L << 30) - 2L) {
#line 111
      utime_omit_count ++;
    }
  } else
#line 105
  if (timespec[0].tv_nsec == (1L << 30) - 2L) {
#line 105
    goto _L___15;
  }
#line 113
  if (timespec[1].tv_nsec == (1L << 30) - 1L) {
    _L___16: /* CIL Label */ 
#line 116
    timespec[1].tv_sec = (__time_t )0;
#line 117
    result = 1;
#line 118
    if (timespec[1].tv_nsec == (1L << 30) - 2L) {
#line 119
      utime_omit_count ++;
    }
  } else
#line 113
  if (timespec[1].tv_nsec == (1L << 30) - 2L) {
#line 113
    goto _L___16;
  }
#line 121
  return (result + (utime_omit_count == 1));
}
}
#line 131 "/tmp/0/patch-2.7.1/lib/utimens.c"
static int update_timespec(struct stat *statbuf , struct timespec *ts[2] ) 
{ 
  struct timespec *timespec ;

  {
#line 133
  timespec = ts[0];
#line 134
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 134
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 136
      return (1);
    }
  }
#line 137
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 137
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 140
      ts[0] = (struct timespec *)((void *)0);
#line 141
      return (0);
    }
  }
#line 144
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
#line 145
    *(timespec + 0) = get_stat_atime(statbuf);
    }
  } else
#line 146
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
#line 147
    gettime(& *(timespec + 0));
    }
  }
#line 149
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
#line 150
    *(timespec + 1) = get_stat_mtime(statbuf);
    }
  } else
#line 151
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
#line 152
    gettime(& *(timespec + 1));
    }
  }
#line 154
  return (0);
}
}
#line 168 "/tmp/0/patch-2.7.1/lib/utimens.c"
int fdutimens(int fd , char const   *file , struct timespec timespec[2] ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *__cil_tmp10 ;
  int result ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___17 ;
  int *__cil_tmp19 ;
  int *__cil_tmp20 ;
  int *__cil_tmp22 ;
  int *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___18 ;
  int __cil_tmp27 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int abig ;
  int mbig ;
  int __cil_tmp34 ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 171
  if (timespec) {
#line 171
    tmp = (struct timespec *)adjusted_timespec;
  } else {
#line 171
    tmp = (struct timespec *)((void *)0);
  }
#line 171
  ts = tmp;
#line 172
  adjustment_needed = 0;
#line 175
  if (ts) {
    {
#line 177
    adjusted_timespec[0] = timespec[0];
#line 178
    adjusted_timespec[1] = timespec[1];
#line 179
    adjustment_needed = validate_timespec(ts);
    }
  }
#line 181
  if (adjustment_needed < 0) {
#line 182
    return (- 1);
  }
#line 187
  if (fd < 0) {
#line 187
    if (! file) {
      {
#line 189
      __cil_tmp10 = __errno_location();
#line 189
      *__cil_tmp10 = 9;
      }
#line 190
      return (- 1);
    }
  }
#line 216
  if (0 <= utimensat_works_really) {
#line 228
    if (adjustment_needed == 2) {
#line 230
      if (fd < 0) {
        {
#line 230
        __cil_tmp12 = stat(file, & st);
#line 230
        tmp___17 = __cil_tmp12;
        }
      } else {
        {
#line 230
        __cil_tmp13 = fstat(fd, & st);
#line 230
        tmp___17 = __cil_tmp13;
        }
      }
#line 230
      if (tmp___17) {
#line 231
        return (- 1);
      }
#line 232
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 233
        *(ts + 0) = get_stat_atime(& st);
        }
      } else
#line 234
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 235
        *(ts + 1) = get_stat_mtime(& st);
        }
      }
#line 237
      adjustment_needed ++;
    }
#line 241
    if (fd < 0) {
      {
#line 243
      result = utimensat(- 100, file, (struct timespec [2])ts, 0);
      }
#line 252
      if (0 < result) {
        {
#line 253
        __cil_tmp19 = __errno_location();
#line 253
        *__cil_tmp19 = 38;
        }
      }
      {
#line 255
      __cil_tmp20 = __errno_location();
      }
#line 255
      if (result == 0) {
#line 257
        utimensat_works_really = 1;
#line 258
        return (result);
      } else
#line 255
      if (*__cil_tmp20 != 38) {
#line 257
        utimensat_works_really = 1;
#line 258
        return (result);
      }
    }
#line 263
    if (0 <= fd) {
      {
#line 265
      result = futimens(fd, (struct timespec [2])ts);
      }
#line 268
      if (0 < result) {
        {
#line 269
        __cil_tmp22 = __errno_location();
#line 269
        *__cil_tmp22 = 38;
        }
      }
      {
#line 271
      __cil_tmp23 = __errno_location();
      }
#line 271
      if (result == 0) {
#line 273
        utimensat_works_really = 1;
#line 274
        return (result);
      } else
#line 271
      if (*__cil_tmp23 != 38) {
#line 273
        utimensat_works_really = 1;
#line 274
        return (result);
      }
    }
  }
#line 279
  utimensat_works_really = - 1;
#line 280
  lutimensat_works_really = - 1;
#line 287
  if (adjustment_needed) {
#line 289
    if (fd < 0) {
      {
#line 289
      __cil_tmp24 = stat(file, & st);
#line 289
      tmp___18 = __cil_tmp24;
      }
    } else {
      {
#line 289
      __cil_tmp25 = fstat(fd, & st);
#line 289
      tmp___18 = __cil_tmp25;
      }
    }
#line 289
    if (adjustment_needed != 3) {
#line 289
      if (tmp___18) {
#line 291
        return (- 1);
      }
    }
    {
#line 292
    __cil_tmp27 = update_timespec(& st, & ts);
    }
#line 292
    if (ts) {
#line 292
      if (__cil_tmp27) {
#line 293
        return (0);
      }
    }
  }
#line 300
  if (ts) {
#line 302
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 303
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 304
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 305
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 306
    t = (struct timeval *)timeval;
  } else {
#line 309
    t = (struct timeval *)((void *)0);
  }
#line 311
  if (fd < 0) {
    {
#line 314
    __cil_tmp30 = futimesat(- 100, file, (struct timeval [2])t);
    }
#line 314
    return (__cil_tmp30);
  } else {
    {
#line 335
    __cil_tmp31 = futimesat(fd, (char const   *)((void *)0), (struct timeval [2])t);
    }
#line 335
    if (__cil_tmp31 == 0) {
#line 343
      if (t) {
        {
#line 345
        abig = 500000L <= (t + 0)->tv_usec;
#line 346
        mbig = 500000L <= (t + 1)->tv_usec;
#line 347
        __cil_tmp34 = fstat(fd, & st);
        }
#line 347
        if (abig | mbig) {
#line 347
          if (__cil_tmp34 == 0) {
            {
#line 351
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
#line 352
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
#line 354
            tt = (struct timeval *)((void *)0);
#line 356
            truncated_timeval[0] = *(t + 0);
#line 357
            truncated_timeval[1] = *(t + 1);
#line 358
            __cil_tmp39 = get_stat_atime_ns(& st);
            }
#line 358
            if (abig) {
#line 358
              if (adiff == 1L) {
#line 358
                if (__cil_tmp39 == 0L) {
#line 360
                  tt = (struct timeval *)truncated_timeval;
#line 361
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
            {
#line 363
            __cil_tmp40 = get_stat_mtime_ns(& st);
            }
#line 363
            if (mbig) {
#line 363
              if (mdiff == 1L) {
#line 363
                if (__cil_tmp40 == 0L) {
#line 365
                  tt = (struct timeval *)truncated_timeval;
#line 366
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 368
            if (tt) {
              {
#line 369
              futimesat(fd, (char const   *)((void *)0), (struct timeval [2])tt);
              }
            }
          }
        }
      }
#line 374
      return (0);
    }
  }
#line 380
  if (! file) {
#line 386
    return (- 1);
  }
  {
#line 390
  __cil_tmp41 = utimes(file, (struct timeval [2])t);
  }
#line 390
  return (__cil_tmp41);
}
}
#line 413 "/tmp/0/patch-2.7.1/lib/utimens.c"
int utimens(char const   *file , struct timespec timespec[2] ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 415
  __cil_tmp3 = fdutimens(- 1, file, timespec);
  }
#line 415
  return (__cil_tmp3);
}
}
#line 423 "/tmp/0/patch-2.7.1/lib/utimens.c"
int lutimens(char const   *file , struct timespec timespec[2] ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int __cil_tmp10 ;
  int *__cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int *__cil_tmp21 ;

  {
#line 426
  if (timespec) {
#line 426
    tmp = (struct timespec *)adjusted_timespec;
  } else {
#line 426
    tmp = (struct timespec *)((void *)0);
  }
#line 426
  ts = tmp;
#line 427
  adjustment_needed = 0;
#line 430
  if (ts) {
    {
#line 432
    adjusted_timespec[0] = timespec[0];
#line 433
    adjusted_timespec[1] = timespec[1];
#line 434
    adjustment_needed = validate_timespec(ts);
    }
  }
#line 436
  if (adjustment_needed < 0) {
#line 437
    return (- 1);
  }
#line 445
  if (0 <= lutimensat_works_really) {
#line 457
    if (adjustment_needed == 2) {
      {
#line 459
      __cil_tmp10 = lstat(file, & st);
      }
#line 459
      if (__cil_tmp10) {
#line 460
        return (- 1);
      }
#line 461
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 462
        *(ts + 0) = get_stat_atime(& st);
        }
      } else
#line 463
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 464
        *(ts + 1) = get_stat_mtime(& st);
        }
      }
#line 466
      adjustment_needed ++;
    }
    {
#line 469
    result = utimensat(- 100, file, (struct timespec [2])ts, 256);
    }
#line 478
    if (0 < result) {
      {
#line 479
      __cil_tmp15 = __errno_location();
#line 479
      *__cil_tmp15 = 38;
      }
    }
    {
#line 481
    __cil_tmp16 = __errno_location();
    }
#line 481
    if (result == 0) {
#line 483
      utimensat_works_really = 1;
#line 484
      lutimensat_works_really = 1;
#line 485
      return (result);
    } else
#line 481
    if (*__cil_tmp16 != 38) {
#line 483
      utimensat_works_really = 1;
#line 484
      lutimensat_works_really = 1;
#line 485
      return (result);
    }
  }
#line 488
  lutimensat_works_really = - 1;
#line 495
  if (adjustment_needed) {
    {
#line 497
    __cil_tmp17 = lstat(file, & st);
    }
#line 497
    if (adjustment_needed != 3) {
#line 497
      if (__cil_tmp17) {
#line 498
        return (- 1);
      }
    }
    {
#line 499
    __cil_tmp18 = update_timespec(& st, & ts);
    }
#line 499
    if (ts) {
#line 499
      if (__cil_tmp18) {
#line 500
        return (0);
      }
    }
  }
  {
#line 528
  __cil_tmp19 = lstat(file, & st);
  }
#line 528
  if (! adjustment_needed) {
#line 528
    if (__cil_tmp19) {
#line 529
      return (- 1);
    }
  }
#line 530
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
#line 531
    __cil_tmp20 = fdutimens(- 1, file, (struct timespec [2])ts);
    }
#line 531
    return (__cil_tmp20);
  }
  {
#line 532
  __cil_tmp21 = __errno_location();
#line 532
  *__cil_tmp21 = 38;
  }
#line 533
  return (- 1);
}
}
#line 48 "./tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 157 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 179 "/tmp/0/patch-2.7.1/lib/tempname.c"
static char const   letters[]  =    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
#line 196 "/tmp/0/patch-2.7.1/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int len ;
  char *XXXXXX ;
  static uint64_t value ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *__cil_tmp12 ;
  struct stat st ;
  unsigned int attempts ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  struct timeval tv ;
  __pid_t __cil_tmp19 ;
  uint64_t v ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  int *__cil_tmp25 ;
  int *__cil_tmp27 ;
  int *__cil_tmp28 ;
  int *__cil_tmp29 ;

  {
  {
#line 203
  fd = - 1;
#line 204
  __cil_tmp12 = __errno_location();
#line 204
  save_errno = *__cil_tmp12;
#line 220
  attempts = (unsigned int )238328;
#line 223
  __cil_tmp15 = strlen((char const   *)tmpl);
#line 223
  len = (int )__cil_tmp15;
#line 224
  __cil_tmp16 = memcmp((void const   *)(& *(tmpl + ((len - 6) - suffixlen))), (void const   *)((char *)"XXXXXX"),
                       (unsigned long )6);
  }
#line 224
  if (len < 6 + suffixlen) {
    {
    {
#line 226
    __cil_tmp17 = __errno_location();
    }
#line 226
    *__cil_tmp17 = 22;
    }
#line 227
    return (- 1);
  } else
#line 224
  if (__cil_tmp16) {
    {
    {
#line 226
    __cil_tmp17 = __errno_location();
    }
#line 226
    *__cil_tmp17 = 22;
    }
#line 227
    return (- 1);
  }
  {
#line 231
  XXXXXX = & *(tmpl + ((len - 6) - suffixlen));
#line 239
  gettimeofday(& tv, (struct timezone *)((void *)0));
#line 240
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 243
  __cil_tmp19 = getpid();
  }
#line 243
  value += random_time_bits ^ (unsigned long )__cil_tmp19;
#line 245
  count = (unsigned int )0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (count < attempts)) {
#line 245
      goto while_break;
    }
#line 247
    v = value;
#line 250
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 251
    v /= (unsigned long )62;
#line 252
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 253
    v /= (unsigned long )62;
#line 254
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 255
    v /= (unsigned long )62;
#line 256
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 257
    v /= (unsigned long )62;
#line 258
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 259
    v /= (unsigned long )62;
#line 260
    *(XXXXXX + 5) = (char )letters[v % 62UL];
    {
#line 264
    if (kind == 0) {
#line 264
      goto case_0;
    }
#line 270
    if (kind == 1) {
#line 270
      goto case_1;
    }
#line 274
    if (kind == 2) {
#line 274
      goto case_2;
    }
#line 262
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 265
    fd = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    }
#line 268
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 271
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    }
#line 272
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 279
    __cil_tmp23 = lstat((char const   *)tmpl, & st);
    }
#line 279
    if (__cil_tmp23 < 0) {
      {
#line 281
      __cil_tmp24 = __errno_location();
      }
#line 281
      if (*__cil_tmp24 == 2) {
        {
#line 283
        __cil_tmp25 = __errno_location();
#line 283
        *__cil_tmp25 = save_errno;
        }
#line 284
        return (0);
      } else {
#line 288
        return (- 1);
      }
    }
#line 290
    goto while_continue;
    {
#line 294
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 297
    if (fd >= 0) {
      {
#line 299
      __cil_tmp27 = __errno_location();
#line 299
      *__cil_tmp27 = save_errno;
      }
#line 300
      return (fd);
    } else {
      {
#line 302
      __cil_tmp28 = __errno_location();
      }
#line 302
      if (*__cil_tmp28 != 17) {
#line 303
        return (- 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  count ++;
  {
#line 245
  value += (unsigned long )7777;
#line 307
  __cil_tmp29 = __errno_location();
#line 307
  *__cil_tmp29 = 17;
  }
#line 308
  return (- 1);
}
}
#line 40 "./dirname.h"
size_t base_len(char const   *name ) ;
#line 42
char *last_component(char const   *name ) ;
#line 44
int strip_trailing_slashes(char *file ) ;
#line 31 "/tmp/0/patch-2.7.1/lib/stripslash.c"
int strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *__cil_tmp3 ;
  char *base_lim ;
  int had_slash ;
  size_t __cil_tmp6 ;

  {
  {
#line 33
  __cil_tmp3 = last_component((char const   *)file);
#line 33
  base = __cil_tmp3;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  __cil_tmp6 = base_len((char const   *)base);
#line 41
  base_lim = base + __cil_tmp6;
#line 42
  had_slash = (int )*base_lim != 0;
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "./safe-write.h"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) ;
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 56 "./safe-read.c"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! 1) {
#line 64
      goto while_break;
    }
    {
#line 66
    __cil_tmp5 = write(fd, buf___0, count);
#line 66
    result = __cil_tmp5;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      __cil_tmp6 = __errno_location();
      }
#line 70
      if (*__cil_tmp6 == 4) {
#line 71
        goto while_continue;
      } else {
        {
#line 72
        __cil_tmp7 = __errno_location();
        }
#line 72
        if (*__cil_tmp7 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 236 "./quotearg.h"
char const   * const  quoting_style_args[] ;
#line 237
enum quoting_style quoting_style_vals[] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options *o ) ;
#line 302
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg ) ;
#line 324
char *quotearg(char const   *arg ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg ) ;
#line 363
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 23 "./quote.h"
struct quoting_options quote_quoting_options ;
#line 27
char const   *quote_n(int n , char const   *name ) ;
#line 31
char const   *quote(char const   *name ) ;
#line 106 "./xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) ;
#line 221
__inline static char *xcharalloc(size_t n ) ;
#line 224 "./xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *tmp ;

  {
#line 226
  if (sizeof(char ) == 1UL) {
    {
#line 226
    __cil_tmp2 = xmalloc(n);
#line 226
    tmp = __cil_tmp2;
    }
  } else {
    {
#line 226
    __cil_tmp3 = xnmalloc(n, sizeof(char ));
#line 226
    tmp = __cil_tmp3;
    }
  }
#line 226
  return ((char *)tmp);
}
}
#line 42 "./c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 45 "./c-strcaseeq.h"
__inline static int strcaseeq9(char const   *s1 , char const   *s2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 47
  __cil_tmp3 = c_strcasecmp(s1 + 9, s2 + 9);
  }
#line 47
  return (__cil_tmp3 == 0);
}
}
#line 51 "./c-strcaseeq.h"
__inline static int strcaseeq8(char const   *s1 , char const   *s2 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp5 ;

  {
#line 53
  tmp = (int )((char )*(s1 + 8)) == (int )s28;
#line 53
  if (tmp) {
#line 55
    if ((int )s28 == 0) {
#line 56
      return (1);
    } else {
      {
#line 58
      __cil_tmp5 = strcaseeq9(s1, s2);
      }
#line 58
      return (__cil_tmp5);
    }
  } else {
#line 61
    return (0);
  }
}
}
#line 65 "./c-strcaseeq.h"
__inline static int strcaseeq7(char const   *s1 , char const   *s2 , char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp6 ;

  {
#line 67
  tmp = (int )((char )*(s1 + 7)) == (int )s27;
#line 67
  if (tmp) {
#line 69
    if ((int )s27 == 0) {
#line 70
      return (1);
    } else {
      {
#line 72
      __cil_tmp6 = strcaseeq8(s1, s2, s28);
      }
#line 72
      return (__cil_tmp6);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 79 "./c-strcaseeq.h"
__inline static int strcaseeq6(char const   *s1 , char const   *s2 , char s26 , char s27 ,
                               char s28 ) 
{ 
  int tmp ;
  int __cil_tmp7 ;

  {
#line 81
  tmp = (int )((char )*(s1 + 6)) == (int )s26;
#line 81
  if (tmp) {
#line 83
    if ((int )s26 == 0) {
#line 84
      return (1);
    } else {
      {
#line 86
      __cil_tmp7 = strcaseeq7(s1, s2, s27, s28);
      }
#line 86
      return (__cil_tmp7);
    }
  } else {
#line 89
    return (0);
  }
}
}
#line 93 "./c-strcaseeq.h"
__inline static int strcaseeq5(char const   *s1 , char const   *s2 , char s25 , char s26 ,
                               char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp8 ;

  {
#line 95
  tmp = (int )((char )*(s1 + 5)) == (int )s25;
#line 95
  if (tmp) {
#line 97
    if ((int )s25 == 0) {
#line 98
      return (1);
    } else {
      {
#line 100
      __cil_tmp8 = strcaseeq6(s1, s2, s26, s27, s28);
      }
#line 100
      return (__cil_tmp8);
    }
  } else {
#line 103
    return (0);
  }
}
}
#line 107 "./c-strcaseeq.h"
__inline static int strcaseeq4(char const   *s1 , char const   *s2 , char s24 , char s25 ,
                               char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp9 ;

  {
#line 109
  tmp = (int )((char )*(s1 + 4)) == (int )s24;
#line 109
  if (tmp) {
#line 111
    if ((int )s24 == 0) {
#line 112
      return (1);
    } else {
      {
#line 114
      __cil_tmp9 = strcaseeq5(s1, s2, s25, s26, s27, s28);
      }
#line 114
      return (__cil_tmp9);
    }
  } else {
#line 117
    return (0);
  }
}
}
#line 121 "./c-strcaseeq.h"
__inline static int strcaseeq3(char const   *s1 , char const   *s2 , char s23 , char s24 ,
                               char s25 , char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp10 ;

  {
#line 123
  tmp = (int )((char )*(s1 + 3)) == (int )s23;
#line 123
  if (tmp) {
#line 125
    if ((int )s23 == 0) {
#line 126
      return (1);
    } else {
      {
#line 128
      __cil_tmp10 = strcaseeq4(s1, s2, s24, s25, s26, s27, s28);
      }
#line 128
      return (__cil_tmp10);
    }
  } else {
#line 131
    return (0);
  }
}
}
#line 135 "./c-strcaseeq.h"
__inline static int strcaseeq2(char const   *s1 , char const   *s2 , char s22 , char s23 ,
                               char s24 , char s25 , char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp11 ;

  {
#line 137
  tmp = (int )((char )*(s1 + 2)) == (int )s22;
#line 137
  if (tmp) {
#line 139
    if ((int )s22 == 0) {
#line 140
      return (1);
    } else {
      {
#line 142
      __cil_tmp11 = strcaseeq3(s1, s2, s23, s24, s25, s26, s27, s28);
      }
#line 142
      return (__cil_tmp11);
    }
  } else {
#line 145
    return (0);
  }
}
}
#line 149 "./c-strcaseeq.h"
__inline static int strcaseeq1(char const   *s1 , char const   *s2 , char s21 , char s22 ,
                               char s23 , char s24 , char s25 , char s26 , char s27 ,
                               char s28 ) 
{ 
  int tmp ;
  int __cil_tmp12 ;

  {
#line 151
  tmp = (int )((char )*(s1 + 1)) == (int )s21;
#line 151
  if (tmp) {
#line 153
    if ((int )s21 == 0) {
#line 154
      return (1);
    } else {
      {
#line 156
      __cil_tmp12 = strcaseeq2(s1, s2, s22, s23, s24, s25, s26, s27, s28);
      }
#line 156
      return (__cil_tmp12);
    }
  } else {
#line 159
    return (0);
  }
}
}
#line 163 "./c-strcaseeq.h"
__inline static int strcaseeq0(char const   *s1 , char const   *s2 , char s20 , char s21 ,
                               char s22 , char s23 , char s24 , char s25 , char s26 ,
                               char s27 , char s28 ) 
{ 
  int tmp ;
  int __cil_tmp13 ;

  {
#line 165
  tmp = (int )((char )*(s1 + 0)) == (int )s20;
#line 165
  if (tmp) {
#line 167
    if ((int )s20 == 0) {
#line 168
      return (1);
    } else {
      {
#line 170
      __cil_tmp13 = strcaseeq1(s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);
      }
#line 170
      return (__cil_tmp13);
    }
  } else {
#line 173
    return (0);
  }
}
}
#line 32 "./localcharset.h"
char const   *locale_charset(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 75 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char const   * const  quoting_style_args[]  = 
#line 75 "/tmp/0/patch-2.7.1/lib/quotearg.c"
  {      (char const   *)((char *)"literal"),      (char const   *)((char *)"shell"),      (char const   *)((char *)"shell-always"),      (char const   *)((char *)"c"), 
        (char const   *)((char *)"c-maybe"),      (char const   *)((char *)"escape"),      (char const   *)((char *)"locale"),      (char const   *)((char *)"clocale"), 
        (char const   */* const  */)0};
#line 89 "/tmp/0/patch-2.7.1/lib/quotearg.c"
enum quoting_style quoting_style_vals[]  = 
#line 89
  {      (enum quoting_style )0,      (enum quoting_style )1,      (enum quoting_style )2,      (enum quoting_style )3, 
        (enum quoting_style )4,      (enum quoting_style )5,      (enum quoting_style )6,      (enum quoting_style )7};
#line 102
static struct quoting_options default_quoting_options ;
#line 108 "/tmp/0/patch-2.7.1/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *__cil_tmp3 ;
  struct quoting_options *p ;
  struct quoting_options *tmp ;
  void *__cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 110
  __cil_tmp3 = __errno_location();
#line 110
  e = *__cil_tmp3;
  }
#line 111
  if (o) {
#line 111
    tmp = o;
  } else {
#line 111
    tmp = & default_quoting_options;
  }
  {
#line 111
  __cil_tmp6 = xmemdup((void const   *)tmp, sizeof(*o));
#line 111
  p = (struct quoting_options *)__cil_tmp6;
#line 113
  __cil_tmp7 = __errno_location();
#line 113
  *__cil_tmp7 = e;
  }
#line 114
  return (p);
}
}
#line 119 "/tmp/0/patch-2.7.1/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 121
  return (tmp->style);
}
}
#line 127 "/tmp/0/patch-2.7.1/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 129
  tmp->style = s;
}
}
#line 138 "/tmp/0/patch-2.7.1/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  p = (unsigned int *)tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 154 "/tmp/0/patch-2.7.1/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 157
  if (! o) {
#line 158
    o = & default_quoting_options;
  }
#line 159
  r = o->flags;
#line 160
  o->flags = i;
#line 161
  return (r);
}
}
#line 165 "/tmp/0/patch-2.7.1/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 168
  if (! o) {
#line 169
    o = & default_quoting_options;
  }
#line 170
  o->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
    {
#line 172
    abort();
    }
    }
  } else
#line 171
  if (! right_quote) {
    {
    {
#line 172
    abort();
    }
    }
  }
#line 173
  o->left_quote = left_quote;
#line 174
  o->right_quote = right_quote;
}
}
#line 179 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = (unsigned int )0;
#line 181
  tmp = (unsigned int )1;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 193 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char const   *locale_code ;
  int __cil_tmp6 ;
  char *tmp ;
  int __cil_tmp8 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
#line 195
  translation = msgid;
#line 198
  if (translation != msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  __cil_tmp6 = strcaseeq0(locale_code, (char const   *)((char *)"UTF-8"), (char )'U',
                          (char )'T', (char )'F', (char )'-', (char )'8', (char )0,
                          (char )0, (char )0, (char )0);
  }
#line 220
  if (__cil_tmp6) {
#line 221
    if ((int )((char )*(msgid + 0)) == 96) {
#line 221
      tmp = (char *)"\342\200\230";
    } else {
#line 221
      tmp = (char *)"\342\200\231";
    }
#line 221
    return ((char const   *)tmp);
  }
  {
#line 222
  __cil_tmp8 = strcaseeq0(locale_code, (char const   *)((char *)"GB18030"), (char )'G',
                          (char )'B', (char )'1', (char )'8', (char )'0', (char )'3',
                          (char )'0', (char )0, (char )0);
  }
#line 222
  if (__cil_tmp8) {
#line 223
    if ((int )((char )*(msgid + 0)) == 96) {
#line 223
      tmp___21 = (char *)"\241\ae";
    } else {
#line 223
      tmp___21 = (char *)"\241\257";
    }
#line 223
    return ((char const   *)tmp___21);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___22 = (char *)"\"";
  } else {
#line 225
    tmp___22 = (char *)"\'";
  }
#line 225
  return ((char const   *)tmp___22);
}
}
#line 242 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  int backslash_escapes ;
  int unibyte_locale ;
  size_t __cil_tmp16 ;
  int elide_outer_quotes ;
  int tmp ;
  unsigned char c ;
  unsigned char esc ;
  int is_right_quote ;
  int __cil_tmp29 ;
  int tmp___23 ;
  size_t m ;
  int printable ;
  unsigned short const   **__cil_tmp43 ;
  mbstate_t mbstate ;
  int __cil_tmp46 ;
  wchar_t w ;
  size_t bytes ;
  size_t __cil_tmp49 ;
  size_t j ;
  int __cil_tmp53 ;
  size_t ilim ;
  size_t __cil_tmp65 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = 0;
#line 254
  __cil_tmp16 = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = __cil_tmp16 == 1UL;
#line 255
  elide_outer_quotes = (flags & 2) != 0;
  }
  {
#line 268
  if ((unsigned int )quoting_style == (unsigned int )4) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == (unsigned int )3) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == (unsigned int )5) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == (unsigned int )8) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == (unsigned int )7) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == (unsigned int )6) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == (unsigned int )1) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == (unsigned int )2) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == (unsigned int )0) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = 1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = 1;
#line 276
  quote_string = (char const   *)((char *)"\"");
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = 1;
#line 282
  elide_outer_quotes = 0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote((char const   *)((char *)"`"), quoting_style);
#line 313
    right_quote = gettext_quote((char const   *)((char *)"\'"), quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! ((char )*quote_string)) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    quote_string ++;
  }
  {
#line 318
  backslash_escapes = 1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = 1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = (char const   *)((char *)"\'");
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = 0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (! (! tmp)) {
#line 343
      goto while_break___3;
    }
    {
#line 347
    is_right_quote = 0;
#line 349
    __cil_tmp29 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                         quote_string_len);
    }
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (i + quote_string_len <= argsize) {
#line 349
          if (__cil_tmp29 == 0) {
#line 354
            if (elide_outer_quotes) {
#line 355
              goto force_outer_quoting_style;
            }
#line 356
            is_right_quote = 1;
          }
        }
      }
    }
#line 359
    c = (unsigned char )((char )*(arg + i));
    {
#line 362
    if ((int )c == '\000') {
#line 362
      goto case_0___0;
    }
#line 388
    if ((int )c == '?') {
#line 388
      goto case_63;
    }
#line 391
    if ((int )c == (unsigned int )2) {
#line 391
      goto case_2___0;
    }
#line 396
    if ((int )c == (unsigned int )3) {
#line 396
      goto case_3___0;
    }
#line 403
    if ((int )c == '>') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '=') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '<') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '/') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '-') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == ')') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '(') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '\'') {
#line 403
      goto case_62;
    }
#line 403
    if ((int )c == '!') {
#line 403
      goto case_62;
    }
#line 426
    if ((int )c == '\a') {
#line 426
      goto case_7___0;
    }
#line 427
    if ((int )c == '\b') {
#line 427
      goto case_8___0;
    }
#line 428
    if ((int )c == '\f') {
#line 428
      goto case_12;
    }
#line 429
    if ((int )c == '\n') {
#line 429
      goto case_10;
    }
#line 430
    if ((int )c == '\r') {
#line 430
      goto case_13;
    }
#line 431
    if ((int )c == '\t') {
#line 431
      goto case_9;
    }
#line 432
    if ((int )c == '\v') {
#line 432
      goto case_11;
    }
#line 433
    if ((int )c == '\\') {
#line 433
      goto case_92;
    }
#line 452
    if ((int )c == '}') {
#line 452
      goto case_125;
    }
#line 452
    if ((int )c == '{') {
#line 452
      goto case_125;
    }
#line 456
    if ((int )c == '~') {
#line 456
      goto case_126;
    }
#line 456
    if ((int )c == '#') {
#line 456
      goto case_126;
    }
#line 468
    if ((int )c == '|') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '`') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '^') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '[') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '>') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '=') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '<') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == ';') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '*') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == ')') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '(') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '&') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '$') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '\"') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == '!') {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == ' ') {
#line 468
      goto case_124;
    }
#line 478
    if ((int )c == '\'') {
#line 478
      goto case_39___0;
    }
#line 500
    if ((int )c == 'z') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'y') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'x') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'w') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'v') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'u') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 't') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 's') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'r') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'q') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'p') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'o') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'n') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'm') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'l') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'k') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'j') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'i') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'h') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'g') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'f') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'e') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'd') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'c') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'b') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'a') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '_') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == ']') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'Z') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'Y') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'X') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'W') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'V') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'U') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'T') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'S') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'R') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'Q') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'P') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'O') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'N') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'M') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'L') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'K') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'J') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'I') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'H') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'G') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'F') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'E') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'D') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'C') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'B') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 'A') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == ':') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '9') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '8') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '7') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '6') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '5') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '4') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '3') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '2') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '1') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '0') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '/') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '.') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '-') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == ',') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '+') {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == '%') {
#line 500
      goto case_122;
    }
#line 573
    if ((int )c == '|') {
#line 573
      goto case_124___0;
    }
#line 573
    if ((int )c == '`') {
#line 573
      goto case_124___0;
    }
#line 573
    if ((int )c == '^') {
#line 573
      goto case_124___0;
    }
#line 573
    if ((int )c == '\\') {
#line 573
      goto case_124___0;
    }
#line 573
    if ((int )c == '[') {
#line 573
      goto case_124___0;
    }
#line 513
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 363
    if (backslash_escapes) {
#line 365
      if (elide_outer_quotes) {
#line 366
        goto force_outer_quoting_style;
      }
      {
#line 367
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer + len) = (char )'\\';
        }
#line 367
        len ++;
#line 367
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 373
      if (i + 1UL < argsize) {
#line 373
        if (48 <= (int )((char )*(arg + (i + 1UL)))) {
#line 373
          if ((int )((char )*(arg + (i + 1UL))) <= 57) {
            {
#line 375
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 375
              if (len < buffersize) {
#line 375
                *(buffer + len) = (char )'0';
              }
#line 375
              len ++;
#line 375
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 376
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 376
              if (len < buffersize) {
#line 376
                *(buffer + len) = (char )'0';
              }
#line 376
              len ++;
#line 376
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 378
      c = (unsigned char )'0';
    } else
#line 384
    if (flags & 1) {
#line 385
      goto while_continue___3;
    }
#line 386
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 391
    if ((unsigned int )quoting_style == (unsigned int )2) {
#line 391
      goto case_2___0;
    }
#line 396
    if ((unsigned int )quoting_style == (unsigned int )3) {
#line 396
      goto case_3___0;
    }
#line 403
    if ((unsigned int )quoting_style == '>') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '=') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '<') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '/') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '-') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == ')') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '(') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '\'') {
#line 403
      goto case_62;
    }
#line 403
    if ((unsigned int )quoting_style == '!') {
#line 403
      goto case_62;
    }
#line 421
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 392
    if (elide_outer_quotes) {
#line 393
      goto force_outer_quoting_style;
    }
#line 394
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 397
    if (flags & 4) {
#line 397
      if (i + 2UL < argsize) {
#line 397
        if ((int )((char )*(arg + (i + 1UL))) == 63) {
          {
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '>') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '=') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '<') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '/') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '-') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == ')') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '(') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '\'') {
#line 403
            goto case_62;
          }
#line 403
          if ((int )((char )*(arg + (i + 2UL))) == '!') {
#line 403
            goto case_62;
          }
#line 416
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 406
          if (elide_outer_quotes) {
#line 407
            goto force_outer_quoting_style;
          }
#line 408
          c = (unsigned char )((char )*(arg + (i + 2UL)));
#line 409
          i += (unsigned long )2;
          {
#line 410
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 410
            if (len < buffersize) {
#line 410
              *(buffer + len) = (char )'?';
            }
#line 410
            len ++;
#line 410
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 411
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 411
            if (len < buffersize) {
#line 411
              *(buffer + len) = (char )'\"';
            }
#line 411
            len ++;
#line 411
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 412
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 412
            if (len < buffersize) {
#line 412
              *(buffer + len) = (char )'\"';
            }
#line 412
            len ++;
#line 412
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 413
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 413
            if (len < buffersize) {
#line 413
              *(buffer + len) = (char )'?';
            }
#line 413
            len ++;
#line 413
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 414
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 417
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 419
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 422
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 424
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 426
    esc = (unsigned char )'a';
#line 426
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 427
    esc = (unsigned char )'b';
#line 427
    goto c_escape;
    case_12: /* CIL Label */ 
#line 428
    esc = (unsigned char )'f';
#line 428
    goto c_escape;
    case_10: /* CIL Label */ 
#line 429
    esc = (unsigned char )'n';
#line 429
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 430
    esc = (unsigned char )'r';
#line 430
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 431
    esc = (unsigned char )'t';
#line 431
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 432
    esc = (unsigned char )'v';
#line 432
    goto c_escape;
    case_92: /* CIL Label */ 
#line 433
    esc = c;
#line 436
    if (backslash_escapes) {
#line 436
      if (elide_outer_quotes) {
#line 436
        if (quote_string_len) {
#line 437
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 440
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 442
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 445
    if (backslash_escapes) {
#line 447
      c = esc;
#line 448
      goto store_escape;
    }
#line 450
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 453
    if (argsize == 0xffffffffffffffffUL) {
#line 453
      tmp___23 = (int )((char )*(arg + 1)) == 0;
    } else {
#line 453
      tmp___23 = argsize == 1UL;
    }
#line 453
    if (! tmp___23) {
#line 454
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 457
    if (i != 0UL) {
#line 458
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 473
    if ((unsigned int )quoting_style == 2U) {
#line 473
      if (elide_outer_quotes) {
#line 475
        goto force_outer_quoting_style;
      }
    }
#line 476
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 479
    if ((unsigned int )quoting_style == 2U) {
#line 481
      if (elide_outer_quotes) {
#line 482
        goto force_outer_quoting_style;
      }
      {
#line 483
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 483
        if (len < buffersize) {
#line 483
          *(buffer + len) = (char )'\'';
        }
#line 483
        len ++;
#line 483
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 484
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 484
        if (len < buffersize) {
#line 484
          *(buffer + len) = (char )'\\';
        }
#line 484
        len ++;
#line 484
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 485
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 485
        if (len < buffersize) {
#line 485
          *(buffer + len) = (char )'\'';
        }
#line 485
        len ++;
#line 485
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 487
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 511
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 525
    if (unibyte_locale) {
      {
#line 527
      m = (size_t )1;
#line 528
      __cil_tmp43 = __ctype_b_loc();
#line 528
      printable = ((int )((unsigned short )*(*__cil_tmp43 + (int )c)) & 16384) != 0;
      }
    } else {
      {
#line 533
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 535
      m = (size_t )0;
#line 536
      printable = 1;
      }
#line 537
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 538
        argsize = strlen(arg);
        }
      }
      {
#line 540
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 543
        __cil_tmp49 = mbrtowc(& w, & *(arg + (i + m)), argsize - (i + m), & mbstate);
#line 543
        bytes = __cil_tmp49;
        }
#line 545
        if (bytes == 0UL) {
#line 546
          goto while_break___14;
        } else
#line 547
        if (bytes == 0xffffffffffffffffUL) {
#line 549
          printable = 0;
#line 550
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xfffffffffffffffeUL) {
#line 554
          printable = 0;
          {
#line 555
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 555
            if (! (i + m < argsize && (int )((char )*(arg + (i + m))))) {
#line 555
              goto while_break___15;
            }
#line 556
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 557
          goto while_break___14;
        } else {
#line 565
          if (elide_outer_quotes) {
#line 565
            if ((unsigned int )quoting_style == 2U) {
#line 569
              j = (size_t )1;
              {
#line 569
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 569
                if (! (j < bytes)) {
#line 569
                  goto while_break___16;
                }
                {
#line 573
                if ((int )((char )*(arg + ((i + m) + j))) == '|') {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int )((char )*(arg + ((i + m) + j))) == '`') {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int )((char )*(arg + ((i + m) + j))) == '^') {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int )((char )*(arg + ((i + m) + j))) == '\\') {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int )((char )*(arg + ((i + m) + j))) == '[') {
#line 573
                  goto case_124___0;
                }
#line 576
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 574
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 577
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
              }
              while_break___16: /* CIL Label */ ;
              }
#line 569
              j ++;
            }
          }
          {
#line 581
          __cil_tmp53 = iswprint((wint_t )w);
          }
#line 581
          if (! __cil_tmp53) {
#line 582
            printable = 0;
          }
#line 583
          m += bytes;
        }
#line 540
        if (! (! __cil_tmp46)) {
#line 540
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 589
    if (1UL < m) {
      _L___24: /* CIL Label */ 
#line 593
      ilim = i + m;
      {
#line 595
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 595
        if (! 1) {
#line 595
          goto while_break___17;
        }
#line 597
        if (backslash_escapes) {
#line 597
          if (! printable) {
#line 599
            if (elide_outer_quotes) {
#line 600
              goto force_outer_quoting_style;
            }
            {
#line 601
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 601
              if (len < buffersize) {
#line 601
                *(buffer + len) = (char )'\\';
              }
#line 601
              len ++;
#line 601
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
            {
#line 602
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 602
              if (len < buffersize) {
#line 602
                *(buffer + len) = (char )(48 + ((int )c >> 6));
              }
#line 602
              len ++;
#line 602
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
            {
#line 603
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 603
              if (len < buffersize) {
#line 603
                *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
              }
#line 603
              len ++;
#line 603
              goto while_break___20;
            }
            while_break___20: /* CIL Label */ ;
            }
#line 604
            c = (unsigned char )(48 + ((int )c & 7));
          } else {
#line 597
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 606
        if (is_right_quote) {
          {
#line 608
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 608
            if (len < buffersize) {
#line 608
              *(buffer + len) = (char )'\\';
            }
#line 608
            len ++;
#line 608
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 609
          is_right_quote = 0;
        }
#line 611
        if (ilim <= i + 1UL) {
#line 612
          goto while_break___17;
        }
        {
#line 613
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 613
          if (len < buffersize) {
#line 613
            *(buffer + len) = (char )c;
          }
#line 613
          len ++;
#line 613
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
#line 614
        i ++;
#line 614
        c = (unsigned char )((char )*(arg + i));
      }
      while_break___17: /* CIL Label */ ;
      }
#line 617
      goto store_c;
    } else
#line 589
    if (backslash_escapes) {
#line 589
      if (! printable) {
#line 589
        goto _L___24;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 622
    if (! (((backslash_escapes || elide_outer_quotes) && quote_these_too) && (unsigned int )*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 622
      if (! is_right_quote) {
#line 626
        goto store_c;
      }
    }
    store_escape: 
#line 629
    if (elide_outer_quotes) {
#line 630
      goto force_outer_quoting_style;
    }
    {
#line 631
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 631
      if (len < buffersize) {
#line 631
        *(buffer + len) = (char )'\\';
      }
#line 631
      len ++;
#line 631
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 634
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 634
      if (len < buffersize) {
#line 634
        *(buffer + len) = (char )c;
      }
#line 634
      len ++;
#line 634
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 343
  i ++;
#line 637
  if (len == 0UL) {
#line 637
    if ((unsigned int )quoting_style == 2U) {
#line 637
      if (elide_outer_quotes) {
#line 639
        goto force_outer_quoting_style;
      }
    }
  }
#line 641
  if (quote_string) {
#line 641
    if (! elide_outer_quotes) {
      {
#line 642
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 642
        if (! ((char )*quote_string)) {
#line 642
          goto while_break___25;
        }
        {
#line 643
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 643
          if (len < buffersize) {
#line 643
            *(buffer + len) = (char )*quote_string;
          }
#line 643
          len ++;
#line 643
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 642
      quote_string ++;
    }
  }
#line 645
  if (len < buffersize) {
#line 646
    *(buffer + len) = (char )'\000';
  }
#line 647
  return (len);
  force_outer_quoting_style: 
  {
#line 652
  __cil_tmp65 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0),
                                         left_quote, right_quote);
  }
#line 652
  return (__cil_tmp65);
}
}
#line 668 "/tmp/0/patch-2.7.1/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options *o ) 
{ 
  struct quoting_options *p ;
  struct quoting_options *tmp ;
  int e ;
  int *__cil_tmp9 ;
  size_t r ;
  size_t __cil_tmp11 ;
  int *__cil_tmp12 ;

  {
#line 672
  if (o) {
#line 672
    tmp = o;
  } else {
#line 672
    tmp = & default_quoting_options;
  }
  {
#line 672
  p = tmp;
#line 673
  __cil_tmp9 = __errno_location();
#line 673
  e = *__cil_tmp9;
#line 674
  __cil_tmp11 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, p->style,
                                         p->flags, (unsigned int const   *)p->quote_these_too,
                                         p->left_quote, p->right_quote);
#line 674
  r = __cil_tmp11;
#line 677
  __cil_tmp12 = __errno_location();
#line 677
  *__cil_tmp12 = e;
  }
#line 678
  return (r);
}
}
#line 683 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options *o ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 686
  __cil_tmp4 = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 686
  return (__cil_tmp4);
}
}
#line 696 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options *o ) 
{ 
  struct quoting_options *p ;
  struct quoting_options *tmp ;
  int e ;
  int *__cil_tmp8 ;
  int flags ;
  int tmp___25 ;
  size_t bufsize___0 ;
  size_t __cil_tmp12 ;
  char *buf___0 ;
  char *__cil_tmp14 ;
  int *__cil_tmp15 ;

  {
#line 699
  if (o) {
#line 699
    tmp = o;
  } else {
#line 699
    tmp = & default_quoting_options;
  }
  {
#line 699
  p = tmp;
#line 700
  __cil_tmp8 = __errno_location();
#line 700
  e = *__cil_tmp8;
  }
#line 702
  if (size) {
#line 702
    tmp___25 = 0;
  } else {
#line 702
    tmp___25 = 1;
  }
  {
#line 702
  flags = p->flags | tmp___25;
#line 703
  __cil_tmp12 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, p->style,
                                         flags, (unsigned int const   *)p->quote_these_too,
                                         p->left_quote, p->right_quote);
#line 703
  bufsize___0 = __cil_tmp12 + 1UL;
#line 707
  __cil_tmp14 = xcharalloc(bufsize___0);
#line 707
  buf___0 = __cil_tmp14;
#line 708
  quotearg_buffer_restyled(buf___0, bufsize___0, arg, argsize, p->style, flags, (unsigned int const   *)p->quote_these_too,
                           p->left_quote, p->right_quote);
#line 711
  __cil_tmp15 = __errno_location();
#line 711
  *__cil_tmp15 = e;
  }
#line 712
  if (size) {
#line 713
    *size = bufsize___0 - 1UL;
  }
#line 714
  return (buf___0);
}
}
#line 726
static char slot0[256] ;
#line 727 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static unsigned int nslots  =    (unsigned int )1;
#line 728 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), (char *)slot0};
#line 729 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 732 "/tmp/0/patch-2.7.1/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 734
  sv = slotvec;
#line 736
  i = (unsigned int )1;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < nslots)) {
#line 736
      goto while_break;
    }
    {
#line 737
    free((void *)(sv + i)->val);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  i ++;
#line 738
  if ((sv + 0)->val != (char *)slot0) {
    {
#line 740
    free((void *)(sv + 0)->val);
#line 741
    slotvec0.size = sizeof(slot0);
#line 742
    slotvec0.val = (char *)slot0;
    }
  }
#line 744
  if (sv != & slotvec0) {
    {
#line 746
    free((void *)sv);
#line 747
    slotvec = & slotvec0;
    }
  }
#line 749
  nslots = (unsigned int )1;
}
}
#line 761 "/tmp/0/patch-2.7.1/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options *options ) 
{ 
  int e ;
  int *__cil_tmp6 ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  int preallocated ;
  int tmp ;
  struct slotvec *tmp___26 ;
  void *__cil_tmp13 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t __cil_tmp18 ;
  int *__cil_tmp20 ;

  {
  {
#line 764
  __cil_tmp6 = __errno_location();
#line 764
  e = *__cil_tmp6;
#line 766
  n0 = (unsigned int )n;
#line 767
  sv = slotvec;
  }
#line 769
  if (n < 0) {
    {
#line 770
    abort();
    }
  }
#line 772
  if (nslots <= n0) {
#line 779
    n1 = (size_t )(n0 + 1U);
#line 780
    preallocated = sv == & slotvec0;
#line 782
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 782
      tmp = - 1;
    } else {
#line 782
      tmp = - 2;
    }
#line 782
    if ((size_t )tmp / sizeof(*sv) < n1) {
      {
#line 783
      xalloc_die();
      }
    }
#line 785
    if (preallocated) {
#line 785
      tmp___26 = (struct slotvec *)((void *)0);
    } else {
#line 785
      tmp___26 = sv;
    }
    {
#line 785
    __cil_tmp13 = xrealloc((void *)tmp___26, n1 * sizeof(*sv));
#line 785
    sv = (struct slotvec *)__cil_tmp13;
#line 785
    slotvec = sv;
    }
#line 786
    if (preallocated) {
#line 787
      *sv = slotvec0;
    }
    {
#line 788
    memset((void *)(sv + nslots), 0, (n1 - (unsigned long )nslots) * sizeof(*sv));
#line 789
    nslots = (unsigned int )n1;
    }
  }
  {
#line 793
  size = (sv + n)->size;
#line 794
  val = (sv + n)->val;
#line 796
  flags = options->flags | 1;
#line 797
  __cil_tmp18 = quotearg_buffer_restyled(val, size, arg, argsize, options->style,
                                         flags, (unsigned int const   *)options->quote_these_too,
                                         options->left_quote, options->right_quote);
#line 797
  qsize = __cil_tmp18;
  }
#line 803
  if (size <= qsize) {
#line 805
    size = qsize + 1UL;
#line 805
    (sv + n)->size = size;
#line 806
    if (val != (char *)slot0) {
      {
#line 807
      free((void *)val);
      }
    }
    {
#line 808
    (sv + n)->val = xcharalloc(size);
#line 809
    quotearg_buffer_restyled(val, size, arg, argsize, options->style, flags, (unsigned int const   *)options->quote_these_too,
                             options->left_quote, options->right_quote);
    }
  }
  {
#line 815
  __cil_tmp20 = __errno_location();
#line 815
  *__cil_tmp20 = e;
  }
#line 816
  return (val);
}
}
#line 821 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 823
  __cil_tmp3 = quotearg_n_options(n, arg, (size_t )(- 1), & default_quoting_options);
  }
#line 823
  return (__cil_tmp3);
}
}
#line 827 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 829
  __cil_tmp4 = quotearg_n_options(n, arg, argsize, & default_quoting_options);
  }
#line 829
  return (__cil_tmp4);
}
}
#line 833 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 835
  __cil_tmp2 = quotearg_n(0, arg);
  }
#line 835
  return (__cil_tmp2);
}
}
#line 839 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 841
  __cil_tmp3 = quotearg_n_mem(0, arg, argsize);
  }
#line 841
  return (__cil_tmp3);
}
}
#line 845 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options __cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 847
  __cil_tmp5 = quoting_options_from_style(s);
#line 847
  o = __cil_tmp5;
#line 848
  __cil_tmp6 = quotearg_n_options(n, arg, (size_t )(- 1), & o);
  }
#line 848
  return (__cil_tmp6);
}
}
#line 852 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options __cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 855
  __cil_tmp6 = quoting_options_from_style(s);
#line 855
  o = __cil_tmp6;
#line 856
  __cil_tmp7 = quotearg_n_options(n, arg, argsize, & o);
  }
#line 856
  return (__cil_tmp7);
}
}
#line 860 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 862
  __cil_tmp3 = quotearg_n_style(0, s, arg);
  }
#line 862
  return (__cil_tmp3);
}
}
#line 866 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 868
  __cil_tmp4 = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 868
  return (__cil_tmp4);
}
}
#line 872 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *__cil_tmp5 ;

  {
  {
#line 875
  options = default_quoting_options;
#line 876
  set_char_quoting(& options, ch, 1);
#line 877
  __cil_tmp5 = quotearg_n_options(0, arg, argsize, & options);
  }
#line 877
  return (__cil_tmp5);
}
}
#line 881 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 883
  __cil_tmp3 = quotearg_char_mem(arg, (size_t )(- 1), ch);
  }
#line 883
  return (__cil_tmp3);
}
}
#line 887 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 889
  __cil_tmp2 = quotearg_char(arg, (char )':');
  }
#line 889
  return (__cil_tmp2);
}
}
#line 893 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 895
  __cil_tmp3 = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 895
  return (__cil_tmp3);
}
}
#line 899 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 902
  __cil_tmp5 = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )(- 1));
  }
#line 902
  return (__cil_tmp5);
}
}
#line 907 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *__cil_tmp7 ;

  {
  {
#line 911
  o = default_quoting_options;
#line 912
  set_custom_quoting(& o, left_quote, right_quote);
#line 913
  __cil_tmp7 = quotearg_n_options(n, arg, argsize, & o);
  }
#line 913
  return (__cil_tmp7);
}
}
#line 917 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 920
  __cil_tmp4 = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 920
  return (__cil_tmp4);
}
}
#line 924 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 927
  __cil_tmp5 = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 927
  return (__cil_tmp5);
}
}
#line 933 "/tmp/0/patch-2.7.1/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {(unsigned int )0}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 942 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 944
  __cil_tmp3 = quotearg_n_options(n, name, (size_t )(- 1), & quote_quoting_options);
  }
#line 944
  return ((char const   *)__cil_tmp3);
}
}
#line 948 "/tmp/0/patch-2.7.1/lib/quotearg.c"
char const   *quote(char const   *name ) 
{ 
  char const   *__cil_tmp2 ;

  {
  {
#line 950
  __cil_tmp2 = quote_n(0, name);
  }
#line 950
  return (__cil_tmp2);
}
}
#line 32 "./progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern _IO_FILE *stderr ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 252
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 33 "/tmp/0/patch-2.7.1/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 39 "/tmp/0/patch-2.7.1/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *__cil_tmp4 ;
  char const   *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 51
  if (argv0 == (char const   *)((void *)0)) {
    {
#line 54
    fputs((char const   *)((char *)"A NULL argv[0] was passed through an exec system call.\n"),
          stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  __cil_tmp4 = strrchr(argv0, '/');
#line 59
  slash = (char const   *)__cil_tmp4;
  }
#line 60
  if (slash != (char const   *)((void *)0)) {
#line 60
    tmp = slash + 1;
  } else {
#line 60
    tmp = argv0;
  }
  {
#line 60
  base = tmp;
#line 61
  __cil_tmp6 = strncmp(base - 7, (char const   *)((char *)"/.libs/"), (unsigned long )7);
  }
#line 61
  if (base - argv0 >= 7L) {
#line 61
    if (__cil_tmp6 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      __cil_tmp7 = strncmp(base, (char const   *)((char *)"lt-"), (unsigned long )3);
      }
#line 64
      if (__cil_tmp7 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
}
}
#line 83 "/tmp/0/patch-2.7.1/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *__cil_tmp11 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  unsigned long tmp ;
  size_t __cil_tmp18 ;
  char const   *np___0 ;
  size_t n___0 ;
  unsigned long tmp___0 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp34 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  unsigned long tmp___1 ;
  unsigned long tmp___27 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *tmp___28 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  unsigned long tmp___29 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp55 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *tmp___32 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *__cil_tmp76 ;
  size_t __cil_tmp77 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  unsigned long tmp___33 ;
  unsigned long tmp___34 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *tmp___35 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  unsigned long tmp___36 ;
  unsigned long tmp___37 ;
  void *__cil_tmp93 ;
  void *__cil_tmp94 ;
  void *tmp___38 ;
  int *__cil_tmp96 ;
  int *__cil_tmp97 ;

  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )7;
#line 94
  d->dir = (char_directive *)d->direct_alloc_dir;
#line 96
  a->count = (size_t )0;
#line 97
  a_allocated = (size_t )7;
#line 98
  a->arg = (argument *)a->direct_alloc_arg;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int )((char )*cp) != 0)) {
#line 134
      goto while_break;
    }
#line 136
    __cil_tmp11 = cp;
#line 136
    cp ++;
#line 136
    c = (char )*__cil_tmp11;
#line 137
    if ((int )c == 37) {
#line 139
      arg_index = ~ ((size_t )0);
#line 140
      dp = & *(d->dir + d->count);
#line 143
      dp->dir_start = cp - 1;
#line 144
      dp->flags = 0;
#line 145
      dp->width_start = (char const   *)((void *)0);
#line 146
      dp->width_end = (char const   *)((void *)0);
#line 147
      dp->width_arg_index = ~ ((size_t )0);
#line 148
      dp->precision_start = (char const   *)((void *)0);
#line 149
      dp->precision_end = (char const   *)((void *)0);
#line 150
      dp->precision_arg_index = ~ ((size_t )0);
#line 151
      dp->arg_index = ~ ((size_t )0);
#line 154
      if ((int )((char )*cp) >= 48) {
#line 154
        if ((int )((char )*cp) <= 57) {
#line 158
          np = cp;
          {
#line 158
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 158
            if (! ((int )((char )*np) >= 48 && (int )((char )*np) <= 57)) {
#line 158
              goto while_break___0;
            }

          }
          while_break___0: /* CIL Label */ ;
          }
#line 158
          np ++;
#line 160
          if ((int )((char )*np) == 36) {
#line 162
            n = (size_t )0;
#line 164
            np = cp;
            {
#line 164
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 164
              if (! ((int )((char )*np) >= 48 && (int )((char )*np) <= 57)) {
#line 164
                goto while_break___1;
              }
#line 165
              if (n <= 1844674407370955161UL) {
#line 165
                tmp = n * 10UL;
              } else {
#line 165
                tmp = 0xffffffffffffffffUL;
              }
              {
#line 165
              __cil_tmp18 = xsum(tmp, (size_t )((int )((char )*np) - 48));
#line 165
              n = __cil_tmp18;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 164
            np ++;
#line 166
            if (n == 0UL) {
#line 168
              goto error;
            }
#line 169
            if (n == 0xffffffffffffffffUL) {
#line 171
              goto error;
            }
#line 172
            arg_index = n - 1UL;
#line 173
            cp = np + 1;
          }
        }
      }
      {
#line 178
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 178
        if (! 1) {
#line 178
          goto while_break___2;
        }
#line 180
        if ((int )((char )*cp) == 39) {
#line 182
          dp->flags |= 1;
#line 183
          cp ++;
        } else
#line 185
        if ((int )((char )*cp) == 45) {
#line 187
          dp->flags |= 2;
#line 188
          cp ++;
        } else
#line 190
        if ((int )((char )*cp) == 43) {
#line 192
          dp->flags |= 4;
#line 193
          cp ++;
        } else
#line 195
        if ((int )((char )*cp) == 32) {
#line 197
          dp->flags |= 8;
#line 198
          cp ++;
        } else
#line 200
        if ((int )((char )*cp) == 35) {
#line 202
          dp->flags |= 16;
#line 203
          cp ++;
        } else
#line 205
        if ((int )((char )*cp) == 48) {
#line 207
          dp->flags |= 32;
#line 208
          cp ++;
        } else
#line 211
        if ((int )((char )*cp) == 73) {
#line 213
          dp->flags |= 64;
#line 214
          cp ++;
        } else {
#line 218
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 222
      if ((int )((char )*cp) == 42) {
#line 224
        dp->width_start = cp;
#line 225
        cp ++;
#line 226
        dp->width_end = cp;
#line 227
        if (max_width_length < 1UL) {
#line 228
          max_width_length = (size_t )1;
        }
#line 231
        if ((int )((char )*cp) >= 48) {
#line 231
          if ((int )((char )*cp) <= 57) {
#line 235
            np___0 = cp;
            {
#line 235
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 235
              if (! ((int )((char )*np___0) >= 48 && (int )((char )*np___0) <= 57)) {
#line 235
                goto while_break___3;
              }

            }
            while_break___3: /* CIL Label */ ;
            }
#line 235
            np___0 ++;
#line 237
            if ((int )((char )*np___0) == 36) {
#line 239
              n___0 = (size_t )0;
#line 241
              np___0 = cp;
              {
#line 241
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 241
                if (! ((int )((char )*np___0) >= 48 && (int )((char )*np___0) <= 57)) {
#line 241
                  goto while_break___4;
                }
#line 242
                if (n___0 <= 1844674407370955161UL) {
#line 242
                  tmp___0 = n___0 * 10UL;
                } else {
#line 242
                  tmp___0 = 0xffffffffffffffffUL;
                }
                {
#line 242
                __cil_tmp32 = xsum(tmp___0, (size_t )((int )((char )*np___0) - 48));
#line 242
                n___0 = __cil_tmp32;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 241
              np___0 ++;
#line 243
              if (n___0 == 0UL) {
#line 245
                goto error;
              }
#line 246
              if (n___0 == 0xffffffffffffffffUL) {
#line 248
                goto error;
              }
#line 249
              dp->width_arg_index = n___0 - 1UL;
#line 250
              cp = np___0 + 1;
            }
          }
        }
#line 253
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 255
          __cil_tmp34 = arg_posn;
#line 255
          arg_posn ++;
#line 255
          dp->width_arg_index = __cil_tmp34;
#line 256
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 258
            goto error;
          }
        }
#line 260
        n___1 = dp->width_arg_index;
#line 260
        if (n___1 >= a_allocated) {
#line 260
          if (a_allocated <= 9223372036854775807UL) {
#line 260
            tmp___1 = a_allocated * 2UL;
          } else {
#line 260
            tmp___1 = 0xffffffffffffffffUL;
          }
#line 260
          a_allocated = tmp___1;
#line 260
          if (a_allocated <= n___1) {
            {
#line 260
            a_allocated = xsum(n___1, (size_t )1);
            }
          }
#line 260
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 260
            tmp___27 = a_allocated * sizeof(argument );
          } else {
#line 260
            tmp___27 = 0xffffffffffffffffUL;
          }
#line 260
          memory_size = tmp___27;
#line 260
          if (memory_size == 0xffffffffffffffffUL) {
#line 260
            goto out_of_memory;
          }
#line 260
          if (a->arg != (argument *)a->direct_alloc_arg) {
            {
#line 260
            __cil_tmp41 = realloc((void *)a->arg, memory_size);
#line 260
            tmp___28 = __cil_tmp41;
            }
          } else {
            {
#line 260
            __cil_tmp42 = malloc(memory_size);
#line 260
            tmp___28 = __cil_tmp42;
            }
          }
#line 260
          memory = (argument *)tmp___28;
#line 260
          if (memory == (argument *)((void *)0)) {
#line 260
            goto out_of_memory;
          }
#line 260
          if (a->arg == (argument *)a->direct_alloc_arg) {
            {
#line 260
            memcpy((void *)memory, (void const   *)a->arg, a->count * sizeof(argument ));
            }
          }
#line 260
          a->arg = memory;
        }
        {
#line 260
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 260
          if (! (a->count <= n___1)) {
#line 260
            goto while_break___5;
          }
#line 260
          (a->arg + a->count)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 260
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 260
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 260
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 260
          goto error;
        }

      } else
#line 262
      if ((int )((char )*cp) >= 48) {
#line 262
        if ((int )((char )*cp) <= 57) {
#line 266
          dp->width_start = cp;
          {
#line 267
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 267
            if (! ((int )((char )*cp) >= 48 && (int )((char )*cp) <= 57)) {
#line 267
              goto while_break___6;
            }

          }
          while_break___6: /* CIL Label */ ;
          }
#line 267
          cp ++;
#line 269
          dp->width_end = cp;
#line 270
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 271
          if (max_width_length < width_length) {
#line 272
            max_width_length = width_length;
          }
        }
      }
#line 276
      if ((int )((char )*cp) == 46) {
#line 278
        cp ++;
#line 279
        if ((int )((char )*cp) == 42) {
#line 281
          dp->precision_start = cp - 1;
#line 282
          cp ++;
#line 283
          dp->precision_end = cp;
#line 284
          if (max_precision_length < 2UL) {
#line 285
            max_precision_length = (size_t )2;
          }
#line 288
          if ((int )((char )*cp) >= 48) {
#line 288
            if ((int )((char )*cp) <= 57) {
#line 292
              np___1 = cp;
              {
#line 292
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 292
                if (! ((int )((char )*np___1) >= 48 && (int )((char )*np___1) <= 57)) {
#line 292
                  goto while_break___7;
                }

              }
              while_break___7: /* CIL Label */ ;
              }
#line 292
              np___1 ++;
#line 294
              if ((int )((char )*np___1) == 36) {
#line 296
                n___2 = (size_t )0;
#line 298
                np___1 = cp;
                {
#line 298
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 298
                  if (! ((int )((char )*np___1) >= 48 && (int )((char )*np___1) <= 57)) {
#line 298
                    goto while_break___8;
                  }
#line 299
                  if (n___2 <= 1844674407370955161UL) {
#line 299
                    tmp___29 = n___2 * 10UL;
                  } else {
#line 299
                    tmp___29 = 0xffffffffffffffffUL;
                  }
                  {
#line 299
                  __cil_tmp53 = xsum(tmp___29, (size_t )((int )((char )*np___1) - 48));
#line 299
                  n___2 = __cil_tmp53;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 298
                np___1 ++;
#line 300
                if (n___2 == 0UL) {
#line 302
                  goto error;
                }
#line 303
                if (n___2 == 0xffffffffffffffffUL) {
#line 306
                  goto error;
                }
#line 307
                dp->precision_arg_index = n___2 - 1UL;
#line 308
                cp = np___1 + 1;
              }
            }
          }
#line 311
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 313
            __cil_tmp55 = arg_posn;
#line 313
            arg_posn ++;
#line 313
            dp->precision_arg_index = __cil_tmp55;
#line 314
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 316
              goto error;
            }
          }
#line 318
          n___3 = dp->precision_arg_index;
#line 318
          if (n___3 >= a_allocated) {
#line 318
            if (a_allocated <= 9223372036854775807UL) {
#line 318
              tmp___30 = a_allocated * 2UL;
            } else {
#line 318
              tmp___30 = 0xffffffffffffffffUL;
            }
#line 318
            a_allocated = tmp___30;
#line 318
            if (a_allocated <= n___3) {
              {
#line 318
              a_allocated = xsum(n___3, (size_t )1);
              }
            }
#line 318
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 318
              tmp___31 = a_allocated * sizeof(argument );
            } else {
#line 318
              tmp___31 = 0xffffffffffffffffUL;
            }
#line 318
            memory_size___0 = tmp___31;
#line 318
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 318
              goto out_of_memory;
            }
#line 318
            if (a->arg != (argument *)a->direct_alloc_arg) {
              {
#line 318
              __cil_tmp62 = realloc((void *)a->arg, memory_size___0);
#line 318
              tmp___32 = __cil_tmp62;
              }
            } else {
              {
#line 318
              __cil_tmp63 = malloc(memory_size___0);
#line 318
              tmp___32 = __cil_tmp63;
              }
            }
#line 318
            memory___0 = (argument *)tmp___32;
#line 318
            if (memory___0 == (argument *)((void *)0)) {
#line 318
              goto out_of_memory;
            }
#line 318
            if (a->arg == (argument *)a->direct_alloc_arg) {
              {
#line 318
              memcpy((void *)memory___0, (void const   *)a->arg, a->count * sizeof(argument ));
              }
            }
#line 318
            a->arg = memory___0;
          }
          {
#line 318
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 318
            if (! (a->count <= n___3)) {
#line 318
              goto while_break___9;
            }
#line 318
            (a->arg + a->count)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 318
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 318
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 318
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 318
            goto error;
          }

        } else {
#line 324
          dp->precision_start = cp - 1;
          {
#line 325
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 325
            if (! ((int )((char )*cp) >= 48 && (int )((char )*cp) <= 57)) {
#line 325
              goto while_break___10;
            }

          }
          while_break___10: /* CIL Label */ ;
          }
#line 325
          cp ++;
#line 327
          dp->precision_end = cp;
#line 328
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 329
          if (max_precision_length < precision_length) {
#line 330
            max_precision_length = precision_length;
          }
        }
      }
#line 339
      flags = 0;
      {
#line 341
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 341
        if (! 1) {
#line 341
          goto while_break___11;
        }
#line 343
        if ((int )((char )*cp) == 104) {
#line 345
          flags |= 1 << (flags & 1);
#line 346
          cp ++;
        } else
#line 348
        if ((int )((char )*cp) == 76) {
#line 350
          flags |= 4;
#line 351
          cp ++;
        } else
#line 353
        if ((int )((char )*cp) == 108) {
#line 355
          flags += 8;
#line 356
          cp ++;
        } else
#line 358
        if ((int )((char )*cp) == 106) {
#line 360
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 363
            flags += 16;
          } else
#line 365
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 368
            flags += 8;
          }
#line 370
          cp ++;
        } else
#line 372
        if ((int )((char )*cp) == 122) {
          _L: /* CIL Label */ 
#line 377
          if (sizeof(size_t ) > sizeof(long )) {
#line 380
            flags += 16;
          } else
#line 382
          if (sizeof(size_t ) > sizeof(int )) {
#line 385
            flags += 8;
          }
#line 387
          cp ++;
        } else
#line 372
        if ((int )((char )*cp) == 90) {
#line 372
          goto _L;
        } else
#line 389
        if ((int )((char )*cp) == 116) {
#line 391
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 394
            flags += 16;
          } else
#line 396
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 399
            flags += 8;
          }
#line 401
          cp ++;
        } else {
#line 442
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 446
      __cil_tmp76 = cp;
#line 446
      cp ++;
#line 446
      c = (char )*__cil_tmp76;
      {
#line 449
      if ((int )c == 'i') {
#line 449
        goto case_105;
      }
#line 449
      if ((int )c == 'd') {
#line 449
        goto case_105;
      }
#line 467
      if ((int )c == 'X') {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 'x') {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 'u') {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 'o') {
#line 467
        goto case_88;
      }
#line 486
      if ((int )c == 'A') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'a') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'G') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'g') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'E') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'e') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'F') {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 'f') {
#line 486
        goto case_65;
      }
#line 492
      if ((int )c == 'c') {
#line 492
        goto case_99;
      }
#line 503
      if ((int )c == 'C') {
#line 503
        goto case_67;
      }
#line 508
      if ((int )c == 's') {
#line 508
        goto case_115;
      }
#line 519
      if ((int )c == 'S') {
#line 519
        goto case_83;
      }
#line 524
      if ((int )c == 'p') {
#line 524
        goto case_112;
      }
#line 527
      if ((int )c == 'n') {
#line 527
        goto case_110;
      }
#line 556
      if ((int )c == '%') {
#line 556
        goto case_37;
      }
#line 559
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 452
      if (flags >= 16) {
#line 453
        type = (arg_type )9;
      } else
#line 452
      if (flags & 4) {
#line 453
        type = (arg_type )9;
      } else
#line 458
      if (flags >= 8) {
#line 459
        type = (arg_type )7;
      } else
#line 460
      if (flags & 2) {
#line 461
        type = (arg_type )1;
      } else
#line 462
      if (flags & 1) {
#line 463
        type = (arg_type )3;
      } else {
#line 465
        type = (arg_type )5;
      }
#line 466
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 470
      if (flags >= 16) {
#line 471
        type = (arg_type )10;
      } else
#line 470
      if (flags & 4) {
#line 471
        type = (arg_type )10;
      } else
#line 476
      if (flags >= 8) {
#line 477
        type = (arg_type )8;
      } else
#line 478
      if (flags & 2) {
#line 479
        type = (arg_type )2;
      } else
#line 480
      if (flags & 1) {
#line 481
        type = (arg_type )4;
      } else {
#line 483
        type = (arg_type )6;
      }
#line 484
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 487
      if (flags >= 16) {
#line 488
        type = (arg_type )12;
      } else
#line 487
      if (flags & 4) {
#line 488
        type = (arg_type )12;
      } else {
#line 490
        type = (arg_type )11;
      }
#line 491
      goto switch_break;
      case_99: /* CIL Label */ 
#line 493
      if (flags >= 8) {
#line 495
        type = (arg_type )14;
      } else {
#line 500
        type = (arg_type )13;
      }
#line 501
      goto switch_break;
      case_67: /* CIL Label */ 
#line 504
      type = (arg_type )14;
#line 505
      c = (char )'c';
#line 506
      goto switch_break;
      case_115: /* CIL Label */ 
#line 509
      if (flags >= 8) {
#line 511
        type = (arg_type )16;
      } else {
#line 516
        type = (arg_type )15;
      }
#line 517
      goto switch_break;
      case_83: /* CIL Label */ 
#line 520
      type = (arg_type )16;
#line 521
      c = (char )'s';
#line 522
      goto switch_break;
      case_112: /* CIL Label */ 
#line 525
      type = (arg_type )17;
#line 526
      goto switch_break;
      case_110: /* CIL Label */ 
#line 530
      if (flags >= 16) {
#line 531
        type = (arg_type )22;
      } else
#line 530
      if (flags & 4) {
#line 531
        type = (arg_type )22;
      } else
#line 536
      if (flags >= 8) {
#line 537
        type = (arg_type )21;
      } else
#line 538
      if (flags & 2) {
#line 539
        type = (arg_type )18;
      } else
#line 540
      if (flags & 1) {
#line 541
        type = (arg_type )19;
      } else {
#line 543
        type = (arg_type )20;
      }
#line 544
      goto switch_break;
      case_37: /* CIL Label */ 
#line 557
      type = (arg_type )0;
#line 558
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 561
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 565
      if ((unsigned int )type != 0U) {
#line 567
        dp->arg_index = arg_index;
#line 568
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 570
          __cil_tmp77 = arg_posn;
#line 570
          arg_posn ++;
#line 570
          dp->arg_index = __cil_tmp77;
#line 571
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 573
            goto error;
          }
        }
#line 575
        n___4 = dp->arg_index;
#line 575
        if (n___4 >= a_allocated) {
#line 575
          if (a_allocated <= 9223372036854775807UL) {
#line 575
            tmp___33 = a_allocated * 2UL;
          } else {
#line 575
            tmp___33 = 0xffffffffffffffffUL;
          }
#line 575
          a_allocated = tmp___33;
#line 575
          if (a_allocated <= n___4) {
            {
#line 575
            a_allocated = xsum(n___4, (size_t )1);
            }
          }
#line 575
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 575
            tmp___34 = a_allocated * sizeof(argument );
          } else {
#line 575
            tmp___34 = 0xffffffffffffffffUL;
          }
#line 575
          memory_size___1 = tmp___34;
#line 575
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 575
            goto out_of_memory;
          }
#line 575
          if (a->arg != (argument *)a->direct_alloc_arg) {
            {
#line 575
            __cil_tmp84 = realloc((void *)a->arg, memory_size___1);
#line 575
            tmp___35 = __cil_tmp84;
            }
          } else {
            {
#line 575
            __cil_tmp85 = malloc(memory_size___1);
#line 575
            tmp___35 = __cil_tmp85;
            }
          }
#line 575
          memory___1 = (argument *)tmp___35;
#line 575
          if (memory___1 == (argument *)((void *)0)) {
#line 575
            goto out_of_memory;
          }
#line 575
          if (a->arg == (argument *)a->direct_alloc_arg) {
            {
#line 575
            memcpy((void *)memory___1, (void const   *)a->arg, a->count * sizeof(argument ));
            }
          }
#line 575
          a->arg = memory___1;
        }
        {
#line 575
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 575
          if (! (a->count <= n___4)) {
#line 575
            goto while_break___12;
          }
#line 575
          (a->arg + a->count)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 575
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 575
          (a->arg + n___4)->type = type;
        } else
#line 575
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 575
          goto error;
        }

      }
#line 577
      dp->conversion = c;
#line 578
      dp->dir_end = cp;
#line 581
      (d->count) ++;
#line 582
      if (d->count >= d_allocated) {
#line 587
        if (d_allocated <= 9223372036854775807UL) {
#line 587
          tmp___36 = d_allocated * 2UL;
        } else {
#line 587
          tmp___36 = 0xffffffffffffffffUL;
        }
#line 587
        d_allocated = tmp___36;
#line 588
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 588
          tmp___37 = d_allocated * sizeof(char_directive );
        } else {
#line 588
          tmp___37 = 0xffffffffffffffffUL;
        }
#line 588
        memory_size___2 = tmp___37;
#line 589
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 591
          goto out_of_memory;
        }
#line 592
        if (d->dir != (char_directive *)d->direct_alloc_dir) {
          {
#line 592
          __cil_tmp93 = realloc((void *)d->dir, memory_size___2);
#line 592
          tmp___38 = __cil_tmp93;
          }
        } else {
          {
#line 592
          __cil_tmp94 = malloc(memory_size___2);
#line 592
          tmp___38 = __cil_tmp94;
          }
        }
#line 592
        memory___2 = (char_directive *)tmp___38;
#line 595
        if (memory___2 == (char_directive *)((void *)0)) {
#line 597
          goto out_of_memory;
        }
#line 598
        if (d->dir == (char_directive *)d->direct_alloc_dir) {
          {
#line 599
          memcpy((void *)memory___2, (void const   *)d->dir, d->count * sizeof(char_directive ));
          }
        }
#line 600
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  (d->dir + d->count)->dir_start = cp;
#line 613
  d->max_width_length = max_width_length;
#line 614
  d->max_precision_length = max_precision_length;
#line 615
  return (0);
  error: 
#line 618
  if (a->arg != (argument *)a->direct_alloc_arg) {
    {
#line 619
    free((void *)a->arg);
    }
  }
#line 620
  if (d->dir != (char_directive *)d->direct_alloc_dir) {
    {
#line 621
    free((void *)d->dir);
    }
  }
  {
#line 622
  __cil_tmp96 = __errno_location();
#line 622
  *__cil_tmp96 = 22;
  }
#line 623
  return (- 1);
  out_of_memory: 
#line 626
  if (a->arg != (argument *)a->direct_alloc_arg) {
    {
#line 627
    free((void *)a->arg);
    }
  }
#line 628
  if (d->dir != (char_directive *)d->direct_alloc_dir) {
    {
#line 629
    free((void *)d->dir);
    }
  }
  {
#line 630
  __cil_tmp97 = __errno_location();
#line 630
  *__cil_tmp97 = 12;
  }
#line 631
  return (- 1);
}
}
#line 36 "/tmp/0/patch-2.7.1/lib/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  wint_t tmp ;
  static wchar_t wide_null_string[] ;
  size_t __cil_tmp7 ;
  argument *__cil_tmp8 ;

  {
#line 41
  ap = & *(a->arg + 0);
#line 41
  i = (size_t )0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < a->count)) {
#line 41
      goto while_break;
    }
    {
#line 44
    if ((unsigned int )ap->type == (unsigned int )1) {
#line 44
      goto case_1;
    }
#line 47
    if ((unsigned int )ap->type == (unsigned int )2) {
#line 47
      goto case_2;
    }
#line 50
    if ((unsigned int )ap->type == (unsigned int )3) {
#line 50
      goto case_3;
    }
#line 53
    if ((unsigned int )ap->type == (unsigned int )4) {
#line 53
      goto case_4;
    }
#line 56
    if ((unsigned int )ap->type == (unsigned int )5) {
#line 56
      goto case_5;
    }
#line 59
    if ((unsigned int )ap->type == (unsigned int )6) {
#line 59
      goto case_6;
    }
#line 62
    if ((unsigned int )ap->type == (unsigned int )7) {
#line 62
      goto case_7;
    }
#line 65
    if ((unsigned int )ap->type == (unsigned int )8) {
#line 65
      goto case_8;
    }
#line 69
    if ((unsigned int )ap->type == (unsigned int )9) {
#line 69
      goto case_9;
    }
#line 72
    if ((unsigned int )ap->type == (unsigned int )10) {
#line 72
      goto case_10;
    }
#line 76
    if ((unsigned int )ap->type == (unsigned int )11) {
#line 76
      goto case_11;
    }
#line 79
    if ((unsigned int )ap->type == (unsigned int )12) {
#line 79
      goto case_12;
    }
#line 82
    if ((unsigned int )ap->type == (unsigned int )13) {
#line 82
      goto case_13;
    }
#line 86
    if ((unsigned int )ap->type == (unsigned int )14) {
#line 86
      goto case_14;
    }
#line 96
    if ((unsigned int )ap->type == (unsigned int )15) {
#line 96
      goto case_15;
    }
#line 105
    if ((unsigned int )ap->type == (unsigned int )16) {
#line 105
      goto case_16;
    }
#line 123
    if ((unsigned int )ap->type == (unsigned int )17) {
#line 123
      goto case_17;
    }
#line 126
    if ((unsigned int )ap->type == (unsigned int )18) {
#line 126
      goto case_18;
    }
#line 129
    if ((unsigned int )ap->type == (unsigned int )19) {
#line 129
      goto case_19;
    }
#line 132
    if ((unsigned int )ap->type == (unsigned int )20) {
#line 132
      goto case_20;
    }
#line 135
    if ((unsigned int )ap->type == (unsigned int )21) {
#line 135
      goto case_21;
    }
#line 139
    if ((unsigned int )ap->type == (unsigned int )22) {
#line 139
      goto case_22;
    }
#line 182
    goto switch_default;
    case_1: /* CIL Label */ 
#line 45
    ap->a.a_schar = (signed char )0;
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
#line 48
    ap->a.a_uchar = (unsigned char )0;
#line 49
    goto switch_break;
    case_3: /* CIL Label */ 
#line 51
    ap->a.a_short = (short )0;
#line 52
    goto switch_break;
    case_4: /* CIL Label */ 
#line 54
    ap->a.a_ushort = (unsigned short )0;
#line 55
    goto switch_break;
    case_5: /* CIL Label */ 
#line 57
    ap->a.a_int = 0;
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
#line 60
    ap->a.a_uint = 0;
#line 61
    goto switch_break;
    case_7: /* CIL Label */ 
#line 63
    ap->a.a_longint = 0;
#line 64
    goto switch_break;
    case_8: /* CIL Label */ 
#line 66
    ap->a.a_ulongint = 0;
#line 67
    goto switch_break;
    case_9: /* CIL Label */ 
#line 70
    ap->a.a_longlongint = 0;
#line 71
    goto switch_break;
    case_10: /* CIL Label */ 
#line 73
    ap->a.a_ulonglongint = 0;
#line 74
    goto switch_break;
    case_11: /* CIL Label */ 
#line 77
    ap->a.a_double = 0;
#line 78
    goto switch_break;
    case_12: /* CIL Label */ 
#line 80
    ap->a.a_longdouble = 0;
#line 81
    goto switch_break;
    case_13: /* CIL Label */ 
#line 83
    ap->a.a_char = 0;
#line 84
    goto switch_break;
    case_14: /* CIL Label */ 
#line 90
    if (sizeof(wint_t ) < sizeof(int )) {
#line 90
      tmp = (wint_t )0;
    } else {
#line 90
      tmp = (wint_t )0;
    }
#line 90
    ap->a.a_wide_char = (int )tmp;
#line 94
    goto switch_break;
    case_15: /* CIL Label */ 
#line 97
    ap->a.a_string = 0;
#line 101
    if (ap->a.a_string == (char const   *)((void *)0)) {
#line 102
      ap->a.a_string = (char const   *)((char *)"(NULL)");
    }
#line 103
    goto switch_break;
    case_16: /* CIL Label */ 
#line 106
    ap->a.a_wide_string = 0;
#line 110
    if (ap->a.a_wide_string == (wchar_t *)((void *)0)) {
#line 119
      ap->a.a_wide_string = (wchar_t *)wide_null_string;
    }
#line 121
    goto switch_break;
    case_17: /* CIL Label */ 
#line 124
    ap->a.a_pointer = 0;
#line 125
    goto switch_break;
    case_18: /* CIL Label */ 
#line 127
    ap->a.a_count_schar_pointer = 0;
#line 128
    goto switch_break;
    case_19: /* CIL Label */ 
#line 130
    ap->a.a_count_short_pointer = 0;
#line 131
    goto switch_break;
    case_20: /* CIL Label */ 
#line 133
    ap->a.a_count_int_pointer = 0;
#line 134
    goto switch_break;
    case_21: /* CIL Label */ 
#line 136
    ap->a.a_count_longint_pointer = 0;
#line 137
    goto switch_break;
    case_22: /* CIL Label */ 
#line 140
    ap->a.a_count_longlongint_pointer = 0;
#line 141
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  __cil_tmp8 = ap;
#line 41
  ap ++;
#line 41
  __cil_tmp7 = i;
#line 41
  i ++;
#line 186
  return (0);
}
}
#line 21 "./unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int fd[2] ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 420
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 31 "/tmp/0/patch-2.7.1/lib/pipe-safer.c"
int pipe_safer(int fd[2] ) 
{ 
  int __cil_tmp2 ;
  int i ;
  int e ;
  int *__cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 34
  __cil_tmp2 = pipe(fd);
  }
#line 34
  if (__cil_tmp2 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      fd[i] = fd_safer(fd[i]);
      }
#line 40
      if (fd[i] < 0) {
        {
#line 42
        __cil_tmp6 = __errno_location();
#line 42
        e = *__cil_tmp6;
#line 43
        close(fd[1 - i]);
#line 44
        __cil_tmp7 = __errno_location();
#line 44
        *__cil_tmp7 = e;
        }
#line 45
        return (- 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 37
    i ++;
#line 49
    return (0);
  }
#line 55
  return (- 1);
}
}
#line 82 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 22 "./parse-datetime.h"
int parse_datetime(struct timespec *result , char const   *p , struct timespec *now ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 650
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 654
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 837
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 119 "parse-datetime.y"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 119
  return ((unsigned char )ch);
}
}
#line 217
static int yylex(YYSTYPE *lvalp , parser_control *pc ) ;
#line 218
static int yyerror(parser_control *pc , char const   *s ) ;
#line 219
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 225 "parse-datetime.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 227
  if (pc->dates_seen) {
#line 227
    if (! pc->year.digits) {
#line 227
      if (! pc->rels_seen) {
#line 227
        if (pc->times_seen) {
#line 229
          pc->year = text_int;
        } else
#line 227
        if (2UL < text_int.digits) {
#line 229
          pc->year = text_int;
        } else {
#line 227
          goto _L;
        }
      } else {
#line 227
        goto _L;
      }
    } else {
#line 227
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 232
  if (4UL < text_int.digits) {
#line 234
    (pc->dates_seen) ++;
#line 235
    pc->day = text_int.value % 100L;
#line 236
    pc->month = (text_int.value / 100L) % 100L;
#line 237
    pc->year.value = text_int.value / 10000L;
#line 238
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 242
    (pc->times_seen) ++;
#line 243
    if (text_int.digits <= 2UL) {
#line 245
      pc->hour = text_int.value;
#line 246
      pc->minutes = (long )0;
    } else {
#line 250
      pc->hour = text_int.value / 100L;
#line 251
      pc->minutes = text_int.value % 100L;
    }
#line 253
    pc->seconds.tv_sec = (__time_t )0;
#line 254
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 255
    pc->meridian = 2;
  }
}
}
#line 262 "parse-datetime.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 264
  pc->rel.ns += (long )factor * rel.ns;
#line 265
  pc->rel.seconds += (long )factor * rel.seconds;
#line 266
  pc->rel.minutes += (long )factor * rel.minutes;
#line 267
  pc->rel.hour += (long )factor * rel.hour;
#line 268
  pc->rel.day += (long )factor * rel.day;
#line 269
  pc->rel.month += (long )factor * rel.month;
#line 270
  pc->rel.year += (long )factor * rel.year;
#line 271
  pc->rels_seen = 1;
}
}
#line 276 "parse-datetime.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 279
  pc->hour = hour;
#line 280
  pc->minutes = minutes;
#line 281
  pc->seconds.tv_sec = sec;
#line 282
  pc->seconds.tv_nsec = nsec;
}
}
#line 696 "parse-datetime.c"
static yytype_uint8 yytranslate[]  = 
#line 696 "parse-datetime.c"
  {      (yytype_uint8 )0,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )26,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )27, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )25,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )23,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )24,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )3,      (yytype_uint8 )4, 
        (yytype_uint8 )5,      (yytype_uint8 )6,      (yytype_uint8 )7,      (yytype_uint8 )8, 
        (yytype_uint8 )9,      (yytype_uint8 )10,      (yytype_uint8 )11,      (yytype_uint8 )12, 
        (yytype_uint8 )13,      (yytype_uint8 )14,      (yytype_uint8 )15,      (yytype_uint8 )16, 
        (yytype_uint8 )17,      (yytype_uint8 )18,      (yytype_uint8 )19,      (yytype_uint8 )20, 
        (yytype_uint8 )21,      (yytype_uint8 )22};
#line 822 "parse-datetime.c"
static yytype_uint8 yyr1[]  = 
#line 822
  {      (yytype_uint8 )0,      (yytype_uint8 )28,      (yytype_uint8 )29,      (yytype_uint8 )29, 
        (yytype_uint8 )30,      (yytype_uint8 )31,      (yytype_uint8 )31,      (yytype_uint8 )32, 
        (yytype_uint8 )32,      (yytype_uint8 )32,      (yytype_uint8 )32,      (yytype_uint8 )32, 
        (yytype_uint8 )32,      (yytype_uint8 )32,      (yytype_uint8 )32,      (yytype_uint8 )32, 
        (yytype_uint8 )33,      (yytype_uint8 )34,      (yytype_uint8 )35,      (yytype_uint8 )35, 
        (yytype_uint8 )35,      (yytype_uint8 )35,      (yytype_uint8 )36,      (yytype_uint8 )36, 
        (yytype_uint8 )36,      (yytype_uint8 )37,      (yytype_uint8 )37,      (yytype_uint8 )38, 
        (yytype_uint8 )39,      (yytype_uint8 )39,      (yytype_uint8 )40,      (yytype_uint8 )40, 
        (yytype_uint8 )40,      (yytype_uint8 )40,      (yytype_uint8 )40,      (yytype_uint8 )40, 
        (yytype_uint8 )40,      (yytype_uint8 )41,      (yytype_uint8 )41,      (yytype_uint8 )41, 
        (yytype_uint8 )41,      (yytype_uint8 )42,      (yytype_uint8 )42,      (yytype_uint8 )42, 
        (yytype_uint8 )42,      (yytype_uint8 )42,      (yytype_uint8 )42,      (yytype_uint8 )42, 
        (yytype_uint8 )42,      (yytype_uint8 )42,      (yytype_uint8 )43,      (yytype_uint8 )44, 
        (yytype_uint8 )44,      (yytype_uint8 )44,      (yytype_uint8 )45,      (yytype_uint8 )45, 
        (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45, 
        (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45, 
        (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45, 
        (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45, 
        (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )45,      (yytype_uint8 )46, 
        (yytype_uint8 )46,      (yytype_uint8 )46,      (yytype_uint8 )46,      (yytype_uint8 )46, 
        (yytype_uint8 )46,      (yytype_uint8 )47,      (yytype_uint8 )48,      (yytype_uint8 )48, 
        (yytype_uint8 )49,      (yytype_uint8 )49,      (yytype_uint8 )50,      (yytype_uint8 )50, 
        (yytype_uint8 )51,      (yytype_uint8 )52,      (yytype_uint8 )53,      (yytype_uint8 )53};
#line 837 "parse-datetime.c"
static yytype_uint8 yyr2[]  = 
#line 837
  {      (yytype_uint8 )0,      (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )2,      (yytype_uint8 )0,      (yytype_uint8 )2,      (yytype_uint8 )1, 
        (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )1,      (yytype_uint8 )3,      (yytype_uint8 )2,      (yytype_uint8 )4, 
        (yytype_uint8 )6,      (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )4, 
        (yytype_uint8 )6,      (yytype_uint8 )0,      (yytype_uint8 )1,      (yytype_uint8 )2, 
        (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )3,      (yytype_uint8 )1, 
        (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )3,      (yytype_uint8 )5,      (yytype_uint8 )3, 
        (yytype_uint8 )3,      (yytype_uint8 )2,      (yytype_uint8 )4,      (yytype_uint8 )2, 
        (yytype_uint8 )3,      (yytype_uint8 )1,      (yytype_uint8 )3,      (yytype_uint8 )2, 
        (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )1, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2,      (yytype_uint8 )2, 
        (yytype_uint8 )2,      (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1,      (yytype_uint8 )1, 
        (yytype_uint8 )1,      (yytype_uint8 )2,      (yytype_uint8 )0,      (yytype_uint8 )2};
#line 854 "parse-datetime.c"
static yytype_uint8 yydefact[]  = 
#line 854
  {      (yytype_uint8 )5,      (yytype_uint8 )0,      (yytype_uint8 )0,      (yytype_uint8 )2, 
        (yytype_uint8 )3,      (yytype_uint8 )85,      (yytype_uint8 )87,      (yytype_uint8 )84, 
        (yytype_uint8 )86,      (yytype_uint8 )4,      (yytype_uint8 )82,      (yytype_uint8 )83, 
        (yytype_uint8 )1,      (yytype_uint8 )56,      (yytype_uint8 )59,      (yytype_uint8 )65, 
        (yytype_uint8 )68,      (yytype_uint8 )73,      (yytype_uint8 )62,      (yytype_uint8 )81, 
        (yytype_uint8 )37,      (yytype_uint8 )35,      (yytype_uint8 )28,      (yytype_uint8 )0, 
        (yytype_uint8 )0,      (yytype_uint8 )30,      (yytype_uint8 )0,      (yytype_uint8 )88, 
        (yytype_uint8 )0,      (yytype_uint8 )0,      (yytype_uint8 )31,      (yytype_uint8 )6, 
        (yytype_uint8 )7,      (yytype_uint8 )16,      (yytype_uint8 )8,      (yytype_uint8 )21, 
        (yytype_uint8 )9,      (yytype_uint8 )10,      (yytype_uint8 )12,      (yytype_uint8 )11, 
        (yytype_uint8 )49,      (yytype_uint8 )13,      (yytype_uint8 )52,      (yytype_uint8 )74, 
        (yytype_uint8 )53,      (yytype_uint8 )14,      (yytype_uint8 )15,      (yytype_uint8 )38, 
        (yytype_uint8 )29,      (yytype_uint8 )0,      (yytype_uint8 )45,      (yytype_uint8 )54, 
        (yytype_uint8 )57,      (yytype_uint8 )63,      (yytype_uint8 )66,      (yytype_uint8 )69, 
        (yytype_uint8 )60,      (yytype_uint8 )39,      (yytype_uint8 )36,      (yytype_uint8 )90, 
        (yytype_uint8 )32,      (yytype_uint8 )75,      (yytype_uint8 )76,      (yytype_uint8 )78, 
        (yytype_uint8 )79,      (yytype_uint8 )80,      (yytype_uint8 )77,      (yytype_uint8 )55, 
        (yytype_uint8 )58,      (yytype_uint8 )64,      (yytype_uint8 )67,      (yytype_uint8 )70, 
        (yytype_uint8 )61,      (yytype_uint8 )40,      (yytype_uint8 )18,      (yytype_uint8 )47, 
        (yytype_uint8 )90,      (yytype_uint8 )0,      (yytype_uint8 )0,      (yytype_uint8 )22, 
        (yytype_uint8 )89,      (yytype_uint8 )71,      (yytype_uint8 )72,      (yytype_uint8 )33, 
        (yytype_uint8 )0,      (yytype_uint8 )51,      (yytype_uint8 )44,      (yytype_uint8 )0, 
        (yytype_uint8 )0,      (yytype_uint8 )34,      (yytype_uint8 )43,      (yytype_uint8 )48, 
        (yytype_uint8 )50,      (yytype_uint8 )27,      (yytype_uint8 )25,      (yytype_uint8 )41, 
        (yytype_uint8 )0,      (yytype_uint8 )17,      (yytype_uint8 )46,      (yytype_uint8 )91, 
        (yytype_uint8 )19,      (yytype_uint8 )90,      (yytype_uint8 )0,      (yytype_uint8 )23, 
        (yytype_uint8 )26,      (yytype_uint8 )0,      (yytype_uint8 )0,      (yytype_uint8 )25, 
        (yytype_uint8 )42,      (yytype_uint8 )25,      (yytype_uint8 )20,      (yytype_uint8 )24, 
        (yytype_uint8 )0,      (yytype_uint8 )25};
#line 871 "parse-datetime.c"
static yytype_int8 yydefgoto[]  = 
#line 871
  {      (yytype_int8 )(- 1),      (yytype_int8 )2,      (yytype_int8 )3,      (yytype_int8 )4, 
        (yytype_int8 )31,      (yytype_int8 )32,      (yytype_int8 )33,      (yytype_int8 )34, 
        (yytype_int8 )35,      (yytype_int8 )103,      (yytype_int8 )104,      (yytype_int8 )36, 
        (yytype_int8 )37,      (yytype_int8 )38,      (yytype_int8 )39,      (yytype_int8 )40, 
        (yytype_int8 )41,      (yytype_int8 )42,      (yytype_int8 )43,      (yytype_int8 )44, 
        (yytype_int8 )9,      (yytype_int8 )10,      (yytype_int8 )11,      (yytype_int8 )45, 
        (yytype_int8 )46,      (yytype_int8 )93};
#line 881 "parse-datetime.c"
static yytype_int8 yypact[]  = 
#line 881
  {      (yytype_int8 )38,      (yytype_int8 )27,      (yytype_int8 )77,      (yytype_int8 )(- 93), 
        (yytype_int8 )46,      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )62,      (yytype_int8 )(- 93),      (yytype_int8 )82,      (yytype_int8 )(- 3), 
        (yytype_int8 )66,      (yytype_int8 )3,      (yytype_int8 )74,      (yytype_int8 )(- 4), 
        (yytype_int8 )83,      (yytype_int8 )84,      (yytype_int8 )75,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )71,      (yytype_int8 )(- 93),      (yytype_int8 )93,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )78,      (yytype_int8 )72,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )25, 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )21, 
        (yytype_int8 )19,      (yytype_int8 )79,      (yytype_int8 )80,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )81,      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )85, 
        (yytype_int8 )86,      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 6),      (yytype_int8 )76, 
        (yytype_int8 )17,      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )87,      (yytype_int8 )69,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )88,      (yytype_int8 )89,      (yytype_int8 )(- 1), 
        (yytype_int8 )(- 93),      (yytype_int8 )18,      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )69,      (yytype_int8 )91};
#line 898 "parse-datetime.c"
static yytype_int8 yypgoto[]  = 
#line 898
  {      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )20,      (yytype_int8 )(- 68),      (yytype_int8 )(- 27),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )60,      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )(- 93),      (yytype_int8 )(- 92),      (yytype_int8 )(- 93), 
        (yytype_int8 )(- 93),      (yytype_int8 )43};
#line 909 "parse-datetime.c"
static yytype_uint8 yytable[]  = 
#line 909
  {      (yytype_uint8 )79,      (yytype_uint8 )67,      (yytype_uint8 )68,      (yytype_uint8 )69, 
        (yytype_uint8 )70,      (yytype_uint8 )71,      (yytype_uint8 )72,      (yytype_uint8 )58, 
        (yytype_uint8 )73,      (yytype_uint8 )100,      (yytype_uint8 )107,      (yytype_uint8 )74, 
        (yytype_uint8 )75,      (yytype_uint8 )101,      (yytype_uint8 )110,      (yytype_uint8 )76, 
        (yytype_uint8 )49,      (yytype_uint8 )50,      (yytype_uint8 )101,      (yytype_uint8 )102, 
        (yytype_uint8 )113,      (yytype_uint8 )77,      (yytype_uint8 )59,      (yytype_uint8 )78, 
        (yytype_uint8 )61,      (yytype_uint8 )62,      (yytype_uint8 )63,      (yytype_uint8 )64, 
        (yytype_uint8 )65,      (yytype_uint8 )66,      (yytype_uint8 )61,      (yytype_uint8 )62, 
        (yytype_uint8 )63,      (yytype_uint8 )64,      (yytype_uint8 )65,      (yytype_uint8 )66, 
        (yytype_uint8 )101,      (yytype_uint8 )101,      (yytype_uint8 )92,      (yytype_uint8 )111, 
        (yytype_uint8 )90,      (yytype_uint8 )91,      (yytype_uint8 )106,      (yytype_uint8 )112, 
        (yytype_uint8 )88,      (yytype_uint8 )111,      (yytype_uint8 )5,      (yytype_uint8 )6, 
        (yytype_uint8 )7,      (yytype_uint8 )8,      (yytype_uint8 )88,      (yytype_uint8 )13, 
        (yytype_uint8 )14,      (yytype_uint8 )15,      (yytype_uint8 )16,      (yytype_uint8 )17, 
        (yytype_uint8 )18,      (yytype_uint8 )19,      (yytype_uint8 )20,      (yytype_uint8 )21, 
        (yytype_uint8 )22,      (yytype_uint8 )1,      (yytype_uint8 )23,      (yytype_uint8 )24, 
        (yytype_uint8 )25,      (yytype_uint8 )26,      (yytype_uint8 )27,      (yytype_uint8 )28, 
        (yytype_uint8 )29,      (yytype_uint8 )79,      (yytype_uint8 )30,      (yytype_uint8 )51, 
        (yytype_uint8 )52,      (yytype_uint8 )53,      (yytype_uint8 )54,      (yytype_uint8 )55, 
        (yytype_uint8 )56,      (yytype_uint8 )12,      (yytype_uint8 )57,      (yytype_uint8 )61, 
        (yytype_uint8 )62,      (yytype_uint8 )63,      (yytype_uint8 )64,      (yytype_uint8 )65, 
        (yytype_uint8 )66,      (yytype_uint8 )60,      (yytype_uint8 )48,      (yytype_uint8 )80, 
        (yytype_uint8 )47,      (yytype_uint8 )6,      (yytype_uint8 )83,      (yytype_uint8 )8, 
        (yytype_uint8 )81,      (yytype_uint8 )82,      (yytype_uint8 )26,      (yytype_uint8 )84, 
        (yytype_uint8 )85,      (yytype_uint8 )86,      (yytype_uint8 )87,      (yytype_uint8 )94, 
        (yytype_uint8 )95,      (yytype_uint8 )96,      (yytype_uint8 )89,      (yytype_uint8 )105, 
        (yytype_uint8 )97,      (yytype_uint8 )98,      (yytype_uint8 )99,      (yytype_uint8 )0, 
        (yytype_uint8 )108,      (yytype_uint8 )109,      (yytype_uint8 )101,      (yytype_uint8 )0, 
        (yytype_uint8 )88};
#line 931 "parse-datetime.c"
static yytype_int8 yycheck[]  = 
#line 931
  {      (yytype_int8 )27,      (yytype_int8 )5,      (yytype_int8 )6,      (yytype_int8 )7, 
        (yytype_int8 )8,      (yytype_int8 )9,      (yytype_int8 )10,      (yytype_int8 )4, 
        (yytype_int8 )12,      (yytype_int8 )15,      (yytype_int8 )102,      (yytype_int8 )15, 
        (yytype_int8 )16,      (yytype_int8 )19,      (yytype_int8 )15,      (yytype_int8 )19, 
        (yytype_int8 )19,      (yytype_int8 )20,      (yytype_int8 )19,      (yytype_int8 )25, 
        (yytype_int8 )112,      (yytype_int8 )25,      (yytype_int8 )19,      (yytype_int8 )27, 
        (yytype_int8 )5,      (yytype_int8 )6,      (yytype_int8 )7,      (yytype_int8 )8, 
        (yytype_int8 )9,      (yytype_int8 )10,      (yytype_int8 )5,      (yytype_int8 )6, 
        (yytype_int8 )7,      (yytype_int8 )8,      (yytype_int8 )9,      (yytype_int8 )10, 
        (yytype_int8 )19,      (yytype_int8 )19,      (yytype_int8 )19,      (yytype_int8 )107, 
        (yytype_int8 )19,      (yytype_int8 )20,      (yytype_int8 )25,      (yytype_int8 )25, 
        (yytype_int8 )25,      (yytype_int8 )113,      (yytype_int8 )19,      (yytype_int8 )20, 
        (yytype_int8 )21,      (yytype_int8 )22,      (yytype_int8 )25,      (yytype_int8 )5, 
        (yytype_int8 )6,      (yytype_int8 )7,      (yytype_int8 )8,      (yytype_int8 )9, 
        (yytype_int8 )10,      (yytype_int8 )11,      (yytype_int8 )12,      (yytype_int8 )13, 
        (yytype_int8 )14,      (yytype_int8 )23,      (yytype_int8 )16,      (yytype_int8 )17, 
        (yytype_int8 )18,      (yytype_int8 )19,      (yytype_int8 )20,      (yytype_int8 )21, 
        (yytype_int8 )22,      (yytype_int8 )96,      (yytype_int8 )24,      (yytype_int8 )5, 
        (yytype_int8 )6,      (yytype_int8 )7,      (yytype_int8 )8,      (yytype_int8 )9, 
        (yytype_int8 )10,      (yytype_int8 )0,      (yytype_int8 )12,      (yytype_int8 )5, 
        (yytype_int8 )6,      (yytype_int8 )7,      (yytype_int8 )8,      (yytype_int8 )9, 
        (yytype_int8 )10,      (yytype_int8 )25,      (yytype_int8 )4,      (yytype_int8 )27, 
        (yytype_int8 )26,      (yytype_int8 )20,      (yytype_int8 )30,      (yytype_int8 )22, 
        (yytype_int8 )9,      (yytype_int8 )9,      (yytype_int8 )19,      (yytype_int8 )24, 
        (yytype_int8 )3,      (yytype_int8 )19,      (yytype_int8 )26,      (yytype_int8 )20, 
        (yytype_int8 )20,      (yytype_int8 )20,      (yytype_int8 )59,      (yytype_int8 )27, 
        (yytype_int8 )84,      (yytype_int8 )20,      (yytype_int8 )20,      (yytype_int8 )(- 1), 
        (yytype_int8 )20,      (yytype_int8 )20,      (yytype_int8 )19,      (yytype_int8 )(- 1), 
        (yytype_int8 )25};
#line 949 "parse-datetime.c"
static yytype_uint8 yystos[]  = 
#line 949
  {      (yytype_uint8 )0,      (yytype_uint8 )23,      (yytype_uint8 )29,      (yytype_uint8 )30, 
        (yytype_uint8 )31,      (yytype_uint8 )19,      (yytype_uint8 )20,      (yytype_uint8 )21, 
        (yytype_uint8 )22,      (yytype_uint8 )48,      (yytype_uint8 )49,      (yytype_uint8 )50, 
        (yytype_uint8 )0,      (yytype_uint8 )5,      (yytype_uint8 )6,      (yytype_uint8 )7, 
        (yytype_uint8 )8,      (yytype_uint8 )9,      (yytype_uint8 )10,      (yytype_uint8 )11, 
        (yytype_uint8 )12,      (yytype_uint8 )13,      (yytype_uint8 )14,      (yytype_uint8 )16, 
        (yytype_uint8 )17,      (yytype_uint8 )18,      (yytype_uint8 )19,      (yytype_uint8 )20, 
        (yytype_uint8 )21,      (yytype_uint8 )22,      (yytype_uint8 )24,      (yytype_uint8 )32, 
        (yytype_uint8 )33,      (yytype_uint8 )34,      (yytype_uint8 )35,      (yytype_uint8 )36, 
        (yytype_uint8 )39,      (yytype_uint8 )40,      (yytype_uint8 )41,      (yytype_uint8 )42, 
        (yytype_uint8 )43,      (yytype_uint8 )44,      (yytype_uint8 )45,      (yytype_uint8 )46, 
        (yytype_uint8 )47,      (yytype_uint8 )51,      (yytype_uint8 )52,      (yytype_uint8 )26, 
        (yytype_uint8 )4,      (yytype_uint8 )19,      (yytype_uint8 )20,      (yytype_uint8 )5, 
        (yytype_uint8 )6,      (yytype_uint8 )7,      (yytype_uint8 )8,      (yytype_uint8 )9, 
        (yytype_uint8 )10,      (yytype_uint8 )12,      (yytype_uint8 )4,      (yytype_uint8 )19, 
        (yytype_uint8 )46,      (yytype_uint8 )5,      (yytype_uint8 )6,      (yytype_uint8 )7, 
        (yytype_uint8 )8,      (yytype_uint8 )9,      (yytype_uint8 )10,      (yytype_uint8 )5, 
        (yytype_uint8 )6,      (yytype_uint8 )7,      (yytype_uint8 )8,      (yytype_uint8 )9, 
        (yytype_uint8 )10,      (yytype_uint8 )12,      (yytype_uint8 )15,      (yytype_uint8 )16, 
        (yytype_uint8 )19,      (yytype_uint8 )25,      (yytype_uint8 )27,      (yytype_uint8 )38, 
        (yytype_uint8 )46,      (yytype_uint8 )9,      (yytype_uint8 )9,      (yytype_uint8 )46, 
        (yytype_uint8 )24,      (yytype_uint8 )3,      (yytype_uint8 )19,      (yytype_uint8 )26, 
        (yytype_uint8 )25,      (yytype_uint8 )53,      (yytype_uint8 )19,      (yytype_uint8 )20, 
        (yytype_uint8 )19,      (yytype_uint8 )53,      (yytype_uint8 )20,      (yytype_uint8 )20, 
        (yytype_uint8 )20,      (yytype_uint8 )36,      (yytype_uint8 )20,      (yytype_uint8 )20, 
        (yytype_uint8 )15,      (yytype_uint8 )19,      (yytype_uint8 )25,      (yytype_uint8 )37, 
        (yytype_uint8 )38,      (yytype_uint8 )27,      (yytype_uint8 )25,      (yytype_uint8 )50, 
        (yytype_uint8 )20,      (yytype_uint8 )20,      (yytype_uint8 )15,      (yytype_uint8 )37, 
        (yytype_uint8 )25,      (yytype_uint8 )50};
#line 1485 "parse-datetime.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 


  {
#line 1498
  if (! yymsg) {
#line 1499
    yymsg = (char const   *)((char *)"Deleting");
  }

  {
#line 1505
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1506
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1520
int yyparse(parser_control *pc ) ;
#line 1545 "parse-datetime.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *__cil_tmp23 ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int tmp ;
  int __cil_tmp28 ;
  long __cil_tmp38 ;
  int tmp___0 ;
  int tmp___38 ;
  int tmp___39 ;

  {
#line 1604
  yylen = 0;
#line 1606
  yytoken = 0;
#line 1607
  yyss = (yytype_int16 *)yyssa;
#line 1608
  yyvs = (YYSTYPE *)yyvsa;
#line 1609
  yystacksize = (unsigned long )20;
#line 1613
  yystate = 0;
#line 1614
  yyerrstatus = 0;
#line 1615
  yynerrs = 0;
#line 1616
  yychar = - 2;
#line 1622
  yyssp = yyss;
#line 1623
  yyvsp = yyvs;
#line 1625
  goto yysetstate;
  yynewstate: 
#line 1633
  yyssp ++;
  yysetstate: 
#line 1636
  *yyssp = (yytype_int16 )yystate;
#line 1638
  if ((yyss + yystacksize) - 1 <= yyssp) {
#line 1641
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1668
    if (20UL <= yystacksize) {
#line 1669
      goto yyexhaustedlab;
    }
#line 1670
    yystacksize *= (unsigned long )2;
#line 1671
    if (20UL < yystacksize) {
#line 1672
      yystacksize = (unsigned long )20;
    }
    {
#line 1675
    yyss1 = yyss;
#line 1676
    __cil_tmp23 = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1676
    yyptr = (union yyalloc *)__cil_tmp23;
    }
#line 1678
    if (! yyptr) {
#line 1679
      goto yyexhaustedlab;
    }
    {
#line 1680
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1680
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1680
      yyss = & yyptr->yyss_alloc;
#line 1680
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1680
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1680
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1681
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1681
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1681
      yyvs = & yyptr->yyvs_alloc;
#line 1681
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1681
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1681
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1683
    if (yyss1 != (yytype_int16 *)yyssa) {
      {
#line 1684
      free((void *)yyss1);
      }
    }
#line 1689
    yyssp = (yyss + yysize) - 1;
#line 1690
    yyvsp = (yyvs + yysize) - 1;
#line 1695
    if ((yyss + yystacksize) - 1 <= yyssp) {
#line 1696
      goto yyabortlab;
    }
  }

#line 1701
  if (yystate == 12) {
#line 1702
    goto yyacceptlab;
  }
#line 1704
  goto yybackup;
  yybackup: 
#line 1715
  yyn = (int )yypact[yystate];
#line 1716
  if (yyn == -93) {
#line 1717
    goto yydefault;
  }
#line 1722
  if (yychar == -2) {
    {
#line 1725
    yychar = yylex(& yylval, pc);
    }
  }
#line 1728
  if (yychar <= 0) {
#line 1730
    yytoken = 0;
#line 1730
    yychar = yytoken;
  } else {
#line 1735
    if ((unsigned int )yychar <= 277U) {
#line 1735
      tmp = (int )yytranslate[yychar];
    } else {
#line 1735
      tmp = 2;
    }
#line 1735
    yytoken = tmp;
  }
#line 1741
  yyn += yytoken;
#line 1742
  if (yyn < 0) {
#line 1743
    goto yydefault;
  } else
#line 1742
  if (112 < yyn) {
#line 1743
    goto yydefault;
  } else
#line 1742
  if ((int )yycheck[yyn] != yytoken) {
#line 1743
    goto yydefault;
  }
#line 1744
  yyn = (int )yytable[yyn];
#line 1745
  if (yyn <= 0) {
#line 1747
    if (0) {
#line 1748
      goto yyerrlab;
    }
#line 1749
    yyn = - yyn;
#line 1750
    goto yyreduce;
  }
#line 1755
  if (yyerrstatus) {
#line 1756
    __cil_tmp28 = yyerrstatus;
#line 1756
    yyerrstatus --;
  }
#line 1762
  yychar = - 2;
#line 1764
  yystate = yyn;
#line 1765
  yyvsp ++;
#line 1765
  *yyvsp = yylval;
#line 1767
  goto yynewstate;
  yydefault: 
#line 1774
  yyn = (int )yydefact[yystate];
#line 1775
  if (yyn == 0) {
#line 1776
    goto yyerrlab;
  }
#line 1777
  goto yyreduce;
  yyreduce: 
#line 1785
  yylen = (int )yyr2[yyn];
#line 1795
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1801
  if (yyn == 4) {
#line 1801
    goto case_4;
  }
#line 336
  if (yyn == 7) {
#line 336 "parse-datetime.y"
    goto case_7;
  }
#line 346
  if (yyn == 8) {
#line 346
    goto case_8;
  }
#line 348
  if (yyn == 9) {
#line 348
    goto case_9;
  }
#line 350
  if (yyn == 10) {
#line 350
    goto case_10;
  }
#line 352
  if (yyn == 11) {
#line 352
    goto case_11;
  }
#line 354
  if (yyn == 12) {
#line 354
    goto case_12;
  }
#line 356
  if (yyn == 18) {
#line 356
    goto case_18;
  }
#line 375
  if (yyn == 19) {
#line 375
    goto case_19;
  }
#line 380
  if (yyn == 20) {
#line 380
    goto case_20;
  }
#line 385
  if (yyn == 22) {
#line 385
    goto case_22;
  }
#line 394
  if (yyn == 23) {
#line 394
    goto case_23;
  }
#line 399
  if (yyn == 24) {
#line 399
    goto case_24;
  }
#line 404
  if (yyn == 27) {
#line 404
    goto case_27;
  }
#line 417
  if (yyn == 28) {
#line 417
    goto case_28;
  }
#line 425
  if (yyn == 29) {
#line 425
    goto case_29;
  }
#line 430
  if (yyn == 30) {
#line 430
    goto case_30;
  }
#line 437
  if (yyn == 31) {
#line 437
    goto case_31;
  }
#line 439
  if (yyn == 32) {
#line 439
    goto case_32;
  }
#line 442
  if (yyn == 33) {
#line 442
    goto case_33;
  }
#line 445
  if (yyn == 34) {
#line 445
    goto case_34;
  }
#line 447
  if (yyn == 35) {
#line 447
    goto case_35;
  }
#line 449
  if (yyn == 36) {
#line 449
    goto case_36;
  }
#line 451
  if (yyn == 37) {
#line 451
    goto case_37;
  }
#line 459
  if (yyn == 38) {
#line 459
    goto case_38;
  }
#line 464
  if (yyn == 39) {
#line 464
    goto case_39;
  }
#line 469
  if (yyn == 40) {
#line 469
    goto case_40;
  }
#line 474
  if (yyn == 41) {
#line 474
    goto case_41;
  }
#line 482
  if (yyn == 42) {
#line 482
    goto case_42;
  }
#line 502
  if (yyn == 43) {
#line 502
    goto case_43;
  }
#line 510
  if (yyn == 44) {
#line 510
    goto case_44;
  }
#line 518
  if (yyn == 45) {
#line 518
    goto case_45;
  }
#line 523
  if (yyn == 46) {
#line 523
    goto case_46;
  }
#line 529
  if (yyn == 47) {
#line 529
    goto case_47;
  }
#line 534
  if (yyn == 48) {
#line 534
    goto case_48;
  }
#line 540
  if (yyn == 50) {
#line 540
    goto case_50;
  }
#line 551
  if (yyn == 51) {
#line 551
    goto case_51;
  }
#line 556
  if (yyn == 52) {
#line 556
    goto case_52;
  }
#line 558
  if (yyn == 53) {
#line 558
    goto case_53;
  }
#line 560
  if (yyn == 54) {
#line 560
    goto case_54;
  }
#line 565
  if (yyn == 55) {
#line 565
    goto case_55;
  }
#line 567
  if (yyn == 56) {
#line 567
    goto case_56;
  }
#line 569
  if (yyn == 57) {
#line 569
    goto case_57;
  }
#line 571
  if (yyn == 58) {
#line 571
    goto case_58;
  }
#line 573
  if (yyn == 59) {
#line 573
    goto case_59;
  }
#line 575
  if (yyn == 60) {
#line 575
    goto case_60;
  }
#line 577
  if (yyn == 61) {
#line 577
    goto case_61;
  }
#line 579
  if (yyn == 62) {
#line 579
    goto case_62;
  }
#line 581
  if (yyn == 63) {
#line 581
    goto case_63;
  }
#line 583
  if (yyn == 64) {
#line 583
    goto case_64;
  }
#line 585
  if (yyn == 65) {
#line 585
    goto case_65;
  }
#line 587
  if (yyn == 66) {
#line 587
    goto case_66;
  }
#line 589
  if (yyn == 67) {
#line 589
    goto case_67;
  }
#line 591
  if (yyn == 68) {
#line 591
    goto case_68;
  }
#line 593
  if (yyn == 69) {
#line 593
    goto case_69;
  }
#line 595
  if (yyn == 70) {
#line 595
    goto case_70;
  }
#line 597
  if (yyn == 71) {
#line 597
    goto case_71;
  }
#line 599
  if (yyn == 72) {
#line 599
    goto case_72;
  }
#line 601
  if (yyn == 73) {
#line 601
    goto case_73;
  }
#line 603
  if (yyn == 75) {
#line 603
    goto case_75;
  }
#line 609
  if (yyn == 76) {
#line 609
    goto case_76;
  }
#line 611
  if (yyn == 77) {
#line 611
    goto case_77;
  }
#line 613
  if (yyn == 78) {
#line 613
    goto case_78;
  }
#line 615
  if (yyn == 79) {
#line 615
    goto case_79;
  }
#line 617
  if (yyn == 80) {
#line 617
    goto case_80;
  }
#line 619
  if (yyn == 81) {
#line 619
    goto case_81;
  }
#line 624
  if (yyn == 85) {
#line 624
    goto case_85;
  }
#line 632
  if (yyn == 87) {
#line 632
    goto case_87;
  }
#line 638
  if (yyn == 88) {
#line 638
    goto case_88;
  }
#line 643
  if (yyn == 89) {
#line 643
    goto case_89;
  }
#line 653
  if (yyn == 90) {
#line 653
    goto case_90;
  }
#line 658
  if (yyn == 91) {
#line 658
    goto case_91;
  }
#line 2410 "parse-datetime.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 331 "parse-datetime.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 332
  pc->timespec_seen = 1;
#line 334
  goto switch_break;
  case_7: /* CIL Label */ 
#line 343
  (pc->times_seen) ++;
#line 343
  (pc->dates_seen) ++;
#line 344
  goto switch_break;
  case_8: /* CIL Label */ 
#line 345
  (pc->times_seen) ++;
#line 346
  goto switch_break;
  case_9: /* CIL Label */ 
#line 347
  (pc->local_zones_seen) ++;
#line 348
  goto switch_break;
  case_10: /* CIL Label */ 
#line 349
  (pc->zones_seen) ++;
#line 350
  goto switch_break;
  case_11: /* CIL Label */ 
#line 351
  (pc->dates_seen) ++;
#line 352
  goto switch_break;
  case_12: /* CIL Label */ 
#line 353
  (pc->days_seen) ++;
#line 354
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 370
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, (long )0, (time_t )0, (long )0);
#line 371
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 373
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 375
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             (long )0);
#line 376
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 378
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 380
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 381
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 383
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 389
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, (long )0, (time_t )0, (long )0);
#line 390
  pc->meridian = 2;
  }
#line 392
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 394
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             (long )0);
#line 395
  pc->meridian = 2;
  }
#line 397
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 399
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 400
  pc->meridian = 2;
  }
#line 402
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 412
  (pc->zones_seen) ++;
#line 413
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 415
  goto switch_break;
  case_28: /* CIL Label */ 
#line 420
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 421
  pc->dsts_seen += (unsigned long )(0L < (yyvsp + 0)->intval);
#line 423
  goto switch_break;
  case_29: /* CIL Label */ 
#line 425
  pc->local_isdst = 1;
#line 426
  pc->dsts_seen += (unsigned long )((0L < (yyvsp + -1)->intval) + 1);
#line 428
  goto switch_break;
  case_30: /* CIL Label */ 
#line 434
  pc->time_zone = (yyvsp + 0)->intval;
#line 435
  goto switch_break;
  case_31: /* CIL Label */ 
#line 436
  pc->time_zone = (long )420;
#line 437
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 438
  pc->time_zone = (yyvsp + -1)->intval;
#line 439
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 440
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 441
  pc->time_zone = (long )420;
#line 442
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 443
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 444
  __cil_tmp38 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 444
  pc->time_zone = (yyvsp + -2)->intval + __cil_tmp38;
  }
#line 445
  goto switch_break;
  case_35: /* CIL Label */ 
#line 446
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 447
  goto switch_break;
  case_36: /* CIL Label */ 
#line 448
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 449
  goto switch_break;
  case_37: /* CIL Label */ 
#line 454
  pc->day_ordinal = (long )0;
#line 455
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 457
  goto switch_break;
  case_38: /* CIL Label */ 
#line 459
  pc->day_ordinal = (long )0;
#line 460
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 462
  goto switch_break;
  case_39: /* CIL Label */ 
#line 464
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 465
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 467
  goto switch_break;
  case_40: /* CIL Label */ 
#line 469
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 470
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 472
  goto switch_break;
  case_41: /* CIL Label */ 
#line 477
  pc->month = (yyvsp + -2)->textintval.value;
#line 478
  pc->day = (yyvsp + 0)->textintval.value;
#line 480
  goto switch_break;
  case_42: /* CIL Label */ 
#line 487
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 489
    pc->year = (yyvsp + -4)->textintval;
#line 490
    pc->month = (yyvsp + -2)->textintval.value;
#line 491
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 495
    pc->month = (yyvsp + -4)->textintval.value;
#line 496
    pc->day = (yyvsp + -2)->textintval.value;
#line 497
    pc->year = (yyvsp + 0)->textintval;
  }
#line 500
  goto switch_break;
  case_43: /* CIL Label */ 
#line 503
  pc->day = (yyvsp + -2)->textintval.value;
#line 504
  pc->month = (yyvsp + -1)->intval;
#line 505
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 506
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 508
  goto switch_break;
  case_44: /* CIL Label */ 
#line 511
  pc->month = (yyvsp + -2)->intval;
#line 512
  pc->day = - (yyvsp + -1)->textintval.value;
#line 513
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 514
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 516
  goto switch_break;
  case_45: /* CIL Label */ 
#line 518
  pc->month = (yyvsp + -1)->intval;
#line 519
  pc->day = (yyvsp + 0)->textintval.value;
#line 521
  goto switch_break;
  case_46: /* CIL Label */ 
#line 523
  pc->month = (yyvsp + -3)->intval;
#line 524
  pc->day = (yyvsp + -2)->textintval.value;
#line 525
  pc->year = (yyvsp + 0)->textintval;
#line 527
  goto switch_break;
  case_47: /* CIL Label */ 
#line 529
  pc->day = (yyvsp + -1)->textintval.value;
#line 530
  pc->month = (yyvsp + 0)->intval;
#line 532
  goto switch_break;
  case_48: /* CIL Label */ 
#line 534
  pc->day = (yyvsp + -2)->textintval.value;
#line 535
  pc->month = (yyvsp + -1)->intval;
#line 536
  pc->year = (yyvsp + 0)->textintval;
#line 538
  goto switch_break;
  case_50: /* CIL Label */ 
#line 545
  pc->year = (yyvsp + -2)->textintval;
#line 546
  pc->month = - (yyvsp + -1)->textintval.value;
#line 547
  pc->day = - (yyvsp + 0)->textintval.value;
#line 549
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 553
  apply_relative_time(pc, (yyvsp + -1)->rel, (int )(yyvsp + 0)->intval);
  }
#line 554
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 555
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 556
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 557
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 558
  goto switch_break;
  case_54: /* CIL Label */ 
#line 562
  yyval.rel = (relative_time )0;
#line 562
  yyval.rel.year = (yyvsp + -1)->intval;
#line 563
  goto switch_break;
  case_55: /* CIL Label */ 
#line 564
  yyval.rel = (relative_time )0;
#line 564
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 565
  goto switch_break;
  case_56: /* CIL Label */ 
#line 566
  yyval.rel = (relative_time )0;
#line 566
  yyval.rel.year = (long )1;
#line 567
  goto switch_break;
  case_57: /* CIL Label */ 
#line 568
  yyval.rel = (relative_time )0;
#line 568
  yyval.rel.month = (yyvsp + -1)->intval;
#line 569
  goto switch_break;
  case_58: /* CIL Label */ 
#line 570
  yyval.rel = (relative_time )0;
#line 570
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 571
  goto switch_break;
  case_59: /* CIL Label */ 
#line 572
  yyval.rel = (relative_time )0;
#line 572
  yyval.rel.month = (long )1;
#line 573
  goto switch_break;
  case_60: /* CIL Label */ 
#line 574
  yyval.rel = (relative_time )0;
#line 574
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 575
  goto switch_break;
  case_61: /* CIL Label */ 
#line 576
  yyval.rel = (relative_time )0;
#line 576
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 577
  goto switch_break;
  case_62: /* CIL Label */ 
#line 578
  yyval.rel = (relative_time )0;
#line 578
  yyval.rel.day = (yyvsp + 0)->intval;
#line 579
  goto switch_break;
  case_63: /* CIL Label */ 
#line 580
  yyval.rel = (relative_time )0;
#line 580
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 581
  goto switch_break;
  case_64: /* CIL Label */ 
#line 582
  yyval.rel = (relative_time )0;
#line 582
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 583
  goto switch_break;
  case_65: /* CIL Label */ 
#line 584
  yyval.rel = (relative_time )0;
#line 584
  yyval.rel.hour = (long )1;
#line 585
  goto switch_break;
  case_66: /* CIL Label */ 
#line 586
  yyval.rel = (relative_time )0;
#line 586
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 587
  goto switch_break;
  case_67: /* CIL Label */ 
#line 588
  yyval.rel = (relative_time )0;
#line 588
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 589
  goto switch_break;
  case_68: /* CIL Label */ 
#line 590
  yyval.rel = (relative_time )0;
#line 590
  yyval.rel.minutes = (long )1;
#line 591
  goto switch_break;
  case_69: /* CIL Label */ 
#line 592
  yyval.rel = (relative_time )0;
#line 592
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 593
  goto switch_break;
  case_70: /* CIL Label */ 
#line 594
  yyval.rel = (relative_time )0;
#line 594
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 595
  goto switch_break;
  case_71: /* CIL Label */ 
#line 596
  yyval.rel = (relative_time )0;
#line 596
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 596
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 597
  goto switch_break;
  case_72: /* CIL Label */ 
#line 598
  yyval.rel = (relative_time )0;
#line 598
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 598
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 599
  goto switch_break;
  case_73: /* CIL Label */ 
#line 600
  yyval.rel = (relative_time )0;
#line 600
  yyval.rel.seconds = (long_time_t )1;
#line 601
  goto switch_break;
  case_75: /* CIL Label */ 
#line 606
  yyval.rel = (relative_time )0;
#line 606
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 607
  goto switch_break;
  case_76: /* CIL Label */ 
#line 608
  yyval.rel = (relative_time )0;
#line 608
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 609
  goto switch_break;
  case_77: /* CIL Label */ 
#line 610
  yyval.rel = (relative_time )0;
#line 610
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 611
  goto switch_break;
  case_78: /* CIL Label */ 
#line 612
  yyval.rel = (relative_time )0;
#line 612
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 613
  goto switch_break;
  case_79: /* CIL Label */ 
#line 614
  yyval.rel = (relative_time )0;
#line 614
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 615
  goto switch_break;
  case_80: /* CIL Label */ 
#line 616
  yyval.rel = (relative_time )0;
#line 616
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 617
  goto switch_break;
  case_81: /* CIL Label */ 
#line 621
  yyval.rel = (relative_time )0;
#line 621
  yyval.rel.day = (yyvsp + 0)->intval;
#line 622
  goto switch_break;
  case_85: /* CIL Label */ 
#line 629
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 629
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 630
  goto switch_break;
  case_87: /* CIL Label */ 
#line 635
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 635
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 636
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 640
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 641
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 648
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 649
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 651
  goto switch_break;
  case_90: /* CIL Label */ 
#line 655
  yyval.intval = (long )(- 1);
#line 656
  goto switch_break;
  case_91: /* CIL Label */ 
#line 657
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 658
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2410 "parse-datetime.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2425
  yyssp -= yylen;
#line 2425
  yyvsp -= yylen;
#line 2426
  yylen = 0;
#line 2429
  yyvsp ++;
#line 2429
  *yyvsp = yyval;
#line 2435
  yyn = (int )yyr1[yyn];
#line 2437
  yystate = (int )yypgoto[yyn - 28] + (int )*yyssp;
#line 2438
  if (0 <= yystate) {
#line 2438
    if (yystate <= 112) {
#line 2438
      if ((int )yycheck[yystate] == (int )*yyssp) {
#line 2439
        yystate = (int )yytable[yystate];
      } else {
#line 2441
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
#line 2441
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
#line 2441
    yystate = (int )yydefgoto[yyn - 28];
  }
#line 2443
  goto yynewstate;
  yyerrlab: 
#line 2452
  if (yychar == -2) {
#line 2452
    tmp___38 = - 2;
  } else {
#line 2452
    if ((unsigned int )yychar <= 277U) {
#line 2452
      tmp___0 = (int )yytranslate[yychar];
    } else {
#line 2452
      tmp___0 = 2;
    }
#line 2452
    tmp___38 = tmp___0;
  }
#line 2452
  yytoken = tmp___38;
#line 2455
  if (! yyerrstatus) {
    {
#line 2457
    yynerrs ++;
#line 2459
    yyerror(pc, (char const   *)((char *)"syntax error"));
    }
  }
#line 2496
  if (yyerrstatus == 3) {
#line 2501
    if (yychar <= 0) {
#line 2504
      if (yychar == 0) {
#line 2505
        goto yyabortlab;
      }
    } else {
      {
#line 2509
      yydestruct((char const   *)((char *)"Error: discarding"), yytoken, & yylval,
                 pc);
#line 2511
      yychar = - 2;
      }
    }
  }
#line 2517
  goto yyerrlab1;
  yyerrorlab: 
#line 2528
  if (0) {
#line 2529
    goto yyerrorlab;
  }
#line 2533
  yyssp -= yylen;
#line 2533
  yyvsp -= yylen;
#line 2534
  yylen = 0;
#line 2536
  yystate = (int )*yyssp;
#line 2537
  goto yyerrlab1;
  yyerrlab1: 
#line 2544
  yyerrstatus = 3;
  {
#line 2546
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2546
    if (! 1) {
#line 2546
      goto while_break___1;
    }
#line 2548
    yyn = (int )yypact[yystate];
#line 2549
    if (! (yyn == -93)) {
#line 2551
      yyn ++;
#line 2552
      if (0 <= yyn) {
#line 2552
        if (yyn <= 112) {
#line 2552
          if ((int )yycheck[yyn] == 1) {
#line 2554
            yyn = (int )yytable[yyn];
#line 2555
            if (0 < yyn) {
#line 2556
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2561
    if (yyssp == yyss) {
#line 2562
      goto yyabortlab;
    }
    {
#line 2565
    yydestruct((char const   *)((char *)"Error: popping"), (int )yystos[yystate],
               yyvsp, pc);
#line 2567
    yyssp --;
    }
#line 2567
    yyvsp --;
#line 2568
    yystate = (int )*yyssp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2572
  yyvsp ++;
#line 2572
  *yyvsp = yylval;
#line 2578
  yystate = yyn;
#line 2579
  goto yynewstate;
  yyacceptlab: 
#line 2586
  yyresult = 0;
#line 2587
  goto yyreturn;
  yyabortlab: 
#line 2593
  yyresult = 1;
#line 2594
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2601
  yyerror(pc, (char const   *)((char *)"memory exhausted"));
  }
#line 2602
  yyresult = 2;
  yyreturn: 
#line 2607
  if (yychar != -2) {
#line 2611
    if ((unsigned int )yychar <= 277U) {
#line 2611
      tmp___39 = (int )yytranslate[yychar];
    } else {
#line 2611
      tmp___39 = 2;
    }
    {
#line 2611
    yytoken = tmp___39;
#line 2612
    yydestruct((char const   *)((char *)"Cleanup: discarding lookahead"), yytoken,
               & yylval, pc);
    }
  }
#line 2617
  yyssp -= yylen;
#line 2617
  yyvsp -= yylen;
  {
#line 2619
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2619
    if (! (yyssp != yyss)) {
#line 2619
      goto while_break___2;
    }
    {
#line 2621
    yydestruct((char const   *)((char *)"Cleanup: popping"), (int )yystos[*yyssp],
               yyvsp, pc);
#line 2623
    yyssp --;
    }
#line 2623
    yyvsp --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2626
  if (yyss != (yytype_int16 *)yyssa) {
    {
#line 2627
    free((void *)yyss);
    }
  }
#line 2634
  return (yyresult);
}
}
#line 662 "parse-datetime.y"
static table meridian_table[]  = {      {(char const   *)((char *)"AM"), 270, 0}, 
        {(char const   *)((char *)"A.M."), 270, 0}, 
        {(char const   *)((char *)"PM"), 270, 1}, 
        {(char const   *)((char *)"P.M."), 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 671 "parse-datetime.y"
static table dst_table[]  = {      {(char const   *)((char *)"DST"), 259, 0}};
#line 676 "parse-datetime.y"
static table month_and_day_table[]  = 
#line 676
  {      {(char const   *)((char *)"JANUARY"), 271, 1}, 
        {(char const   *)((char *)"FEBRUARY"), 271, 2}, 
        {(char const   *)((char *)"MARCH"), 271, 3}, 
        {(char const   *)((char *)"APRIL"), 271, 4}, 
        {(char const   *)((char *)"MAY"), 271, 5}, 
        {(char const   *)((char *)"JUNE"), 271, 6}, 
        {(char const   *)((char *)"JULY"), 271, 7}, 
        {(char const   *)((char *)"AUGUST"), 271, 8}, 
        {(char const   *)((char *)"SEPTEMBER"), 271, 9}, 
        {(char const   *)((char *)"SEPT"), 271, 9}, 
        {(char const   *)((char *)"OCTOBER"), 271, 10}, 
        {(char const   *)((char *)"NOVEMBER"), 271, 11}, 
        {(char const   *)((char *)"DECEMBER"), 271, 12}, 
        {(char const   *)((char *)"SUNDAY"), 267, 0}, 
        {(char const   *)((char *)"MONDAY"), 267, 1}, 
        {(char const   *)((char *)"TUESDAY"), 267, 2}, 
        {(char const   *)((char *)"TUES"), 267, 2}, 
        {(char const   *)((char *)"WEDNESDAY"), 267, 3}, 
        {(char const   *)((char *)"WEDNES"), 267, 3}, 
        {(char const   *)((char *)"THURSDAY"), 267, 4}, 
        {(char const   *)((char *)"THUR"), 267, 4}, 
        {(char const   *)((char *)"THURS"), 267, 4}, 
        {(char const   *)((char *)"FRIDAY"), 267, 5}, 
        {(char const   *)((char *)"SATURDAY"), 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 705 "parse-datetime.y"
static table time_units_table[]  = 
#line 705
  {      {(char const   *)((char *)"YEAR"), 260, 1}, 
        {(char const   *)((char *)"MONTH"), 261, 1}, 
        {(char const   *)((char *)"FORTNIGHT"), 265, 14}, 
        {(char const   *)((char *)"WEEK"), 265, 7}, 
        {(char const   *)((char *)"DAY"), 265, 1}, 
        {(char const   *)((char *)"HOUR"), 262, 1}, 
        {(char const   *)((char *)"MINUTE"), 263, 1}, 
        {(char const   *)((char *)"MIN"), 263, 1}, 
        {(char const   *)((char *)"SECOND"), 264, 1}, 
        {(char const   *)((char *)"SEC"), 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 721 "parse-datetime.y"
static table relative_time_table[]  = 
#line 721
  {      {(char const   *)((char *)"TOMORROW"), 266, 1}, 
        {(char const   *)((char *)"YESTERDAY"), 266, - 1}, 
        {(char const   *)((char *)"TODAY"), 266, 0}, 
        {(char const   *)((char *)"NOW"), 266, 0}, 
        {(char const   *)((char *)"LAST"), 272, - 1}, 
        {(char const   *)((char *)"THIS"), 272, 0}, 
        {(char const   *)((char *)"NEXT"), 272, 1}, 
        {(char const   *)((char *)"FIRST"), 272, 1}, 
        {(char const   *)((char *)"THIRD"), 272, 3}, 
        {(char const   *)((char *)"FOURTH"), 272, 4}, 
        {(char const   *)((char *)"FIFTH"), 272, 5}, 
        {(char const   *)((char *)"SIXTH"), 272, 6}, 
        {(char const   *)((char *)"SEVENTH"), 272, 7}, 
        {(char const   *)((char *)"EIGHTH"), 272, 8}, 
        {(char const   *)((char *)"NINTH"), 272, 9}, 
        {(char const   *)((char *)"TENTH"), 272, 10}, 
        {(char const   *)((char *)"ELEVENTH"), 272, 11}, 
        {(char const   *)((char *)"TWELFTH"), 272, 12}, 
        {(char const   *)((char *)"AGO"), 258, - 1}, 
        {(char const   *)((char *)"HENCE"), 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 750 "parse-datetime.y"
static table universal_time_zone_table[]  = {      {(char const   *)((char *)"GMT"), 273, 0}, 
        {(char const   *)((char *)"UT"), 273, 0}, 
        {(char const   *)((char *)"UTC"), 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 763 "parse-datetime.y"
static table time_zone_table[]  = 
#line 763
  {      {(char const   *)((char *)"WET"), 273, 0}, 
        {(char const   *)((char *)"WEST"), 268, 0}, 
        {(char const   *)((char *)"BST"), 268, 0}, 
        {(char const   *)((char *)"ART"), 273, - 180}, 
        {(char const   *)((char *)"BRT"), 273, - 180}, 
        {(char const   *)((char *)"BRST"), 268, - 180}, 
        {(char const   *)((char *)"NST"), 273, - 210}, 
        {(char const   *)((char *)"NDT"), 268, - 210}, 
        {(char const   *)((char *)"AST"), 273, - 240}, 
        {(char const   *)((char *)"ADT"), 268, - 240}, 
        {(char const   *)((char *)"CLT"), 273, - 240}, 
        {(char const   *)((char *)"CLST"), 268, - 240}, 
        {(char const   *)((char *)"EST"), 273, - 300}, 
        {(char const   *)((char *)"EDT"), 268, - 300}, 
        {(char const   *)((char *)"CST"), 273, - 360}, 
        {(char const   *)((char *)"CDT"), 268, - 360}, 
        {(char const   *)((char *)"MST"), 273, - 420}, 
        {(char const   *)((char *)"MDT"), 268, - 420}, 
        {(char const   *)((char *)"PST"), 273, - 480}, 
        {(char const   *)((char *)"PDT"), 268, - 480}, 
        {(char const   *)((char *)"AKST"), 273, - 540}, 
        {(char const   *)((char *)"AKDT"), 268, - 540}, 
        {(char const   *)((char *)"HST"), 273, - 600}, 
        {(char const   *)((char *)"HAST"), 273, - 600}, 
        {(char const   *)((char *)"HADT"), 268, - 600}, 
        {(char const   *)((char *)"SST"), 273, - 720}, 
        {(char const   *)((char *)"WAT"), 273, 60}, 
        {(char const   *)((char *)"CET"), 273, 60}, 
        {(char const   *)((char *)"CEST"), 268, 60}, 
        {(char const   *)((char *)"MET"), 273, 60}, 
        {(char const   *)((char *)"MEZ"), 273, 60}, 
        {(char const   *)((char *)"MEST"), 268, 60}, 
        {(char const   *)((char *)"MESZ"), 268, 60}, 
        {(char const   *)((char *)"EET"), 273, 120}, 
        {(char const   *)((char *)"EEST"), 268, 120}, 
        {(char const   *)((char *)"CAT"), 273, 120}, 
        {(char const   *)((char *)"SAST"), 273, 120}, 
        {(char const   *)((char *)"EAT"), 273, 180}, 
        {(char const   *)((char *)"MSK"), 273, 180}, 
        {(char const   *)((char *)"MSD"), 268, 180}, 
        {(char const   *)((char *)"IST"), 273, 330}, 
        {(char const   *)((char *)"SGT"), 273, 480}, 
        {(char const   *)((char *)"KST"), 273, 540}, 
        {(char const   *)((char *)"JST"), 273, 540}, 
        {(char const   *)((char *)"GST"), 273, 600}, 
        {(char const   *)((char *)"NZST"), 273, 720}, 
        {(char const   *)((char *)"NZDT"), 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 819 "parse-datetime.y"
static table military_table[]  = 
#line 819
  {      {(char const   *)((char *)"A"), 273, - 60}, 
        {(char const   *)((char *)"B"), 273, - 120}, 
        {(char const   *)((char *)"C"), 273, - 180}, 
        {(char const   *)((char *)"D"), 273, - 240}, 
        {(char const   *)((char *)"E"), 273, - 300}, 
        {(char const   *)((char *)"F"), 273, - 360}, 
        {(char const   *)((char *)"G"), 273, - 420}, 
        {(char const   *)((char *)"H"), 273, - 480}, 
        {(char const   *)((char *)"I"), 273, - 540}, 
        {(char const   *)((char *)"K"), 273, - 600}, 
        {(char const   *)((char *)"L"), 273, - 660}, 
        {(char const   *)((char *)"M"), 273, - 720}, 
        {(char const   *)((char *)"N"), 273, 60}, 
        {(char const   *)((char *)"O"), 273, 120}, 
        {(char const   *)((char *)"P"), 273, 180}, 
        {(char const   *)((char *)"Q"), 273, 240}, 
        {(char const   *)((char *)"R"), 273, 300}, 
        {(char const   *)((char *)"S"), 273, 360}, 
        {(char const   *)((char *)"T"), 'T', 0}, 
        {(char const   *)((char *)"U"), 273, 480}, 
        {(char const   *)((char *)"V"), 273, 540}, 
        {(char const   *)((char *)"W"), 273, 600}, 
        {(char const   *)((char *)"X"), 273, 660}, 
        {(char const   *)((char *)"Y"), 273, 720}, 
        {(char const   *)((char *)"Z"), 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 859 "parse-datetime.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int __cil_tmp6 ;

  {
#line 865
  if (s.digits <= 2UL) {
#line 865
    if (mm < 0L) {
#line 866
      s.value *= (long )100;
    }
  }
#line 868
  if (mm < 0L) {
#line 869
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 871
    if (s.negative) {
#line 871
      tmp = - mm;
    } else {
#line 871
      tmp = mm;
    }
#line 871
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 876
  __cil_tmp6 = abs((int )n_minutes);
  }
#line 876
  if (1440 < __cil_tmp6) {
#line 877
    (pc->zones_seen) ++;
  }
#line 879
  return (n_minutes);
}
}
#line 883 "parse-datetime.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___40 ;
  long tmp___41 ;
  int tmp___42 ;
  long tmp___43 ;

  {
  {
#line 890
  if (meridian == 0) {
#line 890
    goto case_0;
  }
#line 892
  if (meridian == 1) {
#line 892
    goto case_1;
  }
#line 887
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 889
  if (0L <= hours && hours < 24L) {
#line 889
    tmp = hours;
  } else {
#line 889
    tmp = (long )(- 1);
  }
#line 889
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 891
  if (0L < hours && hours < 12L) {
#line 891
    tmp___41 = hours;
  } else {
#line 891
    if (hours == 12L) {
#line 891
      tmp___40 = 0;
    } else {
#line 891
      tmp___40 = - 1;
    }
#line 891
    tmp___41 = (long )tmp___40;
  }
#line 891
  return ((int )tmp___41);
  case_1: /* CIL Label */ 
#line 893
  if (0L < hours && hours < 12L) {
#line 893
    tmp___43 = hours + 12L;
  } else {
#line 893
    if (hours == 12L) {
#line 893
      tmp___42 = 12;
    } else {
#line 893
      tmp___42 = - 1;
    }
#line 893
    tmp___43 = (long )tmp___42;
  }
#line 893
  return ((int )tmp___43);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 898 "parse-datetime.y"
static long to_year(textint textyear ) 
{ 
  long year ;
  int tmp ;

  {
#line 900
  year = textyear.value;
#line 902
  if (year < 0L) {
#line 903
    year = - year;
  } else
#line 907
  if (textyear.digits == 2UL) {
#line 908
    if (year < 69L) {
#line 908
      tmp = 2000;
    } else {
#line 908
      tmp = 1900;
    }
#line 908
    year += (long )tmp;
  }
#line 910
  return (year);
}
}
#line 914 "parse-datetime.y"
static table *lookup_zone(parser_control *pc , char const   *name ) 
{ 
  table *tp ;
  int __cil_tmp4 ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;

  {
#line 918
  tp = (table *)universal_time_zone_table;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! tp->name) {
#line 918
      goto while_break;
    }
    {
#line 919
    __cil_tmp4 = strcmp(name, tp->name);
    }
#line 919
    if (__cil_tmp4 == 0) {
#line 920
      return (tp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 918
  tp ++;
#line 924
  tp = (table *)pc->local_time_zone_table;
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 924
    if (! tp->name) {
#line 924
      goto while_break___0;
    }
    {
#line 925
    __cil_tmp6 = strcmp(name, tp->name);
    }
#line 925
    if (__cil_tmp6 == 0) {
#line 926
      return (tp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 924
  tp ++;
#line 928
  tp = (table *)time_zone_table;
  {
#line 928
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 928
    if (! tp->name) {
#line 928
      goto while_break___1;
    }
    {
#line 929
    __cil_tmp8 = strcmp(name, tp->name);
    }
#line 929
    if (__cil_tmp8 == 0) {
#line 930
      return (tp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 928
  tp ++;
#line 932
  return ((table *)((void *)0));
}
}
#line 963 "parse-datetime.y"
static table *lookup_word(parser_control *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table *tp ;
  int period_found ;
  int abbrev ;
  unsigned char ch ;
  int __cil_tmp11 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int __cil_tmp24 ;

  {
#line 973
  p = word;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! *p) {
#line 973
      goto while_break;
    }
#line 975
    ch = (unsigned char )*p;
#line 976
    *p = (char )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  p ++;
#line 979
  tp = (table *)meridian_table;
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 979
    if (! tp->name) {
#line 979
      goto while_break___0;
    }
    {
#line 980
    __cil_tmp11 = strcmp((char const   *)word, tp->name);
    }
#line 980
    if (__cil_tmp11 == 0) {
#line 981
      return (tp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 979
  tp ++;
#line 984
  wordlen = strlen((char const   *)word);
#line 985
  abbrev = wordlen == 3UL || (wordlen == 4UL && (int )*(word + 3) == 46);
#line 987
  tp = (table *)month_and_day_table;
  }
  {
#line 987
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 987
    if (! tp->name) {
#line 987
      goto while_break___1;
    }
#line 988
    if (abbrev) {
      {
#line 988
      __cil_tmp14 = strncmp((char const   *)word, tp->name, (unsigned long )3);
#line 988
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 988
      __cil_tmp15 = strcmp((char const   *)word, tp->name);
#line 988
      tmp = __cil_tmp15;
      }
    }
#line 988
    if (tmp == 0) {
#line 989
      return (tp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 987
  tp ++;
#line 991
  tp = lookup_zone(pc, (char const   *)word);
  }
#line 991
  if (tp) {
#line 992
    return (tp);
  }
  {
#line 994
  __cil_tmp19 = strcmp((char const   *)word, dst_table[0].name);
  }
#line 994
  if (__cil_tmp19 == 0) {
#line 995
    return ((table *)dst_table);
  }
#line 997
  tp = (table *)time_units_table;
  {
#line 997
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 997
    if (! tp->name) {
#line 997
      goto while_break___2;
    }
    {
#line 998
    __cil_tmp20 = strcmp((char const   *)word, tp->name);
    }
#line 998
    if (__cil_tmp20 == 0) {
#line 999
      return (tp);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 997
  tp ++;
#line 1002
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 1004
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 1005
    tp = (table *)time_units_table;
    {
#line 1005
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1005
      if (! tp->name) {
#line 1005
        goto while_break___3;
      }
      {
#line 1006
      __cil_tmp22 = strcmp((char const   *)word, tp->name);
      }
#line 1006
      if (__cil_tmp22 == 0) {
#line 1007
        return (tp);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1005
    tp ++;
#line 1008
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 1011
  tp = (table *)relative_time_table;
  {
#line 1011
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1011
    if (! tp->name) {
#line 1011
      goto while_break___4;
    }
    {
#line 1012
    __cil_tmp24 = strcmp((char const   *)word, tp->name);
    }
#line 1012
    if (__cil_tmp24 == 0) {
#line 1013
      return (tp);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1011
  tp ++;
#line 1016
  if (wordlen == 1UL) {
#line 1017
    tp = (table *)military_table;
    {
#line 1017
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1017
      if (! tp->name) {
#line 1017
        goto while_break___5;
      }
#line 1018
      if ((int )*(word + 0) == (int )((char )*(tp->name + 0))) {
#line 1019
        return (tp);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1017
    tp ++;
  }
#line 1022
  q = word;
#line 1022
  p = q;
#line 1022
  period_found = 0;
  {
#line 1022
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1022
    if (! *p) {
#line 1022
      goto while_break___6;
    }
#line 1023
    if ((int )*q == 46) {
#line 1024
      period_found = 1;
    } else {
#line 1026
      p ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1022
  q ++;
#line 1027
  tp = lookup_zone(pc, (char const   *)word);
  }
#line 1027
  if (period_found) {
#line 1027
    if (tp) {
#line 1028
      return (tp);
    }
  }
#line 1030
  return ((table *)((void *)0));
}
}
#line 1034 "parse-datetime.y"
static int yylex(YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  int tmp ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  time_t __cil_tmp22 ;
  int tmp___0 ;
  int tmp___1 ;
  char buff[20] ;
  char *p___0 ;
  table *tp ;
  char *__cil_tmp28 ;
  char const   *__cil_tmp30 ;
  unsigned char __cil_tmp31 ;
  char const   *__cil_tmp32 ;
  size_t __cil_tmp34 ;

  {
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1039
    if (! 1) {
#line 1039
      goto while_break;
    }
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1041
      if (! 0) {
#line 1041
        goto while_break___0;
      }
#line 1042
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1044
    if ((unsigned int )c - 48U <= 9U) {
      _L___46: /* CIL Label */ 
#line 1049
      if ((int )c == 45) {
        _L: /* CIL Label */ 
#line 1051
        if ((int )c == 45) {
#line 1051
          tmp = - 1;
        } else {
#line 1051
          tmp = 1;
        }
#line 1051
        sign = tmp;
        {
#line 1052
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1052
          if (! 0) {
#line 1052
            goto while_break___1;
          }
#line 1053
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1054
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1056
          goto while_continue;
        }
      } else
#line 1049
      if ((int )c == 43) {
#line 1049
        goto _L;
      } else {
#line 1059
        sign = 0;
      }
#line 1060
      p = pc->input;
#line 1061
      value = (unsigned long )0;
      {
#line 1061
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1061
        if (! 1) {
#line 1061
          goto while_break___2;
        }
#line 1063
        value1 = value + (unsigned long )((int )c - 48);
#line 1064
        if (value1 < value) {
#line 1065
          return ('?');
        }
#line 1066
        value = value1;
#line 1067
        p ++;
#line 1067
        c = (unsigned char )((char )*p);
#line 1068
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1069
          goto while_break___2;
        }
#line 1070
        if (1844674407370955161UL < value) {
#line 1071
          return ('?');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1061
      value *= (unsigned long )10;
#line 1073
      if ((int )c == 46) {
        _L___45: /* CIL Label */ 
#line 1073
        if ((unsigned int )((char )*(p + 1)) - 48U <= 9U) {
#line 1081
          if (sign < 0) {
#line 1083
            s = (time_t )(- value);
#line 1084
            if (0L < s) {
#line 1085
              return ('?');
            }
#line 1086
            value1___0 = (unsigned long )(- s);
          } else {
#line 1090
            s = (time_t )value;
#line 1091
            if (s < 0L) {
#line 1092
              return ('?');
            }
#line 1093
            value1___0 = (unsigned long )s;
          }
#line 1095
          if (value != value1___0) {
#line 1096
            return ('?');
          }
#line 1099
          p ++;
#line 1100
          __cil_tmp16 = p;
#line 1100
          p ++;
#line 1100
          ns = (int )((char )*__cil_tmp16) - 48;
#line 1101
          digits = 2;
          {
#line 1101
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1101
            if (! (digits <= 9)) {
#line 1101
              goto while_break___3;
            }
#line 1103
            ns *= 10;
#line 1104
            if ((unsigned int )((char )*p) - 48U <= 9U) {
#line 1105
              __cil_tmp17 = p;
#line 1105
              p ++;
#line 1105
              ns += (int )((char )*__cil_tmp17) - 48;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1101
          digits ++;
#line 1109
          if (sign < 0) {
            {
#line 1110
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1110
              if (! ((unsigned int )((char )*p) - 48U <= 9U)) {
#line 1110
                goto while_break___4;
              }
#line 1111
              if ((int )((char )*p) != 48) {
#line 1113
                ns ++;
#line 1114
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1110
            p ++;
          }
          {
#line 1116
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1116
            if (! ((unsigned int )((char )*p) - 48U <= 9U)) {
#line 1116
              goto while_break___5;
            }
#line 1117
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1122
          if (sign < 0) {
#line 1122
            if (ns) {
#line 1124
              __cil_tmp22 = s;
#line 1124
              s --;
#line 1125
              if (! (s < 0L)) {
#line 1126
                return ('?');
              }
#line 1127
              ns = 1000000000 - ns;
            }
          }
#line 1130
          lvalp->timespec.tv_sec = s;
#line 1131
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1132
          pc->input = p;
#line 1133
          if (sign) {
#line 1133
            tmp___0 = 276;
          } else {
#line 1133
            tmp___0 = 277;
          }
#line 1133
          return (tmp___0);
        } else {
#line 1073
          goto _L___44;
        }
      } else
#line 1073
      if ((int )c == 44) {
#line 1073
        goto _L___45;
      } else {
        _L___44: /* CIL Label */ 
#line 1137
        lvalp->textintval.negative = sign < 0;
#line 1138
        if (sign < 0) {
#line 1140
          lvalp->textintval.value = (long )(- value);
#line 1141
          if (0L < lvalp->textintval.value) {
#line 1142
            return ('?');
          }
        } else {
#line 1146
          lvalp->textintval.value = (long )value;
#line 1147
          if (lvalp->textintval.value < 0L) {
#line 1148
            return ('?');
          }
        }
#line 1150
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1151
        pc->input = p;
#line 1152
        if (sign) {
#line 1152
          tmp___1 = 274;
        } else {
#line 1152
          tmp___1 = 275;
        }
#line 1152
        return (tmp___1);
      }
    } else
#line 1044
    if ((int )c == 45) {
#line 1044
      goto _L___46;
    } else
#line 1044
    if ((int )c == 43) {
#line 1044
      goto _L___46;
    }
#line 1156
    if (0) {
#line 1159
      p___0 = (char *)buff;
      {
#line 1162
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1164
        if ((unsigned long )(p___0 - (char *)buff) < sizeof(buff) - 1UL) {
#line 1165
          __cil_tmp28 = p___0;
#line 1165
          p___0 ++;
#line 1165
          *__cil_tmp28 = (char )c;
        }
#line 1166
        (pc->input) ++;
#line 1166
        c = (unsigned char )((char )*(pc->input));
#line 1162
        if (! ((int )c == 46)) {
#line 1162
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1170
      *p___0 = (char )'\000';
#line 1171
      tp = lookup_word(pc, (char *)buff);
      }
#line 1172
      if (! tp) {
#line 1173
        return ('?');
      }
#line 1174
      lvalp->intval = (long )tp->value;
#line 1175
      return (tp->type);
    }
#line 1178
    if ((int )c != 40) {
      {
#line 1179
      __cil_tmp30 = pc->input;
#line 1179
      (pc->input) ++;
#line 1179
      __cil_tmp31 = to_uchar((char )*__cil_tmp30);
      }
#line 1179
      return ((int )__cil_tmp31);
    }
#line 1181
    count = (size_t )0;
    {
#line 1182
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1184
      __cil_tmp32 = pc->input;
#line 1184
      (pc->input) ++;
#line 1184
      c = (unsigned char )((char )*__cil_tmp32);
#line 1185
      if ((int )c == 0) {
#line 1186
        return ((int )c);
      }
#line 1187
      if ((int )c == 40) {
#line 1188
        count ++;
      } else
#line 1189
      if ((int )c == 41) {
#line 1190
        __cil_tmp34 = count;
#line 1190
        count --;
      }
#line 1182
      if (! (count != 0UL)) {
#line 1182
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1198 "parse-datetime.y"
static int yyerror(parser_control *pc , char const   *s ) 
{ 


  {
#line 1201
  return (0);
}
}
#line 1209 "parse-datetime.y"
static int mktime_ok(struct tm *tm0 , struct tm *tm1 , time_t t ) 
{ 


  {
#line 1211
  if (t == -1L) {
    {
#line 1216
    tm1 = localtime(& t);
    }
#line 1217
    if (! tm1) {
#line 1218
      return (0);
    }
  }
#line 1221
  return (! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year)));
}
}
#line 1236 "parse-datetime.y"
static char *get_tz(char tzbuf[100] ) 
{ 
  char *tz ;
  char *__cil_tmp3 ;
  size_t tzsize ;
  size_t __cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *tmp ;

  {
  {
#line 1238
  __cil_tmp3 = getenv((char const   *)((char *)"TZ"));
#line 1238
  tz = __cil_tmp3;
  }
#line 1239
  if (tz) {
    {
#line 1241
    __cil_tmp5 = strlen((char const   *)tz);
#line 1241
    tzsize = __cil_tmp5 + 1UL;
    }
#line 1242
    if (tzsize <= 100UL) {
      {
#line 1242
      __cil_tmp6 = memcpy((void *)tzbuf, (void const   *)tz, tzsize);
#line 1242
      tmp = __cil_tmp6;
      }
    } else {
      {
#line 1242
      __cil_tmp7 = xmemdup((void const   *)tz, tzsize);
#line 1242
      tmp = __cil_tmp7;
      }
    }
#line 1242
    tz = (char *)tmp;
  }
#line 1246
  return (tz);
}
}
#line 1254 "parse-datetime.y"
int parse_datetime(struct timespec *result , char const   *p , struct timespec *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  int tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  int ok ;
  int __cil_tmp18 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  int large_tz ;
  int setenv_ok ;
  void *__cil_tmp29 ;
  void *tmp___48 ;
  char *__cil_tmp31 ;
  int __cil_tmp33 ;
  char const   *__cil_tmp34 ;
  size_t __cil_tmp35 ;
  int quarter ;
  time_t probe ;
  struct tm *probe_tm ;
  struct tm *__cil_tmp39 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  long __cil_tmp43 ;
  int __cil_tmp46 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___49 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[30] ;
  int __cil_tmp54 ;
  int __cil_tmp56 ;
  int year ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___50 ;

  {
#line 1265
  tz_was_altered = 0;
#line 1266
  tz0 = (char *)((void *)0);
#line 1268
  ok = 1;
#line 1270
  if (! now) {
    {
#line 1272
    gettime(& gettime_buffer);
#line 1273
    now = & gettime_buffer;
    }
  }
  {
#line 1276
  Start = now->tv_sec;
#line 1277
  Start_ns = now->tv_nsec;
#line 1279
  tmp = localtime(& now->tv_sec);
  }
#line 1280
  if (! tmp) {
#line 1281
    return (0);
  }
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1283
    if (! 0) {
#line 1283
      goto while_break;
    }
#line 1284
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1286
  __cil_tmp18 = strncmp(p, (char const   *)((char *)"TZ=\""), (unsigned long )4);
  }
#line 1286
  if (__cil_tmp18 == 0) {
#line 1288
    tzbase = p + 4;
#line 1289
    tzsize = (size_t )1;
#line 1292
    s = tzbase;
    {
#line 1292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1292
      if (! ((char )*s)) {
#line 1292
        goto while_break___0;
      }
#line 1293
      if ((int )((char )*s) == 92) {
#line 1295
        s ++;
#line 1296
        if (! ((int )((char )*s) == 92 || (int )((char )*s) == 34)) {
#line 1297
          goto while_break___0;
        }
      } else
#line 1299
      if ((int )((char )*s) == 34) {
        {
#line 1304
        large_tz = 100UL < tzsize;
#line 1307
        free((void *)tz0);
#line 1308
        tz0 = get_tz((char *)tz0buf);
        }
#line 1309
        if (large_tz) {
          {
#line 1309
          __cil_tmp29 = xmalloc(tzsize);
#line 1309
          tmp___48 = __cil_tmp29;
          }
        } else {
#line 1309
          tmp___48 = (void *)((char *)tz1buf);
        }
#line 1309
        tz1 = (char *)tmp___48;
#line 1309
        z = tz1;
#line 1310
        s = tzbase;
        {
#line 1310
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1310
          if (! ((int )((char )*s) != 34)) {
#line 1310
            goto while_break___1;
          }
#line 1311
          s += (int )((char )*s) == 92;
#line 1311
          __cil_tmp31 = z;
#line 1311
          z ++;
#line 1311
          *__cil_tmp31 = (char )*s;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1310
        s ++;
#line 1312
        *z = (char )'\000';
#line 1313
        __cil_tmp33 = setenv((char const   *)((char *)"TZ"), (char const   *)tz1,
                             1);
#line 1313
        setenv_ok = __cil_tmp33 == 0;
        }
#line 1314
        if (large_tz) {
          {
#line 1315
          free((void *)tz1);
          }
        }
#line 1316
        if (! setenv_ok) {
#line 1317
          goto fail;
        }
#line 1318
        tz_was_altered = 1;
#line 1319
        p = s + 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1292
    __cil_tmp35 = tzsize;
#line 1292
    tzsize ++;
#line 1292
    __cil_tmp34 = s;
#line 1292
    s ++;
  }
#line 1326
  if ((int )((char )*p) == 0) {
#line 1327
    p = (char const   *)((char *)"0");
  }
#line 1329
  pc.input = p;
#line 1330
  pc.year.value = (long )tmp->tm_year;
#line 1331
  pc.year.value += (long )1900;
#line 1332
  pc.year.digits = (size_t )0;
#line 1333
  pc.month = (long )(tmp->tm_mon + 1);
#line 1334
  pc.day = (long )tmp->tm_mday;
#line 1335
  pc.hour = (long )tmp->tm_hour;
#line 1336
  pc.minutes = (long )tmp->tm_min;
#line 1337
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1338
  pc.seconds.tv_nsec = Start_ns;
#line 1339
  tm.tm_isdst = tmp->tm_isdst;
#line 1341
  pc.meridian = 2;
#line 1342
  pc.rel = (relative_time )0;
#line 1343
  pc.timespec_seen = 0;
#line 1344
  pc.rels_seen = 0;
#line 1345
  pc.dates_seen = (size_t )0;
#line 1346
  pc.days_seen = (size_t )0;
#line 1347
  pc.times_seen = (size_t )0;
#line 1348
  pc.local_zones_seen = (size_t )0;
#line 1349
  pc.dsts_seen = (size_t )0;
#line 1350
  pc.zones_seen = (size_t )0;
#line 1353
  pc.local_time_zone_table[0].name = tmp->tm_zone;
#line 1354
  pc.local_time_zone_table[0].type = 269;
#line 1355
  pc.local_time_zone_table[0].value = tmp->tm_isdst;
#line 1356
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1362
  quarter = 1;
  {
#line 1362
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1362
    if (! (quarter <= 3)) {
#line 1362
      goto while_break___2;
    }
    {
#line 1364
    probe = Start + (long )(quarter * 7776000);
#line 1365
    __cil_tmp39 = localtime(& probe);
#line 1365
    probe_tm = __cil_tmp39;
    }
#line 1366
    if (probe_tm) {
#line 1366
      if (probe_tm->tm_zone) {
#line 1366
        if (probe_tm->tm_isdst != pc.local_time_zone_table[0].value) {
#line 1370
          pc.local_time_zone_table[1].name = probe_tm->tm_zone;
#line 1371
          pc.local_time_zone_table[1].type = 269;
#line 1372
          pc.local_time_zone_table[1].value = probe_tm->tm_isdst;
#line 1373
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1375
          goto while_break___2;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1362
  quarter ++;
#line 1399
  __cil_tmp41 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
  }
#line 1399
  if (pc.local_time_zone_table[0].name) {
#line 1399
    if (pc.local_time_zone_table[1].name) {
#line 1399
      if (! __cil_tmp41) {
#line 1406
        pc.local_time_zone_table[0].value = - 1;
#line 1407
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1410
  __cil_tmp42 = yyparse(& pc);
  }
#line 1410
  if (__cil_tmp42 != 0) {
#line 1411
    goto fail;
  }
#line 1413
  if (pc.timespec_seen) {
#line 1414
    *result = pc.seconds;
  } else {
#line 1417
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1419
      goto fail;
    }
    {
#line 1421
    __cil_tmp43 = to_year(pc.year);
#line 1421
    tm.tm_year = (int )(__cil_tmp43 - 1900L);
#line 1422
    tm.tm_mon = (int )(pc.month - 1L);
#line 1423
    tm.tm_mday = (int )pc.day;
    }
#line 1424
    if (pc.times_seen) {
      _L: /* CIL Label */ 
      {
#line 1426
      tm.tm_hour = to_hour(pc.hour, pc.meridian);
      }
#line 1427
      if (tm.tm_hour < 0) {
#line 1428
        goto fail;
      }
#line 1429
      tm.tm_min = (int )pc.minutes;
#line 1430
      tm.tm_sec = (int )pc.seconds.tv_sec;
    } else
#line 1424
    if (pc.rels_seen) {
#line 1424
      if (! pc.dates_seen) {
#line 1424
        if (! pc.days_seen) {
#line 1424
          goto _L;
        } else {
#line 1434
          tm.tm_sec = 0;
#line 1434
          tm.tm_min = tm.tm_sec;
#line 1434
          tm.tm_hour = tm.tm_min;
#line 1435
          pc.seconds.tv_nsec = (__syscall_slong_t )0;
        }
      } else {
#line 1434
        tm.tm_sec = 0;
#line 1434
        tm.tm_min = tm.tm_sec;
#line 1434
        tm.tm_hour = tm.tm_min;
#line 1435
        pc.seconds.tv_nsec = (__syscall_slong_t )0;
      }
    } else {
#line 1434
      tm.tm_sec = 0;
#line 1434
      tm.tm_min = tm.tm_sec;
#line 1434
      tm.tm_hour = tm.tm_min;
#line 1435
      pc.seconds.tv_nsec = (__syscall_slong_t )0;
    }
#line 1439
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1440
      tm.tm_isdst = - 1;
    }
#line 1444
    if (pc.local_zones_seen) {
#line 1445
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 1447
    tm0 = tm;
#line 1449
    Start = mktime(& tm);
#line 1451
    __cil_tmp46 = mktime_ok(& tm0, & tm, Start);
    }
#line 1451
    if (! __cil_tmp46) {
#line 1453
      if (! pc.zones_seen) {
#line 1454
        goto fail;
      } else {
#line 1467
        time_zone = pc.time_zone;
#line 1468
        if (time_zone < 0L) {
#line 1468
          tmp___49 = - time_zone;
        } else {
#line 1468
          tmp___49 = time_zone;
        }
#line 1468
        abs_time_zone = tmp___49;
#line 1469
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1470
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1473
        if (! tz_was_altered) {
          {
#line 1474
          tz0 = get_tz((char *)tz0buf);
          }
        }
        {
#line 1475
        sprintf((char *)tz1buf___0, (char const   *)((char *)"XXX%s%ld:%02d"), (char *)"-" + (time_zone < 0L),
                abs_time_zone_hour, abs_time_zone_min);
#line 1477
        __cil_tmp54 = setenv((char const   *)((char *)"TZ"), (char const   *)((char *)tz1buf___0),
                             1);
        }
#line 1477
        if (__cil_tmp54 != 0) {
#line 1478
          goto fail;
        }
        {
#line 1479
        tz_was_altered = 1;
#line 1480
        tm = tm0;
#line 1481
        Start = mktime(& tm);
#line 1482
        __cil_tmp56 = mktime_ok(& tm0, & tm, Start);
        }
#line 1482
        if (! __cil_tmp56) {
#line 1483
          goto fail;
        }
      }
    }
#line 1487
    if (pc.days_seen) {
#line 1487
      if (! pc.dates_seen) {
        {
#line 1489
        tm.tm_mday += (long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )(0L < pc.day_ordinal && tm.tm_wday != pc.day_number));
#line 1493
        tm.tm_isdst = - 1;
#line 1494
        Start = mktime(& tm);
        }
#line 1495
        if (Start == -1L) {
#line 1496
          goto fail;
        }
      }
    }
#line 1500
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1502
      year = (int )((long )tm.tm_year + pc.rel.year);
#line 1503
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1504
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1505
      if ((((year < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1508
        goto fail;
      }
      {
#line 1509
      tm.tm_year = year;
#line 1510
      tm.tm_mon = month;
#line 1511
      tm.tm_mday = day;
#line 1512
      tm.tm_hour = tm0.tm_hour;
#line 1513
      tm.tm_min = tm0.tm_min;
#line 1514
      tm.tm_sec = tm0.tm_sec;
#line 1515
      tm.tm_isdst = tm0.tm_isdst;
#line 1516
      Start = mktime(& tm);
      }
#line 1517
      if (Start == -1L) {
#line 1518
        goto fail;
      }
    }
#line 1523
    if (pc.zones_seen) {
#line 1525
      delta = pc.time_zone * 60L;
#line 1528
      delta -= tm.tm_gmtoff;
#line 1536
      t1 = Start - delta;
#line 1537
      if ((Start < t1) != (delta < 0L)) {
#line 1538
        goto fail;
      }
#line 1539
      Start = t1;
    }
#line 1550
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1551
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1552
    t0 = Start;
#line 1553
    d1 = 3600L * pc.rel.hour;
#line 1554
    t1___0 = t0 + d1;
#line 1555
    d2 = 60L * pc.rel.minutes;
#line 1556
    t2 = t1___0 + d2;
#line 1557
    d3 = pc.rel.seconds;
#line 1558
    t3 = t2 + d3;
#line 1559
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1560
    t4 = t3 + d4;
#line 1561
    t5 = t4;
#line 1563
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1570
      goto fail;
    }
#line 1572
    result->tv_sec = t5;
#line 1573
    result->tv_nsec = normalized_ns;
  }
#line 1577
  goto done;
  fail: 
#line 1580
  ok = 0;
  done: 
#line 1582
  if (tz_was_altered) {
#line 1583
    if (tz0) {
      {
#line 1583
      __cil_tmp76 = setenv((char const   *)((char *)"TZ"), (char const   *)tz0, 1);
#line 1583
      tmp___50 = __cil_tmp76;
      }
    } else {
      {
#line 1583
      __cil_tmp77 = unsetenv((char const   *)((char *)"TZ"));
#line 1583
      tmp___50 = __cil_tmp77;
      }
    }
#line 1583
    ok &= tmp___50 == 0;
  }
#line 1584
  if (tz0 != (char *)tz0buf) {
    {
#line 1585
    free((void *)tz0);
    }
  }
#line 1586
  return (ok);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 22 "./dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 20 "./unistd-safer.h"
int dup_safer(int fd ) ;
#line 31 "/tmp/0/patch-2.7.1/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *__cil_tmp3 ;
  int fd ;
  int __cil_tmp5 ;
  DIR *newdp ;
  int e ;
  int f ;
  int __cil_tmp9 ;
  int *__cil_tmp13 ;

  {
  {
#line 33
  __cil_tmp3 = opendir(name);
#line 33
  dp = __cil_tmp3;
  }
#line 35
  if (dp) {
    {
#line 37
    __cil_tmp5 = dirfd(dp);
#line 37
    fd = __cil_tmp5;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        __cil_tmp9 = dup_safer(fd);
#line 52
        f = __cil_tmp9;
        }
#line 53
        if (f < 0) {
          {
#line 55
          e = (int )__errno_location();
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          e = (int )__errno_location();
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        __cil_tmp13 = __errno_location();
#line 70
        *__cil_tmp13 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 63 "./malloca.h"
void *mmalloca(size_t n ) ;
#line 67
void freea(void *p ) ;
#line 63 "/tmp/0/patch-2.7.1/lib/malloca.c"
static void *mmalloca_results[257] ;
#line 68 "/tmp/0/patch-2.7.1/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *__cil_tmp4 ;
  size_t slot ;

  {
#line 73
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 75
  if (nplus >= n) {
    {
#line 77
    __cil_tmp4 = malloc(nplus);
#line 77
    p = (char *)__cil_tmp4;
    }
#line 79
    if (p != (char *)((void *)0)) {
#line 83
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 86
      *((int *)p + - 1) = 336984906;
#line 89
      slot = (uintptr_t )p % 257UL;
#line 90
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 91
      mmalloca_results[slot] = (void *)p;
#line 93
      return ((void *)p);
    }
  }
#line 97
  return ((void *)0);
}
}
#line 109 "/tmp/0/patch-2.7.1/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 112
  if (p != (void *)0) {
#line 118
    if (*((int *)p + -1) == 336984906) {
#line 122
      slot = (uintptr_t )p % 257UL;
#line 123
      chain = & mmalloca_results[slot];
      {
#line 124
      while (1) {
        while_continue: /* CIL Label */ ;
#line 124
        if (! (*chain != (void *)0)) {
#line 124
          goto while_break;
        }
#line 126
        if (*chain == p) {
          {
#line 129
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 130
          *chain = ((struct header *)p_begin)->next;
#line 131
          free((void *)p_begin);
          }
#line 132
          return;
        }
#line 134
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 377
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 114 "/tmp/0/patch-2.7.1/lib/localcharset.c"
static char const   *charset_aliases ;
#line 118 "/tmp/0/patch-2.7.1/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *__cil_tmp5 ;
  size_t dir_len___0 ;
  size_t __cil_tmp7 ;
  size_t base_len___0 ;
  size_t __cil_tmp9 ;
  int add_slash ;
  void *__cil_tmp11 ;
  int fd ;
  int tmp ;
  int __cil_tmp14 ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int __cil_tmp27 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;

  {
#line 122
  cp = charset_aliases;
#line 123
  if (cp == (char const   *)((void *)0)) {
    {
#line 127
    base = (char const   *)((char *)"charset.alias");
#line 132
    __cil_tmp5 = getenv((char const   *)((char *)"CHARSETALIASDIR"));
#line 132
    dir = (char const   *)__cil_tmp5;
    }
#line 133
    if (dir == (char const   *)((void *)0)) {
#line 134
      dir = (char const   *)((char *)"/usr/local/lib");
    } else
#line 133
    if ((int )((char )*(dir + 0)) == 0) {
#line 134
      dir = (char const   *)((char *)"/usr/local/lib");
    }
    {
#line 138
    __cil_tmp7 = strlen(dir);
#line 138
    dir_len___0 = __cil_tmp7;
#line 139
    __cil_tmp9 = strlen(base);
#line 139
    base_len___0 = __cil_tmp9;
#line 140
    add_slash = dir_len___0 > 0UL && ! ((int )((char )*(dir + (dir_len___0 - 1UL))) == 47);
#line 141
    __cil_tmp11 = malloc(((dir_len___0 + (unsigned long )add_slash) + base_len___0) + 1UL);
#line 141
    file_name = (char *)__cil_tmp11;
    }
#line 142
    if (file_name != (char *)((void *)0)) {
      {
#line 144
      memcpy((void *)file_name, (void const   *)dir, dir_len___0);
      }
#line 145
      if (add_slash) {
#line 146
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 147
      memcpy((void *)((file_name + dir_len___0) + add_slash), (void const   *)base,
             base_len___0 + 1UL);
      }
    }
#line 151
    if (file_name == (char *)((void *)0)) {
#line 153
      cp = (char const   *)((char *)"");
    } else {
      {
#line 165
      tmp = 131072;
#line 165
      __cil_tmp14 = open((char const   *)file_name, tmp);
#line 165
      fd = __cil_tmp14;
      }
#line 167
      if (fd < 0) {
#line 169
        cp = (char const   *)((char *)"");
      } else {
        {
#line 174
        fp = fdopen(fd, (char const   *)((char *)"r"));
        }
#line 175
        if (fp == (FILE *)((void *)0)) {
          {
#line 178
          close(fd);
#line 179
          cp = (char const   *)((char *)"");
          }
        } else {
#line 184
          res_ptr = (char *)((void *)0);
#line 185
          res_size = (size_t )0;
          {
#line 187
          while (1) {
            while_continue: /* CIL Label */ ;
#line 187
            if (! 1) {
#line 187
              goto while_break;
            }
            {
#line 195
            c = getc_unlocked(fp);
            }
#line 196
            if (c == -1) {
#line 197
              goto while_break;
            }
#line 198
            if (c == 10) {
#line 199
              goto while_continue;
            } else
#line 198
            if (c == 32) {
#line 199
              goto while_continue;
            } else
#line 198
            if (c == 9) {
#line 199
              goto while_continue;
            }
#line 200
            if (c == 35) {
              {
#line 203
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 204
                c = getc_unlocked(fp);
                }
#line 203
                if (! (! (c == -1 || c == 10))) {
#line 203
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 206
              if (c == -1) {
#line 207
                goto while_break;
              }
#line 208
              goto while_continue;
            }
            {
#line 210
            ungetc(c, fp);
#line 211
            __cil_tmp27 = fscanf(fp, (char const   *)((char *)"%50s %50s"), (char *)buf1,
                                 (char *)buf2);
            }
#line 211
            if (__cil_tmp27 < 2) {
#line 212
              goto while_break;
            }
            {
#line 213
            l1 = strlen((char const   *)((char *)buf1));
#line 214
            l2 = strlen((char const   *)((char *)buf2));
#line 215
            old_res_ptr = res_ptr;
            }
#line 216
            if (res_size == 0UL) {
              {
#line 218
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 219
              __cil_tmp30 = malloc(res_size + 1UL);
#line 219
              res_ptr = (char *)__cil_tmp30;
              }
            } else {
              {
#line 223
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 224
              __cil_tmp31 = realloc((void *)res_ptr, res_size + 1UL);
#line 224
              res_ptr = (char *)__cil_tmp31;
              }
            }
#line 226
            if (res_ptr == (char *)((void *)0)) {
              {
#line 229
              res_size = (size_t )0;
#line 230
              free((void *)old_res_ptr);
              }
#line 231
              goto while_break;
            }
            {
#line 233
            strcpy(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL), (char const   *)((char *)buf1));
#line 234
            strcpy((res_ptr + res_size) - (l2 + 1UL), (char const   *)((char *)buf2));
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 236
          fclose(fp);
          }
#line 237
          if (res_size == 0UL) {
#line 238
            cp = (char const   *)((char *)"");
          } else {
#line 241
            *(res_ptr + res_size) = (char )'\000';
#line 242
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 247
      free((void *)file_name);
      }
    }
#line 341
    charset_aliases = cp;
  }
#line 344
  return (cp);
}
}
#line 357 "/tmp/0/patch-2.7.1/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *__cil_tmp3 ;
  int __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 367
  __cil_tmp3 = nl_langinfo(14);
#line 367
  codeset = (char const   *)__cil_tmp3;
  }
#line 524
  if (codeset == (char const   *)((void *)0)) {
#line 526
    codeset = (char const   *)((char *)"");
  }
  {
#line 529
  aliases = get_charset_aliases();
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! ((int )((char )*aliases) != 0)) {
#line 529
      goto while_break;
    }
    {
#line 532
    __cil_tmp5 = strcmp(codeset, aliases);
    }
#line 532
    if (__cil_tmp5 == 0) {
      {
      {
#line 535
      __cil_tmp6 = strlen(aliases);
      }
#line 535
      codeset = (aliases + __cil_tmp6) + 1;
      }
#line 536
      goto while_break;
    } else
#line 532
    if ((int )((char )*(aliases + 0)) == 42) {
#line 532
      if ((int )((char )*(aliases + 1)) == 0) {
        {
        {
#line 535
        __cil_tmp6 = strlen(aliases);
        }
#line 535
        codeset = (aliases + __cil_tmp6) + 1;
        }
#line 536
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 531
  __cil_tmp8 = strlen(aliases);
  }
#line 531
  aliases += __cil_tmp8 + 1UL;
  {
#line 531
  __cil_tmp7 = strlen(aliases);
  }
#line 531
  aliases += __cil_tmp7 + 1UL;
#line 542
  if ((int )((char )*(codeset + 0)) == 0) {
#line 543
    codeset = (char const   *)((char *)"ASCII");
  }
#line 552
  return (codeset);
}
}
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 72 "./hash.h"
size_t hash_get_n_buckets(Hash_table *table ) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table *table ) ;
#line 74
size_t hash_get_n_entries(Hash_table *table ) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table *table ) ;
#line 76
int hash_table_ok(Hash_table *table ) ;
#line 77
void hash_print_statistics(Hash_table *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table *table ) ;
#line 82
void *hash_get_next(Hash_table *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table *table , void **buffer , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table *table , Hash_processor processor , void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *hash_initialize(size_t candidate , Hash_tuning *tuning , Hash_hasher hasher ,
                            Hash_comparator comparator , Hash_data_freer data_freer ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
int hash_rehash(Hash_table *table , size_t candidate ) ;
#line 97
void *hash_insert(Hash_table *table , void const   *entry ) ;
#line 100
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 103
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 105
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 77 "./bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 130 "/tmp/0/patch-2.7.1/lib/hash.c"
static Hash_tuning default_tuning  =    {0.f, 1.f, 0.800000011921f, 1.41400003434f, 0};
#line 150 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_get_n_buckets(Hash_table *table ) 
{ 


  {
#line 152
  return (table->n_buckets);
}
}
#line 158 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table *table ) 
{ 


  {
#line 160
  return (table->n_buckets_used);
}
}
#line 166 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_get_n_entries(Hash_table *table ) 
{ 


  {
#line 168
  return (table->n_entries);
}
}
#line 174 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  size_t max_bucket_length ;
  struct hash_entry *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (bucket < table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  bucket ++;
#line 194
  return (max_bucket_length);
}
}
#line 201 "/tmp/0/patch-2.7.1/lib/hash.c"
int hash_table_ok(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (bucket < table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  bucket ++;
#line 223
  if (n_buckets_used == table->n_buckets_used) {
#line 223
    if (n_entries == table->n_entries) {
#line 224
      return (1);
    }
  }
#line 226
  return (0);
}
}
#line 230 "/tmp/0/patch-2.7.1/lib/hash.c"
void hash_print_statistics(Hash_table *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t __cil_tmp4 ;
  size_t n_buckets ;
  size_t __cil_tmp6 ;
  size_t n_buckets_used ;
  size_t __cil_tmp8 ;
  size_t max_bucket_length ;
  size_t __cil_tmp10 ;

  {
  {
#line 232
  __cil_tmp4 = hash_get_n_entries(table);
#line 232
  n_entries = __cil_tmp4;
#line 233
  __cil_tmp6 = hash_get_n_buckets(table);
#line 233
  n_buckets = __cil_tmp6;
#line 234
  __cil_tmp8 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = __cil_tmp8;
#line 235
  __cil_tmp10 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = __cil_tmp10;
#line 237
  fprintf(stream, (char const   *)((char *)"# entries:         %lu\n"), n_entries);
#line 238
  fprintf(stream, (char const   *)((char *)"# buckets:         %lu\n"), n_buckets);
#line 239
  fprintf(stream, (char const   *)((char *)"# buckets used:    %lu (%.2f%%)\n"), n_buckets_used,
          (100. * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf(stream, (char const   *)((char *)"max bucket length: %lu\n"), max_bucket_length);
  }
}
}
#line 249 "/tmp/0/patch-2.7.1/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table *table , void const   *key ) 
{ 
  size_t n ;
  size_t __cil_tmp4 ;

  {
  {
#line 251
  __cil_tmp4 = (table->hasher)(key, table->n_buckets);
#line 251
  n = __cil_tmp4;
  }
#line 252
  if (! (n < table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return (table->bucket + n);
}
}
#line 261 "/tmp/0/patch-2.7.1/lib/hash.c"
void *hash_lookup(Hash_table *table , void const   *entry ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp4 ;
  struct hash_entry *cursor ;
  int __cil_tmp6 ;

  {
  {
#line 263
  __cil_tmp4 = safe_hasher(table, entry);
#line 263
  bucket = __cil_tmp4;
  }
#line 266
  if (bucket->data == (void *)0) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
    {
#line 270
    __cil_tmp6 = (table->comparator)(entry, (void const   *)cursor->data);
    }
#line 270
    if (entry == (void const   *)cursor->data) {
#line 271
      return (cursor->data);
    } else
#line 270
    if (__cil_tmp6) {
#line 271
      return (cursor->data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  cursor = cursor->next;
#line 273
  return ((void *)0);
}
}
#line 288 "/tmp/0/patch-2.7.1/lib/hash.c"
void *hash_get_first(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! 1) {
#line 295
      goto while_break;
    }
#line 296
    if (! (bucket < table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return (bucket->data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  bucket ++;
}
}
#line 307 "/tmp/0/patch-2.7.1/lib/hash.c"
void *hash_get_next(Hash_table *table , void const   *entry ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp4 ;
  struct hash_entry *cursor ;

  {
  {
#line 309
  __cil_tmp4 = safe_hasher(table, entry);
#line 309
  bucket = __cil_tmp4;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (cursor->data == (void *)entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = cursor->next;
#line 314
    if (! (cursor != (struct hash_entry *)((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! (bucket < table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return (bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 336 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_get_entries(Hash_table *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  size_t __cil_tmp7 ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (bucket < table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        __cil_tmp7 = counter;
#line 351
        counter ++;
#line 351
        *(buffer + __cil_tmp7) = cursor->data;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 347
      cursor = cursor->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  bucket ++;
#line 356
  return (counter);
}
}
#line 368 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_do_for_each(Hash_table *table , Hash_processor processor , void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  int __cil_tmp7 ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (bucket < table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        __cil_tmp7 = processor(cursor->data, processor_data);
        }
#line 381
        if (! __cil_tmp7) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 379
      cursor = cursor->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  bucket ++;
#line 388
  return (counter);
}
}
#line 428 "/tmp/0/patch-2.7.1/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31UL + (unsigned long )ch) % n_buckets;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  string ++;
#line 435
  return (value);
}
}
#line 463 "/tmp/0/patch-2.7.1/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  int __cil_tmp2 ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= (unsigned long )1;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (0xffffffffffffffffUL != candidate && ! __cil_tmp2)) {
#line 472
      goto while_break;
    }
#line 473
    candidate += (unsigned long )2;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 479 "/tmp/0/patch-2.7.1/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = default_tuning;
}
}
#line 486 "/tmp/0/patch-2.7.1/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t __cil_tmp4 ;

  {
  {
#line 493
  __cil_tmp4 = rotr_sz((size_t )data, 3);
#line 493
  val = __cil_tmp4;
  }
#line 494
  return (val % n);
}
}
#line 499 "/tmp/0/patch-2.7.1/lib/hash.c"
static int raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return (a == b);
}
}
#line 512 "/tmp/0/patch-2.7.1/lib/hash.c"
static int check_tuning(Hash_table *table ) 
{ 
  Hash_tuning *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if (tuning == & default_tuning) {
#line 517
    return (1);
  }
#line 524
  epsilon = 0.100000001491f;
#line 526
  if (epsilon < tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float )1 - epsilon) {
#line 526
      if ((float )1 + epsilon < tuning->growth_factor) {
#line 526
        if ((float )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float )1) {
#line 526
              if (tuning->shrink_threshold + epsilon < tuning->growth_threshold) {
#line 533
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return (0);
}
}
#line 544 "/tmp/0/patch-2.7.1/lib/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )candidate / tuning->growth_threshold;
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = - 1;
  } else {
#line 554
    tmp = - 2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t )0);
  }
#line 556
  return (candidate);
}
}
#line 594 "/tmp/0/patch-2.7.1/lib/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning *tuning , Hash_hasher hasher ,
                            Hash_comparator comparator , Hash_data_freer data_freer ) 
{ 
  Hash_table *table ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp10 ;

  {
#line 600
  if (hasher == (Hash_hasher )((void *)0)) {
#line 601
    hasher = raw_hasher;
  }
#line 602
  if (comparator == (Hash_comparator )((void *)0)) {
#line 603
    comparator = raw_comparator;
  }
  {
#line 605
  __cil_tmp7 = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)__cil_tmp7;
  }
#line 606
  if (table == (Hash_table *)((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  __cil_tmp8 = check_tuning(table);
  }
#line 612
  if (! __cil_tmp8) {
#line 619
    goto fail;
  }
  {
#line 622
  table->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  __cil_tmp10 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)__cil_tmp10;
  }
#line 627
  if (table->bucket == (struct hash_entry *)((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = table->bucket + table->n_buckets;
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 653 "/tmp/0/patch-2.7.1/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (bucket < table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (table->data_freer)(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 665
      cursor = next;
#line 679
      if (table->data_freer) {
        {
#line 680
        (table->data_freer)(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  bucket ++;
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
}
}
#line 696 "/tmp/0/patch-2.7.1/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! (bucket < table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (table->data_freer)(cursor->data);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 709
          cursor = cursor->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 705
      bucket ++;
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! (bucket < table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 724
    cursor = next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 722
  bucket ++;
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 732
  cursor = next;
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
}
}
#line 751 "/tmp/0/patch-2.7.1/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *__cil_tmp3 ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    __cil_tmp3 = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)__cil_tmp3;
    }
  }
#line 769
  return (new);
}
}
#line 776 "/tmp/0/patch-2.7.1/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
}
}
#line 790 "/tmp/0/patch-2.7.1/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             int delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp6 ;
  struct hash_entry *cursor ;
  int __cil_tmp8 ;
  void *data ;
  struct hash_entry *next ;
  int __cil_tmp11 ;
  void *data___0 ;
  struct hash_entry *next___0 ;

  {
  {
#line 793
  __cil_tmp6 = safe_hasher(table, entry);
#line 793
  bucket = __cil_tmp6;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if (bucket->data == (void *)0) {
#line 800
    return ((void *)0);
  }
  {
#line 803
  __cil_tmp8 = (table->comparator)(entry, (void const   *)bucket->data);
  }
#line 803
  if (entry == (void const   *)bucket->data) {
    _L: /* CIL Label */ 
#line 805
    data = bucket->data;
#line 807
    if (delete) {
#line 809
      if (bucket->next) {
        {
#line 811
        next = bucket->next;
#line 815
        *bucket = *next;
#line 816
        free_entry(table, next);
        }
      } else {
#line 820
        bucket->data = (void *)0;
      }
    }
#line 824
    return (data);
  } else
#line 803
  if (__cil_tmp8) {
#line 803
    goto _L;
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
    {
#line 830
    __cil_tmp11 = (table->comparator)(entry, (void const   *)(cursor->next)->data);
    }
#line 830
    if (entry == (void const   *)(cursor->next)->data) {
      _L___51: /* CIL Label */ 
#line 833
      data___0 = (cursor->next)->data;
#line 835
      if (delete) {
        {
#line 837
        next___0 = cursor->next;
#line 841
        cursor->next = next___0->next;
#line 842
        free_entry(table, next___0);
        }
      }
#line 845
      return (data___0);
    } else
#line 830
    if (__cil_tmp11) {
#line 830
      goto _L___51;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  cursor = cursor->next;
#line 850
  return ((void *)0);
}
}
#line 860 "/tmp/0/patch-2.7.1/lib/hash.c"
static int transfer_entries(Hash_table *dst , Hash_table *src , int safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp13 ;
  size_t __cil_tmp15 ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! (bucket < src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher(dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 877
      cursor = next;
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto while_continue;
      }
      {
#line 907
      new_bucket = safe_hasher(dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        __cil_tmp13 = allocate_entry(dst);
#line 913
        new_entry = __cil_tmp13;
        }
#line 915
        if (new_entry == (struct hash_entry *)((void *)0)) {
#line 916
          return (0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      __cil_tmp15 = src->n_buckets_used;
#line 929
      (src->n_buckets_used) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 865
  bucket ++;
#line 931
  return (1);
}
}
#line 943 "/tmp/0/patch-2.7.1/lib/hash.c"
int hash_rehash(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 947
  __cil_tmp6 = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = __cil_tmp6;
  }
#line 949
  if (! new_size) {
#line 950
    return (0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return (1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  __cil_tmp7 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)__cil_tmp7;
  }
#line 955
  if (new_table->bucket == (struct hash_entry *)((void *)0)) {
#line 956
    return (0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = new_table->bucket + new_size;
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  __cil_tmp8 = transfer_entries(new_table, table, 0);
  }
#line 986
  if (__cil_tmp8) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return (1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  __cil_tmp10 = transfer_entries(table, new_table, 0);
  }
  {
#line 1013
  __cil_tmp9 = transfer_entries(table, new_table, 1);
  }
#line 1013
  if (! (__cil_tmp9 && __cil_tmp10)) {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return (0);
}
}
#line 1038 "/tmp/0/patch-2.7.1/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning *tuning ;
  float candidate ;
  float tmp ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp13 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, 0);
  }
#line 1051
  if (data != (void *)0) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float )table->n_buckets_used > (table->tuning)->growth_threshold * (float )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float )table->n_buckets_used > (table->tuning)->growth_threshold * (float )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (- 1);
      }
      {
#line 1083
      __cil_tmp10 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! __cil_tmp10) {
#line 1084
        return (- 1);
      }
      {
#line 1087
      __cil_tmp11 = hash_find_entry(table, entry, & bucket, 0);
      }
#line 1087
      if (__cil_tmp11 != (void *)0) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    __cil_tmp13 = allocate_entry(table);
#line 1096
    new_entry = __cil_tmp13;
    }
#line 1098
    if (new_entry == (struct hash_entry *)((void *)0)) {
#line 1099
      return (- 1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1122 "/tmp/0/patch-2.7.1/lib/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 1124
  __cil_tmp4 = hash_insert_if_absent(table, entry, matched_ent);
  }
#line 1124
  return (__cil_tmp4);
}
}
#line 1134 "/tmp/0/patch-2.7.1/lib/hash.c"
void *hash_insert(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int __cil_tmp5 ;
  void const   *tmp ;
  void *tmp___52 ;

  {
  {
#line 1137
  __cil_tmp5 = hash_insert_if_absent(table, entry, & matched_ent);
#line 1137
  err = __cil_tmp5;
  }
#line 1138
  if (err == -1) {
#line 1138
    tmp___52 = (void *)0;
  } else {
#line 1138
    if (err == 0) {
#line 1138
      tmp = matched_ent;
    } else {
#line 1138
      tmp = entry;
    }
#line 1138
    tmp___52 = (void *)tmp;
  }
#line 1138
  return (tmp___52);
}
}
#line 1148 "/tmp/0/patch-2.7.1/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  Hash_tuning *tuning ;
  size_t candidate ;
  float tmp ;
  int __cil_tmp11 ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
  {
#line 1153
  data = hash_find_entry(table, entry, & bucket, 1);
  }
#line 1154
  if (! data) {
#line 1155
    return ((void *)0);
  }
#line 1157
  __cil_tmp6 = table->n_entries;
#line 1157
  (table->n_entries) --;
#line 1158
  if (! bucket->data) {
#line 1160
    __cil_tmp7 = table->n_buckets_used;
#line 1160
    (table->n_buckets_used) --;
#line 1165
    if ((float )table->n_buckets_used < (table->tuning)->shrink_threshold * (float )table->n_buckets) {
      {
#line 1170
      check_tuning(table);
      }
#line 1171
      if ((float )table->n_buckets_used < (table->tuning)->shrink_threshold * (float )table->n_buckets) {
#line 1174
        tuning = table->tuning;
#line 1175
        if (tuning->is_n_buckets) {
#line 1175
          tmp = (float )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1175
          tmp = ((float )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1175
        candidate = (size_t )tmp;
#line 1181
        __cil_tmp11 = hash_rehash(table, candidate);
        }
#line 1181
        if (! __cil_tmp11) {
#line 1189
          cursor = table->free_entry_list;
          {
#line 1191
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1191
            if (! cursor) {
#line 1191
              goto while_break;
            }
            {
#line 1193
            next = cursor->next;
#line 1194
            free((void *)cursor);
#line 1195
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1197
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1204
  return (data);
}
}
#line 27 "./gl_linked_list.h"
struct gl_list_implementation gl_linked_list_implementation ;
#line 40 "./gl_anylinked_list2.h"
static gl_list_t gl_linked_nx_create_empty(gl_list_implementation_t implementation ,
                                           gl_listelement_equals_fn equals_fn , gl_listelement_hashcode_fn hashcode_fn ,
                                           gl_listelement_dispose_fn dispose_fn ,
                                           int allow_duplicates ) 
{ 
  struct gl_list_impl *list___53 ;
  void *__cil_tmp7 ;

  {
  {
#line 46
  __cil_tmp7 = malloc(sizeof(struct gl_list_impl ));
#line 46
  list___53 = (struct gl_list_impl *)__cil_tmp7;
  }
#line 49
  if (list___53 == (struct gl_list_impl *)((void *)0)) {
#line 50
    return ((gl_list_t )((void *)0));
  }
#line 52
  list___53->base.vtable = implementation;
#line 53
  list___53->base.equals_fn = equals_fn;
#line 54
  list___53->base.hashcode_fn = hashcode_fn;
#line 55
  list___53->base.dispose_fn = dispose_fn;
#line 56
  list___53->base.allow_duplicates = allow_duplicates;
#line 64
  list___53->root.next = & list___53->root;
#line 65
  list___53->root.prev = & list___53->root;
#line 66
  list___53->count = (size_t )0;
#line 68
  return (list___53);
}
}
#line 78 "./gl_anylinked_list2.h"
static gl_list_t gl_linked_nx_create(gl_list_implementation_t implementation , gl_listelement_equals_fn equals_fn ,
                                     gl_listelement_hashcode_fn hashcode_fn , gl_listelement_dispose_fn dispose_fn ,
                                     int allow_duplicates , size_t count , void const   **contents ) 
{ 
  struct gl_list_impl *list___54 ;
  void *__cil_tmp9 ;
  gl_list_node_t tail ;
  gl_list_node_t node___55 ;
  void *__cil_tmp12 ;
  void const   **__cil_tmp13 ;
  size_t __cil_tmp14 ;
  gl_list_node_t node___56 ;
  gl_list_node_t prev ;

  {
  {
#line 85
  __cil_tmp9 = malloc(sizeof(struct gl_list_impl ));
#line 85
  list___54 = (struct gl_list_impl *)__cil_tmp9;
  }
#line 89
  if (list___54 == (struct gl_list_impl *)((void *)0)) {
#line 90
    return ((gl_list_t )((void *)0));
  }
#line 92
  list___54->base.vtable = implementation;
#line 93
  list___54->base.equals_fn = equals_fn;
#line 94
  list___54->base.hashcode_fn = hashcode_fn;
#line 95
  list___54->base.dispose_fn = dispose_fn;
#line 96
  list___54->base.allow_duplicates = allow_duplicates;
#line 111
  list___54->count = count;
#line 112
  tail = & list___54->root;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (count > 0UL)) {
#line 113
      goto while_break;
    }
    {
#line 115
    __cil_tmp12 = malloc(sizeof(struct gl_list_node_impl ));
#line 115
    node___55 = (struct gl_list_node_impl *)__cil_tmp12;
    }
#line 118
    if (node___55 == (gl_list_node_t )((void *)0)) {
#line 119
      goto fail2;
    }
#line 121
    node___55->value = *contents;
#line 137
    node___55->prev = tail;
#line 138
    tail->next = node___55;
#line 139
    tail = node___55;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  __cil_tmp14 = count;
#line 113
  count --;
#line 113
  __cil_tmp13 = contents;
#line 113
  contents ++;
#line 141
  tail->next = & list___54->root;
#line 142
  list___54->root.prev = tail;
#line 144
  return (list___54);
  fail2: 
#line 150
  node___56 = tail;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! (node___56 != & list___54->root)) {
#line 150
      goto while_break___0;
    }
    {
#line 152
    prev = node___56->prev;
#line 154
    free((void *)node___56);
#line 155
    node___56 = prev;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 162
  free((void *)list___54);
  }
#line 163
  return ((gl_list_t )((void *)0));
}
}
#line 167 "./gl_anylinked_list2.h"
static size_t gl_linked_size(gl_list_t list ) 
{ 


  {
#line 169
  return (list->count);
}
}
#line 173 "./gl_anylinked_list2.h"
static void const   *gl_linked_node_value(gl_list_t list , gl_list_node_t node ) 
{ 


  {
#line 175
  return (node->value);
}
}
#line 179 "./gl_anylinked_list2.h"
static int gl_linked_node_nx_set_value(gl_list_t list , gl_list_node_t node , void const   *elt ) 
{ 


  {
#line 213
  node->value = elt;
#line 215
  return (0);
}
}
#line 219 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_next_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 221
  if (node->next != & list->root) {
#line 221
    tmp = node->next;
  } else {
#line 221
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 221
  return (tmp);
}
}
#line 225 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_previous_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 227
  if (node->prev != & list->root) {
#line 227
    tmp = node->prev;
  } else {
#line 227
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 227
  return (tmp);
}
}
#line 231 "./gl_anylinked_list2.h"
static void const   *gl_linked_get_at(gl_list_t list , size_t position ) 
{ 
  size_t count___57 ;
  gl_list_node_t node___58 ;
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
#line 233
  count___57 = list->count;
#line 236
  if (! (position < count___57)) {
    {
#line 238
    abort();
    }
  }
#line 240
  if (position <= (count___57 - 1UL) / 2UL) {
#line 242
    node___58 = list->root.next;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! (position > 0UL)) {
#line 243
        goto while_break;
      }
#line 244
      node___58 = node___58->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 243
    __cil_tmp5 = position;
#line 243
    position --;
  } else {
#line 248
    position = (count___57 - 1UL) - position;
#line 249
    node___58 = list->root.prev;
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! (position > 0UL)) {
#line 250
        goto while_break___0;
      }
#line 251
      node___58 = node___58->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 250
    __cil_tmp6 = position;
#line 250
    position --;
  }
#line 253
  return (node___58->value);
}
}
#line 257 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_set_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count___59 ;
  gl_list_node_t node___60 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
#line 259
  count___59 = list->count;
#line 262
  if (! (position < count___59)) {
    {
#line 264
    abort();
    }
  }
#line 266
  if (position <= (count___59 - 1UL) / 2UL) {
#line 268
    node___60 = list->root.next;
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! (position > 0UL)) {
#line 269
        goto while_break;
      }
#line 270
      node___60 = node___60->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 269
    __cil_tmp6 = position;
#line 269
    position --;
  } else {
#line 274
    position = (count___59 - 1UL) - position;
#line 275
    node___60 = list->root.prev;
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      if (! (position > 0UL)) {
#line 276
        goto while_break___0;
      }
#line 277
      node___60 = node___60->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    __cil_tmp7 = position;
#line 276
    position --;
  }
#line 310
  node___60->value = elt;
#line 312
  return (node___60);
}
}
#line 316 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_search_from_to(gl_list_t list , size_t start_index ,
                                               size_t end_index , void const   *elt ) 
{ 
  size_t count___61 ;
  gl_listelement_equals_fn equals ;
  gl_list_node_t node___62 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 319
  count___61 = list->count;
#line 321
  if (! (start_index <= end_index && end_index <= count___61)) {
    {
#line 323
    abort();
    }
  }
#line 444
  equals = list->base.equals_fn;
#line 445
  node___62 = list->root.next;
#line 447
  end_index -= start_index;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (start_index > 0UL)) {
#line 448
      goto while_break;
    }
#line 449
    node___62 = node___62->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  __cil_tmp8 = start_index;
#line 448
  start_index --;
#line 451
  if (equals != (gl_listelement_equals_fn )((void *)0)) {
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      if (! (end_index > 0UL)) {
#line 453
        goto while_break___0;
      }
      {
#line 454
      __cil_tmp9 = equals(elt, node___62->value);
      }
#line 454
      if (__cil_tmp9) {
#line 455
        return (node___62);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    __cil_tmp10 = end_index;
#line 453
    end_index --;
#line 453
    node___62 = node___62->next;
  } else {
    {
#line 459
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 459
      if (! (end_index > 0UL)) {
#line 459
        goto while_break___1;
      }
#line 460
      if (elt == node___62->value) {
#line 461
        return (node___62);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 459
    __cil_tmp11 = end_index;
#line 459
    end_index --;
#line 459
    node___62 = node___62->next;
  }
#line 463
  return ((gl_list_node_t )((void *)0));
}
}
#line 469 "./gl_anylinked_list2.h"
static size_t gl_linked_indexof_from_to(gl_list_t list , size_t start_index , size_t end_index ,
                                        void const   *elt ) 
{ 
  size_t count___63 ;
  gl_listelement_equals_fn equals ;
  size_t index ;
  gl_list_node_t node___64 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
#line 472
  count___63 = list->count;
#line 474
  if (! (start_index <= end_index && end_index <= count___63)) {
    {
#line 476
    abort();
    }
  }
#line 567
  equals = list->base.equals_fn;
#line 568
  index = start_index;
#line 569
  node___64 = list->root.next;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (start_index > 0UL)) {
#line 571
      goto while_break;
    }
#line 572
    node___64 = node___64->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  __cil_tmp9 = start_index;
#line 571
  start_index --;
#line 574
  if (equals != (gl_listelement_equals_fn )((void *)0)) {
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 576
      if (! (index < end_index)) {
#line 576
        goto while_break___0;
      }
      {
#line 579
      __cil_tmp10 = equals(elt, node___64->value);
      }
#line 579
      if (__cil_tmp10) {
#line 580
        return (index);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 578
    __cil_tmp11 = index;
#line 578
    index ++;
#line 578
    node___64 = node___64->next;
  } else {
    {
#line 584
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 584
      if (! (index < end_index)) {
#line 584
        goto while_break___1;
      }
#line 587
      if (elt == node___64->value) {
#line 588
        return (index);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 586
    __cil_tmp12 = index;
#line 586
    index ++;
#line 586
    node___64 = node___64->next;
  }
#line 590
  return ((size_t )(- 1));
}
}
#line 596 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_first(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node___65 ;
  void *__cil_tmp4 ;

  {
  {
#line 598
  __cil_tmp4 = malloc(sizeof(struct gl_list_node_impl ));
#line 598
  node___65 = (struct gl_list_node_impl *)__cil_tmp4;
  }
#line 601
  if (node___65 == (gl_list_node_t )((void *)0)) {
#line 602
    return ((gl_list_node_t )((void *)0));
  }
#line 604
  node___65->value = elt;
#line 620
  node___65->prev = & list->root;
#line 621
  node___65->next = list->root.next;
#line 622
  (node___65->next)->prev = node___65;
#line 623
  list->root.next = node___65;
#line 624
  (list->count) ++;
#line 630
  return (node___65);
}
}
#line 634 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_last(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node___66 ;
  void *__cil_tmp4 ;

  {
  {
#line 636
  __cil_tmp4 = malloc(sizeof(struct gl_list_node_impl ));
#line 636
  node___66 = (struct gl_list_node_impl *)__cil_tmp4;
  }
#line 639
  if (node___66 == (gl_list_node_t )((void *)0)) {
#line 640
    return ((gl_list_node_t )((void *)0));
  }
#line 642
  node___66->value = elt;
#line 658
  node___66->next = & list->root;
#line 659
  node___66->prev = list->root.prev;
#line 660
  (node___66->prev)->next = node___66;
#line 661
  list->root.prev = node___66;
#line 662
  (list->count) ++;
#line 668
  return (node___66);
}
}
#line 672 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_before(gl_list_t list , gl_list_node_t node ,
                                              void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *__cil_tmp5 ;

  {
  {
#line 674
  __cil_tmp5 = malloc(sizeof(struct gl_list_node_impl ));
#line 674
  new_node = (struct gl_list_node_impl *)__cil_tmp5;
  }
#line 677
  if (new_node == (gl_list_node_t )((void *)0)) {
#line 678
    return ((gl_list_node_t )((void *)0));
  }
#line 680
  new_node->value = elt;
#line 696
  new_node->next = node;
#line 697
  new_node->prev = node->prev;
#line 698
  (new_node->prev)->next = new_node;
#line 699
  node->prev = new_node;
#line 700
  (list->count) ++;
#line 706
  return (new_node);
}
}
#line 710 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_after(gl_list_t list , gl_list_node_t node ,
                                             void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *__cil_tmp5 ;

  {
  {
#line 712
  __cil_tmp5 = malloc(sizeof(struct gl_list_node_impl ));
#line 712
  new_node = (struct gl_list_node_impl *)__cil_tmp5;
  }
#line 715
  if (new_node == (gl_list_node_t )((void *)0)) {
#line 716
    return ((gl_list_node_t )((void *)0));
  }
#line 718
  new_node->value = elt;
#line 734
  new_node->prev = node;
#line 735
  new_node->next = node->next;
#line 736
  (new_node->next)->prev = new_node;
#line 737
  node->next = new_node;
#line 738
  (list->count) ++;
#line 744
  return (new_node);
}
}
#line 748 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count___67 ;
  gl_list_node_t new_node ;
  void *__cil_tmp6 ;
  gl_list_node_t node___68 ;
  size_t __cil_tmp8 ;
  gl_list_node_t node___69 ;
  size_t __cil_tmp10 ;

  {
#line 750
  count___67 = list->count;
#line 753
  if (! (position <= count___67)) {
    {
#line 755
    abort();
    }
  }
  {
#line 757
  __cil_tmp6 = malloc(sizeof(struct gl_list_node_impl ));
#line 757
  new_node = (struct gl_list_node_impl *)__cil_tmp6;
  }
#line 758
  if (new_node == (gl_list_node_t )((void *)0)) {
#line 759
    return ((gl_list_node_t )((void *)0));
  }
#line 761
  new_node->value = elt;
#line 777
  if (position <= count___67 / 2UL) {
#line 781
    node___68 = & list->root;
    {
#line 782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 782
      if (! (position > 0UL)) {
#line 782
        goto while_break;
      }
#line 783
      node___68 = node___68->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 782
    __cil_tmp8 = position;
#line 782
    position --;
#line 784
    new_node->prev = node___68;
#line 785
    new_node->next = node___68->next;
#line 786
    (new_node->next)->prev = new_node;
#line 787
    node___68->next = new_node;
  } else {
#line 793
    position = count___67 - position;
#line 794
    node___69 = & list->root;
    {
#line 795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 795
      if (! (position > 0UL)) {
#line 795
        goto while_break___0;
      }
#line 796
      node___69 = node___69->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 795
    __cil_tmp10 = position;
#line 795
    position --;
#line 797
    new_node->next = node___69;
#line 798
    new_node->prev = node___69->prev;
#line 799
    (new_node->prev)->next = new_node;
#line 800
    node___69->prev = new_node;
  }
#line 802
  (list->count) ++;
#line 808
  return (new_node);
}
}
#line 812 "./gl_anylinked_list2.h"
static int gl_linked_remove_node(gl_list_t list , gl_list_node_t node ) 
{ 
  gl_list_node_t prev ;
  gl_list_node_t next ;
  size_t __cil_tmp5 ;

  {
#line 823
  prev = node->prev;
#line 824
  next = node->next;
#line 826
  prev->next = next;
#line 827
  next->prev = prev;
#line 828
  __cil_tmp5 = list->count;
#line 828
  (list->count) --;
#line 830
  if (list->base.dispose_fn != (gl_listelement_dispose_fn )((void *)0)) {
    {
#line 831
    (list->base.dispose_fn)(node->value);
    }
  }
  {
#line 832
  free((void *)node);
  }
#line 833
  return (1);
}
}
#line 837 "./gl_anylinked_list2.h"
static int gl_linked_remove_at(gl_list_t list , size_t position ) 
{ 
  size_t count___70 ;
  gl_list_node_t removed_node ;
  gl_list_node_t node___71 ;
  gl_list_node_t after_removed ;
  size_t __cil_tmp7 ;
  gl_list_node_t node___72 ;
  gl_list_node_t before_removed ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 839
  count___70 = list->count;
#line 842
  if (! (position < count___70)) {
    {
#line 844
    abort();
    }
  }
#line 846
  if (position <= (count___70 - 1UL) / 2UL) {
#line 851
    node___71 = & list->root;
    {
#line 852
    while (1) {
      while_continue: /* CIL Label */ ;
#line 852
      if (! (position > 0UL)) {
#line 852
        goto while_break;
      }
#line 853
      node___71 = node___71->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 852
    __cil_tmp7 = position;
#line 852
    position --;
#line 854
    removed_node = node___71->next;
#line 855
    after_removed = (node___71->next)->next;
#line 856
    node___71->next = after_removed;
#line 857
    after_removed->prev = node___71;
  } else {
#line 864
    position = (count___70 - 1UL) - position;
#line 865
    node___72 = & list->root;
    {
#line 866
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 866
      if (! (position > 0UL)) {
#line 866
        goto while_break___0;
      }
#line 867
      node___72 = node___72->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 866
    __cil_tmp10 = position;
#line 866
    position --;
#line 868
    removed_node = node___72->prev;
#line 869
    before_removed = (node___72->prev)->prev;
#line 870
    node___72->prev = before_removed;
#line 871
    before_removed->next = node___72;
  }
#line 876
  __cil_tmp11 = list->count;
#line 876
  (list->count) --;
#line 878
  if (list->base.dispose_fn != (gl_listelement_dispose_fn )((void *)0)) {
    {
#line 879
    (list->base.dispose_fn)(removed_node->value);
    }
  }
  {
#line 880
  free((void *)removed_node);
  }
#line 881
  return (1);
}
}
#line 885 "./gl_anylinked_list2.h"
static int gl_linked_remove(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node___73 ;
  gl_list_node_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 887
  __cil_tmp4 = gl_linked_search_from_to(list, (size_t )0, list->count, elt);
#line 887
  node___73 = __cil_tmp4;
  }
#line 889
  if (node___73 != (gl_list_node_t )((void *)0)) {
    {
#line 890
    __cil_tmp5 = gl_linked_remove_node(list, node___73);
    }
#line 890
    return (__cil_tmp5);
  } else {
#line 892
    return (0);
  }
}
}
#line 896 "./gl_anylinked_list2.h"
static void gl_linked_list_free(gl_list_t list ) 
{ 
  gl_listelement_dispose_fn dispose ;
  gl_list_node_t node___74 ;
  gl_list_node_t next ;

  {
#line 898
  dispose = list->base.dispose_fn;
#line 901
  node___74 = list->root.next;
  {
#line 901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 901
    if (! (node___74 != & list->root)) {
#line 901
      goto while_break;
    }
#line 903
    next = node___74->next;
#line 904
    if (dispose != (gl_listelement_dispose_fn )((void *)0)) {
      {
#line 905
      dispose(node___74->value);
      }
    }
    {
#line 906
    free((void *)node___74);
#line 907
    node___74 = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 912
  free((void *)list);
  }
}
}
#line 918 "./gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator(gl_list_t list ) 
{ 
  gl_list_iterator_t result ;

  {
#line 922
  result.vtable = list->base.vtable;
#line 923
  result.list = list;
#line 924
  result.p = (void *)list->root.next;
#line 925
  result.q = (void *)(& list->root);
#line 932
  return (result);
}
}
#line 936 "./gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator_from_to(gl_list_t list , size_t start_index ,
                                                     size_t end_index ) 
{ 
  gl_list_iterator_t result ;
  size_t n1 ;
  size_t n2 ;
  size_t n3 ;
  gl_list_node_t node___75 ;
  size_t i ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  gl_list_node_t node___76 ;
  size_t i___0 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  gl_list_node_t node___77 ;
  size_t i___1 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;

  {
#line 942
  if (! (start_index <= end_index && end_index <= list->count)) {
    {
#line 944
    abort();
    }
  }
#line 945
  result.vtable = list->base.vtable;
#line 946
  result.list = list;
#line 947
  n1 = start_index;
#line 948
  n2 = end_index - start_index;
#line 949
  n3 = list->count - end_index;
#line 952
  if (n1 > n2) {
#line 952
    if (n1 > n3) {
#line 958
      node___75 = & list->root;
#line 959
      i = n3;
      {
#line 959
      while (1) {
        while_continue: /* CIL Label */ ;
#line 959
        if (! (i > 0UL)) {
#line 959
          goto while_break;
        }
#line 960
        node___75 = node___75->prev;
      }
      while_break: /* CIL Label */ ;
      }
#line 959
      __cil_tmp10 = i;
#line 959
      i --;
#line 961
      result.q = (void *)node___75;
#line 962
      i = n2;
      {
#line 962
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 962
        if (! (i > 0UL)) {
#line 962
          goto while_break___0;
        }
#line 963
        node___75 = node___75->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 962
      __cil_tmp11 = i;
#line 962
      i --;
#line 964
      result.p = (void *)node___75;
    } else {
#line 952
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 966
  if (n2 > n3) {
#line 972
    node___76 = list->root.next;
#line 973
    i___0 = n1;
    {
#line 973
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 973
      if (! (i___0 > 0UL)) {
#line 973
        goto while_break___1;
      }
#line 974
      node___76 = node___76->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 973
    __cil_tmp14 = i___0;
#line 973
    i___0 --;
#line 975
    result.p = (void *)node___76;
#line 977
    node___76 = & list->root;
#line 978
    i___0 = n3;
    {
#line 978
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 978
      if (! (i___0 > 0UL)) {
#line 978
        goto while_break___2;
      }
#line 979
      node___76 = node___76->prev;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 978
    __cil_tmp15 = i___0;
#line 978
    i___0 --;
#line 980
    result.q = (void *)node___76;
  } else {
#line 988
    node___77 = list->root.next;
#line 989
    i___1 = n1;
    {
#line 989
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 989
      if (! (i___1 > 0UL)) {
#line 989
        goto while_break___3;
      }
#line 990
      node___77 = node___77->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 989
    __cil_tmp18 = i___1;
#line 989
    i___1 --;
#line 991
    result.p = (void *)node___77;
#line 992
    i___1 = n2;
    {
#line 992
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 992
      if (! (i___1 > 0UL)) {
#line 992
        goto while_break___4;
      }
#line 993
      node___77 = node___77->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 992
    __cil_tmp19 = i___1;
#line 992
    i___1 --;
#line 994
    result.q = (void *)node___77;
  }
#line 1003
  return (result);
}
}
#line 1007 "./gl_anylinked_list2.h"
static int gl_linked_iterator_next(gl_list_iterator_t *iterator , void const   **eltp ,
                                   gl_list_node_t *nodep ) 
{ 
  gl_list_node_t node___78 ;

  {
#line 1010
  if (iterator->p != iterator->q) {
#line 1012
    node___78 = (gl_list_node_t )iterator->p;
#line 1013
    *eltp = node___78->value;
#line 1014
    if (nodep != (gl_list_node_t *)((void *)0)) {
#line 1015
      *nodep = node___78;
    }
#line 1016
    iterator->p = (void *)node___78->next;
#line 1017
    return (1);
  } else {
#line 1020
    return (0);
  }
}
}
#line 1024 "./gl_anylinked_list2.h"
static void gl_linked_iterator_free(gl_list_iterator_t *iterator ) 
{ 


  {

}
}
#line 1031 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search(gl_list_t list , gl_listelement_compar_fn compar ,
                                                  void const   *elt ) 
{ 
  gl_list_node_t node___79 ;
  int cmp ;
  int __cil_tmp6 ;

  {
#line 1036
  node___79 = list->root.next;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (node___79 != & list->root)) {
#line 1036
      goto while_break;
    }
    {
#line 1038
    __cil_tmp6 = compar(node___79->value, elt);
#line 1038
    cmp = __cil_tmp6;
    }
#line 1040
    if (cmp > 0) {
#line 1041
      goto while_break;
    }
#line 1042
    if (cmp == 0) {
#line 1043
      return (node___79);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  node___79 = node___79->next;
#line 1045
  return ((gl_list_node_t )((void *)0));
}
}
#line 1049 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search_from_to(gl_list_t list , gl_listelement_compar_fn compar ,
                                                          size_t low , size_t high ,
                                                          void const   *elt ) 
{ 
  size_t count___80 ;
  size_t position___81 ;
  gl_list_node_t node___82 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  int cmp ;
  int __cil_tmp12 ;

  {
#line 1054
  count___80 = list->count;
#line 1056
  if (! (low <= high && high <= list->count)) {
    {
#line 1058
    abort();
    }
  }
#line 1060
  high -= low;
#line 1061
  if (high > 0UL) {
#line 1064
    position___81 = low;
#line 1067
    if (position___81 <= (count___80 - 1UL) / 2UL) {
#line 1069
      node___82 = list->root.next;
      {
#line 1070
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1070
        if (! (position___81 > 0UL)) {
#line 1070
          goto while_break;
        }
#line 1071
        node___82 = node___82->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 1070
      __cil_tmp9 = position___81;
#line 1070
      position___81 --;
    } else {
#line 1075
      position___81 = (count___80 - 1UL) - position___81;
#line 1076
      node___82 = list->root.prev;
      {
#line 1077
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1077
        if (! (position___81 > 0UL)) {
#line 1077
          goto while_break___0;
        }
#line 1078
        node___82 = node___82->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1077
      __cil_tmp10 = position___81;
#line 1077
      position___81 --;
    }
    {
#line 1081
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1083
      __cil_tmp12 = compar(node___82->value, elt);
#line 1083
      cmp = __cil_tmp12;
      }
#line 1085
      if (cmp > 0) {
#line 1086
        goto while_break___1;
      }
#line 1087
      if (cmp == 0) {
#line 1088
        return (node___82);
      }
#line 1089
      node___82 = node___82->next;
#line 1081
      if (! (high > 0UL)) {
#line 1081
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1093
  return ((gl_list_node_t )((void *)0));
}
}
#line 1097 "./gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof(gl_list_t list , gl_listelement_compar_fn compar ,
                                           void const   *elt ) 
{ 
  gl_list_node_t node___83 ;
  size_t index ;
  int cmp ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
#line 1103
  index = (size_t )0;
#line 1103
  node___83 = list->root.next;
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (! (node___83 != & list->root)) {
#line 1103
      goto while_break;
    }
    {
#line 1107
    __cil_tmp7 = compar(node___83->value, elt);
#line 1107
    cmp = __cil_tmp7;
    }
#line 1109
    if (cmp > 0) {
#line 1110
      goto while_break;
    }
#line 1111
    if (cmp == 0) {
#line 1112
      return (index);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1105
  __cil_tmp8 = index;
#line 1105
  index ++;
#line 1105
  node___83 = node___83->next;
#line 1114
  return ((size_t )(- 1));
}
}
#line 1118 "./gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof_from_to(gl_list_t list , gl_listelement_compar_fn compar ,
                                                   size_t low , size_t high , void const   *elt ) 
{ 
  size_t count___84 ;
  size_t index ;
  size_t position___85 ;
  gl_list_node_t node___86 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int cmp ;
  int __cil_tmp13 ;

  {
#line 1123
  count___84 = list->count;
#line 1125
  if (! (low <= high && high <= list->count)) {
    {
#line 1127
    abort();
    }
  }
#line 1129
  high -= low;
#line 1130
  if (high > 0UL) {
#line 1133
    index = low;
#line 1134
    position___85 = low;
#line 1137
    if (position___85 <= (count___84 - 1UL) / 2UL) {
#line 1139
      node___86 = list->root.next;
      {
#line 1140
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1140
        if (! (position___85 > 0UL)) {
#line 1140
          goto while_break;
        }
#line 1141
        node___86 = node___86->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 1140
      __cil_tmp10 = position___85;
#line 1140
      position___85 --;
    } else {
#line 1145
      position___85 = (count___84 - 1UL) - position___85;
#line 1146
      node___86 = list->root.prev;
      {
#line 1147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1147
        if (! (position___85 > 0UL)) {
#line 1147
          goto while_break___0;
        }
#line 1148
        node___86 = node___86->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1147
      __cil_tmp11 = position___85;
#line 1147
      position___85 --;
    }
    {
#line 1151
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1153
      __cil_tmp13 = compar(node___86->value, elt);
#line 1153
      cmp = __cil_tmp13;
      }
#line 1155
      if (cmp > 0) {
#line 1156
        goto while_break___1;
      }
#line 1157
      if (cmp == 0) {
#line 1158
        return (index);
      }
#line 1159
      node___86 = node___86->next;
#line 1160
      index ++;
#line 1151
      if (! (high > 0UL)) {
#line 1151
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1164
  return ((size_t )(- 1));
}
}
#line 1168 "./gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_nx_add(gl_list_t list , gl_listelement_compar_fn compar ,
                                                  void const   *elt ) 
{ 
  gl_list_node_t node___87 ;
  int __cil_tmp5 ;
  gl_list_node_t __cil_tmp6 ;
  gl_list_node_t __cil_tmp7 ;

  {
#line 1173
  node___87 = list->root.next;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (node___87 != & list->root)) {
#line 1173
      goto while_break;
    }
    {
#line 1174
    __cil_tmp5 = compar(node___87->value, elt);
    }
#line 1174
    if (__cil_tmp5 >= 0) {
      {
#line 1175
      __cil_tmp6 = gl_linked_nx_add_before(list, node___87, elt);
      }
#line 1175
      return (__cil_tmp6);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1173
  node___87 = node___87->next;
#line 1176
  __cil_tmp7 = gl_linked_nx_add_last(list, elt);
  }
#line 1176
  return (__cil_tmp7);
}
}
#line 1180 "./gl_anylinked_list2.h"
static int gl_linked_sortedlist_remove(gl_list_t list , gl_listelement_compar_fn compar ,
                                       void const   *elt ) 
{ 
  gl_list_node_t node___88 ;
  int cmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1185
  node___88 = list->root.next;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    if (! (node___88 != & list->root)) {
#line 1185
      goto while_break;
    }
    {
#line 1187
    __cil_tmp6 = compar(node___88->value, elt);
#line 1187
    cmp = __cil_tmp6;
    }
#line 1189
    if (cmp > 0) {
#line 1190
      goto while_break;
    }
#line 1191
    if (cmp == 0) {
      {
#line 1192
      __cil_tmp7 = gl_linked_remove_node(list, node___88);
      }
#line 1192
      return (__cil_tmp7);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1185
  node___88 = node___88->next;
#line 1194
  return (0);
}
}
#line 32 "/tmp/0/patch-2.7.1/lib/gl_linked_list.c"
struct gl_list_implementation gl_linked_list_implementation  = 
#line 32 "/tmp/0/patch-2.7.1/lib/gl_linked_list.c"
     {gl_linked_nx_create_empty, gl_linked_nx_create, gl_linked_size, gl_linked_node_value,
    gl_linked_node_nx_set_value, gl_linked_next_node, gl_linked_previous_node, gl_linked_get_at,
    gl_linked_nx_set_at, gl_linked_search_from_to, gl_linked_indexof_from_to, gl_linked_nx_add_first,
    gl_linked_nx_add_last, gl_linked_nx_add_before, gl_linked_nx_add_after, gl_linked_nx_add_at,
    gl_linked_remove_node, gl_linked_remove_at, gl_linked_remove, gl_linked_list_free,
    gl_linked_iterator, gl_linked_iterator_from_to, gl_linked_iterator_next, gl_linked_iterator_free,
    gl_linked_sortedlist_search, gl_linked_sortedlist_search_from_to, gl_linked_sortedlist_indexof,
    gl_linked_sortedlist_indexof_from_to, gl_linked_sortedlist_nx_add, gl_linked_sortedlist_remove};
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 29 "/tmp/0/patch-2.7.1/lib/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int __cil_tmp2 ;
  struct timeval tv ;

  {
  {
#line 36
  __cil_tmp2 = clock_gettime(0, ts);
  }
#line 36
  if (__cil_tmp2 == 0) {
#line 37
    return;
  }
  {
#line 42
  gettimeofday(& tv, (struct timezone *)((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
}
}
#line 29 "./full-write.h"
size_t full_write(int fd , void const   *buf___0 , size_t count ) ;
#line 58 "/tmp/0/patch-2.7.1/lib/full-write.c"
size_t full_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t __cil_tmp7 ;
  int *__cil_tmp8 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char const   *)buf___0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (count > 0UL)) {
#line 63
      goto while_break;
    }
    {
#line 65
    __cil_tmp7 = safe_write(fd, (void const   *)ptr, count);
#line 65
    n_rw = __cil_tmp7;
    }
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      goto while_break;
    }
#line 68
    if (n_rw == 0UL) {
      {
#line 70
      __cil_tmp8 = __errno_location();
#line 70
      *__cil_tmp8 = 28;
      }
#line 71
      goto while_break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (total);
}
}
#line 37 "/tmp/0/patch-2.7.1/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int __cil_tmp3 ;
  int e ;
  int *__cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      __cil_tmp3 = dup_safer(fd);
#line 41
      f = __cil_tmp3;
#line 42
      __cil_tmp5 = __errno_location();
#line 42
      e = *__cil_tmp5;
#line 43
      close(fd);
#line 44
      __cil_tmp6 = __errno_location();
#line 44
      *__cil_tmp6 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 403 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 169 "/tmp/0/patch-2.7.1/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  static int have_dupfd_cloexec ;
  int tmp ;
  int *__cil_tmp9 ;
  int flags ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int saved_errno ;
  int *__cil_tmp16 ;
  int *__cil_tmp17 ;
  void *p ;

  {
  {
#line 172
  result = - 1;
#line 173
  __builtin_va_start((__builtin_va_list *)arg, action);
  }
  {
#line 217
  if (action == 1030) {
#line 217
    goto case_1030;
  }
#line 298
  goto switch_default;
  case_1030: /* CIL Label */ 
#line 219
  target = 0;
#line 232
  tmp = 0;
#line 232
  have_dupfd_cloexec = tmp;
#line 233
  if (0 <= have_dupfd_cloexec) {
    {
#line 235
    result = fcntl(fd, action, target);
#line 236
    __cil_tmp9 = __errno_location();
    }
#line 236
    if (0 <= result) {
#line 238
      have_dupfd_cloexec = 1;
    } else
#line 236
    if (*__cil_tmp9 != 22) {
#line 238
      have_dupfd_cloexec = 1;
    } else {
      {
#line 246
      result = rpl_fcntl(fd, 0, target);
      }
#line 247
      if (result < 0) {
#line 248
        goto switch_break;
      }
#line 249
      have_dupfd_cloexec = - 1;
    }
  } else {
    {
#line 253
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 254
  if (0 <= result) {
#line 254
    if (have_dupfd_cloexec == -1) {
      {
#line 256
      __cil_tmp13 = fcntl(result, 1);
#line 256
      flags = __cil_tmp13;
#line 257
      __cil_tmp14 = fcntl(result, 2, flags | 1);
      }
#line 257
      if (flags < 0) {
        _L: /* CIL Label */ 
        {
#line 259
        __cil_tmp16 = __errno_location();
#line 259
        saved_errno = *__cil_tmp16;
#line 260
        close(result);
#line 261
        __cil_tmp17 = __errno_location();
#line 261
        *__cil_tmp17 = saved_errno;
#line 262
        result = - 1;
        }
      } else
#line 257
      if (__cil_tmp14 == -1) {
#line 257
        goto _L;
      }
    }
  }
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  p = 0;
#line 302
  result = fcntl(fd, action, p);
  }
#line 306
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 309
  __builtin_va_end((__builtin_va_list *)arg);
  }
#line 310
  return (result);
}
}
#line 24 "/tmp/0/patch-2.7.1/lib/exitfail.c"
int exit_failure  =    1;
#line 31 "/tmp/0/patch-2.7.1/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 33
  __cil_tmp2 = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (__cil_tmp2);
}
}
#line 36 "./dirname.h"
char *dir_name(char const   *file ) ;
#line 39
char *mdir_name(char const   *file ) ;
#line 32 "/tmp/0/patch-2.7.1/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *__cil_tmp3 ;

  {
  {
#line 34
  __cil_tmp3 = mdir_name(file);
#line 34
  result = __cil_tmp3;
  }
#line 35
  if (! result) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (result);
}
}
#line 41 "./dirname.h"
size_t dir_len(char const   *file ) ;
#line 32 "/tmp/0/patch-2.7.1/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___90 ;
  int tmp___91 ;
  char *__cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___91 = 0;
  } else {
#line 38
    if ((int )((char )*(file + 0)) == 47) {
#line 38
      tmp = 1;
#line 38
      tmp___90 = tmp;
    } else {
#line 38
      tmp___90 = 0;
    }
#line 38
    tmp___91 = tmp___90;
  }
  {
#line 38
  prefix_length += (unsigned long )tmp___91;
#line 48
  __cil_tmp7 = last_component(file);
#line 48
  length = (size_t )(__cil_tmp7 - file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int )((char )*(file + (length - 1UL))) == 47)) {
#line 51
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  __cil_tmp8 = length;
#line 49
  length --;
#line 52
  return (length);
}
}
#line 71 "/tmp/0/patch-2.7.1/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t __cil_tmp3 ;
  int append_dot ;
  char *dir ;
  void *__cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
  {
#line 73
  __cil_tmp3 = dir_len(file);
#line 73
  length = __cil_tmp3;
#line 74
  append_dot = length == 0UL;
#line 78
  __cil_tmp6 = malloc((length + (unsigned long )append_dot) + 1UL);
#line 78
  dir = (char *)__cil_tmp6;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void *)dir, (void const   *)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    __cil_tmp7 = length;
#line 83
    length ++;
#line 83
    *(dir + __cil_tmp7) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 47 "./c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 27 "/tmp/0/patch-2.7.1/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___92 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if (p1 == p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    c1 = (unsigned char )0;
#line 39
    c2 = (unsigned char )0;
#line 41
    n --;
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  if (1) {
#line 50
    return ((int )c1 - (int )c2);
  } else {
#line 55
    if ((int )c1 > (int )c2) {
#line 55
      tmp___92 = 1;
    } else {
#line 55
      if ((int )c1 < (int )c2) {
#line 55
        tmp = - 1;
      } else {
#line 55
        tmp = 0;
      }
#line 55
      tmp___92 = tmp;
    }
#line 55
    return (tmp___92);
  }
}
}
#line 27 "/tmp/0/patch-2.7.1/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___93 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if (p1 == p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    c1 = (unsigned char )0;
#line 39
    c2 = (unsigned char )0;
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  if (1) {
#line 50
    return ((int )c1 - (int )c2);
  } else {
#line 55
    if ((int )c1 > (int )c2) {
#line 55
      tmp___93 = 1;
    } else {
#line 55
      if ((int )c1 < (int )c2) {
#line 55
        tmp = - 1;
      } else {
#line 55
        tmp = 0;
      }
#line 55
      tmp___93 = tmp;
    }
#line 55
    return (tmp___93);
  }
}
}
#line 120 "./c-ctype.h"
int c_isascii(int c ) ;
#line 122
int c_isalnum(int c ) ;
#line 123
int c_isalpha(int c ) ;
#line 124
int c_isblank(int c ) ;
#line 125
int c_iscntrl(int c ) ;
#line 126
int c_isdigit(int c ) ;
#line 127
int c_islower(int c ) ;
#line 128
int c_isgraph(int c ) ;
#line 129
int c_isprint(int c ) ;
#line 130
int c_ispunct(int c ) ;
#line 131
int c_isspace(int c ) ;
#line 132
int c_isupper(int c ) ;
#line 133
int c_isxdigit(int c ) ;
#line 135
int c_tolower(int c ) ;
#line 136
int c_toupper(int c ) ;
#line 27 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isascii(int c ) 
{ 


  {
#line 29
  return (c >= 0 && c <= 127);
}
}
#line 33 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isalnum(int c ) 
{ 


  {
#line 38
  return ((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 90));
}
}
#line 68 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isalpha(int c ) 
{ 


  {
#line 72
  return ((c & -33) >= 65 && (c & -33) <= 90);
}
}
#line 97 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isblank(int c ) 
{ 


  {
#line 99
  return (c == 32 || c == 9);
}
}
#line 103 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_iscntrl(int c ) 
{ 


  {
#line 106
  return ((c & -32) == 0 || c == 127);
}
}
#line 137 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isdigit(int c ) 
{ 


  {
#line 140
  return (c >= 48 && c <= 57);
}
}
#line 154 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_islower(int c ) 
{ 


  {
#line 157
  return (c >= 97 && c <= 122);
}
}
#line 174 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isgraph(int c ) 
{ 


  {
#line 177
  return (c >= 33 && c <= 126);
}
}
#line 208 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isprint(int c ) 
{ 


  {
#line 211
  return (c >= 32 && c <= 126);
}
}
#line 242 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_ispunct(int c ) 
{ 


  {
#line 245
  return ((c >= 33 && c <= 126) && ! ((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 90)));
}
}
#line 266 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isspace(int c ) 
{ 


  {
#line 268
  return (((((c == 32 || c == 9) || c == 10) || c == 11) || c == 12) || c == 13);
}
}
#line 273 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isupper(int c ) 
{ 


  {
#line 276
  return (c >= 65 && c <= 90);
}
}
#line 293 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_isxdigit(int c ) 
{ 


  {
#line 298
  return ((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 70));
}
}
#line 320 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 323
  if (c >= 65 && c <= 90) {
#line 323
    tmp = (c - 65) + 97;
  } else {
#line 323
    tmp = c;
  }
#line 323
  return (tmp);
}
}
#line 359 "/tmp/0/patch-2.7.1/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 362
  if (c >= 97 && c <= 122) {
#line 362
    tmp = (c - 97) + 65;
  } else {
#line 362
    tmp = c;
  }
#line 362
  return (tmp);
}
}
#line 35 "./dirname.h"
char *base_name(char const   *name ) ;
#line 28 "/tmp/0/patch-2.7.1/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *__cil_tmp3 ;
  size_t length ;
  size_t __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *p ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 30
  __cil_tmp3 = last_component(name);
#line 30
  base = (char const   *)__cil_tmp3;
  }
#line 35
  if (! ((char )*base)) {
    {
#line 36
    __cil_tmp5 = base_len(name);
#line 36
    __cil_tmp6 = xstrndup(name, __cil_tmp5);
    }
#line 36
    return (__cil_tmp6);
  }
  {
#line 39
  length = base_len(base);
  }
#line 40
  if ((int )((char )*(base + length)) == 47) {
#line 41
    length ++;
  }
#line 46
  if (0) {
    {
#line 48
    __cil_tmp10 = xmalloc(length + 3UL);
#line 48
    p = (char *)__cil_tmp10;
#line 49
    *(p + 0) = (char )'.';
#line 50
    *(p + 1) = (char )'/';
#line 51
    memcpy((void *)(p + 2), (void const   *)base, length);
#line 52
    *(p + (length + 2UL)) = (char )'\000';
    }
#line 53
    return (p);
  }
  {
#line 57
  __cil_tmp11 = xstrndup(base, length);
  }
#line 57
  return (__cil_tmp11);
}
}
#line 30 "/tmp/0/patch-2.7.1/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  int saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int )((char )*base) == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! ((char )*p)) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int )((char )*p) == 47) {
#line 42
      saw_slash = 1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 39
  p ++;
#line 50
  return ((char *)base);
}
}
#line 58 "/tmp/0/patch-2.7.1/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;
  size_t __cil_tmp5 ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (1UL < len && (int )((char )*(name + (len - 1UL))) == 47)) {
#line 63
      goto while_break;
    }
#line 64
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  __cil_tmp5 = len;
#line 63
  len --;
#line 66
  if (0) {
#line 68
    return ((size_t )2);
  }
#line 70
  if (0) {
#line 72
    return (prefix_len + 1UL);
  }
#line 74
  return (len);
}
}
#line 47 "./backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version___0 ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version___0 ) ;
#line 52 "./argmatch.h"
argmatch_exit_fn argmatch_die ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , argmatch_exit_fn exit_fn ) ;
#line 119 "./xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) ;
#line 122 "./xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *__cil_tmp5 ;

  {
#line 124
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 124
    tmp = - 1;
  } else {
#line 124
    tmp = - 2;
  }
#line 124
  if ((size_t )tmp / s < n) {
    {
#line 125
    xalloc_die();
    }
  }
  {
#line 126
  __cil_tmp5 = xrealloc(p, n * s);
  }
#line 126
  return (__cil_tmp5);
}
}
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 83 "/tmp/0/patch-2.7.1/lib/backupfile.c"
char const   *simple_backup_suffix  =    (char const   *)((char *)"~");
#line 92 "/tmp/0/patch-2.7.1/lib/backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *__cil_tmp5 ;
  size_t baselen ;
  size_t __cil_tmp7 ;
  size_t baselen_max ;
  int tmp ;
  long name_max ;
  char tmp___94[2] ;
  int *__cil_tmp12 ;
  int *__cil_tmp14 ;
  long size ;
  char *dot ;
  char *__cil_tmp17 ;
  char const   *second_dot ;
  char *__cil_tmp19 ;
  long tmp___95 ;

  {
  {
#line 94
  __cil_tmp5 = last_component((char const   *)file);
#line 94
  base = __cil_tmp5;
#line 95
  __cil_tmp7 = base_len((char const   *)base);
#line 95
  baselen = __cil_tmp7;
#line 96
  tmp = 255;
#line 96
  baselen_max = (size_t )tmp;
  }
#line 98
  if (14UL < baselen) {
    {
#line 106
    memcpy((void *)((char *)tmp___94), (void const   *)base, sizeof("."));
#line 107
    strcpy(base, (char const   *)((char *)"."));
#line 108
    __cil_tmp12 = __errno_location();
#line 108
    *__cil_tmp12 = 0;
#line 109
    name_max = pathconf((char const   *)file, 3);
#line 110
    __cil_tmp14 = __errno_location();
    }
#line 110
    if (0L <= name_max) {
      _L: /* CIL Label */ 
#line 112
      baselen_max = (size_t )name_max;
#line 112
      size = (long )baselen_max;
#line 113
      if (name_max != size) {
#line 114
        baselen_max = (size_t )(- 1);
      }
    } else
#line 110
    if (*__cil_tmp14 == 0) {
#line 110
      goto _L;
    }
    {
#line 116
    memcpy((void *)base, (void const   *)((char *)tmp___94), sizeof("."));
    }
  }
#line 119
  if (0) {
    {
#line 122
    __cil_tmp17 = strchr((char const   *)base, '.');
#line 122
    dot = __cil_tmp17;
    }
#line 123
    if (! dot) {
#line 124
      baselen_max = (size_t )8;
    } else {
      {
#line 127
      __cil_tmp19 = strchr((char const   *)(dot + 1), '.');
#line 127
      second_dot = (char const   *)__cil_tmp19;
      }
#line 128
      if (second_dot) {
#line 128
        tmp___95 = second_dot - base;
      } else {
#line 128
        tmp___95 = ((dot + 1) - base) + 3L;
      }
#line 128
      baselen_max = (size_t )tmp___95;
    }
  }
#line 134
  if (baselen_max < baselen) {
#line 136
    baselen = (size_t )((file + filelen) - base);
#line 137
    if (baselen_max <= baselen) {
#line 138
      baselen = baselen_max - 1UL;
    }
#line 139
    *(base + baselen) = e;
#line 140
    *(base + (baselen + 1UL)) = (char )'\000';
  }
}
}
#line 172 "/tmp/0/patch-2.7.1/lib/backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___0 ;
  size_t versionlenmax ;
  char *base ;
  char *__cil_tmp10 ;
  size_t base_offset ;
  size_t baselen ;
  size_t __cil_tmp13 ;
  char tmp[2] ;
  char const   *p ;
  char *q ;
  int all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp25 ;
  int tmp___96 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 174
  result = (enum numbered_backup_result )2;
#line 177
  buf___0 = *buffer;
#line 178
  versionlenmax = (size_t )1;
#line 179
  __cil_tmp10 = last_component((char const   *)buf___0);
#line 179
  base = __cil_tmp10;
#line 180
  base_offset = (size_t )(base - buf___0);
#line 181
  __cil_tmp13 = base_len((char const   *)base);
#line 181
  baselen = __cil_tmp13;
#line 186
  memcpy((void *)((char *)tmp), (void const   *)base, sizeof("."));
#line 187
  strcpy(base, (char const   *)((char *)"."));
#line 188
  dirp = opendir_safer((char const   *)buf___0);
#line 189
  memcpy((void *)base, (void const   *)((char *)tmp), sizeof("."));
#line 190
  strcpy(base + baselen, (char const   *)((char *)".~1~"));
  }
#line 192
  if (! dirp) {
#line 193
    return (result);
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (dp != (struct dirent *)((void *)0))) {
#line 195
      goto while_break;
    }
    {
#line 203
    __cil_tmp22 = strlen((char const   *)((char *)dp->d_name));
    }
#line 203
    if (! (dp->d_ino != 0UL)) {
#line 204
      goto while_continue;
    } else
#line 203
    if (__cil_tmp22 < baselen + 4UL) {
#line 204
      goto while_continue;
    }
    {
#line 206
    __cil_tmp23 = memcmp((void const   *)(buf___0 + base_offset), (void const   *)((char *)dp->d_name),
                         baselen + 2UL);
    }
#line 206
    if (__cil_tmp23 != 0) {
#line 207
      goto while_continue;
    }
#line 209
    p = (char const   *)(((char *)dp->d_name + baselen) + 2);
#line 215
    if (! (49 <= (int )((char )*p) && (int )((char )*p) <= 57)) {
#line 216
      goto while_continue;
    }
#line 217
    all_9s = (int )((char )*p) == 57;
#line 218
    versionlen = (size_t )1;
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! ((unsigned int )((char )*(p + versionlen)) - 48U <= 9U)) {
#line 218
        goto while_break___0;
      }
#line 219
      all_9s &= (int )((char )*(p + versionlen)) == 57;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    versionlen ++;
#line 221
    __cil_tmp25 = memcmp((void const   *)((buf___0 + filelen) + 2), (void const   *)p,
                         versionlen);
    }
#line 221
    if (! (((int )((char )*(p + versionlen)) == 126 && ! ((char )*(p + (versionlen + 1UL)))) && (versionlenmax < versionlen || (versionlenmax == versionlen && __cil_tmp25 <= 0)))) {
#line 225
      goto while_continue;
    }
#line 231
    versionlenmax = (unsigned long )all_9s + versionlen;
#line 232
    if (all_9s) {
#line 232
      tmp___96 = 1;
    } else {
#line 232
      tmp___96 = 0;
    }
#line 232
    result = (enum numbered_backup_result )tmp___96;
#line 233
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 234
    if (buffer_size <= new_buflen) {
      {
#line 236
      __cil_tmp27 = xnrealloc((void *)buf___0, (size_t )2, new_buflen);
#line 236
      buf___0 = (char *)__cil_tmp27;
#line 237
      buffer_size = new_buflen * 2UL;
      }
    }
    {
#line 239
    q = buf___0 + filelen;
#line 240
    __cil_tmp28 = q;
#line 240
    q ++;
#line 240
    *__cil_tmp28 = (char )'.';
#line 241
    __cil_tmp29 = q;
#line 241
    q ++;
#line 241
    *__cil_tmp29 = (char )'~';
#line 242
    *q = (char )'0';
#line 243
    q += all_9s;
#line 244
    memcpy((void *)q, (void const   *)p, versionlen + 2UL);
#line 248
    q += versionlen;
    }
    {
#line 249
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 249
      if (! ((int )*q == 57)) {
#line 249
        goto while_break___1;
      }
#line 250
      *q = (char )'0';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 251
    (*q) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  closedir(dirp);
#line 255
  *buffer = buf___0;
  }
#line 256
  return (result);
}
}
#line 264 "/tmp/0/patch-2.7.1/lib/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) 
{ 
  size_t filelen ;
  size_t __cil_tmp4 ;
  char *s ;
  size_t ssize ;
  int simple ;
  size_t simple_backup_suffix_size ;
  size_t __cil_tmp9 ;
  size_t backup_suffix_size_guess ;
  void *__cil_tmp11 ;
  enum numbered_backup_result __cil_tmp12 ;

  {
  {
#line 266
  __cil_tmp4 = strlen(file);
#line 266
  filelen = __cil_tmp4;
#line 269
  simple = 1;
#line 273
  __cil_tmp9 = strlen(simple_backup_suffix);
#line 273
  simple_backup_suffix_size = __cil_tmp9 + 1UL;
#line 274
  backup_suffix_size_guess = simple_backup_suffix_size;
  }
#line 276
  if (backup_suffix_size_guess < 9UL) {
#line 277
    backup_suffix_size_guess = (size_t )9;
  }
  {
#line 279
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 280
  __cil_tmp11 = xmalloc(ssize);
#line 280
  s = (char *)__cil_tmp11;
#line 281
  memcpy((void *)s, (void const   *)file, filelen + 1UL);
  }
#line 283
  if ((unsigned int )backup_type___0 != 1U) {
    {
#line 284
    __cil_tmp12 = numbered_backup(& s, ssize, filelen);
    }
    {
#line 286
    if ((unsigned int )__cil_tmp12 == (unsigned int )0) {
#line 286
      goto case_0;
    }
#line 289
    if ((unsigned int )__cil_tmp12 == (unsigned int )1) {
#line 289
      goto case_1;
    }
#line 293
    if ((unsigned int )__cil_tmp12 == (unsigned int )2) {
#line 293
      goto case_2;
    }
#line 284
    goto switch_break;
    case_0: /* CIL Label */ 
#line 287
    return (s);
    case_1: /* CIL Label */ 
#line 290
    simple = 0;
#line 291
    goto switch_break;
    case_2: /* CIL Label */ 
#line 294
    simple = (unsigned int )backup_type___0 == 2U;
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 298
  if (simple) {
    {
#line 299
    memcpy((void *)(s + filelen), (void const   *)simple_backup_suffix, simple_backup_suffix_size);
    }
  }
  {
#line 300
  check_extension(s, filelen, (char )'~');
  }
#line 301
  return (s);
}
}
#line 304 "/tmp/0/patch-2.7.1/lib/backupfile.c"
static char const   * const  backup_args[]  = 
#line 304
  {      (char const   *)((char *)"none"),      (char const   *)((char *)"off"),      (char const   *)((char *)"simple"),      (char const   *)((char *)"never"), 
        (char const   *)((char *)"existing"),      (char const   *)((char *)"nil"),      (char const   *)((char *)"numbered"),      (char const   *)((char *)"t"), 
        (char const   */* const  */)((void *)0)};
#line 315 "/tmp/0/patch-2.7.1/lib/backupfile.c"
static enum backup_type backup_types[]  = 
#line 315
  {      (enum backup_type )0,      (enum backup_type )0,      (enum backup_type )1,      (enum backup_type )1, 
        (enum backup_type )2,      (enum backup_type )2,      (enum backup_type )3,      (enum backup_type )3};
#line 333 "/tmp/0/patch-2.7.1/lib/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version___0 ) 
{ 
  ptrdiff_t __cil_tmp3 ;

  {
#line 335
  if (version___0 == (char const   *)0) {
#line 336
    return ((enum backup_type )2);
  } else
#line 335
  if ((int )((char )*version___0) == 0) {
#line 336
    return ((enum backup_type )2);
  } else {
    {
#line 338
    __cil_tmp3 = __xargmatch_internal(context, version___0, (char const   * const  *)backup_args,
                                      (char const   *)((enum backup_type *)backup_types),
                                      sizeof(*((enum backup_type *)backup_types)),
                                      argmatch_die);
    }
#line 338
    return (backup_types[__cil_tmp3]);
  }
}
}
#line 349 "/tmp/0/patch-2.7.1/lib/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version___0 ) 
{ 
  enum backup_type __cil_tmp3 ;
  char *__cil_tmp4 ;
  enum backup_type __cil_tmp5 ;

  {
#line 351
  if (version___0) {
#line 351
    if ((int )((char )*version___0)) {
      {
#line 352
      __cil_tmp3 = get_version(context, version___0);
      }
#line 352
      return (__cil_tmp3);
    } else {
      {
      {
#line 354
      __cil_tmp4 = getenv((char const   *)((char *)"VERSION_CONTROL"));
      }
      {
#line 354
      __cil_tmp5 = get_version((char const   *)((char *)"$VERSION_CONTROL"), (char const   *)__cil_tmp4);
      }
      }
#line 354
      return (__cil_tmp5);
    }
  } else {
    {
    {
#line 354
    __cil_tmp4 = getenv((char const   *)((char *)"VERSION_CONTROL"));
    }
    {
#line 354
    __cil_tmp5 = get_version((char const   *)((char *)"$VERSION_CONTROL"), (char const   *)__cil_tmp4);
    }
    }
#line 354
    return (__cil_tmp5);
  }
}
}
#line 70 "./vasnprintf.h"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) ;
#line 25 "/tmp/0/patch-2.7.1/lib/asnprintf.c"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 30
  __builtin_va_start((__builtin_va_list *)args, format);
#line 31
  result = vasnprintf(resultbuf, lengthp, format, (__builtin_va_list *)args);
#line 32
  __builtin_va_end((__builtin_va_list *)args);
  }
#line 33
  return (result);
}
}
#line 42 "./argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 61 "/tmp/0/patch-2.7.1/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  exit(exit_failure);
  }
}
}
#line 68 "/tmp/0/patch-2.7.1/lib/argmatch.c"
argmatch_exit_fn argmatch_die  =    __argmatch_die;
#line 83 "/tmp/0/patch-2.7.1/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  int ambiguous ;
  int __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )(- 1);
#line 89
  ambiguous = 0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((char const   *)*(arglist + i))) {
#line 94
      goto while_break;
    }
    {
#line 96
    __cil_tmp10 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! __cil_tmp10) {
      {
#line 98
      __cil_tmp11 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (__cil_tmp11 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else {
        {
#line 107
        __cil_tmp12 = memcmp((void const   *)(vallist + valsize * (unsigned long )matchind),
                             (void const   *)(vallist + valsize * i), valsize);
        }
#line 107
        if (vallist == (char const   *)((void *)0)) {
#line 113
          ambiguous = 1;
        } else
#line 107
        if (__cil_tmp12) {
#line 113
          ambiguous = 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  i ++;
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )(- 2));
  } else {
#line 121
    return (matchind);
  }
}
}
#line 130 "/tmp/0/patch-2.7.1/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
#line 132
  if (problem == -1L) {
#line 132
    tmp = (char const   *)((char *)"invalid argument %s for %s");
  } else {
#line 132
    tmp = (char const   *)((char *)"ambiguous argument %s for %s");
  }
  {
#line 132
  format = tmp;
#line 136
  __cil_tmp6 = quotearg_n_style(0, (enum quoting_style )6, value);
  }
  {
#line 136
  __cil_tmp7 = quote_n(1, context);
#line 136
  error(0, 0, format, __cil_tmp6, __cil_tmp7);
  }
}
}
#line 145 "/tmp/0/patch-2.7.1/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  fputs((char const   *)((char *)"Valid arguments are:"), stderr);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((char const   *)*(arglist + i))) {
#line 154
      goto while_break;
    }
    {
#line 155
    __cil_tmp6 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                        valsize);
    }
#line 155
    if (i == 0UL) {
      {
      {
#line 158
      __cil_tmp7 = quote((char const   *)*(arglist + i));
      }
      {
#line 158
      fprintf(stderr, (char const   *)((char *)"\n  - %s"), __cil_tmp7);
      }
#line 159
      last_val = vallist + valsize * i;
      }
    } else
#line 155
    if (__cil_tmp6) {
      {
      {
#line 158
      __cil_tmp7 = quote((char const   *)*(arglist + i));
      }
      {
#line 158
      fprintf(stderr, (char const   *)((char *)"\n  - %s"), __cil_tmp7);
      }
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 163
      __cil_tmp8 = quote((char const   *)*(arglist + i));
#line 163
      fprintf(stderr, (char const   *)((char *)", %s"), __cil_tmp8);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  i ++;
#line 165
  _IO_putc('\n', stderr);
  }
}
}
#line 175 "/tmp/0/patch-2.7.1/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , argmatch_exit_fn exit_fn ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t __cil_tmp8 ;

  {
  {
#line 180
  __cil_tmp8 = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = __cil_tmp8;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  ((void (*)(void))*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )(- 1));
}
}
#line 196 "/tmp/0/patch-2.7.1/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int __cil_tmp6 ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((char const   *)*(arglist + i))) {
#line 202
      goto while_break;
    }
    {
#line 203
    __cil_tmp6 = memcmp((void const   *)value, (void const   *)(vallist + valsize * i),
                        valsize);
    }
#line 203
    if (! __cil_tmp6) {
#line 204
      return ((char const   *)*(arglist + i));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  i ++;
#line 205
  return ((char const   *)((void *)0));
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 318
extern int printf(char const   *__format  , ...) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 99 "./common.h"
int debug ;
#line 107
int verbosity ;
#line 200
lin in_offset ;
#line 201
lin out_offset ;
#line 204
lin last_frozen_line ;
#line 206
int copy_till(struct outstate *outstate , lin lastline ) ;
#line 211
enum conflict_style conflict_style ;
#line 213
int merge_hunk(int hunk , struct outstate *outstate , lin where , int *somefailed ) ;
#line 20 "./inp.h"
lin input_lines ;
#line 22
char const   *ifetch(lin line , int whichbuf , size_t *psize ) ;
#line 22 "./pch.h"
lin pch_end(void) ;
#line 23
lin pch_first(void) ;
#line 31
lin pch_prefix_context(void) ;
#line 32
lin pch_ptrn_lines(void) ;
#line 34
lin pch_suffix_context(void) ;
#line 36
int pch_write_line(lin line , FILE *file ) ;
#line 38
char *pfetch(lin line ) ;
#line 39
char pch_char(lin line ) ;
#line 42
size_t pch_line_len(lin line ) ;
#line 50
void pch_normalize(enum diff format ) ;
#line 36 "./util.h"
void say(char const   *format  , ...) ;
#line 51
char *format_linenum(char numbuf[23] , lin n ) ;
#line 66
void write_fatal(void) ;
#line 27 "/tmp/0/patch-2.7.1/src/merge.c"
static lin count_context_lines(void) ;
#line 29
static void compute_changes(lin xmin , lin xmax___0 , lin ymin , lin ymax , char *xchar ,
                            char *ychar ) ;
#line 55 "./bestmatch.h"
static lin bestmatch(lin xoff , lin xlim , lin yoff , lin ylim , lin min , lin max ,
                     lin *py ) 
{ 
  lin dmin ;
  lin dmax ;
  lin fmid ;
  lin fmin ;
  lin fmax ;
  lin *V ;
  lin *fd ;
  lin fmid_plus_2_min ;
  lin ymax ;
  lin c ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  lin d ;
  lin x ;
  lin y ;
  int __cil_tmp25 ;
  lin __cil_tmp26 ;
  lin __cil_tmp27 ;

  {
  {
#line 58
  dmin = xoff - ylim;
#line 59
  dmax = xlim - yoff;
#line 60
  fmid = xoff - yoff;
#line 61
  fmin = fmid;
#line 62
  fmax = fmid;
#line 64
  ymax = (lin )(- 1);
#line 67
  __cil_tmp18 = malloc((unsigned long )(2L * max + 3L) * sizeof(lin ));
#line 67
  V = (lin *)__cil_tmp18;
#line 68
  fd = ((V + max) + 1) - fmid;
  }
#line 87
  if (min) {
#line 89
    fmid_plus_2_min = fmid + 2L * min;
#line 90
    min += yoff;
#line 91
    if (min > ylim) {
#line 93
      c = max + 1L;
#line 94
      goto free_and_return;
    }
  } else {
#line 98
    fmid_plus_2_min = (lin )0;
  }
#line 99
  if (! py) {
#line 100
    min = ylim;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((xoff < xlim && yoff < ylim) && __cil_tmp19)) {
#line 103
      goto while_break;
    }
#line 105
    xoff ++;
#line 106
    yoff ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (xoff == xlim) {
#line 108
    if (yoff >= min) {
#line 108
      if (xoff + yoff >= fmid_plus_2_min) {
#line 111
        ymax = yoff;
#line 112
        c = (lin )0;
      } else {
#line 108
        goto _L;
      }
    } else {
#line 108
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 116
    *(fd + fmid) = xoff;
#line 117
    c = (lin )1;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (c <= max)) {
#line 117
        goto while_break___0;
      }
#line 121
      if (fmin > dmin) {
#line 122
        fmin --;
#line 122
        *(fd + (fmin - 1L)) = (lin )(- 1);
      } else {
#line 124
        fmin ++;
      }
#line 125
      if (fmax < dmax) {
#line 126
        fmax ++;
#line 126
        *(fd + (fmax + 1L)) = (lin )(- 1);
      } else {
#line 128
        fmax --;
      }
#line 129
      d = fmax;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 129
        if (! (d >= fmin)) {
#line 129
          goto while_break___1;
        }
#line 133
        if (*(fd + (d - 1L)) < *(fd + (d + 1L))) {
#line 134
          x = *(fd + (d + 1L));
        } else {
#line 136
          x = *(fd + (d - 1L)) + 1L;
        }
#line 137
        y = x - d;
        {
#line 137
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 137
          if (! ((x < xlim && y < ylim) && __cil_tmp25)) {
#line 137
            goto while_break___2;
          }

        }
        while_break___2: /* CIL Label */ ;
        }
#line 139
        __cil_tmp27 = y;
#line 139
        y ++;
#line 139
        __cil_tmp26 = x;
#line 139
        x ++;
#line 141
        *(fd + d) = x;
#line 142
        if (x == xlim) {
#line 142
          if (y >= min) {
#line 142
            if ((x + y) - c >= fmid_plus_2_min) {
#line 145
              if (ymax < y) {
#line 146
                ymax = y;
              }
#line 147
              if (y == ylim) {
#line 148
                goto done;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 129
      d -= (long )2;
#line 151
      if (ymax != -1L) {
#line 152
        goto done;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    c ++;
  }
  done: 
#line 157
  if (py) {
#line 158
    *py = ymax;
  }
  free_and_return: 
  {
#line 161
  free((void *)V);
  }
#line 162
  return (c);
}
}
#line 178 "../lib/diffseq.h"
static void diag(lin xoff , lin xlim , lin yoff , lin ylim , int find_minimal , struct partition *part ,
                 struct context *ctxt ) 
{ 
  lin *fd ;
  lin *bd ;
  lin dmin ;
  lin dmax ;
  lin fmid ;
  lin bmid ;
  lin fmin ;
  lin fmax ;
  lin bmin ;
  lin bmax ;
  lin c ;
  int odd ;
  lin d ;
  int big_snake ;
  lin x ;
  lin y ;
  lin tlo ;
  lin thi ;
  lin x0 ;
  lin tmp ;
  int __cil_tmp28 ;
  lin __cil_tmp29 ;
  lin __cil_tmp30 ;
  lin x___0 ;
  lin y___0 ;
  lin tlo___0 ;
  lin thi___0 ;
  lin x0___0 ;
  lin tmp___0 ;
  int __cil_tmp37 ;
  lin __cil_tmp38 ;
  lin __cil_tmp39 ;
  lin best ;
  lin dd ;
  lin x___1 ;
  lin y___1 ;
  lin v ;
  lin tmp___1 ;
  int k ;
  int __cil_tmp47 ;
  lin best___0 ;
  lin dd___0 ;
  lin x___2 ;
  lin y___2 ;
  lin v___0 ;
  lin tmp___2 ;
  int k___0 ;
  int __cil_tmp56 ;
  lin fxybest ;
  lin fxbest ;
  lin bxybest ;
  lin bxbest ;
  lin x___3 ;
  lin tmp___3 ;
  lin y___3 ;
  lin x___4 ;
  lin tmp___4 ;
  lin y___4 ;

  {
#line 181
  fd = ctxt->fdiag;
#line 182
  bd = ctxt->bdiag;
#line 190
  dmin = xoff - ylim;
#line 191
  dmax = xlim - yoff;
#line 192
  fmid = xoff - yoff;
#line 193
  bmid = xlim - ylim;
#line 194
  fmin = fmid;
#line 195
  fmax = fmid;
#line 196
  bmin = bmid;
#line 197
  bmax = bmid;
#line 199
  odd = (int )((fmid - bmid) & 1L);
#line 202
  *(fd + fmid) = xoff;
#line 203
  *(bd + bmid) = xlim;
#line 205
  c = (lin )1;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! 1) {
#line 205
      goto while_break;
    }
#line 208
    big_snake = 0;
#line 211
    if (fmin > dmin) {
#line 212
      fmin --;
#line 212
      *(fd + (fmin - 1L)) = (lin )(- 1);
    } else {
#line 214
      fmin ++;
    }
#line 215
    if (fmax < dmax) {
#line 216
      fmax ++;
#line 216
      *(fd + (fmax + 1L)) = (lin )(- 1);
    } else {
#line 218
      fmax --;
    }
#line 219
    d = fmax;
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if (! (d >= fmin)) {
#line 219
        goto while_break___0;
      }
#line 223
      tlo = *(fd + (d - 1L));
#line 224
      thi = *(fd + (d + 1L));
#line 225
      if (tlo < thi) {
#line 225
        tmp = thi;
      } else {
#line 225
        tmp = tlo + 1L;
      }
#line 225
      x0 = tmp;
#line 227
      y = x0 - d;
#line 227
      x = x0;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! ((x < xlim && y < ylim) && __cil_tmp28)) {
#line 227
          goto while_break___1;
        }
#line 230
        goto while_continue___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 229
      __cil_tmp30 = y;
#line 229
      y ++;
#line 229
      __cil_tmp29 = x;
#line 229
      x ++;
#line 231
      if (x - x0 > 20L) {
#line 232
        big_snake = 1;
      }
#line 233
      *(fd + d) = x;
#line 234
      if (odd) {
#line 234
        if (bmin <= d) {
#line 234
          if (d <= bmax) {
#line 234
            if (*(bd + d) <= x) {
#line 236
              part->xmid = x;
#line 237
              part->ymid = y;
#line 238
              part->hi_minimal = 1;
#line 238
              part->lo_minimal = part->hi_minimal;
#line 239
              return;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    d -= (long )2;
#line 244
    if (bmin > dmin) {
#line 245
      bmin --;
#line 245
      *(bd + (bmin - 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 247
      bmin ++;
    }
#line 248
    if (bmax < dmax) {
#line 249
      bmax ++;
#line 249
      *(bd + (bmax + 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 251
      bmax --;
    }
#line 252
    d = bmax;
    {
#line 252
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 252
      if (! (d >= bmin)) {
#line 252
        goto while_break___2;
      }
#line 256
      tlo___0 = *(bd + (d - 1L));
#line 257
      thi___0 = *(bd + (d + 1L));
#line 258
      if (tlo___0 < thi___0) {
#line 258
        tmp___0 = tlo___0;
      } else {
#line 258
        tmp___0 = thi___0 - 1L;
      }
#line 258
      x0___0 = tmp___0;
#line 260
      y___0 = x0___0 - d;
#line 260
      x___0 = x0___0;
      {
#line 260
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 260
        if (! ((xoff < x___0 && yoff < y___0) && __cil_tmp37)) {
#line 260
          goto while_break___3;
        }
#line 263
        goto while_continue___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 262
      __cil_tmp39 = y___0;
#line 262
      y___0 --;
#line 262
      __cil_tmp38 = x___0;
#line 262
      x___0 --;
#line 264
      if (x0___0 - x___0 > 20L) {
#line 265
        big_snake = 1;
      }
#line 266
      *(bd + d) = x___0;
#line 267
      if (! odd) {
#line 267
        if (fmin <= d) {
#line 267
          if (d <= fmax) {
#line 267
            if (x___0 <= *(fd + d)) {
#line 269
              part->xmid = x___0;
#line 270
              part->ymid = y___0;
#line 271
              part->hi_minimal = 1;
#line 271
              part->lo_minimal = part->hi_minimal;
#line 272
              return;
            }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 252
    d -= (long )2;
#line 276
    if (find_minimal) {
#line 277
      goto while_continue;
    }
#line 288
    if (200L < c) {
#line 288
      if (big_snake) {
#line 288
        if (ctxt->heuristic) {
#line 291
          best = (lin )0;
#line 293
          d = fmax;
          {
#line 293
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 293
            if (! (d >= fmin)) {
#line 293
              goto while_break___4;
            }
#line 295
            dd = d - fmid;
#line 296
            x___1 = *(fd + d);
#line 297
            y___1 = x___1 - d;
#line 298
            v = (x___1 - xoff) * 2L - dd;
#line 300
            if (dd < 0L) {
#line 300
              tmp___1 = - dd;
            } else {
#line 300
              tmp___1 = dd;
            }
#line 300
            if (v > 12L * (c + tmp___1)) {
#line 302
              if (v > best) {
#line 302
                if (xoff + 20L <= x___1) {
#line 302
                  if (x___1 < xlim) {
#line 302
                    if (yoff + 20L <= y___1) {
#line 302
                      if (y___1 < ylim) {
#line 310
                        k = 1;
                        {
#line 310
                        while (1) {
                          while_continue___5: /* CIL Label */ ;
#line 310
                          if (! __cil_tmp47) {
#line 310
                            goto while_break___5;
                          }
#line 311
                          if (k == 20) {
#line 313
                            best = v;
#line 314
                            part->xmid = x___1;
#line 315
                            part->ymid = y___1;
#line 316
                            goto while_break___5;
                          }
                        }
                        while_break___5: /* CIL Label */ ;
                        }
#line 310
                        k ++;
                      }
                    }
                  }
                }
              }
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 293
          d -= (long )2;
#line 321
          if (best > 0L) {
#line 323
            part->lo_minimal = 1;
#line 324
            part->hi_minimal = 0;
#line 325
            return;
          }
#line 330
          best___0 = (lin )0;
#line 332
          d = bmax;
          {
#line 332
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 332
            if (! (d >= bmin)) {
#line 332
              goto while_break___6;
            }
#line 334
            dd___0 = d - bmid;
#line 335
            x___2 = *(bd + d);
#line 336
            y___2 = x___2 - d;
#line 337
            v___0 = (xlim - x___2) * 2L + dd___0;
#line 339
            if (dd___0 < 0L) {
#line 339
              tmp___2 = - dd___0;
            } else {
#line 339
              tmp___2 = dd___0;
            }
#line 339
            if (v___0 > 12L * (c + tmp___2)) {
#line 341
              if (v___0 > best___0) {
#line 341
                if (xoff < x___2) {
#line 341
                  if (x___2 <= xlim - 20L) {
#line 341
                    if (yoff < y___2) {
#line 341
                      if (y___2 <= ylim - 20L) {
#line 349
                        k___0 = 0;
                        {
#line 349
                        while (1) {
                          while_continue___7: /* CIL Label */ ;
#line 349
                          if (! __cil_tmp56) {
#line 349
                            goto while_break___7;
                          }
#line 350
                          if (k___0 == 19) {
#line 352
                            best___0 = v___0;
#line 353
                            part->xmid = x___2;
#line 354
                            part->ymid = y___2;
#line 355
                            goto while_break___7;
                          }
                        }
                        while_break___7: /* CIL Label */ ;
                        }
#line 349
                        k___0 ++;
                      }
                    }
                  }
                }
              }
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 332
          d -= (long )2;
#line 360
          if (best___0 > 0L) {
#line 362
            part->lo_minimal = 0;
#line 363
            part->hi_minimal = 1;
#line 364
            return;
          }
        }
      }
    }
#line 372
    if (c >= ctxt->too_expensive) {
#line 380
      fxybest = (lin )(- 1);
#line 381
      d = fmax;
      {
#line 381
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 381
        if (! (d >= fmin)) {
#line 381
          goto while_break___8;
        }
#line 383
        if (*(fd + d) < xlim) {
#line 383
          tmp___3 = *(fd + d);
        } else {
#line 383
          tmp___3 = xlim;
        }
#line 383
        x___3 = tmp___3;
#line 384
        y___3 = x___3 - d;
#line 385
        if (ylim < y___3) {
#line 387
          x___3 = ylim + d;
#line 388
          y___3 = ylim;
        }
#line 390
        if (fxybest < x___3 + y___3) {
#line 392
          fxybest = x___3 + y___3;
#line 393
          fxbest = x___3;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 381
      d -= (long )2;
#line 398
      bxybest = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 399
      d = bmax;
      {
#line 399
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 399
        if (! (d >= bmin)) {
#line 399
          goto while_break___9;
        }
#line 401
        if (xoff > *(bd + d)) {
#line 401
          tmp___4 = xoff;
        } else {
#line 401
          tmp___4 = *(bd + d);
        }
#line 401
        x___4 = tmp___4;
#line 402
        y___4 = x___4 - d;
#line 403
        if (y___4 < yoff) {
#line 405
          x___4 = yoff + d;
#line 406
          y___4 = yoff;
        }
#line 408
        if (x___4 + y___4 < bxybest) {
#line 410
          bxybest = x___4 + y___4;
#line 411
          bxbest = x___4;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 399
      d -= (long )2;
#line 416
      if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff)) {
#line 418
        part->xmid = fxbest;
#line 419
        part->ymid = fxybest - fxbest;
#line 420
        part->lo_minimal = 1;
#line 421
        part->hi_minimal = 0;
      } else {
#line 425
        part->xmid = bxbest;
#line 426
        part->ymid = bxybest - bxbest;
#line 427
        part->lo_minimal = 0;
#line 428
        part->hi_minimal = 1;
      }
#line 430
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  c ++;
}
}
#line 454 "../lib/diffseq.h"
static int compareseq(lin xoff , lin xlim , lin yoff , lin ylim , int find_minimal ,
                      struct context *ctxt ) 
{ 
  int __cil_tmp7 ;
  int __cil_tmp10 ;
  lin __cil_tmp11 ;
  lin __cil_tmp12 ;
  struct partition part ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! ((xoff < xlim && yoff < ylim) && __cil_tmp7)) {
#line 466
      goto while_break;
    }
#line 468
    xoff ++;
#line 469
    yoff ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! ((xoff < xlim && yoff < ylim) && __cil_tmp10)) {
#line 473
      goto while_break___0;
    }
#line 475
    __cil_tmp11 = xlim;
#line 475
    xlim --;
#line 476
    __cil_tmp12 = ylim;
#line 476
    ylim --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  if (xoff == xlim) {
    {
#line 481
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 481
      if (! (yoff < ylim)) {
#line 481
        goto while_break___1;
      }
#line 483
      *(ctxt->ychar + yoff) = (char )'+';
#line 484
      if (0) {
#line 485
        return (1);
      }
#line 486
      yoff ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 488
  if (yoff == ylim) {
    {
#line 489
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 489
      if (! (xoff < xlim)) {
#line 489
        goto while_break___2;
      }
#line 491
      *(ctxt->xchar + xoff) = (char )'-';
#line 492
      if (0) {
#line 493
        return (1);
      }
#line 494
      xoff ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 501
    diag(xoff, xlim, yoff, ylim, find_minimal, & part, ctxt);
#line 504
    __cil_tmp16 = compareseq(xoff, part.xmid, yoff, part.ymid, part.lo_minimal, ctxt);
    }
#line 504
    if (__cil_tmp16) {
#line 505
      return (1);
    }
    {
#line 506
    __cil_tmp17 = compareseq(part.xmid, xlim, part.ymid, ylim, part.hi_minimal, ctxt);
    }
#line 506
    if (__cil_tmp17) {
#line 507
      return (1);
    }
  }
#line 510
  return (0);
}
}
#line 46 "/tmp/0/patch-2.7.1/src/merge.c"
static lin locate_merge(lin *matched ) 
{ 
  lin first_guess ;
  lin __cil_tmp3 ;
  lin pat_lines ;
  lin __cil_tmp5 ;
  lin context_lines ;
  lin __cil_tmp7 ;
  lin max_where ;
  lin min_where ;
  lin max_pos_offset ;
  lin max_neg_offset ;
  lin max_offset ;
  lin tmp ;
  lin where ;
  lin max_matched ;
  lin min ;
  lin max ;
  lin offset ;
  int match_until_eof ;
  char numbuf0[23] ;
  char numbuf1[23] ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  lin __cil_tmp24 ;
  lin __cil_tmp25 ;
  lin __cil_tmp26 ;
  lin guess ;
  lin last ;
  lin changes ;
  long tmp___100 ;
  lin __cil_tmp31 ;
  lin guess___0 ;
  lin last___0 ;
  lin changes___0 ;
  long tmp___101 ;
  lin __cil_tmp36 ;
  char numbuf0___0[23] ;
  char numbuf1___0[23] ;
  char numbuf2[23] ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 48
  __cil_tmp3 = pch_first();
#line 48
  first_guess = __cil_tmp3 + in_offset;
#line 49
  __cil_tmp5 = pch_ptrn_lines();
#line 49
  pat_lines = __cil_tmp5;
#line 50
  __cil_tmp7 = count_context_lines();
#line 50
  context_lines = __cil_tmp7;
#line 51
  max_where = ((input_lines - pat_lines) + context_lines) + 1L;
#line 52
  min_where = last_frozen_line + 1L;
#line 53
  max_pos_offset = max_where - first_guess;
#line 54
  max_neg_offset = first_guess - min_where;
  }
#line 55
  if (max_pos_offset < max_neg_offset) {
#line 55
    tmp = max_neg_offset;
  } else {
#line 55
    tmp = max_pos_offset;
  }
#line 55
  max_offset = tmp;
#line 57
  where = first_guess;
#line 57
  max_matched = (lin )0;
#line 68
  if (context_lines == 0L) {
#line 69
    goto out;
  }
#line 73
  max = 2L * context_lines;
#line 74
  min = pat_lines - context_lines;
#line 76
  if (debug & 1) {
    {
#line 80
    __cil_tmp22 = format_linenum((char *)numbuf0, min);
    }
    {
#line 80
    __cil_tmp23 = format_linenum((char *)numbuf1, max);
#line 80
    say((char const   *)((char *)"locating merge: min=%s max=%s "), __cil_tmp22, __cil_tmp23);
    }
  }
  {
#line 87
  __cil_tmp25 = pch_prefix_context();
  }
  {
#line 87
  __cil_tmp24 = pch_suffix_context();
#line 87
  offset = __cil_tmp24 - __cil_tmp25;
#line 88
  __cil_tmp26 = pch_first();
  }
#line 88
  if (offset > 0L) {
#line 88
    if (__cil_tmp26 <= 1L) {
#line 89
      max_pos_offset = (lin )0;
    }
  }
#line 90
  match_until_eof = offset < 0L;
#line 93
  if (first_guess <= max_neg_offset) {
#line 94
    max_neg_offset = first_guess - 1L;
  }
#line 96
  offset = (lin )0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (offset <= max_offset)) {
#line 96
      goto while_break;
    }
#line 98
    if (offset <= max_pos_offset) {
#line 100
      guess = first_guess + offset;
#line 104
      if (match_until_eof) {
#line 104
        tmp___100 = (input_lines - guess) + 1L;
      } else {
#line 104
        tmp___100 = min;
      }
      {
#line 104
      __cil_tmp31 = bestmatch((lin )1, pat_lines + 1L, guess, input_lines + 1L, tmp___100,
                              max, & last);
#line 104
      changes = __cil_tmp31;
      }
#line 107
      if (changes <= max) {
#line 107
        if (max_matched < last - guess) {
#line 109
          max_matched = last - guess;
#line 110
          where = guess;
#line 111
          if (changes == 0L) {
#line 112
            goto while_break;
          }
#line 113
          min = last - guess;
#line 114
          max = changes - 1L;
        }
      }
    }
#line 117
    if (0L < offset) {
#line 117
      if (offset <= max_neg_offset) {
#line 119
        guess___0 = first_guess - offset;
#line 123
        if (match_until_eof) {
#line 123
          tmp___101 = (input_lines - guess___0) + 1L;
        } else {
#line 123
          tmp___101 = min;
        }
        {
#line 123
        __cil_tmp36 = bestmatch((lin )1, pat_lines + 1L, guess___0, input_lines + 1L,
                                tmp___101, max, & last___0);
#line 123
        changes___0 = __cil_tmp36;
        }
#line 126
        if (changes___0 <= max) {
#line 126
          if (max_matched < last___0 - guess___0) {
#line 128
            max_matched = last___0 - guess___0;
#line 129
            where = guess___0;
#line 130
            if (changes___0 == 0L) {
#line 131
              goto while_break;
            }
#line 132
            min = last___0 - guess___0;
#line 133
            max = changes___0 - 1L;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  offset ++;
#line 137
  if (debug & 1) {
    {
#line 142
    __cil_tmp41 = format_linenum((char *)numbuf0___0, where);
    }
    {
#line 142
    __cil_tmp42 = format_linenum((char *)numbuf1___0, max_matched);
    }
    {
#line 142
    __cil_tmp43 = format_linenum((char *)numbuf2, max + 1L);
#line 142
    say((char const   *)((char *)"where=%s matched=%s changes=%s\n"), __cil_tmp41,
        __cil_tmp42, __cil_tmp43);
    }
  }
  out: 
#line 149
  *matched = max_matched;
#line 150
  if (where < min_where) {
#line 151
    where = min_where;
  }
#line 152
  return (where);
}
}
#line 156 "/tmp/0/patch-2.7.1/src/merge.c"
static void print_linerange(lin from , lin to ) 
{ 
  char numbuf0[23] ;
  char numbuf1[23] ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 161
  if (to <= from) {
    {
#line 162
    __cil_tmp5 = format_linenum((char *)numbuf0, from);
#line 162
    printf((char const   *)((char *)"%s"), __cil_tmp5);
    }
  } else {
    {
#line 165
    __cil_tmp6 = format_linenum((char *)numbuf0, from);
    }
    {
#line 165
    __cil_tmp7 = format_linenum((char *)numbuf1, to);
#line 165
    printf((char const   *)((char *)"%s-%s"), __cil_tmp6, __cil_tmp7);
    }
  }
}
}
#line 171 "/tmp/0/patch-2.7.1/src/merge.c"
static void merge_result(int *first_result , int hunk , char const   *what , lin from ,
                         lin to ) 
{ 
  static char const   *last_what ;

  {
#line 175
  if (*first_result) {
#line 175
    if (what) {
      {
#line 177
      printf((char const   *)((char *)"Hunk #%d %s at "), hunk, what);
#line 178
      last_what = what;
      }
    } else {
#line 175
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 180
  if (! what) {
#line 182
    if (! *first_result) {
      {
#line 184
      fputs((char const   *)((char *)".\n"), stdout);
#line 185
      fflush(stdout);
#line 186
      last_what = (char const   *)0;
      }
    }
#line 188
    return;
  } else
#line 190
  if (last_what == what) {
    {
#line 191
    fputs((char const   *)((char *)","), stdout);
    }
  } else {
    {
#line 193
    printf((char const   *)((char *)", %s at "), what);
    }
  }
  {
#line 194
  print_linerange(from + out_offset, to + out_offset);
#line 195
  *first_result = 0;
  }
}
}
#line 199 "/tmp/0/patch-2.7.1/src/merge.c"
int merge_hunk(int hunk , struct outstate *outstate , lin where , int *somefailed ) 
{ 
  int applies_cleanly ;
  int first_result ;
  int already_applied ;
  FILE *fp ;
  lin old ;
  lin firstold ;
  lin __cil_tmp11 ;
  lin new ;
  lin firstnew ;
  lin __cil_tmp14 ;
  lin in ;
  lin firstin ;
  char *oldin ;
  lin matched ;
  lin lastwhere ;
  char __cil_tmp22 ;
  char __cil_tmp23 ;
  void *__cil_tmp27 ;
  char numbuf0[23] ;
  char numbuf1[23] ;
  lin n ;
  char *__cil_tmp31 ;
  lin __cil_tmp32 ;
  char *__cil_tmp33 ;
  lin __cil_tmp34 ;
  char *__cil_tmp35 ;
  size_t __cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  size_t size ;
  char const   *line ;
  int __cil_tmp44 ;
  char __cil_tmp45 ;
  char __cil_tmp46 ;
  lin lines ;
  char __cil_tmp48 ;
  char __cil_tmp52 ;
  char __cil_tmp56 ;
  char __cil_tmp57 ;
  char __cil_tmp58 ;
  char __cil_tmp63 ;
  char __cil_tmp64 ;
  int __cil_tmp66 ;
  char __cil_tmp67 ;
  char __cil_tmp68 ;
  int __cil_tmp72 ;
  char __cil_tmp76 ;
  char __cil_tmp81 ;
  char __cil_tmp83 ;
  char __cil_tmp88 ;
  char __cil_tmp89 ;
  int __cil_tmp97 ;
  lin __cil_tmp98 ;
  lin __cil_tmp99 ;
  lin __cil_tmp100 ;
  lin common_prefix ;
  int __cil_tmp102 ;
  lin common_suffix ;
  lin lines___0 ;
  int __cil_tmp105 ;
  lin __cil_tmp106 ;
  lin __cil_tmp107 ;
  lin __cil_tmp108 ;
  lin __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;

  {
  {
#line 202
  first_result = 1;
#line 204
  fp = outstate->ofp;
#line 205
  old = (lin )1;
#line 206
  __cil_tmp11 = pch_ptrn_lines();
#line 206
  firstold = __cil_tmp11;
#line 207
  new = firstold + 1L;
#line 208
  __cil_tmp14 = pch_end();
#line 208
  firstnew = __cil_tmp14;
#line 216
  pch_normalize((enum diff )5);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((int )__cil_tmp22 == 61 || (int )__cil_tmp23 == 10)) {
#line 219
      goto while_break;
    }
#line 220
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (where) {
    {
#line 224
    applies_cleanly = 1;
#line 225
    matched = pch_ptrn_lines();
    }
  } else {
    {
#line 229
    where = locate_merge(& matched);
#line 230
    applies_cleanly = 0;
    }
  }
  {
#line 233
  in = firstold + 2L;
#line 234
  __cil_tmp27 = xmalloc((size_t )((in + matched) + 1L));
#line 234
  oldin = (char *)__cil_tmp27;
#line 235
  memset((void *)oldin, ' ', (unsigned long )(in + matched));
#line 236
  *(oldin + 0) = (char )'*';
#line 237
  *(oldin + (in - 1L)) = (char )'=';
#line 238
  *(oldin + (in + matched)) = (char )'^';
#line 239
  compute_changes(old, in - 1L, where, where + matched, oldin + old, oldin + in);
  }
#line 242
  if (debug & 2) {
    {
#line 248
    fputc('\n', stderr);
#line 249
    n = (lin )0;
    }
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! (n <= in + matched)) {
#line 249
        goto while_break___0;
      }
      {
#line 251
      __cil_tmp31 = format_linenum((char *)numbuf0, n);
#line 251
      fprintf(stderr, (char const   *)((char *)"%s %c"), __cil_tmp31, (int )*(oldin + n));
      }
#line 254
      if (n == 0L) {
        {
#line 255
        __cil_tmp32 = pch_first();
#line 255
        __cil_tmp33 = format_linenum((char *)numbuf0, __cil_tmp32);
        }
        {
#line 255
        __cil_tmp34 = pch_ptrn_lines();
#line 255
        __cil_tmp35 = format_linenum((char *)numbuf1, __cil_tmp34);
#line 255
        fprintf(stderr, (char const   *)((char *)" %s,%s\n"), __cil_tmp33, __cil_tmp35);
        }
      } else
#line 258
      if (n <= firstold) {
        {
#line 259
        __cil_tmp36 = pch_line_len(n);
        }
        {
#line 259
        __cil_tmp37 = pfetch(n);
#line 259
        fprintf(stderr, (char const   *)((char *)" |%.*s"), (int )__cil_tmp36, __cil_tmp37);
        }
      } else
#line 261
      if (n == in - 1L) {
        {
#line 262
        __cil_tmp38 = format_linenum((char *)numbuf0, where);
        }
        {
#line 262
        __cil_tmp39 = format_linenum((char *)numbuf1, matched);
#line 262
        fprintf(stderr, (char const   *)((char *)" %s,%s\n"), __cil_tmp38, __cil_tmp39);
        }
      } else
#line 265
      if (n >= in) {
#line 265
        if (n < in + matched) {
          {
#line 270
          line = ifetch((where + n) - in, 0, & size);
#line 271
          fprintf(stderr, (char const   *)((char *)" |%.*s"), (int )size, line);
          }
        } else {
          {
          {
#line 275
          fputc('\n', stderr);
          }
          }
        }
      } else {
        {
        {
#line 275
        fputc('\n', stderr);
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 249
    n ++;
#line 277
    fflush(stderr);
    }
  }
#line 280
  if (last_frozen_line < where - 1L) {
    {
#line 281
    __cil_tmp44 = copy_till(outstate, where - 1L);
    }
#line 281
    if (! __cil_tmp44) {
#line 282
      return (0);
    }
  }
  {
#line 284
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 284
    if (! 1) {
#line 284
      goto while_break___1;
    }
    {
#line 286
    firstold = old;
#line 287
    firstnew = new;
#line 288
    firstin = in;
#line 290
    __cil_tmp46 = pch_char(new);
    }
    {
#line 290
    __cil_tmp45 = pch_char(old);
    }
#line 290
    if ((int )__cil_tmp45 == 45) {
      _L: /* CIL Label */ 
      {
#line 294
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 294
        if (! ((int )__cil_tmp48 == 45)) {
#line 294
          goto while_break___2;
        }
#line 296
        if ((int )*(oldin + old) == 45) {
#line 297
          goto conflict;
        } else
#line 296
        if ((int )*(oldin + in) == 43) {
#line 297
          goto conflict;
        } else
#line 298
        if ((int )*(oldin + old) == 32) {
#line 301
          in ++;
        }
#line 303
        old ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 305
      if ((int )*(oldin + old) == 45) {
#line 306
        goto conflict;
      } else
#line 305
      if ((int )*(oldin + in) == 43) {
#line 306
        goto conflict;
      }
      {
#line 307
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 307
        if (! ((int )__cil_tmp52 == 43)) {
#line 307
          goto while_break___3;
        }
#line 308
        new ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 310
      lines = new - firstnew;
#line 311
      if ((unsigned int )verbosity == 2U) {
        {
        {
#line 313
        merge_result(& first_result, hunk, (char const   *)((char *)"merged"), where,
                     (where + lines) - 1L);
        }
        }
      } else
#line 311
      if ((unsigned int )verbosity != 1U) {
#line 311
        if (! applies_cleanly) {
          {
          {
#line 313
          merge_result(& first_result, hunk, (char const   *)((char *)"merged"), where,
                       (where + lines) - 1L);
          }
          }
        }
      }
#line 315
      last_frozen_line += old - firstold;
#line 316
      where += old - firstold;
#line 317
      out_offset += new - firstnew;
#line 319
      if (firstnew < new) {
        {
#line 321
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 321
          if (! (firstnew < new)) {
#line 321
            goto while_break___4;
          }
          {
#line 323
          outstate->after_newline = pch_write_line(firstnew, fp);
#line 324
          firstnew ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 326
        outstate->zero_output = 0;
      }
    } else
#line 290
    if ((int )__cil_tmp46 == 43) {
#line 290
      goto _L;
    } else {
      {
#line 329
      __cil_tmp56 = pch_char(old);
      }
#line 329
      if ((int )__cil_tmp56 == 32) {
#line 331
        if ((int )*(oldin + old) == 45) {
          {
#line 333
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 333
            if (! ((int )__cil_tmp57 == 32)) {
#line 333
              goto while_break___5;
            }
#line 335
            if ((int )*(oldin + old) != 45) {
#line 336
              goto while_break___5;
            }
            {
#line 337
            __cil_tmp58 = pch_char(new);
            }
#line 337
            if ((int )__cil_tmp58 == 43) {
#line 338
              goto conflict;
            }
#line 341
            old ++;
#line 342
            new ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 344
          __cil_tmp64 = pch_char(new);
          }
          {
#line 344
          __cil_tmp63 = pch_char(old);
          }
#line 344
          if ((int )__cil_tmp63 == 45) {
#line 345
            goto conflict;
          } else
#line 344
          if ((int )__cil_tmp64 == 43) {
#line 345
            goto conflict;
          }
        } else
#line 347
        if ((int )*(oldin + in) == 43) {
          {
#line 349
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 349
            if (! ((int )*(oldin + in) == 43)) {
#line 349
              goto while_break___6;
            }
#line 350
            in ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 353
          where += in - firstin;
#line 354
          __cil_tmp66 = copy_till(outstate, where - 1L);
          }
#line 354
          if (! __cil_tmp66) {
#line 355
            return (0);
          }
        } else
#line 357
        if ((int )*(oldin + old) == 32) {
          {
#line 359
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 359
            if (! ((((int )__cil_tmp67 == 32 && (int )*(oldin + old) == 32) && (int )__cil_tmp68 == 32) && (int )*(oldin + in) == 32)) {
#line 359
              goto while_break___7;
            }
#line 364
            old ++;
#line 365
            new ++;
#line 366
            in ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 370
          where += in - firstin;
#line 371
          __cil_tmp72 = copy_till(outstate, where - 1L);
          }
#line 371
          if (! __cil_tmp72) {
#line 372
            return (0);
          }
        }
      } else {
#line 379
        goto while_break___1;
      }
    }
#line 381
    goto while_continue___1;
    conflict: 
    {
#line 385
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 385
      if (! 1) {
#line 385
        goto while_break___8;
      }
      {
#line 387
      __cil_tmp76 = pch_char(old);
      }
#line 387
      if ((int )__cil_tmp76 == 45) {
        {
#line 389
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 389
          if (! ((int )*(oldin + in) == 43)) {
#line 389
            goto while_break___9;
          }
#line 390
          in ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 391
        if ((int )*(oldin + old) == 32) {
#line 394
          in ++;
        }
#line 396
        old ++;
      } else
#line 398
      if ((int )*(oldin + old) == 45) {
        {
#line 400
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 400
          if (! ((int )__cil_tmp81 == 43)) {
#line 400
            goto while_break___10;
          }
#line 401
          new ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 402
        __cil_tmp83 = pch_char(old);
        }
#line 402
        if ((int )__cil_tmp83 == 32) {
#line 405
          new ++;
        }
#line 407
        old ++;
      } else {
        {
#line 409
        __cil_tmp88 = pch_char(new);
        }
#line 409
        if ((int )__cil_tmp88 == 43) {
          {
#line 410
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 410
            if (! ((int )__cil_tmp89 == 43)) {
#line 410
              goto while_break___11;
            }
#line 411
            new ++;
          }
          while_break___11: /* CIL Label */ ;
          }
        } else
#line 412
        if ((int )*(oldin + in) == 43) {
          {
#line 413
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 413
            if (! ((int )*(oldin + in) == 43)) {
#line 413
              goto while_break___12;
            }
#line 414
            in ++;
          }
          while_break___12: /* CIL Label */ ;
          }
        } else {
#line 416
          goto while_break___8;
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 424
    lastwhere = where;
    {
#line 424
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 424
      if (! ((firstin < in && firstnew < new) && __cil_tmp97)) {
#line 424
        goto while_break___13;
      }

    }
    while_break___13: /* CIL Label */ ;
    }
#line 427
    __cil_tmp100 = lastwhere;
#line 427
    lastwhere ++;
#line 427
    __cil_tmp99 = firstnew;
#line 427
    firstnew ++;
#line 427
    __cil_tmp98 = firstin;
#line 427
    firstin ++;
#line 429
    already_applied = firstin == in && firstnew == new;
#line 430
    if (already_applied) {
      {
#line 431
      merge_result(& first_result, hunk, (char const   *)((char *)"already applied"),
                   where, lastwhere - 1L);
      }
    }
#line 433
    if ((unsigned int )conflict_style == 1U) {
#line 435
      common_prefix = lastwhere - where;
#line 438
      firstin -= common_prefix;
#line 439
      firstnew -= common_prefix;
#line 440
      lastwhere -= common_prefix;
    }
#line 442
    if (where != lastwhere) {
      {
#line 444
      where = lastwhere;
#line 445
      __cil_tmp102 = copy_till(outstate, where - 1L);
      }
#line 445
      if (! __cil_tmp102) {
#line 446
        return (0);
      }
    }
#line 449
    if (! already_applied) {
#line 451
      common_suffix = (lin )0;
#line 454
      if ((unsigned int )conflict_style == 0U) {
#line 457
        lastwhere = where + (in - firstin);
        {
#line 457
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 457
          if (! ((firstin < in && firstnew < new) && __cil_tmp105)) {
#line 457
            goto while_break___14;
          }

        }
        while_break___14: /* CIL Label */ ;
        }
#line 460
        __cil_tmp109 = common_suffix;
#line 460
        common_suffix ++;
#line 460
        __cil_tmp108 = lastwhere;
#line 460
        lastwhere --;
#line 460
        __cil_tmp107 = new;
#line 460
        new --;
#line 460
        __cil_tmp106 = in;
#line 460
        in --;
      }
#line 464
      lines___0 = (3L + (in - firstin)) + (new - firstnew);
#line 465
      if ((unsigned int )conflict_style == 1U) {
#line 466
        lines___0 += 1L + (old - firstold);
      }
      {
#line 467
      merge_result(& first_result, hunk, (char const   *)((char *)"NOT MERGED"), where,
                   (where + lines___0) - 1L);
#line 469
      out_offset += lines___0 - (in - firstin);
#line 471
      fputs((char const   *)(outstate->after_newline + (char *)"\n<<<<<<<\n"), fp);
#line 472
      outstate->after_newline = 1;
      }
#line 473
      if (firstin < in) {
        {
#line 475
        where += in - firstin;
#line 476
        __cil_tmp110 = copy_till(outstate, where - 1L);
        }
#line 476
        if (! __cil_tmp110) {
#line 477
          return (0);
        }
      }
#line 480
      if ((unsigned int )conflict_style == 1U) {
        {
#line 482
        fputs((char const   *)(outstate->after_newline + (char *)"\n|||||||\n"), fp);
#line 483
        outstate->after_newline = 1;
        }
        {
#line 484
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 484
          if (! (firstold < old)) {
#line 484
            goto while_break___15;
          }
          {
#line 486
          outstate->after_newline = pch_write_line(firstold, fp);
#line 487
          firstold ++;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 491
      fputs((char const   *)(outstate->after_newline + (char *)"\n=======\n"), fp);
#line 492
      outstate->after_newline = 1;
      }
      {
#line 493
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 493
        if (! (firstnew < new)) {
#line 493
          goto while_break___16;
        }
        {
#line 495
        outstate->after_newline = pch_write_line(firstnew, fp);
#line 496
        firstnew ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 498
      fputs((char const   *)(outstate->after_newline + (char *)"\n>>>>>>>\n"), fp);
#line 499
      outstate->after_newline = 1;
#line 500
      outstate->zero_output = 0;
#line 501
      __cil_tmp115 = ferror(fp);
      }
#line 501
      if (__cil_tmp115) {
        {
#line 502
        write_fatal();
        }
      }
#line 505
      if (common_suffix) {
        {
#line 507
        where += common_suffix;
#line 508
        __cil_tmp116 = copy_till(outstate, where - 1L);
        }
#line 508
        if (! __cil_tmp116) {
#line 509
          return (0);
        }
#line 510
        in += common_suffix;
#line 511
        new += common_suffix;
      }
#line 513
      *somefailed = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 516
  merge_result(& first_result, 0, (char const   *)0, (lin )0, (lin )0);
#line 519
  free((void *)oldin);
  }
#line 520
  return (1);
}
}
#line 524 "/tmp/0/patch-2.7.1/src/merge.c"
static lin count_context_lines(void) 
{ 
  lin old ;
  lin lastold ;
  lin __cil_tmp3 ;
  lin context ;
  char __cil_tmp5 ;

  {
  {
#line 527
  __cil_tmp3 = pch_ptrn_lines();
#line 527
  lastold = __cil_tmp3;
#line 530
  old = (lin )1;
  }
#line 530
  context = (lin )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (old <= lastold)) {
#line 530
      goto while_break;
    }
    {
#line 531
    __cil_tmp5 = pch_char(old);
    }
#line 531
    if ((int )__cil_tmp5 == 32) {
#line 532
      context ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  old ++;
#line 533
  return (context);
}
}
#line 551 "/tmp/0/patch-2.7.1/src/merge.c"
static void compute_changes(lin xmin , lin xmax___0 , lin ymin , lin ymax , char *xchar ,
                            char *ychar ) 
{ 
  struct context ctxt ;
  lin diags ;
  void *__cil_tmp9 ;

  {
  {
#line 557
  ctxt.xchar = xchar - xmin;
#line 558
  ctxt.ychar = ychar - ymin;
#line 560
  diags = (xmax___0 + ymax) + 3L;
#line 561
  __cil_tmp9 = xmalloc((unsigned long )(2L * diags) * sizeof(*(ctxt.fdiag)));
#line 561
  ctxt.fdiag = (lin *)__cil_tmp9;
#line 562
  ctxt.bdiag = ctxt.fdiag + diags;
#line 563
  ctxt.fdiag += ymax + 1L;
#line 564
  ctxt.bdiag += ymax + 1L;
#line 566
  ctxt.heuristic = 1;
#line 567
  ctxt.too_expensive = xmax___0 + ymax;
#line 569
  compareseq(xmin, xmax___0, ymin, ymax, 1, & ctxt);
#line 571
  ctxt.fdiag -= ymax + 1L;
#line 572
  free((void *)ctxt.fdiag);
  }
}
}
#line 3 "./version.h"
void version(void) ;
#line 7 "/tmp/0/patch-2.7.1/src/version.c"
static char const   copyright_string[]  =    "Copyright (C) 2003, 2009-2012 Free Software Foundation, Inc.\nCopyright (C) 1988 Larry Wall";
#line 11 "/tmp/0/patch-2.7.1/src/version.c"
static char const   free_software_msgid[]  =    "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.";
#line 16 "/tmp/0/patch-2.7.1/src/version.c"
static char const   authorship_msgid[]  =    "Written by Larry Wall and Paul Eggert";
#line 20 "/tmp/0/patch-2.7.1/src/version.c"
void version(void) 
{ 


  {
  {
#line 22
  printf((char const   *)((char *)"%s %s\n%s\n\n%s\n\n%s\n"), (char *)"GNU patch",
         (char *)"2.7.1", (char const   *)copyright_string, (char const   *)free_software_msgid,
         (char const   *)authorship_msgid);
  }
}
}
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 73 "./common.h"
char *buf ;
#line 74
size_t bufsize ;
#line 76
int using_plan_a ;
#line 83
int dry_run ;
#line 84
int posixly_correct ;
#line 86
char const   *origprae ;
#line 87
char const   *origbase ;
#line 88
char const   *origsuff ;
#line 103
int force ;
#line 104
int batch ;
#line 105
int noreverse ;
#line 106
int reverse ;
#line 108
int skip_rest_of_patch ;
#line 111
int patch_get ;
#line 112
int set_time ;
#line 113
int set_utc ;
#line 114
int follow_symlinks ;
#line 143
void fatal_exit(int sig ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 781 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 486 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 782
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 805
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 811
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path , char *__buf ,
                                                      size_t __len ) ;
#line 828
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 837
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 203 "/usr/include/fcntl.h"
extern int creat(char const   *__file , mode_t __mode ) ;
#line 32 "./util.h"
enum backup_type backup_type ;
#line 34
int ok_to_reverse(char const   *format  , ...) ;
#line 35
void ask(char const   *format  , ...) ;
#line 38
void fatal(char const   *format  , ...) ;
#line 40
void pfatal(char const   *format  , ...) ;
#line 43
void fetchname(char const   *at , int strip_leading , char **pname , char **ptimestr ,
               struct timespec *pstamp ) ;
#line 44
char *parse_name(char const   *s , int strip_leading , char const   **endp ) ;
#line 45
char *savebuf(char const   *s , size_t size ) ;
#line 46
char *savestr(char const   *s ) ;
#line 47
char const   *version_controller(char const   *filename , int readonly , struct stat *filestat ,
                                 char **getbuf , char **diffbuf ) ;
#line 48
int version_get(char const   *filename , char const   *cs , int exists , int readonly ,
                char const   *getbuf , struct stat *filestat ) ;
#line 49
int create_file(char const   *file , int open_flags , mode_t mode , int to_dir_known_to_exist ) ;
#line 50
int systemic(char const   *command ) ;
#line 52
void Fseek(FILE *stream , file_offset offset , int ptrname ) ;
#line 53
void copy_file(char const   *from , char const   *to , struct stat *tost , int to_flags ,
               mode_t mode , int to_dir_known_to_exist ) ;
#line 54
void append_to_file(char const   *from , char const   *to ) ;
#line 55
void exit_with_signal(int sig ) ;
#line 56
void ignore_signals(void) ;
#line 57
void init_backup_hash_table(void) ;
#line 58
void init_time(void) ;
#line 60
void create_backup(char const   *to , struct stat *to_st , int leave_original ) ;
#line 61
void move_file(char const   *from , int *from_needs_removal , struct stat *fromst ,
               char const   *to , mode_t mode , int backup ) ;
#line 62
void read_fatal(void) ;
#line 63
void remove_prefix(char *p , size_t prefixlen ) ;
#line 64
void removedirs(char const   *name ) ;
#line 65
void set_signals(int reset ) ;
#line 67
void insert_file_id(struct stat *st , enum file_id_type type ) ;
#line 68
enum file_id_type lookup_file_id(struct stat *st ) ;
#line 69
void set_queued_output(struct stat *st , int queued_output ) ;
#line 70
int has_queued_output(struct stat *st ) ;
#line 71
int stat_file(char const   *filename , struct stat *st ) ;
#line 80
void set_file_attributes(char const   *to , enum file_attributes attr , char const   *from ,
                         struct stat *st , mode_t mode , struct timespec *new_time ) ;
#line 91
int make_tempfile(char const   **name , char letter , char const   *real_name , int flags ,
                  mode_t mode ) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 196
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 54 "/tmp/0/patch-2.7.1/src/util.c"
static void makedirs(char const   *name ) ;
#line 67 "/tmp/0/patch-2.7.1/src/util.c"
static size_t file_id_hasher(void const   *entry , size_t table_size ) 
{ 
  file_id *e ;
  size_t i ;

  {
#line 69
  e = (file_id *)entry;
#line 70
  i = e->ino + e->dev;
#line 71
  return (i % table_size);
}
}
#line 77 "/tmp/0/patch-2.7.1/src/util.c"
static int file_id_comparator(void const   *entry1 , void const   *entry2 ) 
{ 
  file_id *e1 ;
  file_id *e2 ;

  {
#line 79
  e1 = (file_id *)entry1;
#line 80
  e2 = (file_id *)entry2;
#line 81
  return (e1->ino == e2->ino && e1->dev == e2->dev);
}
}
#line 84
static Hash_table *file_id_table ;
#line 89 "/tmp/0/patch-2.7.1/src/util.c"
void init_backup_hash_table(void) 
{ 


  {
  {
#line 91
  file_id_table = hash_initialize((size_t )0, (Hash_tuning *)((void *)0), file_id_hasher,
                                  file_id_comparator, free);
  }
#line 93
  if (! file_id_table) {
    {
#line 94
    xalloc_die();
    }
  }
}
}
#line 98 "/tmp/0/patch-2.7.1/src/util.c"
static file_id *__insert_file_id(struct stat *st , enum file_id_type type ) 
{ 
  file_id *p ;
  static file_id *next_slot ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 103
  if (! next_slot) {
    {
#line 104
    __cil_tmp5 = xmalloc(sizeof(*next_slot));
#line 104
    next_slot = (file_id *)__cil_tmp5;
    }
  }
  {
#line 105
  next_slot->dev = st->st_dev;
#line 106
  next_slot->ino = st->st_ino;
#line 107
  next_slot->queued_output = 0;
#line 108
  __cil_tmp6 = hash_insert(file_id_table, (void const   *)next_slot);
#line 108
  p = (file_id *)__cil_tmp6;
  }
#line 109
  if (! p) {
    {
#line 110
    xalloc_die();
    }
  }
#line 111
  if (p == next_slot) {
#line 112
    next_slot = (file_id *)((void *)0);
  }
#line 113
  p->type = type;
#line 114
  return (p);
}
}
#line 118 "/tmp/0/patch-2.7.1/src/util.c"
static file_id *__lookup_file_id(struct stat *st ) 
{ 
  file_id f ;
  void *__cil_tmp3 ;

  {
  {
#line 122
  f.dev = st->st_dev;
#line 123
  f.ino = st->st_ino;
#line 124
  __cil_tmp3 = hash_lookup(file_id_table, (void const   *)(& f));
  }
#line 124
  return ((file_id *)__cil_tmp3);
}
}
#line 131 "/tmp/0/patch-2.7.1/src/util.c"
void insert_file_id(struct stat *st , enum file_id_type type ) 
{ 


  {
  {
#line 133
  __insert_file_id(st, type);
  }
}
}
#line 140 "/tmp/0/patch-2.7.1/src/util.c"
enum file_id_type lookup_file_id(struct stat *st ) 
{ 
  file_id *p ;
  file_id *__cil_tmp3 ;
  unsigned int tmp ;

  {
  {
#line 142
  __cil_tmp3 = __lookup_file_id(st);
#line 142
  p = __cil_tmp3;
  }
#line 144
  if (p) {
#line 144
    tmp = (unsigned int )p->type;
  } else {
#line 144
    tmp = (unsigned int )0;
  }
#line 144
  return ((enum file_id_type )tmp);
}
}
#line 148 "/tmp/0/patch-2.7.1/src/util.c"
void set_queued_output(struct stat *st , int queued_output ) 
{ 
  file_id *p ;
  file_id *__cil_tmp4 ;

  {
  {
#line 150
  __cil_tmp4 = __lookup_file_id(st);
#line 150
  p = __cil_tmp4;
  }
#line 152
  if (! p) {
    {
#line 153
    p = __insert_file_id(st, (enum file_id_type )0);
    }
  }
#line 154
  p->queued_output = queued_output;
}
}
#line 158 "/tmp/0/patch-2.7.1/src/util.c"
int has_queued_output(struct stat *st ) 
{ 
  file_id *p ;
  file_id *__cil_tmp3 ;

  {
  {
#line 160
  __cil_tmp3 = __lookup_file_id(st);
#line 160
  p = __cil_tmp3;
  }
#line 162
  return (p && p->queued_output);
}
}
#line 166 "/tmp/0/patch-2.7.1/src/util.c"
static int contains_slash(char const   *s ) 
{ 


  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((char )*s)) {
#line 168
      goto while_break;
    }
#line 169
    if ((int )((char )*s) == 47) {
#line 170
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  s ++;
#line 171
  return (0);
}
}
#line 224 "/tmp/0/patch-2.7.1/src/util.c"
static int copy_attr(char const   *src_path , char const   *dst_path ) 
{ 


  {
#line 226
  return (0);
}
}
#line 232 "/tmp/0/patch-2.7.1/src/util.c"
void set_file_attributes(char const   *to , enum file_attributes attr , char const   *from ,
                         struct stat *st , mode_t mode , struct timespec *new_time ) 
{ 
  struct timespec times[2] ;
  int __cil_tmp10 ;
  char *tmp ;
  char *__cil_tmp12 ;
  static uid_t euid ;
  static gid_t egid ;
  uid_t uid ;
  uid_t gid ;
  unsigned int tmp___0 ;
  unsigned int tmp___110 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  int *__cil_tmp29 ;
  int *__cil_tmp30 ;
  int *__cil_tmp31 ;
  int __cil_tmp32 ;
  char *tmp___113 ;
  char *__cil_tmp34 ;

  {
#line 236
  if ((unsigned int )attr & 1U) {
#line 239
    if (new_time) {
#line 240
      times[1] = *new_time;
#line 240
      times[0] = times[1];
    } else {
      {
#line 243
      times[0] = get_stat_atime(st);
#line 244
      times[1] = get_stat_mtime(st);
      }
    }
    {
#line 246
    __cil_tmp10 = lutimens(to, (struct timespec [2])((struct timespec *)times));
    }
#line 246
    if (__cil_tmp10 != 0) {
#line 247
      if ((mode & 61440U) == 40960U) {
#line 247
        tmp = (char *)"symbolic link";
      } else {
#line 247
        tmp = (char *)"file";
      }
      {
#line 247
      __cil_tmp12 = quotearg(to);
#line 247
      pfatal((char const   *)((char *)"Failed to set the timestamps of %s %s"), tmp,
             __cil_tmp12);
      }
    }
  }
#line 251
  if ((unsigned int )attr & 2U) {
#line 253
    euid = (uid_t )(- 1);
#line 254
    egid = (gid_t )(- 1);
#line 258
    if (euid == 4294967295U) {
      {
#line 260
      euid = geteuid();
#line 261
      egid = getegid();
      }
    }
#line 263
    if (euid == st->st_uid) {
#line 263
      tmp___0 = (unsigned int )(- 1);
    } else {
#line 263
      tmp___0 = st->st_uid;
    }
#line 263
    uid = tmp___0;
#line 264
    if (egid == st->st_gid) {
#line 264
      tmp___110 = (unsigned int )(- 1);
    } else {
#line 264
      tmp___110 = st->st_gid;
    }
    {
#line 264
    gid = tmp___110;
#line 268
    __cil_tmp24 = __errno_location();
    }
    {
#line 268
    uid = (uid_t )(- 1);
#line 268
    __cil_tmp23 = lchown(to, uid, gid);
    }
    {
#line 268
    __cil_tmp22 = __errno_location();
    }
    {
#line 268
    __cil_tmp21 = lchown(to, uid, gid);
    }
#line 268
    if (uid != 4294967295U) {
      _L___113: /* CIL Label */ 
#line 268
      if (__cil_tmp21 != 0) {
#line 268
        if (*__cil_tmp22 != 1) {
          _L: /* CIL Label */ 
#line 274
          if (uid == 4294967295U) {
#line 274
            tmp___111 = (char *)"owner";
          } else {
#line 274
            tmp___111 = (char *)"owning group";
          }
#line 274
          if ((mode & 61440U) == 40960U) {
#line 274
            tmp___112 = (char *)"symbolic link";
          } else {
#line 274
            tmp___112 = (char *)"file";
          }
          {
#line 274
          __cil_tmp27 = quotearg(to);
#line 274
          pfatal((char const   *)((char *)"Failed to set the %s of %s %s"), tmp___111,
                 tmp___112, __cil_tmp27);
          }
        } else
#line 268
        if (uid != 4294967295U) {
#line 268
          if (__cil_tmp23 != 0) {
#line 268
            if (*__cil_tmp24 != 1) {
#line 268
              goto _L;
            }
          }
        }
      }
    } else
#line 268
    if (gid != 4294967295U) {
#line 268
      goto _L___113;
    }
  }
#line 279
  if ((unsigned int )attr & 8U) {
    {
#line 280
    __cil_tmp31 = __errno_location();
    }
    {
#line 280
    __cil_tmp30 = __errno_location();
    }
    {
#line 280
    __cil_tmp29 = __errno_location();
    }
    {
#line 280
    __cil_tmp28 = copy_attr(from, to);
    }
#line 280
    if (__cil_tmp28 != 0) {
#line 280
      if (*__cil_tmp29 != 38) {
#line 280
        if (*__cil_tmp30 != 95) {
#line 280
          if (*__cil_tmp31 != 1) {
            {
#line 282
            fatal_exit(0);
            }
          }
        }
      }
    }
  }
#line 283
  if ((unsigned int )attr & 4U) {
    {
#line 291
    __cil_tmp32 = chmod(to, mode);
    }
#line 291
    if (! ((mode & 61440U) == 40960U)) {
#line 291
      if (__cil_tmp32 != 0) {
#line 293
        if ((mode & 61440U) == 40960U) {
#line 293
          tmp___113 = (char *)"symbolic link";
        } else {
#line 293
          tmp___113 = (char *)"file";
        }
        {
#line 293
        __cil_tmp34 = quotearg(to);
#line 293
        pfatal((char const   *)((char *)"Failed to set the permissions of %s %s"),
               tmp___113, __cil_tmp34);
        }
      }
    }
  }
}
}
#line 300 "/tmp/0/patch-2.7.1/src/util.c"
static void create_backup_copy(char const   *from , char const   *to , struct stat *st ,
                               int to_dir_known_to_exist ) 
{ 


  {
  {
#line 303
  copy_file(from, to, (struct stat *)((void *)0), 0, st->st_mode, to_dir_known_to_exist);
#line 304
  set_file_attributes(to, (enum file_attributes )7, from, st, st->st_mode, (struct timespec *)((void *)0));
  }
}
}
#line 308 "/tmp/0/patch-2.7.1/src/util.c"
void create_backup(char const   *to , struct stat *to_st , int leave_original ) 
{ 
  char *tmp ;
  enum file_id_type __cil_tmp5 ;
  char *__cil_tmp6 ;
  int try_makedirs_errno ;
  char *bakname ;
  char const   *p ;
  char const   *tmp___114 ;
  char const   *b ;
  char const   *tmp___115 ;
  char const   *s ;
  char const   *tmp___116 ;
  char const   *t ;
  size_t plen ;
  size_t __cil_tmp17 ;
  size_t blen ;
  size_t __cil_tmp19 ;
  size_t slen ;
  size_t __cil_tmp21 ;
  size_t tlen ;
  size_t __cil_tmp23 ;
  char const   *o ;
  size_t olen ;
  char const   *__cil_tmp26 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int fd ;
  char *__cil_tmp33 ;
  int *__cil_tmp35 ;
  char *__cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  int __cil_tmp41 ;
  int *__cil_tmp42 ;
  int *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 323
  if (to_st) {
#line 323
    if (! ((to_st->st_mode & 61440U) == 32768U || (to_st->st_mode & 61440U) == 40960U)) {
#line 324
      if ((to_st->st_mode & 61440U) == 40960U) {
#line 324
        tmp = (char *)"symbolic link";
      } else {
#line 324
        tmp = (char *)"regular file";
      }
      {
#line 324
      fatal((char const   *)((char *)"File %s is not a %s -- refusing to create backup"),
            to, tmp);
      }
    }
  }
  {
#line 327
  __cil_tmp5 = lookup_file_id(to_st);
  }
#line 327
  if (to_st) {
#line 327
    if ((unsigned int )__cil_tmp5 == 1U) {
#line 329
      if (debug & 4) {
        {
#line 330
        __cil_tmp6 = quotearg(to);
#line 330
        say((char const   *)((char *)"File %s already seen\n"), __cil_tmp6);
        }
      }
    } else {
#line 327
      goto _L___119;
    }
  } else {
    _L___119: /* CIL Label */ 
#line 334
    try_makedirs_errno = 0;
#line 337
    if (origprae) {
      _L___117: /* CIL Label */ 
#line 339
      if (origprae) {
#line 339
        tmp___114 = origprae;
      } else {
#line 339
        tmp___114 = (char const   *)((char *)"");
      }
#line 339
      p = tmp___114;
#line 340
      if (origbase) {
#line 340
        tmp___115 = origbase;
      } else {
#line 340
        tmp___115 = (char const   *)((char *)"");
      }
#line 340
      b = tmp___115;
#line 341
      if (origsuff) {
#line 341
        tmp___116 = origsuff;
      } else {
#line 341
        tmp___116 = (char const   *)((char *)"");
      }
      {
#line 341
      s = tmp___116;
#line 342
      t = to;
#line 343
      __cil_tmp17 = strlen(p);
#line 343
      plen = __cil_tmp17;
#line 344
      __cil_tmp19 = strlen(b);
#line 344
      blen = __cil_tmp19;
#line 345
      __cil_tmp21 = strlen(s);
#line 345
      slen = __cil_tmp21;
#line 346
      __cil_tmp23 = strlen(t);
#line 346
      tlen = __cil_tmp23;
#line 350
      olen = (size_t )0;
      }
#line 350
      o = t + tlen;
      {
#line 350
      while (1) {
        while_continue: /* CIL Label */ ;
#line 350
        if (! (o > t && ! ((int )((char )*(o - 1)) == 47))) {
#line 350
          goto while_break;
        }

      }
      while_break: /* CIL Label */ ;
      }
      {
#line 352
      __cil_tmp26 = o;
#line 352
      o --;
#line 354
      olen = (size_t )((t + tlen) - o);
#line 355
      tlen -= olen;
#line 356
      __cil_tmp27 = xmalloc(((((plen + tlen) + blen) + olen) + slen) + 1UL);
#line 356
      bakname = (char *)__cil_tmp27;
#line 357
      memcpy((void *)bakname, (void const   *)p, plen);
#line 358
      memcpy((void *)(bakname + plen), (void const   *)t, tlen);
#line 359
      memcpy((void *)((bakname + plen) + tlen), (void const   *)b, blen);
#line 360
      memcpy((void *)(((bakname + plen) + tlen) + blen), (void const   *)o, olen);
#line 361
      memcpy((void *)((((bakname + plen) + tlen) + blen) + olen), (void const   *)s,
             slen + 1UL);
#line 363
      __cil_tmp30 = contains_slash(origbase);
      }
      {
#line 363
      __cil_tmp29 = contains_slash(to);
      }
      {
#line 363
      __cil_tmp28 = contains_slash(origprae + 0);
      }
#line 363
      if (origprae) {
#line 363
        if (__cil_tmp28) {
#line 367
          try_makedirs_errno = 2;
        } else
#line 363
        if (__cil_tmp29) {
#line 367
          try_makedirs_errno = 2;
        } else {
#line 363
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 363
      if (origbase) {
#line 363
        if (__cil_tmp30) {
#line 367
          try_makedirs_errno = 2;
        }
      }
    } else
#line 337
    if (origbase) {
#line 337
      goto _L___117;
    } else
#line 337
    if (origsuff) {
#line 337
      goto _L___117;
    } else {
      {
#line 371
      bakname = find_backup_file_name(to, backup_type);
      }
#line 372
      if (! bakname) {
        {
#line 373
        xalloc_die();
        }
      }
    }
#line 376
    if (! to_st) {
#line 380
      if (debug & 4) {
        {
#line 381
        __cil_tmp33 = quotearg((char const   *)bakname);
#line 381
        say((char const   *)((char *)"Creating empty file %s\n"), __cil_tmp33);
        }
      }
      {
#line 383
      try_makedirs_errno = 2;
#line 384
      unlink((char const   *)bakname);
      }
      {
#line 385
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 385
        if (! (fd < 0)) {
#line 385
          goto while_break___0;
        }
        {
#line 387
        __cil_tmp35 = __errno_location();
        }
#line 387
        if (*__cil_tmp35 != try_makedirs_errno) {
          {
#line 388
          __cil_tmp36 = quotearg((char const   *)bakname);
#line 388
          pfatal((char const   *)((char *)"Can\'t create file %s"), __cil_tmp36);
          }
        }
        {
#line 389
        makedirs((char const   *)bakname);
#line 390
        try_makedirs_errno = 0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 392
      __cil_tmp37 = close(fd);
      }
#line 392
      if (__cil_tmp37 != 0) {
        {
#line 393
        __cil_tmp38 = quotearg((char const   *)bakname);
#line 393
        pfatal((char const   *)((char *)"Can\'t close file %s"), __cil_tmp38);
        }
      }
    } else
#line 395
    if (leave_original) {
      {
#line 396
      create_backup_copy(to, (char const   *)bakname, to_st, try_makedirs_errno == 0);
      }
    } else {
#line 399
      if (debug & 4) {
        {
#line 400
        __cil_tmp39 = quotearg_n(0, to);
        }
        {
#line 400
        __cil_tmp40 = quotearg_n(1, (char const   *)bakname);
#line 400
        say((char const   *)((char *)"Renaming file %s to %s\n"), __cil_tmp39, __cil_tmp40);
        }
      }
      {
#line 402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 402
        if (! (__cil_tmp41 != 0)) {
#line 402
          goto while_break___1;
        }
        {
#line 404
        __cil_tmp42 = __errno_location();
        }
#line 404
        if (*__cil_tmp42 == try_makedirs_errno) {
          {
#line 406
          makedirs((char const   *)bakname);
#line 407
          try_makedirs_errno = 0;
          }
        } else {
          {
#line 409
          __cil_tmp43 = __errno_location();
          }
#line 409
          if (*__cil_tmp43 == 18) {
            {
#line 411
            create_backup_copy(to, (char const   *)bakname, to_st, try_makedirs_errno == 0);
#line 413
            unlink(to);
            }
#line 414
            goto while_break___1;
          } else {
            {
#line 417
            __cil_tmp44 = quotearg_n(0, to);
            }
            {
#line 417
            __cil_tmp45 = quotearg_n(1, (char const   *)bakname);
#line 417
            pfatal((char const   *)((char *)"Can\'t rename file %s to %s"), __cil_tmp44,
                   __cil_tmp45);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 421
    free((void *)bakname);
    }
  }
}
}
#line 436 "/tmp/0/patch-2.7.1/src/util.c"
void move_file(char const   *from , int *from_needs_removal , struct stat *fromst ,
               char const   *to , mode_t mode , int backup ) 
{ 
  struct stat to_st ;
  int to_errno ;
  struct stat *tmp ;
  int to_dir_known_to_exist ;
  char *buffer ;
  void *__cil_tmp13 ;
  int fd ;
  int size ;
  int i ;
  char *__cil_tmp18 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  int to_dir_known_to_exist___0 ;
  int *__cil_tmp30 ;
  int __cil_tmp31 ;
  int *__cil_tmp32 ;
  struct stat tost ;
  int __cil_tmp34 ;
  int *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  int __cil_tmp40 ;
  int *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 443
  to_errno = stat_file(to, & to_st);
  }
#line 444
  if (backup) {
#line 445
    if (to_errno) {
#line 445
      tmp = (struct stat *)((void *)0);
    } else {
#line 445
      tmp = & to_st;
    }
    {
#line 445
    create_backup(to, tmp, 0);
    }
  }
#line 446
  if (! to_errno) {
    {
#line 447
    insert_file_id(& to_st, (enum file_id_type )3);
    }
  }
#line 449
  if (from) {
#line 451
    if ((mode & 61440U) == 40960U) {
      {
#line 453
      to_dir_known_to_exist = 0;
#line 457
      __cil_tmp13 = xmalloc((size_t )4096);
#line 457
      buffer = (char *)__cil_tmp13;
#line 458
      size = 0;
#line 460
      fd = open(from, 0);
      }
#line 460
      if (fd < 0) {
        {
#line 461
        __cil_tmp18 = quotearg(from);
#line 461
        pfatal((char const   *)((char *)"Can\'t reopen file %s"), __cil_tmp18);
        }
      }
      {
#line 462
      while (1) {
        while_continue: /* CIL Label */ ;
#line 462
        if (! (i > 0)) {
#line 462
          goto while_break;
        }
#line 463
        size += i;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 464
      __cil_tmp20 = close(fd);
      }
#line 464
      if (i != 0) {
        {
        {
#line 465
        read_fatal();
        }
        }
      } else
#line 464
      if (__cil_tmp20 != 0) {
        {
        {
#line 465
        read_fatal();
        }
        }
      }
#line 466
      *(buffer + size) = (char )0;
#line 468
      if (! backup) {
        {
#line 470
        __cil_tmp21 = unlink(to);
        }
#line 470
        if (__cil_tmp21 == 0) {
#line 471
          to_dir_known_to_exist = 1;
        }
      }
      {
#line 473
      __cil_tmp22 = symlink((char const   *)buffer, to);
      }
#line 473
      if (__cil_tmp22 != 0) {
        {
#line 475
        __cil_tmp23 = __errno_location();
        }
#line 475
        if (*__cil_tmp23 == 2) {
#line 475
          if (! to_dir_known_to_exist) {
            {
#line 476
            makedirs(to);
            }
          }
        }
        {
#line 477
        __cil_tmp24 = symlink((char const   *)buffer, to);
        }
#line 477
        if (__cil_tmp24 != 0) {
          {
#line 478
          pfatal((char const   *)((char *)"Can\'t create %s %s"), (char *)"symbolic link",
                 to);
          }
        }
      }
      {
#line 480
      free((void *)buffer);
#line 481
      __cil_tmp25 = lstat(to, & to_st);
      }
#line 481
      if (__cil_tmp25 != 0) {
        {
#line 482
        pfatal((char const   *)((char *)"Can\'t get file attributes of %s %s"), (char *)"symbolic link",
               to);
        }
      }
      {
#line 483
      insert_file_id(& to_st, (enum file_id_type )1);
      }
    } else {
#line 487
      if (debug & 4) {
        {
#line 488
        __cil_tmp26 = quotearg_n(0, from);
        }
        {
#line 488
        __cil_tmp27 = quotearg_n(1, to);
#line 488
        say((char const   *)((char *)"Renaming file %s to %s\n"), __cil_tmp26, __cil_tmp27);
        }
      }
      {
#line 491
      __cil_tmp28 = rename(from, to);
      }
#line 491
      if (__cil_tmp28 != 0) {
        {
#line 493
        to_dir_known_to_exist___0 = 0;
#line 495
        __cil_tmp30 = __errno_location();
        }
#line 495
        if (*__cil_tmp30 == 2) {
#line 495
          if (to_errno == -1) {
            _L: /* CIL Label */ 
            {
#line 498
            makedirs(to);
#line 499
            to_dir_known_to_exist___0 = 1;
#line 500
            __cil_tmp31 = rename(from, to);
            }
#line 500
            if (__cil_tmp31 == 0) {
#line 501
              goto rename_succeeded;
            }
          } else
#line 495
          if (to_errno == 2) {
#line 495
            goto _L;
          }
        }
        {
#line 504
        __cil_tmp32 = __errno_location();
        }
#line 504
        if (*__cil_tmp32 == 18) {
#line 507
          if (! backup) {
            {
#line 509
            __cil_tmp34 = unlink(to);
            }
#line 509
            if (__cil_tmp34 == 0) {
#line 510
              to_dir_known_to_exist___0 = 1;
            } else {
              {
#line 511
              __cil_tmp35 = __errno_location();
              }
#line 511
              if (*__cil_tmp35 != 2) {
                {
#line 512
                __cil_tmp36 = quotearg(to);
#line 512
                pfatal((char const   *)((char *)"Can\'t remove file %s"), __cil_tmp36);
                }
              }
            }
          }
          {
#line 514
          copy_file(from, to, & tost, 0, mode, to_dir_known_to_exist___0);
#line 515
          insert_file_id(& tost, (enum file_id_type )1);
          }
#line 516
          return;
        }
        {
#line 519
        __cil_tmp37 = quotearg_n(0, from);
        }
        {
#line 519
        __cil_tmp38 = quotearg_n(1, to);
#line 519
        pfatal((char const   *)((char *)"Can\'t rename file %s to %s"), __cil_tmp37,
               __cil_tmp38);
        }
      }
      rename_succeeded: 
      {
#line 524
      insert_file_id(fromst, (enum file_id_type )1);
      }
#line 528
      if (0 < to_errno) {
        _L___120: /* CIL Label */ 
#line 528
        if (from_needs_removal) {
#line 531
          *from_needs_removal = 0;
        }
      } else
#line 528
      if (to_errno == 0) {
#line 528
        if (to_st.st_nlink <= 1UL) {
#line 528
          goto _L___120;
        }
      }
    }
  } else
#line 534
  if (! backup) {
#line 536
    if (debug & 4) {
      {
#line 537
      __cil_tmp39 = quotearg(to);
#line 537
      say((char const   *)((char *)"Removing file %s\n"), __cil_tmp39);
      }
    }
    {
#line 538
    __cil_tmp41 = __errno_location();
    }
    {
#line 538
    __cil_tmp40 = unlink(to);
    }
#line 538
    if (__cil_tmp40 != 0) {
#line 538
      if (*__cil_tmp41 != 2) {
        {
#line 539
        __cil_tmp42 = quotearg(to);
#line 539
        pfatal((char const   *)((char *)"Can\'t remove file %s"), __cil_tmp42);
        }
      }
    }
  }
}
}
#line 547 "/tmp/0/patch-2.7.1/src/util.c"
int create_file(char const   *file , int open_flags , mode_t mode , int to_dir_known_to_exist ) 
{ 
  int try_makedirs_errno ;
  int tmp ;
  int fd ;
  int __cil_tmp8 ;
  char *f ;
  int *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 550
  if (to_dir_known_to_exist) {
#line 550
    tmp = 0;
  } else {
#line 550
    tmp = 2;
  }
#line 550
  try_makedirs_errno = tmp;
#line 552
  mode |= (unsigned int )384;
#line 553
  mode &= (unsigned int )(~ ((64 | (64 >> 3)) | ((64 >> 3) >> 3)));
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! 512) {
      {
#line 557
      __cil_tmp8 = creat(file, mode);
#line 557
      close(__cil_tmp8);
      }
    }
    {
#line 558
    fd = open(file, 576 | open_flags, mode);
    }
#line 559
    if (fd < 0) {
      {
#line 562
      __cil_tmp11 = __errno_location();
      }
#line 562
      if (*__cil_tmp11 != try_makedirs_errno) {
        {
#line 563
        __cil_tmp12 = quotearg(file);
#line 563
        pfatal((char const   *)((char *)"Can\'t create file %s"), __cil_tmp12);
        }
      }
      {
#line 564
      f = xstrdup(file);
#line 565
      makedirs((char const   *)f);
#line 566
      free((void *)f);
#line 567
      try_makedirs_errno = 0;
      }
    }
#line 554
    if (! (fd < 0)) {
#line 554
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (fd);
}
}
#line 574 "/tmp/0/patch-2.7.1/src/util.c"
static void copy_to_fd(char const   *from , int tofd ) 
{ 
  int fromfd ;
  ssize_t i ;
  char *__cil_tmp6 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 579
  fromfd = open(from, 0);
  }
#line 579
  if (fromfd < 0) {
    {
#line 580
    __cil_tmp6 = quotearg(from);
#line 580
    pfatal((char const   *)((char *)"Can\'t reopen file %s"), __cil_tmp6);
    }
  }
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (! (i != 0L)) {
#line 581
      goto while_break;
    }
#line 583
    if (i == -1L) {
      {
#line 584
      read_fatal();
      }
    }
    {
#line 585
    __cil_tmp8 = full_write(tofd, (void const   *)buf, (size_t )i);
    }
#line 585
    if (__cil_tmp8 != (unsigned long )i) {
      {
#line 586
      write_fatal();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 588
  __cil_tmp9 = close(fromfd);
  }
#line 588
  if (__cil_tmp9 != 0) {
    {
#line 589
    read_fatal();
    }
  }
}
}
#line 595 "/tmp/0/patch-2.7.1/src/util.c"
void copy_file(char const   *from , char const   *to , struct stat *tost , int to_flags ,
               mode_t mode , int to_dir_known_to_exist ) 
{ 
  int tofd ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *buffer ;
  void *__cil_tmp12 ;
  ssize_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 600
  if (debug & 4) {
#line 601
    if ((mode & 61440U) == 40960U) {
#line 601
      tmp = (char *)"symbolic link";
    } else {
#line 601
      tmp = (char *)"file";
    }
    {
#line 601
    __cil_tmp9 = quotearg_n(0, from);
    }
    {
#line 601
    __cil_tmp10 = quotearg_n(1, to);
#line 601
    say((char const   *)((char *)"Copying %s %s to %s\n"), tmp, __cil_tmp9, __cil_tmp10);
    }
  }
#line 605
  if ((mode & 61440U) == 40960U) {
    {
#line 607
    __cil_tmp12 = xmalloc((size_t )4096);
#line 607
    buffer = (char *)__cil_tmp12;
#line 609
    __cil_tmp13 = readlink(from, buffer, (size_t )4096);
    }
#line 609
    if (__cil_tmp13 < 0L) {
      {
#line 610
      pfatal((char const   *)((char *)"Can\'t read %s %s"), (char *)"symbolic link",
             from);
      }
    }
    {
#line 611
    __cil_tmp14 = symlink((char const   *)buffer, to);
    }
#line 611
    if (__cil_tmp14 != 0) {
      {
#line 612
      pfatal((char const   *)((char *)"Can\'t create %s %s"), (char *)"symbolic link",
             to);
      }
    }
    {
#line 613
    __cil_tmp15 = lstat(to, tost);
    }
#line 613
    if (tost) {
#line 613
      if (__cil_tmp15 != 0) {
        {
#line 614
        pfatal((char const   *)((char *)"Can\'t get file attributes of %s %s"), (char *)"symbolic link",
               to);
        }
      }
    }
    {
#line 615
    free((void *)buffer);
    }
  } else {
    {
#line 620
    tofd = create_file(to, 1 | to_flags, mode, to_dir_known_to_exist);
#line 622
    copy_to_fd(from, tofd);
#line 623
    __cil_tmp18 = fstat(tofd, tost);
    }
#line 623
    if (tost) {
#line 623
      if (__cil_tmp18 != 0) {
        {
#line 624
        pfatal((char const   *)((char *)"Can\'t get file attributes of %s %s"), (char *)"file",
               to);
        }
      }
    }
    {
#line 625
    __cil_tmp19 = close(tofd);
    }
#line 625
    if (__cil_tmp19 != 0) {
      {
#line 626
      write_fatal();
      }
    }
  }
}
}
#line 633 "/tmp/0/patch-2.7.1/src/util.c"
void append_to_file(char const   *from , char const   *to ) 
{ 
  int tofd ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 637
  tofd = open(to, 1025);
  }
#line 637
  if (tofd < 0) {
    {
#line 638
    __cil_tmp5 = quotearg(to);
#line 638
    pfatal((char const   *)((char *)"Can\'t reopen file %s"), __cil_tmp5);
    }
  }
  {
#line 639
  copy_to_fd(from, tofd);
#line 640
  __cil_tmp6 = close(tofd);
  }
#line 640
  if (__cil_tmp6 != 0) {
    {
#line 641
    write_fatal();
    }
  }
}
}
#line 644 "/tmp/0/patch-2.7.1/src/util.c"
static char const   DEV_NULL[]  =    "/dev/null";
#line 646 "/tmp/0/patch-2.7.1/src/util.c"
static char const   RCSSUFFIX[]  =    ",v";
#line 647 "/tmp/0/patch-2.7.1/src/util.c"
static char const   CHECKOUT[]  =    "co %s";
#line 648 "/tmp/0/patch-2.7.1/src/util.c"
static char const   CHECKOUT_LOCKED[]  =    "co -l %s";
#line 649 "/tmp/0/patch-2.7.1/src/util.c"
static char const   RCSDIFF1[]  =    "rcsdiff %s";
#line 651 "/tmp/0/patch-2.7.1/src/util.c"
static char const   SCCSPREFIX[]  =    "s.";
#line 652 "/tmp/0/patch-2.7.1/src/util.c"
static char const   GET[]  =    "get ";
#line 653 "/tmp/0/patch-2.7.1/src/util.c"
static char const   GET_LOCKED[]  =    "get -e ";
#line 654 "/tmp/0/patch-2.7.1/src/util.c"
static char const   SCCSDIFF1[]  =    "get -p ";
#line 655 "/tmp/0/patch-2.7.1/src/util.c"
static char const   SCCSDIFF2[]  =    "|diff - %s";
#line 657 "/tmp/0/patch-2.7.1/src/util.c"
static char const   CLEARTOOL_CO[]  =    "cleartool co -unr -nc ";
#line 659 "/tmp/0/patch-2.7.1/src/util.c"
static char const   PERFORCE_CO[]  =    "p4 edit ";
#line 662 "/tmp/0/patch-2.7.1/src/util.c"
static size_t quote_system_arg(char *quoted , char const   *arg ) 
{ 
  char *q ;
  char *__cil_tmp4 ;
  size_t len ;
  size_t __cil_tmp6 ;

  {
  {
#line 664
  __cil_tmp4 = quotearg_style((enum quoting_style )1, arg);
#line 664
  q = __cil_tmp4;
#line 665
  __cil_tmp6 = strlen((char const   *)q);
#line 665
  len = __cil_tmp6;
  }
#line 667
  if (quoted) {
    {
#line 668
    memcpy((void *)quoted, (void const   *)q, len + 1UL);
    }
  }
#line 669
  return (len);
}
}
#line 684 "/tmp/0/patch-2.7.1/src/util.c"
char const   *version_controller(char const   *filename , int readonly , struct stat *filestat ,
                                 char **getbuf , char **diffbuf ) 
{ 
  struct stat cstat ;
  char *dir ;
  char *__cil_tmp8 ;
  char *filebase ;
  char *__cil_tmp10 ;
  char const   *dotslash ;
  char *tmp ;
  size_t dirlen ;
  size_t __cil_tmp14 ;
  size_t maxfixlen ;
  size_t maxtrysize ;
  size_t __cil_tmp17 ;
  size_t quotelen ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t maxgetsize ;
  size_t maxdiffsize ;
  char *trybuf ;
  void *__cil_tmp24 ;
  char const   *r ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char *p ;
  void *__cil_tmp33 ;
  char const   *tmp___122 ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  char *p___0 ;
  void *__cil_tmp38 ;
  size_t __cil_tmp39 ;
  size_t __cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  char *p___1 ;
  void *__cil_tmp47 ;
  char const   *tmp___123 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  char *p___2 ;
  void *__cil_tmp52 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  char *__cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  char *p___3 ;
  void *__cil_tmp60 ;
  size_t __cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *p___4 ;
  void *__cil_tmp66 ;
  size_t __cil_tmp67 ;

  {
  {
#line 688
  __cil_tmp8 = dir_name(filename);
#line 688
  dir = __cil_tmp8;
#line 689
  __cil_tmp10 = base_name(filename);
#line 689
  filebase = __cil_tmp10;
  }
#line 690
  if ((int )((char )*filename) == 45) {
#line 690
    tmp = (char *)"./";
  } else {
#line 690
    tmp = (char *)"";
  }
  {
#line 690
  dotslash = (char const   *)tmp;
#line 691
  __cil_tmp14 = strlen((char const   *)dir);
#line 691
  dirlen = __cil_tmp14 + 1UL;
#line 692
  maxfixlen = ((sizeof("SCCS/") - 1UL) + sizeof(SCCSPREFIX)) - 1UL;
#line 693
  __cil_tmp17 = strlen((char const   *)filebase);
#line 693
  maxtrysize = ((dirlen + __cil_tmp17) + maxfixlen) + 1UL;
#line 694
  __cil_tmp20 = quote_system_arg((char *)0, (char const   *)filebase);
  }
  {
#line 694
  __cil_tmp19 = quote_system_arg((char *)0, (char const   *)dir);
#line 694
  quotelen = __cil_tmp19 + __cil_tmp20;
#line 695
  maxgetsize = (sizeof(CLEARTOOL_CO) + quotelen) + maxfixlen;
#line 696
  maxdiffsize = ((((sizeof(SCCSDIFF1) + sizeof(SCCSDIFF2)) + sizeof(DEV_NULL)) - 1UL) + 2UL * quotelen) + maxfixlen;
#line 699
  __cil_tmp24 = xmalloc(maxtrysize);
#line 699
  trybuf = (char *)__cil_tmp24;
#line 700
  r = (char const   *)0;
#line 702
  sprintf(trybuf, (char const   *)((char *)"%s/"), dir);
#line 710
  __cil_tmp31 = stat((char const   *)trybuf, & cstat);
  }
  {
#line 710
  __cil_tmp30 = sprintf(trybuf + dirlen, (char const   *)((char *)"%s%s"), filebase,
                        (char const   *)RCSSUFFIX);
  }
  {
#line 710
  __cil_tmp29 = stat((char const   *)trybuf, & cstat);
  }
  {
#line 710
  __cil_tmp28 = sprintf(trybuf + dirlen, (char const   *)((char *)"RCS/%s"), filebase);
  }
  {
#line 710
  __cil_tmp27 = stat((char const   *)trybuf, & cstat);
  }
  {
#line 710
  __cil_tmp26 = sprintf(trybuf + dirlen, (char const   *)((char *)"RCS/%s%s"), filebase,
                        (char const   *)RCSSUFFIX);
  }
#line 710
  if (__cil_tmp27 == 0) {
    _L___130: /* CIL Label */ 
#line 710
    if (! ((filestat && filestat->st_dev == cstat.st_dev) && filestat->st_ino == cstat.st_ino)) {
#line 717
      if (getbuf) {
        {
#line 719
        __cil_tmp33 = xmalloc(maxgetsize);
#line 719
        *getbuf = (char *)__cil_tmp33;
#line 719
        p = *getbuf;
        }
#line 720
        if (readonly) {
#line 720
          tmp___122 = (char const   *)CHECKOUT;
        } else {
#line 720
          tmp___122 = (char const   *)CHECKOUT_LOCKED;
        }
        {
#line 720
        sprintf(p, tmp___122, dotslash);
#line 721
        __cil_tmp35 = strlen((char const   *)p);
        }
        {
#line 721
        p += __cil_tmp35;
#line 722
        __cil_tmp36 = quote_system_arg(p, filename);
        }
#line 722
        p += __cil_tmp36;
#line 723
        *p = (char )'\000';
      }
#line 726
      if (diffbuf) {
        {
#line 728
        __cil_tmp38 = xmalloc(maxdiffsize);
#line 728
        *diffbuf = (char *)__cil_tmp38;
#line 728
        p___0 = *diffbuf;
#line 729
        sprintf(p___0, (char const   *)RCSDIFF1, dotslash);
#line 730
        __cil_tmp39 = strlen((char const   *)p___0);
        }
        {
#line 730
        p___0 += __cil_tmp39;
#line 731
        __cil_tmp40 = quote_system_arg(p___0, filename);
        }
        {
#line 731
        p___0 += __cil_tmp40;
#line 732
        __cil_tmp41 = p___0;
#line 732
        p___0 ++;
#line 732
        *__cil_tmp41 = (char )'>';
#line 733
        strcpy(p___0, (char const   *)DEV_NULL);
        }
      }
#line 736
      r = (char const   *)((char *)"RCS");
    } else {
#line 710
      goto _L___129;
    }
  } else
#line 710
  if (__cil_tmp29 == 0) {
#line 710
    goto _L___130;
  } else
#line 710
  if (__cil_tmp31 == 0) {
#line 710
    goto _L___130;
  } else {
    _L___129: /* CIL Label */ 
    {
#line 738
    __cil_tmp45 = stat((char const   *)trybuf, & cstat);
    }
    {
#line 738
    __cil_tmp44 = sprintf(trybuf + dirlen, (char const   *)((char *)"%s%s"), (char const   *)SCCSPREFIX,
                          filebase);
    }
    {
#line 738
    __cil_tmp43 = stat((char const   *)trybuf, & cstat);
    }
    {
#line 738
    __cil_tmp42 = sprintf(trybuf + dirlen, (char const   *)((char *)"SCCS/%s%s"),
                          (char const   *)SCCSPREFIX, filebase);
    }
#line 738
    if (__cil_tmp43 == 0) {
      _L___128: /* CIL Label */ 
#line 741
      if (getbuf) {
        {
#line 743
        __cil_tmp47 = xmalloc(maxgetsize);
#line 743
        *getbuf = (char *)__cil_tmp47;
#line 743
        p___1 = *getbuf;
        }
#line 744
        if (readonly) {
#line 744
          tmp___123 = (char const   *)GET;
        } else {
#line 744
          tmp___123 = (char const   *)GET_LOCKED;
        }
        {
#line 744
        sprintf(p___1, tmp___123);
#line 745
        __cil_tmp49 = strlen((char const   *)p___1);
        }
        {
#line 745
        p___1 += __cil_tmp49;
#line 746
        __cil_tmp50 = quote_system_arg(p___1, (char const   *)trybuf);
        }
#line 746
        p___1 += __cil_tmp50;
#line 747
        *p___1 = (char )'\000';
      }
#line 750
      if (diffbuf) {
        {
#line 752
        __cil_tmp52 = xmalloc(maxdiffsize);
#line 752
        *diffbuf = (char *)__cil_tmp52;
#line 752
        p___2 = *diffbuf;
#line 753
        strcpy(p___2, (char const   *)SCCSDIFF1);
#line 754
        p___2 += sizeof(SCCSDIFF1) - 1UL;
#line 755
        __cil_tmp53 = quote_system_arg(p___2, (char const   *)trybuf);
        }
        {
#line 755
        p___2 += __cil_tmp53;
#line 756
        sprintf(p___2, (char const   *)SCCSDIFF2, dotslash);
#line 757
        __cil_tmp54 = strlen((char const   *)p___2);
        }
        {
#line 757
        p___2 += __cil_tmp54;
#line 758
        __cil_tmp55 = quote_system_arg(p___2, filename);
        }
        {
#line 758
        p___2 += __cil_tmp55;
#line 759
        __cil_tmp56 = p___2;
#line 759
        p___2 ++;
#line 759
        *__cil_tmp56 = (char )'>';
#line 760
        strcpy(p___2, (char const   *)DEV_NULL);
        }
      }
#line 763
      r = (char const   *)((char *)"SCCS");
    } else
#line 738
    if (__cil_tmp45 == 0) {
#line 738
      goto _L___128;
    } else {
      {
#line 765
      __cil_tmp58 = stat((char const   *)trybuf, & cstat);
      }
      {
#line 765
      __cil_tmp57 = sprintf(trybuf + dirlen, (char const   *)((char *)"%s@@"), filebase);
      }
#line 765
      if (! readonly) {
#line 765
        if (filestat) {
#line 765
          if (__cil_tmp58 == 0) {
#line 765
            if ((cstat.st_mode & 61440U) == 16384U) {
#line 768
              if (getbuf) {
                {
#line 770
                __cil_tmp60 = xmalloc(maxgetsize);
#line 770
                *getbuf = (char *)__cil_tmp60;
#line 770
                p___3 = *getbuf;
#line 771
                strcpy(p___3, (char const   *)CLEARTOOL_CO);
#line 772
                p___3 += sizeof(CLEARTOOL_CO) - 1UL;
#line 773
                __cil_tmp61 = quote_system_arg(p___3, filename);
                }
#line 773
                p___3 += __cil_tmp61;
#line 774
                *p___3 = (char )'\000';
              }
#line 777
              if (diffbuf) {
#line 778
                *diffbuf = (char *)0;
              }
#line 780
              r = (char const   *)((char *)"ClearCase");
            } else {
#line 765
              goto _L___125;
            }
          } else {
#line 765
            goto _L___125;
          }
        } else {
#line 765
          goto _L___125;
        }
      } else {
        _L___125: /* CIL Label */ 
        {
#line 782
        __cil_tmp64 = getenv((char const   *)((char *)"P4CONFIG"));
        }
        {
#line 782
        __cil_tmp63 = getenv((char const   *)((char *)"P4USER"));
        }
        {
#line 782
        __cil_tmp62 = getenv((char const   *)((char *)"P4PORT"));
        }
#line 782
        if (! readonly) {
#line 782
          if (filestat) {
#line 782
            if (__cil_tmp62) {
              _L: /* CIL Label */ 
#line 785
              if (getbuf) {
                {
#line 787
                __cil_tmp66 = xmalloc(maxgetsize);
#line 787
                *getbuf = (char *)__cil_tmp66;
#line 787
                p___4 = *getbuf;
#line 788
                strcpy(p___4, (char const   *)PERFORCE_CO);
#line 789
                p___4 += sizeof(PERFORCE_CO) - 1UL;
#line 790
                __cil_tmp67 = quote_system_arg(p___4, filename);
                }
#line 790
                p___4 += __cil_tmp67;
#line 791
                *p___4 = (char )'\000';
              }
#line 794
              if (diffbuf) {
#line 795
                *diffbuf = (char *)0;
              }
#line 797
              r = (char const   *)((char *)"Perforce");
            } else
#line 782
            if (__cil_tmp63) {
#line 782
              goto _L;
            } else
#line 782
            if (__cil_tmp64) {
#line 782
              goto _L;
            }
          }
        }
      }
    }
  }
  {
#line 800
  free((void *)trybuf);
#line 801
  free((void *)filebase);
#line 802
  free((void *)dir);
  }
#line 803
  return (r);
}
}
#line 812 "/tmp/0/patch-2.7.1/src/util.c"
int version_get(char const   *filename , char const   *cs , int exists , int readonly ,
                char const   *getbuf , struct stat *filestat ) 
{ 
  char *__cil_tmp7 ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *tmp___0 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 815
  if (patch_get < 0) {
    {
#line 817
    __cil_tmp7 = quotearg(filename);
    }
#line 817
    if (readonly) {
#line 817
      tmp = (char *)"";
    } else {
#line 817
      tmp = (char *)" with lock";
    }
    {
#line 817
    ask((char const   *)((char *)"Get file %s from %s%s? [y] "), __cil_tmp7, cs, tmp);
    }
#line 819
    if ((int )*buf == 110) {
#line 820
      return (0);
    }
  }
#line 823
  if (dry_run) {
#line 825
    if (! exists) {
      {
#line 826
      __cil_tmp9 = quotearg(filename);
#line 826
      fatal((char const   *)((char *)"can\'t do dry run on nonexistent version-controlled file %s; invoke \'%s\' and try again"),
            __cil_tmp9, getbuf);
      }
    }
  } else {
#line 831
    if ((unsigned int )verbosity == 2U) {
      {
#line 832
      __cil_tmp10 = quotearg(filename);
      }
#line 832
      if (readonly) {
#line 832
        tmp___0 = (char *)"";
      } else {
#line 832
        tmp___0 = (char *)" with lock";
      }
      {
#line 832
      say((char const   *)((char *)"Getting file %s from %s%s...\n"), __cil_tmp10,
          cs, tmp___0);
      }
    }
    {
#line 834
    __cil_tmp12 = systemic(getbuf);
    }
#line 834
    if (__cil_tmp12 != 0) {
      {
#line 835
      __cil_tmp13 = quotearg(filename);
#line 835
      fatal((char const   *)((char *)"Can\'t get file %s from %s"), __cil_tmp13, cs);
      }
    }
    {
#line 836
    __cil_tmp14 = stat(filename, filestat);
    }
#line 836
    if (__cil_tmp14 != 0) {
      {
#line 837
      __cil_tmp15 = quotearg(filename);
#line 837
      pfatal((char const   *)((char *)"%s"), __cil_tmp15);
      }
    }
  }
#line 840
  return (1);
}
}
#line 846 "/tmp/0/patch-2.7.1/src/util.c"
char *savebuf(char const   *s , size_t size ) 
{ 
  char *rv ;
  void *__cil_tmp4 ;

  {
#line 850
  if (! size) {
#line 851
    return ((char *)((void *)0));
  }
  {
#line 853
  __cil_tmp4 = malloc(size);
#line 853
  rv = (char *)__cil_tmp4;
  }
#line 855
  if (! rv) {
#line 857
    if (! using_plan_a) {
      {
#line 858
      xalloc_die();
      }
    }
  } else {
    {
#line 861
    memcpy((void *)rv, (void const   *)s, size);
    }
  }
#line 863
  return (rv);
}
}
#line 867 "/tmp/0/patch-2.7.1/src/util.c"
char *savestr(char const   *s ) 
{ 
  size_t __cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 869
  __cil_tmp2 = strlen(s);
#line 869
  __cil_tmp3 = savebuf(s, __cil_tmp2 + 1UL);
  }
#line 869
  return (__cil_tmp3);
}
}
#line 873 "/tmp/0/patch-2.7.1/src/util.c"
void remove_prefix(char *p , size_t prefixlen ) 
{ 
  char const   *s ;
  char *__cil_tmp4 ;

  {
#line 875
  s = (char const   *)(p + prefixlen);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! *__cil_tmp4) {
#line 876
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 881 "/tmp/0/patch-2.7.1/src/util.c"
char *format_linenum(char numbuf[23] , lin n ) 
{ 
  char *p ;

  {
#line 883
  p = numbuf + ((sizeof(lin ) * 8UL) / 3UL + 1UL);
#line 884
  *p = (char )'\000';
#line 886
  if (n < 0L) {
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
#line 889
      p --;
#line 889
      *p = (char )(48 - (int )(n % 10L));
#line 888
      if (! (n != 0L)) {
#line 888
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 892
    p --;
#line 892
    *p = (char )'-';
  } else {
    {
#line 896
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 897
      p --;
#line 897
      *p = (char )(48 + (int )(n % 10L));
#line 896
      if (! (n != 0L)) {
#line 896
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 901
  return (p);
}
}
#line 907 "/tmp/0/patch-2.7.1/src/util.c"
void fatal(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 910
  fprintf(stderr, (char const   *)((char *)"%s: **** "), program_name);
#line 911
  __builtin_va_start((__builtin_va_list *)args, format);
#line 912
  vfprintf(stderr, format, (__builtin_va_list *)args);
#line 913
  __builtin_va_end((__builtin_va_list *)args);
#line 914
  _IO_putc('\n', stderr);
#line 915
  fflush(stderr);
#line 916
  fatal_exit(0);
  }
}
}
#line 926 "/tmp/0/patch-2.7.1/src/util.c"
void read_fatal(void) 
{ 


  {
  {
#line 928
  pfatal((char const   *)((char *)"read error"));
  }
}
}
#line 932 "/tmp/0/patch-2.7.1/src/util.c"
void write_fatal(void) 
{ 


  {
  {
#line 934
  pfatal((char const   *)((char *)"write error"));
  }
}
}
#line 940 "/tmp/0/patch-2.7.1/src/util.c"
void pfatal(char const   *format  , ...) 
{ 
  int errnum ;
  int *__cil_tmp3 ;
  va_list args ;
  int *__cil_tmp5 ;

  {
  {
#line 942
  __cil_tmp3 = __errno_location();
#line 942
  errnum = *__cil_tmp3;
#line 944
  fprintf(stderr, (char const   *)((char *)"%s: **** "), program_name);
#line 945
  __builtin_va_start((__builtin_va_list *)args, format);
#line 946
  vfprintf(stderr, format, (__builtin_va_list *)args);
#line 947
  __builtin_va_end((__builtin_va_list *)args);
#line 948
  fflush(stderr);
#line 949
  __cil_tmp5 = __errno_location();
#line 949
  *__cil_tmp5 = errnum;
#line 950
  perror((char const   *)((char *)" "));
#line 951
  fflush(stderr);
#line 952
  fatal_exit(0);
  }
}
}
#line 958 "/tmp/0/patch-2.7.1/src/util.c"
static void vsay(char const   *format , va_list args ) 
{ 


  {
  {
#line 960
  vfprintf(stdout, format, args);
#line 961
  fflush(stdout);
  }
}
}
#line 965 "/tmp/0/patch-2.7.1/src/util.c"
void say(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 968
  __builtin_va_start((__builtin_va_list *)args, format);
#line 969
  vsay(format, (__builtin_va_list *)args);
#line 970
  __builtin_va_end((__builtin_va_list *)args);
  }
}
}
#line 976 "/tmp/0/patch-2.7.1/src/util.c"
void ask(char const   *format  , ...) 
{ 
  static int ttyfd ;
  ssize_t r ;
  va_list args ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int tmp ;
  size_t s ;
  void *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 978
  ttyfd = - 2;
#line 982
  __builtin_va_start((__builtin_va_list *)args, format);
#line 983
  vfprintf(stdout, format, (__builtin_va_list *)args);
#line 984
  __builtin_va_end((__builtin_va_list *)args);
#line 985
  fflush(stdout);
  }
#line 987
  if (ttyfd == -2) {
    {
#line 995
    __cil_tmp5 = isatty(1);
    }
#line 995
    if (posixly_correct || __cil_tmp5) {
      {
#line 995
      __cil_tmp6 = open((char const   *)((char *)"/dev/tty"), 0);
#line 995
      tmp = __cil_tmp6;
      }
    } else {
#line 995
      tmp = - 1;
    }
#line 995
    ttyfd = tmp;
  }
#line 1000
  if (ttyfd < 0) {
    {
#line 1003
    printf((char const   *)((char *)"\n"));
#line 1004
    *(buf + 0) = (char )'\n';
#line 1005
    *(buf + 1) = (char )'\000';
    }
  } else {
#line 1009
    s = (size_t )0;
    {
#line 1010
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1010
      if (! ((unsigned long )r == (bufsize - 1UL) - s && (int )*(buf + (bufsize - 2UL)) != 10)) {
#line 1010
        goto while_break;
      }
      {
#line 1013
      s = bufsize - 1UL;
#line 1014
      bufsize *= (unsigned long )2;
#line 1015
      __cil_tmp10 = realloc((void *)buf, bufsize);
#line 1015
      buf = (char *)__cil_tmp10;
      }
#line 1016
      if (! buf) {
        {
#line 1017
        xalloc_die();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1019
    if (r == 0L) {
      {
#line 1020
      printf((char const   *)((char *)"EOF\n"));
      }
    } else
#line 1021
    if (r < 0L) {
      {
#line 1023
      __cil_tmp11 = __errno_location();
#line 1023
      error(0, *__cil_tmp11, (char const   *)((char *)"tty read failed"));
#line 1025
      ttyfd = - 1;
#line 1026
      r = (ssize_t )0;
      }
    }
#line 1028
    *(buf + (s + (unsigned long )r)) = (char )'\000';
  }
}
}
#line 1035 "/tmp/0/patch-2.7.1/src/util.c"
int ok_to_reverse(char const   *format  , ...) 
{ 
  int r ;
  va_list args ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1037
  r = 0;
#line 1039
  if (noreverse) {
    {
    {
#line 1042
    __builtin_va_start((__builtin_va_list *)args, format);
    }
    {
#line 1043
    vsay(format, (__builtin_va_list *)args);
    }
    {
#line 1044
    __builtin_va_end((__builtin_va_list *)args);
    }
    }
  } else
#line 1039
  if (! (force && (unsigned int )verbosity == 1U)) {
    {
    {
#line 1042
    __builtin_va_start((__builtin_va_list *)args, format);
    }
    {
#line 1043
    vsay(format, (__builtin_va_list *)args);
    }
    {
#line 1044
    __builtin_va_end((__builtin_va_list *)args);
    }
    }
  }
#line 1047
  if (noreverse) {
    {
#line 1049
    say((char const   *)((char *)"  Skipping patch.\n"));
#line 1050
    skip_rest_of_patch = 1;
    }
  } else
#line 1052
  if (force) {
#line 1054
    if ((unsigned int )verbosity != 1U) {
      {
#line 1055
      say((char const   *)((char *)"  Applying it anyway.\n"));
      }
    }
  } else
#line 1057
  if (batch) {
#line 1059
    if (reverse) {
#line 1059
      tmp = (char *)"  Ignoring -R.\n";
    } else {
#line 1059
      tmp = (char *)"  Assuming -R.\n";
    }
    {
#line 1059
    say((char const   *)tmp);
#line 1060
    r = 1;
    }
  } else {
#line 1064
    if (reverse) {
#line 1064
      tmp___0 = (char *)"  Ignore -R? [n] ";
    } else {
#line 1064
      tmp___0 = (char *)"  Assume -R? [n] ";
    }
    {
#line 1064
    ask((char const   *)tmp___0);
#line 1065
    r = (int )*buf == 121;
    }
#line 1066
    if (! r) {
      {
#line 1068
      ask((char const   *)((char *)"Apply anyway? [n] "));
      }
#line 1069
      if ((int )*buf != 121) {
#line 1071
        if ((unsigned int )verbosity != 1U) {
          {
#line 1072
          say((char const   *)((char *)"Skipping patch.\n"));
          }
        }
#line 1073
        skip_rest_of_patch = 1;
      }
    }
  }
#line 1078
  return (r);
}
}
#line 1084 "/tmp/0/patch-2.7.1/src/util.c"
static int const   sigs[]  = {      1,      13,      15,      24, 
        25,      2};
#line 1123
static sigset_t initial_signal_mask ;
#line 1124
static sigset_t signals_to_block ;
#line 1137 "/tmp/0/patch-2.7.1/src/util.c"
void set_signals(int reset ) 
{ 
  int i ;
  struct sigaction initial_act ;
  struct sigaction fatal_act ;
  int ignoring_signal ;
  int __cil_tmp6 ;

  {
  {
#line 1142
  fatal_act.__sigaction_handler.sa_handler = (__sighandler_t )fatal_exit;
#line 1143
  sigemptyset(& fatal_act.sa_mask);
#line 1144
  fatal_act.sa_flags = 0;
  }
#line 1150
  if (! reset) {
    {
#line 1154
    signal(17, (__sighandler_t )0);
#line 1156
    sigemptyset(& signals_to_block);
#line 1157
    i = 0;
    }
    {
#line 1157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1157
      if (! (i < (int )(sizeof(sigs) / sizeof(*((int const   *)sigs))))) {
#line 1157
        goto while_break;
      }
      {
#line 1161
      __cil_tmp6 = sigaction((int )sigs[i], (struct sigaction *)0, & initial_act);
      }
#line 1161
      if (__cil_tmp6 != 0) {
#line 1162
        goto while_continue;
      }
#line 1163
      ignoring_signal = initial_act.__sigaction_handler.sa_handler == (__sighandler_t )1;
#line 1167
      if (! ignoring_signal) {
        {
#line 1169
        sigaddset(& signals_to_block, (int )sigs[i]);
#line 1170
        sigaction((int )sigs[i], & fatal_act, (struct sigaction *)0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1157
    i ++;
  } else {
    {
#line 1178
    sigprocmask(2, & initial_signal_mask, (sigset_t *)0);
    }
  }
}
}
#line 1190 "/tmp/0/patch-2.7.1/src/util.c"
void ignore_signals(void) 
{ 


  {
  {
#line 1193
  sigprocmask(0, & signals_to_block, & initial_signal_mask);
  }
}
}
#line 1203 "/tmp/0/patch-2.7.1/src/util.c"
void exit_with_signal(int sig ) 
{ 
  sigset_t s ;

  {
  {
#line 1206
  signal(sig, (__sighandler_t )0);
#line 1207
  sigemptyset(& s);
#line 1208
  sigaddset(& s, sig);
#line 1209
  sigprocmask(1, & s, (sigset_t *)0);
#line 1210
  raise(sig);
#line 1211
  exit(2);
  }
}
}
#line 1215 "/tmp/0/patch-2.7.1/src/util.c"
int systemic(char const   *command ) 
{ 
  int __cil_tmp2 ;

  {
#line 1217
  if (debug & 8) {
    {
#line 1218
    say((char const   *)((char *)"+ %s\n"), command);
    }
  }
  {
#line 1219
  fflush(stdout);
#line 1220
  __cil_tmp2 = system(command);
  }
#line 1220
  return (__cil_tmp2);
}
}
#line 1227 "/tmp/0/patch-2.7.1/src/util.c"
static char *replace_slashes(char *filename ) 
{ 
  char *f ;
  char *last_location_replaced ;
  char const   *component_start ;
  char *slash ;

  {
#line 1230
  last_location_replaced = (char *)0;
#line 1233
  f = filename + 0;
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if (! ((int )*f == 47)) {
#line 1233
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 1233
  f ++;
#line 1236
  component_start = (char const   *)f;
  {
#line 1238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1238
    if (! *f) {
#line 1238
      goto while_break___0;
    }
#line 1239
    if ((int )*f == 47) {
#line 1241
      slash = f;
      {
#line 1244
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1244
        if (! ((int )*(f + 1) == 47)) {
#line 1244
          goto while_break___1;
        }
#line 1245
        f ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1248
      if (! *(f + 1)) {
#line 1249
        goto while_break___0;
      }
#line 1252
      if (! ((slash - component_start <= 2L && (int )((char )*(component_start + 0)) == 46) && (int )*(slash + -1) == 46)) {
#line 1255
        *slash = (char )'\000';
#line 1256
        last_location_replaced = slash;
      }
#line 1259
      component_start = (char const   *)(f + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1238
  f ++;
#line 1262
  return (last_location_replaced);
}
}
#line 1269 "/tmp/0/patch-2.7.1/src/util.c"
static void makedirs(char const   *name ) 
{ 
  char *filename ;
  char *__cil_tmp3 ;
  char *f ;
  char *flim ;
  char *__cil_tmp6 ;

  {
  {
#line 1271
  __cil_tmp3 = xstrdup(name);
#line 1271
  filename = __cil_tmp3;
#line 1273
  __cil_tmp6 = replace_slashes(filename);
#line 1273
  flim = __cil_tmp6;
  }
#line 1275
  if (flim) {
#line 1282
    f = filename;
    {
#line 1282
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1282
      if (! (f <= flim)) {
#line 1282
        goto while_break;
      }
#line 1283
      if (! *f) {
        {
#line 1285
        mkdir((char const   *)filename, (__mode_t )((((((448 | (256 >> 3)) | (128 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 1289
        *f = (char )'/';
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1282
    f ++;
  }
  {
#line 1292
  free((void *)filename);
  }
}
}
#line 1299 "/tmp/0/patch-2.7.1/src/util.c"
void removedirs(char const   *name ) 
{ 
  char *filename ;
  char *__cil_tmp3 ;
  size_t i ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 1301
  __cil_tmp3 = xstrdup(name);
#line 1301
  filename = __cil_tmp3;
#line 1304
  i = strlen((char const   *)filename);
  }
  {
#line 1304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1304
    if (! (i != 0UL)) {
#line 1304
      goto while_break;
    }
#line 1305
    if ((int )*(filename + i) == 47) {
#line 1305
      if (! ((int )*(filename + (i - 1UL)) == 47 || ((int )*(filename + (i - 1UL)) == 46 && ((i == 1UL || (int )*(filename + (i - 2UL)) == 47) || ((int )*(filename + (i - 2UL)) == 46 && (i == 2UL || (int )*(filename + (i - 3UL)) == 47)))))) {
        {
#line 1314
        *(filename + i) = (char )'\000';
#line 1315
        __cil_tmp6 = rmdir((char const   *)filename);
        }
#line 1315
        if (__cil_tmp6 == 0) {
#line 1315
          if ((unsigned int )verbosity == 2U) {
            {
#line 1316
            __cil_tmp7 = quotearg((char const   *)filename);
#line 1316
            say((char const   *)((char *)"Removed empty directory %s\n"), __cil_tmp7);
            }
          }
        }
#line 1317
        *(filename + i) = (char )'/';
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1304
  __cil_tmp8 = i;
#line 1304
  i --;
#line 1319
  free((void *)filename);
  }
}
}
#line 1322
static struct timespec initial_time ;
#line 1325 "/tmp/0/patch-2.7.1/src/util.c"
void init_time(void) 
{ 


  {
  {
#line 1327
  gettime(& initial_time);
  }
}
}
#line 1331 "/tmp/0/patch-2.7.1/src/util.c"
static char *parse_c_string(char const   *s , char const   **endp ) 
{ 
  char *u ;
  char *v ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;
  char c ;
  char const   *__cil_tmp10 ;
  char *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  int acc ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1336
  s ++;
#line 1337
  __cil_tmp7 = strlen(s);
#line 1337
  __cil_tmp8 = xmalloc(__cil_tmp7);
#line 1337
  v = (char *)__cil_tmp8;
#line 1337
  u = v;
  }
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! 1) {
#line 1338
      goto while_break;
    }
#line 1340
    __cil_tmp10 = s;
#line 1340
    s ++;
#line 1340
    c = (char )*__cil_tmp10;
    {
#line 1344
    if ((int )c == 0) {
#line 1344
      goto case_0;
    }
#line 1347
    if ((int )c == '\"') {
#line 1347
      goto case_34;
    }
#line 1356
    if ((int )c == '\\') {
#line 1356
      goto case_92;
    }
#line 1359
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1345
    goto fail;
    case_34: /* CIL Label */ 
#line 1348
    __cil_tmp11 = v;
#line 1348
    v ++;
#line 1348
    *__cil_tmp11 = (char )0;
    {
#line 1349
    __cil_tmp12 = realloc((void *)u, (unsigned long )(v - u));
#line 1349
    v = (char *)__cil_tmp12;
    }
#line 1350
    if (v) {
#line 1351
      u = v;
    }
#line 1352
    if (endp) {
#line 1353
      *endp = s;
    }
#line 1354
    return (u);
    case_92: /* CIL Label */ 
#line 1357
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1360
    __cil_tmp13 = v;
#line 1360
    v ++;
#line 1360
    *__cil_tmp13 = c;
#line 1361
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 1364
    __cil_tmp14 = s;
#line 1364
    s ++;
#line 1364
    c = (char )*__cil_tmp14;
    {
#line 1367
    if ((int )c == 'a') {
#line 1367
      goto case_97;
    }
#line 1368
    if ((int )c == 'b') {
#line 1368
      goto case_98;
    }
#line 1369
    if ((int )c == 'f') {
#line 1369
      goto case_102;
    }
#line 1370
    if ((int )c == 'n') {
#line 1370
      goto case_110;
    }
#line 1371
    if ((int )c == 'r') {
#line 1371
      goto case_114;
    }
#line 1372
    if ((int )c == 't') {
#line 1372
      goto case_116;
    }
#line 1373
    if ((int )c == 'v') {
#line 1373
      goto case_118;
    }
#line 1374
    if ((int )c == '\"') {
#line 1374
      goto case_34___0;
    }
#line 1374
    if ((int )c == '\\') {
#line 1374
      goto case_34___0;
    }
#line 1376
    if ((int )c == '3') {
#line 1376
      goto case_51;
    }
#line 1376
    if ((int )c == '2') {
#line 1376
      goto case_51;
    }
#line 1376
    if ((int )c == '1') {
#line 1376
      goto case_51;
    }
#line 1376
    if ((int )c == '0') {
#line 1376
      goto case_51;
    }
#line 1391
    goto switch_default___0;
    case_97: /* CIL Label */ 
#line 1367
    c = (char )'\a';
#line 1367
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 1368
    c = (char )'\b';
#line 1368
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 1369
    c = (char )'\f';
#line 1369
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 1370
    c = (char )'\n';
#line 1370
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 1371
    c = (char )'\r';
#line 1371
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 1372
    c = (char )'\t';
#line 1372
    goto switch_break___0;
    case_118: /* CIL Label */ 
#line 1373
    c = (char )'\v';
#line 1373
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
    case_92___0: /* CIL Label */ 
#line 1375
    goto switch_break___0;
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1378
    acc = ((int )c - 48) << 6;
#line 1380
    __cil_tmp16 = s;
#line 1380
    s ++;
#line 1380
    c = (char )*__cil_tmp16;
#line 1381
    if ((int )c < 48) {
#line 1382
      goto fail;
    } else
#line 1381
    if ((int )c > 55) {
#line 1382
      goto fail;
    }
#line 1383
    acc |= ((int )c - 48) << 3;
#line 1384
    __cil_tmp17 = s;
#line 1384
    s ++;
#line 1384
    c = (char )*__cil_tmp17;
#line 1385
    if ((int )c < 48) {
#line 1386
      goto fail;
    } else
#line 1385
    if ((int )c > 55) {
#line 1386
      goto fail;
    }
#line 1387
    acc |= (int )c - 48;
#line 1388
    c = (char )acc;
#line 1389
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1392
    goto fail;
    switch_break___0: /* CIL Label */ ;
    }
#line 1394
    __cil_tmp18 = v;
#line 1394
    v ++;
#line 1394
    *__cil_tmp18 = c;
  }
  while_break: /* CIL Label */ ;
  }
  fail: 
  {
#line 1398
  free((void *)u);
  }
#line 1399
  if (endp) {
#line 1400
    *endp = s;
  }
#line 1401
  return ((char *)((void *)0));
}
}
#line 1409 "/tmp/0/patch-2.7.1/src/util.c"
static int strip_leading_slashes(char *name , int strip_leading ) 
{ 
  int s ;
  char *p ;
  char *n ;
  size_t __cil_tmp8 ;

  {
#line 1411
  s = strip_leading;
#line 1414
  n = name;
#line 1414
  p = n;
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1414
    if (! *p) {
#line 1414
      goto while_break;
    }
#line 1416
    if ((int )*p == 47) {
      {
#line 1418
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1418
        if (! ((int )*(p + 1) == 47)) {
#line 1418
          goto while_break___0;
        }
#line 1419
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1420
      s --;
#line 1420
      if (strip_leading < 0) {
#line 1421
        n = p + 1;
      } else
#line 1420
      if (s >= 0) {
#line 1421
        n = p + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  p ++;
#line 1424
  if (strip_leading < 0) {
    _L: /* CIL Label */ 
#line 1424
    if ((int )*n) {
      {
#line 1426
      __cil_tmp8 = strlen((char const   *)n);
#line 1426
      memmove((void *)name, (void const   *)n, __cil_tmp8 + 1UL);
      }
#line 1427
      return (1);
    } else {
#line 1430
      return (0);
    }
  } else
#line 1424
  if (s <= 0) {
#line 1424
    goto _L;
  } else {
#line 1430
    return (0);
  }
}
}
#line 1437 "/tmp/0/patch-2.7.1/src/util.c"
void fetchname(char const   *at , int strip_leading , char **pname , char **ptimestr ,
               struct timespec *pstamp ) 
{ 
  char *name ;
  char const   *t ;
  char *timestr ;
  struct timespec stamp ;
  unsigned short const   **__cil_tmp10 ;
  char *__cil_tmp13 ;
  unsigned short const   **__cil_tmp14 ;
  char const   *u ;
  unsigned short const   **__cil_tmp16 ;
  int tmp ;
  char *__cil_tmp19 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char const   *u___0 ;
  size_t __cil_tmp25 ;
  char const   *__cil_tmp26 ;
  char const   *__cil_tmp27 ;
  struct timespec lower ;
  struct timespec upper ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 1442
  timestr = (char *)((void *)0);
#line 1445
  stamp.tv_sec = (__time_t )(- 1);
#line 1446
  stamp.tv_nsec = (__syscall_slong_t )0;
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1448
    if (! ((int )((unsigned short )*(*__cil_tmp10 + (int )((unsigned char )((char )*at)))) & 8192)) {
#line 1448
      goto while_break;
    }
#line 1449
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1450
  if (debug & 128) {
    {
#line 1451
    say((char const   *)((char *)"fetchname %s %d\n"), at, strip_leading);
    }
  }
#line 1453
  if ((int )((char )*at) == 34) {
    {
#line 1455
    name = parse_c_string(at, & t);
    }
#line 1456
    if (! name) {
#line 1458
      if (debug & 128) {
        {
#line 1459
        __cil_tmp13 = quotearg(at);
#line 1459
        say((char const   *)((char *)"ignoring malformed filename %s\n"), __cil_tmp13);
        }
      }
#line 1460
      return;
    }
  } else {
#line 1465
    t = at;
    {
#line 1465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1465
      if (! ((char )*t)) {
#line 1465
        goto while_break___0;
      }
      {
#line 1467
      __cil_tmp14 = __ctype_b_loc();
      }
#line 1467
      if ((int )((unsigned short )*(*__cil_tmp14 + (int )((unsigned char )((char )*t)))) & 8192) {
#line 1471
        u = t;
        {
#line 1472
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1472
          if (! ((int )((char )*u) != 9 && (int )((unsigned short )*(*__cil_tmp16 + (int )((unsigned char )((char )*(u + 1))))) & 8192)) {
#line 1472
            goto while_break___1;
          }
#line 1473
          u ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1474
        if (pstamp) {
#line 1474
          tmp = '\t';
        } else {
#line 1474
          tmp = '\n';
        }
        {
#line 1474
        __cil_tmp19 = strchr(u + 1, tmp);
        }
#line 1474
        if ((int )((char )*u) != 9) {
#line 1474
          if (__cil_tmp19) {
#line 1475
            goto while_continue___0;
          }
        }
#line 1476
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1465
    t ++;
#line 1479
    name = savebuf(at, (size_t )((t - at) + 1L));
#line 1480
    *(name + (t - at)) = (char )0;
    }
  }
  {
#line 1486
  __cil_tmp22 = strcmp((char const   *)name, (char const   *)((char *)"/dev/null"));
  }
#line 1486
  if (__cil_tmp22 == 0) {
    {
#line 1488
    free((void *)name);
    }
#line 1489
    if (pstamp) {
#line 1491
      pstamp->tv_sec = (__time_t )0;
#line 1492
      pstamp->tv_nsec = (__syscall_slong_t )0;
    }
#line 1494
    return;
  }
  {
#line 1498
  __cil_tmp23 = strip_leading_slashes(name, strip_leading);
  }
#line 1498
  if (! __cil_tmp23) {
    {
#line 1500
    free((void *)name);
    }
#line 1501
    return;
  }
#line 1504
  if (ptimestr) {
    {
#line 1506
    __cil_tmp25 = strlen(t);
#line 1506
    u___0 = t + __cil_tmp25;
    }
#line 1508
    if (u___0 != t) {
#line 1508
      if ((int )((char )*(u___0 - 1)) == 10) {
#line 1509
        __cil_tmp26 = u___0;
#line 1509
        u___0 --;
      }
    }
#line 1510
    if (u___0 != t) {
#line 1510
      if ((int )((char )*(u___0 - 1)) == 13) {
#line 1511
        __cil_tmp27 = u___0;
#line 1511
        u___0 --;
      }
    }
    {
#line 1512
    timestr = savebuf(t, (size_t )((u___0 - t) + 1L));
#line 1513
    *(timestr + (u___0 - t)) = (char )0;
    }
  }
#line 1516
  if ((int )((char )*t) != 10) {
#line 1518
    if (! pstamp) {
      {
#line 1520
      free((void *)name);
#line 1521
      free((void *)timestr);
      }
#line 1522
      return;
    }
#line 1525
    if (set_time | set_utc) {
      {
#line 1526
      parse_datetime(& stamp, t, & initial_time);
      }
    } else {
#line 1534
      lower.tv_sec = -90000L;
#line 1534
      lower.tv_nsec = 0L;
#line 1534
      upper.tv_sec = 93600L;
      {
#line 1534
      upper.tv_nsec = 0L;
#line 1536
      __cil_tmp33 = timespec_cmp(stamp, upper);
      }
      {
#line 1536
      __cil_tmp32 = timespec_cmp(stamp, lower);
      }
      {
#line 1536
      __cil_tmp31 = parse_datetime(& stamp, t, & initial_time);
      }
#line 1536
      if (__cil_tmp31) {
#line 1536
        if (__cil_tmp32 > 0) {
#line 1536
          if (__cil_tmp33 < 0) {
#line 1539
            stamp.tv_sec = (__time_t )0;
#line 1540
            stamp.tv_nsec = (__syscall_slong_t )0;
          }
        }
      }
    }
  }
  {
#line 1545
  free((void *)*pname);
#line 1546
  *pname = name;
  }
#line 1547
  if (ptimestr) {
    {
#line 1549
    free((void *)*ptimestr);
#line 1550
    *ptimestr = timestr;
    }
  }
#line 1552
  if (pstamp) {
#line 1553
    *pstamp = stamp;
  }
}
}
#line 1557 "/tmp/0/patch-2.7.1/src/util.c"
char *parse_name(char const   *s , int strip_leading , char const   **endp ) 
{ 
  char *ret ;
  unsigned short const   **__cil_tmp5 ;
  char const   *t ;
  unsigned short const   **__cil_tmp9 ;
  int __cil_tmp12 ;

  {
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (! ((int )((unsigned short )*(*__cil_tmp5 + (int )((unsigned char )((char )*s)))) & 8192)) {
#line 1561
      goto while_break;
    }
#line 1562
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  if ((int )((char )*s) == 34) {
    {
#line 1564
    ret = parse_c_string(s, endp);
    }
  } else {
#line 1569
    t = s;
    {
#line 1569
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1569
      if (! ((int )((char )*t) && ! ((int )((unsigned short )*(*__cil_tmp9 + (int )((unsigned char )((char )*t)))) & 8192))) {
#line 1569
        goto while_break___0;
      }

    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1569
    t ++;
#line 1571
    ret = savebuf(s, (size_t )((t - s) + 1L));
#line 1572
    *(ret + (t - s)) = (char )0;
    }
#line 1573
    if (endp) {
#line 1574
      *endp = t;
    }
  }
  {
#line 1576
  __cil_tmp12 = strip_leading_slashes(ret, strip_leading);
  }
#line 1576
  if (! __cil_tmp12) {
    {
#line 1578
    free((void *)ret);
#line 1579
    ret = (char *)((void *)0);
    }
  }
#line 1581
  return (ret);
}
}
#line 1585 "/tmp/0/patch-2.7.1/src/util.c"
void Fseek(FILE *stream , file_offset offset , int ptrname ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 1587
  __cil_tmp4 = fseek(stream, offset, ptrname);
  }
#line 1587
  if (__cil_tmp4 != 0) {
    {
#line 1588
    pfatal((char const   *)((char *)"fseek"));
    }
  }
}
}
#line 1596 "/tmp/0/patch-2.7.1/src/util.c"
int make_tempfile(char const   **name , char letter , char const   *real_name , int flags ,
                  mode_t mode ) 
{ 
  int try_makedirs_errno ;
  char *template ;
  char *dirname ;
  char *basename___132 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  void *__cil_tmp14 ;
  char const   *tmpdir ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  size_t __cil_tmp19 ;
  void *__cil_tmp20 ;
  int fd ;
  int __cil_tmp22 ;
  int *__cil_tmp24 ;
  int *__cil_tmp25 ;

  {
#line 1599
  try_makedirs_errno = 2;
#line 1602
  if (real_name) {
    {
#line 1606
    dirname = dir_name(real_name);
#line 1607
    basename___132 = base_name(real_name);
#line 1609
    __cil_tmp13 = strlen((char const   *)basename___132);
    }
    {
#line 1609
    __cil_tmp12 = strlen((char const   *)dirname);
#line 1609
    __cil_tmp14 = xmalloc(((__cil_tmp12 + 1UL) + __cil_tmp13) + 9UL);
#line 1609
    template = (char *)__cil_tmp14;
#line 1610
    sprintf(template, (char const   *)((char *)"%s/%s.%cXXXXXX"), dirname, basename___132,
            (int )letter);
#line 1611
    free((void *)dirname);
#line 1612
    free((void *)basename___132);
    }
  } else {
    {
#line 1618
    __cil_tmp16 = getenv((char const   *)((char *)"TMPDIR"));
#line 1618
    tmpdir = (char const   *)__cil_tmp16;
    }
#line 1619
    if (! tmpdir) {
      {
#line 1620
      __cil_tmp17 = getenv((char const   *)((char *)"TMP"));
#line 1620
      tmpdir = (char const   *)__cil_tmp17;
      }
    }
#line 1621
    if (! tmpdir) {
      {
#line 1622
      __cil_tmp18 = getenv((char const   *)((char *)"TEMP"));
#line 1622
      tmpdir = (char const   *)__cil_tmp18;
      }
    }
#line 1623
    if (! tmpdir) {
#line 1624
      tmpdir = (char const   *)((char *)"/tmp");
    }
    {
#line 1626
    __cil_tmp19 = strlen(tmpdir);
#line 1626
    __cil_tmp20 = xmalloc(__cil_tmp19 + 10UL);
#line 1626
    template = (char *)__cil_tmp20;
#line 1627
    sprintf(template, (char const   *)((char *)"%s/p%cXXXXXX"), tmpdir, (int )letter);
    }
  }
  {
#line 1629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1629
    if (! 1) {
#line 1629
      goto while_break;
    }
    {
#line 1633
    __cil_tmp22 = gen_tempname(template, 0, flags, 2);
    }
#line 1633
    if (__cil_tmp22) {
      {
#line 1634
      pfatal((char const   *)((char *)"Can\'t create temporary file %s"), template);
      }
    }
    retry: 
    {
#line 1636
    fd = open((char const   *)template, 192 | flags, mode);
    }
#line 1637
    if (fd == -1) {
      {
#line 1639
      __cil_tmp24 = __errno_location();
      }
#line 1639
      if (*__cil_tmp24 == try_makedirs_errno) {
        {
#line 1641
        makedirs((char const   *)template);
#line 1644
        try_makedirs_errno = 0;
        }
#line 1645
        goto retry;
      }
      {
#line 1647
      __cil_tmp25 = __errno_location();
      }
#line 1647
      if (*__cil_tmp25 == 17) {
#line 1648
        goto while_continue;
      }
      {
#line 1649
      pfatal((char const   *)((char *)"Can\'t create temporary file %s"), template);
      }
    }
#line 1651
    *name = (char const   *)template;
#line 1652
    return (fd);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1656 "/tmp/0/patch-2.7.1/src/util.c"
int stat_file(char const   *filename , struct stat *st ) 
{ 
  int (*xstat)(char const   * , struct stat * ) ;
  int tmp(char const   *__path , struct stat *__statbuf ) ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;
  int tmp___133 ;

  {
#line 1658
  if (follow_symlinks) {
#line 1658
    tmp = stat;
  } else {
#line 1658
    tmp = lstat;
  }
  {
#line 1658
  xstat = tmp;
#line 1661
  __cil_tmp5 = xstat(filename, st);
  }
#line 1661
  if (__cil_tmp5 == 0) {
#line 1661
    tmp___133 = 0;
  } else {
    {
#line 1661
    __cil_tmp6 = __errno_location();
#line 1661
    tmp___133 = *__cil_tmp6;
    }
  }
#line 1661
  return (tmp___133);
}
}
#line 232 "/usr/include/stdio.h"
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 652
extern size_t fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 78 "./common.h"
char *inname ;
#line 79
char *outfile ;
#line 80
int inerrno ;
#line 81
int invc ;
#line 82
struct stat instat ;
#line 92
char const   *TMPPATNAME ;
#line 96
int TMPPATNAME_needs_removal ;
#line 109
int strippath ;
#line 110
int canonicalize ;
#line 127
enum diff diff_type ;
#line 129
char *revision ;
#line 181
int no_strip_trailing_cr ;
#line 84 "./util.h"
__inline static char const   *skip_spaces(char const   *str ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((int )((unsigned short )*(*__cil_tmp2 + (int )((unsigned char )((char )*str)))) & 8192)) {
#line 86
      goto while_break;
    }
#line 87
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (str);
}
}
#line 24 "./pch.h"
lin pch_hunk_beg(void) ;
#line 25
char const   *pch_c_function(void) ;
#line 26
int pch_git_diff(void) ;
#line 27
char const   *pch_timestr(int which ) ;
#line 28
char const   *pch_sha1(int which ) ;
#line 29
mode_t pch_mode(int which ) ;
#line 30
lin pch_newfirst(void) ;
#line 33
lin pch_repl_lines(void) ;
#line 35
int pch_swap(void) ;
#line 37
int there_is_another_patch(int need_header , mode_t *file_type ) ;
#line 40
int another_hunk(enum diff difftype , int rev ) ;
#line 41
int pch_says_nonexistent(int which ) ;
#line 43
char const   *pch_name(enum nametype type ) ;
#line 44
int pch_copy(void) ;
#line 45
int pch_rename(void) ;
#line 46
void do_ed_script(char const   *inname___0 , char const   *outname , int *outname_needs_removal ,
                  FILE *ofp ) ;
#line 47
void open_patch_file(char const   *filename ) ;
#line 48
void re_patch(void) ;
#line 49
void set_hunkmax(void) ;
#line 52
struct timespec p_timestamp[2] ;
#line 39 "/tmp/0/patch-2.7.1/src/pch.c"
static FILE *pfp ;
#line 40
static int p_says_nonexistent[2] ;
#line 44
static int p_rfc934_nesting ;
#line 45
static char *p_name[3] ;
#line 46
static char const   *invalid_names[2] ;
#line 47
int p_copy[2] ;
#line 48
int p_rename[2] ;
#line 49
static char *p_timestr[2] ;
#line 50
static char *p_sha1[2] ;
#line 51
static mode_t p_mode[2] ;
#line 52
static off_t p_filesize ;
#line 53
static lin p_first ;
#line 54
static lin p_newfirst ;
#line 55
static lin p_ptrn_lines ;
#line 56
static lin p_repl_lines ;
#line 57 "/tmp/0/patch-2.7.1/src/pch.c"
static lin p_end  =    (lin )(- 1);
#line 58
static lin p_max ;
#line 59
static lin p_prefix_context ;
#line 60
static lin p_suffix_context ;
#line 61
static lin p_input_line ;
#line 62
static char **p_line ;
#line 63
static size_t *p_len ;
#line 64
static char *p_Char ;
#line 65 "/tmp/0/patch-2.7.1/src/pch.c"
static lin hunkmax  =    (lin )125;
#line 66
static size_t p_indent ;
#line 67
static int p_strip_trailing_cr ;
#line 68
static int p_pass_comments_through ;
#line 69
static file_offset p_base ;
#line 70
static lin p_bline ;
#line 71
static file_offset p_start ;
#line 72
static lin p_sline ;
#line 73
static lin p_hunk_beg ;
#line 74 "/tmp/0/patch-2.7.1/src/pch.c"
static lin p_efake  =    (lin )(- 1);
#line 75 "/tmp/0/patch-2.7.1/src/pch.c"
static lin p_bfake  =    (lin )(- 1);
#line 76
static char *p_c_function ;
#line 77
static int p_git_diff ;
#line 79
static char *scan_linenum(char *s0 , lin *linenum ) ;
#line 80
static enum diff intuit_diff_type(int need_header , mode_t *p_file_type ) ;
#line 81
static enum nametype best_name(char * const  *name , int const   *ignore ) ;
#line 82
static int prefix_components(char *filename , int checkdirs ) ;
#line 83
static size_t pget_line(size_t indent , int rfc934_nesting , int strip_trailing_cr ,
                        int pass_comments_through ) ;
#line 84
static size_t get_line(void) ;
#line 85
static int incomplete_line(void) ;
#line 86
static int grow_hunkmax(void) ;
#line 87
static void malformed(void) ;
#line 88
static void next_intuit_at(file_offset file_pos , lin file_line ) ;
#line 89
static void skip_to(file_offset file_pos , lin file_line ) ;
#line 90
static char get_ed_command_letter(char const   *line ) ;
#line 95 "/tmp/0/patch-2.7.1/src/pch.c"
void re_patch(void) 
{ 


  {
#line 97
  p_first = (lin )0;
#line 98
  p_newfirst = (lin )0;
#line 99
  p_ptrn_lines = (lin )0;
#line 100
  p_repl_lines = (lin )0;
#line 101
  p_end = (lin )(- 1);
#line 102
  p_max = (lin )0;
#line 103
  p_indent = (size_t )0;
#line 104
  p_strip_trailing_cr = 0;
}
}
#line 110 "/tmp/0/patch-2.7.1/src/pch.c"
void open_patch_file(char const   *filename ) 
{ 
  file_offset file_pos ;
  file_offset pos ;
  struct stat st ;
  int __cil_tmp5 ;
  char *tmp ;
  FILE *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t charsread ;
  int fd ;
  int __cil_tmp14 ;
  FILE *read_pfp ;
  char *__cil_tmp17 ;
  size_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 112
  file_pos = (file_offset )0;
#line 116
  __cil_tmp5 = strcmp(filename, (char const   *)((char *)"-"));
  }
#line 116
  if (! filename) {
#line 117
    pfp = stdin;
  } else
#line 116
  if (! ((char )*filename)) {
#line 117
    pfp = stdin;
  } else
#line 116
  if (! __cil_tmp5) {
#line 117
    pfp = stdin;
  } else {
    {
#line 120
    tmp = (char *)"r";
#line 120
    __cil_tmp7 = fopen(filename, (char const   *)tmp);
#line 120
    pfp = __cil_tmp7;
    }
#line 121
    if (! pfp) {
      {
#line 122
      __cil_tmp8 = quotearg(filename);
#line 122
      pfatal((char const   *)((char *)"Can\'t open patch file %s"), __cil_tmp8);
      }
    }
  }
  {
#line 132
  __cil_tmp9 = fileno(pfp);
#line 132
  __cil_tmp10 = fstat(__cil_tmp9, & st);
  }
#line 132
  if (__cil_tmp10 != 0) {
    {
#line 133
    pfatal((char const   *)((char *)"fstat"));
    }
  }
  {
#line 134
  pos = ftell(pfp);
  }
#line 134
  if ((st.st_mode & 61440U) == 32768U) {
#line 134
    if (pos != -1L) {
#line 135
      file_pos = pos;
    } else {
#line 134
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 139
    __cil_tmp14 = make_tempfile(& TMPPATNAME, (char )'p', (char const   *)((void *)0),
                                2, (mode_t )0);
#line 139
    fd = __cil_tmp14;
#line 140
    read_pfp = pfp;
#line 141
    TMPPATNAME_needs_removal = 1;
#line 142
    pfp = fdopen(fd, (char const   *)((char *)"w+b"));
    }
#line 143
    if (! pfp) {
      {
#line 144
      __cil_tmp17 = quotearg(TMPPATNAME);
#line 144
      pfatal((char const   *)((char *)"Can\'t open stream for file %s"), __cil_tmp17);
      }
    }
#line 145
    st.st_size = (__off_t )0;
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
#line 145
      if (! (charsread != 0UL)) {
#line 145
        goto while_break;
      }
      {
#line 148
      __cil_tmp19 = fwrite((void const   *)buf, (size_t )1, charsread, pfp);
      }
#line 148
      if (__cil_tmp19 != charsread) {
        {
#line 149
        write_fatal();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 147
    st.st_size += charsread;
#line 150
    __cil_tmp21 = fclose(read_pfp);
    }
    {
#line 150
    __cil_tmp20 = ferror(read_pfp);
    }
#line 150
    if (__cil_tmp20) {
      {
      {
#line 151
      read_fatal();
      }
      }
    } else
#line 150
    if (__cil_tmp21 != 0) {
      {
      {
#line 151
      read_fatal();
      }
      }
    }
    {
#line 152
    __cil_tmp23 = fseek(pfp, (file_offset )0, 0);
    }
    {
#line 152
    __cil_tmp22 = fflush(pfp);
    }
#line 152
    if (__cil_tmp22 != 0) {
      {
      {
#line 154
      write_fatal();
      }
      }
    } else
#line 152
    if (__cil_tmp23 != 0) {
      {
      {
#line 154
      write_fatal();
      }
      }
    }
  }
#line 156
  p_filesize = st.st_size;
#line 157
  if (p_filesize != p_filesize) {
    {
#line 158
    fatal((char const   *)((char *)"patch file is too long"));
    }
  }
  {
#line 159
  next_intuit_at(file_pos, (lin )1);
#line 160
  set_hunkmax();
  }
}
}
#line 166 "/tmp/0/patch-2.7.1/src/pch.c"
void set_hunkmax(void) 
{ 
  void *__cil_tmp1 ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 168
  if (! p_line) {
    {
#line 169
    __cil_tmp1 = malloc((unsigned long )hunkmax * sizeof(*p_line));
#line 169
    p_line = (char **)__cil_tmp1;
    }
  }
#line 170
  if (! p_len) {
    {
#line 171
    __cil_tmp2 = malloc((unsigned long )hunkmax * sizeof(*p_len));
#line 171
    p_len = (size_t *)__cil_tmp2;
    }
  }
#line 172
  if (! p_Char) {
    {
#line 173
    __cil_tmp3 = malloc((unsigned long )hunkmax * sizeof(*p_Char));
#line 173
    p_Char = (char *)__cil_tmp3;
    }
  }
}
}
#line 179 "/tmp/0/patch-2.7.1/src/pch.c"
static int grow_hunkmax(void) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 181
  hunkmax *= (long )2;
#line 183
  __cil_tmp4 = realloc((void *)p_Char, (unsigned long )hunkmax * sizeof(*p_Char));
#line 183
  p_Char = (char *)__cil_tmp4;
  }
  {
#line 183
  __cil_tmp3 = realloc((void *)p_len, (unsigned long )hunkmax * sizeof(*p_len));
#line 183
  p_len = (size_t *)__cil_tmp3;
  }
  {
#line 183
  __cil_tmp2 = realloc((void *)p_line, (unsigned long )hunkmax * sizeof(*p_line));
#line 183
  p_line = (char **)__cil_tmp2;
  }
#line 183
  if (p_line) {
#line 183
    if (p_len) {
#line 183
      if (p_Char) {
#line 186
        return (1);
      }
    }
  }
#line 187
  if (! using_plan_a) {
    {
#line 188
    xalloc_die();
    }
  }
#line 193
  return (0);
}
}
#line 197 "/tmp/0/patch-2.7.1/src/pch.c"
static int maybe_reverse(char const   *name , int nonexistent , int is_empty ) 
{ 
  int looks_reversed ;
  char *tmp ;
  char *tmp___135 ;
  char *tmp___136 ;
  char *__cil_tmp8 ;
  char *tmp___137 ;
  char *tmp___138 ;
  int __cil_tmp11 ;

  {
#line 199
  looks_reversed = ! is_empty < p_says_nonexistent[reverse ^ is_empty];
#line 203
  if (is_empty) {
#line 203
    if (p_says_nonexistent[reverse ^ nonexistent] == 1) {
#line 203
      if (p_says_nonexistent[! reverse ^ nonexistent] == 2) {
#line 206
        return (0);
      }
    }
  }
#line 208
  if (looks_reversed) {
#line 209
    if (reverse) {
#line 209
      tmp = (char *)", when reversed,";
    } else {
#line 209
      tmp = (char *)"";
    }
#line 209
    if (nonexistent) {
#line 209
      tmp___136 = (char *)"delete";
    } else {
#line 209
      if (is_empty) {
#line 209
        tmp___135 = (char *)"empty out";
      } else {
#line 209
        tmp___135 = (char *)"create";
      }
#line 209
      tmp___136 = tmp___135;
    }
    {
#line 209
    __cil_tmp8 = quotearg(name);
    }
#line 209
    if (nonexistent) {
#line 209
      tmp___138 = (char *)"does not exist";
    } else {
#line 209
      if (is_empty) {
#line 209
        tmp___137 = (char *)"is already empty";
      } else {
#line 209
        tmp___137 = (char *)"already exists";
      }
#line 209
      tmp___138 = tmp___137;
    }
    {
#line 209
    __cil_tmp11 = ok_to_reverse((char const   *)((char *)"The next patch%s would %s the file %s,\nwhich %s!"),
                                tmp, tmp___136, __cil_tmp8, tmp___138);
    }
#line 209
    reverse ^= __cil_tmp11;
  }
#line 219
  return (looks_reversed);
}
}
#line 225 "/tmp/0/patch-2.7.1/src/pch.c"
int there_is_another_patch(int need_header , mode_t *file_type ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  char *tmp___142 ;
  char *tmp___143 ;
  char *tmp___144 ;
  char numbuf[23] ;
  char *__cil_tmp13 ;
  char *tmp___145 ;
  char *t ;
  size_t __cil_tmp16 ;

  {
#line 227
  if (p_base != 0L) {
#line 227
    if (p_base >= p_filesize) {
#line 228
      if ((unsigned int )verbosity == 2U) {
        {
#line 229
        say((char const   *)((char *)"done\n"));
        }
      }
#line 230
      return (0);
    }
  }
#line 232
  if ((unsigned int )verbosity == 2U) {
    {
#line 233
    say((char const   *)((char *)"Hmm..."));
    }
  }
  {
#line 234
  diff_type = intuit_diff_type(need_header, file_type);
  }
#line 235
  if ((unsigned int )diff_type == 0U) {
#line 236
    if ((unsigned int )verbosity == 2U) {
#line 237
      if (p_base) {
#line 237
        tmp = (char *)"  Ignoring the trailing garbage.\ndone\n";
      } else {
#line 237
        tmp = (char *)"  I can\'t seem to find a patch in there anywhere.\n";
      }
      {
#line 237
      say((char const   *)tmp);
      }
    }
#line 240
    if (! p_base) {
#line 240
      if (p_filesize) {
        {
#line 241
        fatal((char const   *)((char *)"Only garbage was found in the patch input."));
        }
      }
    }
#line 242
    return (0);
  }
#line 244
  if (skip_rest_of_patch) {
    {
#line 246
    Fseek(pfp, p_start, 0);
#line 247
    p_input_line = p_sline - 1L;
    }
#line 248
    return (1);
  }
#line 250
  if ((unsigned int )verbosity == 2U) {
#line 251
    if (p_base == 0L) {
#line 251
      tmp___0 = (char *)"L";
    } else {
#line 251
      tmp___0 = (char *)"The next patch l";
    }
#line 251
    if ((unsigned int )diff_type == 5U) {
#line 251
      tmp___143 = (char *)"a unified diff";
    } else {
#line 251
      if ((unsigned int )diff_type == 1U) {
#line 251
        tmp___142 = (char *)"a context diff";
      } else {
#line 251
        if ((unsigned int )diff_type == 4U) {
#line 251
          tmp___141 = (char *)"a new-style context diff";
        } else {
#line 251
          if ((unsigned int )diff_type == 2U) {
#line 251
            tmp___140 = (char *)"a normal diff";
          } else {
#line 251
            if ((unsigned int )diff_type == 6U) {
#line 251
              tmp___139 = (char *)"a git binary diff";
            } else {
#line 251
              tmp___139 = (char *)"an ed script";
            }
#line 251
            tmp___140 = tmp___139;
          }
#line 251
          tmp___141 = tmp___140;
        }
#line 251
        tmp___142 = tmp___141;
      }
#line 251
      tmp___143 = tmp___142;
    }
    {
#line 251
    say((char const   *)((char *)"  %sooks like %s to me...\n"), tmp___0, tmp___143);
    }
  }
#line 260
  if (no_strip_trailing_cr) {
#line 261
    p_strip_trailing_cr = 0;
  }
#line 263
  if ((unsigned int )verbosity != 1U) {
#line 265
    if (p_indent) {
#line 266
      if (p_indent == 1UL) {
#line 266
        tmp___144 = (char *)"";
      } else {
#line 266
        tmp___144 = (char *)"s";
      }
      {
#line 266
      say((char const   *)((char *)"(Patch is indented %lu space%s.)\n"), p_indent,
          tmp___144);
      }
    }
#line 268
    if (p_strip_trailing_cr) {
      {
#line 269
      say((char const   *)((char *)"(Stripping trailing CRs from patch; use --binary to disable.)\n"));
      }
    }
#line 270
    if (! inname) {
      {
#line 273
      __cil_tmp13 = format_linenum((char *)numbuf, p_sline);
#line 273
      say((char const   *)((char *)"can\'t find file to patch at input line %s\n"),
          __cil_tmp13);
      }
#line 275
      if ((unsigned int )diff_type != 3U) {
#line 275
        if ((unsigned int )diff_type != 2U) {
#line 276
          if (strippath == -1) {
#line 276
            tmp___145 = (char *)"Perhaps you should have used the -p or --strip option?\n";
          } else {
#line 276
            tmp___145 = (char *)"Perhaps you used the wrong -p or --strip option?\n";
          }
          {
#line 276
          say((char const   *)tmp___145);
          }
        }
      }
    }
  }
  {
#line 282
  skip_to(p_start, p_sline);
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (! inname)) {
#line 283
      goto while_break;
    }
#line 285
    if (force | batch) {
      {
#line 286
      say((char const   *)((char *)"No file to patch.  Skipping patch.\n"));
#line 287
      skip_rest_of_patch = 1;
      }
#line 288
      return (1);
    }
    {
#line 290
    ask((char const   *)((char *)"File to patch: "));
#line 291
    __cil_tmp16 = strlen((char const   *)buf);
#line 291
    t = buf + __cil_tmp16;
    }
#line 292
    if (t > buf + 1) {
#line 292
      if ((int )*(t - 1) == 10) {
        {
#line 294
        inname = savebuf((char const   *)buf, (size_t )(t - buf));
#line 295
        *(inname + ((t - buf) - 1L)) = (char )0;
#line 296
        inerrno = stat_file((char const   *)inname, & instat);
        }
#line 297
        if (inerrno) {
          {
#line 299
          perror((char const   *)inname);
#line 300
          fflush(stderr);
#line 301
          free((void *)inname);
#line 302
          inname = (char *)0;
          }
        } else {
#line 305
          invc = - 1;
        }
      }
    }
#line 307
    if (! inname) {
      {
#line 308
      ask((char const   *)((char *)"Skip this patch? [y] "));
      }
#line 309
      if ((int )*buf != 110) {
#line 310
        if ((unsigned int )verbosity != 1U) {
          {
#line 311
          say((char const   *)((char *)"Skipping patch.\n"));
          }
        }
#line 312
        skip_rest_of_patch = 1;
#line 313
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (1);
}
}
#line 321 "/tmp/0/patch-2.7.1/src/pch.c"
static mode_t fetchmode(char const   *str ) 
{ 
  char const   *s ;
  mode_t mode ;
  unsigned short const   **__cil_tmp4 ;

  {
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! ((int )((unsigned short )*(*__cil_tmp4 + (int )((unsigned char )((char )*str)))) & 8192)) {
#line 326
      goto while_break;
    }
#line 327
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  mode = (mode_t )0;
#line 329
  s = str;
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 329
    if (! (s < str + 6)) {
#line 329
      goto while_break___0;
    }
#line 331
    if ((int )((char )*s) >= 48) {
#line 331
      if ((int )((char )*s) <= 55) {
#line 332
        mode = (mode << 3) + (unsigned int )((int )((char )*s) - 48);
      } else {
#line 335
        mode = (mode_t )0;
#line 336
        goto while_break___0;
      }
    } else {
#line 335
      mode = (mode_t )0;
#line 336
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  s ++;
#line 339
  if ((int )((char )*s) == 13) {
#line 340
    s ++;
  }
#line 341
  if ((int )((char )*s) != 10) {
#line 342
    mode = (mode_t )0;
  }
#line 348
  return (mode);
}
}
#line 352 "/tmp/0/patch-2.7.1/src/pch.c"
static void get_sha1(char **sha1 , char const   *start , char const   *end ) 
{ 
  unsigned int len ;
  void *__cil_tmp5 ;

  {
  {
#line 354
  len = (unsigned int )(end - start);
#line 355
  __cil_tmp5 = xmalloc((size_t )(len + 1U));
#line 355
  *sha1 = (char *)__cil_tmp5;
#line 356
  memcpy((void *)*sha1, (void const   *)start, (unsigned long )len);
#line 357
  *(*sha1 + len) = (char )0;
  }
}
}
#line 361 "/tmp/0/patch-2.7.1/src/pch.c"
static int sha1_says_nonexistent(char const   *sha1 ) 
{ 
  char const   *empty_sha1 ;
  char const   *s ;
  char const   *__cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
#line 363
  empty_sha1 = (char const   *)((char *)"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391");
#line 367
  s = sha1;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((char )*s)) {
#line 367
      goto while_break;
    }
#line 368
    if ((int )((char )*s) != 48) {
#line 369
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  s ++;
#line 370
  if (! ((char )*s)) {
#line 371
    return (2);
  }
#line 374
  s = sha1;
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! ((char )*s)) {
#line 374
      goto while_break___0;
    }
#line 375
    if ((int )((char )*s) != (int )((char )*empty_sha1)) {
#line 376
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  __cil_tmp6 = empty_sha1;
#line 374
  empty_sha1 ++;
#line 374
  __cil_tmp5 = s;
#line 374
  s ++;
#line 377
  return (! ((char )*s));
}
}
#line 381 "/tmp/0/patch-2.7.1/src/pch.c"
static char const   *skip_hex_digits(char const   *str ) 
{ 
  char const   *s ;
  char const   *tmp ;

  {
#line 385
  s = str;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (((int )((char )*s) >= 48 && (int )((char )*s) <= 57) || ((int )((char )*s) >= 97 && (int )((char )*s) <= 102))) {
#line 385
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 385
  s ++;
#line 387
  if (s == str) {
#line 387
    tmp = (char const   *)((void *)0);
  } else {
#line 387
    tmp = s;
  }
#line 387
  return (tmp);
}
}
#line 393 "/tmp/0/patch-2.7.1/src/pch.c"
static int cwd_is_root(char const   *name ) 
{ 
  unsigned int prefix_len ;
  char root[prefix_len + 2U] ;
  struct stat st ;
  dev_t root_dev ;
  ino_t root_ino ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 395
  prefix_len = (unsigned int )0;
#line 401
  memcpy((void *)((char *)root), (void const   *)name, (unsigned long )prefix_len);
#line 402
  root[prefix_len] = (char )'/';
#line 403
  root[prefix_len + 1U] = (char )0;
#line 404
  __cil_tmp7 = stat((char const   *)((char *)root), & st);
  }
#line 404
  if (__cil_tmp7) {
#line 405
    return (0);
  }
  {
#line 406
  root_dev = st.st_dev;
#line 407
  root_ino = st.st_ino;
#line 408
  __cil_tmp8 = stat((char const   *)((char *)"."), & st);
  }
#line 408
  if (__cil_tmp8) {
#line 409
    return (0);
  }
#line 410
  return (root_dev == st.st_dev && root_ino == st.st_ino);
}
}
#line 414 "/tmp/0/patch-2.7.1/src/pch.c"
static int name_is_valid(char const   *name ) 
{ 
  char const   *n ;
  int i ;
  int is_valid ;
  int __cil_tmp5 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 418
  is_valid = 1;
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0]))) {
#line 420
      goto while_break;
    }
#line 422
    if (! invalid_names[i]) {
#line 423
      goto while_break;
    }
    {
#line 424
    __cil_tmp5 = strcmp(invalid_names[i], name);
    }
#line 424
    if (! __cil_tmp5) {
#line 425
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  i ++;
#line 428
  if ((int )((char )*(name + 0)) == 47) {
#line 429
    is_valid = 0;
  } else {
#line 431
    n = name;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      if (! ((char )*n)) {
#line 431
        goto while_break___0;
      }
#line 433
      n ++;
#line 433
      n ++;
#line 433
      if ((int )((char )*n) == 46) {
#line 433
        if ((int )((char )*n) == 46) {
#line 433
          if (! ((char )*n)) {
#line 435
            is_valid = 0;
#line 436
            goto while_break___0;
          } else
#line 433
          if ((int )((char )*n) == 47) {
#line 435
            is_valid = 0;
#line 436
            goto while_break___0;
          }
        }
      }
      {
#line 438
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 438
        if (! ((int )((char )*n) && ! ((int )((char )*n) == 47))) {
#line 438
          goto while_break___1;
        }
#line 439
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 440
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 440
        if (! ((int )((char )*n) == 47)) {
#line 440
          goto while_break___2;
        }
#line 441
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 445
  __cil_tmp9 = cwd_is_root(name);
  }
#line 445
  if (! is_valid) {
#line 445
    if (__cil_tmp9) {
#line 446
      is_valid = 1;
    }
  }
#line 448
  if (! is_valid) {
    {
#line 450
    __cil_tmp10 = quotearg(name);
#line 450
    say((char const   *)((char *)"Ignoring potentially dangerous file name %s\n"),
        __cil_tmp10);
    }
#line 451
    if ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0])) {
#line 452
      invalid_names[i] = name;
    }
  }
#line 454
  return (is_valid);
}
}
#line 460 "/tmp/0/patch-2.7.1/src/pch.c"
static enum diff intuit_diff_type(int need_header , mode_t *p_file_type ) 
{ 
  file_offset this_line ;
  file_offset first_command_line ;
  char first_ed_command_letter ;
  lin fcl_line ;
  int this_is_a_command ;
  int stars_this_line ;
  int extended_headers ;
  enum nametype i ;
  struct stat st[3] ;
  int stat_errno[3] ;
  int version_controlled[3] ;
  enum diff retval ;
  mode_t file_type ;
  char *s ;
  char *t ;
  file_offset previous_line ;
  int last_line_was_command ;
  int stars_last_line ;
  size_t indent ;
  char ed_command_letter ;
  int strip_trailing_cr ;
  size_t chars_read ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned short const   **__cil_tmp44 ;
  unsigned short const   **__cil_tmp46 ;
  char const   *u ;
  unsigned short const   **__cil_tmp48 ;
  char numbuf[23] ;
  char *__cil_tmp51 ;
  char oldc ;
  int __cil_tmp55 ;
  char const   *u___0 ;
  unsigned short const   **__cil_tmp59 ;
  int __cil_tmp63 ;
  char const   *u___1 ;
  char const   *v ;
  unsigned short const   **__cil_tmp68 ;
  int __cil_tmp73 ;
  int __cil_tmp75 ;
  int __cil_tmp77 ;
  int __cil_tmp79 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  struct timespec timestamp ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  struct timespec ti ;
  char numbuf___0[23] ;
  char *__cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int tmp ;
  file_offset saved_p_base ;
  lin saved_p_bline ;
  int __cil_tmp101 ;
  char numbuf___1[23] ;
  char *__cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  mode_t new_file_type ;
  enum nametype i0 ;
  int __cil_tmp108 ;
  enum file_id_type __cil_tmp110 ;
  int __cil_tmp111 ;
  enum nametype nope ;
  char const   *cs ;
  char *getbuf ;
  char *diffbuf ;
  int readonly ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp122 ;
  unsigned int tmp___0 ;
  int __cil_tmp125 ;
  int newdirs[3] ;
  int newdirs_min ;
  int distance_from_minimum[3] ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;

  {
#line 462
  this_line = (file_offset )0;
#line 463
  first_command_line = (file_offset )(- 1);
#line 464
  first_ed_command_letter = (char )0;
#line 465
  fcl_line = (lin )0;
#line 466
  this_is_a_command = 0;
#line 467
  stars_this_line = 0;
#line 468
  extended_headers = 0;
#line 476
  i = (enum nametype )0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! ((unsigned int )i <= 2U)) {
#line 476
      goto while_break;
    }
#line 477
    if (p_name[i]) {
      {
#line 478
      free((void *)p_name[i]);
#line 479
      p_name[i] = (char *)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  i ++;
#line 481
  i = (enum nametype )0;
  {
#line 481
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0]))) {
#line 481
      goto while_break___0;
    }
#line 482
    invalid_names[i] = (char const   *)((void *)0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 481
  i ++;
#line 483
  i = (enum nametype )0;
  {
#line 483
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 483
    if (! ((unsigned int )i <= 1U)) {
#line 483
      goto while_break___1;
    }
#line 484
    if (p_timestr[i]) {
      {
#line 486
      free((void *)p_timestr[i]);
#line 487
      p_timestr[i] = (char *)0;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 483
  i ++;
#line 489
  i = (enum nametype )0;
  {
#line 489
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 489
    if (! ((unsigned int )i <= 1U)) {
#line 489
      goto while_break___2;
    }
#line 490
    if (p_sha1[i]) {
      {
#line 492
      free((void *)p_sha1[i]);
#line 493
      p_sha1[i] = (char *)0;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 489
  i ++;
#line 495
  p_git_diff = 0;
#line 496
  i = (enum nametype )0;
  {
#line 496
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 496
    if (! ((unsigned int )i <= 1U)) {
#line 496
      goto while_break___3;
    }
#line 498
    p_mode[i] = (mode_t )0;
#line 499
    p_copy[i] = 0;
#line 500
    p_rename[i] = 0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 496
  i ++;
#line 504
  if ((unsigned int )diff_type == 3U) {
#line 505
    need_header = 0;
  } else
#line 504
  if ((unsigned int )diff_type == 2U) {
#line 505
    need_header = 0;
  }
  {
#line 507
  version_controlled[0] = - 1;
#line 508
  version_controlled[1] = - 1;
#line 509
  version_controlled[2] = - 1;
#line 510
  p_rfc934_nesting = 0;
#line 511
  p_timestamp[1].tv_sec = (__time_t )(- 1);
#line 511
  p_timestamp[0].tv_sec = p_timestamp[1].tv_sec;
#line 512
  p_says_nonexistent[1] = 0;
#line 512
  p_says_nonexistent[0] = p_says_nonexistent[1];
#line 513
  Fseek(pfp, p_base, 0);
#line 514
  p_input_line = p_bline - 1L;
  }
  {
#line 515
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 515
    if (! 1) {
#line 515
      goto while_break___4;
    }
    {
#line 518
    previous_line = this_line;
#line 519
    last_line_was_command = this_is_a_command;
#line 520
    stars_last_line = stars_this_line;
#line 521
    indent = (size_t )0;
#line 526
    this_line = ftell(pfp);
#line 527
    chars_read = pget_line((size_t )0, 0, 0, 0);
    }
#line 528
    if (chars_read == 0xffffffffffffffffUL) {
      {
#line 529
      xalloc_die();
      }
    }
#line 530
    if (! chars_read) {
#line 531
      if (first_ed_command_letter) {
#line 533
        p_start = first_command_line;
#line 534
        p_sline = fcl_line;
#line 535
        retval = (enum diff )3;
#line 536
        goto scan_exit;
      } else {
#line 539
        p_start = this_line;
#line 540
        p_sline = p_input_line;
#line 541
        if (extended_headers) {
#line 544
          retval = (enum diff )5;
#line 545
          goto scan_exit;
        }
#line 547
        return ((enum diff )0);
      }
    }
#line 550
    strip_trailing_cr = 2UL <= chars_read && (int )*(buf + (chars_read - 2UL)) == 13;
#line 551
    s = buf;
    {
#line 551
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 551
      if (! (((int )*s == 32 || (int )*s == 9) || (int )*s == 88)) {
#line 551
        goto while_break___5;
      }
#line 552
      if ((int )*s == 9) {
#line 553
        indent = (indent + 8UL) & 0xfffffffffffffff8UL;
      } else {
#line 555
        indent ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 551
    s ++;
#line 557
    if ((unsigned int )*s - 48U <= 9U) {
#line 559
      t = s + 1;
      {
#line 559
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 559
        if (! ((unsigned int )*t - 48U <= 9U || (int )*t == 44)) {
#line 559
          goto while_break___6;
        }

      }
      while_break___6: /* CIL Label */ ;
      }
#line 559
      t ++;
#line 561
      if ((int )*t == 100) {
        _L: /* CIL Label */ 
#line 563
        t ++;
        {
#line 563
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 563
          if (! ((unsigned int )*t - 48U <= 9U || (int )*t == 44)) {
#line 563
            goto while_break___7;
          }

        }
        while_break___7: /* CIL Label */ ;
        }
#line 563
        t ++;
        {
#line 565
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 565
          if (! ((int )*t == 32 || (int )*t == 9)) {
#line 565
            goto while_break___8;
          }

        }
        while_break___8: /* CIL Label */ ;
        }
#line 565
        t ++;
#line 567
        if ((int )*t == 13) {
#line 568
          t ++;
        }
#line 569
        this_is_a_command = (int )*t == 10;
      } else
#line 561
      if ((int )*t == 99) {
#line 561
        goto _L;
      } else
#line 561
      if ((int )*t == 97) {
#line 561
        goto _L;
      }
    }
    {
#line 572
    ed_command_letter = get_ed_command_letter((char const   *)s);
    }
#line 572
    if (! need_header) {
#line 572
      if (first_command_line < 0L) {
#line 572
        if ((int )ed_command_letter) {
#line 576
          first_command_line = this_line;
#line 577
          first_ed_command_letter = ed_command_letter;
#line 578
          fcl_line = p_input_line;
#line 579
          p_indent = indent;
#line 580
          p_strip_trailing_cr = strip_trailing_cr;
        } else
#line 572
        if (this_is_a_command) {
#line 576
          first_command_line = this_line;
#line 577
          first_ed_command_letter = ed_command_letter;
#line 578
          fcl_line = p_input_line;
#line 579
          p_indent = indent;
#line 580
          p_strip_trailing_cr = strip_trailing_cr;
        }
      }
    }
    {
#line 582
    __cil_tmp40 = strncmp((char const   *)s, (char const   *)((char *)"*** "), (unsigned long )4);
    }
#line 582
    if (! stars_last_line) {
#line 582
      if (! __cil_tmp40) {
        {
#line 584
        fetchname((char const   *)(s + 4), strippath, & p_name[0], & p_timestr[0],
                  & p_timestamp[0]);
#line 586
        need_header = 0;
        }
      } else {
#line 582
        goto _L___158;
      }
    } else {
      _L___158: /* CIL Label */ 
      {
#line 588
      __cil_tmp41 = strncmp((char const   *)s, (char const   *)((char *)"+++ "), (unsigned long )4);
      }
#line 588
      if (! __cil_tmp41) {
        {
#line 591
        fetchname((char const   *)(s + 4), strippath, & p_name[0], & p_timestr[0],
                  & p_timestamp[0]);
#line 593
        need_header = 0;
#line 594
        p_strip_trailing_cr = strip_trailing_cr;
        }
      } else {
        {
#line 596
        __cil_tmp42 = strncmp((char const   *)s, (char const   *)((char *)"Index:"),
                              (unsigned long )6);
        }
#line 596
        if (! __cil_tmp42) {
          {
#line 598
          fetchname((char const   *)(s + 6), strippath, & p_name[2], (char **)0, (struct timespec *)((void *)0));
#line 599
          need_header = 0;
#line 600
          p_strip_trailing_cr = strip_trailing_cr;
          }
        } else {
          {
#line 602
          __cil_tmp43 = strncmp((char const   *)s, (char const   *)((char *)"Prereq:"),
                                (unsigned long )7);
          }
#line 602
          if (! __cil_tmp43) {
#line 604
            t = s + 7;
            {
#line 604
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 604
              if (! ((int )((unsigned short )*(*__cil_tmp44 + (int )((unsigned char )*t))) & 8192)) {
#line 604
                goto while_break___9;
              }

            }
            while_break___9: /* CIL Label */ ;
            }
#line 604
            t ++;
#line 606
            revision = t;
#line 607
            t = revision;
            {
#line 607
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 607
              if (! *t) {
#line 607
                goto while_break___10;
              }
              {
#line 608
              __cil_tmp46 = __ctype_b_loc();
              }
#line 608
              if ((int )((unsigned short )*(*__cil_tmp46 + (int )((unsigned char )*t))) & 8192) {
#line 611
                u = (char const   *)(t + 1);
                {
#line 611
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 611
                  if (! ((int )((unsigned short )*(*__cil_tmp48 + (int )((unsigned char )((char )*u)))) & 8192)) {
#line 611
                    goto while_break___11;
                  }

                }
                while_break___11: /* CIL Label */ ;
                }
#line 611
                u ++;
#line 613
                if ((char )*u) {
                  {
#line 616
                  __cil_tmp51 = format_linenum((char *)numbuf, this_line);
#line 616
                  say((char const   *)((char *)"Prereq: with multiple words at line %s of patch\n"),
                      __cil_tmp51);
                  }
                }
#line 619
                goto while_break___10;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
#line 607
            t ++;
#line 621
            if (t == revision) {
#line 622
              revision = (char *)0;
            } else {
              {
#line 624
              oldc = *t;
#line 625
              *t = (char )'\000';
#line 626
              revision = savestr((char const   *)revision);
#line 627
              *t = oldc;
              }
            }
          } else {
            {
#line 630
            __cil_tmp55 = strncmp((char const   *)s, (char const   *)((char *)"diff --git "),
                                  (unsigned long )11);
            }
#line 630
            if (! __cil_tmp55) {
#line 634
              if (extended_headers) {
#line 636
                p_start = this_line;
#line 637
                p_sline = p_input_line;
#line 639
                retval = (enum diff )5;
#line 640
                goto scan_exit;
              }
#line 643
              i = (enum nametype )0;
              {
#line 643
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 643
                if (! ((unsigned int )i <= 1U)) {
#line 643
                  goto while_break___12;
                }
                {
#line 645
                free((void *)p_name[i]);
#line 646
                p_name[i] = (char *)0;
                }
              }
              while_break___12: /* CIL Label */ ;
              }
              {
#line 643
              i ++;
#line 648
              u___0 = skip_spaces(u___0);
              }
              {
#line 648
              p_name[1] = parse_name(u___0, strippath, & u___0);
              }
              {
#line 648
              __cil_tmp59 = __ctype_b_loc();
              }
              {
#line 648
              p_name[0] = parse_name((char const   *)(s + 11), strippath, & u___0);
              }
#line 648
              if (! (((p_name[0] && (int )((unsigned short )*(*__cil_tmp59 + (int )((unsigned char )((char )*u___0)))) & 8192) && p_name[1]) && ! ((char )*u___0))) {
#line 652
                i = (enum nametype )0;
                {
#line 652
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 652
                  if (! ((unsigned int )i <= 1U)) {
#line 652
                    goto while_break___13;
                  }
                  {
#line 654
                  free((void *)p_name[i]);
#line 655
                  p_name[i] = (char *)0;
                  }
                }
                while_break___13: /* CIL Label */ ;
                }
#line 652
                i ++;
              }
#line 657
              p_git_diff = 1;
            } else {
              {
#line 659
              __cil_tmp63 = strncmp((char const   *)s, (char const   *)((char *)"index "),
                                    (unsigned long )6);
              }
#line 659
              if (p_git_diff) {
#line 659
                if (! __cil_tmp63) {
                  {
#line 662
                  __cil_tmp68 = __ctype_b_loc();
                  }
                  {
#line 662
                  v = skip_hex_digits(u___1 + 2);
                  }
                  {
#line 662
                  u___1 = skip_hex_digits((char const   *)(s + 6));
                  }
#line 662
                  if (u___1) {
#line 662
                    if ((int )((char )*(u___1 + 0)) == 46) {
#line 662
                      if ((int )((char )*(u___1 + 1)) == 46) {
#line 662
                        if (v) {
#line 662
                          if (! ((char )*v)) {
                            _L___147: /* CIL Label */ 
                            {
#line 667
                            get_sha1(& p_sha1[0], (char const   *)(s + 6), u___1);
#line 668
                            get_sha1(& p_sha1[1], u___1 + 2, v);
#line 669
                            p_says_nonexistent[0] = sha1_says_nonexistent((char const   *)p_sha1[0]);
#line 670
                            p_says_nonexistent[1] = sha1_says_nonexistent((char const   *)p_sha1[1]);
#line 671
                            v = skip_spaces(v);
                            }
#line 671
                            if ((char )*v) {
                              {
#line 672
                              p_mode[0] = fetchmode(v);
                              }
                            }
#line 673
                            extended_headers = 1;
                          } else
#line 662
                          if ((int )((unsigned short )*(*__cil_tmp68 + (int )((unsigned char )((char )*v)))) & 8192) {
#line 662
                            goto _L___147;
                          }
                        }
                      }
                    }
                  }
                } else {
#line 659
                  goto _L___157;
                }
              } else {
                _L___157: /* CIL Label */ 
                {
#line 676
                __cil_tmp73 = strncmp((char const   *)s, (char const   *)((char *)"old mode "),
                                      (unsigned long )9);
                }
#line 676
                if (p_git_diff) {
#line 676
                  if (! __cil_tmp73) {
                    {
#line 678
                    p_mode[0] = fetchmode((char const   *)(s + 9));
#line 679
                    extended_headers = 1;
                    }
                  } else {
#line 676
                    goto _L___156;
                  }
                } else {
                  _L___156: /* CIL Label */ 
                  {
#line 681
                  __cil_tmp75 = strncmp((char const   *)s, (char const   *)((char *)"new mode "),
                                        (unsigned long )9);
                  }
#line 681
                  if (p_git_diff) {
#line 681
                    if (! __cil_tmp75) {
                      {
#line 683
                      p_mode[1] = fetchmode((char const   *)(s + 9));
#line 684
                      extended_headers = 1;
                      }
                    } else {
#line 681
                      goto _L___155;
                    }
                  } else {
                    _L___155: /* CIL Label */ 
                    {
#line 686
                    __cil_tmp77 = strncmp((char const   *)s, (char const   *)((char *)"deleted file mode "),
                                          (unsigned long )18);
                    }
#line 686
                    if (p_git_diff) {
#line 686
                      if (! __cil_tmp77) {
                        {
#line 688
                        p_mode[0] = fetchmode((char const   *)(s + 18));
#line 689
                        p_says_nonexistent[1] = 2;
#line 690
                        extended_headers = 1;
                        }
                      } else {
#line 686
                        goto _L___154;
                      }
                    } else {
                      _L___154: /* CIL Label */ 
                      {
#line 692
                      __cil_tmp79 = strncmp((char const   *)s, (char const   *)((char *)"new file mode "),
                                            (unsigned long )14);
                      }
#line 692
                      if (p_git_diff) {
#line 692
                        if (! __cil_tmp79) {
                          {
#line 694
                          p_mode[1] = fetchmode((char const   *)(s + 14));
#line 695
                          p_says_nonexistent[0] = 2;
#line 696
                          extended_headers = 1;
                          }
                        } else {
#line 692
                          goto _L___153;
                        }
                      } else {
                        _L___153: /* CIL Label */ 
                        {
#line 698
                        __cil_tmp81 = strncmp((char const   *)s, (char const   *)((char *)"rename from "),
                                              (unsigned long )12);
                        }
#line 698
                        if (p_git_diff) {
#line 698
                          if (! __cil_tmp81) {
#line 702
                            p_rename[0] = 1;
#line 703
                            extended_headers = 1;
                          } else {
#line 698
                            goto _L___152;
                          }
                        } else {
                          _L___152: /* CIL Label */ 
                          {
#line 705
                          __cil_tmp82 = strncmp((char const   *)s, (char const   *)((char *)"rename to "),
                                                (unsigned long )10);
                          }
#line 705
                          if (p_git_diff) {
#line 705
                            if (! __cil_tmp82) {
#line 709
                              p_rename[1] = 1;
#line 710
                              extended_headers = 1;
                            } else {
#line 705
                              goto _L___151;
                            }
                          } else {
                            _L___151: /* CIL Label */ 
                            {
#line 712
                            __cil_tmp83 = strncmp((char const   *)s, (char const   *)((char *)"copy from "),
                                                  (unsigned long )10);
                            }
#line 712
                            if (p_git_diff) {
#line 712
                              if (! __cil_tmp83) {
#line 716
                                p_copy[0] = 1;
#line 717
                                extended_headers = 1;
                              } else {
#line 712
                                goto _L___150;
                              }
                            } else {
                              _L___150: /* CIL Label */ 
                              {
#line 719
                              __cil_tmp84 = strncmp((char const   *)s, (char const   *)((char *)"copy to "),
                                                    (unsigned long )8);
                              }
#line 719
                              if (p_git_diff) {
#line 719
                                if (! __cil_tmp84) {
#line 723
                                  p_copy[1] = 1;
#line 724
                                  extended_headers = 1;
                                } else {
#line 719
                                  goto _L___149;
                                }
                              } else {
                                _L___149: /* CIL Label */ 
                                {
#line 726
                                __cil_tmp85 = strncmp((char const   *)s, (char const   *)((char *)"GIT binary patch"),
                                                      (unsigned long )16);
                                }
#line 726
                                if (p_git_diff) {
#line 726
                                  if (! __cil_tmp85) {
#line 728
                                    p_start = this_line;
#line 729
                                    p_sline = p_input_line;
#line 730
                                    retval = (enum diff )6;
#line 731
                                    goto scan_exit;
                                  } else {
#line 726
                                    goto _L___148;
                                  }
                                } else {
                                  _L___148: /* CIL Label */ 
#line 735
                                  t = s;
                                  {
#line 735
                                  while (1) {
                                    while_continue___14: /* CIL Label */ ;
#line 735
                                    if (! ((int )*(t + 0) == 45 && (int )*(t + 1) == 32)) {
#line 735
                                      goto while_break___14;
                                    }

                                  }
                                  while_break___14: /* CIL Label */ ;
                                  }
                                  {
#line 735
                                  t += 2;
#line 737
                                  __cil_tmp86 = strncmp((char const   *)t, (char const   *)((char *)"--- "),
                                                        (unsigned long )4);
                                  }
#line 737
                                  if (! __cil_tmp86) {
                                    {
#line 740
                                    timestamp.tv_sec = (__time_t )(- 1);
#line 741
                                    fetchname((char const   *)(t + 4), strippath,
                                              & p_name[1], & p_timestr[1], & timestamp);
#line 743
                                    need_header = 0;
                                    }
#line 744
                                    if (timestamp.tv_sec != -1L) {
#line 746
                                      p_timestamp[1] = timestamp;
#line 747
                                      p_rfc934_nesting = (int )((t - s) >> 1);
                                    }
#line 749
                                    p_strip_trailing_cr = strip_trailing_cr;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 752
    if (need_header) {
#line 753
      goto while_continue___4;
    }
    {
#line 754
    __cil_tmp88 = strcmp((char const   *)s, (char const   *)((char *)".\n"));
    }
#line 754
    if ((unsigned int )diff_type == 0U) {
      _L___159: /* CIL Label */ 
#line 754
      if (first_command_line >= 0L) {
#line 754
        if (! __cil_tmp88) {
#line 757
          p_start = first_command_line;
#line 758
          p_sline = fcl_line;
#line 759
          retval = (enum diff )3;
#line 760
          goto scan_exit;
        }
      }
    } else
#line 754
    if ((unsigned int )diff_type == 3U) {
#line 754
      goto _L___159;
    }
    {
#line 762
    __cil_tmp89 = strncmp((char const   *)s, (char const   *)((char *)"@@ -"), (unsigned long )4);
    }
#line 762
    if ((unsigned int )diff_type == 0U) {
      _L___160: /* CIL Label */ 
#line 762
      if (! __cil_tmp89) {
#line 767
        ti = p_timestamp[0];
#line 768
        p_timestamp[0] = p_timestamp[1];
#line 769
        p_timestamp[1] = ti;
#line 770
        t = p_name[0];
#line 771
        p_name[0] = p_name[1];
#line 772
        p_name[1] = t;
#line 773
        t = p_timestr[0];
#line 774
        p_timestr[0] = p_timestr[1];
#line 775
        p_timestr[1] = t;
#line 777
        s += 4;
#line 778
        if ((int )*(s + 0) == 48) {
#line 778
          if (! ((unsigned int )*(s + 1) - 48U <= 9U)) {
#line 779
            p_says_nonexistent[0] = 1 + ! p_timestamp[0].tv_sec;
          }
        }
        {
#line 780
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 780
          if (! ((int )*s != 32 && (int )*s != 10)) {
#line 780
            goto while_break___15;
          }
#line 781
          s ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 782
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 782
          if (! ((int )*s == 32)) {
#line 782
            goto while_break___16;
          }
#line 783
          s ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 784
        if ((int )*(s + 0) == 43) {
#line 784
          if ((int )*(s + 1) == 48) {
#line 784
            if (! ((unsigned int )*(s + 2) - 48U <= 9U)) {
#line 785
              p_says_nonexistent[1] = 1 + ! p_timestamp[1].tv_sec;
            }
          }
        }
#line 786
        p_indent = indent;
#line 787
        p_start = this_line;
#line 788
        p_sline = p_input_line;
#line 789
        retval = (enum diff )5;
#line 790
        if (! ((p_name[0] || ! p_timestamp[0].tv_sec) && (p_name[1] || ! p_timestamp[1].tv_sec))) {
#line 790
          if (! p_name[2]) {
#line 790
            if (need_header) {
              {
#line 795
              __cil_tmp94 = format_linenum((char *)numbuf___0, p_sline);
#line 795
              say((char const   *)((char *)"missing header for unified diff at line %s of patch\n"),
                  __cil_tmp94);
              }
            }
          }
        }
#line 798
        goto scan_exit;
      }
    } else
#line 762
    if ((unsigned int )diff_type == 5U) {
#line 762
      goto _L___160;
    }
    {
#line 800
    __cil_tmp95 = strncmp((char const   *)s, (char const   *)((char *)"********"),
                          (unsigned long )8);
#line 800
    stars_this_line = ! __cil_tmp95;
#line 801
    __cil_tmp96 = strncmp((char const   *)s, (char const   *)((char *)"*** "), (unsigned long )4);
    }
#line 801
    if ((unsigned int )diff_type == 0U) {
      _L___161: /* CIL Label */ 
#line 801
      if (stars_last_line) {
#line 801
        if (! __cil_tmp96) {
#line 805
          s += 4;
#line 806
          if ((int )*(s + 0) == 48) {
#line 806
            if (! ((unsigned int )*(s + 1) - 48U <= 9U)) {
#line 807
              p_says_nonexistent[0] = 1 + ! p_timestamp[0].tv_sec;
            }
          }
          {
#line 810
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 810
            if (! ((int )*s != 10)) {
#line 810
              goto while_break___17;
            }
#line 811
            s ++;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 812
          p_indent = indent;
#line 813
          p_strip_trailing_cr = strip_trailing_cr;
#line 814
          p_start = previous_line;
#line 815
          p_sline = p_input_line - 1L;
#line 816
          if ((int )*(s - 1) == 42) {
#line 816
            tmp = 4;
          } else {
#line 816
            tmp = 1;
          }
          {
#line 816
          retval = (enum diff )tmp;
#line 821
          saved_p_base = p_base;
#line 822
          saved_p_bline = p_bline;
#line 823
          Fseek(pfp, previous_line, 0);
#line 824
          p_input_line -= (long )2;
#line 825
          __cil_tmp101 = another_hunk(retval, 0);
          }
#line 825
          if (__cil_tmp101) {
#line 825
            if (! p_repl_lines) {
#line 825
              if (p_newfirst == 1L) {
#line 827
                p_says_nonexistent[1] = 1 + ! p_timestamp[1].tv_sec;
              }
            }
          }
          {
#line 828
          next_intuit_at(saved_p_base, saved_p_bline);
          }
#line 831
          if (! ((p_name[0] || ! p_timestamp[0].tv_sec) && (p_name[1] || ! p_timestamp[1].tv_sec))) {
#line 831
            if (! p_name[2]) {
#line 831
              if (need_header) {
                {
#line 836
                __cil_tmp103 = format_linenum((char *)numbuf___1, p_sline);
#line 836
                say((char const   *)((char *)"missing header for context diff at line %s of patch\n"),
                    __cil_tmp103);
                }
              }
            }
          }
#line 839
          goto scan_exit;
        }
      }
    } else
#line 801
    if ((unsigned int )diff_type == 1U) {
#line 801
      goto _L___161;
    } else
#line 801
    if ((unsigned int )diff_type == 4U) {
#line 801
      goto _L___161;
    }
    {
#line 841
    __cil_tmp105 = strncmp((char const   *)s, (char const   *)((char *)"> "), (unsigned long )2);
    }
    {
#line 841
    __cil_tmp104 = strncmp((char const   *)s, (char const   *)((char *)"< "), (unsigned long )2);
    }
#line 841
    if ((unsigned int )diff_type == 0U) {
      _L___163: /* CIL Label */ 
#line 841
      if (last_line_was_command) {
#line 841
        if (! __cil_tmp104) {
#line 844
          p_start = previous_line;
#line 845
          p_sline = p_input_line - 1L;
#line 846
          p_indent = indent;
#line 847
          retval = (enum diff )2;
#line 848
          goto scan_exit;
        } else
#line 841
        if (! __cil_tmp105) {
#line 844
          p_start = previous_line;
#line 845
          p_sline = p_input_line - 1L;
#line 846
          p_indent = indent;
#line 847
          retval = (enum diff )2;
#line 848
          goto scan_exit;
        }
      }
    } else
#line 841
    if ((unsigned int )diff_type == 2U) {
#line 841
      goto _L___163;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  scan_exit: 
#line 857
  file_type = p_mode[0] & 61440U;
#line 858
  if (file_type) {
#line 860
    new_file_type = p_mode[1] & 61440U;
#line 861
    if (new_file_type) {
#line 861
      if (file_type != new_file_type) {
#line 862
        file_type = (mode_t )0;
      }
    }
  } else {
#line 866
    file_type = p_mode[1] & 61440U;
#line 867
    if (! file_type) {
#line 868
      file_type = (mode_t )32768;
    }
  }
#line 870
  *p_file_type = file_type;
#line 893
  i = (enum nametype )3;
#line 895
  if (! inname) {
#line 897
    i0 = (enum nametype )3;
#line 899
    if (! posixly_correct) {
#line 899
      if (p_name[0]) {
        _L___164: /* CIL Label */ 
#line 899
        if (p_name[2]) {
          {
#line 901
          free((void *)p_name[2]);
#line 902
          p_name[2] = (char *)0;
          }
        }
      } else
#line 899
      if (p_name[1]) {
#line 899
        goto _L___164;
      }
    }
#line 905
    i = (enum nametype )0;
    {
#line 905
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 905
      if (! ((unsigned int )i <= 2U)) {
#line 905
        goto while_break___18;
      }
#line 906
      if (p_name[i]) {
        {
#line 908
        __cil_tmp108 = strcmp((char const   *)p_name[i0], (char const   *)p_name[i]);
        }
#line 908
        if ((unsigned int )i0 != 3U) {
#line 908
          if (__cil_tmp108 == 0) {
#line 911
            stat_errno[i] = stat_errno[i0];
#line 912
            if (! stat_errno[i]) {
#line 913
              st[i] = st[i0];
            }
          } else {
#line 908
            goto _L___165;
          }
        } else {
          _L___165: /* CIL Label */ 
          {
#line 917
          stat_errno[i] = stat_file((char const   *)p_name[i], & st[i]);
          }
#line 918
          if (! stat_errno[i]) {
            {
#line 920
            __cil_tmp110 = lookup_file_id(& st[i]);
            }
#line 920
            if ((unsigned int )__cil_tmp110 == 2U) {
#line 921
              stat_errno[i] = 2;
            } else {
              {
#line 922
              __cil_tmp111 = name_is_valid((char const   *)p_name[i]);
              }
#line 922
              if (posixly_correct) {
#line 922
                if (__cil_tmp111) {
#line 923
                  goto while_break___18;
                }
              }
            }
          }
        }
#line 926
        i0 = i;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 905
    i ++;
#line 929
    if (! posixly_correct) {
      {
#line 932
      i = best_name((char * const  *)((char **)p_name), (int const   *)((int *)stat_errno));
      }
#line 934
      if ((unsigned int )i == 3U) {
#line 934
        if (patch_get) {
#line 936
          nope = (enum nametype )3;
#line 938
          i = (enum nametype )0;
          {
#line 938
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 938
            if (! ((unsigned int )i <= 2U)) {
#line 938
              goto while_break___19;
            }
#line 939
            if (p_name[i]) {
              {
#line 944
              __cil_tmp119 = strcmp((char const   *)outfile, (char const   *)p_name[i]);
#line 944
              readonly = outfile && __cil_tmp119 != 0;
#line 947
              __cil_tmp120 = strcmp((char const   *)p_name[nope], (char const   *)p_name[i]);
              }
#line 947
              if ((unsigned int )nope == 3U) {
                _L___166: /* CIL Label */ 
                {
#line 949
                cs = version_controller((char const   *)p_name[i], readonly, (struct stat *)0,
                                        & getbuf, & diffbuf);
#line 952
                version_controlled[i] = ! (! cs);
                }
#line 953
                if (cs) {
                  {
#line 955
                  __cil_tmp122 = version_get((char const   *)p_name[i], cs, 0, readonly,
                                             (char const   *)getbuf, & st[i]);
                  }
#line 955
                  if (__cil_tmp122) {
#line 957
                    stat_errno[i] = 0;
                  } else {
#line 959
                    version_controlled[i] = 0;
                  }
                  {
#line 961
                  free((void *)getbuf);
#line 962
                  free((void *)diffbuf);
                  }
#line 964
                  if (! stat_errno[i]) {
#line 965
                    goto while_break___19;
                  }
                }
              } else
#line 947
              if (__cil_tmp120 != 0) {
#line 947
                goto _L___166;
              }
#line 969
              nope = i;
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 938
          i ++;
        }
      }
#line 973
      if ((unsigned int )i == 3U) {
#line 973
        tmp___0 = (unsigned int )i0;
      } else {
#line 973
        tmp___0 = (unsigned int )i;
      }
      {
#line 973
      __cil_tmp125 = maybe_reverse((char const   *)p_name[tmp___0], (unsigned int )i == 3U,
                                   (unsigned int )i == 3U || st[i].st_size == 0L);
      }
#line 973
      if ((unsigned int )i0 != 3U) {
#line 973
        if ((unsigned int )i == 3U) {
          _L___167: /* CIL Label */ 
#line 973
          if (__cil_tmp125) {
#line 973
            if ((unsigned int )i == 3U) {
#line 978
              i = i0;
            }
          }
        } else
#line 973
        if ((st[i].st_mode & 61440U) == file_type) {
#line 973
          goto _L___167;
        }
      }
#line 980
      if ((unsigned int )i == 3U) {
#line 980
        if (p_says_nonexistent[reverse]) {
#line 983
          newdirs_min = 2147483647;
#line 986
          i = (enum nametype )0;
          {
#line 986
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 986
            if (! ((unsigned int )i <= 2U)) {
#line 986
              goto while_break___20;
            }
#line 987
            if (p_name[i]) {
              {
#line 989
              __cil_tmp130 = prefix_components(p_name[i], 1);
              }
              {
#line 989
              __cil_tmp129 = prefix_components(p_name[i], 0);
#line 989
              newdirs[i] = __cil_tmp129 - __cil_tmp130;
              }
#line 991
              if (newdirs[i] < newdirs_min) {
#line 992
                newdirs_min = newdirs[i];
              }
            }
          }
          while_break___20: /* CIL Label */ ;
          }
#line 986
          i ++;
#line 995
          i = (enum nametype )0;
          {
#line 995
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 995
            if (! ((unsigned int )i <= 2U)) {
#line 995
              goto while_break___21;
            }
#line 996
            if (p_name[i]) {
#line 997
              distance_from_minimum[i] = newdirs[i] - newdirs_min;
            }
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 995
          i ++;
#line 1000
          i = best_name((char * const  *)((char **)p_name), (int const   *)((int *)distance_from_minimum));
          }
        }
      }
    }
  }
#line 1005
  if ((unsigned int )i == 3U) {
#line 1007
    if (inname) {
      {
#line 1009
      inerrno = stat_file((char const   *)inname, & instat);
      }
#line 1010
      if (inerrno) {
        {
        {
#line 1011
        maybe_reverse((char const   *)inname, inerrno, inerrno || instat.st_size == 0L);
        }
        }
      } else
#line 1010
      if ((instat.st_mode & 61440U) == file_type) {
        {
        {
#line 1011
        maybe_reverse((char const   *)inname, inerrno, inerrno || instat.st_size == 0L);
        }
        }
      }
    } else {
#line 1014
      inerrno = - 1;
    }
  } else {
    {
#line 1018
    inname = savestr((char const   *)p_name[i]);
#line 1019
    inerrno = stat_errno[i];
#line 1020
    invc = version_controlled[i];
#line 1021
    instat = st[i];
    }
  }
#line 1024
  return (retval);
}
}
#line 1030 "/tmp/0/patch-2.7.1/src/pch.c"
static int prefix_components(char *filename , int checkdirs ) 
{ 
  int count ;
  struct stat stat_buf ;
  int stat_result ;
  char *f ;

  {
#line 1032
  count = 0;
#line 1035
  f = filename + 0;
#line 1037
  if (*f) {
    {
#line 1038
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1038
      if (! *f) {
#line 1038
        goto while_break;
      }
#line 1039
      if ((int )*(f + 0) == 47) {
#line 1039
        if (! ((int )*(f + -1) == 47)) {
#line 1041
          if (checkdirs) {
            {
#line 1043
            *f = (char )'\000';
#line 1044
            stat_result = stat((char const   *)filename, & stat_buf);
#line 1045
            *f = (char )'/';
            }
#line 1046
            if (! (stat_result == 0 && (stat_buf.st_mode & 61440U) == 16384U)) {
#line 1047
              goto while_break;
            }
          }
#line 1050
          count ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1053
  return (count);
}
}
#line 1060 "/tmp/0/patch-2.7.1/src/pch.c"
static enum nametype best_name(char * const  *name , int const   *ignore ) 
{ 
  enum nametype i ;
  int components[3] ;
  int components_min ;
  size_t basename_len[3] ;
  size_t basename_len_min ;
  size_t len[3] ;
  size_t len_min ;
  int __cil_tmp14 ;

  {
#line 1064
  components_min = 2147483647;
#line 1066
  basename_len_min = 0xffffffffffffffffUL;
#line 1068
  len_min = 0xffffffffffffffffUL;
#line 1070
  i = (enum nametype )0;
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    if (! ((unsigned int )i <= 2U)) {
#line 1070
      goto while_break;
    }
#line 1071
    if ((char *)*(name + i)) {
#line 1071
      if (! ((int )*(ignore + i))) {
        {
#line 1074
        components[i] = prefix_components((char *)*(name + i), 0);
        }
#line 1075
        if (components_min < components[i]) {
#line 1076
          goto while_continue;
        }
        {
#line 1077
        components_min = components[i];
#line 1080
        basename_len[i] = base_len((char const   *)((char *)*(name + i)));
        }
#line 1081
        if (basename_len_min < basename_len[i]) {
#line 1082
          goto while_continue;
        }
        {
#line 1083
        basename_len_min = basename_len[i];
#line 1086
        len[i] = strlen((char const   *)((char *)*(name + i)));
        }
#line 1087
        if (len_min < len[i]) {
#line 1088
          goto while_continue;
        }
#line 1089
        len_min = len[i];
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  i ++;
#line 1093
  i = (enum nametype )0;
  {
#line 1093
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1093
    if (! ((unsigned int )i <= 2U)) {
#line 1093
      goto while_break___0;
    }
    {
#line 1094
    __cil_tmp14 = name_is_valid((char const   *)((char *)*(name + i)));
    }
#line 1094
    if ((char *)*(name + i)) {
#line 1094
      if (! ((int )*(ignore + i))) {
#line 1094
        if (__cil_tmp14) {
#line 1094
          if (components[i] == components_min) {
#line 1094
            if (basename_len[i] == basename_len_min) {
#line 1094
              if (len[i] == len_min) {
#line 1099
                goto while_break___0;
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1093
  i ++;
#line 1101
  return (i);
}
}
#line 1107 "/tmp/0/patch-2.7.1/src/pch.c"
static void next_intuit_at(file_offset file_pos , lin file_line ) 
{ 


  {
#line 1109
  p_base = file_pos;
#line 1110
  p_bline = file_line;
}
}
#line 1116 "/tmp/0/patch-2.7.1/src/pch.c"
static void skip_to(file_offset file_pos , lin file_line ) 
{ 
  FILE *i ;
  FILE *o ;
  int c ;
  long __cil_tmp7 ;

  {
#line 1118
  i = pfp;
#line 1119
  o = stdout;
#line 1123
  if ((unsigned int )verbosity == 2U) {
    _L: /* CIL Label */ 
#line 1123
    if (p_base < file_pos) {
      {
#line 1124
      Fseek(i, p_base, 0);
#line 1125
      say((char const   *)((char *)"The text leading up to this was:\n--------------------------\n"));
      }
      {
#line 1127
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1127
        if (! (__cil_tmp7 < file_pos)) {
#line 1127
          goto while_break;
        }
        {
#line 1129
        _IO_putc('|', o);
        }
        {
#line 1130
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1132
          c = _IO_getc(i);
          }
#line 1132
          if (c == -1) {
            {
#line 1133
            read_fatal();
            }
          }
          {
#line 1134
          _IO_putc(c, o);
          }
#line 1130
          if (! (c != 10)) {
#line 1130
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1139
      say((char const   *)((char *)"--------------------------\n"));
      }
    } else {
      {
      {
#line 1142
      Fseek(i, file_pos, 0);
      }
      }
    }
  } else
#line 1123
  if (! inname) {
#line 1123
    goto _L;
  } else {
    {
    {
#line 1142
    Fseek(i, file_pos, 0);
    }
    }
  }
#line 1143
  p_input_line = file_line - 1L;
}
}
#line 1148 "/tmp/0/patch-2.7.1/src/pch.c"
static void malformed(void) 
{ 
  char numbuf[23] ;
  char *__cil_tmp2 ;

  {
  {
#line 1151
  __cil_tmp2 = format_linenum((char *)numbuf, p_input_line);
#line 1151
  fatal((char const   *)((char *)"malformed patch at line %s: %s"), __cil_tmp2, buf);
  }
}
}
#line 1159 "/tmp/0/patch-2.7.1/src/pch.c"
static char *scan_linenum(char *s0 , lin *linenum ) 
{ 
  char *s ;
  lin n ;
  int overflow ;
  char numbuf[23] ;
  lin new_n ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1162
  n = (lin )0;
#line 1163
  overflow = 0;
#line 1166
  s = s0;
  {
#line 1166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1166
    if (! ((unsigned int )*s - 48U <= 9U)) {
#line 1166
      goto while_break;
    }
#line 1168
    new_n = 10L * n + (long )((int )*s - 48);
#line 1169
    overflow |= new_n / 10L != n;
#line 1170
    n = new_n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  s ++;
#line 1173
  if (s == s0) {
    {
#line 1174
    __cil_tmp9 = format_linenum((char *)numbuf, p_input_line);
#line 1174
    fatal((char const   *)((char *)"missing line number at line %s: %s"), __cil_tmp9,
          buf);
    }
  }
#line 1177
  if (overflow) {
    {
#line 1178
    __cil_tmp10 = format_linenum((char *)numbuf, p_input_line);
#line 1178
    fatal((char const   *)((char *)"line number %.*s is too large at line %s: %s"),
          (int )(s - s0), s0, __cil_tmp10, buf);
    }
  }
#line 1181
  *linenum = n;
#line 1182
  return (s);
}
}
#line 1189 "/tmp/0/patch-2.7.1/src/pch.c"
int another_hunk(enum diff difftype , int rev ) 
{ 
  char *s ;
  lin context ;
  size_t chars_read ;
  char numbuf0[23] ;
  char numbuf1[23] ;
  char numbuf2[23] ;
  char numbuf3[23] ;
  lin __cil_tmp10 ;
  file_offset line_beginning ;
  long __cil_tmp13 ;
  lin repl_beginning ;
  lin fillcnt ;
  lin fillsrc ;
  lin filldst ;
  int ptrn_spaces_eaten ;
  int some_context ;
  int repl_could_be_missing ;
  int ptrn_missing ;
  int repl_missing ;
  file_offset repl_backtrack_position ;
  lin repl_patch_line ;
  lin repl_context ;
  lin ptrn_prefix_context ;
  lin ptrn_suffix_context ;
  lin repl_prefix_context ;
  lin ptrn_copiable ;
  lin repl_copiable ;
  int __cil_tmp32 ;
  int tmp___168 ;
  lin __cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  lin __cil_tmp48 ;
  int __cil_tmp50 ;
  int __cil_tmp53 ;
  char *tmp___171 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  lin __cil_tmp62 ;
  int __cil_tmp65 ;
  size_t __cil_tmp66 ;
  size_t __cil_tmp68 ;
  lin tmp___173 ;
  int __cil_tmp70 ;
  lin __cil_tmp72 ;
  size_t __cil_tmp74 ;
  lin tmp___174 ;
  int __cil_tmp76 ;
  lin __cil_tmp78 ;
  size_t __cil_tmp82 ;
  size_t __cil_tmp84 ;
  lin tmp___175 ;
  int __cil_tmp89 ;
  lin __cil_tmp91 ;
  lin __cil_tmp92 ;
  char *__cil_tmp93 ;
  lin __cil_tmp94 ;
  lin __cil_tmp95 ;
  char *__cil_tmp96 ;
  lin __cil_tmp98 ;
  lin tmp___177 ;
  lin tmp___178 ;
  char *__cil_tmp102 ;
  lin __cil_tmp103 ;
  char *__cil_tmp105 ;
  char *__cil_tmp108 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  file_offset line_beginning___0 ;
  long __cil_tmp117 ;
  lin fillsrc___0 ;
  lin filldst___0 ;
  char ch ;
  int __cil_tmp122 ;
  int tmp___182 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  int __cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  lin __cil_tmp145 ;
  char *__cil_tmp148 ;
  int __cil_tmp149 ;
  lin __cil_tmp150 ;
  int __cil_tmp152 ;
  lin __cil_tmp153 ;
  int __cil_tmp155 ;
  lin __cil_tmp156 ;
  char hunk_type ;
  int i ;
  lin min ;
  lin max ;
  file_offset line_beginning___1 ;
  long __cil_tmp162 ;
  int tmp___185 ;
  int __cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  int __cil_tmp178 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  int __cil_tmp192 ;
  int __cil_tmp195 ;
  lin i___0 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;

  {
#line 1192
  context = (lin )0;
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1199
    if (! (p_end >= 0L)) {
#line 1199
      goto while_break;
    }
#line 1200
    if (p_end == p_efake) {
#line 1201
      p_end = p_bfake;
    } else {
      {
#line 1203
      free((void *)*(p_line + p_end));
      }
    }
#line 1204
    __cil_tmp10 = p_end;
#line 1204
    p_end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  p_efake = (lin )(- 1);
#line 1209
  if (p_c_function) {
    {
#line 1211
    free((void *)p_c_function);
#line 1212
    p_c_function = (char *)((void *)0);
    }
  }
#line 1215
  p_max = hunkmax;
#line 1216
  if ((unsigned int )difftype == 1U) {
    _L___188: /* CIL Label */ 
    {
#line 1217
    __cil_tmp13 = ftell(pfp);
#line 1217
    line_beginning = __cil_tmp13;
#line 1219
    repl_beginning = (lin )0;
#line 1220
    fillcnt = (lin )0;
#line 1223
    ptrn_spaces_eaten = 0;
#line 1224
    some_context = 0;
#line 1225
    repl_could_be_missing = 1;
#line 1226
    ptrn_missing = 0;
#line 1227
    repl_missing = 0;
#line 1228
    repl_backtrack_position = (file_offset )0;
#line 1232
    ptrn_prefix_context = (lin )(- 1);
#line 1233
    ptrn_suffix_context = (lin )(- 1);
#line 1234
    repl_prefix_context = (lin )(- 1);
#line 1235
    ptrn_copiable = (lin )0;
#line 1236
    repl_copiable = (lin )0;
#line 1239
    repl_context = (lin )0;
#line 1239
    repl_patch_line = repl_context;
#line 1239
    filldst = repl_patch_line;
#line 1239
    fillsrc = filldst;
#line 1241
    chars_read = get_line();
#line 1242
    __cil_tmp32 = strncmp((char const   *)buf, (char const   *)((char *)"********"),
                          (unsigned long )8);
    }
#line 1242
    if (chars_read == 0xffffffffffffffffUL) {
      _L: /* CIL Label */ 
      {
#line 1245
      next_intuit_at(line_beginning, p_input_line);
      }
#line 1246
      if (chars_read == 0xffffffffffffffffUL) {
#line 1246
        tmp___168 = - 1;
      } else {
#line 1246
        tmp___168 = 0;
      }
#line 1246
      return (tmp___168);
    } else
#line 1242
    if (chars_read <= 8UL) {
#line 1242
      goto _L;
    } else
#line 1242
    if (__cil_tmp32 != 0) {
#line 1242
      goto _L;
    }
#line 1248
    s = buf;
    {
#line 1249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1249
      if (! ((int )*s == 42)) {
#line 1249
        goto while_break___0;
      }
#line 1250
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1251
    if ((int )*s == 32) {
#line 1253
      p_c_function = s;
      {
#line 1254
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1254
        if (! ((int )*s != 10)) {
#line 1254
          goto while_break___1;
        }
#line 1255
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1256
      *s = (char )'\000';
#line 1257
      p_c_function = savestr((char const   *)p_c_function);
      }
    }
#line 1259
    p_hunk_beg = p_input_line + 1L;
    {
#line 1260
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1260
      if (! (p_end < p_max)) {
#line 1260
        goto while_break___2;
      }
      {
#line 1261
      chars_read = get_line();
      }
#line 1262
      if (chars_read == 0xffffffffffffffffUL) {
#line 1263
        return (- 1);
      }
#line 1264
      if (! chars_read) {
#line 1265
        if (repl_beginning) {
#line 1265
          if (repl_could_be_missing) {
#line 1266
            repl_missing = 1;
#line 1267
            goto hunk_done;
          }
        }
#line 1269
        if (p_max - p_end < 4L) {
          {
#line 1270
          strcpy(buf, (char const   *)((char *)"  \n"));
#line 1271
          chars_read = (size_t )3;
          }
        } else {
          {
#line 1273
          fatal((char const   *)((char *)"unexpected end of file in patch"));
          }
        }
      }
#line 1276
      p_end ++;
#line 1277
      if (p_end == hunkmax) {
        {
#line 1278
        __cil_tmp39 = pch_hunk_beg();
#line 1278
        __cil_tmp40 = format_linenum((char *)numbuf0, __cil_tmp39);
        }
        {
#line 1278
        __cil_tmp41 = format_linenum((char *)numbuf1, p_input_line);
#line 1278
        fatal((char const   *)((char *)"unterminated hunk starting at line %s; giving up at line %s: %s"),
              __cil_tmp40, __cil_tmp41, buf);
        }
      }
#line 1282
      *(p_Char + p_end) = *buf;
#line 1283
      *(p_len + p_end) = (size_t )0;
#line 1284
      *(p_line + p_end) = (char *)0;
      {
#line 1286
      if ((int )*buf == '*') {
#line 1286
        goto case_42;
      }
#line 1333
      if ((int )*buf == '-') {
#line 1333
        goto case_45;
      }
#line 1415
      if ((int )*buf == '!') {
#line 1415
        goto case_33;
      }
#line 1415
      if ((int )*buf == '+') {
#line 1415
        goto case_33;
      }
#line 1453
      if ((int )*buf == '\n') {
#line 1453
        goto case_10;
      }
#line 1453
      if ((int )*buf == '\t') {
#line 1453
        goto case_10;
      }
#line 1485
      if ((int )*buf == ' ') {
#line 1485
        goto case_32;
      }
#line 1516
      goto switch_default;
      case_42: /* CIL Label */ 
      {
#line 1287
      __cil_tmp43 = strncmp((char const   *)buf, (char const   *)((char *)"********"),
                            (unsigned long )8);
      }
#line 1287
      if (! __cil_tmp43) {
#line 1288
        if (repl_beginning) {
#line 1288
          if (repl_could_be_missing) {
#line 1289
            repl_missing = 1;
#line 1290
            goto hunk_done;
          } else {
            {
            {
#line 1293
            __cil_tmp44 = format_linenum((char *)numbuf0, p_input_line);
            }
            {
#line 1293
            fatal((char const   *)((char *)"unexpected end of hunk at line %s"), __cil_tmp44);
            }
            }
          }
        } else {
          {
          {
#line 1293
          __cil_tmp44 = format_linenum((char *)numbuf0, p_input_line);
          }
          {
#line 1293
          fatal((char const   *)((char *)"unexpected end of hunk at line %s"), __cil_tmp44);
          }
          }
        }
      }
#line 1296
      if (p_end != 0L) {
#line 1297
        if (repl_beginning) {
#line 1297
          if (repl_could_be_missing) {
#line 1298
            repl_missing = 1;
#line 1299
            goto hunk_done;
          }
        }
        {
#line 1301
        __cil_tmp45 = format_linenum((char *)numbuf0, p_input_line);
#line 1301
        fatal((char const   *)((char *)"unexpected \'***\' at line %s: %s"), __cil_tmp45,
              buf);
        }
      }
      {
#line 1304
      context = (lin )0;
#line 1305
      *(p_len + p_end) = strlen((char const   *)buf);
#line 1306
      *(p_line + p_end) = savestr((char const   *)buf);
      }
#line 1306
      if (! *(p_line + p_end)) {
#line 1307
        __cil_tmp48 = p_end;
#line 1307
        p_end --;
#line 1308
        return (- 1);
      }
#line 1310
      s = buf;
      {
#line 1310
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1310
        if (! ((int )*s && ! ((unsigned int )*s - 48U <= 9U))) {
#line 1310
          goto while_break___3;
        }

      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1310
      s ++;
#line 1312
      __cil_tmp50 = strncmp((char const   *)s, (char const   *)((char *)"0,0"), (unsigned long )3);
      }
#line 1312
      if (! __cil_tmp50) {
        {
#line 1313
        remove_prefix(s, (size_t )2);
        }
      }
      {
#line 1314
      s = scan_linenum(s, & p_first);
      }
#line 1315
      if ((int )*s == 44) {
        {
#line 1316
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1316
          if (! ((int )*s && ! ((unsigned int )*s - 48U <= 9U))) {
#line 1316
            goto while_break___4;
          }
#line 1317
          s ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1318
        scan_linenum(s, & p_ptrn_lines);
#line 1319
        p_ptrn_lines += 1L - p_first;
        }
      } else
#line 1321
      if (p_first) {
#line 1322
        p_ptrn_lines = (lin )1;
      } else {
#line 1324
        p_ptrn_lines = (lin )0;
#line 1325
        p_first = (lin )1;
      }
#line 1327
      p_max = p_ptrn_lines + 6L;
      {
#line 1328
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1328
        if (! (p_max + 1L >= hunkmax)) {
#line 1328
          goto while_break___5;
        }
        {
#line 1329
        __cil_tmp53 = grow_hunkmax();
        }
#line 1329
        if (! __cil_tmp53) {
#line 1330
          return (- 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1331
      p_max = hunkmax;
#line 1332
      goto switch_break;
      case_45: /* CIL Label */ 
#line 1334
      if ((int )*(buf + 1) != 45) {
#line 1335
        goto change_line;
      }
#line 1336
      if (ptrn_prefix_context == -1L) {
#line 1337
        ptrn_prefix_context = context;
      }
#line 1338
      ptrn_suffix_context = context;
#line 1339
      if (repl_beginning) {
        _L___172: /* CIL Label */ 
#line 1343
        if (p_end == 1L) {
#line 1347
          ptrn_missing = 1;
#line 1348
          p_end = p_ptrn_lines + 1L;
#line 1349
          ptrn_suffix_context = (lin )(- 1);
#line 1349
          ptrn_prefix_context = ptrn_suffix_context;
#line 1350
          fillsrc = p_end + 1L;
#line 1351
          filldst = (lin )1;
#line 1352
          fillcnt = p_ptrn_lines;
        } else
#line 1354
        if (! repl_beginning) {
#line 1355
          if (p_end <= p_ptrn_lines) {
#line 1355
            tmp___171 = (char *)"Premature";
          } else {
#line 1355
            tmp___171 = (char *)"Overdue";
          }
          {
#line 1355
          __cil_tmp55 = format_linenum((char *)numbuf0, p_input_line);
          }
          {
#line 1355
          __cil_tmp56 = format_linenum((char *)numbuf1, p_hunk_beg);
#line 1355
          fatal((char const   *)((char *)"%s \'---\' at line %s; check line numbers at line %s"),
                tmp___171, __cil_tmp55, __cil_tmp56);
          }
        } else
#line 1361
        if (! repl_could_be_missing) {
          {
#line 1362
          __cil_tmp57 = format_linenum((char *)numbuf0, p_input_line);
          }
          {
#line 1362
          __cil_tmp58 = format_linenum((char *)numbuf1, p_hunk_beg + repl_beginning);
#line 1362
          fatal((char const   *)((char *)"duplicate \'---\' at line %s; check line numbers at line %s"),
                __cil_tmp57, __cil_tmp58);
          }
        } else {
#line 1368
          repl_missing = 1;
#line 1369
          goto hunk_done;
        }
      } else
#line 1339
      if (p_end != (p_ptrn_lines + 1L) + (long )((int )*(p_Char + (p_end - 1L)) == 10)) {
#line 1339
        goto _L___172;
      }
      {
#line 1372
      repl_beginning = p_end;
#line 1373
      repl_backtrack_position = ftell(pfp);
#line 1374
      repl_patch_line = p_input_line;
#line 1375
      repl_context = context;
#line 1376
      *(p_len + p_end) = strlen((char const   *)buf);
#line 1377
      *(p_line + p_end) = savestr((char const   *)buf);
      }
#line 1377
      if (! *(p_line + p_end)) {
#line 1379
        __cil_tmp62 = p_end;
#line 1379
        p_end --;
#line 1380
        return (- 1);
      }
#line 1382
      *(p_Char + p_end) = (char )'=';
#line 1383
      s = buf;
      {
#line 1383
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1383
        if (! ((int )*s && ! ((unsigned int )*s - 48U <= 9U))) {
#line 1383
          goto while_break___6;
        }

      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1383
      s ++;
#line 1385
      s = scan_linenum(s, & p_newfirst);
      }
#line 1386
      if ((int )*s == 44) {
        {
#line 1388
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1390
          s ++;
#line 1390
          if (! *s) {
            {
#line 1391
            malformed();
            }
          }
#line 1388
          if (! (! ((unsigned int )*s - 48U <= 9U))) {
#line 1388
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1394
        scan_linenum(s, & p_repl_lines);
#line 1395
        p_repl_lines += 1L - p_newfirst;
        }
      } else
#line 1397
      if (p_newfirst) {
#line 1398
        p_repl_lines = (lin )1;
      } else {
#line 1401
        p_repl_lines = (lin )0;
#line 1402
        p_newfirst = (lin )1;
      }
#line 1404
      p_max = p_repl_lines + p_end;
      {
#line 1405
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1405
        if (! (p_max + 1L >= hunkmax)) {
#line 1405
          goto while_break___8;
        }
        {
#line 1406
        __cil_tmp65 = grow_hunkmax();
        }
#line 1406
        if (! __cil_tmp65) {
#line 1407
          return (- 1);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1408
      if (p_repl_lines != ptrn_copiable) {
#line 1408
        if (p_prefix_context != 0L) {
#line 1412
          repl_could_be_missing = 0;
        } else
#line 1408
        if (context != 0L) {
#line 1412
          repl_could_be_missing = 0;
        } else
#line 1408
        if (p_repl_lines != 1L) {
#line 1412
          repl_could_be_missing = 0;
        }
      }
#line 1413
      context = (lin )0;
#line 1414
      goto switch_break;
      case_33: /* CIL Label */ 
      case_43: /* CIL Label */ 
#line 1416
      repl_could_be_missing = 0;
      change_line: 
#line 1418
      s = buf + 1;
#line 1419
      __cil_tmp66 = chars_read;
#line 1419
      chars_read --;
#line 1420
      if ((int )*s == 10) {
#line 1420
        if (canonicalize) {
          {
#line 1421
          strcpy(s, (char const   *)((char *)" \n"));
#line 1422
          chars_read = (size_t )2;
          }
        }
      }
#line 1424
      if ((int )*s == 32) {
#line 1425
        s ++;
#line 1426
        __cil_tmp68 = chars_read;
#line 1426
        chars_read --;
      } else
#line 1424
      if ((int )*s == 9) {
#line 1425
        s ++;
#line 1426
        __cil_tmp68 = chars_read;
#line 1426
        chars_read --;
      } else
#line 1427
      if (repl_beginning) {
#line 1427
        if (repl_could_be_missing) {
#line 1428
          repl_missing = 1;
#line 1429
          goto hunk_done;
        }
      }
#line 1431
      if (! repl_beginning) {
#line 1433
        if (ptrn_prefix_context == -1L) {
#line 1434
          ptrn_prefix_context = context;
        }
      } else
#line 1438
      if (repl_prefix_context == -1L) {
#line 1439
        repl_prefix_context = context;
      }
      {
#line 1441
      __cil_tmp70 = incomplete_line();
      }
#line 1441
      if (repl_beginning) {
#line 1441
        tmp___173 = p_max;
      } else {
#line 1441
        tmp___173 = p_ptrn_lines;
      }
      {
#line 1441
      chars_read -= (unsigned long )((1UL < chars_read && p_end == tmp___173) && __cil_tmp70);
#line 1445
      *(p_len + p_end) = chars_read;
#line 1446
      *(p_line + p_end) = savebuf((char const   *)s, chars_read);
      }
#line 1447
      if (chars_read) {
#line 1447
        if (! *(p_line + p_end)) {
#line 1448
          __cil_tmp72 = p_end;
#line 1448
          p_end --;
#line 1449
          return (- 1);
        }
      }
#line 1451
      context = (lin )0;
#line 1452
      goto switch_break;
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1454
      s = buf;
#line 1455
      if ((int )*buf == 9) {
#line 1456
        s ++;
#line 1457
        __cil_tmp74 = chars_read;
#line 1457
        chars_read --;
      }
#line 1459
      if (repl_beginning) {
#line 1459
        if (repl_could_be_missing) {
#line 1459
          if (! ptrn_spaces_eaten) {
#line 1461
            repl_missing = 1;
#line 1462
            goto hunk_done;
          } else
#line 1459
          if ((unsigned int )difftype == 4U) {
#line 1461
            repl_missing = 1;
#line 1462
            goto hunk_done;
          }
        }
      }
      {
#line 1464
      __cil_tmp76 = incomplete_line();
      }
#line 1464
      if (repl_beginning) {
#line 1464
        tmp___174 = p_max;
      } else {
#line 1464
        tmp___174 = p_ptrn_lines;
      }
      {
#line 1464
      chars_read -= (unsigned long )((1UL < chars_read && p_end == tmp___174) && __cil_tmp76);
#line 1468
      *(p_len + p_end) = chars_read;
#line 1469
      *(p_line + p_end) = savebuf((char const   *)buf, chars_read);
      }
#line 1470
      if (chars_read) {
#line 1470
        if (! *(p_line + p_end)) {
#line 1471
          __cil_tmp78 = p_end;
#line 1471
          p_end --;
#line 1472
          return (- 1);
        }
      }
#line 1474
      if (p_end != p_ptrn_lines + 1L) {
#line 1475
        ptrn_spaces_eaten |= repl_beginning != 0L;
#line 1476
        some_context = 1;
#line 1477
        context ++;
#line 1478
        if (repl_beginning) {
#line 1479
          repl_copiable ++;
        } else {
#line 1481
          ptrn_copiable ++;
        }
#line 1482
        *(p_Char + p_end) = (char )' ';
      }
#line 1484
      goto switch_break;
      case_32: /* CIL Label */ 
#line 1486
      s = buf + 1;
#line 1487
      __cil_tmp82 = chars_read;
#line 1487
      chars_read --;
#line 1488
      if ((int )*s == 10) {
#line 1488
        if (canonicalize) {
          {
#line 1489
          strcpy(s, (char const   *)((char *)"\n"));
#line 1490
          chars_read = (size_t )2;
          }
        }
      }
#line 1492
      if ((int )*s == 32) {
#line 1493
        s ++;
#line 1494
        __cil_tmp84 = chars_read;
#line 1494
        chars_read --;
      } else
#line 1492
      if ((int )*s == 9) {
#line 1493
        s ++;
#line 1494
        __cil_tmp84 = chars_read;
#line 1494
        chars_read --;
      } else
#line 1495
      if (repl_beginning) {
#line 1495
        if (repl_could_be_missing) {
#line 1496
          repl_missing = 1;
#line 1497
          goto hunk_done;
        }
      }
#line 1499
      some_context = 1;
#line 1500
      context ++;
#line 1501
      if (repl_beginning) {
#line 1502
        repl_copiable ++;
      } else {
#line 1504
        ptrn_copiable ++;
      }
      {
#line 1505
      __cil_tmp89 = incomplete_line();
      }
#line 1505
      if (repl_beginning) {
#line 1505
        tmp___175 = p_max;
      } else {
#line 1505
        tmp___175 = p_ptrn_lines;
      }
      {
#line 1505
      chars_read -= (unsigned long )((1UL < chars_read && p_end == tmp___175) && __cil_tmp89);
#line 1509
      *(p_len + p_end) = chars_read;
#line 1510
      *(p_line + p_end) = savebuf((char const   *)s, chars_read);
      }
#line 1511
      if (chars_read) {
#line 1511
        if (! *(p_line + p_end)) {
#line 1512
          __cil_tmp91 = p_end;
#line 1512
          p_end --;
#line 1513
          return (- 1);
        }
      }
#line 1515
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1517
      if (repl_beginning) {
#line 1517
        if (repl_could_be_missing) {
#line 1518
          repl_missing = 1;
#line 1519
          goto hunk_done;
        }
      }
      {
#line 1521
      malformed();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    hunk_done: 
#line 1526
    if (p_end >= 0L) {
#line 1526
      if (! repl_beginning) {
        {
#line 1527
        __cil_tmp92 = pch_hunk_beg();
#line 1527
        __cil_tmp93 = format_linenum((char *)numbuf0, __cil_tmp92);
#line 1527
        fatal((char const   *)((char *)"no \'---\' found in patch at line %s"), __cil_tmp93);
        }
      }
    }
#line 1530
    if (repl_missing) {
#line 1533
      p_input_line = repl_patch_line;
#line 1534
      context = repl_context;
#line 1535
      __cil_tmp94 = p_end;
#line 1535
      p_end --;
      {
#line 1535
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1535
        if (! (p_end > repl_beginning)) {
#line 1535
          goto while_break___9;
        }
        {
#line 1536
        free((void *)*(p_line + p_end));
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1535
      __cil_tmp95 = p_end;
#line 1535
      p_end --;
#line 1537
      Fseek(pfp, repl_backtrack_position, 0);
#line 1541
      fillsrc = (lin )1;
#line 1542
      filldst = repl_beginning + 1L;
#line 1543
      fillcnt = p_repl_lines;
#line 1544
      p_end = p_max;
      }
    } else
#line 1546
    if (! ptrn_missing) {
#line 1546
      if (ptrn_copiable != repl_copiable) {
        {
#line 1547
        __cil_tmp96 = format_linenum((char *)numbuf0, p_hunk_beg);
#line 1547
        fatal((char const   *)((char *)"context mangled in hunk at line %s"), __cil_tmp96);
        }
      } else {
#line 1546
        goto _L___176;
      }
    } else
    _L___176: /* CIL Label */ 
#line 1549
    if (! some_context) {
#line 1549
      if (fillcnt == 1L) {
        {
#line 1552
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1552
          if (! (filldst < p_end)) {
#line 1552
            goto while_break___10;
          }
#line 1553
          *(p_line + filldst) = *(p_line + (filldst + 1L));
#line 1554
          *(p_Char + filldst) = *(p_Char + (filldst + 1L));
#line 1555
          *(p_len + filldst) = *(p_len + (filldst + 1L));
#line 1556
          filldst ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1561
        __cil_tmp98 = p_end;
#line 1561
        p_end --;
#line 1562
        p_first ++;
#line 1563
        fillcnt = (lin )0;
#line 1564
        p_ptrn_lines = (lin )0;
      }
    }
#line 1567
    if (repl_prefix_context == -1L || (ptrn_prefix_context != -1L && ptrn_prefix_context < repl_prefix_context)) {
#line 1567
      tmp___177 = ptrn_prefix_context;
    } else {
#line 1567
      tmp___177 = repl_prefix_context;
    }
#line 1567
    p_prefix_context = tmp___177;
#line 1571
    if (ptrn_suffix_context != -1L && ptrn_suffix_context < context) {
#line 1571
      tmp___178 = ptrn_suffix_context;
    } else {
#line 1571
      tmp___178 = context;
    }
#line 1571
    p_suffix_context = tmp___178;
#line 1574
    if (p_prefix_context == -1L) {
      {
      {
#line 1575
      __cil_tmp102 = format_linenum((char *)numbuf0, p_hunk_beg);
      }
      {
#line 1575
      fatal((char const   *)((char *)"replacement text or line numbers mangled in hunk at line %s"),
            __cil_tmp102);
      }
      }
    } else
#line 1574
    if (p_suffix_context == -1L) {
      {
      {
#line 1575
      __cil_tmp102 = format_linenum((char *)numbuf0, p_hunk_beg);
      }
      {
#line 1575
      fatal((char const   *)((char *)"replacement text or line numbers mangled in hunk at line %s"),
            __cil_tmp102);
      }
      }
    }
#line 1578
    if ((unsigned int )difftype == 1U) {
#line 1578
      if (fillcnt) {
        _L___179: /* CIL Label */ 
#line 1582
        if ((unsigned int )verbosity == 2U) {
          {
#line 1583
          say((char const   *)((char *)"%s\n%s\n%s\n"), (char *)"(Fascinating -- this is really a new-style context diff but without",
              (char *)"the telltale extra asterisks on the *** line that usually indicate",
              (char *)"the new style...)");
          }
        }
#line 1587
        difftype = (enum diff )4;
#line 1587
        diff_type = difftype;
      } else
#line 1578
      if (p_first > 1L) {
#line 1578
        if (p_prefix_context + p_suffix_context < ptrn_copiable) {
#line 1578
          goto _L___179;
        }
      }
    }
#line 1591
    if (fillcnt) {
#line 1592
      p_bfake = filldst;
#line 1593
      p_efake = (filldst + fillcnt) - 1L;
      {
#line 1594
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1594
        if (! (__cil_tmp103 > 0L)) {
#line 1594
          goto while_break___11;
        }
        {
#line 1595
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1595
          if (! ((fillsrc <= p_end && fillsrc != repl_beginning) && (int )*(p_Char + fillsrc) != 32)) {
#line 1595
            goto while_break___12;
          }
#line 1597
          fillsrc ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1598
        if (p_end < fillsrc) {
          {
          {
#line 1600
          __cil_tmp105 = format_linenum((char *)numbuf0, p_hunk_beg);
          }
          {
#line 1600
          fatal((char const   *)((char *)"replacement text or line numbers mangled in hunk at line %s"),
                __cil_tmp105);
          }
          }
        } else
#line 1598
        if (fillsrc == repl_beginning) {
          {
          {
#line 1600
          __cil_tmp105 = format_linenum((char *)numbuf0, p_hunk_beg);
          }
          {
#line 1600
          fatal((char const   *)((char *)"replacement text or line numbers mangled in hunk at line %s"),
                __cil_tmp105);
          }
          }
        }
#line 1603
        *(p_line + filldst) = *(p_line + fillsrc);
#line 1604
        *(p_Char + filldst) = *(p_Char + fillsrc);
#line 1605
        *(p_len + filldst) = *(p_len + fillsrc);
#line 1606
        fillsrc ++;
#line 1606
        filldst ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1608
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1608
        if (! (fillsrc <= p_end && fillsrc != repl_beginning)) {
#line 1608
          goto while_break___13;
        }
#line 1610
        if ((int )*(p_Char + fillsrc) == 32) {
          {
#line 1611
          __cil_tmp108 = format_linenum((char *)numbuf0, p_hunk_beg);
#line 1611
          fatal((char const   *)((char *)"replacement text or line numbers mangled in hunk at line %s"),
                __cil_tmp108);
          }
        }
#line 1613
        fillsrc ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1615
      if (debug & 64) {
        {
#line 1616
        __cil_tmp110 = format_linenum((char *)numbuf0, fillsrc);
        }
        {
#line 1616
        __cil_tmp111 = format_linenum((char *)numbuf1, filldst);
        }
        {
#line 1616
        __cil_tmp112 = format_linenum((char *)numbuf2, repl_beginning);
        }
        {
#line 1616
        __cil_tmp113 = format_linenum((char *)numbuf3, p_end + 1L);
#line 1616
        printf((char const   *)((char *)"fillsrc %s, filldst %s, rb %s, e+1 %s\n"),
               __cil_tmp110, __cil_tmp111, __cil_tmp112, __cil_tmp113);
        }
      }
    }
  } else
#line 1216
  if ((unsigned int )difftype == 4U) {
#line 1216
    goto _L___188;
  } else
#line 1625
  if ((unsigned int )difftype == 5U) {
    {
#line 1626
    __cil_tmp117 = ftell(pfp);
#line 1626
    line_beginning___0 = __cil_tmp117;
#line 1629
    ch = (char )'\000';
#line 1631
    chars_read = get_line();
#line 1632
    __cil_tmp122 = strncmp((char const   *)buf, (char const   *)((char *)"@@ -"),
                           (unsigned long )4);
    }
#line 1632
    if (chars_read == 0xffffffffffffffffUL) {
      _L___183: /* CIL Label */ 
      {
#line 1635
      next_intuit_at(line_beginning___0, p_input_line);
      }
#line 1636
      if (chars_read == 0xffffffffffffffffUL) {
#line 1636
        tmp___182 = - 1;
      } else {
#line 1636
        tmp___182 = 0;
      }
#line 1636
      return (tmp___182);
    } else
#line 1632
    if (chars_read <= 4UL) {
#line 1632
      goto _L___183;
    } else
#line 1632
    if (__cil_tmp122 != 0) {
#line 1632
      goto _L___183;
    }
    {
#line 1638
    s = scan_linenum(buf + 4, & p_first);
    }
#line 1639
    if ((int )*s == 44) {
      {
#line 1640
      s = scan_linenum(s + 1, & p_ptrn_lines);
      }
    } else {
#line 1642
      p_ptrn_lines = (lin )1;
    }
#line 1643
    if ((int )*s == 32) {
#line 1643
      s ++;
    }
#line 1644
    if ((int )*s != 43) {
      {
#line 1645
      malformed();
      }
    }
    {
#line 1646
    s = scan_linenum(s + 1, & p_newfirst);
    }
#line 1647
    if ((int )*s == 44) {
      {
#line 1648
      s = scan_linenum(s + 1, & p_repl_lines);
      }
    } else {
#line 1650
      p_repl_lines = (lin )1;
    }
#line 1651
    if ((int )*s == 32) {
#line 1651
      s ++;
    }
#line 1652
    __cil_tmp130 = s;
#line 1652
    s ++;
#line 1652
    if ((int )*__cil_tmp130 != 64) {
      {
#line 1653
      malformed();
      }
    }
#line 1654
    __cil_tmp131 = s;
#line 1654
    s ++;
#line 1654
    if ((int )*__cil_tmp131 == 64) {
#line 1654
      if ((int )*s == 32) {
#line 1654
        if ((int )*s != 0) {
#line 1656
          p_c_function = s;
          {
#line 1657
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1657
            if (! ((int )*s != 10)) {
#line 1657
              goto while_break___14;
            }
#line 1658
            s ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 1659
          *s = (char )'\000';
#line 1660
          p_c_function = savestr((char const   *)p_c_function);
          }
        }
      }
    }
#line 1662
    if (! p_ptrn_lines) {
#line 1663
      p_first ++;
    }
#line 1664
    if (! p_repl_lines) {
#line 1665
      p_newfirst ++;
    }
#line 1666
    p_max = (p_ptrn_lines + p_repl_lines) + 1L;
    {
#line 1667
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1667
      if (! (p_max + 1L >= hunkmax)) {
#line 1667
        goto while_break___15;
      }
      {
#line 1668
      __cil_tmp136 = grow_hunkmax();
      }
#line 1668
      if (! __cil_tmp136) {
#line 1669
        return (- 1);
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 1670
    fillsrc___0 = (lin )1;
#line 1671
    filldst___0 = fillsrc___0 + p_ptrn_lines;
#line 1672
    p_end = filldst___0 + p_repl_lines;
#line 1673
    __cil_tmp137 = format_linenum((char *)numbuf0, p_first);
    }
    {
#line 1673
    __cil_tmp138 = format_linenum((char *)numbuf1, (p_first + p_ptrn_lines) - 1L);
#line 1673
    sprintf(buf, (char const   *)((char *)"*** %s,%s ****\n"), __cil_tmp137, __cil_tmp138);
#line 1676
    *(p_len + 0) = strlen((char const   *)buf);
#line 1677
    *(p_line + 0) = savestr((char const   *)buf);
    }
#line 1677
    if (! *(p_line + 0)) {
#line 1678
      p_end = (lin )(- 1);
#line 1679
      return (- 1);
    }
    {
#line 1681
    *(p_Char + 0) = (char )'*';
#line 1682
    __cil_tmp141 = format_linenum((char *)numbuf0, p_newfirst);
    }
    {
#line 1682
    __cil_tmp142 = format_linenum((char *)numbuf1, (p_newfirst + p_repl_lines) - 1L);
#line 1682
    sprintf(buf, (char const   *)((char *)"--- %s,%s ----\n"), __cil_tmp141, __cil_tmp142);
#line 1685
    *(p_len + filldst___0) = strlen((char const   *)buf);
#line 1686
    *(p_line + filldst___0) = savestr((char const   *)buf);
    }
#line 1686
    if (! *(p_line + filldst___0)) {
#line 1687
      p_end = (lin )0;
#line 1688
      return (- 1);
    }
#line 1690
    __cil_tmp145 = filldst___0;
#line 1690
    filldst___0 ++;
#line 1690
    *(p_Char + __cil_tmp145) = (char )'=';
#line 1691
    p_prefix_context = (lin )(- 1);
#line 1692
    p_hunk_beg = p_input_line + 1L;
    {
#line 1693
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1693
      if (! (fillsrc___0 <= p_ptrn_lines || filldst___0 <= p_end)) {
#line 1693
        goto while_break___16;
      }
      {
#line 1694
      chars_read = get_line();
      }
#line 1695
      if (! chars_read) {
#line 1696
        if (p_max - filldst___0 < 3L) {
          {
#line 1697
          strcpy(buf, (char const   *)((char *)" \n"));
#line 1698
          chars_read = (size_t )2;
          }
        } else {
          {
#line 1700
          fatal((char const   *)((char *)"unexpected end of file in patch"));
          }
        }
      }
#line 1703
      if (chars_read == 0xffffffffffffffffUL) {
#line 1704
        s = (char *)0;
      } else
#line 1705
      if ((int )*buf == 9) {
        {
#line 1706
        ch = (char )' ';
        {
#line 1707
        s = savebuf((char const   *)buf, chars_read);
        }
        }
      } else
#line 1705
      if ((int )*buf == 10) {
        {
#line 1706
        ch = (char )' ';
        {
#line 1707
        s = savebuf((char const   *)buf, chars_read);
        }
        }
      } else {
        {
#line 1710
        ch = *buf;
#line 1711
        chars_read --;
#line 1711
        __cil_tmp148 = savebuf((char const   *)(buf + 1), chars_read);
#line 1711
        s = __cil_tmp148;
        }
      }
#line 1713
      if (chars_read) {
#line 1713
        if (! s) {
          {
#line 1715
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1715
            if (! (filldst___0 > p_ptrn_lines)) {
#line 1715
              goto while_break___17;
            }
            {
#line 1716
            free((void *)*(p_line + filldst___0));
            }
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1717
          p_end = fillsrc___0 - 1L;
#line 1718
          return (- 1);
        }
      }
      {
#line 1721
      if ((int )ch == '-') {
#line 1721
        goto case_45___0;
      }
#line 1732
      if ((int )ch == '=') {
#line 1732
        goto case_61;
      }
#line 1735
      if ((int )ch == ' ') {
#line 1735
        goto case_32___0;
      }
#line 1756
      if ((int )ch == '+') {
#line 1756
        goto case_43___0;
      }
#line 1769
      goto switch_default___0;
      case_45___0: /* CIL Label */ 
#line 1722
      if (fillsrc___0 > p_ptrn_lines) {
        {
#line 1723
        free((void *)s);
#line 1724
        p_end = filldst___0 - 1L;
#line 1725
        malformed();
        }
      }
      {
#line 1727
      __cil_tmp149 = incomplete_line();
      }
#line 1727
      chars_read -= (unsigned long )(fillsrc___0 == p_ptrn_lines && __cil_tmp149);
#line 1728
      *(p_Char + fillsrc___0) = ch;
#line 1729
      *(p_line + fillsrc___0) = s;
#line 1730
      __cil_tmp150 = fillsrc___0;
#line 1730
      fillsrc___0 ++;
#line 1730
      *(p_len + __cil_tmp150) = chars_read;
#line 1731
      goto switch_break___0;
      case_61: /* CIL Label */ 
#line 1733
      ch = (char )' ';
      case_32___0: /* CIL Label */ 
#line 1736
      if (fillsrc___0 > p_ptrn_lines) {
        {
#line 1737
        free((void *)s);
        }
        {
#line 1738
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 1738
          if (! (filldst___0 > p_ptrn_lines)) {
#line 1738
            goto while_break___18;
          }
          {
#line 1739
          free((void *)*(p_line + filldst___0));
          }
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 1740
        p_end = fillsrc___0 - 1L;
#line 1741
        malformed();
        }
      }
      {
#line 1743
      context ++;
#line 1744
      __cil_tmp152 = incomplete_line();
      }
      {
#line 1744
      chars_read -= (unsigned long )(fillsrc___0 == p_ptrn_lines && __cil_tmp152);
#line 1745
      *(p_Char + fillsrc___0) = ch;
#line 1746
      *(p_line + fillsrc___0) = s;
#line 1747
      __cil_tmp153 = fillsrc___0;
#line 1747
      fillsrc___0 ++;
#line 1747
      *(p_len + __cil_tmp153) = chars_read;
#line 1748
      s = savebuf((char const   *)s, chars_read);
      }
#line 1749
      if (chars_read) {
#line 1749
        if (! s) {
          {
#line 1750
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 1750
            if (! (filldst___0 > p_ptrn_lines)) {
#line 1750
              goto while_break___19;
            }
            {
#line 1751
            free((void *)*(p_line + filldst___0));
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 1752
          p_end = fillsrc___0 - 1L;
#line 1753
          return (- 1);
        }
      }
      case_43___0: /* CIL Label */ 
#line 1757
      if (filldst___0 > p_end) {
        {
#line 1758
        free((void *)s);
        }
        {
#line 1759
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 1759
          if (! (filldst___0 > p_ptrn_lines)) {
#line 1759
            goto while_break___20;
          }
          {
#line 1760
          free((void *)*(p_line + filldst___0));
          }
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 1761
        p_end = fillsrc___0 - 1L;
#line 1762
        malformed();
        }
      }
      {
#line 1764
      __cil_tmp155 = incomplete_line();
      }
#line 1764
      chars_read -= (unsigned long )(filldst___0 == p_end && __cil_tmp155);
#line 1765
      *(p_Char + filldst___0) = ch;
#line 1766
      *(p_line + filldst___0) = s;
#line 1767
      __cil_tmp156 = filldst___0;
#line 1767
      filldst___0 ++;
#line 1767
      *(p_len + __cil_tmp156) = chars_read;
#line 1768
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1770
      p_end = filldst___0;
      {
#line 1771
      malformed();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 1773
      if ((int )ch != 32) {
#line 1774
        if (p_prefix_context == -1L) {
#line 1775
          p_prefix_context = context;
        }
#line 1776
        context = (lin )0;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1779
    if (p_prefix_context == -1L) {
      {
#line 1780
      malformed();
      }
    }
#line 1781
    p_suffix_context = context;
  } else {
    {
#line 1787
    __cil_tmp162 = ftell(pfp);
#line 1787
    line_beginning___1 = __cil_tmp162;
#line 1789
    p_suffix_context = (lin )0;
#line 1789
    p_prefix_context = p_suffix_context;
#line 1790
    chars_read = get_line();
    }
#line 1791
    if (chars_read == 0xffffffffffffffffUL) {
      _L___186: /* CIL Label */ 
      {
#line 1792
      next_intuit_at(line_beginning___1, p_input_line);
      }
#line 1793
      if (chars_read == 0xffffffffffffffffUL) {
#line 1793
        tmp___185 = - 1;
      } else {
#line 1793
        tmp___185 = 0;
      }
#line 1793
      return (tmp___185);
    } else
#line 1791
    if (! chars_read) {
#line 1791
      goto _L___186;
    } else
#line 1791
    if (! ((unsigned int )*buf - 48U <= 9U)) {
#line 1791
      goto _L___186;
    }
    {
#line 1795
    s = scan_linenum(buf, & p_first);
    }
#line 1796
    if ((int )*s == 44) {
      {
#line 1797
      s = scan_linenum(s + 1, & p_ptrn_lines);
#line 1798
      p_ptrn_lines += 1L - p_first;
      }
    } else {
#line 1801
      p_ptrn_lines = (lin )((int )*s != 97);
    }
#line 1802
    hunk_type = *s;
#line 1803
    if ((int )hunk_type == 97) {
#line 1804
      p_first ++;
    }
    {
#line 1805
    s = scan_linenum(s + 1, & min);
    }
#line 1806
    if ((int )*s == 44) {
      {
#line 1807
      scan_linenum(s + 1, & max);
      }
    } else {
#line 1809
      max = min;
    }
#line 1810
    if ((int )hunk_type == 100) {
#line 1811
      min ++;
    }
#line 1812
    p_end = (((p_ptrn_lines + 1L) + max) - min) + 1L;
    {
#line 1813
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1813
      if (! (p_end + 1L >= hunkmax)) {
#line 1813
        goto while_break___21;
      }
      {
#line 1814
      __cil_tmp170 = grow_hunkmax();
      }
#line 1814
      if (! __cil_tmp170) {
#line 1816
        p_end = (lin )(- 1);
#line 1817
        return (- 1);
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1819
    p_newfirst = min;
#line 1820
    p_repl_lines = (max - min) + 1L;
#line 1821
    __cil_tmp171 = format_linenum((char *)numbuf0, p_first);
    }
    {
#line 1821
    __cil_tmp172 = format_linenum((char *)numbuf1, (p_first + p_ptrn_lines) - 1L);
#line 1821
    sprintf(buf, (char const   *)((char *)"*** %s,%s\n"), __cil_tmp171, __cil_tmp172);
#line 1824
    *(p_len + 0) = strlen((char const   *)buf);
#line 1825
    *(p_line + 0) = savestr((char const   *)buf);
    }
#line 1825
    if (! *(p_line + 0)) {
#line 1826
      p_end = (lin )(- 1);
#line 1827
      return (- 1);
    }
#line 1829
    *(p_Char + 0) = (char )'*';
#line 1830
    i = 1;
    {
#line 1830
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1830
      if (! ((long )i <= p_ptrn_lines)) {
#line 1830
        goto while_break___22;
      }
      {
#line 1831
      chars_read = get_line();
      }
#line 1832
      if (chars_read == 0xffffffffffffffffUL) {
#line 1834
        p_end = (lin )(i - 1);
#line 1835
        return (- 1);
      }
#line 1837
      if (! chars_read) {
        {
#line 1838
        __cil_tmp176 = format_linenum((char *)numbuf0, p_input_line);
#line 1838
        fatal((char const   *)((char *)"unexpected end of file in patch at line %s"),
              __cil_tmp176);
        }
      }
#line 1840
      if ((int )*(buf + 0) != 60) {
        {
        {
#line 1841
        __cil_tmp177 = format_linenum((char *)numbuf0, p_input_line);
        }
        {
#line 1841
        fatal((char const   *)((char *)"\'<\' expected at line %s of patch"), __cil_tmp177);
        }
        }
      } else
#line 1840
      if ((int )*(buf + 1) != 32) {
#line 1840
        if ((int )*(buf + 1) != 9) {
          {
          {
#line 1841
          __cil_tmp177 = format_linenum((char *)numbuf0, p_input_line);
          }
          {
#line 1841
          fatal((char const   *)((char *)"\'<\' expected at line %s of patch"), __cil_tmp177);
          }
          }
        }
      }
      {
#line 1843
      __cil_tmp178 = incomplete_line();
      }
      {
#line 1843
      chars_read -= (unsigned long )(2 + ((long )i == p_ptrn_lines && __cil_tmp178));
#line 1844
      *(p_len + i) = chars_read;
#line 1845
      *(p_line + i) = savebuf((char const   *)(buf + 2), chars_read);
      }
#line 1846
      if (chars_read) {
#line 1846
        if (! *(p_line + i)) {
#line 1847
          p_end = (lin )(i - 1);
#line 1848
          return (- 1);
        }
      }
#line 1850
      *(p_Char + i) = (char )'-';
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1830
    i ++;
#line 1852
    if ((int )hunk_type == 99) {
      {
#line 1853
      chars_read = get_line();
      }
#line 1854
      if (chars_read == 0xffffffffffffffffUL) {
#line 1856
        p_end = (lin )(i - 1);
#line 1857
        return (- 1);
      }
#line 1859
      if (! chars_read) {
        {
#line 1860
        __cil_tmp182 = format_linenum((char *)numbuf0, p_input_line);
#line 1860
        fatal((char const   *)((char *)"unexpected end of file in patch at line %s"),
              __cil_tmp182);
        }
      }
#line 1862
      if ((int )*buf != 45) {
        {
#line 1863
        __cil_tmp183 = format_linenum((char *)numbuf0, p_input_line);
#line 1863
        fatal((char const   *)((char *)"\'---\' expected at line %s of patch"), __cil_tmp183);
        }
      }
    }
    {
#line 1866
    __cil_tmp184 = format_linenum((char *)numbuf0, min);
    }
    {
#line 1866
    __cil_tmp185 = format_linenum((char *)numbuf1, max);
#line 1866
    sprintf(buf, (char const   *)((char *)"--- %s,%s\n"), __cil_tmp184, __cil_tmp185);
#line 1869
    *(p_len + i) = strlen((char const   *)buf);
#line 1870
    *(p_line + i) = savestr((char const   *)buf);
    }
#line 1870
    if (! *(p_line + i)) {
#line 1871
      p_end = (lin )(i - 1);
#line 1872
      return (- 1);
    }
#line 1874
    *(p_Char + i) = (char )'=';
#line 1875
    i ++;
    {
#line 1875
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1875
      if (! ((long )i <= p_end)) {
#line 1875
        goto while_break___23;
      }
      {
#line 1876
      chars_read = get_line();
      }
#line 1877
      if (chars_read == 0xffffffffffffffffUL) {
#line 1879
        p_end = (lin )(i - 1);
#line 1880
        return (- 1);
      }
#line 1882
      if (! chars_read) {
        {
#line 1883
        __cil_tmp190 = format_linenum((char *)numbuf0, p_input_line);
#line 1883
        fatal((char const   *)((char *)"unexpected end of file in patch at line %s"),
              __cil_tmp190);
        }
      }
#line 1885
      if ((int )*(buf + 0) != 62) {
        {
        {
#line 1886
        __cil_tmp191 = format_linenum((char *)numbuf0, p_input_line);
        }
        {
#line 1886
        fatal((char const   *)((char *)"\'>\' expected at line %s of patch"), __cil_tmp191);
        }
        }
      } else
#line 1885
      if ((int )*(buf + 1) != 32) {
#line 1885
        if ((int )*(buf + 1) != 9) {
          {
          {
#line 1886
          __cil_tmp191 = format_linenum((char *)numbuf0, p_input_line);
          }
          {
#line 1886
          fatal((char const   *)((char *)"\'>\' expected at line %s of patch"), __cil_tmp191);
          }
          }
        }
      }
      {
#line 1888
      __cil_tmp192 = incomplete_line();
      }
      {
#line 1888
      chars_read -= (unsigned long )(2 + ((long )i == p_end && __cil_tmp192));
#line 1889
      *(p_len + i) = chars_read;
#line 1890
      *(p_line + i) = savebuf((char const   *)(buf + 2), chars_read);
      }
#line 1891
      if (chars_read) {
#line 1891
        if (! *(p_line + i)) {
#line 1892
          p_end = (lin )(i - 1);
#line 1893
          return (- 1);
        }
      }
#line 1895
      *(p_Char + i) = (char )'+';
    }
    while_break___23: /* CIL Label */ ;
    }
#line 1875
    i ++;
  }
#line 1898
  if (rev) {
    {
#line 1899
    __cil_tmp195 = pch_swap();
    }
#line 1899
    if (! __cil_tmp195) {
      {
#line 1900
      say((char const   *)((char *)"Not enough memory to swap next hunk!\n"));
      }
    }
  }
#line 1902
  *(p_Char + (p_end + 1L)) = (char )'^';
#line 1903
  if (debug & 2) {
#line 1906
    i___0 = (lin )0;
    {
#line 1906
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1906
      if (! (i___0 <= p_end + 1L)) {
#line 1906
        goto while_break___24;
      }
      {
#line 1907
      __cil_tmp198 = format_linenum((char *)numbuf0, i___0);
#line 1907
      fprintf(stderr, (char const   *)((char *)"%s %c"), __cil_tmp198, (int )*(p_Char + i___0));
      }
#line 1910
      if ((int )*(p_Char + i___0) == 42) {
        {
#line 1911
        __cil_tmp199 = format_linenum((char *)numbuf0, p_first);
        }
        {
#line 1911
        __cil_tmp200 = format_linenum((char *)numbuf1, p_ptrn_lines);
#line 1911
        fprintf(stderr, (char const   *)((char *)" %s,%s\n"), __cil_tmp199, __cil_tmp200);
        }
      } else
#line 1914
      if ((int )*(p_Char + i___0) == 61) {
        {
#line 1915
        __cil_tmp201 = format_linenum((char *)numbuf0, p_newfirst);
        }
        {
#line 1915
        __cil_tmp202 = format_linenum((char *)numbuf1, p_repl_lines);
#line 1915
        fprintf(stderr, (char const   *)((char *)" %s,%s\n"), __cil_tmp201, __cil_tmp202);
        }
      } else
#line 1918
      if ((int )*(p_Char + i___0) != 94) {
        {
#line 1920
        fputs((char const   *)((char *)" |"), stderr);
#line 1921
        pch_write_line(i___0, stderr);
        }
      } else {
        {
#line 1924
        fputc('\n', stderr);
        }
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 1906
    i___0 ++;
#line 1926
    fflush(stderr);
    }
  }
#line 1928
  return (1);
}
}
#line 1932 "/tmp/0/patch-2.7.1/src/pch.c"
static size_t get_line(void) 
{ 
  size_t __cil_tmp1 ;

  {
  {
#line 1934
  __cil_tmp1 = pget_line(p_indent, p_rfc934_nesting, p_strip_trailing_cr, p_pass_comments_through);
  }
#line 1934
  return (__cil_tmp1);
}
}
#line 1950 "/tmp/0/patch-2.7.1/src/pch.c"
static size_t pget_line(size_t indent , int rfc934_nesting , int strip_trailing_cr ,
                        int pass_comments_through ) 
{ 
  FILE *fp ;
  int c ;
  size_t i ;
  char *b ;
  size_t s ;
  int __cil_tmp11 ;
  void *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 1953
  fp = pfp;
  {
#line 1959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1961
    i = (size_t )0;
    {
#line 1962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1962
      if (! 1) {
#line 1962
        goto while_break___0;
      }
      {
#line 1964
      c = _IO_getc(fp);
      }
#line 1965
      if (c == -1) {
        {
#line 1967
        __cil_tmp11 = ferror(fp);
        }
#line 1967
        if (__cil_tmp11) {
          {
#line 1968
          read_fatal();
          }
        }
#line 1969
        return ((size_t )0);
      }
#line 1971
      if (indent <= i) {
#line 1972
        goto while_break___0;
      }
#line 1973
      if (c == 32) {
#line 1974
        i ++;
      } else
#line 1973
      if (c == 88) {
#line 1974
        i ++;
      } else
#line 1975
      if (c == 9) {
#line 1976
        i = (i + 8UL) & 0xfffffffffffffff8UL;
      } else {
#line 1978
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1981
    i = (size_t )0;
#line 1982
    b = buf;
    {
#line 1984
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1984
      if (! (c == 45 && 0 <= rfc934_nesting)) {
#line 1984
        goto while_break___1;
      }
      {
#line 1986
      c = _IO_getc(fp);
      }
#line 1987
      if (c == -1) {
#line 1988
        goto patch_ends_in_middle_of_line;
      }
#line 1989
      if (c != 32) {
#line 1991
        i = (size_t )1;
#line 1992
        *(b + 0) = (char )'-';
#line 1993
        goto while_break___1;
      }
      {
#line 1995
      c = _IO_getc(fp);
      }
#line 1996
      if (c == -1) {
#line 1997
        goto patch_ends_in_middle_of_line;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2000
    s = bufsize;
    {
#line 2002
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2002
      if (! 1) {
#line 2002
        goto while_break___2;
      }
#line 2004
      if (i == s - 1UL) {
        {
#line 2006
        s *= (unsigned long )2;
#line 2007
        __cil_tmp15 = realloc((void *)b, s);
#line 2007
        b = (char *)__cil_tmp15;
        }
#line 2008
        if (! b) {
#line 2010
          if (! using_plan_a) {
            {
#line 2011
            xalloc_die();
            }
          }
#line 2012
          return ((size_t )(- 1));
        }
#line 2014
        buf = b;
#line 2015
        bufsize = s;
      }
#line 2017
      __cil_tmp16 = i;
#line 2017
      i ++;
#line 2017
      *(b + __cil_tmp16) = (char )c;
#line 2018
      if (c == 10) {
#line 2019
        goto while_break___2;
      }
      {
#line 2020
      c = _IO_getc(fp);
      }
#line 2021
      if (c == -1) {
#line 2022
        goto patch_ends_in_middle_of_line;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2025
    p_input_line ++;
#line 1959
    if (! ((int )*b == 35 && ! pass_comments_through)) {
#line 1959
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2029
  if (strip_trailing_cr) {
#line 2029
    if (2UL <= i) {
#line 2029
      if ((int )*(b + (i - 2UL)) == 13) {
#line 2030
        __cil_tmp19 = i;
#line 2030
        i --;
#line 2030
        *(b + (__cil_tmp19 - 2UL)) = (char )'\n';
      }
    }
  }
#line 2031
  *(b + i) = (char )'\000';
#line 2032
  return (i);
  patch_ends_in_middle_of_line: 
  {
#line 2035
  __cil_tmp20 = ferror(fp);
  }
#line 2035
  if (__cil_tmp20) {
    {
#line 2036
    read_fatal();
    }
  }
  {
#line 2037
  say((char const   *)((char *)"patch unexpectedly ends in middle of line\n"));
  }
#line 2038
  return ((size_t )0);
}
}
#line 2042 "/tmp/0/patch-2.7.1/src/pch.c"
static int incomplete_line(void) 
{ 
  FILE *fp ;
  int c ;
  file_offset line_beginning ;
  long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 2044
  fp = pfp;
#line 2046
  __cil_tmp4 = ftell(fp);
#line 2046
  line_beginning = __cil_tmp4;
#line 2048
  __cil_tmp5 = _IO_getc(fp);
  }
#line 2048
  if (__cil_tmp5 == 92) {
    {
#line 2050
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2050
      if (! (c != 10 && c != -1)) {
#line 2050
        goto while_break;
      }

    }
    while_break: /* CIL Label */ ;
    }
#line 2052
    return (1);
  } else {
    {
#line 2057
    Fseek(pfp, line_beginning, 0);
    }
#line 2058
    return (0);
  }
}
}
#line 2065 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_swap(void) 
{ 
  char **tp_line ;
  size_t *tp_len ;
  char *tp_char ;
  lin i ;
  lin n ;
  int blankline ;
  char *s ;
  lin __cil_tmp9 ;
  lin __cil_tmp10 ;
  lin __cil_tmp16 ;
  lin __cil_tmp17 ;

  {
  {
#line 2072
  blankline = 0;
#line 2075
  i = p_first;
#line 2076
  p_first = p_newfirst;
#line 2077
  p_newfirst = i;
#line 2081
  tp_line = p_line;
#line 2082
  tp_len = p_len;
#line 2083
  tp_char = p_Char;
#line 2084
  p_line = (char **)0;
#line 2085
  p_len = (size_t *)0;
#line 2086
  p_Char = (char *)0;
#line 2087
  set_hunkmax();
  }
#line 2088
  if (! p_line) {
    _L: /* CIL Label */ 
    {
#line 2089
    free((void *)p_line);
#line 2090
    p_line = tp_line;
#line 2091
    free((void *)p_len);
#line 2092
    p_len = tp_len;
#line 2093
    free((void *)p_Char);
#line 2094
    p_Char = tp_char;
    }
#line 2095
    return (0);
  } else
#line 2088
  if (! p_len) {
#line 2088
    goto _L;
  } else
#line 2088
  if (! p_Char) {
#line 2088
    goto _L;
  }
#line 2100
  i = p_ptrn_lines + 1L;
#line 2101
  if ((int )*(tp_char + i) == 10) {
#line 2102
    blankline = 1;
#line 2103
    i ++;
  }
#line 2105
  if (p_efake >= 0L) {
#line 2106
    if (p_efake <= i) {
#line 2107
      n = (p_end - i) + 1L;
    } else {
#line 2109
      n = - i;
    }
#line 2110
    p_efake += n;
#line 2111
    p_bfake += n;
  }
#line 2113
  n = (lin )0;
  {
#line 2113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2113
    if (! (i <= p_end)) {
#line 2113
      goto while_break;
    }
#line 2114
    *(p_line + n) = *(tp_line + i);
#line 2115
    *(p_Char + n) = *(tp_char + i);
#line 2116
    if ((int )*(p_Char + n) == 43) {
#line 2117
      *(p_Char + n) = (char )'-';
    }
#line 2118
    *(p_len + n) = *(tp_len + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 2113
  __cil_tmp10 = n;
#line 2113
  n ++;
#line 2113
  __cil_tmp9 = i;
#line 2113
  i ++;
#line 2120
  if (blankline) {
#line 2121
    i = p_ptrn_lines + 1L;
#line 2122
    *(p_line + n) = *(tp_line + i);
#line 2123
    *(p_Char + n) = *(tp_char + i);
#line 2124
    *(p_len + n) = *(tp_len + i);
#line 2125
    n ++;
  }
#line 2128
  *(p_Char + 0) = (char )'*';
#line 2129
  s = *(p_line + 0);
  {
#line 2129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2129
    if (! *s) {
#line 2129
      goto while_break___0;
    }
#line 2130
    if ((int )*s == 45) {
#line 2131
      *s = (char )'*';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2129
  s ++;
#line 2136
  *(tp_char + 0) = (char )'=';
#line 2137
  s = *(tp_line + 0);
  {
#line 2137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2137
    if (! *s) {
#line 2137
      goto while_break___1;
    }
#line 2138
    if ((int )*s == 42) {
#line 2139
      *s = (char )'-';
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2137
  s ++;
#line 2140
  i = (lin )0;
  {
#line 2140
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2140
    if (! (n <= p_end)) {
#line 2140
      goto while_break___2;
    }
#line 2141
    *(p_line + n) = *(tp_line + i);
#line 2142
    *(p_Char + n) = *(tp_char + i);
#line 2143
    if ((int )*(p_Char + n) == 45) {
#line 2144
      *(p_Char + n) = (char )'+';
    }
#line 2145
    *(p_len + n) = *(tp_len + i);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2140
  __cil_tmp17 = n;
#line 2140
  n ++;
  {
#line 2140
  __cil_tmp16 = i;
#line 2140
  i ++;
#line 2148
  i = p_ptrn_lines;
#line 2149
  p_ptrn_lines = p_repl_lines;
#line 2150
  p_repl_lines = i;
#line 2151
  *(p_Char + (p_end + 1L)) = (char )'^';
#line 2152
  free((void *)tp_line);
#line 2153
  free((void *)tp_len);
#line 2154
  free((void *)tp_char);
  }
#line 2155
  return (1);
}
}
#line 2162 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_says_nonexistent(int which ) 
{ 


  {
#line 2164
  return (p_says_nonexistent[which]);
}
}
#line 2168 "/tmp/0/patch-2.7.1/src/pch.c"
char const   *pch_name(enum nametype type ) 
{ 
  char *tmp ;

  {
#line 2170
  if ((unsigned int )type == 3U) {
#line 2170
    tmp = (char *)((void *)0);
  } else {
#line 2170
    tmp = p_name[type];
  }
#line 2170
  return ((char const   *)tmp);
}
}
#line 2173 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_copy(void) 
{ 


  {
#line 2175
  return (((p_copy[0] && p_copy[1]) && p_name[0]) && p_name[1]);
}
}
#line 2179 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_rename(void) 
{ 


  {
#line 2181
  return (((p_rename[0] && p_rename[1]) && p_name[0]) && p_name[1]);
}
}
#line 2188 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_first(void) 
{ 


  {
#line 2190
  return (p_first);
}
}
#line 2196 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_ptrn_lines(void) 
{ 


  {
#line 2198
  return (p_ptrn_lines);
}
}
#line 2204 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_newfirst(void) 
{ 


  {
#line 2206
  return (p_newfirst);
}
}
#line 2212 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_repl_lines(void) 
{ 


  {
#line 2214
  return (p_repl_lines);
}
}
#line 2220 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_end(void) 
{ 


  {
#line 2222
  return (p_end);
}
}
#line 2228 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_prefix_context(void) 
{ 


  {
#line 2230
  return (p_prefix_context);
}
}
#line 2236 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_suffix_context(void) 
{ 


  {
#line 2238
  return (p_suffix_context);
}
}
#line 2244 "/tmp/0/patch-2.7.1/src/pch.c"
size_t pch_line_len(lin line ) 
{ 


  {
#line 2246
  return (*(p_len + line));
}
}
#line 2254 "/tmp/0/patch-2.7.1/src/pch.c"
char pch_char(lin line ) 
{ 


  {
#line 2256
  return (*(p_Char + line));
}
}
#line 2262 "/tmp/0/patch-2.7.1/src/pch.c"
char *pfetch(lin line ) 
{ 


  {
#line 2264
  return (*(p_line + line));
}
}
#line 2270 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_write_line(lin line , FILE *file ) 
{ 
  int after_newline ;
  size_t __cil_tmp4 ;

  {
  {
#line 2272
  after_newline = (int )*(*(p_line + line) + (*(p_len + line) - 1UL)) == 10;
#line 2273
  __cil_tmp4 = fwrite((void const   *)*(p_line + line), sizeof(*(*(p_line + line))),
                      *(p_len + line), file);
  }
#line 2273
  if (! __cil_tmp4) {
    {
#line 2274
    write_fatal();
    }
  }
#line 2275
  return (after_newline);
}
}
#line 2281 "/tmp/0/patch-2.7.1/src/pch.c"
lin pch_hunk_beg(void) 
{ 


  {
#line 2283
  return (p_hunk_beg);
}
}
#line 2287 "/tmp/0/patch-2.7.1/src/pch.c"
char const   *pch_c_function(void) 
{ 


  {
#line 2289
  return ((char const   *)p_c_function);
}
}
#line 2295 "/tmp/0/patch-2.7.1/src/pch.c"
int pch_git_diff(void) 
{ 


  {
#line 2297
  return (p_git_diff);
}
}
#line 2301 "/tmp/0/patch-2.7.1/src/pch.c"
char const   *pch_timestr(int which ) 
{ 


  {
#line 2303
  return ((char const   *)p_timestr[which]);
}
}
#line 2307 "/tmp/0/patch-2.7.1/src/pch.c"
char const   *pch_sha1(int which ) 
{ 


  {
#line 2309
  return ((char const   *)p_sha1[which]);
}
}
#line 2313 "/tmp/0/patch-2.7.1/src/pch.c"
mode_t pch_mode(int which ) 
{ 


  {
#line 2315
  return (p_mode[which]);
}
}
#line 2324 "/tmp/0/patch-2.7.1/src/pch.c"
static char get_ed_command_letter(char const   *line ) 
{ 
  char const   *p ;
  char letter ;
  int pair ;
  char const   *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2326
  p = line;
#line 2328
  pair = 0;
#line 2330
  if ((unsigned int )((char )*p) - 48U <= 9U) {
    {
#line 2332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2332
      if (! ((unsigned int )((char )*p) - 48U <= 9U)) {
#line 2332
        goto while_break;
      }

    }
    while_break: /* CIL Label */ ;
    }
#line 2334
    if ((int )((char )*p) == 44) {
#line 2336
      p ++;
#line 2336
      if (! ((unsigned int )((char )*p) - 48U <= 9U)) {
#line 2337
        return ((char )0);
      }
      {
#line 2338
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2338
        if (! ((unsigned int )((char )*p) - 48U <= 9U)) {
#line 2338
          goto while_break___0;
        }

      }
      while_break___0: /* CIL Label */ ;
      }
#line 2340
      pair = 1;
    }
  }
#line 2344
  __cil_tmp5 = p;
#line 2344
  p ++;
#line 2344
  letter = (char )*__cil_tmp5;
  {
#line 2349
  if ((int )letter == 'i') {
#line 2349
    goto case_105;
  }
#line 2349
  if ((int )letter == 'a') {
#line 2349
    goto case_105;
  }
#line 2355
  if ((int )letter == 'd') {
#line 2355
    goto case_100;
  }
#line 2355
  if ((int )letter == 'c') {
#line 2355
    goto case_100;
  }
#line 2358
  if ((int )letter == 's') {
#line 2358
    goto case_115;
  }
#line 2364
  goto switch_default;
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 2350
  if (pair) {
#line 2351
    return ((char )0);
  }
#line 2352
  goto switch_break;
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 2356
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2359
  __cil_tmp6 = strncmp(p, (char const   *)((char *)"/.//"), (unsigned long )4);
  }
#line 2359
  if (__cil_tmp6 != 0) {
#line 2360
    return ((char )0);
  }
#line 2361
  p += 4;
#line 2362
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2365
  return ((char )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2368
    if (! ((int )((char )*p) == 32 || (int )((char )*p) == 9)) {
#line 2368
      goto while_break___1;
    }
#line 2369
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2370
  if ((int )((char )*p) == 10) {
#line 2371
    return (letter);
  }
#line 2372
  return ((char )0);
}
}
#line 2378 "/tmp/0/patch-2.7.1/src/pch.c"
void do_ed_script(char const   *inname___0 , char const   *outname , int *outname_needs_removal ,
                  FILE *ofp ) 
{ 
  static char const   editor_program[] ;
  file_offset beginning_of_this_line ;
  FILE *pipefp ;
  size_t chars_read ;
  int exclusive ;
  int tmp ;
  char *tmp___194 ;
  char *tmp___195 ;
  FILE *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char ed_command_letter ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp22 ;
  int __cil_tmp23 ;
  size_t __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  FILE *ifp ;
  char *tmp___196 ;
  FILE *__cil_tmp29 ;
  int c ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
#line 2381
  editor_program = "ed";
#line 2384
  pipefp = (FILE *)0;
#line 2387
  if (! dry_run) {
#line 2387
    if (! skip_rest_of_patch) {
#line 2388
      if (*outname_needs_removal) {
#line 2388
        tmp = 0;
      } else {
#line 2388
        tmp = 128;
      }
      {
#line 2388
      exclusive = tmp;
#line 2390
      *outname_needs_removal = 1;
#line 2391
      copy_file(inname___0, outname, (struct stat *)0, exclusive, instat.st_mode,
                1);
      }
#line 2392
      if ((unsigned int )verbosity == 2U) {
#line 2392
        tmp___194 = (char *)"";
      } else {
#line 2392
        tmp___194 = (char *)"- ";
      }
      {
#line 2392
      sprintf(buf, (char const   *)((char *)"%s %s%s"), (char const   *)editor_program,
              tmp___194, outname);
#line 2395
      fflush(stdout);
#line 2396
      tmp___195 = (char *)"w";
#line 2396
      __cil_tmp14 = popen((char const   *)buf, (char const   *)tmp___195);
#line 2396
      pipefp = __cil_tmp14;
      }
#line 2397
      if (! pipefp) {
        {
#line 2398
        __cil_tmp15 = quotearg((char const   *)buf);
#line 2398
        pfatal((char const   *)((char *)"Can\'t open pipe to %s"), __cil_tmp15);
        }
      }
    }
  }
  {
#line 2400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2400
    if (! 1) {
#line 2400
      goto while_break;
    }
    {
#line 2402
    beginning_of_this_line = ftell(pfp);
#line 2403
    chars_read = get_line();
    }
#line 2404
    if (! chars_read) {
      {
#line 2405
      next_intuit_at(beginning_of_this_line, p_input_line);
      }
#line 2406
      goto while_break;
    }
    {
#line 2408
    ed_command_letter = get_ed_command_letter((char const   *)buf);
    }
#line 2409
    if (ed_command_letter) {
#line 2410
      if (pipefp) {
        {
#line 2411
        __cil_tmp20 = fwrite((void const   *)buf, sizeof(*buf), chars_read, pipefp);
        }
#line 2411
        if (! __cil_tmp20) {
          {
#line 2412
          write_fatal();
          }
        }
      }
#line 2413
      if ((int )ed_command_letter != 100) {
#line 2413
        if ((int )ed_command_letter != 115) {
#line 2414
          p_pass_comments_through = 1;
          {
#line 2415
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2415
            if (! (chars_read != 0UL)) {
#line 2415
              goto while_break___0;
            }
#line 2416
            if (pipefp) {
              {
#line 2417
              __cil_tmp22 = fwrite((void const   *)buf, sizeof(*buf), chars_read,
                                   pipefp);
              }
#line 2417
              if (! __cil_tmp22) {
                {
#line 2418
                write_fatal();
                }
              }
            }
            {
#line 2419
            __cil_tmp23 = strcmp((char const   *)buf, (char const   *)((char *)".\n"));
            }
#line 2419
            if (chars_read == 2UL) {
#line 2419
              if (! __cil_tmp23) {
#line 2420
                goto while_break___0;
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2422
          p_pass_comments_through = 0;
        }
      }
    } else {
      {
#line 2426
      next_intuit_at(beginning_of_this_line, p_input_line);
      }
#line 2427
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2430
  if (! pipefp) {
#line 2431
    return;
  }
  {
#line 2432
  __cil_tmp25 = fflush(pipefp);
  }
  {
#line 2432
  __cil_tmp24 = fwrite((void const   *)((char *)"w\nq\n"), sizeof(char ), (size_t )4,
                       pipefp);
  }
#line 2432
  if (__cil_tmp24 == 0UL) {
    {
    {
#line 2434
    write_fatal();
    }
    }
  } else
#line 2432
  if (__cil_tmp25 != 0) {
    {
    {
#line 2434
    write_fatal();
    }
    }
  }
  {
#line 2435
  __cil_tmp26 = pclose(pipefp);
  }
#line 2435
  if (__cil_tmp26 != 0) {
    {
#line 2436
    fatal((char const   *)((char *)"%s FAILED"), (char const   *)editor_program);
    }
  }
#line 2438
  if (ofp) {
    {
#line 2440
    tmp___196 = (char *)"r";
#line 2440
    __cil_tmp29 = fopen(outname, (char const   *)tmp___196);
#line 2440
    ifp = __cil_tmp29;
    }
#line 2442
    if (! ifp) {
      {
#line 2443
      pfatal((char const   *)((char *)"can\'t open \'%s\'"), outname);
      }
    }
    {
#line 2444
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2444
      if (! (c != -1)) {
#line 2444
        goto while_break___1;
      }
      {
#line 2445
      __cil_tmp32 = _IO_putc(c, ofp);
      }
#line 2445
      if (__cil_tmp32 == -1) {
        {
#line 2446
        write_fatal();
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2447
    __cil_tmp34 = fclose(ifp);
    }
    {
#line 2447
    __cil_tmp33 = ferror(ifp);
    }
#line 2447
    if (__cil_tmp33) {
      {
      {
#line 2448
      read_fatal();
      }
      }
    } else
#line 2447
    if (__cil_tmp34 != 0) {
      {
      {
#line 2448
      read_fatal();
      }
      }
    }
  }
}
}
#line 2453 "/tmp/0/patch-2.7.1/src/pch.c"
void pch_normalize(enum diff format ) 
{ 
  lin old ;
  lin new ;

  {
#line 2455
  old = (lin )1;
#line 2456
  new = p_ptrn_lines + 1L;
  {
#line 2458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2458
    if (! ((int )*(p_Char + new) == 61 || (int )*(p_Char + new) == 10)) {
#line 2458
      goto while_break;
    }
#line 2459
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2461
  if ((unsigned int )format == 5U) {
    {
#line 2466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2466
      if (! (old <= p_ptrn_lines)) {
#line 2466
        goto while_break___0;
      }
#line 2467
      if ((int )*(p_Char + old) == 33) {
#line 2468
        *(p_Char + old) = (char )'-';
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2466
    old ++;
    {
#line 2469
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2469
      if (! (new <= p_end)) {
#line 2469
        goto while_break___1;
      }
#line 2470
      if ((int )*(p_Char + new) == 33) {
#line 2471
        *(p_Char + new) = (char )'+';
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2469
    new ++;
  } else {
    {
#line 2478
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2478
      if (! (old <= p_ptrn_lines)) {
#line 2478
        goto while_break___2;
      }
#line 2480
      if ((int )*(p_Char + old) == 45) {
#line 2482
        if (new <= p_end) {
#line 2482
          if ((int )*(p_Char + new) == 43) {
            {
#line 2484
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2486
              *(p_Char + old) = (char )'!';
#line 2487
              old ++;
#line 2484
              if (! (old <= p_ptrn_lines && (int )*(p_Char + old) == 45)) {
#line 2484
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 2490
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2492
              *(p_Char + new) = (char )'!';
#line 2493
              new ++;
#line 2490
              if (! (new <= p_end && (int )*(p_Char + new) == 43)) {
#line 2490
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 2482
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 2499
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2500
            old ++;
#line 2499
            if (! (old <= p_ptrn_lines && (int )*(p_Char + old) == 45)) {
#line 2499
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      } else
#line 2504
      if (new <= p_end) {
#line 2504
        if ((int )*(p_Char + new) == 43) {
          {
#line 2506
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2507
            new ++;
#line 2506
            if (! (new <= p_end && (int )*(p_Char + new) == 43)) {
#line 2506
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
#line 2512
          old ++;
#line 2513
          new ++;
        }
      } else {
#line 2512
        old ++;
#line 2513
        new ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
}
}
#line 290 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 90 "./common.h"
char const   *TMPINNAME ;
#line 91
char const   *TMPOUTNAME ;
#line 94
int TMPINNAME_needs_removal ;
#line 95
int TMPOUTNAME_needs_removal ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 500
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 537
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 207 "./common.h"
int similar(char const   *a , size_t alen , char const   *b , size_t blen ) ;
#line 23 "./inp.h"
int get_input_file(char const   *filename , char const   *outname , mode_t file_type ) ;
#line 24
void re_input(void) ;
#line 25
void scan_input(char *filename , mode_t file_type ) ;
#line 58 "./pch.h"
__inline static struct timespec pch_timestamp(int which ) 
{ 


  {
#line 60
  return (p_timestamp[which]);
}
}
#line 550 "../lib/gl_list.h"
__inline static gl_list_t gl_list_nx_create_empty_inline(gl_list_implementation_t implementation ,
                                                         gl_listelement_equals_fn equals_fn ,
                                                         gl_listelement_hashcode_fn hashcode_fn ,
                                                         gl_listelement_dispose_fn dispose_fn ,
                                                         int allow_duplicates ) 
{ 
  gl_list_t __cil_tmp6 ;

  {
  {
#line 556
  __cil_tmp6 = (implementation->nx_create_empty)(implementation, equals_fn, hashcode_fn,
                                                 dispose_fn, allow_duplicates);
  }
#line 556
  return (__cil_tmp6);
}
}
#line 618 "../lib/gl_list.h"
__inline static void const   *gl_list_get_at_inline(gl_list_t list , size_t position ) 
{ 
  void const   *__cil_tmp3 ;

  {
  {
#line 620
  __cil_tmp3 = ((((struct gl_list_impl_base *)list)->vtable)->get_at)(list, position);
  }
#line 620
  return (__cil_tmp3);
}
}
#line 696 "../lib/gl_list.h"
__inline static gl_list_node_t gl_list_nx_add_last_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t __cil_tmp3 ;

  {
  {
#line 698
  __cil_tmp3 = ((((struct gl_list_impl_base *)list)->vtable)->nx_add_last)(list, elt);
  }
#line 698
  return (__cil_tmp3);
}
}
#line 736 "../lib/gl_list.h"
__inline static int gl_list_remove_at_inline(gl_list_t list , size_t position ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 738
  __cil_tmp3 = ((((struct gl_list_impl_base *)list)->vtable)->remove_at)(list, position);
  }
#line 738
  return (__cil_tmp3);
}
}
#line 759 "../lib/gl_list.h"
__inline static gl_list_iterator_t gl_list_iterator_inline(gl_list_t list ) 
{ 
  gl_list_iterator_t __cil_tmp2 ;

  {
  {
#line 761
  __cil_tmp2 = ((((struct gl_list_impl_base *)list)->vtable)->iterator)(list);
  }
#line 761
  return (__cil_tmp2);
}
}
#line 783 "../lib/gl_list.h"
__inline static void gl_list_iterator_free_inline(gl_list_iterator_t *iterator ) 
{ 


  {
  {
#line 785
  ((iterator->vtable)->iterator_free)(iterator);
  }
}
}
#line 62 "../lib/gl_xlist.h"
__inline static gl_list_t gl_list_create_empty_inline(gl_list_implementation_t implementation ,
                                                      gl_listelement_equals_fn equals_fn ,
                                                      gl_listelement_hashcode_fn hashcode_fn ,
                                                      gl_listelement_dispose_fn dispose_fn ,
                                                      int allow_duplicates ) 
{ 
  gl_list_t result ;
  gl_list_t __cil_tmp7 ;

  {
  {
#line 68
  __cil_tmp7 = gl_list_nx_create_empty_inline(implementation, equals_fn, hashcode_fn,
                                              dispose_fn, allow_duplicates);
#line 68
  result = __cil_tmp7;
  }
#line 71
  if (result == (gl_list_t )((void *)0)) {
    {
#line 72
    xalloc_die();
    }
  }
#line 73
  return (result);
}
}
#line 124 "../lib/gl_xlist.h"
__inline static gl_list_node_t gl_list_add_last_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t result ;
  gl_list_node_t __cil_tmp4 ;

  {
  {
#line 126
  __cil_tmp4 = gl_list_nx_add_last_inline(list, elt);
#line 126
  result = __cil_tmp4;
  }
#line 127
  if (result == (gl_list_node_t )((void *)0)) {
    {
#line 128
    xalloc_die();
    }
  }
#line 129
  return (result);
}
}
#line 39 "/tmp/0/patch-2.7.1/src/patch.c"
static FILE *create_output_file(char const   *name , int open_flags ) ;
#line 40
static lin locate_hunk(lin fuzz ) ;
#line 41
static int check_line_endings(lin where ) ;
#line 42
static int apply_hunk(struct outstate *outstate , lin where ) ;
#line 43
static int patch_match(lin base , lin offset , lin prefix_fuzz , lin suffix_fuzz ) ;
#line 44
static int spew_output(struct outstate *outstate , struct stat *st ) ;
#line 45
static int numeric_string(char const   *string , int negative_allowed , char const   *argtype_msgid ) ;
#line 46
static void cleanup(void) ;
#line 47
static void get_some_switches(void) ;
#line 48
static void init_output(struct outstate *outstate ) ;
#line 49
static FILE *open_outfile(char const   *name ) ;
#line 50
static void init_reject(char const   *outname ) ;
#line 51
static void reinitialize_almost_everything(void) ;
#line 52
static void remove_if_needed(char const   *name , int *needs_removal ) ;
#line 53
static void usage(FILE *stream , int status ) ;
#line 55
static void abort_hunk(char const   *outname , int header , int reverse___0 ) ;
#line 56
static void abort_hunk_context(int header , int reverse___0 ) ;
#line 57
static void abort_hunk_unified(int header , int reverse___0 ) ;
#line 59
static void output_file(char const   *from , int *from_needs_removal , struct stat *from_st ,
                        char const   *to , struct stat *to_st , mode_t mode , int backup ) ;
#line 62
static void init_files_to_delete(void) ;
#line 63
static void init_files_to_output(void) ;
#line 64
static void delete_files(void) ;
#line 65
static void output_files(struct stat *st ) ;
#line 68
static int merge ;
#line 73 "/tmp/0/patch-2.7.1/src/patch.c"
static enum diff reject_format  =    (enum diff )0;
#line 74
static int make_backups ;
#line 75
static int backup_if_mismatch ;
#line 76
static char const   *version_control ;
#line 77
static char const   *version_control_context ;
#line 78
static int remove_empty_files ;
#line 79
static int explicit_inname ;
#line 80 "/tmp/0/patch-2.7.1/src/patch.c"
static int read_only_behavior  =    (int )1;
#line 83
static int reverse_flag_specified ;
#line 85
static char const   *do_defines ;
#line 86 "/tmp/0/patch-2.7.1/src/patch.c"
static char const   if_defined[]  =    "\n#ifdef %s\n";
#line 87 "/tmp/0/patch-2.7.1/src/patch.c"
static char const   not_defined[]  =    "\n#ifndef %s\n";
#line 88 "/tmp/0/patch-2.7.1/src/patch.c"
static char const   else_defined[]  =    "\n#else\n";
#line 89 "/tmp/0/patch-2.7.1/src/patch.c"
static char const   end_defined[]  =    "\n#endif\n";
#line 91
static int Argc ;
#line 92
static char **Argv ;
#line 94
static FILE *rejfp ;
#line 96
static char const   *patchname ;
#line 97
static char *rejname ;
#line 98
static char const   *TMPREJNAME ;
#line 99
static int TMPREJNAME_needs_removal ;
#line 101 "/tmp/0/patch-2.7.1/src/patch.c"
static lin maxfuzz  =    (lin )2;
#line 103
static char serrbuf[8192] ;
#line 108 "/tmp/0/patch-2.7.1/src/patch.c"
int main(int argc , char **argv ) 
{ 
  char const   *val ;
  int somefailed ;
  struct outstate outstate ;
  struct stat tmpoutst ;
  char numbuf[23] ;
  int written_to_rejname ;
  int apply_empty_patch ;
  mode_t file_type ;
  int outfd ;
  int have_git_diff ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int i ;
  ptrdiff_t __cil_tmp16 ;
  ptrdiff_t tmp ;
  unsigned int tmp___197 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___198 ;
  char *__cil_tmp23 ;
  char const   *tmp___199 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp29 ;
  int hunk ;
  int failed ;
  int mismatch ;
  char const   *outname ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;
  mode_t __cil_tmp36 ;
  mode_t __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  char const   *__cil_tmp40 ;
  int __cil_tmp41 ;
  char const   *__cil_tmp42 ;
  int __cil_tmp43 ;
  struct stat outstat ;
  int outerrno ;
  int __cil_tmp46 ;
  int __cil_tmp49 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  char *__cil_tmp53 ;
  int __cil_tmp55 ;
  int got_hunk ;
  int apply_anyway ;
  char *__cil_tmp58 ;
  char *tmp___200 ;
  FILE *__cil_tmp60 ;
  int renamed ;
  int __cil_tmp62 ;
  char *tmp___201 ;
  char *tmp___202 ;
  char *__cil_tmp65 ;
  int tmp___203 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  char *tmp___204 ;
  char *tmp___205 ;
  char *tmp___206 ;
  lin where ;
  lin newwhere ;
  lin fuzz ;
  lin mymaxfuzz ;
  lin prefix_context ;
  lin __cil_tmp78 ;
  lin suffix_context ;
  lin __cil_tmp80 ;
  lin context ;
  lin tmp___207 ;
  lin tmp___208 ;
  int __cil_tmp86 ;
  char *tmp___209 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  lin __cil_tmp91 ;
  lin __cil_tmp92 ;
  lin tmp___210 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  char *tmp___211 ;
  char *__cil_tmp99 ;
  int __cil_tmp100 ;
  char *tmp___212 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  int __cil_tmp105 ;
  int backup ;
  int __cil_tmp107 ;
  struct stat *tmp___220 ;
  int __cil_tmp109 ;
  char *__cil_tmp110 ;
  mode_t old_mode ;
  mode_t __cil_tmp112 ;
  mode_t new_mode ;
  mode_t __cil_tmp114 ;
  int set_mode ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  enum file_attributes attr ;
  struct timespec new_time ;
  struct timespec __cil_tmp120 ;
  mode_t mode ;
  mode_t tmp___222 ;
  struct timespec old_time ;
  struct timespec __cil_tmp124 ;
  int __cil_tmp125 ;
  struct timespec __cil_tmp126 ;
  int __cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  int __cil_tmp130 ;
  struct stat rejst ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  char *tmp___235 ;
  int __cil_tmp136 ;
  char *rej ;
  char const   *s ;
  size_t len ;
  char *__cil_tmp142 ;
  struct stat oldst ;
  int olderrno ;
  enum file_id_type __cil_tmp146 ;
  int __cil_tmp147 ;
  int __cil_tmp148 ;

  {
  {
#line 111
  somefailed = 0;
#line 115
  written_to_rejname = 0;
#line 116
  apply_empty_patch = 0;
#line 118
  outfd = - 1;
#line 119
  have_git_diff = 0;
#line 121
  exit_failure = 2;
#line 122
  set_program_name((char const   *)*(argv + 0));
#line 123
  init_time();
#line 125
  setbuf(stderr, (char *)serrbuf);
#line 127
  bufsize = (size_t )8192;
#line 128
  __cil_tmp13 = xmalloc(bufsize);
#line 128
  buf = (char *)__cil_tmp13;
#line 130
  strippath = - 1;
#line 132
  __cil_tmp14 = getenv((char const   *)((char *)"QUOTING_STYLE"));
#line 132
  val = (char const   *)__cil_tmp14;
  }
#line 134
  if (val) {
    {
#line 134
    __cil_tmp16 = argmatch(val, (char const   * const  *)quoting_style_args, (char const   *)0,
                           (size_t )0);
#line 134
    tmp = __cil_tmp16;
    }
  } else {
#line 134
    tmp = (long )(- 1);
  }
#line 134
  i = (int )tmp;
#line 135
  if (i < 0) {
#line 135
    tmp___197 = (unsigned int )1;
  } else {
#line 135
    tmp___197 = (unsigned int )((enum quoting_style )i);
  }
  {
#line 135
  set_quoting_style((struct quoting_options *)0, (enum quoting_style )tmp___197);
#line 139
  __cil_tmp19 = getenv((char const   *)((char *)"POSIXLY_CORRECT"));
#line 139
  posixly_correct = __cil_tmp19 != (char *)0;
#line 140
  backup_if_mismatch = ! posixly_correct;
#line 141
  __cil_tmp20 = getenv((char const   *)((char *)"PATCH_GET"));
#line 141
  val = (char const   *)__cil_tmp20;
  }
#line 141
  if (val) {
    {
#line 141
    __cil_tmp21 = numeric_string(val, 1, (char const   *)((char *)"PATCH_GET value"));
#line 141
    tmp___198 = __cil_tmp21;
    }
  } else {
#line 141
    tmp___198 = 0;
  }
  {
#line 141
  patch_get = tmp___198;
#line 145
  __cil_tmp23 = getenv((char const   *)((char *)"SIMPLE_BACKUP_SUFFIX"));
#line 145
  val = (char const   *)__cil_tmp23;
  }
#line 146
  if (val && (int )((char )*val)) {
#line 146
    tmp___199 = val;
  } else {
#line 146
    tmp___199 = (char const   *)((char *)".orig");
  }
  {
#line 146
  simple_backup_suffix = tmp___199;
#line 148
  __cil_tmp25 = getenv((char const   *)((char *)"PATCH_VERSION_CONTROL"));
#line 148
  version_control = (char const   *)__cil_tmp25;
  }
#line 148
  if (version_control) {
#line 149
    version_control_context = (char const   *)((char *)"$PATCH_VERSION_CONTROL");
  } else {
    {
#line 150
    __cil_tmp26 = getenv((char const   *)((char *)"VERSION_CONTROL"));
#line 150
    version_control = (char const   *)__cil_tmp26;
    }
#line 150
    if (version_control) {
#line 151
      version_control_context = (char const   *)((char *)"$VERSION_CONTROL");
    }
  }
  {
#line 154
  Argc = argc;
#line 155
  Argv = argv;
#line 156
  get_some_switches();
  }
#line 159
  if (set_utc) {
    {
#line 160
    setenv((char const   *)((char *)"TZ"), (char const   *)((char *)"UTC"), 1);
    }
  }
#line 162
  if (make_backups | backup_if_mismatch) {
    {
#line 163
    backup_type = get_version(version_control_context, version_control);
    }
  }
  {
#line 165
  init_backup_hash_table();
#line 166
  init_files_to_delete();
#line 167
  init_files_to_output();
#line 169
  init_output(& outstate);
  }
#line 170
  if (outfile) {
    {
#line 171
    outstate.ofp = open_outfile((char const   *)outfile);
    }
  }
  {
#line 174
  set_signals(0);
  }
#line 176
  if (inname) {
#line 176
    if (outfile) {
#line 182
      apply_empty_patch = 1;
#line 183
      file_type = (mode_t )32768;
#line 184
      inerrno = - 1;
    }
  }
  {
#line 187
  open_patch_file(patchname);
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (__cil_tmp29 || apply_empty_patch)) {
#line 186
      goto while_break;
    }
    {
#line 193
    hunk = 0;
#line 194
    failed = 0;
#line 195
    mismatch = 0;
#line 196
    outname = (char const   *)((void *)0);
#line 198
    __cil_tmp34 = pch_git_diff();
    }
#line 198
    if (have_git_diff != __cil_tmp34) {
#line 200
      if (have_git_diff) {
        {
#line 202
        output_files((struct stat *)((void *)0));
#line 203
        inerrno = - 1;
        }
      }
#line 205
      have_git_diff = ! have_git_diff;
    }
#line 208
    if (TMPREJNAME_needs_removal) {
#line 210
      if (rejfp) {
        {
#line 212
        fclose(rejfp);
#line 213
        rejfp = (FILE *)((void *)0);
        }
      }
      {
#line 215
      remove_if_needed(TMPREJNAME, & TMPREJNAME_needs_removal);
      }
    }
#line 217
    if (TMPOUTNAME_needs_removal) {
#line 219
      if (outfd != -1) {
        {
#line 221
        close(outfd);
#line 222
        outfd = - 1;
        }
      }
      {
#line 224
      remove_if_needed(TMPOUTNAME, & TMPOUTNAME_needs_removal);
      }
    }
#line 227
    if (! skip_rest_of_patch) {
#line 227
      if (! file_type) {
        {
#line 229
        __cil_tmp35 = quotearg((char const   *)inname);
        }
        {
#line 229
        __cil_tmp36 = pch_mode(reverse);
        }
        {
#line 229
        __cil_tmp37 = pch_mode(! reverse);
#line 229
        say((char const   *)((char *)"File %s: can\'t change file type from 0%o to 0%o.\n"),
            __cil_tmp35, __cil_tmp36 & 61440U, __cil_tmp37 & 61440U);
#line 233
        skip_rest_of_patch = 1;
#line 234
        somefailed = 1;
        }
      }
    }
#line 237
    if (! skip_rest_of_patch) {
#line 239
      if (outfile) {
#line 240
        outname = (char const   *)outfile;
      } else {
        {
#line 241
        __cil_tmp39 = pch_rename();
        }
        {
#line 241
        __cil_tmp38 = pch_copy();
        }
#line 241
        if (__cil_tmp38) {
          {
          {
#line 242
          __cil_tmp40 = pch_name((enum nametype )0);
          }
          {
#line 242
          __cil_tmp41 = strcmp((char const   *)inname, __cil_tmp40);
          }
          {
#line 242
          __cil_tmp42 = pch_name((enum nametype )(! __cil_tmp41));
          }
#line 242
          outname = __cil_tmp42;
          }
        } else
#line 241
        if (__cil_tmp39) {
          {
          {
#line 242
          __cil_tmp40 = pch_name((enum nametype )0);
          }
          {
#line 242
          __cil_tmp41 = strcmp((char const   *)inname, __cil_tmp40);
          }
          {
#line 242
          __cil_tmp42 = pch_name((enum nametype )(! __cil_tmp41));
          }
#line 242
          outname = __cil_tmp42;
          }
        } else {
#line 244
          outname = (char const   *)inname;
        }
      }
    }
    {
#line 247
    __cil_tmp43 = pch_git_diff();
    }
#line 247
    if (__cil_tmp43) {
#line 247
      if (! skip_rest_of_patch) {
        {
#line 250
        outerrno = 0;
#line 256
        __cil_tmp46 = strcmp((char const   *)inname, outname);
        }
#line 256
        if (! __cil_tmp46) {
#line 258
          if (inerrno == -1) {
            {
#line 259
            inerrno = stat_file((char const   *)inname, & instat);
            }
          }
#line 260
          outstat = instat;
#line 261
          outerrno = inerrno;
        } else {
          {
#line 264
          outerrno = stat_file(outname, & outstat);
          }
        }
#line 266
        if (! outerrno) {
          {
#line 268
          __cil_tmp49 = has_queued_output(& outstat);
          }
#line 268
          if (__cil_tmp49) {
            {
#line 270
            output_files(& outstat);
#line 271
            outerrno = stat_file(outname, & outstat);
#line 272
            inerrno = - 1;
            }
          }
#line 274
          if (! outerrno) {
            {
#line 275
            set_queued_output(& outstat, 1);
            }
          }
        }
      }
    }
#line 279
    if (! skip_rest_of_patch) {
      {
#line 281
      __cil_tmp51 = get_input_file((char const   *)inname, outname, file_type);
      }
#line 281
      if (! __cil_tmp51) {
#line 283
        skip_rest_of_patch = 1;
#line 284
        somefailed = 1;
      }
    }
    {
#line 288
    __cil_tmp52 = access((char const   *)inname, 2);
    }
#line 288
    if ((unsigned int )read_only_behavior != 0U) {
#line 288
      if (! inerrno) {
#line 288
        if (! ((instat.st_mode & 61440U) == 40960U)) {
#line 288
          if (__cil_tmp52 != 0) {
            {
#line 292
            __cil_tmp53 = quotearg((char const   *)inname);
#line 292
            say((char const   *)((char *)"File %s is read-only; "), __cil_tmp53);
            }
#line 293
            if ((unsigned int )read_only_behavior == 1U) {
              {
#line 294
              say((char const   *)((char *)"trying to patch anyway\n"));
              }
            } else {
              {
#line 297
              say((char const   *)((char *)"refusing to patch\n"));
#line 298
              skip_rest_of_patch = 1;
#line 299
              somefailed = 1;
              }
            }
          }
        }
      }
    }
    {
#line 303
    tmpoutst.st_size = (__off_t )(- 1);
#line 304
    outfd = make_tempfile(& TMPOUTNAME, (char )'o', outname, 1, instat.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 307
    TMPOUTNAME_needs_removal = 1;
    }
#line 308
    if ((unsigned int )diff_type == 3U) {
      {
#line 309
      outstate.zero_output = 0;
#line 310
      somefailed |= skip_rest_of_patch;
#line 311
      do_ed_script((char const   *)inname, TMPOUTNAME, & TMPOUTNAME_needs_removal,
                   outstate.ofp);
      }
#line 313
      if (! dry_run) {
#line 313
        if (! outfile) {
#line 313
          if (! skip_rest_of_patch) {
            {
#line 315
            __cil_tmp55 = fstat(outfd, & tmpoutst);
            }
#line 315
            if (__cil_tmp55 != 0) {
              {
#line 316
              pfatal((char const   *)((char *)"%s"), TMPOUTNAME);
              }
            }
#line 317
            outstate.zero_output = tmpoutst.st_size == 0L;
          }
        }
      }
      {
#line 319
      close(outfd);
#line 320
      outfd = - 1;
      }
    } else {
#line 323
      apply_anyway = merge;
#line 325
      if (! skip_rest_of_patch) {
#line 325
        if ((unsigned int )diff_type == 6U) {
          {
#line 326
          __cil_tmp58 = quotearg(outname);
#line 326
          say((char const   *)((char *)"File %s: git binary diffs are not supported.\n"),
              __cil_tmp58);
#line 328
          skip_rest_of_patch = 1;
#line 329
          somefailed = 1;
          }
        }
      }
#line 332
      if (! skip_rest_of_patch) {
#line 332
        if (! outfile) {
          {
#line 334
          init_output(& outstate);
#line 335
          tmp___200 = (char *)"w";
#line 335
          __cil_tmp60 = fdopen(outfd, (char const   *)tmp___200);
#line 335
          outstate.ofp = __cil_tmp60;
          }
#line 336
          if (! outstate.ofp) {
            {
#line 337
            pfatal((char const   *)((char *)"%s"), TMPOUTNAME);
            }
          }
        }
      }
#line 341
      if (! skip_rest_of_patch) {
        {
#line 342
        scan_input(inname, file_type);
        }
#line 344
        if ((unsigned int )verbosity != 1U) {
          {
#line 346
          __cil_tmp62 = strcmp((char const   *)inname, outname);
#line 346
          renamed = __cil_tmp62;
          }
#line 348
          if (dry_run) {
#line 348
            tmp___201 = (char *)"checking";
          } else {
#line 348
            tmp___201 = (char *)"patching";
          }
#line 348
          if ((file_type & 61440U) == 40960U) {
#line 348
            tmp___202 = (char *)"symbolic link";
          } else {
#line 348
            tmp___202 = (char *)"file";
          }
          {
#line 348
          __cil_tmp65 = quotearg(outname);
          }
#line 348
          if (renamed) {
#line 348
            tmp___203 = ' ';
          } else {
#line 348
            tmp___203 = '\n';
          }
          {
#line 348
          say((char const   *)((char *)"%s %s %s%c"), tmp___201, tmp___202, __cil_tmp65,
              tmp___203);
          }
#line 352
          if (renamed) {
            {
#line 353
            __cil_tmp67 = pch_copy();
            }
#line 353
            if (__cil_tmp67) {
#line 353
              tmp___205 = (char *)"copied";
            } else {
              {
#line 353
              __cil_tmp68 = pch_rename();
              }
#line 353
              if (__cil_tmp68) {
#line 353
                tmp___204 = (char *)"renamed";
              } else {
#line 353
                tmp___204 = (char *)"read";
              }
#line 353
              tmp___205 = tmp___204;
            }
            {
#line 353
            say((char const   *)((char *)"(%s from %s)\n"), tmp___205, inname);
            }
          }
#line 357
          if ((unsigned int )verbosity == 2U) {
#line 358
            if (using_plan_a) {
#line 358
              tmp___206 = (char *)"A";
            } else {
#line 358
              tmp___206 = (char *)"B";
            }
            {
#line 358
            say((char const   *)((char *)"Using Plan %s...\n"), tmp___206);
            }
          }
        }
      }
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if (! (0 < got_hunk)) {
#line 366
          goto while_break___0;
        }
#line 368
        where = (lin )0;
#line 370
        fuzz = (lin )0;
#line 373
        if (merge) {
#line 376
          mymaxfuzz = (lin )0;
        } else {
          {
#line 380
          __cil_tmp78 = pch_prefix_context();
#line 380
          prefix_context = __cil_tmp78;
#line 381
          __cil_tmp80 = pch_suffix_context();
#line 381
          suffix_context = __cil_tmp80;
          }
#line 382
          if (prefix_context < suffix_context) {
#line 382
            tmp___207 = suffix_context;
          } else {
#line 382
            tmp___207 = prefix_context;
          }
#line 382
          context = tmp___207;
#line 384
          if (maxfuzz < context) {
#line 384
            tmp___208 = maxfuzz;
          } else {
#line 384
            tmp___208 = context;
          }
#line 384
          mymaxfuzz = tmp___208;
        }
#line 387
        hunk ++;
#line 388
        if (! skip_rest_of_patch) {
          {
#line 389
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 390
            where = locate_hunk(fuzz);
            }
#line 391
            if (! where) {
#line 392
              mismatch = 1;
            } else
#line 391
            if (fuzz) {
#line 392
              mismatch = 1;
            } else
#line 391
            if (in_offset) {
#line 392
              mismatch = 1;
            }
#line 393
            if (hunk == 1) {
#line 393
              if (! where) {
#line 393
                if (! (force | apply_anyway)) {
#line 393
                  if (reverse == reverse_flag_specified) {
                    {
#line 396
                    __cil_tmp86 = pch_swap();
                    }
#line 396
                    if (! __cil_tmp86) {
                      {
#line 397
                      say((char const   *)((char *)"Not enough memory to try swapped hunk!  Assuming unswapped.\n"));
                      }
#line 399
                      goto while_continue___1;
                    }
                    {
#line 402
                    where = locate_hunk(fuzz);
                    }
#line 403
                    if (reverse) {
#line 403
                      tmp___209 = (char *)"Unreversed";
                    } else {
#line 403
                      tmp___209 = (char *)"Reversed (or previously applied)";
                    }
                    {
#line 403
                    __cil_tmp89 = ok_to_reverse((char const   *)((char *)"%s patch detected!"),
                                                tmp___209);
                    }
#line 403
                    if (where) {
#line 403
                      if (__cil_tmp89) {
#line 409
                        reverse = ! reverse;
                      } else {
#line 403
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ 
                      {
#line 413
                      __cil_tmp90 = pch_swap();
                      }
#line 413
                      if (! __cil_tmp90) {
                        {
#line 414
                        fatal((char const   *)((char *)"lost hunk on alloc error!"));
                        }
                      }
#line 415
                      if (where) {
#line 417
                        apply_anyway = 1;
#line 418
                        __cil_tmp91 = fuzz;
#line 418
                        fuzz --;
#line 419
                        where = (lin )0;
                      }
                    }
                  }
                }
              }
            }
#line 389
            if (! ((! skip_rest_of_patch && ! where) && fuzz <= mymaxfuzz)) {
#line 389
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 426
          if (skip_rest_of_patch) {
#line 427
            if (outstate.ofp) {
#line 427
              if (! outfile) {
                {
#line 429
                fclose(outstate.ofp);
#line 430
                outstate.ofp = (FILE *)0;
#line 431
                outfd = - 1;
                }
              }
            }
          }
        }
#line 436
        if (where) {
#line 436
          tmp___210 = where;
        } else {
          {
#line 436
          __cil_tmp92 = pch_first();
#line 436
          tmp___210 = __cil_tmp92;
          }
        }
        {
#line 436
        newwhere = tmp___210 + out_offset;
#line 437
        __cil_tmp96 = apply_hunk(& outstate, where);
        }
        {
#line 437
        __cil_tmp95 = pch_says_nonexistent(reverse);
        }
        {
#line 437
        __cil_tmp94 = merge_hunk(hunk, & outstate, where, & somefailed);
        }
#line 437
        if (skip_rest_of_patch) {
          _L___214: /* CIL Label */ 
          {
#line 446
          abort_hunk(outname, ! failed, reverse);
#line 447
          failed ++;
          }
#line 448
          if ((unsigned int )verbosity == 2U) {
            _L___212: /* CIL Label */ 
#line 450
            if (skip_rest_of_patch) {
#line 450
              tmp___211 = (char *)"ignored";
            } else {
#line 450
              tmp___211 = (char *)"FAILED";
            }
            {
#line 450
            __cil_tmp99 = format_linenum((char *)numbuf, newwhere);
            }
            {
#line 450
            __cil_tmp100 = check_line_endings(newwhere);
            }
#line 450
            if (! skip_rest_of_patch && __cil_tmp100) {
#line 450
              tmp___212 = (char *)" (different line endings)";
            } else {
#line 450
              tmp___212 = (char *)"";
            }
            {
#line 450
            say((char const   *)((char *)"Hunk #%d %s at %s%s.\n"), hunk, tmp___211,
                __cil_tmp99, tmp___212);
            }
          } else
#line 448
          if (! skip_rest_of_patch) {
#line 448
            if ((unsigned int )verbosity != 1U) {
#line 448
              goto _L___212;
            }
          }
        } else
#line 437
        if (merge) {
#line 437
          if (! __cil_tmp94) {
#line 437
            goto _L___214;
          } else {
#line 437
            goto _L___219;
          }
        } else
        _L___219: /* CIL Label */ 
#line 437
        if (! merge) {
#line 437
          if (where == 1L) {
#line 437
            if (__cil_tmp95 == 2) {
#line 437
              if (instat.st_size) {
#line 437
                goto _L___214;
              } else {
#line 437
                goto _L___216;
              }
            } else {
#line 437
              goto _L___216;
            }
          } else
          _L___216: /* CIL Label */ 
#line 437
          if (! where) {
#line 437
            goto _L___214;
          } else
#line 437
          if (! __cil_tmp96) {
#line 437
            goto _L___214;
          } else {
#line 437
            goto _L___215;
          }
        } else
        _L___215: /* CIL Label */ 
#line 456
        if (! merge) {
#line 456
          if ((unsigned int )verbosity == 2U) {
            _L___213: /* CIL Label */ 
            {
#line 460
            __cil_tmp102 = format_linenum((char *)numbuf, newwhere);
#line 460
            say((char const   *)((char *)"Hunk #%d succeeded at %s"), hunk, __cil_tmp102);
            }
#line 462
            if (fuzz) {
              {
#line 463
              __cil_tmp103 = format_linenum((char *)numbuf, fuzz);
#line 463
              say((char const   *)((char *)" with fuzz %s"), __cil_tmp103);
              }
            }
#line 464
            if (in_offset) {
              {
#line 465
              __cil_tmp104 = format_linenum((char *)numbuf, in_offset);
#line 465
              say((char const   *)((char *)" (offset %s line%s)"), __cil_tmp104, (char *)"s" + (in_offset == 1L));
              }
            }
            {
#line 468
            say((char const   *)((char *)".\n"));
            }
          } else
#line 456
          if ((unsigned int )verbosity != 1U) {
#line 456
            if (fuzz) {
#line 456
              goto _L___213;
            } else
#line 456
            if (in_offset) {
#line 456
              goto _L___213;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 472
      if (! skip_rest_of_patch) {
#line 474
        if (got_hunk < 0) {
#line 474
          if (using_plan_a) {
#line 476
            if (outfile) {
              {
#line 477
              fatal((char const   *)((char *)"out of memory using Plan A"));
              }
            }
            {
#line 478
            say((char const   *)((char *)"\n\nRan out of memory using Plan A -- trying again...\n\n"));
            }
#line 479
            if (outstate.ofp) {
              {
#line 481
              fclose(outstate.ofp);
#line 482
              outstate.ofp = (FILE *)0;
              }
            }
#line 484
            goto while_continue;
          }
        }
        {
#line 488
        __cil_tmp105 = spew_output(& outstate, & tmpoutst);
        }
#line 488
        if (! __cil_tmp105) {
          {
#line 490
          say((char const   *)((char *)"Skipping patch.\n"));
#line 491
          skip_rest_of_patch = 1;
          }
        }
      }
    }
    {
#line 497
    ignore_signals();
    }
#line 498
    if (! skip_rest_of_patch) {
#line 498
      if (! outfile) {
        {
#line 499
        backup = make_backups || (backup_if_mismatch && mismatch | failed);
#line 501
        __cil_tmp107 = pch_says_nonexistent(! reverse);
        }
#line 501
        if (outstate.zero_output) {
#line 501
          if (remove_empty_files) {
            _L___232: /* CIL Label */ 
#line 507
            if (! dry_run) {
#line 508
              if (inname == (char *)outname) {
#line 508
                tmp___220 = & instat;
              } else {
#line 508
                tmp___220 = (struct stat *)((void *)0);
              }
              {
#line 508
              output_file((char const   *)((void *)0), (int *)((void *)0), (struct stat *)((void *)0),
                          outname, tmp___220, file_type, backup);
              }
            }
          } else
#line 501
          if (__cil_tmp107 == 2) {
#line 501
            if (! posixly_correct) {
#line 501
              goto _L___232;
            } else {
#line 501
              goto _L___234;
            }
          } else
          _L___234: /* CIL Label */ 
#line 501
          if ((file_type & 61440U) == 40960U) {
#line 501
            goto _L___232;
          } else {
#line 501
            goto _L___231;
          }
        } else {
          _L___231: /* CIL Label */ 
          {
#line 514
          __cil_tmp109 = pch_says_nonexistent(! reverse);
          }
#line 514
          if (! outstate.zero_output) {
#line 514
            if (__cil_tmp109 == 2) {
#line 514
              if (remove_empty_files) {
                _L___221: /* CIL Label */ 
#line 514
                if (! (merge && somefailed)) {
#line 519
                  mismatch = 1;
#line 520
                  somefailed = 1;
#line 521
                  if ((unsigned int )verbosity != 1U) {
                    {
#line 522
                    __cil_tmp110 = quotearg(outname);
#line 522
                    say((char const   *)((char *)"File %s is not empty after patch; not deleting\n"),
                        __cil_tmp110);
                    }
                  }
                }
              } else
#line 514
              if (! posixly_correct) {
#line 514
                goto _L___221;
              }
            }
          }
#line 526
          if (! dry_run) {
            {
#line 528
            __cil_tmp112 = pch_mode(reverse);
#line 528
            old_mode = __cil_tmp112;
#line 529
            __cil_tmp114 = pch_mode(! reverse);
#line 529
            new_mode = __cil_tmp114;
#line 530
            set_mode = new_mode && old_mode != new_mode;
#line 533
            __cil_tmp117 = pch_rename();
            }
            {
#line 533
            __cil_tmp116 = pch_copy();
            }
#line 533
            if (failed < hunk) {
              _L___227: /* CIL Label */ 
              {
#line 536
              attr = (enum file_attributes )0;
#line 537
              __cil_tmp120 = pch_timestamp(! reverse);
#line 537
              new_time = __cil_tmp120;
              }
#line 538
              if (new_mode) {
#line 538
                tmp___222 = new_mode;
              } else {
#line 538
                tmp___222 = instat.st_mode;
              }
#line 538
              mode = file_type | (tmp___222 & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 541
              if (set_time | set_utc) {
#line 541
                if (new_time.tv_sec != -1L) {
                  {
#line 543
                  __cil_tmp124 = pch_timestamp(reverse);
#line 543
                  old_time = __cil_tmp124;
#line 545
                  __cil_tmp126 = get_stat_mtime(& instat);
#line 545
                  __cil_tmp127 = timespec_cmp(old_time, __cil_tmp126);
                  }
                  {
#line 545
                  __cil_tmp125 = pch_says_nonexistent(reverse);
                  }
#line 545
                  if (! force) {
#line 545
                    if (! inerrno) {
#line 545
                      if (__cil_tmp125 != 2) {
#line 545
                        if (old_time.tv_sec != -1L) {
#line 545
                          if (__cil_tmp127) {
                            {
#line 550
                            __cil_tmp128 = quotearg(outname);
#line 550
                            say((char const   *)((char *)"Not setting time of file %s (time mismatch)\n"),
                                __cil_tmp128);
                            }
                          } else {
#line 545
                            goto _L___223;
                          }
                        } else {
#line 545
                          goto _L___223;
                        }
                      } else {
#line 545
                        goto _L___223;
                      }
                    } else {
#line 545
                      goto _L___223;
                    }
                  } else
                  _L___223: /* CIL Label */ 
#line 553
                  if (! force) {
#line 553
                    if (mismatch | failed) {
                      {
#line 554
                      __cil_tmp129 = quotearg(outname);
#line 554
                      say((char const   *)((char *)"Not setting time of file %s (contents mismatch)\n"),
                          __cil_tmp129);
                      }
                    } else {
#line 558
                      attr |= (unsigned int )1;
                    }
                  } else {
#line 558
                    attr |= (unsigned int )1;
                  }
                }
              }
#line 561
              if (inerrno) {
                {
#line 562
                set_file_attributes(TMPOUTNAME, attr, (char const   *)((void *)0),
                                    (struct stat *)((void *)0), mode, & new_time);
                }
              } else {
                {
#line 566
                attr |= (unsigned int )14;
#line 567
                set_file_attributes(TMPOUTNAME, attr, (char const   *)inname, & instat,
                                    mode, & new_time);
                }
              }
              {
#line 571
              output_file(TMPOUTNAME, & TMPOUTNAME_needs_removal, & tmpoutst, outname,
                          (struct stat *)((void *)0), mode, backup);
#line 574
              __cil_tmp130 = pch_rename();
              }
#line 574
              if (__cil_tmp130) {
                {
#line 575
                output_file((char const   *)((void *)0), (int *)((void *)0), (struct stat *)((void *)0),
                            (char const   *)inname, & instat, mode, backup);
                }
              }
            } else
#line 533
            if ((unsigned int )diff_type == 3U) {
#line 533
              goto _L___227;
            } else
#line 533
            if (set_mode) {
#line 533
              goto _L___227;
            } else
#line 533
            if (__cil_tmp116) {
#line 533
              goto _L___227;
            } else
#line 533
            if (__cil_tmp117) {
#line 533
              goto _L___227;
            } else {
              {
#line 579
              output_file(outname, (int *)((void *)0), & tmpoutst, (char const   *)((void *)0),
                          (struct stat *)((void *)0), file_type, backup);
              }
            }
          }
        }
      }
    }
#line 584
    if ((unsigned int )diff_type != 3U) {
#line 587
      if (failed) {
        {
#line 588
        __cil_tmp134 = fclose(rejfp);
        }
        {
#line 588
        __cil_tmp132 = fileno(rejfp);
#line 588
        __cil_tmp133 = fstat(__cil_tmp132, & rejst);
        }
#line 588
        if (__cil_tmp133 != 0) {
          {
          {
#line 589
          write_fatal();
          }
          }
        } else
#line 588
        if (__cil_tmp134 != 0) {
          {
          {
#line 589
          write_fatal();
          }
          }
        }
#line 590
        rejfp = (FILE *)((void *)0);
#line 591
        somefailed = 1;
#line 592
        if (skip_rest_of_patch) {
#line 592
          tmp___235 = (char *)"ignored";
        } else {
#line 592
          tmp___235 = (char *)"FAILED";
        }
        {
#line 592
        say((char const   *)((char *)"%d out of %d hunk%s %s"), failed, hunk, (char *)"s" + (hunk == 1),
            tmp___235);
#line 594
        __cil_tmp136 = strcmp((char const   *)rejname, (char const   *)((char *)"-"));
        }
#line 594
        if (outname) {
#line 594
          if (! rejname) {
            _L___236: /* CIL Label */ 
#line 595
            rej = rejname;
#line 596
            if (! rejname) {
              {
#line 598
              s = simple_backup_suffix;
#line 600
              simple_backup_suffix = (char const   *)((char *)".rej");
#line 601
              rej = find_backup_file_name(outname, (enum backup_type )1);
#line 602
              len = strlen((char const   *)rej);
              }
#line 603
              if ((int )*(rej + (len - 1UL)) == 126) {
#line 604
                *(rej + (len - 1UL)) = (char )'#';
              }
#line 605
              simple_backup_suffix = s;
            }
#line 607
            if (! dry_run) {
              {
#line 609
              __cil_tmp142 = quotearg((char const   *)rej);
#line 609
              say((char const   *)((char *)" -- saving rejects to file %s\n"), __cil_tmp142);
              }
#line 610
              if (rejname) {
#line 612
                if (! written_to_rejname) {
                  {
#line 614
                  copy_file(TMPREJNAME, (char const   *)rejname, (struct stat *)0,
                            0, (mode_t )33206, 1);
#line 616
                  written_to_rejname = 1;
                  }
                } else {
                  {
#line 619
                  append_to_file(TMPREJNAME, (char const   *)rejname);
                  }
                }
              } else {
                {
#line 626
                olderrno = stat_file((char const   *)rej, & oldst);
                }
#line 627
                if (olderrno) {
#line 627
                  if (olderrno != 2) {
                    {
#line 628
                    write_fatal();
                    }
                  }
                }
                {
#line 629
                __cil_tmp146 = lookup_file_id(& oldst);
                }
#line 629
                if (! olderrno) {
#line 629
                  if ((unsigned int )__cil_tmp146 == 1U) {
                    {
#line 630
                    append_to_file(TMPREJNAME, (char const   *)rej);
                    }
                  } else {
                    {
                    {
#line 632
                    move_file(TMPREJNAME, & TMPREJNAME_needs_removal, & rejst, (char const   *)rej,
                              (mode_t )33206, 0);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 632
                  move_file(TMPREJNAME, & TMPREJNAME_needs_removal, & rejst, (char const   *)rej,
                            (mode_t )33206, 0);
                  }
                  }
                }
              }
            } else {
              {
#line 637
              say((char const   *)((char *)"\n"));
              }
            }
#line 638
            if (! rejname) {
              {
#line 639
              free((void *)rej);
              }
            }
          } else
#line 594
          if (__cil_tmp136 != 0) {
#line 594
            goto _L___236;
          } else {
            {
            {
#line 641
            say((char const   *)((char *)"\n"));
            }
            }
          }
        } else {
          {
          {
#line 641
          say((char const   *)((char *)"\n"));
          }
          }
        }
      }
    }
    {
#line 644
    set_signals(1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  apply_empty_patch = 0;
  {
#line 190
  reinitialize_almost_everything();
#line 646
  __cil_tmp148 = fclose(outstate.ofp);
  }
  {
#line 646
  __cil_tmp147 = ferror(outstate.ofp);
  }
#line 646
  if (outstate.ofp) {
#line 646
    if (__cil_tmp147) {
      {
      {
#line 647
      write_fatal();
      }
      }
    } else
#line 646
    if (__cil_tmp148 != 0) {
      {
      {
#line 647
      write_fatal();
      }
      }
    }
  }
  {
#line 648
  output_files((struct stat *)((void *)0));
#line 649
  delete_files();
#line 650
  cleanup();
  }
#line 651
  if (somefailed) {
    {
#line 652
    exit(1);
    }
  }
#line 653
  return (0);
}
}
#line 659 "/tmp/0/patch-2.7.1/src/patch.c"
static void reinitialize_almost_everything(void) 
{ 


  {
  {
#line 661
  re_patch();
#line 662
  re_input();
#line 664
  input_lines = (lin )0;
#line 665
  last_frozen_line = (lin )0;
  }
#line 667
  if (inname) {
#line 667
    if (! explicit_inname) {
      {
#line 668
      free((void *)inname);
#line 669
      inname = (char *)0;
      }
    }
  }
#line 672
  in_offset = (lin )0;
#line 673
  out_offset = (lin )0;
#line 675
  diff_type = (enum diff )0;
#line 677
  if (revision) {
    {
#line 678
    free((void *)revision);
#line 679
    revision = (char *)0;
    }
  }
#line 682
  reverse = reverse_flag_specified;
#line 683
  skip_rest_of_patch = 0;
}
}
#line 740 "/tmp/0/patch-2.7.1/src/patch.c"
static char const   * const  option_help[]  = 
#line 740
  {      (char const   *)((char *)"Input options:"),      (char const   *)((char *)""),      (char const   *)((char *)"  -p NUM  --strip=NUM  Strip NUM leading components from file names."),      (char const   *)((char *)"  -F LINES  --fuzz LINES  Set the fuzz factor to LINES for inexact matching."), 
        (char const   *)((char *)"  -l  --ignore-whitespace  Ignore white space changes between patch and input."),      (char const   *)((char *)""),      (char const   *)((char *)"  -c  --context  Interpret the patch as a context difference."),      (char const   *)((char *)"  -e  --ed  Interpret the patch as an ed script."), 
        (char const   *)((char *)"  -n  --normal  Interpret the patch as a normal difference."),      (char const   *)((char *)"  -u  --unified  Interpret the patch as a unified difference."),      (char const   *)((char *)""),      (char const   *)((char *)"  -N  --forward  Ignore patches that appear to be reversed or already applied."), 
        (char const   *)((char *)"  -R  --reverse  Assume patches were created with old and new files swapped."),      (char const   *)((char *)""),      (char const   *)((char *)"  -i PATCHFILE  --input=PATCHFILE  Read patch from PATCHFILE instead of stdin."),      (char const   *)((char *)""), 
        (char const   *)((char *)"Output options:"),      (char const   *)((char *)""),      (char const   *)((char *)"  -o FILE  --output=FILE  Output patched files to FILE."),      (char const   *)((char *)"  -r FILE  --reject-file=FILE  Output rejects to FILE."), 
        (char const   *)((char *)""),      (char const   *)((char *)"  -D NAME  --ifdef=NAME  Make merged if-then-else output using NAME."),      (char const   *)((char *)"  -m  --merge  Merge using conflict markers instead of creating reject files."),      (char const   *)((char *)"  -E  --remove-empty-files  Remove output files that are empty after patching."), 
        (char const   *)((char *)""),      (char const   *)((char *)"  -Z  --set-utc  Set times of patched files, assuming diff uses UTC (GMT)."),      (char const   *)((char *)"  -T  --set-time  Likewise, assuming local time."),      (char const   *)((char *)""), 
        (char const   *)((char *)"  --quoting-style=WORD   output file names using quoting style WORD."),      (char const   *)((char *)"    Valid WORDs are: literal, shell, shell-always, c, escape."),      (char const   *)((char *)"    Default is taken from QUOTING_STYLE env variable, or \'shell\' if unset."),      (char const   *)((char *)""), 
        (char const   *)((char *)"Backup and version control options:"),      (char const   *)((char *)""),      (char const   *)((char *)"  -b  --backup  Back up the original contents of each file."),      (char const   *)((char *)"  --backup-if-mismatch  Back up if the patch does not match exactly."), 
        (char const   *)((char *)"  --no-backup-if-mismatch  Back up mismatches only if otherwise requested."),      (char const   *)((char *)""),      (char const   *)((char *)"  -V STYLE  --version-control=STYLE  Use STYLE version control."),      (char const   *)((char *)"\tSTYLE is either \'simple\', \'numbered\', or \'existing\'."), 
        (char const   *)((char *)"  -B PREFIX  --prefix=PREFIX  Prepend PREFIX to backup file names."),      (char const   *)((char *)"  -Y PREFIX  --basename-prefix=PREFIX  Prepend PREFIX to backup file basenames."),      (char const   *)((char *)"  -z SUFFIX  --suffix=SUFFIX  Append SUFFIX to backup file names."),      (char const   *)((char *)""), 
        (char const   *)((char *)"  -g NUM  --get=NUM  Get files from RCS etc. if positive; ask if negative."),      (char const   *)((char *)""),      (char const   *)((char *)"Miscellaneous options:"),      (char const   *)((char *)""), 
        (char const   *)((char *)"  -t  --batch  Ask no questions; skip bad-Prereq patches; assume reversed."),      (char const   *)((char *)"  -f  --force  Like -t, but ignore bad-Prereq patches, and assume unreversed."),      (char const   *)((char *)"  -s  --quiet  --silent  Work silently unless an error occurs."),      (char const   *)((char *)"  --verbose  Output extra information about the work being done."), 
        (char const   *)((char *)"  --dry-run  Do not actually change any files; just print what would happen."),      (char const   *)((char *)"  --posix  Conform to the POSIX standard."),      (char const   *)((char *)""),      (char const   *)((char *)"  -d DIR  --directory=DIR  Change the working directory to DIR first."), 
        (char const   *)((char *)"  --reject-format=FORMAT  Create \'context\' or \'unified\' rejects."),      (char const   *)((char *)"  --binary  Read and write data in binary mode."),      (char const   *)((char *)"  --read-only=BEHAVIOR  How to handle read-only input files: \'ignore\' that they"),      (char const   *)((char *)"                        are read-only, \'warn\' (default), or \'fail\'."), 
        (char const   *)((char *)""),      (char const   *)((char *)"  -v  --version  Output version info."),      (char const   *)((char *)"  --help  Output this help."),      (char const   *)((char *)""), 
        (char const   *)((char *)"Report bugs to <bug-patch@gnu.org>."),      (char const   */* const  */)0};
#line 813 "/tmp/0/patch-2.7.1/src/patch.c"
static void usage(FILE *stream , int status ) 
{ 
  char const   * const  *p ;

  {
#line 817
  if (status != 0) {
    {
#line 819
    fprintf(stream, (char const   *)((char *)"%s: Try \'%s --help\' for more information.\n"),
            program_name, *(Argv + 0));
    }
  } else {
    {
#line 824
    fprintf(stream, (char const   *)((char *)"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\n\n"),
            *(Argv + 0));
#line 826
    p = (char const   * const  *)option_help;
    }
    {
#line 826
    while (1) {
      while_continue: /* CIL Label */ ;
#line 826
      if (! ((char const   *)*p)) {
#line 826
        goto while_break;
      }
      {
#line 827
      fprintf(stream, (char const   *)((char *)"%s\n"), (char const   *)*p);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 826
    p ++;
  }
  {
#line 830
  exit(status);
  }
}
}
#line 836 "/tmp/0/patch-2.7.1/src/patch.c"
static void get_some_switches(void) 
{ 
  int optc ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  int i ;
  ptrdiff_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 840
  free((void *)rejname);
#line 841
  rejname = (char *)0;
  }
#line 842
  if (optind == Argc) {
#line 843
    return;
  }
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (optc != -1)) {
#line 844
      goto while_break;
    }
    {
#line 847
    if (optc == 'b') {
#line 847
      goto case_98;
    }
#line 865
    if (optc == 'B') {
#line 865
      goto case_66;
    }
#line 870
    if (optc == 'c') {
#line 870
      goto case_99;
    }
#line 873
    if (optc == 'd') {
#line 873
      goto case_100;
    }
#line 877
    if (optc == 'D') {
#line 877
      goto case_68;
    }
#line 880
    if (optc == 'e') {
#line 880
      goto case_101;
    }
#line 883
    if (optc == 'E') {
#line 883
      goto case_69;
    }
#line 886
    if (optc == 'f') {
#line 886
      goto case_102;
    }
#line 889
    if (optc == 'F') {
#line 889
      goto case_70;
    }
#line 892
    if (optc == 'g') {
#line 892
      goto case_103;
    }
#line 895
    if (optc == 'i') {
#line 895
      goto case_105;
    }
#line 898
    if (optc == 'l') {
#line 898
      goto case_108;
    }
#line 902
    if (optc == 'm') {
#line 902
      goto case_109;
    }
#line 917
    if (optc == 'n') {
#line 917
      goto case_110;
    }
#line 920
    if (optc == 'N') {
#line 920
      goto case_78;
    }
#line 923
    if (optc == 'o') {
#line 923
      goto case_111;
    }
#line 926
    if (optc == 'p') {
#line 926
      goto case_112;
    }
#line 929
    if (optc == 'r') {
#line 929
      goto case_114;
    }
#line 932
    if (optc == 'R') {
#line 932
      goto case_82;
    }
#line 936
    if (optc == 's') {
#line 936
      goto case_115;
    }
#line 939
    if (optc == 't') {
#line 939
      goto case_116;
    }
#line 942
    if (optc == 'T') {
#line 942
      goto case_84;
    }
#line 945
    if (optc == 'u') {
#line 945
      goto case_117;
    }
#line 948
    if (optc == 'v') {
#line 948
      goto case_118;
    }
#line 952
    if (optc == 'V') {
#line 952
      goto case_86;
    }
#line 957
    if (optc == 'x') {
#line 957
      goto case_120;
    }
#line 961
    if (optc == 'Y') {
#line 961
      goto case_89;
    }
#line 966
    if (optc == 'z') {
#line 966
      goto case_z;
    }
#line 972
    if (optc == 'Z') {
#line 972
      goto case_90;
    }
#line 975
    if (optc == 128) {
#line 975
      goto case_128;
    }
#line 978
    if (optc == 129) {
#line 978
      goto case_129;
    }
#line 981
    if (optc == 130) {
#line 981
      goto case_130;
    }
#line 987
    if (optc == 131) {
#line 987
      goto case_131;
    }
#line 989
    if (optc == 132) {
#line 989
      goto case_132;
    }
#line 992
    if (optc == 133) {
#line 992
      goto case_133;
    }
#line 995
    if (optc == 134) {
#line 995
      goto case_134;
    }
#line 998
    if (optc == 135) {
#line 998
      goto case_135;
    }
#line 1010
    if (optc == 136) {
#line 1010
      goto case_136;
    }
#line 1018
    if (optc == 137) {
#line 1018
      goto case_137;
    }
#line 1028
    if (optc == 138) {
#line 1028
      goto case_138;
    }
#line 1031
    goto switch_default;
    case_98: /* CIL Label */ 
#line 848
    make_backups = 1;
    {
#line 852
    __cil_tmp3 = strcmp((char const   *)*(Argv + (optind - 1)), (char const   *)((char *)"-b"));
    }
#line 852
    if (Argc - optind == 3) {
#line 852
      if (__cil_tmp3 == 0) {
#line 852
        if (! ((int )*(*(Argv + optind) + 0) == 45 && (int )*(*(Argv + optind) + 1))) {
#line 852
          if (! ((int )*(*(Argv + (optind + 1)) + 0) == 45 && (int )*(*(Argv + (optind + 1)) + 1))) {
#line 852
            if (! ((int )*(*(Argv + (optind + 2)) + 0) == 45 && (int )*(*(Argv + (optind + 2)) + 1))) {
#line 858
              __cil_tmp4 = optind;
#line 858
              optind ++;
#line 858
              optarg = *(Argv + __cil_tmp4);
#line 859
              if ((unsigned int )verbosity != 1U) {
                {
#line 860
                say((char const   *)((char *)"warning: the \'-b %s\' option is obsolete; use \'-b -z %s\' instead\n"),
                    optarg, optarg);
                }
              }
#line 862
              goto case_z;
            }
          }
        }
      }
    }
#line 864
    goto switch_break;
    case_66: /* CIL Label */ 
#line 866
    if (! *optarg) {
      {
#line 867
      fatal((char const   *)((char *)"backup prefix is empty"));
      }
    }
    {
#line 868
    __cil_tmp5 = savestr((char const   *)optarg);
#line 868
    origprae = (char const   *)__cil_tmp5;
    }
#line 869
    goto switch_break;
    case_99: /* CIL Label */ 
#line 871
    diff_type = (enum diff )1;
#line 872
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 874
    __cil_tmp6 = chdir((char const   *)optarg);
    }
#line 874
    if (__cil_tmp6 < 0) {
      {
#line 875
      __cil_tmp7 = quotearg((char const   *)optarg);
#line 875
      pfatal((char const   *)((char *)"Can\'t change to directory %s"), __cil_tmp7);
      }
    }
#line 876
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 878
    __cil_tmp8 = savestr((char const   *)optarg);
#line 878
    do_defines = (char const   *)__cil_tmp8;
    }
#line 879
    goto switch_break;
    case_101: /* CIL Label */ 
#line 881
    diff_type = (enum diff )3;
#line 882
    goto switch_break;
    case_69: /* CIL Label */ 
#line 884
    remove_empty_files = 1;
#line 885
    goto switch_break;
    case_102: /* CIL Label */ 
#line 887
    force = 1;
#line 888
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 890
    __cil_tmp9 = numeric_string((char const   *)optarg, 0, (char const   *)((char *)"fuzz factor"));
#line 890
    maxfuzz = (lin )__cil_tmp9;
    }
#line 891
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 893
    patch_get = numeric_string((char const   *)optarg, 1, (char const   *)((char *)"get option value"));
    }
#line 894
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 896
    __cil_tmp11 = savestr((char const   *)optarg);
#line 896
    patchname = (char const   *)__cil_tmp11;
    }
#line 897
    goto switch_break;
    case_108: /* CIL Label */ 
#line 899
    canonicalize = 1;
#line 900
    goto switch_break;
    case_109: /* CIL Label */ 
#line 903
    merge = 1;
#line 904
    if (optarg) {
      {
#line 906
      __cil_tmp12 = strcmp((char const   *)optarg, (char const   *)((char *)"merge"));
      }
#line 906
      if (! __cil_tmp12) {
#line 907
        conflict_style = (enum conflict_style )0;
      } else {
        {
#line 908
        __cil_tmp13 = strcmp((char const   *)optarg, (char const   *)((char *)"diff3"));
        }
#line 908
        if (! __cil_tmp13) {
#line 909
          conflict_style = (enum conflict_style )1;
        } else {
          {
#line 911
          usage(stderr, 2);
          }
        }
      }
    } else {
#line 914
      conflict_style = (enum conflict_style )0;
    }
#line 915
    goto switch_break;
    case_110: /* CIL Label */ 
#line 918
    diff_type = (enum diff )2;
#line 919
    goto switch_break;
    case_78: /* CIL Label */ 
#line 921
    noreverse = 1;
#line 922
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 924
    outfile = savestr((char const   *)optarg);
    }
#line 925
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 927
    strippath = numeric_string((char const   *)optarg, 0, (char const   *)((char *)"strip count"));
    }
#line 928
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 930
    rejname = savestr((char const   *)optarg);
    }
#line 931
    goto switch_break;
    case_82: /* CIL Label */ 
#line 933
    reverse = 1;
#line 934
    reverse_flag_specified = 1;
#line 935
    goto switch_break;
    case_115: /* CIL Label */ 
#line 937
    verbosity = (int )1;
#line 938
    goto switch_break;
    case_116: /* CIL Label */ 
#line 940
    batch = 1;
#line 941
    goto switch_break;
    case_84: /* CIL Label */ 
#line 943
    set_time = 1;
#line 944
    goto switch_break;
    case_117: /* CIL Label */ 
#line 946
    diff_type = (enum diff )5;
#line 947
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 949
    version();
    }
    {
#line 950
    exit(0);
    }
#line 951
    goto switch_break;
    case_86: /* CIL Label */ 
#line 953
    version_control = (char const   *)optarg;
#line 954
    version_control_context = (char const   *)((char *)"--version-control or -V option");
#line 955
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 958
    debug = numeric_string((char const   *)optarg, 1, (char const   *)((char *)"debugging option"));
    }
#line 959
    goto switch_break;
    case_89: /* CIL Label */ 
#line 962
    if (! *optarg) {
      {
#line 963
      fatal((char const   *)((char *)"backup basename prefix is empty"));
      }
    }
    {
#line 964
    __cil_tmp18 = savestr((char const   *)optarg);
#line 964
    origbase = (char const   *)__cil_tmp18;
    }
#line 965
    goto switch_break;
    case_z: 
    case_122: /* CIL Label */ 
#line 968
    if (! *optarg) {
      {
#line 969
      fatal((char const   *)((char *)"backup suffix is empty"));
      }
    }
    {
#line 970
    __cil_tmp19 = savestr((char const   *)optarg);
#line 970
    origsuff = (char const   *)__cil_tmp19;
    }
#line 971
    goto switch_break;
    case_90: /* CIL Label */ 
#line 973
    set_utc = 1;
#line 974
    goto switch_break;
    case_128: /* CIL Label */ 
#line 976
    dry_run = 1;
#line 977
    goto switch_break;
    case_129: /* CIL Label */ 
#line 979
    verbosity = (int )2;
#line 980
    goto switch_break;
    case_130: /* CIL Label */ 
#line 982
    no_strip_trailing_cr = 1;
#line 986
    goto switch_break;
    case_131: /* CIL Label */ 
    {
#line 988
    usage(stdout, 0);
    }
    case_132: /* CIL Label */ 
#line 990
    backup_if_mismatch = 1;
#line 991
    goto switch_break;
    case_133: /* CIL Label */ 
#line 993
    backup_if_mismatch = 0;
#line 994
    goto switch_break;
    case_134: /* CIL Label */ 
#line 996
    posixly_correct = 1;
#line 997
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 1000
    __cil_tmp21 = argmatch((char const   *)optarg, (char const   * const  *)quoting_style_args,
                           (char const   *)0, (size_t )0);
#line 1000
    i = (int )__cil_tmp21;
    }
#line 1001
    if (i < 0) {
      {
#line 1003
      argmatch_invalid((char const   *)((char *)"quoting style"), (char const   *)optarg,
                       (ptrdiff_t )i);
#line 1004
      usage(stderr, 2);
      }
    }
    {
#line 1006
    set_quoting_style((struct quoting_options *)0, (enum quoting_style )i);
    }
#line 1009
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 1011
    __cil_tmp22 = strcmp((char const   *)optarg, (char const   *)((char *)"context"));
    }
#line 1011
    if (__cil_tmp22 == 0) {
#line 1012
      reject_format = (enum diff )4;
    } else {
      {
#line 1013
      __cil_tmp23 = strcmp((char const   *)optarg, (char const   *)((char *)"unified"));
      }
#line 1013
      if (__cil_tmp23 == 0) {
#line 1014
        reject_format = (enum diff )5;
      } else {
        {
#line 1016
        usage(stderr, 2);
        }
      }
    }
#line 1017
    goto switch_break;
    case_137: /* CIL Label */ 
    {
#line 1019
    __cil_tmp24 = strcmp((char const   *)optarg, (char const   *)((char *)"ignore"));
    }
#line 1019
    if (__cil_tmp24 == 0) {
#line 1020
      read_only_behavior = (int )0;
    } else {
      {
#line 1021
      __cil_tmp25 = strcmp((char const   *)optarg, (char const   *)((char *)"warn"));
      }
#line 1021
      if (__cil_tmp25 == 0) {
#line 1022
        read_only_behavior = (int )1;
      } else {
        {
#line 1023
        __cil_tmp26 = strcmp((char const   *)optarg, (char const   *)((char *)"fail"));
        }
#line 1023
        if (__cil_tmp26 == 0) {
#line 1024
          read_only_behavior = (int )2;
        } else {
          {
#line 1026
          usage(stderr, 2);
          }
        }
      }
    }
#line 1027
    goto switch_break;
    case_138: /* CIL Label */ 
#line 1029
    follow_symlinks = 1;
#line 1030
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1032
    usage(stderr, 2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1037
  if (optind < Argc) {
    {
#line 1039
    __cil_tmp27 = optind;
#line 1039
    optind ++;
#line 1039
    __cil_tmp28 = savestr((char const   *)*(Argv + __cil_tmp27));
#line 1039
    inname = __cil_tmp28;
#line 1040
    explicit_inname = 1;
#line 1041
    invc = - 1;
    }
#line 1042
    if (optind < Argc) {
      {
#line 1044
      __cil_tmp29 = optind;
#line 1044
      optind ++;
#line 1044
      __cil_tmp30 = savestr((char const   *)*(Argv + __cil_tmp29));
#line 1044
      patchname = (char const   *)__cil_tmp30;
      }
#line 1045
      if (optind < Argc) {
        {
#line 1047
        __cil_tmp31 = quotearg((char const   *)*(Argv + optind));
#line 1047
        fprintf(stderr, (char const   *)((char *)"%s: %s: extra operand\n"), program_name,
                __cil_tmp31);
#line 1049
        usage(stderr, 2);
        }
      }
    }
  }
}
}
#line 1059 "/tmp/0/patch-2.7.1/src/patch.c"
static int numeric_string(char const   *string , int negative_allowed , char const   *argtype_msgid ) 
{ 
  int value ;
  char const   *p ;
  int sign ;
  int tmp ;
  int v10 ;
  int digit ;
  int signed_digit ;
  int next_value ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1063
  value = 0;
#line 1064
  p = string;
#line 1065
  if ((int )((char )*p) == 45) {
#line 1065
    tmp = - 1;
  } else {
#line 1065
    tmp = 1;
  }
#line 1065
  sign = tmp;
#line 1067
  p += (int )((char )*p) == 45 || (int )((char )*p) == 43;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1071
    v10 = value * 10;
#line 1072
    digit = (int )((char )*p) - 48;
#line 1073
    signed_digit = sign * digit;
#line 1074
    next_value = v10 + signed_digit;
#line 1076
    if (9U < (unsigned int )digit) {
      {
#line 1077
      __cil_tmp12 = quotearg(string);
#line 1077
      fatal((char const   *)((char *)"%s %s is not a number"), argtype_msgid, __cil_tmp12);
      }
    }
#line 1079
    if (v10 / 10 != value) {
      {
      {
#line 1080
      __cil_tmp13 = quotearg(string);
      }
      {
#line 1080
      fatal((char const   *)((char *)"%s %s is too large"), argtype_msgid, __cil_tmp13);
      }
      }
    } else
#line 1079
    if ((next_value < v10) != (signed_digit < 0)) {
      {
      {
#line 1080
      __cil_tmp13 = quotearg(string);
      }
      {
#line 1080
      fatal((char const   *)((char *)"%s %s is too large"), argtype_msgid, __cil_tmp13);
      }
      }
    }
#line 1082
    value = next_value;
#line 1069
    if (! ((char )*p)) {
#line 1069
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1086
  if (value < 0) {
#line 1086
    if (! negative_allowed) {
      {
#line 1087
      __cil_tmp14 = quotearg(string);
#line 1087
      fatal((char const   *)((char *)"%s %s is negative"), argtype_msgid, __cil_tmp14);
      }
    }
  }
#line 1089
  return (value);
}
}
#line 1095 "/tmp/0/patch-2.7.1/src/patch.c"
static lin locate_hunk(lin fuzz ) 
{ 
  lin first_guess ;
  lin __cil_tmp3 ;
  lin offset ;
  lin pat_lines ;
  lin __cil_tmp6 ;
  lin prefix_context ;
  lin __cil_tmp8 ;
  lin suffix_context ;
  lin __cil_tmp10 ;
  lin context ;
  lin tmp ;
  lin prefix_fuzz ;
  lin suffix_fuzz ;
  lin max_where ;
  lin min_where ;
  lin max_pos_offset ;
  lin max_neg_offset ;
  lin max_offset ;
  lin tmp___237 ;
  lin __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char numbuf0[23] ;
  char numbuf1[23] ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1097
  __cil_tmp3 = pch_first();
#line 1097
  first_guess = __cil_tmp3 + in_offset;
#line 1099
  __cil_tmp6 = pch_ptrn_lines();
#line 1099
  pat_lines = __cil_tmp6;
#line 1100
  __cil_tmp8 = pch_prefix_context();
#line 1100
  prefix_context = __cil_tmp8;
#line 1101
  __cil_tmp10 = pch_suffix_context();
#line 1101
  suffix_context = __cil_tmp10;
  }
#line 1102
  if (prefix_context < suffix_context) {
#line 1102
    tmp = suffix_context;
  } else {
#line 1102
    tmp = prefix_context;
  }
#line 1102
  context = tmp;
#line 1104
  prefix_fuzz = (fuzz + prefix_context) - context;
#line 1105
  suffix_fuzz = (fuzz + suffix_context) - context;
#line 1106
  max_where = (input_lines - (pat_lines - suffix_fuzz)) + 1L;
#line 1107
  min_where = (last_frozen_line + 1L) - (prefix_context - prefix_fuzz);
#line 1108
  max_pos_offset = max_where - first_guess;
#line 1109
  max_neg_offset = first_guess - min_where;
#line 1110
  if (max_pos_offset < max_neg_offset) {
#line 1110
    tmp___237 = max_neg_offset;
  } else {
#line 1110
    tmp___237 = max_pos_offset;
  }
#line 1110
  max_offset = tmp___237;
#line 1113
  if (! pat_lines) {
#line 1114
    return (first_guess);
  }
#line 1117
  if (first_guess <= max_neg_offset) {
#line 1118
    max_neg_offset = first_guess - 1L;
  }
  {
#line 1120
  __cil_tmp21 = pch_first();
  }
#line 1120
  if (prefix_fuzz < 0L) {
#line 1120
    if (__cil_tmp21 <= 1L) {
#line 1124
      if (suffix_fuzz < 0L) {
#line 1126
        if (pat_lines != input_lines) {
#line 1127
          return ((lin )0);
        } else
#line 1126
        if (prefix_context < last_frozen_line) {
#line 1127
          return ((lin )0);
        }
      }
      {
#line 1129
      offset = 1L - first_guess;
#line 1130
      __cil_tmp22 = patch_match(first_guess, offset, (lin )0, suffix_fuzz);
      }
#line 1130
      if (last_frozen_line <= prefix_context) {
#line 1130
        if (offset <= max_pos_offset) {
#line 1130
          if (__cil_tmp22) {
#line 1134
            in_offset += offset;
#line 1135
            return (first_guess + offset);
          } else {
#line 1138
            return ((lin )0);
          }
        } else {
#line 1138
          return ((lin )0);
        }
      } else {
#line 1138
        return ((lin )0);
      }
    } else {
#line 1120
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1140
  if (prefix_fuzz < 0L) {
#line 1141
    prefix_fuzz = (lin )0;
  }
#line 1143
  if (suffix_fuzz < 0L) {
    {
#line 1146
    offset = first_guess - ((input_lines - pat_lines) + 1L);
#line 1147
    __cil_tmp23 = patch_match(first_guess, - offset, prefix_fuzz, (lin )0);
    }
#line 1147
    if (offset <= max_neg_offset) {
#line 1147
      if (__cil_tmp23) {
#line 1150
        in_offset -= offset;
#line 1151
        return (first_guess - offset);
      } else {
#line 1154
        return ((lin )0);
      }
    } else {
#line 1154
      return ((lin )0);
    }
  }
#line 1157
  offset = (lin )0;
  {
#line 1157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1157
    if (! (offset <= max_offset)) {
#line 1157
      goto while_break;
    }
    {
#line 1160
    __cil_tmp26 = patch_match(first_guess, offset, prefix_fuzz, suffix_fuzz);
    }
#line 1160
    if (offset <= max_pos_offset) {
#line 1160
      if (__cil_tmp26) {
#line 1162
        if (debug & 1) {
          {
#line 1163
          __cil_tmp27 = format_linenum((char *)numbuf0, in_offset);
          }
          {
#line 1163
          __cil_tmp28 = format_linenum((char *)numbuf1, in_offset + offset);
#line 1163
          say((char const   *)((char *)"Offset changing from %s to %s\n"), __cil_tmp27,
              __cil_tmp28);
          }
        }
#line 1166
        in_offset += offset;
#line 1167
        return (first_guess + offset);
      }
    }
    {
#line 1169
    __cil_tmp29 = patch_match(first_guess, - offset, prefix_fuzz, suffix_fuzz);
    }
#line 1169
    if (0L < offset) {
#line 1169
      if (offset <= max_neg_offset) {
#line 1169
        if (__cil_tmp29) {
#line 1171
          if (debug & 1) {
            {
#line 1172
            __cil_tmp30 = format_linenum((char *)numbuf0, in_offset);
            }
            {
#line 1172
            __cil_tmp31 = format_linenum((char *)numbuf1, in_offset - offset);
#line 1172
            say((char const   *)((char *)"Offset changing from %s to %s\n"), __cil_tmp30,
                __cil_tmp31);
            }
          }
#line 1175
          in_offset -= offset;
#line 1176
          return (first_guess - offset);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1157
  offset ++;
#line 1179
  return ((lin )0);
}
}
#line 1183 "/tmp/0/patch-2.7.1/src/patch.c"
static void mangled_patch(lin old , lin new ) 
{ 
  char numbuf0[23] ;
  char numbuf1[23] ;
  char __cil_tmp5 ;
  char __cil_tmp6 ;
  lin __cil_tmp7 ;
  char *__cil_tmp8 ;
  lin __cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1187
  if (debug & 1) {
    {
#line 1188
    __cil_tmp5 = pch_char(old);
    }
    {
#line 1188
    __cil_tmp6 = pch_char(new);
#line 1188
    say((char const   *)((char *)"oldchar = \'%c\', newchar = \'%c\'\n"), (int )__cil_tmp5,
        (int )__cil_tmp6);
    }
  }
  {
#line 1190
  __cil_tmp7 = pch_hunk_beg();
#line 1190
  __cil_tmp8 = format_linenum((char *)numbuf0, __cil_tmp7 + old);
  }
  {
#line 1190
  __cil_tmp9 = pch_hunk_beg();
#line 1190
  __cil_tmp10 = format_linenum((char *)numbuf1, __cil_tmp9 + new);
#line 1190
  fatal((char const   *)((char *)"Out-of-sync patch, lines %s,%s -- mangled text or line numbers, maybe?"),
        __cil_tmp8, __cil_tmp10);
  }
}
}
#line 1199 "/tmp/0/patch-2.7.1/src/patch.c"
static void print_unidiff_range(FILE *fp , lin start , lin count ) 
{ 
  char numbuf0[23] ;
  char numbuf1[23] ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1206
  if (count == (lin )0) {
#line 1206
    goto case_0;
  }
#line 1210
  if (count == (lin )1) {
#line 1210
    goto case_1;
  }
#line 1214
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1207
  __cil_tmp6 = format_linenum((char *)numbuf0, start - 1L);
#line 1207
  fprintf(fp, (char const   *)((char *)"%s,0"), __cil_tmp6);
  }
#line 1208
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1211
  __cil_tmp7 = format_linenum((char *)numbuf0, start);
#line 1211
  fprintf(fp, (char const   *)((char *)"%s"), __cil_tmp7);
  }
#line 1212
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1215
  __cil_tmp8 = format_linenum((char *)numbuf0, start);
  }
  {
#line 1215
  __cil_tmp9 = format_linenum((char *)numbuf1, count);
#line 1215
  fprintf(fp, (char const   *)((char *)"%s,%s"), __cil_tmp8, __cil_tmp9);
  }
#line 1218
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1223 "/tmp/0/patch-2.7.1/src/patch.c"
static void print_header_line(FILE *fp , char const   *tag , int reverse___0 ) 
{ 
  char const   *name ;
  char const   *__cil_tmp5 ;
  char const   *timestr ;
  char const   *__cil_tmp7 ;
  char const   *tmp ;
  char const   *tmp___238 ;

  {
  {
#line 1225
  __cil_tmp5 = pch_name((enum nametype )reverse___0);
#line 1225
  name = __cil_tmp5;
#line 1226
  __cil_tmp7 = pch_timestr(reverse___0);
#line 1226
  timestr = __cil_tmp7;
  }
#line 1228
  if (name) {
#line 1228
    tmp = name;
  } else {
#line 1228
    tmp = (char const   *)((char *)"/dev/null");
  }
#line 1228
  if (timestr) {
#line 1228
    tmp___238 = timestr;
  } else {
#line 1228
    tmp___238 = (char const   *)((char *)"");
  }
  {
#line 1228
  fprintf(fp, (char const   *)((char *)"%s %s%s\n"), tag, tmp, tmp___238);
  }
}
}
#line 1235 "/tmp/0/patch-2.7.1/src/patch.c"
static void abort_hunk_unified(int header , int reverse___0 ) 
{ 
  lin old ;
  lin lastline ;
  lin __cil_tmp5 ;
  lin new ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  lin __cil_tmp9 ;
  lin __cil_tmp10 ;
  lin __cil_tmp11 ;
  char __cil_tmp12 ;
  char __cil_tmp13 ;
  char __cil_tmp15 ;
  char __cil_tmp17 ;
  char __cil_tmp19 ;
  char __cil_tmp20 ;
  lin __cil_tmp21 ;
  lin __cil_tmp22 ;
  char __cil_tmp23 ;

  {
  {
#line 1237
  old = (lin )1;
#line 1238
  __cil_tmp5 = pch_ptrn_lines();
#line 1238
  lastline = __cil_tmp5;
#line 1239
  new = lastline + 1L;
  }
#line 1241
  if (header) {
    {
#line 1243
    __cil_tmp7 = pch_name((enum nametype )2);
    }
#line 1243
    if (__cil_tmp7) {
      {
#line 1244
      __cil_tmp8 = pch_name((enum nametype )2);
#line 1244
      fprintf(rejfp, (char const   *)((char *)"Index: %s\n"), __cil_tmp8);
      }
    }
    {
#line 1245
    print_header_line(rejfp, (char const   *)((char *)"---"), reverse___0);
#line 1246
    print_header_line(rejfp, (char const   *)((char *)"+++"), ! reverse___0);
    }
  }
  {
#line 1250
  fprintf(rejfp, (char const   *)((char *)"@@ -"));
#line 1251
  __cil_tmp9 = pch_first();
#line 1251
  print_unidiff_range(rejfp, __cil_tmp9 + out_offset, lastline);
#line 1252
  fprintf(rejfp, (char const   *)((char *)" +"));
#line 1253
  __cil_tmp10 = pch_newfirst();
  }
  {
#line 1253
  __cil_tmp11 = pch_repl_lines();
#line 1253
  print_unidiff_range(rejfp, __cil_tmp10 + out_offset, __cil_tmp11);
#line 1254
  fprintf(rejfp, (char const   *)((char *)" @@\n"));
  }
  {
#line 1256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1256
    if (! ((int )__cil_tmp12 == 61 || (int )__cil_tmp13 == 10)) {
#line 1256
      goto while_break;
    }
#line 1257
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  if ((unsigned int )diff_type != 5U) {
    {
#line 1260
    pch_normalize((enum diff )5);
    }
  }
  {
#line 1262
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1262
    if (! 1) {
#line 1262
      goto while_break___0;
    }
    {
#line 1264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1264
      if (! ((int )__cil_tmp15 == 45)) {
#line 1264
        goto while_break___1;
      }
      {
#line 1266
      fputc('-', rejfp);
#line 1267
      pch_write_line(old, rejfp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1264
    old ++;
    {
#line 1269
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1269
      if (! ((int )__cil_tmp17 == 43)) {
#line 1269
        goto while_break___2;
      }
      {
#line 1271
      fputc('+', rejfp);
#line 1272
      pch_write_line(new, rejfp);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1269
    new ++;
#line 1275
    if (old > lastline) {
#line 1276
      goto while_break___0;
    }
    {
#line 1278
    __cil_tmp20 = pch_char(old);
    }
    {
#line 1278
    __cil_tmp19 = pch_char(new);
    }
#line 1278
    if ((int )__cil_tmp19 != (int )__cil_tmp20) {
      {
#line 1279
      mangled_patch(old, new);
      }
    }
    {
#line 1281
    fputc(' ', rejfp);
#line 1282
    pch_write_line(old, rejfp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1262
  __cil_tmp22 = new;
#line 1262
  new ++;
  {
#line 1262
  __cil_tmp21 = old;
#line 1262
  old ++;
#line 1284
  __cil_tmp23 = pch_char(new);
  }
#line 1284
  if ((int )__cil_tmp23 != 94) {
    {
#line 1285
    mangled_patch(old, new);
    }
  }
}
}
#line 1291 "/tmp/0/patch-2.7.1/src/patch.c"
static void abort_hunk_context(int header , int reverse___0 ) 
{ 
  lin i ;
  lin pat_end ;
  lin __cil_tmp5 ;
  lin oldfirst ;
  lin __cil_tmp7 ;
  lin newfirst ;
  lin __cil_tmp9 ;
  lin oldlast ;
  lin __cil_tmp11 ;
  lin newlast ;
  lin __cil_tmp13 ;
  char const   *stars ;
  char *tmp ;
  char const   *minuses ;
  char *tmp___239 ;
  char const   *c_function ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  char const   *__cil_tmp21 ;
  char const   *tmp___240 ;
  char numbuf0[23] ;
  char numbuf1[23] ;
  char __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char __cil_tmp32 ;
  int __cil_tmp33 ;

  {
  {
#line 1294
  __cil_tmp5 = pch_end();
#line 1294
  pat_end = __cil_tmp5;
#line 1296
  __cil_tmp7 = pch_first();
#line 1296
  oldfirst = __cil_tmp7 + out_offset;
#line 1297
  __cil_tmp9 = pch_newfirst();
#line 1297
  newfirst = __cil_tmp9 + out_offset;
#line 1298
  __cil_tmp11 = pch_ptrn_lines();
#line 1298
  oldlast = (oldfirst + __cil_tmp11) - 1L;
#line 1299
  __cil_tmp13 = pch_repl_lines();
#line 1299
  newlast = (newfirst + __cil_tmp13) - 1L;
  }
#line 1300
  if (4 <= (int )diff_type) {
#line 1300
    tmp = (char *)" ****";
  } else {
#line 1300
    tmp = (char *)"";
  }
#line 1300
  stars = (char const   *)tmp;
#line 1302
  if (4 <= (int )diff_type) {
#line 1302
    tmp___239 = (char *)" ----";
  } else {
#line 1302
    tmp___239 = (char *)" -----";
  }
  {
#line 1302
  minuses = (char const   *)tmp___239;
#line 1304
  __cil_tmp19 = pch_c_function();
#line 1304
  c_function = __cil_tmp19;
  }
#line 1306
  if ((unsigned int )diff_type == 5U) {
    {
#line 1307
    pch_normalize((enum diff )4);
    }
  }
#line 1309
  if (header) {
    {
#line 1311
    __cil_tmp20 = pch_name((enum nametype )2);
    }
#line 1311
    if (__cil_tmp20) {
      {
#line 1312
      __cil_tmp21 = pch_name((enum nametype )2);
#line 1312
      fprintf(rejfp, (char const   *)((char *)"Index: %s\n"), __cil_tmp21);
      }
    }
    {
#line 1313
    print_header_line(rejfp, (char const   *)((char *)"***"), reverse___0);
#line 1314
    print_header_line(rejfp, (char const   *)((char *)"---"), ! reverse___0);
    }
  }
#line 1316
  if (c_function) {
#line 1316
    tmp___240 = c_function;
  } else {
#line 1316
    tmp___240 = (char const   *)((char *)"");
  }
  {
#line 1316
  fprintf(rejfp, (char const   *)((char *)"***************%s\n"), tmp___240);
#line 1317
  i = (lin )0;
  }
  {
#line 1317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1317
    if (! (i <= pat_end)) {
#line 1317
      goto while_break;
    }
    {
#line 1320
    __cil_tmp25 = pch_char(i);
    }
    {
#line 1321
    if ((int )__cil_tmp25 == '*') {
#line 1321
      goto case_42;
    }
#line 1332
    if ((int )__cil_tmp25 == '=') {
#line 1332
      goto case_61;
    }
#line 1343
    if ((int )__cil_tmp25 == '!') {
#line 1343
      goto case_33;
    }
#line 1343
    if ((int )__cil_tmp25 == '+') {
#line 1343
      goto case_33;
    }
#line 1343
    if ((int )__cil_tmp25 == '-') {
#line 1343
      goto case_33;
    }
#line 1343
    if ((int )__cil_tmp25 == ' ') {
#line 1343
      goto case_33;
    }
#line 1346
    if ((int )__cil_tmp25 == '\n') {
#line 1346
      goto case_10;
    }
#line 1349
    goto switch_default;
    case_42: /* CIL Label */ 
#line 1322
    if (oldlast < oldfirst) {
      {
#line 1323
      fprintf(rejfp, (char const   *)((char *)"*** 0%s\n"), stars);
      }
    } else
#line 1324
    if (oldlast == oldfirst) {
      {
#line 1325
      __cil_tmp26 = format_linenum((char *)numbuf0, oldfirst);
#line 1325
      fprintf(rejfp, (char const   *)((char *)"*** %s%s\n"), __cil_tmp26, stars);
      }
    } else {
      {
#line 1328
      __cil_tmp27 = format_linenum((char *)numbuf0, oldfirst);
      }
      {
#line 1328
      __cil_tmp28 = format_linenum((char *)numbuf1, oldlast);
#line 1328
      fprintf(rejfp, (char const   *)((char *)"*** %s,%s%s\n"), __cil_tmp27, __cil_tmp28,
              stars);
      }
    }
#line 1331
    goto switch_break;
    case_61: /* CIL Label */ 
#line 1333
    if (newlast < newfirst) {
      {
#line 1334
      fprintf(rejfp, (char const   *)((char *)"--- 0%s\n"), minuses);
      }
    } else
#line 1335
    if (newlast == newfirst) {
      {
#line 1336
      __cil_tmp29 = format_linenum((char *)numbuf0, newfirst);
#line 1336
      fprintf(rejfp, (char const   *)((char *)"--- %s%s\n"), __cil_tmp29, minuses);
      }
    } else {
      {
#line 1339
      __cil_tmp30 = format_linenum((char *)numbuf0, newfirst);
      }
      {
#line 1339
      __cil_tmp31 = format_linenum((char *)numbuf1, newlast);
#line 1339
      fprintf(rejfp, (char const   *)((char *)"--- %s,%s%s\n"), __cil_tmp30, __cil_tmp31,
              minuses);
      }
    }
#line 1342
    goto switch_break;
    case_33: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 1344
    __cil_tmp32 = pch_char(i);
#line 1344
    fprintf(rejfp, (char const   *)((char *)"%c "), (int )__cil_tmp32);
    }
    case_10: /* CIL Label */ 
    {
#line 1347
    pch_write_line(i, rejfp);
    }
#line 1348
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1350
    fatal((char const   *)((char *)"fatal internal error in abort_hunk_context"));
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1352
    __cil_tmp33 = ferror(rejfp);
    }
#line 1352
    if (__cil_tmp33) {
      {
#line 1353
      write_fatal();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1317
  i ++;
}
}
#line 1360 "/tmp/0/patch-2.7.1/src/patch.c"
static void abort_hunk(char const   *outname , int header , int reverse___0 ) 
{ 


  {
#line 1362
  if (! TMPREJNAME_needs_removal) {
    {
#line 1363
    init_reject(outname);
    }
  }
#line 1364
  if ((unsigned int )reject_format == 5U) {
    {
    {
#line 1366
    abort_hunk_unified(header, reverse___0);
    }
    }
  } else
#line 1364
  if ((unsigned int )reject_format == 0U) {
#line 1364
    if ((unsigned int )diff_type == 5U) {
      {
      {
#line 1366
      abort_hunk_unified(header, reverse___0);
      }
      }
    } else {
      {
      {
#line 1368
      abort_hunk_context(header, reverse___0);
      }
      }
    }
  } else {
    {
    {
#line 1368
    abort_hunk_context(header, reverse___0);
    }
    }
  }
}
}
#line 1374 "/tmp/0/patch-2.7.1/src/patch.c"
static int apply_hunk(struct outstate *outstate , lin where ) 
{ 
  lin old ;
  lin lastline ;
  lin __cil_tmp5 ;
  lin new ;
  enum __anonenum__769 def_state ;
  char const   *R_do_defines ;
  lin pat_end ;
  lin __cil_tmp10 ;
  FILE *fp ;
  lin __cil_tmp12 ;
  char __cil_tmp13 ;
  char __cil_tmp14 ;
  char __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char __cil_tmp28 ;
  char __cil_tmp29 ;
  char __cil_tmp30 ;
  int __cil_tmp32 ;
  int __cil_tmp34 ;
  char __cil_tmp35 ;
  int __cil_tmp39 ;
  char __cil_tmp40 ;
  int __cil_tmp47 ;
  char __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  char __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp55 ;
  lin __cil_tmp56 ;
  lin __cil_tmp57 ;

  {
  {
#line 1376
  old = (lin )1;
#line 1377
  __cil_tmp5 = pch_ptrn_lines();
#line 1377
  lastline = __cil_tmp5;
#line 1378
  new = lastline + 1L;
#line 1379
  def_state = (enum __anonenum__769 )0;
#line 1380
  R_do_defines = do_defines;
#line 1381
  __cil_tmp10 = pch_end();
#line 1381
  pat_end = __cil_tmp10;
#line 1382
  fp = outstate->ofp;
#line 1384
  __cil_tmp12 = where;
#line 1384
  where --;
  }
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1385
    if (! ((int )__cil_tmp13 == 61 || (int )__cil_tmp14 == 10)) {
#line 1385
      goto while_break;
    }
#line 1386
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1388
    if (! (old <= lastline)) {
#line 1388
      goto while_break___0;
    }
    {
#line 1389
    __cil_tmp16 = pch_char(old);
    }
#line 1389
    if ((int )__cil_tmp16 == 45) {
      {
#line 1391
      __cil_tmp18 = copy_till(outstate, (where + old) - 1L);
      }
#line 1391
      if (! __cil_tmp18) {
#line 1392
        return (0);
      }
#line 1393
      if (R_do_defines) {
#line 1394
        if ((unsigned int )def_state == 0U) {
          {
#line 1395
          fprintf(fp, outstate->after_newline + (char const   *)not_defined, R_do_defines);
#line 1397
          def_state = (enum __anonenum__769 )1;
          }
        } else
#line 1399
        if ((unsigned int )def_state == 2U) {
          {
#line 1400
          fputs(outstate->after_newline + (char const   *)else_defined, fp);
#line 1401
          def_state = (enum __anonenum__769 )3;
          }
        }
        {
#line 1403
        __cil_tmp19 = ferror(fp);
        }
#line 1403
        if (__cil_tmp19) {
          {
#line 1404
          write_fatal();
          }
        }
        {
#line 1405
        outstate->after_newline = pch_write_line(old, fp);
#line 1406
        outstate->zero_output = 0;
        }
      }
#line 1408
      last_frozen_line ++;
#line 1409
      old ++;
    } else
#line 1411
    if (new > pat_end) {
#line 1412
      goto while_break___0;
    } else {
      {
#line 1414
      __cil_tmp23 = pch_char(new);
      }
#line 1414
      if ((int )__cil_tmp23 == 43) {
        {
#line 1415
        __cil_tmp24 = copy_till(outstate, (where + old) - 1L);
        }
#line 1415
        if (! __cil_tmp24) {
#line 1416
          return (0);
        }
#line 1417
        if (R_do_defines) {
#line 1418
          if ((unsigned int )def_state == 1U) {
            {
#line 1419
            fputs(outstate->after_newline + (char const   *)else_defined, fp);
#line 1420
            def_state = (enum __anonenum__769 )3;
            }
          } else
#line 1422
          if ((unsigned int )def_state == 0U) {
            {
#line 1423
            fprintf(fp, outstate->after_newline + (char const   *)if_defined, R_do_defines);
#line 1425
            def_state = (enum __anonenum__769 )2;
            }
          }
          {
#line 1427
          __cil_tmp25 = ferror(fp);
          }
#line 1427
          if (__cil_tmp25) {
            {
#line 1428
            write_fatal();
            }
          }
        }
        {
#line 1430
        outstate->after_newline = pch_write_line(new, fp);
#line 1431
        outstate->zero_output = 0;
#line 1432
        new ++;
        }
      } else {
        {
#line 1434
        __cil_tmp29 = pch_char(old);
        }
        {
#line 1434
        __cil_tmp28 = pch_char(new);
        }
#line 1434
        if ((int )__cil_tmp28 != (int )__cil_tmp29) {
          {
#line 1435
          mangled_patch(old, new);
          }
        } else {
          {
#line 1436
          __cil_tmp30 = pch_char(new);
          }
#line 1436
          if ((int )__cil_tmp30 == 33) {
            {
#line 1438
            __cil_tmp32 = copy_till(outstate, (where + old) - 1L);
            }
#line 1438
            if (! __cil_tmp32) {
#line 1439
              return (0);
            }
#line 1441
            if (R_do_defines) {
              {
#line 1442
              fprintf(fp, 1 + (char const   *)not_defined, R_do_defines);
#line 1443
              __cil_tmp34 = ferror(fp);
              }
#line 1443
              if (__cil_tmp34) {
                {
#line 1444
                write_fatal();
                }
              }
#line 1445
              def_state = (enum __anonenum__769 )1;
            }
            {
#line 1448
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1450
              if (R_do_defines) {
                {
#line 1451
                outstate->after_newline = pch_write_line(old, fp);
                }
              }
#line 1453
              last_frozen_line ++;
#line 1454
              old ++;
#line 1448
              if (! ((int )__cil_tmp35 == 33)) {
#line 1448
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1458
            if (R_do_defines) {
              {
#line 1459
              fputs(outstate->after_newline + (char const   *)else_defined, fp);
#line 1460
              __cil_tmp39 = ferror(fp);
              }
#line 1460
              if (__cil_tmp39) {
                {
#line 1461
                write_fatal();
                }
              }
#line 1462
              def_state = (enum __anonenum__769 )3;
            }
            {
#line 1465
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 1467
              outstate->after_newline = pch_write_line(new, fp);
#line 1468
              new ++;
              }
#line 1465
              if (! ((int )__cil_tmp40 == 33)) {
#line 1465
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1471
            outstate->zero_output = 0;
          } else {
#line 1475
            old ++;
#line 1476
            new ++;
#line 1477
            if (R_do_defines) {
#line 1477
              if ((unsigned int )def_state != 0U) {
                {
#line 1478
                fputs(outstate->after_newline + (char const   *)end_defined, fp);
#line 1479
                __cil_tmp47 = ferror(fp);
                }
#line 1479
                if (__cil_tmp47) {
                  {
#line 1480
                  write_fatal();
                  }
                }
#line 1481
                outstate->after_newline = 1;
#line 1482
                def_state = (enum __anonenum__769 )0;
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1486
  __cil_tmp48 = pch_char(new);
  }
#line 1486
  if (new <= pat_end) {
#line 1486
    if ((int )__cil_tmp48 == 43) {
      {
#line 1487
      __cil_tmp49 = copy_till(outstate, (where + old) - 1L);
      }
#line 1487
      if (! __cil_tmp49) {
#line 1488
        return (0);
      }
#line 1489
      if (R_do_defines) {
#line 1490
        if ((unsigned int )def_state == 0U) {
          {
#line 1491
          fprintf(fp, outstate->after_newline + (char const   *)if_defined, R_do_defines);
#line 1493
          def_state = (enum __anonenum__769 )2;
          }
        } else
#line 1495
        if ((unsigned int )def_state == 1U) {
          {
#line 1496
          fputs(outstate->after_newline + (char const   *)else_defined, fp);
#line 1497
          def_state = (enum __anonenum__769 )3;
          }
        }
        {
#line 1499
        __cil_tmp50 = ferror(fp);
        }
#line 1499
        if (__cil_tmp50) {
          {
#line 1500
          write_fatal();
          }
        }
#line 1501
        outstate->zero_output = 0;
      }
      {
#line 1504
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1506
        __cil_tmp52 = _IO_putc('\n', fp);
        }
#line 1506
        if (! outstate->after_newline) {
#line 1506
          if (__cil_tmp52 == -1) {
            {
#line 1507
            write_fatal();
            }
          }
        }
        {
#line 1508
        outstate->after_newline = pch_write_line(new, fp);
#line 1509
        outstate->zero_output = 0;
#line 1510
        new ++;
        }
#line 1504
        if (! (new <= pat_end && (int )__cil_tmp51 == 43)) {
#line 1504
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 1514
  if (R_do_defines) {
#line 1514
    if ((unsigned int )def_state != 0U) {
      {
#line 1515
      fputs(outstate->after_newline + (char const   *)end_defined, fp);
#line 1516
      __cil_tmp55 = ferror(fp);
      }
#line 1516
      if (__cil_tmp55) {
        {
#line 1517
        write_fatal();
        }
      }
#line 1518
      outstate->after_newline = 1;
    }
  }
  {
#line 1520
  __cil_tmp57 = pch_ptrn_lines();
  }
  {
#line 1520
  __cil_tmp56 = pch_repl_lines();
  }
#line 1520
  out_offset += __cil_tmp56 - __cil_tmp57;
#line 1521
  return (1);
}
}
#line 1527 "/tmp/0/patch-2.7.1/src/patch.c"
static FILE *create_output_file(char const   *name , int open_flags ) 
{ 
  int fd ;
  int __cil_tmp4 ;
  FILE *f ;
  char *tmp ;
  FILE *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1529
  __cil_tmp4 = create_file(name, 1 | open_flags, instat.st_mode, 1);
#line 1529
  fd = __cil_tmp4;
#line 1531
  tmp = (char *)"w";
#line 1531
  __cil_tmp7 = fdopen(fd, (char const   *)tmp);
#line 1531
  f = __cil_tmp7;
  }
#line 1532
  if (! f) {
    {
#line 1533
    __cil_tmp8 = quotearg(name);
#line 1533
    pfatal((char const   *)((char *)"Can\'t create file %s"), __cil_tmp8);
    }
  }
#line 1534
  return (f);
}
}
#line 1540 "/tmp/0/patch-2.7.1/src/patch.c"
static void init_output(struct outstate *outstate ) 
{ 


  {
#line 1542
  outstate->ofp = (FILE *)((void *)0);
#line 1543
  outstate->after_newline = 1;
#line 1544
  outstate->zero_output = 1;
}
}
#line 1548 "/tmp/0/patch-2.7.1/src/patch.c"
static FILE *open_outfile(char const   *name ) 
{ 
  int __cil_tmp2 ;
  FILE *__cil_tmp3 ;
  FILE *ofp ;
  int stdout_dup ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1550
  __cil_tmp2 = strcmp(name, (char const   *)((char *)"-"));
  }
#line 1550
  if (__cil_tmp2 != 0) {
    {
#line 1551
    __cil_tmp3 = create_output_file(name, 0);
    }
#line 1551
    return (__cil_tmp3);
  } else {
    {
#line 1555
    __cil_tmp6 = fileno(stdout);
#line 1555
    __cil_tmp7 = dup(__cil_tmp6);
#line 1555
    stdout_dup = __cil_tmp7;
    }
#line 1556
    if (stdout_dup == -1) {
      {
#line 1557
      pfatal((char const   *)((char *)"Failed to duplicate standard output"));
      }
    }
    {
#line 1558
    ofp = fdopen(stdout_dup, (char const   *)((char *)"a"));
    }
#line 1559
    if (! ofp) {
      {
#line 1560
      pfatal((char const   *)((char *)"Failed to duplicate standard output"));
      }
    }
    {
#line 1561
    __cil_tmp9 = fileno(stderr);
    }
    {
#line 1561
    __cil_tmp10 = fileno(stdout);
#line 1561
    __cil_tmp11 = dup2(__cil_tmp9, __cil_tmp10);
    }
#line 1561
    if (__cil_tmp11 == -1) {
      {
#line 1562
      pfatal((char const   *)((char *)"Failed to redirect messages to standard error"));
      }
    }
#line 1564
    return (ofp);
  }
}
}
#line 1571 "/tmp/0/patch-2.7.1/src/patch.c"
static void init_reject(char const   *outname ) 
{ 
  int fd ;
  char *tmp ;
  FILE *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1574
  fd = make_tempfile(& TMPREJNAME, (char )'r', outname, 1, (mode_t )438);
#line 1576
  TMPREJNAME_needs_removal = 1;
#line 1577
  tmp = (char *)"w";
#line 1577
  __cil_tmp5 = fdopen(fd, (char const   *)tmp);
#line 1577
  rejfp = __cil_tmp5;
  }
#line 1578
  if (! rejfp) {
    {
#line 1579
    __cil_tmp6 = quotearg(TMPREJNAME);
#line 1579
    pfatal((char const   *)((char *)"Can\'t open stream for file %s"), __cil_tmp6);
    }
  }
}
}
#line 1585 "/tmp/0/patch-2.7.1/src/patch.c"
int copy_till(struct outstate *outstate , lin lastline ) 
{ 
  lin R_last_frozen_line ;
  FILE *fp ;
  char const   *s ;
  size_t size ;
  char const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
#line 1587
  R_last_frozen_line = last_frozen_line;
#line 1588
  fp = outstate->ofp;
#line 1592
  if (R_last_frozen_line > lastline) {
    {
#line 1594
    say((char const   *)((char *)"misordered hunks! output would be garbled\n"));
    }
#line 1595
    return (0);
  }
  {
#line 1597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1597
    if (! (R_last_frozen_line < lastline)) {
#line 1597
      goto while_break;
    }
    {
#line 1599
    R_last_frozen_line ++;
#line 1599
    __cil_tmp7 = ifetch(R_last_frozen_line, 0, & size);
#line 1599
    s = __cil_tmp7;
    }
#line 1600
    if (size) {
      {
#line 1602
      __cil_tmp9 = fwrite((void const   *)s, sizeof(*s), size, fp);
      }
      {
#line 1602
      __cil_tmp8 = _IO_putc('\n', fp);
      }
#line 1602
      if (! outstate->after_newline) {
#line 1602
        if (__cil_tmp8 == -1) {
          {
          {
#line 1604
          write_fatal();
          }
          }
        } else {
#line 1602
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1602
      if (! __cil_tmp9) {
        {
        {
#line 1604
        write_fatal();
        }
        }
      }
#line 1605
      outstate->after_newline = (int )((char )*(s + (size - 1UL))) == 10;
#line 1606
      outstate->zero_output = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1609
  last_frozen_line = R_last_frozen_line;
#line 1610
  return (1);
}
}
#line 1616 "/tmp/0/patch-2.7.1/src/patch.c"
static int spew_output(struct outstate *outstate , struct stat *st ) 
{ 
  char numbuf0[23] ;
  char numbuf1[23] ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1618
  if (debug & 256) {
    {
#line 1622
    __cil_tmp5 = format_linenum((char *)numbuf0, input_lines);
    }
    {
#line 1622
    __cil_tmp6 = format_linenum((char *)numbuf1, last_frozen_line);
#line 1622
    say((char const   *)((char *)"il=%s lfl=%s\n"), __cil_tmp5, __cil_tmp6);
    }
  }
#line 1627
  if (last_frozen_line < input_lines) {
    {
#line 1628
    __cil_tmp7 = copy_till(outstate, input_lines);
    }
#line 1628
    if (! __cil_tmp7) {
#line 1629
      return (0);
    }
  }
#line 1631
  if (outstate->ofp) {
#line 1631
    if (! outfile) {
      {
#line 1633
      __cil_tmp11 = fclose(outstate->ofp);
      }
      {
#line 1633
      __cil_tmp9 = fileno(outstate->ofp);
#line 1633
      __cil_tmp10 = fstat(__cil_tmp9, st);
      }
      {
#line 1633
      __cil_tmp8 = fflush(outstate->ofp);
      }
#line 1633
      if (__cil_tmp8 != 0) {
        {
        {
        {
#line 1636
        write_fatal();
        }
        }
        }
      } else
#line 1633
      if (__cil_tmp10 != 0) {
        {
        {
        {
#line 1636
        write_fatal();
        }
        }
        }
      } else
#line 1633
      if (__cil_tmp11 != 0) {
        {
        {
        {
#line 1636
        write_fatal();
        }
        }
        }
      }
#line 1637
      outstate->ofp = (FILE *)0;
    }
  }
#line 1640
  return (1);
}
}
#line 1646 "/tmp/0/patch-2.7.1/src/patch.c"
static int patch_match(lin base , lin offset , lin prefix_fuzz , lin suffix_fuzz ) 
{ 
  lin pline ;
  lin iline ;
  lin pat_lines ;
  lin __cil_tmp8 ;
  size_t size ;
  char const   *p ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  lin __cil_tmp18 ;
  lin __cil_tmp19 ;

  {
  {
#line 1648
  pline = 1L + prefix_fuzz;
#line 1650
  __cil_tmp8 = pch_ptrn_lines();
#line 1650
  pat_lines = __cil_tmp8 - suffix_fuzz;
#line 1654
  iline = (base + offset) + prefix_fuzz;
  }
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! (pline <= pat_lines)) {
#line 1654
      goto while_break;
    }
    {
#line 1655
    p = ifetch(iline, offset >= 0L, & size);
    }
#line 1656
    if (canonicalize) {
      {
#line 1657
      __cil_tmp12 = pfetch(pline);
      }
      {
#line 1657
      __cil_tmp13 = pch_line_len(pline);
#line 1657
      __cil_tmp14 = similar(p, size, (char const   *)__cil_tmp12, __cil_tmp13);
      }
#line 1657
      if (! __cil_tmp14) {
#line 1660
        return (0);
      }
    } else {
      {
#line 1662
      __cil_tmp16 = pfetch(pline);
#line 1662
      __cil_tmp17 = memcmp((void const   *)p, (void const   *)__cil_tmp16, size);
      }
      {
#line 1662
      __cil_tmp15 = pch_line_len(pline);
      }
#line 1662
      if (size != __cil_tmp15) {
#line 1664
        return (0);
      } else
#line 1662
      if (__cil_tmp17 != 0) {
#line 1664
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1654
  __cil_tmp19 = iline;
#line 1654
  iline ++;
#line 1654
  __cil_tmp18 = pline;
#line 1654
  pline ++;
#line 1666
  return (1);
}
}
#line 1672 "/tmp/0/patch-2.7.1/src/patch.c"
static int check_line_endings(lin where ) 
{ 
  char const   *p ;
  size_t size ;
  int input_crlf ;
  int patch_crlf ;
  char *__cil_tmp6 ;

  {
  {
#line 1678
  __cil_tmp6 = pfetch((lin )1);
#line 1678
  p = (char const   *)__cil_tmp6;
#line 1679
  size = pch_line_len((lin )1);
  }
#line 1680
  if (! size) {
#line 1681
    return (0);
  }
#line 1682
  patch_crlf = (size >= 2UL && (int )((char )*(p + (size - 2UL))) == 13) && (int )((char )*(p + (size - 1UL))) == 10;
#line 1684
  if (! input_lines) {
#line 1685
    return (0);
  }
#line 1686
  if (where > input_lines) {
#line 1687
    where = input_lines;
  }
  {
#line 1688
  p = ifetch(where, 0, & size);
  }
#line 1689
  if (! size) {
#line 1690
    return (0);
  }
#line 1691
  input_crlf = (size >= 2UL && (int )((char )*(p + (size - 2UL))) == 13) && (int )((char )*(p + (size - 1UL))) == 10;
#line 1693
  return (patch_crlf != input_crlf);
}
}
#line 1699 "/tmp/0/patch-2.7.1/src/patch.c"
int similar(char const   *a , size_t alen , char const   *b , size_t blen ) 
{ 
  char const   *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  char const   *__cil_tmp7 ;
  size_t __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
#line 1702
  alen -= (unsigned long )(alen && (int )((char )*(a + (alen - 1UL))) == 10);
#line 1703
  blen -= (unsigned long )(blen && (int )((char )*(b + (blen - 1UL))) == 10);
  {
#line 1705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1705
    if (! 1) {
#line 1705
      goto while_break;
    }
#line 1707
    if (! blen) {
      _L: /* CIL Label */ 
      {
#line 1709
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1709
        if (! (blen && ((int )((char )*b) == 32 || (int )((char )*b) == 9))) {
#line 1709
          goto while_break___0;
        }
#line 1710
        __cil_tmp6 = blen;
#line 1710
        blen --;
#line 1710
        __cil_tmp5 = b;
#line 1710
        b ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1711
      if (alen) {
#line 1713
        if (! ((int )((char )*a) == 32 || (int )((char )*a) == 9)) {
#line 1714
          return (0);
        }
        {
#line 1715
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1715
          __cil_tmp8 = alen;
#line 1715
          alen --;
#line 1715
          __cil_tmp7 = a;
#line 1715
          a ++;
#line 1715
          if (! (alen && ((int )((char )*a) == 32 || (int )((char )*a) == 9))) {
#line 1715
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1718
      if (! alen) {
#line 1719
        return (alen == blen);
      } else
#line 1718
      if (! blen) {
#line 1719
        return (alen == blen);
      }
    } else
#line 1707
    if ((int )((char )*b) == 32) {
#line 1707
      goto _L;
    } else
#line 1707
    if ((int )((char )*b) == 9) {
#line 1707
      goto _L;
    } else {
#line 1721
      __cil_tmp10 = b;
#line 1721
      b ++;
#line 1721
      __cil_tmp9 = a;
#line 1721
      a ++;
#line 1721
      if (! alen) {
#line 1722
        return (0);
      } else
#line 1721
      if ((int )((char )*__cil_tmp9) != (int )((char )*__cil_tmp10)) {
#line 1722
        return (0);
      } else {
#line 1724
        __cil_tmp12 = blen;
#line 1724
        blen --;
#line 1724
        __cil_tmp11 = alen;
#line 1724
        alen --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1736
static gl_list_t files_to_delete ;
#line 1739 "/tmp/0/patch-2.7.1/src/patch.c"
static void init_files_to_delete(void) 
{ 


  {
  {
#line 1741
  files_to_delete = gl_list_create_empty_inline(& gl_linked_list_implementation, (gl_listelement_equals_fn )((void *)0),
                                                (gl_listelement_hashcode_fn )((void *)0),
                                                (gl_listelement_dispose_fn )((void *)0),
                                                1);
  }
}
}
#line 1745 "/tmp/0/patch-2.7.1/src/patch.c"
static void delete_file_later(char const   *name , struct stat *st , int backup ) 
{ 
  struct file_to_delete *file_to_delete ;
  struct stat st_tmp ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1750
  if (! st) {
    {
#line 1752
    __cil_tmp6 = stat_file(name, & st_tmp);
    }
#line 1752
    if (__cil_tmp6 != 0) {
      {
#line 1753
      pfatal((char const   *)((char *)"Can\'t get file attributes of %s %s"), (char *)"file",
             name);
      }
    }
#line 1754
    st = & st_tmp;
  }
  {
#line 1756
  __cil_tmp7 = xmalloc(sizeof(*file_to_delete));
#line 1756
  file_to_delete = (struct file_to_delete *)__cil_tmp7;
#line 1757
  file_to_delete->name = xstrdup(name);
#line 1758
  file_to_delete->st = *st;
#line 1759
  file_to_delete->backup = backup;
#line 1760
  gl_list_add_last_inline(files_to_delete, (void const   *)file_to_delete);
#line 1761
  insert_file_id(st, (enum file_id_type )2);
  }
}
}
#line 1765 "/tmp/0/patch-2.7.1/src/patch.c"
static void delete_files(void) 
{ 
  gl_list_iterator_t iter ;
  void const   *elt___242 ;
  int __cil_tmp4 ;
  struct file_to_delete *file_to_delete ;
  enum file_id_type __cil_tmp6 ;
  mode_t mode ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 1770
  iter = gl_list_iterator_inline(files_to_delete);
  }
  {
#line 1771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1771
    if (! __cil_tmp4) {
#line 1771
      goto while_break;
    }
    {
#line 1773
    file_to_delete = (struct file_to_delete *)elt___242;
#line 1775
    __cil_tmp6 = lookup_file_id(& file_to_delete->st);
    }
#line 1775
    if ((unsigned int )__cil_tmp6 == 2U) {
#line 1777
      mode = file_to_delete->st.st_mode;
#line 1779
      if ((unsigned int )verbosity == 2U) {
#line 1780
        if ((mode & 61440U) == 40960U) {
#line 1780
          tmp = (char *)"symbolic link";
        } else {
#line 1780
          tmp = (char *)"file";
        }
        {
#line 1780
        __cil_tmp9 = quotearg((char const   *)file_to_delete->name);
#line 1780
        say((char const   *)((char *)"Removing %s %s\n"), tmp, __cil_tmp9);
        }
      }
      {
#line 1783
      move_file((char const   *)0, (int *)0, (struct stat *)0, (char const   *)file_to_delete->name,
                mode, file_to_delete->backup);
#line 1785
      removedirs((char const   *)file_to_delete->name);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1788
  gl_list_iterator_free_inline(& iter);
  }
}
}
#line 1801
static gl_list_t files_to_output ;
#line 1804 "/tmp/0/patch-2.7.1/src/patch.c"
static void output_file_later(char const   *from , int *from_needs_removal , struct stat *from_st ,
                              char const   *to , mode_t mode , int backup ) 
{ 
  struct file_to_output *file_to_output ;
  void *__cil_tmp8 ;
  char *__cil_tmp10 ;
  char *tmp ;

  {
  {
#line 1809
  __cil_tmp8 = xmalloc(sizeof(*file_to_output));
#line 1809
  file_to_output = (struct file_to_output *)__cil_tmp8;
#line 1810
  file_to_output->from = xstrdup(from);
#line 1811
  file_to_output->from_st = *from_st;
  }
#line 1812
  if (to) {
    {
#line 1812
    __cil_tmp10 = xstrdup(to);
#line 1812
    tmp = __cil_tmp10;
    }
  } else {
#line 1812
    tmp = (char *)((void *)0);
  }
  {
#line 1812
  file_to_output->to = tmp;
#line 1813
  file_to_output->mode = mode;
#line 1814
  file_to_output->backup = backup;
#line 1815
  gl_list_add_last_inline(files_to_output, (void const   *)file_to_output);
  }
#line 1816
  if (from_needs_removal) {
#line 1817
    *from_needs_removal = 0;
  }
}
}
#line 1821 "/tmp/0/patch-2.7.1/src/patch.c"
static void output_file_now(char const   *from , int *from_needs_removal , struct stat *from_st ,
                            char const   *to , mode_t mode , int backup ) 
{ 


  {
#line 1825
  if (to == (char const   *)((void *)0)) {
#line 1827
    if (backup) {
      {
#line 1828
      create_backup(from, from_st, 1);
      }
    }
  } else {
    {
#line 1833
    move_file(from, from_needs_removal, from_st, to, mode, backup);
    }
  }
}
}
#line 1838 "/tmp/0/patch-2.7.1/src/patch.c"
static void output_file(char const   *from , int *from_needs_removal , struct stat *from_st ,
                        char const   *to , struct stat *to_st , mode_t mode , int backup ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1842
  if (from == (char const   *)((void *)0)) {
    {
#line 1848
    delete_file_later(to, to_st, backup);
    }
  } else {
    {
#line 1850
    __cil_tmp9 = pch_says_nonexistent(reverse);
    }
    {
#line 1850
    __cil_tmp8 = pch_git_diff();
    }
#line 1850
    if (__cil_tmp8) {
#line 1850
      if (__cil_tmp9 != 2) {
        {
#line 1866
        output_file_later(from, from_needs_removal, from_st, to, mode, backup);
        }
      } else {
        {
        {
#line 1869
        output_file_now(from, from_needs_removal, from_st, to, mode, backup);
        }
        }
      }
    } else {
      {
      {
#line 1869
      output_file_now(from, from_needs_removal, from_st, to, mode, backup);
      }
      }
    }
  }
}
}
#line 1873 "/tmp/0/patch-2.7.1/src/patch.c"
static void dispose_file_to_output(void const   *elt ) 
{ 
  struct file_to_output *file_to_output ;

  {
  {
#line 1875
  file_to_output = (struct file_to_output *)elt;
#line 1877
  free((void *)file_to_output->from);
#line 1878
  free((void *)file_to_output->to);
  }
}
}
#line 1882 "/tmp/0/patch-2.7.1/src/patch.c"
static void init_files_to_output(void) 
{ 


  {
  {
#line 1884
  files_to_output = gl_list_create_empty_inline(& gl_linked_list_implementation, (gl_listelement_equals_fn )((void *)0),
                                                (gl_listelement_hashcode_fn )((void *)0),
                                                dispose_file_to_output, 1);
  }
}
}
#line 1889 "/tmp/0/patch-2.7.1/src/patch.c"
static void gl_list_clear(gl_list_t list ) 
{ 
  size_t __cil_tmp2 ;

  {
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1891
    if (! (__cil_tmp2 > 0UL)) {
#line 1891
      goto while_break;
    }
    {
#line 1892
    gl_list_remove_at_inline(list, (size_t )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1896 "/tmp/0/patch-2.7.1/src/patch.c"
static void output_files(struct stat *st ) 
{ 
  gl_list_iterator_t iter ;
  void const   *elt___243 ;
  int __cil_tmp5 ;
  struct file_to_output *file_to_output ;
  int from_needs_removal ;
  struct stat *from_st ;
  void const   *elt2 ;
  void const   *__cil_tmp10 ;

  {
  {
#line 1901
  iter = gl_list_iterator_inline(files_to_output);
  }
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1902
    if (! __cil_tmp5) {
#line 1902
      goto while_break;
    }
    {
#line 1904
    file_to_output = (struct file_to_output *)elt___243;
#line 1905
    from_needs_removal = 1;
#line 1906
    from_st = & file_to_output->from_st;
#line 1908
    output_file_now((char const   *)file_to_output->from, & from_needs_removal, from_st,
                    (char const   *)file_to_output->to, file_to_output->mode, file_to_output->backup);
    }
#line 1911
    if (file_to_output->to) {
#line 1911
      if (from_needs_removal) {
        {
#line 1912
        unlink((char const   *)file_to_output->from);
        }
      }
    }
#line 1914
    if (st) {
#line 1914
      if (st->st_dev == from_st->st_dev) {
#line 1914
        if (st->st_ino == from_st->st_ino) {
          {
#line 1917
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1917
            if (! 1) {
#line 1917
              goto while_break___0;
            }
            {
#line 1919
            __cil_tmp10 = gl_list_get_at_inline(files_to_output, (size_t )0);
#line 1919
            elt2 = __cil_tmp10;
#line 1920
            gl_list_remove_at_inline(files_to_output, (size_t )0);
            }
#line 1921
            if (elt___243 == elt2) {
#line 1922
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1924
          gl_list_iterator_free_inline(& iter);
          }
#line 1925
          return;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1928
  gl_list_iterator_free_inline(& iter);
#line 1929
  gl_list_clear(files_to_output);
  }
}
}
#line 1933 "/tmp/0/patch-2.7.1/src/patch.c"
static void forget_output_files(void) 
{ 
  gl_list_iterator_t iter ;
  gl_list_iterator_t __cil_tmp2 ;
  void const   *elt___244 ;
  int __cil_tmp4 ;
  struct file_to_output *file_to_output ;

  {
  {
#line 1935
  __cil_tmp2 = gl_list_iterator_inline(files_to_output);
#line 1935
  iter = __cil_tmp2;
  }
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1938
    if (! __cil_tmp4) {
#line 1938
      goto while_break;
    }
    {
#line 1940
    file_to_output = (struct file_to_output *)elt___244;
#line 1942
    unlink((char const   *)file_to_output->from);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1944
  gl_list_iterator_free_inline(& iter);
#line 1945
  gl_list_clear(files_to_output);
  }
}
}
#line 1951 "/tmp/0/patch-2.7.1/src/patch.c"
void fatal_exit(int sig ) 
{ 


  {
  {
#line 1953
  cleanup();
  }
#line 1955
  if (sig) {
    {
#line 1956
    exit_with_signal(sig);
    }
  }
  {
#line 1958
  exit(2);
  }
}
}
#line 1962 "/tmp/0/patch-2.7.1/src/patch.c"
static void remove_if_needed(char const   *name , int *needs_removal ) 
{ 


  {
#line 1964
  if (*needs_removal) {
    {
#line 1966
    unlink(name);
#line 1967
    *needs_removal = 0;
    }
  }
}
}
#line 1972 "/tmp/0/patch-2.7.1/src/patch.c"
static void cleanup(void) 
{ 


  {
  {
#line 1974
  remove_if_needed(TMPINNAME, & TMPINNAME_needs_removal);
#line 1975
  remove_if_needed(TMPOUTNAME, & TMPOUTNAME_needs_removal);
#line 1976
  remove_if_needed(TMPPATNAME, & TMPPATNAME_needs_removal);
#line 1977
  remove_if_needed(TMPREJNAME, & TMPREJNAME_needs_removal);
#line 1978
  forget_output_files();
  }
}
}
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 31 "/tmp/0/patch-2.7.1/src/inp.c"
static char *i_buffer ;
#line 32
static char const   **i_ptr ;
#line 34
static size_t tibufsize ;
#line 38 "/tmp/0/patch-2.7.1/src/inp.c"
static int tifd  =    - 1;
#line 39
static char *tibuf[2] ;
#line 40 "/tmp/0/patch-2.7.1/src/inp.c"
static lin tiline[2]  = {      (lin )(- 1),      (lin )(- 1)};
#line 41
static lin lines_per_buf ;
#line 42
static size_t tireclen ;
#line 43
static size_t last_line_size ;
#line 45
static int plan_a(char const   *filename ) ;
#line 46
static void plan_b(char const   *filename ) ;
#line 47
static void report_revision(int found_revision ) ;
#line 48
static void too_many_lines(char const   *filename ) ;
#line 53 "/tmp/0/patch-2.7.1/src/inp.c"
void re_input(void) 
{ 


  {
#line 55
  if (using_plan_a) {
#line 56
    if (i_buffer) {
      {
#line 58
      free((void *)i_buffer);
#line 59
      i_buffer = (char *)0;
#line 60
      free((void *)i_ptr);
      }
    }
  } else {
#line 64
    if (tifd >= 0) {
      {
#line 65
      close(tifd);
      }
    }
#line 66
    tifd = - 1;
#line 67
    if (tibuf[0]) {
      {
#line 69
      free((void *)tibuf[0]);
#line 70
      tibuf[0] = (char *)0;
      }
    }
#line 72
    tiline[1] = (lin )(- 1);
#line 72
    tiline[0] = tiline[1];
#line 73
    tireclen = (size_t )0;
  }
}
}
#line 80 "/tmp/0/patch-2.7.1/src/inp.c"
void scan_input(char *filename , mode_t file_type ) 
{ 
  int __cil_tmp3 ;
  char *__cil_tmp5 ;

  {
  {
#line 82
  __cil_tmp3 = plan_a((char const   *)filename);
#line 82
  using_plan_a = ! (debug & 16) && __cil_tmp3;
  }
#line 83
  if (! using_plan_a) {
#line 85
    if (! ((file_type & 61440U) == 32768U)) {
      {
#line 88
      __cil_tmp5 = quotearg((char const   *)filename);
#line 88
      fatal((char const   *)((char *)"Can\'t handle %s %s"), (char *)"symbolic link",
            __cil_tmp5);
      }
    }
    {
#line 90
    plan_b((char const   *)filename);
    }
  }
}
}
#line 97 "/tmp/0/patch-2.7.1/src/inp.c"
static void report_revision(int found_revision ) 
{ 
  char const   *rev ;
  char *__cil_tmp3 ;

  {
  {
#line 99
  __cil_tmp3 = quotearg((char const   *)revision);
#line 99
  rev = (char const   *)__cil_tmp3;
  }
#line 101
  if (found_revision) {
#line 103
    if ((unsigned int )verbosity == 2U) {
      {
#line 104
      say((char const   *)((char *)"Good.  This file appears to be the %s version.\n"),
          rev);
      }
    }
  } else
#line 106
  if (force) {
#line 108
    if ((unsigned int )verbosity != 1U) {
      {
#line 109
      say((char const   *)((char *)"Warning: this file doesn\'t appear to be the %s version -- patching anyway.\n"),
          rev);
      }
    }
  } else
#line 112
  if (batch) {
    {
#line 113
    fatal((char const   *)((char *)"This file doesn\'t appear to be the %s version -- aborting."),
          rev);
    }
  } else {
    {
#line 117
    ask((char const   *)((char *)"This file doesn\'t appear to be the %s version -- patch anyway? [n] "),
        rev);
    }
#line 119
    if ((int )*buf != 121) {
      {
#line 120
      fatal((char const   *)((char *)"aborted"));
      }
    }
  }
}
}
#line 126 "/tmp/0/patch-2.7.1/src/inp.c"
static void too_many_lines(char const   *filename ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 128
  __cil_tmp2 = quotearg(filename);
#line 128
  fatal((char const   *)((char *)"File %s has too many lines"), __cil_tmp2);
  }
}
}
#line 133 "/tmp/0/patch-2.7.1/src/inp.c"
int get_input_file(char const   *filename , char const   *outname , mode_t file_type ) 
{ 
  int elsewhere ;
  int __cil_tmp5 ;
  char const   *cs ;
  char *diffbuf ;
  char *getbuf ;
  __uid_t __cil_tmp10 ;
  struct stat *tmp ;
  char const   *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *tmp___246 ;

  {
  {
#line 135
  __cil_tmp5 = strcmp(filename, outname);
#line 135
  elsewhere = __cil_tmp5 != 0;
  }
#line 140
  if (inerrno == -1) {
    {
#line 141
    inerrno = stat_file(filename, & instat);
    }
  }
#line 144
  if (inerrno) {
#line 144
    tmp = (struct stat *)0;
  } else {
#line 144
    tmp = & instat;
  }
  {
#line 144
  __cil_tmp12 = version_controller(filename, elsewhere, tmp, & getbuf, & diffbuf);
#line 144
  cs = __cil_tmp12;
#line 144
  invc = ! (! cs);
  }
  {
#line 144
  __cil_tmp10 = geteuid();
  }
#line 144
  if ((file_type & 61440U) == 32768U) {
#line 144
    if (patch_get) {
#line 144
      if (invc != 0) {
#line 144
        if (inerrno) {
          _L: /* CIL Label */ 
#line 144
          if (invc) {
#line 159
            if (! inerrno) {
#line 160
              if (! elsewhere) {
#line 160
                if ((instat.st_mode & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) != 0U) {
                  {
#line 163
                  __cil_tmp13 = quotearg(filename);
#line 163
                  fatal((char const   *)((char *)"File %s seems to be locked by somebody else under %s"),
                        __cil_tmp13, cs);
                  }
                }
              }
#line 165
              if (diffbuf) {
#line 170
                if ((unsigned int )verbosity == 2U) {
                  {
#line 171
                  __cil_tmp14 = quotearg(filename);
#line 171
                  say((char const   *)((char *)"Comparing file %s to default %s version...\n"),
                      __cil_tmp14, cs);
                  }
                }
                {
#line 174
                __cil_tmp15 = systemic((char const   *)diffbuf);
                }
#line 174
                if (__cil_tmp15 != 0) {
                  {
#line 176
                  __cil_tmp16 = quotearg(filename);
#line 176
                  say((char const   *)((char *)"warning: Patching file %s, which does not match default %s version\n"),
                      __cil_tmp16, cs);
#line 178
                  cs = (char const   *)0;
                  }
                }
              }
#line 181
              if (dry_run) {
#line 182
                cs = (char const   *)0;
              }
            }
            {
#line 185
            __cil_tmp17 = version_get(filename, cs, ! inerrno, elsewhere, (char const   *)getbuf,
                                      & instat);
            }
#line 185
            if (cs) {
#line 185
              if (__cil_tmp17) {
#line 187
                inerrno = 0;
              }
            }
            {
#line 189
            free((void *)getbuf);
#line 190
            free((void *)diffbuf);
            }
          }
        } else
#line 144
        if (! elsewhere) {
#line 144
          if ((instat.st_mode & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) == 0U) {
#line 144
            goto _L;
          } else
#line 144
          if ((instat.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) == 0U) {
#line 144
            if (instat.st_uid != __cil_tmp10) {
#line 144
              goto _L;
            }
          }
        }
      }
    }
  }
#line 193
  if (inerrno) {
#line 195
    instat.st_mode = (__mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 196
    instat.st_size = (__off_t )0;
  } else
#line 198
  if (! (((file_type & 61440U) == 32768U || (file_type & 61440U) == 40960U) && (file_type & 61440U) == (instat.st_mode & 61440U))) {
    {
#line 201
    __cil_tmp18 = quotearg(filename);
    }
#line 201
    if ((file_type & 61440U) == 40960U) {
#line 201
      tmp___246 = (char *)"symbolic link";
    } else {
#line 201
      tmp___246 = (char *)"regular file";
    }
    {
#line 201
    say((char const   *)((char *)"File %s is not a %s -- refusing to patch\n"), __cil_tmp18,
        tmp___246);
    }
#line 204
    return (0);
  }
#line 206
  return (1);
}
}
#line 213 "/tmp/0/patch-2.7.1/src/inp.c"
static int plan_a(char const   *filename ) 
{ 
  char const   *s ;
  char const   *lim ;
  char const   **ptr ;
  char *buffer ;
  lin iline ;
  size_t size ;
  size_t tmp ;
  void *__cil_tmp9 ;
  int ifd ;
  int __cil_tmp11 ;
  size_t buffered ;
  size_t n ;
  char *__cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  int __cil_tmp16 ;
  ssize_t n___0 ;
  char *__cil_tmp19 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char const   *rev ;
  int rev0 ;
  int found_revision ;
  size_t revlen ;
  size_t __cil_tmp29 ;
  char const   *limrev ;
  int __cil_tmp32 ;
  unsigned short const   **__cil_tmp33 ;
  unsigned short const   **__cil_tmp34 ;

  {
#line 220
  size = (size_t )instat.st_size;
#line 224
  if (size) {
#line 224
    tmp = size;
  } else {
#line 224
    tmp = (size_t )1;
  }
  {
#line 224
  __cil_tmp9 = malloc(tmp);
#line 224
  buffer = (char *)__cil_tmp9;
  }
#line 224
  if (! (size == (unsigned long )instat.st_size && buffer)) {
#line 226
    return (0);
  }
#line 230
  if (size) {
#line 232
    if ((instat.st_mode & 61440U) == 32768U) {
      {
#line 234
      __cil_tmp11 = open(filename, 0);
#line 234
      ifd = __cil_tmp11;
#line 235
      buffered = (size_t )0;
      }
#line 236
      if (ifd < 0) {
        {
#line 237
        __cil_tmp14 = quotearg(filename);
#line 237
        pfatal((char const   *)((char *)"can\'t open file %s"), __cil_tmp14);
        }
      }
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! (size - buffered != 0UL)) {
#line 239
          goto while_break;
        }
        {
#line 241
        __cil_tmp15 = read(ifd, (void *)(buffer + buffered), size - buffered);
#line 241
        n = (size_t )__cil_tmp15;
        }
#line 242
        if (n == 0UL) {
#line 246
          size = buffered;
#line 247
          goto while_break;
        }
#line 249
        if (n == 0xffffffffffffffffUL) {
          {
#line 252
          close(ifd);
#line 253
          free((void *)buffer);
          }
#line 254
          return (0);
        }
#line 256
        buffered += n;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 259
      __cil_tmp16 = close(ifd);
      }
#line 259
      if (__cil_tmp16 != 0) {
        {
#line 260
        read_fatal();
        }
      }
    } else
#line 262
    if ((instat.st_mode & 61440U) == 40960U) {
      {
#line 265
      n___0 = readlink(filename, buffer, size);
      }
#line 266
      if (n___0 < 0L) {
        {
#line 267
        __cil_tmp19 = quotearg(filename);
#line 267
        pfatal((char const   *)((char *)"can\'t read %s %s"), (char *)"symbolic link",
               __cil_tmp19);
        }
      }
#line 268
      size = (size_t )n___0;
    } else {
      {
#line 272
      free((void *)buffer);
      }
#line 273
      return (0);
    }
  }
#line 278
  lim = (char const   *)(buffer + size);
#line 279
  iline = (lin )3;
#line 280
  s = (char const   *)buffer;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! s) {
#line 280
      goto while_break___0;
    }
#line 281
    iline ++;
#line 281
    if (iline < 0L) {
      {
#line 282
      too_many_lines(filename);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  s ++;
#line 283
  __cil_tmp22 = malloc((size_t )iline * sizeof(*ptr));
#line 283
  ptr = (char const   **)__cil_tmp22;
  }
#line 283
  if (! (((unsigned long )iline == (size_t )iline && ((size_t )iline * sizeof(*ptr)) / sizeof(*ptr) == (size_t )iline) && ptr)) {
    {
#line 287
    free((void *)buffer);
    }
#line 288
    return (0);
  }
#line 290
  iline = (lin )0;
#line 291
  s = (char const   *)buffer;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if (! 1) {
#line 291
      goto while_break___1;
    }
    {
#line 293
    iline ++;
#line 293
    *(ptr + iline) = s;
#line 294
    __cil_tmp23 = memchr((void const   *)s, '\n', (unsigned long )(lim - s));
#line 294
    s = (char const   *)((char *)__cil_tmp23);
    }
#line 294
    if (! s) {
#line 295
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 291
  s ++;
#line 297
  if (size) {
#line 297
    if ((int )((char )*(lim + -1)) != 10) {
#line 298
      iline ++;
#line 298
      *(ptr + iline) = lim;
    }
  }
#line 299
  input_lines = iline - 1L;
#line 301
  if (revision) {
    {
#line 303
    rev = (char const   *)revision;
#line 304
    rev0 = (int )((char )*(rev + 0));
#line 305
    found_revision = 0;
#line 306
    __cil_tmp29 = strlen(rev);
#line 306
    revlen = __cil_tmp29;
    }
#line 308
    if (revlen <= size) {
#line 310
      limrev = lim - revlen;
#line 312
      s = (char const   *)buffer;
      {
#line 312
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 312
        if (! s) {
#line 312
          goto while_break___2;
        }
        {
#line 313
        __cil_tmp34 = __ctype_b_loc();
        }
        {
#line 313
        __cil_tmp33 = __ctype_b_loc();
        }
        {
#line 313
        __cil_tmp32 = memcmp((void const   *)s, (void const   *)rev, revlen);
        }
#line 313
        if (__cil_tmp32 == 0) {
#line 313
          if (s == (char const   *)buffer) {
            _L: /* CIL Label */ 
#line 313
            if (s + 1 == limrev) {
#line 317
              found_revision = 1;
#line 318
              goto while_break___2;
            } else
#line 313
            if ((int )((unsigned short )*(*__cil_tmp34 + (int )((unsigned char )((char )*(s + revlen))))) & 8192) {
#line 317
              found_revision = 1;
#line 318
              goto while_break___2;
            }
          } else
#line 313
          if ((int )((unsigned short )*(*__cil_tmp33 + (int )((unsigned char )((char )*(s + -1))))) & 8192) {
#line 313
            goto _L;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 312
      s ++;
    }
    {
#line 322
    report_revision(found_revision);
    }
  }
#line 326
  i_buffer = buffer;
#line 327
  i_ptr = ptr;
#line 328
  return (1);
}
}
#line 334 "/tmp/0/patch-2.7.1/src/inp.c"
static void plan_b(char const   *filename ) 
{ 
  FILE *ifp ;
  int c ;
  size_t len ;
  size_t maxlen ;
  int found_revision ;
  size_t i ;
  char const   *rev ;
  size_t revlen ;
  lin line ;
  char *tmp ;
  FILE *__cil_tmp12 ;
  char *__cil_tmp13 ;
  size_t __cil_tmp16 ;
  size_t tmp___247 ;
  unsigned short const   **__cil_tmp20 ;
  unsigned long tmp___248 ;
  unsigned short const   **__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *p ;
  char const   *p0 ;
  ssize_t __cil_tmp26 ;
  char *__cil_tmp28 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  ssize_t __cil_tmp34 ;

  {
#line 344
  line = (lin )1;
#line 346
  if (instat.st_size == 0L) {
#line 347
    filename = (char const   *)((char *)"/dev/null");
  }
  {
#line 348
  tmp = (char *)"r";
#line 348
  __cil_tmp12 = fopen(filename, (char const   *)tmp);
#line 348
  ifp = __cil_tmp12;
  }
#line 348
  if (! ifp) {
    {
#line 349
    __cil_tmp13 = quotearg(filename);
#line 349
    pfatal((char const   *)((char *)"Can\'t open file %s"), __cil_tmp13);
    }
  }
#line 350
  if (TMPINNAME_needs_removal) {
    {
#line 353
    tifd = create_file(TMPINNAME, 2, (mode_t )0, 1);
    }
  } else {
    {
#line 357
    tifd = make_tempfile(& TMPINNAME, (char )'i', (char const   *)((void *)0), 2,
                         (mode_t )384);
#line 359
    TMPINNAME_needs_removal = 1;
    }
  }
#line 361
  i = (size_t )0;
#line 362
  len = (size_t )0;
#line 363
  maxlen = (size_t )1;
#line 364
  rev = (char const   *)revision;
#line 365
  found_revision = ! rev;
#line 366
  if (rev) {
    {
#line 366
    __cil_tmp16 = strlen(rev);
#line 366
    tmp___247 = __cil_tmp16;
    }
  } else {
#line 366
    tmp___247 = (unsigned long )0;
  }
#line 366
  revlen = tmp___247;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (c != -1)) {
#line 368
      goto while_break;
    }
#line 370
    len ++;
#line 372
    if (c == 10) {
#line 374
      line ++;
#line 374
      if (line < 0L) {
        {
#line 375
        too_many_lines(filename);
        }
      }
#line 376
      if (maxlen < len) {
#line 377
        maxlen = len;
      }
#line 378
      len = (size_t )0;
    }
#line 381
    if (! found_revision) {
#line 383
      if (i == revlen) {
        {
#line 385
        __cil_tmp20 = __ctype_b_loc();
#line 385
        found_revision = (int )((unsigned short )*(*__cil_tmp20 + (int )((unsigned char )c))) & 8192;
#line 386
        i = (size_t )(- 1);
        }
      } else
#line 388
      if (i != 0xffffffffffffffffUL) {
#line 389
        if ((int )((char )*(rev + i)) == c) {
#line 389
          tmp___248 = i + 1UL;
        } else {
#line 389
          tmp___248 = (size_t )(- 1);
        }
#line 389
        i = tmp___248;
      }
      {
#line 391
      __cil_tmp22 = __ctype_b_loc();
      }
#line 391
      if (i == 0xffffffffffffffffUL) {
#line 391
        if ((int )((unsigned short )*(*__cil_tmp22 + (int )((unsigned char )c))) & 8192) {
#line 392
          i = (size_t )0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if (revision) {
    {
#line 397
    report_revision(found_revision);
    }
  }
  {
#line 398
  Fseek(ifp, (file_offset )0, 0);
#line 399
  tibufsize = (size_t )8192;
  }
  {
#line 399
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 399
    if (! (tibufsize < maxlen)) {
#line 399
      goto while_break___0;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 399
  tibufsize <<= 1;
#line 401
  lines_per_buf = (lin )(tibufsize / maxlen);
#line 402
  tireclen = maxlen;
#line 403
  __cil_tmp23 = xmalloc(2UL * tibufsize);
#line 403
  tibuf[0] = (char *)__cil_tmp23;
#line 404
  tibuf[1] = tibuf[0] + tibufsize;
#line 406
  line = (lin )1;
  }
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 406
    if (! 1) {
#line 406
      goto while_break___1;
    }
#line 408
    p = tibuf[0] + maxlen * (unsigned long )(line % lines_per_buf);
#line 409
    p0 = (char const   *)p;
#line 410
    if (! (line % lines_per_buf)) {
      {
#line 411
      __cil_tmp26 = write(tifd, (void const   *)tibuf[0], tibufsize);
      }
#line 411
      if ((unsigned long )__cil_tmp26 != tibufsize) {
        {
#line 412
        write_fatal();
        }
      }
    }
    {
#line 413
    c = _IO_getc(ifp);
    }
#line 413
    if (c == -1) {
#line 414
      goto while_break___1;
    }
    {
#line 416
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 416
      if (! 1) {
#line 416
        goto while_break___2;
      }
#line 418
      __cil_tmp28 = p;
#line 418
      p ++;
#line 418
      *__cil_tmp28 = (char )c;
#line 419
      if (c == 10) {
#line 421
        last_line_size = (size_t )(p - p0);
#line 422
        goto while_break___2;
      }
      {
#line 425
      c = _IO_getc(ifp);
      }
#line 425
      if (c == -1) {
#line 427
        last_line_size = (size_t )(p - p0);
#line 428
        line ++;
#line 429
        goto EOF_reached;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 406
  line ++;
  EOF_reached: 
  {
#line 434
  __cil_tmp33 = fclose(ifp);
  }
  {
#line 434
  __cil_tmp32 = ferror(ifp);
  }
#line 434
  if (__cil_tmp32) {
    {
    {
#line 435
    read_fatal();
    }
    }
  } else
#line 434
  if (__cil_tmp33 != 0) {
    {
    {
#line 435
    read_fatal();
    }
    }
  }
#line 437
  if (line % lines_per_buf != 0L) {
    {
#line 438
    __cil_tmp34 = write(tifd, (void const   *)tibuf[0], tibufsize);
    }
#line 438
    if ((unsigned long )__cil_tmp34 != tibufsize) {
      {
#line 439
      write_fatal();
      }
    }
  }
#line 440
  input_lines = line - 1L;
}
}
#line 447 "/tmp/0/patch-2.7.1/src/inp.c"
char const   *ifetch(lin line , int whichbuf , size_t *psize ) 
{ 
  char const   *q ;
  char const   *p ;
  lin offline ;
  lin baseline ;
  __off_t __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
#line 452
  if (line < 1L) {
#line 453
    *psize = (size_t )0;
#line 454
    return ((char const   *)((char *)""));
  } else
#line 452
  if (line > input_lines) {
#line 453
    *psize = (size_t )0;
#line 454
    return ((char const   *)((char *)""));
  }
#line 456
  if (using_plan_a) {
#line 457
    p = *(i_ptr + line);
#line 458
    *psize = (size_t )(*(i_ptr + (line + 1L)) - p);
#line 459
    return (p);
  } else {
#line 461
    offline = line % lines_per_buf;
#line 462
    baseline = line - offline;
#line 464
    if (tiline[0] == baseline) {
#line 465
      whichbuf = 0;
    } else
#line 466
    if (tiline[1] == baseline) {
#line 467
      whichbuf = 1;
    } else {
      {
#line 469
      tiline[whichbuf] = baseline;
#line 470
      __cil_tmp9 = read(tifd, (void *)tibuf[whichbuf], tibufsize);
      }
      {
#line 470
      __cil_tmp8 = lseek(tifd, (__off_t )((unsigned long )(baseline / lines_per_buf) * tibufsize),
                         0);
      }
#line 470
      if (__cil_tmp8 == -1L) {
        {
        {
#line 473
        read_fatal();
        }
        }
      } else
#line 470
      if (__cil_tmp9 < 0L) {
        {
        {
#line 473
        read_fatal();
        }
        }
      }
    }
#line 475
    p = (char const   *)(tibuf[whichbuf] + tireclen * (unsigned long )offline);
#line 476
    if (line == input_lines) {
#line 477
      *psize = last_line_size;
    } else {
#line 479
      q = p;
      {
#line 479
      while (1) {
        while_continue: /* CIL Label */ ;
#line 479
        if (! ((int )((char )*__cil_tmp10) != 10)) {
#line 479
          goto while_break;
        }

      }
      while_break: /* CIL Label */ ;
      }
#line 481
      *psize = (size_t )(q - p);
    }
#line 483
    return (p);
  }
}
}
