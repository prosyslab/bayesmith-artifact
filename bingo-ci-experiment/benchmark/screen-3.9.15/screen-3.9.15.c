/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 62 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 48 "/usr/lib/llvm-6.0/lib/clang/6.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 805 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 257 "./os.h"
typedef char *slot_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 76 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_39 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_39 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 58 "./ansi.h"
enum state_t {
    LIT = 0,
    ESC = 1,
    ASTR = 2,
    STRESC = 3,
    CSI = 4,
    PRIN = 5,
    PRINESC = 6,
    PRINCSI = 7,
    PRIN4 = 8
} ;
#line 72
enum string_t {
    NONE = 0,
    DCS = 1,
    OSC = 2,
    APC = 3,
    PM = 4,
    AKA = 5,
    GM = 6,
    STATUS = 7
} ;
#line 25 "./sched.h"
struct event {
   struct event *next ;
   void (*handler)(void * , char * ) ;
   char *data ;
   int fd ;
   int type ;
   int pri ;
   struct timeval timeout ;
   int queued ;
   int active ;
   int *condpos ;
   int *condneg ;
};
#line 40 "./acls.h"
typedef unsigned char *AclBits;
#line 48
struct acluser ;
#line 46 "./acls.h"
struct aclusergroup {
   struct acluser *u ;
   struct aclusergroup *next ;
};
#line 60 "./acls.h"
struct plop {
   char *buf ;
   int len ;
   int enc ;
};
#line 74 "./acls.h"
struct acluser {
   struct acluser *u_next ;
   char u_name[21] ;
   char *u_password ;
   int u_checkpassword ;
   int u_detachwin ;
   int u_detachotherwin ;
   int u_Esc ;
   int u_MetaEsc ;
   struct plop u_plop ;
   int u_id ;
   AclBits u_umask_w_bits[3] ;
   struct aclusergroup *u_group ;
};
#line 42 "./comm.h"
struct action {
   int nr ;
   char **args ;
};
#line 30 "./layer.h"
struct mchar ;
#line 32 "./layer.h"
struct LayFuncs {
   void (*lf_LayProcess)(char ** , int * ) ;
   void (*lf_LayAbort)(void) ;
   void (*lf_LayRedisplayLine)(int  , int  , int  , int  ) ;
   void (*lf_LayClearLine)(int  , int  , int  , int  ) ;
   int (*lf_LayRewrite)(int  , int  , int  , struct mchar * , int  ) ;
   int (*lf_LayResize)(int  , int  ) ;
   void (*lf_LayRestore)(void) ;
};
#line 45
struct canvas ;
#line 43 "./layer.h"
struct layer {
   struct canvas *l_cvlist ;
   int l_width ;
   int l_height ;
   int l_x ;
   int l_y ;
   int l_encoding ;
   struct LayFuncs *l_layfn ;
   char *l_data ;
   struct layer *l_next ;
   struct layer *l_bottom ;
   int l_blocking ;
};
#line 15 "./term.h"
union tcu {
   int flg ;
   int num ;
   char *str ;
};
#line 112 "./screen.h"
struct mode {
   struct termios tio ;
};
#line 53 "./image.h"
struct mchar {
   unsigned char image ;
   unsigned char attr ;
   unsigned char font ;
   unsigned char color ;
   unsigned char mbcs ;
};
#line 62 "./image.h"
struct mline {
   unsigned char *image ;
   unsigned char *attr ;
   unsigned char *font ;
   unsigned char *color ;
};
#line 26 "./display.h"
struct kmap {
   char seq[8] ;
   char off[8] ;
   int nr ;
};
#line 44
struct win ;
#line 49
struct display ;
#line 50
struct viewport ;
#line 46 "./display.h"
struct canvas {
   struct canvas *c_next ;
   struct display *c_display ;
   struct viewport *c_vplist ;
   struct layer *c_layer ;
   struct canvas *c_lnext ;
   struct layer c_blank ;
   int c_xoff ;
   int c_yoff ;
   int c_xs ;
   int c_xe ;
   int c_ys ;
   int c_ye ;
   struct event c_captev ;
};
#line 63 "./display.h"
struct viewport {
   struct viewport *v_next ;
   struct canvas *v_canvas ;
   int v_xoff ;
   int v_yoff ;
   int v_xs ;
   int v_xe ;
   int v_ys ;
   int v_ye ;
};
#line 75 "./display.h"
struct display {
   struct display *d_next ;
   struct acluser *d_user ;
   struct canvas *d_cvlist ;
   struct canvas *d_forecv ;
   void (*d_processinput)(char * , int  ) ;
   char *d_processinputdata ;
   int d_vpxmin ;
   int d_vpxmax ;
   struct win *d_fore ;
   struct win *d_other ;
   char d_nonblock ;
   char d_termname[21] ;
   char *d_tentry ;
   char d_tcinited ;
   int d_width ;
   int d_height ;
   int d_defwidth ;
   int d_defheight ;
   int d_top ;
   int d_bot ;
   int d_x ;
   int d_y ;
   struct mchar d_rend ;
   int d_col16change ;
   char d_atyp ;
   int d_mbcs ;
   int d_encoding ;
   int d_decodestate ;
   int d_realfont ;
   int d_insert ;
   int d_keypad ;
   int d_cursorkeys ;
   int d_revvid ;
   int d_curvis ;
   int d_has_hstatus ;
   int d_hstatus ;
   int d_lp_missing ;
   int d_mouse ;
   struct mchar d_lpchar ;
   time_t d_status_time ;
   int d_status ;
   char d_status_bell ;
   int d_status_len ;
   char *d_status_lastmsg ;
   int d_status_buflen ;
   int d_status_lastx ;
   int d_status_lasty ;
   int d_status_obuflen ;
   int d_status_obuffree ;
   struct event d_statusev ;
   struct event d_hstatusev ;
   int d_kaablamm ;
   struct action *d_ESCseen ;
   int d_userpid ;
   char d_usertty[4096] ;
   int d_userfd ;
   struct event d_readev ;
   struct event d_writeev ;
   struct mode d_OldMode ;
   struct mode d_NewMode ;
   int d_flow ;
   int d_intrc ;
   char *d_obuf ;
   int d_obuflen ;
   int d_obufmax ;
   int d_obuflenmax ;
   char *d_obufp ;
   int d_obuffree ;
   int d_auto_nuke ;
   int d_nseqs ;
   char *d_seqp ;
   int d_seql ;
   struct event d_mapev ;
   int d_dontmap ;
   int d_mapdefault ;
   struct kmap d_kmaps[119] ;
   union tcu d_tcs[188] ;
   char *d_attrtab[6] ;
   char d_attrtyp[6] ;
   int d_hascolor ;
   short d_dospeed ;
   char d_c0_tab[256] ;
   char ***d_xtable ;
   int d_UPcost ;
   int d_DOcost ;
   int d_LEcost ;
   int d_NDcost ;
   int d_CRcost ;
   int d_IMcost ;
   int d_EIcost ;
   int d_NLcost ;
   int d_printfd ;
   slot_t d_loginslot ;
   struct utmp d_utmp_logintty ;
   int d_loginttymode ;
};
#line 54 "./window.h"
struct pseudowin {
   int p_fdpat ;
   int p_pid ;
   int p_ptyfd ;
   struct event p_readev ;
   struct event p_writeev ;
   char p_cmd[256] ;
   char p_tty[256] ;
   char p_inbuf[4096] ;
   int p_inlen ;
};
#line 114 "./window.h"
struct paster {
   char *pa_pastebuf ;
   char *pa_pasteptr ;
   int pa_pastelen ;
   struct layer *pa_pastelayer ;
   struct event pa_slowev ;
};
#line 213
struct logfile ;
#line 126 "./window.h"
struct win {
   struct win *w_next ;
   int w_type ;
   void *w_data ;
   struct layer w_layer ;
   struct layer *w_savelayer ;
   int w_blocked ;
   struct pseudowin *w_pwin ;
   struct display *w_pdisplay ;
   int w_number ;
   struct event w_readev ;
   struct event w_writeev ;
   struct event w_silenceev ;
   int w_ptyfd ;
   char w_inbuf[4096] ;
   int w_inlen ;
   char w_outbuf[4096] ;
   int w_outlen ;
   int w_aflag ;
   char *w_title ;
   char *w_akachange ;
   char w_akabuf[256] ;
   int w_autoaka ;
   int w_intermediate ;
   int w_args[64] ;
   int w_NumArgs ;
   int w_wlock ;
   struct acluser *w_wlockuser ;
   AclBits w_userbits[3] ;
   AclBits w_lio_notify ;
   AclBits w_mon_notify ;
   enum state_t w_state ;
   enum string_t w_StringType ;
   struct mline *w_mlines ;
   struct mchar w_rend ;
   char w_FontL ;
   char w_FontR ;
   char w_FontE ;
   int w_Charset ;
   int w_CharsetR ;
   int w_charsets[4] ;
   int w_ss ;
   int w_saved ;
   int w_Saved_x ;
   int w_Saved_y ;
   struct mchar w_SavedRend ;
   int w_SavedCharset ;
   int w_SavedCharsetR ;
   int w_SavedCharsets[4] ;
   int w_top ;
   int w_bot ;
   int w_wrap ;
   int w_origin ;
   int w_insert ;
   int w_keypad ;
   int w_cursorkeys ;
   int w_revvid ;
   int w_curinv ;
   int w_curvvis ;
   int w_autolf ;
   char *w_hstatus ;
   int w_gr ;
   int w_c1 ;
   int w_bce ;
   int w_decodestate ;
   int w_mbcs ;
   char w_string[256] ;
   char *w_stringp ;
   char *w_tabs ;
   int w_bell ;
   int w_flow ;
   struct logfile *w_log ;
   int w_logsilence ;
   int w_monitor ;
   int w_silencewait ;
   int w_silence ;
   char w_vbwait ;
   char w_norefresh ;
   int w_mouse ;
   int w_slowpaste ;
   int w_histheight ;
   int w_histidx ;
   struct mline *w_hlines ;
   struct paster w_paster ;
   int w_pid ;
   char *w_cmdargs[64] ;
   char *w_dir ;
   char *w_term ;
   int w_lflag ;
   slot_t w_slot ;
   struct utmp w_savut ;
   char w_tty[256] ;
   struct mline *w_alt_mlines ;
   int w_alt_width ;
   int w_alt_height ;
   int w_alt_histheight ;
   int w_alt_x ;
   int w_alt_y ;
   struct mline *w_alt_hlines ;
   int w_alt_histidx ;
};
#line 52 "/tmp/screen-3.9.15/encoding.c"
struct encoding {
   char *name ;
   char *charsets ;
   int deffont ;
   int usegr ;
   int noc1 ;
   char *fontlist ;
};
#line 280 "/tmp/screen-3.9.15/encoding.c"
struct recodetab {
   unsigned short (*tab)[2] ;
   int flags ;
};
#line 633 "/tmp/screen-3.9.15/encoding.c"
struct combchar {
   unsigned short c1 ;
   unsigned short c2 ;
   unsigned short next ;
   unsigned short prev ;
};
#line 875 "/tmp/screen-3.9.15/encoding.c"
struct __anonstruct_45 {
   unsigned short first ;
   unsigned short last ;
};
#line 34 "/tmp/screen-3.9.15/nethack.c"
struct nlstrans {
   char *from ;
   char *to ;
};
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 254 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_109 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_109 fd_set;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone *__timezone_ptr_t;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 25 "./logfile.h"
struct logfile {
   struct logfile *next ;
   FILE *fp ;
   char *name ;
   int opencount ;
   int writecount ;
   int flushcount ;
   struct stat *st ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 5 "./comm.h"
struct comm {
   char *name ;
   int flags ;
   AclBits userbits[1] ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 88 "./ansi.h"
enum move_t {
    M_NONE = 0,
    M_UP = 1,
    M_CUP = 2,
    M_DO = 3,
    M_CDO = 4,
    M_LE = 5,
    M_CLE = 6,
    M_RI = 7,
    M_CRI = 8,
    M_RW = 9,
    M_CR = 10
} ;
#line 27 "./window.h"
struct NewWindow {
   int StartAt ;
   char *aka ;
   char **args ;
   char *dir ;
   char *term ;
   int aflag ;
   int flowflag ;
   int lflag ;
   int histheight ;
   int monitor ;
   int wlock ;
   int silence ;
   int wrap ;
   int Lflag ;
   int slow ;
   int gr ;
   int c1 ;
   int bce ;
   int encoding ;
   char *hstatus ;
   char *charset ;
};
#line 284 "./screen.h"
struct baud_values {
   int idx ;
   int bps ;
   int sym ;
};
#line 9 "./term.h"
struct term {
   char *tcname ;
   int type ;
};
#line 193 "/tmp/screen-3.9.15/process.c"
struct kclass {
   struct kclass *next ;
   char *name ;
   struct action ktab[256] ;
};
#line 5082 "/tmp/screen-3.9.15/process.c"
struct inputsu {
   struct acluser **up ;
   char name[24] ;
   char pw1[130] ;
   char pw2[130] ;
};
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 184 "./screen.h"
struct __anonstruct_547 {
   int lflag ;
   int aflag ;
   int flowflag ;
   int hheight ;
   int nargs ;
   char line[4096] ;
   char dir[4096] ;
   char screenterm[20] ;
};
#line 196 "./screen.h"
struct __anonstruct_548 {
   char auser[21] ;
   int apid ;
   int adaptflag ;
   int lines ;
   int columns ;
   char preselect[20] ;
   int esc ;
   int meta_esc ;
   char envterm[21] ;
   int encoding ;
};
#line 209 "./screen.h"
struct __anonstruct_549 {
   char duser[21] ;
   int dpid ;
};
#line 215 "./screen.h"
struct __anonstruct_550 {
   char auser[21] ;
   int nargs ;
   char cmd[4096] ;
   int apid ;
   char preselect[20] ;
};
#line 182 "./screen.h"
union __anonunion_551 {
   struct __anonstruct_547 create ;
   struct __anonstruct_548 attach ;
   struct __anonstruct_549 detach ;
   struct __anonstruct_550 command ;
   char message[8192] ;
};
#line 177 "./screen.h"
struct msg {
   int protocol_revision ;
   int type ;
   char m_tty[4096] ;
   union __anonunion_551 m ;
};
#line 42 "/tmp/screen-3.9.15/input.c"
struct inpline {
   char buf[101] ;
   int len ;
   int pos ;
};
#line 52 "/tmp/screen-3.9.15/input.c"
struct inpdata {
   struct inpline inp ;
   int inpmaxlen ;
   char *inpstring ;
   int inpstringlen ;
   int inpmode ;
   void (*inpfinfunc)(char *buf , int len , char *priv ) ;
   char *priv ;
};
#line 114 "/tmp/screen-3.9.15/help.c"
struct helpdata {
   char *class ;
   struct action *ktabp ;
   int maxrow ;
   int grow ;
   int numcols ;
   int numrows ;
   int num_names ;
   int numskip ;
   int numpages ;
   int command_search ;
   int command_bindings ;
   int refgrow ;
   int refcommand_search ;
   int inter ;
   int mcom ;
   int mkey ;
   int nact[170] ;
};
#line 464 "/tmp/screen-3.9.15/help.c"
struct copydata {
   char *cps ;
   char *savedcps ;
   char *refcps ;
   char *refsavedcps ;
};
#line 674 "/tmp/screen-3.9.15/help.c"
struct displaysdata {
   int dummy_element_for_solaris ;
};
#line 855 "/tmp/screen-3.9.15/help.c"
struct wlistdata {
   int pos ;
   int ypos ;
   int npos ;
   int numwin ;
   int first ;
   int last ;
   int start ;
};
#line 1295 "/tmp/screen-3.9.15/help.c"
struct bindkeydata {
   char *title ;
   struct action *tab ;
   int pos ;
   int last ;
   int page ;
   int pages ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 25 "./mark.h"
struct markdata {
   struct win *md_window ;
   struct acluser *md_user ;
   int cx ;
   int cy ;
   int x1 ;
   int y1 ;
   int second ;
   int left_mar ;
   int right_mar ;
   int nonl ;
   int rep_cnt ;
   int append_mode ;
   int write_buffer ;
   int hist_offset ;
   char isstr[100] ;
   int isstrl ;
   char isistr[200] ;
   int isistrl ;
   int isdir ;
   int isstartpos ;
   int isstartdir ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 124 "/tmp/screen-3.9.15/socket.c"
struct sent {
   struct sent *next ;
   int mode ;
   char *name ;
};
#line 1251 "/tmp/screen-3.9.15/socket.c"
struct pwdata {
   int l ;
   char buf[21] ;
   struct msg m ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_1000 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_1000 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1014 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1015 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1016 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1017 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1018 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_1019 {
   struct __anonstruct_1018 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1020 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_1019 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1021 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1022 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_1023 {
   int _pad[28] ;
   struct __anonstruct_1014 _kill ;
   struct __anonstruct_1015 _timer ;
   struct __anonstruct_1016 _rt ;
   struct __anonstruct_1017 _sigchld ;
   struct __anonstruct_1020 _sigfault ;
   struct __anonstruct_1021 _sigpoll ;
   struct __anonstruct_1022 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1024 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_1023 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_1024 siginfo_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_1027 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_1027 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/tmp/screen-3.9.15/screen.c"
struct backtick ;
#line 2066 "/tmp/screen-3.9.15/screen.c"
struct backtick {
   struct backtick *next ;
   int num ;
   int tick ;
   int lifespan ;
   time_t bestbefore ;
   char result[256] ;
   char **cmdv ;
   struct event ev ;
   char *buf ;
   int bufi ;
};
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major |= 0UL;
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor |= (__dev & 17592184995840UL) >> 12;
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern _IO_FILE *stdin ;
#line 136
extern _IO_FILE *stdout ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 327
extern int vfprintf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 333
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 484
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 495
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 496
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 506
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 524
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp3 = vfprintf(stdout, __fmt, __arg);
  }
#line 38
  return (__cil_tmp3);
}
}
#line 44
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 46
  __cil_tmp1 = _IO_getc(stdin);
  }
#line 46
  return (__cil_tmp1);
}
}
#line 53
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 55
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 55
  if (__cil_tmp2) {
    {
#line 55
    __cil_tmp3 = __uflow(__fp);
#line 55
    tmp = __cil_tmp3;
    }
  } else {
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 55
  return (tmp);
}
}
#line 70
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 72
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 72
  if (__cil_tmp1) {
    {
#line 72
    __cil_tmp2 = __uflow(stdin);
#line 72
    tmp = __cil_tmp2;
    }
  } else {
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 72
  return (tmp);
}
}
#line 79
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _IO_putc(__c, stdout);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 88
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 90
  if (__cil_tmp3) {
    {
#line 90
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp = __cil_tmp4;
    }
  } else {
#line 90
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    *__cil_tmp5 = (char )__c;
#line 90
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 90
  return (tmp);
}
}
#line 105
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 107
  if (__cil_tmp2) {
    {
#line 107
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp = __cil_tmp3;
    }
  } else {
#line 107
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    *__cil_tmp4 = (char )__c;
#line 107
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 107
  return (tmp);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 549
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 817
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = ((int (*)(void const   * , void const   * ))*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 384 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s ) ;
#line 42 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n ) ;
#line 59 "./extern.h"
void SetCharsets(struct win *p , char *s ) ;
#line 72
FILE *secfopen(char *name , char *mode ) ;
#line 278
void Resize_obuf(void) ;
#line 434
void ExitOverlayPage(void) ;
#line 455
void InitBuiltinTabs(void) ;
#line 456
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) ;
#line 457
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) ;
#line 458
int FromUtf8(int c , int *utf8charp ) ;
#line 459
void AddUtf8(int c ) ;
#line 460
int ToUtf8(char *p , int c ) ;
#line 461
int ToUtf8_comb(char *p , int c ) ;
#line 462
int utf8_isdouble(int c ) ;
#line 463
int utf8_iscomb(int c ) ;
#line 464
void utf8_handle_comb(int c , struct mchar *mc ) ;
#line 465
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) ;
#line 466
int LoadFontTranslation(int font , char *file ) ;
#line 467
void LoadFontTranslationsForEncoding(int encoding ) ;
#line 469
void WinSwitchEncoding(struct win *p , int encoding ) ;
#line 470
int FindEncoding(char *name ) ;
#line 471
char *EncodingName(int encoding ) ;
#line 472
int EncodingDefFont(int encoding ) ;
#line 473
void ResetEncoding(struct win *p ) ;
#line 474
int CanEncodeFont(int encoding , int f ) ;
#line 475
int DecodeChar(int c , int encoding , int *statep ) ;
#line 476
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) ;
#line 478
int PrepareEncodedChar(int c ) ;
#line 481
int EncodeChar(char *bp , int c , int encoding , int *fontp ) ;
#line 35 "/tmp/screen-3.9.15/encoding.c"
unsigned char *null ;
#line 36
struct display *display ;
#line 36
struct display *displays ;
#line 37
struct layer *flayer ;
#line 39
char *screenencodings ;
#line 41
static int encmatch(char *s1 , char *s2 ) ;
#line 43
static int recode_char(int c , int to_utf , int font ) ;
#line 44
static int recode_char_to_encoding(int c , int encoding ) ;
#line 45
static void comb_tofront(int root , int i ) ;
#line 47
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) ;
#line 48
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) ;
#line 65 "/tmp/screen-3.9.15/encoding.c"
struct encoding encodings[]  = 
#line 65
  {      {(char *)"C", (char *)0, 0, 0, 0, (char *)0}, 
        {(char *)"eucJP", (char *)"B\002I\00401", 0, 1, 0, (char *)"\002\004I"}, 
        {(char *)"SJIS", (char *)"BIBB01", 0, 1, 1, (char *)"\002I"}, 
        {(char *)"eucKR", (char *)"B\003BB01", 0, 1, 0, (char *)"\003"}, 
        {(char *)"eucCN", (char *)"B\001BB01", 0, 1, 0, (char *)"\001"}, 
        {(char *)"Big5", (char *)"B\030BB01", 0, 1, 0, (char *)"\030"}, 
        {(char *)"KOI8-R", (char *)0, 161, 0, 1, (char *)0}, 
        {(char *)"CP1251", (char *)0, 191, 0, 1, (char *)0}, 
        {(char *)"UTF-8", (char *)0, - 1, 0, 0, (char *)0}, 
        {(char *)"ISO8859-2", (char *)0, 194, 0, 0, (char *)0}, 
        {(char *)"ISO8859-3", (char *)0, 195, 0, 0, (char *)0}, 
        {(char *)"ISO8859-4", (char *)0, 196, 0, 0, (char *)0}, 
        {(char *)"ISO8859-5", (char *)0, 204, 0, 0, (char *)0}, 
        {(char *)"ISO8859-6", (char *)0, 199, 0, 0, (char *)0}, 
        {(char *)"ISO8859-7", (char *)0, 198, 0, 0, (char *)0}, 
        {(char *)"ISO8859-8", (char *)0, 200, 0, 0, (char *)0}, 
        {(char *)"ISO8859-9", (char *)0, 205, 0, 0, (char *)0}, 
        {(char *)"ISO8859-10", (char *)0, 214, 0, 0, (char *)0}, 
        {(char *)"ISO8859-15", (char *)0, 226, 0, 0, (char *)0}, 
        {(char *)"jis", (char *)0, 0, 0, 0, (char *)"\002\004I"}, 
        {(char *)"GBK", (char *)"B\031BB01", 226, 1, 1, (char *)"\031"}};
#line 91 "/tmp/screen-3.9.15/encoding.c"
static unsigned short builtin_tabs[][2]  = 
#line 91
  { {        (unsigned short )48,        (unsigned short )0}, 
   {        (unsigned short )95,        (unsigned short )9646}, 
   {        (unsigned short )96,        (unsigned short )9670}, 
   {        (unsigned short )97,        (unsigned short )9618}, 
   {        (unsigned short )98,        (unsigned short )9225}, 
   {        (unsigned short )99,        (unsigned short )9228}, 
   {        (unsigned short )100,        (unsigned short )9229}, 
   {        (unsigned short )101,        (unsigned short )9226}, 
   {        (unsigned short )102,        (unsigned short )176}, 
   {        (unsigned short )103,        (unsigned short )177}, 
   {        (unsigned short )104,        (unsigned short )9252}, 
   {        (unsigned short )105,        (unsigned short )9227}, 
   {        (unsigned short )106,        (unsigned short )9496}, 
   {        (unsigned short )107,        (unsigned short )9488}, 
   {        (unsigned short )108,        (unsigned short )9484}, 
   {        (unsigned short )109,        (unsigned short )9492}, 
   {        (unsigned short )110,        (unsigned short )9532}, 
   {        (unsigned short )111,        (unsigned short )9146}, 
   {        (unsigned short )112,        (unsigned short )9147}, 
   {        (unsigned short )113,        (unsigned short )9472}, 
   {        (unsigned short )114,        (unsigned short )9148}, 
   {        (unsigned short )115,        (unsigned short )9149}, 
   {        (unsigned short )116,        (unsigned short )9500}, 
   {        (unsigned short )117,        (unsigned short )9508}, 
   {        (unsigned short )118,        (unsigned short )9524}, 
   {        (unsigned short )119,        (unsigned short )9516}, 
   {        (unsigned short )120,        (unsigned short )9474}, 
   {        (unsigned short )121,        (unsigned short )8804}, 
   {        (unsigned short )122,        (unsigned short )8805}, 
   {        (unsigned short )123,        (unsigned short )960}, 
   {        (unsigned short )124,        (unsigned short )8800}, 
   {        (unsigned short )125,        (unsigned short )163}, 
   {        (unsigned short )126,        (unsigned short )183}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )52,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )190}, 
   {        (unsigned short )91,        (unsigned short )255}, 
   {        (unsigned short )92,        (unsigned short )189}, 
   {        (unsigned short )93,        (unsigned short )124}, 
   {        (unsigned short )123,        (unsigned short )168}, 
   {        (unsigned short )124,        (unsigned short )102}, 
   {        (unsigned short )125,        (unsigned short )188}, 
   {        (unsigned short )126,        (unsigned short )180}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )53,        (unsigned short )0}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )233}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )54,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )196}, 
   {        (unsigned short )91,        (unsigned short )198}, 
   {        (unsigned short )92,        (unsigned short )216}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )228}, 
   {        (unsigned short )123,        (unsigned short )230}, 
   {        (unsigned short )124,        (unsigned short )248}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )55,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )201}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )233}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )61,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )249}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )233}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )234}, 
   {        (unsigned short )94,        (unsigned short )238}, 
   {        (unsigned short )95,        (unsigned short )232}, 
   {        (unsigned short )96,        (unsigned short )244}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )252}, 
   {        (unsigned short )126,        (unsigned short )251}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )65,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )75,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )220}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )252}, 
   {        (unsigned short )126,        (unsigned short )223}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )81,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )226}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )234}, 
   {        (unsigned short )94,        (unsigned short )238}, 
   {        (unsigned short )96,        (unsigned short )244}, 
   {        (unsigned short )123,        (unsigned short )233}, 
   {        (unsigned short )124,        (unsigned short )249}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )251}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )82,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )176}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )167}, 
   {        (unsigned short )123,        (unsigned short )233}, 
   {        (unsigned short )124,        (unsigned short )249}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )168}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )89,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )176}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )233}, 
   {        (unsigned short )96,        (unsigned short )249}, 
   {        (unsigned short )123,        (unsigned short )224}, 
   {        (unsigned short )124,        (unsigned short )242}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )236}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )90,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )161}, 
   {        (unsigned short )92,        (unsigned short )209}, 
   {        (unsigned short )93,        (unsigned short )191}, 
   {        (unsigned short )123,        (unsigned short )176}, 
   {        (unsigned short )124,        (unsigned short )241}, 
   {        (unsigned short )125,        (unsigned short )231}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )226,        (unsigned short )0}, 
   {        (unsigned short )164,        (unsigned short )8364}, 
   {        (unsigned short )166,        (unsigned short )352}, 
   {        (unsigned short )168,        (unsigned short )353}, 
   {        (unsigned short )180,        (unsigned short )381}, 
   {        (unsigned short )184,        (unsigned short )382}, 
   {        (unsigned short )188,        (unsigned short )338}, 
   {        (unsigned short )189,        (unsigned short )339}, 
   {        (unsigned short )190,        (unsigned short )376}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )74,        (unsigned short )0}, 
   {        (unsigned short )92,        (unsigned short )165}, 
   {        (unsigned short )126,        (unsigned short )8254}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )73,        (unsigned short )0}, 
   {        (unsigned short )33,        (unsigned short )65377}, 
   {        (unsigned short )32863,        (unsigned short )65439}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )0,        (unsigned short )0}};
#line 290
static struct recodetab recodetabs[256] ;
#line 293 "/tmp/screen-3.9.15/encoding.c"
void InitBuiltinTabs(void) 
{ 
  unsigned short (*p)[2] ;

  {
#line 296
  p = (unsigned short (*)[2])builtin_tabs;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (*p)[0]) {
#line 296
      goto while_break;
    }
#line 298
    recodetabs[(*p)[0]].flags = 2;
#line 299
    recodetabs[(*p)[0]].tab = p + 1;
#line 300
    p ++;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! (*p)[0]) {
#line 301
        goto while_break___0;
      }
#line 302
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  p ++;
}
}
#line 307 "/tmp/screen-3.9.15/encoding.c"
static int recode_char(int c , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  if (to_utf) {
#line 315
    if (c < 256) {
#line 316
      return (c);
    }
#line 317
    f = (c >> 8) & 255;
#line 318
    c &= 255;
    {
#line 322
    if (f == 'C') {
#line 322
      goto case_67;
    }
#line 325
    if (f == 'E') {
#line 325
      goto case_69;
    }
#line 328
    if (f == 'H') {
#line 328
      goto case_72;
    }
#line 331
    goto switch_default;
    case_67: /* CIL Label */ 
#line 323
    f ^= 118;
#line 324
    goto switch_break;
    case_69: /* CIL Label */ 
#line 326
    f ^= 115;
#line 327
    goto switch_break;
    case_72: /* CIL Label */ 
#line 329
    f ^= 127;
#line 330
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 332
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 334
    p = recodetabs[f].tab;
#line 335
    if (p == (unsigned short (*)[2])0) {
#line 335
      if (recodetabs[f].flags == 0) {
        {
#line 337
        LoadFontTranslation(f, (char *)0);
#line 338
        p = recodetabs[f].tab;
        }
      }
    }
#line 340
    if (p) {
      {
#line 341
      while (1) {
        while_continue: /* CIL Label */ ;
#line 341
        if (! (*p)[0]) {
#line 341
          goto while_break;
        }
#line 343
        if ((int )(*(p + 0))[0] & 32768) {
#line 343
          if (c <= ((int )(*(p + 0))[0] & 32767)) {
#line 343
            if (c >= (int )(*(p + -1))[0]) {
#line 344
              return ((c - (int )(*(p + -1))[0]) + (int )(*(p + -1))[1]);
            }
          }
        }
#line 345
        if ((int )(*p)[0] == c) {
#line 346
          return ((int )(*p)[1]);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 341
      p ++;
    }
#line 348
    return (c & 255);
  }
#line 350
  if (font == -1) {
#line 352
    if (c < 256) {
#line 353
      return (c);
    }
#line 354
    font = 32;
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! (font < 128)) {
#line 354
        goto while_break___0;
      }
#line 356
      p = recodetabs[font].tab;
#line 357
      if (p) {
        {
#line 358
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 358
          if (! (*p)[1]) {
#line 358
            goto while_break___1;
          }
#line 360
          if ((int )(*(p + 0))[0] & 32768) {
#line 360
            if (c <= (int )(*(p + 0))[1]) {
#line 360
              if (c >= (int )(*(p + -1))[1]) {
#line 361
                return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | (font << 8));
              }
            }
          }
#line 362
          if ((int )(*p)[1] == c) {
#line 363
            return ((int )(*p)[0] | (font << 8));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 358
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 354
    font ++;
#line 366
    return ('?');
  }
#line 368
  if (c < 128) {
#line 368
    if ((font & 128) != 0) {
#line 369
      return (c);
    }
  }
#line 370
  if (font >= 32) {
#line 372
    p = recodetabs[font].tab;
#line 373
    if (p == (unsigned short (*)[2])0) {
#line 373
      if (recodetabs[font].flags == 0) {
        {
#line 375
        LoadFontTranslation(font, (char *)0);
#line 376
        p = recodetabs[font].tab;
        }
      }
    }
#line 378
    if (p) {
      {
#line 379
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 379
        if (! (*p)[1]) {
#line 379
          goto while_break___2;
        }
#line 381
        if ((int )(*(p + 0))[0] & 32768) {
#line 381
          if (c <= (int )(*(p + 0))[1]) {
#line 381
            if (c >= (int )(*(p + -1))[1]) {
#line 382
              if (font & 128) {
#line 382
                tmp = 0;
              } else {
#line 382
                tmp = font << 8;
              }
#line 382
              return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | tmp);
            }
          }
        }
#line 383
        if ((int )(*p)[1] == c) {
#line 384
          if (font & 128) {
#line 384
            tmp___0 = 0;
          } else {
#line 384
            tmp___0 = font << 8;
          }
#line 384
          return ((int )(*p)[0] | tmp___0);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 379
      p ++;
    }
  }
#line 387
  return (- 1);
}
}
#line 393 "/tmp/screen-3.9.15/encoding.c"
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int __cil_tmp7 ;

  {
#line 399
  if (to_utf) {
#line 401
    f = (c >> 8) & 255;
#line 402
    c = ((c & 255) << 8) | (*c2p & 255);
#line 403
    *c2p = 65535;
#line 404
    p = recodetabs[f].tab;
#line 405
    if (p == (unsigned short (*)[2])0) {
#line 405
      if (recodetabs[f].flags == 0) {
        {
#line 407
        LoadFontTranslation(f, (char *)0);
#line 408
        p = recodetabs[f].tab;
        }
      }
    }
#line 410
    if (p) {
      {
#line 411
      while (1) {
        while_continue: /* CIL Label */ ;
#line 411
        if (! (*p)[0]) {
#line 411
          goto while_break;
        }
#line 412
        if ((int )(*p)[0] == c) {
          {
#line 415
          __cil_tmp7 = utf8_isdouble((int )(*p)[1]);
          }
#line 415
          if (! __cil_tmp7) {
#line 416
            *c2p = ' ';
          }
#line 418
          return ((int )(*p)[1]);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      p ++;
    }
#line 420
    return (65311);
  }
#line 422
  if (font == -1) {
#line 424
    font = 0;
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      if (! (font < 24)) {
#line 424
        goto while_break___0;
      }
#line 426
      p = recodetabs[font].tab;
#line 427
      if (p) {
        {
#line 428
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 428
          if (! (*p)[1]) {
#line 428
            goto while_break___1;
          }
#line 429
          if ((int )(*p)[1] == c) {
#line 431
            *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 432
            return (((int )(*p)[0] >> 8) | (font << 8));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 428
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    font ++;
#line 435
    *c2p = '?';
#line 436
    return ('?');
  }
#line 438
  if (font < 32) {
#line 440
    p = recodetabs[font].tab;
#line 441
    if (p == (unsigned short (*)[2])0) {
#line 441
      if (recodetabs[font].flags == 0) {
        {
#line 443
        LoadFontTranslation(font, (char *)0);
#line 444
        p = recodetabs[font].tab;
        }
      }
    }
#line 446
    if (p) {
      {
#line 447
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 447
        if (! (*p)[1]) {
#line 447
          goto while_break___2;
        }
#line 448
        if ((int )(*p)[1] == c) {
#line 450
          *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 451
          return (((int )(*p)[0] >> 8) | (font << 8));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 447
      p ++;
    }
  }
#line 454
  return (- 1);
}
}
#line 459 "/tmp/screen-3.9.15/encoding.c"
static int recode_char_to_encoding(int c , int encoding ) 
{ 
  char *fp ;
  int x ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;

  {
#line 465
  if (encoding == 8) {
    {
#line 466
    __cil_tmp5 = recode_char(c, 1, - 1);
    }
#line 466
    return (__cil_tmp5);
  }
#line 467
  fp = encodings[encoding].fontlist;
#line 467
  if (fp != (char *)0) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      if (! *fp) {
#line 468
        goto while_break;
      }
      {
#line 469
      __cil_tmp6 = fp;
#line 469
      fp ++;
#line 469
      __cil_tmp7 = recode_char(c, 0, (int )((unsigned char )*__cil_tmp6));
#line 469
      x = __cil_tmp7;
      }
#line 469
      if (x != -1) {
#line 470
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 471
  if (encodings[encoding].deffont) {
    {
#line 472
    x = recode_char(c, 0, encodings[encoding].deffont);
    }
#line 472
    if (x != -1) {
#line 473
      return (x);
    }
  }
  {
#line 474
  __cil_tmp9 = recode_char(c, 0, - 1);
  }
#line 474
  return (__cil_tmp9);
}
}
#line 479 "/tmp/screen-3.9.15/encoding.c"
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) 
{ 
  char *fp ;
  int x ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;

  {
#line 485
  if (encoding == 8) {
    {
#line 486
    __cil_tmp6 = recode_char_dw(c, c2p, 1, - 1);
    }
#line 486
    return (__cil_tmp6);
  }
#line 487
  fp = encodings[encoding].fontlist;
#line 487
  if (fp != (char *)0) {
    {
#line 488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 488
      if (! *fp) {
#line 488
        goto while_break;
      }
      {
#line 489
      __cil_tmp7 = fp;
#line 489
      fp ++;
#line 489
      __cil_tmp8 = recode_char_dw(c, c2p, 0, (int )((unsigned char )*__cil_tmp7));
#line 489
      x = __cil_tmp8;
      }
#line 489
      if (x != -1) {
#line 490
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 491
  if (encodings[encoding].deffont) {
    {
#line 492
    x = recode_char_dw(c, c2p, 0, encodings[encoding].deffont);
    }
#line 492
    if (x != -1) {
#line 493
      return (x);
    }
  }
  {
#line 494
  __cil_tmp10 = recode_char_dw(c, c2p, 0, - 1);
  }
#line 494
  return (__cil_tmp10);
}
}
#line 500 "/tmp/screen-3.9.15/encoding.c"
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) 
{ 
  static struct mchar rmc ;
  int c ;
  int c2 ;

  {
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  if (from == to) {
#line 509
    return (mc);
  } else
#line 508
  if (from != 8) {
#line 508
    if (to != 8) {
#line 509
      return (mc);
    }
  }
#line 510
  rmc = *mc;
#line 511
  if ((int )rmc.font == 0) {
#line 511
    if (from != 8) {
#line 512
      rmc.font = (unsigned char )encodings[from].deffont;
    }
  }
#line 513
  if ((int )rmc.font == 0) {
#line 514
    return (mc);
  }
#line 515
  c = (int )rmc.image | ((int )rmc.font << 8);
#line 517
  if (rmc.mbcs) {
    {
#line 519
    c2 = (int )rmc.mbcs;
#line 520
    c = recode_char_dw_to_encoding(c, & c2, to);
#line 521
    rmc.mbcs = (unsigned char )c2;
    }
  } else {
    {
#line 525
    c = recode_char_to_encoding(c, to);
    }
  }
#line 526
  rmc.image = (unsigned char )(c & 255);
#line 527
  rmc.font = (unsigned char )((c >> 8) & 255);
#line 528
  return (& rmc);
}
}
#line 532 "/tmp/screen-3.9.15/encoding.c"
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) 
{ 
  static int maxlen ;
  static int last ;
  static struct mline rml[2] ;
  static struct mline *rl ;
  int i ;
  int c ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp20 ;
  int c2 ;

  {
#line 542
  if (from == to) {
#line 543
    return (ml);
  } else
#line 542
  if (from != 8) {
#line 542
    if (to != 8) {
#line 543
      return (ml);
    } else {
#line 542
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 542
  if (w == 0) {
#line 543
    return (ml);
  }
#line 544
  if (ml->font == null) {
#line 544
    if (encodings[from].deffont == 0) {
#line 545
      return (ml);
    }
  }
#line 546
  if (w > maxlen) {
#line 548
    i = 0;
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 548
      if (! (i < 2)) {
#line 548
        goto while_break;
      }
#line 550
      if (rml[i].image == (unsigned char *)0) {
        {
#line 551
        __cil_tmp11 = malloc((unsigned long )w);
#line 551
        rml[i].image = (unsigned char *)__cil_tmp11;
        }
      } else {
        {
#line 553
        __cil_tmp12 = realloc((void *)rml[i].image, (unsigned long )w);
#line 553
        rml[i].image = (unsigned char *)__cil_tmp12;
        }
      }
#line 554
      if (rml[i].font == (unsigned char *)0) {
        {
#line 555
        __cil_tmp13 = malloc((unsigned long )w);
#line 555
        rml[i].font = (unsigned char *)__cil_tmp13;
        }
      } else {
        {
#line 557
        __cil_tmp14 = realloc((void *)rml[i].font, (unsigned long )w);
#line 557
        rml[i].font = (unsigned char *)__cil_tmp14;
        }
      }
#line 558
      if (rml[i].image == (unsigned char *)0) {
#line 560
        maxlen = 0;
#line 561
        return (ml);
      } else
#line 558
      if (rml[i].font == (unsigned char *)0) {
#line 560
        maxlen = 0;
#line 561
        return (ml);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 548
    i ++;
#line 564
    maxlen = w;
  }
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 567
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 568
    if (! (i < w)) {
#line 568
      goto while_break___1;
    }
    {
#line 569
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 569
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 568
  i ++;
  {
#line 570
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 570
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 571
  i = 0;
  {
#line 571
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 571
    if (! (i < w)) {
#line 571
      goto while_break___4;
    }
    {
#line 572
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 572
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 571
  i ++;
  {
#line 573
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 573
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 574
    if (! (i < w)) {
#line 574
      goto while_break___7;
    }
    {
#line 575
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 575
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 574
  i ++;
  {
#line 576
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 576
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 577
  i = 0;
  {
#line 577
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 577
    if (! (i < w)) {
#line 577
      goto while_break___10;
    }
    {
#line 578
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 578
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 577
  i ++;
  {
#line 579
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 579
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 581
  rl = (struct mline *)rml + last;
#line 582
  rl->attr = ml->attr;
#line 584
  rl->color = ml->color;
#line 589
  i = 0;
  {
#line 589
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 589
    if (! (i < w)) {
#line 589
      goto while_break___13;
    }
#line 591
    c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 592
    if (from != 8) {
#line 592
      if (c < 256) {
#line 593
        c |= encodings[from].deffont << 8;
      }
    }
    {
#line 595
    __cil_tmp20 = utf8_isdouble(c);
    }
#line 595
    if (from != 8) {
#line 595
      if ((c & 7936) != 0) {
#line 595
        if ((c & 57344) == 0) {
          _L___1: /* CIL Label */ 
#line 597
          if (i + 1 == w) {
#line 598
            c = '?';
          } else {
            {
#line 602
            i ++;
#line 603
            c2 = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 604
            c = recode_char_dw_to_encoding(c, & c2, to);
#line 605
            *(rl->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 606
            *(rl->image + (i - 1)) = (unsigned char )(c & 255);
#line 607
            c = c2;
            }
          }
        } else {
#line 595
          goto _L___2;
        }
      } else {
#line 595
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 595
    if (from == 8) {
#line 595
      if (__cil_tmp20) {
#line 595
        goto _L___1;
      } else {
        {
        {
#line 612
        c = recode_char_to_encoding(c, to);
        }
        }
      }
    } else {
      {
      {
#line 612
      c = recode_char_to_encoding(c, to);
      }
      }
    }
#line 613
    *(rl->image + i) = (unsigned char )(c & 255);
#line 614
    *(rl->font + i) = (unsigned char )((c >> 8) & 255);
  }
  while_break___13: /* CIL Label */ ;
  }
#line 589
  i ++;
#line 616
  last ^= 1;
  {
#line 617
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 617
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 618
  i = 0;
  {
#line 618
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 618
    if (! (i < w)) {
#line 618
      goto while_break___15;
    }
    {
#line 619
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 619
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 618
  i ++;
  {
#line 620
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 620
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 621
  i = 0;
  {
#line 621
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 621
    if (! (i < w)) {
#line 621
      goto while_break___18;
    }
    {
#line 622
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 622
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 621
  i ++;
  {
#line 623
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 623
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 624
  i = 0;
  {
#line 624
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 624
    if (! (i < w)) {
#line 624
      goto while_break___21;
    }
    {
#line 625
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 625
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  while_break___21: /* CIL Label */ ;
  }
#line 624
  i ++;
  {
#line 626
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 626
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 627
    if (! (i < w)) {
#line 627
      goto while_break___24;
    }
    {
#line 628
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 628
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
#line 627
  i ++;
  {
#line 629
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 629
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 630
  return (rl);
}
}
#line 639
struct combchar **combchars ;
#line 642 "/tmp/screen-3.9.15/encoding.c"
void AddUtf8(int c ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  if (c >= 55296) {
#line 646
    if (c < 57344) {
#line 646
      if (combchars) {
#line 646
        if (*(combchars + (c - 55296))) {
          {
#line 648
          AddUtf8((int )(*(combchars + (c - 55296)))->c1);
#line 649
          c = (int )(*(combchars + (c - 55296)))->c2;
          }
        }
      }
    }
  }
#line 651
  if (c >= 2048) {
    {
#line 653
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 653
      (display->d_obuffree) --;
#line 653
      if (display->d_obuffree <= 0) {
        {
#line 653
        Resize_obuf();
        }
      }
#line 653
      __cil_tmp2 = display->d_obufp;
#line 653
      (display->d_obufp) ++;
#line 653
      *__cil_tmp2 = (char )(((c & 61440) >> 12) | 224);
#line 653
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 654
    c = (c & 4095) | 4096;
  }
#line 656
  if (c >= 128) {
    {
#line 658
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 658
      (display->d_obuffree) --;
#line 658
      if (display->d_obuffree <= 0) {
        {
#line 658
        Resize_obuf();
        }
      }
#line 658
      __cil_tmp3 = display->d_obufp;
#line 658
      (display->d_obufp) ++;
#line 658
      *__cil_tmp3 = (char )(((c & 8128) >> 6) ^ 192);
#line 658
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 659
    c = (c & 63) | 128;
  }
  {
#line 661
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 661
    (display->d_obuffree) --;
#line 661
    if (display->d_obuffree <= 0) {
      {
#line 661
      Resize_obuf();
      }
    }
#line 661
    __cil_tmp4 = display->d_obufp;
#line 661
    (display->d_obufp) ++;
#line 661
    *__cil_tmp4 = (char )c;
#line 661
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 665 "/tmp/screen-3.9.15/encoding.c"
int ToUtf8_comb(char *p , int c ) 
{ 
  int l ;
  char *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 671
  if (c >= 55296) {
#line 671
    if (c < 57344) {
#line 671
      if (combchars) {
#line 671
        if (*(combchars + (c - 55296))) {
          {
#line 673
          l = ToUtf8_comb(p, (int )(*(combchars + (c - 55296)))->c1);
          }
#line 674
          if (p) {
#line 674
            tmp = p + l;
          } else {
#line 674
            tmp = (char *)0;
          }
          {
#line 674
          __cil_tmp6 = ToUtf8(tmp, (int )(*(combchars + (c - 55296)))->c2);
          }
#line 674
          return (l + __cil_tmp6);
        }
      }
    }
  }
  {
#line 676
  __cil_tmp7 = ToUtf8(p, c);
  }
#line 676
  return (__cil_tmp7);
}
}
#line 680 "/tmp/screen-3.9.15/encoding.c"
int ToUtf8(char *p , int c ) 
{ 
  int l ;
  char *__cil_tmp4 ;
  char *__cil_tmp6 ;
  char *__cil_tmp8 ;

  {
#line 684
  l = 1;
#line 685
  if (c >= 2048) {
#line 687
    if (p) {
#line 688
      __cil_tmp4 = p;
#line 688
      p ++;
#line 688
      *__cil_tmp4 = (char )(((c & 61440) >> 12) | 224);
    }
#line 689
    l ++;
#line 690
    c = (c & 4095) | 4096;
  }
#line 692
  if (c >= 128) {
#line 694
    if (p) {
#line 695
      __cil_tmp6 = p;
#line 695
      p ++;
#line 695
      *__cil_tmp6 = (char )(((c & 8128) >> 6) ^ 192);
    }
#line 696
    l ++;
#line 697
    c = (c & 63) | 128;
  }
#line 699
  if (p) {
#line 700
    __cil_tmp8 = p;
#line 700
    p ++;
#line 700
    *__cil_tmp8 = (char )c;
  }
#line 701
  return (l);
}
}
#line 711 "/tmp/screen-3.9.15/encoding.c"
int FromUtf8(int c , int *utf8charp ) 
{ 
  int utf8char ;
  int tmp ;

  {
#line 714
  utf8char = *utf8charp;
#line 715
  if (utf8char) {
#line 717
    if ((c & 192) != 128) {
#line 719
      *utf8charp = 0;
#line 720
      return (- 2);
    } else {
#line 723
      c = (c & 63) | (utf8char << 6);
    }
#line 724
    if (! (utf8char & 1073741824)) {
#line 727
      if (((unsigned int )c & 2181571552U) == 2147483648U) {
#line 728
        c = (int )4261412863U;
      } else
#line 729
      if ((c & 34087408) == 33554432) {
#line 730
        c = (int )4294443007U;
      } else
#line 731
      if ((c & 532728) == 524288) {
#line 732
        c = (int )4294955008U;
      } else
#line 733
      if ((c & 8316) == 8192) {
#line 734
        c = (int )4294967152U;
      }
    }
  } else
#line 740
  if (c >= 254) {
#line 741
    c = 65533;
  } else
#line 742
  if (c >= 252) {
#line 743
    c = (int )((unsigned int )(c & 1) | 3221225468U);
  } else
#line 744
  if (c >= 248) {
#line 745
    c = (int )((unsigned int )(c & 3) | 3221225216U);
  } else
#line 746
  if (c >= 240) {
#line 747
    c = (int )((unsigned int )(c & 7) | 3221209088U);
  } else
#line 748
  if (c >= 224) {
#line 749
    c = (int )((unsigned int )(c & 15) | 3220176896U);
  } else
#line 750
  if (c >= 194) {
#line 751
    c = (int )((unsigned int )(c & 31) | 4227858432U);
  } else
#line 752
  if (c >= 192) {
#line 753
    c = (int )4261412863U;
  } else
#line 754
  if (c >= 128) {
#line 755
    c = 65533;
  }
#line 757
  if ((unsigned int )c & 2147483648U) {
#line 757
    tmp = c;
  } else {
#line 757
    tmp = 0;
  }
#line 757
  utf8char = tmp;
#line 757
  *utf8charp = utf8char;
#line 758
  if (utf8char) {
#line 759
    return (- 1);
  }
#line 760
  if ((unsigned int )c & 4294901760U) {
#line 761
    c = 65533;
  }
#line 762
  if (c >= 55296) {
#line 762
    if (c <= 57343) {
#line 763
      c = 65533;
    } else
#line 762
    if (c == 65534) {
#line 763
      c = 65533;
    } else
#line 762
    if (c == 65535) {
#line 763
      c = 65533;
    }
  }
#line 764
  return (c);
}
}
#line 769 "/tmp/screen-3.9.15/encoding.c"
void WinSwitchEncoding(struct win *p , int encoding ) 
{ 
  int i ;
  int j ;
  int c ;
  struct mline *ml ;
  struct display *d ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  struct mline *tmp ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int c2 ;

  {
#line 779
  if ((p->w_layer.l_encoding == 8) == (encoding == 8)) {
#line 781
    p->w_layer.l_encoding = encoding;
#line 782
    return;
  }
#line 784
  oldflayer = flayer;
#line 785
  d = displays;
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! d) {
#line 785
      goto while_break;
    }
#line 786
    cv = d->d_cvlist;
    {
#line 786
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 786
      if (! cv) {
#line 786
        goto while_break___0;
      }
#line 787
      if (p == (struct win *)((cv->c_layer)->l_bottom)->l_data) {
#line 789
        flayer = cv->c_layer;
        {
#line 790
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 790
          if (! flayer->l_next) {
#line 790
            goto while_break___1;
          }
#line 792
          if (oldflayer == flayer) {
#line 793
            oldflayer = flayer->l_next;
          }
          {
#line 794
          ExitOverlayPage();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 786
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  d = d->d_next;
#line 797
  flayer = oldflayer;
#line 798
  j = 0;
  {
#line 798
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 798
    if (! (j < p->w_layer.l_height + p->w_histheight)) {
#line 798
      goto while_break___2;
    }
#line 801
    if (j < p->w_layer.l_height) {
#line 801
      tmp = & *(p->w_mlines + j);
    } else {
#line 801
      tmp = & *(p->w_hlines + (j - p->w_layer.l_height));
    }
#line 801
    ml = tmp;
#line 805
    if (ml->font == null) {
#line 805
      if (encodings[p->w_layer.l_encoding].deffont == 0) {
#line 806
        goto while_continue___2;
      }
    }
#line 807
    i = 0;
    {
#line 807
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 807
      if (! (i < p->w_layer.l_width)) {
#line 807
        goto while_break___3;
      }
#line 809
      c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 810
      if (p->w_layer.l_encoding != 8) {
#line 810
        if (c < 256) {
#line 811
          c |= encodings[p->w_layer.l_encoding].deffont << 8;
        }
      }
#line 812
      if (c < 256) {
#line 813
        goto while_continue___3;
      }
#line 814
      if (ml->font == null) {
        {
#line 816
        __cil_tmp11 = malloc((unsigned long )(p->w_layer.l_width + 1));
#line 816
        ml->font = (unsigned char *)__cil_tmp11;
        }
#line 816
        if (ml->font == (unsigned char *)0) {
#line 818
          ml->font = null;
#line 819
          goto while_break___3;
        }
        {
#line 821
        bzero((void *)ml->font, (unsigned long )(p->w_layer.l_width + 1));
        }
      }
      {
#line 824
      __cil_tmp12 = utf8_isdouble(c);
      }
#line 824
      if (p->w_layer.l_encoding != 8) {
#line 824
        if ((c & 7936) != 0) {
#line 824
          if ((c & 57344) == 0) {
            _L: /* CIL Label */ 
#line 826
            if (i + 1 == p->w_layer.l_width) {
#line 827
              c = '?';
            } else {
              {
#line 831
              i ++;
#line 832
              c2 = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 833
              c = recode_char_dw_to_encoding(c, & c2, encoding);
#line 834
              *(ml->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 835
              *(ml->image + (i - 1)) = (unsigned char )(c & 255);
#line 836
              c = c2;
              }
            }
          } else {
#line 824
            goto _L___4;
          }
        } else {
#line 824
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 824
      if (p->w_layer.l_encoding == 8) {
#line 824
        if (__cil_tmp12) {
#line 824
          goto _L;
        } else {
          {
          {
#line 841
          c = recode_char_to_encoding(c, encoding);
          }
          }
        }
      } else {
        {
        {
#line 841
        c = recode_char_to_encoding(c, encoding);
        }
        }
      }
#line 842
      *(ml->image + i) = (unsigned char )(c & 255);
#line 843
      *(ml->font + i) = (unsigned char )((c >> 8) & 255);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 807
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 798
  j ++;
#line 846
  p->w_layer.l_encoding = encoding;
#line 847
  return;
}
}
#line 852 "/tmp/screen-3.9.15/encoding.c"
int utf8_isdouble(int c ) 
{ 


  {
#line 855
  return (c >= 4352 && ((((((((c <= 4447 || (((c >= 11904 && c <= 42191) && (c & -18) != 12298) && c != 12351)) || (c >= 44032 && c <= 55203)) || (c >= 57088 && c <= 57343)) || (c >= 63744 && c <= 64255)) || (c >= 65072 && c <= 65135)) || (c >= 65280 && c <= 65375)) || (c >= 65504 && c <= 65510)) || (c >= 131072 && c <= 196607)));
}
}
#line 871 "/tmp/screen-3.9.15/encoding.c"
int utf8_iscomb(int c ) 
{ 
  static struct __anonstruct_45 combining[] ;
  int mid ;
  int min ;
  int max ;

  {
#line 916
  min = 0;
#line 916
  max = (int )(sizeof(combining) / sizeof(*((struct __anonstruct_45 *)combining)) - 1UL);
#line 918
  if (c < 768) {
#line 919
    return (0);
  } else
#line 918
  if (c > 65531) {
#line 919
    return (0);
  }
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! (max >= min)) {
#line 920
      goto while_break;
    }
#line 922
    mid = (min + max) / 2;
#line 923
    if (c > (int )combining[mid].last) {
#line 924
      min = mid + 1;
    } else
#line 925
    if (c < (int )combining[mid].first) {
#line 926
      max = mid - 1;
    } else {
#line 928
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  return (0);
}
}
#line 934 "/tmp/screen-3.9.15/encoding.c"
static void comb_tofront(int root , int i ) 
{ 


  {
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (! 1) {
#line 937
      goto while_break;
    }
    {
#line 939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 939
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 940
    (*(combchars + (*(combchars + i))->prev))->next = (*(combchars + i))->next;
#line 941
    (*(combchars + (*(combchars + i))->next))->prev = (*(combchars + i))->prev;
#line 942
    (*(combchars + i))->next = (*(combchars + root))->next;
#line 943
    (*(combchars + i))->prev = (unsigned short )root;
#line 944
    (*(combchars + (*(combchars + root))->next))->prev = (unsigned short )i;
#line 945
    (*(combchars + root))->next = (unsigned short )i;
#line 946
    i = (int )(*(combchars + i))->c1;
#line 947
    if (i < 55296) {
#line 948
      return;
    } else
#line 947
    if (i >= 57344) {
#line 948
      return;
    }
#line 949
    i -= 55296;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 954 "/tmp/screen-3.9.15/encoding.c"
void utf8_handle_comb(int c , struct mchar *mc ) 
{ 
  int root ;
  int i ;
  int c1 ;
  int isdouble ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int tmp ;
  void *__cil_tmp13 ;

  {
  {
#line 961
  c1 = (int )mc->image | ((int )mc->font << 8);
#line 962
  __cil_tmp7 = utf8_isdouble(c1);
#line 962
  isdouble = c1 >= 4352 && __cil_tmp7;
  }
#line 963
  if (! combchars) {
    {
#line 965
    __cil_tmp8 = malloc(sizeof(struct combchar *) * 2050UL);
#line 965
    combchars = (struct combchar **)__cil_tmp8;
    }
#line 966
    if (! combchars) {
#line 967
      return;
    }
    {
#line 968
    bzero((void *)((char *)combchars), sizeof(struct combchar *) * 2050UL);
#line 969
    __cil_tmp9 = malloc(sizeof(struct combchar ));
#line 969
    *(combchars + 2048) = (struct combchar *)__cil_tmp9;
#line 970
    __cil_tmp10 = malloc(sizeof(struct combchar ));
#line 970
    *(combchars + 2049) = (struct combchar *)__cil_tmp10;
    }
#line 971
    if (! *(combchars + 2048)) {
      _L: /* CIL Label */ 
#line 973
      if (*(combchars + 2048)) {
        {
#line 974
        free((void *)*(combchars + 2048));
        }
      }
#line 975
      if (*(combchars + 2049)) {
        {
#line 976
        free((void *)*(combchars + 2049));
        }
      }
      {
#line 977
      free((void *)combchars);
      }
#line 978
      return;
    } else
#line 971
    if (! *(combchars + 2049)) {
#line 971
      goto _L;
    }
#line 980
    (*(combchars + 2048))->c1 = (unsigned short )0;
#line 981
    (*(combchars + 2048))->c2 = (unsigned short )1792;
#line 982
    (*(combchars + 2048))->next = (unsigned short )2048;
#line 983
    (*(combchars + 2048))->prev = (unsigned short )2048;
#line 984
    (*(combchars + 2049))->c1 = (unsigned short )1792;
#line 985
    (*(combchars + 2049))->c2 = (unsigned short )2048;
#line 986
    (*(combchars + 2049))->next = (unsigned short )2049;
#line 987
    (*(combchars + 2049))->prev = (unsigned short )2049;
  }
#line 989
  if (isdouble) {
#line 989
    tmp = 2049;
  } else {
#line 989
    tmp = 2048;
  }
#line 989
  root = tmp;
#line 990
  i = (int )(*(combchars + root))->c1;
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (! (i < (int )(*(combchars + root))->c2)) {
#line 990
      goto while_break;
    }
#line 992
    if (! *(combchars + i)) {
#line 993
      goto while_break;
    }
#line 994
    if ((int )(*(combchars + i))->c1 == c1) {
#line 994
      if ((int )(*(combchars + i))->c2 == c) {
#line 995
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 990
  i ++;
#line 997
  if (i == (int )(*(combchars + root))->c2) {
#line 1000
    if (c1 >= 55296) {
#line 1000
      if (c1 < 57344) {
        {
#line 1001
        comb_tofront(root, c1);
        }
      }
    }
#line 1002
    i = (int )(*(combchars + root))->prev;
  } else
#line 1005
  if (! *(combchars + i)) {
    {
#line 1007
    __cil_tmp13 = malloc(sizeof(struct combchar ));
#line 1007
    *(combchars + i) = (struct combchar *)__cil_tmp13;
    }
#line 1008
    if (! *(combchars + i)) {
#line 1009
      return;
    }
#line 1010
    (*(combchars + i))->prev = (unsigned short )i;
#line 1011
    (*(combchars + i))->next = (unsigned short )i;
  }
#line 1013
  (*(combchars + i))->c1 = (unsigned short )c1;
#line 1014
  (*(combchars + i))->c2 = (unsigned short )c;
#line 1015
  mc->image = (unsigned char )(i & 255);
#line 1016
  mc->font = (unsigned char )((i >> 8) + 216);
  {
#line 1017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1017
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1018
  comb_tofront(root, i);
  }
}
}
#line 1035 "/tmp/screen-3.9.15/encoding.c"
static int encmatch(char *s1 , char *s2 ) 
{ 
  int c1 ;
  int c2 ;

  {
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1042
    c1 = (int )((unsigned char )*s1);
#line 1043
    if (c1 >= 65) {
#line 1043
      if (c1 <= 90) {
#line 1044
        c1 += 32;
      }
    }
#line 1045
    if (! (c1 >= 97 && c1 <= 122)) {
#line 1045
      if (! (c1 >= 48 && c1 <= 57)) {
#line 1047
        s1 ++;
#line 1048
        goto while_continue;
      }
    }
#line 1050
    c2 = (int )((unsigned char )*s2);
#line 1051
    if (c2 >= 65) {
#line 1051
      if (c2 <= 90) {
#line 1052
        c2 += 32;
      }
    }
#line 1053
    if (! (c2 >= 97 && c2 <= 122)) {
#line 1053
      if (! (c2 >= 48 && c2 <= 57)) {
#line 1055
        s2 ++;
#line 1056
        goto while_continue;
      }
    }
#line 1058
    if (c1 != c2) {
#line 1059
      return (0);
    }
#line 1060
    s1 ++;
#line 1061
    s2 ++;
#line 1040
    if (! c1) {
#line 1040
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  return (1);
}
}
#line 1068 "/tmp/screen-3.9.15/encoding.c"
int FindEncoding(char *name ) 
{ 
  int encoding ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1074
  if (name == (char *)0) {
#line 1075
    return (0);
  } else
#line 1074
  if ((int )*name == 0) {
#line 1075
    return (0);
  }
  {
#line 1076
  __cil_tmp3 = encmatch(name, (char *)"euc");
  }
#line 1076
  if (__cil_tmp3) {
#line 1077
    name = (char *)"eucJP";
  }
  {
#line 1078
  __cil_tmp5 = encmatch(name, (char *)"iso8859-1");
  }
  {
#line 1078
  __cil_tmp4 = encmatch(name, (char *)"off");
  }
#line 1078
  if (__cil_tmp4) {
#line 1079
    return (0);
  } else
#line 1078
  if (__cil_tmp5) {
#line 1079
    return (0);
  }
#line 1084
  encoding = 0;
  {
#line 1084
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1084
    if (! ((unsigned long )encoding < sizeof(encodings) / sizeof(*((struct encoding *)encodings)))) {
#line 1084
      goto while_break___0;
    }
    {
#line 1085
    __cil_tmp6 = encmatch(name, encodings[encoding].name);
    }
#line 1085
    if (__cil_tmp6) {
      {
#line 1088
      LoadFontTranslationsForEncoding(encoding);
      }
#line 1090
      return (encoding);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1084
  encoding ++;
#line 1092
  return (- 1);
}
}
#line 1096 "/tmp/screen-3.9.15/encoding.c"
char *EncodingName(int encoding ) 
{ 


  {
#line 1099
  if ((unsigned long )encoding >= sizeof(encodings) / sizeof(*((struct encoding *)encodings))) {
#line 1100
    return ((char *)0);
  }
#line 1101
  return (encodings[encoding].name);
}
}
#line 1105 "/tmp/screen-3.9.15/encoding.c"
int EncodingDefFont(int encoding ) 
{ 


  {
#line 1108
  return (encodings[encoding].deffont);
}
}
#line 1112 "/tmp/screen-3.9.15/encoding.c"
void ResetEncoding(struct win *p ) 
{ 
  char *c ;
  int encoding ;

  {
#line 1116
  encoding = p->w_layer.l_encoding;
#line 1118
  c = encodings[encoding].charsets;
#line 1119
  if (c) {
    {
#line 1120
    SetCharsets(p, c);
    }
  }
  {
#line 1122
  LoadFontTranslationsForEncoding(encoding);
  }
#line 1124
  if (encodings[encoding].usegr) {
#line 1126
    p->w_gr = 2;
#line 1127
    p->w_FontE = *(encodings[encoding].charsets + 1);
  } else {
#line 1130
    p->w_FontE = (char )0;
  }
#line 1131
  if (encodings[encoding].noc1) {
#line 1132
    p->w_c1 = 0;
  }
}
}
#line 1136 "/tmp/screen-3.9.15/encoding.c"
int DecodeChar(int c , int encoding , int *statep ) 
{ 
  int t ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int tmp ;

  {
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  if (encoding == 8) {
    {
#line 1146
    __cil_tmp5 = FromUtf8(c, statep);
    }
#line 1146
    return (__cil_tmp5);
  }
#line 1148
  if (encoding == 2) {
#line 1150
    if (! *statep) {
#line 1152
      if (129 <= c) {
#line 1152
        if (c <= 159) {
#line 1154
          *statep = c;
#line 1155
          return (- 1);
        } else {
#line 1152
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1152
      if (224 <= c) {
#line 1152
        if (c <= 239) {
#line 1154
          *statep = c;
#line 1155
          return (- 1);
        }
      }
#line 1157
      return (c | (73 << 16));
    }
#line 1159
    t = c;
#line 1160
    c = *statep;
#line 1161
    *statep = 0;
#line 1162
    if (64 <= t) {
#line 1162
      if (t <= 252) {
#line 1162
        if (t != 127) {
#line 1164
          if (c <= 159) {
#line 1164
            c = (c - 129) * 2 + 33;
          } else {
#line 1165
            c = (c - 193) * 2 + 33;
          }
#line 1166
          if (t <= 126) {
#line 1166
            t -= 31;
          } else
#line 1167
          if (t <= 158) {
#line 1167
            t -= 32;
          } else {
#line 1168
            __cil_tmp6 = c;
#line 1168
            c ++;
#line 1168
            t -= 126;
          }
#line 1169
          return (((c << 8) | t) | (2 << 16));
        }
      }
    }
#line 1171
    return (t);
  }
#line 1173
  if (encoding == 1) {
    _L___6: /* CIL Label */ 
#line 1175
    if (! *statep) {
#line 1177
      if (c & 128) {
#line 1179
        *statep = c;
#line 1180
        return (- 1);
      }
#line 1182
      return (c);
    }
#line 1184
    t = c;
#line 1185
    c = *statep;
#line 1186
    *statep = 0;
#line 1187
    if (encoding == 1) {
#line 1189
      if (c == 142) {
#line 1190
        return (t | (73 << 16));
      }
#line 1191
      if (c == 143) {
#line 1193
        *statep = t | (4 << 8);
#line 1194
        return (- 1);
      }
    }
#line 1197
    c &= 65407;
#line 1198
    t &= 127;
#line 1199
    c = (c << 8) | t;
#line 1200
    if (encoding == 3) {
#line 1201
      return (c | (3 << 16));
    }
#line 1202
    if (encoding == 4) {
#line 1203
      return (c | (1 << 16));
    }
#line 1204
    if (c & (4 << 16)) {
#line 1205
      return (c);
    } else {
#line 1207
      return (c | (2 << 16));
    }
  } else
#line 1173
  if (encoding == 3) {
#line 1173
    goto _L___6;
  } else
#line 1173
  if (encoding == 4) {
#line 1173
    goto _L___6;
  }
#line 1209
  if (encoding == 5) {
    _L___8: /* CIL Label */ 
#line 1211
    if (! *statep) {
#line 1213
      if (c & 128) {
#line 1215
        if (encoding == 20) {
#line 1215
          if (c == 128) {
#line 1216
            return (164 | (226 << 16));
          }
        }
#line 1217
        *statep = c;
#line 1218
        return (- 1);
      }
#line 1220
      return (c);
    }
#line 1222
    t = c;
#line 1223
    c = *statep;
#line 1224
    *statep = 0;
#line 1225
    c &= 127;
#line 1226
    if (encoding == 5) {
#line 1226
      tmp = 24 << 16;
    } else {
#line 1226
      tmp = 25 << 16;
    }
#line 1226
    return (((c << 8) | t) | tmp);
  } else
#line 1209
  if (encoding == 20) {
#line 1209
    goto _L___8;
  }
#line 1228
  return (c | (encodings[encoding].deffont << 16));
}
}
#line 1232 "/tmp/screen-3.9.15/encoding.c"
int EncodeChar(char *bp , int c , int encoding , int *fontp ) 
{ 
  int t ;
  int f ;
  int l ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int c2 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int c2___0 ;
  int tmp ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  int tmp___11 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp45 ;

  {
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1241
  if (c == -1) {
#line 1241
    if (fontp) {
#line 1243
      if (*fontp == 0) {
#line 1244
        return (0);
      }
#line 1245
      if (bp) {
#line 1247
        __cil_tmp8 = bp;
#line 1247
        bp ++;
#line 1247
        *__cil_tmp8 = (char )27;
#line 1248
        __cil_tmp9 = bp;
#line 1248
        bp ++;
#line 1248
        *__cil_tmp9 = (char )'(';
#line 1249
        __cil_tmp10 = bp;
#line 1249
        bp ++;
#line 1249
        *__cil_tmp10 = (char )'B';
      }
#line 1251
      return (3);
    }
  }
#line 1253
  f = c >> 16;
#line 1256
  if (encoding == 8) {
#line 1258
    if (f) {
#line 1261
      if (f) {
#line 1261
        if ((f & 96) == 0) {
          {
#line 1263
          c2 = (c >> 8) & 255;
#line 1264
          c = (c & 255) | (f << 8);
#line 1265
          c = recode_char_dw_to_encoding(c, & c2, encoding);
          }
        } else {
          {
#line 1270
          c = (c & 255) | (f << 8);
          {
#line 1271
          c = recode_char_to_encoding(c, encoding);
          }
          }
        }
      } else {
        {
#line 1270
        c = (c & 255) | (f << 8);
        {
#line 1271
        c = recode_char_to_encoding(c, encoding);
        }
        }
      }
    }
    {
#line 1274
    __cil_tmp14 = ToUtf8(bp, c);
    }
#line 1274
    return (__cil_tmp14);
  }
#line 1276
  if (c & 65280) {
#line 1276
    if (f == 0) {
      {
#line 1279
      __cil_tmp15 = utf8_isdouble(c);
      }
#line 1279
      if (__cil_tmp15) {
        {
#line 1281
        c2___0 = 65535;
#line 1282
        c = recode_char_dw_to_encoding(c, & c2___0, encoding);
#line 1283
        c = (c << 8) | (c2___0 & 255);
        }
      } else {
        {
#line 1288
        c = recode_char_to_encoding(c, encoding);
#line 1289
        c = ((c & 65280) << 8) | (c & 255);
        }
      }
      {
#line 1291
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1291
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1292
      f = c >> 16;
    }
  }
#line 1295
  if (f & 128) {
#line 1296
    f = 0;
  }
#line 1298
  if (encoding == 2) {
#line 1300
    if (f == 73) {
#line 1301
      c = (c & 255) | 128;
    } else
#line 1302
    if (f == 2) {
#line 1304
      if (! bp) {
#line 1305
        return (2);
      }
#line 1306
      t = c & 255;
#line 1307
      c = (c >> 8) & 255;
#line 1308
      if (c & 1) {
#line 1308
        if (t <= 95) {
#line 1308
          tmp = 31;
        } else {
#line 1308
          tmp = 32;
        }
#line 1308
        tmp___9 = tmp;
      } else {
#line 1308
        tmp___9 = 126;
      }
#line 1308
      t += tmp___9;
#line 1309
      if (c < 95) {
#line 1309
        tmp___10 = 129;
      } else {
#line 1309
        tmp___10 = 193;
      }
#line 1309
      c = (c - 33) / 2 + tmp___10;
#line 1310
      __cil_tmp22 = bp;
#line 1310
      bp ++;
#line 1310
      *__cil_tmp22 = (char )c;
#line 1311
      __cil_tmp23 = bp;
#line 1311
      bp ++;
#line 1311
      *__cil_tmp23 = (char )t;
#line 1312
      return (2);
    }
  }
#line 1315
  if (encoding == 1) {
#line 1317
    if (f == 73) {
#line 1319
      if (bp) {
#line 1321
        __cil_tmp24 = bp;
#line 1321
        bp ++;
#line 1321
        *__cil_tmp24 = (char )142;
#line 1322
        __cil_tmp25 = bp;
#line 1322
        bp ++;
#line 1322
        *__cil_tmp25 = (char )c;
      }
#line 1324
      return (2);
    }
#line 1326
    if (f == 2) {
#line 1328
      if (bp) {
#line 1330
        __cil_tmp26 = bp;
#line 1330
        bp ++;
#line 1330
        *__cil_tmp26 = (char )((c >> 8) | 128);
#line 1331
        __cil_tmp27 = bp;
#line 1331
        bp ++;
#line 1331
        *__cil_tmp27 = (char )(c | 128);
      }
#line 1333
      return (2);
    }
#line 1335
    if (f == 4) {
#line 1337
      if (bp) {
#line 1339
        __cil_tmp28 = bp;
#line 1339
        bp ++;
#line 1339
        *__cil_tmp28 = (char )143;
#line 1340
        __cil_tmp29 = bp;
#line 1340
        bp ++;
#line 1340
        *__cil_tmp29 = (char )(c >> 8);
#line 1341
        __cil_tmp30 = bp;
#line 1341
        bp ++;
#line 1341
        *__cil_tmp30 = (char )c;
      }
#line 1343
      return (3);
    }
  }
#line 1346
  if (encoding == 3) {
#line 1346
    if (f == 3) {
      _L: /* CIL Label */ 
#line 1348
      if (bp) {
#line 1350
        __cil_tmp31 = bp;
#line 1350
        bp ++;
#line 1350
        *__cil_tmp31 = (char )((c >> 8) | 128);
#line 1351
        __cil_tmp32 = bp;
#line 1351
        bp ++;
#line 1351
        *__cil_tmp32 = (char )(c | 128);
      }
#line 1353
      return (2);
    } else {
#line 1346
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 1346
  if (encoding == 4) {
#line 1346
    if (f == 1) {
#line 1346
      goto _L;
    }
  }
#line 1355
  if (encoding == 5) {
#line 1355
    if (f == 24) {
      _L___12: /* CIL Label */ 
#line 1357
      if (bp) {
#line 1359
        __cil_tmp33 = bp;
#line 1359
        bp ++;
#line 1359
        *__cil_tmp33 = (char )((c >> 8) | 128);
#line 1360
        __cil_tmp34 = bp;
#line 1360
        bp ++;
#line 1360
        *__cil_tmp34 = (char )c;
      }
#line 1362
      return (2);
    } else {
#line 1355
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 1355
  if (encoding == 20) {
#line 1355
    if (f == 25) {
#line 1355
      goto _L___12;
    }
  }
#line 1364
  if (encoding == 20) {
#line 1364
    if (f == 0) {
#line 1364
      if (c == 164) {
#line 1365
        c = 128;
      }
    }
  }
#line 1367
  l = 0;
#line 1368
  if (fontp) {
#line 1368
    if (f != *fontp) {
#line 1370
      *fontp = f;
#line 1371
      if (f) {
#line 1371
        if (f < 32) {
#line 1373
          if (bp) {
#line 1375
            __cil_tmp35 = bp;
#line 1375
            bp ++;
#line 1375
            *__cil_tmp35 = (char )27;
#line 1376
            __cil_tmp36 = bp;
#line 1376
            bp ++;
#line 1376
            *__cil_tmp36 = (char )'$';
#line 1377
            if (f > 2) {
#line 1378
              __cil_tmp37 = bp;
#line 1378
              bp ++;
#line 1378
              *__cil_tmp37 = (char )'(';
            }
#line 1379
            __cil_tmp38 = bp;
#line 1379
            bp ++;
#line 1379
            *__cil_tmp38 = (char )(64 + f);
          }
#line 1381
          if (f > 2) {
#line 1381
            tmp___11 = 4;
          } else {
#line 1381
            tmp___11 = 3;
          }
#line 1381
          l += tmp___11;
        } else {
#line 1371
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 1383
      if (f < 128) {
#line 1385
        if (f == 0) {
#line 1386
          f = 'B';
        }
#line 1387
        if (bp) {
#line 1389
          __cil_tmp40 = bp;
#line 1389
          bp ++;
#line 1389
          *__cil_tmp40 = (char )27;
#line 1390
          __cil_tmp41 = bp;
#line 1390
          bp ++;
#line 1390
          *__cil_tmp41 = (char )'(';
#line 1391
          __cil_tmp42 = bp;
#line 1391
          bp ++;
#line 1391
          *__cil_tmp42 = (char )f;
        }
#line 1393
        l += 3;
      }
    }
  }
#line 1396
  if (c & 65280) {
#line 1398
    if (bp) {
#line 1399
      __cil_tmp43 = bp;
#line 1399
      bp ++;
#line 1399
      *__cil_tmp43 = (char )(c >> 8);
    }
#line 1400
    l ++;
  }
#line 1402
  if (bp) {
#line 1403
    __cil_tmp45 = bp;
#line 1403
    bp ++;
#line 1403
    *__cil_tmp45 = (char )c;
  }
#line 1404
  return (l + 1);
}
}
#line 1408 "/tmp/screen-3.9.15/encoding.c"
int CanEncodeFont(int encoding , int f ) 
{ 


  {
  {
#line 1414
  if (encoding == 8) {
#line 1414
    goto case_8;
  }
#line 1417
  if (encoding == 2) {
#line 1417
    goto case_2;
  }
#line 1419
  if (encoding == 1) {
#line 1419
    goto case_1;
  }
#line 1421
  if (encoding == 3) {
#line 1421
    goto case_3;
  }
#line 1423
  if (encoding == 4) {
#line 1423
    goto case_4;
  }
#line 1425
  if (encoding == 5) {
#line 1425
    goto case_5;
  }
#line 1427
  if (encoding == 20) {
#line 1427
    goto case_20;
  }
#line 1429
  goto switch_default;
  case_8: /* CIL Label */ 
#line 1415
  return (1);
  case_2: /* CIL Label */ 
#line 1418
  return (f == 2 || f == 73);
  case_1: /* CIL Label */ 
#line 1420
  return ((f == 2 || f == 73) || f == 4);
  case_3: /* CIL Label */ 
#line 1422
  return (f == 3);
  case_4: /* CIL Label */ 
#line 1424
  return (f == 1);
  case_5: /* CIL Label */ 
#line 1426
  return (f == 24);
  case_20: /* CIL Label */ 
#line 1428
  return (f == 25);
  switch_default: /* CIL Label */ 
#line 1430
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1432
  return (0);
}
}
#line 1437 "/tmp/screen-3.9.15/encoding.c"
int PrepareEncodedChar(int c ) 
{ 
  int encoding ;
  int t ;
  int f ;
  int tmp ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1441
  t = 0;
#line 1444
  encoding = display->d_encoding;
#line 1445
  f = (int )display->d_rend.font;
#line 1446
  t = display->d_mbcs;
#line 1447
  if (encoding == 2) {
#line 1449
    if (f == 73) {
#line 1450
      return (c | 128);
    } else
#line 1451
    if (f == 2) {
#line 1453
      if (c & 1) {
#line 1453
        if (t <= 95) {
#line 1453
          tmp = 31;
        } else {
#line 1453
          tmp = 32;
        }
#line 1453
        tmp___15 = tmp;
      } else {
#line 1453
        tmp___15 = 126;
      }
#line 1453
      t += tmp___15;
#line 1454
      if (c < 95) {
#line 1454
        tmp___16 = 129;
      } else {
#line 1454
        tmp___16 = 193;
      }
#line 1454
      c = (c - 33) / 2 + tmp___16;
#line 1455
      display->d_mbcs = t;
    }
#line 1457
    return (c);
  }
#line 1459
  if (encoding == 1) {
#line 1461
    if (f == 73) {
      {
#line 1463
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1463
        (display->d_obuffree) --;
#line 1463
        if (display->d_obuffree <= 0) {
          {
#line 1463
          Resize_obuf();
          }
        }
#line 1463
        __cil_tmp8 = display->d_obufp;
#line 1463
        (display->d_obufp) ++;
#line 1463
        *__cil_tmp8 = (char )142;
#line 1463
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1464
      return (c | 128);
    }
#line 1466
    if (f == 2) {
#line 1468
      display->d_mbcs = t | 128;
#line 1469
      return (c | 128);
    }
#line 1471
    if (f == 4) {
      {
#line 1473
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1473
        (display->d_obuffree) --;
#line 1473
        if (display->d_obuffree <= 0) {
          {
#line 1473
          Resize_obuf();
          }
        }
#line 1473
        __cil_tmp9 = display->d_obufp;
#line 1473
        (display->d_obufp) ++;
#line 1473
        *__cil_tmp9 = (char )143;
#line 1473
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1474
      display->d_mbcs = t | 128;
#line 1475
      return (c | 128);
    }
  }
#line 1478
  if (encoding == 3) {
#line 1478
    if (f == 3) {
#line 1480
      display->d_mbcs = t | 128;
#line 1481
      return (c | 128);
    } else {
#line 1478
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1478
  if (encoding == 4) {
#line 1478
    if (f == 1) {
#line 1480
      display->d_mbcs = t | 128;
#line 1481
      return (c | 128);
    }
  }
#line 1483
  if (encoding == 5) {
#line 1483
    if (f == 24) {
#line 1484
      return (c | 128);
    } else {
#line 1483
      goto _L___17;
    }
  } else
  _L___17: /* CIL Label */ 
#line 1483
  if (encoding == 20) {
#line 1483
    if (f == 25) {
#line 1484
      return (c | 128);
    }
  }
#line 1485
  return (c);
}
}
#line 1490 "/tmp/screen-3.9.15/encoding.c"
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) 
{ 
  int c ;
  int i ;
  int j ;
  int decstate ;
  int font ;
  int __cil_tmp12 ;
  char *tmp ;
  int __cil_tmp14 ;
  char *tmp___0 ;
  int __cil_tmp17 ;

  {
#line 1497
  decstate = 0;
#line 1497
  font = 0;
#line 1499
  j = 0;
#line 1499
  i = j;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (i < flen)) {
#line 1499
      goto while_break;
    }
    {
#line 1501
    c = (int )*(fbuf + i);
#line 1502
    c = DecodeChar(c, fenc, & decstate);
    }
#line 1503
    if (c == -2) {
#line 1504
      __cil_tmp12 = i;
#line 1504
      i --;
    }
#line 1505
    if (c < 0) {
#line 1506
      goto while_continue;
    }
#line 1507
    if (tbuf) {
#line 1507
      tmp = (char *)tbuf + j;
    } else {
#line 1507
      tmp = (char *)0;
    }
    {
#line 1507
    __cil_tmp14 = EncodeChar(tmp, c, tenc, & font);
    }
#line 1507
    j += __cil_tmp14;
  }
  while_break: /* CIL Label */ ;
  }
#line 1499
  i ++;
#line 1509
  if (tbuf) {
#line 1509
    tmp___0 = (char *)tbuf + j;
  } else {
#line 1509
    tmp___0 = (char *)0;
  }
  {
#line 1509
  __cil_tmp17 = EncodeChar(tmp___0, - 1, tenc, & font);
  }
#line 1509
  j += __cil_tmp17;
#line 1510
  return (j);
}
}
#line 1515 "/tmp/screen-3.9.15/encoding.c"
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) 
{ 
  unsigned char *f ;
  unsigned char *i ;
  int c ;
  int x ;
  int dx ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;

  {
#line 1523
  if (encoding == 8) {
#line 1524
    return (0);
  } else
#line 1523
  if (encodings[encoding].deffont == 0) {
#line 1524
    return (0);
  }
#line 1525
  i = ml->image + xs;
#line 1526
  f = ml->font + xs;
#line 1527
  dx = (xe - xs) + 1;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! (__cil_tmp10 > 0)) {
#line 1528
      goto while_break;
    }
#line 1530
    __cil_tmp11 = f;
#line 1530
    f ++;
#line 1530
    if (*__cil_tmp11) {
#line 1531
      goto while_continue;
    }
    {
#line 1532
    __cil_tmp12 = i;
#line 1532
    i ++;
#line 1532
    c = (int )*__cil_tmp12;
#line 1533
    x = recode_char_to_encoding(c | (encodings[encoding].deffont << 8), 8);
    }
#line 1534
    if (c != x) {
      {
#line 1536
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1536
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1537
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1540
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1540
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1541
  return (0);
}
}
#line 1546 "/tmp/screen-3.9.15/encoding.c"
int LoadFontTranslation(int font , char *file ) 
{ 
  char buf[1024] ;
  char *myfile ;
  FILE *f ;
  int i ;
  int fo ;
  int x ;
  int u ;
  int c ;
  int ok ;
  unsigned short (*p)[2] ;
  unsigned short (*tab)[2] ;
  size_t __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  void *__cil_tmp23 ;
  int __cil_tmp25 ;
  int __cil_tmp29 ;
  int tmp ;

  {
#line 1557
  myfile = file;
#line 1558
  if (myfile == (char *)0) {
#line 1560
    if (font == 0) {
#line 1561
      return (- 1);
    } else
#line 1560
    if (screenencodings == (char *)0) {
#line 1561
      return (- 1);
    }
    {
#line 1562
    __cil_tmp14 = strlen((char const   *)screenencodings);
    }
#line 1562
    if (__cil_tmp14 > sizeof(buf) - 10UL) {
#line 1563
      return (- 1);
    }
    {
#line 1564
    sprintf((char *)buf, (char const   *)((char *)"%s/%02x"), screenencodings, font & 255);
#line 1565
    myfile = (char *)buf;
    }
  }
  {
#line 1567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1567
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1568
  f = secfopen(myfile, (char *)"r");
  }
#line 1568
  if (f == (FILE *)0) {
#line 1569
    return (- 1);
  }
#line 1570
  ok = 0;
#line 1570
  i = ok;
  {
#line 1571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1571
    if (! 1) {
#line 1571
      goto while_break___0;
    }
    {
#line 1573
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1573
      if (! (i < 12)) {
#line 1573
        goto while_break___1;
      }
      {
#line 1574
      __cil_tmp16 = _IO_getc(f);
      }
#line 1574
      if (__cil_tmp16 != (int )*((char *)"ScreenI2UTF8" + i)) {
#line 1575
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1573
    i ++;
#line 1576
    __cil_tmp18 = _IO_getc(f);
    }
#line 1576
    if (__cil_tmp18 != 0) {
#line 1577
      goto while_break___0;
    }
    {
#line 1578
    fo = _IO_getc(f);
    }
#line 1579
    if (fo == -1) {
#line 1580
      goto while_break___0;
    }
#line 1581
    if (font != -1) {
#line 1581
      if (font != fo) {
#line 1582
        goto while_break___0;
      }
    }
    {
#line 1583
    i = _IO_getc(f);
#line 1584
    x = _IO_getc(f);
    }
#line 1585
    if (x == -1) {
#line 1586
      goto while_break___0;
    }
    {
#line 1587
    i = (i << 8) | x;
#line 1588
    _IO_getc(f);
    }
    {
#line 1589
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1589
      if (! (x && x != -1)) {
#line 1589
        goto while_break___2;
      }
      {
#line 1590
      _IO_getc(f);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1591
    __cil_tmp23 = malloc(sizeof(*p) * (unsigned long )(i + 1));
#line 1591
    p = (unsigned short (*)[2])__cil_tmp23;
    }
#line 1591
    if (p == (unsigned short (*)[2])0) {
#line 1592
      goto while_break___0;
    }
#line 1593
    tab = p;
    {
#line 1594
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1594
      if (! (i > 0)) {
#line 1594
        goto while_break___3;
      }
      {
#line 1596
      x = _IO_getc(f);
#line 1597
      __cil_tmp25 = _IO_getc(f);
#line 1597
      x = (x << 8) | __cil_tmp25;
#line 1598
      u = _IO_getc(f);
#line 1599
      c = _IO_getc(f);
#line 1600
      u = (u << 8) | c;
      }
#line 1601
      if (c == -1) {
#line 1602
        goto while_break___3;
      }
#line 1603
      (*p)[0] = (unsigned short )x;
#line 1604
      (*p)[1] = (unsigned short )u;
#line 1605
      p ++;
#line 1606
      __cil_tmp29 = i;
#line 1606
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1608
    (*p)[0] = (unsigned short )0;
#line 1609
    (*p)[1] = (unsigned short )0;
#line 1610
    if (i) {
      {
      {
#line 1612
      free((void *)tab);
      }
      }
#line 1613
      goto while_break___0;
    } else
#line 1610
    if ((int )(*(tab + 0))[0] & 32768) {
      {
      {
#line 1612
      free((void *)tab);
      }
      }
#line 1613
      goto while_break___0;
    }
#line 1615
    if (recodetabs[fo].tab) {
#line 1615
      if ((recodetabs[fo].flags & 1) != 0) {
        {
#line 1616
        free((void *)recodetabs[fo].tab);
        }
      }
    }
#line 1617
    recodetabs[fo].tab = tab;
#line 1618
    recodetabs[fo].flags = 1;
    {
#line 1619
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1619
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1620
    c = _IO_getc(f);
    }
#line 1621
    if (c == -1) {
#line 1623
      ok = 1;
#line 1624
      goto while_break___0;
    }
#line 1626
    if (c != 83) {
#line 1627
      goto while_break___0;
    }
#line 1628
    i = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1630
  fclose(f);
  }
#line 1631
  if (font != -1) {
#line 1631
    if (file == (char *)0) {
#line 1631
      if (recodetabs[font].flags == 0) {
#line 1632
        recodetabs[font].flags = 4;
      }
    }
  }
#line 1633
  if (ok) {
#line 1633
    tmp = 0;
  } else {
#line 1633
    tmp = - 1;
  }
#line 1633
  return (tmp);
}
}
#line 1637 "/tmp/screen-3.9.15/encoding.c"
void LoadFontTranslationsForEncoding(int encoding ) 
{ 
  char *c ;
  int f ;

  {
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1644
  c = encodings[encoding].fontlist;
#line 1644
  if (c != (char *)0) {
    {
#line 1645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1645
      if (! (f != 0)) {
#line 1645
        goto while_break___0;
      }
#line 1646
      if (recodetabs[f].flags == 0) {
        {
#line 1647
        LoadFontTranslation(f, (char *)0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1648
  f = encodings[encoding].deffont;
#line 1649
  if (f > 0) {
#line 1649
    if (recodetabs[f].flags == 0) {
      {
#line 1650
      LoadFontTranslation(f, (char *)0);
      }
    }
  }
}
}
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 31 "/tmp/screen-3.9.15/nethack.c"
int nethackflag ;
#line 40 "/tmp/screen-3.9.15/nethack.c"
static struct nlstrans nethacktrans[]  = 
#line 40
  {      {(char *)"Cannot lock terminal - fork failed", (char *)"Cannot fork terminal - lock failed"}, 
        {(char *)"Got only %d bytes from %s",
      (char *)"You choke on your food: %d bytes from %s"}, 
        {(char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)", (char *)"Welcome to hacker\'s treasure zoo - Column %d Line %d(+%d) (%d,%d)"}, 
        {(char *)"First mark set - Column %d Line %d",
      (char *)"You drop a magic marker - Column %d Line %d"}, 
        {(char *)"Copy mode aborted", (char *)"You escaped the dungeon."}, 
        {(char *)"Filter removed.", (char *)"You have a sad feeling for a moment..."}, 
        {(char *)"Window %d (%s) killed.",
      (char *)"You destroy poor window %d (%s)."}, 
        {(char *)"Window %d (%s) is now being monitored for all activity.", (char *)"You feel like someone is watching you..."}, 
        {(char *)"Window %d (%s) is no longer being monitored for activity.",
      (char *)"You no longer sense the watcher\'s presence."}, 
        {(char *)"empty buffer", (char *)"Nothing happens."}, 
        {(char *)"switched to audible bell.", (char *)"Suddenly you can\'t see your bell!"}, 
        {(char *)"switched to visual bell.",
      (char *)"Your bell is no longer invisible."}, 
        {(char *)"The window is now being monitored for %d sec. silence.", (char *)"You feel like someone is waiting for %d sec. silence..."}, 
        {(char *)"The window is no longer being monitored for silence.",
      (char *)"You no longer sense the watcher\'s silence."}, 
        {(char *)"No other window.", (char *)"You cannot escape from window %d!"}, 
        {(char *)"Logfile \"%s\" closed.", (char *)"You put away your scroll of logging named \"%s\"."}, 
        {(char *)"Error opening logfile \"%s\"",
      (char *)"You don\'t seem to have a scroll of logging named \"%s\"."}, 
        {(char *)"Creating logfile \"%s\".", (char *)"You start writing on your scroll of logging named \"%s\"."}, 
        {(char *)"Appending to logfile \"%s\".",
      (char *)"You add to your scroll of logging named \"%s\"."}, 
        {(char *)"Detach aborted.", (char *)"The blast of disintegration whizzes by you!"}, 
        {(char *)"Empty register.",
      (char *)"Nothing happens."}, 
        {(char *)"[ Passwords don\'t match - checking turned off ]", (char *)"[ Passwords don\'t match - your armor crumbles away ]"}, 
        {(char *)"Aborted because of window size change.",
      (char *)"KAABLAMM!!!  You triggered a land mine!"}, 
        {(char *)"Out of memory.", (char *)"Who was that Maude person anyway?"}, 
        {(char *)"getpwuid() can\'t identify your account!", (char *)"An alarm sounds through the dungeon...\nThe Keystone Kops are after you!"}, 
        {(char *)"Must be connected to a terminal.",
      (char *)"You must play from a terminal."}, 
        {(char *)"No Sockets found in %s.\n", (char *)"This room is empty (%s).\n"}, 
        {(char *)"New screen...", (char *)"Be careful!  New screen tonight."}, 
        {(char *)"Child has been stopped, restarting.", (char *)"You regain consciousness."}, 
        {(char *)"There are screens on:",
      (char *)"Your inventory:"}, 
        {(char *)"There is a screen on:", (char *)"Your inventory:"}, 
        {(char *)"There are several screens on:", (char *)"Prove thyself worthy or perish:"}, 
        {(char *)"There is a suitable screen on:",
      (char *)"You see here a good looking screen:"}, 
        {(char *)"There are several suitable screens on:", (char *)"You may wish for a screen, what do you want?"}, 
        {(char *)"%d socket%s wiped out.",
      (char *)"You hear %d distant explosion%s."}, 
        {(char *)"Remove dead screens with \'screen -wipe\'.", (char *)"The dead screen%s touch%s you. Try \'screen -wipe\'."}, 
        {(char *)"Illegal reattach attempt from terminal %s.",
      (char *)"\'%s\' tries to touch your session, but fails."}, 
        {(char *)"Could not write %s", (char *)"%s is too hard to dig in"}, 
        {(char *)0, (char *)0}};
#line 122 "/tmp/screen-3.9.15/nethack.c"
char *DoNLS(char *from ) 
{ 
  struct nlstrans *t ;
  int __cil_tmp3 ;

  {
#line 128
  if (nethackflag) {
#line 130
    t = (struct nlstrans *)nethacktrans;
    {
#line 130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 130
      if (! t->from) {
#line 130
        goto while_break;
      }
      {
#line 131
      __cil_tmp3 = strcmp((char const   *)from, (char const   *)t->from);
      }
#line 131
      if (__cil_tmp3 == 0) {
#line 132
        return (t->to);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 130
    t ++;
  }
#line 135
  return (from);
}
}
#line 302 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__)) ;
#line 309
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__)) ;
#line 309 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 311
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 313
    return ((struct cmsghdr *)0);
  }
#line 315
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 317
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 322
    return ((struct cmsghdr *)0);
  } else
#line 317
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 322
    return ((struct cmsghdr *)0);
  }
#line 323
  return (__cmsg);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , __timezone_ptr_t __tz ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 39 "./extern.h"
void Panic(int err , char *fmt  , ...) ;
#line 313
void evenq(struct event *ev ) ;
#line 314
void evdeq(struct event *ev ) ;
#line 315
void SetTimeout(struct event *ev , int timo ) ;
#line 316
void sched(void) ;
#line 38 "/tmp/screen-3.9.15/sched.c"
static struct event *evs ;
#line 39
static struct event *tevs ;
#line 40
static struct event *nextev ;
#line 41
static int calctimeout ;
#line 43
static struct event *calctimo(void) ;
#line 49 "/tmp/screen-3.9.15/sched.c"
void evenq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (ev->queued) {
#line 55
    return;
  }
#line 56
  evpp = & evs;
#line 57
  if (ev->type == 0) {
#line 59
    calctimeout = 1;
#line 60
    evpp = & tevs;
  }
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! evp) {
#line 62
      goto while_break___0;
    }
#line 63
    if (ev->pri > evp->pri) {
#line 64
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  evpp = & evp->next;
#line 65
  ev->next = evp;
#line 66
  *evpp = ev;
#line 67
  ev->queued = 1;
}
}
#line 71 "/tmp/screen-3.9.15/sched.c"
void evdeq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if (! ev->queued) {
#line 77
    return;
  }
#line 78
  evpp = & evs;
#line 79
  if (ev->type == 0) {
#line 81
    calctimeout = 1;
#line 82
    evpp = & tevs;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! evp) {
#line 84
      goto while_break___0;
    }
#line 85
    if (evp == ev) {
#line 86
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  evpp = & evp->next;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 87
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 88
  *evpp = ev->next;
#line 89
  ev->queued = 0;
#line 90
  if (ev == nextev) {
#line 91
    nextev = nextev->next;
  }
}
}
#line 95 "/tmp/screen-3.9.15/sched.c"
static struct event *calctimo(void) 
{ 
  struct event *ev ;
  struct event *min ;
  long mins ;

  {
#line 100
  min = tevs;
#line 100
  if (min == (struct event *)0) {
#line 101
    return ((struct event *)0);
  }
#line 102
  mins = min->timeout.tv_sec;
#line 103
  ev = tevs->next;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ev) {
#line 103
      goto while_break;
    }
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    if (mins < ev->timeout.tv_sec) {
#line 107
      goto while_continue;
    }
#line 108
    if (mins > ev->timeout.tv_sec) {
#line 110
      min = ev;
#line 111
      mins = ev->timeout.tv_sec;
    } else
#line 108
    if (min->timeout.tv_usec > ev->timeout.tv_usec) {
#line 110
      min = ev;
#line 111
      mins = ev->timeout.tv_sec;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  ev = ev->next;
#line 114
  return (min);
}
}
#line 118 "/tmp/screen-3.9.15/sched.c"
void sched(void) 
{ 
  struct event *ev ;
  fd_set r ;
  fd_set w ;
  fd_set *set ;
  struct event *timeoutev ;
  struct timeval timeout ;
  int nsel ;
  __time_t __cil_tmp9 ;
  int tmp ;
  struct timeval *tmp___0 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  int *__cil_tmp18 ;
  fd_set *tmp___18 ;
  int __cil_tmp20 ;
  int tmp___19 ;

  {
#line 122
  timeoutev = (struct event *)0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! 1) {
#line 126
      goto while_break;
    }
#line 128
    if (calctimeout) {
      {
#line 129
      timeoutev = calctimo();
      }
    }
#line 130
    if (timeoutev) {
      {
#line 132
      gettimeofday(& timeout, (struct timezone *)((void *)0));
#line 134
      timeout.tv_sec = timeoutev->timeout.tv_sec - timeout.tv_sec;
#line 135
      timeout.tv_usec = timeoutev->timeout.tv_usec - timeout.tv_usec;
      }
#line 136
      if (timeout.tv_usec < 0L) {
#line 138
        timeout.tv_usec += (long )1000000;
#line 139
        __cil_tmp9 = timeout.tv_sec;
#line 139
        (timeout.tv_sec) --;
      }
#line 141
      if (timeout.tv_sec < 0L) {
#line 143
        timeout.tv_usec = (__suseconds_t )0;
#line 144
        timeout.tv_sec = (__time_t )0;
      }
    }
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
      __asm__  ("cld; rep; stosq":);
#line 160
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
      __asm__  ("cld; rep; stosq":);
#line 161
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 162
    ev = evs;
    {
#line 162
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 162
      if (! ev) {
#line 162
        goto while_break___2;
      }
#line 164
      if (ev->condneg) {
#line 164
        tmp = *(ev->condneg);
      } else {
#line 164
        tmp = 0;
      }
#line 164
      if (ev->condpos) {
#line 164
        if (*(ev->condpos) <= tmp) {
          {
#line 166
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 166
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 167
          goto while_continue___2;
        }
      }
#line 169
      if (ev->type == 1) {
#line 170
        r.__fds_bits[ev->fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )));
      } else
#line 171
      if (ev->type == 2) {
#line 172
        w.__fds_bits[ev->fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 162
    ev = ev->next;
#line 188
    if (timeoutev) {
#line 188
      tmp___0 = & timeout;
    } else {
#line 188
      tmp___0 = (struct timeval *)0;
    }
    {
#line 188
    __cil_tmp16 = select(1024, & r, & w, (fd_set *)0, tmp___0);
#line 188
    nsel = __cil_tmp16;
    }
#line 189
    if (nsel < 0) {
      {
#line 191
      __cil_tmp17 = __errno_location();
      }
#line 191
      if (*__cil_tmp17 != 4) {
        {
#line 203
        __cil_tmp18 = __errno_location();
#line 203
        Panic(*__cil_tmp18, (char *)"select");
        }
      }
#line 205
      nsel = 0;
    } else
#line 207
    if (nsel == 0) {
      {
#line 209
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 209
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 210
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 210
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 211
      evdeq(timeoutev);
#line 212
      ((void (*)(struct event * , char * ))timeoutev->handler)(timeoutev, timeoutev->data);
      }
    }
#line 223
    ev = evs;
    {
#line 223
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 223
      if (! ev) {
#line 223
        goto while_break___6;
      }
#line 225
      nextev = ev->next;
#line 226
      if (ev->type != 3) {
#line 228
        if (ev->type == 1) {
#line 228
          tmp___18 = & r;
        } else {
#line 228
          tmp___18 = & w;
        }
#line 228
        set = tmp___18;
#line 229
        if (nsel == 0) {
#line 230
          goto while_continue___6;
        } else
#line 229
        if (! ((set->__fds_bits[ev->fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 230
          goto while_continue___6;
        }
#line 231
        __cil_tmp20 = nsel;
#line 231
        nsel --;
      }
#line 233
      if (ev->condneg) {
#line 233
        tmp___19 = *(ev->condneg);
      } else {
#line 233
        tmp___19 = 0;
      }
#line 233
      if (ev->condpos) {
#line 233
        if (*(ev->condpos) <= tmp___19) {
#line 234
          goto while_continue___6;
        }
      }
      {
#line 235
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 235
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 236
      ((void (*)(struct event * , char * ))ev->handler)(ev, ev->data);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 223
    ev = nextev;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 242 "/tmp/screen-3.9.15/sched.c"
void SetTimeout(struct event *ev , int timo ) 
{ 


  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 247
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 248
  gettimeofday(& ev->timeout, (struct timezone *)((void *)0));
#line 249
  ev->timeout.tv_sec += (long )(timo / 1000);
#line 250
  ev->timeout.tv_usec += (long )((timo % 1000) * 1000);
  }
#line 251
  if (ev->timeout.tv_usec > 1000000L) {
#line 253
    ev->timeout.tv_usec -= (long )1000000;
#line 254
    (ev->timeout.tv_sec) ++;
  }
#line 256
  if (ev->queued) {
#line 257
    calctimeout = 1;
  }
}
}
#line 344 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 396
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "./extern.h"
void Msg(int err , char *fmt  , ...) ;
#line 49
int PutWinMsg(char *s , int start , int max ) ;
#line 87
void SetFlow(int on ) ;
#line 240
void PUTCHARLP(int c ) ;
#line 242
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) ;
#line 243
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) ;
#line 245
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) ;
#line 251
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) ;
#line 252
void GotoPos(int x2 , int y2 ) ;
#line 254
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) ;
#line 255
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) ;
#line 256
void PutChar(struct mchar *c , int x , int y ) ;
#line 257
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) ;
#line 258
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) ;
#line 261
void KeypadMode(int on ) ;
#line 262
void CursorkeysMode(int on ) ;
#line 264
void CursorVisibility(int v ) ;
#line 265
void MouseMode(int mode ) ;
#line 269
void SetRendition(struct mchar *mc ) ;
#line 271
void MakeStatus(char *msg ) ;
#line 272
void RemoveStatus(void) ;
#line 407
void LGotoPos(struct layer *l , int x , int y ) ;
#line 408
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) ;
#line 409
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) ;
#line 410
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 411
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 412
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 413
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) ;
#line 414
void LClearAll(struct layer *l , int uself ) ;
#line 415
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) ;
#line 416
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 417
void LRefreshAll(struct layer *l , int isblank ) ;
#line 418
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) ;
#line 419
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) ;
#line 420
void LSetRendition(struct layer *l , struct mchar *r ) ;
#line 421
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) ;
#line 422
void LCursorVisibility(struct layer *l , int vis ) ;
#line 423
void LSetFlow(struct layer *l , int flow ) ;
#line 424
void LKeypadMode(struct layer *l , int on ) ;
#line 425
void LCursorkeysMode(struct layer *l , int on ) ;
#line 426
void LMouseMode(struct layer *l , int on ) ;
#line 428
void LMsg(int err , char *fmt  , ...) ;
#line 432
void KillLayerChain(struct layer *lay ) ;
#line 433
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) ;
#line 37 "/tmp/screen-3.9.15/layer.c"
extern struct mline mline_blank ;
#line 37
extern struct mline mline_null ;
#line 38
struct mchar mchar_blank ;
#line 41
struct LayFuncs WinLf ;
#line 42
struct LayFuncs BlankLf ;
#line 45
static struct mline *mloff(struct mline *ml , int off ) ;
#line 57 "/tmp/screen-3.9.15/layer.c"
static struct mline *mloff(struct mline *ml , int off ) 
{ 
  static struct mline mml ;

  {
#line 63
  if (ml == (struct mline *)0) {
#line 64
    return ((struct mline *)0);
  }
#line 65
  mml.image = ml->image + off;
#line 66
  mml.attr = ml->attr + off;
#line 68
  mml.font = ml->font + off;
#line 71
  mml.color = ml->color + off;
#line 76
  return (& mml);
}
}
#line 89 "/tmp/screen-3.9.15/layer.c"
void LGotoPos(struct layer *l , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;

  {
#line 101
  cv = l->l_cvlist;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! cv) {
#line 101
      goto while_break;
    }
#line 103
    display = cv->c_display;
#line 104
    if (cv != display->d_forecv) {
#line 105
      goto while_continue;
    }
#line 106
    x2 = x + cv->c_xoff;
#line 107
    y2 = y + cv->c_yoff;
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 108
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    if (x2 < cv->c_xs) {
#line 110
      x2 = cv->c_xs;
    }
#line 111
    if (y2 < cv->c_ys) {
#line 112
      y2 = cv->c_ys;
    }
#line 113
    if (x2 > cv->c_xe) {
#line 114
      x2 = cv->c_xe;
    }
#line 115
    if (y2 > cv->c_ye) {
#line 116
      y2 = cv->c_ye;
    }
#line 117
    vp = cv->c_vplist;
    {
#line 117
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 117
      if (! vp) {
#line 117
        goto while_break___1;
      }
#line 119
      if (x2 < vp->v_xs) {
#line 120
        goto while_continue___1;
      } else
#line 119
      if (x2 > vp->v_xe) {
#line 120
        goto while_continue___1;
      }
#line 121
      if (y2 < vp->v_ys) {
#line 122
        goto while_continue___1;
      } else
#line 121
      if (y2 > vp->v_ye) {
#line 122
        goto while_continue___1;
      }
      {
#line 123
      GotoPos(x2, y2);
      }
#line 124
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 117
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  cv = cv->c_lnext;
}
}
#line 130 "/tmp/screen-3.9.15/layer.c"
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *__cil_tmp13 ;
  struct mline *tmp ;

  {
#line 140
  if (n == 0) {
#line 141
    return;
  }
#line 142
  cv = l->l_cvlist;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! cv) {
#line 142
      goto while_break;
    }
#line 143
    vp = cv->c_vplist;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! vp) {
#line 143
        goto while_break___0;
      }
#line 145
      y2 = y + vp->v_yoff;
#line 146
      if (y2 < vp->v_ys) {
#line 147
        goto while_continue___0;
      } else
#line 146
      if (y2 > vp->v_ye) {
#line 147
        goto while_continue___0;
      }
#line 148
      xs2 = xs + vp->v_xoff;
#line 149
      xe2 = xe + vp->v_xoff;
#line 150
      if (xs2 < vp->v_xs) {
#line 151
        xs2 = vp->v_xs;
      }
#line 152
      if (xe2 > vp->v_xe) {
#line 153
        xe2 = vp->v_xe;
      }
#line 154
      if (xs2 > xe2) {
#line 155
        goto while_continue___0;
      }
#line 156
      display = cv->c_display;
#line 157
      if (ol) {
        {
#line 157
        __cil_tmp13 = mloff(ol, - vp->v_xoff);
#line 157
        tmp = __cil_tmp13;
        }
      } else {
#line 157
        tmp = (struct mline *)0;
      }
      {
#line 157
      ScrollH(y2, xs2, xe2, n, bce, tmp);
      }
#line 158
      if (xe2 - xs2 == xe - xs) {
#line 159
        goto while_continue___0;
      }
#line 160
      if (n > 0) {
#line 162
        xs2 = (xe2 + 1) - n;
#line 163
        xe2 = (xe + vp->v_xoff) - n;
      } else {
#line 167
        xe2 = (xs2 - 1) - n;
#line 168
        xs2 = (xs + vp->v_xoff) - n;
      }
#line 170
      if (xs2 < vp->v_xs) {
#line 171
        xs2 = vp->v_xs;
      }
#line 172
      if (xe2 > vp->v_xe) {
#line 173
        xe2 = vp->v_xe;
      }
#line 174
      if (xs2 <= xe2) {
        {
#line 175
        RefreshArea(xs2, y2, xe2, y2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  cv = cv->c_lnext;
}
}
#line 180 "/tmp/screen-3.9.15/layer.c"
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int ys2 ;
  int ye2 ;
  int xs2 ;
  int xe2 ;

  {
#line 189
  if (n == 0) {
#line 190
    return;
  }
#line 191
  cv = l->l_cvlist;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! cv) {
#line 191
      goto while_break;
    }
#line 192
    vp = cv->c_vplist;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! vp) {
#line 192
        goto while_break___0;
      }
#line 194
      xs2 = vp->v_xoff;
#line 195
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 196
      ys2 = ys + vp->v_yoff;
#line 197
      ye2 = ye + vp->v_yoff;
#line 198
      if (xs2 < vp->v_xs) {
#line 199
        xs2 = vp->v_xs;
      }
#line 200
      if (xe2 > vp->v_xe) {
#line 201
        xe2 = vp->v_xe;
      }
#line 202
      if (ys2 < vp->v_ys) {
#line 203
        ys2 = vp->v_ys;
      }
#line 204
      if (ye2 > vp->v_ye) {
#line 205
        ye2 = vp->v_ye;
      }
#line 206
      if (ys2 > ye2) {
#line 207
        goto while_continue___0;
      } else
#line 206
      if (xs2 > xe2) {
#line 207
        goto while_continue___0;
      }
      {
#line 208
      display = cv->c_display;
#line 212
      ScrollV(vp->v_xs, ys2, vp->v_xe, ye2, n, bce);
      }
      {
#line 214
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 214
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 215
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 215
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      if (ye2 - ys2 == ye - ys) {
#line 217
        goto while_continue___0;
      }
#line 218
      if (n > 0) {
#line 220
        ys2 = (ye2 + 1) - n;
#line 221
        ye2 = (ye + vp->v_yoff) - n;
      } else {
#line 225
        ye2 = (ys2 - 1) - n;
#line 226
        ys2 = (ys + vp->v_yoff) - n;
      }
      {
#line 228
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 228
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 229
      if (ys2 < vp->v_ys) {
#line 230
        ys2 = vp->v_ys;
      }
#line 231
      if (ye2 > vp->v_ye) {
#line 232
        ye2 = vp->v_ye;
      }
      {
#line 233
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 233
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 234
      if (ys2 <= ye2) {
        {
#line 235
        RefreshArea(xs2, ys2, xe2, ye2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  cv = cv->c_lnext;
}
}
#line 240 "/tmp/screen-3.9.15/layer.c"
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int f ;
  struct mchar *c2 ;
  struct mchar cc ;
  struct mline *rol ;
  int i ;
  struct mline *__cil_tmp16 ;
  struct mline *tmp ;
  struct mchar *__cil_tmp18 ;
  struct mchar *tmp___20 ;
  struct mline *__cil_tmp20 ;

  {
#line 252
  cv = l->l_cvlist;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! cv) {
#line 252
      goto while_break;
    }
#line 253
    vp = cv->c_vplist;
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! vp) {
#line 253
        goto while_break___0;
      }
#line 255
      y2 = y + vp->v_yoff;
#line 256
      if (y2 < vp->v_ys) {
#line 257
        goto while_continue___0;
      } else
#line 256
      if (y2 > vp->v_ye) {
#line 257
        goto while_continue___0;
      }
#line 258
      xs2 = x + vp->v_xoff;
#line 259
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 260
      c2 = c;
#line 261
      f = 0;
#line 262
      if (xs2 < vp->v_xs) {
#line 264
        xs2 = vp->v_xs;
#line 265
        c2 = & mchar_blank;
#line 266
        if (ol) {
#line 269
          i = (xs2 - vp->v_xoff) - 1;
#line 270
          if (i >= 0) {
#line 270
            if (i < l->l_width) {
              {
#line 272
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 272
                cc.image = *(ol->image + i);
#line 272
                cc.attr = *(ol->attr + i);
#line 272
                cc.font = *(ol->font + i);
#line 272
                cc.color = *(ol->color + i);
#line 272
                cc.mbcs = (unsigned char )0;
#line 272
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 273
              c2 = & cc;
            }
          }
        } else {
#line 277
          f = 1;
        }
      }
#line 279
      if (xe2 > vp->v_xe) {
#line 280
        xe2 = vp->v_xe;
      }
#line 281
      if (xs2 > xe2) {
#line 282
        goto while_continue___0;
      }
#line 283
      display = cv->c_display;
#line 284
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 284
        __cil_tmp16 = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 284
        tmp = __cil_tmp16;
        }
      } else {
#line 284
        tmp = ol;
      }
#line 284
      rol = tmp;
#line 285
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 285
        __cil_tmp18 = recode_mchar(c2, l->l_encoding, display->d_encoding);
#line 285
        tmp___20 = __cil_tmp18;
        }
      } else {
#line 285
        tmp___20 = c2;
      }
      {
#line 285
      __cil_tmp20 = mloff(rol, - vp->v_xoff);
#line 285
      InsChar(tmp___20, xs2, xe2, y2, __cil_tmp20);
      }
#line 286
      if (f) {
        {
#line 287
        RefreshArea(xs2, y2, xs2, y2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 253
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  cv = cv->c_lnext;
}
}
#line 292 "/tmp/screen-3.9.15/layer.c"
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;
  struct mchar *__cil_tmp9 ;
  struct mchar *tmp ;

  {
#line 307
  cv = l->l_cvlist;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! cv) {
#line 307
      goto while_break;
    }
#line 309
    display = cv->c_display;
#line 310
    vp = cv->c_vplist;
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 310
      if (! vp) {
#line 310
        goto while_break___0;
      }
#line 312
      y2 = y + vp->v_yoff;
#line 313
      if (y2 < vp->v_ys) {
#line 314
        goto while_continue___0;
      } else
#line 313
      if (y2 > vp->v_ye) {
#line 314
        goto while_continue___0;
      }
#line 315
      x2 = x + vp->v_xoff;
#line 316
      if (x2 < vp->v_xs) {
#line 317
        goto while_continue___0;
      } else
#line 316
      if (x2 > vp->v_xe) {
#line 317
        goto while_continue___0;
      }
#line 318
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 318
        __cil_tmp9 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 318
        tmp = __cil_tmp9;
        }
      } else {
#line 318
        tmp = c;
      }
      {
#line 318
      PutChar(tmp, x2, y2);
      }
#line 319
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  cv = cv->c_lnext;
}
}
#line 325 "/tmp/screen-3.9.15/layer.c"
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  char *s2 ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mchar mc ;
  char *__cil_tmp14 ;
  struct mchar *__cil_tmp15 ;
  struct mchar *tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 337
  if (x + n > l->l_width) {
#line 338
    n = l->l_width - x;
  }
#line 346
  cv = l->l_cvlist;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! cv) {
#line 346
      goto while_break;
    }
#line 347
    vp = cv->c_vplist;
    {
#line 347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 347
      if (! vp) {
#line 347
        goto while_break___0;
      }
#line 349
      y2 = y + vp->v_yoff;
#line 350
      if (y2 < vp->v_ys) {
#line 351
        goto while_continue___0;
      } else
#line 350
      if (y2 > vp->v_ye) {
#line 351
        goto while_continue___0;
      }
#line 352
      xs2 = x + vp->v_xoff;
#line 353
      xe2 = (xs2 + n) - 1;
#line 354
      if (xs2 < vp->v_xs) {
#line 355
        xs2 = vp->v_xs;
      }
#line 356
      if (xe2 > vp->v_xe) {
#line 357
        xe2 = vp->v_xe;
      }
#line 358
      if (xs2 > xe2) {
#line 359
        goto while_continue___0;
      }
      {
#line 360
      display = cv->c_display;
#line 361
      GotoPos(xs2, y2);
#line 362
      SetRendition(r);
#line 363
      s2 = ((s + xs2) - x) - vp->v_xoff;
      }
#line 365
      if (display->d_encoding == 8) {
#line 365
        if (l->l_encoding != 8) {
#line 365
          if ((int )r->font) {
            _L: /* CIL Label */ 
#line 368
            mc = *r;
            {
#line 369
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 369
              if (! (xs2 <= xe2)) {
#line 369
                goto while_break___1;
              }
#line 371
              __cil_tmp14 = s2;
#line 371
              s2 ++;
#line 371
              mc.image = (unsigned char )*__cil_tmp14;
#line 372
              if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
                {
#line 372
                __cil_tmp15 = recode_mchar(& mc, l->l_encoding, display->d_encoding);
#line 372
                tmp = __cil_tmp15;
                }
              } else {
#line 372
                tmp = & mc;
              }
              {
#line 372
              __cil_tmp17 = xs2;
#line 372
              xs2 ++;
#line 372
              PutChar(tmp, __cil_tmp17, y2);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 374
            goto while_continue___0;
          } else
#line 365
          if (l->l_encoding) {
#line 365
            goto _L;
          }
        }
      }
      {
#line 377
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 377
        if (! (__cil_tmp18 <= xe2)) {
#line 377
          goto while_break___2;
        }
        {
#line 378
        __cil_tmp19 = s2;
#line 378
        s2 ++;
#line 378
        PUTCHARLP((int )*__cil_tmp19);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 347
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  cv = cv->c_lnext;
}
}
#line 383 "/tmp/screen-3.9.15/layer.c"
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  char *s2 ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int len ;
  int len2 ;
  struct mchar or ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp21 ;

  {
#line 396
  if (x + n > l->l_width) {
#line 397
    n = l->l_width - x;
  }
  {
#line 405
  __cil_tmp16 = strlen((char const   *)s);
#line 405
  len = (int )__cil_tmp16;
  }
#line 406
  if (len > n) {
#line 407
    len = n;
  }
#line 408
  cv = l->l_cvlist;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! cv) {
#line 408
      goto while_break;
    }
#line 409
    vp = cv->c_vplist;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! vp) {
#line 409
        goto while_break___0;
      }
#line 411
      y2 = y + vp->v_yoff;
#line 412
      if (y2 < vp->v_ys) {
#line 413
        goto while_continue___0;
      } else
#line 412
      if (y2 > vp->v_ye) {
#line 413
        goto while_continue___0;
      }
#line 414
      xs2 = x + vp->v_xoff;
#line 415
      xe2 = (xs2 + n) - 1;
#line 416
      if (xs2 < vp->v_xs) {
#line 417
        xs2 = vp->v_xs;
      }
#line 418
      if (xe2 > vp->v_xe) {
#line 419
        xe2 = vp->v_xe;
      }
#line 420
      if (xs2 > xe2) {
#line 421
        goto while_continue___0;
      }
      {
#line 422
      display = cv->c_display;
#line 423
      GotoPos(xs2, y2);
#line 424
      SetRendition(r);
#line 425
      len2 = (xe2 - (x + vp->v_xoff)) + 1;
      }
#line 426
      if (len2 > len) {
#line 427
        len2 = len;
      }
      {
#line 428
      __cil_tmp17 = PutWinMsg(s, (xs2 - x) - vp->v_xoff, len2);
      }
#line 428
      if (! __cil_tmp17) {
#line 430
        s2 = ((s + xs2) - x) - vp->v_xoff;
        {
#line 431
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 431
          if (! (__cil_tmp18 > 0)) {
#line 431
            goto while_break___1;
          }
          {
#line 433
          __cil_tmp19 = s2;
#line 433
          s2 ++;
#line 433
          PUTCHARLP((int )*__cil_tmp19);
#line 434
          xs2 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 438
        xs2 = (x + vp->v_xoff) + len2;
      }
#line 439
      if (xs2 < vp->v_xs) {
#line 440
        xs2 = vp->v_xs;
      }
      {
#line 441
      or = display->d_rend;
#line 442
      GotoPos(xs2, y2);
#line 443
      SetRendition(& or);
      }
      {
#line 444
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 444
        if (! (__cil_tmp21 <= xe2)) {
#line 444
          goto while_break___2;
        }
        {
#line 445
        PUTCHARLP(' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 409
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  cv = cv->c_lnext;
}
}
#line 450 "/tmp/screen-3.9.15/layer.c"
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *__cil_tmp12 ;
  struct mline *tmp ;
  struct mline *__cil_tmp14 ;
  struct mline *tmp___21 ;

  {
#line 460
  if (xs >= l->l_width) {
#line 461
    xs = l->l_width - 1;
  }
#line 462
  if (xe >= l->l_width) {
#line 463
    xe = l->l_width - 1;
  }
#line 464
  cv = l->l_cvlist;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! cv) {
#line 464
      goto while_break;
    }
#line 465
    vp = cv->c_vplist;
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! vp) {
#line 465
        goto while_break___0;
      }
#line 467
      xs2 = xs + vp->v_xoff;
#line 468
      xe2 = xe + vp->v_xoff;
#line 469
      y2 = y + vp->v_yoff;
#line 470
      if (y2 < vp->v_ys) {
#line 471
        goto while_continue___0;
      } else
#line 470
      if (y2 > vp->v_ye) {
#line 471
        goto while_continue___0;
      }
#line 472
      if (xs2 < vp->v_xs) {
#line 473
        xs2 = vp->v_xs;
      }
#line 474
      if (xe2 > vp->v_xe) {
#line 475
        xe2 = vp->v_xe;
      }
#line 476
      if (xs2 > xe2) {
#line 477
        goto while_continue___0;
      }
#line 478
      display = cv->c_display;
#line 479
      if (ol) {
#line 479
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 479
          __cil_tmp12 = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 479
          tmp = __cil_tmp12;
          }
        } else {
#line 479
          tmp = ol;
        }
        {
#line 479
        __cil_tmp14 = mloff(tmp, - vp->v_xoff);
#line 479
        tmp___21 = __cil_tmp14;
        }
      } else {
#line 479
        tmp___21 = (struct mline *)0;
      }
      {
#line 479
      ClearLine(tmp___21, y2, xs2, xe2, bce);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 465
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  cv = cv->c_lnext;
}
}
#line 484 "/tmp/screen-3.9.15/layer.c"
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int ys2 ;
  int xe2 ;
  int ye2 ;
  int __cil_tmp15 ;

  {
#line 498
  if (xs >= l->l_width) {
#line 499
    xs = l->l_width - 1;
  }
#line 500
  if (xe >= l->l_width) {
#line 501
    xe = l->l_width - 1;
  }
#line 502
  cv = l->l_cvlist;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! cv) {
#line 502
      goto while_break;
    }
#line 503
    vp = cv->c_vplist;
    {
#line 503
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 503
      if (! vp) {
#line 503
        goto while_break___0;
      }
#line 505
      xs2 = xs + vp->v_xoff;
#line 506
      xe2 = xe + vp->v_xoff;
#line 507
      ys2 = ys + vp->v_yoff;
#line 508
      ye2 = ye + vp->v_yoff;
#line 509
      if (xs2 < vp->v_xs) {
#line 510
        xs2 = vp->v_xs;
      }
#line 511
      if (xe2 > vp->v_xe) {
#line 512
        xe2 = vp->v_xe;
      }
#line 513
      if (xs2 > vp->v_xe) {
#line 514
        ys2 ++;
      }
#line 515
      if (xe2 < vp->v_xs) {
#line 516
        __cil_tmp15 = ye2;
#line 516
        ye2 --;
      }
#line 517
      if (ys2 < vp->v_ys) {
#line 518
        ys2 = vp->v_ys;
      }
#line 519
      if (ye2 > vp->v_ye) {
#line 520
        ye2 = vp->v_ye;
      }
#line 521
      if (ys2 > ye2) {
#line 522
        goto while_continue___0;
      }
#line 539
      if (xs == 0) {
#line 540
        xs2 = vp->v_xs;
      } else
#line 539
      if (ys2 != ys + vp->v_yoff) {
#line 540
        xs2 = vp->v_xs;
      }
#line 541
      if (xe == l->l_width - 1) {
#line 542
        xe2 = vp->v_xe;
      } else
#line 541
      if (ye2 != ye + vp->v_yoff) {
#line 542
        xe2 = vp->v_xe;
      }
      {
#line 543
      display = cv->c_display;
#line 544
      ClearArea(xs2, ys2, vp->v_xs, vp->v_xe, xe2, ye2, bce, uself);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 503
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  cv = cv->c_lnext;
}
}
#line 550 "/tmp/screen-3.9.15/layer.c"
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mline *tmp ;
  struct mline *__cil_tmp13 ;
  struct mline *tmp___22 ;
  struct mline *__cil_tmp15 ;

  {
#line 566
  cv = l->l_cvlist;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! cv) {
#line 566
      goto while_break;
    }
#line 567
    vp = cv->c_vplist;
    {
#line 567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 567
      if (! vp) {
#line 567
        goto while_break___0;
      }
#line 569
      xs2 = xs + vp->v_xoff;
#line 570
      xe2 = xe + vp->v_xoff;
#line 571
      y2 = y + vp->v_yoff;
#line 572
      if (y2 < vp->v_ys) {
#line 573
        goto while_continue___0;
      } else
#line 572
      if (y2 > vp->v_ye) {
#line 573
        goto while_continue___0;
      }
#line 574
      if (xs2 < vp->v_xs) {
#line 575
        xs2 = vp->v_xs;
      }
#line 576
      if (xe2 > vp->v_xe) {
#line 577
        xe2 = vp->v_xe;
      }
#line 578
      if (xs2 > xe2) {
#line 579
        goto while_continue___0;
      }
#line 580
      display = cv->c_display;
      {
#line 581
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 581
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 582
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 582
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 583
      if (isblank) {
#line 583
        tmp = & mline_blank;
      } else {
#line 583
        tmp = & mline_null;
      }
#line 583
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 583
        __cil_tmp13 = recode_mline(ml, l->l_width, l->l_encoding, display->d_encoding);
#line 583
        tmp___22 = __cil_tmp13;
        }
      } else {
#line 583
        tmp___22 = ml;
      }
      {
#line 583
      __cil_tmp15 = mloff(tmp___22, - vp->v_xoff);
#line 583
      DisplayLine(tmp, __cil_tmp15, y2, xs2, xe2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 567
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  cv = cv->c_lnext;
}
}
#line 588 "/tmp/screen-3.9.15/layer.c"
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) 
{ 
  struct mchar nc ;
  int tmp ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    nc.image = *(ml->image + 0);
#line 595
    nc.attr = *(ml->attr + 0);
#line 595
    nc.font = *(ml->font + 0);
#line 595
    nc.color = *(ml->color + 0);
#line 595
    nc.mbcs = (unsigned char )0;
#line 595
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  if (l->l_encoding == 8) {
#line 597
    tmp = (int )*(ml->font + 1) == 255 && (int )*(ml->image + 1) == 255;
  } else {
#line 597
    tmp = ((int )*(ml->font + 0) & 31) != 0 && ((int )*(ml->font + 0) & 224) == 0;
  }
#line 597
  if (tmp) {
#line 599
    nc.mbcs = *(ml->image + 1);
#line 600
    from ++;
  }
  {
#line 603
  LWrapChar(l, & nc, y - 1, - 1, - 1, 0);
#line 604
  from ++;
  }
#line 605
  if (from <= to) {
    {
#line 606
    LCDisplayLine(l, ml, y, from, to, isblank);
    }
  }
}
}
#line 610 "/tmp/screen-3.9.15/layer.c"
void LSetRendition(struct layer *l , struct mchar *r ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;

  {
#line 617
  cv = l->l_cvlist;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! cv) {
#line 617
      goto while_break;
    }
#line 618
    vp = cv->c_vplist;
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 618
      if (! vp) {
#line 618
        goto while_break___0;
      }
      {
#line 620
      display = cv->c_display;
#line 621
      SetRendition(r);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 618
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  cv = cv->c_lnext;
}
}
#line 626 "/tmp/screen-3.9.15/layer.c"
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct viewport *evp ;
  struct viewport **vpp ;
  int yy ;
  int y2 ;
  int yy2 ;
  int top2 ;
  int bot2 ;
  int bce ;
  int tmp ;
  int tmp___23 ;
  struct mchar *__cil_tmp21 ;
  struct mchar *tmp___24 ;
  struct mchar *__cil_tmp23 ;
  struct mchar *tmp___26 ;

  {
#line 638
  if ((int )c->attr & (1 << 7)) {
#line 638
    tmp = 256;
  } else {
#line 638
    tmp = 0;
  }
#line 638
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 642
  if (y != bot) {
#line 647
    if (y == l->l_height - 1) {
#line 647
      tmp___23 = y;
    } else {
#line 647
      tmp___23 = y + 1;
    }
#line 647
    yy = tmp___23;
#line 649
    cv = l->l_cvlist;
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;
#line 649
      if (! cv) {
#line 649
        goto while_break;
      }
#line 651
      y2 = 0;
#line 652
      display = cv->c_display;
#line 654
      vp = cv->c_vplist;
      {
#line 654
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 654
        if (! vp) {
#line 654
          goto while_break___0;
        }
#line 656
        y2 = y + vp->v_yoff;
#line 657
        yy2 = yy + vp->v_yoff;
#line 658
        if (yy2 >= vp->v_ys) {
#line 658
          if (yy2 <= vp->v_ye) {
#line 658
            if (vp->v_xoff >= vp->v_xs) {
#line 658
              if (vp->v_xoff <= vp->v_xe) {
#line 659
                goto while_break___0;
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 654
      vp = vp->v_next;
#line 661
      if (vp == (struct viewport *)0) {
#line 662
        goto while_continue;
      }
#line 664
      evp = cv->c_vplist;
      {
#line 664
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 664
        if (! evp) {
#line 664
          goto while_break___1;
        }
#line 665
        if (y2 >= evp->v_ys) {
#line 665
          if (y2 <= evp->v_ye) {
#line 665
            if ((evp->v_xoff + l->l_width) - 1 >= evp->v_xs) {
#line 665
              if ((evp->v_xoff + l->l_width) - 1 <= evp->v_xe) {
#line 666
                goto while_break___1;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 664
      evp = evp->v_next;
#line 667
      if (evp == (struct viewport *)0) {
        _L: /* CIL Label */ 
        {
#line 670
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 670
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 671
        cvlist = l->l_cvlist;
#line 672
        cvlnext = cv->c_lnext;
#line 673
        l->l_cvlist = cv;
#line 674
        cv->c_lnext = (struct canvas *)0;
#line 675
        if (ins) {
          {
#line 676
          LInsChar(l, c, 0, yy, (struct mline *)0);
          }
        } else {
          {
#line 678
          LPutChar(l, c, 0, yy);
          }
        }
#line 679
        l->l_cvlist = cvlist;
#line 680
        cv->c_lnext = cvlnext;
      } else
#line 667
      if (ins) {
#line 667
        if ((vp->v_xoff + l->l_width) - 1 > vp->v_ye) {
#line 667
          goto _L;
        } else {
#line 667
          goto _L___25;
        }
      } else {
        _L___25: /* CIL Label */ 
#line 684
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 684
          __cil_tmp21 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 684
          tmp___24 = __cil_tmp21;
          }
        } else {
#line 684
          tmp___24 = c;
        }
        {
#line 684
        WrapChar(tmp___24, vp->v_xoff + l->l_width, y2, vp->v_xoff, - 1, (vp->v_xoff + l->l_width) - 1,
                 - 1, ins);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 649
    cv = cv->c_lnext;
  } else {
#line 692
    cv = l->l_cvlist;
    {
#line 692
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 692
      if (! cv) {
#line 692
        goto while_break___3;
      }
#line 694
      display = cv->c_display;
#line 696
      vpp = & cv->c_vplist;
      {
#line 696
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 696
        if (! vp) {
#line 696
          goto while_break___4;
        }
#line 698
        yy2 = bot + vp->v_yoff;
#line 699
        if (yy2 >= vp->v_ys) {
#line 699
          if (yy2 <= vp->v_ye) {
#line 699
            if (vp->v_xoff >= vp->v_xs) {
#line 699
              if ((vp->v_xoff + l->l_width) - 1 <= vp->v_xe) {
#line 700
                goto while_break___4;
              }
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 696
      vpp = & vp->v_next;
#line 703
      if (vp) {
#line 707
        *vpp = vp->v_next;
      }
#line 709
      if (cv->c_vplist) {
        {
#line 712
        cvlist = l->l_cvlist;
#line 713
        cvlnext = cv->c_lnext;
#line 714
        l->l_cvlist = cv;
#line 715
        cv->c_lnext = (struct canvas *)0;
#line 716
        LScrollV(l, 1, top, bot, bce);
        }
#line 717
        if (! vp) {
#line 719
          if (ins) {
            {
#line 720
            LInsChar(l, c, 0, bot, (struct mline *)0);
            }
          } else {
            {
#line 722
            LPutChar(l, c, 0, bot);
            }
          }
        }
#line 724
        l->l_cvlist = cvlist;
#line 725
        cv->c_lnext = cvlnext;
      }
#line 727
      if (vp) {
#line 730
        *vpp = vp;
#line 731
        top2 = top + vp->v_yoff;
#line 732
        bot2 = bot + vp->v_yoff;
#line 733
        if (top2 < vp->v_ys) {
#line 734
          top2 = vp->v_ys;
        }
#line 735
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 735
          __cil_tmp23 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 735
          tmp___26 = __cil_tmp23;
          }
        } else {
#line 735
          tmp___26 = c;
        }
        {
#line 735
        WrapChar(tmp___26, vp->v_xoff + l->l_width, bot2, vp->v_xoff, top2, (vp->v_xoff + l->l_width) - 1,
                 bot2, ins);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 692
    cv = cv->c_lnext;
  }
}
}
#line 743 "/tmp/screen-3.9.15/layer.c"
void LCursorVisibility(struct layer *l , int vis ) 
{ 
  struct canvas *cv ;

  {
#line 748
  cv = l->l_cvlist;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! cv) {
#line 748
      goto while_break;
    }
#line 750
    display = cv->c_display;
#line 751
    if (cv != display->d_forecv) {
#line 752
      goto while_continue;
    }
    {
#line 753
    CursorVisibility(vis);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  cv = cv->c_lnext;
}
}
#line 758 "/tmp/screen-3.9.15/layer.c"
void LSetFlow(struct layer *l , int flow ) 
{ 
  struct canvas *cv ;

  {
#line 763
  cv = l->l_cvlist;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! cv) {
#line 763
      goto while_break;
    }
#line 765
    display = cv->c_display;
#line 766
    if (cv != display->d_forecv) {
#line 767
      goto while_continue;
    }
    {
#line 768
    SetFlow(flow);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  cv = cv->c_lnext;
}
}
#line 773 "/tmp/screen-3.9.15/layer.c"
void LKeypadMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 778
  cv = l->l_cvlist;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! cv) {
#line 778
      goto while_break;
    }
#line 780
    display = cv->c_display;
#line 781
    if (cv != display->d_forecv) {
#line 782
      goto while_continue;
    }
    {
#line 783
    KeypadMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  cv = cv->c_lnext;
}
}
#line 788 "/tmp/screen-3.9.15/layer.c"
void LCursorkeysMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 793
  cv = l->l_cvlist;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! cv) {
#line 793
      goto while_break;
    }
#line 795
    display = cv->c_display;
#line 796
    if (cv != display->d_forecv) {
#line 797
      goto while_continue;
    }
    {
#line 798
    CursorkeysMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  cv = cv->c_lnext;
}
}
#line 803 "/tmp/screen-3.9.15/layer.c"
void LMouseMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 808
  cv = l->l_cvlist;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! cv) {
#line 808
      goto while_break;
    }
#line 810
    display = cv->c_display;
#line 811
    if (cv != display->d_forecv) {
#line 812
      goto while_continue;
    }
    {
#line 813
    MouseMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  cv = cv->c_lnext;
}
}
#line 821 "/tmp/screen-3.9.15/layer.c"
void LClearAll(struct layer *l , int uself ) 
{ 


  {
  {
#line 825
  LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, uself);
  }
}
}
#line 829 "/tmp/screen-3.9.15/layer.c"
void LRefreshAll(struct layer *l , int isblank ) 
{ 
  struct layer *oldflayer ;
  int y ;

  {
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  oldflayer = flayer;
#line 838
  flayer = l;
#line 839
  if (! isblank) {
    {
#line 840
    LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, 0);
    }
  }
  {
#line 842
  ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                    - 1,
                                                                                    - 1,
                                                                                    1);
#line 843
  y = 0;
  }
  {
#line 843
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 843
    if (! (y < l->l_height)) {
#line 843
      goto while_break___0;
    }
    {
#line 844
    ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(y,
                                                                                      0,
                                                                                      l->l_width - 1,
                                                                                      1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 843
  y ++;
#line 845
  flayer = oldflayer;
}
}
#line 850 "/tmp/screen-3.9.15/layer.c"
void KillLayerChain(struct layer *lay ) 
{ 
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;
  struct layer *oldflayer ;

  {
#line 856
  oldflayer = flayer;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  l = lay;
  {
#line 858
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 858
    if (! l) {
#line 858
      goto while_break___0;
    }
#line 860
    if (l->l_layfn == & WinLf) {
#line 861
      goto while_break___0;
    } else
#line 860
    if (l->l_layfn == & BlankLf) {
#line 861
      goto while_break___0;
    }
    {
#line 862
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 862
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 863
    if (oldflayer == l) {
#line 864
      oldflayer = (struct layer *)0;
    }
#line 865
    cv = l->l_cvlist;
    {
#line 865
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 865
      if (! cv) {
#line 865
        goto while_break___2;
      }
#line 867
      ncv = cv->c_lnext;
#line 868
      cv->c_layer = (struct layer *)0;
#line 869
      cv->c_lnext = (struct canvas *)0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 865
    cv = ncv;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 858
  l = l->l_next;
#line 872
  flayer = lay;
  {
#line 873
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 873
    if (! (flayer != l)) {
#line 873
      goto while_break___3;
    }
    {
#line 874
    ExitOverlayPage();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 875
  flayer = oldflayer;
}
}
#line 887 "/tmp/screen-3.9.15/layer.c"
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) 
{ 
  char *data ;
  struct layer *newlay ;
  struct canvas *cv ;
  struct canvas *cvp ;
  struct canvas **cvpp ;
  struct win *p ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  struct display *olddisplay ;
  struct display *olddisplay___0 ;
  struct canvas *cv___27 ;

  {
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 899
  cv = (struct canvas *)0;
#line 900
  if (display) {
#line 900
    if ((display->d_forecv)->c_layer == flayer) {
#line 901
      cv = display->d_forecv;
    }
  }
  {
#line 903
  __cil_tmp10 = calloc((unsigned long )1, sizeof(struct layer ));
#line 903
  newlay = (struct layer *)__cil_tmp10;
  }
#line 903
  if (newlay == (struct layer *)0) {
    {
#line 905
    Msg(0, (char *)"No memory for layer struct");
    }
#line 906
    return (- 1);
  }
  {
#line 908
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 908
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 909
  data = (char *)0;
#line 910
  if (datasize) {
    {
#line 912
    __cil_tmp11 = malloc((unsigned long )datasize);
#line 912
    data = (char *)__cil_tmp11;
    }
#line 912
    if (data == (char *)0) {
      {
#line 914
      free((void *)((char *)newlay));
#line 915
      Msg(0, (char *)"No memory for layer data");
      }
#line 916
      return (- 1);
    }
    {
#line 918
    bzero((void *)data, (unsigned long )datasize);
    }
  }
#line 921
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 923
  if (p) {
#line 923
    if (p->w_savelayer == flayer) {
      _L: /* CIL Label */ 
#line 925
      if (p->w_savelayer) {
#line 925
        if (p->w_savelayer != flayer) {
#line 925
          if ((p->w_savelayer)->l_cvlist == (struct canvas *)0) {
            {
#line 926
            KillLayerChain(p->w_savelayer);
            }
          }
        }
      }
#line 927
      p->w_savelayer = newlay;
    } else
#line 923
    if (block) {
#line 923
      if (flayer->l_next == (struct layer *)0) {
#line 923
        goto _L;
      }
    }
  }
#line 930
  if (cv) {
#line 930
    if (flayer->l_next == (struct layer *)0) {
#line 930
      if (! block) {
        {
#line 932
        olddisplay = display;
#line 933
        display = cv->c_display;
#line 934
        RemoveStatus();
#line 935
        display = olddisplay;
#line 938
        cvpp = & flayer->l_cvlist;
        }
        {
#line 938
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 938
          if (! cvp) {
#line 938
            goto while_break___1;
          }
#line 939
          if (cvp == cv) {
#line 940
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 938
        cvpp = & cvp->c_lnext;
        {
#line 941
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 941
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 942
        *cvpp = cv->c_lnext;
#line 943
        newlay->l_cvlist = cv;
#line 944
        cv->c_lnext = (struct canvas *)0;
#line 945
        cv->c_layer = newlay;
      } else {
#line 930
        goto _L___28;
      }
    } else {
#line 930
      goto _L___28;
    }
  } else {
    _L___28: /* CIL Label */ 
    {
#line 949
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 949
      olddisplay___0 = display;
#line 949
      display = displays;
      {
#line 949
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 949
        if (! display) {
#line 949
          goto while_break___4;
        }
#line 949
        cv___27 = display->d_cvlist;
        {
#line 949
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 949
          if (! cv___27) {
#line 949
            goto while_break___5;
          }
#line 949
          if (cv___27->c_layer == flayer) {
#line 949
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 949
        cv___27 = cv___27->c_next;
#line 949
        if (cv___27 == (struct canvas *)0) {
#line 949
          goto while_continue___4;
        }
        {
#line 949
        RemoveStatus();
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 949
      display = display->d_next;
#line 949
      display = olddisplay___0;
#line 949
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 950
    if (block) {
      {
#line 951
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 951
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 952
    if (block) {
#line 952
      if (flayer->l_layfn == & WinLf) {
        {
#line 954
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 954
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 955
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 955
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 956
        (p->w_blocked) ++;
#line 957
        newlay->l_blocking = 1;
      }
    }
#line 960
    newlay->l_cvlist = flayer->l_cvlist;
#line 961
    cvp = newlay->l_cvlist;
    {
#line 961
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 961
      if (! cvp) {
#line 961
        goto while_break___9;
      }
#line 962
      cvp->c_layer = newlay;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 961
    cvp = cvp->c_lnext;
#line 963
    flayer->l_cvlist = (struct canvas *)0;
  }
  {
#line 965
  newlay->l_width = flayer->l_width;
#line 966
  newlay->l_height = flayer->l_height;
#line 967
  newlay->l_encoding = 0;
#line 968
  newlay->l_layfn = lf;
#line 969
  newlay->l_data = data;
#line 970
  newlay->l_next = flayer;
#line 971
  newlay->l_bottom = flayer->l_bottom;
#line 972
  flayer = newlay;
#line 973
  ((void (*)(void))*((flayer->l_layfn)->lf_LayRestore))();
  }
#line 974
  return (0);
}
}
#line 978 "/tmp/screen-3.9.15/layer.c"
void ExitOverlayPage(void) 
{ 
  struct layer *oldlay ;
  struct win *p ;
  int doredisplay ;
  struct canvas *cv ;
  struct canvas *ocv ;
  int __cil_tmp6 ;

  {
#line 982
  doredisplay = 0;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 986
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 986
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 987
  oldlay = flayer;
#line 988
  if (oldlay->l_data) {
    {
#line 989
    free((void *)oldlay->l_data);
    }
  }
#line 991
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 993
  flayer = oldlay->l_next;
#line 994
  if (flayer->l_layfn == & WinLf) {
#line 996
    if (oldlay->l_blocking) {
      {
#line 998
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 998
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 999
      __cil_tmp6 = p->w_blocked;
#line 999
      (p->w_blocked) --;
      {
#line 1000
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1000
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1003
    if (p->w_blocked) {
#line 1003
      if (p->w_savelayer) {
#line 1003
        if (p->w_savelayer != flayer) {
#line 1003
          if (oldlay->l_cvlist) {
            {
#line 1005
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1005
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1007
            flayer = p->w_savelayer;
#line 1008
            doredisplay = 1;
          }
        }
      }
    }
  }
#line 1011
  if (p) {
#line 1011
    if (p->w_savelayer == oldlay) {
#line 1012
      p->w_savelayer = flayer;
    }
  }
#line 1014
  if (p) {
#line 1014
    if (oldlay == p->w_paster.pa_pastelayer) {
#line 1015
      p->w_paster.pa_pastelayer = (struct layer *)0;
    }
  }
#line 1019
  cv = oldlay->l_cvlist;
#line 1019
  ocv = (struct canvas *)0;
  {
#line 1019
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1019
    if (! cv) {
#line 1019
      goto while_break___4;
    }
#line 1021
    cv->c_layer = flayer;
#line 1022
    ocv = cv;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1019
  cv = cv->c_lnext;
#line 1024
  if (ocv) {
#line 1026
    cv = flayer->l_cvlist;
#line 1027
    ocv->c_lnext = (struct canvas *)0;
#line 1028
    flayer->l_cvlist = oldlay->l_cvlist;
#line 1030
    if (doredisplay) {
      {
#line 1031
      LRefreshAll(flayer, 0);
      }
    }
#line 1032
    ocv->c_lnext = cv;
  }
  {
#line 1034
  oldlay->l_cvlist = (struct canvas *)0;
#line 1035
  free((void *)((char *)oldlay));
#line 1036
  ((void (*)(void))*((flayer->l_layfn)->lf_LayRestore))();
#line 1037
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 1043 "/tmp/screen-3.9.15/layer.c"
void LMsg(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf[8192] ;
  char *p ;
  struct canvas *cv ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1053
  p = (char *)buf;
#line 1056
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 1057
  fmt = DoNLS(fmt);
#line 1058
  __cil_tmp8 = vsnprintf(p, sizeof(buf) - 100UL, (char const   *)fmt, (__builtin_va_list *)ap);
#line 1059
  __builtin_va_end((__builtin_va_list *)ap);
  }
#line 1060
  if (err) {
    {
#line 1062
    __cil_tmp9 = strlen((char const   *)p);
    }
    {
#line 1062
    p += __cil_tmp9;
#line 1063
    __cil_tmp10 = p;
#line 1063
    p ++;
#line 1063
    *__cil_tmp10 = (char )':';
#line 1064
    __cil_tmp11 = p;
#line 1064
    p ++;
#line 1064
    *__cil_tmp11 = (char )' ';
#line 1065
    __cil_tmp12 = strerror(err);
#line 1065
    strncpy(p, (char const   *)__cil_tmp12, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 1066
    buf[sizeof(buf) - 1UL] = (char )0;
    }
  }
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  display = displays;
  {
#line 1069
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1069
    if (! display) {
#line 1069
      goto while_break___0;
    }
#line 1071
    cv = display->d_cvlist;
    {
#line 1071
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1071
      if (! cv) {
#line 1071
        goto while_break___1;
      }
#line 1072
      if (cv->c_layer == flayer) {
#line 1073
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1071
    cv = cv->c_next;
#line 1074
    if (cv == (struct canvas *)0) {
#line 1075
      goto while_continue___0;
    }
    {
#line 1076
    MakeStatus((char *)buf);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1069
  display = display->d_next;
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 449
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 449 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 451
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 451
  return (__cil_tmp3);
}
}
#line 456
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 456 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 458
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 458
  return (__cil_tmp3);
}
}
#line 463
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 463 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 465
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (__cil_tmp3);
}
}
#line 470
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 470 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 473
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 473
  return (__cil_tmp5);
}
}
#line 479
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 479 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 481
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (__cil_tmp4);
}
}
#line 487
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 487 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 490
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (__cil_tmp5);
}
}
#line 157 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 652
extern size_t fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 329 "./extern.h"
char *SaveStr(char const   *str ) ;
#line 42 "./logfile.h"
struct logfile *logfopen(char *name , FILE *fp ) ;
#line 49
int islogfile(char *name ) ;
#line 54
int logfclose(struct logfile *l ) ;
#line 55
int logfwrite(struct logfile *l , char *buf , int n ) ;
#line 62
int logfflush(struct logfile *l ) ;
#line 72
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) ;
#line 82
int lf_move_fd(int fd , int need_fd ) ;
#line 37 "/tmp/screen-3.9.15/logfile.c"
static void changed_logfile(struct logfile *l ) ;
#line 38
static struct logfile *lookup_logfile(char *name ) ;
#line 39
static int stolen_logfile(struct logfile *l ) ;
#line 41 "/tmp/screen-3.9.15/logfile.c"
static struct logfile *logroot  =    (struct logfile *)((void *)0);
#line 44 "/tmp/screen-3.9.15/logfile.c"
static void changed_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 47
  s = l->st;
#line 49
  __cil_tmp4 = fileno(l->fp);
#line 49
  __cil_tmp5 = fstat(__cil_tmp4, & o);
  }
#line 49
  if (__cil_tmp5 < 0) {
#line 50
    return;
  }
#line 51
  if (o.st_size > s->st_size) {
#line 53
    s->st_size = o.st_size;
#line 54
    s->st_mtim.tv_sec = o.st_mtim.tv_sec;
  }
}
}
#line 67 "/tmp/screen-3.9.15/logfile.c"
int lf_move_fd(int fd , int need_fd ) 
{ 
  int r ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 70
  r = - 1;
#line 72
  if (fd == need_fd) {
#line 73
    return (fd);
  }
#line 74
  if (fd >= 0) {
#line 74
    if (fd < need_fd) {
      {
#line 75
      __cil_tmp4 = dup(fd);
#line 75
      __cil_tmp5 = lf_move_fd(__cil_tmp4, need_fd);
#line 75
      r = __cil_tmp5;
      }
    }
  }
  {
#line 76
  close(fd);
  }
#line 77
  return (r);
}
}
#line 81 "/tmp/screen-3.9.15/logfile.c"
static int logfile_reopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int __cil_tmp6 ;

  {
  {
#line 88
  close(wantfd);
#line 89
  __cil_tmp6 = lf_move_fd(got_fd, wantfd);
  }
  {
#line 89
  got_fd = open((char const   *)name, 1089, 438);
  }
#line 89
  if (got_fd < 0) {
    _L: /* CIL Label */ 
    {
#line 92
    logfclose(l);
    }
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
#line 93
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 94
    return (- 1);
  } else
#line 89
  if (__cil_tmp6 < 0) {
#line 89
    goto _L;
  }
  {
#line 96
  changed_logfile(l);
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 98
  return (0);
}
}
#line 101 "/tmp/screen-3.9.15/logfile.c"
static int (*lf_reopen_fn)()  =    logfile_reopen;
#line 116 "/tmp/screen-3.9.15/logfile.c"
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) 
{ 
  int (*tmp)(char * , int  , struct logfile * ) ;

  {
#line 119
  if (fn) {
#line 119
    tmp = fn;
  } else {
#line 119
    tmp = (int (*)(char * , int  , struct logfile * ))logfile_reopen;
  }
#line 119
  lf_reopen_fn = (int (*)())tmp;
}
}
#line 129 "/tmp/screen-3.9.15/logfile.c"
static int stolen_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 132
  s = l->st;
#line 134
  o = *s;
#line 135
  __cil_tmp4 = fileno(l->fp);
#line 135
  __cil_tmp5 = fstat(__cil_tmp4, s);
  }
#line 135
  if (__cil_tmp5 < 0) {
#line 136
    s->st_dev = (__dev_t )0;
#line 136
    s->st_ino = s->st_dev;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (! o.st_dev) {
#line 138
    if (! o.st_ino) {
#line 139
      return (0);
    }
  }
#line 141
  if (! s->st_dev) {
#line 141
    if (! s->st_ino) {
      _L: /* CIL Label */ 
      {
#line 149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 149
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 150
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 152
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 152
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 153
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 153
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 155
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 155
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 157
      return (- 1);
    } else {
#line 141
      goto _L___33;
    }
  } else
  _L___33: /* CIL Label */ 
#line 141
  if (! s->st_nlink) {
#line 141
    goto _L;
  } else
#line 141
  if (s->st_size < o.st_size) {
#line 141
    goto _L;
  } else
#line 141
  if (s->st_mtim.tv_sec != o.st_mtim.tv_sec) {
#line 141
    goto _L;
  } else
#line 141
  if (s->st_ctim.tv_sec != o.st_ctim.tv_sec) {
#line 141
    if (! (s->st_mtim.tv_sec == s->st_ctim.tv_sec && o.st_ctim.tv_sec < s->st_ctim.tv_sec)) {
#line 141
      goto _L;
    }
  }
  {
#line 160
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 160
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 161
  return (0);
}
}
#line 165 "/tmp/screen-3.9.15/logfile.c"
static struct logfile *lookup_logfile(char *name ) 
{ 
  struct logfile *l ;
  int __cil_tmp3 ;

  {
#line 170
  l = logroot;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! l) {
#line 170
      goto while_break;
    }
    {
#line 171
    __cil_tmp3 = strcmp((char const   *)name, (char const   *)l->name);
    }
#line 171
    if (! __cil_tmp3) {
#line 172
      return (l);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  l = l->next;
#line 173
  return ((struct logfile *)((void *)0));
}
}
#line 177 "/tmp/screen-3.9.15/logfile.c"
struct logfile *logfopen(char *name , FILE *fp ) 
{ 
  struct logfile *l ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 183
  if (! fp) {
    {
#line 185
    l = lookup_logfile(name);
    }
#line 185
    if (! l) {
#line 186
      return ((struct logfile *)((void *)0));
    }
#line 187
    (l->opencount) ++;
#line 188
    return (l);
  }
  {
#line 191
  __cil_tmp6 = malloc(sizeof(struct logfile ));
#line 191
  l = (struct logfile *)__cil_tmp6;
  }
#line 191
  if (! l) {
#line 192
    return ((struct logfile *)((void *)0));
  }
  {
#line 193
  __cil_tmp7 = malloc(sizeof(struct stat ));
#line 193
  l->st = (struct stat *)__cil_tmp7;
  }
#line 193
  if (! l->st) {
    {
#line 195
    free((void *)((char *)l));
    }
#line 196
    return ((struct logfile *)((void *)0));
  }
  {
#line 199
  l->name = SaveStr((char const   *)name);
  }
#line 199
  if (! l->name) {
    {
#line 201
    free((void *)((char *)l->st));
#line 202
    free((void *)((char *)l));
    }
#line 203
    return ((struct logfile *)((void *)0));
  }
  {
#line 205
  l->fp = fp;
#line 206
  l->opencount = 1;
#line 207
  l->writecount = 0;
#line 208
  l->flushcount = 0;
#line 209
  changed_logfile(l);
#line 211
  l->next = logroot;
#line 212
  logroot = l;
  }
#line 213
  return (l);
}
}
#line 217 "/tmp/screen-3.9.15/logfile.c"
int islogfile(char *name ) 
{ 
  int tmp ;
  struct logfile *__cil_tmp3 ;
  int tmp___34 ;

  {
#line 220
  if (! name) {
#line 221
    if (logroot) {
#line 221
      tmp = 1;
    } else {
#line 221
      tmp = 0;
    }
#line 221
    return (tmp);
  }
  {
#line 222
  __cil_tmp3 = lookup_logfile(name);
  }
#line 222
  if (__cil_tmp3) {
#line 222
    tmp___34 = 1;
  } else {
#line 222
    tmp___34 = 0;
  }
#line 222
  return (tmp___34);
}
}
#line 226 "/tmp/screen-3.9.15/logfile.c"
int logfclose(struct logfile *l ) 
{ 
  struct logfile **lp ;

  {
#line 231
  lp = & logroot;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! *lp) {
#line 231
      goto while_break;
    }
#line 232
    if (*lp == l) {
#line 233
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  lp = & (*lp)->next;
#line 235
  if (! *lp) {
#line 236
    return (- 1);
  }
#line 238
  (l->opencount) --;
#line 238
  if (l->opencount > 0) {
#line 239
    return (0);
  }
#line 240
  if (l->opencount < 0) {
    {
#line 241
    abort();
    }
  }
  {
#line 243
  *lp = l->next;
#line 244
  fclose(l->fp);
#line 245
  free((void *)l->name);
#line 246
  free((void *)((char *)l));
  }
#line 247
  return (0);
}
}
#line 256 "/tmp/screen-3.9.15/logfile.c"
int logfwrite(struct logfile *l , char *buf , int n ) 
{ 
  int r ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 263
  __cil_tmp6 = fileno(l->fp);
#line 263
  __cil_tmp7 = lf_reopen_fn(l->name, __cil_tmp6, l);
  }
  {
#line 263
  __cil_tmp5 = stolen_logfile(l);
  }
#line 263
  if (__cil_tmp5) {
#line 263
    if (__cil_tmp7) {
#line 264
      return (- 1);
    }
  }
  {
#line 265
  __cil_tmp8 = fwrite((void const   *)buf, (size_t )n, (size_t )1, l->fp);
#line 265
  r = (int )__cil_tmp8;
#line 266
  l->writecount += l->flushcount + 1;
#line 267
  l->flushcount = 0;
#line 268
  changed_logfile(l);
  }
#line 269
  return (r);
}
}
#line 273 "/tmp/screen-3.9.15/logfile.c"
int logfflush(struct logfile *l ) 
{ 
  int r ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 276
  r = 0;
#line 278
  if (! l) {
#line 279
    l = logroot;
    {
#line 279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 279
      if (! l) {
#line 279
        goto while_break;
      }
      {
#line 281
      __cil_tmp4 = fileno(l->fp);
#line 281
      __cil_tmp5 = lf_reopen_fn(l->name, __cil_tmp4, l);
      }
      {
#line 281
      __cil_tmp3 = stolen_logfile(l);
      }
#line 281
      if (__cil_tmp3) {
#line 281
        if (__cil_tmp5) {
#line 282
          return (- 1);
        }
      }
      {
#line 283
      __cil_tmp6 = fflush(l->fp);
      }
      {
#line 283
      r |= __cil_tmp6;
#line 284
      (l->flushcount) ++;
#line 285
      changed_logfile(l);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 279
    l = l->next;
  } else {
    {
#line 289
    __cil_tmp9 = fileno(l->fp);
#line 289
    __cil_tmp10 = lf_reopen_fn(l->name, __cil_tmp9, l);
    }
    {
#line 289
    __cil_tmp8 = stolen_logfile(l);
    }
#line 289
    if (__cil_tmp8) {
#line 289
      if (__cil_tmp10) {
#line 290
        return (- 1);
      }
    }
    {
#line 291
    r = fflush(l->fp);
#line 292
    (l->flushcount) ++;
#line 293
    changed_logfile(l);
    }
  }
#line 295
  return (r);
}
}
#line 115 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 86 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void syslog(int __pri , char const   *__fmt  , ...) ;
#line 73 "./osdef.h"
extern char *crypt(char * , char * ) ;
#line 93 "./acls.h"
int DefaultEsc ;
#line 93
int DefaultMetaEsc ;
#line 34 "./extern.h"
void Detach(int mode ) ;
#line 45
void Finit(int i ) ;
#line 108
void FreePaster(struct paster *pa ) ;
#line 181
int FindCommnr(char *str ) ;
#line 194
int WindowByNoN(char *str ) ;
#line 375
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) ;
#line 376
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) ;
#line 377
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) ;
#line 378
int AclUmask(struct acluser *u , char *str , char **errp ) ;
#line 379
int UsersAcl(struct acluser *uu , int argc , char **argv ) ;
#line 380
void AclWinSwap(int a , int b ) ;
#line 381
int NewWindowAcl(struct win *w , struct acluser *u ) ;
#line 382
void FreeWindowAcl(struct win *w ) ;
#line 383
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) ;
#line 384
int AclLinkUser(char *from , char *to ) ;
#line 386
int UserFreeCopyBuffer(struct acluser *u ) ;
#line 387
struct acluser **FindUserPtr(char *name ) ;
#line 388
int UserAdd(char *name , char *pass , struct acluser **up ) ;
#line 389
int UserDel(char *name , struct acluser **up ) ;
#line 55 "/tmp/screen-3.9.15/acls.c"
struct comm comms[170] ;
#line 56
struct win *windows ;
#line 56
struct win *wtab[40] ;
#line 57
char NullStr[] ;
#line 58
char SockPath[4608] ;
#line 60
struct acluser *users ;
#line 63 "/tmp/screen-3.9.15/acls.c"
int maxusercount  =    0;
#line 66
static AclBits userbits ;
#line 72 "/tmp/screen-3.9.15/acls.c"
static char default_w_bit[3]  = {      (char )1,      (char )1,      (char )1};
#line 79 "/tmp/screen-3.9.15/acls.c"
static char default_c_bit[1]  = {      (char )0};
#line 91
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) ;
#line 92
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) ;
#line 93
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) ;
#line 94
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) ;
#line 95
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) ;
#line 96
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) ;
#line 100 "/tmp/screen-3.9.15/acls.c"
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) 
{ 
  AclBits n ;
  AclBits o ;
  int i ;
  void *__cil_tmp8 ;

  {
  {
#line 104
  o = *bfp;
#line 107
  __cil_tmp8 = calloc((unsigned long )1, (unsigned long )(& *((char *)0 + (((len + delta) + 1) >> 3))));
#line 107
  n = (AclBits )__cil_tmp8;
  }
#line 107
  if (! n) {
#line 108
    return (- 1);
  }
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < len + delta)) {
#line 109
      goto while_break;
    }
#line 111
    if (i < len) {
#line 111
      if ((128 >> (i & 7)) & (int )*(o + (i >> 3))) {
#line 113
        *(n + (i >> 3)) |= 128 >> (i & 7);
      } else {
#line 111
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 111
    if (i >= len) {
#line 111
      if (defaultbit) {
#line 113
        *(n + (i >> 3)) |= 128 >> (i & 7);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i ++;
#line 115
  if (len) {
    {
#line 116
    free((void *)((char *)o));
    }
  }
#line 117
  *bfp = n;
#line 118
  return (0);
}
}
#line 128 "/tmp/screen-3.9.15/acls.c"
struct acluser **FindUserPtr(char *name ) 
{ 
  struct acluser **u ;
  int __cil_tmp3 ;

  {
#line 133
  u = & users;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! *u) {
#line 133
      goto while_break;
    }
    {
#line 134
    __cil_tmp3 = strcmp((char const   *)((char *)(*u)->u_name), (char const   *)name);
    }
#line 134
    if (! __cil_tmp3) {
#line 135
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  u = & (*u)->u_next;
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return (u);
}
}
#line 145 "/tmp/screen-3.9.15/acls.c"
int DefaultEsc  =    - 1;
#line 146 "/tmp/screen-3.9.15/acls.c"
int DefaultMetaEsc  =    - 1;
#line 154 "/tmp/screen-3.9.15/acls.c"
int UserAdd(char *name , char *pass , struct acluser **up ) 
{ 
  int j ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  int j___35 ;
  struct win *w ;
  struct acluser *u ;
  int __cil_tmp14 ;
  int i ;
  int __cil_tmp16 ;
  int __cil_tmp19 ;
  int __cil_tmp21 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 162
  if (! up) {
    {
#line 163
    up = FindUserPtr(name);
    }
  }
#line 164
  if (*up) {
#line 166
    if (pass) {
      {
#line 167
      (*up)->u_password = SaveStr((char const   *)pass);
      }
    }
#line 168
    return (1);
  }
  {
#line 170
  __cil_tmp7 = strcmp((char const   *)((char *)"none"), (char const   *)name);
  }
#line 170
  if (__cil_tmp7) {
    {
#line 171
    __cil_tmp8 = calloc((unsigned long )1, sizeof(struct acluser ));
#line 171
    *up = (struct acluser *)__cil_tmp8;
    }
  }
#line 172
  if (! *up) {
#line 173
    return (- 1);
  }
  {
#line 175
  (*up)->u_plop.buf = (char *)((void *)0);
#line 176
  (*up)->u_plop.len = 0;
#line 178
  (*up)->u_plop.enc = 0;
#line 181
  (*up)->u_Esc = DefaultEsc;
#line 182
  (*up)->u_MetaEsc = DefaultMetaEsc;
#line 183
  strncpy((char *)(*up)->u_name, (char const   *)name, (unsigned long )20);
#line 184
  (*up)->u_password = (char *)((void *)0);
  }
#line 185
  if (pass) {
    {
#line 186
    (*up)->u_password = SaveStr((char const   *)pass);
    }
  }
#line 187
  if (! (*up)->u_password) {
#line 188
    (*up)->u_password = (char *)NullStr;
  }
#line 189
  (*up)->u_detachwin = - 1;
#line 190
  (*up)->u_detachotherwin = - 1;
#line 193
  (*up)->u_group = (struct aclusergroup *)((void *)0);
#line 195
  (*up)->u_id = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! ((*up)->u_id < maxusercount)) {
#line 195
      goto while_break;
    }
#line 196
    if (! ((128 >> ((*up)->u_id & 7)) & (int )*(userbits + ((*up)->u_id >> 3)))) {
#line 197
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  ((*up)->u_id) ++;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  if ((*up)->u_id == maxusercount) {
    {
#line 205
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 205
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 208
    __cil_tmp14 = GrowBitfield(& userbits, maxusercount, 8, 0);
    }
#line 208
    if (__cil_tmp14) {
      {
#line 210
      free((void *)((char *)*up));
#line 210
      *up = (struct acluser *)((void *)0);
      }
#line 210
      return (- 1);
    }
#line 223
    j___35 = 0;
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 223
      if (! (j___35 <= 169)) {
#line 223
        goto while_break___2;
      }
#line 227
      i = 0;
      {
#line 227
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 227
        if (! (i < 1)) {
#line 227
          goto while_break___3;
        }
        {
#line 228
        __cil_tmp16 = GrowBitfield(& comms[j___35].userbits[i], maxusercount, 8, (int )default_c_bit[i]);
        }
#line 228
        if (__cil_tmp16) {
          {
#line 231
          free((void *)((char *)*up));
#line 231
          *up = (struct acluser *)((void *)0);
          }
#line 231
          return (- 1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 227
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 223
    j___35 ++;
#line 235
    u = users;
    {
#line 235
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 235
      if (! (u != *up)) {
#line 235
        goto while_break___4;
      }
#line 237
      j___35 = 0;
      {
#line 237
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 237
        if (! (j___35 < 3)) {
#line 237
          goto while_break___5;
        }
        {
#line 239
        __cil_tmp19 = GrowBitfield(& u->u_umask_w_bits[j___35], maxusercount, 8, (int )default_w_bit[j___35]);
        }
#line 239
        if (__cil_tmp19) {
          {
#line 242
          free((void *)((char *)*up));
#line 242
          *up = (struct acluser *)((void *)0);
          }
#line 242
          return (- 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 237
      j___35 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 235
    u = u->u_next;
#line 249
    w = windows;
    {
#line 249
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 249
      if (! w) {
#line 249
        goto while_break___6;
      }
#line 252
      j___35 = 0;
      {
#line 252
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 252
        if (! (j___35 < 3)) {
#line 252
          goto while_break___7;
        }
        {
#line 253
        __cil_tmp21 = GrowBitfield(& w->w_userbits[j___35], maxusercount, 8, (int )default_w_bit[j___35]);
        }
#line 253
        if (__cil_tmp21) {
          {
#line 256
          free((void *)((char *)*up));
#line 256
          *up = (struct acluser *)((void *)0);
          }
#line 256
          return (- 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 252
      j___35 ++;
#line 260
      __cil_tmp24 = GrowBitfield(& w->w_lio_notify, maxusercount, 8, 0);
      }
      {
#line 260
      __cil_tmp23 = GrowBitfield(& w->w_mon_notify, maxusercount, 8, 0);
      }
#line 260
      if (__cil_tmp23) {
        {
        {
#line 263
        free((void *)((char *)*up));
        }
#line 263
        *up = (struct acluser *)((void *)0);
        }
#line 263
        return (- 1);
      } else
#line 260
      if (__cil_tmp24) {
        {
        {
#line 263
        free((void *)((char *)*up));
        }
#line 263
        *up = (struct acluser *)((void *)0);
        }
#line 263
        return (- 1);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 249
    w = w->w_next;
#line 266
    maxusercount += 8;
  }
#line 270
  *(userbits + ((*up)->u_id >> 3)) |= 128 >> ((*up)->u_id & 7);
#line 273
  if ((*up)->u_id == 0) {
    {
#line 274
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+a", (char *)"#?");
    }
  }
  {
#line 277
  __cil_tmp25 = strcmp((char const   *)((char *)(*up)->u_name), (char const   *)((char *)"nobody"));
  }
#line 277
  if (! __cil_tmp25) {
    {
#line 279
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"-rwx", (char *)"#?");
#line 280
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"su");
#line 281
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"detach");
#line 282
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"displays");
#line 283
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"version");
    }
  }
#line 291
  j = 0;
  {
#line 291
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 291
    if (! (j < 3)) {
#line 291
      goto while_break___8;
    }
    {
#line 293
    __cil_tmp26 = GrowBitfield(& (*up)->u_umask_w_bits[j], 0, maxusercount, (int )default_w_bit[j]);
    }
#line 293
    if (__cil_tmp26) {
      {
#line 296
      free((void *)((char *)*up));
#line 296
      *up = (struct acluser *)((void *)0);
      }
#line 296
      return (- 1);
    }
#line 298
    *((*up)->u_umask_w_bits[j] + ((*up)->u_id >> 3)) |= 128 >> ((*up)->u_id & 7);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 291
  j ++;
#line 303
  return (0);
}
}
#line 330 "/tmp/screen-3.9.15/acls.c"
int UserDel(char *name , struct acluser **up ) 
{ 
  struct acluser *u ;
  int i ;
  struct display *old ;
  struct display *next ;
  struct aclusergroup **g ;
  struct aclusergroup *next___36 ;
  char *tmp ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;

  {
#line 340
  if (! up) {
    {
#line 341
    up = FindUserPtr(name);
    }
  }
#line 342
  u = *up;
#line 342
  if (! u) {
#line 343
    return (- 1);
  }
#line 344
  old = display;
#line 345
  display = displays;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! display) {
#line 345
      goto while_break;
    }
#line 347
    next = display->d_next;
#line 348
    if (display->d_user != u) {
#line 349
      goto while_continue;
    }
#line 350
    if (display == old) {
#line 351
      old = (struct display *)((void *)0);
    }
    {
#line 352
    Detach(2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  display = next;
#line 354
  display = old;
#line 355
  *up = u->u_next;
#line 358
  up = & users;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! *up) {
#line 358
      goto while_break___0;
    }
#line 361
    g = & (*up)->u_group;
    {
#line 363
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 363
      if (! *g) {
#line 363
        goto while_break___1;
      }
#line 365
      if ((*g)->u == u) {
        {
#line 367
        next___36 = (*g)->next;
#line 369
        free((void *)((char *)*g));
#line 370
        *g = next___36;
        }
      } else {
#line 373
        g = & (*g)->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  up = & (*up)->u_next;
#line 376
  *(userbits + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
#line 378
  if ((int )default_w_bit[2]) {
#line 378
    tmp = (char *)"+r";
  } else {
#line 378
    tmp = (char *)"-r";
  }
  {
#line 378
  AclSetPerm((struct acluser *)((void *)0), u, tmp, (char *)"#");
  }
#line 379
  if ((int )default_w_bit[1]) {
#line 379
    tmp___37 = (char *)"+w";
  } else {
#line 379
    tmp___37 = (char *)"-w";
  }
  {
#line 379
  AclSetPerm((struct acluser *)((void *)0), u, tmp___37, (char *)"#");
  }
#line 380
  if ((int )default_w_bit[0]) {
#line 380
    tmp___38 = (char *)"+x";
  } else {
#line 380
    tmp___38 = (char *)"-x";
  }
  {
#line 380
  AclSetPerm((struct acluser *)((void *)0), u, tmp___38, (char *)"#");
  }
#line 381
  if ((int )default_c_bit[0]) {
#line 381
    tmp___39 = (char *)"+x";
  } else {
#line 381
    tmp___39 = (char *)"-x";
  }
  {
#line 381
  AclSetPerm((struct acluser *)((void *)0), u, tmp___39, (char *)"?");
#line 382
  i = 0;
  }
  {
#line 382
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 382
    if (! (i < 3)) {
#line 382
      goto while_break___2;
    }
    {
#line 383
    free((void *)((char *)u->u_umask_w_bits[i]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 382
  i ++;
  {
#line 385
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 385
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 387
  UserFreeCopyBuffer(u);
#line 389
  free((void *)((char *)u));
  }
#line 390
  if (! users) {
    {
#line 392
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 392
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 393
    Finit(0);
    }
  }
#line 395
  return (0);
}
}
#line 406 "/tmp/screen-3.9.15/acls.c"
int UserFreeCopyBuffer(struct acluser *u ) 
{ 
  struct win *w ;
  struct paster *pa ;

  {
#line 412
  if (! u->u_plop.buf) {
#line 413
    return (1);
  }
#line 414
  w = windows;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! w) {
#line 414
      goto while_break;
    }
#line 416
    pa = & w->w_paster;
#line 417
    if (pa->pa_pasteptr >= u->u_plop.buf) {
#line 417
      if (pa->pa_pasteptr - u->u_plop.buf < (long )u->u_plop.len) {
        {
#line 419
        FreePaster(pa);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  w = w->w_next;
#line 421
  free((void *)u->u_plop.buf);
#line 422
  u->u_plop.len = 0;
#line 423
  u->u_plop.buf = (char *)0;
  }
#line 424
  return (0);
}
}
#line 436 "/tmp/screen-3.9.15/acls.c"
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) 
{ 
  struct aclusergroup **g ;

  {
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if (! *gp) {
#line 444
      goto while_break___0;
    }
#line 446
    if ((*gp)->u == u) {
#line 447
      return (gp);
    }
    {
#line 448
    g = FindGroupPtr(& ((*gp)->u)->u_group, u, recursive + 1);
    }
#line 448
    if (recursive) {
#line 448
      if (*g) {
#line 450
        return (g);
      }
    }
#line 451
    gp = & (*gp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 453
  return (gp);
}
}
#line 462 "/tmp/screen-3.9.15/acls.c"
int AclLinkUser(char *from , char *to ) 
{ 
  struct acluser **u1 ;
  struct acluser **u2 ;
  struct aclusergroup **g ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  struct aclusergroup **__cil_tmp10 ;
  void *__cil_tmp12 ;

  {
  {
#line 468
  __cil_tmp7 = UserAdd(from, (char *)((void *)0), u1);
  }
  {
#line 468
  u1 = FindUserPtr(from);
  }
#line 468
  if (! *u1) {
#line 468
    if (__cil_tmp7) {
#line 469
      return (- 1);
    }
  }
  {
#line 470
  __cil_tmp9 = UserAdd(to, (char *)((void *)0), u2);
  }
  {
#line 470
  u2 = FindUserPtr(to);
  }
#line 470
  if (! *u2) {
#line 470
    if (__cil_tmp9) {
#line 471
      return (- 1);
    }
  }
  {
#line 473
  __cil_tmp10 = FindGroupPtr(& (*u2)->u_group, *u1, 1);
  }
#line 473
  if (*__cil_tmp10) {
#line 474
    return (1);
  }
  {
#line 475
  g = FindGroupPtr(& (*u1)->u_group, *u2, 0);
  }
#line 475
  if (*g) {
#line 476
    return (2);
  }
  {
#line 478
  __cil_tmp12 = malloc(sizeof(struct aclusergroup ));
#line 478
  *g = (struct aclusergroup *)__cil_tmp12;
  }
#line 478
  if (! *g) {
#line 479
    return (- 1);
  }
#line 480
  (*g)->u = *u2;
#line 481
  (*g)->next = (struct aclusergroup *)((void *)0);
#line 482
  return (0);
}
}
#line 491 "/tmp/screen-3.9.15/acls.c"
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) 
{ 
  struct acluser *u ;
  int sorry ;
  struct passwd *pp ;
  struct spwd *ss ;
  int t ;
  int c ;
  char *pass ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *tmp ;

  {
  {
#line 496
  sorry = 0;
#line 498
  u = (struct acluser *)FindUserPtr(name);
  }
#line 498
  if (! u) {
#line 499
    sorry ++;
  } else {
    {
#line 508
    pass = (char *)"";
#line 510
    pp = getpwnam((char const   *)name);
    }
#line 510
    if (! pp) {
      {
#line 512
      while (1) {
        while_continue: /* CIL Label */ ;
#line 512
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 513
      if (! ((pw1 && (int )*pw1) && (int )*pw1 != 4294967295U)) {
        {
#line 515
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 515
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 516
        sorry ++;
      }
    } else {
#line 520
      pass = pp->pw_passwd;
    }
#line 522
    t = 0;
    {
#line 522
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 522
      if (! (t < 13)) {
#line 522
        goto while_break___1;
      }
#line 524
      c = (int )*(pass + t);
#line 525
      if (! ((((c == 46 || c == 47) || (c >= 48 && c <= 57)) || (c >= 97 && c <= 122)) || (c >= 65 && c <= 90))) {
#line 529
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 522
    t ++;
#line 531
    if (t < 13) {
      {
#line 533
      ss = getspnam((char const   *)name);
      }
#line 533
      if (! ss) {
        {
#line 535
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 535
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 536
        sorry ++;
      } else {
#line 539
        pass = ss->sp_pwdp;
      }
    }
#line 543
    if (pw2) {
#line 543
      if ((int )*pw2) {
#line 543
        if ((int )*pw2 != 4294967295U) {
          {
#line 545
          __cil_tmp19 = crypt(pw2, pass);
#line 545
          __cil_tmp20 = strcmp((char const   *)__cil_tmp19, (char const   *)pass);
          }
#line 545
          if (! *pass) {
            _L: /* CIL Label */ 
            {
#line 548
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 548
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 549
            sorry ++;
          } else
#line 545
          if (__cil_tmp20) {
#line 545
            goto _L;
          }
        } else {
#line 543
          goto _L___40;
        }
      } else {
#line 543
        goto _L___40;
      }
    } else
    _L___40: /* CIL Label */ 
#line 553
    if (*pass) {
#line 554
      sorry ++;
    }
#line 556
    if (pw1) {
#line 556
      if ((int )*pw1) {
#line 556
        if ((int )*pw1 != 4294967295U) {
          {
#line 558
          __cil_tmp23 = crypt(pw1, u->u_password);
#line 558
          __cil_tmp24 = strcmp((char const   *)__cil_tmp23, (char const   *)u->u_password);
          }
#line 558
          if (! *(u->u_password)) {
            _L___42: /* CIL Label */ 
            {
#line 561
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 561
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 562
            sorry ++;
          } else
#line 558
          if (__cil_tmp24) {
#line 558
            goto _L___42;
          }
        } else {
#line 556
          goto _L___43;
        }
      } else {
#line 556
        goto _L___43;
      }
    } else
    _L___43: /* CIL Label */ 
#line 566
    if (*(u->u_password)) {
#line 567
      sorry ++;
    }
  }
  {
#line 570
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 570
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 571
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 571
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 576
  openlog((char const   *)((char *)"screen"), 1, 4 << 3);
  }
#line 578
  if (sorry) {
#line 578
    tmp = (char *)"failed";
  } else {
#line 578
    tmp = (char *)"succeded";
  }
  {
#line 578
  syslog(5, (char const   *)((char *)"%s: \"su %s\" %s for \"%s\""), (char *)SockPath,
         name, tmp, (char *)(*up)->u_name);
#line 580
  closelog();
  }
#line 585
  if (sorry) {
#line 586
    return ((char *)"Sorry.");
  } else {
#line 588
    *up = u;
  }
#line 589
  return ((char *)((void *)0));
}
}
#line 602 "/tmp/screen-3.9.15/acls.c"
int NewWindowAcl(struct win *w , struct acluser *u ) 
{ 
  int i ;
  int j ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 612
  __cil_tmp6 = GrowBitfield(& w->w_lio_notify, 0, maxusercount, 0);
  }
  {
#line 612
  __cil_tmp5 = GrowBitfield(& w->w_mon_notify, 0, maxusercount, 0);
  }
#line 612
  if (__cil_tmp5) {
#line 614
    return (- 1);
  } else
#line 612
  if (__cil_tmp6) {
#line 614
    return (- 1);
  }
#line 615
  j = 0;
  {
#line 615
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 615
    if (! (j < 3)) {
#line 615
      goto while_break___0;
    }
    {
#line 618
    __cil_tmp7 = GrowBitfield(& w->w_userbits[j], 0, maxusercount, 0);
    }
#line 618
    if (__cil_tmp7) {
      {
#line 620
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 620
        if (! (j >= 0)) {
#line 620
          goto while_break___1;
        }
        {
#line 621
        free((void *)((char *)w->w_userbits[j]));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 622
      free((void *)((char *)w->w_mon_notify));
#line 623
      free((void *)((char *)w->w_lio_notify));
      }
#line 624
      return (- 1);
    }
#line 626
    i = 0;
    {
#line 626
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 626
      if (! (i < maxusercount)) {
#line 626
        goto while_break___2;
      }
#line 627
      if (u) {
#line 627
        tmp = (128 >> (i & 7)) & (int )*(u->u_umask_w_bits[j] + (i >> 3));
      } else {
#line 627
        tmp = (int )default_w_bit[j];
      }
#line 627
      if (tmp) {
#line 629
        *(w->w_userbits[j] + (i >> 3)) |= 128 >> (i & 7);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 615
  j ++;
#line 631
  return (0);
}
}
#line 635 "/tmp/screen-3.9.15/acls.c"
void FreeWindowAcl(struct win *w ) 
{ 
  int i ;

  {
#line 640
  i = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (i < 3)) {
#line 640
      goto while_break;
    }
    {
#line 641
    free((void *)((char *)w->w_userbits[i]));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  i ++;
#line 642
  free((void *)((char *)w->w_mon_notify));
#line 643
  free((void *)((char *)w->w_lio_notify));
  }
}
}
#line 653 "/tmp/screen-3.9.15/acls.c"
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) 
{ 
  int neg ;
  char *m ;
  char *__cil_tmp6 ;

  {
#line 658
  neg = 0;
#line 659
  m = mode;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! *m) {
#line 661
      goto while_break;
    }
#line 663
    __cil_tmp6 = m;
#line 663
    m ++;
    {
#line 665
    if ((int )*__cil_tmp6 == '-') {
#line 665
      goto case_45;
    }
#line 668
    if ((int )*__cil_tmp6 == '+') {
#line 668
      goto case_43;
    }
#line 673
    if ((int )*__cil_tmp6 == 'x') {
#line 673
      goto case_120;
    }
#line 673
    if ((int )*__cil_tmp6 == 'e') {
#line 673
      goto case_120;
    }
#line 673
    if ((int )*__cil_tmp6 == 'a') {
#line 673
      goto case_120;
    }
#line 681
    if ((int )*__cil_tmp6 == 'w') {
#line 681
      goto case_119;
    }
#line 681
    if ((int )*__cil_tmp6 == 'r') {
#line 681
      goto case_119;
    }
#line 683
    goto switch_default;
    case_45: /* CIL Label */ 
#line 666
    neg = 1;
#line 667
    goto while_continue;
    case_43: /* CIL Label */ 
#line 669
    neg = 0;
#line 670
    goto while_continue;
    case_120: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 675
    if (neg) {
#line 676
      *(cmd->userbits[0] + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
    } else {
#line 678
      *(cmd->userbits[0] + (u->u_id >> 3)) |= 128 >> (u->u_id & 7);
    }
#line 679
    goto switch_break;
    case_119: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 682
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 684
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 698 "/tmp/screen-3.9.15/acls.c"
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) 
{ 
  int neg ;
  int bit ;
  int bits ;
  AclBits *bitarray ;
  char *m ;
  char *__cil_tmp10 ;
  int tmp ;
  int tmp___0 ;

  {
#line 703
  neg = 0;
#line 706
  m = mode;
#line 708
  if (uu) {
    {
#line 710
    while (1) {
      while_continue: /* CIL Label */ ;
#line 710
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 711
    bitarray = (AclBits *)uu->u_umask_w_bits;
  } else {
    {
#line 715
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 715
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    bitarray = (AclBits *)win->w_userbits;
    {
#line 717
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 717
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 720
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 720
    if (! *m) {
#line 720
      goto while_break___2;
    }
#line 722
    __cil_tmp10 = m;
#line 722
    m ++;
    {
#line 724
    if ((int )*__cil_tmp10 == '-') {
#line 724
      goto case_45;
    }
#line 727
    if ((int )*__cil_tmp10 == '+') {
#line 727
      goto case_43;
    }
#line 730
    if ((int )*__cil_tmp10 == 'r') {
#line 730
      goto case_114;
    }
#line 733
    if ((int )*__cil_tmp10 == 'w') {
#line 733
      goto case_119;
    }
#line 736
    if ((int )*__cil_tmp10 == 'x') {
#line 736
      goto case_120;
    }
#line 739
    if ((int )*__cil_tmp10 == 'a') {
#line 739
      goto case_97;
    }
#line 742
    goto switch_default;
    case_45: /* CIL Label */ 
#line 725
    neg = 1;
#line 726
    goto while_continue___2;
    case_43: /* CIL Label */ 
#line 728
    neg = 0;
#line 729
    goto while_continue___2;
    case_114: /* CIL Label */ 
#line 731
    bits = 1 << 2;
#line 732
    goto switch_break;
    case_119: /* CIL Label */ 
#line 734
    bits = 1 << 1;
#line 735
    goto switch_break;
    case_120: /* CIL Label */ 
#line 737
    bits = 1;
#line 738
    goto switch_break;
    case_97: /* CIL Label */ 
#line 740
    bits = (1 << 3) - 1;
#line 741
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 743
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
#line 745
    bit = 0;
    {
#line 745
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 745
      if (! (bit < 3)) {
#line 745
        goto while_break___3;
      }
#line 747
      if (! (bits & (1 << bit))) {
#line 748
        goto while_continue___3;
      }
#line 749
      if (neg) {
#line 750
        *(*(bitarray + bit) + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
      } else {
#line 752
        *(*(bitarray + bit) + (u->u_id >> 3)) |= 128 >> (u->u_id & 7);
      }
#line 753
      if (! uu) {
#line 753
        if (win->w_wlockuser == u) {
#line 753
          if (neg) {
#line 753
            if (bit == 1) {
              {
#line 755
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 755
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 756
              win->w_wlockuser = (struct acluser *)((void *)0);
#line 757
              if (win->w_wlock == 2) {
#line 758
                win->w_wlock = 1;
              }
            }
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 745
    bit ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 762
  if (uu) {
#line 762
    if ((int )u->u_name[0] == 63) {
#line 762
      if ((int )u->u_name[1] == 0) {
#line 768
        if (win) {
          {
#line 770
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 770
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 771
          bit = 0;
          {
#line 771
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 771
            if (! (bit < 3)) {
#line 771
              goto while_break___6;
            }
#line 772
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 772
              tmp = 1;
            } else {
#line 772
              tmp = 0;
            }
#line 772
            default_w_bit[bit] = (char )tmp;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 771
          bit ++;
        } else {
          {
#line 782
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 782
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 783
          bit = 0;
          {
#line 783
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 783
            if (! (bit < 1)) {
#line 783
              goto while_break___8;
            }
#line 784
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 784
              tmp___0 = 1;
            } else {
#line 784
              tmp___0 = 0;
            }
#line 784
            default_c_bit[bit] = (char )tmp___0;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 783
          bit ++;
        }
        {
#line 787
        UserDel((char *)u->u_name, (struct acluser **)((void *)0));
        }
      }
    }
  }
#line 789
  return (0);
}
}
#line 798 "/tmp/screen-3.9.15/acls.c"
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) 
{ 
  struct win *w ;
  int i ;
  char *p ;
  char ch ;
  int __cil_tmp9 ;
  char *__cil_tmp14 ;

  {
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 808
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 808
    if (! *s) {
#line 808
      goto while_break___0;
    }
    {
#line 812
    if ((int )*s == '*') {
#line 812
      goto case_42;
    }
#line 814
    if ((int )*s == '#') {
#line 814
      goto case_35;
    }
#line 822
    if ((int )*s == '?') {
#line 822
      goto case_63;
    }
#line 830
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 813
    __cil_tmp9 = AclSetPerm(uu, u, mode, (char *)"#?");
    }
#line 813
    return (__cil_tmp9);
    case_35: /* CIL Label */ 
#line 815
    if (uu) {
      {
#line 816
      AclSetPermWin(uu, u, mode, (struct win *)1);
      }
    } else {
#line 818
      w = windows;
      {
#line 818
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 818
        if (! w) {
#line 818
          goto while_break___1;
        }
        {
#line 819
        AclSetPermWin((struct acluser *)0, u, mode, w);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 818
      w = w->w_next;
    }
#line 820
    s ++;
#line 821
    goto switch_break;
    case_63: /* CIL Label */ 
#line 823
    if (uu) {
      {
#line 824
      AclSetPermWin(uu, u, mode, (struct win *)0);
      }
    } else {
#line 826
      i = 0;
      {
#line 826
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 826
        if (! (i <= 169)) {
#line 826
          goto while_break___2;
        }
        {
#line 827
        AclSetPermCmd(u, mode, & comms[i]);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 826
      i ++;
    }
#line 828
    s ++;
#line 829
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 831
    p = s;
    {
#line 831
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 831
      if (! ((((int )*p && (int )*p != 32) && (int )*p != 9) && (int )*p != 44)) {
#line 831
        goto while_break___3;
      }

    }
    while_break___3: /* CIL Label */ ;
    }
#line 831
    p ++;
#line 833
    ch = *p;
#line 833
    if (ch) {
#line 834
      __cil_tmp14 = p;
#line 834
      p ++;
#line 834
      *__cil_tmp14 = (char )'\000';
    }
    {
#line 835
    i = FindCommnr(s);
    }
#line 835
    if (i != -1) {
      {
#line 836
      AclSetPermCmd(u, mode, & comms[i]);
      }
    } else {
      {
#line 837
      i = WindowByNoN(s);
      }
#line 837
      if (i >= 0) {
#line 837
        if (wtab[i]) {
          {
#line 838
          AclSetPermWin((struct acluser *)0, u, mode, wtab[i]);
          }
        } else {
#line 841
          return (- 1);
        }
      } else {
#line 841
        return (- 1);
      }
    }
#line 842
    if (ch) {
#line 843
      *(p + - 1) = ch;
    }
#line 844
    s = p;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 847
  return (0);
}
}
#line 862 "/tmp/screen-3.9.15/acls.c"
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 867
  __cil_tmp6 = strcmp((char const   *)*(argv + 0), (char const   *)((char *)"nobody"));
  }
  {
#line 867
  __cil_tmp5 = strcmp((char const   *)((char *)(*u)->u_name), (char const   *)((char *)"nobody"));
  }
#line 867
  if (*u) {
#line 867
    if (! __cil_tmp5) {
#line 869
      return (- 1);
    } else {
#line 867
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 867
  if (argc > 1) {
#line 867
    if (! __cil_tmp6) {
#line 869
      return (- 1);
    }
  }
  {
#line 873
  if (argc == 4) {
#line 873
    goto case_4;
  }
#line 877
  if (argc == 3) {
#line 877
    goto case_3;
  }
#line 881
  if (argc == 2) {
#line 881
    goto case_2;
  }
#line 884
  if (argc == 1) {
#line 884
    goto case_1;
  }
#line 888
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  __cil_tmp8 = AclSetPerm(uu, *u, *(argv + 2), *(argv + 3));
  }
  {
#line 875
  __cil_tmp7 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 875
  return (__cil_tmp7 < 0 || __cil_tmp8);
  case_3: /* CIL Label */ 
  {
#line 878
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 878
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 879
  __cil_tmp10 = AclSetPerm(uu, *u, *(argv + 1), *(argv + 2));
  }
  {
#line 879
  __cil_tmp9 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 879
  return (__cil_tmp9 < 0 || __cil_tmp10);
  case_2: /* CIL Label */ 
  {
#line 882
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 882
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 883
  __cil_tmp11 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 883
  return (__cil_tmp11 < 0);
  case_1: /* CIL Label */ 
  {
#line 885
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 885
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 886
  __cil_tmp13 = AclSetPerm(uu, *u, (char *)"+a", (char *)"#?");
  }
  {
#line 886
  __cil_tmp12 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 886
  return (__cil_tmp12 < 0 || __cil_tmp13);
  switch_default: /* CIL Label */ 
#line 889
  return (- 1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 894 "/tmp/screen-3.9.15/acls.c"
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) 
{ 
  struct win *w ;
  int i ;
  int j ;
  int to_id ;
  int from_id ;

  {
#line 900
  if (! *to_up) {
#line 901
    return (- 1);
  } else
#line 900
  if (! *from_up) {
#line 901
    return (- 1);
  }
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 904
  from_id = (*from_up)->u_id;
#line 904
  to_id = (*to_up)->u_id;
#line 904
  if (to_id == from_id) {
#line 905
    return (- 1);
  }
#line 906
  w = windows;
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 906
    if (! w) {
#line 906
      goto while_break___0;
    }
#line 908
    i = 0;
    {
#line 908
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 908
      if (! (i < 3)) {
#line 908
        goto while_break___1;
      }
#line 910
      if ((int )*(w->w_userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 911
        *(w->w_userbits[i] + (to_id >> 3)) |= 128 >> (to_id & 7);
      } else {
#line 914
        *(w->w_userbits[i] + (to_id >> 3)) &= ~ (128 >> (to_id & 7));
#line 915
        if (w->w_wlockuser == *to_up) {
#line 915
          if (i == 1) {
            {
#line 917
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 917
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 919
            w->w_wlockuser = (struct acluser *)((void *)0);
#line 920
            if (w->w_wlock == 2) {
#line 921
              w->w_wlock = 1;
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 908
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 906
  w = w->w_next;
#line 926
  j = 0;
  {
#line 926
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 926
    if (! (j <= 169)) {
#line 926
      goto while_break___3;
    }
#line 928
    i = 0;
    {
#line 928
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 928
      if (! (i < 1)) {
#line 928
        goto while_break___4;
      }
#line 930
      if ((int )*(comms[j].userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 931
        *(comms[j].userbits[i] + (to_id >> 3)) |= 128 >> (to_id & 7);
      } else {
#line 933
        *(comms[j].userbits[i] + (to_id >> 3)) &= ~ (128 >> (to_id & 7));
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 928
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 926
  j ++;
#line 937
  return (0);
}
}
#line 949 "/tmp/screen-3.9.15/acls.c"
int UsersAcl(struct acluser *uu , int argc , char **argv ) 
{ 
  char *s ;
  int r ;
  struct acluser **cf_u ;
  char *p ;
  char *__cil_tmp8 ;
  struct acluser **u ;
  int __cil_tmp11 ;
  int tmp ;
  char *__cil_tmp16 ;
  int tmp___0 ;
  struct acluser **__cil_tmp18 ;
  int __cil_tmp19 ;
  struct acluser **__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___45 ;

  {
#line 956
  cf_u = (struct acluser **)((void *)0);
#line 958
  if (argc == 1) {
#line 960
    p = (char *)((void *)0);
#line 962
    s = *(argv + 0);
    {
#line 963
    while (1) {
      while_continue: /* CIL Label */ ;
#line 963
      if (! *s) {
#line 963
        goto while_break;
      }
#line 964
      __cil_tmp8 = s;
#line 964
      s ++;
#line 964
      if ((int )*__cil_tmp8 == 61) {
#line 964
        p = s;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 965
    if (p) {
      {
#line 967
      *(p + - 1) = (char )'\000';
#line 968
      cf_u = FindUserPtr(p);
      }
    }
  }
#line 972
  if ((int )*(*(argv + 0) + 0) == 42) {
#line 972
    if ((int )*(*(argv + 0) + 1) == 0) {
      {
#line 976
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 976
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 977
      u = & users;
      {
#line 977
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 977
        if (! *u) {
#line 977
          goto while_break___1;
        }
#line 978
        if (cf_u) {
          {
#line 978
          r = UserAclCopy(u, cf_u);
#line 978
          tmp = r < 0;
          }
        } else {
          {
#line 978
          r = UserAcl(uu, u, argc, argv);
#line 978
          tmp = r < 0;
          }
        }
        {
#line 978
        __cil_tmp11 = strcmp((char const   *)((char *)"nobody"), (char const   *)((char *)(*u)->u_name));
        }
#line 978
        if (__cil_tmp11) {
#line 978
          if (tmp) {
#line 982
            return (- 1);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 977
      u = & (*u)->u_next;
#line 983
      return (0);
    }
  }
  {
#line 986
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 988
    s = *(argv + 0);
    {
#line 988
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 988
      if (! (((((int )*s && (int )*s != 32) && (int )*s != 9) && (int )*s != 44) && (int )*s != 61)) {
#line 988
        goto while_break___3;
      }

    }
    while_break___3: /* CIL Label */ ;
    }
#line 988
    s ++;
#line 990
    if ((int )*s) {
#line 990
      __cil_tmp16 = s;
#line 990
      s ++;
#line 990
      *__cil_tmp16 = (char )'\000';
#line 990
      tmp___0 = (int )*__cil_tmp16;
    } else {
#line 990
      *s = (char )'\000';
#line 990
      tmp___0 = (int )*s;
    }
    {
#line 991
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 991
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 992
    if (cf_u) {
      {
#line 992
      __cil_tmp18 = FindUserPtr(*(argv + 0));
#line 992
      __cil_tmp19 = UserAclCopy(__cil_tmp18, cf_u);
#line 992
      r = __cil_tmp19;
#line 992
      tmp___45 = r < 0;
      }
    } else {
      {
#line 992
      __cil_tmp20 = FindUserPtr(*(argv + 0));
#line 992
      __cil_tmp21 = UserAcl(uu, __cil_tmp20, argc, argv);
#line 992
      r = __cil_tmp21;
#line 992
      tmp___45 = r < 0;
      }
    }
#line 992
    if (tmp___45) {
#line 995
      return (- 1);
    }
#line 986
    if (! *(*(argv + 0))) {
#line 986
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 997
  return (0);
}
}
#line 1010 "/tmp/screen-3.9.15/acls.c"
int AclUmask(struct acluser *u , char *str , char **errp ) 
{ 
  char mode[16] ;
  char *av[3] ;
  char *p ;
  char c ;
  int __cil_tmp9 ;
  char *tmp ;
  int __cil_tmp12 ;

  {
#line 1017
  c = (char )'\000';
#line 1020
  p = str;
  {
#line 1020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    if (! *p) {
#line 1020
      goto while_break;
    }
#line 1021
    c = *p;
#line 1021
    if ((int )c == 43) {
#line 1022
      goto while_break;
    } else
#line 1021
    if ((int )c == 45) {
#line 1022
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1020
  p ++;
#line 1023
  if (! *p) {
#line 1025
    *errp = (char *)"Bad argument. Should be ``[user[,user...]{+|-}rwxn\'\'.";
#line 1026
    return (- 1);
  }
  {
#line 1028
  strncpy((char *)mode, (char const   *)p, (unsigned long )15);
#line 1029
  mode[15] = (char )'\000';
#line 1030
  *p = (char )'\000';
#line 1033
  __cil_tmp9 = strcmp((char const   *)((char *)"??"), (char const   *)str);
  }
#line 1033
  if (! __cil_tmp9) {
#line 1035
    str ++;
#line 1036
    av[2] = (char *)"?";
  } else {
#line 1039
    av[2] = (char *)"#";
  }
#line 1040
  av[1] = (char *)mode;
#line 1041
  if ((int )*str) {
#line 1041
    tmp = str;
  } else {
#line 1041
    tmp = (char *)"*";
  }
  {
#line 1041
  av[0] = tmp;
#line 1043
  __cil_tmp12 = UsersAcl(u, 3, (char **)av);
  }
#line 1043
  if (__cil_tmp12) {
#line 1045
    *errp = (char *)"UsersAcl failed. Hmmm.";
#line 1046
    *p = c;
#line 1047
    return (- 1);
  }
#line 1049
  *p = c;
#line 1050
  return (0);
}
}
#line 1054 "/tmp/screen-3.9.15/acls.c"
void AclWinSwap(int a , int b ) 
{ 


  {
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1060 "/tmp/screen-3.9.15/acls.c"
struct acluser *EffectiveAclUser  =    (struct acluser *)((void *)0);
#line 1063 "/tmp/screen-3.9.15/acls.c"
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int __cil_tmp7 ;

  {
#line 1070
  if (mode < 0) {
#line 1071
    return (- 1);
  } else
#line 1070
  if (mode >= 3) {
#line 1071
    return (- 1);
  }
#line 1072
  if (EffectiveAclUser) {
    {
#line 1074
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1074
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1075
    u = EffectiveAclUser;
  }
#line 1077
  ok = (int )*(w->w_userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1078
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1078
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1080
  if (! ok) {
#line 1082
    g = & u->u_group;
#line 1083
    saved_eff = EffectiveAclUser;
#line 1085
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1086
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1086
      if (! *g) {
#line 1086
        goto while_break___1;
      }
      {
#line 1088
      __cil_tmp7 = AclCheckPermWin((*g)->u, mode, w);
      }
#line 1088
      if (! __cil_tmp7) {
#line 1089
        goto while_break___1;
      }
#line 1090
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1092
    EffectiveAclUser = saved_eff;
#line 1093
    if (*g) {
#line 1094
      ok = 1;
    }
  }
  {
#line 1096
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1096
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1097
  return (! ok);
}
}
#line 1101 "/tmp/screen-3.9.15/acls.c"
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int __cil_tmp7 ;

  {
#line 1108
  if (mode < 0) {
#line 1109
    return (- 1);
  } else
#line 1108
  if (mode >= 1) {
#line 1109
    return (- 1);
  }
#line 1110
  if (EffectiveAclUser) {
    {
#line 1112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1112
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1113
    u = EffectiveAclUser;
  }
#line 1115
  ok = (int )*(c->userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1116
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1117
  if (! ok) {
#line 1119
    g = & u->u_group;
#line 1120
    saved_eff = EffectiveAclUser;
#line 1122
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1123
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1123
      if (! *g) {
#line 1123
        goto while_break___1;
      }
      {
#line 1125
      __cil_tmp7 = AclCheckPermCmd((*g)->u, mode, c);
      }
#line 1125
      if (! __cil_tmp7) {
#line 1126
        goto while_break___1;
      }
#line 1127
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1129
    EffectiveAclUser = saved_eff;
#line 1130
    if (*g) {
#line 1131
      ok = 1;
    }
  }
  {
#line 1133
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1133
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1134
  return (! ok);
}
}
#line 9 "/tmp/screen-3.9.15/kmapdef.c"
char *kmapdef[]  = 
#line 9 "/tmp/screen-3.9.15/kmapdef.c"
  {      (char *)"\033[10~",      (char *)"\033OP",      (char *)"\033OQ",      (char *)"\033OR", 
        (char *)"\033OS",      (char *)"\033[15~",      (char *)"\033[17~",      (char *)"\033[18~", 
        (char *)"\033[19~",      (char *)"\033[20~",      (char *)"\033[21~",      (char *)"\033[23~", 
        (char *)"\033[24~",      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)"\033[1~", 
        (char *)0,      (char *)"\033[4~",      (char *)0,      (char *)"\033[6~", 
        (char *)"\033[5~",      (char *)"\033[2~",      (char *)"\033[3~",      (char *)"\033[A", 
        (char *)"\033[B",      (char *)"\033[C",      (char *)"\033[D",      (char *)"0", 
        (char *)"1",      (char *)"2",      (char *)"3",      (char *)"4", 
        (char *)"5",      (char *)"6",      (char *)"7",      (char *)"8", 
        (char *)"9",      (char *)"+",      (char *)"-",      (char *)"*", 
        (char *)"/",      (char *)"=",      (char *)".",      (char *)",", 
        (char *)"\r"};
#line 81 "/tmp/screen-3.9.15/kmapdef.c"
char *kmapadef[]  = 
#line 81
  {      (char *)"\033OA",      (char *)"\033OB",      (char *)"\033OC",      (char *)"\033OD", 
        (char *)"\033Op",      (char *)"\033Oq",      (char *)"\033Or",      (char *)"\033Os", 
        (char *)"\033Ot",      (char *)"\033Ou",      (char *)"\033Ov",      (char *)"\033Ow", 
        (char *)"\033Ox",      (char *)"\033Oy",      (char *)"\033Ok",      (char *)"\033Om", 
        (char *)"\033Oj",      (char *)"\033Oo",      (char *)"\033OX",      (char *)"\033On", 
        (char *)"\033Ol",      (char *)"\033OM"};
#line 106 "/tmp/screen-3.9.15/kmapdef.c"
char *kmapmdef[]  = 
#line 106
  {      (char *)"\004",      (char *)0,      (char *)0,      (char *)"\025", 
        (char *)0,      (char *)0,      (char *)0,      (char *)"\201", 
        (char *)0,      (char *)"\205",      (char *)0,      (char *)"\006", 
        (char *)"\002",      (char *)0,      (char *)0,      (char *)"\220", 
        (char *)"\216",      (char *)"\206",      (char *)"\202"};
#line 44 "/tmp/screen-3.9.15/comm.c"
struct comm comms[170]  = 
#line 44 "/tmp/screen-3.9.15/comm.c"
  {      {(char *)"acladd", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"aclchg", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"acldel", 1, {(AclBits )0}}, 
        {(char *)"aclgrp", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"aclumask", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"activity", 1, {(AclBits )0}}, 
        {(char *)"addacl", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"allpartial", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"altscreen", 1 << 2, {(AclBits )0}}, 
        {(char *)"at", ((1 << 7) | 2) | (1 << 5), {(AclBits )0}}, 
        {(char *)"attrcolor", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"autodetach", 1, {(AclBits )0}}, 
        {(char *)"autonuke", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"backtick", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"bce", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"bell", 1 << 2, {(AclBits )0}}, 
        {(char *)"bell_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"bind", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"bindkey", 1 << 5, {(AclBits )0}}, 
        {(char *)"break", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"breaktype", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"bufferfile", 1 << 2, {(AclBits )0}}, 
        {(char *)"c1", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"caption", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"chacl", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"charset", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"chdir", 1 << 2, {(AclBits )0}}, 
        {(char *)"clear", 1 << 6, {(AclBits )0}}, 
        {(char *)"colon", (1 << 8) | (1 << 2), {(AclBits )0}}, 
        {(char *)"command", (1 << 7) | (1 << 3), {(AclBits )0}}, 
        {(char *)"compacthist", 1 << 2, {(AclBits )0}}, 
        {(char *)"console", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"copy", 1 << 6, {(AclBits )0}}, 
        {(char *)"crlf", 1 << 2, {(AclBits )0}}, 
        {(char *)"debug", 1 << 2, {(AclBits )0}}, 
        {(char *)"defautonuke", 1, {(AclBits )0}}, 
        {(char *)"defbce", 1, {(AclBits )0}}, 
        {(char *)"defbreaktype", 1 << 2, {(AclBits )0}}, 
        {(char *)"defc1", 1, {(AclBits )0}}, 
        {(char *)"defcharset", 1 << 2, {(AclBits )0}}, 
        {(char *)"defencoding", 1, {(AclBits )0}}, 
        {(char *)"defescape", 1, {(AclBits )0}}, 
        {(char *)"defflow", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"defgr", 1, {(AclBits )0}}, 
        {(char *)"defhstatus", 1 << 2, {(AclBits )0}}, 
        {(char *)"defkanji", 1, {(AclBits )0}}, 
        {(char *)"deflog", 1, {(AclBits )0}}, 
        {(char *)"deflogin", 1, {(AclBits )0}}, 
        {(char *)"defmode", 1, {(AclBits )0}}, 
        {(char *)"defmonitor", 1, {(AclBits )0}}, 
        {(char *)"defobuflimit", 1, {(AclBits )0}}, 
        {(char *)"defscrollback", 1, {(AclBits )0}}, 
        {(char *)"defshell", 1, {(AclBits )0}}, 
        {(char *)"defsilence", 1, {(AclBits )0}}, 
        {(char *)"defslowpaste", 1, {(AclBits )0}}, 
        {(char *)"defutf8", 1, {(AclBits )0}}, 
        {(char *)"defwrap", 1, {(AclBits )0}}, 
        {(char *)"defwritelock", 1, {(AclBits )0}}, 
        {(char *)"detach", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"digraph", (1 << 8) | (1 << 2), {(AclBits )0}}, 
        {(char *)"dinfo", 1 << 7, {(AclBits )0}}, 
        {(char *)"displays", 1 << 8, {(AclBits )0}}, 
        {(char *)"dumptermcap", 1 << 6, {(AclBits )0}}, 
        {(char *)"echo", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"encoding", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"escape", 1, {(AclBits )0}}, 
        {(char *)"eval", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"exec", (1 << 6) | (1 << 5), {(AclBits )0}}, 
        {(char *)"fit", 1 << 7, {(AclBits )0}}, 
        {(char *)"flow", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"focus", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"gr", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"hardcopy", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"hardcopy_append", 1, {(AclBits )0}}, 
        {(char *)"hardcopydir", 1 << 2, {(AclBits )0}}, 
        {(char *)"hardstatus", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"height", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"help", (1 << 8) | (1 << 3), {(AclBits )0}}, 
        {(char *)"history", (1 << 7) | (1 << 6), {(AclBits )0}}, 
        {(char *)"hstatus", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"ignorecase", 1 << 2, {(AclBits )0}}, 
        {(char *)"info", 1 << 8, {(AclBits )0}}, 
        {(char *)"kanji", (1 << 6) | (1 | (1 << 2)), {(AclBits )0}}, 
        {(char *)"kill", 1 << 6, {(AclBits )0}}, 
        {(char *)"lastmsg", 1 << 7, {(AclBits )0}}, 
        {(char *)"license", 1 << 8, {(AclBits )0}}, 
        {(char *)"lockscreen", 1 << 7, {(AclBits )0}}, 
        {(char *)"log", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"logfile", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"login", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"logtstamp", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"mapdefault", 1 << 7, {(AclBits )0}}, 
        {(char *)"mapnotnext", 1 << 7, {(AclBits )0}}, 
        {(char *)"maptimeout", 1 << 2, {(AclBits )0}}, 
        {(char *)"markkeys", 1, {(AclBits )0}}, 
        {(char *)"maxwin", 1, {(AclBits )0}}, 
        {(char *)"meta", 1 << 8, {(AclBits )0}}, 
        {(char *)"monitor", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"msgminwait", 1, {(AclBits )0}}, 
        {(char *)"msgwait", 1, {(AclBits )0}}, 
        {(char *)"multiuser", 1, {(AclBits )0}}, 
        {(char *)"nethack", 1, {(AclBits )0}}, 
        {(char *)"next", 0, {(AclBits )0}}, 
        {(char *)"nonblock", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"number", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"obuflimit", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"only", 1 << 7, {(AclBits )0}}, 
        {(char *)"other", 0, {(AclBits )0}}, 
        {(char *)"partial", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"password", 1 << 2, {(AclBits )0}}, 
        {(char *)"paste", (1 << 8) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"pastefont", 1 << 2, {(AclBits )0}}, 
        {(char *)"pow_break", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"pow_detach", 1 << 7, {(AclBits )0}}, 
        {(char *)"pow_detach_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"prev", 0, {(AclBits )0}}, 
        {(char *)"printcmd", 1 << 2, {(AclBits )0}}, 
        {(char *)"process", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"quit", 0, {(AclBits )0}}, 
        {(char *)"readbuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"readreg", 1 << 5, {(AclBits )0}}, 
        {(char *)"redisplay", 1 << 7, {(AclBits )0}}, 
        {(char *)"register", 2 | (1 << 3), {(AclBits )0}}, 
        {(char *)"remove", 1 << 7, {(AclBits )0}}, 
        {(char *)"removebuf", 0, {(AclBits )0}}, 
        {(char *)"reset", 1 << 6, {(AclBits )0}}, 
        {(char *)"resize", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"screen", 1 << 5, {(AclBits )0}}, 
        {(char *)"scrollback", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"select", 1 << 2, {(AclBits )0}}, 
        {(char *)"sessionname", 1 << 2, {(AclBits )0}}, 
        {(char *)"setenv", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"setsid", 1, {(AclBits )0}}, 
        {(char *)"shell", 1, {(AclBits )0}}, 
        {(char *)"shelltitle", 1, {(AclBits )0}}, 
        {(char *)"silence", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"silencewait", 1, {(AclBits )0}}, 
        {(char *)"sleep", 1, {(AclBits )0}}, 
        {(char *)"slowpaste", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"sorendition", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"source", 1, {(AclBits )0}}, 
        {(char *)"split", 1 << 7, {(AclBits )0}}, 
        {(char *)"startup_message", 1, {(AclBits )0}}, 
        {(char *)"stuff", (1 << 8) | (1 | (1 << 2)), {(AclBits )0}}, 
        {(char *)"su", (1 << 7) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"suspend", 1 << 7, {(AclBits )0}}, 
        {(char *)"term", 1, {(AclBits )0}}, 
        {(char *)"termcap", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"termcapinfo", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"terminfo", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"time", 1 << 2, {(AclBits )0}}, 
        {(char *)"title", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"umask", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"unsetenv", 1, {(AclBits )0}}, 
        {(char *)"utf8", (1 << 6) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"vbell", 1 << 2, {(AclBits )0}}, 
        {(char *)"vbell_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"vbellwait", 1, {(AclBits )0}}, 
        {(char *)"verbose", 1 << 2, {(AclBits )0}}, 
        {(char *)"version", 0, {(AclBits )0}}, 
        {(char *)"wall", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"width", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"windowlist", (1 << 7) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"windows", 1 << 7, {(AclBits )0}}, 
        {(char *)"wrap", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"writebuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"writelock", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"xoff", 1 << 8, {(AclBits )0}}, 
        {(char *)"xon", 1 << 8, {(AclBits )0}}, 
        {(char *)"zombie", 1 << 2, {(AclBits )0}}};
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 447
extern unsigned int sleep(unsigned int __seconds ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 38 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios *__termios_p ) ;
#line 90
extern  __attribute__((__nothrow__)) int tcflush(int __fd , int __queue_selector ) ;
#line 79 "./osdef.h"
void xtputs(char *str , int affcnt , int (*outc)(int  ) ) ;
#line 80
extern char *tgoto(char * , int  , int  ) ;
#line 35 "./extern.h"
void Hangup(void) ;
#line 44
void DisplaySleep(int n , int eat ) ;
#line 48
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) ;
#line 65
void WindowChanged(struct win *p , int what ) ;
#line 85
void SetTTY(int fd , struct mode *mp ) ;
#line 96
struct baud_values *lookup_baud(int baud ) ;
#line 175
void ProcessInput(char *ibuf , int ilen ) ;
#line 177
void ProcessInput2(char *ibuf , int ilen ) ;
#line 206
void ApplyAttrColor(int i , struct mchar *mc ) ;
#line 218
void FreeTransTable(void) ;
#line 227
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) ;
#line 228
void FreeDisplay(void) ;
#line 229
void DefProcess(char **bufp , int *lenp ) ;
#line 230
void DefRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 231
void DefClearLine(int y , int xs , int xe , int bce ) ;
#line 232
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) ;
#line 233
int DefResize(int wi , int he ) ;
#line 234
void DefRestore(void) ;
#line 235
void AddCStr(char *s ) ;
#line 236
void AddCStr2(char *s , int c ) ;
#line 237
void InitTerm(int adapt ) ;
#line 238
void FinitTerm(void) ;
#line 239
void PUTCHAR(int c ) ;
#line 241
void ClearAll(void) ;
#line 244
void RefreshAll(int isblank ) ;
#line 246
void RefreshLine(int y , int from , int to , int isblank ) ;
#line 247
void Redisplay(int cur_only ) ;
#line 248
void RedisplayDisplays(int cur_only ) ;
#line 249
void ShowHStatus(char *str ) ;
#line 250
void RefreshHStatus(void) ;
#line 253
int CalcCost(char *s ) ;
#line 259
void ChangeScrollRegion(int newtop , int newbot ) ;
#line 260
void InsertMode(int on ) ;
#line 263
void ReverseVideo(int on ) ;
#line 266
void SetFont(int new ) ;
#line 267
void SetAttr(int new ) ;
#line 268
void SetColor(int f , int b ) ;
#line 270
void SetRenditionMline(struct mline *ml , int x ) ;
#line 273
int ResizeDisplay(int wi , int he ) ;
#line 274
void AddStr(char *str ) ;
#line 275
void AddStrn(char *str , int n ) ;
#line 276
void Flush(void) ;
#line 277
void freetty(void) ;
#line 280
void NukePending(void) ;
#line 282
void SetCanvasWindow(struct canvas *cv , struct win *wi ) ;
#line 283
int MakeDefaultCanvas(void) ;
#line 284
int AddCanvas(void) ;
#line 285
void RemCanvas(void) ;
#line 286
void OneCanvas(void) ;
#line 287
int RethinkDisplayViewports(void) ;
#line 288
void RethinkViewportOffsets(struct canvas *cv ) ;
#line 294
int color256to16(int jj ) ;
#line 302
void ChangeScreenSize(int wi , int he , int change_fore ) ;
#line 303
void CheckScreenSize(int change_flag ) ;
#line 305
void ResizeLayersToCanvases(void) ;
#line 36 "/tmp/screen-3.9.15/display.c"
static int CountChars(int c ) ;
#line 37
static int DoAddChar(int c ) ;
#line 38
static int BlankResize(int wi , int he ) ;
#line 39
static int CallRewrite(int y , int xs , int xe , int doit ) ;
#line 40
static void FreeCanvas(struct canvas *cv ) ;
#line 41
static void disp_readev_fn(struct event *ev , char *data ) ;
#line 42
static void disp_writeev_fn(struct event *ev , char *data ) ;
#line 43
static void disp_status_fn(struct event *ev , char *data ) ;
#line 44
static void disp_hstatus_fn(struct event *ev , char *data ) ;
#line 45
static void cv_winid_fn(struct event *ev , char *data ) ;
#line 47
static void disp_map_fn(struct event *ev , char *data ) ;
#line 49
static void WriteLP(int x2 , int y2 ) ;
#line 50
static void INSERTCHAR(int c ) ;
#line 51
static void RAW_PUTCHAR(int c ) ;
#line 53
static void SetBackColor(int new ) ;
#line 61
int use_hardstatus ;
#line 62
int MsgWait ;
#line 62
int MsgMinWait ;
#line 63
int Z0width ;
#line 63
int Z1width ;
#line 65
struct mline mline_old ;
#line 66
struct mchar mchar_null ;
#line 66
struct mchar mchar_so ;
#line 67
struct NewWindow nwin_default ;
#line 70
char *hstatusstring ;
#line 71
char *captionstring ;
#line 73
int pastefont ;
#line 81
extern short ospeed ;
#line 86
int attr2color[8][4] ;
#line 87
int nattr2color ;
#line 97 "/tmp/screen-3.9.15/display.c"
int defobuflimit  =    256;
#line 99 "/tmp/screen-3.9.15/display.c"
int defautonuke  =    0;
#line 101
int captionalways ;
#line 102 "/tmp/screen-3.9.15/display.c"
int hardstatusemu  =    0;
#line 109 "/tmp/screen-3.9.15/display.c"
void DefProcess(char **bufp , int *lenp ) 
{ 


  {
#line 113
  *bufp += *lenp;
#line 114
  *lenp = 0;
}
}
#line 118 "/tmp/screen-3.9.15/display.c"
void DefRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 121
  if (isblank == 0) {
#line 121
    if (y >= 0) {
      {
#line 122
      DefClearLine(y, xs, xe, 0);
      }
    }
  }
}
}
#line 126 "/tmp/screen-3.9.15/display.c"
void DefClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
  {
#line 129
  LClearLine(flayer, y, xs, xe, bce, (struct mline *)0);
  }
}
}
#line 134 "/tmp/screen-3.9.15/display.c"
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) 
{ 


  {
#line 138
  return (1000);
}
}
#line 143 "/tmp/screen-3.9.15/display.c"
int DefResize(int wi , int he ) 
{ 


  {
#line 146
  return (- 1);
}
}
#line 150 "/tmp/screen-3.9.15/display.c"
void DefRestore(void) 
{ 
  struct display *olddisplay ;
  struct canvas *cv ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    olddisplay = display;
#line 152
    display = displays;
    {
#line 152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 152
      if (! display) {
#line 152
        goto while_break___0;
      }
#line 152
      cv = display->d_cvlist;
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        if (! cv) {
#line 152
          goto while_break___1;
        }
#line 152
        if (cv->c_layer == flayer) {
#line 152
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 152
      cv = cv->c_next;
#line 152
      if (cv == (struct canvas *)0) {
#line 152
        goto while_continue___0;
      }
      {
#line 152
      InsertMode(0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 152
    display = display->d_next;
#line 152
    display = olddisplay;
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  LKeypadMode(flayer, 0);
#line 155
  LCursorkeysMode(flayer, 0);
#line 156
  LCursorVisibility(flayer, 0);
#line 157
  LMouseMode(flayer, 0);
#line 158
  LSetRendition(flayer, & mchar_null);
#line 159
  LSetFlow(flayer, nwin_default.flowflag & 1);
  }
}
}
#line 166 "/tmp/screen-3.9.15/display.c"
struct LayFuncs BlankLf  =    {(void (*)(char ** , int * ))DefProcess, (void (*)(void))0, (void (*)(int  , int  ,
                                                                         int  , int  ))DefRedisplayLine,
    (void (*)(int  , int  , int  , int  ))DefClearLine, (int (*)(int  , int  , int  ,
                                                                 struct mchar * ,
                                                                 int  ))DefRewrite,
    BlankResize, DefRestore};
#line 179 "/tmp/screen-3.9.15/display.c"
static int BlankResize(int wi , int he ) 
{ 


  {
#line 182
  flayer->l_width = wi;
#line 183
  flayer->l_height = he;
#line 184
  return (0);
}
}
#line 195 "/tmp/screen-3.9.15/display.c"
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) 
{ 
  struct acluser **u ;
  struct baud_values *b ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  speed_t __cil_tmp12 ;
  struct baud_values *__cil_tmp13 ;

  {
  {
#line 203
  __cil_tmp10 = UserAdd(uname, (char *)0, u);
  }
  {
#line 203
  u = FindUserPtr(uname);
  }
#line 203
  if (! *u) {
#line 203
    if (__cil_tmp10) {
#line 204
      return ((struct display *)0);
    }
  }
  {
#line 207
  __cil_tmp11 = calloc((unsigned long )1, sizeof(*display));
#line 207
  display = (struct display *)__cil_tmp11;
  }
#line 207
  if (display == (struct display *)0) {
#line 208
    return ((struct display *)0);
  }
  {
#line 215
  display->d_next = displays;
#line 216
  displays = display;
#line 217
  display->d_flow = 1;
#line 218
  display->d_nonblock = (char )0;
#line 219
  display->d_userfd = fd;
#line 220
  display->d_writeev.fd = fd;
#line 220
  display->d_readev.fd = display->d_writeev.fd;
#line 221
  display->d_readev.type = 1;
#line 222
  display->d_writeev.type = 2;
#line 223
  display->d_writeev.data = (char *)display;
#line 223
  display->d_readev.data = display->d_writeev.data;
#line 224
  display->d_readev.handler = disp_readev_fn;
#line 225
  display->d_writeev.handler = disp_writeev_fn;
#line 226
  evenq(& display->d_readev);
#line 227
  display->d_writeev.condpos = & display->d_obuflen;
#line 228
  display->d_writeev.condneg = & display->d_obuffree;
#line 229
  evenq(& display->d_writeev);
#line 230
  display->d_statusev.type = 0;
#line 231
  display->d_statusev.data = (char *)display;
#line 232
  display->d_statusev.handler = disp_status_fn;
#line 233
  display->d_hstatusev.type = 0;
#line 234
  display->d_hstatusev.data = (char *)display;
#line 235
  display->d_hstatusev.handler = disp_hstatus_fn;
#line 237
  display->d_mapev.type = 0;
#line 238
  display->d_mapev.data = (char *)display;
#line 239
  display->d_mapev.handler = disp_map_fn;
#line 241
  display->d_OldMode = *Mode;
#line 242
  display->d_status_obuffree = - 1;
#line 243
  Resize_obuf();
#line 244
  display->d_obufmax = defobuflimit;
#line 245
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 247
  display->d_auto_nuke = defautonuke;
#line 249
  display->d_obufp = display->d_obuf;
#line 250
  display->d_printfd = - 1;
#line 251
  display->d_userpid = pid;
#line 254
  __cil_tmp12 = cfgetospeed(& display->d_OldMode.tio);
#line 254
  __cil_tmp13 = lookup_baud((int )__cil_tmp12);
#line 254
  b = __cil_tmp13;
  }
#line 254
  if (b) {
#line 255
    display->d_dospeed = (short )b->idx;
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  strncpy((char *)display->d_usertty, (char const   *)utty, sizeof(display->d_usertty) - 1UL);
#line 267
  display->d_usertty[sizeof(display->d_usertty) - 1UL] = (char )0;
#line 268
  strncpy((char *)display->d_termname, (char const   *)term___0, sizeof(display->d_termname) - 1UL);
#line 269
  display->d_termname[sizeof(display->d_termname) - 1UL] = (char )0;
#line 270
  display->d_user = *u;
#line 271
  display->d_processinput = ProcessInput;
  }
#line 272
  return (display);
}
}
#line 277 "/tmp/screen-3.9.15/display.c"
void FreeDisplay(void) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct canvas *cvp ;
  struct display *d ;
  struct display **dp ;

  {
  {
#line 286
  FreeTransTable();
  }
#line 288
  if (display->d_userfd >= 0) {
    {
#line 290
    Flush();
    }
#line 291
    if (! display) {
#line 292
      return;
    }
    {
#line 293
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 294
    fcntl(display->d_userfd, 4, 0);
    }
  }
  {
#line 296
  freetty();
  }
#line 297
  if (display->d_tentry) {
    {
#line 298
    free((void *)display->d_tentry);
    }
  }
#line 299
  display->d_tentry = (char *)0;
#line 300
  if (display->d_processinputdata) {
    {
#line 301
    free((void *)display->d_processinputdata);
    }
  }
  {
#line 302
  display->d_processinputdata = (char *)0;
#line 303
  display->d_tcinited = (char )0;
#line 304
  evdeq(& display->d_hstatusev);
#line 305
  evdeq(& display->d_statusev);
#line 306
  evdeq(& display->d_readev);
#line 307
  evdeq(& display->d_writeev);
#line 309
  evdeq(& display->d_mapev);
#line 320
  dp = & displays;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! d) {
#line 320
      goto while_break;
    }
#line 321
    if (d == display) {
#line 322
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  dp = & d->d_next;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 324
  if (display->d_status_lastmsg) {
    {
#line 325
    free((void *)display->d_status_lastmsg);
    }
  }
#line 326
  if (display->d_obuf) {
    {
#line 327
    free((void *)display->d_obuf);
    }
  }
#line 328
  *dp = display->d_next;
#line 329
  cv = display->d_cvlist;
#line 338
  p = windows;
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! p) {
#line 338
      goto while_break___1;
    }
#line 340
    if (p->w_pdisplay == display) {
#line 341
      p->w_pdisplay = (struct display *)0;
    }
#line 342
    if (p->w_readev.condneg == & display->d_status) {
#line 343
      p->w_readev.condneg = (int *)0;
#line 343
      p->w_readev.condpos = p->w_readev.condneg;
    } else
#line 342
    if (p->w_readev.condneg == & display->d_obuflenmax) {
#line 343
      p->w_readev.condneg = (int *)0;
#line 343
      p->w_readev.condpos = p->w_readev.condneg;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 338
  p = p->w_next;
  {
#line 345
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 345
    if (! cv) {
#line 345
      goto while_break___2;
    }
    {
#line 347
    cvp = cv->c_next;
#line 348
    FreeCanvas(cv);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 345
  cv = cvp;
#line 351
  free((void *)((char *)display));
#line 353
  display = (struct display *)0;
  }
}
}
#line 357 "/tmp/screen-3.9.15/display.c"
int MakeDefaultCanvas(void) 
{ 
  struct canvas *cv ;
  void *__cil_tmp2 ;

  {
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  __cil_tmp2 = calloc((unsigned long )1, sizeof(*cv));
#line 362
  cv = (struct canvas *)__cil_tmp2;
  }
#line 362
  if (cv == (struct canvas *)0) {
#line 363
    return (- 1);
  }
  {
#line 364
  cv->c_xs = 0;
#line 365
  cv->c_xe = display->d_width - 1;
#line 366
  cv->c_ys = 0;
#line 367
  cv->c_ye = ((display->d_height - 1) - (display->d_has_hstatus == 1)) - captionalways;
#line 368
  cv->c_xoff = 0;
#line 369
  cv->c_yoff = 0;
#line 370
  cv->c_next = (struct canvas *)0;
#line 371
  cv->c_display = display;
#line 372
  cv->c_vplist = (struct viewport *)0;
#line 373
  cv->c_captev.type = 0;
#line 374
  cv->c_captev.data = (char *)cv;
#line 375
  cv->c_captev.handler = cv_winid_fn;
#line 377
  cv->c_blank.l_cvlist = cv;
#line 378
  cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 379
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 380
  cv->c_blank.l_y = 0;
#line 380
  cv->c_blank.l_x = cv->c_blank.l_y;
#line 381
  cv->c_blank.l_layfn = & BlankLf;
#line 382
  cv->c_blank.l_data = (char *)0;
#line 383
  cv->c_blank.l_next = (struct layer *)0;
#line 384
  cv->c_blank.l_bottom = & cv->c_blank;
#line 385
  cv->c_blank.l_blocking = 0;
#line 386
  cv->c_layer = & cv->c_blank;
#line 387
  cv->c_lnext = (struct canvas *)0;
#line 389
  display->d_cvlist = cv;
#line 390
  RethinkDisplayViewports();
#line 391
  display->d_forecv = cv;
  }
#line 392
  return (0);
}
}
#line 396 "/tmp/screen-3.9.15/display.c"
static void FreeCanvas(struct canvas *cv ) 
{ 
  struct viewport *vp ;
  struct viewport *nvp ;
  struct win *p ;

  {
  {
#line 402
  p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 403
  SetCanvasWindow(cv, (struct win *)0);
  }
#line 404
  if (p) {
    {
#line 405
    WindowChanged(p, 'u');
    }
  }
#line 406
  if (flayer == cv->c_layer) {
#line 407
    flayer = (struct layer *)0;
  }
#line 408
  vp = cv->c_vplist;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! vp) {
#line 408
      goto while_break;
    }
    {
#line 410
    vp->v_canvas = (struct canvas *)0;
#line 411
    nvp = vp->v_next;
#line 412
    vp->v_next = (struct viewport *)0;
#line 413
    free((void *)vp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  vp = nvp;
#line 415
  evdeq(& cv->c_captev);
#line 416
  free((void *)cv);
  }
}
}
#line 420 "/tmp/screen-3.9.15/display.c"
int AddCanvas(void) 
{ 
  int hh ;
  int h ;
  int i ;
  int j ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 425
  j = 0;
#line 425
  cv = display->d_cvlist;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! cv) {
#line 425
      goto while_break;
    }
#line 426
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  cv = cv->c_next;
#line 427
  j ++;
#line 428
  h = display->d_height - (display->d_has_hstatus == 1);
#line 429
  if (h / j <= 1) {
#line 430
    return (- 1);
  }
#line 432
  cv = display->d_cvlist;
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 432
    if (! cv) {
#line 432
      goto while_break___0;
    }
#line 433
    if (cv == display->d_forecv) {
#line 434
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  cv = cv->c_next;
  {
#line 435
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 435
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 436
  cvpp = & cv->c_next;
#line 438
  __cil_tmp9 = calloc((unsigned long )1, sizeof(*cv));
#line 438
  cv = (struct canvas *)__cil_tmp9;
  }
#line 438
  if (cv == (struct canvas *)0) {
#line 439
    return (- 1);
  }
#line 441
  cv->c_xs = 0;
#line 442
  cv->c_xe = display->d_width - 1;
#line 443
  cv->c_ys = 0;
#line 444
  cv->c_ye = display->d_height - 1;
#line 445
  cv->c_xoff = 0;
#line 446
  cv->c_yoff = 0;
#line 447
  cv->c_display = display;
#line 448
  cv->c_vplist = (struct viewport *)0;
#line 449
  cv->c_captev.type = 0;
#line 450
  cv->c_captev.data = (char *)cv;
#line 451
  cv->c_captev.handler = cv_winid_fn;
#line 453
  cv->c_blank.l_cvlist = cv;
#line 454
  cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 455
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 456
  cv->c_blank.l_y = 0;
#line 456
  cv->c_blank.l_x = cv->c_blank.l_y;
#line 457
  cv->c_blank.l_layfn = & BlankLf;
#line 458
  cv->c_blank.l_data = (char *)0;
#line 459
  cv->c_blank.l_next = (struct layer *)0;
#line 460
  cv->c_blank.l_bottom = & cv->c_blank;
#line 461
  cv->c_blank.l_blocking = 0;
#line 462
  cv->c_layer = & cv->c_blank;
#line 463
  cv->c_lnext = (struct canvas *)0;
#line 465
  cv->c_next = *cvpp;
#line 466
  *cvpp = cv;
#line 468
  i = 0;
#line 469
  cv = display->d_cvlist;
  {
#line 469
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 469
    if (! cv) {
#line 469
      goto while_break___2;
    }
#line 471
    __cil_tmp10 = j;
#line 471
    j --;
#line 471
    hh = h / __cil_tmp10 - 1;
#line 472
    cv->c_ys = i;
#line 473
    cv->c_ye = (i + hh) - 1;
#line 474
    cv->c_yoff = i;
#line 475
    i += hh + 1;
#line 476
    h -= hh + 1;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 469
  cv = cv->c_next;
#line 479
  RethinkDisplayViewports();
#line 480
  ResizeLayersToCanvases();
  }
#line 481
  return (0);
}
}
#line 485 "/tmp/screen-3.9.15/display.c"
void RemCanvas(void) 
{ 
  int hh ;
  int h ;
  int i ;
  int j ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  int did ;
  int __cil_tmp9 ;
  struct canvas *tmp ;
  int __cil_tmp11 ;

  {
#line 489
  did = 0;
#line 491
  h = display->d_height - (display->d_has_hstatus == 1);
#line 492
  j = 0;
#line 492
  cv = display->d_cvlist;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! cv) {
#line 492
      goto while_break;
    }
#line 493
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  cv = cv->c_next;
#line 494
  if (j == 1) {
#line 495
    return;
  }
#line 496
  i = 0;
#line 497
  __cil_tmp9 = j;
#line 497
  j --;
#line 498
  cvpp = & display->d_cvlist;
  {
#line 498
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 498
    if (! cv) {
#line 498
      goto while_break___0;
    }
#line 500
    if (cv == display->d_forecv) {
#line 500
      if (! did) {
        {
#line 502
        *cvpp = cv->c_next;
#line 503
        FreeCanvas(cv);
#line 504
        cv = *cvpp;
        }
#line 505
        if (cv) {
#line 505
          tmp = cv;
        } else {
#line 505
          tmp = display->d_cvlist;
        }
#line 505
        display->d_forecv = tmp;
#line 506
        display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 507
        flayer = (display->d_forecv)->c_layer;
#line 508
        if (cv == (struct canvas *)0) {
#line 509
          goto while_break___0;
        }
#line 510
        did = 1;
      }
    }
#line 512
    __cil_tmp11 = j;
#line 512
    j --;
#line 512
    hh = h / __cil_tmp11 - 1;
#line 513
    if (! captionalways) {
#line 513
      if (i == 0) {
#line 513
        if (j == 0) {
#line 514
          hh ++;
        }
      }
    }
#line 515
    cv->c_ys = i;
#line 516
    cv->c_ye = (i + hh) - 1;
#line 517
    cv->c_yoff = i;
#line 518
    i += hh + 1;
#line 519
    h -= hh + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 498
  cvpp = & cv->c_next;
#line 521
  RethinkDisplayViewports();
#line 522
  ResizeLayersToCanvases();
  }
}
}
#line 526 "/tmp/screen-3.9.15/display.c"
void OneCanvas(void) 
{ 
  struct canvas *mycv ;
  struct canvas *cv ;
  struct canvas **cvpp ;

  {
#line 528
  mycv = display->d_forecv;
#line 531
  cvpp = & display->d_cvlist;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! cv) {
#line 531
      goto while_break;
    }
#line 533
    if (cv == mycv) {
#line 535
      cv->c_ys = 0;
#line 536
      cv->c_ye = ((display->d_height - 1) - (display->d_has_hstatus == 1)) - captionalways;
#line 537
      cv->c_yoff = 0;
#line 538
      cvpp = & cv->c_next;
    } else {
      {
#line 542
      *cvpp = cv->c_next;
#line 543
      FreeCanvas(cv);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 546
  RethinkDisplayViewports();
#line 547
  ResizeLayersToCanvases();
  }
}
}
#line 551 "/tmp/screen-3.9.15/display.c"
int RethinkDisplayViewports(void) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  struct viewport *vpn ;
  void *__cil_tmp4 ;

  {
#line 557
  cv = display->d_cvlist;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! cv) {
#line 557
      goto while_break;
    }
#line 559
    vp = cv->c_vplist;
    {
#line 559
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 559
      if (! vp) {
#line 559
        goto while_break___0;
      }
      {
#line 561
      vp->v_canvas = (struct canvas *)0;
#line 562
      vpn = vp->v_next;
#line 563
      bzero((void *)((char *)vp), sizeof(*vp));
#line 564
      free((void *)vp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 559
    vp = vpn;
#line 566
    cv->c_vplist = (struct viewport *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  cv = cv->c_next;
#line 568
  display->d_vpxmin = - 1;
#line 569
  display->d_vpxmax = - 1;
#line 571
  cv = display->d_cvlist;
  {
#line 571
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 571
    if (! cv) {
#line 571
      goto while_break___1;
    }
    {
#line 573
    __cil_tmp4 = malloc(sizeof(*vp));
#line 573
    vp = (struct viewport *)__cil_tmp4;
    }
#line 573
    if (vp == (struct viewport *)0) {
#line 574
      return (- 1);
    }
#line 622
    vp->v_canvas = cv;
#line 623
    vp->v_xs = cv->c_xs;
#line 624
    vp->v_ys = cv->c_ys;
#line 625
    vp->v_xe = cv->c_xe;
#line 626
    vp->v_ye = cv->c_ye;
#line 627
    vp->v_xoff = cv->c_xoff;
#line 628
    vp->v_yoff = cv->c_yoff;
#line 629
    vp->v_next = cv->c_vplist;
#line 630
    cv->c_vplist = vp;
#line 633
    if (cv->c_xs < display->d_vpxmin) {
#line 634
      display->d_vpxmin = cv->c_xs;
    } else
#line 633
    if (display->d_vpxmin == -1) {
#line 634
      display->d_vpxmin = cv->c_xs;
    }
#line 635
    if (cv->c_xe > display->d_vpxmax) {
#line 636
      display->d_vpxmax = cv->c_xe;
    } else
#line 635
    if (display->d_vpxmax == -1) {
#line 636
      display->d_vpxmax = cv->c_xe;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 571
  cv = cv->c_next;
#line 638
  return (0);
}
}
#line 642 "/tmp/screen-3.9.15/display.c"
void RethinkViewportOffsets(struct canvas *cv ) 
{ 
  struct viewport *vp ;

  {
#line 647
  vp = cv->c_vplist;
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! vp) {
#line 647
      goto while_break;
    }
#line 649
    vp->v_xoff = cv->c_xoff;
#line 650
    vp->v_yoff = cv->c_yoff;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  vp = vp->v_next;
}
}
#line 659 "/tmp/screen-3.9.15/display.c"
void InitTerm(int adapt ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 663
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 664
  display->d_bot = - 1;
#line 664
  display->d_top = display->d_bot;
#line 665
  AddCStr(display->d_tcs[40].str);
#line 666
  AddCStr(display->d_tcs[39].str);
#line 668
  __cil_tmp2 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
  }
#line 668
  if (display->d_tcs[27].str) {
#line 668
    if (__cil_tmp2) {
      {
#line 669
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
  {
#line 670
  display->d_insert = 0;
#line 672
  AddCStr(display->d_tcs[69].str);
#line 673
  AddCStr(display->d_tcs[71].str);
#line 681
  display->d_keypad = 0;
#line 682
  display->d_cursorkeys = 0;
#line 683
  AddCStr(display->d_tcs[55].str);
#line 684
  AddCStr(display->d_tcs[104].str);
#line 685
  AddCStr(display->d_tcs[99].str);
#line 686
  display->d_rend = mchar_null;
#line 687
  display->d_atyp = (char )0;
  }
#line 688
  if (adapt == 0) {
    {
#line 689
    ResizeDisplay(display->d_defwidth, display->d_defheight);
    }
  }
  {
#line 690
  ChangeScrollRegion(0, display->d_height - 1);
#line 691
  display->d_y = 0;
#line 691
  display->d_x = display->d_y;
#line 692
  Flush();
#line 693
  ClearAll();
  }
  {
#line 694
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 694
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 697
  if (adapt) {
#line 697
    tmp = 2;
  } else {
#line 697
    tmp = 0;
  }
  {
#line 697
  CheckScreenSize(tmp);
  }
}
}
#line 701 "/tmp/screen-3.9.15/display.c"
void FinitTerm(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if (display->d_tcinited) {
    {
#line 706
    ResizeDisplay(display->d_defwidth, display->d_defheight);
#line 707
    InsertMode(0);
#line 708
    ChangeScrollRegion(0, display->d_height - 1);
#line 709
    KeypadMode(0);
#line 710
    CursorkeysMode(0);
#line 711
    CursorVisibility(0);
#line 712
    MouseMode(0);
#line 713
    SetRendition(& mchar_null);
#line 714
    SetFlow(1);
#line 716
    AddCStr(display->d_tcs[70].str);
#line 717
    AddCStr(display->d_tcs[72].str);
    }
#line 719
    if (display->d_hstatus) {
      {
#line 720
      ShowHStatus((char *)0);
      }
    }
    {
#line 724
    display->d_y = - 1;
#line 724
    display->d_x = display->d_y;
#line 725
    GotoPos(0, display->d_height - 1);
    }
    {
#line 726
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 726
      (display->d_obuffree) --;
#line 726
      if (display->d_obuffree <= 0) {
        {
#line 726
        Resize_obuf();
        }
      }
#line 726
      __cil_tmp1 = display->d_obufp;
#line 726
      (display->d_obufp) ++;
#line 726
      *__cil_tmp1 = (char )'\r';
#line 726
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 727
      (display->d_obuffree) --;
#line 727
      if (display->d_obuffree <= 0) {
        {
#line 727
        Resize_obuf();
        }
      }
#line 727
      __cil_tmp2 = display->d_obufp;
#line 727
      (display->d_obufp) ++;
#line 727
      *__cil_tmp2 = (char )'\n';
#line 727
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 728
    AddCStr(display->d_tcs[41].str);
    }
  }
  {
#line 730
  Flush();
  }
}
}
#line 735 "/tmp/screen-3.9.15/display.c"
static void INSERTCHAR(int c ) 
{ 


  {
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 738
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  if (! display->d_insert) {
#line 739
    if (display->d_x < display->d_width - 1) {
#line 741
      if (display->d_tcs[29].str) {
        _L: /* CIL Label */ 
#line 743
        if (display->d_tcs[29].str) {
          {
#line 744
          AddCStr(display->d_tcs[29].str);
          }
        } else {
          {
#line 746
          AddCStr2(display->d_tcs[30].str, 1);
          }
        }
        {
#line 747
        RAW_PUTCHAR(c);
        }
#line 748
        return;
      } else
#line 741
      if (display->d_tcs[30].str) {
#line 741
        goto _L;
      }
      {
#line 750
      InsertMode(1);
      }
#line 751
      if (! display->d_insert) {
        {
#line 753
        RefreshLine(display->d_y, display->d_x, display->d_width - 1, 0);
        }
#line 754
        return;
      }
    }
  }
  {
#line 757
  RAW_PUTCHAR(c);
  }
}
}
#line 761 "/tmp/screen-3.9.15/display.c"
void PUTCHAR(int c ) 
{ 


  {
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  if (display->d_insert) {
#line 765
    if (display->d_x < display->d_width - 1) {
      {
#line 766
      InsertMode(0);
      }
    }
  }
  {
#line 767
  RAW_PUTCHAR(c);
  }
}
}
#line 771 "/tmp/screen-3.9.15/display.c"
void PUTCHARLP(int c ) 
{ 
  int y ;
  int __cil_tmp3 ;

  {
#line 774
  if (display->d_x < display->d_width - 1) {
#line 776
    if (display->d_insert) {
      {
#line 777
      InsertMode(0);
      }
    }
    {
#line 778
    RAW_PUTCHAR(c);
    }
#line 779
    return;
  }
#line 781
  if (display->d_tcs[87].flg) {
    _L: /* CIL Label */ 
    {
#line 783
    y = display->d_y;
#line 784
    RAW_PUTCHAR(c);
    }
#line 785
    if (display->d_tcs[83].flg) {
#line 785
      if (! display->d_tcs[87].flg) {
        {
#line 786
        GotoPos(display->d_width - 1, y);
        }
      }
    }
#line 787
    return;
  } else
#line 781
  if (display->d_y != display->d_bot) {
#line 781
    goto _L;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  display->d_lp_missing = 1;
#line 791
  display->d_rend.image = (unsigned char )c;
#line 792
  display->d_lpchar = display->d_rend;
#line 795
  if (display->d_mbcs) {
#line 797
    display->d_lpchar.mbcs = (unsigned char )c;
#line 798
    display->d_lpchar.image = (unsigned char )display->d_mbcs;
#line 799
    display->d_mbcs = 0;
#line 800
    __cil_tmp3 = display->d_x;
#line 800
    (display->d_x) --;
  }
}
}
#line 811 "/tmp/screen-3.9.15/display.c"
static void RAW_PUTCHAR(int c ) 
{ 
  int tmp ;
  int __cil_tmp3 ;
  char *__cil_tmp5 ;
  int t ;
  int __cil_tmp8 ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  int tmp___1 ;

  {
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  if (display->d_encoding == 8) {
#line 820
    c = (c & 255) | ((int )display->d_rend.font << 8);
#line 822
    if (display->d_mbcs) {
#line 824
      c = display->d_mbcs;
#line 825
      if (display->d_x == display->d_width) {
#line 826
        if (display->d_tcs[83].flg) {
#line 826
          tmp = 1;
        } else {
#line 826
          tmp = - 1;
        }
#line 826
        display->d_x += tmp;
      }
#line 827
      display->d_mbcs = 0;
    } else {
      {
#line 829
      __cil_tmp3 = utf8_isdouble(c);
      }
#line 829
      if (__cil_tmp3) {
#line 831
        display->d_mbcs = c;
#line 832
        (display->d_x) ++;
#line 833
        return;
      }
    }
#line 836
    if (c < 32) {
      {
#line 838
      AddCStr2(display->d_tcs[98].str, '0');
      }
      {
#line 839
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 839
        (display->d_obuffree) --;
#line 839
        if (display->d_obuffree <= 0) {
          {
#line 839
          Resize_obuf();
          }
        }
#line 839
        __cil_tmp5 = display->d_obufp;
#line 839
        (display->d_obufp) ++;
#line 839
        *__cil_tmp5 = (char )(c + 95);
#line 839
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 840
      AddCStr(display->d_tcs[99].str);
      }
#line 841
      goto addedutf8;
    }
    {
#line 843
    AddUtf8(c);
    }
#line 844
    goto addedutf8;
  }
#line 848
  if ((int )display->d_rend.font) {
#line 848
    if (((int )display->d_rend.font & 96) == 0) {
#line 850
      t = c;
#line 851
      if (display->d_mbcs == 0) {
#line 853
        display->d_mbcs = c;
#line 854
        (display->d_x) ++;
#line 855
        return;
      }
#line 857
      __cil_tmp8 = display->d_x;
#line 857
      (display->d_x) --;
#line 858
      if (display->d_x == display->d_width - 1) {
#line 859
        if (display->d_tcs[83].flg) {
#line 859
          tmp___0 = 1;
        } else {
#line 859
          tmp___0 = - 1;
        }
#line 859
        display->d_x += tmp___0;
      }
#line 860
      c = display->d_mbcs;
#line 861
      display->d_mbcs = t;
    }
  }
#line 865
  if (display->d_encoding) {
    {
#line 866
    c = PrepareEncodedChar(c);
    }
  }
  kanjiloop: 
#line 871
  if (display->d_xtable) {
#line 871
    if (*(display->d_xtable + (int )display->d_rend.font)) {
#line 871
      if (*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c))) {
        {
#line 872
        AddStr(*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c)));
        }
      } else {
#line 871
        goto _L;
      }
    } else {
#line 871
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 874
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 874
      (display->d_obuffree) --;
#line 874
      if (display->d_obuffree <= 0) {
        {
#line 874
        Resize_obuf();
        }
      }
#line 874
      if ((int )display->d_rend.font != 48) {
#line 874
        tmp___1 = c;
      } else {
#line 874
        tmp___1 = (int )display->d_c0_tab[(int )((unsigned char )c)];
      }
#line 874
      __cil_tmp11 = display->d_obufp;
#line 874
      (display->d_obufp) ++;
#line 874
      *__cil_tmp11 = (char )tmp___1;
#line 874
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  addedutf8: 
#line 882
  (display->d_x) ++;
#line 882
  if (display->d_x >= display->d_width) {
#line 884
    if (display->d_tcs[83].flg == 0) {
#line 885
      display->d_x = display->d_width - 1;
    } else
#line 886
    if (! display->d_tcs[87].flg) {
      _L___47: /* CIL Label */ 
#line 888
      display->d_x -= display->d_width;
#line 889
      if (display->d_y < display->d_height - 1) {
#line 889
        if (display->d_y != display->d_bot) {
#line 890
          (display->d_y) ++;
        }
      }
    } else
#line 886
    if (display->d_x > display->d_width) {
#line 886
      goto _L___47;
    }
  }
#line 894
  if (display->d_mbcs) {
#line 896
    c = display->d_mbcs;
#line 897
    display->d_mbcs = 0;
#line 898
    goto kanjiloop;
  }
}
}
#line 904 "/tmp/screen-3.9.15/display.c"
static int DoAddChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 908
    (display->d_obuffree) --;
#line 908
    if (display->d_obuffree <= 0) {
      {
#line 908
      Resize_obuf();
      }
    }
#line 908
    __cil_tmp2 = display->d_obufp;
#line 908
    (display->d_obufp) ++;
#line 908
    *__cil_tmp2 = (char )c;
#line 908
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (c);
}
}
#line 913 "/tmp/screen-3.9.15/display.c"
void AddCStr(char *s ) 
{ 


  {
#line 916
  if (display) {
#line 916
    if (s) {
#line 916
      if ((int )*s) {
        {
#line 918
        ospeed = display->d_dospeed;
#line 919
        xtputs(s, 1, (int (*)(int  ))DoAddChar);
        }
      }
    }
  }
}
}
#line 924 "/tmp/screen-3.9.15/display.c"
void AddCStr2(char *s , int c ) 
{ 
  char *__cil_tmp3 ;

  {
#line 928
  if (display) {
#line 928
    if (s) {
#line 928
      if ((int )*s) {
        {
#line 930
        ospeed = display->d_dospeed;
#line 931
        __cil_tmp3 = tgoto(s, 0, c);
#line 931
        xtputs(__cil_tmp3, 1, (int (*)(int  ))DoAddChar);
        }
      }
    }
  }
}
}
#line 939 "/tmp/screen-3.9.15/display.c"
void InsertMode(int on ) 
{ 


  {
#line 942
  if (display) {
#line 942
    if (on != display->d_insert) {
#line 942
      if (display->d_tcs[27].str) {
#line 944
        display->d_insert = on;
#line 945
        if (on) {
          {
#line 946
          AddCStr(display->d_tcs[27].str);
          }
        } else {
          {
#line 948
          AddCStr(display->d_tcs[28].str);
          }
        }
      }
    }
  }
}
}
#line 955 "/tmp/screen-3.9.15/display.c"
void KeypadMode(int on ) 
{ 


  {
#line 959
  if (display) {
#line 960
    display->d_keypad = on;
  }
}
}
#line 974 "/tmp/screen-3.9.15/display.c"
void CursorkeysMode(int on ) 
{ 


  {
#line 978
  if (display) {
#line 979
    display->d_cursorkeys = on;
  }
}
}
#line 993 "/tmp/screen-3.9.15/display.c"
void ReverseVideo(int on ) 
{ 


  {
#line 996
  if (display) {
#line 996
    if (display->d_revvid != on) {
#line 996
      if (display->d_tcs[93].str) {
#line 998
        display->d_revvid = on;
#line 999
        if (display->d_revvid) {
          {
#line 1000
          AddCStr(display->d_tcs[93].str);
          }
        } else {
          {
#line 1002
          AddCStr(display->d_tcs[94].str);
          }
        }
      }
    }
  }
}
}
#line 1007 "/tmp/screen-3.9.15/display.c"
void CursorVisibility(int v ) 
{ 


  {
#line 1010
  if (display) {
#line 1010
    if (display->d_curvis != v) {
#line 1012
      if (display->d_curvis) {
        {
#line 1013
        AddCStr(display->d_tcs[82].str);
        }
      }
#line 1014
      display->d_curvis = 0;
#line 1015
      if (v == -1) {
#line 1015
        if (display->d_tcs[80].str) {
          {
#line 1016
          AddCStr(display->d_tcs[80].str);
          }
        } else {
#line 1015
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1017
      if (v == 1) {
#line 1017
        if (display->d_tcs[81].str) {
          {
#line 1018
          AddCStr(display->d_tcs[81].str);
          }
        } else {
#line 1020
          return;
        }
      } else {
#line 1020
        return;
      }
#line 1021
      display->d_curvis = v;
    }
  }
}
}
#line 1026 "/tmp/screen-3.9.15/display.c"
void MouseMode(int mode ) 
{ 
  char mousebuf[20] ;

  {
#line 1029
  if (display) {
#line 1029
    if (display->d_mouse != mode) {
#line 1032
      if (! display->d_tcs[96].flg) {
#line 1033
        return;
      }
#line 1034
      if (display->d_mouse) {
        {
#line 1036
        sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dl"), display->d_mouse);
#line 1037
        AddStr((char *)mousebuf);
        }
      }
#line 1039
      if (mode) {
        {
#line 1041
        sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dl"), mode);
#line 1042
        AddStr((char *)mousebuf);
        }
      }
#line 1044
      display->d_mouse = mode;
    }
  }
}
}
#line 1048
static int StrCost ;
#line 1052 "/tmp/screen-3.9.15/display.c"
static int CountChars(int c ) 
{ 


  {
#line 1055
  StrCost ++;
#line 1056
  return (c);
}
}
#line 1060 "/tmp/screen-3.9.15/display.c"
int CalcCost(char *s ) 
{ 


  {
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  if (s) {
    {
#line 1066
    StrCost = 0;
#line 1067
    ospeed = display->d_dospeed;
#line 1068
    xtputs(s, 1, (int (*)(int  ))CountChars);
    }
#line 1069
    return (StrCost);
  } else {
#line 1072
    return (1000);
  }
}
}
#line 1076 "/tmp/screen-3.9.15/display.c"
static int CallRewrite(int y , int xs , int xe , int doit ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct layer *oldflayer ;
  int cost ;

  {
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1085
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1085
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1086
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1086
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1088
  vp = (struct viewport *)0;
#line 1089
  cv = display->d_cvlist;
  {
#line 1089
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1089
    if (! cv) {
#line 1089
      goto while_break___2;
    }
#line 1091
    if (y < cv->c_ys) {
#line 1092
      goto while_continue___2;
    } else
#line 1091
    if (y > cv->c_ye) {
#line 1092
      goto while_continue___2;
    } else
#line 1091
    if (xe < cv->c_xs) {
#line 1092
      goto while_continue___2;
    } else
#line 1091
    if (xs > cv->c_xe) {
#line 1092
      goto while_continue___2;
    }
#line 1093
    vp = cv->c_vplist;
    {
#line 1093
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1093
      if (! vp) {
#line 1093
        goto while_break___3;
      }
#line 1094
      if (y >= vp->v_ys) {
#line 1094
        if (y <= vp->v_ye) {
#line 1094
          if (xe >= vp->v_xs) {
#line 1094
            if (xs <= vp->v_xe) {
#line 1095
              goto while_break___3;
            }
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1093
    vp = vp->v_next;
#line 1096
    if (vp) {
#line 1097
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1089
  cv = cv->c_next;
#line 1099
  if (doit) {
    {
#line 1101
    oldflayer = flayer;
#line 1102
    flayer = cv->c_layer;
#line 1103
    cvlist = flayer->l_cvlist;
#line 1104
    cvlnext = cv->c_lnext;
#line 1105
    flayer->l_cvlist = cv;
#line 1106
    cv->c_lnext = (struct canvas *)0;
#line 1107
    ((int (*)(int  , int  , int  , struct mchar * , int  ))*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff,
                                                                                                xs - vp->v_xoff,
                                                                                                xe - vp->v_xoff,
                                                                                                & display->d_rend,
                                                                                                1);
#line 1108
    flayer->l_cvlist = cvlist;
#line 1109
    cv->c_lnext = cvlnext;
#line 1110
    flayer = oldflayer;
    }
#line 1111
    return (0);
  }
#line 1113
  if (cv == (struct canvas *)0) {
#line 1114
    return (1000);
  } else
#line 1113
  if (cv->c_layer == (struct layer *)0) {
#line 1114
    return (1000);
  }
#line 1115
  if (xs < vp->v_xs) {
#line 1116
    return (1000);
  } else
#line 1115
  if (xe > vp->v_xe) {
#line 1116
    return (1000);
  }
#line 1117
  if (y - vp->v_yoff < 0) {
#line 1118
    return (1000);
  } else
#line 1117
  if (y - vp->v_yoff >= (cv->c_layer)->l_height) {
#line 1118
    return (1000);
  }
#line 1119
  if (xs - vp->v_xoff < 0) {
#line 1120
    return (1000);
  } else
#line 1119
  if (xe - vp->v_xoff >= (cv->c_layer)->l_width) {
#line 1120
    return (1000);
  }
#line 1122
  if (display->d_encoding == 8) {
#line 1123
    display->d_rend.font = (unsigned char )0;
  }
#line 1125
  oldflayer = flayer;
#line 1126
  flayer = cv->c_layer;
  {
#line 1127
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1127
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1128
  cost = ((int (*)(int  , int  , int  , struct mchar * , int  ))*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff,
                                                                                                     xs - vp->v_xoff,
                                                                                                     xe - vp->v_xoff,
                                                                                                     & display->d_rend,
                                                                                                     0);
#line 1129
  flayer = oldflayer;
  }
#line 1130
  if (display->d_insert) {
#line 1131
    cost += display->d_EIcost + display->d_IMcost;
  }
#line 1132
  return (cost);
}
}
#line 1137 "/tmp/screen-3.9.15/display.c"
void GotoPos(int x2 , int y2 ) 
{ 
  register int dy ;
  register int dx ;
  register int x1 ;
  register int y1 ;
  register int costx ;
  register int costy ;
  register int m ;
  register char *s ;
  int CMcost ;
  enum move_t xm ;
  enum move_t ym ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int tmp___51 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  char *tmp___52 ;
  int __cil_tmp36 ;

  {
#line 1145
  xm = (enum move_t )0;
#line 1145
  ym = (enum move_t )0;
#line 1147
  if (! display) {
#line 1148
    return;
  }
#line 1150
  x1 = display->d_x;
#line 1151
  y1 = display->d_y;
#line 1153
  if (x1 == display->d_width) {
#line 1155
    if (display->d_tcs[87].flg) {
#line 1155
      if (display->d_tcs[83].flg) {
#line 1156
        x1 = - 1;
      } else {
#line 1158
        __cil_tmp14 = x1;
#line 1158
        x1 --;
      }
    } else {
#line 1158
      __cil_tmp14 = x1;
#line 1158
      x1 --;
    }
  }
#line 1160
  if (x2 == display->d_width) {
#line 1161
    __cil_tmp15 = x2;
#line 1161
    x2 --;
  }
#line 1162
  dx = x2 - x1;
#line 1163
  dy = y2 - y1;
#line 1164
  if (dy == 0) {
#line 1164
    if (dx == 0) {
#line 1165
      return;
    }
  }
  {
#line 1166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1167
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1168
  if (! display->d_tcs[56].flg) {
    {
#line 1169
    SetRendition(& mchar_null);
    }
  }
#line 1170
  if (y1 < 0) {
    DoCM: 
#line 1175
    if (display->d_tcs[6].str) {
#line 1175
      if (! x2) {
#line 1175
        if (! y2) {
          {
#line 1176
          AddCStr(display->d_tcs[6].str);
          }
        } else {
          {
          {
          {
#line 1178
          __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
          }
          }
          {
          {
#line 1178
          AddCStr(__cil_tmp16);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 1178
        __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
        }
        }
        {
        {
#line 1178
        AddCStr(__cil_tmp16);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 1178
      __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
      }
      }
      {
      {
#line 1178
      AddCStr(__cil_tmp16);
      }
      }
      }
    }
#line 1179
    display->d_x = x2;
#line 1180
    display->d_y = y2;
#line 1181
    return;
  } else
#line 1170
  if (y2 > display->d_bot) {
#line 1170
    if (y1 <= display->d_bot) {
#line 1170
      goto DoCM;
    } else {
#line 1170
      goto _L___49;
    }
  } else
  _L___49: /* CIL Label */ 
#line 1170
  if (y2 < display->d_top) {
#line 1170
    if (y1 >= display->d_top) {
#line 1170
      goto DoCM;
    }
  }
#line 1187
  if (y1 > display->d_bot) {
#line 1187
    if (y2 > y1) {
#line 1188
      goto DoCM;
    } else {
#line 1187
      goto _L___50;
    }
  } else
  _L___50: /* CIL Label */ 
#line 1187
  if (y1 < display->d_top) {
#line 1187
    if (y2 < y1) {
#line 1188
      goto DoCM;
    }
  }
#line 1191
  if (display->d_tcs[6].str) {
#line 1191
    if (! x2) {
#line 1191
      if (! y2) {
#line 1192
        s = display->d_tcs[6].str;
      } else {
        {
        {
        {
#line 1194
        s = tgoto(display->d_tcs[5].str, x2, y2);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 1194
      s = tgoto(display->d_tcs[5].str, x2, y2);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 1194
    s = tgoto(display->d_tcs[5].str, x2, y2);
    }
    }
    }
  }
  {
#line 1195
  CMcost = CalcCost(s);
#line 1198
  costx = 1000;
  }
#line 1199
  if (x1 >= 0) {
#line 1201
    if (dx > 0) {
#line 1203
      if (display->d_tcs[17].str) {
#line 1203
        if (dx > 1) {
          {
          {
#line 1205
          __cil_tmp19 = tgoto(display->d_tcs[17].str, 0, dx);
          }
          {
#line 1205
          __cil_tmp20 = CalcCost(__cil_tmp19);
          }
#line 1205
          costx = __cil_tmp20;
#line 1206
          xm = (enum move_t )8;
          }
        } else
#line 1203
        if (! display->d_tcs[16].str) {
          {
          {
#line 1205
          __cil_tmp19 = tgoto(display->d_tcs[17].str, 0, dx);
          }
          {
#line 1205
          __cil_tmp20 = CalcCost(__cil_tmp19);
          }
#line 1205
          costx = __cil_tmp20;
#line 1206
          xm = (enum move_t )8;
          }
        }
      }
#line 1208
      m = display->d_NDcost * dx;
#line 1208
      if (m < costx) {
#line 1210
        costx = m;
#line 1211
        xm = (enum move_t )7;
      }
      {
#line 1214
      m = CallRewrite(y1, x1, x2 - 1, 0);
      }
#line 1214
      if (dx < costx) {
#line 1214
        if (m < costx) {
#line 1216
          costx = m;
#line 1217
          xm = (enum move_t )9;
        }
      }
    } else
#line 1220
    if (dx < 0) {
#line 1222
      if (display->d_tcs[15].str) {
#line 1222
        if (dx < -1) {
          {
          {
#line 1224
          __cil_tmp22 = tgoto(display->d_tcs[15].str, 0, - dx);
          }
          {
#line 1224
          __cil_tmp23 = CalcCost(__cil_tmp22);
          }
#line 1224
          costx = __cil_tmp23;
#line 1225
          xm = (enum move_t )6;
          }
        } else
#line 1222
        if (! display->d_tcs[13].str) {
          {
          {
#line 1224
          __cil_tmp22 = tgoto(display->d_tcs[15].str, 0, - dx);
          }
          {
#line 1224
          __cil_tmp23 = CalcCost(__cil_tmp22);
          }
#line 1224
          costx = __cil_tmp23;
#line 1225
          xm = (enum move_t )6;
          }
        }
      }
#line 1227
      m = - dx * display->d_LEcost;
#line 1227
      if (m < costx) {
#line 1229
        costx = m;
#line 1230
        xm = (enum move_t )5;
      }
    } else {
#line 1234
      costx = 0;
    }
  }
#line 1237
  if (x2) {
    {
#line 1237
    __cil_tmp24 = CallRewrite(y1, 0, x2 - 1, 0);
#line 1237
    tmp = __cil_tmp24;
    }
  } else {
#line 1237
    tmp = 0;
  }
#line 1237
  m = tmp + display->d_CRcost;
#line 1237
  if (x2 + display->d_CRcost < costx) {
#line 1237
    if (m < costx) {
#line 1239
      costx = m;
#line 1240
      xm = (enum move_t )10;
    }
  }
#line 1244
  if (costx >= CMcost) {
#line 1245
    goto DoCM;
  }
#line 1248
  costy = 1000;
#line 1249
  if (dy > 0) {
#line 1251
    if (display->d_tcs[11].str) {
#line 1251
      if (dy > 1) {
        {
#line 1253
        __cil_tmp26 = tgoto(display->d_tcs[11].str, 0, dy);
#line 1253
        __cil_tmp27 = CalcCost(__cil_tmp26);
#line 1253
        costy = __cil_tmp27;
#line 1254
        ym = (enum move_t )4;
        }
      }
    }
#line 1256
    if (x2 == 0) {
#line 1256
      tmp___51 = display->d_NLcost;
    } else {
#line 1256
      tmp___51 = display->d_DOcost;
    }
#line 1256
    m = dy * tmp___51;
#line 1256
    if (m < costy) {
#line 1258
      costy = m;
#line 1259
      ym = (enum move_t )3;
    }
  } else
#line 1262
  if (dy < 0) {
#line 1264
    if (display->d_tcs[9].str) {
#line 1264
      if (dy < -1) {
        {
        {
#line 1266
        __cil_tmp29 = tgoto(display->d_tcs[9].str, 0, - dy);
        }
        {
#line 1266
        __cil_tmp30 = CalcCost(__cil_tmp29);
        }
#line 1266
        costy = __cil_tmp30;
#line 1267
        ym = (enum move_t )2;
        }
      } else
#line 1264
      if (! display->d_tcs[8].str) {
        {
        {
#line 1266
        __cil_tmp29 = tgoto(display->d_tcs[9].str, 0, - dy);
        }
        {
#line 1266
        __cil_tmp30 = CalcCost(__cil_tmp29);
        }
#line 1266
        costy = __cil_tmp30;
#line 1267
        ym = (enum move_t )2;
        }
      }
    }
#line 1269
    m = - dy * display->d_UPcost;
#line 1269
    if (m < costy) {
#line 1271
      costy = m;
#line 1272
      ym = (enum move_t )1;
    }
  } else {
#line 1276
    costy = 0;
  }
#line 1279
  if (costx + costy >= CMcost) {
#line 1280
    goto DoCM;
  }
  {
#line 1284
  if ((unsigned int )xm == (unsigned int )5) {
#line 1284
    goto case_5;
  }
#line 1288
  if ((unsigned int )xm == (unsigned int )6) {
#line 1288
    goto case_6;
  }
#line 1291
  if ((unsigned int )xm == (unsigned int )7) {
#line 1291
    goto case_7;
  }
#line 1295
  if ((unsigned int )xm == (unsigned int )8) {
#line 1295
    goto case_8;
  }
#line 1298
  if ((unsigned int )xm == (unsigned int )10) {
#line 1298
    goto case_10;
  }
#line 1303
  if ((unsigned int )xm == (unsigned int )9) {
#line 1303
    goto case_9;
  }
#line 1307
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1285
    if (! (__cil_tmp31 < 0)) {
#line 1285
      goto while_break___1;
    }
    {
#line 1286
    AddCStr(display->d_tcs[13].str);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1287
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1289
  AddCStr2(display->d_tcs[15].str, - dx);
  }
#line 1290
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1292
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1292
    if (! (__cil_tmp32 > 0)) {
#line 1292
      goto while_break___2;
    }
    {
#line 1293
    AddCStr(display->d_tcs[16].str);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1294
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1296
  AddCStr2(display->d_tcs[17].str, dx);
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1299
  AddCStr(display->d_tcs[7].str);
  }
#line 1300
  display->d_x = 0;
#line 1301
  x1 = 0;
  case_9: /* CIL Label */ 
#line 1304
  if (x1 < x2) {
    {
#line 1305
    __cil_tmp33 = CallRewrite(y1, x1, x2 - 1, 1);
    }
  }
#line 1306
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1308
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1313
  if ((unsigned int )ym == (unsigned int )1) {
#line 1313
    goto case_1;
  }
#line 1317
  if ((unsigned int )ym == (unsigned int )2) {
#line 1317
    goto case_2;
  }
#line 1320
  if ((unsigned int )ym == (unsigned int )3) {
#line 1320
    goto case_3;
  }
#line 1325
  if ((unsigned int )ym == (unsigned int )4) {
#line 1325
    goto case_4;
  }
#line 1328
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1314
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1314
    if (! (__cil_tmp34 < 0)) {
#line 1314
      goto while_break___3;
    }
    {
#line 1315
    AddCStr(display->d_tcs[8].str);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1316
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1318
  AddCStr2(display->d_tcs[9].str, - dy);
  }
#line 1319
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1321
  if (x2 == 0) {
#line 1321
    tmp___52 = display->d_tcs[19].str;
  } else {
#line 1321
    tmp___52 = display->d_tcs[10].str;
  }
#line 1321
  s = tmp___52;
  {
#line 1322
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1322
    if (! (__cil_tmp36 > 0)) {
#line 1322
      goto while_break___4;
    }
    {
#line 1323
    AddCStr(s);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1324
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1326
  AddCStr2(display->d_tcs[11].str, dy);
  }
#line 1327
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1329
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1331
  display->d_x = x2;
#line 1332
  display->d_y = y2;
}
}
#line 1336 "/tmp/screen-3.9.15/display.c"
void ClearAll(void) 
{ 


  {
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1339
  ClearArea(0, 0, 0, display->d_width - 1, display->d_width - 1, display->d_height - 1,
            0, 0);
  }
}
}
#line 1343 "/tmp/screen-3.9.15/display.c"
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) 
{ 
  int y ;
  int xxe ;
  struct canvas *cv ;
  struct viewport *vp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct layer *oldflayer ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int __cil_tmp18 ;

  {
  {
#line 1350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1351
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1352
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1352
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1353
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1353
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1354
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1354
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1355
  if (x1 == display->d_width) {
#line 1356
    __cil_tmp13 = x1;
#line 1356
    x1 --;
  }
#line 1357
  if (x2 == display->d_width) {
#line 1358
    __cil_tmp14 = x2;
#line 1358
    x2 --;
  }
#line 1359
  if (xs == -1) {
#line 1360
    xs = x1;
  }
#line 1361
  if (xe == -1) {
#line 1362
    xe = x2;
  }
#line 1363
  if (display->d_tcs[33].flg) {
    {
#line 1364
    SetRendition(& mchar_null);
    }
  }
#line 1366
  if (display->d_tcs[66].flg) {
    {
#line 1367
    SetBackColor(bce);
    }
  }
#line 1369
  if (display->d_lp_missing) {
#line 1369
    if (y1 <= display->d_bot) {
#line 1369
      if (xe >= display->d_width - 1) {
#line 1371
        if (y2 > display->d_bot) {
#line 1372
          display->d_lp_missing = 0;
        } else
#line 1371
        if (y2 == display->d_bot) {
#line 1371
          if (x2 >= display->d_width - 1) {
#line 1372
            display->d_lp_missing = 0;
          }
        }
      }
    }
  }
#line 1374
  if (x2 == display->d_width - 1) {
#line 1374
    if (xs == 0) {
      _L___53: /* CIL Label */ 
#line 1374
      if (xe == display->d_width - 1) {
#line 1374
        if (y2 == display->d_height - 1) {
#line 1374
          if (! bce) {
            _L: /* CIL Label */ 
#line 1377
            if (x1 == 0) {
#line 1377
              if (y1 == 0) {
#line 1377
                if (display->d_auto_nuke) {
                  {
#line 1378
                  NukePending();
                  }
                }
              }
            }
#line 1380
            if (x1 == 0) {
#line 1380
              if (y1 == 0) {
#line 1380
                if (display->d_tcs[34].str) {
                  {
#line 1382
                  AddCStr(display->d_tcs[34].str);
#line 1383
                  display->d_x = 0;
#line 1383
                  display->d_y = display->d_x;
                  }
#line 1384
                  return;
                }
              }
            }
#line 1390
            if (display->d_tcs[35].str) {
#line 1390
              if (y1 < y2) {
                {
                {
#line 1392
                GotoPos(x1, y1);
                }
                {
#line 1393
                AddCStr(display->d_tcs[35].str);
                }
                }
#line 1394
                return;
              } else
#line 1390
              if (! display->d_tcs[37].str) {
                {
                {
#line 1392
                GotoPos(x1, y1);
                }
                {
#line 1393
                AddCStr(display->d_tcs[35].str);
                }
                }
#line 1394
                return;
              }
            }
          } else
#line 1374
          if (display->d_tcs[66].flg) {
#line 1374
            goto _L;
          }
        }
      }
    } else
#line 1374
    if (y1 == y2) {
#line 1374
      goto _L___53;
    }
  }
#line 1397
  if (x1 == 0) {
#line 1397
    if (xs == 0) {
#line 1397
      if (xe == display->d_width - 1) {
        _L___54: /* CIL Label */ 
#line 1397
        if (y1 == 0) {
#line 1397
          if (display->d_tcs[36].str) {
#line 1397
            if (! bce) {
              {
              {
#line 1399
              GotoPos(x1, y1);
              }
              {
#line 1400
              AddCStr(display->d_tcs[36].str);
              }
              }
#line 1401
              return;
            } else
#line 1397
            if (display->d_tcs[66].flg) {
              {
              {
#line 1399
              GotoPos(x1, y1);
              }
              {
#line 1400
              AddCStr(display->d_tcs[36].str);
              }
              }
#line 1401
              return;
            }
          }
        }
      } else
#line 1397
      if (y1 == y2) {
#line 1397
        goto _L___54;
      }
    }
  }
#line 1403
  xxe = xe;
#line 1404
  y = y1;
  {
#line 1404
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1404
    if (! (y <= y2)) {
#line 1404
      goto while_break___4;
    }
#line 1406
    if (y == y2) {
#line 1407
      xxe = x2;
    }
#line 1408
    if (x1 == 0) {
#line 1408
      if (display->d_tcs[38].str) {
#line 1408
        if (xxe != display->d_width - 1) {
          _L___55: /* CIL Label */ 
#line 1408
          if (! bce) {
            {
            {
#line 1410
            GotoPos(xxe, y);
            }
            {
#line 1411
            AddCStr(display->d_tcs[38].str);
            }
            }
#line 1412
            goto while_continue___4;
          } else
#line 1408
          if (display->d_tcs[66].flg) {
            {
            {
#line 1410
            GotoPos(xxe, y);
            }
            {
#line 1411
            AddCStr(display->d_tcs[38].str);
            }
            }
#line 1412
            goto while_continue___4;
          }
        } else
#line 1408
        if (display->d_x == xxe) {
#line 1408
          if (display->d_y == y) {
#line 1408
            goto _L___55;
          }
        }
      }
    }
#line 1414
    if (xxe == display->d_width - 1) {
#line 1414
      if (display->d_tcs[37].str) {
#line 1414
        if (! bce) {
          {
          {
#line 1416
          GotoPos(x1, y);
          }
          {
#line 1417
          AddCStr(display->d_tcs[37].str);
          }
          }
#line 1418
          goto while_continue___4;
        } else
#line 1414
        if (display->d_tcs[66].flg) {
          {
          {
#line 1416
          GotoPos(x1, y);
          }
          {
#line 1417
          AddCStr(display->d_tcs[37].str);
          }
          }
#line 1418
          goto while_continue___4;
        }
      }
    }
#line 1420
    if (uselayfn) {
#line 1422
      vp = (struct viewport *)0;
#line 1423
      cv = display->d_cvlist;
      {
#line 1423
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1423
        if (! cv) {
#line 1423
          goto while_break___5;
        }
#line 1425
        if (y < cv->c_ys) {
#line 1426
          goto while_continue___5;
        } else
#line 1425
        if (y > cv->c_ye) {
#line 1426
          goto while_continue___5;
        } else
#line 1425
        if (xxe < cv->c_xs) {
#line 1426
          goto while_continue___5;
        } else
#line 1425
        if (x1 > cv->c_xe) {
#line 1426
          goto while_continue___5;
        }
#line 1427
        vp = cv->c_vplist;
        {
#line 1427
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1427
          if (! vp) {
#line 1427
            goto while_break___6;
          }
#line 1428
          if (y >= vp->v_ys) {
#line 1428
            if (y <= vp->v_ye) {
#line 1428
              if (xxe >= vp->v_xs) {
#line 1428
                if (x1 <= vp->v_xe) {
#line 1429
                  goto while_break___6;
                }
              }
            }
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1427
        vp = vp->v_next;
#line 1430
        if (vp) {
#line 1431
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1423
      cv = cv->c_next;
#line 1433
      if (cv) {
#line 1433
        if (cv->c_layer) {
#line 1433
          if (x1 >= vp->v_xs) {
#line 1433
            if (xxe <= vp->v_xe) {
#line 1433
              if (y - vp->v_yoff >= 0) {
#line 1433
                if (y - vp->v_yoff < (cv->c_layer)->l_height) {
#line 1433
                  if (xxe - vp->v_xoff >= 0) {
#line 1433
                    if (x1 - vp->v_xoff < (cv->c_layer)->l_width) {
                      {
#line 1437
                      oldflayer = flayer;
#line 1439
                      flayer = cv->c_layer;
#line 1440
                      cvlist = flayer->l_cvlist;
#line 1441
                      cvlnext = cv->c_lnext;
#line 1442
                      flayer->l_cvlist = cv;
#line 1443
                      cv->c_lnext = (struct canvas *)0;
#line 1444
                      ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayClearLine))(y - vp->v_yoff,
                                                                                                    x1 - vp->v_xoff,
                                                                                                    xxe - vp->v_xoff,
                                                                                                    bce);
#line 1445
                      flayer->l_cvlist = cvlist;
#line 1446
                      cv->c_lnext = cvlnext;
#line 1447
                      flayer = oldflayer;
                      }
#line 1448
                      goto while_continue___4;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1451
    ClearLine((struct mline *)0, y, x1, xxe, bce);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1404
  x1 = xs;
#line 1404
  __cil_tmp18 = y;
#line 1404
  y ++;
}
}
#line 1461 "/tmp/screen-3.9.15/display.c"
void Redisplay(int cur_only ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1467
  InsertMode(0);
#line 1468
  ChangeScrollRegion(0, display->d_height - 1);
#line 1469
  KeypadMode(0);
#line 1470
  CursorkeysMode(0);
#line 1471
  CursorVisibility(0);
#line 1472
  MouseMode(0);
#line 1473
  SetRendition(& mchar_null);
#line 1474
  SetFlow(1);
#line 1476
  ClearAll();
  }
#line 1480
  if (cur_only > 0) {
#line 1480
    if (display->d_fore) {
      {
#line 1481
      RefreshArea(0, (display->d_fore)->w_layer.l_y, display->d_width - 1, (display->d_fore)->w_layer.l_y,
                  1);
      }
    } else {
      {
      {
#line 1483
      RefreshAll(1);
      }
      }
    }
  } else {
    {
    {
#line 1483
    RefreshAll(1);
    }
    }
  }
  {
#line 1484
  RefreshHStatus();
#line 1485
  olddisplay = display;
#line 1485
  oldflayer = flayer;
#line 1485
  l = (display->d_forecv)->c_layer;
#line 1485
  cvlist = l->l_cvlist;
#line 1485
  cvlnext = (display->d_forecv)->c_lnext;
#line 1485
  flayer = l;
#line 1485
  l->l_cvlist = display->d_forecv;
#line 1485
  (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 1485
  ((void (*)(void))*((flayer->l_layfn)->lf_LayRestore))();
#line 1485
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 1485
  flayer = oldflayer;
#line 1485
  l->l_cvlist = cvlist;
#line 1485
  (display->d_forecv)->c_lnext = cvlnext;
#line 1485
  display = olddisplay;
  }
}
}
#line 1489 "/tmp/screen-3.9.15/display.c"
void RedisplayDisplays(int cur_only ) 
{ 
  struct display *olddisplay ;

  {
#line 1492
  olddisplay = display;
#line 1493
  display = displays;
  {
#line 1493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1493
    if (! display) {
#line 1493
      goto while_break;
    }
    {
#line 1494
    Redisplay(cur_only);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  display = display->d_next;
#line 1495
  display = olddisplay;
}
}
#line 1501 "/tmp/screen-3.9.15/display.c"
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) 
{ 
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1507
  if (n == 0) {
#line 1508
    return;
  }
#line 1509
  if (xe != display->d_width - 1) {
    {
#line 1511
    RefreshLine(y, xs, xe, 0);
    }
#line 1513
    return;
  }
  {
#line 1515
  GotoPos(xs, y);
  }
#line 1516
  if (display->d_tcs[33].flg) {
    {
#line 1517
    SetRendition(& mchar_null);
    }
  }
#line 1519
  if (display->d_tcs[66].flg) {
    {
#line 1520
    SetBackColor(bce);
    }
  }
#line 1522
  if (n > 0) {
#line 1524
    if (n >= (xe - xs) + 1) {
#line 1525
      n = (xe - xs) + 1;
    }
#line 1526
    if (display->d_tcs[32].str) {
#line 1526
      if (! (n == 1 && display->d_tcs[31].str)) {
        {
#line 1527
        AddCStr2(display->d_tcs[32].str, n);
        }
      } else {
#line 1526
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1528
    if (display->d_tcs[31].str) {
#line 1530
      i = n;
      {
#line 1530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1530
        if (! __cil_tmp8) {
#line 1530
          goto while_break;
        }
        {
#line 1531
        AddCStr(display->d_tcs[31].str);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1535
      RefreshLine(y, xs, xe, 0);
      }
#line 1537
      return;
    }
  } else {
#line 1542
    if (- n >= (xe - xs) + 1) {
#line 1543
      n = - ((xe - xs) + 1);
    }
#line 1544
    if (! display->d_insert) {
#line 1546
      if (display->d_tcs[30].str) {
#line 1546
        if (! (n == -1 && display->d_tcs[29].str)) {
          {
#line 1547
          AddCStr2(display->d_tcs[30].str, - n);
          }
        } else {
#line 1546
          goto _L___56;
        }
      } else
      _L___56: /* CIL Label */ 
#line 1548
      if (display->d_tcs[29].str) {
#line 1550
        i = - n;
        {
#line 1550
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1550
          if (! __cil_tmp9) {
#line 1550
            goto while_break___0;
          }
          {
#line 1551
          AddCStr(display->d_tcs[29].str);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 1553
      if (display->d_tcs[27].str) {
        {
#line 1555
        InsertMode(1);
#line 1556
        SetRendition(& mchar_null);
#line 1558
        SetBackColor(bce);
#line 1560
        i = - n;
        }
        {
#line 1560
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1560
          if (! __cil_tmp10) {
#line 1560
            goto while_break___1;
          }
          {
#line 1561
          INSERTCHAR(' ');
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1562
        bce = 0;
      } else {
        {
#line 1567
        RefreshLine(y, xs, xe, 0);
        }
#line 1568
        return;
      }
    } else {
      {
#line 1573
      SetRendition(& mchar_null);
#line 1575
      SetBackColor(bce);
#line 1577
      i = - n;
      }
      {
#line 1577
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1577
        if (! __cil_tmp11) {
#line 1577
          goto while_break___2;
        }
        {
#line 1578
        INSERTCHAR(' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1579
      bce = 0;
    }
  }
#line 1582
  if (bce) {
#line 1582
    if (! display->d_tcs[66].flg) {
#line 1584
      if (n > 0) {
        {
#line 1585
        ClearLine((struct mline *)0, y, (xe - n) + 1, xe, bce);
        }
      } else {
        {
#line 1587
        ClearLine((struct mline *)0, y, xs, (xs - n) - 1, bce);
        }
      }
    }
  }
#line 1589
  if (display->d_lp_missing) {
#line 1589
    if (y == display->d_bot) {
#line 1591
      if (n > 0) {
        {
#line 1592
        WriteLP((display->d_width - 1) - n, y);
        }
      }
#line 1593
      display->d_lp_missing = 0;
    }
  }
}
}
#line 1598 "/tmp/screen-3.9.15/display.c"
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) 
{ 
  int i ;
  int up ;
  int oldtop ;
  int oldbot ;
  int alok ;
  int dlok ;
  int aldlfaster ;
  int missy ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int __cil_tmp18 ;
  int tmp___0 ;
  int __cil_tmp20 ;

  {
#line 1605
  missy = 0;
  {
#line 1607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1608
  if (n == 0) {
#line 1609
    return;
  }
#line 1610
  if (n >= (ye - ys) + 1) {
    {
    {
#line 1612
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
    }
#line 1613
    return;
  } else
#line 1610
  if (- n >= (ye - ys) + 1) {
    {
    {
#line 1612
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
    }
#line 1613
    return;
  }
#line 1615
  if (xs > display->d_vpxmin) {
    {
    {
#line 1617
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1618
    return;
  } else
#line 1615
  if (xe < display->d_vpxmax) {
    {
    {
#line 1617
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1618
    return;
  }
#line 1621
  if (display->d_lp_missing) {
#line 1623
    if (display->d_bot > ye) {
#line 1624
      missy = display->d_bot;
    } else
#line 1623
    if (display->d_bot < ys) {
#line 1624
      missy = display->d_bot;
    } else {
#line 1627
      missy = display->d_bot - n;
#line 1628
      if (missy > ye) {
#line 1629
        display->d_lp_missing = 0;
      } else
#line 1628
      if (missy < ys) {
#line 1629
        display->d_lp_missing = 0;
      }
    }
  }
#line 1633
  up = 1;
#line 1634
  if (n < 0) {
#line 1636
    up = 0;
#line 1637
    n = - n;
  }
#line 1639
  if (n >= (ye - ys) + 1) {
#line 1640
    n = (ye - ys) + 1;
  }
#line 1642
  oldtop = display->d_top;
#line 1643
  oldbot = display->d_bot;
#line 1644
  if (ys < display->d_top) {
    {
    {
#line 1645
    ChangeScrollRegion(ys, ye);
    }
    }
  } else
#line 1644
  if (display->d_bot != ye) {
    {
    {
#line 1645
    ChangeScrollRegion(ys, ye);
    }
    }
  }
#line 1646
  alok = (display->d_tcs[22].str || display->d_tcs[23].str) || ((ys >= display->d_top && ye == display->d_bot) && up);
#line 1647
  dlok = (display->d_tcs[24].str || display->d_tcs[25].str) || ((ys >= display->d_top && ye == display->d_bot) && ! up);
#line 1648
  if (display->d_top != ys) {
#line 1648
    if (! (alok && dlok)) {
      {
#line 1649
      ChangeScrollRegion(ys, ye);
      }
    }
  }
#line 1651
  if (display->d_lp_missing) {
#line 1651
    if (oldbot != display->d_bot) {
      _L: /* CIL Label */ 
      {
#line 1655
      WriteLP(display->d_width - 1, oldbot);
      }
#line 1656
      if (oldbot == display->d_bot) {
#line 1658
        n --;
#line 1658
        if (n == 0) {
#line 1663
          if (bce) {
#line 1663
            if (! display->d_tcs[66].flg) {
              {
#line 1664
              ClearLine((struct mline *)0, ye, xs, xe, bce);
              }
            }
          }
#line 1665
          return;
        }
      }
    } else
#line 1651
    if (oldbot == display->d_bot) {
#line 1651
      if (up) {
#line 1651
        if (display->d_top == ys) {
#line 1651
          if (display->d_bot == ye) {
#line 1651
            goto _L;
          }
        }
      }
    }
  }
#line 1670
  if (display->d_tcs[33].flg) {
    {
#line 1671
    SetRendition(& mchar_null);
    }
  }
#line 1673
  if (display->d_tcs[66].flg) {
    {
#line 1674
    SetBackColor(bce);
    }
  }
#line 1677
  aldlfaster = ((n > 1 && ys >= display->d_top) && ye == display->d_bot) && ((up && display->d_tcs[25].str) || (! up && display->d_tcs[23].str));
#line 1679
  if (up) {
    _L___64: /* CIL Label */ 
#line 1679
    if (display->d_top == ys) {
#line 1679
      if (display->d_bot == ye) {
#line 1679
        if (! aldlfaster) {
#line 1681
          if (up) {
            {
#line 1683
            GotoPos(0, ye);
#line 1684
            i = n;
            }
            {
#line 1684
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1684
              if (! (__cil_tmp15 > 0)) {
#line 1684
                goto while_break___0;
              }
              {
#line 1685
              AddCStr(display->d_tcs[19].str);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 1689
            GotoPos(0, ys);
#line 1690
            i = n;
            }
            {
#line 1690
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1690
              if (! (__cil_tmp16 > 0)) {
#line 1690
                goto while_break___1;
              }
              {
#line 1691
              AddCStr(display->d_tcs[21].str);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1679
          goto _L___61;
        }
      } else {
#line 1679
        goto _L___61;
      }
    } else {
#line 1679
      goto _L___61;
    }
  } else
#line 1679
  if (display->d_tcs[21].str) {
#line 1679
    goto _L___64;
  } else
  _L___61: /* CIL Label */ 
#line 1694
  if (alok) {
#line 1694
    if (dlok) {
#line 1696
      if (up) {
        _L___58: /* CIL Label */ 
#line 1698
        if (up) {
#line 1698
          tmp = ys;
        } else {
#line 1698
          tmp = (ye + 1) - n;
        }
        {
#line 1698
        GotoPos(0, tmp);
        }
#line 1699
        if (display->d_tcs[25].str) {
#line 1699
          if (! (n == 1 && display->d_tcs[24].str)) {
            {
#line 1700
            AddCStr2(display->d_tcs[25].str, n);
            }
          } else {
#line 1699
            goto _L___57;
          }
        } else {
          _L___57: /* CIL Label */ 
#line 1702
          i = n;
          {
#line 1702
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1702
            if (! __cil_tmp18) {
#line 1702
              goto while_break___2;
            }
            {
#line 1703
            AddCStr(display->d_tcs[24].str);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else
#line 1696
      if (ye != display->d_bot) {
#line 1696
        goto _L___58;
      }
#line 1705
      if (! up) {
        _L___60: /* CIL Label */ 
#line 1707
        if (up) {
#line 1707
          tmp___0 = (ye + 1) - n;
        } else {
#line 1707
          tmp___0 = ys;
        }
        {
#line 1707
        GotoPos(0, tmp___0);
        }
#line 1708
        if (display->d_tcs[23].str) {
#line 1708
          if (! (n == 1 && display->d_tcs[22].str)) {
            {
#line 1709
            AddCStr2(display->d_tcs[23].str, n);
            }
          } else {
#line 1708
            goto _L___59;
          }
        } else {
          _L___59: /* CIL Label */ 
#line 1711
          i = n;
          {
#line 1711
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1711
            if (! __cil_tmp20) {
#line 1711
              goto while_break___3;
            }
            {
#line 1712
            AddCStr(display->d_tcs[22].str);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else
#line 1705
      if (ye != display->d_bot) {
#line 1705
        goto _L___60;
      }
    } else {
      {
      {
#line 1717
      RefreshArea(xs, ys, xe, ye, 0);
      }
      }
#line 1718
      return;
    }
  } else {
    {
    {
#line 1717
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1718
    return;
  }
#line 1720
  if (bce) {
#line 1720
    if (! display->d_tcs[66].flg) {
#line 1722
      if (up) {
        {
#line 1723
        ClearArea(xs, (ye - n) + 1, xs, xe, xe, ye, bce, 0);
        }
      } else {
        {
#line 1725
        ClearArea(xs, ys, xs, xe, xe, (ys + n) - 1, bce, 0);
        }
      }
    }
  }
#line 1727
  if (display->d_lp_missing) {
#line 1727
    if (missy != display->d_bot) {
      {
#line 1728
      WriteLP(display->d_width - 1, missy);
      }
    }
  }
}
}
#line 1737 "/tmp/screen-3.9.15/display.c"
void SetAttr(int new ) 
{ 
  register int i ;
  register int j ;
  register int old ;
  register int typ ;
  int __cil_tmp6 ;

  {
#line 1742
  old = (int )display->d_rend.attr;
#line 1742
  if (! display) {
#line 1743
    return;
  } else
#line 1742
  if (old == new) {
#line 1743
    return;
  }
#line 1745
  display->d_col16change = (old ^ new) & ((1 << 6) | (1 << 7));
#line 1746
  new ^= display->d_col16change;
#line 1747
  if (old == new) {
#line 1748
    return;
  }
#line 1768
  typ = (int )display->d_atyp;
#line 1769
  if ((new & old) != old) {
#line 1771
    if (typ & (1 << 2)) {
      {
#line 1772
      AddCStr(display->d_tcs[53].str);
      }
    }
#line 1773
    if (typ & (1 << 1)) {
      {
#line 1774
      AddCStr(display->d_tcs[54].str);
      }
    }
#line 1775
    if (typ & 1) {
      {
#line 1777
      AddCStr(display->d_tcs[55].str);
      }
#line 1780
      if (display->d_hascolor) {
#line 1781
        display->d_rend.attr &= ~ ((1 << 7) | (1 << 6));
#line 1781
        display->d_rend.color = (unsigned char )0;
      }
#line 1784
      if (! display->d_tcs[97].flg) {
#line 1787
        display->d_rend.font = (unsigned char )0;
#line 1789
        display->d_realfont = 0;
      }
    }
#line 1794
    old = 0;
#line 1795
    typ = 0;
  }
#line 1797
  old ^= new;
#line 1798
  j = 1;
#line 1798
  i = 0;
  {
#line 1798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1798
    if (! (old && i < 6)) {
#line 1798
      goto while_break;
    }
#line 1800
    if ((old & j) == 0) {
#line 1801
      goto while_continue;
    }
#line 1802
    old ^= j;
#line 1803
    if (display->d_attrtab[i]) {
      {
#line 1805
      AddCStr(display->d_attrtab[i]);
#line 1806
      typ |= (int )display->d_attrtyp[i];
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1798
  j <<= 1;
#line 1798
  __cil_tmp6 = i;
#line 1798
  i ++;
#line 1809
  display->d_rend.attr = (unsigned char )new;
#line 1810
  display->d_atyp = (char )typ;
}
}
#line 1815 "/tmp/screen-3.9.15/display.c"
void SetFont(int new ) 
{ 
  int old ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1818
  old = (int )display->d_rend.font;
#line 1819
  if (! display) {
#line 1820
    return;
  } else
#line 1819
  if (old == new) {
#line 1820
    return;
  }
  {
#line 1821
  display->d_rend.font = (unsigned char )new;
#line 1823
  __cil_tmp3 = CanEncodeFont(display->d_encoding, new);
  }
#line 1823
  if (display->d_encoding) {
#line 1823
    if (__cil_tmp3) {
#line 1824
      return;
    }
  }
#line 1825
  if (new == display->d_realfont) {
#line 1826
    return;
  }
#line 1827
  display->d_realfont = new;
#line 1829
  if (display->d_xtable) {
#line 1829
    if (*(display->d_xtable + (int )((unsigned char )new))) {
#line 1829
      if (*(*(display->d_xtable + (int )((unsigned char )new)) + 256)) {
        {
#line 1832
        AddCStr(*(*(display->d_xtable + (int )((unsigned char )new)) + 256));
        }
#line 1833
        return;
      }
    }
  }
#line 1836
  if (! display->d_tcs[97].flg) {
#line 1836
    if (new != 48) {
#line 1838
      new = 0;
#line 1839
      if (old == new) {
#line 1840
        return;
      }
    }
  }
#line 1843
  if (new == 0) {
    {
#line 1844
    AddCStr(display->d_tcs[99].str);
    }
  } else
#line 1846
  if (new < 32) {
    {
#line 1848
    AddStr((char *)"\033$");
    }
#line 1849
    if (new > 2) {
      {
#line 1850
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1850
        (display->d_obuffree) --;
#line 1850
        if (display->d_obuffree <= 0) {
          {
#line 1850
          Resize_obuf();
          }
        }
#line 1850
        __cil_tmp4 = display->d_obufp;
#line 1850
        (display->d_obufp) ++;
#line 1850
        *__cil_tmp4 = (char )'(';
#line 1850
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1851
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1851
      (display->d_obuffree) --;
#line 1851
      if (display->d_obuffree <= 0) {
        {
#line 1851
        Resize_obuf();
        }
      }
#line 1851
      __cil_tmp5 = display->d_obufp;
#line 1851
      (display->d_obufp) ++;
#line 1851
      *__cil_tmp5 = (char )(new + 64);
#line 1851
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1855
    AddCStr2(display->d_tcs[98].str, new);
    }
  }
}
}
#line 1862 "/tmp/screen-3.9.15/display.c"
int color256to16(int jj ) 
{ 
  int min ;
  int max ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;

  {
#line 1868
  if (jj >= 232) {
#line 1870
    jj = (jj - 232) / 6;
#line 1871
    if (jj & 2) {
#line 1871
      tmp = 7;
    } else {
#line 1871
      tmp = 0;
    }
#line 1871
    jj = ((jj & 1) << 3) | tmp;
  } else
#line 1873
  if (jj >= 16) {
#line 1875
    jj -= 16;
#line 1876
    r = jj / 36;
#line 1877
    g = (jj / 6) % 6;
#line 1878
    b = jj % 6;
#line 1879
    if (r < g) {
#line 1879
      if (r < b) {
#line 1879
        tmp___0 = r;
      } else {
#line 1879
        tmp___0 = b;
      }
#line 1879
      tmp___66 = tmp___0;
    } else {
#line 1879
      if (g < b) {
#line 1879
        tmp___65 = g;
      } else {
#line 1879
        tmp___65 = b;
      }
#line 1879
      tmp___66 = tmp___65;
    }
#line 1879
    min = tmp___66;
#line 1880
    if (r > g) {
#line 1880
      if (r > b) {
#line 1880
        tmp___67 = r;
      } else {
#line 1880
        tmp___67 = b;
      }
#line 1880
      tmp___69 = tmp___67;
    } else {
#line 1880
      if (g > b) {
#line 1880
        tmp___68 = g;
      } else {
#line 1880
        tmp___68 = b;
      }
#line 1880
      tmp___69 = tmp___68;
    }
#line 1880
    max = tmp___69;
#line 1881
    if (min == max) {
#line 1882
      if ((max + 1) & 4) {
#line 1882
        tmp___70 = 7;
      } else {
#line 1882
        tmp___70 = 0;
      }
#line 1882
      jj = (((max + 1) & 2) << 2) | tmp___70;
    } else {
#line 1884
      if (max > 3) {
#line 1884
        tmp___71 = 8;
      } else {
#line 1884
        tmp___71 = 0;
      }
#line 1884
      jj = ((((b - min) / (max - min) << 2) | ((g - min) / (max - min) << 1)) | (r - min) / (max - min)) | tmp___71;
    }
  }
#line 1887
  return (jj);
}
}
#line 1912 "/tmp/screen-3.9.15/display.c"
void SetColor(int f , int b ) 
{ 
  int of ;
  int ob ;
  static unsigned char sftrans[8] ;
  int tmp ;
  int tmp___72 ;
  int oattr ;
  char *tmp___73 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;

  {
#line 1916
  sftrans[0] = (unsigned char )0;
#line 1916
  sftrans[1] = (unsigned char )4;
#line 1916
  sftrans[2] = (unsigned char )2;
#line 1916
  sftrans[3] = (unsigned char )6;
#line 1916
  sftrans[4] = (unsigned char )1;
#line 1916
  sftrans[5] = (unsigned char )5;
#line 1916
  sftrans[6] = (unsigned char )3;
#line 1916
  sftrans[7] = (unsigned char )7;
#line 1918
  if (! display) {
#line 1919
    return;
  }
#line 1921
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 1921
    tmp = 256;
  } else {
#line 1921
    tmp = 0;
  }
#line 1921
  of = ((int )display->d_rend.color & 15) | tmp;
#line 1922
  if ((int )display->d_rend.attr & (1 << 7)) {
#line 1922
    tmp___72 = 256;
  } else {
#line 1922
    tmp___72 = 0;
  }
#line 1922
  ob = (((int )display->d_rend.color & 240) >> 4) | tmp___72;
#line 1926
  if (f == 256) {
#line 1927
    f = 0;
  }
#line 1928
  if (b == 256) {
#line 1929
    b = 0;
  }
  {
#line 1931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1931
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1932
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1932
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1933
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1933
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1934
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1934
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1936
  if (! display->d_tcs[67].flg) {
#line 1936
    if (display->d_hascolor) {
#line 1936
      if (f == 0) {
#line 1936
        if (f != of) {
          _L: /* CIL Label */ 
#line 1938
          if (display->d_tcs[64].str) {
            {
#line 1939
            AddCStr(display->d_tcs[64].str);
            }
          } else {
#line 1943
            oattr = (int )display->d_rend.attr;
#line 1944
            if (display->d_tcs[55].str) {
#line 1944
              tmp___73 = display->d_tcs[55].str;
            } else {
#line 1944
              tmp___73 = (char *)"\033[m";
            }
            {
#line 1944
            AddCStr(tmp___73);
            }
#line 1946
            if (display->d_tcs[55].str) {
#line 1946
              if (! display->d_tcs[97].flg) {
#line 1949
                display->d_rend.font = (unsigned char )0;
#line 1951
                display->d_realfont = 0;
              }
            }
            {
#line 1955
            display->d_atyp = (char )0;
#line 1956
            display->d_rend.attr = (unsigned char )0;
#line 1957
            SetAttr(oattr);
            }
          }
#line 1959
          ob = 0;
#line 1959
          of = ob;
        } else {
#line 1936
          goto _L___74;
        }
      } else
      _L___74: /* CIL Label */ 
#line 1936
      if (b == 0) {
#line 1936
        if (b != ob) {
#line 1936
          goto _L;
        }
      }
    }
  }
#line 1961
  if (f & 256) {
#line 1961
    tmp___75 = 0;
  } else {
#line 1961
    tmp___75 = 1 << 6;
  }
#line 1961
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 6)) ^ tmp___75);
#line 1961
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 240) | (f & 15));
#line 1962
  if (b & 256) {
#line 1962
    tmp___76 = 0;
  } else {
#line 1962
    tmp___76 = 1 << 7;
  }
#line 1962
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 7)) ^ tmp___76);
#line 1962
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 15) | ((b << 4) & 240));
#line 1964
  display->d_col16change = 0;
#line 1966
  if (! display->d_hascolor) {
#line 1967
    return;
  }
#line 1968
  if (f) {
#line 1968
    if ((f & 504) == 264) {
#line 1968
      tmp___77 = f ^ 264;
    } else {
#line 1968
      tmp___77 = f & 255;
    }
#line 1968
    tmp___78 = tmp___77 ^ 9;
  } else {
#line 1968
    tmp___78 = - 1;
  }
#line 1968
  f = tmp___78;
#line 1969
  if (b) {
#line 1969
    if ((b & 504) == 264) {
#line 1969
      tmp___79 = b ^ 264;
    } else {
#line 1969
      tmp___79 = b & 255;
    }
#line 1969
    tmp___80 = tmp___79 ^ 9;
  } else {
#line 1969
    tmp___80 = - 1;
  }
#line 1969
  b = tmp___80;
#line 1970
  if (of) {
#line 1970
    if ((of & 504) == 264) {
#line 1970
      tmp___81 = of ^ 264;
    } else {
#line 1970
      tmp___81 = of & 255;
    }
#line 1970
    tmp___82 = tmp___81 ^ 9;
  } else {
#line 1970
    tmp___82 = - 1;
  }
#line 1970
  of = tmp___82;
#line 1971
  if (ob) {
#line 1971
    if ((ob & 504) == 264) {
#line 1971
      tmp___83 = ob ^ 264;
    } else {
#line 1971
      tmp___83 = ob & 255;
    }
#line 1971
    tmp___84 = tmp___83 ^ 9;
  } else {
#line 1971
    tmp___84 = - 1;
  }
#line 1971
  ob = tmp___84;
#line 1988
  if (f != of) {
#line 1988
    if (f != (of | 8)) {
#line 1990
      if (f == -1) {
        {
#line 1991
        AddCStr((char *)"\033[39m");
        }
      } else
#line 1992
      if (display->d_tcs[60].str) {
        {
#line 1993
        AddCStr2(display->d_tcs[60].str, f & 7);
        }
      } else
#line 1994
      if (display->d_tcs[62].str) {
        {
#line 1995
        AddCStr2(display->d_tcs[62].str, (int )sftrans[f & 7]);
        }
      }
    }
  }
#line 1997
  if (b != ob) {
#line 1997
    if (b != (ob | 8)) {
#line 1999
      if (b == -1) {
        {
#line 2000
        AddCStr((char *)"\033[49m");
        }
      } else
#line 2001
      if (display->d_tcs[61].str) {
        {
#line 2002
        AddCStr2(display->d_tcs[61].str, b & 7);
        }
      } else
#line 2003
      if (display->d_tcs[63].str) {
        {
#line 2004
        AddCStr2(display->d_tcs[63].str, (int )sftrans[b & 7]);
        }
      }
    }
  }
#line 2007
  if (f != of) {
#line 2007
    if (display->d_tcs[96].flg) {
#line 2007
      if ((f & 8) != 0) {
#line 2007
        if (f != -1) {
          {
#line 2010
          AddCStr2((char *)"\033[9%p1%dm", f & 7);
          }
        }
      }
    }
  }
#line 2015
  if (b != ob) {
#line 2015
    if (display->d_tcs[96].flg) {
#line 2015
      if ((b & 8) != 0) {
#line 2015
        if (b != -1) {
          {
#line 2018
          AddCStr2((char *)"\033[10%p1%dm", b & 7);
          }
        }
      }
    }
  }
}
}
#line 2027 "/tmp/screen-3.9.15/display.c"
static void SetBackColor(int new ) 
{ 
  int tmp ;

  {
#line 2030
  if (! display) {
#line 2031
    return;
  }
#line 2032
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 2032
    tmp = 256;
  } else {
#line 2032
    tmp = 0;
  }
  {
#line 2032
  SetColor(((int )display->d_rend.color & 15) | tmp, new);
  }
}
}
#line 2037 "/tmp/screen-3.9.15/display.c"
void SetRendition(struct mchar *mc ) 
{ 
  static struct mchar mmc ;
  int i ;
  int a ;
  int tmp ;
  int tmp___88 ;

  {
#line 2040
  if (! display) {
#line 2041
    return;
  }
#line 2042
  if (nattr2color) {
#line 2042
    if (display->d_hascolor) {
#line 2042
      if (((int )mc->attr & nattr2color) != 0) {
#line 2046
        mmc = *mc;
#line 2047
        i = 0;
        {
#line 2047
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2047
          if (! (i < 8)) {
#line 2047
            goto while_break;
          }
#line 2048
          if ((int *)attr2color[i]) {
#line 2048
            if (((int )mc->attr & (1 << i)) != 0) {
#line 2050
              if ((int )mc->color == 0) {
#line 2050
                if (attr2color[i][3]) {
                  {
#line 2051
                  ApplyAttrColor(attr2color[i][3], & mmc);
                  }
                } else {
#line 2050
                  goto _L___85;
                }
              } else
              _L___85: /* CIL Label */ 
#line 2052
              if (((int )mc->color & 15) == 0) {
#line 2052
                if (attr2color[i][2]) {
                  {
#line 2053
                  ApplyAttrColor(attr2color[i][2], & mmc);
                  }
                } else {
#line 2052
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 2054
              if (((int )mc->color & 240) == 0) {
#line 2054
                if (attr2color[i][1]) {
                  {
#line 2055
                  ApplyAttrColor(attr2color[i][1], & mmc);
                  }
                } else {
                  {
                  {
#line 2057
                  ApplyAttrColor(attr2color[i][0], & mmc);
                  }
                  }
                }
              } else {
                {
                {
#line 2057
                ApplyAttrColor(attr2color[i][0], & mmc);
                }
                }
              }
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 2047
        i ++;
#line 2059
        mc = & mmc;
        {
#line 2060
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2060
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 2062
  if (display->d_hascolor) {
#line 2062
    if (display->d_tcs[68].flg) {
#line 2062
      if ((int )mc->attr & ((1 << 6) | (1 << 7))) {
#line 2064
        a = (int )mc->attr;
#line 2065
        if ((int )mc->attr & (1 << 6)) {
#line 2065
          if (display->d_tcs[49].str) {
#line 2066
            a |= 1 << 2;
          }
        }
#line 2067
        if ((int )mc->attr & (1 << 7)) {
#line 2067
          if (display->d_tcs[52].str) {
#line 2068
            a |= 1 << 5;
          }
        }
#line 2069
        if ((int )display->d_rend.attr != a) {
          {
#line 2070
          SetAttr(a);
          }
        }
      } else {
#line 2062
        goto _L___86;
      }
    } else {
#line 2062
      goto _L___86;
    }
  } else
  _L___86: /* CIL Label */ 
#line 2072
  if ((int )display->d_rend.attr != (int )mc->attr) {
    {
#line 2073
    SetAttr((int )mc->attr);
    }
  }
#line 2075
  if ((int )display->d_rend.color != (int )mc->color) {
    _L___89: /* CIL Label */ 
#line 2083
    if ((int )mc->attr & (1 << 6)) {
#line 2083
      tmp = 256;
    } else {
#line 2083
      tmp = 0;
    }
#line 2083
    if ((int )mc->attr & (1 << 7)) {
#line 2083
      tmp___88 = 256;
    } else {
#line 2083
      tmp___88 = 0;
    }
    {
#line 2083
    SetColor(((int )mc->color & 15) | tmp, (((int )mc->color & 240) >> 4) | tmp___88);
    }
  } else
#line 2075
  if (display->d_col16change) {
#line 2075
    goto _L___89;
  }
#line 2086
  if ((int )display->d_rend.font != (int )mc->font) {
    {
#line 2087
    SetFont((int )mc->font);
    }
  }
}
}
#line 2092 "/tmp/screen-3.9.15/display.c"
void SetRenditionMline(struct mline *ml , int x ) 
{ 
  struct mchar mc ;
  int a ;
  struct mchar mc___0 ;
  int tmp ;
  int tmp___91 ;

  {
#line 2096
  if (! display) {
#line 2097
    return;
  }
#line 2098
  if (nattr2color) {
#line 2098
    if (display->d_hascolor) {
#line 2098
      if (((int )*(ml->attr + x) & nattr2color) != 0) {
        {
#line 2101
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2101
          mc.image = *(ml->image + x);
#line 2101
          mc.attr = *(ml->attr + x);
#line 2101
          mc.font = *(ml->font + x);
#line 2101
          mc.color = *(ml->color + x);
#line 2101
          mc.mbcs = (unsigned char )0;
#line 2101
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2102
        SetRendition(& mc);
        }
#line 2103
        return;
      }
    }
  }
#line 2105
  if (display->d_hascolor) {
#line 2105
    if (display->d_tcs[68].flg) {
#line 2105
      if ((int )*(ml->attr + x) & ((1 << 6) | (1 << 7))) {
#line 2107
        a = (int )*(ml->attr + x);
#line 2108
        if ((int )*(ml->attr + x) & (1 << 6)) {
#line 2108
          if (display->d_tcs[49].str) {
#line 2109
            a |= 1 << 2;
          }
        }
#line 2110
        if ((int )*(ml->attr + x) & (1 << 7)) {
#line 2110
          if (display->d_tcs[52].str) {
#line 2111
            a |= 1 << 5;
          }
        }
#line 2112
        if ((int )display->d_rend.attr != a) {
          {
#line 2113
          SetAttr(a);
          }
        }
      } else {
#line 2105
        goto _L;
      }
    } else {
#line 2105
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2115
  if ((int )display->d_rend.attr != (int )*(ml->attr + x)) {
    {
#line 2116
    SetAttr((int )*(ml->attr + x));
    }
  }
#line 2118
  if ((int )display->d_rend.color != (int )*(ml->color + x)) {
    _L___92: /* CIL Label */ 
    {
#line 2128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2128
      mc___0.image = *(ml->image + x);
#line 2128
      mc___0.attr = *(ml->attr + x);
#line 2128
      mc___0.font = *(ml->font + x);
#line 2128
      mc___0.color = *(ml->color + x);
#line 2128
      mc___0.mbcs = (unsigned char )0;
#line 2128
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2129
    if ((int )mc___0.attr & (1 << 6)) {
#line 2129
      tmp = 256;
    } else {
#line 2129
      tmp = 0;
    }
#line 2129
    if ((int )mc___0.attr & (1 << 7)) {
#line 2129
      tmp___91 = 256;
    } else {
#line 2129
      tmp___91 = 0;
    }
    {
#line 2129
    SetColor(((int )mc___0.color & 15) | tmp, (((int )mc___0.color & 240) >> 4) | tmp___91);
    }
  } else
#line 2118
  if (display->d_col16change) {
#line 2118
    goto _L___92;
  }
#line 2133
  if ((int )display->d_rend.font != (int )*(ml->font + x)) {
    {
#line 2134
    SetFont((int )*(ml->font + x));
    }
  }
}
}
#line 2139 "/tmp/screen-3.9.15/display.c"
void MakeStatus(char *msg ) 
{ 
  register char *s ;
  register char *t ;
  register int max ;
  register int ti ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;
  time_t __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *buf ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp15 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *tmp___95 ;
  time_t __cil_tmp23 ;

  {
#line 2145
  if (! display) {
#line 2146
    return;
  }
#line 2148
  if (! display->d_tcinited) {
    {
#line 2150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2150
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2151
    if (display->d_processinputdata) {
#line 2152
      return;
    }
    {
#line 2153
    AddStr(msg);
#line 2154
    AddStr((char *)"\r\n");
#line 2155
    Flush();
    }
#line 2156
    return;
  }
#line 2158
  if (! use_hardstatus) {
    _L: /* CIL Label */ 
#line 2160
    max = display->d_width;
#line 2161
    if (display->d_tcs[87].flg == 0) {
#line 2162
      __cil_tmp6 = max;
#line 2162
      max --;
    }
  } else
#line 2158
  if (! display->d_tcs[75].flg) {
#line 2158
    goto _L;
  } else {
#line 2165
    if (display->d_tcs[76].num > 0) {
#line 2165
      tmp = display->d_tcs[76].num;
    } else {
#line 2165
      tmp = display->d_width - ! display->d_tcs[87].flg;
    }
#line 2165
    max = tmp;
  }
#line 2166
  if (display->d_status) {
    {
#line 2169
    __cil_tmp8 = strcmp((char const   *)msg, (char const   *)display->d_status_lastmsg);
    }
#line 2169
    if (__cil_tmp8 == 0) {
      {
#line 2171
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2171
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2172
      SetTimeout(& display->d_statusev, MsgWait * 1000);
      }
#line 2173
      return;
    }
#line 2175
    if (! display->d_status_bell) {
      {
#line 2177
      __cil_tmp9 = time((time_t *)0);
#line 2177
      ti = (int )(__cil_tmp9 - display->d_status_time);
      }
#line 2178
      if (ti < MsgMinWait) {
        {
#line 2179
        DisplaySleep(MsgMinWait - ti, 0);
        }
      }
    }
    {
#line 2181
    RemoveStatus();
    }
  }
#line 2183
  t = msg;
#line 2183
  s = t;
  {
#line 2183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2183
    if (! ((int )*s && t - msg < (long )max)) {
#line 2183
      goto while_break___1;
    }
#line 2184
    if ((int )*s == 7) {
      {
#line 2185
      AddCStr(display->d_tcs[42].str);
      }
    } else
#line 2186
    if ((int )((unsigned char )*s) >= 32) {
#line 2186
      if ((int )*s != 127) {
#line 2187
        __cil_tmp10 = t;
#line 2187
        t ++;
#line 2187
        *__cil_tmp10 = *s;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2183
  s ++;
#line 2188
  *t = (char )'\000';
#line 2189
  if (t == msg) {
#line 2190
    return;
  }
#line 2191
  if (t - msg >= (long )display->d_status_buflen) {
#line 2194
    if (display->d_status_lastmsg) {
      {
#line 2195
      __cil_tmp12 = realloc((void *)display->d_status_lastmsg, (unsigned long )((t - msg) + 1L));
#line 2195
      buf = (char *)__cil_tmp12;
      }
    } else {
      {
#line 2197
      __cil_tmp13 = malloc((unsigned long )((t - msg) + 1L));
#line 2197
      buf = (char *)__cil_tmp13;
      }
    }
#line 2198
    if (buf) {
#line 2200
      display->d_status_lastmsg = buf;
#line 2201
      display->d_status_buflen = (int )((t - msg) + 1L);
    }
  }
#line 2204
  if (t - msg < (long )display->d_status_buflen) {
    {
#line 2205
    strcpy(display->d_status_lastmsg, (char const   *)msg);
    }
  }
#line 2206
  display->d_status_len = (int )(t - msg);
#line 2207
  display->d_status_lastx = display->d_x;
#line 2208
  display->d_status_lasty = display->d_y;
#line 2209
  if (! use_hardstatus) {
    _L___93: /* CIL Label */ 
#line 2211
    display->d_status = 1;
    {
#line 2212
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2212
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2213
    GotoPos(0, display->d_height - 1);
#line 2214
    SetRendition(& mchar_so);
#line 2215
    InsertMode(0);
#line 2216
    AddStr(msg);
    }
#line 2217
    if (display->d_status_len < max) {
      {
#line 2220
      (display->d_status_len) ++;
#line 2221
      SetRendition(& mchar_null);
      }
      {
#line 2222
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2222
        (display->d_obuffree) --;
#line 2222
        if (display->d_obuffree <= 0) {
          {
#line 2222
          Resize_obuf();
          }
        }
#line 2222
        __cil_tmp15 = display->d_obufp;
#line 2222
        (display->d_obufp) ++;
#line 2222
        *__cil_tmp15 = (char )' ';
#line 2222
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2223
      if (display->d_status_len < max) {
#line 2225
        (display->d_status_len) ++;
        {
#line 2226
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2226
          (display->d_obuffree) --;
#line 2226
          if (display->d_obuffree <= 0) {
            {
#line 2226
            Resize_obuf();
            }
          }
#line 2226
          __cil_tmp17 = display->d_obufp;
#line 2226
          (display->d_obufp) ++;
#line 2226
          *__cil_tmp17 = (char )' ';
#line 2226
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2227
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2227
          (display->d_obuffree) --;
#line 2227
          if (display->d_obuffree <= 0) {
            {
#line 2227
            Resize_obuf();
            }
          }
#line 2227
          __cil_tmp18 = display->d_obufp;
#line 2227
          (display->d_obufp) ++;
#line 2227
          *__cil_tmp18 = (char )'\b';
#line 2227
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2229
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2229
        (display->d_obuffree) --;
#line 2229
        if (display->d_obuffree <= 0) {
          {
#line 2229
          Resize_obuf();
          }
        }
#line 2229
        __cil_tmp19 = display->d_obufp;
#line 2229
        (display->d_obufp) ++;
#line 2229
        *__cil_tmp19 = (char )'\b';
#line 2229
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 2231
    display->d_x = - 1;
  } else
#line 2209
  if (display->d_has_hstatus == 0) {
#line 2209
    goto _L___93;
  } else
#line 2209
  if (display->d_has_hstatus == 2) {
#line 2209
    goto _L___93;
  } else {
    {
#line 2235
    display->d_status = 2;
#line 2236
    ShowHStatus(msg);
    }
  }
  {
#line 2238
  Flush();
  }
#line 2239
  if (! display) {
#line 2240
    return;
  }
#line 2241
  if (display->d_status == 1) {
#line 2243
    olddisplay = display;
#line 2244
    oldflayer = flayer;
    {
#line 2246
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2246
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2248
    display->d_status = 0;
#line 2249
    GotoPos(0, display->d_height - 1);
#line 2250
    RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
#line 2251
    GotoPos(display->d_status_lastx, display->d_status_lasty);
    }
#line 2252
    if (display->d_forecv) {
#line 2252
      tmp___95 = (display->d_forecv)->c_layer;
    } else {
#line 2252
      tmp___95 = (struct layer *)0;
    }
#line 2252
    flayer = tmp___95;
#line 2253
    if (flayer) {
      {
#line 2254
      LGotoPos(flayer, flayer->l_x, flayer->l_y);
      }
    }
#line 2255
    display = olddisplay;
#line 2256
    flayer = oldflayer;
#line 2257
    display->d_status_obuflen = display->d_obuflen;
#line 2258
    display->d_status_obuffree = display->d_obuffree;
#line 2259
    display->d_obuflen = 0;
#line 2259
    display->d_obuffree = display->d_obuflen;
#line 2260
    display->d_status = 1;
  }
  {
#line 2262
  __cil_tmp23 = time(& display->d_status_time);
#line 2263
  SetTimeout(& display->d_statusev, MsgWait * 1000);
#line 2264
  evenq(& display->d_statusev);
  }
}
}
#line 2271 "/tmp/screen-3.9.15/display.c"
void RemoveStatus(void) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int where ;
  struct layer *tmp ;

  {
#line 2277
  if (! display) {
#line 2278
    return;
  }
#line 2279
  where = display->d_status;
#line 2279
  if (! where) {
#line 2280
    return;
  }
  {
#line 2282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2282
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2283
  if (display->d_status_obuffree >= 0) {
    {
#line 2285
    display->d_obuflen = display->d_status_obuflen;
#line 2286
    display->d_obuffree = display->d_status_obuffree;
#line 2287
    display->d_status_obuffree = - 1;
#line 2288
    display->d_status = 0;
#line 2289
    display->d_status_bell = (char )0;
#line 2290
    evdeq(& display->d_statusev);
    }
#line 2291
    return;
  }
  {
#line 2293
  display->d_status = 0;
#line 2294
  display->d_status_bell = (char )0;
#line 2295
  evdeq(& display->d_statusev);
#line 2296
  olddisplay = display;
#line 2297
  oldflayer = flayer;
  }
#line 2298
  if (where == 1) {
    {
#line 2300
    GotoPos(0, display->d_height - 1);
#line 2301
    RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
#line 2302
    GotoPos(display->d_status_lastx, display->d_status_lasty);
    }
  } else {
    {
#line 2305
    RefreshHStatus();
    }
  }
#line 2306
  if (display->d_forecv) {
#line 2306
    tmp = (display->d_forecv)->c_layer;
  } else {
#line 2306
    tmp = (struct layer *)0;
  }
#line 2306
  flayer = tmp;
#line 2307
  if (flayer) {
    {
#line 2308
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
    }
  }
#line 2309
  display = olddisplay;
#line 2310
  flayer = oldflayer;
}
}
#line 2315 "/tmp/screen-3.9.15/display.c"
void ShowHStatus(char *str ) 
{ 
  int l ;
  int i ;
  int ox ;
  int oy ;
  int max ;
  int tmp ;
  size_t __cil_tmp8 ;
  char *tmp___0 ;
  size_t __cil_tmp10 ;
  struct mchar *tmp___96 ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;
  int tmp___97 ;

  {
#line 2320
  if (display->d_status == 1) {
#line 2320
    if (display->d_has_hstatus == 1) {
#line 2320
      if (display->d_height - 1 == display->d_height - 1) {
#line 2321
        return;
      }
    }
  }
#line 2323
  if (display->d_tcs[75].flg) {
#line 2323
    if (display->d_has_hstatus == 3) {
#line 2325
      if (! display->d_hstatus) {
#line 2325
        if (str == (char *)0) {
#line 2326
          return;
        } else
#line 2325
        if ((int )*str == 0) {
#line 2326
          return;
        }
      }
      {
#line 2327
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2327
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2328
      SetRendition(& mchar_null);
#line 2329
      InsertMode(0);
      }
#line 2330
      if (display->d_hstatus) {
        {
#line 2331
        AddCStr(display->d_tcs[79].str);
        }
      }
#line 2332
      display->d_hstatus = 0;
#line 2333
      if (str == (char *)0) {
#line 2334
        return;
      } else
#line 2333
      if ((int )*str == 0) {
#line 2334
        return;
      }
      {
#line 2335
      AddCStr2(display->d_tcs[77].str, 0);
      }
#line 2336
      if (display->d_tcs[76].num > 0) {
#line 2336
        tmp = display->d_tcs[76].num;
      } else {
#line 2336
        tmp = display->d_width - ! display->d_tcs[87].flg;
      }
      {
#line 2336
      max = tmp;
#line 2337
      __cil_tmp8 = strlen((char const   *)str);
      }
#line 2337
      if (__cil_tmp8 > (unsigned long )max) {
        {
#line 2338
        AddStrn(str, max);
        }
      } else {
        {
#line 2340
        AddStr(str);
        }
      }
      {
#line 2341
      AddCStr(display->d_tcs[78].str);
#line 2342
      display->d_hstatus = 1;
      }
    } else {
#line 2323
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2344
  if (display->d_has_hstatus == 1) {
    {
#line 2346
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2346
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2347
    ox = display->d_x;
#line 2348
    oy = display->d_y;
#line 2349
    if (str) {
#line 2349
      tmp___0 = str;
    } else {
#line 2349
      tmp___0 = (char *)"";
    }
    {
#line 2349
    str = tmp___0;
#line 2350
    __cil_tmp10 = strlen((char const   *)str);
#line 2350
    l = (int )__cil_tmp10;
    }
#line 2351
    if (l > display->d_width) {
#line 2352
      l = display->d_width;
    }
    {
#line 2353
    GotoPos(0, display->d_height - 1);
    }
#line 2354
    if ((captionalways || display->d_cvlist == (struct canvas *)0) || (display->d_cvlist)->c_next) {
#line 2354
      tmp___96 = & mchar_null;
    } else {
#line 2354
      tmp___96 = & mchar_so;
    }
    {
#line 2354
    SetRendition(tmp___96);
#line 2355
    __cil_tmp12 = PutWinMsg(str, 0, l);
    }
#line 2355
    if (! __cil_tmp12) {
#line 2356
      i = 0;
      {
#line 2356
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2356
        if (! (i < l)) {
#line 2356
          goto while_break___1;
        }
        {
#line 2357
        PUTCHARLP((int )*(str + i));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2356
      i ++;
    }
#line 2358
    if (! captionalways) {
#line 2358
      if (display->d_cvlist) {
#line 2358
        if (! (display->d_cvlist)->c_next) {
          {
#line 2359
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2359
            if (! (__cil_tmp14 < display->d_width)) {
#line 2359
              goto while_break___2;
            }
            {
#line 2360
            PUTCHARLP(' ');
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 2361
    if (l < display->d_width) {
      {
#line 2362
      ClearArea(l, display->d_height - 1, l, display->d_width - 1, display->d_width - 1,
                display->d_height - 1, 0, 0);
      }
    }
#line 2363
    if (ox != -1) {
#line 2363
      if (oy != -1) {
        {
#line 2364
        GotoPos(ox, oy);
        }
      }
    }
#line 2365
    if ((int )*str) {
#line 2365
      tmp___97 = 1;
    } else {
#line 2365
      tmp___97 = 0;
    }
    {
#line 2365
    display->d_hstatus = tmp___97;
#line 2366
    SetRendition(& mchar_null);
    }
  } else
#line 2368
  if (str) {
#line 2368
    if ((int )*str) {
#line 2368
      if (display->d_has_hstatus == 2) {
        {
#line 2370
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2370
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 2371
        Msg(0, (char *)"%s", str);
        }
      }
    }
  }
}
}
#line 2380 "/tmp/screen-3.9.15/display.c"
void RefreshHStatus(void) 
{ 
  char *buf ;
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 2384
  evdeq(& display->d_hstatusev);
  }
#line 2385
  if (display->d_status == 2) {
#line 2386
    return;
  }
#line 2387
  if ((display->d_tcs[75].flg && display->d_has_hstatus == 3) && display->d_tcs[76].num > 0) {
#line 2387
    tmp = display->d_tcs[76].num;
  } else {
#line 2387
    tmp = display->d_width - ! display->d_tcs[87].flg;
  }
  {
#line 2387
  __cil_tmp3 = MakeWinMsgEv(hstatusstring, display->d_fore, '%', tmp, & display->d_hstatusev,
                            0);
#line 2387
  buf = __cil_tmp3;
  }
#line 2388
  if (buf) {
#line 2388
    if ((int )*buf) {
      {
#line 2390
      ShowHStatus(buf);
      }
#line 2391
      if (display->d_has_hstatus != 0) {
#line 2391
        if (display->d_hstatusev.timeout.tv_sec) {
          {
#line 2392
          evenq(& display->d_hstatusev);
          }
        }
      }
    } else {
      {
      {
#line 2395
      ShowHStatus((char *)0);
      }
      }
    }
  } else {
    {
    {
#line 2395
    ShowHStatus((char *)0);
    }
    }
  }
}
}
#line 2404 "/tmp/screen-3.9.15/display.c"
void RefreshAll(int isblank ) 
{ 
  struct canvas *cv ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 2409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2409
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2410
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2411
  cv = display->d_cvlist;
  {
#line 2411
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2411
    if (! cv) {
#line 2411
      goto while_break___1;
    }
    {
#line 2413
    olddisplay = display;
#line 2413
    oldflayer = flayer;
#line 2413
    l = cv->c_layer;
#line 2413
    cvlist = l->l_cvlist;
#line 2413
    cvlnext = cv->c_lnext;
#line 2413
    flayer = l;
#line 2413
    l->l_cvlist = cv;
#line 2413
    cv->c_lnext = (struct canvas *)0;
#line 2413
    ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                      - 1,
                                                                                      - 1,
                                                                                      isblank);
#line 2413
    flayer = oldflayer;
#line 2413
    l->l_cvlist = cvlist;
#line 2413
    cv->c_lnext = cvlnext;
#line 2413
    display = olddisplay;
#line 2414
    display = cv->c_display;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2411
  cv = cv->c_next;
#line 2416
  RefreshArea(0, 0, display->d_width - 1, display->d_height - 1, isblank);
  }
}
}
#line 2420 "/tmp/screen-3.9.15/display.c"
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) 
{ 
  int y ;

  {
  {
#line 2424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2424
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2425
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2425
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2426
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2426
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2427
  if (! isblank) {
#line 2427
    if (xs == 0) {
#line 2427
      if (xe == display->d_width - 1) {
#line 2427
        if (ye == display->d_height - 1) {
#line 2427
          if (ys == 0) {
            {
            {
#line 2429
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
            }
#line 2430
            isblank = 1;
            }
          } else
#line 2427
          if (display->d_tcs[35].str) {
            {
            {
#line 2429
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
            }
#line 2430
            isblank = 1;
            }
          }
        }
      }
    }
  }
#line 2432
  y = ys;
  {
#line 2432
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2432
    if (! (y <= ye)) {
#line 2432
      goto while_break___2;
    }
    {
#line 2433
    RefreshLine(y, xs, xe, isblank);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2432
  y ++;
}
}
#line 2437 "/tmp/screen-3.9.15/display.c"
void RefreshLine(int y , int from , int to , int isblank ) 
{ 
  struct viewport *vp ;
  struct viewport *lvp ;
  struct canvas *cv ;
  struct canvas *lcv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct layer *oldflayer ;
  int xx ;
  int yy ;
  char *buf ;
  struct win *p ;
  int tmp ;
  size_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp___0 ;
  int __cil_tmp23 ;

  {
  {
#line 2447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2447
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2449
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2449
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2450
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2450
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2452
  if (display->d_status == 1) {
#line 2452
    if (y == display->d_height - 1) {
#line 2453
      return;
    }
  }
#line 2455
  if (isblank == 0) {
#line 2455
    if (display->d_tcs[37].str) {
#line 2455
      if (to == display->d_width - 1) {
#line 2455
        if (from < to) {
          {
#line 2457
          GotoPos(from, y);
          }
#line 2458
          if (display->d_tcs[33].flg) {
            {
            {
#line 2459
            SetRendition(& mchar_null);
            }
            }
          } else
#line 2458
          if (display->d_tcs[66].flg) {
            {
            {
#line 2459
            SetRendition(& mchar_null);
            }
            }
          }
          {
#line 2460
          AddCStr(display->d_tcs[37].str);
#line 2461
          isblank = 1;
          }
        }
      }
    }
  }
  {
#line 2463
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2463
    if (! (from <= to)) {
#line 2463
      goto while_break___2;
    }
#line 2465
    lcv = (struct canvas *)0;
#line 2466
    lvp = (struct viewport *)0;
#line 2467
    cv = display->d_cvlist;
    {
#line 2467
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2467
      if (! cv) {
#line 2467
        goto while_break___3;
      }
#line 2469
      if (y < cv->c_ys) {
#line 2470
        goto while_continue___3;
      } else
#line 2469
      if (y > cv->c_ye) {
#line 2470
        goto while_continue___3;
      } else
#line 2469
      if (to < cv->c_xs) {
#line 2470
        goto while_continue___3;
      } else
#line 2469
      if (from > cv->c_xe) {
#line 2470
        goto while_continue___3;
      }
      {
#line 2471
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2471
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2472
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2472
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2473
      vp = cv->c_vplist;
      {
#line 2473
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2473
        if (! vp) {
#line 2473
          goto while_break___6;
        }
        {
#line 2475
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2475
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2476
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2476
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2478
        if (y >= vp->v_ys) {
#line 2478
          if (y <= vp->v_ye) {
#line 2478
            if (from <= vp->v_xe) {
#line 2478
              if (to >= vp->v_xs) {
#line 2478
                if (lvp == (struct viewport *)0) {
#line 2480
                  lcv = cv;
#line 2481
                  lvp = vp;
                } else
#line 2478
                if (lvp->v_xs > vp->v_xs) {
#line 2480
                  lcv = cv;
#line 2481
                  lvp = vp;
                }
              }
            }
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2473
      vp = vp->v_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2467
    cv = cv->c_next;
#line 2485
    if (lvp == (struct viewport *)0) {
#line 2486
      goto while_break___2;
    }
#line 2487
    if (from < lvp->v_xs) {
#line 2489
      if (! isblank) {
        {
#line 2490
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xs - 1);
        }
      }
#line 2491
      from = lvp->v_xs;
    }
#line 2495
    yy = y - lvp->v_yoff;
#line 2496
    if (to < lvp->v_xe) {
#line 2496
      tmp = to;
    } else {
#line 2496
      tmp = lvp->v_xe;
    }
#line 2496
    xx = tmp;
#line 2498
    if (lcv->c_layer) {
#line 2498
      if (yy == (lcv->c_layer)->l_height) {
        {
#line 2500
        GotoPos(from, y);
#line 2501
        SetRendition(& mchar_blank);
        }
        {
#line 2502
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2502
          if (! (from <= lvp->v_xe && from - lvp->v_xoff < (lcv->c_layer)->l_width)) {
#line 2502
            goto while_break___9;
          }
          {
#line 2504
          PUTCHARLP('-');
#line 2505
          from ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2507
        if (from >= lvp->v_xe + 1) {
#line 2508
          goto while_continue___2;
        }
      }
    }
#line 2510
    if (lcv->c_layer == (struct layer *)0) {
      _L: /* CIL Label */ 
#line 2512
      if (! isblank) {
        {
#line 2513
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xe);
        }
      }
#line 2514
      from = lvp->v_xe + 1;
#line 2515
      goto while_continue___2;
    } else
#line 2510
    if (yy >= (lcv->c_layer)->l_height) {
#line 2510
      goto _L;
    } else
#line 2510
    if (from - lvp->v_xoff >= (lcv->c_layer)->l_width) {
#line 2510
      goto _L;
    }
#line 2518
    if (xx - lvp->v_xoff >= (lcv->c_layer)->l_width) {
#line 2519
      xx = ((lcv->c_layer)->l_width + lvp->v_xoff) - 1;
    }
    {
#line 2520
    oldflayer = flayer;
#line 2521
    flayer = lcv->c_layer;
#line 2522
    cvlist = flayer->l_cvlist;
#line 2523
    cvlnext = lcv->c_lnext;
#line 2524
    flayer->l_cvlist = lcv;
#line 2525
    lcv->c_lnext = (struct canvas *)0;
#line 2526
    ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(yy,
                                                                                      from - lvp->v_xoff,
                                                                                      xx - lvp->v_xoff,
                                                                                      isblank);
#line 2527
    flayer->l_cvlist = cvlist;
#line 2528
    lcv->c_lnext = cvlnext;
#line 2529
    flayer = oldflayer;
#line 2531
    from = xx + 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2533
  if (from > to) {
#line 2534
    return;
  }
#line 2536
  if (y == display->d_height - 1) {
#line 2536
    if (display->d_has_hstatus == 1) {
      {
#line 2538
      RefreshHStatus();
      }
#line 2539
      return;
    }
  }
#line 2542
  cv = display->d_cvlist;
  {
#line 2542
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2542
    if (! cv) {
#line 2542
      goto while_break___10;
    }
#line 2543
    if (y == cv->c_ye + 1) {
#line 2544
      goto while_break___10;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2542
  cv = cv->c_next;
#line 2545
  if (cv == (struct canvas *)0) {
#line 2547
    if (! isblank) {
      {
#line 2548
      DisplayLine(& mline_null, & mline_blank, y, from, to);
      }
    }
#line 2549
    return;
  }
  {
#line 2552
  p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 2553
  buf = MakeWinMsgEv(captionstring, p, '%', display->d_width - ! display->d_tcs[87].flg,
                     & cv->c_captev, 0);
  }
#line 2554
  if (cv->c_captev.timeout.tv_sec) {
    {
#line 2555
    evenq(& cv->c_captev);
    }
  }
  {
#line 2556
  __cil_tmp19 = strlen((char const   *)buf);
#line 2556
  xx = (int )__cil_tmp19;
#line 2557
  GotoPos(from, y);
#line 2558
  SetRendition(& mchar_so);
#line 2559
  __cil_tmp20 = PutWinMsg(buf, from, to + 1);
  }
#line 2559
  if (__cil_tmp20) {
#line 2560
    if (xx > to + 1) {
#line 2560
      tmp___0 = to + 1;
    } else {
#line 2560
      tmp___0 = xx;
    }
#line 2560
    from = tmp___0;
  } else {
    {
#line 2563
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2563
      if (! (from <= to && from < xx)) {
#line 2563
        goto while_break___11;
      }
      {
#line 2565
      PUTCHARLP((int )*(buf + from));
#line 2566
      from ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 2569
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2569
    if (! (__cil_tmp23 <= to)) {
#line 2569
      goto while_break___12;
    }
    {
#line 2570
    PUTCHARLP(' ');
    }
  }
  while_break___12: /* CIL Label */ ;
  }
}
}
#line 2579 "/tmp/screen-3.9.15/display.c"
static void WriteLP(int x2 , int y2 ) 
{ 
  struct mchar oldrend ;
  int __cil_tmp4 ;

  {
  {
#line 2584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2584
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2585
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2585
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2586
  oldrend = display->d_rend;
  {
#line 2587
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2587
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2589
  if (display->d_lpchar.mbcs) {
#line 2591
    if (x2 > 0) {
#line 2592
      __cil_tmp4 = x2;
#line 2592
      x2 --;
    } else {
#line 2594
      display->d_lpchar = mchar_blank;
    }
  }
  {
#line 2598
  GotoPos(x2, y2);
#line 2599
  SetRendition(& display->d_lpchar);
#line 2600
  PUTCHAR((int )display->d_lpchar.image);
  }
#line 2602
  if (display->d_lpchar.mbcs) {
    {
#line 2603
    PUTCHAR((int )display->d_lpchar.mbcs);
    }
  }
  {
#line 2605
  display->d_lp_missing = 0;
#line 2606
  SetRendition(& oldrend);
  }
}
}
#line 2610 "/tmp/screen-3.9.15/display.c"
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) 
{ 
  int x ;
  struct mchar bcechar ;
  int tmp ;

  {
  {
#line 2619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2619
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2620
  if (display->d_tcs[33].flg) {
    {
#line 2621
    SetRendition(& mchar_null);
    }
  }
#line 2623
  if (display->d_tcs[66].flg) {
    {
#line 2624
    SetBackColor(bce);
    }
  }
#line 2626
  if (from == 0) {
#line 2626
    if (display->d_tcs[38].str) {
#line 2626
      if (to != display->d_width - 1) {
        _L: /* CIL Label */ 
#line 2626
        if (! bce) {
          {
          {
#line 2628
          GotoPos(to, y);
          }
          {
#line 2629
          AddCStr(display->d_tcs[38].str);
          }
          }
#line 2630
          return;
        } else
#line 2626
        if (display->d_tcs[66].flg) {
          {
          {
#line 2628
          GotoPos(to, y);
          }
          {
#line 2629
          AddCStr(display->d_tcs[38].str);
          }
          }
#line 2630
          return;
        }
      } else
#line 2626
      if (display->d_x == to) {
#line 2626
        if (display->d_y == y) {
#line 2626
          goto _L;
        }
      }
    }
  }
#line 2632
  if (to == display->d_width - 1) {
#line 2632
    if (display->d_tcs[37].str) {
#line 2632
      if (! bce) {
        {
        {
#line 2634
        GotoPos(from, y);
        }
        {
#line 2635
        AddCStr(display->d_tcs[37].str);
        }
        }
#line 2636
        return;
      } else
#line 2632
      if (display->d_tcs[66].flg) {
        {
        {
#line 2634
        GotoPos(from, y);
        }
        {
#line 2635
        AddCStr(display->d_tcs[37].str);
        }
        }
#line 2636
        return;
      }
    }
  }
#line 2638
  if (oml == (struct mline *)0) {
#line 2639
    oml = & mline_null;
  }
#line 2641
  if (! bce) {
    {
#line 2643
    DisplayLine(oml, & mline_blank, y, from, to);
    }
#line 2644
    return;
  }
#line 2646
  bcechar = mchar_blank;
#line 2647
  if (bce & 256) {
#line 2647
    tmp = 0;
  } else {
#line 2647
    tmp = 1 << 7;
  }
#line 2647
  bcechar.attr = (unsigned char )(((int )bcechar.attr | (1 << 7)) ^ tmp);
#line 2647
  bcechar.color = (unsigned char )(((int )bcechar.color & 15) | ((bce << 4) & 240));
#line 2648
  x = from;
  {
#line 2648
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2648
    if (! (x <= to)) {
#line 2648
      goto while_break___0;
    }
    {
#line 2649
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2649
      *(mline_old.image + x) = bcechar.image;
#line 2649
      *(mline_old.attr + x) = bcechar.attr;
#line 2649
      *(mline_old.font + x) = bcechar.font;
#line 2649
      *(mline_old.color + x) = bcechar.color;
#line 2649
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2648
  x ++;
#line 2650
  DisplayLine(oml, & mline_old, y, from, to);
  }
}
}
#line 2657 "/tmp/screen-3.9.15/display.c"
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) 
{ 
  register int x ;
  int last2flag ;
  int delete_lp ;
  int tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int tmp___104 ;
  int tmp___105 ;

  {
#line 2662
  last2flag = 0;
#line 2662
  delete_lp = 0;
  {
#line 2664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2664
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2665
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2665
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2666
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2666
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2667
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2667
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2668
  if (! display->d_tcs[87].flg) {
#line 2668
    if (y == display->d_bot) {
#line 2668
      if (to == display->d_width - 1) {
#line 2670
        if (display->d_lp_missing) {
          _L___101: /* CIL Label */ 
#line 2673
          if (display->d_encoding == 8) {
#line 2673
            tmp = (int )*(ml->font + (to + 1)) == 255 && (int )*(ml->image + (to + 1)) == 255;
          } else {
#line 2673
            tmp = ((int )*(ml->font + to) & 31) != 0 && ((int )*(ml->font + to) & 224) == 0;
          }
#line 2673
          if (display->d_tcs[29].str) {
            _L___100: /* CIL Label */ 
#line 2673
            if (from < to) {
#line 2673
              if (! tmp) {
#line 2678
                last2flag = 1;
#line 2679
                display->d_lp_missing = 0;
#line 2680
                __cil_tmp10 = to;
#line 2680
                to --;
              } else {
#line 2673
                goto _L;
              }
            } else {
#line 2673
              goto _L;
            }
          } else
#line 2673
          if (display->d_tcs[27].str) {
#line 2673
            goto _L___100;
          } else {
            _L: /* CIL Label */ 
#line 2684
            delete_lp = ! ((((int )mchar_blank.image == (int )*(oml->image + to) && (int )mchar_blank.attr == (int )*(oml->attr + to)) && (int )mchar_blank.font == (int )*(oml->font + to)) && (int )mchar_blank.color == (int )*(oml->color + to)) && ((display->d_tcs[37].str || display->d_tcs[31].str) || display->d_tcs[32].str);
#line 2685
            display->d_lp_missing = ! ((((int )mchar_blank.image == (int )*(ml->image + to) && (int )mchar_blank.attr == (int )*(ml->attr + to)) && (int )mchar_blank.font == (int )*(ml->font + to)) && (int )mchar_blank.color == (int )*(ml->color + to));
            {
#line 2686
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2686
              display->d_lpchar.image = *(ml->image + to);
#line 2686
              display->d_lpchar.attr = *(ml->attr + to);
#line 2686
              display->d_lpchar.font = *(ml->font + to);
#line 2686
              display->d_lpchar.color = *(ml->color + to);
#line 2686
              display->d_lpchar.mbcs = (unsigned char )0;
#line 2686
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else
#line 2670
        if (! ((((int )*(oml->image + to) == (int )*(ml->image + to) && (int )*(oml->attr + to) == (int )*(ml->attr + to)) && (int )*(oml->font + to) == (int )*(ml->font + to)) && (int )*(oml->color + to) == (int )*(ml->color + to))) {
#line 2670
          goto _L___101;
        }
#line 2689
        __cil_tmp11 = to;
#line 2689
        to --;
      }
    }
  }
#line 2692
  if (display->d_mbcs) {
    {
#line 2695
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2695
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2696
    SetRenditionMline(ml, from);
#line 2697
    PUTCHAR((int )*(ml->image + from));
#line 2698
    from ++;
    }
  }
#line 2701
  x = from;
  {
#line 2701
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2701
    if (! (x <= to)) {
#line 2701
      goto while_break___5;
    }
#line 2707
    if (x < to) {
      _L___102: /* CIL Label */ 
#line 2708
      if ((int )*(oml->image + x) == (int )*(ml->image + x)) {
#line 2708
        if ((int )*(oml->attr + x) == (int )*(ml->attr + x)) {
#line 2708
          if ((int )*(oml->font + x) == (int )*(ml->font + x)) {
#line 2708
            if ((int )*(oml->color + x) == (int )*(ml->color + x)) {
#line 2709
              goto while_continue___5;
            }
          }
        }
      }
    } else
#line 2707
    if (x != display->d_width - 1) {
#line 2707
      goto _L___102;
    } else
#line 2707
    if ((int )*(ml->image + (x + 1))) {
#line 2707
      goto _L___102;
    }
    {
#line 2710
    GotoPos(x, y);
    }
#line 2713
    if (display->d_encoding == 8) {
#line 2713
      tmp___0 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
    } else {
#line 2713
      tmp___0 = ((int )*(ml->font + x) & 224) == 128;
    }
#line 2713
    if (tmp___0) {
#line 2715
      __cil_tmp14 = x;
#line 2715
      x --;
      {
#line 2716
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2716
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2717
      GotoPos(x, y);
      }
    }
#line 2719
    if (display->d_encoding == 8) {
#line 2719
      tmp___104 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 2719
      tmp___104 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 2719
    if (x == to) {
#line 2719
      if (tmp___104) {
#line 2720
        goto while_break___5;
      }
    }
    {
#line 2722
    SetRenditionMline(ml, x);
#line 2723
    PUTCHAR((int )*(ml->image + x));
    }
#line 2725
    if (display->d_encoding == 8) {
#line 2725
      tmp___105 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 2725
      tmp___105 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 2725
    if (tmp___105) {
      {
#line 2726
      x ++;
#line 2726
      PUTCHAR((int )*(ml->image + x));
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2701
  x ++;
#line 2734
  if (last2flag) {
    {
#line 2736
    GotoPos(x, y);
#line 2737
    SetRenditionMline(ml, x + 1);
#line 2738
    PUTCHAR((int )*(ml->image + (x + 1)));
#line 2739
    GotoPos(x, y);
#line 2740
    SetRenditionMline(ml, x);
#line 2741
    INSERTCHAR((int )*(ml->image + x));
    }
  } else
#line 2743
  if (delete_lp) {
#line 2745
    if (display->d_tcs[33].flg) {
      {
#line 2746
      SetRendition(& mchar_null);
      }
    }
#line 2747
    if (display->d_tcs[31].str) {
      {
#line 2748
      AddCStr(display->d_tcs[31].str);
      }
    } else
#line 2749
    if (display->d_tcs[32].str) {
      {
#line 2750
      AddCStr2(display->d_tcs[32].str, 1);
      }
    } else
#line 2751
    if (display->d_tcs[37].str) {
      {
#line 2752
      AddCStr(display->d_tcs[37].str);
      }
    }
  }
}
}
#line 2757 "/tmp/screen-3.9.15/display.c"
void PutChar(struct mchar *c , int x , int y ) 
{ 


  {
  {
#line 2761
  GotoPos(x, y);
#line 2762
  SetRendition(c);
#line 2763
  PUTCHARLP((int )c->image);
  }
#line 2765
  if (c->mbcs) {
#line 2768
    if (display->d_encoding == 8) {
#line 2769
      display->d_rend.font = (unsigned char )0;
    }
    {
#line 2771
    PUTCHARLP((int )c->mbcs);
    }
  }
}
}
#line 2777 "/tmp/screen-3.9.15/display.c"
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) 
{ 
  int tmp ;

  {
  {
#line 2782
  GotoPos(x, y);
  }
#line 2783
  if (y == display->d_bot) {
#line 2783
    if (! display->d_tcs[87].flg) {
#line 2785
      if (x == display->d_width - 1) {
#line 2787
        display->d_lp_missing = 1;
#line 2788
        display->d_lpchar = *c;
#line 2789
        return;
      }
#line 2791
      if (xe == display->d_width - 1) {
#line 2792
        display->d_lp_missing = 0;
      }
    }
  }
#line 2794
  if (x == xe) {
    {
#line 2796
    SetRendition(c);
#line 2797
    PUTCHARLP((int )c->image);
    }
#line 2798
    return;
  }
#line 2800
  if (! ((display->d_tcs[29].str || display->d_tcs[30].str) || display->d_tcs[27].str)) {
    {
    {
#line 2802
    RefreshLine(y, x, xe, 0);
    }
    {
#line 2803
    GotoPos(x + 1, y);
    }
    }
#line 2805
    return;
  } else
#line 2800
  if (xe != display->d_width - 1) {
    {
    {
#line 2802
    RefreshLine(y, x, xe, 0);
    }
    {
#line 2803
    GotoPos(x + 1, y);
    }
    }
#line 2805
    return;
  }
  {
#line 2807
  InsertMode(1);
  }
#line 2808
  if (! display->d_insert) {
#line 2811
    if ((int )c->mbcs) {
#line 2811
      if (display->d_tcs[29].str) {
        {
#line 2812
        AddCStr(display->d_tcs[29].str);
        }
      }
    }
#line 2813
    if (display->d_tcs[29].str) {
      {
#line 2814
      AddCStr(display->d_tcs[29].str);
      }
    } else {
#line 2816
      if ((int )c->mbcs) {
#line 2816
        tmp = 2;
      } else {
#line 2816
        tmp = 1;
      }
      {
#line 2816
      AddCStr2(display->d_tcs[30].str, tmp);
      }
    }
  }
  {
#line 2824
  SetRendition(c);
#line 2825
  RAW_PUTCHAR((int )c->image);
  }
#line 2827
  if (c->mbcs) {
#line 2830
    if (display->d_encoding == 8) {
#line 2831
      display->d_rend.font = (unsigned char )0;
    }
#line 2833
    if (display->d_x == display->d_width - 1) {
      {
#line 2834
      PUTCHARLP((int )c->mbcs);
      }
    } else {
      {
#line 2836
      RAW_PUTCHAR((int )c->mbcs);
      }
    }
  }
}
}
#line 2842 "/tmp/screen-3.9.15/display.c"
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) 
{ 
  int bce ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___109 ;

  {
#line 2851
  if ((int )c->attr & (1 << 7)) {
#line 2851
    tmp = 256;
  } else {
#line 2851
    tmp = 0;
  }
#line 2851
  bce = (((int )c->color & 240) >> 4) | tmp;
  {
#line 2855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2855
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2856
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2857
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2857
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2858
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2858
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2859
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2859
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2860
  if (xs != 0) {
    _L: /* CIL Label */ 
#line 2862
    if (y == ye) {
      {
#line 2863
      ScrollV(xs, ys, xe, ye, 1, bce);
      }
    } else
#line 2864
    if (y < display->d_height - 1) {
#line 2865
      y ++;
    }
#line 2866
    if (ins) {
      {
#line 2867
      InsChar(c, xs, xe, y, (struct mline *)0);
      }
    } else {
      {
#line 2869
      PutChar(c, xs, y);
      }
    }
#line 2870
    return;
  } else
#line 2860
  if (x != display->d_width) {
#line 2860
    goto _L;
  } else
#line 2860
  if (! display->d_tcs[83].flg) {
#line 2860
    goto _L;
  }
#line 2872
  if (y == ye) {
    {
#line 2874
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2874
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2875
    ChangeScrollRegion(ys, ye);
    }
#line 2876
    if (display->d_bot != y) {
      _L___107: /* CIL Label */ 
      {
#line 2878
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2878
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2879
      ScrollV(xs, ys, xe, ye, 1, bce);
#line 2880
      __cil_tmp12 = y;
#line 2880
      y --;
      }
    } else
#line 2876
    if (display->d_x != display->d_width) {
#line 2876
      goto _L___107;
    } else
#line 2876
    if (! bce) {
#line 2876
      if (! display->d_tcs[66].flg) {
#line 2876
        goto _L___107;
      }
    }
  } else
#line 2883
  if (y == display->d_bot) {
    {
#line 2884
    ChangeScrollRegion(0, display->d_height - 1);
    }
  }
#line 2885
  if (display->d_x != display->d_width) {
    _L___111: /* CIL Label */ 
#line 2887
    if (display->d_tcs[87].flg) {
#line 2887
      if (y >= 0) {
        {
#line 2888
        RefreshLine(y, display->d_width - 1, display->d_width - 1, 0);
        }
      }
    }
    {
#line 2889
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2889
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2890
    if (display->d_x != display->d_width) {
      _L___110: /* CIL Label */ 
#line 2892
      if (y == ye) {
        {
#line 2893
        ScrollV(xs, ys, xe, ye, 1, bce);
        }
      }
#line 2894
      if (y == ye || y == display->d_height - 1) {
#line 2894
        tmp___109 = y;
      } else {
#line 2894
        tmp___109 = y + 1;
      }
      {
#line 2894
      GotoPos(xs, tmp___109);
      }
    } else
#line 2890
    if (display->d_y != y) {
#line 2890
      goto _L___110;
    }
  } else
#line 2885
  if (display->d_y != y) {
#line 2885
    goto _L___111;
  }
  {
#line 2897
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2897
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2898
  if (y != ye) {
#line 2898
    if (y < display->d_height - 1) {
#line 2899
      y ++;
    }
  }
#line 2900
  if (ins != display->d_insert) {
    {
#line 2901
    InsertMode(ins);
    }
  }
#line 2902
  if (ins) {
#line 2902
    if (! display->d_insert) {
      {
#line 2904
      InsChar(c, 0, xe, y, (struct mline *)0);
      }
      {
#line 2905
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2905
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2906
      return;
    }
  }
  {
#line 2908
  display->d_y = y;
#line 2909
  display->d_x = 0;
#line 2910
  SetRendition(c);
#line 2911
  RAW_PUTCHAR((int )c->image);
  }
#line 2913
  if (c->mbcs) {
#line 2916
    if (display->d_encoding == 8) {
#line 2917
      display->d_rend.font = (unsigned char )0;
    }
    {
#line 2919
    RAW_PUTCHAR((int )c->mbcs);
    }
  }
  {
#line 2922
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2922
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
}
}
#line 2926 "/tmp/screen-3.9.15/display.c"
int ResizeDisplay(int wi , int he ) 
{ 
  char *tmp ;
  int tmp___112 ;
  char *__cil_tmp5 ;

  {
  {
#line 2929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2929
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2930
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2930
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2931
  if (display->d_width == wi) {
#line 2931
    if (display->d_height == he) {
      {
#line 2933
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2933
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2934
      return (0);
    }
  }
#line 2936
  if (display->d_width != wi) {
#line 2936
    if (display->d_height == he) {
      _L___113: /* CIL Label */ 
#line 2936
      if (display->d_tcs[45].str) {
#line 2936
        if (wi == Z0width) {
          _L: /* CIL Label */ 
          {
#line 2938
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2938
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2939
          if (wi == Z0width) {
#line 2939
            tmp = display->d_tcs[45].str;
          } else {
#line 2939
            tmp = display->d_tcs[46].str;
          }
          {
#line 2939
          AddCStr(tmp);
#line 2940
          ChangeScreenSize(wi, display->d_height, 0);
          }
#line 2941
          if (he == display->d_height) {
#line 2941
            tmp___112 = 0;
          } else {
#line 2941
            tmp___112 = - 1;
          }
#line 2941
          return (tmp___112);
        } else
#line 2936
        if (wi == Z1width) {
#line 2936
          goto _L;
        }
      }
    } else
#line 2936
    if (! display->d_tcs[44].str) {
#line 2936
      goto _L___113;
    }
  }
#line 2943
  if (display->d_tcs[44].str) {
    {
#line 2945
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2945
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2946
    __cil_tmp5 = tgoto(display->d_tcs[44].str, wi, he);
#line 2946
    AddCStr(__cil_tmp5);
#line 2947
    ChangeScreenSize(wi, he, 0);
    }
#line 2948
    return (0);
  }
#line 2950
  return (- 1);
}
}
#line 2954 "/tmp/screen-3.9.15/display.c"
void ChangeScrollRegion(int newtop , int newbot ) 
{ 
  char *__cil_tmp3 ;

  {
#line 2957
  if (display == (struct display *)0) {
#line 2958
    return;
  }
#line 2959
  if (newtop == newbot) {
#line 2960
    return;
  }
#line 2961
  if (newtop == -1) {
#line 2962
    newtop = 0;
  }
#line 2963
  if (newbot == -1) {
#line 2964
    newbot = display->d_height - 1;
  }
#line 2965
  if (display->d_tcs[18].str == (char *)0) {
#line 2967
    display->d_top = 0;
#line 2968
    display->d_bot = display->d_height - 1;
#line 2969
    return;
  }
#line 2971
  if (display->d_top == newtop) {
#line 2971
    if (display->d_bot == newbot) {
#line 2972
      return;
    }
  }
  {
#line 2973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2973
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2974
  __cil_tmp3 = tgoto(display->d_tcs[18].str, newbot, newtop);
#line 2974
  AddCStr(__cil_tmp3);
#line 2975
  display->d_top = newtop;
#line 2976
  display->d_bot = newbot;
#line 2977
  display->d_x = - 1;
#line 2977
  display->d_y = display->d_x;
  }
}
}
#line 3024 "/tmp/screen-3.9.15/display.c"
void AddStr(char *str ) 
{ 
  register char c ;
  char *__cil_tmp5 ;

  {
  {
#line 3029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3029
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3032
  if (display->d_encoding == 8) {
    {
#line 3034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3034
      if (! c) {
#line 3034
        goto while_break___0;
      }
      {
#line 3035
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3036
    return;
  }
  {
#line 3039
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3039
    if (! c) {
#line 3039
      goto while_break___1;
    }
    {
#line 3040
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3040
      (display->d_obuffree) --;
#line 3040
      if (display->d_obuffree <= 0) {
        {
#line 3040
        Resize_obuf();
        }
      }
#line 3040
      __cil_tmp5 = display->d_obufp;
#line 3040
      (display->d_obufp) ++;
#line 3040
      *__cil_tmp5 = c;
#line 3040
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 3044 "/tmp/screen-3.9.15/display.c"
void AddStrn(char *str , int n ) 
{ 
  register char c ;
  int __cil_tmp5 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3050
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3050
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3052
  if (display->d_encoding == 8) {
    {
#line 3054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3054
      if (! ((int )c && __cil_tmp5 > 0)) {
#line 3054
        goto while_break___0;
      }
      {
#line 3055
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3059
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3059
      if (! ((int )c && __cil_tmp7 > 0)) {
#line 3059
        goto while_break___1;
      }
      {
#line 3060
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3060
        (display->d_obuffree) --;
#line 3060
        if (display->d_obuffree <= 0) {
          {
#line 3060
          Resize_obuf();
          }
        }
#line 3060
        __cil_tmp8 = display->d_obufp;
#line 3060
        (display->d_obufp) ++;
#line 3060
        *__cil_tmp8 = c;
#line 3060
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 3061
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3061
    if (! (__cil_tmp9 > 0)) {
#line 3061
      goto while_break___3;
    }
    {
#line 3062
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3062
      (display->d_obuffree) --;
#line 3062
      if (display->d_obuffree <= 0) {
        {
#line 3062
        Resize_obuf();
        }
      }
#line 3062
      __cil_tmp10 = display->d_obufp;
#line 3062
      (display->d_obufp) ++;
#line 3062
      *__cil_tmp10 = (char )' ';
#line 3062
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 3066 "/tmp/screen-3.9.15/display.c"
void Flush(void) 
{ 
  register int l ;
  register char *p ;
  int __cil_tmp3 ;
  register int wr ;
  ssize_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 3071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3071
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3072
  l = (int )(display->d_obufp - display->d_obuf);
  {
#line 3073
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3073
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3074
  if (l == 0) {
#line 3075
    return;
  }
  {
#line 3076
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3076
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3077
  if (display->d_userfd < 0) {
#line 3079
    display->d_obuffree += l;
#line 3080
    display->d_obufp = display->d_obuf;
#line 3081
    return;
  }
  {
#line 3083
  p = display->d_obuf;
#line 3084
  __cil_tmp3 = fcntl(display->d_userfd, 4, 0);
  }
#line 3084
  if (__cil_tmp3) {
    {
#line 3085
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3085
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 3086
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3086
    if (! l) {
#line 3086
      goto while_break___3;
    }
    {
#line 3089
    __cil_tmp5 = write(display->d_userfd, (void const   *)p, (size_t )l);
#line 3089
    wr = (int )__cil_tmp5;
    }
#line 3090
    if (wr <= 0) {
      {
#line 3092
      __cil_tmp6 = __errno_location();
      }
#line 3092
      if (*__cil_tmp6 == 4) {
#line 3093
        goto while_continue___3;
      }
      {
#line 3094
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3094
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3095
      wr = l;
    }
#line 3097
    if (! display) {
#line 3098
      return;
    }
#line 3099
    display->d_obuffree += wr;
#line 3100
    p += wr;
#line 3101
    l -= wr;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3103
  display->d_obuffree += l;
#line 3104
  display->d_obufp = display->d_obuf;
#line 3105
  if ((int )display->d_nonblock > 1) {
#line 3106
    display->d_nonblock = (char )1;
  }
  {
#line 3107
  __cil_tmp7 = fcntl(display->d_userfd, 4, 2048);
  }
#line 3107
  if (__cil_tmp7) {
    {
#line 3108
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3108
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
}
}
#line 3112 "/tmp/screen-3.9.15/display.c"
void freetty(void) 
{ 


  {
#line 3114
  if (display->d_userfd >= 0) {
    {
#line 3115
    close(display->d_userfd);
    }
  }
  {
#line 3116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3117
  display->d_userfd = - 1;
#line 3118
  display->d_obufp = (char *)0;
#line 3119
  display->d_obuffree = 0;
#line 3120
  if (display->d_obuf) {
    {
#line 3121
    free((void *)display->d_obuf);
    }
  }
#line 3122
  display->d_obuf = (char *)0;
#line 3123
  display->d_obuflen = 0;
#line 3124
  display->d_obuflenmax = - display->d_obufmax;
}
}
#line 3133 "/tmp/screen-3.9.15/display.c"
void Resize_obuf(void) 
{ 
  register int ind ;
  int ti ;
  time_t __cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 3137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3138
  if (display->d_status_obuffree >= 0) {
    {
#line 3140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3140
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3141
    if (! display->d_status_bell) {
      {
#line 3143
      __cil_tmp3 = time((time_t *)0);
#line 3143
      ti = (int )(__cil_tmp3 - display->d_status_time);
      }
#line 3144
      if (ti < MsgMinWait) {
        {
#line 3145
        DisplaySleep(MsgMinWait - ti, 0);
        }
      }
    }
    {
#line 3147
    RemoveStatus();
#line 3148
    (display->d_obuffree) --;
    }
#line 3148
    if (display->d_obuffree > 0) {
#line 3149
      return;
    }
  }
#line 3151
  if (display->d_obuflen) {
#line 3151
    if (display->d_obuf) {
      {
#line 3153
      ind = (int )(display->d_obufp - display->d_obuf);
#line 3154
      display->d_obuflen += 4096;
#line 3155
      display->d_obuffree += 4096;
#line 3156
      __cil_tmp4 = realloc((void *)display->d_obuf, (unsigned long )display->d_obuflen);
#line 3156
      display->d_obuf = (char *)__cil_tmp4;
      }
    } else {
      {
#line 3160
      ind = 0;
#line 3161
      display->d_obuflen = 4096;
#line 3162
      display->d_obuffree = 4096;
      {
#line 3163
      __cil_tmp5 = malloc((unsigned long )display->d_obuflen);
      }
#line 3163
      display->d_obuf = (char *)__cil_tmp5;
      }
    }
  } else {
    {
#line 3160
    ind = 0;
#line 3161
    display->d_obuflen = 4096;
#line 3162
    display->d_obuffree = 4096;
    {
#line 3163
    __cil_tmp5 = malloc((unsigned long )display->d_obuflen);
    }
#line 3163
    display->d_obuf = (char *)__cil_tmp5;
    }
  }
#line 3165
  if (! display->d_obuf) {
    {
#line 3166
    Panic(0, (char *)"Out of memory");
    }
  }
#line 3167
  display->d_obufp = display->d_obuf + ind;
#line 3168
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  {
#line 3169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3169
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 3174 "/tmp/screen-3.9.15/display.c"
void NukePending(void) 
{ 
  register int len ;
  int oldtop ;
  int oldbot ;
  struct mchar oldrend ;
  int oldkeypad ;
  int oldcursorkeys ;
  int oldcurvis ;
  int oldmouse ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *tmp ;

  {
#line 3177
  oldtop = display->d_top;
#line 3177
  oldbot = display->d_bot;
#line 3179
  oldkeypad = display->d_keypad;
#line 3179
  oldcursorkeys = display->d_cursorkeys;
#line 3180
  oldcurvis = display->d_curvis;
#line 3181
  oldmouse = display->d_mouse;
#line 3183
  oldrend = display->d_rend;
#line 3184
  len = (int )(display->d_obufp - display->d_obuf);
  {
#line 3185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3185
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3189
  tcflush(display->d_userfd, 1);
#line 3196
  display->d_obufp = display->d_obuf;
#line 3197
  display->d_obuffree += len;
#line 3198
  display->d_bot = - 1;
#line 3198
  display->d_top = display->d_bot;
#line 3199
  AddCStr(display->d_tcs[40].str);
#line 3200
  AddCStr(display->d_tcs[39].str);
  }
#line 3202
  if (display->d_tcs[55].str) {
    {
#line 3203
    AddCStr(display->d_tcs[55].str);
    }
  } else {
#line 3207
    if (display->d_hascolor) {
      {
#line 3208
      AddStr((char *)"\033[m");
      }
    }
    {
#line 3210
    AddCStr(display->d_tcs[54].str);
#line 3211
    AddCStr(display->d_tcs[53].str);
    }
  }
  {
#line 3214
  __cil_tmp9 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
  }
#line 3214
  if (display->d_tcs[27].str) {
#line 3214
    if (__cil_tmp9) {
      {
#line 3215
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
  {
#line 3216
  display->d_insert = 0;
#line 3219
  __cil_tmp10 = strcmp((char const   *)display->d_tcs[69].str, (char const   *)display->d_tcs[70].str);
  }
#line 3219
  if (display->d_tcs[69].str) {
#line 3219
    if (__cil_tmp10) {
      {
#line 3220
      AddCStr(display->d_tcs[69].str);
      }
    }
  }
  {
#line 3221
  __cil_tmp11 = strcmp((char const   *)display->d_tcs[71].str, (char const   *)display->d_tcs[72].str);
  }
#line 3221
  if (display->d_tcs[71].str) {
#line 3221
    if (__cil_tmp11) {
      {
#line 3222
      AddCStr(display->d_tcs[71].str);
      }
    }
  }
  {
#line 3231
  AddCStr(display->d_tcs[99].str);
#line 3232
  display->d_rend = mchar_null;
#line 3233
  display->d_atyp = (char )0;
#line 3234
  AddCStr(display->d_tcs[79].str);
#line 3235
  display->d_hstatus = 0;
#line 3236
  AddCStr(display->d_tcs[82].str);
#line 3237
  display->d_curvis = 0;
#line 3238
  ChangeScrollRegion(oldtop, oldbot);
#line 3239
  SetRendition(& oldrend);
#line 3240
  KeypadMode(oldkeypad);
#line 3241
  CursorkeysMode(oldcursorkeys);
#line 3242
  CursorVisibility(oldcurvis);
#line 3243
  MouseMode(oldmouse);
  }
#line 3244
  if (display->d_tcs[44].str) {
    {
#line 3246
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3246
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3247
    __cil_tmp12 = tgoto(display->d_tcs[44].str, display->d_width, display->d_height);
#line 3247
    AddCStr(__cil_tmp12);
    }
  } else
#line 3249
  if (display->d_tcs[45].str) {
#line 3249
    if (display->d_width == Z0width) {
      _L: /* CIL Label */ 
      {
#line 3251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3251
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3252
      if (display->d_width == Z0width) {
#line 3252
        tmp = display->d_tcs[45].str;
      } else {
#line 3252
        tmp = display->d_tcs[46].str;
      }
      {
#line 3252
      AddCStr(tmp);
      }
    } else
#line 3249
    if (display->d_width == Z1width) {
#line 3249
      goto _L;
    }
  }
}
}
#line 3258 "/tmp/screen-3.9.15/display.c"
static void disp_writeev_fn(struct event *ev , char *data ) 
{ 
  int len ;
  int size ;
  ssize_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;

  {
#line 3262
  size = 256;
#line 3264
  display = (struct display *)data;
#line 3265
  len = (int )(display->d_obufp - display->d_obuf);
#line 3266
  if (len < size) {
#line 3267
    size = len;
  }
  {
#line 3268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3269
  __cil_tmp5 = write(display->d_userfd, (void const   *)display->d_obuf, (size_t )size);
#line 3269
  size = (int )__cil_tmp5;
  }
#line 3270
  if (size >= 0) {
#line 3272
    len -= size;
#line 3273
    if (len) {
      {
#line 3275
      bcopy((void const   *)(display->d_obuf + size), (void *)display->d_obuf, (size_t )len);
      }
      {
#line 3276
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3276
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3279
    if ((int )display->d_nonblock > 1) {
#line 3279
      if (len < display->d_obufmax / 2) {
#line 3280
        display->d_nonblock = (char )1;
      }
    }
#line 3281
    display->d_obufp -= size;
#line 3282
    display->d_obuffree += size;
  } else {
    {
#line 3286
    __cil_tmp7 = __errno_location();
    }
    {
#line 3286
    __cil_tmp6 = __errno_location();
    }
#line 3286
    if (*__cil_tmp6 != 4) {
#line 3286
      if (*__cil_tmp7 != 11) {
        {
#line 3290
        __cil_tmp8 = __errno_location();
#line 3290
        Msg(*__cil_tmp8, (char *)"Error writing output to display");
        }
      }
    }
  }
}
}
#line 3295 "/tmp/screen-3.9.15/display.c"
static void disp_readev_fn(struct event *ev , char *data ) 
{ 
  int size ;
  char buf[4096] ;
  struct canvas *cv ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  unsigned char *bp ;
  int x ;
  int y ;
  int i ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  int tmp ;
  int i___0 ;
  int j ;
  int c ;
  int enc ;
  char buf2[8202] ;
  int tmp___116 ;
  int __cil_tmp28 ;
  int font ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 3303
  display = (struct display *)data;
#line 3306
  if (display->d_forecv) {
#line 3307
    cv = ((display->d_forecv)->c_layer)->l_cvlist;
    {
#line 3307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3307
      if (! cv) {
#line 3307
        goto while_break;
      }
#line 3309
      display = cv->c_display;
#line 3310
      if (display->d_status == 1) {
        {
#line 3311
        RemoveStatus();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3307
    cv = cv->c_lnext;
  }
#line 3314
  display = (struct display *)data;
#line 3315
  if (display->d_fore == (struct win *)0) {
#line 3316
    size = 4096;
  } else
#line 3320
  if ((display->d_fore)->w_pwin) {
#line 3320
    if (((display->d_fore)->w_pwin)->p_fdpat & 4096) {
#line 3321
      size = (int )(sizeof(((display->d_fore)->w_pwin)->p_inbuf) - (unsigned long )((display->d_fore)->w_pwin)->p_inlen);
    } else {
#line 3324
      size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
    }
  } else {
#line 3324
    size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
  }
#line 3327
  if (size > 4096) {
#line 3328
    size = 4096;
  }
#line 3329
  if (size <= 0) {
#line 3330
    size = 1;
  }
  {
#line 3332
  __cil_tmp6 = read(display->d_userfd, (void *)((char *)buf), (size_t )size);
#line 3332
  size = (int )__cil_tmp6;
  }
#line 3333
  if (size < 0) {
    {
#line 3335
    __cil_tmp8 = __errno_location();
    }
    {
#line 3335
    __cil_tmp7 = __errno_location();
    }
#line 3335
    if (*__cil_tmp7 == 4) {
#line 3336
      return;
    } else
#line 3335
    if (*__cil_tmp8 == 11) {
#line 3336
      return;
    }
    {
#line 3341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3341
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3342
    Hangup();
#line 3343
    sleep((unsigned int )1);
    }
#line 3344
    return;
  } else
#line 3346
  if (size == 0) {
    {
#line 3348
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3348
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3349
    Hangup();
#line 3350
    sleep((unsigned int )1);
    }
#line 3351
    return;
  }
#line 3353
  if (display->d_mouse) {
#line 3353
    if (display->d_forecv) {
#line 3355
      bp = (unsigned char *)((char *)buf);
#line 3356
      i = size;
#line 3359
      i = size;
      {
#line 3359
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3359
        if (! (i > 0)) {
#line 3359
          goto while_break___2;
        }
#line 3361
        if (i > 5) {
#line 3361
          if ((int )*(bp + 0) == 27) {
#line 3361
            if ((int )*(bp + 1) == 91) {
#line 3361
              if ((int )*(bp + 2) == 77) {
#line 3363
                bp ++;
#line 3364
                __cil_tmp14 = i;
#line 3364
                i --;
              } else {
#line 3361
                goto _L;
              }
            } else {
#line 3361
              goto _L;
            }
          } else {
#line 3361
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3366
        if (i < 5) {
#line 3367
          goto while_continue___2;
        } else
#line 3366
        if ((int )*(bp + 0) != 155) {
#line 3367
          goto while_continue___2;
        } else
#line 3366
        if ((int )*(bp + 1) != 77) {
#line 3367
          goto while_continue___2;
        }
#line 3368
        x = (int )*(bp + 3) - 33;
#line 3369
        y = (int )*(bp + 4) - 33;
#line 3370
        if (x >= (display->d_forecv)->c_xs) {
#line 3370
          if (x <= (display->d_forecv)->c_xe) {
#line 3370
            if (y >= (display->d_forecv)->c_ys) {
#line 3370
              if (y <= (display->d_forecv)->c_ye) {
#line 3372
                x -= (display->d_forecv)->c_xoff;
#line 3373
                y -= (display->d_forecv)->c_yoff;
#line 3374
                if (x >= 0) {
#line 3374
                  if (x < ((display->d_forecv)->c_layer)->l_width) {
#line 3374
                    if (y >= 0) {
#line 3374
                      if (y < ((display->d_forecv)->c_layer)->l_height) {
#line 3376
                        *(bp + 3) = (unsigned char )(x + 33);
#line 3377
                        *(bp + 4) = (unsigned char )(y + 33);
#line 3378
                        i -= 4;
#line 3379
                        bp += 4;
#line 3380
                        goto while_continue___2;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 3383
        if ((int )*(bp + 0) == 91) {
          {
#line 3385
          bcopy((void const   *)((char *)bp + 1), (void *)((char *)bp), (size_t )i);
#line 3386
          __cil_tmp15 = bp;
#line 3386
          bp --;
#line 3387
          __cil_tmp16 = size;
#line 3387
          size --;
          }
        }
#line 3389
        if (i > 5) {
          {
#line 3390
          bcopy((void const   *)((char *)bp + 5), (void *)((char *)bp), (size_t )(i - 5));
          }
        }
#line 3391
        __cil_tmp17 = bp;
#line 3391
        bp --;
#line 3392
        i -= 4;
#line 3393
        size -= 5;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3359
      __cil_tmp19 = bp;
#line 3359
      bp ++;
#line 3359
      __cil_tmp18 = i;
#line 3359
      i --;
    }
  }
#line 3397
  if (display->d_forecv) {
#line 3397
    tmp = ((display->d_forecv)->c_layer)->l_encoding;
  } else {
#line 3397
    tmp = 0;
  }
#line 3397
  if (display->d_encoding != tmp) {
#line 3401
    if (display->d_forecv) {
#line 3401
      tmp___116 = ((display->d_forecv)->c_layer)->l_encoding;
    } else {
#line 3401
      tmp___116 = 0;
    }
#line 3401
    enc = tmp___116;
#line 3402
    j = 0;
#line 3402
    i___0 = j;
    {
#line 3402
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3402
      if (! (i___0 < size)) {
#line 3402
        goto while_break___3;
      }
      {
#line 3404
      c = (int )((unsigned char )buf[i___0]);
#line 3405
      c = DecodeChar(c, display->d_encoding, & display->d_decodestate);
      }
#line 3406
      if (c == -2) {
#line 3407
        __cil_tmp28 = i___0;
#line 3407
        i___0 --;
      }
#line 3408
      if (c < 0) {
#line 3409
        goto while_continue___3;
      }
#line 3410
      if (pastefont) {
        {
#line 3412
        font = 0;
#line 3413
        __cil_tmp30 = EncodeChar((char *)buf2 + j, c, enc, & font);
        }
        {
#line 3413
        j += __cil_tmp30;
#line 3414
        __cil_tmp31 = EncodeChar((char *)buf2 + j, - 1, enc, & font);
        }
#line 3414
        j += __cil_tmp31;
      } else {
        {
#line 3417
        __cil_tmp32 = EncodeChar((char *)buf2 + j, c, enc, (int *)0);
        }
#line 3417
        j += __cil_tmp32;
      }
#line 3418
      if ((unsigned long )j > sizeof(buf2) - 10UL) {
#line 3419
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3402
    i___0 ++;
#line 3421
    ((void (*)(char * , int  ))*(display->d_processinput))((char *)buf2, j);
    }
#line 3422
    return;
  }
  {
#line 3425
  ((void (*)(char * , int  ))*(display->d_processinput))((char *)buf, size);
  }
}
}
#line 3429 "/tmp/screen-3.9.15/display.c"
static void disp_status_fn(struct event *ev , char *data ) 
{ 


  {
#line 3433
  display = (struct display *)data;
  {
#line 3434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3435
  if (display->d_status) {
    {
#line 3436
    RemoveStatus();
    }
  }
}
}
#line 3440 "/tmp/screen-3.9.15/display.c"
static void disp_hstatus_fn(struct event *ev , char *data ) 
{ 


  {
#line 3444
  display = (struct display *)data;
#line 3445
  if (display->d_status == 2) {
    {
#line 3447
    SetTimeout(ev, 1);
#line 3448
    evenq(ev);
    }
#line 3449
    return;
  }
  {
#line 3451
  RefreshHStatus();
  }
}
}
#line 3455 "/tmp/screen-3.9.15/display.c"
static void cv_winid_fn(struct event *ev , char *data ) 
{ 
  int ox ;
  int oy ;
  struct canvas *cv ;

  {
#line 3460
  cv = (struct canvas *)data;
#line 3462
  display = cv->c_display;
#line 3463
  if (display->d_status == 1) {
    {
#line 3465
    SetTimeout(ev, 1);
#line 3466
    evenq(ev);
    }
#line 3467
    return;
  }
#line 3469
  ox = display->d_x;
#line 3470
  oy = display->d_y;
#line 3471
  if (cv->c_ye + 1 < display->d_height) {
    {
#line 3472
    RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
    }
  }
#line 3473
  if (ox != -1) {
#line 3473
    if (oy != -1) {
      {
#line 3474
      GotoPos(ox, oy);
      }
    }
  }
}
}
#line 3479 "/tmp/screen-3.9.15/display.c"
static void disp_map_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  int l ;

  {
#line 3485
  display = (struct display *)data;
  {
#line 3486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3486
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3487
  l = display->d_seql;
#line 3487
  if (! l) {
#line 3488
    return;
  }
  {
#line 3489
  p = display->d_seqp - l;
#line 3490
  display->d_seqp = (char *)display->d_kmaps[0].seq;
#line 3491
  display->d_seql = 0;
#line 3492
  ProcessInput2(p, l);
  }
}
}
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 500
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 654 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 68 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 262 "./screen.h"
char strnomem[] ;
#line 46 "./extern.h"
void MakeNewEnv(void) ;
#line 47
char *MakeWinMsg(char *s , struct win *win , int esc ) ;
#line 51
void setbacktick(int num , int lifespan , int tick , char **cmdv ) ;
#line 54
void ResetAnsiState(struct win *p ) ;
#line 56
void ResetCharsets(struct win *p ) ;
#line 57
void WriteString(struct win *wp , char *buf , int len ) ;
#line 58
void ChangeAKA(struct win *p , char *s , int l ) ;
#line 60
int GetAnsiStatus(struct win *w , char *buf ) ;
#line 62
void WBell(struct win *p , int visual ) ;
#line 71
void RcLine(char *ubuf ) ;
#line 74
void WriteFile(struct acluser *user , char *fn , int dump ) ;
#line 75
char *ReadFile(char *fn , int *lenp ) ;
#line 76
void KillBuffers(void) ;
#line 79
void do_source(char *rcfilename ) ;
#line 88
void SendBreak(struct win *wp , int n , int closeopen ) ;
#line 89
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) ;
#line 90
char *TtyGetModemStatus(int fd , char *buf ) ;
#line 102
int GetHistory(void) ;
#line 103
void MarkRoutine(void) ;
#line 106
int InMark(void) ;
#line 107
void MakePaster(struct paster *pa , char *buf , int len , int bufiscopy ) ;
#line 116
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *data ) , char *data ) ;
#line 117
int InInput(void) ;
#line 121
void display_help(char *class , struct action *ktabp ) ;
#line 122
void display_copyright(void) ;
#line 123
void display_displays(void) ;
#line 124
void display_bindkey(char *title , struct action *tab ) ;
#line 125
void display_wlist(int onblank ) ;
#line 126
int InWList(void) ;
#line 130
int MakeWindow(struct NewWindow *newwin ) ;
#line 132
void FreeWindow(struct win *wp ) ;
#line 134
int winexec(char **av ) ;
#line 135
void FreePseudowin(struct win *w ) ;
#line 138
int DoStartLog(struct win *w , char *buf , int bufsize ) ;
#line 139
int ReleaseAutoWritelock(struct display *dis , struct win *w ) ;
#line 140
int ObtainAutoWritelock(struct display *d , struct win *w ) ;
#line 149
int SetUtmp(struct win *wi ) ;
#line 150
int RemoveUtmp(struct win *wi ) ;
#line 152
void SlotToggle(int how ) ;
#line 174
void InitKeytab(void) ;
#line 179
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) ;
#line 180
void DoAction(struct action *act , int key ) ;
#line 182
void DoCommand(char **argv ) ;
#line 183
void Activate(int norefresh ) ;
#line 184
void KillWindow(struct win *wi ) ;
#line 185
void SetForeWindow(struct win *wi ) ;
#line 186
int Parse(char *buf , char **args ) ;
#line 187
int ParseEscape(struct acluser *u , char *p ) ;
#line 188
void DoScreen(char *fn , char **av ) ;
#line 189
int IsNumColon(char *s , int base , char *p , int psize ) ;
#line 190
void ShowWindows(int where ) ;
#line 191
char *AddWindows(char *buf , int len , int flags , int where ) ;
#line 192
char *AddWindowFlags(char *buf , int len , struct win *p ) ;
#line 193
char *AddOtherUsers(char *buf , int len , struct win *p ) ;
#line 195
struct win *FindNiceWindow(struct win *wi , char *presel ) ;
#line 197
int CompileKeys(char *s , unsigned char *array ) ;
#line 202
int ParseSaveStr(struct action *act , char **var ) ;
#line 203
int ParseNum(struct action *act , int *var ) ;
#line 204
int ParseSwitch(struct action *act , int *var ) ;
#line 205
int ParseAttrColor(char *s1 , char *s2 , int msgok ) ;
#line 207
void SwitchWindow(int n ) ;
#line 211
char *MakeTermcap(int aflag ) ;
#line 214
int remap(int n , int map ) ;
#line 215
void CheckEscape(void) ;
#line 301
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) ;
#line 306
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) ;
#line 307
int MayResizeLayer(struct layer *l ) ;
#line 323
int chsock(void) ;
#line 336
char *Filename(char *s ) ;
#line 357
int AddXChars(char *buf , int len , char *str ) ;
#line 358
void xsetenv(char *var , char *value ) ;
#line 52 "/tmp/screen-3.9.15/process.c"
char *rc_name ;
#line 53
char *home ;
#line 54
char *BellString ;
#line 54
char *ActivityString ;
#line 54
char *ShellProg ;
#line 54
char *ShellArgs[2] ;
#line 55
char *timestring ;
#line 56
char *wliststr ;
#line 56
char *wlisttit ;
#line 58
char *hardcopydir ;
#line 58
char *screenlogfile ;
#line 58
char *logtstamp_string ;
#line 59
int log_flush ;
#line 59
int logtstamp_on ;
#line 59
int logtstamp_after ;
#line 60
char *VisualBellString ;
#line 61
int VBellWait ;
#line 61
int SilenceWait ;
#line 62
char *SockName ;
#line 63
int TtyMode ;
#line 63
int auto_detach ;
#line 63
int use_altscreen ;
#line 64
int iflag ;
#line 64
int maxwin ;
#line 65
int visual_bell ;
#line 71
char *printcmd ;
#line 72
int default_startup ;
#line 74
int ZombieKey_destroy ;
#line 75
extern int ZombieKey_resurrect ;
#line 79
int separate_sids ;
#line 80
struct NewWindow nwin_undef ;
#line 82
int join_with_cr ;
#line 83
int compacthist ;
#line 84
int search_ic ;
#line 88
unsigned char mark_key_tab[256] ;
#line 89
char *BufferFile ;
#line 92
char *PowDetachString ;
#line 97
struct term term[188] ;
#line 99
int maptimeout ;
#line 105
int VerboseCreate ;
#line 110
static int CheckArgNum(int nr , char **args ) ;
#line 111
static void ClearAction(struct action *act ) ;
#line 112
static int NextWindow(void) ;
#line 113
static int PreviousWindow(void) ;
#line 114
static int MoreWindows(void) ;
#line 115
static void LogToggle(int on ) ;
#line 116
static void ShowInfo(void) ;
#line 117
static void ShowDInfo(void) ;
#line 118
static char **SaveArgs(char **args ) ;
#line 119
static struct win *WindowByName(char *s ) ;
#line 120
static int WindowByNumber(char *str ) ;
#line 121
static int ParseOnOff(struct action *act , int *var ) ;
#line 122
static int ParseWinNum(struct action *act , int *var ) ;
#line 123
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) ;
#line 124
static char *ParseChar(char *p , char *cp ) ;
#line 125
static int IsNum(char *s , int base ) ;
#line 126
static void Colonfin(char *buf , int len , char *data ) ;
#line 127
static void InputSelect(void) ;
#line 128
static void InputSetenv(char *arg ) ;
#line 129
static void InputAKA(void) ;
#line 131
static int InputSu(struct win *w , struct acluser **up , char *name ) ;
#line 132
static void su_fin(char *buf , int len , char *data ) ;
#line 134
static void AKAfin(char *buf , int len , char *data ) ;
#line 136
static void copy_reg_fn(char *buf , int len , char *data ) ;
#line 137
static void ins_reg_fn(char *buf , int len , char *data ) ;
#line 139
static void process_fn(char *buf , int len , char *data ) ;
#line 141
static void pass1(char *buf , int len , char *data ) ;
#line 142
static void pass2(char *buf , int len , char *data ) ;
#line 145
static void pow_detach_fn(char *buf , int len , char *data ) ;
#line 147
static void digraph_fn(char *buf , int len , char *data ) ;
#line 148
static void confirm_fn(char *buf , int len , char *data ) ;
#line 150
static int StuffKey(int i ) ;
#line 152
static int IsOnDisplay(struct win *wi ) ;
#line 153
static void ResizeRegions(char *arg ) ;
#line 154
static void ResizeFin(char *buf , int len , char *data ) ;
#line 159
struct win *fore ;
#line 159
struct win *console_window ;
#line 162
char screenterm[20] ;
#line 162
char HostName[256] ;
#line 162
char version[40] ;
#line 177
char *multi ;
#line 180 "/tmp/screen-3.9.15/process.c"
char NullStr[]  =    "";
#line 182
struct plop plop_tab[256] ;
#line 188 "/tmp/screen-3.9.15/process.c"
int TtyMode  =    400;
#line 189 "/tmp/screen-3.9.15/process.c"
int hardcopy_append  =    0;
#line 190 "/tmp/screen-3.9.15/process.c"
int all_norefresh  =    0;
#line 192
struct action ktab[256] ;
#line 198
struct kclass *kclasses ;
#line 201
struct action umtab[141] ;
#line 202
struct action dmtab[141] ;
#line 203
struct action mmtab[141] ;
#line 205
char *kmap_extras[50] ;
#line 206
int kmap_extras_fl[50] ;
#line 212 "/tmp/screen-3.9.15/process.c"
static unsigned char const   digraphs[][3]  = 
#line 212
  { {        (unsigned char )' ',        (unsigned char )' ',        (unsigned char )160}, 
   {        (unsigned char )'N',        (unsigned char )'S',        (unsigned char )160}, 
   {        (unsigned char )'~',        (unsigned char )'!',        (unsigned char )161}, 
   {        (unsigned char )'!',        (unsigned char )'!',        (unsigned char )161}, 
   {        (unsigned char )'!',        (unsigned char )'I',        (unsigned char )161}, 
   {        (unsigned char )'c',        (unsigned char )'|',        (unsigned char )162}, 
   {        (unsigned char )'c',        (unsigned char )'t',        (unsigned char )162}, 
   {        (unsigned char )'$',        (unsigned char )'$',        (unsigned char )163}, 
   {        (unsigned char )'P',        (unsigned char )'d',        (unsigned char )163}, 
   {        (unsigned char )'o',        (unsigned char )'x',        (unsigned char )164}, 
   {        (unsigned char )'C',        (unsigned char )'u',        (unsigned char )164}, 
   {        (unsigned char )'C',        (unsigned char )'u',        (unsigned char )164}, 
   {        (unsigned char )'E',        (unsigned char )'u',        (unsigned char )164}, 
   {        (unsigned char )'Y',        (unsigned char )'-',        (unsigned char )165}, 
   {        (unsigned char )'Y',        (unsigned char )'e',        (unsigned char )165}, 
   {        (unsigned char )'|',        (unsigned char )'|',        (unsigned char )166}, 
   {        (unsigned char )'B',        (unsigned char )'B',        (unsigned char )166}, 
   {        (unsigned char )'p',        (unsigned char )'a',        (unsigned char )167}, 
   {        (unsigned char )'S',        (unsigned char )'E',        (unsigned char )167}, 
   {        (unsigned char )'\"',        (unsigned char )'\"',        (unsigned char )168}, 
   {        (unsigned char )'\'',        (unsigned char )':',        (unsigned char )168}, 
   {        (unsigned char )'c',        (unsigned char )'O',        (unsigned char )169}, 
   {        (unsigned char )'C',        (unsigned char )'o',        (unsigned char )169}, 
   {        (unsigned char )'a',        (unsigned char )'-',        (unsigned char )170}, 
   {        (unsigned char )'<',        (unsigned char )'<',        (unsigned char )171}, 
   {        (unsigned char )'-',        (unsigned char )',',        (unsigned char )172}, 
   {        (unsigned char )'N',        (unsigned char )'O',        (unsigned char )172}, 
   {        (unsigned char )'-',        (unsigned char )'-',        (unsigned char )173}, 
   {        (unsigned char )'r',        (unsigned char )'O',        (unsigned char )174}, 
   {        (unsigned char )'R',        (unsigned char )'g',        (unsigned char )174}, 
   {        (unsigned char )'-',        (unsigned char )'=',        (unsigned char )175}, 
   {        (unsigned char )'\'',        (unsigned char )'m',        (unsigned char )175}, 
   {        (unsigned char )'~',        (unsigned char )'o',        (unsigned char )176}, 
   {        (unsigned char )'D',        (unsigned char )'G',        (unsigned char )176}, 
   {        (unsigned char )'+',        (unsigned char )'-',        (unsigned char )177}, 
   {        (unsigned char )'2',        (unsigned char )'2',        (unsigned char )178}, 
   {        (unsigned char )'2',        (unsigned char )'S',        (unsigned char )178}, 
   {        (unsigned char )'3',        (unsigned char )'3',        (unsigned char )179}, 
   {        (unsigned char )'3',        (unsigned char )'S',        (unsigned char )179}, 
   {        (unsigned char )'\'',        (unsigned char )'\'',        (unsigned char )180}, 
   {        (unsigned char )'j',        (unsigned char )'u',        (unsigned char )181}, 
   {        (unsigned char )'M',        (unsigned char )'y',        (unsigned char )181}, 
   {        (unsigned char )'p',        (unsigned char )'p',        (unsigned char )182}, 
   {        (unsigned char )'P',        (unsigned char )'I',        (unsigned char )182}, 
   {        (unsigned char )'~',        (unsigned char )'.',        (unsigned char )183}, 
   {        (unsigned char )'.',        (unsigned char )'M',        (unsigned char )183}, 
   {        (unsigned char )',',        (unsigned char )',',        (unsigned char )184}, 
   {        (unsigned char )'\'',        (unsigned char )',',        (unsigned char )184}, 
   {        (unsigned char )'1',        (unsigned char )'1',        (unsigned char )185}, 
   {        (unsigned char )'1',        (unsigned char )'S',        (unsigned char )185}, 
   {        (unsigned char )'o',        (unsigned char )'-',        (unsigned char )186}, 
   {        (unsigned char )'>',        (unsigned char )'>',        (unsigned char )187}, 
   {        (unsigned char )'1',        (unsigned char )'4',        (unsigned char )188}, 
   {        (unsigned char )'1',        (unsigned char )'2',        (unsigned char )189}, 
   {        (unsigned char )'3',        (unsigned char )'4',        (unsigned char )190}, 
   {        (unsigned char )'~',        (unsigned char )'?',        (unsigned char )191}, 
   {        (unsigned char )'?',        (unsigned char )'?',        (unsigned char )191}, 
   {        (unsigned char )'?',        (unsigned char )'I',        (unsigned char )191}, 
   {        (unsigned char )'A',        (unsigned char )'`',        (unsigned char )192}, 
   {        (unsigned char )'A',        (unsigned char )'!',        (unsigned char )192}, 
   {        (unsigned char )'A',        (unsigned char )'\'',        (unsigned char )193}, 
   {        (unsigned char )'A',        (unsigned char )'^',        (unsigned char )194}, 
   {        (unsigned char )'A',        (unsigned char )'>',        (unsigned char )194}, 
   {        (unsigned char )'A',        (unsigned char )'~',        (unsigned char )195}, 
   {        (unsigned char )'A',        (unsigned char )'?',        (unsigned char )195}, 
   {        (unsigned char )'A',        (unsigned char )'\"',        (unsigned char )196}, 
   {        (unsigned char )'A',        (unsigned char )':',        (unsigned char )196}, 
   {        (unsigned char )'A',        (unsigned char )'@',        (unsigned char )197}, 
   {        (unsigned char )'A',        (unsigned char )'A',        (unsigned char )197}, 
   {        (unsigned char )'A',        (unsigned char )'E',        (unsigned char )198}, 
   {        (unsigned char )'C',        (unsigned char )',',        (unsigned char )199}, 
   {        (unsigned char )'E',        (unsigned char )'`',        (unsigned char )200}, 
   {        (unsigned char )'E',        (unsigned char )'!',        (unsigned char )200}, 
   {        (unsigned char )'E',        (unsigned char )'\'',        (unsigned char )201}, 
   {        (unsigned char )'E',        (unsigned char )'^',        (unsigned char )202}, 
   {        (unsigned char )'E',        (unsigned char )'>',        (unsigned char )202}, 
   {        (unsigned char )'E',        (unsigned char )'\"',        (unsigned char )203}, 
   {        (unsigned char )'E',        (unsigned char )':',        (unsigned char )203}, 
   {        (unsigned char )'I',        (unsigned char )'`',        (unsigned char )204}, 
   {        (unsigned char )'I',        (unsigned char )'!',        (unsigned char )204}, 
   {        (unsigned char )'I',        (unsigned char )'\'',        (unsigned char )205}, 
   {        (unsigned char )'I',        (unsigned char )'^',        (unsigned char )206}, 
   {        (unsigned char )'I',        (unsigned char )'>',        (unsigned char )206}, 
   {        (unsigned char )'I',        (unsigned char )'\"',        (unsigned char )207}, 
   {        (unsigned char )'I',        (unsigned char )':',        (unsigned char )207}, 
   {        (unsigned char )'D',        (unsigned char )'-',        (unsigned char )208}, 
   {        (unsigned char )'N',        (unsigned char )'~',        (unsigned char )209}, 
   {        (unsigned char )'N',        (unsigned char )'?',        (unsigned char )209}, 
   {        (unsigned char )'O',        (unsigned char )'`',        (unsigned char )210}, 
   {        (unsigned char )'O',        (unsigned char )'!',        (unsigned char )210}, 
   {        (unsigned char )'O',        (unsigned char )'\'',        (unsigned char )211}, 
   {        (unsigned char )'O',        (unsigned char )'^',        (unsigned char )212}, 
   {        (unsigned char )'O',        (unsigned char )'>',        (unsigned char )212}, 
   {        (unsigned char )'O',        (unsigned char )'~',        (unsigned char )213}, 
   {        (unsigned char )'O',        (unsigned char )'?',        (unsigned char )213}, 
   {        (unsigned char )'O',        (unsigned char )'\"',        (unsigned char )214}, 
   {        (unsigned char )'O',        (unsigned char )':',        (unsigned char )214}, 
   {        (unsigned char )'/',        (unsigned char )'\\',        (unsigned char )215}, 
   {        (unsigned char )'*',        (unsigned char )'x',        (unsigned char )215}, 
   {        (unsigned char )'O',        (unsigned char )'/',        (unsigned char )216}, 
   {        (unsigned char )'U',        (unsigned char )'`',        (unsigned char )217}, 
   {        (unsigned char )'U',        (unsigned char )'!',        (unsigned char )217}, 
   {        (unsigned char )'U',        (unsigned char )'\'',        (unsigned char )218}, 
   {        (unsigned char )'U',        (unsigned char )'^',        (unsigned char )219}, 
   {        (unsigned char )'U',        (unsigned char )'>',        (unsigned char )219}, 
   {        (unsigned char )'U',        (unsigned char )'\"',        (unsigned char )220}, 
   {        (unsigned char )'U',        (unsigned char )':',        (unsigned char )220}, 
   {        (unsigned char )'Y',        (unsigned char )'\'',        (unsigned char )221}, 
   {        (unsigned char )'I',        (unsigned char )'p',        (unsigned char )222}, 
   {        (unsigned char )'T',        (unsigned char )'H',        (unsigned char )222}, 
   {        (unsigned char )'s',        (unsigned char )'s',        (unsigned char )223}, 
   {        (unsigned char )'s',        (unsigned char )'\"',        (unsigned char )223}, 
   {        (unsigned char )'a',        (unsigned char )'`',        (unsigned char )224}, 
   {        (unsigned char )'a',        (unsigned char )'!',        (unsigned char )224}, 
   {        (unsigned char )'a',        (unsigned char )'\'',        (unsigned char )225}, 
   {        (unsigned char )'a',        (unsigned char )'^',        (unsigned char )226}, 
   {        (unsigned char )'a',        (unsigned char )'>',        (unsigned char )226}, 
   {        (unsigned char )'a',        (unsigned char )'~',        (unsigned char )227}, 
   {        (unsigned char )'a',        (unsigned char )'?',        (unsigned char )227}, 
   {        (unsigned char )'a',        (unsigned char )'\"',        (unsigned char )228}, 
   {        (unsigned char )'a',        (unsigned char )':',        (unsigned char )228}, 
   {        (unsigned char )'a',        (unsigned char )'a',        (unsigned char )229}, 
   {        (unsigned char )'a',        (unsigned char )'e',        (unsigned char )230}, 
   {        (unsigned char )'c',        (unsigned char )',',        (unsigned char )231}, 
   {        (unsigned char )'e',        (unsigned char )'`',        (unsigned char )232}, 
   {        (unsigned char )'e',        (unsigned char )'!',        (unsigned char )232}, 
   {        (unsigned char )'e',        (unsigned char )'\'',        (unsigned char )233}, 
   {        (unsigned char )'e',        (unsigned char )'^',        (unsigned char )234}, 
   {        (unsigned char )'e',        (unsigned char )'>',        (unsigned char )234}, 
   {        (unsigned char )'e',        (unsigned char )'\"',        (unsigned char )235}, 
   {        (unsigned char )'e',        (unsigned char )':',        (unsigned char )235}, 
   {        (unsigned char )'i',        (unsigned char )'`',        (unsigned char )236}, 
   {        (unsigned char )'i',        (unsigned char )'!',        (unsigned char )236}, 
   {        (unsigned char )'i',        (unsigned char )'\'',        (unsigned char )237}, 
   {        (unsigned char )'i',        (unsigned char )'^',        (unsigned char )238}, 
   {        (unsigned char )'i',        (unsigned char )'>',        (unsigned char )238}, 
   {        (unsigned char )'i',        (unsigned char )'\"',        (unsigned char )239}, 
   {        (unsigned char )'i',        (unsigned char )':',        (unsigned char )239}, 
   {        (unsigned char )'d',        (unsigned char )'-',        (unsigned char )240}, 
   {        (unsigned char )'n',        (unsigned char )'~',        (unsigned char )241}, 
   {        (unsigned char )'n',        (unsigned char )'?',        (unsigned char )241}, 
   {        (unsigned char )'o',        (unsigned char )'`',        (unsigned char )242}, 
   {        (unsigned char )'o',        (unsigned char )'!',        (unsigned char )242}, 
   {        (unsigned char )'o',        (unsigned char )'\'',        (unsigned char )243}, 
   {        (unsigned char )'o',        (unsigned char )'^',        (unsigned char )244}, 
   {        (unsigned char )'o',        (unsigned char )'>',        (unsigned char )244}, 
   {        (unsigned char )'o',        (unsigned char )'~',        (unsigned char )245}, 
   {        (unsigned char )'o',        (unsigned char )'?',        (unsigned char )245}, 
   {        (unsigned char )'o',        (unsigned char )'\"',        (unsigned char )246}, 
   {        (unsigned char )'o',        (unsigned char )':',        (unsigned char )246}, 
   {        (unsigned char )':',        (unsigned char )'-',        (unsigned char )247}, 
   {        (unsigned char )'o',        (unsigned char )'/',        (unsigned char )248}, 
   {        (unsigned char )'u',        (unsigned char )'`',        (unsigned char )249}, 
   {        (unsigned char )'u',        (unsigned char )'!',        (unsigned char )249}, 
   {        (unsigned char )'u',        (unsigned char )'\'',        (unsigned char )250}, 
   {        (unsigned char )'u',        (unsigned char )'^',        (unsigned char )251}, 
   {        (unsigned char )'u',        (unsigned char )'>',        (unsigned char )251}, 
   {        (unsigned char )'u',        (unsigned char )'\"',        (unsigned char )252}, 
   {        (unsigned char )'u',        (unsigned char )':',        (unsigned char )252}, 
   {        (unsigned char )'y',        (unsigned char )'\'',        (unsigned char )253}, 
   {        (unsigned char )'i',        (unsigned char )'p',        (unsigned char )254}, 
   {        (unsigned char )'t',        (unsigned char )'h',        (unsigned char )254}, 
   {        (unsigned char )'y',        (unsigned char )'\"',        (unsigned char )255}, 
   {        (unsigned char )'y',        (unsigned char )':',        (unsigned char )255}, 
   {        (unsigned char )'\"',        (unsigned char )'[',        (unsigned char )196}, 
   {        (unsigned char )'\"',        (unsigned char )'\\',        (unsigned char )214}, 
   {        (unsigned char )'\"',        (unsigned char )']',        (unsigned char )220}, 
   {        (unsigned char )'\"',        (unsigned char )'{',        (unsigned char )228}, 
   {        (unsigned char )'\"',        (unsigned char )'|',        (unsigned char )246}, 
   {        (unsigned char )'\"',        (unsigned char )'}',        (unsigned char )252}, 
   {        (unsigned char )'\"',        (unsigned char )'~',        (unsigned char )223}};
#line 387
char *noargs[1] ;
#line 390 "/tmp/screen-3.9.15/process.c"
void InitKeytab(void) 
{ 
  register unsigned int i ;
  char *argarr[2] ;
  char *args[2] ;
  int tmp ;
  char *args___0[2] ;
  char arg1[10] ;
  char *args___1[2] ;
  char *args___2[2] ;

  {
#line 397
  i = (unsigned int )0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! ((unsigned long )i < sizeof(ktab) / sizeof(*((struct action *)ktab)))) {
#line 397
      goto while_break;
    }
#line 399
    ktab[i].nr = - 1;
#line 400
    ktab[i].args = (char **)noargs;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i ++;
#line 403
  i = (unsigned int )0;
  {
#line 403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 403
    if (! (i < 141U)) {
#line 403
      goto while_break___0;
    }
#line 405
    umtab[i].nr = - 1;
#line 406
    umtab[i].args = (char **)noargs;
#line 407
    dmtab[i].nr = - 1;
#line 408
    dmtab[i].args = (char **)noargs;
#line 409
    mmtab[i].nr = - 1;
#line 410
    mmtab[i].args = (char **)noargs;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 403
  i ++;
#line 412
  argarr[1] = (char *)0;
#line 413
  i = (unsigned int )0;
  {
#line 413
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 413
    if (! (i < 69U)) {
#line 413
      goto while_break___1;
    }
#line 415
    if (i + 106U < 106U) {
#line 416
      goto while_continue___1;
    }
#line 417
    if (i + 106U >= 175U) {
#line 418
      goto while_continue___1;
    }
#line 419
    if (kmapdef[i] == (char *)0) {
#line 420
      goto while_continue___1;
    }
    {
#line 421
    argarr[0] = kmapdef[i];
#line 422
    dmtab[i].nr = 143;
#line 423
    dmtab[i].args = SaveArgs((char **)argarr);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 413
  i ++;
#line 425
  i = (unsigned int )0;
  {
#line 425
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 425
    if (! (i < 22U)) {
#line 425
      goto while_break___2;
    }
#line 427
    if (i + 153U < 153U) {
#line 428
      goto while_continue___2;
    }
#line 429
    if (i + 153U >= 175U) {
#line 430
      goto while_continue___2;
    }
#line 431
    if (kmapadef[i] == (char *)0) {
#line 432
      goto while_continue___2;
    }
    {
#line 433
    argarr[0] = kmapadef[i];
#line 434
    dmtab[i + 69U].nr = 143;
#line 435
    dmtab[i + 69U].args = SaveArgs((char **)argarr);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 425
  i ++;
#line 437
  i = (unsigned int )0;
  {
#line 437
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 437
    if (! (i < 19U)) {
#line 437
      goto while_break___3;
    }
#line 439
    if (i + 138U < 106U) {
#line 440
      goto while_continue___3;
    }
#line 441
    if (i + 138U >= 175U) {
#line 442
      goto while_continue___3;
    }
#line 443
    if (kmapmdef[i] == (char *)0) {
#line 444
      goto while_continue___3;
    }
    {
#line 445
    argarr[0] = kmapmdef[i];
#line 446
    argarr[1] = (char *)0;
#line 447
    mmtab[i + 32U].nr = 143;
#line 448
    mmtab[i + 32U].args = SaveArgs((char **)argarr);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 437
  i ++;
#line 452
  ktab['h'].nr = 72;
#line 454
  ktab[26].nr = 145;
#line 454
  ktab['z'].nr = ktab[26].nr;
#line 456
  ktab[3].nr = 127;
#line 456
  ktab['c'].nr = ktab[3].nr;
#line 457
  ktab[14].nr = 102;
#line 457
  ktab['n'].nr = ktab[14].nr;
#line 457
  ktab[0].nr = ktab['n'].nr;
#line 457
  ktab[' '].nr = ktab[0].nr;
#line 459
  ktab['N'].nr = 104;
#line 460
  ktab[16].nr = 115;
#line 460
  ktab['p'].nr = ktab[16].nr;
#line 460
  ktab[127].nr = ktab['p'].nr;
#line 460
  ktab[8].nr = ktab[127].nr;
#line 461
  ktab[11].nr = 83;
#line 461
  ktab['k'].nr = ktab[11].nr;
#line 462
  ktab[12].nr = 121;
#line 462
  ktab['l'].nr = ktab[12].nr;
#line 463
  ktab[23].nr = 163;
#line 463
  ktab['w'].nr = ktab[23].nr;
#line 464
  ktab['v'].nr = 159;
#line 465
  ktab[22].nr = 59;
#line 466
  ktab[17].nr = 168;
#line 466
  ktab['q'].nr = ktab[17].nr;
#line 467
  ktab[19].nr = 167;
#line 467
  ktab['s'].nr = ktab[19].nr;
#line 468
  ktab[20].nr = 150;
#line 468
  ktab['t'].nr = ktab[20].nr;
#line 469
  ktab[9].nr = 81;
#line 469
  ktab['i'].nr = ktab[9].nr;
#line 470
  ktab[13].nr = 84;
#line 470
  ktab['m'].nr = ktab[13].nr;
#line 471
  ktab['A'].nr = 151;
#line 473
  ktab['L'].nr = 89;
#line 475
  ktab[','].nr = 85;
#line 476
  ktab['W'].nr = 161;
#line 477
  ktab['.'].nr = 62;
#line 478
  ktab[28].nr = 118;
#line 480
  ktab[4].nr = 58;
#line 480
  ktab['d'].nr = ktab[4].nr;
#line 482
  ktab['D'].nr = 113;
#line 485
  ktab[18].nr = 164;
#line 485
  ktab['r'].nr = ktab[18].nr;
#line 486
  ktab[6].nr = 69;
#line 486
  ktab['f'].nr = ktab[6].nr;
#line 487
  ktab['C'].nr = 27;
#line 488
  ktab['Z'].nr = 125;
#line 489
  ktab['H'].nr = 87;
#line 490
  ktab['M'].nr = 97;
#line 491
  ktab['?'].nr = 77;
#line 493
  ktab['*'].nr = 61;
#line 497
  args[0] = (char *)"-";
#line 498
  args[1] = (char *)((void *)0);
#line 499
  ktab['-'].nr = 129;
#line 500
  ktab['-'].args = SaveArgs((char **)args);
#line 502
  i = (unsigned int )0;
  }
  {
#line 502
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 502
    if (! (i < (unsigned int )tmp)) {
#line 502
      goto while_break___4;
    }
    {
#line 505
    args___0[0] = (char *)arg1;
#line 506
    args___0[1] = (char *)0;
#line 507
    sprintf((char *)arg1, (char const   *)((char *)"%d"), i);
#line 508
    ktab[48U + i].nr = 129;
#line 509
    ktab[48U + i].args = SaveArgs((char **)args___0);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 502
  i ++;
#line 511
  ktab['\''].nr = 129;
#line 514
  args___1[0] = (char *)"-b";
#line 515
  args___1[1] = (char *)0;
#line 516
  ktab['\"'].nr = 162;
#line 517
  ktab['\"'].args = SaveArgs((char **)args___1);
#line 519
  ktab[7].nr = 155;
#line 520
  ktab[':'].nr = 28;
#line 522
  ktab[27].nr = 32;
#line 522
  ktab['['].nr = ktab[27].nr;
#line 525
  args___2[0] = (char *)".";
#line 526
  args___2[1] = (char *)0;
#line 527
  ktab[']'].args = SaveArgs((char **)args___2);
#line 528
  ktab[29].args = SaveArgs((char **)args___2);
#line 529
  ktab[29].nr = 110;
#line 529
  ktab[']'].nr = ktab[29].nr;
#line 531
  ktab['{'].nr = 78;
#line 532
  ktab['}'].nr = 78;
#line 533
  ktab['>'].nr = 165;
#line 534
  ktab['<'].nr = 119;
#line 535
  ktab['='].nr = 124;
#line 538
  ktab['D'].nr = 113;
#line 541
  ktab[24].nr = 86;
#line 541
  ktab['x'].nr = ktab[24].nr;
#line 543
  ktab[2].nr = 19;
#line 543
  ktab['b'].nr = ktab[2].nr;
#line 544
  ktab['B'].nr = 112;
#line 545
  ktab['_'].nr = 135;
#line 546
  ktab['S'].nr = 141;
#line 547
  ktab['Q'].nr = 106;
#line 548
  ktab['X'].nr = 123;
#line 549
  ktab['F'].nr = 68;
#line 550
  ktab['\t'].nr = 70;
  }
#line 552
  if (DefaultEsc >= 0) {
    {
#line 554
    ClearAction(& ktab[DefaultEsc]);
#line 555
    ktab[DefaultEsc].nr = 107;
    }
  }
#line 557
  if (DefaultMetaEsc >= 0) {
    {
#line 559
    ClearAction(& ktab[DefaultMetaEsc]);
#line 560
    ktab[DefaultMetaEsc].nr = 96;
    }
  }
}
}
#line 565 "/tmp/screen-3.9.15/process.c"
struct action *FindKtab(char *class , int create ) 
{ 
  struct kclass *kp ;
  struct kclass **kpp ;
  int i ;
  int __cil_tmp6 ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 572
  if (class == (char *)0) {
#line 573
    return ((struct action *)ktab);
  }
#line 574
  kpp = & kclasses;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (kp != (struct kclass *)0)) {
#line 574
      goto while_break;
    }
    {
#line 575
    __cil_tmp6 = strcmp((char const   *)kp->name, (char const   *)class);
    }
#line 575
    if (! __cil_tmp6) {
#line 576
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  kpp = & kp->next;
#line 577
  if (kp == (struct kclass *)0) {
#line 579
    if (! create) {
#line 580
      return ((struct action *)0);
    }
    {
#line 581
    __cil_tmp7 = strlen((char const   *)class);
    }
#line 581
    if (__cil_tmp7 > 80UL) {
      {
#line 583
      Msg(0, (char *)"Command class name too long.");
      }
#line 584
      return ((struct action *)0);
    }
    {
#line 586
    __cil_tmp8 = malloc(sizeof(*kp));
#line 586
    kp = (struct kclass *)__cil_tmp8;
    }
#line 587
    if (kp == (struct kclass *)0) {
      {
#line 589
      Msg(0, (char *)strnomem);
      }
#line 590
      return ((struct action *)0);
    }
    {
#line 592
    kp->name = SaveStr((char const   *)class);
#line 593
    i = 0;
    }
    {
#line 593
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 593
      if (! ((unsigned long )i < sizeof(kp->ktab) / sizeof(*((struct action *)kp->ktab)))) {
#line 593
        goto while_break___0;
      }
#line 595
      kp->ktab[i].nr = - 1;
#line 596
      kp->ktab[i].args = (char **)noargs;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 593
    i ++;
#line 598
    kp->next = (struct kclass *)0;
#line 599
    *kpp = kp;
  }
#line 601
  return ((struct action *)kp->ktab);
}
}
#line 605 "/tmp/screen-3.9.15/process.c"
static void ClearAction(struct action *act ) 
{ 
  char **p ;

  {
#line 610
  if (act->nr == -1) {
#line 611
    return;
  }
#line 612
  act->nr = - 1;
#line 613
  if (act->args == (char **)noargs) {
#line 614
    return;
  }
#line 615
  p = act->args;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! *p) {
#line 615
      goto while_break;
    }
    {
#line 616
    free((void *)*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 615
  p ++;
#line 617
  free((void *)((char *)act->args));
#line 618
  act->args = (char **)noargs;
  }
}
}
#line 634 "/tmp/screen-3.9.15/process.c"
void ProcessInput(char *ibuf , int ilen ) 
{ 
  int ch ;
  int slen ;
  unsigned char *s ;
  int i ;
  int l ;
  char *p ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  struct kmap *km ;
  struct kmap *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (display == (struct display *)0) {
#line 645
    return;
  } else
#line 644
  if (ilen == 0) {
#line 645
    return;
  }
#line 646
  if (display->d_seql) {
    {
#line 647
    evdeq(& display->d_mapev);
    }
  }
#line 648
  slen = ilen;
#line 649
  s = (unsigned char *)ibuf;
  {
#line 650
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 650
    if (! (__cil_tmp9 > 0)) {
#line 650
      goto while_break___0;
    }
#line 652
    __cil_tmp10 = s;
#line 652
    s ++;
#line 652
    ch = (int )*__cil_tmp10;
#line 653
    if (display->d_dontmap) {
#line 655
      display->d_dontmap = 0;
#line 656
      goto while_continue___0;
    } else
#line 653
    if (! display->d_nseqs) {
#line 655
      display->d_dontmap = 0;
#line 656
      goto while_continue___0;
    }
    {
#line 658
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 658
      if (! 1) {
#line 658
        goto while_break___1;
      }
#line 660
      if ((int )*((unsigned char *)display->d_seqp) != ch) {
#line 662
        l = (int )*((unsigned char *)display->d_seqp + ((int )((char *)((struct kmap *)0)->off) - (int )((char *)((struct kmap *)0)->seq)));
#line 663
        if (l) {
#line 665
          display->d_seqp += sizeof(struct kmap ) * (unsigned long )l;
#line 666
          goto while_continue___1;
        }
#line 668
        display->d_mapdefault = 0;
#line 669
        l = display->d_seql;
#line 670
        p = display->d_seqp - l;
#line 671
        display->d_seql = 0;
#line 672
        display->d_seqp = (char *)display->d_kmaps[0].seq;
#line 673
        if (l) {
          {
#line 675
          ProcessInput2(p, l);
          }
#line 676
          if (display == (struct display *)0) {
#line 677
            return;
          }
        }
#line 679
        goto while_break___1;
      }
#line 681
      __cil_tmp11 = display->d_seql;
#line 681
      (display->d_seql) ++;
#line 681
      if (__cil_tmp11 == 0) {
        {
#line 684
        slen -= ilen + 1;
#line 685
        ProcessInput2(ibuf, slen);
        }
#line 686
        if (display == (struct display *)0) {
#line 687
          return;
        }
      }
#line 689
      ibuf = (char *)s;
#line 690
      slen = ilen;
#line 691
      ch = - 1;
#line 692
      (display->d_seqp) ++;
#line 692
      if ((int )*(display->d_seqp) == 0) {
#line 694
        i = (int )((struct kmap *)((display->d_seqp - display->d_seql) - (int )((char *)((struct kmap *)0)->seq)) - (struct kmap *)display->d_kmaps);
        {
#line 695
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 695
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 696
        i = display->d_kmaps[i].nr & -16385;
#line 697
        l = display->d_seql;
#line 698
        p = display->d_seqp - l;
#line 699
        display->d_seql = 0;
#line 700
        display->d_seqp = (char *)display->d_kmaps[0].seq;
#line 701
        __cil_tmp12 = StuffKey(i);
        }
#line 701
        if (__cil_tmp12) {
          {
#line 702
          ProcessInput2(p, l);
          }
        }
#line 703
        if (display == (struct display *)0) {
#line 704
          return;
        }
      }
#line 706
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 709
  if (display->d_seql) {
    {
#line 712
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 712
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 713
    km = (struct kmap *)((display->d_seqp - display->d_seql) - (int )((char *)((struct kmap *)0)->seq));
#line 714
    i = (int )*((display->d_seqp - 1) + ((int )((char *)((struct kmap *)0)->off) - (int )((char *)((struct kmap *)0)->seq)));
#line 715
    if (i == 0) {
#line 716
      i = (int )((long )display->d_nseqs - (km - (struct kmap *)display->d_kmaps));
    }
    {
#line 717
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 717
      if (! i) {
#line 717
        goto while_break___4;
      }
#line 718
      if (km->nr & 16384) {
#line 719
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 717
    __cil_tmp15 = i;
#line 717
    i --;
#line 717
    __cil_tmp14 = km;
#line 717
    km ++;
#line 720
    if (i == 0) {
      {
#line 722
      SetTimeout(& display->d_mapev, maptimeout / 1000);
#line 723
      evenq(& display->d_mapev);
      }
    }
  }
  {
#line 726
  ProcessInput2(ibuf, slen);
  }
}
}
#line 739 "/tmp/screen-3.9.15/process.c"
void ProcessInput2(char *ibuf , int ilen ) 
{ 
  char *s ;
  int ch ;
  int slen ;
  struct action *ktabp ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  struct action *tmp ;
  int __cil_tmp10 ;

  {
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 748
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 748
    if (! (ilen && display)) {
#line 748
      goto while_break___0;
    }
    {
#line 750
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 750
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 751
    flayer = (display->d_forecv)->c_layer;
#line 752
    fore = display->d_fore;
#line 753
    slen = ilen;
#line 754
    s = ibuf;
#line 755
    if (! display->d_ESCseen) {
      {
#line 757
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 757
        if (! (ilen > 0)) {
#line 757
          goto while_break___2;
        }
#line 759
        __cil_tmp7 = s;
#line 759
        s ++;
#line 759
        if ((int )((unsigned char )*__cil_tmp7) == (display->d_user)->u_Esc) {
#line 760
          goto while_break___2;
        }
#line 761
        __cil_tmp8 = ilen;
#line 761
        ilen --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 763
      slen -= ilen;
#line 764
      if (slen) {
        {
#line 765
        DoProcess(fore, & ibuf, & slen, (struct paster *)0);
        }
      }
#line 766
      ilen --;
#line 766
      if (ilen == 0) {
#line 767
        display->d_ESCseen = (struct action *)ktab;
      }
    }
#line 769
    if (ilen <= 0) {
#line 770
      return;
    }
#line 771
    if (display->d_ESCseen) {
#line 771
      tmp = display->d_ESCseen;
    } else {
#line 771
      tmp = (struct action *)ktab;
    }
#line 771
    ktabp = tmp;
#line 772
    display->d_ESCseen = (struct action *)0;
#line 773
    ch = (int )((unsigned char )*s);
#line 781
    if (ch == (display->d_user)->u_Esc) {
#line 782
      ch = DefaultEsc;
    } else
#line 783
    if (ch == (display->d_user)->u_MetaEsc) {
#line 784
      ch = DefaultMetaEsc;
    }
#line 786
    if (ch >= 0) {
      {
#line 787
      DoAction(& *(ktabp + ch), ch);
      }
    }
#line 788
    ibuf = s + 1;
#line 789
    __cil_tmp10 = ilen;
#line 789
    ilen --;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 794 "/tmp/screen-3.9.15/process.c"
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) 
{ 
  int oldlen ;
  struct display *d ;

  {
#line 801
  d = display;
#line 804
  if (! pa) {
#line 804
    if (p) {
#line 804
      if (p->w_paster.pa_pastelen) {
        {
#line 806
        while (1) {
          while_continue: /* CIL Label */ ;
#line 806
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 807
        WBell(p, visual_bell);
#line 808
        *bufp += *lenp;
#line 809
        *lenp = 0;
#line 810
        display = d;
        }
#line 811
        return;
      }
    }
  }
#line 814
  if (pa) {
#line 814
    if (*lenp > 1) {
#line 814
      if (p) {
#line 814
        if (p->w_slowpaste) {
          {
#line 817
          SetTimeout(& p->w_paster.pa_slowev, p->w_slowpaste);
#line 818
          evenq(& p->w_paster.pa_slowev);
          }
#line 819
          return;
        }
      }
    }
  }
  {
#line 822
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 822
    if (! (flayer && *lenp)) {
#line 822
      goto while_break___0;
    }
    {
#line 824
    oldlen = *lenp;
#line 825
    ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(bufp, lenp);
    }
#line 827
    if (pa) {
#line 827
      if (! pa->pa_pastelayer) {
#line 828
        goto while_break___0;
      }
    }
#line 830
    if (*lenp == oldlen) {
#line 832
      if (pa) {
#line 834
        display = d;
#line 835
        return;
      }
      {
#line 838
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 838
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 839
      WBell(p, visual_bell);
      }
#line 840
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 843
  *bufp += *lenp;
#line 844
  *lenp = 0;
#line 845
  display = d;
#line 847
  if (pa) {
#line 847
    if (pa->pa_pastelen == 0) {
      {
#line 848
      FreePaster(pa);
      }
    }
  }
}
}
#line 853 "/tmp/screen-3.9.15/process.c"
int FindCommnr(char *str ) 
{ 
  int x ;
  int m ;
  int l ;
  int r ;

  {
#line 856
  l = 0;
#line 856
  r = 169;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! (l <= r)) {
#line 857
      goto while_break;
    }
    {
#line 859
    m = (l + r) / 2;
#line 860
    x = strcmp((char const   *)str, (char const   *)comms[m].name);
    }
#line 861
    if (x > 0) {
#line 862
      l = m + 1;
    } else
#line 863
    if (x < 0) {
#line 864
      r = m - 1;
    } else {
#line 866
      return (m);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 868
  return (- 1);
}
}
#line 872 "/tmp/screen-3.9.15/process.c"
static int CheckArgNum(int nr , char **args ) 
{ 
  int i ;
  int n ;
  static char *argss[] ;
  static char *orformat[] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 886
  n = comms[nr].flags & 3;
#line 887
  i = 0;
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if (! *(args + i)) {
#line 887
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 887
  i ++;
#line 889
  if (comms[nr].flags & (1 << 5)) {
#line 891
    if (i < n) {
#line 893
      if (n != 1) {
#line 893
        tmp = (char *)"s";
      } else {
#line 893
        tmp = (char *)"";
      }
      {
#line 893
      Msg(0, (char *)"%s: %s: at least %s argument%s required", rc_name, comms[nr].name,
          argss[n], tmp);
      }
#line 895
      return (- 1);
    }
  } else
#line 898
  if (comms[nr].flags & (1 << 2)) {
#line 898
    if (comms[nr].flags & (1 << 3)) {
#line 898
      if (comms[nr].flags & (1 << 4)) {
#line 902
        if (i != n) {
#line 902
          if (i != n + 1) {
#line 902
            if (i != n + 2) {
#line 902
              if (i != n + 3) {
                {
#line 904
                Msg(0, orformat[3], rc_name, comms[nr].name, argss[n], argss[n + 1],
                    argss[n + 2], argss[n + 3], (char *)"");
                }
#line 906
                return (- 1);
              }
            }
          }
        }
      } else {
#line 898
        goto _L___119;
      }
    } else {
#line 898
      goto _L___119;
    }
  } else
  _L___119: /* CIL Label */ 
#line 909
  if (comms[nr].flags & (1 << 2)) {
#line 909
    if (comms[nr].flags & (1 << 3)) {
#line 912
      if (i != n) {
#line 912
        if (i != n + 1) {
#line 912
          if (i != n + 2) {
            {
#line 914
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 1], argss[n + 2],
                (char *)"");
            }
#line 916
            return (- 1);
          }
        }
      }
    } else {
#line 909
      goto _L___118;
    }
  } else
  _L___118: /* CIL Label */ 
#line 919
  if (comms[nr].flags & (1 << 2)) {
#line 919
    if (comms[nr].flags & (1 << 4)) {
#line 922
      if (i != n) {
#line 922
        if (i != n + 1) {
#line 922
          if (i != n + 3) {
            {
#line 924
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 1], argss[n + 3],
                (char *)"");
            }
#line 926
            return (- 1);
          }
        }
      }
    } else {
#line 919
      goto _L___117;
    }
  } else
  _L___117: /* CIL Label */ 
#line 929
  if (comms[nr].flags & (1 << 3)) {
#line 929
    if (comms[nr].flags & (1 << 4)) {
#line 932
      if (i != n) {
#line 932
        if (i != n + 2) {
#line 932
          if (i != n + 3) {
            {
#line 934
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 2], argss[n + 3],
                (char *)"");
            }
#line 936
            return (- 1);
          }
        }
      }
    } else {
#line 929
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 939
  if (comms[nr].flags & (1 << 2)) {
#line 941
    if (i != n) {
#line 941
      if (i != n + 1) {
#line 943
        if (n != 0) {
#line 943
          tmp___0 = (char *)"s";
        } else {
#line 943
          tmp___0 = (char *)"";
        }
        {
#line 943
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 1], tmp___0);
        }
#line 945
        return (- 1);
      }
    }
  } else
#line 948
  if (comms[nr].flags & (1 << 3)) {
#line 950
    if (i != n) {
#line 950
      if (i != n + 2) {
        {
#line 952
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 2], (char *)"s");
        }
#line 954
        return (- 1);
      }
    }
  } else
#line 957
  if (comms[nr].flags & (1 << 4)) {
#line 959
    if (i != n) {
#line 959
      if (i != n + 3) {
        {
#line 961
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 3], (char *)"");
        }
#line 963
        return (- 1);
      }
    }
  } else
#line 966
  if (i != n) {
#line 968
    if (n != 1) {
#line 968
      tmp___1 = (char *)"s";
    } else {
#line 968
      tmp___1 = (char *)"";
    }
    {
#line 968
    Msg(0, orformat[0], rc_name, comms[nr].name, argss[n], tmp___1);
    }
#line 969
    return (- 1);
  }
#line 971
  return (i);
}
}
#line 976 "/tmp/screen-3.9.15/process.c"
void DoAction(struct action *act , int key ) 
{ 
  int nr ;
  char **args ;
  struct win *p ;
  int argc ;
  int i ;
  int n ;
  int msgok ;
  char *s ;
  char ch ;
  struct display *odisplay ;
  struct acluser *user ;
  struct acluser *tmp ;
  int __cil_tmp16 ;
  struct acluser *tmp___121 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *tmp___122 ;
  int __cil_tmp21 ;
  char *tmp___123 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int mode ;
  int __cil_tmp26 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp___124 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  char *name ;
  char *tmp___125 ;
  int __cil_tmp38 ;
  static char buf[2] ;
  int __cil_tmp40 ;
  char ch2 ;
  struct display *olddisplay ;
  size_t __cil_tmp46 ;
  int __cil_tmp47 ;
  struct display *nd ;
  struct acluser *u ;
  int __cil_tmp50 ;
  char *tmp___127 ;
  struct display *nd___0 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  char *tmp___129 ;
  int __cil_tmp59 ;
  struct win *nw ;
  int ch___130 ;
  int __cil_tmp64 ;
  struct layer *tmp___131 ;
  char *tmp___132 ;
  char *tmp___133 ;
  int tmp___135 ;
  int tmp___136 ;
  int __cil_tmp70 ;
  struct plop *pp ;
  int tmp___137 ;
  int tmp___138 ;
  int __cil_tmp77 ;
  size_t __cil_tmp81 ;
  struct plop *plp ;
  size_t __cil_tmp84 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp89 ;
  char *tmp___139 ;
  size_t __cil_tmp91 ;
  char *__cil_tmp93 ;
  struct action *ktabp ;
  int __cil_tmp95 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int tmp___140 ;
  static char *types[] ;
  extern int breaktype___0 ;
  int __cil_tmp102 ;
  int __cil_tmp105 ;
  int w ;
  int h ;
  int what ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp116 ;
  int tmp___142 ;
  size_t __cil_tmp118 ;
  int __cil_tmp119 ;
  int tmp___143 ;
  int tmp___144 ;
  int __cil_tmp122 ;
  int tmp___145 ;
  int tmp___146 ;
  char *tmp___147 ;
  int __cil_tmp126 ;
  int tmp___148 ;
  int __cil_tmp128 ;
  int tmp___149 ;
  int __cil_tmp130 ;
  char *tmp___150 ;
  char *tmp___151 ;
  int __cil_tmp133 ;
  int __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  int __cil_tmp140 ;
  int __cil_tmp142 ;
  struct action *ktabp___0 ;
  static char *pasteargs[] ;
  int __cil_tmp146 ;
  char *ss ;
  char *dbuf ;
  char dch ;
  int l ;
  int enc ;
  int __cil_tmp153 ;
  int __cil_tmp154 ;
  int tmp___154 ;
  char *tmp___155 ;
  void *__cil_tmp158 ;
  struct plop *pp___0 ;
  struct plop *tmp___156 ;
  int __cil_tmp161 ;
  struct plop *pp___1 ;
  struct plop oldplop ;
  int __cil_tmp165 ;
  int enc___0 ;
  int l___0 ;
  char *newbuf ;
  void *__cil_tmp171 ;
  int tmp___157 ;
  int tmp___158 ;
  int __cil_tmp175 ;
  char *tmp___159 ;
  char *__cil_tmp178 ;
  int __cil_tmp179 ;
  char *tmp___160 ;
  int __cil_tmp181 ;
  int __cil_tmp182 ;
  char *tmp___161 ;
  int __cil_tmp184 ;
  int *__cil_tmp185 ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  char *tmp___162 ;
  int __cil_tmp189 ;
  int __cil_tmp191 ;
  int __cil_tmp192 ;
  int __cil_tmp193 ;
  int __cil_tmp194 ;
  char *tmp___163 ;
  int __cil_tmp196 ;
  int __cil_tmp198 ;
  int __cil_tmp200 ;
  int __cil_tmp201 ;
  size_t __cil_tmp202 ;
  int __cil_tmp203 ;
  char *tmp___166 ;
  char buf___0[256] ;
  int __cil_tmp206 ;
  int __cil_tmp208 ;
  int __cil_tmp209 ;
  char buf___1[256] ;
  int __cil_tmp211 ;
  int __cil_tmp212 ;
  int __cil_tmp213 ;
  int __cil_tmp214 ;
  int __cil_tmp215 ;
  int __cil_tmp216 ;
  int __cil_tmp217 ;
  int __cil_tmp218 ;
  int __cil_tmp219 ;
  int __cil_tmp220 ;
  int __cil_tmp221 ;
  int __cil_tmp222 ;
  int __cil_tmp223 ;
  int tmp___168 ;
  int __cil_tmp225 ;
  int tmp___169 ;
  char *tmp___170 ;
  int __cil_tmp228 ;
  int __cil_tmp229 ;
  int __cil_tmp230 ;
  struct display *olddisplay___0 ;
  int old_use ;
  int new_use ;
  int __cil_tmp234 ;
  int __cil_tmp235 ;
  int __cil_tmp236 ;
  int __cil_tmp237 ;
  int __cil_tmp238 ;
  char buf___2[256] ;
  int tmp___171 ;
  int __cil_tmp242 ;
  char *tmp___173 ;
  int __cil_tmp244 ;
  int __cil_tmp245 ;
  struct display *olddisplay___1 ;
  int __cil_tmp247 ;
  char buf___3[256] ;
  int __cil_tmp250 ;
  int __cil_tmp251 ;
  struct win *tmp___175 ;
  int __cil_tmp253 ;
  char *tmp___176 ;
  int __cil_tmp255 ;
  int __cil_tmp256 ;
  int __cil_tmp257 ;
  int __cil_tmp258 ;
  int __cil_tmp259 ;
  int __cil_tmp260 ;
  int old ;
  int __cil_tmp262 ;
  struct display *tmp___177 ;
  int __cil_tmp264 ;
  int __cil_tmp265 ;
  int __cil_tmp268 ;
  int __cil_tmp269 ;
  int __cil_tmp270 ;
  char buf___4[4096] ;
  int __cil_tmp272 ;
  size_t __cil_tmp273 ;
  char *__cil_tmp274 ;
  __pid_t __cil_tmp275 ;
  int __cil_tmp276 ;
  int *__cil_tmp277 ;
  int __cil_tmp278 ;
  int *__cil_tmp279 ;
  int __cil_tmp280 ;
  char *tmp___181 ;
  int __cil_tmp282 ;
  char *tmp___182 ;
  int __cil_tmp284 ;
  int __cil_tmp285 ;
  int __cil_tmp286 ;
  char *tmp___183 ;
  int __cil_tmp288 ;
  int __cil_tmp289 ;
  char *tmp___184 ;
  int __cil_tmp291 ;
  int __cil_tmp292 ;
  char buf___5[256] ;
  int __cil_tmp294 ;
  int __cil_tmp295 ;
  int __cil_tmp296 ;
  int __cil_tmp297 ;
  int tmp___185 ;
  int __cil_tmp300 ;
  char *tmp___186 ;
  struct action *ktabp___1 ;
  int __cil_tmp303 ;
  int __cil_tmp307 ;
  struct action *newact ;
  int newnr ;
  int fl ;
  int kf ;
  int af ;
  int df ;
  int mf ;
  struct display *odisp ;
  int used ;
  int __cil_tmp318 ;
  int __cil_tmp319 ;
  int __cil_tmp320 ;
  int __cil_tmp321 ;
  int __cil_tmp322 ;
  int __cil_tmp323 ;
  int __cil_tmp326 ;
  char *tmp___187 ;
  int __cil_tmp329 ;
  struct action *tmp___189 ;
  struct action *tmp___190 ;
  int __cil_tmp334 ;
  int tmp___191 ;
  int __cil_tmp338 ;
  int __cil_tmp339 ;
  int __cil_tmp340 ;
  int __cil_tmp341 ;
  struct acluser *u___0 ;
  struct aclusergroup *g ;
  char buf___6[256] ;
  char *p___192 ;
  int ngroups ;
  struct acluser *u___1 ;
  struct aclusergroup *g___0 ;
  size_t __cil_tmp352 ;
  char *tmp___193 ;
  char *tmp___194 ;
  char *err ;
  struct acluser *tmp___195 ;
  int __cil_tmp358 ;
  int __cil_tmp359 ;
  char *tmp___196 ;
  char *tmp___197 ;
  int __cil_tmp362 ;
  char *tmp___198 ;
  int __cil_tmp364 ;
  char *tmp___199 ;
  int __cil_tmp366 ;
  char *tmp___200 ;
  int __cil_tmp368 ;
  char *tmp___201 ;
  int __cil_tmp370 ;
  char *tmp___202 ;
  int __cil_tmp373 ;
  int __cil_tmp374 ;
  int __cil_tmp375 ;
  int __cil_tmp379 ;
  int tmp___204 ;
  char *tmp___205 ;
  int __cil_tmp382 ;
  int __cil_tmp383 ;
  int tmp___206 ;
  char *tmp___207 ;
  int tmp___208 ;
  size_t __cil_tmp389 ;
  char buf___7[256] ;
  int __cil_tmp391 ;
  int __cil_tmp392 ;
  char buf___8[256] ;
  size_t __cil_tmp394 ;
  char *__cil_tmp398 ;
  int __cil_tmp404 ;
  struct canvas *tmp___217 ;
  int __cil_tmp406 ;
  struct canvas *cv ;
  int __cil_tmp408 ;
  int __cil_tmp409 ;
  struct canvas *cv___0 ;
  struct display *olddisplay___2 ;
  struct layer *oldflayer ;
  struct layer *l___1 ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int __cil_tmp416 ;
  char *ss___0 ;
  char *__cil_tmp418 ;
  int __cil_tmp420 ;
  char *tmp___219 ;
  int __cil_tmp422 ;
  int __cil_tmp423 ;
  int lifespan ;
  int tick ;
  int __cil_tmp426 ;
  int __cil_tmp427 ;
  char **__cil_tmp428 ;

  {
#line 980
  nr = act->nr;
#line 981
  args = act->args;
#line 986
  odisplay = display;
#line 989
  if (display) {
#line 989
    tmp = display->d_user;
  } else {
#line 989
    tmp = users;
  }
#line 989
  user = tmp;
#line 990
  if (nr == -1) {
    {
#line 992
    while (1) {
      while_continue: /* CIL Label */ ;
#line 992
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 993
    return;
  }
#line 995
  n = comms[nr].flags;
#line 996
  if (n & (1 << 7)) {
#line 996
    if (display == (struct display *)0) {
      {
#line 998
      Msg(0, (char *)"%s: %s: display required", rc_name, comms[nr].name);
      }
#line 999
      return;
    }
  }
#line 1001
  if (n & (1 << 6)) {
#line 1001
    if (fore == (struct win *)0) {
      {
#line 1003
      Msg(0, (char *)"%s: %s: window required", rc_name, comms[nr].name);
      }
#line 1004
      return;
    }
  }
#line 1006
  if (n & (1 << 8)) {
#line 1006
    if (flayer == (struct layer *)0) {
      {
#line 1008
      Msg(0, (char *)"%s: %s: display or window required", rc_name, comms[nr].name);
      }
#line 1009
      return;
    }
  }
  {
#line 1011
  argc = CheckArgNum(nr, args);
  }
#line 1011
  if (argc < 0) {
#line 1012
    return;
  }
#line 1014
  if (display) {
    {
#line 1016
    __cil_tmp16 = AclCheckPermCmd(display->d_user, 0, & comms[nr]);
    }
#line 1016
    if (__cil_tmp16) {
      {
#line 1018
      Msg(0, (char *)"%s: %s: permission denied (user %s)", rc_name, comms[nr].name,
          (char *)tmp___121->u_name);
      }
#line 1020
      return;
    }
  }
#line 1025
  msgok = display && ! *rc_name;
  {
#line 1028
  if (nr == 129) {
#line 1028
    goto case_129;
  }
#line 1040
  if (nr == 35) {
#line 1040
    goto case_35;
  }
#line 1046
  if (nr == 12) {
#line 1046
    goto case_12;
  }
#line 1051
  if (nr == 50) {
#line 1051
    goto case_50;
  }
#line 1060
  if (nr == 105) {
#line 1060
    goto case_105;
  }
#line 1067
  if (nr == 62) {
#line 1067
    goto case_62;
  }
#line 1070
  if (nr == 72) {
#line 1070
    goto case_72;
  }
#line 1091
  if (nr == 46) {
#line 1091
    goto case_46;
  }
#line 1094
  if (nr == 87) {
#line 1094
    goto case_87;
  }
#line 1100
  if (nr == 145) {
#line 1100
    goto case_145;
  }
#line 1104
  if (nr == 102) {
#line 1104
    goto case_102;
  }
#line 1108
  if (nr == 115) {
#line 1108
    goto case_115;
  }
#line 1112
  if (nr == 83) {
#line 1112
    goto case_83;
  }
#line 1141
  if (nr == 118) {
#line 1141
    goto case_118;
  }
#line 1150
  if (nr == 58) {
#line 1150
    goto case_58;
  }
#line 1157
  if (nr == 113) {
#line 1157
    goto case_113;
  }
#line 1170
  if (nr == 34) {
#line 1170
    goto case_34;
  }
#line 1198
  if (nr == 169) {
#line 1198
    goto case_169;
  }
#line 1219
  if (nr == 160) {
#line 1219
    goto case_160;
  }
#line 1232
  if (nr == 9) {
#line 1232
    goto case_9;
  }
#line 1250
  if (nr == '*') {
#line 1250
    goto case_42;
  }
#line 1285
  if (nr == '%') {
#line 1285
    goto case_37;
  }
#line 1314
  if (nr == '#') {
#line 1314
    goto case_35___0;
  }
#line 1389
  if (nr == 120) {
#line 1389
    goto case_120;
  }
#line 1451
  if (nr == 122) {
#line 1451
    goto case_122;
  }
#line 1501
  if (nr == 117) {
#line 1501
    goto case_117;
  }
#line 1514
  if (nr == 143) {
#line 1514
    goto case_143;
  }
#line 1544
  if (nr == 121) {
#line 1544
    goto case_121;
  }
#line 1547
  if (nr == 163) {
#line 1547
    goto case_163;
  }
#line 1550
  if (nr == 159) {
#line 1550
    goto case_159;
  }
#line 1553
  if (nr == 150) {
#line 1553
    goto case_150;
  }
#line 1561
  if (nr == 81) {
#line 1561
    goto case_81;
  }
#line 1564
  if (nr == 60) {
#line 1564
    goto case_60;
  }
#line 1567
  if (nr == 29) {
#line 1567
    goto case_29;
  }
#line 1586
  if (nr == 107) {
#line 1586
    goto case_107;
  }
#line 1590
  if (nr == 96) {
#line 1590
    goto case_96;
  }
#line 1598
  if (nr == 168) {
#line 1598
    goto case_168;
  }
#line 1604
  if (nr == 167) {
#line 1604
    goto case_167;
  }
#line 1611
  if (nr == 20) {
#line 1611
    goto case_20;
  }
#line 1611
  if (nr == 37) {
#line 1611
    goto case_20;
  }
#line 1645
  if (nr == 19) {
#line 1645
    goto case_19;
  }
#line 1645
  if (nr == 112) {
#line 1645
    goto case_19;
  }
#line 1652
  if (nr == 86) {
#line 1652
    goto case_86;
  }
#line 1657
  if (nr == 76) {
#line 1657
    goto case_76;
  }
#line 1657
  if (nr == 161) {
#line 1657
    goto case_76;
  }
#line 1784
  if (nr == 151) {
#line 1784
    goto case_151;
  }
#line 1790
  if (nr == 28) {
#line 1790
    goto case_28;
  }
#line 1799
  if (nr == 84) {
#line 1799
    goto case_84;
  }
#line 1803
  if (nr == 127) {
#line 1803
    goto case_127;
  }
#line 1806
  if (nr == 164) {
#line 1806
    goto case_164;
  }
#line 1810
  if (nr == 69) {
#line 1810
    goto case_69;
  }
#line 1839
  if (nr == 57) {
#line 1839
    goto case_57;
  }
#line 1849
  if (nr == 166) {
#line 1849
    goto case_166;
  }
#line 1873
  if (nr == 27) {
#line 1873
    goto case_27;
  }
#line 1877
  if (nr == 125) {
#line 1877
    goto case_125;
  }
#line 1881
  if (nr == 97) {
#line 1881
    goto case_97;
  }
#line 1917
  if (nr == 61) {
#line 1917
    goto case_61;
  }
#line 1921
  if (nr == 162) {
#line 1921
    goto case_162;
  }
#line 1951
  if (nr == 77) {
#line 1951
    goto case_77;
  }
#line 1965
  if (nr == 85) {
#line 1965
    goto case_85;
  }
#line 1969
  if (nr == 32) {
#line 1969
    goto case_32;
  }
#line 1977
  if (nr == 78) {
#line 1977
    goto case_78;
  }
#line 1993
  if (nr == 110) {
#line 1993
    goto case_110;
  }
#line 2135
  if (nr == 165) {
#line 2135
    goto case_165;
  }
#line 2184
  if (nr == 119) {
#line 2184
    goto case_119;
  }
#line 2214
  if (nr == 124) {
#line 2214
    goto case_124;
  }
#line 2217
  if (nr == 80) {
#line 2217
    goto case_80;
  }
#line 2223
  if (nr == 65) {
#line 2223
    goto case_65;
  }
#line 2235
  if (nr == 41) {
#line 2235
    goto case_41;
  }
#line 2245
  if (nr == 26) {
#line 2245
    goto case_26;
  }
#line 2251
  if (nr == 52) {
#line 2251
    goto case_52;
  }
#line 2251
  if (nr == 133) {
#line 2251
    goto case_52;
  }
#line 2255
  if (nr == 74) {
#line 2255
    goto case_74;
  }
#line 2261
  if (nr == 88) {
#line 2261
    goto case_88;
  }
#line 2276
  if (nr == 90) {
#line 2276
    goto case_90;
  }
#line 2306
  if (nr == 134) {
#line 2306
    goto case_134;
  }
#line 2311
  if (nr == 149) {
#line 2311
    goto case_149;
  }
#line 2311
  if (nr == 148) {
#line 2311
    goto case_149;
  }
#line 2311
  if (nr == 147) {
#line 2311
    goto case_149;
  }
#line 2315
  if (nr == 137) {
#line 2315
    goto case_137;
  }
#line 2317
  if (nr == 146) {
#line 2317
    goto case_146;
  }
#line 2333
  if (nr == 63) {
#line 2333
    goto case_63;
  }
#line 2346
  if (nr == 16) {
#line 2346
    goto case_16;
  }
#line 2346
  if (nr == 15) {
#line 2346
    goto case_16;
  }
#line 2357
  if (nr == 21) {
#line 2357
    goto case_21;
  }
#line 2366
  if (nr == 5) {
#line 2366
    goto case_5;
  }
#line 2370
  if (nr == 114) {
#line 2370
    goto case_114;
  }
#line 2382
  if (nr == 89) {
#line 2382
    goto case_89;
  }
#line 2401
  if (nr == 47) {
#line 2401
    goto case_47;
  }
#line 2410
  if (nr == 42) {
#line 2410
    goto case_42___0;
  }
#line 2432
  if (nr == 56) {
#line 2432
    goto case_56;
  }
#line 2435
  if (nr == 38) {
#line 2435
    goto case_38;
  }
#line 2439
  if (nr == 36) {
#line 2439
    goto case_36;
  }
#line 2443
  if (nr == 43) {
#line 2443
    goto case_43;
  }
#line 2446
  if (nr == 49) {
#line 2446
    goto case_49;
  }
#line 2450
  if (nr == 53) {
#line 2450
    goto case_53;
  }
#line 2454
  if (nr == 158) {
#line 2454
    goto case_158;
  }
#line 2461
  if (nr == 75) {
#line 2461
    goto case_75;
  }
#line 2528
  if (nr == 23) {
#line 2528
    goto case_23;
  }
#line 2560
  if (nr == 31) {
#line 2560
    goto case_31;
  }
#line 2575
  if (nr == 7) {
#line 2575
    goto case_7;
  }
#line 2584
  if (nr == 108) {
#line 2584
    goto case_108;
  }
#line 2588
  if (nr == 155) {
#line 2588
    goto case_155;
  }
#line 2596
  if (nr == 157) {
#line 2596
    goto case_157;
  }
#line 2600
  if (nr == 99) {
#line 2600
    goto case_99;
  }
#line 2604
  if (nr == 98) {
#line 2604
    goto case_98;
  }
#line 2608
  if (nr == 136) {
#line 2608
    goto case_136;
  }
#line 2618
  if (nr == 104) {
#line 2618
    goto case_104;
  }
#line 2659
  if (nr == 135) {
#line 2659
    goto case_135;
  }
#line 2712
  if (nr == 51) {
#line 2712
    goto case_51;
  }
#line 2715
  if (nr == 128) {
#line 2715
    goto case_128;
  }
#line 2722
  if (nr == 130) {
#line 2722
    goto case_130;
  }
#line 2756
  if (nr == 131) {
#line 2756
    goto case_131;
  }
#line 2768
  if (nr == 153) {
#line 2768
    goto case_153;
  }
#line 2773
  if (nr == 54) {
#line 2773
    goto case_54;
  }
#line 2776
  if (nr == 138) {
#line 2776
    goto case_138;
  }
#line 2788
  if (nr == 94) {
#line 2788
    goto case_94;
  }
#line 2802
  if (nr == 111) {
#line 2802
    goto case_111;
  }
#line 2807
  if (nr == 33) {
#line 2807
    goto case_33;
  }
#line 2810
  if (nr == 30) {
#line 2810
    goto case_30;
  }
#line 2816
  if (nr == 101) {
#line 2816
    goto case_101;
  }
#line 2820
  if (nr == 73) {
#line 2820
    goto case_73;
  }
#line 2823
  if (nr == 156) {
#line 2823
    goto case_156;
  }
#line 2834
  if (nr == 48) {
#line 2834
    goto case_48;
  }
#line 2846
  if (nr == 11) {
#line 2846
    goto case_11;
  }
#line 2849
  if (nr == 142) {
#line 2849
    goto case_142;
  }
#line 2853
  if (nr == 109) {
#line 2853
    goto case_109;
  }
#line 2878
  if (nr == 17) {
#line 2878
    goto case_17;
  }
#line 2915
  if (nr == 18) {
#line 2915
    goto case_18;
  }
#line 3043
  if (nr == 93) {
#line 3043
    goto case_93;
  }
#line 3058
  if (nr == 92) {
#line 3058
    goto case_92;
  }
#line 3061
  if (nr == 91) {
#line 3061
    goto case_91;
  }
#line 3069
  if (nr == 24) {
#line 3069
    goto case_24;
  }
#line 3069
  if (nr == 6) {
#line 3069
    goto case_24;
  }
#line 3069
  if (nr == 0) {
#line 3069
    goto case_24;
  }
#line 3069
  if (nr == 1) {
#line 3069
    goto case_24;
  }
#line 3072
  if (nr == 2) {
#line 3072
    goto case_2;
  }
#line 3078
  if (nr == 3) {
#line 3078
    goto case_3;
  }
#line 3137
  if (nr == 152) {
#line 3137
    goto case_152;
  }
#line 3137
  if (nr == 4) {
#line 3137
    goto case_152;
  }
#line 3146
  if (nr == 100) {
#line 3146
    goto case_100;
  }
#line 3156
  if (nr == 67) {
#line 3156
    goto case_67;
  }
#line 3161
  if (nr == 103) {
#line 3161
    goto case_103;
  }
#line 3167
  if (nr == 71) {
#line 3167
    goto case_71;
  }
#line 3179
  if (nr == 22) {
#line 3179
    goto case_22;
  }
#line 3184
  if (nr == 14) {
#line 3184
    goto case_14;
  }
#line 3191
  if (nr == 64) {
#line 3191
    goto case_64;
  }
#line 3191
  if (nr == 82) {
#line 3191
    goto case_64;
  }
#line 3244
  if (nr == 40) {
#line 3244
    goto case_40;
  }
#line 3244
  if (nr == 45) {
#line 3244
    goto case_40;
  }
#line 3256
  if (nr == 55) {
#line 3256
    goto case_55;
  }
#line 3265
  if (nr == 154) {
#line 3265
    goto case_154;
  }
#line 3295
  if (nr == 116) {
#line 3295
    goto case_116;
  }
#line 3314
  if (nr == 59) {
#line 3314
    goto case_59;
  }
#line 3324
  if (nr == 44) {
#line 3324
    goto case_44;
  }
#line 3341
  if (nr == 79) {
#line 3341
    goto case_79;
  }
#line 3353
  if (nr == 25) {
#line 3353
    goto case_25;
  }
#line 3353
  if (nr == 39) {
#line 3353
    goto case_25;
  }
#line 3387
  if (nr == 10) {
#line 3387
    goto case_10;
  }
#line 3427
  if (nr == 139) {
#line 3427
    goto case_139;
  }
#line 3444
  if (nr == 140) {
#line 3444
    goto case_140;
  }
#line 3449
  if (nr == 144) {
#line 3449
    goto case_144;
  }
#line 3466
  if (nr == 141) {
#line 3466
    goto case_141;
  }
#line 3470
  if (nr == 123) {
#line 3470
    goto case_123;
  }
#line 3474
  if (nr == 106) {
#line 3474
    goto case_106;
  }
#line 3478
  if (nr == 68) {
#line 3478
    goto case_68;
  }
#line 3486
  if (nr == 70) {
#line 3486
    goto case_70;
  }
#line 3527
  if (nr == 126) {
#line 3527
    goto case_126;
  }
#line 3533
  if (nr == 132) {
#line 3533
    goto case_132;
  }
#line 3536
  if (nr == 66) {
#line 3536
    goto case_66;
  }
#line 3544
  if (nr == 8) {
#line 3544
    goto case_8;
  }
#line 3549
  if (nr == 95) {
#line 3549
    goto case_95;
  }
#line 3559
  if (nr == 13) {
#line 3559
    goto case_13;
  }
#line 3579
  goto switch_default___0;
  case_129: /* CIL Label */ 
#line 1029
  if (! *args) {
    {
#line 1030
    InputSelect();
    }
  } else
#line 1031
  if ((int )*(*(args + 0) + 0) == 45) {
#line 1031
    if (! *(*(args + 0) + 1)) {
      {
#line 1033
      SetForeWindow((struct win *)0);
#line 1034
      Activate(0);
      }
    } else {
#line 1031
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1036
    __cil_tmp18 = ParseWinNum(act, & n);
    }
#line 1036
    if (__cil_tmp18 == 0) {
      {
#line 1037
      SwitchWindow(n);
      }
    }
  }
#line 1038
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 1041
  __cil_tmp19 = ParseOnOff(act, & defautonuke);
  }
#line 1041
  if (__cil_tmp19 == 0) {
#line 1041
    if (msgok) {
#line 1042
      if (defautonuke) {
#line 1042
        tmp___122 = (char *)"on";
      } else {
#line 1042
        tmp___122 = (char *)"off";
      }
      {
#line 1042
      Msg(0, (char *)"Default autonuke turned %s", tmp___122);
      }
    }
  }
#line 1043
  if (display) {
#line 1043
    if ((int )*rc_name) {
#line 1044
      display->d_auto_nuke = defautonuke;
    }
  }
#line 1045
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1047
  __cil_tmp21 = ParseOnOff(act, & display->d_auto_nuke);
  }
#line 1047
  if (__cil_tmp21 == 0) {
#line 1047
    if (msgok) {
#line 1048
      if (display->d_auto_nuke) {
#line 1048
        tmp___123 = (char *)"on";
      } else {
#line 1048
        tmp___123 = (char *)"off";
      }
      {
#line 1048
      Msg(0, (char *)"Autonuke turned %s", tmp___123);
      }
    }
  }
#line 1049
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 1052
  __cil_tmp23 = ParseNum(act, & defobuflimit);
  }
#line 1052
  if (__cil_tmp23 == 0) {
#line 1052
    if (msgok) {
      {
#line 1053
      Msg(0, (char *)"Default limit set to %d", defobuflimit);
      }
    }
  }
#line 1054
  if (display) {
#line 1054
    if ((int )*rc_name) {
#line 1056
      display->d_obufmax = defobuflimit;
#line 1057
      display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
    }
  }
#line 1059
  goto switch_break;
  case_105: /* CIL Label */ 
#line 1061
  if (*args == (char *)0) {
    {
#line 1062
    Msg(0, (char *)"Limit is %d, current buffer size is %d", display->d_obufmax, display->d_obuflen);
    }
  } else {
    {
#line 1063
    __cil_tmp24 = ParseNum(act, & display->d_obufmax);
    }
#line 1063
    if (__cil_tmp24 == 0) {
#line 1063
      if (msgok) {
        {
#line 1064
        Msg(0, (char *)"Limit set to %d", display->d_obufmax);
        }
      }
    }
  }
#line 1065
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 1066
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 1068
  WriteFile(user, (char *)0, 0);
  }
#line 1069
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 1072
  mode = 1;
#line 1074
  __cil_tmp26 = strcmp((char const   *)*args, (char const   *)((char *)"-h"));
  }
#line 1074
  if (argc > 1) {
#line 1074
    if (! __cil_tmp26) {
#line 1076
      mode = 3;
#line 1077
      args ++;
#line 1078
      __cil_tmp28 = argc;
#line 1078
      argc --;
    }
  }
#line 1080
  if (*args) {
#line 1080
    if (*(args + 1)) {
      {
#line 1082
      Msg(0, (char *)"%s: hardcopy: too many arguments", rc_name);
      }
#line 1083
      goto switch_break;
    }
  }
#line 1085
  if (fore == (struct win *)0) {
#line 1085
    if (*args == (char *)0) {
      {
#line 1086
      Msg(0, (char *)"%s: hardcopy: window required", rc_name);
      }
    } else {
      {
      {
#line 1088
      WriteFile(user, *args, mode);
      }
      }
    }
  } else {
    {
    {
#line 1088
    WriteFile(user, *args, mode);
    }
    }
  }
#line 1090
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 1092
  __cil_tmp29 = ParseOnOff(act, & nwin_default.Lflag);
  }
#line 1093
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1095
  if (fore->w_log) {
#line 1095
    tmp___124 = 1;
  } else {
#line 1095
    tmp___124 = 0;
  }
  {
#line 1095
  n = tmp___124;
#line 1096
  ParseSwitch(act, & n);
#line 1097
  LogToggle(n);
  }
#line 1098
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 1101
  Detach(1);
  }
#line 1102
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 1105
  __cil_tmp31 = MoreWindows();
  }
#line 1105
  if (__cil_tmp31) {
    {
#line 1106
    __cil_tmp32 = NextWindow();
#line 1106
    SwitchWindow(__cil_tmp32);
    }
  }
#line 1107
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 1109
  __cil_tmp33 = MoreWindows();
  }
#line 1109
  if (__cil_tmp33) {
    {
#line 1110
    __cil_tmp34 = PreviousWindow();
#line 1110
    SwitchWindow(__cil_tmp34);
    }
  }
#line 1111
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1116
  if (key >= 0) {
#line 1119
    if (fore->w_pwin) {
#line 1119
      tmp___125 = (char *)"Really kill this filter [y/n]";
    } else {
#line 1119
      tmp___125 = (char *)"Really kill this window [y/n]";
    }
    {
#line 1119
    Input(tmp___125, 1, 2, confirm_fn, (char *)83);
    }
#line 1123
    goto switch_break;
  }
#line 1125
  n = fore->w_number;
#line 1127
  if (fore->w_pwin) {
    {
#line 1129
    FreePseudowin(fore);
#line 1130
    Msg(0, (char *)"Filter removed.");
    }
#line 1131
    goto switch_break;
  }
  {
#line 1134
  name = SaveStr((char const   *)fore->w_title);
#line 1135
  KillWindow(fore);
#line 1136
  Msg(0, (char *)"Window %d (%s) killed.", n, name);
  }
#line 1137
  if (name) {
    {
#line 1138
    free((void *)name);
    }
  }
#line 1139
  goto switch_break;
  case_118: /* CIL Label */ 
#line 1142
  if (key >= 0) {
    {
#line 1144
    Input((char *)"Really quit and kill all your windows [y/n]", 1, 2, confirm_fn,
          (char *)118);
    }
#line 1145
    goto switch_break;
  }
  {
#line 1147
  Finit(0);
  }
  case_58: /* CIL Label */ 
  {
#line 1151
  __cil_tmp38 = strcmp((char const   *)*args, (char const   *)((char *)"-h"));
  }
#line 1151
  if (*args) {
#line 1151
    if (! __cil_tmp38) {
      {
#line 1152
      Hangup();
      }
    } else {
      {
      {
#line 1154
      Detach(0);
      }
      }
    }
  } else {
    {
    {
#line 1154
    Detach(0);
    }
    }
  }
#line 1155
  goto switch_break;
  case_113: /* CIL Label */ 
#line 1158
  if (key >= 0) {
    {
#line 1162
    buf[0] = (char )key;
#line 1163
    Input((char *)buf, 1, 2, pow_detach_fn, (char *)((void *)0));
    }
  } else {
    {
#line 1166
    Detach(3);
    }
  }
#line 1167
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 1194
  __cil_tmp40 = strcmp((char const   *)((char *)"off"), (char const   *)*args);
  }
#line 1194
  if (*args == (char *)0) {
    {
    {
#line 1195
    Msg(0, (char *)"Sorry, screen was compiled without -DDEBUG option.");
    }
    }
  } else
#line 1194
  if (__cil_tmp40) {
    {
    {
#line 1195
    Msg(0, (char *)"Sorry, screen was compiled without -DDEBUG option.");
    }
    }
  }
#line 1197
  goto switch_break;
  case_169: /* CIL Label */ 
#line 1200
  ch2 = (char )0;
#line 1202
  s = *args;
#line 1202
  if (! s) {
#line 1204
    ZombieKey_destroy = 0;
#line 1205
    goto switch_break;
  }
  {
#line 1207
  s = ParseChar(s, & ch);
  }
#line 1207
  if (! s) {
    _L___126: /* CIL Label */ 
    {
#line 1209
    s = ParseChar(s, & ch2);
    }
#line 1209
    if (! s) {
      {
      {
      {
#line 1211
      Msg(0, (char *)"%s:zombie: one or two characters expected.", rc_name);
      }
      }
      }
#line 1212
      goto switch_break;
    } else
#line 1209
    if (! s) {
      {
      {
      {
#line 1211
      Msg(0, (char *)"%s:zombie: one or two characters expected.", rc_name);
      }
      }
      }
#line 1212
      goto switch_break;
    } else
#line 1209
    if ((int )*s) {
      {
      {
      {
#line 1211
      Msg(0, (char *)"%s:zombie: one or two characters expected.", rc_name);
      }
      }
      }
#line 1212
      goto switch_break;
    }
  } else
#line 1207
  if ((int )*s) {
#line 1207
    goto _L___126;
  }
#line 1215
  ZombieKey_destroy = (int )ch;
#line 1216
  ZombieKey_resurrect = (int )ch2;
#line 1218
  goto switch_break;
  case_160: /* CIL Label */ 
#line 1221
  s = (char *)(display->d_user)->u_name;
  {
#line 1226
  olddisplay = display;
#line 1227
  display = (struct display *)0;
#line 1228
  Msg(0, (char *)"%s: %s", s, *args);
#line 1229
  display = olddisplay;
  }
#line 1231
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1235
  s = SaveStr((char const   *)((char *)(display->d_user)->u_name));
  }
  {
#line 1237
  EffectiveAclUser = display->d_user;
#line 1241
  __cil_tmp46 = strlen((char const   *)*(args + 0));
#line 1241
  n = (int )__cil_tmp46;
  }
#line 1242
  if (n) {
#line 1242
    __cil_tmp47 = n;
#line 1242
    n --;
  }
  {
#line 1250
  if ((int )*(*(args + 0) + n) == '*') {
#line 1250
    goto case_42;
  }
#line 1285
  if ((int )*(*(args + 0) + n) == '%') {
#line 1285
    goto case_37;
  }
#line 1314
  if ((int )*(*(args + 0) + n) == '#') {
#line 1314
    goto case_35___0;
  }
#line 1317
  goto switch_default;
  case_42: /* CIL Label */ 
#line 1255
  if (! n) {
#line 1256
    u = display->d_user;
  } else {
#line 1258
    u = users;
    {
#line 1258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1258
      if (! u) {
#line 1258
        goto while_break___0;
      }
      {
#line 1260
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1260
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1261
      __cil_tmp50 = strncmp((char const   *)*args, (char const   *)((char *)u->u_name),
                            (unsigned long )n);
      }
#line 1261
      if (! __cil_tmp50) {
#line 1262
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1258
    u = u->u_next;
  }
  {
#line 1264
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1264
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1265
  display = displays;
  {
#line 1265
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1265
    if (! display) {
#line 1265
      goto while_break___3;
    }
#line 1267
    nd = display->d_next;
#line 1268
    if (display->d_forecv == (struct canvas *)0) {
#line 1269
      goto while_continue___3;
    }
#line 1270
    flayer = (display->d_forecv)->c_layer;
#line 1271
    fore = display->d_fore;
#line 1272
    if (display->d_user != u) {
#line 1273
      goto while_continue___3;
    }
    {
#line 1274
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1274
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1275
    DoCommand(args + 1);
    }
#line 1276
    if (display) {
#line 1277
      if (*(args + 2)) {
#line 1277
        tmp___127 = *(args + 2);
      } else {
#line 1277
        tmp___127 = (char *)"";
      }
      {
#line 1277
      Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___127);
      }
    }
#line 1279
    display = (struct display *)((void *)0);
#line 1280
    flayer = (struct layer *)0;
#line 1281
    fore = (struct win *)((void *)0);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1265
  display = nd;
#line 1283
  goto switch_break___0;
  case_37: /* CIL Label */ 
  {
#line 1289
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1289
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1290
  display = displays;
  {
#line 1290
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1290
    if (! display) {
#line 1290
      goto while_break___6;
    }
#line 1292
    nd___0 = display->d_next;
#line 1293
    if (display->d_forecv == (struct canvas *)0) {
#line 1294
      goto while_continue___6;
    }
    {
#line 1295
    fore = display->d_fore;
#line 1296
    flayer = (display->d_forecv)->c_layer;
#line 1297
    __cil_tmp57 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty + 8),
                          (unsigned long )n);
    }
    {
#line 1297
    __cil_tmp56 = strncmp((char const   *)((char *)"/dev/tty"), (char const   *)((char *)display->d_usertty),
                          (unsigned long )8);
    }
    {
#line 1297
    __cil_tmp55 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty + 5),
                          (unsigned long )n);
    }
    {
#line 1297
    __cil_tmp54 = strncmp((char const   *)((char *)"/dev/"), (char const   *)((char *)display->d_usertty),
                          (unsigned long )5);
    }
    {
#line 1297
    __cil_tmp53 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty),
                          (unsigned long )n);
    }
#line 1297
    if (__cil_tmp53) {
#line 1297
      if (__cil_tmp54) {
        _L___128: /* CIL Label */ 
#line 1297
        if (__cil_tmp56) {
#line 1302
          goto while_continue___6;
        } else
#line 1297
        if (__cil_tmp57) {
#line 1302
          goto while_continue___6;
        }
      } else
#line 1297
      if (__cil_tmp55) {
#line 1297
        goto _L___128;
      }
    }
    {
#line 1303
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1303
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1304
    DoCommand(args + 1);
    }
#line 1305
    if (display) {
#line 1306
      if (*(args + 2)) {
#line 1306
        tmp___129 = *(args + 2);
      } else {
#line 1306
        tmp___129 = (char *)"";
      }
      {
#line 1306
      Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___129);
      }
    }
#line 1308
    display = (struct display *)((void *)0);
#line 1309
    fore = (struct win *)((void *)0);
#line 1310
    flayer = (struct layer *)0;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1290
  display = nd___0;
#line 1312
  goto switch_break___0;
  case_35___0: /* CIL Label */ 
#line 1315
  __cil_tmp59 = n;
#line 1315
  n --;
  switch_default: /* CIL Label */ 
  {
#line 1322
  n ++;
#line 1323
  ch___130 = (int )*(*(args + 0) + n);
#line 1324
  *(*(args + 0) + n) = (char )'\000';
#line 1325
  i = WindowByNumber(*(args + 0));
  }
#line 1325
  if (! *(*(args + 0))) {
    _L___134: /* CIL Label */ 
#line 1327
    *(*(args + 0) + n) = (char )ch___130;
#line 1329
    fore = windows;
    {
#line 1329
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1329
      if (! fore) {
#line 1329
        goto while_break___8;
      }
      {
#line 1331
      nw = fore->w_next;
#line 1332
      __cil_tmp64 = strncmp((char const   *)*(args + 0), (char const   *)fore->w_title,
                            (unsigned long )n);
      }
#line 1332
      if (__cil_tmp64) {
#line 1333
        goto while_continue___8;
      }
      {
#line 1334
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1334
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1342
      i = 0;
#line 1344
      if (fore->w_layer.l_cvlist) {
#line 1345
        display = (fore->w_layer.l_cvlist)->c_display;
      }
#line 1346
      if (fore->w_savelayer) {
#line 1346
        tmp___131 = fore->w_savelayer;
      } else {
#line 1346
        tmp___131 = & fore->w_layer;
      }
      {
#line 1346
      flayer = tmp___131;
#line 1347
      DoCommand(args + 1);
      }
#line 1348
      if (fore) {
#line 1348
        if (fore->w_layer.l_cvlist) {
#line 1350
          display = (fore->w_layer.l_cvlist)->c_display;
#line 1351
          if (*(args + 2)) {
#line 1351
            tmp___132 = *(args + 2);
          } else {
#line 1351
            tmp___132 = (char *)"";
          }
          {
#line 1351
          Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___132);
          }
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1329
    fore = nw;
#line 1355
    display = (struct display *)((void *)0);
#line 1356
    fore = (struct win *)((void *)0);
#line 1357
    if (i < 0) {
      {
#line 1358
      Msg(0, (char *)"%s: at \'%s\': no such window.\n", rc_name, *(args + 0));
      }
    }
#line 1359
    goto switch_break___0;
  } else
#line 1325
  if (i < 0) {
#line 1325
    goto _L___134;
  } else {
#line 1361
    fore = wtab[i];
#line 1361
    if (i < 40) {
#line 1361
      if (fore) {
#line 1363
        *(*(args + 0) + n) = (char )ch___130;
        {
#line 1364
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1364
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1365
        if (fore->w_layer.l_cvlist) {
#line 1366
          display = (fore->w_layer.l_cvlist)->c_display;
        }
        {
#line 1367
        DoCommand(args + 1);
        }
#line 1368
        if (fore) {
#line 1368
          if (fore->w_layer.l_cvlist) {
#line 1370
            display = (fore->w_layer.l_cvlist)->c_display;
#line 1371
            if (*(args + 2)) {
#line 1371
              tmp___133 = *(args + 2);
            } else {
#line 1371
              tmp___133 = (char *)"";
            }
            {
#line 1371
            Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___133);
            }
          }
        }
#line 1374
        display = (struct display *)((void *)0);
#line 1375
        fore = (struct win *)((void *)0);
      } else {
        {
        {
#line 1378
        Msg(0, (char *)"%s: at [identifier][%%|*|#] command [args]", rc_name);
        }
        }
      }
    } else {
      {
      {
#line 1378
      Msg(0, (char *)"%s: at [identifier][%%|*|#] command [args]", rc_name);
      }
      }
    }
  }
#line 1379
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1382
  free((void *)s);
#line 1384
  EffectiveAclUser = (struct acluser *)((void *)0);
  }
#line 1386
  goto switch_break;
  case_120: /* CIL Label */ 
#line 1391
  if (fore) {
#line 1391
    tmp___136 = fore->w_layer.l_encoding;
  } else {
#line 1391
    if (display) {
#line 1391
      tmp___135 = display->d_encoding;
    } else {
#line 1391
      tmp___135 = 0;
    }
#line 1391
    tmp___136 = tmp___135;
  }
  {
#line 1391
  i = tmp___136;
#line 1392
  __cil_tmp70 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 1392
  if (*(args + 0)) {
#line 1392
    if (*(args + 1)) {
#line 1392
      if (! __cil_tmp70) {
        {
#line 1394
        i = FindEncoding(*(args + 1));
        }
#line 1395
        if (i == -1) {
          {
#line 1397
          Msg(0, (char *)"%s: readreg: unknown encoding", rc_name);
          }
#line 1398
          goto switch_break;
        }
#line 1400
        args += 2;
      }
    }
  }
#line 1409
  s = *args;
#line 1409
  if (s == (char *)((void *)0)) {
    {
#line 1411
    Input((char *)"Copy to register:", 1, 2, copy_reg_fn, (char *)((void *)0));
    }
#line 1412
    goto switch_break;
  }
  {
#line 1414
  s = ParseChar(s, & ch);
  }
#line 1414
  if (s == (char *)((void *)0)) {
    {
    {
#line 1416
    Msg(0, (char *)"%s: copyreg: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 1417
    goto switch_break;
  } else
#line 1414
  if ((int )*s) {
    {
    {
#line 1416
    Msg(0, (char *)"%s: copyreg: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 1417
    goto switch_break;
  }
#line 1422
  if (*(args + 1)) {
#line 1424
    if (*(args + 2)) {
      {
#line 1426
      Msg(0, (char *)"%s: readreg: too many arguments", rc_name);
      }
#line 1427
      goto switch_break;
    }
    {
#line 1429
    s = ReadFile(*(args + 1), & n);
    }
#line 1429
    if (s) {
#line 1431
      pp = (struct plop *)plop_tab + (int )((unsigned char )ch);
#line 1433
      if (pp->buf) {
        {
#line 1434
        free((void *)pp->buf);
        }
      }
#line 1435
      pp->buf = s;
#line 1436
      pp->len = n;
#line 1438
      pp->enc = i;
    }
  } else {
    {
#line 1448
    copy_reg_fn(& ch, 0, (char *)((void *)0));
    }
  }
#line 1449
  goto switch_break;
  case_122: /* CIL Label */ 
#line 1453
  if (fore) {
#line 1453
    tmp___138 = fore->w_layer.l_encoding;
  } else {
#line 1453
    if (display) {
#line 1453
      tmp___137 = display->d_encoding;
    } else {
#line 1453
      tmp___137 = 0;
    }
#line 1453
    tmp___138 = tmp___137;
  }
  {
#line 1453
  i = tmp___138;
#line 1454
  __cil_tmp77 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 1454
  if (*(args + 0)) {
#line 1454
    if (*(args + 1)) {
#line 1454
      if (! __cil_tmp77) {
        {
#line 1456
        i = FindEncoding(*(args + 1));
        }
#line 1457
        if (i == -1) {
          {
#line 1459
          Msg(0, (char *)"%s: register: unknown encoding", rc_name);
          }
#line 1460
          goto switch_break;
        }
#line 1462
        args += 2;
#line 1463
        argc -= 2;
      }
    }
  }
#line 1466
  if (argc != 2) {
    {
#line 1468
    Msg(0, (char *)"%s: register: illegal number of arguments.", rc_name);
    }
#line 1469
    goto switch_break;
  }
  {
#line 1471
  s = ParseChar(*args, & ch);
  }
#line 1471
  if (s == (char *)0) {
    {
    {
#line 1472
    Msg(0, (char *)"%s: register: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
  } else
#line 1471
  if ((int )*s) {
    {
    {
#line 1472
    Msg(0, (char *)"%s: register: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
  } else
#line 1474
  if ((int )ch == 46) {
#line 1476
    if (user->u_plop.buf != (char *)((void *)0)) {
      {
#line 1477
      UserFreeCopyBuffer(user);
      }
    }
#line 1478
    if (*(args + 1)) {
#line 1478
      if ((int )*(*(args + 1) + 0)) {
        {
#line 1480
        user->u_plop.buf = SaveStr((char const   *)*(args + 1));
#line 1481
        __cil_tmp81 = strlen((char const   *)user->u_plop.buf);
#line 1481
        user->u_plop.len = (int )__cil_tmp81;
#line 1483
        user->u_plop.enc = i;
        }
      }
    }
  } else {
#line 1490
    plp = (struct plop *)plop_tab + (int )((unsigned char )ch);
#line 1492
    if (plp->buf) {
      {
#line 1493
      free((void *)plp->buf);
      }
    }
    {
#line 1494
    plp->buf = SaveStr((char const   *)*(args + 1));
#line 1495
    __cil_tmp84 = strlen((char const   *)plp->buf);
#line 1495
    plp->len = (int )__cil_tmp84;
#line 1497
    plp->enc = i;
    }
  }
#line 1500
  goto switch_break;
  case_117: /* CIL Label */ 
#line 1502
  s = *args;
#line 1502
  if (s == (char *)((void *)0)) {
    {
#line 1504
    Input((char *)"Process register:", 1, 2, process_fn, (char *)((void *)0));
    }
#line 1505
    goto switch_break;
  }
  {
#line 1507
  s = ParseChar(s, & ch);
  }
#line 1507
  if (s == (char *)((void *)0)) {
    {
    {
#line 1509
    Msg(0, (char *)"%s: process: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 1510
    goto switch_break;
  } else
#line 1507
  if ((int )*s) {
    {
    {
#line 1509
    Msg(0, (char *)"%s: process: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 1510
    goto switch_break;
  }
  {
#line 1512
  process_fn(& ch, 0, (char *)((void *)0));
  }
#line 1513
  goto switch_break;
  case_143: /* CIL Label */ 
#line 1515
  s = *args;
#line 1516
  if (*(args + 1)) {
    {
#line 1518
    __cil_tmp86 = strcmp((char const   *)s, (char const   *)((char *)"-k"));
    }
#line 1518
    if (__cil_tmp86) {
      {
#line 1520
      Msg(0, (char *)"%s: stuff: invalid option %s", rc_name, s);
      }
#line 1521
      goto switch_break;
    }
#line 1523
    s = *(args + 1);
#line 1524
    i = 106;
    {
#line 1524
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1524
      if (! (i < 175)) {
#line 1524
        goto while_break___11;
      }
      {
#line 1525
      __cil_tmp87 = strcmp((char const   *)term[i].tcname, (char const   *)s);
      }
#line 1525
      if (__cil_tmp87 == 0) {
#line 1526
        goto while_break___11;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1524
    i ++;
#line 1527
    if (i == 175) {
      {
#line 1529
      Msg(0, (char *)"%s: stuff: unknown key \'%s\'", rc_name, s);
      }
#line 1530
      goto switch_break;
    }
    {
#line 1533
    __cil_tmp89 = StuffKey(i - 106);
    }
#line 1533
    if (__cil_tmp89 == 0) {
#line 1534
      goto switch_break;
    }
#line 1536
    if (display) {
#line 1536
      tmp___139 = display->d_tcs[i].str;
    } else {
#line 1536
      tmp___139 = (char *)0;
    }
#line 1536
    s = tmp___139;
#line 1537
    if (s == (char *)0) {
#line 1538
      goto switch_break;
    }
  }
  {
#line 1540
  __cil_tmp91 = strlen((char const   *)s);
#line 1540
  n = (int )__cil_tmp91;
  }
  {
#line 1541
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1541
    if (! n) {
#line 1541
      goto while_break___12;
    }
    {
#line 1542
    ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1543
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 1545
  Activate(- 1);
  }
#line 1546
  goto switch_break;
  case_163: /* CIL Label */ 
  {
#line 1548
  ShowWindows(- 1);
  }
#line 1549
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1551
  Msg(0, (char *)"screen %s", (char *)version);
  }
#line 1552
  goto switch_break;
  case_150: /* CIL Label */ 
#line 1554
  if (*args) {
    {
#line 1556
    timestring = SaveStr((char const   *)*args);
    }
#line 1557
    goto switch_break;
  }
  {
#line 1559
  __cil_tmp93 = MakeWinMsg(timestring, fore, '%');
#line 1559
  Msg(0, (char *)"%s", __cil_tmp93);
  }
#line 1560
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 1562
  ShowInfo();
  }
#line 1563
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 1565
  ShowDInfo();
  }
#line 1566
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1569
  ktabp = (struct action *)ktab;
#line 1570
  __cil_tmp95 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
  }
#line 1570
  if (argc == 2) {
#line 1570
    if (! __cil_tmp95) {
      {
#line 1572
      ktabp = FindKtab(*(args + 1), 0);
      }
#line 1572
      if (ktabp == (struct action *)0) {
        {
#line 1574
        Msg(0, (char *)"Unknown command class \'%s\'", *(args + 1));
        }
#line 1575
        goto switch_break;
      }
    }
  }
#line 1578
  if (display->d_ESCseen != (struct action *)ktab) {
#line 1580
    display->d_ESCseen = ktabp;
#line 1581
    goto switch_break;
  } else
#line 1578
  if (ktabp != (struct action *)ktab) {
#line 1580
    display->d_ESCseen = ktabp;
#line 1581
    goto switch_break;
  }
#line 1583
  display->d_ESCseen = (struct action *)0;
  case_107: /* CIL Label */ 
  {
#line 1587
  __cil_tmp97 = MoreWindows();
  }
#line 1587
  if (__cil_tmp97) {
#line 1588
    if (display && display->d_other) {
#line 1588
      tmp___140 = (display->d_other)->w_number;
    } else {
      {
#line 1588
      __cil_tmp98 = NextWindow();
#line 1588
      tmp___140 = __cil_tmp98;
      }
    }
    {
#line 1588
    SwitchWindow(tmp___140);
    }
  }
#line 1589
  goto switch_break;
  case_96: /* CIL Label */ 
#line 1591
  if (user->u_Esc == -1) {
#line 1592
    goto switch_break;
  }
  {
#line 1593
  ch = (char )user->u_Esc;
#line 1594
  s = & ch;
#line 1595
  n = 1;
#line 1596
  ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1597
  goto switch_break;
  case_168: /* CIL Label */ 
#line 1599
  ch = (char )17;
  {
#line 1600
  s = & ch;
#line 1601
  n = 1;
#line 1602
  ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1603
  goto switch_break;
  case_167: /* CIL Label */ 
#line 1605
  ch = (char )19;
  {
#line 1606
  s = & ch;
#line 1607
  n = 1;
#line 1608
  ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1609
  goto switch_break;
  case_20: /* CIL Label */ 
  case_37___0: /* CIL Label */ 
#line 1616
  if (*args) {
    {
#line 1618
    __cil_tmp102 = ParseNum(act, & n);
    }
#line 1618
    if (__cil_tmp102) {
#line 1619
      n = 0;
      {
#line 1619
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1619
        if (! ((unsigned long )n < sizeof(types) / sizeof(*((char **)types)))) {
#line 1619
          goto while_break___13;
        }
#line 1621
        i = 0;
        {
#line 1621
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1621
          if (! (i < 4)) {
#line 1621
            goto while_break___14;
          }
#line 1623
          ch = *(*(args + 0) + i);
#line 1624
          if ((int )ch >= 97) {
#line 1624
            if ((int )ch <= 122) {
#line 1625
              ch -= 32;
            }
          }
#line 1626
          if ((int )ch != (int )*(types[n] + i)) {
#line 1626
            if ((int )ch + 32 != (int )*(types[n] + i)) {
#line 1627
              goto while_break___14;
            }
          }
        }
        while_break___14: /* CIL Label */ ;
        }
#line 1621
        i ++;
#line 1629
        if (i == 4) {
#line 1630
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1619
      n ++;
    }
#line 1632
    if (n < 0) {
      {
      {
#line 1633
      Msg(0, (char *)"%s invalid, chose one of %s, %s or %s", *args, types[0], types[1],
          types[2]);
      }
      }
    } else
#line 1632
    if ((unsigned long )n >= sizeof(types) / sizeof(*((char **)types))) {
      {
      {
#line 1633
      Msg(0, (char *)"%s invalid, chose one of %s, %s or %s", *args, types[0], types[1],
          types[2]);
      }
      }
    } else {
      {
#line 1636
      breaktype___0 = n;
#line 1637
      Msg(0, (char *)"breaktype set to (%d) %s", n, types[n]);
      }
    }
  } else {
    {
#line 1641
    Msg(0, (char *)"breaktype is (%d) %s", breaktype___0, types[breaktype___0]);
    }
  }
#line 1643
  goto switch_break;
  case_19: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 1646
  n = 0;
  {
#line 1647
  __cil_tmp105 = ParseNum(act, & n);
  }
#line 1647
  if (*args) {
#line 1647
    if (__cil_tmp105) {
#line 1648
      goto switch_break;
    }
  }
  {
#line 1649
  SendBreak(fore, n, nr == 112);
  }
#line 1650
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 1653
  Detach(5);
  }
#line 1654
  goto switch_break;
  case_76: /* CIL Label */ 
  case_161: /* CIL Label */ 
  {
#line 1660
  what = 0;
#line 1662
  i = 1;
#line 1663
  __cil_tmp109 = strcmp((char const   *)*args, (char const   *)((char *)"-w"));
  }
#line 1663
  if (*args) {
#line 1663
    if (! __cil_tmp109) {
#line 1664
      what = 1;
    } else {
#line 1663
      goto _L___141;
    }
  } else {
    _L___141: /* CIL Label */ 
    {
#line 1665
    __cil_tmp110 = strcmp((char const   *)*args, (char const   *)((char *)"-d"));
    }
#line 1665
    if (*args) {
#line 1665
      if (! __cil_tmp110) {
#line 1666
        what = 2;
      }
    }
  }
#line 1667
  if (what) {
#line 1668
    args ++;
  }
#line 1669
  if (what == 0) {
#line 1669
    if (flayer) {
#line 1669
      if (! display) {
#line 1670
        what = 1;
      }
    }
  }
#line 1671
  if (what == 1) {
#line 1673
    if (! flayer) {
      {
#line 1675
      Msg(0, (char *)"%s: %s: window required", rc_name, comms[nr].name);
      }
#line 1676
      goto switch_break;
    }
#line 1678
    w = flayer->l_width;
#line 1679
    h = flayer->l_height;
  } else {
#line 1683
    if (! display) {
      {
#line 1685
      Msg(0, (char *)"%s: %s: display required", rc_name, comms[nr].name);
      }
#line 1686
      goto switch_break;
    }
#line 1688
    w = display->d_width;
#line 1689
    h = display->d_height;
  }
#line 1691
  if (*args) {
#line 1691
    if ((int )*(*(args + 0) + 0) == 45) {
      {
#line 1693
      Msg(0, (char *)"%s: %s: unknown option %s", rc_name, comms[nr].name, *args);
      }
#line 1694
      goto switch_break;
    }
  }
#line 1696
  if (nr == 76) {
#line 1698
    if (! *args) {
#line 1702
      if (h == 42) {
#line 1703
        h = 24;
      } else
#line 1704
      if (h == 24) {
#line 1705
        h = 42;
      } else
#line 1706
      if (h > 33) {
#line 1707
        h = 42;
      } else {
#line 1709
        h = 24;
      }
    } else {
      {
#line 1713
      h = atoi((char const   *)*args);
      }
#line 1714
      if (*(args + 1)) {
        {
#line 1715
        w = atoi((char const   *)*(args + 1));
        }
      }
    }
  } else
#line 1720
  if (! *args) {
#line 1722
    if (w == Z0width) {
#line 1723
      w = Z1width;
    } else
#line 1724
    if (w == Z1width) {
#line 1725
      w = Z0width;
    } else
#line 1726
    if (w > (Z0width + Z1width) / 2) {
#line 1727
      w = Z0width;
    } else {
#line 1729
      w = Z1width;
    }
  } else {
    {
#line 1733
    w = atoi((char const   *)*args);
    }
#line 1734
    if (*(args + 1)) {
      {
#line 1735
      h = atoi((char const   *)*(args + 1));
      }
    }
  }
#line 1738
  if (*args) {
#line 1738
    if (*(args + 1)) {
#line 1738
      if (*(args + 2)) {
        {
#line 1740
        Msg(0, (char *)"%s: %s: too many arguments", rc_name, comms[nr].name);
        }
#line 1741
        goto switch_break;
      }
    }
  }
#line 1743
  if (w <= 0) {
    {
#line 1745
    Msg(0, (char *)"Illegal width");
    }
#line 1746
    goto switch_break;
  }
#line 1748
  if (h <= 0) {
    {
#line 1750
    Msg(0, (char *)"Illegal height");
    }
#line 1751
    goto switch_break;
  }
#line 1753
  if (what == 1) {
#line 1755
    if (flayer->l_width == w) {
#line 1755
      if (flayer->l_height == h) {
#line 1756
        goto switch_break;
      }
    }
    {
#line 1757
    ResizeLayer(flayer, w, h, (struct display *)0);
    }
#line 1758
    goto switch_break;
  }
#line 1760
  if (display->d_width == w) {
#line 1760
    if (display->d_height == h) {
#line 1761
      goto switch_break;
    }
  }
#line 1762
  if (what == 2) {
    {
#line 1764
    ChangeScreenSize(w, h, 1);
    }
  } else {
    {
#line 1768
    __cil_tmp116 = ResizeDisplay(w, h);
    }
#line 1768
    if (__cil_tmp116 == 0) {
#line 1770
      if (display->d_fore) {
#line 1770
        tmp___142 = (int )(display->d_fore)->w_norefresh;
      } else {
#line 1770
        tmp___142 = 0;
      }
      {
#line 1770
      Activate(tmp___142);
#line 1772
      ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                  ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
      }
#line 1773
      goto switch_break;
    }
#line 1775
    if (h == display->d_height) {
      {
#line 1776
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s width to %d.",
          w);
      }
    } else
#line 1777
    if (w == display->d_width) {
      {
#line 1778
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s height to %d.",
          h);
      }
    } else {
      {
#line 1780
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s resolution to %dx%d.",
          w, h);
      }
    }
  }
#line 1783
  goto switch_break;
  case_151: /* CIL Label */ 
#line 1785
  if (*args == (char *)0) {
    {
#line 1786
    InputAKA();
    }
  } else {
    {
#line 1788
    ChangeAKA(fore, *args, 20);
    }
  }
#line 1789
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1791
  Input((char *)":", 100, 0, Colonfin, (char *)((void *)0));
  }
#line 1792
  if (*args) {
#line 1792
    if ((int )*(*args)) {
      {
#line 1794
      s = *args;
#line 1795
      __cil_tmp118 = strlen((char const   *)s);
#line 1795
      n = (int )__cil_tmp118;
#line 1796
      ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 1798
  goto switch_break;
  case_84: /* CIL Label */ 
#line 1800
  if (display->d_status_lastmsg) {
    {
#line 1801
    Msg(0, (char *)"%s", display->d_status_lastmsg);
    }
  }
#line 1802
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 1804
  DoScreen((char *)"key", args);
  }
#line 1805
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1807
  __cil_tmp119 = ParseSwitch(act, & fore->w_wrap);
  }
#line 1807
  if (__cil_tmp119 == 0) {
#line 1807
    if (msgok) {
#line 1808
      if (fore->w_wrap) {
#line 1808
        tmp___143 = '+';
      } else {
#line 1808
        tmp___143 = '-';
      }
      {
#line 1808
      Msg(0, (char *)"%cwrap", tmp___143);
      }
    }
  }
#line 1809
  goto switch_break;
  case_69: /* CIL Label */ 
#line 1811
  if (*args) {
#line 1813
    if ((int )*(*(args + 0) + 0) == 97) {
#line 1815
      if (fore->w_flow & (1 << 1)) {
#line 1815
        tmp___144 = ((1 << 2) | (1 << 1)) | 1;
      } else {
#line 1815
        tmp___144 = 1 << 2;
      }
#line 1815
      fore->w_flow = tmp___144;
    } else {
      {
#line 1819
      __cil_tmp122 = ParseOnOff(act, & n);
      }
#line 1819
      if (__cil_tmp122) {
#line 1820
        goto switch_break;
      }
#line 1821
      fore->w_flow = (fore->w_flow & (1 << 1)) | n;
    }
  } else
#line 1826
  if (fore->w_flow & (1 << 2)) {
#line 1827
    fore->w_flow = (fore->w_flow & (1 << 1)) | 1;
  } else
#line 1828
  if (fore->w_flow & 1) {
#line 1829
    fore->w_flow &= ~ 1;
  } else {
#line 1831
    if (fore->w_flow) {
#line 1831
      tmp___145 = ((1 << 2) | (1 << 1)) | 1;
    } else {
#line 1831
      tmp___145 = 1 << 2;
    }
#line 1831
    fore->w_flow = tmp___145;
  }
  {
#line 1833
  SetFlow(fore->w_flow & 1);
  }
#line 1834
  if (msgok) {
#line 1835
    if (fore->w_flow & 1) {
#line 1835
      tmp___146 = '+';
    } else {
#line 1835
      tmp___146 = '-';
    }
#line 1835
    if (fore->w_flow & (1 << 2)) {
#line 1835
      tmp___147 = (char *)"(auto)";
    } else {
#line 1835
      tmp___147 = (char *)"";
    }
    {
#line 1835
    Msg(0, (char *)"%cflow%s", tmp___146, tmp___147);
    }
  }
#line 1837
  goto switch_break;
  case_57: /* CIL Label */ 
#line 1840
  if ((int )*(*(args + 0) + 0) == 97) {
#line 1841
    nwin_default.wlock = 1;
  } else {
    {
#line 1844
    __cil_tmp126 = ParseOnOff(act, & n);
    }
#line 1844
    if (__cil_tmp126) {
#line 1845
      goto switch_break;
    }
#line 1846
    if (n) {
#line 1846
      tmp___148 = 2;
    } else {
#line 1846
      tmp___148 = 0;
    }
#line 1846
    nwin_default.wlock = tmp___148;
  }
#line 1848
  goto switch_break;
  case_166: /* CIL Label */ 
#line 1850
  if (*args) {
#line 1852
    if ((int )*(*(args + 0) + 0) == 97) {
#line 1854
      fore->w_wlock = 1;
    } else {
      {
#line 1858
      __cil_tmp128 = ParseOnOff(act, & n);
      }
#line 1858
      if (__cil_tmp128) {
#line 1859
        goto switch_break;
      }
#line 1860
      if (n) {
#line 1860
        tmp___149 = 2;
      } else {
#line 1860
        tmp___149 = 0;
      }
#line 1860
      fore->w_wlock = tmp___149;
    }
    {
#line 1866
    __cil_tmp130 = AclCheckPermWin(display->d_user, 1, fore);
    }
#line 1866
    if (! __cil_tmp130) {
#line 1867
      fore->w_wlockuser = display->d_user;
    }
  }
#line 1869
  if (fore->w_wlock == 1) {
#line 1869
    tmp___151 = (char *)"auto";
  } else {
#line 1869
    if (fore->w_wlock == 0) {
#line 1869
      tmp___150 = (char *)"off";
    } else {
#line 1869
      tmp___150 = (char *)"on";
    }
#line 1869
    tmp___151 = tmp___150;
  }
  {
#line 1869
  Msg(0, (char *)"writelock %s", tmp___151);
  }
#line 1871
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 1874
  ResetAnsiState(fore);
  }
  {
#line 1875
  WriteString(fore, (char *)"\033[H\033[J", 6);
  }
#line 1876
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 1878
  ResetAnsiState(fore);
  }
  {
#line 1879
  WriteString(fore, (char *)"\033c", 2);
  }
#line 1880
  goto switch_break;
  case_97: /* CIL Label */ 
#line 1882
  n = fore->w_monitor != 0;
  {
#line 1883
  __cil_tmp133 = ParseSwitch(act, & n);
  }
#line 1883
  if (__cil_tmp133) {
#line 1884
    goto switch_break;
  }
#line 1885
  if (n) {
#line 1888
    if (display) {
#line 1889
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) |= 128 >> ((display->d_user)->u_id & 7);
    } else {
#line 1891
      i = 0;
      {
#line 1891
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1891
        if (! (i < maxusercount)) {
#line 1891
          goto while_break___15;
        }
#line 1892
        *(fore->w_mon_notify + (i >> 3)) |= 128 >> (i & 7);
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1891
      i ++;
    }
#line 1894
    if (fore->w_monitor == 0) {
#line 1895
      fore->w_monitor = 1;
    }
    {
#line 1896
    Msg(0, (char *)"Window %d (%s) is now being monitored for all activity.", fore->w_number,
        fore->w_title);
    }
  } else {
#line 1901
    if (display) {
#line 1902
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) &= ~ (128 >> ((display->d_user)->u_id & 7));
    } else {
#line 1905
      i = 0;
      {
#line 1905
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1905
        if (! (i < maxusercount)) {
#line 1905
          goto while_break___16;
        }
#line 1906
        *(fore->w_mon_notify + (i >> 3)) &= ~ (128 >> (i & 7));
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1905
      i ++;
    }
#line 1907
    i = maxusercount - 1;
    {
#line 1907
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1907
      if (! (i >= 0)) {
#line 1907
        goto while_break___17;
      }
#line 1908
      if (*(fore->w_mon_notify + (i >> 3))) {
#line 1909
        goto while_break___17;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1907
    __cil_tmp136 = i;
#line 1907
    i --;
#line 1910
    if (i < 0) {
#line 1912
      fore->w_monitor = 0;
    }
    {
#line 1913
    Msg(0, (char *)"Window %d (%s) is no longer being monitored for activity.", fore->w_number,
        fore->w_title);
    }
  }
#line 1915
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 1918
  display_displays();
  }
#line 1919
  goto switch_break;
  case_162: /* CIL Label */ 
#line 1922
  if (! *args) {
    {
#line 1923
    display_wlist(0);
    }
  } else {
    {
#line 1924
    __cil_tmp137 = strcmp((char const   *)*args, (char const   *)((char *)"-b"));
    }
#line 1924
    if (! __cil_tmp137) {
#line 1924
      if (! *(args + 1)) {
        {
#line 1925
        display_wlist(1);
        }
      } else {
#line 1924
        goto _L___152;
      }
    } else {
      _L___152: /* CIL Label */ 
      {
#line 1926
      __cil_tmp138 = strcmp((char const   *)*args, (char const   *)((char *)"string"));
      }
#line 1926
      if (! __cil_tmp138) {
#line 1928
        if (*(args + 1)) {
#line 1930
          if (wliststr) {
            {
#line 1931
            free((void *)wliststr);
            }
          }
          {
#line 1932
          wliststr = SaveStr((char const   *)*(args + 1));
          }
        }
#line 1934
        if (msgok) {
          {
#line 1935
          Msg(0, (char *)"windowlist string is \'%s\'", wliststr);
          }
        }
      } else {
        {
#line 1937
        __cil_tmp140 = strcmp((char const   *)*args, (char const   *)((char *)"title"));
        }
#line 1937
        if (! __cil_tmp140) {
#line 1939
          if (*(args + 1)) {
#line 1941
            if (wlisttit) {
              {
#line 1942
              free((void *)wlisttit);
              }
            }
            {
#line 1943
            wlisttit = SaveStr((char const   *)*(args + 1));
            }
          }
#line 1945
          if (msgok) {
            {
#line 1946
            Msg(0, (char *)"windowlist title is \'%s\'", wlisttit);
            }
          }
        } else {
          {
#line 1949
          Msg(0, (char *)"usage: windowlist [-b] [string [string] | title [title]]");
          }
        }
      }
    }
  }
#line 1950
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1952
  __cil_tmp142 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
  }
#line 1952
  if (argc == 2) {
#line 1952
    if (! __cil_tmp142) {
      {
#line 1955
      ktabp___0 = FindKtab(*(args + 1), 0);
      }
#line 1955
      if (ktabp___0 == (struct action *)0) {
        {
#line 1957
        Msg(0, (char *)"Unknown command class \'%s\'", *(args + 1));
        }
#line 1958
        goto switch_break;
      }
      {
#line 1960
      display_help(*(args + 1), ktabp___0);
      }
    } else {
      {
      {
#line 1963
      display_help((char *)0, (struct action *)ktab);
      }
      }
    }
  } else {
    {
    {
#line 1963
    display_help((char *)0, (struct action *)ktab);
    }
    }
  }
#line 1964
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1966
  display_copyright();
  }
#line 1967
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1970
  if (flayer->l_layfn != & WinLf) {
    {
#line 1972
    Msg(0, (char *)"Must be on a window layer");
    }
#line 1973
    goto switch_break;
  }
  {
#line 1975
  MarkRoutine();
  }
#line 1976
  goto switch_break;
  case_78: /* CIL Label */ 
#line 1981
  if (flayer->l_layfn != & WinLf) {
    {
#line 1983
    Msg(0, (char *)"Must be on a window layer");
    }
#line 1984
    goto switch_break;
  }
  {
#line 1986
  __cil_tmp146 = GetHistory();
  }
#line 1986
  if (__cil_tmp146 == 0) {
#line 1987
    goto switch_break;
  }
#line 1988
  if (user->u_plop.buf == (char *)((void *)0)) {
#line 1989
    goto switch_break;
  }
#line 1990
  args = (char **)pasteargs;
  case_110: /* CIL Label */ 
#line 1996
  l = 0;
#line 1998
  enc = - 1;
#line 2004
  s = *args;
#line 2004
  if (s == (char *)((void *)0)) {
    {
#line 2006
    Input((char *)"Paste from register:", 1, 2, ins_reg_fn, (char *)((void *)0));
    }
#line 2007
    goto switch_break;
  }
#line 2009
  if (*(args + 1) == (char *)0) {
#line 2009
    if (! fore) {
#line 2010
      goto switch_break;
    }
  }
  {
#line 2015
  s = ParseChar(*(args + 1), & dch);
  }
#line 2015
  if (*(args + 1)) {
#line 2015
    if (s == (char *)((void *)0)) {
      {
      {
#line 2017
      Msg(0, (char *)"%s: paste destination: character, ^x, or (octal) \\032 expected.",
          rc_name);
      }
      }
#line 2019
      goto switch_break;
    } else
#line 2015
    if ((int )*s) {
      {
      {
#line 2017
      Msg(0, (char *)"%s: paste destination: character, ^x, or (octal) \\032 expected.",
          rc_name);
      }
      }
#line 2019
      goto switch_break;
    } else {
#line 2015
      goto _L___153;
    }
  } else
  _L___153: /* CIL Label */ 
#line 2022
  if (fore) {
#line 2023
    enc = fore->w_layer.l_encoding;
  }
#line 2029
  s = *args;
#line 2029
  ss = s;
  {
#line 2029
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 2029
    if (! ch) {
#line 2029
      goto while_break___18;
    }
#line 2031
    if ((int )ch == 46) {
#line 2034
      if (enc == -1) {
#line 2035
        enc = user->u_plop.enc;
      }
#line 2036
      if (enc != user->u_plop.enc) {
        {
#line 2037
        __cil_tmp153 = RecodeBuf((unsigned char *)user->u_plop.buf, user->u_plop.len,
                                 user->u_plop.enc, enc, (unsigned char *)0);
        }
#line 2037
        l += __cil_tmp153;
      } else {
#line 2040
        l += user->u_plop.len;
      }
    } else {
#line 2045
      if (enc == -1) {
#line 2046
        enc = plop_tab[(int )((unsigned char )ch)].enc;
      }
#line 2047
      if (enc != plop_tab[(int )((unsigned char )ch)].enc) {
        {
#line 2048
        __cil_tmp154 = RecodeBuf((unsigned char *)plop_tab[(int )((unsigned char )ch)].buf,
                                 plop_tab[(int )((unsigned char )ch)].len, plop_tab[(int )((unsigned char )ch)].enc,
                                 enc, (unsigned char *)0);
        }
#line 2048
        l += __cil_tmp154;
      } else {
#line 2051
        l += plop_tab[(int )((unsigned char )ch)].len;
      }
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 2029
  ss ++;
#line 2054
  if (l == 0) {
    {
#line 2056
    Msg(0, (char *)"empty buffer");
    }
#line 2057
    goto switch_break;
  }
#line 2064
  if ((int )*(s + 1) == 0) {
#line 2064
    if (*(args + 1) == (char *)0) {
#line 2066
      if ((int )*s == 46) {
#line 2066
        tmp___154 = user->u_plop.enc;
      } else {
#line 2066
        tmp___154 = plop_tab[(int )((unsigned char )*s)].enc;
      }
#line 2066
      if (enc == tmp___154) {
#line 2069
        if ((int )*s == 46) {
#line 2069
          tmp___155 = user->u_plop.buf;
        } else {
#line 2069
          tmp___155 = plop_tab[(int )((unsigned char )*s)].buf;
        }
        {
#line 2069
        MakePaster(& fore->w_paster, tmp___155, l, 0);
        }
#line 2070
        goto switch_break;
      }
    }
  }
  {
#line 2075
  __cil_tmp158 = malloc((unsigned long )l);
#line 2075
  dbuf = (char *)__cil_tmp158;
  }
#line 2075
  if (dbuf == (char *)0) {
    {
#line 2077
    Msg(0, (char *)strnomem);
    }
#line 2078
    goto switch_break;
  }
#line 2080
  l = 0;
#line 2085
  ss = s;
  {
#line 2085
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2085
    if (! ch) {
#line 2085
      goto while_break___19;
    }
#line 2087
    if ((int )ch == 46) {
#line 2087
      tmp___156 = & user->u_plop;
    } else {
#line 2087
      tmp___156 = & plop_tab[(int )((unsigned char )ch)];
    }
#line 2087
    pp___0 = tmp___156;
#line 2089
    if (pp___0->enc != enc) {
      {
#line 2091
      __cil_tmp161 = RecodeBuf((unsigned char *)pp___0->buf, pp___0->len, pp___0->enc,
                               enc, (unsigned char *)dbuf + l);
      }
#line 2091
      l += __cil_tmp161;
#line 2092
      goto while_continue___19;
    }
    {
#line 2095
    bcopy((void const   *)pp___0->buf, (void *)(dbuf + l), (size_t )pp___0->len);
#line 2096
    l += pp___0->len;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
#line 2085
  ss ++;
#line 2101
  if (*(args + 1) == (char *)0) {
    {
#line 2103
    MakePaster(& fore->w_paster, dbuf, l, 1);
    }
  } else
#line 2111
  if ((int )dch == 46) {
#line 2113
    if (user->u_plop.buf != (char *)((void *)0)) {
      {
#line 2114
      UserFreeCopyBuffer(user);
      }
    }
#line 2115
    user->u_plop.buf = dbuf;
#line 2116
    user->u_plop.len = l;
#line 2118
    user->u_plop.enc = enc;
  } else {
#line 2123
    pp___1 = (struct plop *)plop_tab + (int )((unsigned char )dch);
#line 2124
    if (pp___1->buf) {
      {
#line 2125
      free((void *)pp___1->buf);
      }
    }
#line 2126
    pp___1->buf = dbuf;
#line 2127
    pp___1->len = l;
#line 2129
    pp___1->enc = enc;
  }
#line 2133
  goto switch_break;
  case_165: /* CIL Label */ 
#line 2136
  if (! user->u_plop.buf) {
    {
#line 2138
    Msg(0, (char *)"empty buffer");
    }
#line 2139
    goto switch_break;
  }
  {
#line 2145
  oldplop = user->u_plop;
#line 2146
  __cil_tmp165 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 2146
  if (*(args + 0)) {
#line 2146
    if (*(args + 1)) {
#line 2146
      if (! __cil_tmp165) {
        {
#line 2151
        enc___0 = FindEncoding(*(args + 1));
        }
#line 2152
        if (enc___0 == -1) {
          {
#line 2154
          Msg(0, (char *)"%s: writebuf: unknown encoding", rc_name);
          }
#line 2155
          goto switch_break;
        }
#line 2157
        if (enc___0 != oldplop.enc) {
          {
#line 2159
          l___0 = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len, oldplop.enc,
                            enc___0, (unsigned char *)0);
#line 2160
          __cil_tmp171 = malloc((unsigned long )(l___0 + 1));
#line 2160
          newbuf = (char *)__cil_tmp171;
          }
#line 2161
          if (! newbuf) {
            {
#line 2163
            Msg(0, (char *)strnomem);
            }
#line 2164
            goto switch_break;
          }
          {
#line 2166
          user->u_plop.len = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len,
                                       oldplop.enc, enc___0, (unsigned char *)newbuf);
#line 2167
          user->u_plop.buf = newbuf;
#line 2168
          user->u_plop.enc = enc___0;
          }
        }
#line 2170
        args += 2;
      }
    }
  }
#line 2173
  if (*(args + 0)) {
#line 2173
    if (*(args + 1)) {
      {
#line 2174
      Msg(0, (char *)"%s: writebuf: too many arguments", rc_name);
      }
    } else {
      {
      {
#line 2176
      WriteFile(user, *(args + 0), 2);
      }
      }
    }
  } else {
    {
    {
#line 2176
    WriteFile(user, *(args + 0), 2);
    }
    }
  }
#line 2178
  if (user->u_plop.buf != oldplop.buf) {
    {
#line 2179
    free((void *)user->u_plop.buf);
    }
  }
#line 2180
  user->u_plop = oldplop;
#line 2183
  goto switch_break;
  case_119: /* CIL Label */ 
#line 2186
  if (fore) {
#line 2186
    tmp___158 = fore->w_layer.l_encoding;
  } else {
#line 2186
    if (display) {
#line 2186
      tmp___157 = display->d_encoding;
    } else {
#line 2186
      tmp___157 = 0;
    }
#line 2186
    tmp___158 = tmp___157;
  }
  {
#line 2186
  i = tmp___158;
#line 2187
  __cil_tmp175 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 2187
  if (*(args + 0)) {
#line 2187
    if (*(args + 1)) {
#line 2187
      if (! __cil_tmp175) {
        {
#line 2189
        i = FindEncoding(*(args + 1));
        }
#line 2190
        if (i == -1) {
          {
#line 2192
          Msg(0, (char *)"%s: readbuf: unknown encoding", rc_name);
          }
#line 2193
          goto switch_break;
        }
#line 2195
        args += 2;
      }
    }
  }
#line 2198
  if (*(args + 0)) {
#line 2198
    if (*(args + 1)) {
      {
#line 2200
      Msg(0, (char *)"%s: readbuf: too many arguments", rc_name);
      }
#line 2201
      goto switch_break;
    }
  }
#line 2203
  if (*(args + 0)) {
#line 2203
    tmp___159 = *(args + 0);
  } else {
#line 2203
    tmp___159 = BufferFile;
  }
  {
#line 2203
  __cil_tmp178 = ReadFile(tmp___159, & n);
#line 2203
  s = __cil_tmp178;
  }
#line 2203
  if (s) {
#line 2205
    if (user->u_plop.buf) {
      {
#line 2206
      UserFreeCopyBuffer(user);
      }
    }
#line 2207
    user->u_plop.len = n;
#line 2208
    user->u_plop.buf = s;
#line 2210
    user->u_plop.enc = i;
  }
#line 2213
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 2215
  KillBuffers();
  }
#line 2216
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 2218
  __cil_tmp179 = ParseSwitch(act, & search_ic);
  }
#line 2219
  if (msgok) {
#line 2220
    if (search_ic) {
#line 2220
      tmp___160 = (char *)"";
    } else {
#line 2220
      tmp___160 = (char *)"not ";
    }
    {
#line 2220
    Msg(0, (char *)"Will %signore case in searches", tmp___160);
    }
  }
#line 2221
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 2224
  __cil_tmp181 = ParseEscape(user, *args);
  }
#line 2224
  if (__cil_tmp181) {
    {
#line 2226
    Msg(0, (char *)"%s: two characters required after escape.", rc_name);
    }
#line 2227
    goto switch_break;
  }
#line 2232
  if (display) {
#line 2232
    if (user != users) {
#line 2233
      goto switch_break;
    }
  }
  case_41: /* CIL Label */ 
  {
#line 2236
  __cil_tmp182 = ParseEscape((struct acluser *)((void *)0), *args);
  }
#line 2236
  if (__cil_tmp182) {
    {
#line 2238
    Msg(0, (char *)"%s: two characters required after defescape.", rc_name);
    }
#line 2239
    goto switch_break;
  }
  {
#line 2242
  CheckEscape();
  }
#line 2244
  goto switch_break;
  case_26: /* CIL Label */ 
#line 2246
  if (*args) {
#line 2246
    tmp___161 = *args;
  } else {
#line 2246
    tmp___161 = home;
  }
  {
#line 2246
  s = tmp___161;
#line 2247
  __cil_tmp184 = chdir((char const   *)s);
  }
#line 2247
  if (__cil_tmp184 == -1) {
    {
#line 2248
    __cil_tmp185 = __errno_location();
#line 2248
    Msg(*__cil_tmp185, (char *)"%s", s);
    }
  }
#line 2249
  goto switch_break;
  case_52: /* CIL Label */ 
  case_133: /* CIL Label */ 
  {
#line 2252
  __cil_tmp186 = ParseSaveStr(act, & ShellProg);
  }
#line 2252
  if (__cil_tmp186 == 0) {
#line 2253
    ShellArgs[0] = ShellProg;
  }
#line 2254
  goto switch_break;
  case_74: /* CIL Label */ 
#line 2256
  if (*args) {
    {
#line 2257
    __cil_tmp187 = ParseSaveStr(act, & hardcopydir);
    }
  }
#line 2258
  if (msgok) {
#line 2259
    if (hardcopydir && (int )*hardcopydir) {
#line 2259
      tmp___162 = hardcopydir;
    } else {
#line 2259
      tmp___162 = (char *)"<cwd>";
    }
    {
#line 2259
    Msg(0, (char *)"hardcopydir is %s\n", tmp___162);
    }
  }
#line 2260
  goto switch_break;
  case_88: /* CIL Label */ 
#line 2262
  if (*args) {
    {
#line 2264
    __cil_tmp189 = strcmp((char const   *)*args, (char const   *)((char *)"flush"));
    }
#line 2264
    if (*(args + 1)) {
#line 2264
      if (! __cil_tmp189) {
        {
#line 2266
        log_flush = atoi((char const   *)*(args + 1));
        }
#line 2267
        if (msgok) {
          {
#line 2268
          Msg(0, (char *)"log flush timeout set to %ds\n", log_flush);
          }
        }
#line 2269
        goto switch_break;
      }
    }
    {
#line 2271
    __cil_tmp191 = ParseSaveStr(act, & screenlogfile);
    }
#line 2271
    if (__cil_tmp191) {
#line 2272
      goto switch_break;
    } else
#line 2271
    if (! msgok) {
#line 2272
      goto switch_break;
    }
  }
  {
#line 2274
  Msg(0, (char *)"logfile is \'%s\'", screenlogfile);
  }
#line 2275
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 2277
  __cil_tmp193 = strcmp((char const   *)*args, (char const   *)((char *)"off"));
  }
  {
#line 2277
  __cil_tmp192 = strcmp((char const   *)*args, (char const   *)((char *)"on"));
  }
#line 2277
  if (! *args) {
    _L___164: /* CIL Label */ 
    {
#line 2279
    __cil_tmp194 = ParseSwitch(act, & logtstamp_on);
    }
#line 2279
    if (__cil_tmp194 == 0) {
#line 2279
      if (msgok) {
#line 2280
        if (logtstamp_on) {
#line 2280
          tmp___163 = (char *)"on";
        } else {
#line 2280
          tmp___163 = (char *)"off";
        }
        {
#line 2280
        Msg(0, (char *)"timestamps turned %s", tmp___163);
        }
      }
    }
  } else
#line 2277
  if (! __cil_tmp192) {
#line 2277
    goto _L___164;
  } else
#line 2277
  if (! __cil_tmp193) {
#line 2277
    goto _L___164;
  } else {
    {
#line 2282
    __cil_tmp196 = strcmp((char const   *)*args, (char const   *)((char *)"string"));
    }
#line 2282
    if (! __cil_tmp196) {
#line 2284
      if (*(args + 1)) {
#line 2286
        if (logtstamp_string) {
          {
#line 2287
          free((void *)logtstamp_string);
          }
        }
        {
#line 2288
        logtstamp_string = SaveStr((char const   *)*(args + 1));
        }
      }
#line 2290
      if (msgok) {
        {
#line 2291
        Msg(0, (char *)"logfile timestamp is \'%s\'", logtstamp_string);
        }
      }
    } else {
      {
#line 2293
      __cil_tmp198 = strcmp((char const   *)*args, (char const   *)((char *)"after"));
      }
#line 2293
      if (! __cil_tmp198) {
#line 2295
        if (*(args + 1)) {
          {
#line 2297
          logtstamp_after = atoi((char const   *)*(args + 1));
          }
#line 2298
          if (! msgok) {
#line 2299
            goto switch_break;
          }
        }
        {
#line 2301
        Msg(0, (char *)"timestamp printed after %ds\n", logtstamp_after);
        }
      } else {
        {
#line 2304
        Msg(0, (char *)"usage: logtstamp [after [n]|string [str]|on|off]");
        }
      }
    }
  }
#line 2305
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 2307
  __cil_tmp200 = ParseSaveStr(act, & nwin_default.aka);
  }
#line 2308
  goto switch_break;
  case_149: /* CIL Label */ 
  case_148: /* CIL Label */ 
  case_147: /* CIL Label */ 
#line 2312
  if (! rc_name) {
    {
    {
#line 2313
    Msg(0, (char *)"Sorry, too late now. Place that in your .screenrc file.");
    }
    }
  } else
#line 2312
  if (! *rc_name) {
    {
    {
#line 2313
    Msg(0, (char *)"Sorry, too late now. Place that in your .screenrc file.");
    }
    }
  }
#line 2314
  goto switch_break;
  case_137: /* CIL Label */ 
#line 2316
  goto switch_break;
  case_146: /* CIL Label */ 
#line 2318
  s = (char *)((void *)0);
  {
#line 2319
  __cil_tmp201 = ParseSaveStr(act, & s);
  }
#line 2319
  if (__cil_tmp201) {
#line 2320
    goto switch_break;
  }
  {
#line 2321
  __cil_tmp202 = strlen((char const   *)s);
  }
#line 2321
  if (__cil_tmp202 >= 20UL) {
    {
#line 2323
    Msg(0, (char *)"%s: term: argument too long ( < 20)", rc_name);
#line 2324
    free((void *)s);
    }
#line 2325
    goto switch_break;
  }
  {
#line 2327
  strcpy((char *)screenterm, (char const   *)s);
#line 2328
  free((void *)s);
  }
  {
#line 2329
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2329
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 2330
  MakeTermcap(display == (struct display *)0);
  }
  {
#line 2331
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2331
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2332
  goto switch_break;
  case_63: /* CIL Label */ 
#line 2334
  if (! msgok) {
#line 2335
    goto switch_break;
  }
  {
#line 2340
  __cil_tmp203 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"-n"));
  }
#line 2340
  if (*args) {
#line 2340
    if (*(args + 1) == (char *)0) {
      _L___167: /* CIL Label */ 
#line 2341
      if (*(args + 1)) {
#line 2341
        tmp___166 = *(args + 1);
      } else {
#line 2341
        tmp___166 = *args;
      }
      {
#line 2341
      Msg(0, (char *)"%s", tmp___166);
      }
    } else
#line 2340
    if (__cil_tmp203 == 0) {
#line 2340
      if (*(args + 2) == (char *)0) {
#line 2340
        goto _L___167;
      } else {
        {
        {
        {
#line 2343
        Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 2343
      Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 2343
    Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
    }
    }
    }
  }
#line 2344
  goto switch_break;
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 2347
  if (*args == (char *)0) {
    {
#line 2350
    AddXChars((char *)buf___0, (int )sizeof(buf___0), BellString);
#line 2351
    Msg(0, (char *)"bell_msg is \'%s\'", (char *)buf___0);
    }
#line 2352
    goto switch_break;
  }
  {
#line 2354
  __cil_tmp206 = ParseSaveStr(act, & BellString);
  }
#line 2355
  goto switch_break;
  case_21: /* CIL Label */ 
#line 2358
  if (*args == (char *)0) {
    {
#line 2359
    BufferFile = SaveStr((char const   *)((char *)"/tmp/screen-exchange"));
    }
  } else {
    {
#line 2360
    __cil_tmp208 = ParseSaveStr(act, & BufferFile);
    }
#line 2360
    if (__cil_tmp208) {
#line 2361
      goto switch_break;
    }
  }
#line 2362
  if (msgok) {
    {
#line 2363
    Msg(0, (char *)"Bufferfile is now \'%s\'", BufferFile);
    }
  }
#line 2364
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2367
  __cil_tmp209 = ParseSaveStr(act, & ActivityString);
  }
#line 2368
  goto switch_break;
  case_114: /* CIL Label */ 
#line 2371
  if (*args == (char *)0) {
    {
#line 2374
    AddXChars((char *)buf___1, (int )sizeof(buf___1), PowDetachString);
#line 2375
    Msg(0, (char *)"pow_detach_msg is \'%s\'", (char *)buf___1);
    }
#line 2376
    goto switch_break;
  }
  {
#line 2378
  __cil_tmp211 = ParseSaveStr(act, & PowDetachString);
  }
#line 2379
  goto switch_break;
  case_89: /* CIL Label */ 
#line 2383
  n = fore->w_slot != (slot_t )-1;
  {
#line 2384
  __cil_tmp212 = strcmp((char const   *)*args, (char const   *)((char *)"always"));
  }
#line 2384
  if (*args) {
#line 2384
    if (! __cil_tmp212) {
#line 2386
      fore->w_lflag = 3;
#line 2387
      if (! displays) {
#line 2387
        if (n) {
          {
#line 2388
          SlotToggle(n);
          }
        }
      }
#line 2389
      goto switch_break;
    }
  }
  {
#line 2391
  __cil_tmp213 = strcmp((char const   *)*args, (char const   *)((char *)"attached"));
  }
#line 2391
  if (*args) {
#line 2391
    if (! __cil_tmp213) {
#line 2393
      fore->w_lflag = 1;
#line 2394
      if (! displays) {
#line 2394
        if (n) {
          {
#line 2395
          SlotToggle(0);
          }
        }
      }
#line 2396
      goto switch_break;
    }
  }
  {
#line 2398
  __cil_tmp214 = ParseSwitch(act, & n);
  }
#line 2398
  if (__cil_tmp214 == 0) {
    {
#line 2399
    SlotToggle(n);
    }
  }
#line 2400
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 2402
  __cil_tmp215 = strcmp((char const   *)*args, (char const   *)((char *)"always"));
  }
#line 2402
  if (! __cil_tmp215) {
#line 2403
    nwin_default.lflag |= 2;
  } else {
    {
#line 2404
    __cil_tmp216 = strcmp((char const   *)*args, (char const   *)((char *)"attached"));
    }
#line 2404
    if (! __cil_tmp216) {
#line 2405
      nwin_default.lflag &= ~ 2;
    } else {
      {
#line 2407
      __cil_tmp217 = ParseOnOff(act, & nwin_default.lflag);
      }
    }
  }
#line 2408
  goto switch_break;
  case_42___0: /* CIL Label */ 
#line 2411
  if (*(args + 0)) {
#line 2411
    if (*(args + 1)) {
#line 2411
      if ((int )*(*(args + 1) + 0) == 105) {
#line 2413
        iflag = 1;
#line 2414
        display = displays;
        {
#line 2414
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 2414
          if (! display) {
#line 2414
            goto while_break___22;
          }
#line 2416
          if (! display->d_flow) {
#line 2417
            goto while_continue___22;
          }
          {
#line 2419
          display->d_NewMode.tio.c_cc[0] = display->d_OldMode.tio.c_cc[0];
#line 2420
          display->d_NewMode.tio.c_lflag |= (unsigned int )1;
#line 2424
          SetTTY(display->d_userfd, & display->d_NewMode);
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 2414
        display = display->d_next;
      }
    }
  }
#line 2427
  if (*(args + 0)) {
#line 2427
    if ((int )*(*(args + 0) + 0) == 97) {
#line 2428
      nwin_default.flowflag = 1 << 2;
    } else {
      {
      {
#line 2430
      __cil_tmp218 = ParseOnOff(act, & nwin_default.flowflag);
      }
      }
    }
  } else {
    {
    {
#line 2430
    __cil_tmp218 = ParseOnOff(act, & nwin_default.flowflag);
    }
    }
  }
#line 2431
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 2433
  __cil_tmp219 = ParseOnOff(act, & nwin_default.wrap);
  }
#line 2434
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 2436
  __cil_tmp220 = ParseOnOff(act, & nwin_default.c1);
  }
#line 2437
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 2440
  __cil_tmp221 = ParseOnOff(act, & nwin_default.bce);
  }
#line 2441
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 2444
  __cil_tmp222 = ParseOnOff(act, & nwin_default.gr);
  }
#line 2445
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 2447
  __cil_tmp223 = ParseOnOff(act, & n);
  }
#line 2447
  if (__cil_tmp223 == 0) {
#line 2448
    if (n == 0) {
#line 2448
      tmp___168 = 0;
    } else {
#line 2448
      tmp___168 = 1;
    }
#line 2448
    nwin_default.monitor = tmp___168;
  }
#line 2449
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 2451
  __cil_tmp225 = ParseOnOff(act, & n);
  }
#line 2451
  if (__cil_tmp225 == 0) {
#line 2452
    if (n == 0) {
#line 2452
      tmp___169 = 0;
    } else {
#line 2452
      tmp___169 = 1;
    }
#line 2452
    nwin_default.silence = tmp___169;
  }
#line 2453
  goto switch_break;
  case_158: /* CIL Label */ 
#line 2455
  if (! *args) {
#line 2456
    if (VerboseCreate) {
#line 2456
      tmp___170 = (char *)"ill";
    } else {
#line 2456
      tmp___170 = (char *)"on\'t";
    }
    {
#line 2456
    Msg(0, (char *)"W%s echo command when creating windows.", tmp___170);
    }
  } else {
    {
#line 2458
    __cil_tmp228 = ParseOnOff(act, & n);
    }
#line 2458
    if (__cil_tmp228 == 0) {
#line 2459
      VerboseCreate = n;
    }
  }
#line 2460
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2462
  if (display) {
    {
#line 2464
    Msg(0, (char *)"%s", (char *)"");
#line 2465
    RemoveStatus();
    }
  }
  {
#line 2467
  __cil_tmp230 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"off"));
  }
  {
#line 2467
  __cil_tmp229 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"on"));
  }
#line 2467
  if (*(args + 0)) {
#line 2467
    if (__cil_tmp229) {
#line 2467
      if (__cil_tmp230) {
        {
#line 2469
        olddisplay___0 = display;
#line 2470
        new_use = - 1;
#line 2472
        s = *(args + 0);
#line 2473
        __cil_tmp234 = strncmp((char const   *)s, (char const   *)((char *)"always"),
                               (unsigned long )6);
        }
#line 2473
        if (! __cil_tmp234) {
#line 2474
          s += 6;
        }
        {
#line 2475
        __cil_tmp235 = strcmp((char const   *)s, (char const   *)((char *)"lastline"));
        }
#line 2475
        if (! __cil_tmp235) {
#line 2476
          new_use = 1;
        } else {
          {
#line 2477
          __cil_tmp236 = strcmp((char const   *)s, (char const   *)((char *)"ignore"));
          }
#line 2477
          if (! __cil_tmp236) {
#line 2478
            new_use = 0;
          } else {
            {
#line 2479
            __cil_tmp237 = strcmp((char const   *)s, (char const   *)((char *)"message"));
            }
#line 2479
            if (! __cil_tmp237) {
#line 2480
              new_use = 2;
            } else {
              {
#line 2481
              __cil_tmp238 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"string"));
              }
#line 2481
              if (! __cil_tmp238) {
#line 2483
                if (! *(args + 1)) {
                  {
#line 2486
                  AddXChars((char *)buf___2, (int )sizeof(buf___2), hstatusstring);
#line 2487
                  Msg(0, (char *)"hardstatus string is \'%s\'", (char *)buf___2);
                  }
#line 2488
                  goto switch_break;
                }
              } else {
                {
#line 2493
                Msg(0, (char *)"%s: usage: hardstatus [always]lastline|ignore|message|string [string]",
                    rc_name);
                }
#line 2494
                goto switch_break;
              }
            }
          }
        }
#line 2496
        if (new_use != -1) {
#line 2498
          if (s == *(args + 0)) {
#line 2498
            tmp___171 = 0;
          } else {
#line 2498
            tmp___171 = 1 << 2;
          }
#line 2498
          hardstatusemu = new_use | tmp___171;
#line 2499
          display = displays;
          {
#line 2499
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 2499
            if (! display) {
#line 2499
              goto while_break___23;
            }
            {
#line 2501
            RemoveStatus();
#line 2502
            new_use = hardstatusemu & ~ (1 << 2);
            }
#line 2503
            if (display->d_tcs[75].flg) {
#line 2503
              if (s == *(args + 0)) {
#line 2504
                new_use = 3;
              }
            }
            {
#line 2505
            ShowHStatus((char *)0);
#line 2506
            old_use = display->d_has_hstatus;
#line 2507
            display->d_has_hstatus = new_use;
            }
#line 2508
            if (new_use == 1) {
#line 2508
              if (old_use != 1) {
                {
                {
#line 2509
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              } else {
#line 2508
                goto _L___172;
              }
            } else
            _L___172: /* CIL Label */ 
#line 2508
            if (new_use != 1) {
#line 2508
              if (old_use == 1) {
                {
                {
#line 2509
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              }
            }
            {
#line 2510
            RefreshHStatus();
            }
          }
          while_break___23: /* CIL Label */ ;
          }
#line 2499
          display = display->d_next;
        }
#line 2513
        if (*(args + 1)) {
#line 2515
          if (hstatusstring) {
            {
#line 2516
            free((void *)hstatusstring);
            }
          }
          {
#line 2517
          hstatusstring = SaveStr((char const   *)*(args + 1));
#line 2518
          display = displays;
          }
          {
#line 2518
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 2518
            if (! display) {
#line 2518
              goto while_break___24;
            }
            {
#line 2519
            RefreshHStatus();
            }
          }
          while_break___24: /* CIL Label */ ;
          }
#line 2518
          display = display->d_next;
        }
#line 2521
        display = olddisplay___0;
#line 2522
        goto switch_break;
      }
    }
  }
  {
#line 2524
  __cil_tmp242 = ParseSwitch(act, & use_hardstatus);
  }
#line 2525
  if (msgok) {
#line 2526
    if (use_hardstatus) {
#line 2526
      tmp___173 = (char *)"hardstatus line";
    } else {
#line 2526
      tmp___173 = (char *)"window";
    }
    {
#line 2526
    Msg(0, (char *)"messages displayed on %s", tmp___173);
    }
  }
#line 2527
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 2529
  __cil_tmp245 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"splitonly"));
  }
  {
#line 2529
  __cil_tmp244 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"always"));
  }
#line 2529
  if (__cil_tmp244 == 0) {
    _L___174: /* CIL Label */ 
#line 2531
    olddisplay___1 = display;
#line 2533
    captionalways = (int )*(*(args + 0) + 0) == 97;
#line 2534
    display = displays;
    {
#line 2534
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 2534
      if (! display) {
#line 2534
        goto while_break___25;
      }
      {
#line 2535
      ChangeScreenSize(display->d_width, display->d_height, 1);
      }
    }
    while_break___25: /* CIL Label */ ;
    }
#line 2534
    display = display->d_next;
#line 2536
    display = olddisplay___1;
  } else
#line 2529
  if (__cil_tmp245 == 0) {
#line 2529
    goto _L___174;
  } else {
    {
#line 2538
    __cil_tmp247 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"string"));
    }
#line 2538
    if (__cil_tmp247 == 0) {
#line 2540
      if (! *(args + 1)) {
        {
#line 2543
        AddXChars((char *)buf___3, (int )sizeof(buf___3), captionstring);
#line 2544
        Msg(0, (char *)"caption string is \'%s\'", (char *)buf___3);
        }
#line 2545
        goto switch_break;
      }
    } else {
      {
#line 2550
      Msg(0, (char *)"%s: usage: caption always|splitonly|string <string>", rc_name);
      }
#line 2551
      goto switch_break;
    }
  }
#line 2553
  if (! *(args + 1)) {
#line 2554
    goto switch_break;
  }
#line 2555
  if (captionstring) {
    {
#line 2556
    free((void *)captionstring);
    }
  }
  {
#line 2557
  captionstring = SaveStr((char const   *)*(args + 1));
#line 2558
  RedisplayDisplays(0);
  }
#line 2559
  goto switch_break;
  case_31: /* CIL Label */ 
#line 2561
  n = console_window != (struct win *)0;
  {
#line 2562
  __cil_tmp250 = ParseSwitch(act, & n);
  }
#line 2562
  if (__cil_tmp250) {
#line 2563
    goto switch_break;
  }
  {
#line 2564
  __cil_tmp251 = TtyGrabConsole(fore->w_ptyfd, n, rc_name);
  }
#line 2564
  if (__cil_tmp251) {
#line 2565
    goto switch_break;
  }
#line 2566
  if (n == 0) {
    {
#line 2567
    Msg(0, (char *)"%s: releasing console %s", rc_name, (char *)HostName);
    }
  } else
#line 2568
  if (console_window) {
    {
#line 2569
    Msg(0, (char *)"%s: stealing console %s from window %d (%s)", rc_name, (char *)HostName,
        console_window->w_number, console_window->w_title);
    }
  } else {
    {
#line 2572
    Msg(0, (char *)"%s: grabbing console %s", rc_name, (char *)HostName);
    }
  }
#line 2573
  if (n) {
#line 2573
    tmp___175 = fore;
  } else {
#line 2573
    tmp___175 = (struct win *)0;
  }
#line 2573
  console_window = tmp___175;
#line 2574
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2576
  __cil_tmp253 = ParseOnOff(act, & all_norefresh);
  }
#line 2576
  if (__cil_tmp253) {
#line 2577
    goto switch_break;
  }
#line 2578
  if (! all_norefresh) {
#line 2578
    if (fore) {
      {
#line 2579
      Activate(- 1);
      }
    }
  }
#line 2580
  if (msgok) {
#line 2581
    if (all_norefresh) {
#line 2581
      tmp___176 = (char *)"No refresh on window change!\n";
    } else {
#line 2581
      tmp___176 = (char *)"Window specific refresh\n";
    }
    {
#line 2581
    Msg(0, tmp___176);
    }
  }
#line 2583
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 2585
  __cil_tmp255 = ParseSwitch(act, & n);
  }
#line 2586
  fore->w_norefresh = (char )n;
#line 2587
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 2589
  __cil_tmp256 = ParseSwitch(act, & visual_bell);
  }
#line 2589
  if (__cil_tmp256) {
#line 2590
    goto switch_break;
  } else
#line 2589
  if (! msgok) {
#line 2590
    goto switch_break;
  }
#line 2591
  if (visual_bell == 0) {
    {
#line 2592
    Msg(0, (char *)"switched to audible bell.");
    }
  } else {
    {
#line 2594
    Msg(0, (char *)"switched to visual bell.");
    }
  }
#line 2595
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 2597
  __cil_tmp257 = ParseNum(act, & VBellWait);
  }
#line 2597
  if (__cil_tmp257 == 0) {
#line 2597
    if (msgok) {
      {
#line 2598
      Msg(0, (char *)"vbellwait set to %d seconds", VBellWait);
      }
    }
  }
#line 2599
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2601
  __cil_tmp258 = ParseNum(act, & MsgWait);
  }
#line 2601
  if (__cil_tmp258 == 0) {
#line 2601
    if (msgok) {
      {
#line 2602
      Msg(0, (char *)"msgwait set to %d seconds", MsgWait);
      }
    }
  }
#line 2603
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 2605
  __cil_tmp259 = ParseNum(act, & MsgMinWait);
  }
#line 2605
  if (__cil_tmp259 == 0) {
#line 2605
    if (msgok) {
      {
#line 2606
      Msg(0, (char *)"msgminwait set to %d seconds", MsgMinWait);
      }
    }
  }
#line 2607
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 2609
  __cil_tmp260 = ParseNum(act, & SilenceWait);
  }
#line 2609
  if (__cil_tmp260 == 0) {
#line 2609
    if (msgok) {
#line 2611
      if (SilenceWait < 1) {
#line 2612
        SilenceWait = 1;
      }
#line 2613
      p = windows;
      {
#line 2613
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 2613
        if (! p) {
#line 2613
          goto while_break___26;
        }
#line 2614
        p->w_silencewait = SilenceWait;
      }
      while_break___26: /* CIL Label */ ;
      }
      {
#line 2613
      p = p->w_next;
#line 2615
      Msg(0, (char *)"silencewait set to %d seconds", SilenceWait);
      }
    }
  }
#line 2617
  goto switch_break;
  case_104: /* CIL Label */ 
#line 2619
  if (*args == (char *)0) {
    {
#line 2620
    Msg(0, (char *)"This is window %d (%s).\n", fore->w_number, fore->w_title);
    }
  } else {
    {
#line 2623
    old = fore->w_number;
#line 2625
    __cil_tmp262 = ParseNum(act, & n);
    }
#line 2625
    if (__cil_tmp262) {
#line 2626
      goto switch_break;
    } else
#line 2625
    if (n >= maxwin) {
#line 2626
      goto switch_break;
    }
#line 2627
    p = wtab[n];
#line 2628
    wtab[n] = fore;
#line 2629
    fore->w_number = n;
#line 2630
    wtab[old] = p;
#line 2631
    if (p) {
#line 2632
      p->w_number = old;
    }
    {
#line 2635
    AclWinSwap(old, n);
    }
#line 2639
    if (fore->w_slot != (slot_t )-1) {
#line 2639
      if (fore->w_slot != (slot_t )0) {
        {
#line 2641
        RemoveUtmp(fore);
#line 2642
        SetUtmp(fore);
        }
      }
    }
#line 2644
    if (p) {
#line 2644
      if (p->w_slot != (slot_t )-1) {
#line 2644
        if (p->w_slot != (slot_t )0) {
#line 2647
          if (fore->w_layer.l_cvlist) {
#line 2647
            tmp___177 = (fore->w_layer.l_cvlist)->c_display;
          } else {
#line 2647
            tmp___177 = (struct display *)0;
          }
          {
#line 2647
          display = tmp___177;
#line 2648
          RemoveUtmp(p);
#line 2649
          SetUtmp(p);
          }
        }
      }
    }
    {
#line 2653
    WindowChanged(fore, 'n');
#line 2654
    WindowChanged((struct win *)0, 'w');
#line 2655
    WindowChanged((struct win *)0, 'W');
#line 2656
    WindowChanged((struct win *)0, 0);
    }
  }
#line 2658
  goto switch_break;
  case_135: /* CIL Label */ 
#line 2660
  n = fore->w_silence != 0;
#line 2661
  i = fore->w_silencewait;
#line 2662
  if (*(args + 0)) {
#line 2662
    if ((int )*(*(args + 0) + 0) == 45) {
      _L___179: /* CIL Label */ 
      {
#line 2664
      __cil_tmp264 = ParseNum(act, & i);
      }
#line 2664
      if (__cil_tmp264) {
#line 2665
        goto switch_break;
      }
#line 2666
      n = i > 0;
    } else
#line 2662
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 2662
      if ((int )*(*(args + 0) + 0) <= 57) {
#line 2662
        goto _L___179;
      } else {
#line 2662
        goto _L___178;
      }
    } else {
#line 2662
      goto _L___178;
    }
  } else {
    _L___178: /* CIL Label */ 
    {
#line 2668
    __cil_tmp265 = ParseSwitch(act, & n);
    }
#line 2668
    if (__cil_tmp265) {
#line 2669
      goto switch_break;
    }
  }
#line 2670
  if (n) {
#line 2673
    if (display) {
#line 2674
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) |= 128 >> ((display->d_user)->u_id & 7);
    } else {
#line 2676
      n = 0;
      {
#line 2676
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 2676
        if (! (n < maxusercount)) {
#line 2676
          goto while_break___27;
        }
#line 2677
        *(fore->w_lio_notify + (n >> 3)) |= 128 >> (n & 7);
      }
      while_break___27: /* CIL Label */ ;
      }
#line 2676
      n ++;
    }
    {
#line 2679
    fore->w_silencewait = i;
#line 2680
    fore->w_silence = 1;
#line 2681
    SetTimeout(& fore->w_silenceev, fore->w_silencewait * 1000);
#line 2682
    evenq(& fore->w_silenceev);
    }
#line 2684
    if (! msgok) {
#line 2685
      goto switch_break;
    }
    {
#line 2686
    Msg(0, (char *)"The window is now being monitored for %d sec. silence.", fore->w_silencewait);
    }
  } else {
#line 2691
    if (display) {
#line 2692
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) &= ~ (128 >> ((display->d_user)->u_id & 7));
    } else {
#line 2695
      n = 0;
      {
#line 2695
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 2695
        if (! (n < maxusercount)) {
#line 2695
          goto while_break___28;
        }
#line 2696
        *(fore->w_lio_notify + (n >> 3)) &= ~ (128 >> (n & 7));
      }
      while_break___28: /* CIL Label */ ;
      }
#line 2695
      n ++;
    }
#line 2697
    i = maxusercount - 1;
    {
#line 2697
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 2697
      if (! (i >= 0)) {
#line 2697
        goto while_break___29;
      }
#line 2698
      if (*(fore->w_lio_notify + (i >> 3))) {
#line 2699
        goto while_break___29;
      }
    }
    while_break___29: /* CIL Label */ ;
    }
#line 2697
    __cil_tmp268 = i;
#line 2697
    i --;
#line 2700
    if (i < 0) {
      {
#line 2703
      fore->w_silence = 0;
#line 2704
      evdeq(& fore->w_silenceev);
      }
    }
#line 2706
    if (! msgok) {
#line 2707
      goto switch_break;
    }
    {
#line 2708
    Msg(0, (char *)"The window is no longer being monitored for silence.");
    }
  }
#line 2710
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 2713
  __cil_tmp269 = ParseNum(act, & nwin_default.histheight);
  }
#line 2714
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 2716
  __cil_tmp270 = ParseNum(act, & n);
  }
  {
#line 2717
  ChangeWindowSize(fore, fore->w_layer.l_width, fore->w_layer.l_height, n);
  }
#line 2718
  if (msgok) {
    {
#line 2719
    Msg(0, (char *)"scrollback set to %d", fore->w_histheight);
    }
  }
#line 2720
  goto switch_break;
  case_130: /* CIL Label */ 
#line 2723
  if (*args == (char *)0) {
    {
#line 2724
    Msg(0, (char *)"This session is named \'%s\'\n", SockName);
    }
  } else {
    {
#line 2729
    s = (char *)0;
#line 2730
    __cil_tmp272 = ParseSaveStr(act, & s);
    }
#line 2730
    if (__cil_tmp272) {
#line 2731
      goto switch_break;
    }
    {
#line 2732
    __cil_tmp274 = index((char const   *)s, '/');
    }
    {
#line 2732
    __cil_tmp273 = strlen((char const   *)s);
    }
#line 2732
    if (! *s) {
      {
      {
      {
#line 2734
      Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
      }
      }
      {
      {
#line 2735
      free((void *)s);
      }
      }
      }
#line 2736
      goto switch_break;
    } else
#line 2732
    if (__cil_tmp273 + (unsigned long )(SockName - (char *)SockPath) > 4083UL) {
      {
      {
      {
#line 2734
      Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
      }
      }
      {
      {
#line 2735
      free((void *)s);
      }
      }
      }
#line 2736
      goto switch_break;
    } else
#line 2732
    if (__cil_tmp274) {
      {
      {
      {
#line 2734
      Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
      }
      }
      {
      {
#line 2735
      free((void *)s);
      }
      }
      }
#line 2736
      goto switch_break;
    }
    {
#line 2738
    strncpy((char *)buf___4, (char const   *)((char *)SockPath), (unsigned long )(SockName - (char *)SockPath));
#line 2739
    __cil_tmp275 = getpid();
#line 2739
    sprintf((char *)buf___4 + (SockName - (char *)SockPath), (char const   *)((char *)"%d.%s"),
            __cil_tmp275, s);
#line 2740
    free((void *)s);
#line 2741
    __cil_tmp277 = __errno_location();
    }
    {
#line 2741
    __cil_tmp276 = access((char const   *)((char *)buf___4), 0);
    }
#line 2741
    if (__cil_tmp276 == 0) {
      {
      {
#line 2743
      Msg(0, (char *)"%s: inappropriate path: \'%s\'.", rc_name, (char *)buf___4);
      }
      }
#line 2744
      goto switch_break;
    } else
#line 2741
    if (*__cil_tmp277 != 2) {
      {
      {
#line 2743
      Msg(0, (char *)"%s: inappropriate path: \'%s\'.", rc_name, (char *)buf___4);
      }
      }
#line 2744
      goto switch_break;
    }
    {
#line 2746
    __cil_tmp278 = rename((char const   *)((char *)SockPath), (char const   *)((char *)buf___4));
    }
#line 2746
    if (__cil_tmp278) {
      {
#line 2748
      __cil_tmp279 = __errno_location();
#line 2748
      Msg(*__cil_tmp279, (char *)"%s: failed to rename(%s, %s)", rc_name, (char *)SockPath,
          (char *)buf___4);
      }
#line 2749
      goto switch_break;
    }
    {
#line 2751
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 2751
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 2752
    strcpy((char *)SockPath, (char const   *)((char *)buf___4));
#line 2753
    MakeNewEnv();
    }
  }
#line 2755
  goto switch_break;
  case_131: /* CIL Label */ 
#line 2757
  if (! *(args + 0)) {
    _L___180: /* CIL Label */ 
    {
#line 2759
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 2759
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 2760
    InputSetenv(*(args + 0));
    }
  } else
#line 2757
  if (! *(args + 1)) {
#line 2757
    goto _L___180;
  } else {
    {
#line 2764
    xsetenv(*(args + 0), *(args + 1));
#line 2765
    MakeNewEnv();
    }
  }
#line 2767
  goto switch_break;
  case_153: /* CIL Label */ 
  {
#line 2769
  unsetenv((char const   *)*args);
  }
  {
#line 2770
  MakeNewEnv();
  }
#line 2771
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 2774
  __cil_tmp280 = ParseNum(act, & nwin_default.slow);
  }
#line 2775
  goto switch_break;
  case_138: /* CIL Label */ 
#line 2777
  if (*args == (char *)0) {
#line 2778
    if (fore->w_slowpaste) {
#line 2778
      tmp___181 = (char *)"Slowpaste in window %d is %d milliseconds.";
    } else {
#line 2778
      tmp___181 = (char *)"Slowpaste in window %d is unset.";
    }
    {
#line 2778
    Msg(0, tmp___181, fore->w_number, fore->w_slowpaste);
    }
  } else {
    {
#line 2782
    __cil_tmp282 = ParseNum(act, & fore->w_slowpaste);
    }
#line 2782
    if (__cil_tmp282 == 0) {
#line 2782
      if (msgok) {
#line 2783
        if (fore->w_slowpaste) {
#line 2783
          tmp___182 = (char *)"Slowpaste in window %d set to %d milliseconds.";
        } else {
#line 2783
          tmp___182 = (char *)"Slowpaste in window %d now unset.";
        }
        {
#line 2783
        Msg(0, tmp___182, fore->w_number, fore->w_slowpaste);
        }
      }
    }
  }
#line 2787
  goto switch_break;
  case_94: /* CIL Label */ 
#line 2789
  s = (char *)0;
  {
#line 2790
  __cil_tmp284 = ParseSaveStr(act, & s);
  }
#line 2790
  if (__cil_tmp284) {
#line 2791
    goto switch_break;
  }
  {
#line 2792
  __cil_tmp285 = CompileKeys(s, (unsigned char *)mark_key_tab);
  }
#line 2792
  if (__cil_tmp285) {
    {
#line 2794
    Msg(0, (char *)"%s: markkeys: syntax error.", rc_name);
#line 2795
    free((void *)s);
    }
#line 2796
    goto switch_break;
  }
  {
#line 2798
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 2798
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 2799
  free((void *)s);
  }
#line 2800
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 2803
  __cil_tmp286 = ParseSwitch(act, & pastefont);
  }
#line 2803
  if (__cil_tmp286 == 0) {
#line 2803
    if (msgok) {
#line 2804
      if (pastefont) {
#line 2804
        tmp___183 = (char *)"";
      } else {
#line 2804
        tmp___183 = (char *)"not ";
      }
      {
#line 2804
      Msg(0, (char *)"Will %spaste font settings", tmp___183);
      }
    }
  }
#line 2805
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 2808
  __cil_tmp288 = ParseSwitch(act, & join_with_cr);
  }
#line 2809
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 2811
  __cil_tmp289 = ParseSwitch(act, & compacthist);
  }
#line 2811
  if (__cil_tmp289 == 0) {
#line 2811
    if (msgok) {
#line 2812
      if (compacthist) {
#line 2812
        tmp___184 = (char *)"";
      } else {
#line 2812
        tmp___184 = (char *)"not ";
      }
      {
#line 2812
      Msg(0, (char *)"%scompacting history lines", tmp___184);
      }
    }
  }
#line 2813
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 2817
  __cil_tmp291 = ParseOnOff(act, & nethackflag);
  }
#line 2818
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 2821
  __cil_tmp292 = ParseOnOff(act, & hardcopy_append);
  }
#line 2822
  goto switch_break;
  case_156: /* CIL Label */ 
#line 2824
  if (*args == (char *)0) {
    {
#line 2827
    AddXChars((char *)buf___5, (int )sizeof(buf___5), VisualBellString);
#line 2828
    Msg(0, (char *)"vbell_msg is \'%s\'", (char *)buf___5);
    }
#line 2829
    goto switch_break;
  }
  {
#line 2831
  __cil_tmp294 = ParseSaveStr(act, & VisualBellString);
  }
  {
#line 2832
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 2832
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 2833
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 2835
  __cil_tmp295 = ParseBase(act, *args, & n, 8, (char *)"octal");
  }
#line 2835
  if (__cil_tmp295) {
#line 2836
    goto switch_break;
  }
#line 2837
  if (n < 0) {
    {
    {
#line 2839
    Msg(0, (char *)"%s: mode: Invalid tty mode %o", rc_name, n);
    }
    }
#line 2840
    goto switch_break;
  } else
#line 2837
  if (n > 511) {
    {
    {
#line 2839
    Msg(0, (char *)"%s: mode: Invalid tty mode %o", rc_name, n);
    }
    }
#line 2840
    goto switch_break;
  }
#line 2842
  TtyMode = n;
#line 2843
  if (msgok) {
    {
#line 2844
    Msg(0, (char *)"Ttymode set to %03o", TtyMode);
    }
  }
#line 2845
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2847
  __cil_tmp296 = ParseOnOff(act, & auto_detach);
  }
#line 2848
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 2850
  __cil_tmp297 = ParseOnOff(act, & default_startup);
  }
#line 2851
  goto switch_break;
  case_109: /* CIL Label */ 
#line 2854
  if (*args) {
#line 2856
    if ((int )*(user->u_password)) {
#line 2856
      tmp___185 = 1;
    } else {
#line 2856
      tmp___185 = 0;
    }
#line 2856
    n = tmp___185;
#line 2857
    if (user->u_password != (char *)NullStr) {
      {
#line 2857
      free((void *)user->u_password);
      }
    }
    {
#line 2858
    user->u_password = SaveStr((char const   *)*args);
#line 2859
    __cil_tmp300 = strcmp((char const   *)user->u_password, (char const   *)((char *)"none"));
    }
#line 2859
    if (! __cil_tmp300) {
#line 2861
      if (n) {
        {
#line 2862
        Msg(0, (char *)"Password checking disabled");
        }
      }
      {
#line 2863
      free((void *)user->u_password);
#line 2864
      user->u_password = (char *)NullStr;
      }
    }
  } else {
#line 2869
    if (! fore) {
      {
#line 2871
      Msg(0, (char *)"%s: password: window required", rc_name);
      }
#line 2872
      goto switch_break;
    }
#line 2874
    if (display) {
#line 2874
      tmp___186 = (char *)display->d_user;
    } else {
#line 2874
      tmp___186 = (char *)users;
    }
    {
#line 2874
    Input((char *)"New screen password:", 100, 1, pass1, tmp___186);
    }
  }
#line 2876
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2880
  ktabp___1 = (struct action *)ktab;
#line 2882
  __cil_tmp303 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
  }
#line 2882
  if (argc > 2) {
#line 2882
    if (! __cil_tmp303) {
      {
#line 2884
      ktabp___1 = FindKtab(*(args + 1), 1);
      }
#line 2885
      if (ktabp___1 == (struct action *)0) {
#line 2886
        goto switch_break;
      }
#line 2887
      args += 2;
    }
  }
  {
#line 2889
  s = ParseChar(*args, & ch);
  }
#line 2889
  if (s == (char *)0) {
    {
    {
#line 2891
    Msg(0, (char *)"%s: bind: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 2893
    goto switch_break;
  } else
#line 2889
  if ((int )*s) {
    {
    {
#line 2891
    Msg(0, (char *)"%s: bind: character, ^x, or (octal) \\032 expected.", rc_name);
    }
    }
#line 2893
    goto switch_break;
  }
#line 2895
  n = (int )((unsigned char )ch);
#line 2896
  if (*(args + 1)) {
    {
#line 2898
    i = FindCommnr(*(args + 1));
    }
#line 2898
    if (i == -1) {
      {
#line 2900
      Msg(0, (char *)"%s: bind: unknown command \'%s\'", rc_name, *(args + 1));
      }
#line 2901
      goto switch_break;
    }
    {
#line 2903
    __cil_tmp307 = CheckArgNum(i, args + 2);
    }
#line 2903
    if (__cil_tmp307 < 0) {
#line 2904
      goto switch_break;
    }
    {
#line 2905
    ClearAction(& *(ktabp___1 + n));
#line 2906
    (ktabp___1 + n)->nr = i;
    }
#line 2907
    if (*(args + 2)) {
      {
#line 2908
      (ktabp___1 + n)->args = SaveArgs(args + 2);
      }
    }
  } else {
    {
#line 2911
    ClearAction(& *(ktabp___1 + n));
    }
  }
#line 2913
  goto switch_break;
  case_18: /* CIL Label */ 
#line 2918
  fl = 0;
#line 2918
  kf = 0;
#line 2918
  af = 0;
#line 2918
  df = 0;
#line 2918
  mf = 0;
#line 2919
  odisp = display;
#line 2920
  used = 0;
  {
#line 2922
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 2922
    if (! (*args && (int )*(*args) == 45)) {
#line 2922
      goto while_break___34;
    }
    {
#line 2924
    __cil_tmp318 = strcmp((char const   *)*args, (char const   *)((char *)"-t"));
    }
#line 2924
    if (__cil_tmp318 == 0) {
#line 2925
      fl = 16384;
    } else {
      {
#line 2926
      __cil_tmp319 = strcmp((char const   *)*args, (char const   *)((char *)"-k"));
      }
#line 2926
      if (__cil_tmp319 == 0) {
#line 2927
        kf = 1;
      } else {
        {
#line 2928
        __cil_tmp320 = strcmp((char const   *)*args, (char const   *)((char *)"-a"));
        }
#line 2928
        if (__cil_tmp320 == 0) {
#line 2929
          af = 1;
        } else {
          {
#line 2930
          __cil_tmp321 = strcmp((char const   *)*args, (char const   *)((char *)"-d"));
          }
#line 2930
          if (__cil_tmp321 == 0) {
#line 2931
            df = 1;
          } else {
            {
#line 2932
            __cil_tmp322 = strcmp((char const   *)*args, (char const   *)((char *)"-m"));
            }
#line 2932
            if (__cil_tmp322 == 0) {
#line 2933
              mf = 1;
            } else {
              {
#line 2934
              __cil_tmp323 = strcmp((char const   *)*args, (char const   *)((char *)"--"));
              }
#line 2934
              if (__cil_tmp323 == 0) {
#line 2936
                args ++;
#line 2937
                goto while_break___34;
              } else {
                {
#line 2941
                Msg(0, (char *)"%s: bindkey: invalid option %s", rc_name, *args);
                }
#line 2942
                return;
              }
            }
          }
        }
      }
    }
  }
  while_break___34: /* CIL Label */ ;
  }
#line 2922
  args ++;
#line 2945
  if (df) {
#line 2945
    if (mf) {
      {
#line 2947
      Msg(0, (char *)"%s: bindkey: -d does not work with -m", rc_name);
      }
#line 2948
      goto switch_break;
    }
  }
#line 2950
  if (*args == (char *)0) {
#line 2952
    if (mf) {
      {
#line 2953
      display_bindkey((char *)"Edit mode", (struct action *)mmtab);
      }
    } else
#line 2954
    if (df) {
      {
#line 2955
      display_bindkey((char *)"Default", (struct action *)dmtab);
      }
    } else {
      {
#line 2957
      display_bindkey((char *)"User", (struct action *)umtab);
      }
    }
#line 2958
    goto switch_break;
  }
#line 2960
  if (kf == 0) {
#line 2962
    if (af) {
      {
#line 2964
      Msg(0, (char *)"%s: bindkey: -a only works with -k", rc_name);
      }
#line 2965
      goto switch_break;
    }
#line 2967
    i = 0;
    {
#line 2967
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 2967
      if (! (i < 50)) {
#line 2967
        goto while_break___35;
      }
#line 2968
      if (kmap_extras[i] == (char *)0) {
#line 2970
        if (*(args + 1)) {
#line 2971
          goto while_break___35;
        }
      } else {
        {
#line 2974
        __cil_tmp326 = strcmp((char const   *)kmap_extras[i], (char const   *)*args);
        }
#line 2974
        if (__cil_tmp326 == 0) {
#line 2975
          goto while_break___35;
        }
      }
    }
    while_break___35: /* CIL Label */ ;
    }
#line 2967
    i ++;
#line 2976
    if (i == 50) {
#line 2978
      if (*(args + 1)) {
#line 2978
        tmp___187 = (char *)"%s: bindkey: no more room for keybinding";
      } else {
#line 2978
        tmp___187 = (char *)"%s: bindkey: keybinding not found";
      }
      {
#line 2978
      Msg(0, tmp___187, rc_name);
      }
#line 2979
      goto switch_break;
    }
#line 2981
    if (df == 0) {
#line 2981
      if (dmtab[(i + 69) + 22].nr != -1) {
#line 2982
        used = 1;
      }
    }
#line 2983
    if (mf == 0) {
#line 2983
      if (mmtab[(i + 69) + 22].nr != -1) {
#line 2984
        used = 1;
      }
    }
#line 2985
    if (df) {
      _L___188: /* CIL Label */ 
#line 2985
      if (umtab[(i + 69) + 22].nr != -1) {
#line 2986
        used = 1;
      }
    } else
#line 2985
    if (mf) {
#line 2985
      goto _L___188;
    }
#line 2987
    i += 91;
  } else {
#line 2991
    i = 106;
    {
#line 2991
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 2991
      if (! (i < 175)) {
#line 2991
        goto while_break___36;
      }
      {
#line 2992
      __cil_tmp329 = strcmp((char const   *)term[i].tcname, (char const   *)*args);
      }
#line 2992
      if (__cil_tmp329 == 0) {
#line 2993
        goto while_break___36;
      }
    }
    while_break___36: /* CIL Label */ ;
    }
#line 2991
    i ++;
#line 2994
    if (i == 175) {
      {
#line 2996
      Msg(0, (char *)"%s: bindkey: unknown key \'%s\'", rc_name, *args);
      }
#line 2997
      goto switch_break;
    }
#line 2999
    if (af) {
#line 2999
      if (i >= 153) {
#line 2999
        if (i < 175) {
#line 3000
          i -= 84;
        } else {
#line 3002
          i -= 106;
        }
      } else {
#line 3002
        i -= 106;
      }
    } else {
#line 3002
      i -= 106;
    }
  }
#line 3004
  if (df) {
#line 3004
    tmp___190 = & dmtab[i];
  } else {
#line 3004
    if (mf) {
#line 3004
      tmp___189 = & mmtab[i];
    } else {
#line 3004
      tmp___189 = & umtab[i];
    }
#line 3004
    tmp___190 = tmp___189;
  }
#line 3004
  newact = tmp___190;
#line 3005
  if (*(args + 1)) {
    {
#line 3007
    newnr = FindCommnr(*(args + 1));
    }
#line 3007
    if (newnr == -1) {
      {
#line 3009
      Msg(0, (char *)"%s: bindkey: unknown command \'%s\'", rc_name, *(args + 1));
      }
#line 3010
      goto switch_break;
    }
    {
#line 3012
    __cil_tmp334 = CheckArgNum(newnr, args + 2);
    }
#line 3012
    if (__cil_tmp334 < 0) {
#line 3013
      goto switch_break;
    }
    {
#line 3014
    ClearAction(newact);
#line 3015
    newact->nr = newnr;
    }
#line 3016
    if (*(args + 2)) {
      {
#line 3017
      newact->args = SaveArgs(args + 2);
      }
    }
#line 3018
    if (kf == 0) {
#line 3018
      if (*(args + 1)) {
#line 3020
        if (kmap_extras[i - 91]) {
          {
#line 3021
          free((void *)kmap_extras[i - 91]);
          }
        }
        {
#line 3022
        kmap_extras[i - 91] = SaveStr((char const   *)*args);
#line 3023
        kmap_extras_fl[i - 91] = fl;
        }
      }
    }
  } else {
    {
#line 3027
    ClearAction(newact);
    }
  }
#line 3028
  display = displays;
  {
#line 3028
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 3028
    if (! display) {
#line 3028
      goto while_break___37;
    }
#line 3029
    if (*(args + 1)) {
#line 3029
      tmp___191 = 1;
    } else {
#line 3029
      tmp___191 = 0;
    }
    {
#line 3029
    remap(i, tmp___191);
    }
  }
  while_break___37: /* CIL Label */ ;
  }
#line 3028
  display = display->d_next;
#line 3030
  if (kf == 0) {
#line 3030
    if (! *(args + 1)) {
#line 3032
      i -= 91;
#line 3033
      if (! used) {
#line 3033
        if (kmap_extras[i]) {
          {
#line 3035
          free((void *)kmap_extras[i]);
#line 3036
          kmap_extras[i] = (char *)0;
#line 3037
          kmap_extras_fl[i] = 0;
          }
        }
      }
    }
  }
#line 3040
  display = odisp;
#line 3042
  goto switch_break;
  case_93: /* CIL Label */ 
#line 3044
  if (*args) {
    {
#line 3046
    __cil_tmp338 = ParseNum(act, & n);
    }
#line 3046
    if (__cil_tmp338) {
#line 3047
      goto switch_break;
    }
#line 3048
    if (n < 0) {
      {
      {
#line 3050
      Msg(0, (char *)"%s: maptimeout: illegal time %d", rc_name, n);
      }
      }
#line 3051
      goto switch_break;
    } else
#line 3048
    if (n >= 1000) {
      {
      {
#line 3050
      Msg(0, (char *)"%s: maptimeout: illegal time %d", rc_name, n);
      }
      }
#line 3051
      goto switch_break;
    }
#line 3053
    maptimeout = n * 1000;
  }
#line 3055
  if (*args == (char *)0) {
    {
    {
#line 3056
    Msg(0, (char *)"maptimeout is %dms", maptimeout / 1000);
    }
    }
  } else
#line 3055
  if (msgok) {
    {
    {
#line 3056
    Msg(0, (char *)"maptimeout is %dms", maptimeout / 1000);
    }
    }
  }
#line 3057
  goto switch_break;
  case_92: /* CIL Label */ 
#line 3059
  display->d_dontmap = 1;
#line 3060
  goto switch_break;
  case_91: /* CIL Label */ 
#line 3062
  display->d_mapdefault = 1;
#line 3063
  goto switch_break;
  case_24: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 3070
  UsersAcl((struct acluser *)((void *)0), argc, args);
  }
#line 3071
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3073
  __cil_tmp339 = UserDel(*(args + 0), (struct acluser **)((void *)0));
  }
#line 3073
  if (__cil_tmp339) {
#line 3074
    goto switch_break;
  }
#line 3075
  if (msgok) {
    {
#line 3076
    Msg(0, (char *)"%s removed from acl database", *(args + 0));
    }
  }
#line 3077
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3084
  if (*(args + 1)) {
    {
#line 3086
    __cil_tmp340 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"none"));
    }
#line 3086
    if (__cil_tmp340) {
      {
#line 3088
      __cil_tmp341 = AclLinkUser(*(args + 0), *(args + 1));
      }
#line 3088
      if (__cil_tmp341) {
#line 3089
        goto switch_break;
      }
#line 3090
      if (msgok) {
        {
#line 3091
        Msg(0, (char *)"User %s joined acl-group %s", *(args + 0), *(args + 1));
        }
      }
    } else {
      {
#line 3098
      u___0 = (struct acluser *)FindUserPtr(*(args + 0));
      }
#line 3098
      if (! u___0) {
#line 3099
        goto switch_break;
      }
      {
#line 3100
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 3100
        if (! g) {
#line 3100
          goto while_break___38;
        }
        {
#line 3102
        u___0->u_group = g->next;
#line 3103
        free((void *)((char *)g));
        }
      }
      while_break___38: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3109
    p___192 = (char *)buf___6;
#line 3110
    ngroups = 0;
#line 3114
    u___1 = (struct acluser *)FindUserPtr(*(args + 0));
    }
#line 3114
    if (! u___1) {
#line 3116
      if (msgok) {
        {
#line 3117
        Msg(0, (char *)"User %s does not exist.", *(args + 0));
        }
      }
#line 3118
      goto switch_break;
    }
#line 3120
    g___0 = u___1->u_group;
    {
#line 3121
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 3121
      if (! g___0) {
#line 3121
        goto while_break___39;
      }
      {
#line 3123
      ngroups ++;
#line 3124
      sprintf(p___192, (char const   *)((char *)"%s "), (char *)(g___0->u)->u_name);
#line 3125
      __cil_tmp352 = strlen((char const   *)p___192);
      }
#line 3125
      p___192 += __cil_tmp352;
#line 3126
      if (p___192 > (char *)buf___6 + 200) {
#line 3127
        goto while_break___39;
      }
#line 3128
      g___0 = g___0->next;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 3130
    if (ngroups) {
#line 3131
      p___192 --;
#line 3131
      *p___192 = (char )'\000';
    }
#line 3132
    if (ngroups == 1) {
#line 3132
      tmp___193 = (char *)"";
    } else {
#line 3132
      tmp___193 = (char *)"s";
    }
#line 3132
    if (ngroups == 0) {
#line 3132
      tmp___194 = (char *)"none";
    } else {
#line 3132
      tmp___194 = (char *)buf___6;
    }
    {
#line 3132
    Msg(0, (char *)"%s\'s group%s: %s.", *(args + 0), tmp___193, tmp___194);
    }
  }
#line 3135
  goto switch_break;
  case_152: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 3138
  while (1) {
    while_continue___40: /* CIL Label */ ;
#line 3138
    if (! s) {
#line 3138
      goto while_break___40;
    }
#line 3140
    err = (char *)0;
#line 3142
    if (display) {
#line 3142
      tmp___195 = display->d_user;
    } else {
#line 3142
      tmp___195 = users;
    }
    {
#line 3142
    __cil_tmp358 = AclUmask(tmp___195, s, & err);
    }
#line 3142
    if (__cil_tmp358) {
      {
#line 3143
      Msg(0, (char *)"umask: %s\n", err);
      }
    }
  }
  while_break___40: /* CIL Label */ ;
  }
#line 3145
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 3147
  __cil_tmp359 = ParseOnOff(act, & n);
  }
#line 3147
  if (__cil_tmp359) {
#line 3148
    goto switch_break;
  }
#line 3149
  if (n) {
#line 3149
    tmp___196 = (char *)"";
  } else {
#line 3149
    tmp___196 = (char *)0;
  }
  {
#line 3149
  multi = tmp___196;
#line 3150
  chsock();
  }
#line 3151
  if (msgok) {
#line 3152
    if (multi) {
#line 3152
      tmp___197 = (char *)"enabled";
    } else {
#line 3152
      tmp___197 = (char *)"disabled";
    }
    {
#line 3152
    Msg(0, (char *)"Multiuser mode %s", tmp___197);
    }
  }
#line 3153
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 3157
  winexec(args);
  }
#line 3158
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 3162
  __cil_tmp362 = ParseSwitch(act, & i);
  }
#line 3162
  if (! __cil_tmp362) {
#line 3162
    if (msgok) {
#line 3163
      if ((int )display->d_nonblock) {
#line 3163
        tmp___198 = (char *)"non";
      } else {
#line 3163
        tmp___198 = (char *)"";
      }
      {
#line 3163
      Msg(0, (char *)"display set to %sblocking mode.", tmp___198);
      }
    }
  }
#line 3164
  display->d_nonblock = (char )i;
#line 3165
  goto switch_break;
  case_71: /* CIL Label */ 
#line 3169
  if (fore->w_gr == 2) {
#line 3170
    fore->w_gr = 0;
  }
  {
#line 3172
  __cil_tmp364 = ParseSwitch(act, & fore->w_gr);
  }
#line 3172
  if (__cil_tmp364 == 0) {
#line 3172
    if (msgok) {
#line 3173
      if (fore->w_gr) {
#line 3173
        tmp___199 = (char *)"";
      } else {
#line 3173
        tmp___199 = (char *)"not ";
      }
      {
#line 3173
      Msg(0, (char *)"Will %suse GR", tmp___199);
      }
    }
  }
#line 3175
  if (fore->w_gr == 0) {
#line 3175
    if ((int )fore->w_FontE) {
#line 3176
      fore->w_gr = 2;
    }
  }
#line 3178
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 3180
  __cil_tmp366 = ParseSwitch(act, & fore->w_c1);
  }
#line 3180
  if (__cil_tmp366 == 0) {
#line 3180
    if (msgok) {
#line 3181
      if (fore->w_c1) {
#line 3181
        tmp___200 = (char *)"";
      } else {
#line 3181
        tmp___200 = (char *)"not ";
      }
      {
#line 3181
      Msg(0, (char *)"Will %suse C1", tmp___200);
      }
    }
  }
#line 3182
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 3185
  __cil_tmp368 = ParseSwitch(act, & fore->w_bce);
  }
#line 3185
  if (__cil_tmp368 == 0) {
#line 3185
    if (msgok) {
#line 3186
      if (fore->w_bce) {
#line 3186
        tmp___201 = (char *)"";
      } else {
#line 3186
        tmp___201 = (char *)"not ";
      }
      {
#line 3186
      Msg(0, (char *)"Will %serase with background color", tmp___201);
      }
    }
  }
#line 3187
  goto switch_break;
  case_64: /* CIL Label */ 
  case_82: /* CIL Label */ 
  {
#line 3193
  __cil_tmp370 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-d"));
  }
#line 3193
  if (*args) {
#line 3193
    if (! __cil_tmp370) {
#line 3195
      if (! *(args + 1)) {
#line 3196
        if (screenencodings) {
#line 3196
          tmp___202 = screenencodings;
        } else {
#line 3196
          tmp___202 = (char *)"<unset>";
        }
        {
#line 3196
        Msg(0, (char *)"encodings directory is %s", tmp___202);
        }
      } else {
        {
#line 3199
        free((void *)screenencodings);
#line 3200
        screenencodings = SaveStr((char const   *)*(args + 1));
        }
      }
#line 3202
      goto switch_break;
    }
  }
  {
#line 3204
  __cil_tmp373 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-l"));
  }
#line 3204
  if (*args) {
#line 3204
    if (! __cil_tmp373) {
#line 3206
      if (! *(args + 1)) {
        {
#line 3207
        Msg(0, (char *)"encoding: -l: argument required");
        }
      } else {
        {
#line 3208
        __cil_tmp374 = LoadFontTranslation(- 1, *(args + 1));
        }
#line 3208
        if (__cil_tmp374) {
          {
#line 3209
          Msg(0, (char *)"encoding: could not load utf8 encoding file");
          }
        } else
#line 3210
        if (msgok) {
          {
#line 3211
          Msg(0, (char *)"encoding: utf8 encoding file loaded");
          }
        }
      }
#line 3212
      goto switch_break;
    }
  }
#line 3222
  i = 0;
  {
#line 3222
  while (1) {
    while_continue___41: /* CIL Label */ ;
#line 3222
    if (! (i < 2)) {
#line 3222
      goto while_break___41;
    }
#line 3224
    if (*(args + i) == (char *)0) {
#line 3225
      goto while_break___41;
    }
    {
#line 3226
    __cil_tmp375 = strcmp((char const   *)*(args + i), (char const   *)((char *)"."));
    }
#line 3226
    if (! __cil_tmp375) {
#line 3227
      goto while_continue___41;
    }
    {
#line 3228
    n = FindEncoding(*(args + i));
    }
#line 3229
    if (n == -1) {
      {
#line 3231
      Msg(0, (char *)"encoding: unknown encoding \'%s\'", *(args + i));
      }
#line 3232
      goto while_break___41;
    }
#line 3234
    if (i == 0) {
#line 3234
      if (fore) {
        {
#line 3236
        WinSwitchEncoding(fore, n);
#line 3237
        ResetCharsets(fore);
        }
      } else {
#line 3234
        goto _L___203;
      }
    } else
    _L___203: /* CIL Label */ 
#line 3239
    if (i) {
#line 3239
      if (display) {
#line 3240
        display->d_encoding = n;
      }
    }
  }
  while_break___41: /* CIL Label */ ;
  }
#line 3222
  i ++;
#line 3242
  goto switch_break;
  case_40: /* CIL Label */ 
  case_45: /* CIL Label */ 
  {
#line 3245
  n = FindEncoding(*args);
  }
#line 3246
  if (n == -1) {
    {
#line 3248
    Msg(0, (char *)"defencoding: unknown encoding \'%s\'", *args);
    }
#line 3249
    goto switch_break;
  }
#line 3251
  nwin_default.encoding = n;
#line 3252
  goto switch_break;
  case_55: /* CIL Label */ 
#line 3257
  n = nwin_default.encoding == 8;
  {
#line 3258
  __cil_tmp379 = ParseSwitch(act, & n);
  }
#line 3258
  if (__cil_tmp379 == 0) {
#line 3260
    if (n) {
#line 3260
      tmp___204 = 8;
    } else {
#line 3260
      tmp___204 = 0;
    }
#line 3260
    nwin_default.encoding = tmp___204;
#line 3261
    if (msgok) {
#line 3262
      if (n) {
#line 3262
        tmp___205 = (char *)"";
      } else {
#line 3262
        tmp___205 = (char *)"not ";
      }
      {
#line 3262
      Msg(0, (char *)"Will %suse UTF-8 encoding for new windows", tmp___205);
      }
    }
  }
#line 3264
  goto switch_break;
  case_154: /* CIL Label */ 
#line 3266
  i = 0;
  {
#line 3266
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 3266
    if (! (i < 2)) {
#line 3266
      goto while_break___42;
    }
#line 3268
    if (i) {
#line 3268
      if (*(args + i) == (char *)0) {
#line 3269
        goto while_break___42;
      }
    }
#line 3270
    if (*(args + i) == (char *)0) {
#line 3271
      n = fore->w_layer.l_encoding != 8;
    } else {
      {
#line 3272
      __cil_tmp382 = strcmp((char const   *)*(args + i), (char const   *)((char *)"off"));
      }
#line 3272
      if (__cil_tmp382 == 0) {
#line 3273
        n = 0;
      } else {
        {
#line 3274
        __cil_tmp383 = strcmp((char const   *)*(args + i), (char const   *)((char *)"on"));
        }
#line 3274
        if (__cil_tmp383 == 0) {
#line 3275
          n = 1;
        } else {
          {
#line 3278
          Msg(0, (char *)"utf8: illegal argument (%s)", *(args + i));
          }
#line 3279
          goto while_break___42;
        }
      }
    }
#line 3281
    if (i == 0) {
#line 3283
      if (n) {
#line 3283
        tmp___206 = 8;
      } else {
#line 3283
        tmp___206 = 0;
      }
      {
#line 3283
      WinSwitchEncoding(fore, tmp___206);
      }
#line 3284
      if (msgok) {
#line 3285
        if (n) {
#line 3285
          tmp___207 = (char *)"";
        } else {
#line 3285
          tmp___207 = (char *)"not ";
        }
        {
#line 3285
        Msg(0, (char *)"Will %suse UTF-8 encoding", tmp___207);
        }
      }
    } else
#line 3287
    if (display) {
#line 3288
      if (n) {
#line 3288
        tmp___208 = 8;
      } else {
#line 3288
        tmp___208 = 0;
      }
#line 3288
      display->d_encoding = tmp___208;
    }
#line 3289
    if (*(args + i) == (char *)0) {
#line 3290
      goto while_break___42;
    }
  }
  while_break___42: /* CIL Label */ ;
  }
#line 3266
  i ++;
#line 3292
  goto switch_break;
  case_116: /* CIL Label */ 
#line 3296
  if (*args) {
#line 3298
    if (printcmd) {
      {
#line 3299
      free((void *)printcmd);
      }
    }
#line 3300
    printcmd = (char *)0;
#line 3301
    if (*(*args)) {
      {
#line 3302
      printcmd = SaveStr((char const   *)*args);
      }
    }
  }
#line 3304
  if (*args == (char *)0) {
    _L___209: /* CIL Label */ 
#line 3306
    if (printcmd) {
      {
#line 3307
      Msg(0, (char *)"using \'%s\' as print command", printcmd);
      }
    } else {
      {
#line 3309
      Msg(0, (char *)"using termcap entries for printing");
      }
    }
#line 3310
    goto switch_break;
  } else
#line 3304
  if (msgok) {
#line 3304
    goto _L___209;
  }
#line 3312
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 3315
  Input((char *)"Enter digraph: ", 10, 4, digraph_fn, (char *)((void *)0));
  }
#line 3316
  if (*args) {
#line 3316
    if ((int )*(*args)) {
      {
#line 3318
      s = *args;
#line 3319
      __cil_tmp389 = strlen((char const   *)s);
#line 3319
      n = (int )__cil_tmp389;
#line 3320
      ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 3322
  goto switch_break;
  case_44: /* CIL Label */ 
#line 3325
  if (*args == (char *)0) {
#line 3328
    *((char *)buf___7) = (char )0;
#line 3329
    if (nwin_default.hstatus) {
      {
#line 3330
      AddXChars((char *)buf___7, (int )sizeof(buf___7), nwin_default.hstatus);
      }
    }
    {
#line 3331
    Msg(0, (char *)"default hstatus is \'%s\'", (char *)buf___7);
    }
#line 3332
    goto switch_break;
  }
  {
#line 3334
  __cil_tmp391 = ParseSaveStr(act, & nwin_default.hstatus);
  }
#line 3335
  if ((int )*(nwin_default.hstatus) == 0) {
    {
#line 3337
    free((void *)nwin_default.hstatus);
#line 3338
    nwin_default.hstatus = (char *)0;
    }
  }
#line 3340
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 3342
  __cil_tmp392 = ParseSaveStr(act, & fore->w_hstatus);
  }
#line 3343
  if ((int )*(fore->w_hstatus) == 0) {
    {
#line 3345
    free((void *)fore->w_hstatus);
#line 3346
    fore->w_hstatus = (char *)0;
    }
  }
  {
#line 3348
  WindowChanged(fore, 'h');
  }
#line 3349
  goto switch_break;
  case_25: /* CIL Label */ 
  case_39: /* CIL Label */ 
#line 3354
  if (*args == (char *)0) {
#line 3357
    *((char *)buf___8) = (char )0;
#line 3358
    if (nwin_default.charset) {
      {
#line 3359
      AddXChars((char *)buf___8, (int )sizeof(buf___8), nwin_default.charset);
      }
    }
    {
#line 3360
    Msg(0, (char *)"default charset is \'%s\'", (char *)buf___8);
    }
#line 3361
    goto switch_break;
  }
  {
#line 3363
  __cil_tmp394 = strlen((char const   *)*args);
#line 3363
  n = (int )__cil_tmp394;
  }
#line 3364
  if (n == 0) {
    {
    {
#line 3366
    Msg(0, (char *)"%s: %s: string has illegal size.", rc_name, comms[nr].name);
    }
    }
#line 3367
    goto switch_break;
  } else
#line 3364
  if (n > 6) {
    {
    {
#line 3366
    Msg(0, (char *)"%s: %s: string has illegal size.", rc_name, comms[nr].name);
    }
    }
#line 3367
    goto switch_break;
  }
#line 3369
  if (n > 4) {
#line 3369
    if ((int )*(*(args + 0) + 4) < 48) {
      _L___212: /* CIL Label */ 
#line 3369
      if ((int )*(*(args + 0) + 4) != 46) {
        {
        {
#line 3373
        Msg(0, (char *)"%s: %s: illegal mapping number.", rc_name, comms[nr].name);
        }
        }
#line 3374
        goto switch_break;
      } else {
#line 3369
        goto _L___211;
      }
    } else
#line 3369
    if ((int )*(*(args + 0) + 4) > 51) {
#line 3369
      goto _L___212;
    } else
    _L___211: /* CIL Label */ 
#line 3369
    if ((int )*(*(args + 0) + 5) < 48) {
      _L___210: /* CIL Label */ 
#line 3369
      if ((int )*(*(args + 0) + 5)) {
#line 3369
        if ((int )*(*(args + 0) + 5) != 46) {
          {
          {
#line 3373
          Msg(0, (char *)"%s: %s: illegal mapping number.", rc_name, comms[nr].name);
          }
          }
#line 3374
          goto switch_break;
        }
      }
    } else
#line 3369
    if ((int )*(*(args + 0) + 5) > 51) {
#line 3369
      goto _L___210;
    }
  }
#line 3376
  if (nr == 25) {
    {
#line 3378
    SetCharsets(fore, *args);
    }
#line 3379
    goto switch_break;
  }
#line 3381
  if (nwin_default.charset) {
    {
#line 3382
    free((void *)nwin_default.charset);
    }
  }
  {
#line 3383
  nwin_default.charset = SaveStr((char const   *)*args);
  }
#line 3384
  goto switch_break;
  case_10: /* CIL Label */ 
#line 3388
  s = *(args + 0);
#line 3389
  if ((int )*s >= 48) {
#line 3389
    if ((int )*s <= 57) {
#line 3390
      i = (int )*s - 48;
    } else {
#line 3389
      goto _L___213;
    }
  } else {
    _L___213: /* CIL Label */ 
#line 3392
    i = 0;
    {
#line 3392
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 3392
      if (! (i < 8)) {
#line 3392
        goto while_break___43;
      }
#line 3393
      if ((int )*s == (int )*((char *)"dubrsBiI" + i)) {
#line 3394
        goto while_break___43;
      }
    }
    while_break___43: /* CIL Label */ ;
    }
#line 3392
    i ++;
  }
#line 3395
  s ++;
#line 3396
  nr = 0;
#line 3397
  if ((int )*s) {
#line 3397
    if ((int )*(s + 1)) {
#line 3397
      if (! *(s + 2)) {
#line 3399
        if ((int )*s == 100) {
#line 3399
          if ((int )*(s + 1) == 100) {
#line 3400
            nr = 3;
          } else {
#line 3399
            goto _L___216;
          }
        } else
        _L___216: /* CIL Label */ 
#line 3401
        if ((int )*s == 46) {
#line 3401
          if ((int )*(s + 1) == 100) {
#line 3402
            nr = 2;
          } else {
#line 3401
            goto _L___215;
          }
        } else
        _L___215: /* CIL Label */ 
#line 3403
        if ((int )*s == 100) {
#line 3403
          if ((int )*(s + 1) == 46) {
#line 3404
            nr = 1;
          } else {
#line 3403
            goto _L___214;
          }
        } else
        _L___214: /* CIL Label */ 
#line 3405
        if ((int )*s != 46) {
#line 3406
          __cil_tmp398 = s;
#line 3406
          s --;
        } else
#line 3405
        if ((int )*(s + 1) != 46) {
#line 3406
          __cil_tmp398 = s;
#line 3406
          s --;
        }
#line 3407
        s += 2;
      }
    }
  }
#line 3409
  if ((int )*s) {
    {
    {
    {
#line 3411
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
    }
    }
#line 3412
    goto switch_break;
  } else
#line 3409
  if (i < 0) {
    {
    {
    {
#line 3411
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
    }
    }
#line 3412
    goto switch_break;
  } else
#line 3409
  if (i >= 8) {
    {
    {
    {
#line 3411
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
    }
    }
#line 3412
    goto switch_break;
  }
#line 3414
  n = 0;
#line 3415
  if (*(args + 1)) {
    {
#line 3416
    n = ParseAttrColor(*(args + 1), *(args + 2), 1);
    }
  }
#line 3417
  if (n == -1) {
#line 3418
    goto switch_break;
  }
#line 3419
  attr2color[i][nr] = n;
#line 3420
  n = 0;
#line 3421
  i = 0;
  {
#line 3421
  while (1) {
    while_continue___44: /* CIL Label */ ;
#line 3421
    if (! (i < 8)) {
#line 3421
      goto while_break___44;
    }
#line 3422
    if (attr2color[i][0]) {
#line 3423
      n |= 1 << i;
    } else
#line 3422
    if (attr2color[i][1]) {
#line 3423
      n |= 1 << i;
    } else
#line 3422
    if (attr2color[i][2]) {
#line 3423
      n |= 1 << i;
    } else
#line 3422
    if (attr2color[i][3]) {
#line 3423
      n |= 1 << i;
    }
  }
  while_break___44: /* CIL Label */ ;
  }
#line 3421
  i ++;
#line 3424
  nattr2color = n;
#line 3425
  goto switch_break;
  case_139: /* CIL Label */ 
#line 3428
  i = 0;
#line 3429
  if (*args) {
    {
#line 3431
    i = ParseAttrColor(*args, *(args + 1), 1);
    }
#line 3432
    if (i == -1) {
#line 3433
      goto switch_break;
    }
    {
#line 3434
    ApplyAttrColor(i, & mchar_so);
    }
  }
#line 3436
  if (msgok) {
    {
#line 3438
    Msg(0, (char *)"Standout attributes 0x%02x  color 0x%02x", (int )mchar_so.attr,
        153 ^ (int )mchar_so.color);
    }
  }
#line 3442
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 3445
  do_source(*args);
  }
#line 3446
  goto switch_break;
  case_144: /* CIL Label */ 
#line 3450
  s = (char *)((void *)0);
#line 3451
  if (! *args) {
    {
#line 3453
    Msg(0, (char *)"%s:%s screen login", (char *)HostName, (char *)SockPath);
#line 3454
    InputSu(display->d_fore, & display->d_user, (char *)((void *)0));
    }
  } else
#line 3456
  if (! *(args + 1)) {
    {
#line 3457
    InputSu(display->d_fore, & display->d_user, *(args + 0));
    }
  } else
#line 3458
  if (! *(args + 2)) {
    {
#line 3459
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), (char *)"\377");
    }
  } else {
    {
#line 3461
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), *(args + 2));
    }
  }
#line 3462
  if (s) {
    {
#line 3463
    Msg(0, (char *)"%s", s);
    }
  }
#line 3464
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 3467
  AddCanvas();
  }
  {
#line 3468
  Activate(- 1);
  }
#line 3469
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 3471
  RemCanvas();
  }
  {
#line 3472
  Activate(- 1);
  }
#line 3473
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 3475
  OneCanvas();
  }
  {
#line 3476
  Activate(- 1);
  }
#line 3477
  goto switch_break;
  case_68: /* CIL Label */ 
#line 3479
  (display->d_forecv)->c_xoff = (display->d_forecv)->c_xs;
  {
#line 3480
  (display->d_forecv)->c_yoff = (display->d_forecv)->c_ys;
#line 3481
  RethinkViewportOffsets(display->d_forecv);
#line 3482
  ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
              ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
#line 3483
  flayer = (display->d_forecv)->c_layer;
#line 3484
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 3485
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 3487
  __cil_tmp404 = strcmp((char const   *)*args, (char const   *)((char *)"down"));
  }
#line 3487
  if (! *args) {
    _L___218: /* CIL Label */ 
#line 3488
    if ((display->d_forecv)->c_next) {
#line 3488
      tmp___217 = (display->d_forecv)->c_next;
    } else {
#line 3488
      tmp___217 = display->d_cvlist;
    }
#line 3488
    display->d_forecv = tmp___217;
  } else
#line 3487
  if (! __cil_tmp404) {
#line 3487
    goto _L___218;
  } else {
    {
#line 3489
    __cil_tmp406 = strcmp((char const   *)*args, (char const   *)((char *)"up"));
    }
#line 3489
    if (! __cil_tmp406) {
#line 3492
      cv = display->d_cvlist;
      {
#line 3492
      while (1) {
        while_continue___45: /* CIL Label */ ;
#line 3492
        if (! (cv->c_next && cv->c_next != display->d_forecv)) {
#line 3492
          goto while_break___45;
        }

      }
      while_break___45: /* CIL Label */ ;
      }
#line 3492
      cv = cv->c_next;
#line 3494
      display->d_forecv = cv;
    } else {
      {
#line 3496
      __cil_tmp408 = strcmp((char const   *)*args, (char const   *)((char *)"top"));
      }
#line 3496
      if (! __cil_tmp408) {
#line 3497
        display->d_forecv = display->d_cvlist;
      } else {
        {
#line 3498
        __cil_tmp409 = strcmp((char const   *)*args, (char const   *)((char *)"bottom"));
        }
#line 3498
        if (! __cil_tmp409) {
#line 3501
          cv___0 = display->d_cvlist;
          {
#line 3501
          while (1) {
            while_continue___46: /* CIL Label */ ;
#line 3501
            if (! cv___0->c_next) {
#line 3501
              goto while_break___46;
            }

          }
          while_break___46: /* CIL Label */ ;
          }
#line 3501
          cv___0 = cv___0->c_next;
#line 3503
          display->d_forecv = cv___0;
        } else {
          {
#line 3507
          Msg(0, (char *)"%s: usage: focus [up|down|top|bottom]", rc_name);
          }
#line 3508
          goto switch_break;
        }
      }
    }
  }
  {
#line 3510
  display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 3510
  fore = display->d_fore;
#line 3511
  flayer = (display->d_forecv)->c_layer;
#line 3519
  RefreshHStatus();
#line 3523
  flayer = (display->d_forecv)->c_layer;
#line 3524
  olddisplay___2 = display;
#line 3524
  oldflayer = flayer;
#line 3524
  l___1 = (display->d_forecv)->c_layer;
#line 3524
  cvlist = l___1->l_cvlist;
#line 3524
  cvlnext = (display->d_forecv)->c_lnext;
#line 3524
  flayer = l___1;
#line 3524
  l___1->l_cvlist = display->d_forecv;
#line 3524
  (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 3524
  ((void (*)(void))*((flayer->l_layfn)->lf_LayRestore))();
#line 3524
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 3524
  flayer = oldflayer;
#line 3524
  l___1->l_cvlist = cvlist;
#line 3524
  (display->d_forecv)->c_lnext = cvlnext;
#line 3524
  display = olddisplay___2;
#line 3525
  WindowChanged((struct win *)0, 'F');
  }
#line 3526
  goto switch_break;
  case_126: /* CIL Label */ 
#line 3528
  if (*args) {
    {
#line 3529
    ResizeRegions(*args);
    }
  } else {
    {
#line 3531
    Input((char *)"resize # lines: ", 20, 0, ResizeFin, (char *)0);
    }
  }
#line 3532
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 3534
  __cil_tmp416 = ParseSwitch(act, & separate_sids);
  }
#line 3535
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 3537
  while (1) {
    while_continue___47: /* CIL Label */ ;
#line 3537
    if (! *args) {
#line 3537
      goto while_break___47;
    }
    {
#line 3539
    __cil_tmp418 = SaveStr((char const   *)*args);
#line 3539
    ss___0 = __cil_tmp418;
#line 3540
    RcLine(ss___0);
#line 3541
    free((void *)ss___0);
    }
  }
  while_break___47: /* CIL Label */ ;
  }
#line 3537
  args ++;
#line 3543
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 3545
  __cil_tmp420 = ParseSwitch(act, & use_altscreen);
  }
#line 3546
  if (msgok) {
#line 3547
    if (use_altscreen) {
#line 3547
      tmp___219 = (char *)"";
    } else {
#line 3547
      tmp___219 = (char *)"not ";
    }
    {
#line 3547
    Msg(0, (char *)"Will %sdo alternate screen switching", tmp___219);
    }
  }
#line 3548
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 3550
  __cil_tmp422 = ParseNum(act, & n);
  }
#line 3550
  if (__cil_tmp422) {
#line 3551
    goto switch_break;
  }
#line 3552
  if (n < 1) {
    {
#line 3553
    Msg(0, (char *)"illegal maxwin number specified");
    }
  } else
#line 3554
  if (n > maxwin) {
    {
#line 3555
    Msg(0, (char *)"may only decrease maxwin number");
    }
  } else {
#line 3557
    maxwin = n;
  }
#line 3558
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 3560
  __cil_tmp423 = ParseBase(act, *args, & n, 10, (char *)"decimal");
  }
#line 3560
  if (__cil_tmp423) {
#line 3561
    goto switch_break;
  }
#line 3562
  if (! *(args + 1)) {
    {
#line 3563
    setbacktick(n, 0, 0, (char **)0);
    }
  } else {
#line 3567
    if (argc < 4) {
      {
#line 3569
      Msg(0, (char *)"%s: usage: backtick num [lifespan tick cmd args...]", rc_name);
      }
#line 3570
      goto switch_break;
    }
    {
#line 3572
    __cil_tmp426 = ParseBase(act, *(args + 1), & lifespan, 10, (char *)"decimal");
    }
#line 3572
    if (__cil_tmp426) {
#line 3573
      goto switch_break;
    }
    {
#line 3574
    __cil_tmp427 = ParseBase(act, *(args + 2), & tick, 10, (char *)"decimal");
    }
#line 3574
    if (__cil_tmp427) {
#line 3575
      goto switch_break;
    }
    {
#line 3576
    __cil_tmp428 = SaveArgs(args + 3);
#line 3576
    setbacktick(n, lifespan, tick, __cil_tmp428);
    }
  }
#line 3578
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 3584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3586
  if (display != odisplay) {
#line 3588
    display = displays;
    {
#line 3588
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 3588
      if (! display) {
#line 3588
        goto while_break___48;
      }
#line 3589
      if (display == odisplay) {
#line 3590
        goto while_break___48;
      }
    }
    while_break___48: /* CIL Label */ ;
    }
#line 3588
    display = display->d_next;
  }
}
}
#line 3595 "/tmp/screen-3.9.15/process.c"
void DoCommand(char **argv ) 
{ 
  struct action act ;

  {
  {
#line 3600
  act.nr = FindCommnr(*argv);
  }
#line 3600
  if (act.nr == -1) {
    {
#line 3602
    Msg(0, (char *)"%s: unknown command \'%s\'", rc_name, *argv);
    }
#line 3603
    return;
  }
  {
#line 3605
  act.args = argv + 1;
#line 3606
  DoAction(& act, - 1);
  }
}
}
#line 3610 "/tmp/screen-3.9.15/process.c"
static char **SaveArgs(char **args ) 
{ 
  register char **ap ;
  register char **pp ;
  register int argc ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  char **__cil_tmp8 ;
  char **__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 3614
  argc = 0;
  {
#line 3616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3616
    if (! *(args + argc)) {
#line 3616
      goto while_break;
    }
#line 3617
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3618
  __cil_tmp6 = malloc((unsigned long )((unsigned int )(argc + 1)) * sizeof(char **));
#line 3618
  ap = (char **)__cil_tmp6;
#line 3618
  pp = ap;
  }
#line 3618
  if (pp == (char **)0) {
    {
#line 3619
    Panic(0, (char *)strnomem);
    }
  }
  {
#line 3620
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3620
    if (! __cil_tmp7) {
#line 3620
      goto while_break___0;
    }
    {
#line 3621
    __cil_tmp9 = args;
#line 3621
    args ++;
#line 3621
    __cil_tmp10 = SaveStr((char const   *)*__cil_tmp9);
    }
#line 3621
    __cil_tmp8 = pp;
#line 3621
    pp ++;
#line 3621
    *__cil_tmp8 = __cil_tmp10;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3622
  *pp = (char *)0;
#line 3623
  return (ap);
}
}
#line 3636 "/tmp/screen-3.9.15/process.c"
int Parse(char *buf , char **args ) 
{ 
  register char *p ;
  register char **ap ;
  register char *pp ;
  register int delim ;
  register int argc ;
  char **__cil_tmp8 ;
  char **__cil_tmp10 ;
  char **__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 3639
  p = buf;
#line 3639
  ap = args;
#line 3642
  argc = 0;
  {
#line 3643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3643
    if (! 1) {
#line 3643
      goto while_break;
    }
    {
#line 3645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3645
      if (! ((int )*p && ((int )*p == 32 || (int )*p == 9))) {
#line 3645
        goto while_break___0;
      }
#line 3646
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3647
    if (argc == 0) {
      {
#line 3659
      if ((int )*p == '@') {
#line 3659
        goto case_64;
      }
#line 3673
      if ((int )*p == '|') {
#line 3673
        goto case_124;
      }
#line 3673
      if ((int )*p == '!') {
#line 3673
        goto case_124;
      }
#line 3657
      goto switch_break;
      case_64: /* CIL Label */ 
#line 3660
      __cil_tmp8 = ap;
#line 3660
      ap ++;
#line 3660
      *__cil_tmp8 = (char *)"at";
#line 3665
      if ((int )*(p + 1) == 35) {
#line 3666
        *p = (char )'\\';
      }
      {
#line 3667
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3667
        if (! ((int )*p == 32 || (int )*p == 9)) {
#line 3667
          goto while_break___1;
        }

      }
      while_break___1: /* CIL Label */ ;
      }
#line 3669
      argc ++;
#line 3670
      goto switch_break;
      case_124: /* CIL Label */ 
      case_33: /* CIL Label */ 
#line 3674
      __cil_tmp10 = ap;
#line 3674
      ap ++;
#line 3674
      *__cil_tmp10 = (char *)"exec";
#line 3675
      if ((int )*p == 33) {
#line 3676
        p ++;
      }
      {
#line 3677
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3677
        if (! ((int )*p == 32 || (int )*p == 9)) {
#line 3677
          goto while_break___2;
        }
#line 3678
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3679
      argc ++;
#line 3680
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3684
    if ((int )*p == 0) {
#line 3686
      *p = (char )'\000';
#line 3687
      *(args + argc) = (char *)0;
#line 3688
      return (argc);
    } else
#line 3684
    if ((int )*p == 35) {
#line 3686
      *p = (char )'\000';
#line 3687
      *(args + argc) = (char *)0;
#line 3688
      return (argc);
    }
#line 3690
    if ((int )*p == 92) {
#line 3690
      if ((int )*(p + 1) == 35) {
#line 3691
        p ++;
      }
    }
#line 3692
    argc ++;
#line 3692
    if (argc >= 64) {
      {
#line 3694
      Msg(0, (char *)"%s: too many tokens.", rc_name);
      }
#line 3695
      return (0);
    }
#line 3697
    delim = 0;
#line 3698
    pp = p;
#line 3698
    __cil_tmp15 = ap;
#line 3698
    ap ++;
#line 3698
    *__cil_tmp15 = pp;
    {
#line 3699
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3699
      if (! ((int )*p && (delim || ((int )*p != 32 && (int )*p != 9)))) {
#line 3699
        goto while_break___3;
      }
#line 3701
      if ((int )*p == delim) {
#line 3702
        delim = 0;
      } else
#line 3703
      if (! delim) {
#line 3703
        if ((int )*p == 34) {
#line 3704
          delim = (int )*p;
        } else
#line 3703
        if ((int )*p == 39) {
#line 3704
          delim = (int )*p;
        } else {
#line 3706
          __cil_tmp16 = pp;
#line 3706
          pp ++;
#line 3706
          *__cil_tmp16 = *p;
        }
      } else {
#line 3706
        __cil_tmp16 = pp;
#line 3706
        pp ++;
#line 3706
        *__cil_tmp16 = *p;
      }
#line 3707
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3709
    if ((int )*p == 0) {
#line 3711
      if (delim) {
        {
#line 3713
        Msg(0, (char *)"%s: Missing quote.", rc_name);
        }
#line 3714
        return (0);
      }
    } else {
#line 3718
      p ++;
    }
#line 3719
    *pp = (char )0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3724 "/tmp/screen-3.9.15/process.c"
int ParseEscape(struct acluser *u , char *p ) 
{ 
  unsigned char buf[2] ;
  int e ;
  int me ;

  {
#line 3731
  if ((int )*p == 0) {
#line 3732
    me = - 1;
#line 3732
    e = me;
  } else {
    {
#line 3735
    p = ParseChar(p, (char *)((unsigned char *)buf) + 1);
    }
    {
#line 3735
    p = ParseChar(p, (char *)((unsigned char *)buf));
    }
#line 3735
    if (p == (char *)((void *)0)) {
#line 3737
      return (- 1);
    } else
#line 3735
    if (p == (char *)((void *)0)) {
#line 3737
      return (- 1);
    } else
#line 3735
    if ((int )*p) {
#line 3737
      return (- 1);
    }
#line 3738
    e = (int )buf[0];
#line 3739
    me = (int )buf[1];
  }
#line 3741
  if (u) {
#line 3743
    u->u_Esc = e;
#line 3744
    u->u_MetaEsc = me;
  } else {
#line 3748
    if (users) {
#line 3750
      if (DefaultEsc >= 0) {
        {
#line 3751
        ClearAction(& ktab[DefaultEsc]);
        }
      }
#line 3752
      if (DefaultMetaEsc >= 0) {
        {
#line 3753
        ClearAction(& ktab[DefaultMetaEsc]);
        }
      }
    }
#line 3755
    DefaultEsc = e;
#line 3756
    DefaultMetaEsc = me;
#line 3757
    if (users) {
#line 3759
      if (DefaultEsc >= 0) {
        {
#line 3761
        ClearAction(& ktab[DefaultEsc]);
#line 3762
        ktab[DefaultEsc].nr = 107;
        }
      }
#line 3764
      if (DefaultMetaEsc >= 0) {
        {
#line 3766
        ClearAction(& ktab[DefaultMetaEsc]);
#line 3767
        ktab[DefaultMetaEsc].nr = 96;
        }
      }
    }
  }
#line 3771
  return (0);
}
}
#line 3775 "/tmp/screen-3.9.15/process.c"
int ParseSwitch(struct action *act , int *var ) 
{ 
  int __cil_tmp3 ;

  {
#line 3779
  if (*(act->args) == (char *)0) {
#line 3781
    *var ^= 1;
#line 3782
    return (0);
  }
  {
#line 3784
  __cil_tmp3 = ParseOnOff(act, var);
  }
#line 3784
  return (__cil_tmp3);
}
}
#line 3788 "/tmp/screen-3.9.15/process.c"
static int ParseOnOff(struct action *act , int *var ) 
{ 
  register int num ;
  char **args ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 3792
  num = - 1;
#line 3793
  args = act->args;
#line 3795
  if (*(args + 1) == (char *)0) {
    {
#line 3797
    __cil_tmp5 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"on"));
    }
#line 3797
    if (__cil_tmp5 == 0) {
#line 3798
      num = 1;
    } else {
      {
#line 3799
      __cil_tmp6 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"off"));
      }
#line 3799
      if (__cil_tmp6 == 0) {
#line 3800
        num = 0;
      }
    }
  }
#line 3802
  if (num < 0) {
    {
#line 3804
    Msg(0, (char *)"%s: %s: invalid argument. Give \'on\' or \'off\'", rc_name, comms[act->nr].name);
    }
#line 3805
    return (- 1);
  }
#line 3807
  *var = num;
#line 3808
  return (0);
}
}
#line 3812 "/tmp/screen-3.9.15/process.c"
int ParseSaveStr(struct action *act , char **var ) 
{ 
  char **args ;

  {
#line 3816
  args = act->args;
#line 3817
  if (*args == (char *)0) {
    {
    {
#line 3819
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
    }
#line 3820
    return (- 1);
  } else
#line 3817
  if (*(args + 1)) {
    {
    {
#line 3819
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
    }
#line 3820
    return (- 1);
  }
#line 3822
  if (*var) {
    {
#line 3823
    free((void *)*var);
    }
  }
  {
#line 3824
  *var = SaveStr((char const   *)*args);
  }
#line 3825
  return (0);
}
}
#line 3829 "/tmp/screen-3.9.15/process.c"
int ParseNum(struct action *act , int *var ) 
{ 
  int i ;
  char *p ;
  char **args ;

  {
#line 3834
  args = act->args;
#line 3836
  p = *args;
#line 3837
  if (p == (char *)0) {
    {
    {
    {
#line 3839
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
    }
    }
#line 3841
    return (- 1);
  } else
#line 3837
  if ((int )*p == 0) {
    {
    {
    {
#line 3839
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
    }
    }
#line 3841
    return (- 1);
  } else
#line 3837
  if (*(args + 1)) {
    {
    {
    {
#line 3839
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
    }
    }
#line 3841
    return (- 1);
  }
#line 3843
  i = 0;
  {
#line 3844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3844
    if (! *p) {
#line 3844
      goto while_break;
    }
#line 3846
    if ((int )*p >= 48) {
#line 3846
      if ((int )*p <= 57) {
#line 3847
        i = 10 * i + ((int )*p - 48);
      } else {
        {
        {
#line 3850
        Msg(0, (char *)"%s: %s: invalid argument. Give numeric argument.", rc_name,
            comms[act->nr].name);
        }
        }
#line 3852
        return (- 1);
      }
    } else {
      {
      {
#line 3850
      Msg(0, (char *)"%s: %s: invalid argument. Give numeric argument.", rc_name,
          comms[act->nr].name);
      }
      }
#line 3852
      return (- 1);
    }
#line 3854
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3856
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3857
  *var = i;
#line 3858
  return (0);
}
}
#line 3862 "/tmp/screen-3.9.15/process.c"
static struct win *WindowByName(char *s ) 
{ 
  struct win *p ;
  int __cil_tmp3 ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 3867
  p = windows;
  {
#line 3867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3867
    if (! p) {
#line 3867
      goto while_break;
    }
    {
#line 3868
    __cil_tmp3 = strcmp((char const   *)p->w_title, (char const   *)s);
    }
#line 3868
    if (! __cil_tmp3) {
#line 3869
      return (p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3867
  p = p->w_next;
#line 3870
  p = windows;
  {
#line 3870
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3870
    if (! p) {
#line 3870
      goto while_break___0;
    }
    {
#line 3871
    __cil_tmp4 = strlen((char const   *)s);
#line 3871
    __cil_tmp5 = strncmp((char const   *)p->w_title, (char const   *)s, __cil_tmp4);
    }
#line 3871
    if (! __cil_tmp5) {
#line 3872
      return (p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3870
  p = p->w_next;
#line 3873
  return ((struct win *)0);
}
}
#line 3877 "/tmp/screen-3.9.15/process.c"
static int WindowByNumber(char *str ) 
{ 
  int i ;
  char *s ;
  int tmp ;

  {
#line 3883
  s = str;
#line 3883
  i = 0;
  {
#line 3883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3883
    if (! *s) {
#line 3883
      goto while_break;
    }
#line 3885
    if ((int )*s < 48) {
#line 3886
      goto while_break;
    } else
#line 3885
    if ((int )*s > 57) {
#line 3886
      goto while_break;
    }
#line 3887
    i = i * 10 + ((int )*s - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 3883
  s ++;
#line 3889
  if ((int )*s) {
#line 3889
    tmp = - 1;
  } else {
#line 3889
    tmp = i;
  }
#line 3889
  return (tmp);
}
}
#line 3898 "/tmp/screen-3.9.15/process.c"
int WindowByNoN(char *str ) 
{ 
  int i ;
  struct win *p ;

  {
  {
#line 3904
  i = WindowByNumber(str);
  }
#line 3904
  if (i < 0) {
    _L: /* CIL Label */ 
    {
#line 3906
    p = WindowByName(str);
    }
#line 3906
    if (p) {
#line 3907
      return (p->w_number);
    }
#line 3908
    return (- 1);
  } else
#line 3904
  if (i >= 40) {
#line 3904
    goto _L;
  }
#line 3910
  return (i);
}
}
#line 3914 "/tmp/screen-3.9.15/process.c"
static int ParseWinNum(struct action *act , int *var ) 
{ 
  char **args ;
  int i ;

  {
#line 3918
  args = act->args;
#line 3919
  i = 0;
#line 3921
  if (*args == (char *)0) {
    {
    {
#line 3923
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
    }
#line 3924
    return (- 1);
  } else
#line 3921
  if (*(args + 1)) {
    {
    {
#line 3923
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
    }
#line 3924
    return (- 1);
  }
  {
#line 3927
  i = WindowByNoN(*args);
  }
#line 3928
  if (i < 0) {
    {
#line 3930
    Msg(0, (char *)"%s: %s: invalid argument. Give window number or name.", rc_name,
        comms[act->nr].name);
    }
#line 3932
    return (- 1);
  }
  {
#line 3934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3934
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3935
  *var = i;
#line 3936
  return (0);
}
}
#line 3940 "/tmp/screen-3.9.15/process.c"
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) 
{ 
  int i ;
  int c ;

  {
#line 3947
  i = 0;
#line 3950
  if ((int )*p == 0) {
    {
#line 3952
    Msg(0, (char *)"%s: %s: empty argument.", rc_name, comms[act->nr].name);
    }
#line 3953
    return (- 1);
  }
  {
#line 3955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3955
    if (! c) {
#line 3955
      goto while_break;
    }
#line 3957
    if (c >= 97) {
#line 3957
      if (c <= 122) {
#line 3958
        c -= 32;
      }
    }
#line 3959
    if (c >= 65) {
#line 3959
      if (c <= 90) {
#line 3960
        c -= 7;
      }
    }
#line 3961
    c -= '0';
#line 3962
    if (c < 0) {
      {
      {
#line 3964
      Msg(0, (char *)"%s: %s: argument is not %s.", rc_name, comms[act->nr].name,
          bname);
      }
      }
#line 3965
      return (- 1);
    } else
#line 3962
    if (c >= base) {
      {
      {
#line 3964
      Msg(0, (char *)"%s: %s: argument is not %s.", rc_name, comms[act->nr].name,
          bname);
      }
      }
#line 3965
      return (- 1);
    }
#line 3967
    i = base * i + c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3969
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3969
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3970
  *var = i;
#line 3971
  return (0);
}
}
#line 3982 "/tmp/screen-3.9.15/process.c"
static char *ParseChar(char *p , char *cp ) 
{ 
  char *__cil_tmp3 ;

  {
#line 3985
  if ((int )*p == 0) {
#line 3986
    return ((char *)0);
  }
#line 3987
  if ((int )*p == 94) {
#line 3987
    if ((int )*(p + 1)) {
#line 3989
      p ++;
#line 3989
      if ((int )*p == 63) {
#line 3990
        *cp = (char )'\177';
      } else
#line 3991
      if ((int )*p >= 64) {
#line 3992
        *cp = (char )((int )*p & 31);
      } else {
#line 3994
        return ((char *)0);
      }
#line 3995
      p ++;
    } else {
#line 3987
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3997
    p ++;
#line 3997
    if ((int )*p == 92) {
#line 3997
      if ((int )*p <= 55) {
#line 3997
        if ((int )*p >= 48) {
#line 3999
          *cp = (char )0;
          {
#line 4000
          while (1) {
            while_continue: /* CIL Label */ ;
#line 4001
            *cp = (char )(((int )*cp * 8 + (int )*p) - 48);
#line 4000
            if (! ((int )*p <= 55 && (int )*p >= 48)) {
#line 4000
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 4005
          __cil_tmp3 = p;
#line 4005
          p ++;
#line 4005
          *cp = *__cil_tmp3;
        }
      } else {
#line 4005
        __cil_tmp3 = p;
#line 4005
        p ++;
#line 4005
        *cp = *__cil_tmp3;
      }
    } else {
#line 4005
      __cil_tmp3 = p;
#line 4005
      p ++;
#line 4005
      *cp = *__cil_tmp3;
    }
  }
#line 4006
  return (p);
}
}
#line 4011 "/tmp/screen-3.9.15/process.c"
static int IsNum(char *s , int base ) 
{ 


  {
#line 4015
  base += '0';
  {
#line 4015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4015
    if (! *s) {
#line 4015
      goto while_break;
    }
#line 4016
    if ((int )*s < 48) {
#line 4017
      return (0);
    } else
#line 4016
    if ((int )*s > base) {
#line 4017
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4015
  s ++;
#line 4018
  return (1);
}
}
#line 4022 "/tmp/screen-3.9.15/process.c"
int IsNumColon(char *s , int base , char *p , int psize ) 
{ 
  char *q ;
  int __cil_tmp7 ;

  {
  {
#line 4027
  q = rindex((char const   *)s, ':');
  }
#line 4027
  if (q != (char *)0) {
    {
#line 4029
    strncpy(p, (char const   *)(q + 1), (unsigned long )(psize - 1));
#line 4030
    *(p + (psize - 1)) = (char )'\000';
#line 4031
    *q = (char )'\000';
    }
  } else {
#line 4034
    *p = (char )'\000';
  }
  {
#line 4035
  __cil_tmp7 = IsNum(s, base);
  }
#line 4035
  return (__cil_tmp7);
}
}
#line 4039 "/tmp/screen-3.9.15/process.c"
void SwitchWindow(int n ) 
{ 
  struct win *p ;
  int __cil_tmp3 ;

  {
  {
#line 4044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4044
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4045
  if (n < 0) {
    {
    {
#line 4047
    ShowWindows(- 1);
    }
    }
#line 4048
    return;
  } else
#line 4045
  if (n >= 40) {
    {
    {
#line 4047
    ShowWindows(- 1);
    }
    }
#line 4048
    return;
  }
#line 4050
  p = wtab[n];
#line 4050
  if (p == (struct win *)0) {
    {
#line 4052
    ShowWindows(n);
    }
#line 4053
    return;
  }
#line 4055
  if (display == (struct display *)0) {
#line 4057
    fore = p;
#line 4058
    return;
  }
#line 4060
  if (p == display->d_fore) {
    {
#line 4062
    Msg(0, (char *)"This IS window %d (%s).", n, p->w_title);
    }
#line 4063
    return;
  }
  {
#line 4066
  __cil_tmp3 = AclCheckPermWin(display->d_user, 2, p);
  }
#line 4066
  if (__cil_tmp3) {
    {
#line 4068
    Msg(0, (char *)"Access to window %d denied.", p->w_number);
    }
#line 4069
    return;
  }
  {
#line 4072
  SetForeWindow(p);
#line 4073
  Activate((int )fore->w_norefresh);
  }
}
}
#line 4078 "/tmp/screen-3.9.15/process.c"
void SetCanvasWindow(struct canvas *cv , struct win *wi ) 
{ 
  struct win *p ;
  struct win **pp ;
  struct layer *l ;
  struct canvas *cvp ;
  struct canvas **cvpp ;

  {
#line 4082
  p = (struct win *)0;
#line 4086
  l = cv->c_layer;
#line 4087
  display = cv->c_display;
#line 4089
  if (l) {
#line 4092
    cvpp = & l->l_cvlist;
    {
#line 4092
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4092
      if (! cvp) {
#line 4092
        goto while_break;
      }
#line 4093
      if (cvp == cv) {
#line 4094
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4092
    cvpp = & cvp->c_lnext;
    {
#line 4095
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4095
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4096
    *cvpp = cvp->c_lnext;
#line 4098
    p = (struct win *)(l->l_bottom)->l_data;
#line 4099
    l = cv->c_layer;
#line 4100
    cv->c_layer = (struct layer *)0;
#line 4102
    if (p) {
#line 4102
      if (cv == display->d_forecv) {
        {
#line 4105
        ReleaseAutoWritelock(display, p);
        }
#line 4107
        if (p->w_silence) {
          {
#line 4109
          SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 4110
          evenq(& p->w_silenceev);
          }
        }
#line 4112
        display->d_other = fore;
#line 4113
        display->d_fore = (struct win *)0;
      }
    }
#line 4115
    if (l->l_cvlist == (struct canvas *)0) {
#line 4115
      if (p == (struct win *)0) {
        {
        {
#line 4116
        KillLayerChain(l);
        }
        }
      } else
#line 4115
      if (l != p->w_savelayer) {
        {
        {
#line 4116
        KillLayerChain(l);
        }
        }
      }
    }
  }
#line 4120
  if (wi) {
#line 4122
    l = & wi->w_layer;
#line 4123
    if (wi->w_savelayer) {
#line 4123
      if (wi->w_blocked) {
#line 4124
        l = wi->w_savelayer;
      } else
#line 4123
      if ((wi->w_savelayer)->l_cvlist == (struct canvas *)0) {
#line 4124
        l = wi->w_savelayer;
      }
    }
  } else {
#line 4127
    l = & cv->c_blank;
  }
  {
#line 4130
  cv->c_lnext = l->l_cvlist;
#line 4131
  l->l_cvlist = cv;
#line 4132
  cv->c_layer = l;
#line 4133
  cv->c_xoff = cv->c_xs;
#line 4134
  cv->c_yoff = cv->c_ys;
#line 4135
  RethinkViewportOffsets(cv);
  }
#line 4137
  if (flayer == (struct layer *)0) {
#line 4138
    flayer = l;
  }
#line 4140
  if (wi) {
#line 4140
    if (display->d_other == wi) {
#line 4141
      display->d_other = wi->w_next;
    }
  }
#line 4142
  if (cv == display->d_forecv) {
#line 4144
    display->d_fore = wi;
#line 4145
    fore = display->d_fore;
#line 4146
    if (wi) {
      {
#line 4149
      ObtainAutoWritelock(display, wi);
#line 4154
      pp = & windows;
      }
      {
#line 4154
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4154
        if (! p) {
#line 4154
          goto while_break___1;
        }
#line 4155
        if (p == wi) {
#line 4156
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4154
      pp = & p->w_next;
      {
#line 4157
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4157
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 4158
      *pp = p->w_next;
#line 4159
      p->w_next = windows;
#line 4160
      windows = p;
    }
  }
}
}
#line 4171 "/tmp/screen-3.9.15/process.c"
void SetForeWindow(struct win *wi ) 
{ 
  struct win *p ;

  {
#line 4175
  if (display == (struct display *)0) {
#line 4177
    fore = wi;
#line 4178
    return;
  }
  {
#line 4180
  p = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 4181
  SetCanvasWindow(display->d_forecv, wi);
  }
#line 4182
  if (p) {
    {
#line 4183
    WindowChanged(p, 'u');
    }
  }
#line 4184
  if (wi) {
    {
#line 4185
    WindowChanged(wi, 'u');
    }
  }
#line 4186
  flayer = (display->d_forecv)->c_layer;
}
}
#line 4198 "/tmp/screen-3.9.15/process.c"
void Activate(int norefresh ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 4201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4201
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4202
  if (display == (struct display *)0) {
#line 4203
    return;
  }
#line 4204
  if (display->d_status) {
    {
#line 4206
    Msg(0, (char *)"%s", (char *)"");
#line 4207
    RemoveStatus();
    }
  }
  {
#line 4210
  __cil_tmp2 = MayResizeLayer((display->d_forecv)->c_layer);
  }
#line 4210
  if (__cil_tmp2) {
    {
#line 4211
    ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, display);
    }
  }
#line 4213
  fore = display->d_fore;
#line 4214
  if (fore) {
#line 4217
    if (fore->w_monitor != 0) {
#line 4218
      fore->w_monitor = 1;
    }
    {
#line 4219
    fore->w_bell = 0;
#line 4220
    WindowChanged(fore, 'f');
    }
  }
  {
#line 4231
  Redisplay(norefresh + all_norefresh);
  }
}
}
#line 4236 "/tmp/screen-3.9.15/process.c"
static int NextWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;

  {
#line 4239
  if (fore) {
#line 4239
    tmp = fore->w_number;
  } else {
#line 4239
    tmp = - 1;
  }
#line 4239
  n = tmp;
#line 4241
  pp = ((struct win **)wtab + n) + 1;
  {
#line 4241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4241
    if (! (pp != (struct win **)wtab + n)) {
#line 4241
      goto while_break;
    }
#line 4243
    if (pp == (struct win **)wtab + 40) {
#line 4244
      pp = (struct win **)wtab;
    }
#line 4245
    if (*pp) {
#line 4246
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4241
  pp ++;
#line 4248
  return ((int )(pp - (struct win **)wtab));
}
}
#line 4252 "/tmp/screen-3.9.15/process.c"
static int PreviousWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;
  struct win **__cil_tmp4 ;

  {
#line 4255
  if (fore) {
#line 4255
    tmp = fore->w_number;
  } else {
#line 4255
    tmp = 39;
  }
#line 4255
  n = tmp;
#line 4257
  pp = ((struct win **)wtab + n) - 1;
  {
#line 4257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4257
    if (! (pp != (struct win **)wtab + n)) {
#line 4257
      goto while_break;
    }
#line 4259
    if (pp < (struct win **)wtab) {
#line 4260
      pp = ((struct win **)wtab + 40) - 1;
    }
#line 4261
    if (*pp) {
#line 4262
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4257
  __cil_tmp4 = pp;
#line 4257
  pp --;
#line 4264
  return ((int )(pp - (struct win **)wtab));
}
}
#line 4268 "/tmp/screen-3.9.15/process.c"
static int MoreWindows(void) 
{ 
  char *m ;

  {
#line 4270
  m = (char *)"No other window.";
#line 4271
  if (windows) {
#line 4271
    if (fore == (struct win *)0) {
#line 4272
      return (1);
    } else
#line 4271
    if (windows->w_next) {
#line 4272
      return (1);
    }
  }
#line 4273
  if (fore == (struct win *)0) {
    {
#line 4275
    Msg(0, (char *)"No window available");
    }
#line 4276
    return (0);
  }
  {
#line 4278
  Msg(0, m, fore->w_number);
  }
#line 4279
  return (0);
}
}
#line 4283 "/tmp/screen-3.9.15/process.c"
void KillWindow(struct win *wi ) 
{ 
  struct win **pp ;
  struct win *p ;
  struct canvas *cv ;
  int gotone ;
  struct win *__cil_tmp6 ;

  {
#line 4293
  pp = & windows;
  {
#line 4293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4293
    if (! p) {
#line 4293
      goto while_break;
    }
#line 4294
    if (p == wi) {
#line 4295
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4293
  pp = & p->w_next;
  {
#line 4296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4296
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4297
  *pp = p->w_next;
#line 4298
  wi->w_inlen = 0;
#line 4299
  wtab[wi->w_number] = (struct win *)0;
#line 4301
  if (windows == (struct win *)0) {
    {
#line 4303
    FreeWindow(wi);
#line 4304
    Finit(0);
    }
  }
#line 4310
  display = displays;
  {
#line 4310
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4310
    if (! display) {
#line 4310
      goto while_break___1;
    }
#line 4312
    gotone = 0;
#line 4313
    cv = display->d_cvlist;
    {
#line 4313
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4313
      if (! cv) {
#line 4313
        goto while_break___2;
      }
#line 4315
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data != wi) {
#line 4316
        goto while_continue___2;
      }
      {
#line 4318
      __cil_tmp6 = FindNiceWindow(display->d_other, (char *)0);
#line 4318
      SetCanvasWindow(cv, __cil_tmp6);
#line 4319
      gotone = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4313
    cv = cv->c_next;
#line 4321
    if (gotone) {
      {
#line 4322
      Activate(- 1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4310
  display = display->d_next;
#line 4324
  FreeWindow(wi);
#line 4325
  WindowChanged((struct win *)0, 'w');
#line 4326
  WindowChanged((struct win *)0, 'W');
#line 4327
  WindowChanged((struct win *)0, 0);
  }
}
}
#line 4331 "/tmp/screen-3.9.15/process.c"
static void LogToggle(int on ) 
{ 
  char buf[1024] ;
  char *tmp ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;
  long __cil_tmp6 ;

  {
#line 4336
  if ((fore->w_log != (struct logfile *)0) == on) {
#line 4338
    if (display) {
#line 4338
      if (! *rc_name) {
#line 4339
        if (on) {
#line 4339
          tmp = (char *)"already";
        } else {
#line 4339
          tmp = (char *)"not";
        }
        {
#line 4339
        Msg(0, (char *)"You are %s logging.", tmp);
        }
      }
    }
#line 4340
    return;
  }
#line 4342
  if (fore->w_log != (struct logfile *)0) {
    {
#line 4344
    Msg(0, (char *)"Logfile \"%s\" closed.", (fore->w_log)->name);
#line 4345
    logfclose(fore->w_log);
#line 4346
    fore->w_log = (struct logfile *)0;
#line 4347
    WindowChanged(fore, 'f');
    }
#line 4348
    return;
  }
  {
#line 4350
  __cil_tmp4 = DoStartLog(fore, (char *)buf, (int )sizeof(buf));
  }
#line 4350
  if (__cil_tmp4) {
    {
#line 4352
    __cil_tmp5 = __errno_location();
#line 4352
    Msg(*__cil_tmp5, (char *)"Error opening logfile \"%s\"", (char *)buf);
    }
#line 4353
    return;
  }
  {
#line 4355
  __cil_tmp6 = ftell((fore->w_log)->fp);
  }
#line 4355
  if (__cil_tmp6 == 0L) {
    {
#line 4356
    Msg(0, (char *)"Creating logfile \"%s\".", (fore->w_log)->name);
    }
  } else {
    {
#line 4358
    Msg(0, (char *)"Appending to logfile \"%s\".", (fore->w_log)->name);
    }
  }
  {
#line 4359
  WindowChanged(fore, 'f');
  }
}
}
#line 4363 "/tmp/screen-3.9.15/process.c"
char *AddWindows(char *buf , int len , int flags , int where ) 
{ 
  register char *s ;
  register char *ss ;
  register struct win **pp ;
  register struct win *p ;
  register char *cmd ;
  struct win **tmp ;
  size_t __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  size_t __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp18 ;
  size_t __cil_tmp19 ;

  {
#line 4373
  ss = buf;
#line 4373
  s = ss;
#line 4374
  if (flags & 4 && where >= 0) {
#line 4374
    tmp = ((struct win **)wtab + where) + 1;
  } else {
#line 4374
    tmp = (struct win **)wtab;
  }
#line 4374
  pp = tmp;
  {
#line 4374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4374
    if (! (pp < (struct win **)wtab + 40)) {
#line 4374
      goto while_break;
    }
#line 4376
    if (pp - (struct win **)wtab == (long )where) {
#line 4376
      if (ss == buf) {
#line 4377
        ss = s;
      }
    }
#line 4378
    p = *pp;
#line 4378
    if (p == (struct win *)0) {
#line 4379
      goto while_continue;
    }
#line 4380
    if (flags & 1) {
#line 4380
      if (display) {
#line 4380
        if (p == display->d_fore) {
#line 4381
          goto while_continue;
        }
      }
    }
    {
#line 4383
    cmd = p->w_title;
#line 4384
    __cil_tmp11 = strlen((char const   *)cmd);
    }
#line 4384
    if ((unsigned long )(s - buf) + __cil_tmp11 > (unsigned long )(len - 24)) {
#line 4385
      goto while_break;
    }
#line 4386
    if (s > buf) {
      _L: /* CIL Label */ 
#line 4388
      __cil_tmp12 = s;
#line 4388
      s ++;
#line 4388
      *__cil_tmp12 = (char )' ';
#line 4389
      __cil_tmp13 = s;
#line 4389
      s ++;
#line 4389
      *__cil_tmp13 = (char )' ';
    } else
#line 4386
    if (flags & 4) {
#line 4386
      goto _L;
    }
    {
#line 4391
    sprintf(s, (char const   *)((char *)"%d"), p->w_number);
    }
#line 4392
    if (p->w_number == where) {
#line 4393
      ss = s;
    }
    {
#line 4394
    __cil_tmp14 = strlen((char const   *)s);
    }
#line 4394
    s += __cil_tmp14;
#line 4395
    if (display) {
#line 4395
      if (p == display->d_fore) {
#line 4396
        __cil_tmp15 = s;
#line 4396
        s ++;
#line 4396
        *__cil_tmp15 = (char )'*';
      }
    }
#line 4397
    if (! (flags & 2)) {
#line 4399
      if (display) {
#line 4399
        if (p == display->d_other) {
#line 4400
          __cil_tmp16 = s;
#line 4400
          s ++;
#line 4400
          *__cil_tmp16 = (char )'-';
        }
      }
      {
#line 4401
      s = AddWindowFlags(s, len, p);
      }
    }
    {
#line 4403
    __cil_tmp18 = s;
#line 4403
    s ++;
#line 4403
    *__cil_tmp18 = (char )' ';
#line 4404
    strcpy(s, (char const   *)cmd);
#line 4405
    __cil_tmp19 = strlen((char const   *)s);
    }
#line 4405
    s += __cil_tmp19;
  }
  while_break: /* CIL Label */ ;
  }
#line 4374
  pp ++;
#line 4407
  *s = (char )0;
#line 4408
  return (ss);
}
}
#line 4412 "/tmp/screen-3.9.15/process.c"
char *AddWindowFlags(char *buf , int len , struct win *p ) 
{ 
  char *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4417
  s = buf;
#line 4418
  if (p == (struct win *)0) {
#line 4420
    *s = (char )0;
#line 4421
    return (s);
  } else
#line 4418
  if (len < 12) {
#line 4420
    *s = (char )0;
#line 4421
    return (s);
  }
#line 4429
  if (p->w_layer.l_cvlist) {
#line 4429
    if ((p->w_layer.l_cvlist)->c_lnext) {
#line 4430
      __cil_tmp5 = s;
#line 4430
      s ++;
#line 4430
      *__cil_tmp5 = (char )'&';
    }
  }
#line 4431
  if (p->w_monitor == 3) {
#line 4432
    __cil_tmp6 = s;
#line 4432
    s ++;
#line 4432
    *__cil_tmp6 = (char )'@';
  }
#line 4433
  if (p->w_bell == 2) {
#line 4434
    __cil_tmp7 = s;
#line 4434
    s ++;
#line 4434
    *__cil_tmp7 = (char )'!';
  }
#line 4436
  if (p->w_slot != (slot_t )0) {
#line 4436
    if (p->w_slot != (slot_t )-1) {
#line 4437
      __cil_tmp8 = s;
#line 4437
      s ++;
#line 4437
      *__cil_tmp8 = (char )'$';
    }
  }
#line 4439
  if (p->w_log != (struct logfile *)0) {
    {
#line 4441
    strcpy(s, (char const   *)((char *)"(L)"));
#line 4442
    s += 3;
    }
  }
#line 4444
  if (p->w_ptyfd < 0) {
#line 4445
    __cil_tmp9 = s;
#line 4445
    s ++;
#line 4445
    *__cil_tmp9 = (char )'Z';
  }
#line 4446
  *s = (char )0;
#line 4447
  return (s);
}
}
#line 4451 "/tmp/screen-3.9.15/process.c"
char *AddOtherUsers(char *buf , int len , struct win *p ) 
{ 
  struct display *d ;
  struct display *olddisplay ;
  struct canvas *cv ;
  char *s ;
  int l ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 4456
  olddisplay = display;
#line 4461
  s = buf;
#line 4462
  display = displays;
  {
#line 4462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4462
    if (! display) {
#line 4462
      goto while_break;
    }
#line 4464
    if (display->d_user == olddisplay->d_user) {
#line 4465
      goto while_continue;
    }
#line 4466
    cv = display->d_cvlist;
    {
#line 4466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4466
      if (! cv) {
#line 4466
        goto while_break___0;
      }
#line 4467
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data == p) {
#line 4468
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4466
    cv = cv->c_next;
#line 4469
    if (! cv) {
#line 4470
      goto while_continue;
    }
#line 4471
    d = displays;
    {
#line 4471
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4471
      if (! (d && d != display)) {
#line 4471
        goto while_break___1;
      }
#line 4472
      if (display->d_user == d->d_user) {
#line 4473
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4471
    d = d->d_next;
#line 4474
    if (d) {
#line 4474
      if (d != display) {
#line 4475
        goto while_continue;
      }
    }
#line 4476
    if (len > 1) {
#line 4476
      if (s != buf) {
#line 4478
        __cil_tmp9 = s;
#line 4478
        s ++;
#line 4478
        *__cil_tmp9 = (char )',';
#line 4479
        __cil_tmp10 = len;
#line 4479
        len --;
      }
    }
    {
#line 4481
    __cil_tmp11 = strlen((char const   *)((char *)(display->d_user)->u_name));
#line 4481
    l = (int )__cil_tmp11;
    }
#line 4482
    if (l + 1 > len) {
#line 4483
      goto while_break;
    }
    {
#line 4484
    strcpy(s, (char const   *)((char *)(display->d_user)->u_name));
#line 4485
    s += l;
#line 4486
    len -= l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4462
  display = display->d_next;
#line 4488
  *s = (char )0;
#line 4489
  display = olddisplay;
#line 4490
  return (s);
}
}
#line 4494 "/tmp/screen-3.9.15/process.c"
void ShowWindows(int where ) 
{ 
  char buf[1024] ;
  char *s ;
  char *ss ;
  size_t __cil_tmp6 ;

  {
#line 4500
  if (! display) {
#line 4501
    return;
  }
#line 4502
  if (where == -1) {
#line 4502
    if (display->d_fore) {
#line 4503
      where = (display->d_fore)->w_number;
    }
  }
  {
#line 4504
  ss = AddWindows((char *)buf, (int )sizeof(buf), 0, where);
#line 4505
  __cil_tmp6 = strlen((char const   *)((char *)buf));
#line 4505
  s = (char *)buf + __cil_tmp6;
  }
#line 4506
  if (ss - (char *)buf > (long )(display->d_width / 2)) {
#line 4508
    ss -= display->d_width / 2;
#line 4509
    if (s - ss < (long )display->d_width) {
#line 4511
      ss = s - display->d_width;
#line 4512
      if (ss < (char *)buf) {
#line 4513
        ss = (char *)buf;
      }
    }
  } else {
#line 4517
    ss = (char *)buf;
  }
  {
#line 4518
  Msg(0, (char *)"%s", ss);
  }
}
}
#line 4522 "/tmp/screen-3.9.15/process.c"
static void ShowInfo(void) 
{ 
  char buf[512] ;
  char *p ;
  register struct win *wp ;
  register int i ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int tmp ;
  char *tmp___220 ;
  char *tmp___221 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 4525
  wp = fore;
#line 4528
  if (wp == (struct win *)0) {
    {
#line 4530
    Msg(0, (char *)"(%d,%d)/(%d,%d) no window", display->d_x + 1, display->d_y + 1,
        display->d_width, display->d_height);
    }
#line 4531
    return;
  }
  {
#line 4533
  p = (char *)buf;
#line 4534
  __cil_tmp5 = GetAnsiStatus(wp, p);
  }
#line 4534
  p += __cil_tmp5;
#line 4534
  if ((char *)buf < p) {
#line 4535
    __cil_tmp6 = p;
#line 4535
    p ++;
#line 4535
    *__cil_tmp6 = (char )' ';
  }
  {
#line 4536
  sprintf(p, (char const   *)((char *)"(%d,%d)/(%d,%d)"), wp->w_layer.l_x + 1, wp->w_layer.l_y + 1,
          wp->w_layer.l_width, wp->w_layer.l_height);
#line 4539
  __cil_tmp7 = strlen((char const   *)p);
  }
  {
#line 4539
  p += __cil_tmp7;
#line 4539
  sprintf(p, (char const   *)((char *)"+%d"), wp->w_histheight);
#line 4541
  __cil_tmp8 = strlen((char const   *)p);
  }
#line 4541
  p += __cil_tmp8;
#line 4541
  if (wp->w_flow & 1) {
#line 4541
    tmp = '+';
  } else {
#line 4541
    tmp = '-';
  }
#line 4541
  if (wp->w_flow & (1 << 2)) {
#line 4541
    tmp___221 = (char *)"";
  } else {
#line 4541
    if (wp->w_flow & (1 << 1)) {
#line 4541
      tmp___220 = (char *)"(+)";
    } else {
#line 4541
      tmp___220 = (char *)"(-)";
    }
#line 4541
    tmp___221 = tmp___220;
  }
  {
#line 4541
  sprintf(p, (char const   *)((char *)" %c%sflow"), tmp, tmp___221);
  }
#line 4545
  if (! wp->w_wrap) {
    {
#line 4545
    __cil_tmp12 = strlen((char const   *)p);
    }
    {
#line 4545
    p += __cil_tmp12;
#line 4545
    sprintf(p, (char const   *)((char *)" -wrap"));
    }
  }
#line 4546
  if (wp->w_insert) {
    {
#line 4546
    __cil_tmp13 = strlen((char const   *)p);
    }
    {
#line 4546
    p += __cil_tmp13;
#line 4546
    sprintf(p, (char const   *)((char *)" ins"));
    }
  }
#line 4547
  if (wp->w_origin) {
    {
#line 4547
    __cil_tmp14 = strlen((char const   *)p);
    }
    {
#line 4547
    p += __cil_tmp14;
#line 4547
    sprintf(p, (char const   *)((char *)" org"));
    }
  }
#line 4548
  if (wp->w_keypad) {
    {
#line 4548
    __cil_tmp15 = strlen((char const   *)p);
    }
    {
#line 4548
    p += __cil_tmp15;
#line 4548
    sprintf(p, (char const   *)((char *)" app"));
    }
  }
#line 4549
  if (wp->w_log) {
    {
#line 4549
    __cil_tmp16 = strlen((char const   *)p);
    }
    {
#line 4549
    p += __cil_tmp16;
#line 4549
    sprintf(p, (char const   *)((char *)" log"));
    }
  }
#line 4550
  if (wp->w_monitor != 0) {
    {
#line 4550
    __cil_tmp17 = strlen((char const   *)p);
    }
    {
#line 4550
    p += __cil_tmp17;
#line 4550
    sprintf(p, (char const   *)((char *)" mon"));
    }
  }
#line 4551
  if (wp->w_mouse) {
    {
#line 4551
    __cil_tmp18 = strlen((char const   *)p);
    }
    {
#line 4551
    p += __cil_tmp18;
#line 4551
    sprintf(p, (char const   *)((char *)" mouse"));
    }
  }
#line 4553
  if (wp->w_bce) {
    {
#line 4553
    __cil_tmp19 = strlen((char const   *)p);
    }
    {
#line 4553
    p += __cil_tmp19;
#line 4553
    sprintf(p, (char const   *)((char *)" bce"));
    }
  }
#line 4555
  if (! wp->w_c1) {
    {
#line 4555
    __cil_tmp20 = strlen((char const   *)p);
    }
    {
#line 4555
    p += __cil_tmp20;
#line 4555
    sprintf(p, (char const   *)((char *)" -c1"));
    }
  }
#line 4556
  if (wp->w_norefresh) {
    {
#line 4556
    __cil_tmp21 = strlen((char const   *)p);
    }
    {
#line 4556
    p += __cil_tmp21;
#line 4556
    sprintf(p, (char const   *)((char *)" nored"));
    }
  }
  {
#line 4558
  __cil_tmp22 = strlen((char const   *)p);
  }
  {
#line 4558
  p += __cil_tmp22;
#line 4561
  __cil_tmp23 = EncodingDefFont(wp->w_layer.l_encoding);
  }
#line 4561
  if (wp->w_layer.l_encoding) {
#line 4561
    if (display == (struct display *)0) {
      _L: /* CIL Label */ 
      {
#line 4563
      __cil_tmp24 = p;
#line 4563
      p ++;
#line 4563
      *__cil_tmp24 = (char )' ';
#line 4564
      __cil_tmp25 = EncodingName(wp->w_layer.l_encoding);
#line 4564
      strcpy(p, (char const   *)__cil_tmp25);
#line 4565
      __cil_tmp26 = strlen((char const   *)p);
      }
#line 4565
      p += __cil_tmp26;
    } else
#line 4561
    if (display->d_encoding != wp->w_layer.l_encoding) {
#line 4561
      goto _L;
    } else
#line 4561
    if (__cil_tmp23 <= 0) {
#line 4561
      goto _L;
    }
  }
#line 4568
  if (wp->w_layer.l_encoding != 8) {
#line 4571
    if (display->d_tcs[100].str) {
      _L___223: /* CIL Label */ 
#line 4573
      if (wp->w_gr == 2) {
        {
#line 4575
        sprintf(p, (char const   *)((char *)" G%c"), wp->w_Charset + 48);
        }
#line 4576
        if ((int )wp->w_FontE >= 32) {
#line 4577
          *(p + 3) = wp->w_FontE;
        } else {
#line 4580
          *(p + 3) = (char )'^';
#line 4581
          *(p + 4) = (char )((int )wp->w_FontE ^ 64);
#line 4582
          p ++;
        }
#line 4584
        *(p + 4) = (char )'[';
#line 4585
        p ++;
      } else
#line 4587
      if (wp->w_gr) {
        {
#line 4588
        __cil_tmp29 = p;
#line 4588
        p ++;
#line 4588
        sprintf(__cil_tmp29, (char const   *)((char *)" G%c%c["), wp->w_Charset + 48,
                wp->w_CharsetR + 48);
        }
      } else {
        {
#line 4590
        sprintf(p, (char const   *)((char *)" G%c["), wp->w_Charset + 48);
        }
      }
#line 4591
      p += 4;
#line 4592
      i = 0;
      {
#line 4592
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4592
        if (! (i < 4)) {
#line 4592
          goto while_break;
        }
#line 4594
        if (wp->w_charsets[i] == 0) {
#line 4595
          __cil_tmp30 = p;
#line 4595
          p ++;
#line 4595
          *__cil_tmp30 = (char )'B';
        } else
#line 4596
        if (wp->w_charsets[i] >= 32) {
#line 4597
          __cil_tmp31 = p;
#line 4597
          p ++;
#line 4597
          *__cil_tmp31 = (char )wp->w_charsets[i];
        } else {
#line 4600
          __cil_tmp32 = p;
#line 4600
          p ++;
#line 4600
          *__cil_tmp32 = (char )'^';
#line 4601
          __cil_tmp33 = p;
#line 4601
          p ++;
#line 4601
          *__cil_tmp33 = (char )(wp->w_charsets[i] ^ 64);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 4592
      i ++;
#line 4604
      __cil_tmp35 = p;
#line 4604
      p ++;
#line 4604
      *__cil_tmp35 = (char )']';
#line 4605
      *p = (char )0;
    } else
#line 4571
    if (display->d_tcs[98].str) {
#line 4571
      if ((int )*(display->d_tcs[98].str)) {
#line 4571
        goto _L___223;
      }
    }
  }
#line 4609
  if (wp->w_type == 1) {
    {
#line 4612
    __cil_tmp36 = p;
#line 4612
    p ++;
#line 4612
    *__cil_tmp36 = (char )' ';
#line 4613
    TtyGetModemStatus(wp->w_ptyfd, p);
    }
  }
  {
#line 4622
  Msg(0, (char *)"%s %d(%s)", (char *)buf, wp->w_number, wp->w_title);
  }
}
}
#line 4626 "/tmp/screen-3.9.15/process.c"
static void ShowDInfo(void) 
{ 
  char buf[512] ;
  char *p ;
  int __cil_tmp3 ;
  size_t __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 4629
  if (display == (struct display *)0) {
#line 4630
    return;
  }
  {
#line 4631
  p = (char *)buf;
#line 4632
  __cil_tmp4 = strlen((char const   *)p);
  }
#line 4632
  p += __cil_tmp4;
  {
#line 4632
  __cil_tmp3 = sprintf(p, (char const   *)((char *)"(%d,%d)"), display->d_width, display->d_height);
  }
#line 4635
  if (display->d_encoding) {
    {
#line 4637
    __cil_tmp5 = p;
#line 4637
    p ++;
#line 4637
    *__cil_tmp5 = (char )' ';
#line 4638
    __cil_tmp6 = EncodingName(display->d_encoding);
#line 4638
    strcpy(p, (char const   *)__cil_tmp6);
#line 4639
    __cil_tmp7 = strlen((char const   *)p);
    }
#line 4639
    p += __cil_tmp7;
  }
#line 4642
  if (display->d_tcs[96].flg) {
    {
#line 4644
    strcpy(p, (char const   *)((char *)" xterm"));
#line 4645
    __cil_tmp8 = strlen((char const   *)p);
    }
#line 4645
    p += __cil_tmp8;
  }
#line 4648
  if (display->d_hascolor) {
    {
#line 4650
    strcpy(p, (char const   *)((char *)" color"));
#line 4651
    __cil_tmp9 = strlen((char const   *)p);
    }
#line 4651
    p += __cil_tmp9;
  }
#line 4655
  if (display->d_tcs[97].flg) {
    {
#line 4657
    strcpy(p, (char const   *)((char *)" iso2022"));
#line 4658
    __cil_tmp10 = strlen((char const   *)p);
    }
#line 4658
    p += __cil_tmp10;
  } else
#line 4660
  if (display->d_tcs[98].str) {
#line 4660
    if ((int )*(display->d_tcs[98].str)) {
      {
#line 4662
      strcpy(p, (char const   *)((char *)" altchar"));
#line 4663
      __cil_tmp11 = strlen((char const   *)p);
      }
#line 4663
      p += __cil_tmp11;
    }
  }
  {
#line 4666
  Msg(0, (char *)"%s", (char *)buf);
  }
}
}
#line 4670 "/tmp/screen-3.9.15/process.c"
static void AKAfin(char *buf , int len , char *data ) 
{ 


  {
  {
#line 4675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4675
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4676
  if (len) {
#line 4676
    if (fore) {
      {
#line 4677
      ChangeAKA(fore, buf, 20);
      }
    }
  }
}
}
#line 4681 "/tmp/screen-3.9.15/process.c"
static void InputAKA(void) 
{ 
  char *s ;
  char *ss ;
  int n ;

  {
  {
#line 4685
  Input((char *)"Set window\'s title to: ", 20, 0, (void (*)(char * , int  , char * ))AKAfin,
        (char *)((void *)0));
#line 4686
  s = fore->w_title;
  }
#line 4687
  if (! s) {
#line 4688
    return;
  }
  {
#line 4689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4689
    if (! *s) {
#line 4689
      goto while_break;
    }
#line 4691
    if (((int )*((unsigned char *)s) & 127) < 32) {
#line 4692
      goto while_continue;
    } else
#line 4691
    if ((int )*s == 127) {
#line 4692
      goto while_continue;
    }
    {
#line 4693
    ss = s;
#line 4694
    n = 1;
#line 4695
    ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& ss, & n);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4689
  s ++;
}
}
#line 4700 "/tmp/screen-3.9.15/process.c"
static void Colonfin(char *buf , int len , char *data ) 
{ 


  {
#line 4705
  if (len) {
    {
#line 4706
    RcLine(buf);
    }
  }
}
}
#line 4710 "/tmp/screen-3.9.15/process.c"
static void SelectFin(char *buf , int len , char *data ) 
{ 
  int n ;

  {
#line 4717
  if (! len) {
#line 4718
    return;
  } else
#line 4717
  if (! display) {
#line 4718
    return;
  }
#line 4719
  if (len == 1) {
#line 4719
    if ((int )*buf == 45) {
      {
#line 4721
      SetForeWindow((struct win *)0);
#line 4722
      Activate(0);
      }
#line 4723
      return;
    }
  }
  {
#line 4725
  n = WindowByNoN(buf);
  }
#line 4725
  if (n < 0) {
#line 4726
    return;
  }
  {
#line 4727
  SwitchWindow(n);
  }
}
}
#line 4731 "/tmp/screen-3.9.15/process.c"
static void InputSelect(void) 
{ 


  {
  {
#line 4733
  Input((char *)"Switch to window: ", 20, 0, (void (*)(char * , int  , char * ))SelectFin,
        (char *)((void *)0));
  }
}
}
#line 4736
static char setenv_var[31] ;
#line 4740 "/tmp/screen-3.9.15/process.c"
static void SetenvFin1(char *buf , int len , char *data ) 
{ 


  {
#line 4745
  if (! len) {
#line 4746
    return;
  } else
#line 4745
  if (! display) {
#line 4746
    return;
  }
  {
#line 4747
  InputSetenv(buf);
  }
}
}
#line 4751 "/tmp/screen-3.9.15/process.c"
static void SetenvFin2(char *buf , int len , char *data ) 
{ 


  {
#line 4756
  if (! len) {
#line 4757
    return;
  } else
#line 4756
  if (! display) {
#line 4757
    return;
  }
  {
#line 4758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4758
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4759
  xsetenv((char *)setenv_var, buf);
#line 4760
  MakeNewEnv();
  }
}
}
#line 4764 "/tmp/screen-3.9.15/process.c"
static void InputSetenv(char *arg ) 
{ 
  static char setenv_buf[81] ;

  {
#line 4769
  if (arg) {
    {
#line 4771
    strncpy((char *)setenv_var, (char const   *)arg, sizeof(setenv_var) - 1UL);
#line 4772
    sprintf((char *)setenv_buf, (char const   *)((char *)"Enter value for %s: "),
            (char *)setenv_var);
#line 4773
    Input((char *)setenv_buf, 30, 0, (void (*)(char * , int  , char * ))SetenvFin2,
          (char *)((void *)0));
    }
  } else {
    {
#line 4776
    Input((char *)"Setenv: Enter variable name: ", 30, 0, (void (*)(char * , int  ,
                                                                    char * ))SetenvFin1,
          (char *)((void *)0));
    }
  }
}
}
#line 4787 "/tmp/screen-3.9.15/process.c"
void DoScreen(char *fn , char **av ) 
{ 
  struct NewWindow nwin ;
  register int num ;
  char buf[20] ;
  int __cil_tmp9 ;

  {
#line 4794
  nwin = nwin_undef;
  {
#line 4795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4795
    if (! ((av && *av) && (int )*(*(av + 0) + 0) == 45)) {
#line 4795
      goto while_break;
    }
#line 4797
    if ((int )*(*(av + 0) + 1) == 45) {
#line 4799
      av ++;
#line 4800
      goto while_break;
    }
    {
#line 4804
    if ((int )*(*(av + 0) + 1) == 'f') {
#line 4804
      goto case_102;
    }
#line 4808
    if ((int )*(*(av + 0) + 1) == '0') {
#line 4808
      goto case_48;
    }
#line 4808
    if ((int )*(*(av + 0) + 1) == 'n') {
#line 4808
      goto case_48;
    }
#line 4813
    if ((int )*(*(av + 0) + 1) == '\000') {
#line 4813
      goto case_0;
    }
#line 4813
    if ((int )*(*(av + 0) + 1) == '1') {
#line 4813
      goto case_0;
    }
#line 4813
    if ((int )*(*(av + 0) + 1) == 'y') {
#line 4813
      goto case_0;
    }
#line 4816
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 4816
      goto case_97;
    }
#line 4823
    if ((int )*(*(av + 0) + 1) == 't') {
#line 4823
      goto case_116;
    }
#line 4831
    if ((int )*(*(av + 0) + 1) == 'T') {
#line 4831
      goto case_84;
    }
#line 4839
    if ((int )*(*(av + 0) + 1) == 'h') {
#line 4839
      goto case_104;
    }
#line 4848
    if ((int )*(*(av + 0) + 1) == 'l') {
#line 4848
      goto case_108;
    }
#line 4852
    if ((int )*(*(av + 0) + 1) == '0') {
#line 4852
      goto case_48___0;
    }
#line 4852
    if ((int )*(*(av + 0) + 1) == 'n') {
#line 4852
      goto case_48___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 1) == '\000') {
#line 4857
      goto case_0___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 1) == '1') {
#line 4857
      goto case_0___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 1) == 'y') {
#line 4857
      goto case_0___0;
    }
#line 4860
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 4860
      goto case_97___0;
    }
#line 4868
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 4868
      goto case_97___1;
    }
#line 4871
    if ((int )*(*(av + 0) + 1) == 'M') {
#line 4871
      goto case_77;
    }
#line 4874
    if ((int )*(*(av + 0) + 1) == 'L') {
#line 4874
      goto case_76;
    }
#line 4877
    goto switch_default___1;
    case_102: /* CIL Label */ 
    {
#line 4808
    if ((int )*(*(av + 0) + 2) == '0') {
#line 4808
      goto case_48;
    }
#line 4808
    if ((int )*(*(av + 0) + 2) == 'n') {
#line 4808
      goto case_48;
    }
#line 4813
    if ((int )*(*(av + 0) + 2) == '\000') {
#line 4813
      goto case_0;
    }
#line 4813
    if ((int )*(*(av + 0) + 2) == '1') {
#line 4813
      goto case_0;
    }
#line 4813
    if ((int )*(*(av + 0) + 2) == 'y') {
#line 4813
      goto case_0;
    }
#line 4816
    if ((int )*(*(av + 0) + 2) == 'a') {
#line 4816
      goto case_97;
    }
#line 4819
    goto switch_default;
    case_48: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 4809
    nwin.flowflag = 0;
#line 4810
    goto switch_break___0;
    case_0: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 4814
    nwin.flowflag = 1;
#line 4815
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 4817
    nwin.flowflag = 1 << 2;
#line 4818
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 4820
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 4822
    goto switch_break;
    case_116: /* CIL Label */ 
#line 4824
    if (*(*(av + 0) + 2)) {
#line 4825
      nwin.aka = & *(*(av + 0) + 2);
    } else {
#line 4826
      av ++;
#line 4826
      if (*av) {
#line 4827
        nwin.aka = *av;
      } else {
#line 4829
        av --;
      }
    }
#line 4830
    goto switch_break;
    case_84: /* CIL Label */ 
#line 4832
    if (*(*(av + 0) + 2)) {
#line 4833
      nwin.term = & *(*(av + 0) + 2);
    } else {
#line 4834
      av ++;
#line 4834
      if (*av) {
#line 4835
        nwin.term = *av;
      } else {
#line 4837
        av --;
      }
    }
#line 4838
    goto switch_break;
    case_104: /* CIL Label */ 
#line 4840
    if (*(*(av + 0) + 2)) {
      {
#line 4841
      nwin.histheight = atoi((char const   *)(*(av + 0) + 2));
      }
    } else {
#line 4842
      av ++;
#line 4842
      if (*av) {
        {
#line 4843
        nwin.histheight = atoi((char const   *)*av);
        }
      } else {
#line 4845
        av --;
      }
    }
#line 4846
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 4852
    if ((int )*(*(av + 0) + 2) == '0') {
#line 4852
      goto case_48___0;
    }
#line 4852
    if ((int )*(*(av + 0) + 2) == 'n') {
#line 4852
      goto case_48___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 2) == '\000') {
#line 4857
      goto case_0___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 2) == '1') {
#line 4857
      goto case_0___0;
    }
#line 4857
    if ((int )*(*(av + 0) + 2) == 'y') {
#line 4857
      goto case_0___0;
    }
#line 4860
    if ((int )*(*(av + 0) + 2) == 'a') {
#line 4860
      goto case_97___0;
    }
#line 4863
    goto switch_default___0;
    case_48___0: /* CIL Label */ 
    case_110___0: /* CIL Label */ 
#line 4853
    nwin.lflag = 0;
#line 4854
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_121___0: /* CIL Label */ 
#line 4858
    nwin.lflag = 1;
#line 4859
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 4861
    nwin.lflag = 3;
#line 4862
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 4864
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 4866
    goto switch_break;
    case_97___1: /* CIL Label */ 
#line 4869
    nwin.aflag = 1;
#line 4870
    goto switch_break;
    case_77: /* CIL Label */ 
#line 4872
    nwin.monitor = 1;
#line 4873
    goto switch_break;
    case_76: /* CIL Label */ 
#line 4875
    nwin.Lflag = 1;
#line 4876
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 4878
    Msg(0, (char *)"%s: screen: invalid option -%c.", fn, (int )*(*(av + 0) + 1));
    }
#line 4879
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4881
    av ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4883
  num = 0;
#line 4884
  __cil_tmp9 = IsNumColon(*av, 10, (char *)buf, (int )sizeof(buf));
  }
#line 4884
  if (av) {
#line 4884
    if (*av) {
#line 4884
      if (__cil_tmp9) {
#line 4886
        if ((int )*((char *)buf) != 0) {
#line 4887
          nwin.aka = (char *)buf;
        }
        {
#line 4888
        num = atoi((char const   *)*av);
        }
#line 4889
        if (num < 0) {
          {
          {
#line 4891
          Msg(0, (char *)"%s: illegal screen number %d.", fn, num);
          }
#line 4892
          num = 0;
          }
        } else
#line 4889
        if (num > 39) {
          {
          {
#line 4891
          Msg(0, (char *)"%s: illegal screen number %d.", fn, num);
          }
#line 4892
          num = 0;
          }
        }
#line 4894
        nwin.StartAt = num;
#line 4895
        av ++;
      }
    }
  }
#line 4897
  if (av) {
#line 4897
    if (*av) {
#line 4899
      nwin.args = av;
#line 4900
      if (! nwin.aka) {
        {
#line 4901
        nwin.aka = Filename(*av);
        }
      }
    }
  }
  {
#line 4903
  MakeWindow(& nwin);
  }
}
}
#line 4917 "/tmp/screen-3.9.15/process.c"
int CompileKeys(char *s , unsigned char *array ) 
{ 
  int i ;
  unsigned char key ;
  unsigned char value ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4924
  if (! s) {
    _L: /* CIL Label */ 
#line 4926
    i = 0;
    {
#line 4926
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4926
      if (! (i < 256)) {
#line 4926
        goto while_break;
      }
#line 4927
      *(array + i) = (unsigned char )i;
    }
    while_break: /* CIL Label */ ;
    }
#line 4926
    i ++;
#line 4928
    return (0);
  } else
#line 4924
  if (! *s) {
#line 4924
    goto _L;
  }
  {
#line 4930
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4930
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4931
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4931
    if (! *s) {
#line 4931
      goto while_break___1;
    }
    {
#line 4933
    s = ParseChar(s, (char *)(& key));
    }
#line 4934
    if (! s) {
#line 4935
      return (- 1);
    } else
#line 4934
    if ((int )*s != 61) {
#line 4935
      return (- 1);
    }
    {
#line 4936
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 4938
      s ++;
#line 4938
      __cil_tmp8 = ParseChar(s, (char *)(& value));
#line 4938
      s = __cil_tmp8;
      }
#line 4939
      if (! s) {
#line 4940
        return (- 1);
      }
#line 4941
      *(array + value) = key;
#line 4936
      if (! ((int )*s == 61)) {
#line 4936
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4944
    if (! *s) {
#line 4945
      goto while_break___1;
    }
#line 4946
    __cil_tmp9 = s;
#line 4946
    s ++;
#line 4946
    if ((int )*__cil_tmp9 != 58) {
#line 4947
      return (- 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4949
  return (0);
}
}
#line 4959 "/tmp/screen-3.9.15/process.c"
static void pow_detach_fn(char *buf , int len , char *data ) 
{ 


  {
  {
#line 4964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4964
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4965
  if (len) {
#line 4967
    *buf = (char )0;
#line 4968
    return;
  }
#line 4970
  if (ktab[(int )((unsigned char )*buf)].nr != 113) {
#line 4972
    if (display) {
      {
#line 4973
      write(display->d_userfd, (void const   *)((char *)"\a"), (size_t )1);
      }
    }
    {
#line 4974
    Msg(0, (char *)"Detach aborted.");
    }
  } else {
    {
#line 4977
    Detach(3);
    }
  }
}
}
#line 4983 "/tmp/screen-3.9.15/process.c"
static void copy_reg_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;
  void *__cil_tmp5 ;

  {
#line 4988
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 4990
  if (len) {
#line 4992
    *buf = (char )0;
#line 4993
    return;
  }
#line 4995
  if (pp->buf) {
    {
#line 4996
    free((void *)pp->buf);
    }
  }
#line 4997
  pp->buf = (char *)0;
#line 4998
  pp->len = 0;
#line 4999
  if ((display->d_user)->u_plop.len) {
    {
#line 5001
    __cil_tmp5 = malloc((unsigned long )(display->d_user)->u_plop.len);
#line 5001
    pp->buf = (char *)__cil_tmp5;
    }
#line 5001
    if (pp->buf == (char *)((void *)0)) {
      {
#line 5003
      Msg(0, (char *)strnomem);
      }
#line 5004
      return;
    }
    {
#line 5006
    bcopy((void const   *)(display->d_user)->u_plop.buf, (void *)pp->buf, (size_t )(display->d_user)->u_plop.len);
    }
  }
  {
#line 5008
  pp->len = (display->d_user)->u_plop.len;
#line 5010
  pp->enc = (display->d_user)->u_plop.enc;
#line 5012
  Msg(0, (char *)"Copied %d characters into register %c", (display->d_user)->u_plop.len,
      (int )*buf);
  }
}
}
#line 5016 "/tmp/screen-3.9.15/process.c"
static void ins_reg_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 5021
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 5024
  if (! fore) {
#line 5025
    return;
  }
#line 5026
  if ((int )*buf == 46) {
    {
#line 5027
    Msg(0, (char *)"ins_reg_fn: Warning: pasting real register \'.\'!");
    }
  }
#line 5028
  if (len) {
#line 5030
    *buf = (char )0;
#line 5031
    return;
  }
#line 5033
  if (pp->buf) {
    {
#line 5035
    MakePaster(& fore->w_paster, pp->buf, pp->len, 0);
    }
#line 5036
    return;
  }
  {
#line 5038
  Msg(0, (char *)"Empty register.");
  }
}
}
#line 5043 "/tmp/screen-3.9.15/process.c"
static void process_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 5048
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 5050
  if (len) {
#line 5052
    *buf = (char )0;
#line 5053
    return;
  }
#line 5055
  if (pp->buf) {
    {
#line 5057
    ProcessInput(pp->buf, pp->len);
    }
#line 5058
    return;
  }
  {
#line 5060
  Msg(0, (char *)"Empty register.");
  }
}
}
#line 5064 "/tmp/screen-3.9.15/process.c"
static void confirm_fn(char *buf , int len , char *data ) 
{ 
  struct action act ;

  {
#line 5071
  if (len) {
#line 5073
    *buf = (char )0;
#line 5074
    return;
  } else
#line 5071
  if ((int )*buf != 121) {
#line 5071
    if ((int )*buf != 89) {
#line 5073
      *buf = (char )0;
#line 5074
      return;
    }
  }
  {
#line 5076
  act.nr = (int )data;
#line 5077
  act.args = (char **)noargs;
#line 5078
  DoAction(& act, - 1);
  }
}
}
#line 5091 "/tmp/screen-3.9.15/process.c"
static void su_fin(char *buf , int len , char *data ) 
{ 
  struct inputsu *i ;
  char *p ;
  int l ;
  int tmp ;

  {
#line 5096
  i = (struct inputsu *)data;
#line 5100
  if (! *((char *)i->name)) {
#line 5101
    p = (char *)i->name;
#line 5101
    l = (int )(sizeof(i->name) - 1UL);
  } else
#line 5102
  if (! *((char *)i->pw1)) {
    {
#line 5103
    p = (char *)i->pw1;
#line 5103
    strcpy(p, (char const   *)((char *)"\377"));
#line 5103
    l = (int )(sizeof(i->pw1) - 1UL);
    }
  } else {
    {
#line 5105
    p = (char *)i->pw2;
#line 5105
    strcpy(p, (char const   *)((char *)"\377"));
#line 5105
    l = (int )(sizeof(i->pw2) - 1UL);
    }
  }
#line 5106
  if (buf) {
#line 5106
    if (len) {
#line 5107
      if (1 + (l < len)) {
#line 5107
        tmp = l;
      } else {
#line 5107
        tmp = len;
      }
      {
#line 5107
      strncpy(p, (char const   *)buf, (unsigned long )tmp);
      }
    }
  }
#line 5108
  if (! *((char *)i->name)) {
    {
#line 5109
    Input((char *)"Screen User: ", (int )(sizeof(i->name) - 1UL), 0, (void (*)(char * ,
                                                                               int  ,
                                                                               char * ))su_fin,
          (char *)i);
    }
  } else
#line 5110
  if (! *((char *)i->pw1)) {
    {
#line 5111
    Input((char *)"User\'s UNIX Password: ", (int )(sizeof(i->pw1) - 1UL), 1, (void (*)(char * ,
                                                                                        int  ,
                                                                                        char * ))su_fin,
          (char *)i);
    }
  } else
#line 5112
  if (! *((char *)i->pw2)) {
    {
#line 5113
    Input((char *)"User\'s Screen Password: ", (int )(sizeof(i->pw2) - 1UL), 1, (void (*)(char * ,
                                                                                          int  ,
                                                                                          char * ))su_fin,
          (char *)i);
    }
  } else {
    {
#line 5116
    p = DoSu(i->up, (char *)i->name, (char *)i->pw2, (char *)i->pw1);
    }
#line 5116
    if (p) {
      {
#line 5117
      Msg(0, (char *)"%s", p);
      }
    }
    {
#line 5118
    free((void *)((char *)i));
    }
  }
}
}
#line 5123 "/tmp/screen-3.9.15/process.c"
static int InputSu(struct win *w , struct acluser **up , char *name ) 
{ 
  struct inputsu *i ;
  void *__cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
  {
#line 5130
  __cil_tmp5 = calloc((unsigned long )1, sizeof(struct inputsu ));
#line 5130
  i = (struct inputsu *)__cil_tmp5;
  }
#line 5130
  if (! i) {
#line 5131
    return (- 1);
  }
#line 5133
  i->up = up;
#line 5134
  if (name) {
#line 5134
    if ((int )*name) {
      {
#line 5135
      __cil_tmp6 = strlen((char const   *)name);
#line 5135
      su_fin(name, (int )__cil_tmp6, (char *)i);
      }
    } else {
      {
      {
#line 5137
      su_fin((char *)0, 0, (char *)i);
      }
      }
    }
  } else {
    {
    {
#line 5137
    su_fin((char *)0, 0, (char *)i);
    }
    }
  }
#line 5138
  return (0);
}
}
#line 5145 "/tmp/screen-3.9.15/process.c"
static void pass1(char *buf , int len , char *data ) 
{ 
  struct acluser *u ;
  size_t __cil_tmp6 ;

  {
#line 5150
  u = (struct acluser *)data;
#line 5152
  if (! *buf) {
#line 5153
    return;
  }
  {
#line 5154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5155
  if (u->u_password != (char *)NullStr) {
    {
#line 5156
    free((void *)u->u_password);
    }
  }
  {
#line 5157
  u->u_password = SaveStr((char const   *)buf);
#line 5158
  __cil_tmp6 = strlen((char const   *)buf);
#line 5158
  bzero((void *)buf, __cil_tmp6);
#line 5159
  Input((char *)"Retype new password:", 100, 1, pass2, data);
  }
}
}
#line 5163 "/tmp/screen-3.9.15/process.c"
static void pass2(char *buf , int len , char *data ) 
{ 
  int st ;
  char salt[3] ;
  struct acluser *u ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  time_t __cil_tmp10 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;

  {
#line 5170
  u = (struct acluser *)data;
  {
#line 5172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5173
  __cil_tmp7 = strcmp((char const   *)u->u_password, (char const   *)buf);
  }
#line 5173
  if (! buf) {
    _L: /* CIL Label */ 
    {
#line 5175
    Msg(0, (char *)"[ Passwords don\'t match - checking turned off ]");
    }
#line 5176
    if (u->u_password != (char *)NullStr) {
      {
#line 5178
      __cil_tmp8 = strlen((char const   *)u->u_password);
#line 5178
      bzero((void *)u->u_password, __cil_tmp8);
#line 5179
      free((void *)u->u_password);
      }
    }
#line 5181
    u->u_password = (char *)NullStr;
  } else
#line 5173
  if (__cil_tmp7) {
#line 5173
    goto _L;
  } else
#line 5183
  if ((int )*(u->u_password + 0) == 0) {
    {
#line 5185
    Msg(0, (char *)"[ No password - no secure ]");
    }
#line 5186
    if (buf) {
      {
#line 5187
      __cil_tmp9 = strlen((char const   *)buf);
#line 5187
      bzero((void *)buf, __cil_tmp9);
      }
    }
  }
#line 5190
  if (u->u_password != (char *)NullStr) {
#line 5192
    st = 0;
    {
#line 5192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5192
      if (! (st < 2)) {
#line 5192
        goto while_break___0;
      }
      {
#line 5193
      __cil_tmp10 = time((time_t *)0);
#line 5193
      salt[st] = (char )(65 + (int )((__cil_tmp10 >> 6 * st) % 26L));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 5192
    st ++;
#line 5194
    salt[2] = (char )0;
#line 5195
    buf = crypt(u->u_password, (char *)salt);
#line 5196
    __cil_tmp13 = strlen((char const   *)u->u_password);
#line 5196
    bzero((void *)u->u_password, __cil_tmp13);
#line 5197
    free((void *)u->u_password);
#line 5198
    u->u_password = SaveStr((char const   *)buf);
#line 5199
    __cil_tmp15 = strlen((char const   *)buf);
#line 5199
    bzero((void *)buf, __cil_tmp15);
    }
#line 5201
    if (u->u_plop.buf) {
      {
#line 5202
      UserFreeCopyBuffer(u);
      }
    }
    {
#line 5203
    __cil_tmp16 = strlen((char const   *)u->u_password);
#line 5203
    u->u_plop.len = (int )__cil_tmp16;
#line 5205
    u->u_plop.enc = 0;
#line 5207
    u->u_plop.buf = SaveStr((char const   *)u->u_password);
    }
#line 5207
    if (! u->u_plop.buf) {
      {
#line 5209
      Msg(0, (char *)strnomem);
#line 5210
      (display->d_user)->u_plop.len = 0;
      }
    } else {
      {
#line 5213
      Msg(0, (char *)"[ Password moved into copybuffer ]");
      }
    }
  }
}
}
#line 5222 "/tmp/screen-3.9.15/process.c"
static void digraph_fn(char *buf , int len , char *data ) 
{ 
  int ch ;
  int i ;
  int x ;
  int tmp ;

  {
#line 5229
  ch = (int )*(buf + len);
#line 5230
  if (ch) {
#line 5232
    if (ch < 32) {
#line 5233
      return;
    } else
#line 5232
    if (ch == 127) {
#line 5233
      return;
    }
#line 5234
    if (len >= 1) {
#line 5234
      if ((int )*buf == 85) {
#line 5234
        if ((int )*(buf + 1) == 43) {
          _L___225: /* CIL Label */ 
#line 5236
          if (len == 1) {
#line 5237
            return;
          }
#line 5238
          if (ch < 48) {
            _L___224: /* CIL Label */ 
#line 5238
            if (ch < 97) {
              _L: /* CIL Label */ 
#line 5238
              if (ch < 65) {
#line 5240
                *(buf + len) = (char )'\034';
#line 5241
                return;
              } else
#line 5238
              if (ch > 70) {
#line 5240
                *(buf + len) = (char )'\034';
#line 5241
                return;
              }
            } else
#line 5238
            if (ch > 102) {
#line 5238
              goto _L;
            }
          } else
#line 5238
          if (ch > 57) {
#line 5238
            goto _L___224;
          }
#line 5243
          if ((int )*buf == 85) {
#line 5243
            tmp = 5;
          } else {
#line 5243
            tmp = 3;
          }
#line 5243
          if (len == tmp) {
#line 5244
            *(buf + len) = (char )'\n';
          }
#line 5245
          return;
        } else {
#line 5234
          goto _L___226;
        }
      } else
      _L___226: /* CIL Label */ 
#line 5234
      if ((int )*buf == 48) {
#line 5234
        if ((int )*(buf + 1) == 120) {
#line 5234
          goto _L___225;
        } else
#line 5234
        if ((int )*(buf + 1) == 88) {
#line 5234
          goto _L___225;
        }
      }
    }
#line 5247
    if (len) {
#line 5247
      if ((int )*buf == 48) {
#line 5249
        if (ch < 48) {
#line 5251
          *(buf + len) = (char )'\034';
#line 5252
          return;
        } else
#line 5249
        if (ch > 55) {
#line 5251
          *(buf + len) = (char )'\034';
#line 5252
          return;
        }
#line 5254
        if (len == 3) {
#line 5255
          *(buf + len) = (char )'\n';
        }
#line 5256
        return;
      }
    }
#line 5258
    if (len == 1) {
#line 5259
      *(buf + len) = (char )'\n';
    }
#line 5260
    return;
  }
#line 5262
  *(buf + len) = *(buf + (len + 1));
#line 5263
  len ++;
#line 5264
  if (len < 2) {
#line 5265
    return;
  }
#line 5266
  if (len >= 1) {
#line 5266
    if ((int )*buf == 85) {
#line 5266
      if ((int )*(buf + 1) == 43) {
        _L___231: /* CIL Label */ 
#line 5268
        x = 0;
#line 5269
        i = 2;
        {
#line 5269
        while (1) {
          while_continue: /* CIL Label */ ;
#line 5269
          if (! (i < len)) {
#line 5269
            goto while_break;
          }
#line 5271
          if ((int )*(buf + i) >= 48) {
#line 5271
            if ((int )*(buf + i) <= 57) {
#line 5272
              x = x * 16 | ((int )*(buf + i) - 48);
            } else {
#line 5271
              goto _L___228;
            }
          } else
          _L___228: /* CIL Label */ 
#line 5273
          if ((int )*(buf + i) >= 97) {
#line 5273
            if ((int )*(buf + i) <= 102) {
#line 5274
              x = x * 16 | ((int )*(buf + i) - 87);
            } else {
#line 5273
              goto _L___227;
            }
          } else
          _L___227: /* CIL Label */ 
#line 5275
          if ((int )*(buf + i) >= 65) {
#line 5275
            if ((int )*(buf + i) <= 70) {
#line 5276
              x = x * 16 | ((int )*(buf + i) - 55);
            } else {
#line 5278
              goto while_break;
            }
          } else {
#line 5278
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 5269
        i ++;
      } else {
#line 5266
        goto _L___232;
      }
    } else
    _L___232: /* CIL Label */ 
#line 5266
    if ((int )*buf == 48) {
#line 5266
      if ((int )*(buf + 1) == 120) {
#line 5266
        goto _L___231;
      } else
#line 5266
      if ((int )*(buf + 1) == 88) {
#line 5266
        goto _L___231;
      } else {
#line 5266
        goto _L___230;
      }
    } else {
#line 5266
      goto _L___230;
    }
  } else
  _L___230: /* CIL Label */ 
#line 5281
  if ((int )*(buf + 0) == 48) {
#line 5283
    x = 0;
#line 5284
    i = 1;
    {
#line 5284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5284
      if (! (i < len)) {
#line 5284
        goto while_break___0;
      }
#line 5286
      if ((int )*(buf + i) < 48) {
#line 5287
        goto while_break___0;
      } else
#line 5286
      if ((int )*(buf + i) > 55) {
#line 5287
        goto while_break___0;
      }
#line 5288
      x = x * 8 | ((int )*(buf + i) - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5284
    i ++;
  } else {
#line 5293
    i = 0;
    {
#line 5293
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5293
      if (! ((unsigned long )i < sizeof(digraphs) / sizeof(*((unsigned char const   (*)[3])digraphs)))) {
#line 5293
        goto while_break___1;
      }
#line 5294
      if ((int )((unsigned char )digraphs[i][0]) == (int )((unsigned char )*(buf + 0))) {
#line 5294
        if ((int )((unsigned char )digraphs[i][1]) == (int )((unsigned char )*(buf + 1))) {
#line 5296
          goto while_break___1;
        } else {
#line 5294
          goto _L___229;
        }
      } else
      _L___229: /* CIL Label */ 
#line 5294
      if ((int )((unsigned char )digraphs[i][0]) == (int )((unsigned char )*(buf + 1))) {
#line 5294
        if ((int )((unsigned char )digraphs[i][1]) == (int )((unsigned char )*(buf + 0))) {
#line 5296
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5293
    i ++;
#line 5297
    if ((unsigned long )i == sizeof(digraphs) / sizeof(*((unsigned char const   (*)[3])digraphs))) {
      {
#line 5299
      Msg(0, (char *)"Unknown digraph");
      }
#line 5300
      return;
    }
#line 5302
    x = (int )((unsigned char )digraphs[i][2]);
  }
#line 5304
  i = 1;
#line 5305
  *buf = (char )x;
#line 5307
  if (flayer->l_encoding == 8) {
    {
#line 5308
    i = ToUtf8(buf, x);
    }
  }
  {
#line 5310
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5310
    if (! i) {
#line 5310
      goto while_break___2;
    }
    {
#line 5311
    ((void (*)(char ** , int * ))*((flayer->l_layfn)->lf_LayProcess))(& buf, & i);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 5316 "/tmp/screen-3.9.15/process.c"
static int StuffKey(int i ) 
{ 
  struct action *act ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 5321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5326
  if (i >= 47) {
#line 5326
    if (i < 51) {
#line 5326
      if (display->d_cursorkeys) {
#line 5327
        i += 22;
      } else {
#line 5326
        goto _L;
      }
    } else {
#line 5326
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5328
  if (i >= 51) {
#line 5328
    if (i < 69) {
#line 5328
      if (display->d_keypad) {
#line 5329
        i += 22;
      }
    }
  }
  {
#line 5330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5330
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5331
  flayer = (display->d_forecv)->c_layer;
#line 5332
  fore = display->d_fore;
#line 5333
  act = (struct action *)0;
#line 5335
  __cil_tmp5 = InWList();
  }
  {
#line 5335
  __cil_tmp4 = InInput();
  }
  {
#line 5335
  __cil_tmp3 = InMark();
  }
#line 5335
  if (__cil_tmp3) {
#line 5336
    act = & mmtab[i];
  } else
#line 5335
  if (__cil_tmp4) {
#line 5336
    act = & mmtab[i];
  } else
#line 5335
  if (__cil_tmp5) {
#line 5336
    act = & mmtab[i];
  }
#line 5338
  if (! act) {
    _L___234: /* CIL Label */ 
#line 5338
    if (! display->d_mapdefault) {
#line 5339
      act = & umtab[i];
    }
  } else
#line 5338
  if (act->nr == -1) {
#line 5338
    goto _L___234;
  }
#line 5340
  display->d_mapdefault = 0;
#line 5341
  if (! act) {
#line 5342
    act = & dmtab[i];
  } else
#line 5341
  if (act->nr == -1) {
#line 5342
    act = & dmtab[i];
  }
#line 5343
  if (act == (struct action *)0) {
#line 5344
    return (- 1);
  } else
#line 5343
  if (act->nr == -1) {
#line 5344
    return (- 1);
  }
  {
#line 5345
  DoAction(act, 0);
  }
#line 5346
  return (0);
}
}
#line 5352 "/tmp/screen-3.9.15/process.c"
static int IsOnDisplay(struct win *wi ) 
{ 
  struct canvas *cv ;

  {
  {
#line 5356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5356
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5357
  cv = display->d_cvlist;
  {
#line 5357
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5357
    if (! cv) {
#line 5357
      goto while_break___0;
    }
#line 5358
    if ((struct win *)((cv->c_layer)->l_bottom)->l_data == wi) {
#line 5359
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5357
  cv = cv->c_next;
#line 5360
  return (0);
}
}
#line 5364 "/tmp/screen-3.9.15/process.c"
struct win *FindNiceWindow(struct win *wi , char *presel ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 5370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5371
  if (presel) {
    {
#line 5373
    i = WindowByNoN(presel);
    }
#line 5374
    if (i >= 0) {
#line 5375
      wi = wtab[i];
    }
  }
#line 5377
  if (! display) {
#line 5378
    return (wi);
  }
  {
#line 5380
  __cil_tmp5 = AclCheckPermWin(display->d_user, 2, wi);
  }
#line 5380
  if (wi) {
#line 5380
    if (__cil_tmp5) {
#line 5381
      wi = (struct win *)0;
    }
  }
  {
#line 5383
  __cil_tmp6 = IsOnDisplay(wi);
  }
#line 5383
  if (! wi) {
    _L: /* CIL Label */ 
#line 5386
    wi = (struct win *)0;
#line 5388
    wi = windows;
    {
#line 5388
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5388
      if (! wi) {
#line 5388
        goto while_break___0;
      }
      {
#line 5389
      __cil_tmp7 = AclCheckPermWin(display->d_user, 1, wi);
      }
#line 5389
      if (! wi->w_layer.l_cvlist) {
#line 5389
        if (! __cil_tmp7) {
#line 5390
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5388
    wi = wi->w_next;
#line 5391
    if (! wi) {
#line 5392
      wi = windows;
      {
#line 5392
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5392
        if (! wi) {
#line 5392
          goto while_break___1;
        }
        {
#line 5393
        __cil_tmp9 = AclCheckPermWin(display->d_user, 1, wi);
        }
        {
#line 5393
        __cil_tmp8 = IsOnDisplay(wi);
        }
#line 5393
        if (wi->w_layer.l_cvlist) {
#line 5393
          if (! __cil_tmp8) {
#line 5393
            if (! __cil_tmp9) {
#line 5394
              goto while_break___1;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5392
      wi = wi->w_next;
    }
#line 5395
    if (! wi) {
#line 5396
      wi = windows;
      {
#line 5396
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5396
        if (! wi) {
#line 5396
          goto while_break___2;
        }
        {
#line 5397
        __cil_tmp10 = AclCheckPermWin(display->d_user, 2, wi);
        }
#line 5397
        if (! wi->w_layer.l_cvlist) {
#line 5397
          if (! __cil_tmp10) {
#line 5398
            goto while_break___2;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5396
      wi = wi->w_next;
    }
#line 5399
    if (! wi) {
#line 5400
      wi = windows;
      {
#line 5400
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5400
        if (! wi) {
#line 5400
          goto while_break___3;
        }
        {
#line 5401
        __cil_tmp12 = AclCheckPermWin(display->d_user, 2, wi);
        }
        {
#line 5401
        __cil_tmp11 = IsOnDisplay(wi);
        }
#line 5401
        if (wi->w_layer.l_cvlist) {
#line 5401
          if (! __cil_tmp11) {
#line 5401
            if (! __cil_tmp12) {
#line 5402
              goto while_break___3;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5400
      wi = wi->w_next;
    }
#line 5404
    if (! wi) {
#line 5405
      wi = windows;
      {
#line 5405
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5405
        if (! wi) {
#line 5405
          goto while_break___4;
        }
#line 5406
        if (! wi->w_layer.l_cvlist) {
#line 5407
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5405
      wi = wi->w_next;
    }
#line 5408
    if (! wi) {
#line 5409
      wi = windows;
      {
#line 5409
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 5409
        if (! wi) {
#line 5409
          goto while_break___5;
        }
        {
#line 5410
        __cil_tmp13 = IsOnDisplay(wi);
        }
#line 5410
        if (wi->w_layer.l_cvlist) {
#line 5410
          if (! __cil_tmp13) {
#line 5411
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 5409
      wi = wi->w_next;
    }
  } else
#line 5383
  if (__cil_tmp6) {
#line 5383
    if (! presel) {
#line 5383
      goto _L;
    }
  }
  {
#line 5414
  __cil_tmp14 = AclCheckPermWin(display->d_user, 2, wi);
  }
#line 5414
  if (wi) {
#line 5414
    if (__cil_tmp14) {
#line 5415
      wi = (struct win *)0;
    }
  }
#line 5417
  return (wi);
}
}
#line 5483 "/tmp/screen-3.9.15/process.c"
static void ResizeRegions(char *arg ) 
{ 
  struct canvas *cv ;
  int nreg ;
  int dsize ;
  int diff ;
  int siz ;
  int h ;
  int hh ;
  int i ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int s ;
  int i___0 ;
  int found ;
  int di ;
  int d2 ;
  int tmp ;

  {
  {
#line 5489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5489
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5490
  cv = display->d_cvlist;
#line 5490
  nreg = 0;
  {
#line 5490
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5490
    if (! cv) {
#line 5490
      goto while_break___0;
    }
#line 5491
    nreg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5490
  cv = cv->c_next;
#line 5492
  if (nreg < 2) {
    {
#line 5494
    Msg(0, (char *)"resize: need more than one region");
    }
#line 5495
    return;
  }
#line 5497
  dsize = display->d_height - (display->d_has_hstatus == 1);
#line 5498
  if ((int )*arg == 61) {
#line 5501
    h = dsize;
#line 5502
    i = 0;
#line 5503
    cv = display->d_cvlist;
    {
#line 5503
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5503
      if (! cv) {
#line 5503
        goto while_break___1;
      }
#line 5505
      __cil_tmp11 = nreg;
#line 5505
      nreg --;
#line 5505
      hh = h / __cil_tmp11 - 1;
#line 5506
      cv->c_ys = i;
#line 5507
      cv->c_ye = (i + hh) - 1;
#line 5508
      cv->c_yoff = i;
#line 5509
      i += hh + 1;
#line 5510
      h -= hh + 1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 5503
    cv = cv->c_next;
#line 5512
    RethinkDisplayViewports();
#line 5513
    ResizeLayersToCanvases();
    }
#line 5514
    return;
  }
#line 5516
  siz = ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1;
#line 5517
  if ((int )*arg == 43) {
    {
#line 5518
    diff = atoi((char const   *)(arg + 1));
    }
  } else
#line 5519
  if ((int )*arg == 45) {
    {
#line 5520
    __cil_tmp13 = atoi((char const   *)(arg + 1));
#line 5520
    diff = - __cil_tmp13;
    }
  } else {
    {
#line 5521
    __cil_tmp14 = strcmp((char const   *)arg, (char const   *)((char *)"min"));
    }
#line 5521
    if (! __cil_tmp14) {
#line 5522
      diff = 1 - siz;
    } else {
      {
#line 5523
      __cil_tmp15 = strcmp((char const   *)arg, (char const   *)((char *)"max"));
      }
#line 5523
      if (! __cil_tmp15) {
#line 5524
        diff = ((dsize - (nreg - 1) * 2) - 1) - siz;
      } else {
        {
#line 5526
        __cil_tmp16 = atoi((char const   *)arg);
#line 5526
        diff = __cil_tmp16 - siz;
        }
      }
    }
  }
#line 5527
  if (diff == 0) {
#line 5528
    return;
  }
#line 5529
  if (siz + diff < 1) {
#line 5530
    diff = 1 - siz;
  }
#line 5531
  if (siz + diff > (dsize - (nreg - 1) * 2) - 1) {
#line 5532
    diff = ((dsize - (nreg - 1) * 2) - 1) - siz;
  }
#line 5533
  if (diff == 0) {
#line 5534
    return;
  } else
#line 5533
  if (siz + diff < 1) {
#line 5534
    return;
  }
#line 5536
  if (diff < 0) {
#line 5538
    if ((display->d_forecv)->c_next) {
#line 5540
      (display->d_forecv)->c_ye += diff;
#line 5541
      ((display->d_forecv)->c_next)->c_ys += diff;
#line 5542
      ((display->d_forecv)->c_next)->c_yoff += diff;
    } else {
#line 5546
      cv = display->d_cvlist;
      {
#line 5546
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5546
        if (! cv) {
#line 5546
          goto while_break___2;
        }
#line 5547
        if (cv->c_next == display->d_forecv) {
#line 5548
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5546
      cv = cv->c_next;
      {
#line 5549
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5549
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5550
      cv->c_ye -= diff;
#line 5551
      (display->d_forecv)->c_ys -= diff;
#line 5552
      (display->d_forecv)->c_yoff -= diff;
    }
  } else {
#line 5557
    i___0 = 0;
#line 5557
    found = 0;
#line 5557
    di = diff;
#line 5558
    s = ((dsize - (nreg - 1) * 2) - 1) - siz;
#line 5559
    cv = display->d_cvlist;
    {
#line 5559
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5559
      if (! cv) {
#line 5559
        goto while_break___4;
      }
#line 5561
      if (cv == display->d_forecv) {
#line 5563
        cv->c_ye = (i___0 + (cv->c_ye - cv->c_ys)) + diff;
#line 5564
        cv->c_yoff -= cv->c_ys - i___0;
#line 5565
        cv->c_ys = i___0;
#line 5566
        found = 1;
#line 5567
        goto while_continue___4;
      }
#line 5569
      s -= cv->c_ye - cv->c_ys;
#line 5570
      if (! found) {
#line 5572
        if (s >= di) {
#line 5573
          goto while_continue___4;
        }
#line 5574
        d2 = di - s;
      } else {
#line 5577
        if (di > cv->c_ye - cv->c_ys) {
#line 5577
          tmp = cv->c_ye - cv->c_ys;
        } else {
#line 5577
          tmp = di;
        }
#line 5577
        d2 = tmp;
      }
#line 5578
      di -= d2;
#line 5579
      cv->c_ye = (i___0 + (cv->c_ye - cv->c_ys)) - d2;
#line 5580
      cv->c_yoff -= cv->c_ys - i___0;
#line 5581
      cv->c_ys = i___0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5559
    cv = cv->c_next;
#line 5559
    i___0 = cv->c_ye + 2;
  }
  {
#line 5584
  RethinkDisplayViewports();
#line 5585
  ResizeLayersToCanvases();
  }
}
}
#line 5589 "/tmp/screen-3.9.15/process.c"
static void ResizeFin(char *buf , int len , char *data ) 
{ 


  {
  {
#line 5594
  ResizeRegions(buf);
  }
}
}
#line 5611 "/tmp/screen-3.9.15/process.c"
int ParseAttrColor(char *s1 , char *s2 , int msgok ) 
{ 
  int i ;
  int n ;
  char *s ;
  char *ss ;
  int r ;
  int mode ;
  int n___235 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  static char costr[] ;
  int numco ;
  int j ;

  {
#line 5617
  r = 0;
#line 5619
  s = s1;
  {
#line 5620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5620
    if (! ((int )*s == 32)) {
#line 5620
      goto while_break;
    }
#line 5621
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5622
  ss = s;
  {
#line 5623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5623
    if (! ((int )*ss && (int )*ss != 32)) {
#line 5623
      goto while_break___0;
    }
#line 5624
    ss ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5625
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5625
    if (! ((int )*ss == 32)) {
#line 5625
      goto while_break___1;
    }
#line 5626
    ss ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5627
  if ((int )*s) {
#line 5627
    if (s2) {
      _L___239: /* CIL Label */ 
#line 5629
      mode = 0;
#line 5629
      n___235 = 0;
#line 5630
      if ((int )*s == 43) {
#line 5632
        mode = 1;
#line 5633
        s ++;
      } else
#line 5635
      if ((int )*s == 45) {
#line 5637
        mode = - 1;
#line 5638
        s ++;
      } else
#line 5640
      if ((int )*s == 33) {
#line 5642
        mode = 2;
#line 5643
        s ++;
      } else
#line 5645
      if ((int )*s == 61) {
#line 5646
        s ++;
      }
#line 5647
      if ((int )*s >= 48) {
#line 5647
        if ((int )*s <= 57) {
#line 5649
          __cil_tmp18 = s;
#line 5649
          s ++;
#line 5649
          n___235 = (int )*__cil_tmp18 - 48;
#line 5650
          if ((int )*s >= 48) {
#line 5650
            if ((int )*s <= 57) {
#line 5651
              __cil_tmp19 = s;
#line 5651
              s ++;
#line 5651
              n___235 = n___235 * 16 + ((int )*__cil_tmp19 - 48);
            } else {
#line 5650
              goto _L___237;
            }
          } else
          _L___237: /* CIL Label */ 
#line 5652
          if ((int )*s >= 97) {
#line 5652
            if ((int )*s <= 102) {
#line 5653
              __cil_tmp20 = s;
#line 5653
              s ++;
#line 5653
              n___235 = n___235 * 16 + ((int )*__cil_tmp20 - 87);
            } else {
#line 5652
              goto _L___236;
            }
          } else
          _L___236: /* CIL Label */ 
#line 5654
          if ((int )*s >= 65) {
#line 5654
            if ((int )*s <= 70) {
#line 5655
              __cil_tmp21 = s;
#line 5655
              s ++;
#line 5655
              n___235 = n___235 * 16 + ((int )*__cil_tmp21 - 55);
            } else {
#line 5654
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 5656
          if ((int )*s) {
#line 5656
            if ((int )*s != 32) {
#line 5658
              if (msgok) {
                {
#line 5659
                Msg(0, (char *)"Illegal attribute hexchar \'%c\'", (int )*s);
                }
              }
#line 5660
              return (- 1);
            }
          }
        } else {
#line 5647
          goto _L___238;
        }
      } else {
        _L___238: /* CIL Label */ 
        {
#line 5665
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 5665
          if (! ((int )*s && (int )*s != 32)) {
#line 5665
            goto while_break___2;
          }
#line 5667
          if ((int )*s == 100) {
#line 5668
            n___235 |= 1;
          } else
#line 5669
          if ((int )*s == 117) {
#line 5670
            n___235 |= 1 << 1;
          } else
#line 5671
          if ((int )*s == 98) {
#line 5672
            n___235 |= 1 << 2;
          } else
#line 5673
          if ((int )*s == 114) {
#line 5674
            n___235 |= 1 << 3;
          } else
#line 5675
          if ((int )*s == 115) {
#line 5676
            n___235 |= 1 << 4;
          } else
#line 5677
          if ((int )*s == 66) {
#line 5678
            n___235 |= 1 << 5;
          } else {
#line 5681
            if (msgok) {
              {
#line 5682
              Msg(0, (char *)"Illegal attribute specifier \'%c\'", (int )*s);
              }
            }
#line 5683
            return (- 1);
          }
#line 5685
          s ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 5688
      if ((int )*s) {
#line 5688
        if ((int )*s != 32) {
#line 5690
          if (msgok) {
            {
#line 5691
            Msg(0, (char *)"junk after attribute description: \'%c\'", (int )*s);
            }
          }
#line 5692
          return (- 1);
        }
      }
#line 5694
      if (mode == -1) {
#line 5695
        r = (n___235 << 8) | n___235;
      } else
#line 5696
      if (mode == 1) {
#line 5697
        r = n___235 << 8;
      } else
#line 5698
      if (mode == 2) {
#line 5699
        r = n___235;
      } else
#line 5700
      if (mode == 0) {
#line 5701
        r = 65535 ^ n___235;
      }
    } else
#line 5627
    if ((int )*ss) {
#line 5627
      goto _L___239;
    } else
#line 5627
    if (! ((((int )*s >= 97 && (int )*s <= 122) || ((int )*s >= 65 && (int )*s <= 90)) || (int )*s == 46)) {
#line 5627
      goto _L___239;
    }
  }
  {
#line 5703
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5703
    if (! ((int )*s && (int )*s == 32)) {
#line 5703
      goto while_break___3;
    }
#line 5704
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5706
  if (s2) {
#line 5708
    if (*s) {
#line 5710
      if (msgok) {
        {
#line 5711
        Msg(0, (char *)"junk after description: \'%c\'", (int )*s);
        }
      }
#line 5712
      return (- 1);
    }
#line 5714
    s = s2;
    {
#line 5715
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5715
      if (! ((int )*s && (int )*s == 32)) {
#line 5715
        goto while_break___4;
      }
#line 5716
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 5720
  if (*s) {
#line 5722
    costr = "krgybmcw d    i.01234567 9     f               FKRGYBMCW      I ";
#line 5723
    numco = 0;
#line 5725
    n = 0;
#line 5726
    if ((int )*s == 46) {
#line 5728
      numco ++;
#line 5729
      n = 15;
#line 5730
      s ++;
    }
#line 5732
    j = 0;
    {
#line 5732
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 5732
      if (! ((j < 2 && (int )*s) && (int )*s != 32)) {
#line 5732
        goto while_break___5;
      }
#line 5734
      i = 0;
      {
#line 5734
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 5734
        if (! costr[i]) {
#line 5734
          goto while_break___6;
        }
#line 5735
        if ((int )*s == (int )costr[i]) {
#line 5736
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 5734
      i ++;
#line 5737
      if (! costr[i]) {
#line 5739
        if (msgok) {
          {
#line 5740
          Msg(0, (char *)"illegal color descriptor: \'%c\'", (int )*s);
          }
        }
#line 5741
        return (- 1);
      }
#line 5743
      numco ++;
#line 5744
      n = (n << 4) | (i & 15);
#line 5746
      if (i >= 48) {
#line 5747
        n = (n & 8447) | 512;
      }
#line 5749
      s ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 5732
    j ++;
#line 5751
    if ((n & 3840) == 3840) {
#line 5752
      n ^= 3840;
    }
#line 5754
    if (n & 8192) {
#line 5755
      n ^= 9216;
    }
#line 5757
    if (numco == 1) {
#line 5758
      n |= 240;
    }
#line 5759
    if (numco != 2) {
#line 5759
      if (n != 255) {
#line 5760
        n |= 256;
      }
    }
#line 5761
    if ((int )*s) {
#line 5761
      if ((int )*s != 32) {
#line 5763
        if (msgok) {
          {
#line 5764
          Msg(0, (char *)"junk after color description: \'%c\'", (int )*s);
          }
        }
#line 5765
        return (- 1);
      }
    }
#line 5767
    n ^= 255;
#line 5768
    r |= n << 16;
  }
  {
#line 5772
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 5772
    if (! ((int )*s && (int )*s == 32)) {
#line 5772
      goto while_break___7;
    }
#line 5773
    s ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 5774
  if (*s) {
#line 5776
    if (msgok) {
      {
#line 5777
      Msg(0, (char *)"junk after description: \'%c\'", (int )*s);
      }
    }
#line 5778
    return (- 1);
  }
  {
#line 5780
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 5780
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 5781
  return (r);
}
}
#line 5793 "/tmp/screen-3.9.15/process.c"
void ApplyAttrColor(int i , struct mchar *mc ) 
{ 


  {
  {
#line 5797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5798
  mc->attr |= (i >> 8) & 255;
#line 5799
  mc->attr ^= i & 255;
#line 5801
  i = (i >> 16) ^ 255;
#line 5802
  if ((i & 256) != 0) {
#line 5804
    i &= 3839;
#line 5805
    if ((int )mc->attr & ((1 << 4) | (1 << 3))) {
#line 5807
      i = ((((i & 15) << 4) | ((i & 240) >> 4)) | ((i & 512) << 1)) | ((i & 1024) >> 1);
    }
  }
#line 5813
  if ((i & 15) != 15) {
#line 5814
    mc->attr = (unsigned char )(((int )mc->attr & 191) | ((i >> 3) & 64));
  }
#line 5815
  if ((i & 240) != 240) {
#line 5816
    mc->attr = (unsigned char )(((int )mc->attr & 127) | ((i >> 3) & 128));
  }
#line 5818
  mc->color = (unsigned char )(153 ^ (int )mc->color);
#line 5819
  if ((i & 14) == 14) {
#line 5820
    i = (i & 240) | ((int )mc->color & 15);
  }
#line 5821
  if ((i & 224) == 224) {
#line 5822
    i = (i & 15) | ((int )mc->color & 240);
  }
#line 5823
  mc->color = (unsigned char )(153 ^ i);
  {
#line 5824
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5824
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 170 "./extern.h"
int OpenPTY(char **ttyn ) ;
#line 171
void InitPTY(int f ) ;
#line 347
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) ;
#line 78 "/tmp/screen-3.9.15/pty.c"
static char PtyName[32] ;
#line 78
static char TtyName[32] ;
#line 95
static void initmaster(int f ) ;
#line 102 "/tmp/screen-3.9.15/pty.c"
int pty_preopen  =    0;
#line 116 "/tmp/screen-3.9.15/pty.c"
static void initmaster(int f ) 
{ 


  {
  {
#line 120
  tcflush(f, 2);
  }
}
}
#line 132 "/tmp/screen-3.9.15/pty.c"
void InitPTY(int f ) 
{ 


  {
#line 135
  if (f < 0) {
#line 136
    return;
  }
}
}
#line 249 "/tmp/screen-3.9.15/pty.c"
int OpenPTY(char **ttyn ) 
{ 
  register int f ;
  char *m ;
  void (*sigcld)(int  ) ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 260
  strcpy((char *)PtyName, (char const   *)((char *)"/dev/ptmx"));
#line 262
  f = getpt();
  }
#line 262
  if (f == -1) {
#line 266
    return (- 1);
  }
  {
#line 272
  sigcld = xsignal(17, (__sighandler_t )0);
#line 273
  __cil_tmp9 = unlockpt(f);
  }
  {
#line 273
  __cil_tmp8 = grantpt(f);
  }
  {
#line 273
  m = (char *)ptsname(f);
  }
#line 273
  if (m == (char *)((void *)0)) {
    {
    {
    {
#line 275
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 276
    close(f);
    }
    }
    }
#line 277
    return (- 1);
  } else
#line 273
  if (__cil_tmp8) {
    {
    {
    {
#line 275
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 276
    close(f);
    }
    }
    }
#line 277
    return (- 1);
  } else
#line 273
  if (__cil_tmp9) {
    {
    {
    {
#line 275
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 276
    close(f);
    }
    }
    }
#line 277
    return (- 1);
  }
  {
#line 279
  xsignal(17, sigcld);
#line 280
  strncpy((char *)TtyName, (char const   *)m, sizeof(TtyName));
#line 281
  initmaster(f);
#line 282
  *ttyn = (char *)TtyName;
  }
#line 283
  return (f);
}
}
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 137 "/usr/include/stdio.h"
extern _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 318
extern int printf(char const   *__format  , ...) ;
#line 435 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 472
extern int pause(void) ;
#line 576
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 703
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 949
extern char *getpass(char const   *__prompt ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 631
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 33 "./extern.h"
void eexit(int e ) ;
#line 36
void Kill(int pid , int sig ) ;
#line 221
int Attach(int how ) ;
#line 222
void Attacher(void) ;
#line 223
void AttacherFinit(int sigsig ) ;
#line 224
void SendCmdMessage(char *sty , char *match , char **av ) ;
#line 319
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match ) ;
#line 320
int MakeClientSocket(int err ) ;
#line 342
void closeallfiles(int except ) ;
#line 353
void xseteuid(int euid ) ;
#line 38 "/tmp/screen-3.9.15/attacher.c"
static int WriteMessage(int s , struct msg *m ) ;
#line 39
static void AttacherSigInt(int sigsig ) ;
#line 41
static void AttacherWinch(int sigsig ) ;
#line 44
static void DoLock(int sigsig ) ;
#line 45
static void LockTerminal(void) ;
#line 46
static void LockHup(int sigsig ) ;
#line 47
static void screen_builtin_lck(void) ;
#line 53
static void AttachSigCont(int sigsig ) ;
#line 56
int real_uid ;
#line 56
int real_gid ;
#line 56
int eff_uid ;
#line 56
int eff_gid ;
#line 57
char *SockMatch ;
#line 58
struct passwd *ppp ;
#line 59
char *attach_tty ;
#line 59
char *attach_term ;
#line 59
char *LoginName ;
#line 59
char *preselect ;
#line 60
int xflag ;
#line 60
int dflag ;
#line 60
int rflag ;
#line 60
int quietflag ;
#line 60
int adaptflag ;
#line 61
struct mode attach_Mode ;
#line 62
extern struct NewWindow nwin_options ;
#line 63
int MasterPid ;
#line 67
int multiattach ;
#line 67
int multi_uid ;
#line 67
int own_uid ;
#line 68
int tty_mode ;
#line 68
int tty_oldmode ;
#line 76
static int ContinuePlease ;
#line 79 "/tmp/screen-3.9.15/attacher.c"
static void AttachSigCont(int sigsig ) 
{ 


  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  ContinuePlease = 1;
}
}
#line 96 "/tmp/screen-3.9.15/attacher.c"
static int WriteMessage(int s , struct msg *m ) 
{ 
  int r ;
  int l ;
  ssize_t __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 100
  l = (int )sizeof(*m);
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (l > 0)) {
#line 102
      goto while_break;
    }
    {
#line 104
    __cil_tmp5 = write(s, (void const   *)((char *)m + (sizeof(*m) - (unsigned long )l)),
                       (size_t )l);
#line 104
    r = (int )__cil_tmp5;
#line 105
    __cil_tmp6 = __errno_location();
    }
#line 105
    if (r == -1) {
#line 105
      if (*__cil_tmp6 == 4) {
#line 106
        goto while_continue;
      }
    }
#line 107
    if (r == -1) {
#line 108
      return (- 1);
    } else
#line 107
    if (r == 0) {
#line 108
      return (- 1);
    }
#line 109
    l -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (0);
}
}
#line 116 "/tmp/screen-3.9.15/attacher.c"
int Attach(int how ) 
{ 
  int n ;
  int lasts ;
  struct msg m ;
  struct stat st ;
  char *s ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;
  char *tmp ;
  char *tmp___241 ;
  char *tmp___242 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  int tmp___243 ;
  char *tmp___244 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;
  char *tmp___248 ;
  int tmp___249 ;
  int __cil_tmp31 ;
  int *__cil_tmp32 ;
  int __cil_tmp33 ;
  int *__cil_tmp34 ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (how == 2) {
    _L: /* CIL Label */ 
#line 186
    if (multiattach) {
      {
#line 188
      real_uid = multi_uid;
#line 189
      eff_uid = own_uid;
#line 190
      xseteuid(multi_uid);
#line 191
      xseteuid(own_uid);
#line 192
      __cil_tmp7 = chmod((char const   *)attach_tty, (__mode_t )438);
      }
#line 192
      if (__cil_tmp7) {
        {
#line 193
        __cil_tmp8 = __errno_location();
#line 193
        Panic(*__cil_tmp8, (char *)"chmod %s", attach_tty);
        }
      }
#line 194
      tty_oldmode = tty_mode;
    }
  } else
#line 186
  if (how == 3) {
#line 186
    goto _L;
  }
  {
#line 199
  bzero((void *)((char *)(& m)), sizeof(m));
#line 200
  m.type = how;
#line 201
  m.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
#line 202
  strncpy((char *)m.m_tty, (char const   *)attach_tty, sizeof(m.m_tty) - 1UL);
#line 203
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
  }
#line 205
  if (how == 6) {
    {
#line 207
    lasts = MakeClientSocket(0);
    }
#line 207
    if (lasts >= 0) {
      {
#line 209
      WriteMessage(lasts, & m);
#line 210
      close(lasts);
      }
    }
#line 212
    return (0);
  }
#line 215
  if (how == 3) {
    {
#line 217
    lasts = MakeClientSocket(0);
    }
#line 217
    if (lasts < 0) {
      {
#line 219
      Panic(0, (char *)"Sorry, cannot contact session \"%s\" again.\r\n", SockName);
      }
    }
  } else {
    {
#line 225
    n = FindSocket(& lasts, (int *)0, (int *)0, SockMatch);
    }
    {
#line 228
    if (n == 0) {
#line 228
      goto case_0;
    }
#line 238
    if (n == 1) {
#line 238
      goto case_1;
    }
#line 240
    goto switch_default;
    case_0: /* CIL Label */ 
#line 229
    if (rflag) {
#line 229
      if ((rflag & 1) == 0) {
#line 230
        return (0);
      }
    }
#line 231
    if (quietflag) {
      {
#line 232
      eexit(10);
      }
    }
#line 233
    if (SockMatch && (int )*SockMatch) {
#line 233
      tmp = (char *)"There is no screen to be %sed matching %s.";
    } else {
#line 233
      tmp = (char *)"There is no screen to be %sed.";
    }
#line 233
    if (xflag) {
#line 233
      tmp___242 = (char *)"attach";
    } else {
#line 233
      if (dflag) {
#line 233
        tmp___241 = (char *)"detach";
      } else {
#line 233
        tmp___241 = (char *)"resum";
      }
#line 233
      tmp___242 = tmp___241;
    }
    {
#line 233
    Panic(0, tmp, tmp___242, SockMatch);
    }
    case_1: /* CIL Label */ 
#line 239
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 241
    if (rflag < 3) {
#line 243
      if (quietflag) {
        {
#line 244
        eexit(10 + n);
        }
      }
      {
#line 245
      Panic(0, (char *)"Type \"screen [-d] -r [pid.]tty.host\" to resume one of them.");
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 256
  if (! multiattach) {
    {
#line 258
    setuid((__uid_t )real_uid);
    }
  } else {
    {
#line 263
    xseteuid(real_uid);
    }
  }
  {
#line 266
  setgid((__gid_t )real_gid);
#line 267
  eff_uid = real_uid;
#line 268
  eff_gid = real_gid;
  }
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  MasterPid = 0;
#line 272
  s = SockName;
  {
#line 272
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 272
    if (! *s) {
#line 272
      goto while_break___1;
    }
#line 274
    if ((int )*s > 57) {
#line 275
      goto while_break___1;
    } else
#line 274
    if ((int )*s < 48) {
#line 275
      goto while_break___1;
    }
#line 276
    MasterPid = 10 * MasterPid + ((int )*s - 48);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 272
  s ++;
  {
#line 278
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 278
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 279
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 279
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 280
  __cil_tmp16 = stat((char const   *)((char *)SockPath), & st);
  }
#line 280
  if (__cil_tmp16 == -1) {
    {
#line 281
    __cil_tmp17 = __errno_location();
#line 281
    Panic(*__cil_tmp17, (char *)"stat %s", (char *)SockPath);
    }
  }
#line 282
  if ((st.st_mode & 384U) != 384U) {
    {
#line 283
    Panic(0, (char *)"Socket is in wrong mode (%03o)", (int )st.st_mode);
    }
  }
#line 288
  if (xflag) {
    _L___243: /* CIL Label */ 
#line 288
    if (dflag) {
#line 288
      if ((st.st_mode & 448U) == 384U) {
#line 289
        dflag = 0;
      }
    }
  } else
#line 288
  if (rflag) {
#line 288
    goto _L___243;
  }
#line 295
  if (dflag) {
#line 295
    tmp___243 = 448;
  } else {
#line 295
    tmp___243 = 384;
  }
#line 295
  if (dflag) {
    _L___245: /* CIL Label */ 
#line 295
    if ((st.st_mode & 448U) != (unsigned int )tmp___243) {
#line 296
      if (dflag) {
#line 296
        tmp___244 = (char *)"already ";
      } else {
#line 296
        tmp___244 = (char *)"not ";
      }
      {
#line 296
      Panic(0, (char *)"That screen is %sdetached.", tmp___244);
      }
    }
  } else
#line 295
  if (! xflag) {
#line 295
    goto _L___245;
  }
#line 298
  if (dflag) {
#line 298
    if (how == 2) {
      _L___246: /* CIL Label */ 
      {
#line 301
      m.m.detach.dpid = getpid();
#line 302
      strncpy((char *)m.m.detach.duser, (char const   *)LoginName, sizeof(m.m.detach.duser) - 1UL);
#line 303
      m.m.detach.duser[sizeof(m.m.detach.duser) - 1UL] = (char )0;
      }
#line 305
      if (dflag == 2) {
#line 306
        m.type = 5;
      } else {
#line 309
        m.type = 4;
      }
      {
#line 310
      __cil_tmp21 = WriteMessage(lasts, & m);
      }
#line 310
      if (__cil_tmp21) {
        {
#line 311
        __cil_tmp22 = __errno_location();
#line 311
        Panic(*__cil_tmp22, (char *)"WriteMessage");
        }
      }
      {
#line 312
      close(lasts);
      }
#line 313
      if (how != 2) {
#line 314
        return (0);
      }
      {
#line 315
      sleep((unsigned int )1);
#line 316
      lasts = MakeClientSocket(0);
      }
#line 316
      if (lasts == -1) {
        {
#line 317
        Panic(0, (char *)"Cannot contact screen again. Sigh.");
        }
      }
#line 318
      m.type = how;
    } else
#line 298
    if (how == 4) {
#line 298
      goto _L___246;
    } else
#line 298
    if (how == 5) {
#line 298
      goto _L___246;
    }
  }
  {
#line 321
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 321
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 322
  strncpy((char *)m.m.attach.envterm, (char const   *)attach_term, sizeof(m.m.attach.envterm) - 1UL);
#line 323
  m.m.attach.envterm[sizeof(m.m.attach.envterm) - 1UL] = (char )0;
  }
  {
#line 324
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 324
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 326
  strncpy((char *)m.m.attach.auser, (char const   *)LoginName, sizeof(m.m.attach.auser) - 1UL);
#line 327
  m.m.attach.auser[sizeof(m.m.attach.auser) - 1UL] = (char )0;
#line 328
  m.m.attach.esc = DefaultEsc;
#line 329
  m.m.attach.meta_esc = DefaultMetaEsc;
  }
#line 330
  if (preselect) {
#line 330
    tmp___248 = preselect;
  } else {
#line 330
    tmp___248 = (char *)"";
  }
  {
#line 330
  strncpy((char *)m.m.attach.preselect, (char const   *)tmp___248, sizeof(m.m.attach.preselect) - 1UL);
#line 331
  m.m.attach.preselect[sizeof(m.m.attach.preselect) - 1UL] = (char )0;
#line 332
  m.m.attach.apid = getpid();
#line 333
  m.m.attach.adaptflag = adaptflag;
#line 334
  m.m.attach.columns = 0;
#line 334
  m.m.attach.lines = m.m.attach.columns;
#line 335
  s = getenv((char const   *)((char *)"LINES"));
  }
#line 335
  if (s) {
    {
#line 336
    m.m.attach.lines = atoi((char const   *)s);
    }
  }
  {
#line 337
  s = getenv((char const   *)((char *)"COLUMNS"));
  }
#line 337
  if (s) {
    {
#line 338
    m.m.attach.columns = atoi((char const   *)s);
    }
  }
#line 339
  if (nwin_options.encoding > 0) {
#line 339
    tmp___249 = nwin_options.encoding + 1;
  } else {
#line 339
    tmp___249 = 0;
  }
#line 339
  m.m.attach.encoding = tmp___249;
#line 343
  if (multi) {
#line 343
    if (how == 2) {
      {
      {
#line 344
      xsignal(18, (void (*)(int  ))AttachSigCont);
      }
      }
    } else
#line 343
    if (how == 3) {
      {
      {
#line 344
      xsignal(18, (void (*)(int  ))AttachSigCont);
      }
      }
    }
  }
  {
#line 347
  __cil_tmp31 = WriteMessage(lasts, & m);
  }
#line 347
  if (__cil_tmp31) {
    {
#line 348
    __cil_tmp32 = __errno_location();
#line 348
    Panic(*__cil_tmp32, (char *)"WriteMessage");
    }
  }
  {
#line 349
  close(lasts);
  }
  {
#line 350
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 350
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 352
  if (multi) {
#line 352
    if (how == 2) {
      _L___250: /* CIL Label */ 
      {
#line 354
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 354
        if (! (! ContinuePlease)) {
#line 354
          goto while_break___7;
        }
        {
#line 355
        pause();
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 356
      xsignal(18, (__sighandler_t )0);
#line 357
      ContinuePlease = 0;
#line 361
      xseteuid(own_uid);
      }
#line 362
      if (tty_oldmode >= 0) {
        {
#line 363
        __cil_tmp33 = chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
        }
#line 363
        if (__cil_tmp33) {
          {
#line 364
          __cil_tmp34 = __errno_location();
#line 364
          Panic(*__cil_tmp34, (char *)"chmod %s", attach_tty);
          }
        }
      }
      {
#line 365
      tty_oldmode = - 1;
#line 366
      xseteuid(real_uid);
      }
    } else
#line 352
    if (how == 3) {
#line 352
      goto _L___250;
    }
  }
#line 370
  rflag = 0;
#line 371
  return (1);
}
}
#line 376 "/tmp/screen-3.9.15/attacher.c"
static int AttacherPanic  =    0;
#line 389 "/tmp/screen-3.9.15/attacher.c"
static void AttacherSigAlarm(int sigsig ) 
{ 


  {

}
}
#line 404 "/tmp/screen-3.9.15/attacher.c"
static void AttacherSigInt(int sigsig ) 
{ 


  {
  {
#line 406
  xsignal(2, (void (*)(int  ))AttacherSigInt);
#line 407
  Kill(MasterPid, 2);
  }
}
}
#line 417 "/tmp/screen-3.9.15/attacher.c"
void AttacherFinit(int sigsig ) 
{ 
  struct stat statb ;
  struct msg m ;
  int s ;
  int __cil_tmp5 ;

  {
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  xsignal(1, (__sighandler_t )1);
#line 426
  __cil_tmp5 = stat((char const   *)((char *)SockPath), & statb);
  }
#line 426
  if (__cil_tmp5 == 0) {
#line 426
    if ((statb.st_mode & 511U) != 384U) {
      {
#line 428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 428
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 429
      bzero((void *)((char *)(& m)), sizeof(m));
#line 430
      strncpy((char *)m.m_tty, (char const   *)attach_tty, sizeof(m.m_tty) - 1UL);
#line 431
      m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
      }
      {
#line 432
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 432
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 433
      m.m.detach.dpid = getpid();
#line 434
      m.type = 7;
#line 435
      m.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
#line 436
      s = MakeClientSocket(0);
      }
#line 436
      if (s >= 0) {
        {
#line 438
        WriteMessage(s, & m);
#line 439
        close(s);
        }
      }
    }
  }
#line 443
  if (tty_oldmode >= 0) {
    {
#line 445
    setuid((__uid_t )own_uid);
#line 446
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 449
  exit(0);
  }
}
}
#line 455 "/tmp/screen-3.9.15/attacher.c"
static void AttacherFinitBye(int sigsig ) 
{ 
  int ppid ;

  {
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 463
  setgid((__gid_t )real_gid);
#line 465
  setuid((__uid_t )own_uid);
#line 470
  ppid = getppid();
  }
#line 470
  if (ppid > 1) {
    {
#line 471
    Kill(ppid, 1);
    }
  }
  {
#line 472
  exit(0);
  }
}
}
#line 494
static int SuspendPlease ;
#line 497 "/tmp/screen-3.9.15/attacher.c"
static void SigStop(int sigsig ) 
{ 


  {
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  SuspendPlease = 1;
}
}
#line 505
static int LockPlease ;
#line 508 "/tmp/screen-3.9.15/attacher.c"
static void DoLock(int sigsig ) 
{ 


  {
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  LockPlease = 1;
}
}
#line 520
static int SigWinchPlease ;
#line 523 "/tmp/screen-3.9.15/attacher.c"
static void AttacherWinch(int sigsig ) 
{ 


  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  SigWinchPlease = 1;
}
}
#line 537 "/tmp/screen-3.9.15/attacher.c"
void Attacher(void) 
{ 
  int __cil_tmp1 ;
  int *__cil_tmp2 ;
  __pid_t __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 539
  xsignal(1, (void (*)(int  ))AttacherFinit);
#line 540
  xsignal(1, (void (*)(int  ))AttacherFinit);
#line 542
  xsignal(10, (void (*)(int  ))AttacherFinitBye);
#line 548
  xsignal(12, (void (*)(int  ))DoLock);
#line 550
  xsignal(2, (void (*)(int  ))AttacherSigInt);
#line 552
  xsignal(20, (void (*)(int  ))SigStop);
#line 555
  xsignal(28, (void (*)(int  ))AttacherWinch);
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  dflag = 0;
#line 563
  xflag = 1;
  {
#line 565
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 565
    if (! 1) {
#line 565
      goto while_break___0;
    }
    {
#line 568
    xsignal(14, (void (*)(int  ))AttacherSigAlarm);
#line 569
    alarm((unsigned int )15);
#line 570
    pause();
#line 571
    alarm((unsigned int )0);
#line 572
    __cil_tmp2 = __errno_location();
    }
    {
#line 572
    __cil_tmp1 = kill(MasterPid, 0);
    }
#line 572
    if (__cil_tmp1 < 0) {
#line 572
      if (*__cil_tmp2 != 1) {
        {
#line 574
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 574
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 575
        AttacherPanic ++;
      }
    }
#line 581
    if (AttacherPanic) {
      {
#line 583
      fcntl(0, 4, 0);
#line 584
      SetTTY(0, & attach_Mode);
#line 585
      printf((char const   *)((char *)"\nSuddenly the Dungeon collapses!! - You die...\n"));
#line 586
      eexit(1);
      }
    }
#line 590
    if (SuspendPlease) {
      {
#line 592
      SuspendPlease = 0;
#line 597
      xsignal(20, (__sighandler_t )0);
      }
      {
#line 598
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 598
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 599
      __cil_tmp4 = getpid();
#line 599
      kill(__cil_tmp4, 20);
      }
      {
#line 600
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 600
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 601
      xsignal(20, (void (*)(int  ))SigStop);
#line 602
      __cil_tmp5 = Attach(3);
      }
    }
#line 606
    if (LockPlease) {
      {
#line 608
      LockPlease = 0;
#line 613
      LockTerminal();
#line 617
      __cil_tmp6 = Attach(3);
      }
    }
#line 621
    if (SigWinchPlease) {
      {
#line 623
      SigWinchPlease = 0;
#line 627
      __cil_tmp7 = Attach(6);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 638 "/tmp/screen-3.9.15/attacher.c"
static char LockEnd[]  =    "Welcome back to screen !!\n";
#line 641 "/tmp/screen-3.9.15/attacher.c"
static void LockHup(int sigsig ) 
{ 
  int ppid ;
  __pid_t __cil_tmp3 ;

  {
  {
#line 643
  __cil_tmp3 = getppid();
#line 643
  ppid = __cil_tmp3;
#line 644
  setgid((__gid_t )real_gid);
#line 646
  setuid((__uid_t )own_uid);
  }
#line 650
  if (ppid > 1) {
    {
#line 651
    Kill(ppid, 1);
    }
  }
  {
#line 652
  exit(0);
  }
}
}
#line 656 "/tmp/screen-3.9.15/attacher.c"
static void LockTerminal(void) 
{ 
  char *prg ;
  int sig ;
  int pid ;
  void (*sigs[65])(int  ) ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp11 ;
  int *__cil_tmp12 ;
  int wstat ;
  int wret ;
  int *__cil_tmp15 ;
  int *__cil_tmp17 ;
  int *__cil_tmp18 ;
  int *__cil_tmp19 ;
  int *__cil_tmp20 ;
  char *tmp ;

  {
#line 662
  sig = 1;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! (sig < 65)) {
#line 662
      goto while_break;
    }
    {
#line 663
    sigs[sig] = xsignal(sig, (__sighandler_t )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 662
  sig ++;
#line 664
  xsignal(1, (void (*)(int  ))LockHup);
#line 665
  printf((char const   *)((char *)"\n"));
#line 667
  prg = getenv((char const   *)((char *)"LOCKPRG"));
#line 668
  __cil_tmp9 = access((char const   *)prg, 1);
  }
  {
#line 668
  __cil_tmp8 = strcmp((char const   *)prg, (char const   *)((char *)"builtin"));
  }
#line 668
  if (prg) {
#line 668
    if (__cil_tmp8) {
#line 668
      if (! __cil_tmp9) {
        {
#line 670
        xsignal(17, (__sighandler_t )0);
        }
        {
#line 671
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 671
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 672
        pid = fork();
        }
#line 672
        if (pid == 0) {
          {
#line 675
          setgid((__gid_t )real_gid);
#line 677
          setuid((__uid_t )own_uid);
#line 681
          closeallfiles(0);
#line 682
          execl((char const   *)prg, (char const   *)((char *)"SCREEN-LOCK"), (void *)0);
#line 683
          __cil_tmp11 = __errno_location();
#line 683
          exit(*__cil_tmp11);
          }
        }
#line 685
        if (pid == -1) {
          {
#line 686
          __cil_tmp12 = __errno_location();
#line 686
          Msg(*__cil_tmp12, (char *)"Cannot lock terminal - fork failed");
          }
        } else {
          {
#line 699
          __cil_tmp15 = __errno_location();
#line 699
          *__cil_tmp15 = 0;
          }
          {
#line 700
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 700
            if (! (wret != pid || (wret == -1 && *__cil_tmp17 == 4))) {
#line 700
              goto while_break___1;
            }
            {
#line 703
            __cil_tmp18 = __errno_location();
#line 703
            *__cil_tmp18 = 0;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 705
          __cil_tmp19 = __errno_location();
          }
#line 705
          if (*__cil_tmp19) {
            {
#line 707
            __cil_tmp20 = __errno_location();
#line 707
            Msg(*__cil_tmp20, (char *)"Lock");
#line 708
            sleep((unsigned int )2);
            }
          } else
#line 710
          if ((wstat & 127) != 0) {
#line 712
            if (wstat & 128) {
#line 712
              tmp = (char *)" (Core dumped)";
            } else {
#line 712
              tmp = (char *)"";
            }
            {
#line 712
            fprintf(stderr, (char const   *)((char *)"Lock: %s: Killed by signal: %d%s\n"),
                    prg, wstat & 127, tmp);
#line 714
            sleep((unsigned int )2);
            }
          } else
#line 716
          if ((wstat & 65280) >> 8) {
            {
#line 718
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 718
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 721
            printf((char const   *)((char *)LockEnd));
            }
          }
        }
      } else {
#line 668
        goto _L;
      }
    } else {
#line 668
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 726
    if (prg) {
      {
#line 728
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 728
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 732
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 732
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 734
    screen_builtin_lck();
    }
  }
#line 737
  sig = 1;
  {
#line 737
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 737
    if (! (sig < 65)) {
#line 737
      goto while_break___5;
    }
#line 739
    if (sigs[sig] != (void (*)(int  ))-1) {
      {
#line 740
      xsignal(sig, sigs[sig]);
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 737
  sig ++;
}
}
#line 806 "/tmp/screen-3.9.15/attacher.c"
static void screen_builtin_lck(void) 
{ 
  char fullname[100] ;
  char *cp1 ;
  char message[200] ;
  char *pass ;
  char mypass[17] ;
  char salt[3] ;
  int __cil_tmp9 ;
  time_t __cil_tmp10 ;
  time_t __cil_tmp11 ;
  int *__cil_tmp16 ;
  char *__cil_tmp18 ;
  size_t __cil_tmp19 ;
  int __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;

  {
#line 817
  pass = ppp->pw_passwd;
#line 818
  if (pass == (char *)0) {
    _L: /* CIL Label */ 
    {
#line 820
    pass = getpass((char const   *)((char *)"Key:   "));
    }
#line 820
    if (pass) {
      {
#line 822
      strncpy((char *)mypass, (char const   *)pass, sizeof(mypass) - 1UL);
#line 823
      mypass[sizeof(mypass) - 1UL] = (char )0;
      }
#line 824
      if ((int )*((char *)mypass) == 0) {
#line 825
        return;
      }
      {
#line 826
      pass = getpass((char const   *)((char *)"Again: "));
      }
#line 826
      if (pass) {
        {
#line 828
        __cil_tmp9 = strcmp((char const   *)((char *)mypass), (char const   *)pass);
        }
#line 828
        if (__cil_tmp9) {
          {
#line 830
          fprintf(stderr, (char const   *)((char *)"Passwords don\'t match.\a\n"));
#line 831
          sleep((unsigned int )2);
          }
#line 832
          return;
        }
      }
    }
#line 836
    if (pass == (char *)0) {
      {
#line 838
      fprintf(stderr, (char const   *)((char *)"Getpass error.\a\n"));
#line 839
      sleep((unsigned int )2);
      }
#line 840
      return;
    }
    {
#line 843
    __cil_tmp10 = time((time_t *)0);
#line 843
    salt[0] = (char )(65 + (int )(__cil_tmp10 % 26L));
#line 844
    __cil_tmp11 = time((time_t *)0);
#line 844
    salt[1] = (char )(65 + (int )((__cil_tmp11 >> 6) % 26L));
#line 845
    salt[2] = (char )0;
#line 846
    pass = crypt((char *)mypass, (char *)salt);
#line 847
    pass = SaveStr((char const   *)pass);
    }
  } else
#line 818
  if ((int )*pass == 0) {
#line 818
    goto _L;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  strncpy((char *)fullname, (char const   *)ppp->pw_gecos, sizeof(fullname) - 9UL);
#line 853
  fullname[sizeof(fullname) - 9UL] = (char )0;
#line 855
  cp1 = index((char const   *)((char *)fullname), ',');
  }
#line 855
  if (cp1 != (char *)((void *)0)) {
#line 856
    *cp1 = (char )'\000';
  }
  {
#line 857
  cp1 = index((char const   *)((char *)fullname), '&');
  }
#line 857
  if (cp1 != (char *)((void *)0)) {
    {
#line 859
    strncpy(cp1, (char const   *)ppp->pw_name, (unsigned long )8);
#line 860
    *(cp1 + 8) = (char )0;
    }
#line 861
    if ((int )*cp1 >= 97) {
#line 861
      if ((int )*cp1 <= 122) {
#line 862
        *cp1 -= 32;
      }
    }
  }
  {
#line 865
  sprintf((char *)message, (char const   *)((char *)"Screen used by %s <%s>.\nPassword:\a"),
          (char *)fullname, ppp->pw_name);
  }
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 869
    if (! 1) {
#line 869
      goto while_break___0;
    }
    {
#line 871
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 871
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 872
    __cil_tmp16 = __errno_location();
#line 872
    *__cil_tmp16 = 0;
#line 873
    cp1 = getpass((char const   *)((char *)message));
    }
#line 873
    if (cp1 == (char *)((void *)0)) {
      {
#line 875
      AttacherFinit(0);
      }
    }
    {
#line 889
    __cil_tmp18 = crypt(cp1, pass);
    }
    {
#line 889
    __cil_tmp19 = strlen((char const   *)pass);
#line 889
    __cil_tmp20 = strncmp((char const   *)__cil_tmp18, (char const   *)pass, __cil_tmp19);
    }
#line 889
    if (! __cil_tmp20) {
#line 890
      goto while_break___0;
    }
    {
#line 892
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 892
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 893
    __cil_tmp21 = strlen((char const   *)cp1);
#line 893
    bzero((void *)cp1, __cil_tmp21);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 895
  __cil_tmp22 = strlen((char const   *)cp1);
#line 895
  bzero((void *)cp1, __cil_tmp22);
  }
  {
#line 896
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 896
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 903 "/tmp/screen-3.9.15/attacher.c"
void SendCmdMessage(char *sty , char *match , char **av ) 
{ 
  int i ;
  int s ;
  struct msg m ;
  char *p ;
  int len ;
  int n ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp15 ;
  char *tmp ;
  int __cil_tmp18 ;
  int *__cil_tmp19 ;

  {
#line 913
  if (sty == (char *)0) {
    {
#line 915
    i = FindSocket(& s, (int *)0, (int *)0, match);
    }
#line 916
    if (i == 0) {
      {
#line 917
      Panic(0, (char *)"No screen session found.");
      }
    }
#line 918
    if (i != 1) {
      {
#line 919
      Panic(0, (char *)"Use -S to specify a session.");
      }
    }
  } else {
    {
#line 924
    __cil_tmp11 = strlen((char const   *)sty);
    }
#line 924
    if (__cil_tmp11 > 255UL) {
#line 925
      *(sty + 255) = (char )0;
    }
    {
#line 927
    __cil_tmp12 = strlen((char const   *)sty);
    }
#line 927
    if (__cil_tmp12 > 511UL) {
#line 928
      *(sty + 511) = (char )0;
    }
    {
#line 929
    __cil_tmp13 = strlen((char const   *)((char *)SockPath));
#line 929
    sprintf((char *)SockPath + __cil_tmp13, (char const   *)((char *)"/%s"), sty);
#line 930
    s = MakeClientSocket(1);
    }
#line 930
    if (s == -1) {
      {
#line 931
      exit(1);
      }
    }
  }
  {
#line 933
  bzero((void *)((char *)(& m)), sizeof(m));
#line 934
  m.type = 8;
  }
#line 935
  if (attach_tty) {
    {
#line 937
    strncpy((char *)m.m_tty, (char const   *)attach_tty, sizeof(m.m_tty) - 1UL);
#line 938
    m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
    }
  }
#line 940
  p = (char *)m.m.command.cmd;
#line 941
  n = 0;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    if (! (*av && n < 63)) {
#line 942
      goto while_break;
    }
    {
#line 944
    __cil_tmp15 = strlen((char const   *)*av);
#line 944
    len = (int )(__cil_tmp15 + 1UL);
    }
#line 945
    if (p + len >= ((char *)m.m.command.cmd + sizeof(m.m.command.cmd)) - 1) {
#line 946
      goto while_break;
    }
    {
#line 947
    strcpy(p, (char const   *)*av);
#line 948
    p += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 942
  n ++;
  {
#line 942
  av ++;
#line 950
  *p = (char )0;
#line 951
  m.m.command.nargs = n;
#line 952
  strncpy((char *)m.m.attach.auser, (char const   *)LoginName, sizeof(m.m.attach.auser) - 1UL);
#line 953
  m.m.command.auser[sizeof(m.m.command.auser) - 1UL] = (char )0;
#line 954
  m.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  }
#line 955
  if (preselect) {
#line 955
    tmp = preselect;
  } else {
#line 955
    tmp = (char *)"";
  }
  {
#line 955
  strncpy((char *)m.m.command.preselect, (char const   *)tmp, sizeof(m.m.command.preselect) - 1UL);
#line 956
  m.m.command.preselect[sizeof(m.m.command.preselect) - 1UL] = (char )0;
#line 957
  m.m.command.apid = getpid();
  }
  {
#line 958
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 958
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 959
  __cil_tmp18 = WriteMessage(s, & m);
  }
#line 959
  if (__cil_tmp18) {
    {
#line 960
    __cil_tmp19 = __errno_location();
#line 960
    Msg(*__cil_tmp19, (char *)"write");
    }
  }
  {
#line 961
  close(s);
  }
}
}
#line 115 "./extern.h"
void inp_setprompt(char *p , char *s ) ;
#line 34 "/tmp/screen-3.9.15/input.c"
static void InpProcess(char **ppbuf , int *plen ) ;
#line 35
static void InpAbort(void) ;
#line 36
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 49
static struct inpline inphist ;
#line 63 "/tmp/screen-3.9.15/input.c"
static struct LayFuncs InpLf  =    {InpProcess, InpAbort, InpRedisplayLine, DefClearLine, DefRewrite, DefResize, DefRestore};
#line 80 "/tmp/screen-3.9.15/input.c"
void inp_setprompt(char *p , char *s ) 
{ 
  struct inpdata *inpdata ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
#line 85
  inpdata = (struct inpdata *)flayer->l_data;
#line 86
  if (p) {
    {
#line 88
    __cil_tmp4 = strlen((char const   *)p);
#line 88
    inpdata->inpstringlen = (int )__cil_tmp4;
#line 89
    inpdata->inpstring = p;
    }
  }
#line 91
  if (s) {
#line 93
    if (s != (char *)inpdata->inp.buf) {
      {
#line 94
      strncpy((char *)inpdata->inp.buf, (char const   *)s, sizeof(inpdata->inp.buf) - 1UL);
      }
    }
    {
#line 95
    inpdata->inp.buf[sizeof(inpdata->inp.buf) - 1UL] = (char )0;
#line 96
    __cil_tmp5 = strlen((char const   *)((char *)inpdata->inp.buf));
#line 96
    inpdata->inp.len = (int )__cil_tmp5;
#line 96
    inpdata->inp.pos = inpdata->inp.len;
    }
  }
  {
#line 98
  InpRedisplayLine(flayer->l_height - 1, 0, flayer->l_width - 1, 0);
  }
}
}
#line 112 "/tmp/screen-3.9.15/input.c"
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *data ) , char *data ) 
{ 
  int maxlen ;
  struct inpdata *inpdata ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 122
  if (len > 100) {
#line 123
    len = 100;
  }
#line 124
  if (! (mode & 1)) {
    {
#line 126
    __cil_tmp8 = strlen((char const   *)istr);
#line 126
    maxlen = (int )((unsigned long )(flayer->l_width - 1) - __cil_tmp8);
    }
#line 127
    if (len > maxlen) {
#line 128
      len = maxlen;
    }
  }
#line 130
  if (len < 0) {
    {
#line 132
    LMsg(0, (char *)"Width %d chars too small", - len);
    }
#line 133
    return;
  }
  {
#line 135
  __cil_tmp9 = InitOverlayPage((int )sizeof(*inpdata), & InpLf, 1);
  }
#line 135
  if (__cil_tmp9) {
#line 136
    return;
  }
  {
#line 137
  inpdata = (struct inpdata *)flayer->l_data;
#line 138
  inpdata->inpmaxlen = len;
#line 139
  inpdata->inpfinfunc = finfunc;
#line 140
  inpdata->inp.len = 0;
#line 140
  inpdata->inp.pos = inpdata->inp.len;
#line 141
  inpdata->inpmode = mode;
#line 142
  inpdata->priv = data;
#line 143
  inp_setprompt(istr, (char *)((void *)0));
#line 144
  flayer->l_x = inpdata->inpstringlen;
#line 145
  flayer->l_y = flayer->l_height - 1;
  }
}
}
#line 149 "/tmp/screen-3.9.15/input.c"
static void InpProcess(char **ppbuf , int *plen ) 
{ 
  int len___252 ;
  int x ;
  char *pbuf ;
  char ch ;
  struct inpdata *inpdata ;
  struct display *inpdisplay ;
  int tmp ;
  char *p ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  struct mchar mc ;
  char *__cil_tmp16 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;
  struct mchar mc___0 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  struct mchar mc___1 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___267 ;

  {
#line 159
  inpdata = (struct inpdata *)flayer->l_data;
#line 160
  inpdisplay = display;
#line 162
  if (inpdata->inpmode & 1) {
#line 162
    tmp = 0;
  } else {
#line 162
    tmp = inpdata->inp.pos;
  }
  {
#line 162
  LGotoPos(flayer, inpdata->inpstringlen + tmp, flayer->l_height - 1);
  }
#line 163
  if (ppbuf == (char **)0) {
    {
#line 165
    InpAbort();
    }
#line 166
    return;
  }
#line 168
  x = inpdata->inpstringlen + inpdata->inp.pos;
#line 169
  len___252 = *plen;
#line 170
  pbuf = *ppbuf;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! len___252) {
#line 171
      goto while_break;
    }
#line 173
    p = (char *)inpdata->inp.buf + inpdata->inp.pos;
#line 175
    __cil_tmp11 = pbuf;
#line 175
    pbuf ++;
#line 175
    ch = *__cil_tmp11;
#line 176
    __cil_tmp12 = len___252;
#line 176
    len___252 --;
#line 177
    if (inpdata->inpmode & 4) {
      {
#line 179
      inpdata->inp.buf[inpdata->inp.len] = ch;
#line 180
      inpdata->inp.buf[inpdata->inp.len + 1] = ch;
#line 181
      display = inpdisplay;
#line 182
      ((void (*)(char * , int  , char * ))*(inpdata->inpfinfunc))((char *)inpdata->inp.buf,
                                                                  inpdata->inp.len,
                                                                  inpdata->priv);
#line 183
      ch = inpdata->inp.buf[inpdata->inp.len];
      }
    } else
#line 185
    if (inpdata->inpmode & 2) {
      {
#line 187
      display = inpdisplay;
#line 188
      ((void (*)(char * , int  , char * ))*(inpdata->inpfinfunc))(& ch, 1, inpdata->priv);
      }
#line 189
      if (ch) {
#line 190
        goto while_continue;
      }
    }
#line 192
    if (((int )((unsigned char )ch) & 127) >= 32) {
#line 192
      if ((int )ch != 127) {
#line 192
        if (inpdata->inp.len < inpdata->inpmaxlen) {
#line 194
          if (inpdata->inp.len > inpdata->inp.pos) {
            {
#line 195
            bcopy((void const   *)p, (void *)(p + 1), (size_t )(inpdata->inp.len - inpdata->inp.pos));
            }
          }
#line 196
          __cil_tmp13 = inpdata->inp.pos;
#line 196
          (inpdata->inp.pos) ++;
#line 196
          inpdata->inp.buf[__cil_tmp13] = ch;
#line 197
          (inpdata->inp.len) ++;
#line 199
          if (! (inpdata->inpmode & 1)) {
            {
#line 202
            mc = mchar_so;
#line 203
            __cil_tmp16 = p;
#line 203
            p ++;
#line 203
            mc.image = (unsigned char )*__cil_tmp16;
#line 204
            LPutChar(flayer, & mc, x, flayer->l_height - 1);
#line 205
            x ++;
            }
#line 206
            if (p < (char *)inpdata->inp.buf + inpdata->inp.len) {
              {
#line 208
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 208
                if (! (p < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 208
                  goto while_break___0;
                }
                {
#line 210
                __cil_tmp18 = p;
#line 210
                p ++;
#line 210
                mc.image = (unsigned char )*__cil_tmp18;
#line 211
                __cil_tmp19 = x;
#line 211
                x ++;
#line 211
                LPutChar(flayer, & mc, __cil_tmp19, flayer->l_height - 1);
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 213
              x = inpdata->inpstringlen + inpdata->inp.pos;
#line 214
              LGotoPos(flayer, x, flayer->l_height - 1);
              }
            }
          }
        } else {
#line 192
          goto _L___265;
        }
      } else {
#line 192
        goto _L___265;
      }
    } else
    _L___265: /* CIL Label */ 
#line 218
    if ((int )ch == 8) {
      _L___264: /* CIL Label */ 
#line 218
      if (inpdata->inp.pos > 0) {
#line 220
        if (inpdata->inp.len > inpdata->inp.pos) {
          {
#line 221
          bcopy((void const   *)p, (void *)(p - 1), (size_t )(inpdata->inp.len - inpdata->inp.pos));
          }
        }
#line 222
        __cil_tmp20 = inpdata->inp.len;
#line 222
        (inpdata->inp.len) --;
#line 223
        __cil_tmp21 = inpdata->inp.pos;
#line 223
        (inpdata->inp.pos) --;
#line 224
        __cil_tmp22 = p;
#line 224
        p --;
#line 226
        if (! (inpdata->inpmode & 1)) {
#line 229
          mc___0 = mchar_so;
#line 230
          __cil_tmp24 = x;
#line 230
          x --;
          {
#line 231
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 231
            if (! (p < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 231
              goto while_break___1;
            }
            {
#line 233
            __cil_tmp25 = p;
#line 233
            p ++;
#line 233
            mc___0.image = (unsigned char )*__cil_tmp25;
#line 234
            __cil_tmp26 = x;
#line 234
            x ++;
#line 234
            LPutChar(flayer, & mc___0, __cil_tmp26, flayer->l_height - 1);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 236
          LPutChar(flayer, & mchar_blank, x, flayer->l_height - 1);
#line 237
          x = inpdata->inpstringlen + inpdata->inp.pos;
#line 238
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      } else {
#line 218
        goto _L___263;
      }
    } else
#line 218
    if ((int )ch == 127) {
#line 218
      goto _L___264;
    } else
    _L___263: /* CIL Label */ 
#line 241
    if ((int )ch == 21) {
#line 243
      x = inpdata->inpstringlen;
#line 244
      if (inpdata->inp.len) {
#line 244
        if (! (inpdata->inpmode & 1)) {
          {
#line 246
          LClearArea(flayer, x, flayer->l_height - 1, (x + inpdata->inp.len) - 1,
                     flayer->l_height - 1, 0, 0);
#line 247
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 249
      inpdata->inp.pos = 0;
#line 249
      inpdata->inp.len = inpdata->inp.pos;
    } else
#line 251
    if ((int )ch == 11) {
#line 253
      x = inpdata->inpstringlen + inpdata->inp.pos;
#line 254
      if (inpdata->inp.len > inpdata->inp.pos) {
#line 254
        if (! (inpdata->inpmode & 1)) {
          {
#line 256
          LClearArea(flayer, x, flayer->l_height - 1, ((x + inpdata->inp.len) - inpdata->inp.pos) - 1,
                     flayer->l_height - 1, 0, 0);
#line 257
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 259
      inpdata->inp.len = inpdata->inp.pos;
    } else
#line 261
    if ((int )ch == 1) {
      {
#line 263
      x -= inpdata->inp.pos;
      {
#line 263
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 264
      inpdata->inp.pos = 0;
      }
    } else
#line 261
    if ((int )((unsigned char )ch) == 129) {
      {
#line 263
      x -= inpdata->inp.pos;
      {
#line 263
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 264
      inpdata->inp.pos = 0;
      }
    } else
#line 266
    if ((int )ch == 2) {
      _L___262: /* CIL Label */ 
#line 266
      if (inpdata->inp.pos > 0) {
        {
#line 268
        x --;
#line 268
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 269
        __cil_tmp27 = inpdata->inp.pos;
#line 269
        (inpdata->inp.pos) --;
        }
      } else {
#line 266
        goto _L___261;
      }
    } else
#line 266
    if ((int )((unsigned char )ch) == 130) {
#line 266
      goto _L___262;
    } else
    _L___261: /* CIL Label */ 
#line 271
    if ((int )ch == 5) {
      {
#line 273
      x += inpdata->inp.len - inpdata->inp.pos;
      {
#line 273
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 274
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 271
    if ((int )((unsigned char )ch) == 133) {
      {
#line 273
      x += inpdata->inp.len - inpdata->inp.pos;
      {
#line 273
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 274
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 276
    if ((int )ch == 6) {
      _L___260: /* CIL Label */ 
#line 276
      if (inpdata->inp.pos < inpdata->inp.len) {
        {
#line 278
        x ++;
#line 278
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 279
        (inpdata->inp.pos) ++;
        }
      } else {
#line 276
        goto _L___259;
      }
    } else
#line 276
    if ((int )((unsigned char )ch) == 134) {
#line 276
      goto _L___260;
    } else
    _L___259: /* CIL Label */ 
#line 281
    if ((int )ch == 16) {
      _L___258: /* CIL Label */ 
#line 284
      mc___1 = mchar_so;
#line 285
      if (inpdata->inp.len) {
#line 285
        if (! (inpdata->inpmode & 1)) {
          {
#line 286
          LClearArea(flayer, inpdata->inpstringlen, flayer->l_height - 1, (inpdata->inpstringlen + inpdata->inp.len) - 1,
                     flayer->l_height - 1, 0, 0);
          }
        }
      }
#line 288
      inpdata->inp = inphist;
#line 289
      if (inpdata->inp.len > inpdata->inpmaxlen) {
#line 290
        inpdata->inp.len = inpdata->inpmaxlen;
      }
#line 291
      if (inpdata->inp.pos > inpdata->inp.len) {
#line 292
        inpdata->inp.pos = inpdata->inp.len;
      }
#line 294
      x = inpdata->inpstringlen;
#line 295
      p = (char *)inpdata->inp.buf;
#line 297
      if (! (inpdata->inpmode & 1)) {
        {
#line 299
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 299
          if (! (p < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 299
            goto while_break___2;
          }
          {
#line 301
          __cil_tmp30 = p;
#line 301
          p ++;
#line 301
          mc___1.image = (unsigned char )*__cil_tmp30;
#line 302
          __cil_tmp31 = x;
#line 302
          x ++;
#line 302
          LPutChar(flayer, & mc___1, __cil_tmp31, flayer->l_height - 1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 305
      x = inpdata->inpstringlen + inpdata->inp.pos;
#line 306
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
    } else
#line 281
    if ((int )((unsigned char )ch) == 144) {
#line 281
      goto _L___258;
    } else
#line 309
    if ((int )ch == 4) {
      _L: /* CIL Label */ 
#line 312
      if ((int )ch != 4) {
#line 312
        if ((int )ch != 10) {
#line 312
          if ((int )ch != 13) {
#line 313
            inpdata->inp.len = 0;
          }
        }
      }
#line 314
      inpdata->inp.buf[inpdata->inp.len] = (char )0;
#line 316
      if (inpdata->inp.len) {
#line 316
        if (inpdata->inpmode == 0) {
#line 317
          inphist = inpdata->inp;
        }
      }
      {
#line 319
      flayer->l_data = (char *)0;
#line 320
      InpAbort();
#line 321
      *ppbuf = pbuf;
#line 322
      *plen = len___252;
#line 323
      display = inpdisplay;
      }
#line 324
      if ((inpdata->inpmode & 2) == 0) {
        {
#line 325
        ((void (*)(char * , int  , char * ))*(inpdata->inpfinfunc))((char *)inpdata->inp.buf,
                                                                    inpdata->inp.len,
                                                                    inpdata->priv);
        }
      } else {
        {
#line 327
        ((void (*)(char * , int  , char * ))*(inpdata->inpfinfunc))(pbuf - 1, 0, inpdata->priv);
        }
      }
      {
#line 328
      free((void *)((char *)inpdata));
      }
#line 329
      return;
    } else
#line 309
    if ((int )ch == 3) {
#line 309
      goto _L;
    } else
#line 309
    if ((int )ch == 7) {
#line 309
      goto _L;
    } else
#line 309
    if ((int )ch == 27) {
#line 309
      goto _L;
    } else
#line 309
    if ((int )ch == 0) {
#line 309
      goto _L;
    } else
#line 309
    if ((int )ch == 10) {
#line 309
      goto _L;
    } else
#line 309
    if ((int )ch == 13) {
#line 309
      goto _L;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  if (! (inpdata->inpmode & 2)) {
#line 334
    if (inpdata->inpmode & 1) {
#line 334
      tmp___267 = 0;
    } else {
#line 334
      tmp___267 = inpdata->inp.pos;
    }
#line 334
    flayer->l_x = inpdata->inpstringlen + tmp___267;
#line 335
    flayer->l_y = flayer->l_height - 1;
  }
#line 337
  *ppbuf = pbuf;
#line 338
  *plen = len___252;
}
}
#line 342 "/tmp/screen-3.9.15/input.c"
static void InpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    oldlay = flayer;
    {
#line 344
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 344
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 344
    flayer = flayer->l_next;
#line 344
    oldcvlist = flayer->l_cvlist;
    {
#line 344
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 344
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 344
    flayer->l_cvlist = oldlay->l_cvlist;
#line 344
    cv = flayer->l_cvlist;
    {
#line 344
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 344
      if (! cv) {
#line 344
        goto while_break___2;
      }
#line 344
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 344
    cv = cv->c_lnext;
#line 344
    ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1,
                                                                                      0,
                                                                                      flayer->l_width - 1,
                                                                                      0);
#line 344
    flayer = oldlay;
#line 344
    cv = flayer->l_cvlist;
    }
    {
#line 344
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 344
      if (! cv) {
#line 344
        goto while_break___3;
      }
#line 344
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 344
    cv = cv->c_lnext;
#line 344
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 344
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  ExitOverlayPage();
  }
}
}
#line 349 "/tmp/screen-3.9.15/input.c"
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int q ;
  int r ;
  int s ;
  int l ;
  int v ;
  struct inpdata *inpdata ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
#line 355
  inpdata = (struct inpdata *)flayer->l_data;
#line 356
  if (y != flayer->l_height - 1) {
    {
#line 358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 358
      oldlay = flayer;
      {
#line 358
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 358
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 358
      flayer = flayer->l_next;
#line 358
      oldcvlist = flayer->l_cvlist;
      {
#line 358
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 358
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 358
      flayer->l_cvlist = oldlay->l_cvlist;
#line 358
      cv = flayer->l_cvlist;
      {
#line 358
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 358
        if (! cv) {
#line 358
          goto while_break___2;
        }
#line 358
        cv->c_layer = flayer;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 358
      cv = cv->c_lnext;
#line 358
      ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(y,
                                                                                        xs,
                                                                                        xe,
                                                                                        isblank);
#line 358
      flayer = oldlay;
#line 358
      cv = flayer->l_cvlist;
      }
      {
#line 358
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 358
        if (! cv) {
#line 358
          goto while_break___3;
        }
#line 358
        cv->c_layer = flayer;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 358
      cv = cv->c_lnext;
#line 358
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 358
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 359
    return;
  }
#line 361
  inpdata->inp.buf[inpdata->inp.len] = (char )0;
#line 362
  q = xs;
#line 363
  v = (xe - xs) + 1;
#line 364
  s = 0;
#line 365
  r = inpdata->inpstringlen;
#line 366
  if (v > 0) {
#line 366
    if (q < r) {
#line 368
      l = v;
#line 369
      if (l > r - q) {
#line 370
        l = r - q;
      }
      {
#line 371
      LPutStr(flayer, (inpdata->inpstring + q) - s, l, & mchar_so, q, y);
#line 372
      q += l;
#line 373
      v -= l;
      }
    }
  }
#line 375
  s = r;
#line 376
  r += inpdata->inp.len;
#line 377
  if (! (inpdata->inpmode & 1)) {
#line 377
    if (v > 0) {
#line 377
      if (q < r) {
#line 379
        l = v;
#line 380
        if (l > r - q) {
#line 381
          l = r - q;
        }
        {
#line 382
        LPutStr(flayer, ((char *)inpdata->inp.buf + q) - s, l, & mchar_so, q, y);
#line 383
        q += l;
#line 384
        v -= l;
        }
      }
    }
  }
#line 386
  s = r;
#line 387
  r = flayer->l_width;
#line 388
  if (! isblank) {
#line 388
    if (v > 0) {
#line 388
      if (q < r) {
#line 390
        l = v;
#line 391
        if (l > r - q) {
#line 392
          l = r - q;
        }
        {
#line 393
        LClearArea(flayer, q, y, (q + l) - 1, y, 0, 0);
#line 394
        q += l;
        }
      }
    }
  }
}
}
#line 399 "/tmp/screen-3.9.15/input.c"
int InInput(void) 
{ 


  {
#line 401
  if (flayer) {
#line 401
    if (flayer->l_layfn == & InpLf) {
#line 402
      return (1);
    }
  }
#line 403
  return (0);
}
}
#line 75 "./osdef.h"
extern int tgetent(char * , char * ) ;
#line 76
extern char *tgetstr(char * , char ** ) ;
#line 77
extern int tgetnum(char * ) ;
#line 78
extern int tgetflag(char * ) ;
#line 210 "./extern.h"
int InitTermcap(int wi , int he ) ;
#line 212
char *gettermcapstring(char *s ) ;
#line 217
int CreateTransTable(char *s ) ;
#line 330
char *InStr(char *str , char const   *pat ) ;
#line 354
void xsetegid(int egid ) ;
#line 36 "/tmp/screen-3.9.15/termcap.c"
int force_vt ;
#line 49
static void AddCap(char *s ) ;
#line 50
static void MakeString(char *cap , char *buf , int buflen , char *s ) ;
#line 51
static char *findcap(char *cap , char **tepp , int n ) ;
#line 52
static int copyarg(char **pp , char *s ) ;
#line 53
static int e_tgetent(char *bp , char *name ) ;
#line 54
static char *e_tgetstr(char *cap , char **tepp ) ;
#line 55
static int e_tgetflag(char *cap ) ;
#line 56
static int e_tgetnum(char *cap ) ;
#line 58
static int addmapseq(char *seq , int nr ) ;
#line 59
static int remmapseq(char *seq ) ;
#line 66
char Termcap[2056] ;
#line 67
static int Termcaplen ;
#line 68
static int tcLineLen ;
#line 69
char Term[261] ;
#line 72
char *extra_incap ;
#line 72
char *extra_outcap ;
#line 74 "/tmp/screen-3.9.15/termcap.c"
static char const   TermcapConst[]  =    "\\\n\t:DO=\\E[%dB:LE=\\E[%dD:RI=\\E[%dC:UP=\\E[%dA:bs:bt=\\E[Z:\\\n\t:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:cm=\\E[%i%d;%dH:ct=\\E[3g:\\\n\t:do=^J:nd=\\E[C:pt:rc=\\E8:rs=\\Ec:sc=\\E7:st=\\EH:up=\\EM:\\\n\t:le=^H:bl=^G:cr=^M:it#8:ho=\\E[H:nw=\\EE:ta=^I:is=\\E)0:";
#line 81 "/tmp/screen-3.9.15/termcap.c"
char *gettermcapstring(char *s ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 86
  if (display == (struct display *)0) {
#line 87
    return ((char *)0);
  } else
#line 86
  if (s == (char *)0) {
#line 87
    return ((char *)0);
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 188)) {
#line 88
      goto while_break;
    }
#line 90
    if (term[i].type != 2) {
#line 91
      goto while_continue;
    }
    {
#line 92
    __cil_tmp3 = strcmp((char const   *)term[i].tcname, (char const   *)s);
    }
#line 92
    if (__cil_tmp3 == 0) {
#line 93
      return (display->d_tcs[i].str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  i ++;
#line 95
  return ((char *)0);
}
}
#line 104 "/tmp/screen-3.9.15/termcap.c"
int InitTermcap(int wi , int he ) 
{ 
  register char *s ;
  int i ;
  char tbuf[2048] ;
  char *tp ;
  int t ;
  int xue ;
  int xse ;
  int xme ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  unsigned long tmp ;
  void *__cil_tmp14 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int tmp___268 ;
  int tmp___269 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int tmp___273 ;
  int tmp___274 ;
  int __cil_tmp42 ;
  char *tmp___275 ;
  char *tmp___276 ;
  size_t __cil_tmp46 ;
  size_t __cil_tmp47 ;
  int __cil_tmp48 ;
  int enc ;
  int __cil_tmp50 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  bzero((void *)((char *)tbuf), sizeof(tbuf));
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 116
  __cil_tmp11 = e_tgetent((char *)tbuf, (char *)display->d_termname);
  }
#line 116
  if ((int )*((char *)display->d_termname) == 0) {
    {
    {
#line 119
    Msg(0, (char *)"Cannot find terminfo entry for \'%s\'.", (char *)display->d_termname);
    }
    }
#line 123
    return (- 1);
  } else
#line 116
  if (__cil_tmp11 != 1) {
    {
    {
#line 119
    Msg(0, (char *)"Cannot find terminfo entry for \'%s\'.", (char *)display->d_termname);
    }
    }
#line 123
    return (- 1);
  }
  {
#line 125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 125
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 133
  if (extra_incap) {
    {
#line 133
    __cil_tmp12 = strlen((char const   *)extra_incap);
#line 133
    tmp = __cil_tmp12 + 1UL;
    }
  } else {
#line 133
    tmp = (unsigned long )0;
  }
  {
#line 133
  __cil_tmp14 = malloc(2048UL + tmp);
#line 133
  display->d_tentry = (char *)__cil_tmp14;
  }
#line 133
  if (display->d_tentry == (char *)0) {
    {
#line 135
    Msg(0, (char *)strnomem);
    }
#line 136
    return (- 1);
  }
#line 142
  tp = display->d_tentry;
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 188)) {
#line 143
      goto while_break___2;
    }
    {
#line 147
    if (term[i].type == 0) {
#line 147
      goto case_0;
    }
#line 150
    if (term[i].type == 1) {
#line 150
      goto case_1;
    }
#line 153
    if (term[i].type == 2) {
#line 153
      goto case_2;
    }
#line 159
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 148
    display->d_tcs[i].flg = e_tgetflag(term[i].tcname);
    }
#line 149
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 151
    display->d_tcs[i].num = e_tgetnum(term[i].tcname);
    }
#line 152
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 154
    display->d_tcs[i].str = e_tgetstr(term[i].tcname, & tp);
    }
#line 156
    if (display->d_tcs[i].str) {
#line 156
      if ((int )*(display->d_tcs[i].str) == 0) {
#line 157
        display->d_tcs[i].str = (char *)0;
      }
    }
#line 158
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 160
    Panic(0, (char *)"Illegal tc type in entry #%d", i);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 143
  i ++;
#line 168
  if (display->d_tcs[2].flg) {
    {
#line 170
    Msg(0, (char *)"You can\'t run screen on a hardcopy terminal.");
    }
#line 171
    return (- 1);
  }
#line 173
  if (display->d_tcs[3].flg) {
    {
#line 175
    Msg(0, (char *)"You can\'t run screen on a terminal that overstrikes.");
    }
#line 176
    return (- 1);
  }
#line 178
  if (! display->d_tcs[34].str) {
    {
#line 180
    Msg(0, (char *)"Clear screen capability required.");
    }
#line 181
    return (- 1);
  }
#line 183
  if (! display->d_tcs[5].str) {
    {
#line 185
    Msg(0, (char *)"Addressable cursor capability required.");
    }
#line 186
    return (- 1);
  }
  {
#line 188
  i = atoi((char const   *)s);
  }
  {
#line 188
  s = getenv((char const   *)((char *)"COLUMNS"));
  }
#line 188
  if (s) {
#line 188
    if (i > 0) {
#line 189
      display->d_tcs[1].num = i;
    }
  }
  {
#line 190
  i = atoi((char const   *)s);
  }
  {
#line 190
  s = getenv((char const   *)((char *)"LINES"));
  }
#line 190
  if (s) {
#line 190
    if (i > 0) {
#line 191
      display->d_tcs[0].num = i;
    }
  }
#line 192
  if (wi) {
#line 193
    display->d_tcs[1].num = wi;
  }
#line 194
  if (he) {
#line 195
    display->d_tcs[0].num = he;
  }
#line 196
  if (display->d_tcs[1].num <= 0) {
#line 197
    display->d_tcs[1].num = 80;
  }
#line 198
  if (display->d_tcs[0].num <= 0) {
#line 199
    display->d_tcs[0].num = 24;
  }
#line 201
  if (display->d_tcs[95].flg) {
    {
#line 205
    __cil_tmp24 = InStr(display->d_tcs[55].str, (char const   *)((char *)"\033[0m"));
    }
    {
#line 205
    __cil_tmp23 = InStr(display->d_tcs[55].str, (char const   *)((char *)"\033[m"));
    }
#line 205
    if (! display->d_tcs[60].str) {
#line 205
      if (display->d_tcs[55].str) {
#line 205
        if (__cil_tmp23) {
#line 208
          display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 209
          display->d_tcs[61].str = (char *)"\033[4%p1%dm";
        } else
#line 205
        if (__cil_tmp24) {
#line 208
          display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 209
          display->d_tcs[61].str = (char *)"\033[4%p1%dm";
        }
      }
    }
    {
#line 215
    __cil_tmp25 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[39;49m"));
    }
#line 215
    if (display->d_tcs[64].str) {
#line 215
      if (__cil_tmp25) {
#line 216
        display->d_tcs[67].flg = 1;
      }
    }
    {
#line 217
    __cil_tmp27 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[0m"));
    }
    {
#line 217
    __cil_tmp26 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[m"));
    }
#line 217
    if (display->d_tcs[64].str) {
#line 217
      if (__cil_tmp26) {
#line 218
        display->d_tcs[64].str = (char *)0;
      } else
#line 217
      if (__cil_tmp27) {
#line 218
        display->d_tcs[64].str = (char *)0;
      }
    }
    {
#line 220
    __cil_tmp29 = InStr(display->d_tcs[101].str, (char const   *)((char *)"\033(0"));
    }
    {
#line 220
    __cil_tmp28 = InStr(display->d_tcs[104].str, (char const   *)((char *)"\033(B"));
    }
#line 220
    if (display->d_tcs[104].str) {
#line 220
      if (__cil_tmp28) {
#line 221
        display->d_tcs[97].flg = 1;
      } else {
#line 220
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 220
    if (display->d_tcs[101].str) {
#line 220
      if (__cil_tmp29) {
#line 221
        display->d_tcs[97].flg = 1;
      }
    }
    {
#line 222
    __cil_tmp31 = InStr((char *)display->d_termname, (char const   *)((char *)"rxvt"));
    }
    {
#line 222
    __cil_tmp30 = InStr((char *)display->d_termname, (char const   *)((char *)"xterm"));
    }
#line 222
    if (__cil_tmp30) {
#line 223
      display->d_tcs[96].flg = 1;
    } else
#line 222
    if (__cil_tmp31) {
#line 223
      display->d_tcs[96].flg = 1;
    }
#line 225
    if (display->d_tcs[96].flg) {
#line 226
      display->d_tcs[66].flg = 1;
    }
  }
#line 228
  if (nwin_options.flowflag == nwin_undef.flowflag) {
#line 229
    if (display->d_tcs[88].flg) {
#line 229
      tmp___269 = 0;
    } else {
#line 229
      if (display->d_tcs[89].flg) {
#line 229
        tmp___268 = 1;
      } else {
#line 229
        tmp___268 = 1 << 2;
      }
#line 229
      tmp___269 = tmp___268;
    }
#line 229
    nwin_default.flowflag = tmp___269;
  }
#line 232
  display->d_tcs[87].flg |= (! display->d_tcs[83].flg || display->d_tcs[84].flg) || display->d_tcs[85].flg;
#line 233
  if (! display->d_tcs[42].str) {
#line 234
    display->d_tcs[42].str = (char *)"\a";
  }
#line 235
  if (! display->d_tcs[13].str) {
#line 237
    if (display->d_tcs[12].flg) {
#line 238
      display->d_tcs[13].str = (char *)"\b";
    } else {
#line 240
      display->d_tcs[13].str = display->d_tcs[14].str;
    }
  }
#line 242
  if (! display->d_tcs[7].str) {
#line 243
    display->d_tcs[7].str = (char *)"\r";
  }
#line 244
  if (! display->d_tcs[19].str) {
#line 245
    display->d_tcs[19].str = (char *)"\n";
  }
#line 253
  if (display->d_tcs[58].num > 0) {
#line 254
    display->d_tcs[53].str = (char *)0;
#line 254
    display->d_tcs[48].str = display->d_tcs[53].str;
  }
#line 255
  if (display->d_tcs[57].num > 0) {
#line 256
    display->d_tcs[54].str = (char *)0;
#line 256
    display->d_tcs[51].str = display->d_tcs[54].str;
  }
#line 260
  if (display->d_tcs[58].num > 0) {
#line 260
    if (display->d_tcs[57].num > 0) {
#line 261
      display->d_tcs[55].str = (char *)0;
#line 261
      display->d_tcs[52].str = display->d_tcs[55].str;
#line 261
      display->d_tcs[50].str = display->d_tcs[52].str;
#line 261
      display->d_tcs[49].str = display->d_tcs[50].str;
#line 261
      display->d_tcs[47].str = display->d_tcs[49].str;
    }
  }
#line 263
  xue = 1 << 2;
#line 264
  xse = 1 << 1;
#line 265
  xme = 1;
#line 267
  if (display->d_tcs[51].str) {
#line 267
    if (display->d_tcs[54].str == (char *)0) {
      {
#line 269
      Msg(0, (char *)"Warning: \'so\' but no \'se\' capability.");
      }
#line 270
      if (display->d_tcs[55].str) {
#line 271
        xse = xme;
      } else {
#line 273
        display->d_tcs[51].str = (char *)0;
      }
    }
  }
#line 275
  if (display->d_tcs[48].str) {
#line 275
    if (display->d_tcs[53].str == (char *)0) {
      {
#line 277
      Msg(0, (char *)"Warning: \'us\' but no \'ue\' capability.");
      }
#line 278
      if (display->d_tcs[55].str) {
#line 279
        xue = xme;
      } else {
#line 281
        display->d_tcs[48].str = (char *)0;
      }
    }
  }
#line 283
  if (display->d_tcs[47].str) {
    _L___270: /* CIL Label */ 
#line 283
    if (display->d_tcs[55].str == (char *)0) {
      {
#line 285
      Msg(0, (char *)"Warning: \'m?\' but no \'me\' capability.");
#line 286
      display->d_tcs[52].str = (char *)0;
#line 286
      display->d_tcs[50].str = display->d_tcs[52].str;
#line 286
      display->d_tcs[49].str = display->d_tcs[50].str;
#line 286
      display->d_tcs[47].str = display->d_tcs[49].str;
      }
    }
  } else
#line 283
  if (display->d_tcs[49].str) {
#line 283
    goto _L___270;
  } else
#line 283
  if (display->d_tcs[50].str) {
#line 283
    goto _L___270;
  } else
#line 283
  if (display->d_tcs[52].str) {
#line 283
    goto _L___270;
  }
  {
#line 293
  __cil_tmp34 = strcmp((char const   *)display->d_tcs[54].str, (char const   *)display->d_tcs[53].str);
  }
#line 293
  if (display->d_tcs[53].str) {
#line 293
    if (display->d_tcs[54].str) {
#line 293
      if (__cil_tmp34 == 0) {
#line 294
        xse = xue;
      }
    }
  }
  {
#line 295
  __cil_tmp35 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[54].str);
  }
#line 295
  if (display->d_tcs[54].str) {
#line 295
    if (display->d_tcs[55].str) {
#line 295
      if (__cil_tmp35 == 0) {
#line 296
        xse = xme;
      }
    }
  }
  {
#line 297
  __cil_tmp36 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[53].str);
  }
#line 297
  if (display->d_tcs[53].str) {
#line 297
    if (display->d_tcs[55].str) {
#line 297
      if (__cil_tmp36 == 0) {
#line 298
        xue = xme;
      }
    }
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 300
    if (! (i < 6)) {
#line 300
      goto while_break___3;
    }
#line 302
    display->d_attrtab[i] = display->d_tcs[47 + i].str;
#line 303
    if (i == 4) {
#line 303
      tmp___274 = xse;
    } else {
#line 303
      if (i == 1) {
#line 303
        tmp___273 = xue;
      } else {
#line 303
        tmp___273 = xme;
      }
#line 303
      tmp___274 = tmp___273;
    }
#line 303
    display->d_attrtyp[i] = (char )tmp___274;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 300
  i ++;
#line 307
  s = (char *)0;
#line 308
  t = 0;
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 309
    if (! (i < 6)) {
#line 309
      goto while_break___4;
    }
#line 310
    s = display->d_attrtab[i];
#line 310
    if (s) {
#line 312
      t = (int )display->d_attrtyp[i];
#line 313
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 309
  i ++;
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 315
    if (! (i < 6)) {
#line 315
      goto while_break___5;
    }
#line 317
    if (display->d_attrtab[i] == (char *)0) {
#line 319
      display->d_attrtab[i] = s;
#line 320
      display->d_attrtyp[i] = (char )t;
    } else {
#line 324
      s = display->d_attrtab[i];
#line 325
      t = (int )display->d_attrtyp[i];
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 315
  i ++;
#line 328
  if (display->d_tcs[60].str) {
#line 329
    display->d_hascolor = 1;
  } else
#line 328
  if (display->d_tcs[61].str) {
#line 329
    display->d_hascolor = 1;
  } else
#line 328
  if (display->d_tcs[62].str) {
#line 329
    display->d_hascolor = 1;
  } else
#line 328
  if (display->d_tcs[63].str) {
#line 329
    display->d_hascolor = 1;
  }
#line 330
  if (display->d_tcs[33].flg) {
#line 331
    display->d_tcs[66].flg = 1;
  }
#line 333
  if (! display->d_tcs[10].str) {
#line 334
    display->d_tcs[10].str = display->d_tcs[19].str;
  }
#line 335
  if (! display->d_tcs[20].str) {
#line 336
    display->d_tcs[20].str = display->d_tcs[19].str;
  }
#line 337
  if (display->d_tcs[26].flg) {
#line 338
    display->d_tcs[27].str = (char *)0;
#line 338
    display->d_tcs[29].str = display->d_tcs[27].str;
  }
#line 339
  if (display->d_tcs[28].str == (char *)0) {
#line 340
    display->d_tcs[27].str = (char *)0;
  }
  {
#line 342
  __cil_tmp42 = strcmp((char const   *)display->d_tcs[29].str, (char const   *)display->d_tcs[27].str);
  }
#line 342
  if (display->d_tcs[29].str) {
#line 342
    if (display->d_tcs[27].str) {
#line 342
      if (__cil_tmp42 == 0) {
#line 343
        display->d_tcs[29].str = (char *)0;
      }
    }
  }
#line 344
  if (display->d_tcs[70].str == (char *)0) {
#line 345
    display->d_tcs[69].str = (char *)0;
  }
#line 346
  if (display->d_tcs[94].str == (char *)0) {
#line 347
    display->d_tcs[93].str = (char *)0;
  }
#line 348
  if (display->d_tcs[82].str == (char *)0) {
#line 349
    display->d_tcs[81].str = (char *)0;
#line 349
    display->d_tcs[80].str = display->d_tcs[81].str;
  }
#line 350
  if (display->d_tcs[72].str == (char *)0) {
#line 351
    display->d_tcs[71].str = (char *)0;
  }
#line 354
  if (display->d_tcs[97].flg) {
#line 356
    if (display->d_tcs[98].str == (char *)0) {
#line 358
      display->d_tcs[98].str = (char *)"\033(%p1%c";
    }
#line 362
    if (display->d_tcs[99].str == (char *)0) {
#line 363
      display->d_tcs[99].str = (char *)"\033(B";
    }
#line 364
    display->d_tcs[103].str = (char *)0;
#line 365
    display->d_tcs[104].str = (char *)0;
  } else
#line 367
  if (display->d_tcs[103].str) {
    _L___277: /* CIL Label */ 
#line 369
    if (display->d_tcs[101].str && display->d_tcs[102].str) {
#line 369
      tmp___275 = display->d_tcs[101].str;
    } else {
#line 369
      tmp___275 = (char *)"";
    }
#line 369
    display->d_tcs[98].str = tmp___275;
#line 370
    if (display->d_tcs[101].str && display->d_tcs[102].str) {
#line 370
      tmp___276 = display->d_tcs[102].str;
    } else {
#line 370
      tmp___276 = (char *)"";
    }
#line 370
    display->d_tcs[99].str = tmp___276;
#line 371
    display->d_tcs[100].str = display->d_tcs[103].str;
  } else
#line 367
  if (display->d_tcs[101].str) {
#line 367
    if (display->d_tcs[102].str) {
#line 367
      goto _L___277;
    } else {
#line 375
      display->d_tcs[99].str = (char *)"";
#line 375
      display->d_tcs[98].str = display->d_tcs[99].str;
#line 376
      display->d_tcs[100].str = (char *)0;
#line 377
      display->d_tcs[103].str = (char *)"";
    }
  } else {
#line 375
    display->d_tcs[99].str = (char *)"";
#line 375
    display->d_tcs[98].str = display->d_tcs[99].str;
#line 376
    display->d_tcs[100].str = (char *)0;
#line 377
    display->d_tcs[103].str = (char *)"";
  }
#line 380
  i = 0;
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < 256)) {
#line 380
      goto while_break___6;
    }
#line 381
    display->d_c0_tab[i] = (char )i;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 380
  i ++;
#line 382
  if (display->d_tcs[103].str) {
    {
#line 385
    s = (char *)"l+m+k+j+u+t+v+w+q-x|n+o~s_p\"r#`+a:f\'g#~o.v-^+<,>h#I#0#y<z>";
#line 386
    __cil_tmp46 = strlen((char const   *)s);
#line 386
    i = (int )(__cil_tmp46 & 0xfffffffffffffffeUL);
    }
    {
#line 386
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 386
      if (! (i >= 0)) {
#line 386
        goto while_break___7;
      }
#line 387
      display->d_c0_tab[(int )((unsigned char )*(s + i))] = *(s + (i + 1));
    }
    while_break___7: /* CIL Label */ ;
    }
#line 386
    i -= 2;
  }
#line 389
  if (display->d_tcs[100].str) {
    {
#line 390
    __cil_tmp47 = strlen((char const   *)display->d_tcs[100].str);
#line 390
    i = (int )(__cil_tmp47 & 0xfffffffffffffffeUL);
    }
    {
#line 390
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 390
      if (! (i >= 0)) {
#line 390
        goto while_break___8;
      }
#line 391
      display->d_c0_tab[(int )((unsigned char )*(display->d_tcs[100].str + i))] = *(display->d_tcs[100].str + (i + 1));
    }
    while_break___8: /* CIL Label */ ;
    }
#line 390
    i -= 2;
  }
  {
#line 392
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 392
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 394
  if (display->d_tcs[74].str == (char *)0) {
#line 395
    display->d_tcs[73].str = (char *)0;
  }
  {
#line 396
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 396
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 399
  if (display->d_tcs[105].str) {
    {
#line 400
    __cil_tmp48 = CreateTransTable(display->d_tcs[105].str);
    }
#line 400
    if (__cil_tmp48) {
#line 401
      return (- 1);
    }
  }
#line 405
  if (display->d_tcs[46].str == (char *)0) {
#line 406
    display->d_tcs[45].str = (char *)0;
  }
  {
#line 407
  Z0width = 132;
#line 408
  Z1width = 80;
#line 410
  CheckScreenSize(0);
  }
#line 412
  if (display->d_tcs[77].str == (char *)0) {
#line 413
    display->d_tcs[75].flg = 0;
  } else
#line 412
  if (display->d_tcs[78].str == (char *)0) {
#line 413
    display->d_tcs[75].flg = 0;
  } else
#line 412
  if (display->d_tcs[79].str == (char *)0) {
#line 413
    display->d_tcs[75].flg = 0;
  }
#line 414
  if (display->d_tcs[75].flg) {
    {
#line 416
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 416
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 417
    if (display->d_tcs[76].num < 0) {
#line 418
      display->d_tcs[76].num = 0;
    }
  }
#line 420
  display->d_has_hstatus = hardstatusemu & ~ (1 << 2);
#line 421
  if (display->d_tcs[75].flg) {
#line 421
    if (! (hardstatusemu & (1 << 2))) {
#line 422
      display->d_has_hstatus = 3;
    }
  }
#line 425
  if (display->d_tcs[92].str) {
    {
#line 427
    __cil_tmp50 = FindEncoding(display->d_tcs[92].str);
#line 427
    enc = __cil_tmp50;
    }
#line 428
    if (enc != -1) {
#line 429
      display->d_encoding = enc;
    }
  }
#line 432
  if (! display->d_tcs[145].str) {
#line 432
    if (display->d_tcs[146].str) {
#line 433
      display->d_tcs[145].str = display->d_tcs[146].str;
    }
  }
#line 434
  if (! display->d_tcs[147].str) {
#line 434
    if (display->d_tcs[148].str) {
#line 435
      display->d_tcs[147].str = display->d_tcs[148].str;
    }
  }
  {
#line 437
  display->d_UPcost = CalcCost(display->d_tcs[8].str);
#line 438
  display->d_DOcost = CalcCost(display->d_tcs[10].str);
#line 439
  display->d_NLcost = CalcCost(display->d_tcs[19].str);
#line 440
  display->d_LEcost = CalcCost(display->d_tcs[13].str);
#line 441
  display->d_NDcost = CalcCost(display->d_tcs[16].str);
#line 442
  display->d_CRcost = CalcCost(display->d_tcs[7].str);
#line 443
  display->d_IMcost = CalcCost(display->d_tcs[27].str);
#line 444
  display->d_EIcost = CalcCost(display->d_tcs[28].str);
  }
#line 447
  if (display->d_tcs[90].flg) {
    {
#line 449
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 449
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 450
    display->d_auto_nuke = 1;
  }
#line 453
  if (display->d_tcs[91].num > 0) {
    {
#line 455
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 455
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 456
    display->d_obufmax = display->d_tcs[91].num;
#line 457
    display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  }
  {
#line 461
  __cil_tmp59 = strcmp((char const   *)display->d_tcs[106].str, (char const   *)display->d_tcs[116].str);
  }
#line 461
  if (display->d_tcs[106].str) {
#line 461
    if (display->d_tcs[116].str) {
#line 461
      if (! __cil_tmp59) {
#line 462
        display->d_tcs[106].str = (char *)0;
      }
    }
  }
  {
#line 464
  __cil_tmp60 = strcmp((char const   *)display->d_tcs[152].str, (char const   *)((char *)"\0177"));
  }
#line 464
  if (display->d_tcs[152].str) {
#line 464
    if (! __cil_tmp60) {
#line 465
      display->d_tcs[152].str = (char *)0;
    }
  }
  {
#line 467
  __cil_tmp61 = strcmp((char const   *)display->d_tcs[156].str, (char const   *)((char *)""));
  }
#line 467
  if (display->d_tcs[156].str) {
#line 467
    if (! __cil_tmp61) {
#line 468
      display->d_tcs[156].str = (char *)0;
    }
  }
#line 471
  display->d_nseqs = 0;
#line 472
  i = 0;
  {
#line 472
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 472
    if (! (i < 69)) {
#line 472
      goto while_break___14;
    }
    {
#line 473
    remap(i, 1);
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 472
  i ++;
#line 474
  i = 0;
  {
#line 474
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 474
    if (! (i < 50)) {
#line 474
      goto while_break___15;
    }
    {
#line 475
    remap(i + 91, 1);
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 474
  i ++;
#line 476
  display->d_seqp = (char *)display->d_kmaps[0].seq;
#line 479
  display->d_tcinited = (char )1;
#line 480
  MakeTermcap(0);
#line 482
  CheckEscape();
  }
#line 484
  return (0);
}
}
#line 490 "/tmp/screen-3.9.15/termcap.c"
int remap(int n , int map ) 
{ 
  char *s ;
  int fl ;
  int domap ;
  struct action *a1 ;
  struct action *a2 ;
  struct action *tab ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 495
  fl = 0;
#line 495
  domap = 0;
#line 498
  tab = (struct action *)umtab;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! 1) {
#line 499
      goto while_break;
    }
#line 501
    a1 = & *(tab + n);
#line 502
    a2 = (struct action *)0;
#line 503
    if (n < 91) {
#line 505
      if (n >= 69) {
#line 506
        n -= 22;
      }
#line 507
      s = display->d_tcs[n + 106].str;
#line 508
      if (n >= 47) {
#line 509
        a2 = & *(tab + (n + 22));
      }
    } else {
#line 513
      s = kmap_extras[n - 91];
#line 514
      fl |= kmap_extras_fl[n - 91];
    }
#line 516
    if (s == (char *)0) {
#line 517
      return (0);
    }
#line 518
    if (a1) {
#line 518
      if (a1->nr == -1) {
#line 519
        a1 = (struct action *)0;
      }
    }
#line 520
    if (a2) {
#line 520
      if (a2->nr == -1) {
#line 521
        a2 = (struct action *)0;
      }
    }
    {
#line 522
    __cil_tmp9 = strcmp((char const   *)*(a1->args + 0), (char const   *)s);
    }
#line 522
    if (a1) {
#line 522
      if (a1->nr == 143) {
#line 522
        if (__cil_tmp9 == 0) {
#line 523
          a1 = (struct action *)0;
        }
      }
    }
    {
#line 524
    __cil_tmp10 = strcmp((char const   *)*(a2->args + 0), (char const   *)s);
    }
#line 524
    if (a2) {
#line 524
      if (a2->nr == 143) {
#line 524
        if (__cil_tmp10 == 0) {
#line 525
          a2 = (struct action *)0;
        }
      }
    }
#line 526
    domap |= a1 || a2;
#line 527
    if (tab == (struct action *)umtab) {
#line 528
      tab = (struct action *)dmtab;
    } else
#line 529
    if (tab == (struct action *)dmtab) {
#line 530
      tab = (struct action *)mmtab;
    } else {
#line 532
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if (map == 0) {
#line 535
    if (domap) {
#line 536
      return (0);
    }
  }
#line 537
  if (map) {
#line 537
    if (! domap) {
#line 538
      return (0);
    }
  }
  {
#line 539
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 539
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 540
  if (map) {
    {
#line 541
    __cil_tmp11 = addmapseq(s, n | fl);
    }
#line 541
    return (__cil_tmp11);
  } else {
    {
#line 543
    __cil_tmp12 = remmapseq(s);
    }
#line 543
    return (__cil_tmp12);
  }
}
}
#line 547 "/tmp/screen-3.9.15/termcap.c"
void CheckEscape(void) 
{ 
  struct display *odisplay ;
  int i ;
  int nr ;

  {
#line 552
  if (DefaultEsc >= 0) {
#line 553
    return;
  }
#line 555
  odisplay = display;
#line 556
  display = displays;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! display) {
#line 556
      goto while_break;
    }
#line 558
    i = 0;
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 558
      if (! (i < display->d_nseqs)) {
#line 558
        goto while_break___0;
      }
#line 560
      nr = display->d_kmaps[i].nr & -16385;
#line 561
      if (umtab[nr].nr == 29) {
#line 562
        goto while_break___0;
      }
#line 563
      if (umtab[nr].nr == -1) {
#line 563
        if (dmtab[nr].nr == 29) {
#line 564
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 558
    i ++;
#line 566
    if (i >= display->d_nseqs) {
#line 567
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  display = display->d_next;
#line 569
  if (display == (struct display *)0) {
#line 571
    display = odisplay;
#line 572
    return;
  }
  {
#line 574
  ParseEscape((struct acluser *)0, (char *)"^aa");
  }
#line 575
  if ((odisplay->d_user)->u_Esc == -1) {
#line 576
    (odisplay->d_user)->u_Esc = DefaultEsc;
  }
#line 577
  if ((odisplay->d_user)->u_MetaEsc == -1) {
#line 578
    (odisplay->d_user)->u_MetaEsc = DefaultMetaEsc;
  }
  {
#line 579
  display = (struct display *)0;
#line 580
  Msg(0, (char *)"Warning: escape char set back to ^A");
#line 581
  display = odisplay;
  }
}
}
#line 585 "/tmp/screen-3.9.15/termcap.c"
static int addmapseq(char *seq , int nr ) 
{ 
  int i ;
  int j ;
  int k ;
  int mo ;
  int m ;
  char *p ;
  char *o ;
  size_t __cil_tmp10 ;
  int __cil_tmp13 ;
  int tmp ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 589
  j = 0;
#line 592
  __cil_tmp10 = strlen((char const   *)seq);
#line 592
  k = (int )__cil_tmp10;
  }
#line 593
  if ((unsigned long )k > sizeof(display->d_kmaps[0].seq) - 1UL) {
#line 594
    return (- 1);
  }
#line 595
  i = 0;
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (i < display->d_nseqs)) {
#line 595
      goto while_break;
    }
    {
#line 596
    j = strcmp((char const   *)((char *)display->d_kmaps[i].seq), (char const   *)seq);
    }
#line 596
    if (j >= 0) {
#line 597
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  i ++;
#line 598
  if (i < display->d_nseqs) {
#line 598
    if (j == 0) {
#line 600
      display->d_kmaps[i].nr = nr;
#line 601
      return (0);
    }
  }
#line 603
  if ((unsigned long )display->d_nseqs >= sizeof(display->d_kmaps) / sizeof(*((struct kmap *)display->d_kmaps))) {
#line 604
    return (- 1);
  }
#line 605
  j = display->d_nseqs - 1;
  {
#line 605
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 605
    if (! (j >= i)) {
#line 605
      goto while_break___0;
    }
#line 606
    display->d_kmaps[j + 1] = display->d_kmaps[j];
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 605
  __cil_tmp13 = j;
#line 605
  j --;
#line 607
  p = (char *)display->d_kmaps[i].seq;
#line 608
  o = (char *)display->d_kmaps[i].off;
#line 609
  strcpy(p, (char const   *)seq);
#line 610
  bzero((void *)o, (unsigned long )(k + 1));
#line 611
  display->d_kmaps[i].nr = nr;
#line 612
  (display->d_nseqs) ++;
  }
#line 614
  if (i + 1 < display->d_nseqs) {
#line 615
    j = 0;
    {
#line 615
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 615
      if (! *p) {
#line 615
        goto while_break___1;
      }
#line 617
      if ((int )display->d_kmaps[i + 1].seq[j] != (int )*p) {
#line 619
        if (display->d_kmaps[i + 1].seq[j]) {
#line 620
          *o = (char )1;
        }
#line 621
        goto while_break___1;
      }
#line 623
      if ((int )display->d_kmaps[i + 1].off[j]) {
#line 623
        tmp = (int )display->d_kmaps[i + 1].off[j] + 1;
      } else {
#line 623
        tmp = 0;
      }
#line 623
      *o = (char )tmp;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 615
    __cil_tmp18 = j;
#line 615
    j ++;
#line 615
    __cil_tmp17 = o;
#line 615
    o ++;
#line 615
    __cil_tmp16 = p;
#line 615
    p ++;
  }
#line 626
  k = 0;
  {
#line 626
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 626
    if (! (k < i)) {
#line 626
      goto while_break___2;
    }
#line 627
    o = (char *)display->d_kmaps[k].off;
#line 627
    p = (char *)display->d_kmaps[k].seq;
#line 627
    j = 0;
#line 627
    m = j;
    {
#line 627
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 627
      if (! *p) {
#line 627
        goto while_break___3;
      }
#line 629
      mo = m;
#line 630
      if (! m) {
#line 630
        if ((int )*p != (int )display->d_kmaps[i].seq[j]) {
#line 631
          m = 1;
        }
      }
#line 632
      if ((int )*o == 0) {
#line 632
        if (mo == 0) {
#line 632
          if (m) {
#line 633
            *o = (char )(i - k);
          }
        }
      }
#line 634
      if ((int )*o < i - k) {
#line 635
        goto while_continue___3;
      } else
#line 634
      if ((int )*o == i - k) {
#line 634
        if (m) {
#line 635
          goto while_continue___3;
        }
      }
#line 636
      (*o) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 627
    __cil_tmp22 = j;
#line 627
    j ++;
#line 627
    __cil_tmp21 = o;
#line 627
    o ++;
#line 627
    __cil_tmp20 = p;
#line 627
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 626
  k ++;
#line 641
  return (0);
}
}
#line 645 "/tmp/screen-3.9.15/termcap.c"
static int remmapseq(char *seq ) 
{ 
  int i ;
  int j ;
  int k ;
  char *p ;
  char *o ;
  int tmp ;
  char __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp16 ;

  {
#line 648
  j = 0;
#line 651
  i = 0;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! (i < display->d_nseqs)) {
#line 651
      goto while_break;
    }
    {
#line 652
    j = strcmp((char const   *)((char *)display->d_kmaps[i].seq), (char const   *)seq);
    }
#line 652
    if (j >= 0) {
#line 653
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  i ++;
#line 654
  if (i == display->d_nseqs) {
#line 655
    return (- 1);
  } else
#line 654
  if (j) {
#line 655
    return (- 1);
  }
#line 656
  k = 0;
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 656
    if (! (k < i)) {
#line 656
      goto while_break___0;
    }
#line 657
    o = (char *)display->d_kmaps[k].off;
#line 657
    p = (char *)display->d_kmaps[k].seq;
#line 657
    j = 0;
    {
#line 657
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 657
      if (! *p) {
#line 657
        goto while_break___1;
      }
#line 659
      if (k + (int )*o == i) {
#line 660
        if ((int )display->d_kmaps[i].off[j]) {
#line 660
          tmp = ((int )display->d_kmaps[i].off[j] + (int )*o) - 1;
        } else {
#line 660
          tmp = 0;
        }
#line 660
        *o = (char )tmp;
      } else
#line 661
      if (k + (int )*o > i) {
#line 662
        __cil_tmp10 = *o;
#line 662
        (*o) --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 657
    __cil_tmp13 = j;
#line 657
    j ++;
#line 657
    __cil_tmp12 = o;
#line 657
    o ++;
#line 657
    __cil_tmp11 = p;
#line 657
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 656
  k ++;
#line 664
  j = i + 1;
  {
#line 664
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 664
    if (! (j < display->d_nseqs)) {
#line 664
      goto while_break___2;
    }
#line 665
    display->d_kmaps[j - 1] = display->d_kmaps[j];
  }
  while_break___2: /* CIL Label */ ;
  }
#line 664
  j ++;
#line 666
  __cil_tmp16 = display->d_nseqs;
#line 666
  (display->d_nseqs) --;
#line 670
  return (0);
}
}
#line 703 "/tmp/screen-3.9.15/termcap.c"
static void AddCap(char *s ) 
{ 
  register int n ;
  size_t __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp3 = strlen((char const   *)s);
#line 708
  n = (int )__cil_tmp3;
  }
#line 708
  if (tcLineLen + n > 55) {
#line 708
    if (Termcaplen < 2043) {
      {
#line 710
      strcpy((char *)Termcap + Termcaplen, (char const   *)((char *)"\\\n\t:"));
#line 711
      Termcaplen += 4;
#line 712
      tcLineLen = 0;
      }
    }
  }
#line 714
  if (Termcaplen + n < 2047) {
    {
#line 716
    strcpy((char *)Termcap + Termcaplen, (char const   *)s);
#line 717
    Termcaplen += n;
#line 718
    tcLineLen += n;
    }
  } else {
    {
#line 721
    Panic(0, (char *)"TERMCAP overflow - sorry.");
    }
  }
}
}
#line 729 "/tmp/screen-3.9.15/termcap.c"
char *MakeTermcap(int aflag ) 
{ 
  char buf[2048] ;
  register char *p ;
  register char *cp ;
  register char *s ;
  register char ch ;
  register char *tname ;
  int i ;
  int wi ;
  int he ;
  int found ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp23 ;
  size_t __cil_tmp24 ;
  struct action *act ;

  {
#line 736
  if (display) {
#line 738
    wi = display->d_width;
#line 739
    he = display->d_height;
#line 740
    tname = (char *)display->d_termname;
  } else {
#line 744
    wi = 80;
#line 745
    he = 24;
#line 746
    tname = (char *)"vt100";
  }
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  __cil_tmp13 = strlen((char const   *)s);
  }
  {
#line 749
  s = getenv((char const   *)((char *)"SCREENCAP"));
  }
#line 749
  if (s) {
#line 749
    if (__cil_tmp13 < 2048UL) {
      {
#line 751
      sprintf((char *)Termcap, (char const   *)((char *)"TERMCAP=%s"), s);
#line 752
      strcpy((char *)Term, (char const   *)((char *)"TERM=screen"));
      }
      {
#line 753
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 753
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 754
      return ((char *)Termcap);
    }
  }
#line 756
  Termcaplen = 0;
  {
#line 757
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 757
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 758
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 758
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 759
  __cil_tmp14 = strlen((char const   *)((char *)screenterm));
  }
#line 759
  if ((int )*((char *)screenterm) == 0) {
    _L: /* CIL Label */ 
    {
#line 761
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 761
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 762
    strcpy((char *)screenterm, (char const   *)((char *)"screen"));
    }
  } else
#line 759
  if (__cil_tmp14 > 253UL) {
#line 759
    goto _L;
  }
#line 764
  found = 1;
  {
#line 765
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 767
    strcpy((char *)Term, (char const   *)((char *)"TERM="));
#line 768
    p = (char *)Term + 5;
#line 769
    __cil_tmp16 = strlen((char const   *)tname);
    }
    {
#line 769
    __cil_tmp15 = strlen((char const   *)((char *)screenterm));
    }
#line 769
    if (! aflag) {
#line 769
      if (__cil_tmp15 + __cil_tmp16 < 255UL) {
        {
#line 771
        sprintf(p, (char const   *)((char *)"%s.%s"), (char *)screenterm, tname);
#line 772
        __cil_tmp17 = e_tgetent((char *)buf, p);
        }
#line 772
        if (__cil_tmp17 == 1) {
#line 773
          goto while_break___4;
        }
      }
    }
#line 776
    if (nwin_default.bce) {
      {
#line 778
      sprintf(p, (char const   *)((char *)"%s-bce"), (char *)screenterm);
#line 779
      __cil_tmp18 = e_tgetent((char *)buf, p);
      }
#line 779
      if (__cil_tmp18 == 1) {
#line 780
        goto while_break___4;
      }
    }
    {
#line 791
    strcpy(p, (char const   *)((char *)screenterm));
#line 792
    __cil_tmp19 = e_tgetent((char *)buf, p);
    }
#line 792
    if (__cil_tmp19 == 1) {
#line 793
      goto while_break___4;
    }
    {
#line 794
    strcpy(p, (char const   *)((char *)"vt100"));
#line 795
    found = 0;
    }
#line 765
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 813
  tcLineLen = 100;
#line 814
  __cil_tmp20 = strlen((char const   *)((char *)Term));
  }
#line 814
  if (__cil_tmp20 > 2008UL) {
    {
#line 815
    strcpy((char *)Term, (char const   *)((char *)"too_long"));
    }
  }
  {
#line 816
  sprintf((char *)Termcap, (char const   *)((char *)"TERMCAP=SC|%s|VT 100/ANSI X3.64 virtual terminal:"),
          (char *)Term + 5);
#line 817
  __cil_tmp21 = strlen((char const   *)((char *)Termcap));
#line 817
  Termcaplen = (int )__cil_tmp21;
  }
  {
#line 818
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 818
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 819
  if (extra_outcap) {
#line 819
    if ((int )*extra_outcap) {
#line 821
      cp = extra_outcap;
      {
#line 821
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 821
        if (! p) {
#line 821
          goto while_break___6;
        }
        {
#line 823
        p ++;
#line 823
        ch = *p;
#line 824
        *p = (char )'\000';
#line 825
        AddCap(cp);
#line 826
        *p = ch;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 821
      cp = p;
#line 828
      tcLineLen = 100;
    }
  }
  {
#line 830
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 830
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 831
  __cil_tmp23 = strlen((char const   *)TermcapConst);
  }
#line 831
  if ((unsigned long )Termcaplen + __cil_tmp23 < 2048UL) {
    {
#line 833
    strcpy((char *)Termcap + Termcaplen, (char const   *)((char *)((char const   *)TermcapConst)));
#line 834
    __cil_tmp24 = strlen((char const   *)TermcapConst);
    }
#line 834
    Termcaplen += __cil_tmp24;
  }
  {
#line 836
  sprintf((char *)buf, (char const   *)((char *)"li#%d:co#%d:"), he, wi);
#line 837
  AddCap((char *)buf);
#line 838
  AddCap((char *)"am:");
  }
#line 839
  if (aflag) {
    {
    {
    {
    {
#line 841
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 842
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 843
    AddCap((char *)"LP:");
    }
    }
    }
    }
  } else
#line 839
  if (force_vt) {
#line 839
    if (! display->d_tcs[86].flg) {
      {
      {
      {
      {
#line 841
      AddCap((char *)"xn:");
      }
      }
      }
      {
      {
      {
#line 842
      AddCap((char *)"xv:");
      }
      }
      }
      {
      {
      {
#line 843
      AddCap((char *)"LP:");
      }
      }
      }
      }
    } else {
#line 839
      goto _L___278;
    }
  } else
  _L___278: /* CIL Label */ 
#line 839
  if (display->d_tcs[87].flg) {
    {
    {
    {
    {
#line 841
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 842
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 843
    AddCap((char *)"LP:");
    }
    }
    }
    }
  } else
#line 839
  if (! display->d_tcs[83].flg) {
    {
    {
    {
    {
#line 841
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 842
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 843
    AddCap((char *)"LP:");
    }
    }
    }
    }
  }
#line 845
  if (aflag) {
    {
    {
    {
    {
#line 847
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 848
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 849
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 845
  if (display->d_tcs[18].str) {
#line 845
    if (display->d_tcs[21].str) {
      {
      {
      {
      {
#line 847
      AddCap((char *)"sr=\\EM:");
      }
      }
      }
      {
      {
      {
#line 848
      AddCap((char *)"al=\\E[L:");
      }
      }
      }
      {
      {
      {
#line 849
      AddCap((char *)"AL=\\E[%dL:");
      }
      }
      }
      }
    } else {
#line 845
      goto _L___279;
    }
  } else
  _L___279: /* CIL Label */ 
#line 845
  if (display->d_tcs[22].str) {
    {
    {
    {
    {
#line 847
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 848
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 849
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 845
  if (display->d_tcs[23].str) {
    {
    {
    {
    {
#line 847
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 848
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 849
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 851
  if (display->d_tcs[21].str) {
    {
#line 852
    AddCap((char *)"sr=\\EM:");
    }
  }
#line 853
  if (aflag) {
    {
    {
#line 854
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
    }
  } else
#line 853
  if (display->d_tcs[18].str) {
    {
    {
#line 854
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
    }
  }
#line 855
  if (aflag) {
    {
    {
    {
    {
#line 857
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 858
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 855
  if (display->d_tcs[18].str) {
    {
    {
    {
    {
#line 857
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 858
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 855
  if (display->d_tcs[24].str) {
    {
    {
    {
    {
#line 857
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 858
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 855
  if (display->d_tcs[25].str) {
    {
    {
    {
    {
#line 857
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 858
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  }
#line 860
  if (aflag) {
    {
    {
    {
#line 862
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 863
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  } else
#line 860
  if (display->d_tcs[31].str) {
    {
    {
    {
#line 862
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 863
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  } else
#line 860
  if (display->d_tcs[32].str) {
    {
    {
    {
#line 862
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 863
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  }
#line 865
  if (aflag) {
    {
    {
    {
    {
#line 867
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 868
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 869
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 870
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 865
  if (display->d_tcs[30].str) {
    {
    {
    {
    {
#line 867
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 868
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 869
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 870
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 865
  if (display->d_tcs[29].str) {
    {
    {
    {
    {
#line 867
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 868
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 869
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 870
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 865
  if (display->d_tcs[27].str) {
    {
    {
    {
    {
#line 867
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 868
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 869
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 870
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  }
  {
#line 873
  AddCap((char *)"ks=\\E[?1h\\E=:");
#line 874
  AddCap((char *)"ke=\\E[?1l\\E>:");
#line 876
  AddCap((char *)"vi=\\E[?25l:");
#line 877
  AddCap((char *)"ve=\\E[34h\\E[?25h:");
#line 878
  AddCap((char *)"vs=\\E[34l:");
#line 879
  AddCap((char *)"ti=\\E[?1049h:");
#line 880
  AddCap((char *)"te=\\E[?1049l:");
  }
#line 881
  if (display) {
#line 883
    if (display->d_tcs[48].str) {
      {
#line 885
      AddCap((char *)"us=\\E[4m:");
#line 886
      AddCap((char *)"ue=\\E[24m:");
      }
    }
#line 888
    if (display->d_tcs[51].str) {
      {
#line 890
      AddCap((char *)"so=\\E[3m:");
#line 891
      AddCap((char *)"se=\\E[23m:");
      }
    }
#line 893
    if (display->d_tcs[52].str) {
      {
#line 894
      AddCap((char *)"mb=\\E[5m:");
      }
    }
#line 895
    if (display->d_tcs[49].str) {
      {
#line 896
      AddCap((char *)"md=\\E[1m:");
      }
    }
#line 897
    if (display->d_tcs[47].str) {
      {
#line 898
      AddCap((char *)"mh=\\E[2m:");
      }
    }
#line 899
    if (display->d_tcs[50].str) {
      {
#line 900
      AddCap((char *)"mr=\\E[7m:");
      }
    }
#line 901
    if (display->d_tcs[52].str) {
      {
      {
      {
      {
#line 902
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 901
    if (display->d_tcs[49].str) {
      {
      {
      {
      {
#line 902
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 901
    if (display->d_tcs[47].str) {
      {
      {
      {
      {
#line 902
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 901
    if (display->d_tcs[50].str) {
      {
      {
      {
      {
#line 902
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    }
#line 903
    if (display->d_hascolor) {
      {
#line 904
      AddCap((char *)"Co#8:pa#64:AF=\\E[3%dm:AB=\\E[4%dm:op=\\E[39;49m:AX:");
      }
    }
#line 905
    if (display->d_tcs[43].str) {
      {
#line 906
      AddCap((char *)"vb=\\Eg:");
      }
    }
#line 919
    if (display->d_tcs[97].flg) {
      {
#line 920
      AddCap((char *)"G0:");
      }
    }
#line 921
    if (display->d_tcs[100].str) {
      {
      {
#line 923
      AddCap((char *)"as=\\E(0:");
      }
      {
#line 924
      AddCap((char *)"ae=\\E(B:");
      }
      {
#line 926
      AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
      }
      }
    } else
#line 921
    if (display->d_tcs[98].str) {
#line 921
      if ((int )*(display->d_tcs[98].str)) {
        {
        {
#line 923
        AddCap((char *)"as=\\E(0:");
        }
        {
#line 924
        AddCap((char *)"ae=\\E(B:");
        }
        {
#line 926
        AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
        }
        }
      }
    }
#line 928
    if (display->d_tcs[73].str) {
      {
#line 930
      AddCap((char *)"po=\\E[5i:");
#line 931
      AddCap((char *)"pf=\\E[4i:");
      }
    }
#line 933
    if (display->d_tcs[45].str) {
      {
#line 935
      AddCap((char *)"Z0=\\E[?3h:");
#line 936
      AddCap((char *)"Z1=\\E[?3l:");
      }
    }
#line 938
    if (display->d_tcs[44].str) {
      {
#line 939
      AddCap((char *)"WS=\\E[8;%d;%dt:");
      }
    }
  }
#line 941
  i = 106;
  {
#line 941
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 941
    if (! (i < 188)) {
#line 941
      goto while_break___8;
    }
#line 945
    if (i < 175) {
#line 947
      if (i >= 157) {
#line 948
        goto while_continue___8;
      }
#line 949
      if (i >= 153) {
#line 949
        if (i < 175) {
#line 951
          act = & umtab[i - 84];
#line 952
          if (act->nr == -1) {
#line 953
            act = & dmtab[i - 84];
          }
        } else {
#line 949
          goto _L___280;
        }
      } else {
        _L___280: /* CIL Label */ 
#line 957
        act = & umtab[i - 106];
#line 958
        if (act->nr == -1) {
#line 959
          act = & dmtab[i - 106];
        }
      }
#line 961
      if (act->nr == -1) {
#line 961
        if (i == 146) {
          _L___281: /* CIL Label */ 
#line 964
          act = & umtab[(i - 106) - 1];
#line 965
          if (act->nr == -1) {
#line 966
            act = & dmtab[(i - 106) - 1];
          }
        } else
#line 961
        if (i == 148) {
#line 961
          goto _L___281;
        }
      }
#line 968
      if (act->nr != -1) {
#line 970
        if (act->nr == 143) {
          {
#line 972
          MakeString(term[i].tcname, (char *)buf, (int )sizeof(buf), *(act->args + 0));
#line 973
          AddCap((char *)buf);
          }
        }
#line 975
        goto while_continue___8;
      }
    }
#line 979
    if (display == (struct display *)0) {
#line 980
      goto while_continue___8;
    }
    {
#line 983
    if (term[i].type == 2) {
#line 983
      goto case_2;
    }
#line 989
    if (term[i].type == 0) {
#line 989
      goto case_0;
    }
#line 995
    goto switch_default;
    case_2: /* CIL Label */ 
#line 984
    if (display->d_tcs[i].str == (char *)0) {
#line 985
      goto switch_break;
    }
    {
#line 986
    MakeString(term[i].tcname, (char *)buf, (int )sizeof(buf), display->d_tcs[i].str);
#line 987
    AddCap((char *)buf);
    }
#line 988
    goto switch_break;
    case_0: /* CIL Label */ 
#line 990
    if (display->d_tcs[i].flg == 0) {
#line 991
      goto switch_break;
    }
    {
#line 992
    sprintf((char *)buf, (char const   *)((char *)"%s:"), term[i].tcname);
#line 993
    AddCap((char *)buf);
    }
#line 994
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 996
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 941
  i ++;
  {
#line 999
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 999
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1000
  return ((char *)Termcap);
}
}
#line 1004 "/tmp/screen-3.9.15/termcap.c"
static void MakeString(char *cap , char *buf , int buflen , char *s ) 
{ 
  register char *p ;
  register char *pmax ;
  register unsigned int c ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1012
  p = buf;
#line 1013
  pmax = (p + buflen) - 9;
#line 1014
  __cil_tmp9 = cap;
#line 1014
  cap ++;
#line 1014
  __cil_tmp8 = p;
#line 1014
  p ++;
#line 1014
  *__cil_tmp8 = *__cil_tmp9;
#line 1015
  __cil_tmp10 = p;
#line 1015
  p ++;
#line 1015
  *__cil_tmp10 = *cap;
#line 1016
  __cil_tmp11 = p;
#line 1016
  p ++;
#line 1016
  *__cil_tmp11 = (char )'=';
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    if (! (c && p < pmax)) {
#line 1017
      goto while_break;
    }
    {
#line 1021
    if (c == (unsigned int )'\033') {
#line 1021
      goto case_27;
    }
#line 1025
    if (c == (unsigned int )':') {
#line 1025
      goto case_58;
    }
#line 1030
    if (c == (unsigned int )'\\') {
#line 1030
      goto case_92;
    }
#line 1030
    if (c == (unsigned int )'^') {
#line 1030
      goto case_92;
    }
#line 1034
    goto switch_default;
    case_27: /* CIL Label */ 
#line 1022
    __cil_tmp13 = p;
#line 1022
    p ++;
#line 1022
    *__cil_tmp13 = (char )'\\';
#line 1023
    __cil_tmp14 = p;
#line 1023
    p ++;
#line 1023
    *__cil_tmp14 = (char )'E';
#line 1024
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 1026
    strcpy(p, (char const   *)((char *)"\\072"));
    }
#line 1027
    p += 4;
#line 1028
    goto switch_break;
    case_92: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 1031
    __cil_tmp15 = p;
#line 1031
    p ++;
#line 1031
    *__cil_tmp15 = (char )'\\';
#line 1032
    __cil_tmp16 = p;
#line 1032
    p ++;
#line 1032
    *__cil_tmp16 = (char )c;
#line 1033
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1035
    if (c >= 200U) {
      {
#line 1037
      sprintf(p, (char const   *)((char *)"\\%03o"), c & 255U);
#line 1038
      p += 4;
      }
    } else
#line 1040
    if (c < 32U) {
#line 1042
      __cil_tmp17 = p;
#line 1042
      p ++;
#line 1042
      *__cil_tmp17 = (char )'^';
#line 1043
      __cil_tmp18 = p;
#line 1043
      p ++;
#line 1043
      *__cil_tmp18 = (char )(c + 64U);
    } else {
#line 1046
      __cil_tmp19 = p;
#line 1046
      p ++;
#line 1046
      *__cil_tmp19 = (char )c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  __cil_tmp20 = p;
#line 1049
  p ++;
#line 1049
  *__cil_tmp20 = (char )':';
#line 1050
  *p = (char )'\000';
}
}
#line 1060 "/tmp/screen-3.9.15/termcap.c"
int CreateTransTable(char *s ) 
{ 
  int curchar ;
  char *templ ;
  char *arg ;
  int templlen ;
  int templnsub ;
  char *p ;
  char *sx ;
  char **ctable ;
  int l ;
  int c ;
  void *__cil_tmp12 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp24 ;
  char *tmp ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1071
  __cil_tmp12 = malloc(256UL * sizeof(char **));
#line 1071
  display->d_xtable = (char ***)__cil_tmp12;
  }
#line 1071
  if (display->d_xtable == (char ***)0) {
    {
#line 1073
    Msg(0, (char *)strnomem);
    }
#line 1074
    return (- 1);
  }
  {
#line 1076
  bzero((void *)((char *)display->d_xtable), 256UL * sizeof(char **));
  }
  {
#line 1078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (! *s) {
#line 1078
      goto while_break;
    }
#line 1080
    if ((int )*s == 92) {
#line 1080
      if ((int )*(s + 1) == 92) {
#line 1081
        s ++;
      } else
#line 1080
      if ((int )*(s + 1) == 44) {
#line 1081
        s ++;
      } else
#line 1080
      if ((int )*(s + 1) == 37) {
#line 1081
        s ++;
      }
    }
#line 1082
    __cil_tmp14 = s;
#line 1082
    s ++;
#line 1082
    curchar = (int )((unsigned char )*__cil_tmp14);
#line 1083
    if (curchar == 66) {
#line 1084
      curchar = 0;
    }
#line 1085
    templ = s;
#line 1086
    templlen = 0;
#line 1087
    templnsub = 0;
#line 1088
    if (*(display->d_xtable + curchar) == (char **)0) {
      {
#line 1090
      __cil_tmp15 = malloc(257UL * sizeof(char *));
#line 1090
      *(display->d_xtable + curchar) = (char **)__cil_tmp15;
      }
#line 1090
      if (*(display->d_xtable + curchar) == (char **)0) {
        {
#line 1092
        Msg(0, (char *)strnomem);
#line 1093
        FreeTransTable();
        }
#line 1094
        return (- 1);
      }
      {
#line 1096
      bzero((void *)((char *)*(display->d_xtable + curchar)), 257UL * sizeof(char *));
      }
    }
#line 1098
    ctable = *(display->d_xtable + curchar);
    {
#line 1099
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1099
      if (! ((int )*s && (int )*s != 44)) {
#line 1099
        goto while_break___0;
      }
#line 1101
      if ((int )*s == 92) {
#line 1101
        if ((int )*(s + 1) == 92) {
#line 1102
          s ++;
        } else
#line 1101
        if ((int )*(s + 1) == 44) {
#line 1102
          s ++;
        } else
#line 1101
        if ((int )*(s + 1) == 37) {
#line 1102
          s ++;
        } else {
#line 1101
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1103
      if ((int )*s == 37) {
#line 1105
        templnsub ++;
#line 1106
        goto while_continue___0;
      }
#line 1108
      templlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1099
    s ++;
#line 1110
    __cil_tmp20 = s;
#line 1110
    s ++;
#line 1110
    if ((int )*__cil_tmp20 == 0) {
#line 1111
      goto while_break;
    }
    {
#line 1112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1112
      if (! ((int )*s && (int )*s != 44)) {
#line 1112
        goto while_break___1;
      }
#line 1114
      __cil_tmp21 = s;
#line 1114
      s ++;
#line 1114
      c = (int )((unsigned char )*__cil_tmp21);
#line 1115
      if ((int )*(s - 1) == 92) {
#line 1115
        if ((int )*((s - 1) + 1) == 92) {
#line 1116
          __cil_tmp22 = s;
#line 1116
          s ++;
#line 1116
          c = (int )((unsigned char )*__cil_tmp22);
        } else
#line 1115
        if ((int )*((s - 1) + 1) == 44) {
#line 1116
          __cil_tmp22 = s;
#line 1116
          s ++;
#line 1116
          c = (int )((unsigned char )*__cil_tmp22);
        } else
#line 1115
        if ((int )*((s - 1) + 1) == 37) {
#line 1116
          __cil_tmp22 = s;
#line 1116
          s ++;
#line 1116
          c = (int )((unsigned char )*__cil_tmp22);
        } else {
#line 1115
          goto _L___282;
        }
      } else
      _L___282: /* CIL Label */ 
#line 1117
      if (c == 37) {
#line 1118
        c = 256;
      }
#line 1119
      if (*(ctable + c)) {
        {
#line 1120
        free((void *)*(ctable + c));
        }
      }
      {
#line 1121
      arg = s;
#line 1122
      l = copyarg(& s, (char *)0);
      }
#line 1123
      if (c != 256) {
#line 1124
        l = l * templnsub + templlen;
      }
      {
#line 1125
      __cil_tmp24 = malloc((unsigned long )(l + 1));
#line 1125
      *(ctable + c) = (char *)__cil_tmp24;
      }
#line 1125
      if (*(ctable + c) == (char *)0) {
        {
#line 1127
        Msg(0, (char *)strnomem);
#line 1128
        FreeTransTable();
        }
#line 1129
        return (- 1);
      }
#line 1131
      sx = *(ctable + c);
#line 1132
      if (c == 256) {
#line 1132
        tmp = (char *)"%";
      } else {
#line 1132
        tmp = templ;
      }
#line 1132
      p = tmp;
      {
#line 1132
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1132
        if (! ((int )*p && (int )*p != 44)) {
#line 1132
          goto while_break___2;
        }
#line 1134
        if ((int )*p == 92) {
#line 1134
          if ((int )*(p + 1) == 92) {
#line 1135
            p ++;
          } else
#line 1134
          if ((int )*(p + 1) == 44) {
#line 1135
            p ++;
          } else
#line 1134
          if ((int )*(p + 1) == 37) {
#line 1135
            p ++;
          } else {
#line 1134
            goto _L___283;
          }
        } else
        _L___283: /* CIL Label */ 
#line 1136
        if ((int )*p == 37) {
          {
#line 1138
          s = arg;
#line 1139
          __cil_tmp27 = copyarg(& s, sx);
          }
#line 1139
          sx += __cil_tmp27;
#line 1140
          goto while_continue___2;
        }
#line 1142
        __cil_tmp28 = sx;
#line 1142
        sx ++;
#line 1142
        *__cil_tmp28 = *p;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1132
      p ++;
#line 1144
      *sx = (char )0;
      {
#line 1145
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1145
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1146
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1146
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1148
    if ((int )*s == 44) {
#line 1149
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1151
  return (0);
}
}
#line 1155 "/tmp/screen-3.9.15/termcap.c"
void FreeTransTable(void) 
{ 
  char ***p ;
  char **q ;
  int i ;
  int j ;
  int __cil_tmp5 ;
  char **__cil_tmp6 ;
  int __cil_tmp7 ;
  char ***__cil_tmp8 ;

  {
#line 1160
  p = display->d_xtable;
#line 1160
  if (p == (char ***)0) {
#line 1161
    return;
  }
#line 1162
  i = 0;
  {
#line 1162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1162
    if (! (i < 256)) {
#line 1162
      goto while_break;
    }
#line 1164
    if (*p == (char **)0) {
#line 1165
      goto while_continue;
    }
#line 1166
    q = *p;
#line 1167
    j = 0;
    {
#line 1167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1167
      if (! (j < 257)) {
#line 1167
        goto while_break___0;
      }
#line 1168
      if (*q) {
        {
#line 1169
        free((void *)*q);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1167
    __cil_tmp6 = q;
#line 1167
    q ++;
    {
#line 1167
    __cil_tmp5 = j;
#line 1167
    j ++;
#line 1170
    free((void *)*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  __cil_tmp8 = p;
#line 1162
  p ++;
  {
#line 1162
  __cil_tmp7 = i;
#line 1162
  i ++;
#line 1172
  free((void *)display->d_xtable);
  }
}
}
#line 1177 "/tmp/screen-3.9.15/termcap.c"
static int copyarg(char **pp , char *s ) 
{ 
  int l ;
  char *p ;
  char *__cil_tmp6 ;

  {
#line 1183
  p = *pp;
#line 1183
  l = 0;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! ((int )*p && (int )*p != 44)) {
#line 1183
      goto while_break;
    }
#line 1185
    if ((int )*p == 92) {
#line 1185
      if ((int )*(p + 1) == 92) {
#line 1186
        p ++;
      } else
#line 1185
      if ((int )*(p + 1) == 44) {
#line 1186
        p ++;
      } else
#line 1185
      if ((int )*(p + 1) == 37) {
#line 1186
        p ++;
      }
    }
#line 1187
    if (s) {
#line 1188
      __cil_tmp6 = s;
#line 1188
      s ++;
#line 1188
      *__cil_tmp6 = *p;
    }
#line 1189
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1183
  p ++;
#line 1191
  if ((int )*p == 44) {
#line 1192
    p ++;
  }
#line 1193
  *pp = p;
#line 1194
  return (l);
}
}
#line 1205 "/tmp/screen-3.9.15/termcap.c"
static int e_tgetent(char *bp , char *name ) 
{ 
  int r ;

  {
  {
#line 1211
  xseteuid(real_uid);
#line 1212
  xsetegid(real_gid);
#line 1214
  r = tgetent(bp, name);
#line 1216
  xseteuid(eff_uid);
#line 1217
  xsetegid(eff_gid);
  }
#line 1219
  return (r);
}
}
#line 1230 "/tmp/screen-3.9.15/termcap.c"
static char *findcap(char *cap , char **tepp , int n ) 
{ 
  char *tep ;
  char c ;
  char *p ;
  char *cp ;
  int mode ;
  int num ;
  int capl ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1238
  num = 0;
#line 1240
  if (! extra_incap) {
#line 1241
    return ((char *)0);
  }
  {
#line 1242
  tep = *tepp;
#line 1243
  __cil_tmp11 = strlen((char const   *)cap);
#line 1243
  capl = (int )__cil_tmp11;
#line 1244
  cp = (char *)0;
#line 1245
  mode = 0;
#line 1246
  p = extra_incap;
  }
  {
#line 1246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1246
    if (! *p) {
#line 1246
      goto while_break;
    }
    {
#line 1248
    __cil_tmp12 = strncmp((char const   *)p, (char const   *)cap, (unsigned long )capl);
    }
#line 1248
    if (__cil_tmp12 == 0) {
#line 1250
      p += capl;
#line 1251
      c = *p;
#line 1252
      if ((int )c) {
#line 1252
        if ((int )c != 58) {
#line 1252
          if ((int )c != 64) {
#line 1253
            p ++;
          }
        }
      }
#line 1254
      if ((int )c == 0) {
#line 1255
        cp = tep;
      } else
#line 1254
      if ((int )c == 64) {
#line 1255
        cp = tep;
      } else
#line 1254
      if ((int )c == 61) {
#line 1255
        cp = tep;
      } else
#line 1254
      if ((int )c == 58) {
#line 1255
        cp = tep;
      } else
#line 1254
      if ((int )c == 35) {
#line 1255
        cp = tep;
      }
    }
    {
#line 1257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1257
      if (! c) {
#line 1257
        goto while_break___0;
      }
#line 1259
      p ++;
#line 1260
      if (mode == 0) {
#line 1262
        if ((int )c == 58) {
#line 1263
          goto while_break___0;
        }
#line 1264
        if ((int )c == 94) {
#line 1265
          mode = 1;
        }
#line 1266
        if ((int )c == 92) {
#line 1267
          mode = 2;
        }
      } else
#line 1269
      if (mode == 1) {
#line 1271
        mode = 0;
#line 1272
        c = (char )((int )c & 31);
      } else
#line 1274
      if (mode == 2) {
#line 1276
        mode = 0;
        {
#line 1288
        if ((int )c == '9') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '8') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '7') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '6') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '5') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '4') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '3') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '2') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '1') {
#line 1288
          goto case_57;
        }
#line 1288
        if ((int )c == '0') {
#line 1288
          goto case_57;
        }
#line 1292
        if ((int )c == 'E') {
#line 1292
          goto case_69;
        }
#line 1295
        if ((int )c == 'n') {
#line 1295
          goto case_110;
        }
#line 1298
        if ((int )c == 'r') {
#line 1298
          goto case_114;
        }
#line 1301
        if ((int )c == 't') {
#line 1301
          goto case_116;
        }
#line 1304
        if ((int )c == 'b') {
#line 1304
          goto case_98;
        }
#line 1307
        if ((int )c == 'f') {
#line 1307
          goto case_102;
        }
#line 1277
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1289
        mode = 3;
#line 1290
        num = 0;
#line 1291
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1293
        c = (char )27;
#line 1294
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1296
        c = (char )'\n';
#line 1297
        goto switch_break;
        case_114: /* CIL Label */ 
#line 1299
        c = (char )'\r';
#line 1300
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1302
        c = (char )'\t';
#line 1303
        goto switch_break;
        case_98: /* CIL Label */ 
#line 1305
        c = (char )'\b';
#line 1306
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1308
        c = (char )'\f';
#line 1309
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1312
      if (mode > 2) {
#line 1314
        num = num * 8 + ((int )c - 48);
#line 1315
        __cil_tmp15 = mode;
#line 1315
        mode ++;
#line 1315
        if (__cil_tmp15 == 5) {
#line 1317
          c = (char )num;
#line 1318
          mode = 0;
        } else
#line 1315
        if ((int )*p < 48) {
#line 1317
          c = (char )num;
#line 1318
          mode = 0;
        } else
#line 1315
        if ((int )*p > 57) {
#line 1317
          c = (char )num;
#line 1318
          mode = 0;
        }
      }
#line 1321
      if (mode) {
#line 1322
        goto while_continue___0;
      }
#line 1324
      if (cp) {
#line 1324
        if (n != 1) {
#line 1326
          __cil_tmp16 = cp;
#line 1326
          cp ++;
#line 1326
          *__cil_tmp16 = c;
#line 1327
          __cil_tmp17 = n;
#line 1327
          n --;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1330
    if (cp) {
#line 1332
      __cil_tmp18 = cp;
#line 1332
      cp ++;
#line 1332
      *__cil_tmp18 = (char )0;
#line 1333
      *tepp = cp;
      {
#line 1334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1334
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1335
      return (tep);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  return ((char *)0);
}
}
#line 1342 "/tmp/screen-3.9.15/termcap.c"
static char *e_tgetstr(char *cap , char **tepp ) 
{ 
  char *tep ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 1347
  tep = findcap(cap, tepp, 0);
  }
#line 1347
  if (tep) {
#line 1348
    if ((int )*tep == 64) {
#line 1348
      tmp = (char *)0;
    } else {
#line 1348
      tmp = tep;
    }
#line 1348
    return (tmp);
  }
  {
#line 1349
  __cil_tmp6 = tgetstr(cap, tepp);
  }
#line 1349
  return (__cil_tmp6);
}
}
#line 1353 "/tmp/screen-3.9.15/termcap.c"
static int e_tgetflag(char *cap ) 
{ 
  char buf[2] ;
  char *bufp ;
  char *tep ;
  int tmp ;
  int __cil_tmp7 ;

  {
  {
#line 1358
  bufp = (char *)buf;
#line 1359
  tep = findcap(cap, & bufp, 2);
  }
#line 1359
  if (tep) {
#line 1360
    if ((int )*tep == 64) {
#line 1360
      tmp = 0;
    } else {
#line 1360
      tmp = 1;
    }
#line 1360
    return (tmp);
  }
  {
#line 1361
  __cil_tmp7 = tgetflag(cap);
  }
#line 1361
  return (__cil_tmp7 > 0);
}
}
#line 1365 "/tmp/screen-3.9.15/termcap.c"
static int e_tgetnum(char *cap ) 
{ 
  char buf[20] ;
  char *bufp ;
  char *tep ;
  char c ;
  int res ;
  int base ;
  int __cil_tmp10 ;

  {
  {
#line 1370
  base = 10;
#line 1372
  bufp = (char *)buf;
#line 1373
  tep = findcap(cap, & bufp, 20);
  }
#line 1373
  if (tep) {
#line 1375
    c = *tep;
#line 1376
    if ((int )c == 64) {
#line 1377
      return (- 1);
    }
#line 1378
    if ((int )c == 48) {
#line 1379
      base = 8;
    }
#line 1380
    res = 0;
    {
#line 1381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1381
      if (! ((int )c >= 48 && (int )c <= 57)) {
#line 1381
        goto while_break;
      }
#line 1382
      res = res * base + ((int )c - 48);
    }
    while_break: /* CIL Label */ ;
    }
#line 1383
    return (res);
  }
  {
#line 1385
  __cil_tmp10 = tgetnum(cap);
  }
#line 1385
  return (__cil_tmp10);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 120 "./extern.h"
void exit_with_usage(char *myname , char *message , char *arg ) ;
#line 127
void WListUpdatecv(struct canvas *cv , struct win *p ) ;
#line 334
void centerline(char *str , int y ) ;
#line 335
void leftline(char *str , int y ) ;
#line 356
int AddXChar(char *buf , int ch ) ;
#line 40 "/tmp/screen-3.9.15/help.c"
extern char *blank ;
#line 43
static void PadStr(char *str , int n , int x , int y ) ;
#line 49 "/tmp/screen-3.9.15/help.c"
void exit_with_usage(char *myname , char *message , char *arg ) 
{ 


  {
  {
#line 52
  printf((char const   *)((char *)"Use: %s [-opts] [cmd [args]]\n"), myname);
#line 53
  printf((char const   *)((char *)" or: %s -r [host.tty]\n\nOptions:\n"), myname);
#line 54
  printf((char const   *)((char *)"-a            Force all capabilities into each window\'s termcap.\n"));
#line 55
  printf((char const   *)((char *)"-A -[r|R]     Adapt all windows to the new display width & height.\n"));
#line 56
  printf((char const   *)((char *)"-c file       Read configuration file instead of \'.screenrc\'.\n"));
#line 58
  printf((char const   *)((char *)"-d (-r)       Detach the elsewhere running screen (and reattach here).\n"));
#line 59
  printf((char const   *)((char *)"-dmS name     Start as daemon: Screen session in detached mode.\n"));
#line 60
  printf((char const   *)((char *)"-D (-r)       Detach and logout remote (and reattach here).\n"));
#line 61
  printf((char const   *)((char *)"-D -RR        Do whatever is needed to get a screen session.\n"));
#line 63
  printf((char const   *)((char *)"-e xy         Change command characters.\n"));
#line 64
  printf((char const   *)((char *)"-f            Flow control on, -fn = off, -fa = auto.\n"));
#line 65
  printf((char const   *)((char *)"-h lines      Set the size of the scrollback history buffer.\n"));
#line 66
  printf((char const   *)((char *)"-i            Interrupt output sooner when flow control is on.\n"));
#line 68
  printf((char const   *)((char *)"-l            Login mode on (update %s), -ln = off.\n"),
         (char *)"/var/run/utmp");
#line 70
  printf((char const   *)((char *)"-list         or -ls. Do nothing, just list our SockDir.\n"));
#line 71
  printf((char const   *)((char *)"-L            Turn on output logging.\n"));
#line 72
  printf((char const   *)((char *)"-m            ignore $STY variable, do create a new screen session.\n"));
#line 73
  printf((char const   *)((char *)"-O            Choose optimal output rather than exact vt100 emulation.\n"));
#line 74
  printf((char const   *)((char *)"-p window     Preselect the named window if it exists.\n"));
#line 75
  printf((char const   *)((char *)"-q            Quiet startup. Exits with non-zero return code if unsuccessful.\n"));
#line 76
  printf((char const   *)((char *)"-r            Reattach to a detached screen process.\n"));
#line 77
  printf((char const   *)((char *)"-R            Reattach if possible, otherwise start a new session.\n"));
#line 78
  printf((char const   *)((char *)"-s shell      Shell to execute rather than $SHELL.\n"));
#line 79
  printf((char const   *)((char *)"-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.\n"));
#line 80
  printf((char const   *)((char *)"-t title      Set title. (window\'s name).\n"));
#line 81
  printf((char const   *)((char *)"-T term       Use term as $TERM for windows, rather than \"screen\".\n"));
#line 83
  printf((char const   *)((char *)"-U            Tell screen to use UTF-8 encoding.\n"));
#line 85
  printf((char const   *)((char *)"-v            Print \"Screen version %s\".\n"),
         (char *)version);
#line 86
  printf((char const   *)((char *)"-wipe         Do nothing, just clean up SockDir.\n"));
#line 88
  printf((char const   *)((char *)"-x            Attach to a not detached screen. (Multi display mode).\n"));
#line 90
  printf((char const   *)((char *)"-X            Execute <cmd> as a screen command in the specified session.\n"));
  }
#line 91
  if (message) {
#line 91
    if ((int )*message) {
      {
#line 93
      printf((char const   *)((char *)"\nError: "));
#line 94
      printf((char const   *)message, arg);
#line 95
      printf((char const   *)((char *)"\n"));
      }
    }
  }
  {
#line 97
  exit(1);
  }
}
}
#line 107
static void HelpProcess(char **ppbuf , int *plen ) ;
#line 108
static void HelpAbort(void) ;
#line 109
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 110
static void add_key_to_buf(char *buf , int key ) ;
#line 111
static void AddAction(struct action *act , int x , int y ) ;
#line 112
static int helppage(void) ;
#line 128 "/tmp/screen-3.9.15/help.c"
static struct LayFuncs HelpLf  =    {HelpProcess, HelpAbort, HelpRedisplayLine, DefClearLine, DefRewrite, DefResize,
    DefRestore};
#line 141 "/tmp/screen-3.9.15/help.c"
void display_help(char *class , struct action *ktabp ) 
{ 
  int i ;
  int n ;
  int key ;
  int mcom ;
  int mkey ;
  int l ;
  struct helpdata *helpdata ;
  int used[170] ;
  int __cil_tmp11 ;
  int tmp ;
  int tmp___284 ;
  size_t __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 149
  if (flayer->l_height < 6) {
    {
#line 151
    LMsg(0, (char *)"Window height too small for help page");
    }
#line 152
    return;
  }
  {
#line 154
  __cil_tmp11 = InitOverlayPage((int )sizeof(*helpdata), & HelpLf, 0);
  }
#line 154
  if (__cil_tmp11) {
#line 155
    return;
  }
#line 157
  helpdata = (struct helpdata *)flayer->l_data;
#line 158
  helpdata->class = class;
#line 159
  helpdata->ktabp = ktabp;
#line 160
  helpdata->command_bindings = 0;
#line 160
  helpdata->num_names = helpdata->command_bindings;
#line 161
  helpdata->command_search = 0;
#line 162
  n = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (n <= 169)) {
#line 162
      goto while_break;
    }
#line 163
    used[n] = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  n ++;
#line 164
  mcom = 0;
#line 165
  mkey = 0;
#line 166
  key = 0;
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! (key < 256)) {
#line 166
      goto while_break___0;
    }
#line 168
    n = (ktabp + key)->nr;
#line 169
    if (n == -1) {
#line 170
      goto while_continue___0;
    }
#line 171
    if ((ktabp + key)->args == (char **)noargs) {
#line 173
      if (key <= 32 || key == 127) {
#line 173
        tmp___284 = 3;
      } else {
#line 173
        if (key > 127) {
#line 173
          tmp = 5;
        } else {
#line 173
          tmp = 2;
        }
#line 173
        tmp___284 = tmp;
      }
#line 173
      used[n] += tmp___284;
    } else {
#line 177
      (helpdata->command_bindings) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 166
  key ++;
#line 179
  i = 0;
#line 179
  n = i;
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (! (n <= 169)) {
#line 179
      goto while_break___1;
    }
#line 180
    if (used[n]) {
      {
#line 182
      __cil_tmp17 = strlen((char const   *)comms[n].name);
#line 182
      l = (int )__cil_tmp17;
      }
#line 183
      if (l > mcom) {
#line 184
        mcom = l;
      }
#line 185
      if (used[n] > mkey) {
#line 186
        mkey = used[n];
      }
#line 187
      __cil_tmp18 = i;
#line 187
      i ++;
#line 187
      helpdata->nact[__cil_tmp18] = n;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 179
  n ++;
  {
#line 189
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 189
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 191
  helpdata->num_names = i;
#line 193
  if (mkey > 256) {
#line 194
    mkey = 256;
  }
#line 195
  helpdata->numcols = flayer->l_width / ((mcom + mkey) + 1);
#line 196
  if (helpdata->numcols == 0) {
    {
#line 198
    HelpAbort();
#line 199
    LMsg(0, (char *)"Width too small");
    }
#line 200
    return;
  }
#line 202
  helpdata->inter = (flayer->l_width - (mcom + mkey) * helpdata->numcols) / (helpdata->numcols + 1);
#line 203
  if (helpdata->inter <= 0) {
#line 204
    helpdata->inter = 1;
  }
  {
#line 205
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 205
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 206
  helpdata->mcom = mcom;
#line 207
  helpdata->mkey = mkey;
#line 208
  helpdata->numrows = ((helpdata->num_names + helpdata->numcols) - 1) / helpdata->numcols;
  {
#line 209
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 209
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 210
  helpdata->numskip = (flayer->l_height - 5) - (2 + helpdata->numrows);
  {
#line 211
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 211
    if (! (helpdata->numskip < 0)) {
#line 211
      goto while_break___6;
    }
#line 212
    helpdata->numskip += flayer->l_height - 5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 213
  helpdata->numskip %= flayer->l_height - 5;
  {
#line 214
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 214
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 215
  if (helpdata->numskip > flayer->l_height / 3) {
#line 216
    helpdata->numskip = 1;
  } else
#line 215
  if (helpdata->numskip > helpdata->command_bindings) {
#line 216
    helpdata->numskip = 1;
  }
  {
#line 217
  helpdata->maxrow = ((2 + helpdata->numrows) + helpdata->numskip) + helpdata->command_bindings;
#line 218
  helpdata->grow = 0;
#line 220
  helpdata->numpages = ((helpdata->maxrow + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 221
  flayer->l_x = 0;
#line 222
  flayer->l_y = flayer->l_height - 1;
#line 223
  helppage();
  }
}
}
#line 227 "/tmp/screen-3.9.15/help.c"
static void HelpProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  int __cil_tmp4 ;

  {
#line 231
  done = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (! done && *plen > 0)) {
#line 233
      goto while_break;
    }
    {
#line 237
    if ((int )*(*ppbuf) == ' ') {
#line 237
      goto case_32;
    }
#line 242
    if ((int )*(*ppbuf) == '\n') {
#line 242
      goto case_10;
    }
#line 242
    if ((int )*(*ppbuf) == '\r') {
#line 242
      goto case_10;
    }
#line 245
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 238
    __cil_tmp4 = helppage();
    }
#line 238
    if (__cil_tmp4 == 0) {
#line 239
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 243
    done = 1;
#line 244
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 246
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 248
    (*ppbuf) ++;
#line 249
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (done) {
    {
#line 252
    HelpAbort();
    }
  }
}
}
#line 256 "/tmp/screen-3.9.15/help.c"
static void HelpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    oldlay = flayer;
    {
#line 258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 258
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    flayer = flayer->l_next;
#line 258
    oldcvlist = flayer->l_cvlist;
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 258
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 258
    flayer->l_cvlist = oldlay->l_cvlist;
#line 258
    cv = flayer->l_cvlist;
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 258
      if (! cv) {
#line 258
        goto while_break___2;
      }
#line 258
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 258
    cv = cv->c_lnext;
#line 258
    LRefreshAll(flayer, 0);
#line 258
    flayer = oldlay;
#line 258
    cv = flayer->l_cvlist;
    }
    {
#line 258
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 258
      if (! cv) {
#line 258
        goto while_break___3;
      }
#line 258
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 258
    cv = cv->c_lnext;
#line 258
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  ExitOverlayPage();
  }
}
}
#line 264 "/tmp/screen-3.9.15/help.c"
static int helppage(void) 
{ 
  struct helpdata *helpdata ;
  int col ;
  int crow ;
  int n ;
  int key ;
  int x ;
  char buf[256] ;
  char Esc_buf[5] ;
  char cbuf[256] ;
  struct action *ktabp ;
  size_t __cil_tmp12 ;
  int __cil_tmp16 ;
  char *tmp ;

  {
#line 271
  helpdata = (struct helpdata *)flayer->l_data;
#line 273
  ktabp = helpdata->ktabp;
#line 274
  if (helpdata->grow >= helpdata->maxrow) {
#line 275
    return (- 1);
  }
  {
#line 276
  helpdata->refgrow = helpdata->grow;
#line 277
  helpdata->refcommand_search = helpdata->command_search;
#line 280
  LClearAll(flayer, 0);
#line 282
  sprintf((char *)cbuf, (char const   *)((char *)"Screen key bindings, page %d of %d."),
          helpdata->grow / (flayer->l_height - 5) + 1, helpdata->numpages);
#line 283
  centerline((char *)cbuf, 0);
#line 284
  crow = 2;
#line 286
  *((char *)Esc_buf) = (char )'\000';
#line 287
  *((char *)buf) = (char )'\000';
  }
#line 289
  if (flayer->l_cvlist) {
#line 289
    if ((flayer->l_cvlist)->c_display) {
      {
#line 291
      add_key_to_buf((char *)buf, (((flayer->l_cvlist)->c_display)->d_user)->u_MetaEsc);
#line 292
      add_key_to_buf((char *)Esc_buf, (((flayer->l_cvlist)->c_display)->d_user)->u_Esc);
      }
    } else {
      {
      {
#line 296
      strcpy((char *)Esc_buf, (char const   *)((char *)"??"));
      }
      {
#line 297
      strcpy((char *)buf, (char const   *)((char *)"??"));
      }
      }
    }
  } else {
    {
    {
#line 296
    strcpy((char *)Esc_buf, (char const   *)((char *)"??"));
    }
    {
#line 297
    strcpy((char *)buf, (char const   *)((char *)"??"));
    }
    }
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (crow < flayer->l_height - 3)) {
#line 300
      goto while_break;
    }
#line 302
    if (helpdata->grow < 1) {
#line 304
      if (ktabp == (struct action *)ktab) {
        {
#line 305
        sprintf((char *)cbuf, (char const   *)((char *)"Command key:  %s   Literal %s:  %s"),
                (char *)Esc_buf, (char *)Esc_buf, (char *)buf);
        }
      } else {
        {
#line 307
        sprintf((char *)cbuf, (char const   *)((char *)"Command class: \'%.80s\'"),
                helpdata->class);
        }
      }
      {
#line 308
      centerline((char *)cbuf, crow);
#line 309
      (helpdata->grow) ++;
      }
    } else
#line 311
    if (helpdata->grow >= 2) {
#line 311
      if (helpdata->grow - 2 < helpdata->numrows) {
#line 313
        x = 0;
#line 314
        col = 0;
        {
#line 314
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 314
          if (! (col < helpdata->numcols && n < helpdata->num_names)) {
#line 314
            goto while_break___0;
          }
#line 316
          x += helpdata->inter - ! col;
#line 317
          n = helpdata->nact[n];
#line 318
          buf[0] = (char )'\000';
#line 319
          key = 0;
          {
#line 319
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 319
            if (! (key < 256)) {
#line 319
              goto while_break___1;
            }
            {
#line 320
            __cil_tmp12 = strlen((char const   *)((char *)buf));
            }
#line 320
            if ((ktabp + key)->nr == n) {
#line 320
              if ((ktabp + key)->args == (char **)noargs) {
#line 320
                if (__cil_tmp12 < sizeof(buf) - 7UL) {
                  {
#line 322
                  strcat((char *)buf, (char const   *)((char *)" "));
#line 323
                  add_key_to_buf((char *)buf, key);
                  }
                }
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 319
          key ++;
#line 325
          PadStr(comms[n].name, helpdata->mcom, x, crow);
#line 326
          x += helpdata->mcom;
#line 327
          PadStr((char *)buf, helpdata->mkey, x, crow);
#line 328
          x += helpdata->mkey;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 314
        col ++;
#line 330
        (helpdata->grow) ++;
      } else {
#line 311
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 332
    if ((helpdata->grow - 2) - helpdata->numrows >= helpdata->numskip) {
#line 332
      if (((helpdata->grow - 2) - helpdata->numrows) - helpdata->numskip < helpdata->command_bindings) {
        {
#line 335
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 335
          if (! (n == -1 || (ktabp + helpdata->command_search)->args == (char **)noargs)) {
#line 335
            goto while_break___2;
          }
#line 338
          (helpdata->command_search) ++;
#line 338
          if (helpdata->command_search >= 256) {
#line 339
            return (- 1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 341
        buf[0] = (char )'\000';
#line 342
        add_key_to_buf((char *)buf, helpdata->command_search);
#line 343
        PadStr((char *)buf, 4, 0, crow);
#line 344
        __cil_tmp16 = helpdata->command_search;
#line 344
        (helpdata->command_search) ++;
#line 344
        AddAction(& *(ktabp + __cil_tmp16), 4, crow);
#line 345
        (helpdata->grow) ++;
        }
      } else {
#line 348
        (helpdata->grow) ++;
      }
    } else {
#line 348
      (helpdata->grow) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  crow ++;
#line 350
  if (helpdata->grow < helpdata->maxrow) {
#line 350
    tmp = (char *)"for next page;";
  } else {
#line 350
    tmp = (char *)"or";
  }
  {
#line 350
  sprintf((char *)cbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp);
#line 352
  centerline((char *)cbuf, flayer->l_height - 2);
#line 353
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 354
  return (0);
}
}
#line 358 "/tmp/screen-3.9.15/help.c"
static void AddAction(struct action *act , int x , int y ) 
{ 
  char buf[256] ;
  int del ;
  int l ;
  char *bp ;
  char *cp ;
  char **pp ;
  int fr ;
  struct mchar mchar_dol ;
  size_t __cil_tmp12 ;
  struct mchar *tmp ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  struct mchar *tmp___285 ;
  int __cil_tmp26 ;

  {
#line 368
  mchar_dol = mchar_blank;
#line 369
  mchar_dol.image = (unsigned char )'$';
#line 371
  fr = (flayer->l_width - 1) - x;
#line 372
  if (fr <= 0) {
#line 373
    return;
  }
  {
#line 374
  __cil_tmp12 = strlen((char const   *)comms[act->nr].name);
#line 374
  l = (int )__cil_tmp12;
  }
#line 376
  if (l + 1 > fr) {
#line 377
    l = fr - 1;
  }
  {
#line 378
  PadStr(comms[act->nr].name, l, x, y);
#line 379
  x += l;
#line 380
  fr -= l + 1;
  }
#line 381
  if (fr) {
#line 381
    tmp = & mchar_blank;
  } else {
#line 381
    tmp = & mchar_dol;
  }
  {
#line 381
  __cil_tmp14 = x;
#line 381
  x ++;
#line 381
  LPutChar(flayer, tmp, __cil_tmp14, y);
#line 383
  pp = act->args;
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (pp && cp != (char *)((void *)0))) {
#line 384
      goto while_break;
    }
    {
#line 386
    del = 0;
#line 387
    bp = (char *)buf;
#line 388
    __cil_tmp15 = index((char const   *)cp, ' ');
    }
#line 388
    if (! *cp) {
      _L: /* CIL Label */ 
      {
#line 390
      __cil_tmp16 = index((char const   *)cp, '\'');
      }
#line 390
      if (__cil_tmp16 != (char *)((void *)0)) {
#line 391
        del = '\"';
#line 391
        __cil_tmp17 = bp;
#line 391
        bp ++;
#line 391
        *__cil_tmp17 = (char )del;
      } else {
#line 393
        del = '\'';
#line 393
        __cil_tmp18 = bp;
#line 393
        bp ++;
#line 393
        *__cil_tmp18 = (char )del;
      }
    } else
#line 388
    if (__cil_tmp15 != (char *)((void *)0)) {
#line 388
      goto _L;
    }
    {
#line 395
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 395
      if (! ((int )*cp && bp < (char *)buf + 250)) {
#line 395
        goto while_break___0;
      }
      {
#line 396
      __cil_tmp19 = cp;
#line 396
      cp ++;
#line 396
      __cil_tmp20 = AddXChar(bp, (int )*((unsigned char *)__cil_tmp19));
      }
#line 396
      bp += __cil_tmp20;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 397
    if (del) {
#line 398
      __cil_tmp21 = bp;
#line 398
      bp ++;
#line 398
      *__cil_tmp21 = (char )del;
    }
#line 399
    *bp = (char )0;
#line 400
    fr -= (bp - (char *)buf) + 1L;
#line 400
    if (fr < 0) {
#line 402
      fr += bp - (char *)buf;
#line 403
      if (fr > 0) {
        {
#line 404
        PadStr((char *)buf, fr, x, y);
        }
      }
#line 405
      if (fr == 0) {
        {
#line 406
        LPutChar(flayer, & mchar_dol, x, y);
        }
      }
#line 407
      return;
    }
    {
#line 409
    __cil_tmp22 = strlen((char const   *)((char *)buf));
#line 409
    PadStr((char *)buf, (int )__cil_tmp22, x, y);
#line 410
    __cil_tmp23 = strlen((char const   *)((char *)buf));
    }
#line 410
    x += __cil_tmp23;
#line 411
    pp ++;
#line 412
    if (*pp) {
#line 413
      if (fr) {
#line 413
        tmp___285 = & mchar_blank;
      } else {
#line 413
        tmp___285 = & mchar_dol;
      }
      {
#line 413
      __cil_tmp26 = x;
#line 413
      x ++;
#line 413
      LPutChar(flayer, tmp___285, __cil_tmp26, y);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 418 "/tmp/screen-3.9.15/help.c"
static void add_key_to_buf(char *buf , int key ) 
{ 
  size_t __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 422
  __cil_tmp3 = strlen((char const   *)buf);
  }
#line 422
  buf += __cil_tmp3;
#line 423
  if (key < 0) {
    {
#line 424
    strcpy(buf, (char const   *)((char *)"unset"));
    }
  } else
#line 425
  if (key == 32) {
    {
#line 426
    strcpy(buf, (char const   *)((char *)"sp"));
    }
  } else {
    {
#line 428
    __cil_tmp4 = AddXChar(buf, key);
#line 428
    *(buf + __cil_tmp4) = (char )0;
    }
  }
}
}
#line 433 "/tmp/screen-3.9.15/help.c"
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct helpdata *helpdata ;

  {
#line 436
  if (y < 0) {
    {
#line 440
    helpdata = (struct helpdata *)flayer->l_data;
#line 441
    helpdata->grow = helpdata->refgrow;
#line 442
    helpdata->command_search = helpdata->refcommand_search;
#line 443
    helppage();
    }
#line 444
    return;
  }
#line 446
  if (y != 0) {
#line 446
    if (y != flayer->l_height - 1) {
#line 447
      return;
    }
  }
#line 448
  if (! isblank) {
    {
#line 449
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
}
}
#line 459
static void CopyrightProcess(char **ppbuf , int *plen ) ;
#line 460
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 461
static void CopyrightAbort(void) ;
#line 462
static void copypage(void) ;
#line 470 "/tmp/screen-3.9.15/help.c"
static struct LayFuncs CopyrightLf  =    {CopyrightProcess, CopyrightAbort, CopyrightRedisplayLine, DefClearLine, DefRewrite,
    DefResize, DefRestore};
#line 481 "/tmp/screen-3.9.15/help.c"
static char const   cpmsg[]  =    "\nScreen version %v\n\nCopyright (c) 1993-2002 Juergen Weigert, Michael Schroeder\nCopyright (c) 1987 Oliver Laumann\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program (see the file COPYING); if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\nSend bugreports, fixes, enhancements, t-shirts, money, beer & pizza to screen@uni-erlangen.de\n";
#line 508 "/tmp/screen-3.9.15/help.c"
static void CopyrightProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct copydata *copydata ;

  {
#line 512
  done = 0;
#line 515
  copydata = (struct copydata *)flayer->l_data;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (! done && *plen > 0)) {
#line 516
      goto while_break;
    }
    {
#line 520
    if ((int )*(*ppbuf) == ' ') {
#line 520
      goto case_32;
    }
#line 528
    if ((int )*(*ppbuf) == '\n') {
#line 528
      goto case_10;
    }
#line 528
    if ((int )*(*ppbuf) == '\r') {
#line 528
      goto case_10;
    }
#line 532
    goto switch_default;
    case_32: /* CIL Label */ 
#line 521
    if (*(copydata->cps)) {
      {
#line 523
      copypage();
      }
#line 524
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 529
    CopyrightAbort();
    }
#line 530
    done = 1;
#line 531
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 533
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 535
    (*ppbuf) ++;
#line 536
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 541 "/tmp/screen-3.9.15/help.c"
static void CopyrightAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    oldlay = flayer;
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 543
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 543
    flayer = flayer->l_next;
#line 543
    oldcvlist = flayer->l_cvlist;
    {
#line 543
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 543
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 543
    flayer->l_cvlist = oldlay->l_cvlist;
#line 543
    cv = flayer->l_cvlist;
    {
#line 543
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 543
      if (! cv) {
#line 543
        goto while_break___2;
      }
#line 543
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 543
    cv = cv->c_lnext;
#line 543
    LRefreshAll(flayer, 0);
#line 543
    flayer = oldlay;
#line 543
    cv = flayer->l_cvlist;
    }
    {
#line 543
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 543
      if (! cv) {
#line 543
        goto while_break___3;
      }
#line 543
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 543
    cv = cv->c_lnext;
#line 543
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 543
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  ExitOverlayPage();
  }
}
}
#line 548 "/tmp/screen-3.9.15/help.c"
void display_copyright(void) 
{ 
  struct copydata *copydata ;
  int __cil_tmp2 ;

  {
#line 552
  if (flayer->l_width < 10) {
    {
    {
#line 554
    LMsg(0, (char *)"Window size too small for copyright page");
    }
    }
#line 555
    return;
  } else
#line 552
  if (flayer->l_height < 5) {
    {
    {
#line 554
    LMsg(0, (char *)"Window size too small for copyright page");
    }
    }
#line 555
    return;
  }
  {
#line 557
  __cil_tmp2 = InitOverlayPage((int )sizeof(*copydata), & CopyrightLf, 0);
  }
#line 557
  if (__cil_tmp2) {
#line 558
    return;
  }
  {
#line 559
  copydata = (struct copydata *)flayer->l_data;
#line 560
  copydata->cps = (char *)((char const   *)cpmsg);
#line 561
  copydata->savedcps = (char *)0;
#line 562
  flayer->l_x = 0;
#line 563
  flayer->l_y = flayer->l_height - 1;
#line 564
  copypage();
  }
}
}
#line 568 "/tmp/screen-3.9.15/help.c"
static void copypage(void) 
{ 
  register char *cps ;
  char *ws ;
  int x ;
  int y ;
  int l ;
  char cbuf[80] ;
  struct copydata *copydata ;
  int __cil_tmp9 ;
  char *tmp ;

  {
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 577
  copydata = (struct copydata *)flayer->l_data;
#line 579
  LClearAll(flayer, 0);
#line 580
  y = 0;
#line 580
  x = y;
#line 581
  cps = copydata->cps;
#line 582
  copydata->refcps = cps;
#line 583
  copydata->refsavedcps = copydata->savedcps;
  }
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (! ((int )*cps && y < flayer->l_height - 3)) {
#line 584
      goto while_break___0;
    }
#line 586
    ws = cps;
    {
#line 587
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 587
      if (! ((int )*cps == 32)) {
#line 587
        goto while_break___1;
      }
#line 588
      cps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 589
    __cil_tmp9 = strncmp((char const   *)cps, (char const   *)((char *)"%v"), (unsigned long )2);
    }
#line 589
    if (__cil_tmp9 == 0) {
#line 591
      copydata->savedcps = cps + 2;
#line 592
      cps = (char *)version;
#line 593
      goto while_continue___0;
    }
    {
#line 595
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 595
      if (! (((int )*cps && (int )*cps != 32) && (int )*cps != 10)) {
#line 595
        goto while_break___2;
      }
#line 596
      cps ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 597
    l = (int )(cps - ws);
#line 598
    cps = ws;
#line 599
    if (l > flayer->l_width - 1) {
#line 600
      l = flayer->l_width - 1;
    }
#line 601
    if (x) {
#line 601
      if (x + l >= flayer->l_width - 2) {
#line 603
        x = 0;
#line 604
        y ++;
#line 605
        goto while_continue___0;
      }
    }
#line 607
    if (x) {
      {
#line 609
      LPutChar(flayer, & mchar_blank, x, y);
#line 610
      x ++;
      }
    }
#line 612
    if (l) {
      {
#line 613
      LPutStr(flayer, ws, l, & mchar_blank, x, y);
      }
    }
#line 614
    x += l;
#line 615
    cps += l;
#line 616
    if ((int )*cps == 0) {
#line 616
      if (copydata->savedcps) {
#line 618
        cps = copydata->savedcps;
#line 619
        copydata->savedcps = (char *)0;
      }
    }
#line 621
    if ((int )*cps == 10) {
#line 623
      x = 0;
#line 624
      y ++;
    }
#line 626
    if ((int )*cps == 32) {
#line 627
      cps ++;
    } else
#line 626
    if ((int )*cps == 10) {
#line 627
      cps ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 629
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 629
    if (! ((int )*cps == 10)) {
#line 629
      goto while_break___3;
    }
#line 630
    cps ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 631
  if ((int )*cps) {
#line 631
    tmp = (char *)"for next page;";
  } else {
#line 631
    tmp = (char *)"or";
  }
  {
#line 631
  sprintf((char *)cbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp);
#line 633
  centerline((char *)cbuf, flayer->l_height - 2);
#line 634
  copydata->cps = cps;
#line 635
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 639 "/tmp/screen-3.9.15/help.c"
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct copydata *copydata ;

  {
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  if (y < 0) {
    {
#line 647
    copydata = (struct copydata *)flayer->l_data;
#line 648
    copydata->cps = copydata->refcps;
#line 649
    copydata->savedcps = copydata->refsavedcps;
#line 650
    copypage();
    }
#line 651
    return;
  }
#line 653
  if (y != 0) {
#line 653
    if (y != flayer->l_height - 1) {
#line 654
      return;
    }
  }
#line 655
  if (isblank) {
#line 656
    return;
  }
  {
#line 657
  LClearArea(flayer, xs, y, xe, y, 0, 0);
  }
}
}
#line 670
static void DisplaysProcess(char **ppbuf , int *plen ) ;
#line 671
static void DisplaysRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 672
static void displayspage(void) ;
#line 679 "/tmp/screen-3.9.15/help.c"
static struct LayFuncs DisplaysLf  =    {DisplaysProcess, HelpAbort, DisplaysRedisplayLine, DefClearLine, DefRewrite, DefResize,
    DefRestore};
#line 691 "/tmp/screen-3.9.15/help.c"
static void DisplaysProcess(char **ppbuf , int *plen ) 
{ 
  int done ;

  {
#line 695
  done = 0;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 698
    if (! (! done && *plen > 0)) {
#line 698
      goto while_break___0;
    }
    {
#line 702
    if ((int )*(*ppbuf) == ' ') {
#line 702
      goto case_32;
    }
#line 706
    if ((int )*(*ppbuf) == '\n') {
#line 706
      goto case_10;
    }
#line 706
    if ((int )*(*ppbuf) == '\r') {
#line 706
      goto case_10;
    }
#line 710
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 703
    displayspage();
    }
#line 704
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 707
    HelpAbort();
    }
#line 708
    done = 1;
#line 709
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 711
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 713
    (*ppbuf) ++;
#line 714
    (*plen) --;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 720 "/tmp/screen-3.9.15/help.c"
void display_displays(void) 
{ 
  int __cil_tmp1 ;

  {
#line 722
  if (flayer->l_width < 10) {
    {
    {
#line 724
    LMsg(0, (char *)"Window size too small for displays page");
    }
    }
#line 725
    return;
  } else
#line 722
  if (flayer->l_height < 5) {
    {
    {
#line 724
    LMsg(0, (char *)"Window size too small for displays page");
    }
    }
#line 725
    return;
  }
  {
#line 727
  __cil_tmp1 = InitOverlayPage((int )sizeof(struct displaysdata ), & DisplaysLf, 0);
  }
#line 727
  if (__cil_tmp1) {
#line 728
    return;
  }
  {
#line 729
  flayer->l_x = 0;
#line 730
  flayer->l_y = flayer->l_height - 1;
#line 731
  displayspage();
  }
}
}
#line 756 "/tmp/screen-3.9.15/help.c"
static void displayspage(void) 
{ 
  int y ;
  int l ;
  char tbuf[80] ;
  struct display *d ;
  struct win *w ;
  char *tmp ;
  char *tmp___286 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int tmp___287 ;
  int __cil_tmp11 ;
  int tmp___288 ;
  int tmp___289 ;
  int __cil_tmp14 ;
  int tmp___290 ;
  int tmp___291 ;
  int tmp___292 ;
  int __cil_tmp18 ;
  int tmp___293 ;
  char *tmp___294 ;

  {
  {
#line 763
  LClearAll(flayer, 0);
#line 765
  leftline((char *)"term-type   size         user interface           window", 0);
#line 766
  leftline((char *)"---------- ------- ---------- ----------------- ----------", 1);
#line 767
  y = 2;
#line 769
  d = displays;
  }
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! d) {
#line 769
      goto while_break;
    }
#line 771
    w = d->d_fore;
#line 773
    if (y >= flayer->l_height - 3) {
#line 774
      goto while_break;
    }
#line 775
    if ((int )d->d_nonblock) {
#line 775
      if (d->d_obufp - d->d_obuf > (long )d->d_obufmax) {
#line 775
        tmp = (char *)"NB";
      } else {
#line 775
        tmp = (char *)"nb";
      }
#line 775
      tmp___286 = tmp;
    } else {
#line 775
      tmp___286 = (char *)"  ";
    }
    {
#line 775
    sprintf((char *)tbuf, (char const   *)((char *)"%-10.10s%4dx%-4d%10.10s@%-16.16s%s"),
            (char *)d->d_termname, d->d_width, d->d_height, (char *)(d->d_user)->u_name,
            (char *)d->d_usertty, tmp___286);
    }
#line 781
    if (w) {
      {
#line 783
      __cil_tmp8 = strlen((char const   *)w->w_title);
#line 783
      l = (int )(10UL - __cil_tmp8);
      }
#line 784
      if (l < 0) {
#line 785
        l = 0;
      }
      {
#line 786
      __cil_tmp9 = strlen((char const   *)((char *)tbuf));
      }
#line 786
      tmp___287 = ' ';
      {
#line 786
      __cil_tmp11 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 786
      if (__cil_tmp11) {
#line 786
        tmp___289 = '-';
      } else {
#line 786
        if (w->w_wlock == 0 || d->d_user == w->w_wlockuser) {
#line 786
          tmp___288 = 'r';
        } else {
#line 786
          tmp___288 = 'R';
        }
#line 786
        tmp___289 = tmp___288;
      }
      {
#line 786
      __cil_tmp14 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 786
      if (__cil_tmp14) {
#line 786
        tmp___292 = '-';
      } else {
#line 786
        if (w->w_wlock == 0) {
#line 786
          tmp___291 = 'w';
        } else {
#line 786
          if (d->d_user == w->w_wlockuser) {
#line 786
            tmp___290 = 'W';
          } else {
#line 786
            tmp___290 = 'v';
          }
#line 786
          tmp___291 = tmp___290;
        }
#line 786
        tmp___292 = tmp___291;
      }
      {
#line 786
      __cil_tmp18 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 786
      if (__cil_tmp18) {
#line 786
        tmp___293 = '-';
      } else {
#line 786
        tmp___293 = 'x';
      }
      {
#line 786
      sprintf((char *)tbuf + __cil_tmp9, (char const   *)((char *)"%3d(%.10s)%*s%c%c%c%c"),
              w->w_number, w->w_title, l, (char *)"", tmp___287, tmp___289, tmp___292,
              tmp___293);
      }
    }
    {
#line 809
    leftline((char *)tbuf, y);
#line 810
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  d = d->d_next;
#line 812
  tmp___294 = (char *)"to refresh;";
#line 812
  sprintf((char *)tbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp___294);
#line 814
  centerline((char *)tbuf, flayer->l_height - 2);
#line 815
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 819 "/tmp/screen-3.9.15/help.c"
static void DisplaysRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 822
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  if (y < 0) {
    {
#line 825
    displayspage();
    }
#line 826
    return;
  }
#line 828
  if (y != 0) {
#line 828
    if (y != flayer->l_height - 1) {
#line 829
      return;
    }
  }
#line 830
  if (isblank) {
#line 831
    return;
  }
  {
#line 832
  LClearArea(flayer, xs, y, xe, y, 0, 0);
  }
}
}
#line 845
static void WListProcess(char **ppbuf , int *plen ) ;
#line 846
static void WListRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 847
static void wlistpage(void) ;
#line 848
static void WListLine(int y , int i , int pos , int isblank ) ;
#line 849
static void WListLines(int up , int oldpos ) ;
#line 850
static void WListMove(int num , int ypos ) ;
#line 851
static void WListUpdate(struct win *p ) ;
#line 852
static int WListNormalize(void) ;
#line 853
static int WListResize(int wi , int he ) ;
#line 865 "/tmp/screen-3.9.15/help.c"
static struct LayFuncs WListLf  =    {WListProcess, HelpAbort, WListRedisplayLine, DefClearLine, DefRewrite, WListResize,
    DefRestore};
#line 877 "/tmp/screen-3.9.15/help.c"
static int WListResize(int wi , int he ) 
{ 
  struct wlistdata *wlistdata ;

  {
#line 881
  if (wi < 10) {
#line 882
    return (- 1);
  } else
#line 881
  if (he < 5) {
#line 882
    return (- 1);
  }
#line 883
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 884
  flayer->l_width = wi;
#line 885
  flayer->l_height = he;
#line 886
  wlistdata->numwin = he - 3;
#line 887
  if (wlistdata->ypos >= wlistdata->numwin) {
#line 888
    wlistdata->ypos = wlistdata->numwin - 1;
  }
#line 889
  flayer->l_y = he - 1;
#line 890
  return (0);
}
}
#line 894 "/tmp/screen-3.9.15/help.c"
static void WListProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct wlistdata *wlistdata ;
  int h ;
  int n ;
  int d ;
  int __cil_tmp8 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  struct win *p ;
  struct win *tmp ;
  struct win *__cil_tmp15 ;

  {
#line 898
  done = 0;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 904
  h = wlistdata->numwin;
  {
#line 905
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 905
    if (! (! done && *plen > 0)) {
#line 905
      goto while_break___0;
    }
#line 907
    if ((int )((unsigned char )*(*ppbuf)) >= 48) {
#line 907
      if ((int )((unsigned char )*(*ppbuf)) <= 57) {
#line 909
        n = (int )((unsigned char )*(*ppbuf)) - 48;
#line 910
        d = 0;
#line 911
        if (n < 40) {
#line 911
          if (wtab[n]) {
            {
#line 913
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 913
              if (! (wlistdata->pos > n)) {
#line 913
                goto while_break___1;
              }
#line 915
              if (wtab[n]) {
#line 916
                __cil_tmp8 = d;
#line 916
                d --;
              }
#line 917
              n ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 919
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 919
              if (! (wlistdata->pos < n)) {
#line 919
                goto while_break___2;
              }
#line 921
              if (wtab[n]) {
#line 922
                d ++;
              }
#line 923
              __cil_tmp11 = n;
#line 923
              n --;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 926
        if (d) {
          {
#line 927
          WListMove(d, - 1);
          }
        }
      }
    }
    {
#line 933
    if ((int )((unsigned char )*(*ppbuf)) == 'k') {
#line 933
      goto case_107;
    }
#line 933
    if ((int )((unsigned char )*(*ppbuf)) == 16) {
#line 933
      goto case_107;
    }
#line 933
    if ((int )((unsigned char )*(*ppbuf)) == 144) {
#line 933
      goto case_107;
    }
#line 938
    if ((int )((unsigned char )*(*ppbuf)) == 'j') {
#line 938
      goto case_106;
    }
#line 938
    if ((int )((unsigned char )*(*ppbuf)) == 14) {
#line 938
      goto case_106;
    }
#line 938
    if ((int )((unsigned char )*(*ppbuf)) == 142) {
#line 938
      goto case_106;
    }
#line 941
    if ((int )((unsigned char )*(*ppbuf)) == '\025') {
#line 941
      goto case_21;
    }
#line 944
    if ((int )((unsigned char )*(*ppbuf)) == '\004') {
#line 944
      goto case_4;
    }
#line 948
    if ((int )((unsigned char )*(*ppbuf)) == 'b') {
#line 948
      goto case_98;
    }
#line 948
    if ((int )((unsigned char )*(*ppbuf)) == 2) {
#line 948
      goto case_98;
    }
#line 952
    if ((int )((unsigned char )*(*ppbuf)) == 'f') {
#line 952
      goto case_102;
    }
#line 952
    if ((int )((unsigned char )*(*ppbuf)) == 6) {
#line 952
      goto case_102;
    }
#line 955
    if ((int )((unsigned char )*(*ppbuf)) == 129) {
#line 955
      goto case_129;
    }
#line 958
    if ((int )((unsigned char )*(*ppbuf)) == 133) {
#line 958
      goto case_133;
    }
#line 963
    if ((int )((unsigned char )*(*ppbuf)) == ' ') {
#line 963
      goto case_32;
    }
#line 963
    if ((int )((unsigned char )*(*ppbuf)) == '\n') {
#line 963
      goto case_32;
    }
#line 963
    if ((int )((unsigned char )*(*ppbuf)) == '\r') {
#line 963
      goto case_32;
    }
#line 977
    if ((int )((unsigned char )*(*ppbuf)) == 7) {
#line 977
      goto case_7;
    }
#line 977
    if ((int )((unsigned char )*(*ppbuf)) == 27) {
#line 977
      goto case_7;
    }
#line 990
    goto switch_default;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
    {
#line 934
    WListMove(- 1, - 1);
    }
#line 935
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
    {
#line 939
    WListMove(1, - 1);
    }
#line 940
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 942
    WListMove(- (h / 2), wlistdata->ypos);
    }
#line 943
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 945
    WListMove(h / 2, wlistdata->ypos);
    }
#line 946
    goto switch_break;
    case_98: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 949
    WListMove(- h, - 1);
    }
#line 950
    goto switch_break;
    case_102: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 953
    WListMove(h, - 1);
    }
#line 954
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 956
    WListMove(- wlistdata->pos, - 1);
    }
#line 957
    goto switch_break;
    case_133: /* CIL Label */ 
    {
#line 959
    WListMove(40, - 1);
    }
#line 960
    goto switch_break;
    case_32: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 964
    done = 1;
#line 965
    h = wlistdata->pos;
#line 966
    if (! display) {
      {
      {
      {
      {
#line 967
      HelpAbort();
      }
      }
      }
      }
    } else
#line 966
    if (! wtab[h]) {
      {
      {
      {
      {
#line 967
      HelpAbort();
      }
      }
      }
      }
    } else
#line 966
    if (wtab[h] == display->d_fore) {
      {
      {
      {
      {
#line 967
      HelpAbort();
      }
      }
      }
      }
    } else
#line 966
    if (flayer->l_cvlist) {
#line 966
      if ((flayer->l_cvlist)->c_lnext) {
        {
        {
        {
        {
#line 967
        HelpAbort();
        }
        }
        }
        }
      } else {
#line 966
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 969
      __cil_tmp12 = AclCheckPermWin(display->d_user, 2, wtab[h]);
      }
#line 969
      if (__cil_tmp12) {
        {
#line 970
        HelpAbort();
        }
      } else {
        {
#line 973
        ExitOverlayPage();
        }
      }
    }
    {
#line 974
    SwitchWindow(h);
    }
#line 975
    goto switch_break;
    case_7: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 978
    h = wlistdata->start;
    {
#line 979
    HelpAbort();
    }
#line 980
    if (h >= 0) {
#line 980
      if (wtab[h]) {
        {
#line 981
        SwitchWindow(h);
        }
      } else {
#line 980
        goto _L___294;
      }
    } else
    _L___294: /* CIL Label */ 
#line 982
    if (h == -2) {
#line 984
      if (display) {
#line 984
        tmp = display->d_other;
      } else {
#line 984
        tmp = (struct win *)0;
      }
      {
#line 984
      __cil_tmp15 = FindNiceWindow(tmp, (char *)0);
#line 984
      p = __cil_tmp15;
      }
#line 985
      if (p) {
        {
#line 986
        SwitchWindow(p->w_number);
        }
      }
    }
#line 988
    done = 1;
#line 989
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 991
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 993
    (*ppbuf) ++;
#line 994
    (*plen) --;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 999 "/tmp/screen-3.9.15/help.c"
static void WListLine(int y , int i , int pos , int isblank ) 
{ 
  char *str ;
  int n ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  struct mchar *tmp___295 ;

  {
  {
#line 1007
  display = (struct display *)0;
#line 1008
  str = MakeWinMsgEv(wliststr, wtab[i], '%', flayer->l_width, (struct event *)0, 0);
#line 1009
  __cil_tmp8 = strlen((char const   *)str);
#line 1009
  n = (int )__cil_tmp8;
  }
#line 1010
  if (i != pos) {
#line 1010
    if (isblank) {
      {
#line 1011
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1011
        if (! (n && (int )*(str + (n - 1)) == 32)) {
#line 1011
          goto while_break;
        }
#line 1012
        __cil_tmp9 = n;
#line 1012
        n --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1013
  if (i == pos || ! isblank) {
#line 1013
    tmp = flayer->l_width;
  } else {
#line 1013
    tmp = n;
  }
#line 1013
  if (i == pos) {
#line 1013
    tmp___295 = & mchar_so;
  } else {
#line 1013
    tmp___295 = & mchar_blank;
  }
  {
#line 1013
  LPutWinMsg(flayer, str, tmp, tmp___295, 0, y + 2);
  }
#line 1020
  return;
}
}
#line 1024 "/tmp/screen-3.9.15/help.c"
static void WListLines(int up , int oldpos ) 
{ 
  struct wlistdata *wlistdata ;
  int ypos ;
  int pos ;
  int y ;
  int i ;
  int first ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1031
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1032
  ypos = wlistdata->ypos;
#line 1033
  pos = wlistdata->pos;
#line 1035
  first = ypos;
#line 1036
  i = pos;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (i >= 0)) {
#line 1036
      goto while_break;
    }
#line 1037
    __cil_tmp9 = first;
#line 1037
    first --;
#line 1037
    if (wtab[i]) {
#line 1037
      if (__cil_tmp9 == 0) {
#line 1038
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  __cil_tmp10 = i;
#line 1036
  i --;
#line 1039
  y = 0;
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1039
    if (! (y < wlistdata->numwin)) {
#line 1039
      goto while_break___0;
    }
    {
#line 1041
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1041
      if (! (i < 40 && wtab[i] == (struct win *)0)) {
#line 1041
        goto while_break___1;
      }
#line 1042
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1043
    if (i == 40) {
#line 1044
      goto while_continue___0;
    }
#line 1045
    if (y == 0) {
#line 1046
      wlistdata->first = i;
    }
#line 1047
    wlistdata->last = i;
#line 1048
    if (i == oldpos) {
      _L___297: /* CIL Label */ 
#line 1048
      if (pos != oldpos) {
        {
        {
        {
#line 1049
        WListLine(y, i, pos, i != oldpos);
        }
        }
        }
      } else {
#line 1048
        goto _L___296;
      }
    } else
#line 1048
    if (i == pos) {
#line 1048
      goto _L___297;
    } else
    _L___296: /* CIL Label */ 
#line 1048
    if (up > 0) {
#line 1048
      if (y >= wlistdata->numwin - up) {
        {
        {
        {
#line 1049
        WListLine(y, i, pos, i != oldpos);
        }
        }
        }
      } else {
#line 1048
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1048
    if (up < 0) {
#line 1048
      if (y < - up) {
        {
        {
        {
#line 1049
        WListLine(y, i, pos, i != oldpos);
        }
        }
        }
      }
    }
#line 1050
    if (i == pos) {
#line 1051
      wlistdata->ypos = y;
    }
#line 1052
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1039
  y ++;
}
}
#line 1057 "/tmp/screen-3.9.15/help.c"
static int WListNormalize(void) 
{ 
  struct wlistdata *wlistdata ;
  int i ;
  int n ;
  int ypos ;
  int pos ;

  {
#line 1063
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1064
  ypos = wlistdata->ypos;
#line 1065
  pos = wlistdata->pos;
#line 1066
  if (ypos < 0) {
#line 1067
    ypos = 0;
  }
#line 1068
  if (ypos >= wlistdata->numwin) {
#line 1069
    ypos = wlistdata->numwin - 1;
  }
#line 1070
  i = pos;
#line 1070
  n = 0;
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    if (! (i < 40 && n < wlistdata->numwin)) {
#line 1070
      goto while_break;
    }
#line 1071
    if (wtab[i]) {
#line 1072
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  i ++;
#line 1073
  if (ypos < wlistdata->numwin - n) {
#line 1074
    ypos = wlistdata->numwin - n;
  }
#line 1075
  i = 0;
#line 1075
  n = i;
  {
#line 1075
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1075
    if (! (i < pos)) {
#line 1075
      goto while_break___0;
    }
#line 1076
    if (wtab[i]) {
#line 1077
      n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1075
  i ++;
#line 1078
  if (ypos > n) {
#line 1079
    ypos = n;
  }
#line 1080
  wlistdata->ypos = ypos;
#line 1081
  wlistdata->npos = n;
#line 1082
  return (ypos);
}
}
#line 1086 "/tmp/screen-3.9.15/help.c"
static void WListMove(int num , int ypos ) 
{ 
  struct wlistdata *wlistdata ;
  int oldpos ;
  int oldypos ;
  int oldnpos ;
  int pos ;
  int up ;
  int i ;
  int tmp ;
  int __cil_tmp11 ;

  {
#line 1094
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1095
  oldpos = wlistdata->pos;
#line 1096
  oldypos = wlistdata->ypos;
#line 1097
  oldnpos = wlistdata->npos;
#line 1098
  if (ypos == -1) {
#line 1098
    tmp = oldypos + num;
  } else {
#line 1098
    tmp = ypos;
  }
#line 1098
  wlistdata->ypos = tmp;
#line 1099
  pos = oldpos;
#line 1100
  i = pos;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (! (num > 0 && i < 39)) {
#line 1101
      goto while_break;
    }
#line 1102
    i ++;
#line 1102
    if (wtab[i]) {
#line 1104
      pos = i;
#line 1105
      __cil_tmp11 = num;
#line 1105
      num --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1107
    if (! (num < 0 && i > 0)) {
#line 1107
      goto while_break___0;
    }
#line 1108
    i --;
#line 1108
    if (wtab[i]) {
#line 1110
      pos = i;
#line 1111
      num ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1113
  wlistdata->pos = pos;
#line 1114
  ypos = WListNormalize();
#line 1115
  up = (wlistdata->npos - ypos) - (oldnpos - oldypos);
  }
#line 1116
  if (up) {
    {
#line 1118
    LScrollV(flayer, up, 2, (2 + wlistdata->numwin) - 1, 0);
#line 1119
    WListLines(up, oldpos);
#line 1120
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
    }
#line 1121
    return;
  }
#line 1123
  if (pos == oldpos) {
#line 1124
    return;
  }
  {
#line 1125
  WListLine(oldypos, oldpos, pos, 0);
#line 1126
  WListLine(ypos, pos, pos, 1);
#line 1127
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 1131 "/tmp/screen-3.9.15/help.c"
static void WListRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  if (y < 0) {
    {
#line 1137
    wlistpage();
    }
#line 1138
    return;
  }
#line 1140
  if (y != 0) {
#line 1140
    if (y != flayer->l_height - 1) {
#line 1141
      return;
    }
  }
#line 1142
  if (! isblank) {
    {
#line 1143
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
}
}
#line 1147 "/tmp/screen-3.9.15/help.c"
void display_wlist(int onblank ) 
{ 
  struct win *p ;
  struct wlistdata *wlistdata ;
  int __cil_tmp4 ;
  int tmp ;
  int tmp___298 ;

  {
#line 1153
  if (flayer->l_width < 10) {
    {
    {
#line 1155
    LMsg(0, (char *)"Window size too small for window list page");
    }
    }
#line 1156
    return;
  } else
#line 1153
  if (flayer->l_height < 5) {
    {
    {
#line 1155
    LMsg(0, (char *)"Window size too small for window list page");
    }
    }
#line 1156
    return;
  }
#line 1158
  if (onblank) {
    {
#line 1160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1160
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1161
    if (! display) {
      {
#line 1163
      LMsg(0, (char *)"windowlist -b: display required");
      }
#line 1164
      return;
    }
    {
#line 1166
    p = display->d_fore;
#line 1167
    SetForeWindow((struct win *)0);
#line 1168
    Activate(0);
    }
#line 1169
    if (flayer->l_width < 10) {
      {
      {
#line 1171
      LMsg(0, (char *)"Window size too small for window list page");
      }
      }
#line 1172
      return;
    } else
#line 1169
    if (flayer->l_height < 5) {
      {
      {
#line 1171
      LMsg(0, (char *)"Window size too small for window list page");
      }
      }
#line 1172
      return;
    }
    {
#line 1174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1174
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1177
    p = (struct win *)(flayer->l_bottom)->l_data;
  }
  {
#line 1178
  __cil_tmp4 = InitOverlayPage((int )sizeof(*wlistdata), & WListLf, 0);
  }
#line 1178
  if (__cil_tmp4) {
#line 1179
    return;
  }
#line 1180
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1181
  flayer->l_x = 0;
#line 1182
  flayer->l_y = flayer->l_height - 1;
#line 1183
  if (onblank && p) {
#line 1183
    tmp = p->w_number;
  } else {
#line 1183
    tmp = - 1;
  }
#line 1183
  wlistdata->start = tmp;
#line 1184
  if (p) {
#line 1184
    tmp___298 = p->w_number;
  } else {
#line 1184
    tmp___298 = 0;
  }
  {
#line 1184
  wlistdata->pos = tmp___298;
#line 1185
  wlistdata->ypos = 0;
#line 1186
  wlistdata->numwin = flayer->l_height - 3;
#line 1187
  wlistpage();
  }
}
}
#line 1191 "/tmp/screen-3.9.15/help.c"
static void wlistpage(void) 
{ 
  struct wlistdata *wlistdata ;
  char *str ;
  int pos ;
  size_t __cil_tmp5 ;

  {
  {
#line 1197
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1199
  LClearAll(flayer, 0);
  }
#line 1200
  if (wlistdata->start >= 0) {
#line 1200
    if (wtab[wlistdata->start] == (struct win *)0) {
#line 1201
      wlistdata->start = - 2;
    }
  }
#line 1203
  pos = wlistdata->pos;
#line 1204
  if (wtab[pos] == (struct win *)0) {
    {
#line 1207
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1207
      if (! (pos < 40)) {
#line 1207
        goto while_break;
      }
#line 1208
      if (wtab[pos]) {
#line 1209
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1210
    if (pos == 40) {
      {
#line 1211
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1211
        if (! (pos > 0)) {
#line 1211
          goto while_break___0;
        }
#line 1212
        if (wtab[pos]) {
#line 1213
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1215
  wlistdata->pos = pos;
#line 1217
  display = (struct display *)0;
#line 1218
  str = MakeWinMsgEv(wlisttit, (struct win *)0, '%', flayer->l_width, (struct event *)0,
                     0);
#line 1219
  __cil_tmp5 = strlen((char const   *)str);
#line 1219
  LPutWinMsg(flayer, str, (int )__cil_tmp5, & mchar_blank, 0, 0);
#line 1220
  WListNormalize();
#line 1221
  WListLines(wlistdata->numwin, - 1);
#line 1222
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 1226 "/tmp/screen-3.9.15/help.c"
static void WListUpdate(struct win *p ) 
{ 
  struct wlistdata *wlistdata ;
  int i ;
  int n ;
  int y ;

  {
#line 1232
  if (p == (struct win *)0) {
    {
#line 1234
    wlistpage();
    }
#line 1235
    return;
  }
#line 1237
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1238
  n = p->w_number;
#line 1239
  if (n < wlistdata->first) {
#line 1240
    return;
  } else
#line 1239
  if (n > wlistdata->last) {
#line 1240
    return;
  }
#line 1241
  i = wlistdata->first;
#line 1242
  y = 0;
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    if (! (y < wlistdata->numwin)) {
#line 1242
      goto while_break;
    }
    {
#line 1244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1244
      if (! (i < 40 && wtab[i] == (struct win *)0)) {
#line 1244
        goto while_break___0;
      }
#line 1245
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1246
    if (i == 40) {
#line 1247
      return;
    }
#line 1248
    if (i == n) {
#line 1249
      goto while_break;
    }
#line 1250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1242
  y ++;
#line 1252
  if (y == wlistdata->numwin) {
#line 1253
    return;
  }
  {
#line 1254
  WListLine(y, i, wlistdata->pos, 0);
#line 1255
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 1259 "/tmp/screen-3.9.15/help.c"
void WListUpdatecv(struct canvas *cv , struct win *p ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 1263
  if ((cv->c_layer)->l_layfn != & WListLf) {
#line 1264
    return;
  }
  {
#line 1265
  olddisplay = display;
#line 1265
  oldflayer = flayer;
#line 1265
  l = cv->c_layer;
#line 1265
  cvlist = l->l_cvlist;
#line 1265
  cvlnext = cv->c_lnext;
#line 1265
  flayer = l;
#line 1265
  l->l_cvlist = cv;
#line 1265
  cv->c_lnext = (struct canvas *)0;
#line 1265
  WListUpdate(p);
#line 1265
  flayer = oldflayer;
#line 1265
  l->l_cvlist = cvlist;
#line 1265
  cv->c_lnext = cvlnext;
#line 1265
  display = olddisplay;
  }
}
}
#line 1269 "/tmp/screen-3.9.15/help.c"
int InWList(void) 
{ 


  {
#line 1271
  if (flayer) {
#line 1271
    if (flayer->l_layfn == & WListLf) {
#line 1272
      return (1);
    }
  }
#line 1273
  return (0);
}
}
#line 1290
static void BindkeyProcess(char **ppbuf , int *plen ) ;
#line 1291
static void BindkeyAbort(void) ;
#line 1292
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 1293
static void bindkeypage(void) ;
#line 1305 "/tmp/screen-3.9.15/help.c"
static struct LayFuncs BindkeyLf  =    {BindkeyProcess, BindkeyAbort, BindkeyRedisplayLine, DefClearLine, DefRewrite,
    DefResize, DefRestore};
#line 1318 "/tmp/screen-3.9.15/help.c"
void display_bindkey(char *title , struct action *tab ) 
{ 
  struct bindkeydata *bindkeydata ;
  int i ;
  int n ;
  int __cil_tmp6 ;

  {
#line 1325
  if (flayer->l_height < 6) {
    {
#line 1327
    LMsg(0, (char *)"Window height too small for bindkey page");
    }
#line 1328
    return;
  }
  {
#line 1330
  __cil_tmp6 = InitOverlayPage((int )sizeof(*bindkeydata), & BindkeyLf, 0);
  }
#line 1330
  if (__cil_tmp6) {
#line 1331
    return;
  }
#line 1333
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 1334
  bindkeydata->title = title;
#line 1335
  bindkeydata->tab = tab;
#line 1337
  n = 0;
#line 1338
  i = 0;
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! (i < 141)) {
#line 1338
      goto while_break;
    }
#line 1340
    if ((tab + i)->nr != -1) {
#line 1341
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  i ++;
#line 1343
  bindkeydata->pos = 0;
#line 1344
  bindkeydata->page = 1;
#line 1345
  bindkeydata->pages = ((n + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 1346
  if (bindkeydata->pages == 0) {
#line 1347
    bindkeydata->pages = 1;
  }
  {
#line 1348
  flayer->l_x = 0;
#line 1349
  flayer->l_y = flayer->l_height - 1;
#line 1350
  bindkeypage();
  }
}
}
#line 1354 "/tmp/screen-3.9.15/help.c"
static void BindkeyAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 1356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1356
    oldlay = flayer;
    {
#line 1356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1356
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1356
    flayer = flayer->l_next;
#line 1356
    oldcvlist = flayer->l_cvlist;
    {
#line 1356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1356
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1356
    flayer->l_cvlist = oldlay->l_cvlist;
#line 1356
    cv = flayer->l_cvlist;
    {
#line 1356
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1356
      if (! cv) {
#line 1356
        goto while_break___2;
      }
#line 1356
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1356
    cv = cv->c_lnext;
#line 1356
    LRefreshAll(flayer, 0);
#line 1356
    flayer = oldlay;
#line 1356
    cv = flayer->l_cvlist;
    }
    {
#line 1356
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1356
      if (! cv) {
#line 1356
        goto while_break___3;
      }
#line 1356
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1356
    cv = cv->c_lnext;
#line 1356
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 1356
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1357
  ExitOverlayPage();
  }
}
}
#line 1361 "/tmp/screen-3.9.15/help.c"
static void bindkeypage(void) 
{ 
  struct bindkeydata *bindkeydata ;
  char tbuf[256] ;
  int del ;
  int i ;
  int ch ;
  int y ;
  struct action *act ;
  char *xch ;
  char *s ;
  char *p ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  char *tmp ;

  {
  {
#line 1369
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 1371
  LClearAll(flayer, 0);
#line 1373
  sprintf((char *)tbuf, (char const   *)((char *)"%s key bindings, page %d of %d."),
          bindkeydata->title, bindkeydata->page, bindkeydata->pages);
#line 1374
  centerline((char *)tbuf, 0);
#line 1375
  y = 2;
#line 1376
  i = bindkeydata->pos;
  }
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! (i < 141 && y < flayer->l_height - 3)) {
#line 1376
      goto while_break;
    }
#line 1378
    p = (char *)tbuf;
#line 1379
    act = & *(bindkeydata->tab + i);
#line 1380
    if (act->nr == -1) {
#line 1381
      goto while_continue;
    }
#line 1382
    xch = (char *)"   ";
#line 1383
    if (i < 69) {
#line 1385
      __cil_tmp11 = p;
#line 1385
      p ++;
#line 1385
      *__cil_tmp11 = (char )':';
#line 1385
      del = (int )*__cil_tmp11;
#line 1386
      s = term[i + 106].tcname;
    } else
#line 1388
    if (i < 91) {
#line 1390
      __cil_tmp12 = p;
#line 1390
      p ++;
#line 1390
      *__cil_tmp12 = (char )':';
#line 1390
      del = (int )*__cil_tmp12;
#line 1391
      s = term[i + 84].tcname;
#line 1392
      xch = (char *)"[A]";
    } else {
#line 1396
      del = 0;
#line 1397
      s = kmap_extras[i - 91];
#line 1398
      if (kmap_extras_fl[i - 91]) {
#line 1399
        xch = (char *)"[T]";
      }
    }
    {
#line 1401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1401
      if (! ch) {
#line 1401
        goto while_break___0;
      }
      {
#line 1402
      __cil_tmp14 = AddXChar(p, ch);
      }
#line 1402
      p += __cil_tmp14;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1403
    if (del) {
#line 1404
      __cil_tmp15 = p;
#line 1404
      p ++;
#line 1404
      *__cil_tmp15 = (char )del;
    }
#line 1405
    __cil_tmp16 = p;
#line 1405
    p ++;
#line 1405
    *__cil_tmp16 = (char )' ';
    {
#line 1406
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1406
      if (! (p < (char *)tbuf + 15)) {
#line 1406
        goto while_break___1;
      }
#line 1407
      __cil_tmp17 = p;
#line 1407
      p ++;
#line 1407
      *__cil_tmp17 = (char )' ';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1408
    sprintf(p, (char const   *)((char *)"%s -> "), xch);
#line 1409
    p += 7;
    }
#line 1410
    if (p - (char *)tbuf > (long )(flayer->l_width - 1)) {
#line 1412
      tbuf[flayer->l_width - 2] = (char )'$';
#line 1413
      tbuf[flayer->l_width - 1] = (char )0;
    }
    {
#line 1415
    __cil_tmp18 = strlen((char const   *)((char *)tbuf));
#line 1415
    PadStr((char *)tbuf, (int )__cil_tmp18, 0, y);
#line 1416
    __cil_tmp19 = strlen((char const   *)((char *)tbuf));
#line 1416
    AddAction(act, (int )__cil_tmp19, y);
#line 1417
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1376
  i ++;
#line 1419
  y ++;
#line 1420
  bindkeydata->last = i;
#line 1421
  if (bindkeydata->page < bindkeydata->pages) {
#line 1421
    tmp = (char *)"for next page;";
  } else {
#line 1421
    tmp = (char *)"or";
  }
  {
#line 1421
  sprintf((char *)tbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp);
#line 1422
  centerline((char *)tbuf, flayer->l_height - 2);
#line 1423
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
}
}
#line 1427 "/tmp/screen-3.9.15/help.c"
static void BindkeyProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct bindkeydata *bindkeydata ;

  {
#line 1431
  done = 0;
#line 1434
  bindkeydata = (struct bindkeydata *)flayer->l_data;
  {
#line 1435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1435
    if (! (! done && *plen > 0)) {
#line 1435
      goto while_break;
    }
    {
#line 1439
    if ((int )*(*ppbuf) == ' ') {
#line 1439
      goto case_32;
    }
#line 1449
    if ((int )*(*ppbuf) == '\n') {
#line 1449
      goto case_10;
    }
#line 1449
    if ((int )*(*ppbuf) == '\r') {
#line 1449
      goto case_10;
    }
#line 1452
    goto switch_default;
    case_32: /* CIL Label */ 
#line 1440
    if (bindkeydata->page < bindkeydata->pages) {
      {
#line 1442
      bindkeydata->pos = bindkeydata->last;
#line 1443
      (bindkeydata->page) ++;
#line 1444
      bindkeypage();
      }
#line 1445
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 1450
    done = 1;
#line 1451
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1453
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1455
    (*ppbuf) ++;
#line 1456
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1458
  if (done) {
    {
#line 1459
    BindkeyAbort();
    }
  }
}
}
#line 1463 "/tmp/screen-3.9.15/help.c"
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 1466
  if (y < 0) {
    {
#line 1468
    bindkeypage();
    }
#line 1469
    return;
  }
#line 1471
  if (y != 0) {
#line 1471
    if (y != flayer->l_height - 1) {
#line 1472
      return;
    }
  }
#line 1473
  if (! isblank) {
    {
#line 1474
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
}
}
#line 1483 "/tmp/screen-3.9.15/help.c"
static void PadStr(char *str , int n , int x , int y ) 
{ 
  int l ;
  size_t __cil_tmp6 ;

  {
  {
#line 1489
  __cil_tmp6 = strlen((char const   *)str);
#line 1489
  l = (int )__cil_tmp6;
  }
#line 1490
  if (l > n) {
#line 1491
    l = n;
  }
  {
#line 1492
  LPutStr(flayer, str, l, & mchar_blank, x, y);
  }
#line 1493
  if (l < n) {
    {
#line 1494
    LPutStr(flayer, blank, n - l, & mchar_blank, x + l, y);
    }
  }
}
}
#line 564 "/usr/include/stdio.h"
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 165 "./extern.h"
void InitLoadav(void) ;
#line 166
void AddLoadav(char *p ) ;
#line 50 "/tmp/screen-3.9.15/loadav.c"
static int GetLoadav(void) ;
#line 52
static double loadav[3] ;
#line 53
static int loadok ;
#line 66 "/tmp/screen-3.9.15/loadav.c"
void InitLoadav(void) 
{ 


  {
#line 68
  loadok = 1;
}
}
#line 72 "/tmp/screen-3.9.15/loadav.c"
static int GetLoadav(void) 
{ 
  FILE *fp ;
  char buf[128] ;
  char *s ;
  int i ;
  double d ;
  double e ;
  int tmp ;
  double tmp___299 ;

  {
  {
#line 79
  fp = secfopen((char *)"/proc/loadavg", (char *)"r");
  }
#line 79
  if (fp == (FILE *)((void *)0)) {
#line 80
    return (0);
  }
  {
#line 81
  *((char *)buf) = (char )0;
#line 82
  fgets((char *)buf, (int )sizeof(buf), fp);
#line 83
  fclose(fp);
#line 87
  s = (char *)buf;
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < tmp)) {
#line 88
      goto while_break;
    }
#line 90
    e = (double )0;
#line 90
    d = e;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! ((int )*s == 32)) {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 93
    if ((int )*s == 0) {
#line 94
      goto while_break;
    }
    {
#line 95
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 95
      if (! 1) {
#line 95
        goto while_break___1;
      }
#line 97
      if ((int )*s == 46) {
#line 98
        e = (double )1;
      } else
#line 99
      if ((int )*s >= 48) {
#line 99
        if ((int )*s <= 57) {
#line 101
          d = d * (double )10 + (double )((int )*s - 48);
#line 102
          if (e) {
#line 103
            e *= (double )10;
          }
        } else {
#line 106
          goto while_break___1;
        }
      } else {
#line 106
        goto while_break___1;
      }
#line 107
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    if (e) {
#line 109
      tmp___299 = d / e;
    } else {
#line 109
      tmp___299 = d;
    }
#line 109
    loadav[i] = tmp___299;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  i ++;
#line 111
  return (i);
}
}
#line 340 "/tmp/screen-3.9.15/loadav.c"
void AddLoadav(char *p ) 
{ 
  int i ;
  int j ;
  size_t __cil_tmp5 ;

  {
#line 344
  if (loadok == 0) {
#line 345
    return;
  }
  {
#line 346
  j = GetLoadav();
#line 347
  i = 0;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < j)) {
#line 347
      goto while_break;
    }
    {
#line 349
    sprintf(p, (char const   *)((char *)" %2.2f" + ! i), loadav[i] / (double )1);
#line 350
    __cil_tmp5 = strlen((char const   *)p);
    }
#line 350
    p += __cil_tmp5;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  i ++;
}
}
#line 773 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 65 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void setutent(void) ;
#line 76
extern  __attribute__((__nothrow__)) struct utmp *getutline(struct utmp * ) ;
#line 79
extern  __attribute__((__nothrow__)) struct utmp *pututline(struct utmp *__utmp_ptr ) ;
#line 146 "./extern.h"
void InitUtmp(void) ;
#line 147
void RemoveLoginSlot(void) ;
#line 148
void RestoreLoginSlot(void) ;
#line 337
char *stripdev(char *nam ) ;
#line 85 "/tmp/screen-3.9.15/utmp.c"
static slot_t TtyNameSlot(char *nam ) ;
#line 86
static void makeuser(struct utmp *u , char *line , char *user , int pid ) ;
#line 87
static void makedead(struct utmp *u ) ;
#line 88
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) ;
#line 89
static struct utmp *getutslot(slot_t slot ) ;
#line 97
struct utmp *xpututline(struct utmp *u ) ;
#line 102
static int utmpok ;
#line 103 "/tmp/screen-3.9.15/utmp.c"
static char UtmpName[]  =    "/var/run/utmp";
#line 105 "/tmp/screen-3.9.15/utmp.c"
static int utmpfd  =    - 1;
#line 176 "/tmp/screen-3.9.15/utmp.c"
void SlotToggle(int how ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  if (fore->w_type != 0) {
    {
#line 182
    Msg(0, (char *)"Can only work with normal windows.\n");
    }
#line 183
    return;
  }
#line 185
  if (how) {
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    if (fore->w_slot == (slot_t )-1) {
      _L: /* CIL Label */ 
      {
#line 197
      __cil_tmp2 = SetUtmp(fore);
      }
#line 197
      if (__cil_tmp2 == 0) {
        {
#line 198
        Msg(0, (char *)"This window is now logged in.");
        }
      } else {
        {
#line 200
        Msg(0, (char *)"This window should now be logged in.");
        }
      }
      {
#line 201
      WindowChanged(fore, 'f');
      }
    } else
#line 188
    if (fore->w_slot == (slot_t )0) {
#line 188
      goto _L;
    } else {
      {
#line 204
      Msg(0, (char *)"This window is already logged in.");
      }
    }
  } else {
    {
#line 208
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 208
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 209
    if (fore->w_slot == (slot_t )-1) {
      {
#line 210
      Msg(0, (char *)"This window is already logged out\n");
      }
    } else
#line 211
    if (fore->w_slot == (slot_t )0) {
      {
#line 213
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 213
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 214
      Msg(0, (char *)"This window is not logged in.");
#line 215
      fore->w_slot = (slot_t )(- 1);
      }
    } else {
      {
#line 219
      RemoveUtmp(fore);
      }
#line 220
      if (fore->w_slot != (slot_t )-1) {
        {
#line 221
        Msg(0, (char *)"What? Cannot remove Utmp slot?");
        }
      } else {
        {
#line 223
        Msg(0, (char *)"This window is no longer logged in.");
        }
      }
      {
#line 227
      WindowChanged(fore, 'f');
      }
    }
  }
}
}
#line 263 "/tmp/screen-3.9.15/utmp.c"
void InitUtmp(void) 
{ 
  int *__cil_tmp2 ;
  int *__cil_tmp3 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  utmpfd = open((char const   *)((char *)UtmpName), 2);
  }
#line 267
  if (utmpfd == -1) {
    {
#line 269
    __cil_tmp2 = __errno_location();
    }
#line 269
    if (*__cil_tmp2 != 13) {
      {
#line 270
      __cil_tmp3 = __errno_location();
#line 270
      Msg(*__cil_tmp3, (char *)UtmpName);
      }
    }
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 271
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 272
    utmpok = 0;
#line 273
    return;
  }
  {
#line 276
  close(utmpfd);
#line 277
  utmpfd = - 1;
#line 280
  utmpok = 1;
  }
}
}
#line 311 "/tmp/screen-3.9.15/utmp.c"
void RemoveLoginSlot(void) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  int __cil_tmp5 ;
  struct stat stb ;
  char *tty ;
  int __cil_tmp9 ;

  {
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 316
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  display->d_loginslot = TtyNameSlot((char *)display->d_usertty);
  }
#line 318
  if (display->d_loginslot == (slot_t )0) {
#line 319
    return;
  } else
#line 318
  if (display->d_loginslot == (slot_t )-1) {
#line 319
    return;
  }
#line 323
  if (! utmpok) {
#line 326
    display->d_loginslot = (slot_t )0;
    {
#line 327
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 327
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 340
    uu = getutslot(display->d_loginslot);
    }
#line 340
    if (uu == (struct utmp *)0) {
      {
#line 342
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 342
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 343
      display->d_loginslot = (slot_t )0;
    } else {
      {
#line 347
      display->d_utmp_logintty = *uu;
#line 348
      u = *uu;
#line 349
      makedead(& u);
#line 350
      __cil_tmp5 = pututslot(display->d_loginslot, & u, (char *)0, (struct win *)0);
      }
#line 350
      if (__cil_tmp5 == 0) {
#line 351
        display->d_loginslot = (slot_t )0;
      }
    }

  }
  {
#line 355
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 355
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 356
  if (display->d_loginslot == (slot_t )0) {
    {
#line 361
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 361
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 362
    display->d_loginttymode = 0;
#line 363
    __cil_tmp9 = stat((char const   *)tty, & stb);
    }
    {
#line 363
    tty = ttyname(display->d_userfd);
    }
#line 363
    if (tty) {
#line 363
      if (__cil_tmp9 == 0) {
#line 363
        if (stb.st_uid == (unsigned int )real_uid) {
#line 363
          if (((int )stb.st_mode & 511) != 438) {
            {
#line 365
            display->d_loginttymode = (int )stb.st_mode & 511;
#line 366
            chmod((char const   *)((char *)display->d_usertty), stb.st_mode & 384U);
            }
          }
        }
      }
    }
  }
}
}
#line 375 "/tmp/screen-3.9.15/utmp.c"
void RestoreLoginSlot(void) 
{ 
  char *tty ;
  int __cil_tmp2 ;
  int *__cil_tmp3 ;

  {
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 381
  if (utmpok) {
#line 381
    if (display->d_loginslot != (slot_t )0) {
#line 381
      if (display->d_loginslot != (slot_t )-1) {
        {
#line 383
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 383
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 384
        __cil_tmp2 = pututslot(display->d_loginslot, & display->d_utmp_logintty, (char *)display->d_utmp_logintty.ut_host,
                               (struct win *)0);
        }
#line 384
        if (__cil_tmp2 == 0) {
          {
#line 385
          __cil_tmp3 = __errno_location();
#line 385
          Msg(*__cil_tmp3, (char *)"Could not write %s", (char *)UtmpName);
          }
        }
      }
    }
  }
  {
#line 388
  display->d_loginslot = (slot_t )0;
#line 389
  tty = ttyname(display->d_userfd);
  }
#line 389
  if (display->d_loginttymode) {
#line 389
    if (tty) {
      {
#line 390
      chmod((char const   *)tty, (__mode_t )display->d_loginttymode);
      }
    }
  }
}
}
#line 405 "/tmp/screen-3.9.15/utmp.c"
int SetUtmp(struct win *wi ) 
{ 
  register slot_t slot ;
  struct utmp u ;
  int saved_ut ;
  char *p ;
  char host[271] ;
  char *__cil_tmp9 ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;

  {
#line 418
  wi->w_slot = (slot_t )0;
#line 419
  if (! utmpok) {
#line 420
    return (- 1);
  } else
#line 419
  if (wi->w_type != 0) {
#line 420
    return (- 1);
  }
  {
#line 421
  slot = TtyNameSlot((char *)wi->w_tty);
  }
#line 421
  if (slot == (slot_t )0) {
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 424
    return (- 1);
  }
  {
#line 426
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 426
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 428
  bzero((void *)((char *)(& u)), sizeof(u));
#line 429
  saved_ut = bcmp((void const   *)((char *)(& wi->w_savut)), (void const   *)((char *)(& u)),
                  sizeof(u));
  }
#line 429
  if (saved_ut) {
    {
#line 431
    bcopy((void const   *)((char *)(& wi->w_savut)), (void *)((char *)(& u)), sizeof(u));
    }
  }
#line 433
  if (! saved_ut) {
    {
#line 434
    __cil_tmp9 = stripdev((char *)wi->w_tty);
#line 434
    makeuser(& u, __cil_tmp9, LoginName, wi->w_pid);
    }
  }
#line 437
  host[sizeof(host) - 15UL] = (char )'\000';
#line 438
  if (display) {
    {
#line 440
    strncpy((char *)host, (char const   *)((char *)display->d_utmp_logintty.ut_host),
            sizeof(host) - 15UL);
    }
#line 441
    if (display->d_loginslot != (slot_t )0) {
#line 441
      if (display->d_loginslot != (slot_t )-1) {
#line 441
        if ((int )host[0] != 0) {
#line 451
          p = (char *)host;
          {
#line 451
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 451
            if (! *p) {
#line 451
              goto while_break___1;
            }
#line 452
            if ((int )*p < 48) {
              _L: /* CIL Label */ 
#line 452
              if ((int )*p != 46) {
#line 453
                goto while_break___1;
              }
            } else
#line 452
            if ((int )*p > 57) {
#line 452
              goto _L;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 451
          p ++;
#line 454
          if (*p) {
#line 456
            p = (char *)host;
            {
#line 456
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 456
              if (! *p) {
#line 456
                goto while_break___2;
              }
#line 457
              if ((int )*p == 46) {
#line 459
                *p = (char )'\000';
#line 460
                goto while_break___2;
              } else
#line 457
              if ((int )*p == 58) {
#line 457
                if (p != (char *)host) {
#line 459
                  *p = (char )'\000';
#line 460
                  goto while_break___2;
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 456
            p ++;
          }
        } else {
          {
          {
          {
#line 466
          __cil_tmp12 = stripdev((char *)display->d_usertty);
          }
          }
          {
          {
#line 466
          strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
          }
          }
#line 467
          host[0] = (char )':';
          }
        }
      } else {
        {
        {
        {
#line 466
        __cil_tmp12 = stripdev((char *)display->d_usertty);
        }
        }
        {
        {
#line 466
        strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
        }
        }
#line 467
        host[0] = (char )':';
        }
      }
    } else {
      {
      {
      {
#line 466
      __cil_tmp12 = stripdev((char *)display->d_usertty);
      }
      }
      {
      {
#line 466
      strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
      }
      }
#line 467
      host[0] = (char )':';
      }
    }
  } else {
    {
#line 471
    strncpy((char *)host, (char const   *)((char *)"local"), sizeof(host) - 15UL);
    }
  }
  {
#line 473
  __cil_tmp13 = strlen((char const   *)((char *)host));
#line 473
  sprintf((char *)host + __cil_tmp13, (char const   *)((char *)":S.%d"), wi->w_number);
  }
  {
#line 474
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 474
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 477
  strncpy((char *)u.ut_host, (char const   *)((char *)host), sizeof(u.ut_host));
#line 481
  __cil_tmp14 = pututslot(slot, & u, (char *)host, wi);
  }
#line 481
  if (__cil_tmp14 == 0) {
    {
#line 483
    __cil_tmp15 = __errno_location();
#line 483
    Msg(*__cil_tmp15, (char *)"Could not write %s", (char *)UtmpName);
    }
#line 485
    return (- 1);
  }
  {
#line 487
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 487
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 488
  wi->w_slot = slot;
#line 489
  bcopy((void const   *)((char *)(& u)), (void *)((char *)(& wi->w_savut)), sizeof(u));
  }
#line 491
  return (0);
}
}
#line 500 "/tmp/screen-3.9.15/utmp.c"
int RemoveUtmp(struct win *wi ) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  slot_t slot ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
#line 506
  slot = wi->w_slot;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  if (! utmpok) {
#line 509
    return (- 1);
  }
#line 510
  if (slot == (slot_t )0) {
#line 512
    wi->w_slot = (slot_t )(- 1);
#line 513
    return (0);
  } else
#line 510
  if (slot == (slot_t )-1) {
#line 512
    wi->w_slot = (slot_t )(- 1);
#line 513
    return (0);
  }
  {
#line 515
  bzero((void *)((char *)(& u)), sizeof(u));
#line 520
  uu = getutslot(slot);
  }
#line 520
  if (uu == (struct utmp *)0) {
    {
#line 522
    Msg(0, (char *)"Utmp slot not found -> not removed");
    }
#line 523
    return (- 1);
  }
  {
#line 525
  bcopy((void const   *)((char *)uu), (void *)((char *)(& wi->w_savut)), sizeof(wi->w_savut));
#line 527
  u = *uu;
#line 528
  makedead(& u);
#line 529
  __cil_tmp6 = pututslot(slot, & u, (char *)0, wi);
  }
#line 529
  if (__cil_tmp6 == 0) {
    {
#line 531
    __cil_tmp7 = __errno_location();
#line 531
    Msg(*__cil_tmp7, (char *)"Could not write %s", (char *)UtmpName);
    }
#line 533
    return (- 1);
  }
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 535
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  wi->w_slot = (slot_t )(- 1);
#line 538
  return (0);
}
}
#line 553 "/tmp/screen-3.9.15/utmp.c"
static struct utmp *getutslot(slot_t slot ) 
{ 
  struct utmp u ;
  struct utmp *__cil_tmp3 ;

  {
  {
#line 557
  bzero((void *)((char *)(& u)), sizeof(u));
#line 558
  strncpy((char *)u.ut_line, (char const   *)slot, sizeof(u.ut_line));
#line 559
  setutent();
#line 560
  __cil_tmp3 = getutline(& u);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564 "/tmp/screen-3.9.15/utmp.c"
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) 
{ 
  struct utmp *__cil_tmp5 ;

  {
  {
#line 587
  setutent();
#line 588
  __cil_tmp5 = xpututline(u);
  }
#line 588
  return (__cil_tmp5 != (struct utmp *)0);
}
}
#line 592 "/tmp/screen-3.9.15/utmp.c"
static void makedead(struct utmp *u ) 
{ 


  {
#line 595
  u->ut_type = (short )8;
#line 597
  u->ut_exit.e_termination = (short )0;
#line 598
  u->ut_exit.e_exit = (short )0;
#line 601
  u->ut_user[0] = (char )0;
}
}
#line 606 "/tmp/screen-3.9.15/utmp.c"
static void makeuser(struct utmp *u , char *line , char *user , int pid ) 
{ 
  time_t __cil_tmp5 ;

  {
  {
#line 611
  u->ut_type = (short )7;
#line 612
  strncpy((char *)u->ut_user, (char const   *)user, sizeof(u->ut_user));
#line 615
  strncpy((char *)u->ut_id, (char const   *)(line + 3), sizeof(u->ut_id));
#line 623
  strncpy((char *)u->ut_line, (char const   *)line, sizeof(u->ut_line));
#line 624
  u->ut_pid = pid;
#line 625
  __cil_tmp5 = time((time_t *)(& u->ut_tv.tv_sec));
  }
}
}
#line 629 "/tmp/screen-3.9.15/utmp.c"
static slot_t TtyNameSlot(char *nam ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = stripdev(nam);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 870 "/tmp/screen-3.9.15/utmp.c"
struct utmp *xpututline(struct utmp *u ) 
{ 
  struct utmp *u2 ;
  struct utmp *tmp ;
  struct utmp *tmp___300 ;

  {
  {
#line 874
  pututline(u);
#line 875
  setutent();
#line 876
  u2 = getutline(u);
  }
#line 877
  if (u2 == (struct utmp *)0) {
#line 878
    if ((int )u->ut_type == 8) {
#line 878
      tmp = u;
    } else {
#line 878
      tmp = (struct utmp *)0;
    }
#line 878
    return (tmp);
  }
#line 879
  if ((int )u->ut_type == (int )u2->ut_type) {
#line 879
    tmp___300 = u;
  } else {
#line 879
    tmp___300 = (struct utmp *)0;
  }
#line 879
  return (tmp___300);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 554
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 50 "./extern.h"
void WindowDied(struct win *p ) ;
#line 55
void ResetWindow(struct win *p ) ;
#line 61
void WNewAutoFlow(struct win *win , int on ) ;
#line 82
int OpenTTY(char *line , char *opt ) ;
#line 83
void InitTTY(struct mode *m , int ttyflag ) ;
#line 94
int fgtty(int fd ) ;
#line 95
void brktty(int fd ) ;
#line 131
int RemakeWindow(struct win *p ) ;
#line 137
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) ;
#line 141
void CloseDevice(struct win *wp ) ;
#line 52 "/tmp/screen-3.9.15/window.c"
char **NewEnv ;
#line 54
struct event logflushev ;
#line 62
struct winsize glwz ;
#line 69
static void WinProcess(char **bufpp , int *lenp ) ;
#line 70
static void WinRedisplayLine(int y , int from , int to , int isblank ) ;
#line 71
static void WinClearLine(int y , int xs , int xe , int bce ) ;
#line 72
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) ;
#line 73
static int WinResize(int wi , int he ) ;
#line 74
static void WinRestore(void) ;
#line 75
static int DoAutolf(char *buf , int *lenp , int fr ) ;
#line 76
static void ZombieProcess(char **bufpp , int *lenp ) ;
#line 77
static void win_readev_fn(struct event *ev , char *data ) ;
#line 78
static void win_writeev_fn(struct event *ev , char *data ) ;
#line 79
static int muchpending(struct win *p , struct event *ev ) ;
#line 81
static void paste_slowev_fn(struct event *ev , char *data ) ;
#line 84
static void pseu_readev_fn(struct event *ev , char *data ) ;
#line 85
static void pseu_writeev_fn(struct event *ev , char *data ) ;
#line 87
static void win_silenceev_fn(struct event *ev , char *data ) ;
#line 89
static int OpenDevice(char **args , int lflag , int *typep , char **namep ) ;
#line 90
static int ForkWindow(struct win *win , char **args , char *ttyn ) ;
#line 91
static void execvpe(char *prog , char **args , char **env ) ;
#line 94 "/tmp/screen-3.9.15/window.c"
int VerboseCreate  =    0;
#line 96 "/tmp/screen-3.9.15/window.c"
char DefaultShell[]  =    "/bin/sh";
#line 97 "/tmp/screen-3.9.15/window.c"
static char DefaultPath[]  =    ":/usr/ucb:/bin:/usr/bin";
#line 100 "/tmp/screen-3.9.15/window.c"
struct NewWindow nwin_undef  = 
#line 100
     {- 1, (char *)0, (char **)0, (char *)0, (char *)0, - 1, - 1, - 1, - 1, - 1, - 1,
    - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, (char *)0, (char *)0};
#line 125 "/tmp/screen-3.9.15/window.c"
struct NewWindow nwin_default  = 
#line 125
     {0, (char *)0, (char **)ShellArgs, (char *)0, (char *)screenterm, 0, 1, 1, 100,
    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, (char *)0, (char *)0};
#line 152 "/tmp/screen-3.9.15/window.c"
static int const_IOSIZE  =    4096;
#line 153 "/tmp/screen-3.9.15/window.c"
static int const_one  =    1;
#line 156 "/tmp/screen-3.9.15/window.c"
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) 
{ 
  int tmp ;
  char *tmp___301 ;
  char **tmp___302 ;
  char *tmp___303 ;
  char *tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___311 ;
  int tmp___312 ;
  int tmp___313 ;
  int tmp___314 ;
  int tmp___315 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  char *tmp___319 ;
  char *tmp___320 ;

  {
#line 160
  if (new->StartAt != nwin_undef.StartAt) {
#line 160
    tmp = new->StartAt;
  } else {
#line 160
    tmp = def->StartAt;
  }
#line 160
  res->StartAt = tmp;
#line 161
  if (new->aka != nwin_undef.aka) {
#line 161
    tmp___301 = new->aka;
  } else {
#line 161
    tmp___301 = def->aka;
  }
#line 161
  res->aka = tmp___301;
#line 162
  if (new->args != nwin_undef.args) {
#line 162
    tmp___302 = new->args;
  } else {
#line 162
    tmp___302 = def->args;
  }
#line 162
  res->args = tmp___302;
#line 163
  if (new->dir != nwin_undef.dir) {
#line 163
    tmp___303 = new->dir;
  } else {
#line 163
    tmp___303 = def->dir;
  }
#line 163
  res->dir = tmp___303;
#line 164
  if (new->term != nwin_undef.term) {
#line 164
    tmp___304 = new->term;
  } else {
#line 164
    tmp___304 = def->term;
  }
#line 164
  res->term = tmp___304;
#line 165
  if (new->aflag != nwin_undef.aflag) {
#line 165
    tmp___305 = new->aflag;
  } else {
#line 165
    tmp___305 = def->aflag;
  }
#line 165
  res->aflag = tmp___305;
#line 166
  if (new->flowflag != nwin_undef.flowflag) {
#line 166
    tmp___306 = new->flowflag;
  } else {
#line 166
    tmp___306 = def->flowflag;
  }
#line 166
  res->flowflag = tmp___306;
#line 167
  if (new->lflag != nwin_undef.lflag) {
#line 167
    tmp___307 = new->lflag;
  } else {
#line 167
    tmp___307 = def->lflag;
  }
#line 167
  res->lflag = tmp___307;
#line 168
  if (new->histheight != nwin_undef.histheight) {
#line 168
    tmp___308 = new->histheight;
  } else {
#line 168
    tmp___308 = def->histheight;
  }
#line 168
  res->histheight = tmp___308;
#line 169
  if (new->monitor != nwin_undef.monitor) {
#line 169
    tmp___309 = new->monitor;
  } else {
#line 169
    tmp___309 = def->monitor;
  }
#line 169
  res->monitor = tmp___309;
#line 170
  if (new->wlock != nwin_undef.wlock) {
#line 170
    tmp___310 = new->wlock;
  } else {
#line 170
    tmp___310 = def->wlock;
  }
#line 170
  res->wlock = tmp___310;
#line 171
  if (new->silence != nwin_undef.silence) {
#line 171
    tmp___311 = new->silence;
  } else {
#line 171
    tmp___311 = def->silence;
  }
#line 171
  res->silence = tmp___311;
#line 172
  if (new->wrap != nwin_undef.wrap) {
#line 172
    tmp___312 = new->wrap;
  } else {
#line 172
    tmp___312 = def->wrap;
  }
#line 172
  res->wrap = tmp___312;
#line 173
  if (new->Lflag != nwin_undef.Lflag) {
#line 173
    tmp___313 = new->Lflag;
  } else {
#line 173
    tmp___313 = def->Lflag;
  }
#line 173
  res->Lflag = tmp___313;
#line 174
  if (new->slow != nwin_undef.slow) {
#line 174
    tmp___314 = new->slow;
  } else {
#line 174
    tmp___314 = def->slow;
  }
#line 174
  res->slow = tmp___314;
#line 175
  if (new->gr != nwin_undef.gr) {
#line 175
    tmp___315 = new->gr;
  } else {
#line 175
    tmp___315 = def->gr;
  }
#line 175
  res->gr = tmp___315;
#line 176
  if (new->c1 != nwin_undef.c1) {
#line 176
    tmp___316 = new->c1;
  } else {
#line 176
    tmp___316 = def->c1;
  }
#line 176
  res->c1 = tmp___316;
#line 177
  if (new->bce != nwin_undef.bce) {
#line 177
    tmp___317 = new->bce;
  } else {
#line 177
    tmp___317 = def->bce;
  }
#line 177
  res->bce = tmp___317;
#line 178
  if (new->encoding != nwin_undef.encoding) {
#line 178
    tmp___318 = new->encoding;
  } else {
#line 178
    tmp___318 = def->encoding;
  }
#line 178
  res->encoding = tmp___318;
#line 179
  if (new->hstatus != nwin_undef.hstatus) {
#line 179
    tmp___319 = new->hstatus;
  } else {
#line 179
    tmp___319 = def->hstatus;
  }
#line 179
  res->hstatus = tmp___319;
#line 180
  if (new->charset != nwin_undef.charset) {
#line 180
    tmp___320 = new->charset;
  } else {
#line 180
    tmp___320 = def->charset;
  }
#line 180
  res->charset = tmp___320;
}
}
#line 189 "/tmp/screen-3.9.15/window.c"
struct LayFuncs WinLf  =    {WinProcess, (void (*)(void))0, WinRedisplayLine, WinClearLine, WinRewrite, WinResize,
    WinRestore};
#line 201 "/tmp/screen-3.9.15/window.c"
static int DoAutolf(char *buf , int *lenp , int fr ) 
{ 
  char *p ;
  int len ;
  int trunc ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 207
  len = *lenp;
#line 208
  trunc = 0;
#line 210
  p = buf;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (len > 0)) {
#line 210
      goto while_break;
    }
#line 212
    if ((int )*p != 13) {
#line 213
      goto while_continue;
    }
#line 214
    __cil_tmp7 = fr;
#line 214
    fr --;
#line 214
    if (__cil_tmp7 <= 0) {
#line 216
      trunc ++;
#line 217
      __cil_tmp9 = len;
#line 217
      len --;
    }
#line 219
    if (len == 0) {
#line 220
      goto while_break;
    }
    {
#line 221
    __cil_tmp10 = len;
#line 221
    len ++;
#line 221
    bcopy((void const   *)p, (void *)(p + 1), (size_t )__cil_tmp10);
#line 222
    *(p + 1) = (char )'\n';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  __cil_tmp12 = len;
#line 210
  len --;
#line 210
  __cil_tmp11 = p;
#line 210
  p ++;
#line 224
  *lenp = (int )(p - buf);
#line 225
  return (trunc);
}
}
#line 229 "/tmp/screen-3.9.15/window.c"
static void WinProcess(char **bufpp , int *lenp ) 
{ 
  int l2 ;
  int f ;
  int *ilen ;
  int l ;
  int trunc ;
  char *ibuf ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 233
  l2 = 0;
#line 233
  l = *lenp;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  fore = (struct win *)flayer->l_data;
#line 239
  if (fore->w_ptyfd < 0) {
    {
#line 241
    ZombieProcess(bufpp, lenp);
    }
#line 242
    return;
  }
  {
#line 249
  __cil_tmp9 = AclCheckPermWin(display->d_user, 1, fore);
  }
#line 249
  if (display) {
#line 249
    if (fore->w_wlock == 1) {
#line 249
      if (! fore->w_wlockuser) {
#line 249
        if (! __cil_tmp9) {
#line 252
          fore->w_wlockuser = display->d_user;
          {
#line 253
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 253
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 257
  if (fore->w_wlock == 0) {
    {
#line 257
    __cil_tmp10 = AclCheckPermWin(display->d_user, 1, fore);
#line 257
    tmp = __cil_tmp10;
    }
  } else {
#line 257
    tmp = display->d_user != fore->w_wlockuser;
  }
#line 257
  if (display) {
#line 257
    if (tmp) {
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 262
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 262
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 265
      WBell(fore, visual_bell);
#line 266
      *bufpp += *lenp;
#line 267
      *lenp = 0;
      }
#line 268
      return;
    }
  }
#line 281
  if (fore->w_pwin) {
#line 281
    if ((fore->w_pwin)->p_fdpat & 4096) {
#line 284
      ibuf = (char *)(fore->w_pwin)->p_inbuf;
#line 284
      ilen = & (fore->w_pwin)->p_inlen;
#line 285
      f = (int )(sizeof((fore->w_pwin)->p_inbuf) - (unsigned long )*ilen);
    } else {
#line 291
      ibuf = (char *)fore->w_inbuf;
#line 291
      ilen = & fore->w_inlen;
#line 292
      f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
    }
  } else {
#line 291
    ibuf = (char *)fore->w_inbuf;
#line 291
    ilen = & fore->w_inlen;
#line 292
    f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
  }
#line 295
  if (l > f) {
#line 296
    l = f;
  }
#line 300
  if (l > 0) {
    {
#line 303
    l2 = l;
#line 304
    bcopy((void const   *)*bufpp, (void *)(ibuf + *ilen), (size_t )l2);
#line 305
    trunc = DoAutolf(ibuf + *ilen, & l2, f - l2);
    }
#line 305
    if (fore->w_autolf) {
#line 305
      if (trunc) {
#line 306
        l -= trunc;
      }
    }
#line 315
    *ilen += l2;
#line 316
    *bufpp += l;
#line 317
    *lenp -= l;
#line 318
    return;
  }
}
}
#line 323 "/tmp/screen-3.9.15/window.c"
static void ZombieProcess(char **bufpp , int *lenp ) 
{ 
  int l ;
  char *buf ;
  char b1[10] ;
  char b2[10] ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 327
  l = *lenp;
#line 328
  buf = *bufpp;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  fore = (struct win *)flayer->l_data;
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 334
  *bufpp += *lenp;
#line 335
  *lenp = 0;
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 336
    if (! (__cil_tmp7 > 0)) {
#line 336
      goto while_break___1;
    }
#line 338
    if ((int )*((unsigned char *)buf) == ZombieKey_destroy) {
      {
#line 340
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 340
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 341
      KillWindow(fore);
      }
#line 342
      return;
    }
#line 344
    if ((int )*((unsigned char *)buf) == ZombieKey_resurrect) {
      {
#line 346
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 346
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 347
      WriteString(fore, (char *)"\r\n", 2);
#line 348
      RemakeWindow(fore);
      }
#line 349
      return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 336
  buf ++;
#line 352
  __cil_tmp9 = AddXChar((char *)b1, ZombieKey_destroy);
#line 352
  b1[__cil_tmp9] = (char )'\000';
#line 353
  __cil_tmp10 = AddXChar((char *)b2, ZombieKey_resurrect);
#line 353
  b2[__cil_tmp10] = (char )'\000';
#line 354
  Msg(0, (char *)"Press %s to destroy or %s to resurrect window", (char *)b1, (char *)b2);
  }
}
}
#line 358 "/tmp/screen-3.9.15/window.c"
static void WinRedisplayLine(int y , int from , int to , int isblank ) 
{ 


  {
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if (y < 0) {
#line 363
    return;
  }
#line 364
  fore = (struct win *)flayer->l_data;
#line 365
  if (from == 0) {
#line 365
    if (y > 0) {
#line 365
      if ((int )*((fore->w_mlines + (y - 1))->image + fore->w_layer.l_width) == 0) {
        {
#line 366
        LCDisplayLineWrap(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
        }
      } else {
        {
        {
        {
#line 368
        LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 368
      LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 368
    LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
    }
    }
    }
  }
}
}
#line 372 "/tmp/screen-3.9.15/window.c"
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) 
{ 
  register int cost ;
  register int dx ;
  register unsigned char *p ;
  register unsigned char *i ;
  register unsigned char *f ;
  register unsigned char *c ;
  int __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;

  {
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  fore = (struct win *)flayer->l_data;
#line 390
  dx = (x2 - x1) + 1;
#line 391
  if (doit) {
#line 393
    i = (fore->w_mlines + y)->image + x1;
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 394
      if (! (__cil_tmp12 > 0)) {
#line 394
        goto while_break___0;
      }
      {
#line 395
      __cil_tmp13 = i;
#line 395
      i ++;
#line 395
      PUTCHAR((int )*__cil_tmp13);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 396
    return (0);
  }
#line 398
  p = (fore->w_mlines + y)->attr + x1;
#line 400
  f = (fore->w_mlines + y)->font + x1;
#line 402
  if ((int )rend->font) {
#line 402
    if (((int )rend->font & 96) == 0) {
#line 403
      return (1000);
    }
  }
  {
#line 406
  __cil_tmp14 = ContainsSpecialDeffont(fore->w_mlines + y, x1, x2, fore->w_layer.l_encoding);
  }
#line 406
  if (fore->w_layer.l_encoding) {
#line 406
    if (fore->w_layer.l_encoding != 8) {
#line 406
      if (display->d_encoding == 8) {
#line 406
        if (__cil_tmp14) {
#line 407
          return (1000);
        }
      }
    }
  }
#line 411
  c = (fore->w_mlines + y)->color + x1;
#line 417
  dx = (x2 - x1) + 1;
#line 417
  cost = dx;
  {
#line 418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 418
    if (! (__cil_tmp15 > 0)) {
#line 418
      goto while_break___1;
    }
#line 420
    __cil_tmp16 = p;
#line 420
    p ++;
#line 420
    if ((int )*__cil_tmp16 != (int )rend->attr) {
#line 421
      return (1000);
    }
#line 423
    __cil_tmp17 = f;
#line 423
    f ++;
#line 423
    if ((int )*__cil_tmp17 != (int )rend->font) {
#line 424
      return (1000);
    }
#line 427
    __cil_tmp18 = c;
#line 427
    c ++;
#line 427
    if ((int )*__cil_tmp18 != (int )rend->color) {
#line 428
      return (1000);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  return (cost);
}
}
#line 439 "/tmp/screen-3.9.15/window.c"
static void WinClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
#line 442
  fore = (struct win *)flayer->l_data;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  LClearLine(flayer, y, xs, xe, bce, & *(fore->w_mlines + y));
  }
}
}
#line 448 "/tmp/screen-3.9.15/window.c"
static int WinResize(int wi , int he ) 
{ 


  {
  {
#line 451
  fore = (struct win *)flayer->l_data;
#line 452
  ChangeWindowSize(fore, wi, he, fore->w_histheight);
  }
#line 453
  return (0);
}
}
#line 457 "/tmp/screen-3.9.15/window.c"
static void WinRestore(void) 
{ 
  struct canvas *cv ;
  int tmp ;

  {
#line 460
  fore = (struct win *)flayer->l_data;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  cv = flayer->l_cvlist;
  {
#line 462
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 462
    if (! cv) {
#line 462
      goto while_break___0;
    }
#line 464
    display = cv->c_display;
#line 465
    if (cv != display->d_forecv) {
#line 466
      goto while_continue___0;
    }
    {
#line 468
    KeypadMode(fore->w_keypad);
#line 469
    CursorkeysMode(fore->w_cursorkeys);
#line 470
    SetFlow(fore->w_flow & 1);
#line 471
    InsertMode(fore->w_insert);
#line 472
    ReverseVideo(fore->w_revvid);
    }
#line 473
    if (fore->w_curinv) {
#line 473
      tmp = - 1;
    } else {
#line 473
      tmp = fore->w_curvvis;
    }
    {
#line 473
    CursorVisibility(tmp);
#line 474
    MouseMode(fore->w_mouse);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 462
  cv = cv->c_next;
}
}
#line 488 "/tmp/screen-3.9.15/window.c"
int DoStartLog(struct win *w , char *buf , int bufsize ) 
{ 
  int n ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  FILE *__cil_tmp7 ;
  FILE *tmp ;
  struct logfile *__cil_tmp9 ;
  int tmp___321 ;

  {
#line 494
  if (! w) {
#line 495
    return (- 1);
  } else
#line 494
  if (! buf) {
#line 495
    return (- 1);
  }
  {
#line 497
  __cil_tmp5 = MakeWinMsg(screenlogfile, w, '%');
#line 497
  strncpy(buf, (char const   *)__cil_tmp5, (unsigned long )(bufsize - 1));
#line 498
  *(buf + (bufsize - 1)) = (char )0;
  }
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (w->w_log != (struct logfile *)((void *)0)) {
    {
#line 503
    logfclose(w->w_log);
    }
  }
  {
#line 505
  __cil_tmp6 = islogfile(buf);
  }
#line 505
  if (__cil_tmp6) {
#line 505
    tmp = (FILE *)((void *)0);
  } else {
    {
#line 505
    __cil_tmp7 = secfopen(buf, (char *)"a");
#line 505
    tmp = __cil_tmp7;
    }
  }
  {
#line 505
  __cil_tmp9 = logfopen(buf, tmp);
#line 505
  w->w_log = __cil_tmp9;
  }
#line 505
  if (w->w_log == (struct logfile *)((void *)0)) {
#line 506
    return (- 2);
  }
#line 507
  if (! logflushev.queued) {
#line 509
    if (log_flush) {
#line 509
      tmp___321 = log_flush;
    } else {
#line 509
      tmp___321 = (logtstamp_after + 4) / 5;
    }
#line 509
    n = tmp___321;
#line 510
    if (n) {
      {
#line 512
      SetTimeout(& logflushev, n * 1000);
#line 513
      evenq(& logflushev);
      }
    }
  }
#line 516
  return (0);
}
}
#line 524 "/tmp/screen-3.9.15/window.c"
int MakeWindow(struct NewWindow *newwin ) 
{ 
  register struct win **pp ;
  register struct win *p ;
  register int n ;
  register int i ;
  int f ;
  struct NewWindow nwin ;
  int type ;
  int startat ;
  char *TtyName___0 ;
  extern struct acluser *users___0 ;
  int tmp ;
  void *__cil_tmp14 ;
  struct acluser *tmp___322 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___323 ;
  char *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  int tmp___324 ;
  int tmp___325 ;
  int __cil_tmp32 ;
  struct display *d ;
  size_t __cil_tmp34 ;
  size_t __cil_tmp35 ;
  char buf[1024] ;

  {
#line 529
  f = - 1;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 539
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 539
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 540
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 540
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 542
  nwin_compose(& nwin_default, newwin, & nwin);
  }
  {
#line 543
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 543
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 544
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 544
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 545
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 545
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 547
  if (nwin.StartAt < maxwin) {
#line 547
    tmp = nwin.StartAt;
  } else {
#line 547
    tmp = 0;
  }
#line 547
  startat = tmp;
#line 548
  pp = (struct win **)wtab + startat;
  {
#line 550
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 552
    if (*pp == (struct win *)0) {
#line 553
      goto while_break___6;
    }
#line 554
    pp ++;
#line 554
    if (pp == (struct win **)wtab + maxwin) {
#line 555
      pp = (struct win **)wtab;
    }
#line 550
    if (! (pp != (struct win **)wtab + startat)) {
#line 550
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 558
  if (*pp) {
    {
#line 560
    Msg(0, (char *)"No more windows.");
    }
#line 561
    return (- 1);
  }
#line 574
  n = (int )(pp - (struct win **)wtab);
  {
#line 575
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 575
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 577
  f = OpenDevice(nwin.args, nwin.lflag, & type, & TtyName___0);
  }
#line 577
  if (f < 0) {
#line 578
    return (- 1);
  }
  {
#line 580
  __cil_tmp14 = malloc(sizeof(struct win ));
#line 580
  p = (struct win *)__cil_tmp14;
  }
#line 580
  if (p == (struct win *)0) {
    {
#line 582
    close(f);
#line 583
    Msg(0, (char *)strnomem);
    }
#line 584
    return (- 1);
  }
  {
#line 586
  bzero((void *)((char *)p), (unsigned long )((int )sizeof(struct win )));
  }
#line 589
  if (type != 0) {
#line 590
    nwin.lflag = 0;
  }
#line 593
  p->w_type = type;
#line 596
  i = 0;
  {
#line 596
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 596
    if (! (*(nwin.args + i) && i < 63)) {
#line 596
      goto while_break___8;
    }
    {
#line 597
    p->w_cmdargs[i] = SaveStr((char const   *)*(nwin.args + i));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 596
  i ++;
#line 598
  p->w_cmdargs[i] = (char *)0;
#line 599
  if (nwin.dir) {
    {
#line 600
    p->w_dir = SaveStr((char const   *)nwin.dir);
    }
  }
#line 601
  if (nwin.term) {
    {
#line 602
    p->w_term = SaveStr((char const   *)nwin.term);
    }
  }
#line 604
  p->w_number = n;
#line 611
  if (display) {
#line 611
    tmp___322 = display->d_user;
  } else {
#line 611
    tmp___322 = users___0;
  }
  {
#line 611
  __cil_tmp20 = NewWindowAcl(p, tmp___322);
  }
#line 611
  if (__cil_tmp20) {
    {
#line 613
    free((void *)((char *)p));
#line 614
    close(f);
#line 615
    Msg(0, (char *)strnomem);
    }
#line 616
    return (- 1);
  }
  {
#line 619
  p->w_layer.l_next = (struct layer *)0;
#line 620
  p->w_layer.l_bottom = & p->w_layer;
#line 621
  p->w_layer.l_layfn = & WinLf;
#line 622
  p->w_layer.l_data = (char *)p;
#line 623
  p->w_savelayer = & p->w_layer;
#line 624
  p->w_pdisplay = (struct display *)0;
#line 627
  __cil_tmp21 = AclCheckPermWin(display->d_user, 1, p);
  }
#line 627
  if (display) {
#line 627
    if (! __cil_tmp21) {
#line 628
      p->w_wlockuser = display->d_user;
    }
  }
#line 629
  p->w_wlock = nwin.wlock;
#line 631
  p->w_ptyfd = f;
#line 632
  p->w_aflag = nwin.aflag;
#line 633
  if (nwin.flowflag & (1 << 2)) {
#line 633
    tmp___323 = (1 << 1) | 1;
  } else {
#line 633
    tmp___323 = 1 << 1;
  }
#line 633
  p->w_flow = nwin.flowflag | tmp___323;
#line 634
  if (! nwin.aka) {
    {
#line 635
    nwin.aka = Filename(*(nwin.args + 0));
    }
  }
  {
#line 636
  strncpy((char *)p->w_akabuf, (char const   *)nwin.aka, (unsigned long )255);
#line 637
  nwin.aka = rindex((char const   *)((char *)p->w_akabuf), '|');
  }
#line 637
  if (nwin.aka != (char *)((void *)0)) {
    {
#line 639
    p->w_autoaka = 0;
#line 640
    __cil_tmp25 = nwin.aka;
#line 640
    (nwin.aka) ++;
#line 640
    *__cil_tmp25 = (char )0;
#line 641
    p->w_title = nwin.aka;
#line 642
    __cil_tmp26 = strlen((char const   *)nwin.aka);
#line 642
    p->w_akachange = nwin.aka + __cil_tmp26;
    }
  } else {
#line 645
    p->w_akachange = (char *)p->w_akabuf;
#line 645
    p->w_title = p->w_akachange;
  }
#line 646
  if (nwin.hstatus) {
    {
#line 647
    p->w_hstatus = SaveStr((char const   *)nwin.hstatus);
    }
  }
#line 648
  p->w_monitor = nwin.monitor;
#line 650
  if (p->w_monitor == 1) {
#line 653
    i = 0;
    {
#line 653
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 653
      if (! (i < maxusercount)) {
#line 653
        goto while_break___9;
      }
#line 654
      *(p->w_mon_notify + (i >> 3)) |= 128 >> (i & 7);
    }
    while_break___9: /* CIL Label */ ;
    }
#line 653
    i ++;
  }
#line 660
  p->w_silence = nwin.silence;
#line 661
  p->w_silencewait = SilenceWait;
#line 663
  if (p->w_silence == 1) {
#line 666
    i = 0;
    {
#line 666
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 666
      if (! (i < maxusercount)) {
#line 666
        goto while_break___10;
      }
#line 667
      *(p->w_lio_notify + (i >> 3)) |= 128 >> (i & 7);
    }
    while_break___10: /* CIL Label */ ;
    }
#line 666
    i ++;
  }
  {
#line 671
  p->w_slowpaste = nwin.slow;
#line 676
  p->w_norefresh = (char )0;
#line 677
  strncpy((char *)p->w_tty, (char const   *)TtyName___0, (unsigned long )255);
  }
#line 689
  if (display) {
#line 689
    tmp___324 = ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1;
  } else {
#line 689
    tmp___324 = 80;
  }
#line 689
  if (display) {
#line 689
    tmp___325 = ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1;
  } else {
#line 689
    tmp___325 = 24;
  }
  {
#line 689
  __cil_tmp32 = ChangeWindowSize(p, tmp___324, tmp___325, nwin.histheight);
  }
#line 689
  if (__cil_tmp32) {
    {
#line 693
    FreeWindow(p);
    }
#line 694
    return (- 1);
  }
  {
#line 698
  p->w_layer.l_encoding = nwin.encoding;
#line 699
  ResetWindow(p);
  }
#line 702
  if (nwin.charset) {
    {
#line 703
    SetCharsets(p, nwin.charset);
    }
  }
#line 706
  if (VerboseCreate) {
    {
#line 708
    d = display;
#line 710
    WriteString(p, (char *)":screen (", 9);
#line 711
    __cil_tmp34 = strlen((char const   *)p->w_title);
#line 711
    WriteString(p, p->w_title, (int )__cil_tmp34);
#line 712
    WriteString(p, (char *)"):", 2);
#line 713
    f = 0;
    }
    {
#line 713
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 713
      if (! p->w_cmdargs[f]) {
#line 713
        goto while_break___11;
      }
      {
#line 715
      WriteString(p, (char *)" ", 1);
#line 716
      __cil_tmp35 = strlen((char const   *)p->w_cmdargs[f]);
#line 716
      WriteString(p, p->w_cmdargs[f], (int )__cil_tmp35);
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 713
    f ++;
#line 718
    WriteString(p, (char *)"\r\n", 2);
#line 719
    display = d;
    }
  }
#line 722
  p->w_pid = 0;
#line 724
  p->w_pwin = (struct pseudowin *)0;
#line 738
  if (type == 0) {
    {
#line 740
    p->w_pid = ForkWindow(p, nwin.args, TtyName___0);
    }
#line 741
    if (p->w_pid < 0) {
      {
#line 743
      FreeWindow(p);
      }
#line 744
      return (- 1);
    }
  }
#line 751
  if (display) {
#line 751
    if (display->d_fore) {
#line 752
      display->d_other = display->d_fore;
    }
  }
#line 753
  *pp = p;
#line 754
  p->w_next = windows;
#line 755
  windows = p;
#line 756
  p->w_lflag = nwin.lflag;
#line 758
  p->w_slot = (slot_t )(- 1);
  {
#line 760
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 760
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 761
  if (nwin.lflag & 1) {
#line 767
    p->w_slot = (slot_t )0;
#line 768
    if (display) {
      {
      {
#line 769
      SetUtmp(p);
      }
      }
    } else
#line 768
    if (p->w_lflag & 2) {
      {
      {
#line 769
      SetUtmp(p);
      }
      }
    }
  }
#line 776
  if (nwin.Lflag) {
    {
#line 779
    DoStartLog(p, (char *)buf, (int )sizeof(buf));
    }
  }
  {
#line 782
  p->w_writeev.fd = p->w_ptyfd;
#line 782
  p->w_readev.fd = p->w_writeev.fd;
#line 783
  p->w_readev.type = 1;
#line 784
  p->w_writeev.type = 2;
#line 785
  p->w_writeev.data = (char *)p;
#line 785
  p->w_readev.data = p->w_writeev.data;
#line 786
  p->w_readev.handler = win_readev_fn;
#line 787
  p->w_writeev.handler = win_writeev_fn;
#line 788
  p->w_writeev.condpos = & p->w_inlen;
#line 789
  evenq(& p->w_readev);
#line 790
  evenq(& p->w_writeev);
#line 792
  p->w_paster.pa_slowev.type = 0;
#line 793
  p->w_paster.pa_slowev.data = (char *)(& p->w_paster);
#line 794
  p->w_paster.pa_slowev.handler = paste_slowev_fn;
#line 796
  p->w_silenceev.type = 0;
#line 797
  p->w_silenceev.data = (char *)p;
#line 798
  p->w_silenceev.handler = win_silenceev_fn;
  }
#line 799
  if (p->w_silence > 0) {
    {
#line 801
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 801
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 802
    SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 803
    evenq(& p->w_silenceev);
    }
  }
  {
#line 806
  SetForeWindow(p);
#line 807
  Activate((int )p->w_norefresh);
#line 808
  WindowChanged((struct win *)0, 'w');
#line 809
  WindowChanged((struct win *)0, 'W');
#line 810
  WindowChanged((struct win *)0, 0);
  }
#line 811
  return (n);
}
}
#line 821 "/tmp/screen-3.9.15/window.c"
int RemakeWindow(struct win *p ) 
{ 
  char *TtyName___0 ;
  int lflag ;
  int f ;
  char *tmp ;
  struct display *d ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
  {
#line 827
  lflag = nwin_default.lflag;
#line 828
  f = OpenDevice((char **)p->w_cmdargs, lflag, & p->w_type, & TtyName___0);
  }
#line 828
  if (f < 0) {
#line 829
    return (- 1);
  }
#line 831
  if ((int )*TtyName___0) {
#line 831
    tmp = TtyName___0;
  } else {
#line 831
    tmp = p->w_title;
  }
  {
#line 831
  strncpy((char *)p->w_tty, (char const   *)tmp, (unsigned long )255);
#line 832
  p->w_ptyfd = f;
#line 833
  p->w_readev.fd = f;
#line 834
  p->w_writeev.fd = f;
#line 835
  evenq(& p->w_readev);
#line 836
  evenq(& p->w_writeev);
  }
#line 838
  if (VerboseCreate) {
    {
#line 840
    d = display;
#line 842
    WriteString(p, (char *)":screen (", 9);
#line 843
    __cil_tmp8 = strlen((char const   *)p->w_title);
#line 843
    WriteString(p, p->w_title, (int )__cil_tmp8);
#line 844
    WriteString(p, (char *)"):", 2);
#line 845
    f = 0;
    }
    {
#line 845
    while (1) {
      while_continue: /* CIL Label */ ;
#line 845
      if (! p->w_cmdargs[f]) {
#line 845
        goto while_break;
      }
      {
#line 847
      WriteString(p, (char *)" ", 1);
#line 848
      __cil_tmp9 = strlen((char const   *)p->w_cmdargs[f]);
#line 848
      WriteString(p, p->w_cmdargs[f], (int )__cil_tmp9);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 845
    f ++;
#line 850
    WriteString(p, (char *)"\r\n", 2);
#line 851
    display = d;
    }
  }
#line 854
  p->w_pid = 0;
#line 863
  if (p->w_type == 0) {
    {
#line 865
    p->w_pid = ForkWindow(p, (char **)p->w_cmdargs, TtyName___0);
    }
#line 866
    if (p->w_pid < 0) {
#line 867
      return (- 1);
    }
  }
#line 871
  if (p->w_slot == (slot_t )0) {
#line 871
    if (display) {
      {
      {
#line 872
      SetUtmp(p);
      }
      }
    } else
#line 871
    if (p->w_lflag & 2) {
      {
      {
#line 872
      SetUtmp(p);
      }
      }
    }
  }
  {
#line 877
  WindowChanged(p, 'f');
  }
#line 878
  return (p->w_number);
}
}
#line 882 "/tmp/screen-3.9.15/window.c"
void CloseDevice(struct win *wp ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 885
  if (wp->w_ptyfd < 0) {
#line 886
    return;
  }
#line 887
  if (wp->w_type == 0) {
    {
#line 890
    __cil_tmp2 = chmod((char const   *)((char *)wp->w_tty), (__mode_t )438);
#line 891
    __cil_tmp3 = chown((char const   *)((char *)wp->w_tty), (__uid_t )0, (__gid_t )0);
    }
  }
  {
#line 893
  close(wp->w_ptyfd);
#line 894
  wp->w_ptyfd = - 1;
#line 895
  wp->w_tty[0] = (char )0;
#line 896
  evdeq(& wp->w_readev);
#line 897
  evdeq(& wp->w_writeev);
#line 901
  wp->w_writeev.fd = - 1;
#line 901
  wp->w_readev.fd = wp->w_writeev.fd;
  }
}
}
#line 905 "/tmp/screen-3.9.15/window.c"
void FreeWindow(struct win *wp ) 
{ 
  struct display *d ;
  int i ;
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;
  struct win *tmp ;

  {
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  if (wp->w_pwin) {
    {
#line 916
    FreePseudowin(wp);
    }
  }
  {
#line 919
  RemoveUtmp(wp);
#line 921
  CloseDevice(wp);
  }
#line 923
  if (wp == console_window) {
    {
#line 925
    TtyGrabConsole(- 1, - 1, (char *)"free");
#line 926
    console_window = (struct win *)0;
    }
  }
#line 928
  if (wp->w_log != (struct logfile *)((void *)0)) {
    {
#line 929
    logfclose(wp->w_log);
    }
  }
  {
#line 930
  ChangeWindowSize(wp, 0, 0, 0);
  }
#line 932
  if (wp->w_hstatus) {
    {
#line 933
    free((void *)wp->w_hstatus);
    }
  }
#line 934
  i = 0;
  {
#line 934
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 934
    if (! wp->w_cmdargs[i]) {
#line 934
      goto while_break___0;
    }
    {
#line 935
    free((void *)wp->w_cmdargs[i]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 934
  i ++;
#line 936
  if (wp->w_dir) {
    {
#line 937
    free((void *)wp->w_dir);
    }
  }
#line 938
  if (wp->w_term) {
    {
#line 939
    free((void *)wp->w_term);
    }
  }
#line 940
  d = displays;
  {
#line 940
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 940
    if (! d) {
#line 940
      goto while_break___1;
    }
#line 942
    if (d->d_other == wp) {
#line 943
      if (d->d_fore && (d->d_fore)->w_next != wp) {
#line 943
        tmp = (d->d_fore)->w_next;
      } else {
#line 943
        tmp = wp->w_next;
      }
#line 943
      d->d_other = tmp;
    }
#line 944
    if (d->d_fore == wp) {
#line 945
      d->d_fore = (struct win *)((void *)0);
    }
#line 946
    cv = d->d_cvlist;
    {
#line 946
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 946
      if (! cv) {
#line 946
        goto while_break___2;
      }
#line 948
      l = cv->c_layer;
      {
#line 948
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 948
        if (! l) {
#line 948
          goto while_break___3;
        }
#line 949
        if (l->l_layfn == & WinLf) {
#line 950
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 948
      l = l->l_next;
#line 951
      if (! l) {
#line 952
        goto while_continue___2;
      }
#line 953
      if ((struct win *)l->l_data != wp) {
#line 954
        goto while_continue___2;
      }
#line 955
      if (cv->c_layer == wp->w_savelayer) {
#line 956
        wp->w_savelayer = (struct layer *)0;
      }
      {
#line 957
      KillLayerChain(cv->c_layer);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 946
    cv = cv->c_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 940
  d = d->d_next;
#line 960
  if (wp->w_savelayer) {
    {
#line 961
    KillLayerChain(wp->w_savelayer);
    }
  }
#line 962
  cv = wp->w_layer.l_cvlist;
  {
#line 962
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 962
    if (! cv) {
#line 962
      goto while_break___4;
    }
    {
#line 964
    ncv = cv->c_lnext;
#line 965
    cv->c_layer = & cv->c_blank;
#line 966
    cv->c_blank.l_cvlist = cv;
#line 967
    cv->c_lnext = (struct canvas *)0;
#line 968
    cv->c_xoff = cv->c_xs;
#line 969
    cv->c_yoff = cv->c_ys;
#line 970
    RethinkViewportOffsets(cv);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 962
  cv = ncv;
#line 972
  wp->w_layer.l_cvlist = (struct canvas *)0;
#line 973
  if (flayer == & wp->w_layer) {
#line 974
    flayer = (struct layer *)0;
  }
  {
#line 977
  FreeWindowAcl(wp);
#line 979
  evdeq(& wp->w_readev);
#line 980
  evdeq(& wp->w_writeev);
#line 981
  evdeq(& wp->w_silenceev);
#line 983
  FreePaster(& wp->w_paster);
#line 985
  free((void *)((char *)wp));
  }
}
}
#line 989 "/tmp/screen-3.9.15/window.c"
static int OpenDevice(char **args , int lflag , int *typep , char **namep ) 
{ 
  char *arg ;
  struct stat st ;
  int f ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int flag ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;
  int tmp ;
  int __cil_tmp20 ;
  int *__cil_tmp21 ;

  {
#line 995
  arg = *(args + 0);
#line 999
  if (! arg) {
#line 1000
    return (- 1);
  }
  {
#line 1011
  __cil_tmp8 = stat((char const   *)arg, & st);
  }
#line 1011
  if (__cil_tmp8 == 0) {
#line 1011
    if ((st.st_mode & 61440U) == 8192U) {
      {
#line 1013
      __cil_tmp9 = access((char const   *)arg, 6);
      }
#line 1013
      if (__cil_tmp9 == -1) {
        {
#line 1015
        __cil_tmp10 = __errno_location();
#line 1015
        Msg(*__cil_tmp10, (char *)"Cannot access line \'%s\' for R/W", arg);
        }
#line 1016
        return (- 1);
      }
      {
#line 1018
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1018
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1019
      f = OpenTTY(arg, *(args + 1));
      }
#line 1019
      if (f < 0) {
#line 1020
        return (- 1);
      }
#line 1021
      lflag = 0;
#line 1022
      *typep = 1;
#line 1023
      *namep = arg;
    } else {
#line 1011
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1027
    *typep = 0;
#line 1028
    f = OpenPTY(namep);
    }
#line 1029
    if (f == -1) {
      {
#line 1031
      Msg(0, (char *)"No more PTYs.");
      }
#line 1032
      return (- 1);
    }
    {
#line 1036
    flag = 1;
#line 1037
    __cil_tmp14 = ioctl(f, (unsigned long )21536, (char *)(& flag));
    }
#line 1037
    if (__cil_tmp14) {
      {
#line 1039
      __cil_tmp15 = __errno_location();
#line 1039
      Msg(*__cil_tmp15, (char *)"TIOCPKT ioctl");
#line 1040
      close(f);
      }
#line 1041
      return (- 1);
    }
  }
  {
#line 1046
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1046
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1047
  __cil_tmp16 = fcntl(f, 4, 2048);
  }
#line 1065
  if (*typep == 0) {
    {
    {
#line 1066
    tcflush(f, 2);
    }
    }
  } else
#line 1065
  if (*typep == 1) {
    {
    {
#line 1066
    tcflush(f, 2);
    }
    }
  }
#line 1069
  if (*typep != 0) {
#line 1070
    return (f);
  }
  {
#line 1074
  __cil_tmp17 = chown((char const   *)*namep, (__uid_t )real_uid, (__gid_t )5);
  }
#line 1074
  if (__cil_tmp17) {
#line 1074
    if (! eff_uid) {
      {
#line 1079
      __cil_tmp18 = __errno_location();
#line 1079
      Msg(*__cil_tmp18, (char *)"chown tty");
#line 1080
      close(f);
      }
#line 1081
      return (- 1);
    }
  }
#line 1084
  if (lflag) {
#line 1084
    tmp = TtyMode;
  } else {
#line 1084
    tmp = TtyMode & -19;
  }
  {
#line 1084
  __cil_tmp20 = chmod((char const   *)*namep, (__mode_t )tmp);
  }
#line 1084
  if (__cil_tmp20) {
#line 1084
    if (! eff_uid) {
      {
#line 1089
      __cil_tmp21 = __errno_location();
#line 1089
      Msg(*__cil_tmp21, (char *)"chmod tty");
#line 1090
      close(f);
      }
#line 1091
      return (- 1);
    }
  }
#line 1094
  return (f);
}
}
#line 1105 "/tmp/screen-3.9.15/window.c"
static int ForkWindow(struct win *win , char **args , char *ttyn ) 
{ 
  int pid ;
  char tebuf[25] ;
  char ebuf[10] ;
  char shellbuf[4103] ;
  char *proc ;
  int newfd ;
  int w ;
  int h ;
  int i ;
  int pat ;
  int wfdused ;
  struct pseudowin *pwin ;
  int slave ;
  int *__cil_tmp18 ;
  int *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int *__cil_tmp23 ;
  int __cil_tmp24 ;
  int *__cil_tmp25 ;
  int tmp ;
  int *__cil_tmp30 ;
  int __cil_tmp32 ;
  int *__cil_tmp33 ;
  struct mode fakemode ;
  struct mode *modep ;
  int __cil_tmp36 ;
  int *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp41 ;
  size_t __cil_tmp42 ;
  char *s1 ;
  char *s2 ;
  char tl ;
  size_t __cil_tmp46 ;
  char *__cil_tmp48 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  int *__cil_tmp52 ;

  {
#line 1118
  w = win->w_layer.l_width;
#line 1119
  h = win->w_layer.l_height;
#line 1122
  pwin = win->w_pwin;
#line 1124
  slave = - 1;
#line 1127
  if (pty_preopen) {
    {
#line 1129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1129
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1130
    slave = open((char const   *)ttyn, 258);
    }
#line 1130
    if (slave == -1) {
      {
#line 1132
      __cil_tmp18 = __errno_location();
#line 1132
      Msg(*__cil_tmp18, (char *)"ttyn");
      }
#line 1133
      return (- 1);
    }
  }
  {
#line 1137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1138
  proc = *args;
#line 1139
  if (proc == (char *)0) {
#line 1141
    args = (char **)ShellArgs;
#line 1142
    proc = *args;
  }
  {
#line 1144
  fflush(stdout);
#line 1145
  fflush(stderr);
#line 1146
  pid = fork();
  }
  {
#line 1148
  if (pid == - 1) {
#line 1148
    goto case_exp;
  }
#line 1151
  if (pid == 0) {
#line 1151
    goto case_0;
  }
#line 1372
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 1149
  __cil_tmp20 = __errno_location();
#line 1149
  Msg(*__cil_tmp20, (char *)"fork");
  }
#line 1150
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1152
  xsignal(1, (__sighandler_t )0);
  }
  {
#line 1153
  xsignal(2, (__sighandler_t )0);
#line 1154
  xsignal(3, (__sighandler_t )0);
#line 1155
  xsignal(15, (__sighandler_t )0);
#line 1157
  xsignal(21, (__sighandler_t )0);
#line 1158
  xsignal(22, (__sighandler_t )0);
#line 1161
  xsignal(13, (__sighandler_t )0);
#line 1164
  xsignal(25, (__sighandler_t )0);
#line 1167
  displays = (struct display *)0;
#line 1168
  __cil_tmp22 = setuid((__uid_t )real_uid);
  }
  {
#line 1168
  __cil_tmp21 = setgid((__gid_t )real_gid);
  }
#line 1168
  if (__cil_tmp21) {
    {
    {
#line 1169
    __cil_tmp23 = __errno_location();
    }
    {
#line 1169
    Panic(*__cil_tmp23, (char *)"Setuid/gid");
    }
    }
  } else
#line 1168
  if (__cil_tmp22) {
    {
    {
#line 1169
    __cil_tmp23 = __errno_location();
    }
    {
#line 1169
    Panic(*__cil_tmp23, (char *)"Setuid/gid");
    }
    }
  }
#line 1170
  eff_uid = real_uid;
#line 1171
  eff_gid = real_gid;
#line 1173
  if (! pwin) {
    {
#line 1175
    __cil_tmp24 = chdir((char const   *)win->w_dir);
    }
#line 1175
    if (win->w_dir) {
#line 1175
      if ((int )*(win->w_dir)) {
#line 1175
        if (__cil_tmp24) {
          {
#line 1176
          __cil_tmp25 = __errno_location();
#line 1176
          Panic(*__cil_tmp25, (char *)"Cannot chdir to %s", win->w_dir);
          }
        }
      }
    }
  }
#line 1178
  if (display) {
    {
#line 1180
    brktty(display->d_userfd);
#line 1181
    freetty();
    }
  } else {
    {
#line 1184
    brktty(- 1);
    }
  }
#line 1189
  if (slave != -1) {
    {
#line 1191
    close(0);
#line 1192
    dup(slave);
#line 1193
    close(slave);
#line 1194
    closeallfiles(win->w_ptyfd);
#line 1195
    slave = dup(0);
    }
  } else {
    {
#line 1198
    closeallfiles(win->w_ptyfd);
    }
  }
  {
#line 1213
  close(0);
#line 1214
  close(1);
#line 1215
  close(2);
#line 1216
  newfd = - 1;
  }
#line 1221
  if (pwin) {
#line 1221
    tmp = pwin->p_fdpat;
  } else {
#line 1221
    tmp = ((1 << 4) | (1 << 2)) | 1;
  }
#line 1221
  pat = tmp;
#line 1223
  wfdused = 0;
#line 1224
  i = 0;
  {
#line 1224
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1224
    if (! (i < 3)) {
#line 1224
      goto while_break___1;
    }
#line 1226
    if (pat & (1 << 2 * i)) {
#line 1228
      if (newfd < 0) {
#line 1231
        if (separate_sids) {
          {
#line 1232
          newfd = open((char const   *)ttyn, 2);
          }
        } else {
          {
#line 1234
          newfd = open((char const   *)ttyn, 258);
          }
        }
#line 1238
        if (newfd < 0) {
          {
#line 1239
          __cil_tmp30 = __errno_location();
#line 1239
          Panic(*__cil_tmp30, (char *)"Cannot open %s", ttyn);
          }
        }
      } else {
        {
#line 1242
        dup(newfd);
        }
      }
    } else {
      {
#line 1246
      dup(win->w_ptyfd);
#line 1247
      wfdused = 1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1224
  i ++;
#line 1250
  if (wfdused) {
    {
#line 1256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1256
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1257
    __cil_tmp32 = fcntl(win->w_ptyfd, 4, 0);
    }
#line 1257
    if (__cil_tmp32) {
      {
#line 1258
      __cil_tmp33 = __errno_location();
#line 1258
      Msg(*__cil_tmp33, (char *)"Warning: clear NBLOCK fcntl failed");
      }
    }
  }
  {
#line 1274
  close(win->w_ptyfd);
  }
#line 1275
  if (slave != -1) {
    {
#line 1276
    close(slave);
    }
  }
#line 1277
  if (newfd >= 0) {
    {
#line 1280
    InitPTY(newfd);
#line 1281
    __cil_tmp36 = fgtty(newfd);
    }
#line 1281
    if (__cil_tmp36) {
      {
#line 1282
      __cil_tmp37 = __errno_location();
#line 1282
      Msg(*__cil_tmp37, (char *)"fgtty");
      }
    }
#line 1283
    if (display) {
      {
#line 1285
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1285
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1286
      modep = & display->d_OldMode;
    } else {
      {
#line 1290
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1290
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1291
      modep = & fakemode;
#line 1292
      InitTTY(modep, 0);
      }
    }
#line 1301
    if (pwin) {
#line 1301
      if (! (pat & 4096)) {
        _L: /* CIL Label */ 
        {
#line 1303
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1303
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1305
        modep->tio.c_lflag &= (unsigned int )(~ 8);
#line 1306
        modep->tio.c_iflag &= (unsigned int )(~ 256);
      } else
#line 1301
      if (pat & (2 << 2)) {
#line 1301
        goto _L;
      }
    }
    {
#line 1312
    SetTTY(newfd, modep);
#line 1314
    glwz.ws_col = (unsigned short )w;
#line 1315
    glwz.ws_row = (unsigned short )h;
#line 1316
    __cil_tmp38 = ioctl(newfd, (unsigned long )21524, (char *)(& glwz));
#line 1319
    __cil_tmp39 = fcntl(newfd, 4, 0);
    }
  }
  {
#line 1328
  *(NewEnv + 2) = MakeTermcap(display == (struct display *)0 || win->w_aflag);
#line 1335
  strcpy((char *)shellbuf, (char const   *)((char *)"SHELL="));
#line 1336
  strncpy((char *)shellbuf + 6, (char const   *)(ShellProg + ((int )*ShellProg == 45)),
          sizeof(shellbuf) - 7UL);
#line 1337
  shellbuf[sizeof(shellbuf) - 1UL] = (char )0;
#line 1338
  *(NewEnv + 4) = (char *)shellbuf;
  }
  {
#line 1339
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1339
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1340
  __cil_tmp42 = strlen((char const   *)win->w_term);
  }
  {
#line 1340
  __cil_tmp41 = strcmp((char const   *)((char *)screenterm), (char const   *)win->w_term);
  }
#line 1340
  if (win->w_term) {
#line 1340
    if ((int )*(win->w_term)) {
#line 1340
      if (__cil_tmp41) {
#line 1340
        if (__cil_tmp42 < 20UL) {
          {
#line 1345
          sprintf((char *)tebuf, (char const   *)((char *)"TERM=%s"), win->w_term);
          }
          {
#line 1346
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1346
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 1347
          __cil_tmp46 = strlen((char const   *)win->w_term);
#line 1347
          tl = (char )__cil_tmp46;
#line 1348
          *(NewEnv + 1) = (char *)tebuf;
#line 1349
          s1 = index((char const   *)*(NewEnv + 2), '|');
          }
#line 1349
          if (s1) {
            {
#line 1351
            s1 ++;
#line 1351
            __cil_tmp48 = index((char const   *)s1, '|');
#line 1351
            s2 = __cil_tmp48;
            }
#line 1351
            if (s2) {
              {
#line 1353
              __cil_tmp49 = strlen((char const   *)*(NewEnv + 2));
              }
#line 1353
              if ((__cil_tmp49 - (unsigned long )(s2 - s1)) + (unsigned long )tl < 1024UL) {
                {
#line 1355
                __cil_tmp50 = strlen((char const   *)s2);
#line 1355
                bcopy((void const   *)s2, (void *)(s1 + (int )tl), __cil_tmp50 + 1UL);
#line 1356
                bcopy((void const   *)win->w_term, (void *)s1, (size_t )tl);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1361
  sprintf((char *)ebuf, (char const   *)((char *)"WINDOW=%d"), win->w_number);
#line 1362
  *(NewEnv + 3) = (char *)ebuf;
  }
#line 1364
  if ((int )*proc == 45) {
#line 1365
    proc ++;
  }
#line 1366
  if (! *proc) {
#line 1367
    proc = (char *)DefaultShell;
  }
  {
#line 1368
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1368
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1369
  execvpe(proc, args, NewEnv);
  }
  {
#line 1370
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1370
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1371
  __cil_tmp52 = __errno_location();
#line 1371
  Panic(*__cil_tmp52, (char *)"Cannot exec \'%s\'", proc);
  }
  switch_default: /* CIL Label */ 
#line 1373
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1375
  if (slave != -1) {
    {
#line 1376
    close(slave);
    }
  }
#line 1377
  return (pid);
}
}
#line 1381 "/tmp/screen-3.9.15/window.c"
static void execvpe(char *prog , char **args , char **env ) 
{ 
  register char *path ;
  register char *p ;
  char buf[1024] ;
  char *shargs[65] ;
  register int i ;
  register int eaccess ;
  char *__cil_tmp10 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int *__cil_tmp17 ;
  int *__cil_tmp18 ;

  {
  {
#line 1384
  path = (char *)((void *)0);
#line 1387
  eaccess = 0;
#line 1389
  __cil_tmp10 = rindex((char const   *)prog, '/');
  }
#line 1389
  if (__cil_tmp10) {
#line 1390
    path = (char *)"";
  }
  {
#line 1391
  path = getenv((char const   *)((char *)"PATH"));
  }
#line 1391
  if (! path) {
#line 1391
    if (! path) {
#line 1392
      path = (char *)DefaultPath;
    }
  }
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1395
    p = (char *)buf;
    {
#line 1395
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1395
      if (! ((int )*path && (int )*path != 58)) {
#line 1395
        goto while_break___0;
      }
#line 1396
      if ((unsigned long )(p - (char *)buf) < sizeof(buf) - 2UL) {
#line 1397
        __cil_tmp13 = p;
#line 1397
        p ++;
#line 1397
        *__cil_tmp13 = *path;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1395
    path ++;
#line 1398
    if (p > (char *)buf) {
#line 1399
      __cil_tmp15 = p;
#line 1399
      p ++;
#line 1399
      *__cil_tmp15 = (char )'/';
    }
    {
#line 1400
    __cil_tmp16 = strlen((char const   *)prog);
    }
#line 1400
    if ((unsigned long )(p - (char *)buf) + __cil_tmp16 >= sizeof(buf) - 1UL) {
#line 1401
      goto while_continue;
    }
    {
#line 1402
    strcpy(p, (char const   *)prog);
#line 1403
    execve((char const   *)((char *)buf), (char * const  [])args, (char * const  [])env);
#line 1404
    __cil_tmp17 = __errno_location();
    }
    {
#line 1406
    if (*__cil_tmp17 == 8) {
#line 1406
      goto case_8;
    }
#line 1413
    if (*__cil_tmp17 == 13) {
#line 1413
      goto case_13;
    }
#line 1418
    if (*__cil_tmp17 == 26) {
#line 1418
      goto case_26;
    }
#line 1418
    if (*__cil_tmp17 == 7) {
#line 1418
      goto case_26;
    }
#line 1418
    if (*__cil_tmp17 == 12) {
#line 1418
      goto case_26;
    }
#line 1404
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1407
    shargs[0] = (char *)DefaultShell;
#line 1408
    shargs[1] = (char *)buf;
#line 1409
    i = 1;
    {
#line 1409
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1409
      if (! (shargs[i + 1] != (char *)((void *)0))) {
#line 1409
        goto while_break___1;
      }

    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1409
    i ++;
#line 1411
    execve((char const   *)((char *)DefaultShell), (char * const  [])((char **)shargs),
           (char * const  [])env);
    }
#line 1412
    return;
    case_13: /* CIL Label */ 
#line 1414
    eaccess = 1;
#line 1415
    goto switch_break;
    case_26: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1419
    return;
    switch_break: /* CIL Label */ ;
    }
#line 1393
    if (! *__cil_tmp12) {
#line 1393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  if (eaccess) {
    {
#line 1423
    __cil_tmp18 = __errno_location();
#line 1423
    *__cil_tmp18 = 13;
    }
  }
}
}
#line 1429 "/tmp/screen-3.9.15/window.c"
int winexec(char **av ) 
{ 
  char **pp ;
  char *p ;
  char *s ;
  char *t ;
  int i ;
  int r ;
  int l ;
  struct win *w ;
  extern struct display *display___326 ;
  extern struct win *windows___327 ;
  struct pseudowin *pwin ;
  int type ;
  struct win *tmp ;
  char *tmp___328 ;
  void *__cil_tmp16 ;
  char *__cil_tmp19 ;
  int tmp___329 ;
  char *__cil_tmp24 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int flag ;
  int __cil_tmp35 ;
  int *__cil_tmp36 ;

  {
#line 1434
  r = 0;
#line 1434
  l = 0;
#line 1441
  if (display___326) {
#line 1441
    tmp = fore;
  } else {
#line 1441
    tmp = windows___327;
  }
#line 1441
  w = tmp;
#line 1441
  if (w == (struct win *)((void *)0)) {
#line 1442
    return (- 1);
  }
#line 1443
  if (! *av) {
    _L: /* CIL Label */ 
#line 1445
    if (w->w_pwin) {
#line 1445
      tmp___328 = (char *)(w->w_pwin)->p_cmd;
    } else {
#line 1445
      tmp___328 = (char *)"(none)";
    }
    {
#line 1445
    Msg(0, (char *)"Filter running: %s", tmp___328);
    }
#line 1446
    return (- 1);
  } else
#line 1443
  if (w->w_pwin) {
#line 1443
    goto _L;
  }
#line 1448
  if (w->w_ptyfd < 0) {
    {
#line 1450
    Msg(0, (char *)"You feel dead inside.");
    }
#line 1451
    return (- 1);
  }
  {
#line 1453
  __cil_tmp16 = malloc(sizeof(struct pseudowin ));
#line 1453
  pwin = (struct pseudowin *)__cil_tmp16;
  }
#line 1453
  if (! pwin) {
    {
#line 1455
    Msg(0, (char *)strnomem);
    }
#line 1456
    return (- 1);
  }
  {
#line 1458
  bzero((void *)((char *)pwin), (unsigned long )((int )sizeof(*pwin)));
#line 1461
  s = *av;
  }
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! ((int )*s == 32)) {
#line 1461
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 1461
  s ++;
#line 1463
  p = s;
  {
#line 1463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1463
    if (! (((int )*p == 58 || (int )*p == 46) || (int )*p == 33)) {
#line 1463
      goto while_break___0;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
#line 1463
  p ++;
#line 1465
  if ((int )*p != 124) {
    {
#line 1466
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1466
      if (! (((int )*p && p > s) && (int )*(p + -1) == 46)) {
#line 1466
        goto while_break___1;
      }
#line 1467
      __cil_tmp19 = p;
#line 1467
      p --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1468
  if ((int )*p == 124) {
#line 1470
    l = 4096;
#line 1471
    p ++;
  }
#line 1473
  if (*p) {
#line 1474
    *(av + 0) = p;
  } else {
#line 1476
    av ++;
  }
#line 1478
  t = (char *)pwin->p_cmd;
#line 1479
  i = 0;
  {
#line 1479
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1479
    if (! (i < 3)) {
#line 1479
      goto while_break___2;
    }
#line 1481
    if (s < p) {
#line 1481
      s ++;
#line 1481
      tmp___329 = (int )*s;
    } else {
#line 1481
      tmp___329 = '.';
    }
#line 1481
    *t = (char )tmp___329;
#line 1482
    __cil_tmp24 = t;
#line 1482
    t ++;
    {
#line 1485
    if ((int )*__cil_tmp24 == '|') {
#line 1485
      goto case_124;
    }
#line 1485
    if ((int )*__cil_tmp24 == '.') {
#line 1485
      goto case_124;
    }
#line 1488
    if ((int )*__cil_tmp24 == '!') {
#line 1488
      goto case_33;
    }
#line 1491
    if ((int )*__cil_tmp24 == ':') {
#line 1491
      goto case_58;
    }
#line 1482
    goto switch_break;
    case_124: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 1486
    l |= 1 << i * 2;
#line 1487
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1489
    l |= 2 << i * 2;
#line 1490
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1492
    l |= 3 << i * 2;
#line 1493
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1479
  i ++;
#line 1497
  if (l & 4096) {
#line 1499
    __cil_tmp26 = t;
#line 1499
    t ++;
#line 1499
    *__cil_tmp26 = (char )'|';
#line 1500
    if ((l & 3) == 1) {
#line 1502
      *((char *)pwin->p_cmd) = (char )'!';
#line 1503
      l ^= 3;
    }
  }
#line 1506
  if (! (l & 2)) {
#line 1507
    l |= 4096;
  }
#line 1508
  __cil_tmp27 = t;
#line 1508
  t ++;
#line 1508
  *__cil_tmp27 = (char )' ';
#line 1509
  pwin->p_fdpat = l;
  {
#line 1510
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1510
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1512
  l = 252;
#line 1513
  pp = av;
  {
#line 1513
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1513
    if (! *pp) {
#line 1513
      goto while_break___4;
    }
#line 1515
    p = *pp;
    {
#line 1516
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1516
      if (! ((int )*p && __cil_tmp28 > 0)) {
#line 1516
        goto while_break___5;
      }
#line 1517
      __cil_tmp30 = p;
#line 1517
      p ++;
#line 1517
      __cil_tmp29 = t;
#line 1517
      t ++;
#line 1517
      *__cil_tmp29 = *__cil_tmp30;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1518
    if (l <= 0) {
#line 1519
      goto while_break___4;
    }
#line 1520
    __cil_tmp31 = t;
#line 1520
    t ++;
#line 1520
    *__cil_tmp31 = (char )' ';
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1513
  pp ++;
#line 1522
  t --;
#line 1522
  *t = (char )'\000';
  {
#line 1523
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1523
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1525
  pwin->p_ptyfd = OpenDevice(av, 0, & type, & t);
  }
#line 1525
  if (pwin->p_ptyfd < 0) {
    {
#line 1527
    free((void *)((char *)pwin));
    }
#line 1528
    return (- 1);
  }
  {
#line 1530
  strncpy((char *)pwin->p_tty, (char const   *)t, (unsigned long )255);
#line 1531
  w->w_pwin = pwin;
  }
#line 1532
  if (type != 0) {
    {
#line 1534
    FreePseudowin(w);
#line 1535
    Msg(0, (char *)"Cannot only use commands as pseudo win.");
    }
#line 1536
    return (- 1);
  }
  {
#line 1540
  flag = 0;
#line 1542
  __cil_tmp35 = ioctl(pwin->p_ptyfd, (unsigned long )21536, (char *)(& flag));
  }
#line 1542
  if (__cil_tmp35) {
    {
#line 1544
    __cil_tmp36 = __errno_location();
#line 1544
    Msg(*__cil_tmp36, (char *)"TIOCPKT ioctl");
#line 1545
    FreePseudowin(w);
    }
#line 1546
    return (- 1);
  }
  {
#line 1551
  pwin->p_writeev.fd = pwin->p_ptyfd;
#line 1551
  pwin->p_readev.fd = pwin->p_writeev.fd;
#line 1552
  pwin->p_readev.type = 1;
#line 1553
  pwin->p_writeev.type = 2;
#line 1554
  pwin->p_writeev.data = (char *)w;
#line 1554
  pwin->p_readev.data = pwin->p_writeev.data;
#line 1555
  pwin->p_readev.handler = pseu_readev_fn;
#line 1556
  pwin->p_writeev.handler = pseu_writeev_fn;
#line 1557
  pwin->p_writeev.condpos = & pwin->p_inlen;
#line 1558
  evenq(& pwin->p_readev);
#line 1559
  evenq(& pwin->p_writeev);
#line 1560
  pwin->p_pid = ForkWindow(w, av, t);
#line 1561
  r = pwin->p_pid;
  }
#line 1561
  if (r < 0) {
    {
#line 1562
    FreePseudowin(w);
    }
  }
#line 1563
  return (r);
}
}
#line 1567 "/tmp/screen-3.9.15/window.c"
void FreePseudowin(struct win *w ) 
{ 
  struct pseudowin *pwin ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 1570
  pwin = w->w_pwin;
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1572
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1573
  __cil_tmp3 = fcntl(w->w_ptyfd, 4, 2048);
  }
#line 1573
  if (__cil_tmp3) {
    {
#line 1574
    __cil_tmp4 = __errno_location();
#line 1574
    Msg(*__cil_tmp4, (char *)"Warning: FreePseudowin: NBLOCK fcntl failed");
    }
  }
  {
#line 1576
  __cil_tmp5 = chmod((char const   *)((char *)pwin->p_tty), (__mode_t )438);
#line 1577
  __cil_tmp6 = chown((char const   *)((char *)pwin->p_tty), (__uid_t )0, (__gid_t )0);
  }
#line 1578
  if (pwin->p_ptyfd >= 0) {
    {
#line 1579
    close(pwin->p_ptyfd);
    }
  }
  {
#line 1580
  evdeq(& pwin->p_readev);
#line 1581
  evdeq(& pwin->p_writeev);
  }
#line 1582
  if (w->w_readev.condneg == & pwin->p_inlen) {
#line 1583
    w->w_readev.condneg = (int *)0;
#line 1583
    w->w_readev.condpos = w->w_readev.condneg;
  }
  {
#line 1584
  free((void *)((char *)pwin));
#line 1585
  w->w_pwin = (struct pseudowin *)((void *)0);
  }
}
}
#line 1596 "/tmp/screen-3.9.15/window.c"
int ReleaseAutoWritelock(struct display *dis , struct win *w ) 
{ 
  struct display *d ;

  {
  {
#line 1600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1600
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  if (w->w_wlock == 1) {
#line 1604
    if (w->w_wlockuser == dis->d_user) {
#line 1608
      d = displays;
      {
#line 1608
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1608
        if (! d) {
#line 1608
          goto while_break___0;
        }
#line 1609
        if (d != dis) {
#line 1609
          if (d->d_fore == w) {
#line 1609
            if (d->d_user == dis->d_user) {
#line 1610
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1608
      d = d->d_next;
      {
#line 1611
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1611
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1613
      if (! d) {
#line 1615
        w->w_wlockuser = (struct acluser *)((void *)0);
#line 1616
        return (0);
      }
    }
  }
#line 1619
  return (1);
}
}
#line 1626 "/tmp/screen-3.9.15/window.c"
int ObtainAutoWritelock(struct display *d , struct win *w ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1630
  __cil_tmp3 = AclCheckPermWin(d->d_user, 1, w);
  }
#line 1630
  if (w->w_wlock == 1) {
#line 1630
    if (! __cil_tmp3) {
#line 1630
      if (! w->w_wlockuser) {
        {
#line 1634
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1634
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1636
        w->w_wlockuser = d->d_user;
#line 1637
        return (0);
      }
    }
  }
#line 1639
  return (1);
}
}
#line 1650 "/tmp/screen-3.9.15/window.c"
static void paste_slowev_fn(struct event *ev , char *data ) 
{ 
  struct paster *pa ;
  struct win *p ;
  int l ;

  {
#line 1654
  pa = (struct paster *)data;
#line 1657
  l = 1;
#line 1658
  flayer = pa->pa_pastelayer;
#line 1659
  if (! flayer) {
#line 1660
    pa->pa_pastelen = 0;
  }
#line 1661
  if (! pa->pa_pastelen) {
#line 1662
    return;
  }
  {
#line 1663
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 1664
  DoProcess(p, & pa->pa_pasteptr, & l, pa);
#line 1665
  pa->pa_pastelen -= 1 - l;
  }
#line 1666
  if (pa->pa_pastelen > 0) {
    {
#line 1668
    SetTimeout(& pa->pa_slowev, p->w_slowpaste);
#line 1669
    evenq(& pa->pa_slowev);
    }
  }
}
}
#line 1676 "/tmp/screen-3.9.15/window.c"
static int muchpending(struct win *p , struct event *ev ) 
{ 
  struct canvas *cv ;

  {
#line 1681
  cv = p->w_layer.l_cvlist;
  {
#line 1681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1681
    if (! cv) {
#line 1681
      goto while_break;
    }
#line 1683
    display = cv->c_display;
#line 1684
    if (display->d_status == 1) {
#line 1684
      if (! display->d_status_bell) {
        {
#line 1687
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1687
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1688
        ev->condpos = & const_one;
#line 1689
        ev->condneg = & display->d_status;
#line 1690
        return (1);
      }
    }
#line 1692
    if (display->d_obufp - display->d_obuf > (long )display->d_obufmax) {
      {
#line 1694
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1694
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1695
      ev->condpos = & display->d_obuffree;
#line 1696
      ev->condneg = & display->d_obuflenmax;
#line 1697
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1681
  cv = cv->c_lnext;
#line 1700
  return (0);
}
}
#line 1704 "/tmp/screen-3.9.15/window.c"
static void win_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf[4096] ;
  char *bp ;
  int size ;
  int len ;
  int wtop ;
  int __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  int *__cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp14 ;

  {
#line 1708
  p = (struct win *)data;
#line 1715
  bp = (char *)buf;
#line 1716
  size = 4096;
#line 1719
  wtop = p->w_pwin && ((p->w_pwin)->p_fdpat & 3) == 3;
#line 1720
  if (wtop) {
    {
#line 1722
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1722
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1723
    size = 4096 - (p->w_pwin)->p_inlen;
#line 1724
    if (size <= 0) {
#line 1726
      ev->condpos = & const_IOSIZE;
#line 1727
      ev->condneg = & (p->w_pwin)->p_inlen;
#line 1728
      return;
    }
  }
  {
#line 1732
  __cil_tmp9 = muchpending(p, ev);
  }
#line 1732
  if (p->w_layer.l_cvlist) {
#line 1732
    if (__cil_tmp9) {
#line 1733
      return;
    }
  }
#line 1734
  if (p->w_blocked) {
#line 1736
    ev->condpos = & const_one;
#line 1737
    ev->condneg = & p->w_blocked;
#line 1738
    return;
  }
#line 1740
  if (ev->condpos) {
#line 1741
    ev->condneg = (int *)0;
#line 1741
    ev->condpos = ev->condneg;
  }
#line 1743
  len = p->w_outlen;
#line 1743
  if (len) {
    {
#line 1745
    p->w_outlen = 0;
#line 1746
    WriteString(p, (char *)p->w_outbuf, len);
    }
#line 1747
    return;
  }
  {
#line 1750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1750
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1751
  __cil_tmp10 = read(ev->fd, (void *)((char *)buf), (size_t )size);
#line 1751
  len = (int )__cil_tmp10;
  }
#line 1751
  if (len < 0) {
    {
#line 1753
    __cil_tmp12 = __errno_location();
    }
    {
#line 1753
    __cil_tmp11 = __errno_location();
    }
#line 1753
    if (*__cil_tmp11 == 4) {
#line 1754
      return;
    } else
#line 1753
    if (*__cil_tmp12 == 11) {
#line 1754
      return;
    }
    {
#line 1759
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1759
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1760
    WindowDied(p);
    }
#line 1761
    return;
  }
#line 1763
  if (len == 0) {
    {
#line 1765
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1765
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1766
    WindowDied(p);
    }
#line 1767
    return;
  }
  {
#line 1769
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1769
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1771
  if (p->w_type == 0) {
#line 1773
    if (buf[0]) {
      {
#line 1775
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1775
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1776
      if ((int )buf[0] & 16) {
        {
#line 1777
        WNewAutoFlow(p, 0);
        }
      }
#line 1778
      if ((int )buf[0] & 32) {
        {
#line 1779
        WNewAutoFlow(p, 1);
        }
      }
    }
#line 1781
    bp ++;
#line 1782
    __cil_tmp14 = len;
#line 1782
    len --;
  }
#line 1789
  if (len == 0) {
#line 1790
    return;
  }
#line 1792
  if (wtop) {
    {
#line 1794
    bcopy((void const   *)bp, (void *)((char *)(p->w_pwin)->p_inbuf + (p->w_pwin)->p_inlen),
          (size_t )len);
#line 1795
    (p->w_pwin)->p_inlen += len;
    }
  }
  {
#line 1798
  WriteString(p, bp, len);
  }
#line 1799
  return;
}
}
#line 1804 "/tmp/screen-3.9.15/window.c"
static void win_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  int len ;
  ssize_t __cil_tmp5 ;
  struct paster *pa ;

  {
#line 1808
  p = (struct win *)data;
#line 1810
  if (p->w_inlen) {
    {
#line 1812
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1812
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1813
    __cil_tmp5 = write(ev->fd, (void const   *)((char *)p->w_inbuf), (size_t )p->w_inlen);
#line 1813
    len = (int )__cil_tmp5;
    }
#line 1813
    if (len <= 0) {
#line 1814
      len = p->w_inlen;
    }
#line 1815
    p->w_inlen -= len;
#line 1815
    if (p->w_inlen) {
      {
#line 1816
      bcopy((void const   *)((char *)p->w_inbuf + len), (void *)((char *)p->w_inbuf),
            (size_t )p->w_inlen);
      }
    }
  }
#line 1819
  if (p->w_paster.pa_pastelen) {
#line 1819
    if (! p->w_slowpaste) {
#line 1821
      pa = & p->w_paster;
#line 1822
      flayer = pa->pa_pastelayer;
#line 1823
      if (flayer) {
        {
#line 1824
        DoProcess(p, & pa->pa_pasteptr, & pa->pa_pastelen, pa);
        }
      }
    }
  }
#line 1827
  return;
}
}
#line 1835 "/tmp/screen-3.9.15/window.c"
static void pseu_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf[4096] ;
  int size ;
  int ptow ;
  int len ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 1839
  p = (struct win *)data;
#line 1843
  size = 4096;
#line 1845
  ptow = ((p->w_pwin)->p_fdpat & (3 << 2)) == 3 << 2 || ((p->w_pwin)->p_fdpat & (3 << 4)) == 3 << 4;
#line 1846
  if (ptow) {
    {
#line 1848
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1848
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1849
    size = 4096 - p->w_inlen;
#line 1850
    if (size <= 0) {
#line 1852
      ev->condpos = & const_IOSIZE;
#line 1853
      ev->condneg = & p->w_inlen;
#line 1854
      return;
    }
  }
  {
#line 1857
  __cil_tmp8 = muchpending(p, ev);
  }
#line 1857
  if (p->w_layer.l_cvlist) {
#line 1857
    if (__cil_tmp8) {
#line 1858
      return;
    }
  }
#line 1859
  if (p->w_blocked) {
#line 1861
    ev->condpos = & const_one;
#line 1862
    ev->condneg = & p->w_blocked;
#line 1863
    return;
  }
#line 1865
  if (ev->condpos) {
#line 1866
    ev->condneg = (int *)0;
#line 1866
    ev->condpos = ev->condneg;
  }
#line 1868
  len = p->w_outlen;
#line 1868
  if (len) {
    {
#line 1870
    p->w_outlen = 0;
#line 1871
    WriteString(p, (char *)p->w_outbuf, len);
    }
#line 1872
    return;
  }
  {
#line 1875
  __cil_tmp9 = read(ev->fd, (void *)((char *)buf), (size_t )size);
#line 1875
  len = (int )__cil_tmp9;
  }
#line 1875
  if (len <= 0) {
    {
#line 1877
    __cil_tmp11 = __errno_location();
    }
    {
#line 1877
    __cil_tmp10 = __errno_location();
    }
#line 1877
    if (*__cil_tmp10 == 4) {
#line 1878
      return;
    } else
#line 1877
    if (*__cil_tmp11 == 11) {
#line 1878
      return;
    }
    {
#line 1883
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1883
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1884
    FreePseudowin(p);
    }
#line 1885
    return;
  }
#line 1888
  if (ptow) {
    {
#line 1890
    bcopy((void const   *)((char *)buf), (void *)((char *)p->w_inbuf + p->w_inlen),
          (size_t )len);
#line 1891
    p->w_inlen += len;
    }
  }
  {
#line 1893
  WriteString(p, (char *)buf, len);
  }
#line 1894
  return;
}
}
#line 1898 "/tmp/screen-3.9.15/window.c"
static void pseu_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct pseudowin *pw ;
  int len ;
  ssize_t __cil_tmp6 ;

  {
#line 1902
  p = (struct win *)data;
#line 1903
  pw = p->w_pwin;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1907
  if (pw->p_inlen == 0) {
#line 1908
    return;
  }
  {
#line 1909
  __cil_tmp6 = write(ev->fd, (void const   *)((char *)pw->p_inbuf), (size_t )pw->p_inlen);
#line 1909
  len = (int )__cil_tmp6;
  }
#line 1909
  if (len <= 0) {
#line 1910
    len = pw->p_inlen;
  }
#line 1911
  (p->w_pwin)->p_inlen -= len;
#line 1911
  if ((p->w_pwin)->p_inlen) {
    {
#line 1912
    bcopy((void const   *)((char *)(p->w_pwin)->p_inbuf + len), (void *)((char *)(p->w_pwin)->p_inbuf),
          (size_t )(p->w_pwin)->p_inlen);
    }
  }
}
}
#line 1919 "/tmp/screen-3.9.15/window.c"
static void win_silenceev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct canvas *cv ;

  {
#line 1923
  p = (struct win *)data;
  {
#line 1925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1925
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1926
  display = displays;
  {
#line 1926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1926
    if (! display) {
#line 1926
      goto while_break___0;
    }
#line 1928
    cv = display->d_cvlist;
    {
#line 1928
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1928
      if (! cv) {
#line 1928
        goto while_break___1;
      }
#line 1929
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 1930
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1928
    cv = cv->c_next;
#line 1931
    if (cv) {
#line 1932
      goto while_continue___0;
    }
#line 1934
    if (! ((int )*(p->w_lio_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 1935
      goto while_continue___0;
    }
    {
#line 1937
    Msg(0, (char *)"Window %d: silence for %d seconds", p->w_number, p->w_silencewait);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1926
  display = display->d_next;
}
}
#line 33 "/tmp/screen-3.9.15/term.c"
struct term term[188]  = 
#line 33 "/tmp/screen-3.9.15/term.c"
  {      {(char *)"li", 1}, 
        {(char *)"co", 1}, 
        {(char *)"hc", 0}, 
        {(char *)"os", 0}, 
        {(char *)"ns", 0}, 
        {(char *)"cm", 2}, 
        {(char *)"ho", 2}, 
        {(char *)"cr", 2}, 
        {(char *)"up", 2}, 
        {(char *)"UP", 2}, 
        {(char *)"do", 2}, 
        {(char *)"DO", 2}, 
        {(char *)"bs", 0}, 
        {(char *)"bc", 2}, 
        {(char *)"le", 2}, 
        {(char *)"LE", 2}, 
        {(char *)"nd", 2}, 
        {(char *)"RI", 2}, 
        {(char *)"cs", 2}, 
        {(char *)"nl", 2}, 
        {(char *)"sf", 2}, 
        {(char *)"sr", 2}, 
        {(char *)"al", 2}, 
        {(char *)"AL", 2}, 
        {(char *)"dl", 2}, 
        {(char *)"DL", 2}, 
        {(char *)"in", 0}, 
        {(char *)"im", 2}, 
        {(char *)"ei", 2}, 
        {(char *)"ic", 2}, 
        {(char *)"IC", 2}, 
        {(char *)"dc", 2}, 
        {(char *)"DC", 2}, 
        {(char *)"ut", 0}, 
        {(char *)"cl", 2}, 
        {(char *)"cd", 2}, 
        {(char *)"CD", 2}, 
        {(char *)"ce", 2}, 
        {(char *)"cb", 2}, 
        {(char *)"is", 2}, 
        {(char *)"ti", 2}, 
        {(char *)"te", 2}, 
        {(char *)"bl", 2}, 
        {(char *)"vb", 2}, 
        {(char *)"WS", 2}, 
        {(char *)"Z0", 2}, 
        {(char *)"Z1", 2}, 
        {(char *)"mh", 2}, 
        {(char *)"us", 2}, 
        {(char *)"md", 2}, 
        {(char *)"mr", 2}, 
        {(char *)"so", 2}, 
        {(char *)"mb", 2}, 
        {(char *)"ue", 2}, 
        {(char *)"se", 2}, 
        {(char *)"me", 2}, 
        {(char *)"ms", 0}, 
        {(char *)"sg", 1}, 
        {(char *)"ug", 1}, 
        {(char *)"sa", 2}, 
        {(char *)"AF", 2}, 
        {(char *)"AB", 2}, 
        {(char *)"Sf", 2}, 
        {(char *)"Sb", 2}, 
        {(char *)"op", 2}, 
        {(char *)"Co", 1}, 
        {(char *)"be", 0}, 
        {(char *)"AX", 0}, 
        {(char *)"C8", 0}, 
        {(char *)"ks", 2}, 
        {(char *)"ke", 2}, 
        {(char *)"CS", 2}, 
        {(char *)"CE", 2}, 
        {(char *)"po", 2}, 
        {(char *)"pf", 2}, 
        {(char *)"hs", 0}, 
        {(char *)"ws", 1}, 
        {(char *)"ts", 2}, 
        {(char *)"fs", 2}, 
        {(char *)"ds", 2}, 
        {(char *)"vi", 2}, 
        {(char *)"vs", 2}, 
        {(char *)"ve", 2}, 
        {(char *)"am", 0}, 
        {(char *)"xv", 0}, 
        {(char *)"xn", 0}, 
        {(char *)"OP", 0}, 
        {(char *)"LP", 0}, 
        {(char *)"NF", 0}, 
        {(char *)"nx", 0}, 
        {(char *)"AN", 0}, 
        {(char *)"OL", 1}, 
        {(char *)"KJ", 2}, 
        {(char *)"VR", 2}, 
        {(char *)"VN", 2}, 
        {(char *)"TF", 0}, 
        {(char *)"XT", 0}, 
        {(char *)"G0", 0}, 
        {(char *)"S0", 2}, 
        {(char *)"E0", 2}, 
        {(char *)"C0", 2}, 
        {(char *)"as", 2}, 
        {(char *)"ae", 2}, 
        {(char *)"ac", 2}, 
        {(char *)"eA", 2}, 
        {(char *)"XC", 2}, 
        {(char *)"k0", 2}, 
        {(char *)"k1", 2}, 
        {(char *)"k2", 2}, 
        {(char *)"k3", 2}, 
        {(char *)"k4", 2}, 
        {(char *)"k5", 2}, 
        {(char *)"k6", 2}, 
        {(char *)"k7", 2}, 
        {(char *)"k8", 2}, 
        {(char *)"k9", 2}, 
        {(char *)"k;", 2}, 
        {(char *)"F1", 2}, 
        {(char *)"F2", 2}, 
        {(char *)"F3", 2}, 
        {(char *)"F4", 2}, 
        {(char *)"F5", 2}, 
        {(char *)"F6", 2}, 
        {(char *)"F7", 2}, 
        {(char *)"F8", 2}, 
        {(char *)"F9", 2}, 
        {(char *)"FA", 2}, 
        {(char *)"kb", 2}, 
        {(char *)"K1", 2}, 
        {(char *)"K2", 2}, 
        {(char *)"K3", 2}, 
        {(char *)"K4", 2}, 
        {(char *)"K5", 2}, 
        {(char *)"kA", 2}, 
        {(char *)"ka", 2}, 
        {(char *)"kB", 2}, 
        {(char *)"kC", 2}, 
        {(char *)"kE", 2}, 
        {(char *)"kF", 2}, 
        {(char *)"kL", 2}, 
        {(char *)"kM", 2}, 
        {(char *)"kR", 2}, 
        {(char *)"kS", 2}, 
        {(char *)"kT", 2}, 
        {(char *)"kt", 2}, 
        {(char *)"kh", 2}, 
        {(char *)"@1", 2}, 
        {(char *)"kH", 2}, 
        {(char *)"@7", 2}, 
        {(char *)"kN", 2}, 
        {(char *)"kP", 2}, 
        {(char *)"kI", 2}, 
        {(char *)"kD", 2}, 
        {(char *)"ku", 2}, 
        {(char *)"kd", 2}, 
        {(char *)"kr", 2}, 
        {(char *)"kl", 2}, 
        {(char *)"f0", 2}, 
        {(char *)"f1", 2}, 
        {(char *)"f2", 2}, 
        {(char *)"f3", 2}, 
        {(char *)"f4", 2}, 
        {(char *)"f5", 2}, 
        {(char *)"f6", 2}, 
        {(char *)"f7", 2}, 
        {(char *)"f8", 2}, 
        {(char *)"f9", 2}, 
        {(char *)"f+", 2}, 
        {(char *)"f-", 2}, 
        {(char *)"f*", 2}, 
        {(char *)"f/", 2}, 
        {(char *)"fq", 2}, 
        {(char *)"f.", 2}, 
        {(char *)"f,", 2}, 
        {(char *)"fe", 2}, 
        {(char *)"km", 0}, 
        {(char *)"ko", 2}, 
        {(char *)"l0", 2}, 
        {(char *)"l1", 2}, 
        {(char *)"l2", 2}, 
        {(char *)"l3", 2}, 
        {(char *)"l4", 2}, 
        {(char *)"l5", 2}, 
        {(char *)"l6", 2}, 
        {(char *)"l7", 2}, 
        {(char *)"l8", 2}, 
        {(char *)"l9", 2}, 
        {(char *)"la", 2}};
#line 670 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 782
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 844
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios *__termios_p ) ;
#line 80
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 73 "./extern.h"
int secopen(char *name , int flags , int mode ) ;
#line 84
void GetTTY(int fd , struct mode *mp ) ;
#line 86
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) ;
#line 97
int SetBaud(struct mode *m , int ibaud , int obaud ) ;
#line 98
int SttyMode(struct mode *m , char *opt ) ;
#line 343
int UserContext(void) ;
#line 344
void UserReturn(int val ) ;
#line 345
int UserStatus(void) ;
#line 360
void sleep1000(int msec ) ;
#line 71 "/tmp/screen-3.9.15/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) ;
#line 74 "/tmp/screen-3.9.15/tty.c"
int separate_sids  =    1;
#line 76
static void DoSendBreak(int fd , int n , int type ) ;
#line 77
static void SigAlrmDummy(int sigsig ) ;
#line 104 "/tmp/screen-3.9.15/tty.c"
static void SigAlrmDummy(int sigsig ) 
{ 


  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }

}
}
#line 116 "/tmp/screen-3.9.15/tty.c"
int OpenTTY(char *line , char *opt ) 
{ 
  int f ;
  struct mode Mode ;
  void (*sigalrm)(int  ) ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  int __cil_tmp10 ;
  int *__cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  int mcs ;

  {
  {
#line 123
  sigalrm = xsignal(14, (void (*)(int  ))SigAlrmDummy);
#line 124
  alarm((unsigned int )2);
#line 127
  f = secopen(line, 2306, 0);
  }
#line 127
  if (f == -1) {
    {
#line 129
    __cil_tmp8 = __errno_location();
    }
#line 129
    if (*__cil_tmp8 == 4) {
      {
#line 130
      Msg(0, (char *)"Cannot open line \'%s\' for R/W: open() blocked, aborted.",
          line);
      }
    } else {
      {
#line 132
      __cil_tmp9 = __errno_location();
#line 132
      Msg(*__cil_tmp9, (char *)"Cannot open line \'%s\' for R/W", line);
      }
    }
    {
#line 133
    alarm((unsigned int )0);
#line 134
    xsignal(14, sigalrm);
    }
#line 135
    return (- 1);
  }
  {
#line 137
  __cil_tmp10 = isatty(f);
  }
#line 137
  if (! __cil_tmp10) {
    {
#line 139
    Msg(0, (char *)"\'%s\' is not a tty", line);
#line 140
    alarm((unsigned int )0);
#line 141
    xsignal(14, sigalrm);
#line 142
    close(f);
    }
#line 143
    return (- 1);
  }
  {
#line 156
  __cil_tmp11 = __errno_location();
#line 156
  *__cil_tmp11 = 0;
#line 157
  __cil_tmp12 = ioctl(f, (unsigned long )21516, (char *)0);
  }
#line 157
  if (__cil_tmp12 < 0) {
    {
#line 158
    __cil_tmp13 = __errno_location();
#line 158
    Msg(*__cil_tmp13, (char *)"%s: ioctl TIOCEXCL failed", line);
    }
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  InitTTY(& Mode, 1);
#line 175
  SttyMode(& Mode, opt);
#line 179
  SetTTY(f, & Mode);
#line 183
  mcs = 0;
#line 184
  ioctl(f, (unsigned long )21525, & mcs);
#line 185
  mcs |= 4;
#line 186
  ioctl(f, (unsigned long )21528, & mcs);
#line 190
  brktty(f);
#line 191
  alarm((unsigned int )0);
#line 192
  xsignal(14, sigalrm);
  }
  {
#line 193
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 193
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 194
  return (f);
}
}
#line 203 "/tmp/screen-3.9.15/tty.c"
void InitTTY(struct mode *m , int ttyflag ) 
{ 


  {
  {
#line 207
  bzero((void *)((char *)m), sizeof(*m));
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  m->tio.c_iflag |= (unsigned int )2;
#line 217
  m->tio.c_iflag |= (unsigned int )4;
#line 221
  m->tio.c_iflag |= (unsigned int )1024;
#line 225
  if (! ttyflag) {
#line 228
    m->tio.c_iflag |= (unsigned int )256;
#line 231
    m->tio.c_oflag |= (unsigned int )4;
#line 234
    m->tio.c_oflag |= (unsigned int )6144;
#line 241
    m->tio.c_oflag |= (unsigned int )1;
  }
  {
#line 257
  cfsetospeed(& m->tio, (speed_t )13);
#line 260
  cfsetispeed(& m->tio, (speed_t )13);
#line 264
  m->tio.c_cflag |= (unsigned int )48;
#line 267
  m->tio.c_cflag |= (unsigned int )128;
#line 270
  m->tio.c_cflag |= (unsigned int )2048;
#line 274
  m->tio.c_lflag |= (unsigned int )512;
#line 277
  m->tio.c_lflag |= (unsigned int )2048;
  }
#line 280
  if (! ttyflag) {
#line 283
    m->tio.c_lflag |= (unsigned int )1;
#line 286
    m->tio.c_lflag |= (unsigned int )2;
#line 289
    m->tio.c_lflag |= (unsigned int )8;
  }
#line 293
  m->tio.c_lflag |= (unsigned int )16;
#line 296
  m->tio.c_lflag |= (unsigned int )32;
#line 299
  m->tio.c_lflag |= (unsigned int )32768;
#line 304
  m->tio.c_cc[0] = (cc_t )3;
#line 309
  m->tio.c_cc[1] = (cc_t )28;
#line 314
  m->tio.c_cc[2] = (cc_t )127;
#line 319
  m->tio.c_cc[3] = (cc_t )8;
#line 324
  m->tio.c_cc[4] = (cc_t )4;
#line 329
  m->tio.c_cc[11] = (cc_t )0;
#line 334
  m->tio.c_cc[16] = (cc_t )0;
#line 344
  m->tio.c_cc[8] = (cc_t )17;
#line 349
  m->tio.c_cc[9] = (cc_t )19;
#line 354
  m->tio.c_cc[10] = (cc_t )26;
#line 364
  m->tio.c_cc[12] = (cc_t )18;
#line 369
  m->tio.c_cc[13] = (cc_t )15;
#line 374
  m->tio.c_cc[14] = (cc_t )23;
#line 379
  m->tio.c_cc[15] = (cc_t )22;
#line 388
  if (ttyflag) {
#line 390
    m->tio.c_cc[6] = (cc_t )100;
#line 391
    m->tio.c_cc[5] = (cc_t )2;
  }
}
}
#line 585 "/tmp/screen-3.9.15/tty.c"
void SetTTY(int fd , struct mode *mp ) 
{ 
  int *__cil_tmp3 ;
  int *__cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 589
  __cil_tmp3 = __errno_location();
#line 589
  *__cil_tmp3 = 0;
#line 591
  tcsetattr(fd, 1, & mp->tio);
#line 619
  __cil_tmp4 = __errno_location();
  }
#line 619
  if (*__cil_tmp4) {
    {
#line 620
    __cil_tmp5 = __errno_location();
#line 620
    Msg(*__cil_tmp5, (char *)"SetTTY (fd %d): ioctl failed", fd);
    }
  }
}
}
#line 624 "/tmp/screen-3.9.15/tty.c"
void GetTTY(int fd , struct mode *mp ) 
{ 
  int *__cil_tmp3 ;
  int *__cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 628
  __cil_tmp3 = __errno_location();
#line 628
  *__cil_tmp3 = 0;
#line 630
  tcgetattr(fd, & mp->tio);
#line 663
  __cil_tmp4 = __errno_location();
  }
#line 663
  if (*__cil_tmp4) {
    {
#line 664
    __cil_tmp5 = __errno_location();
#line 664
    Msg(*__cil_tmp5, (char *)"GetTTY (fd %d): ioctl failed", fd);
    }
  }
}
}
#line 671 "/tmp/screen-3.9.15/tty.c"
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) 
{ 


  {
#line 675
  *np = *op;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  np->tio.c_iflag &= (unsigned int )(~ 256);
#line 688
  np->tio.c_iflag &= (unsigned int )(~ 32);
#line 691
  np->tio.c_oflag &= (unsigned int )(~ 4);
#line 693
  np->tio.c_lflag &= (unsigned int )(~ 10);
#line 699
  np->tio.c_lflag &= (unsigned int )(~ 32768);
#line 711
  if (interrupt) {
#line 712
    np->tio.c_lflag |= (unsigned int )1;
  } else {
#line 714
    np->tio.c_lflag &= (unsigned int )(~ 1);
  }
#line 723
  np->tio.c_cc[6] = (cc_t )1;
#line 724
  np->tio.c_cc[5] = (cc_t )0;
#line 725
  if (! interrupt) {
#line 726
    np->tio.c_cc[0] = (cc_t )'\000';
  } else
#line 725
  if (! flow) {
#line 726
    np->tio.c_cc[0] = (cc_t )'\000';
  }
#line 727
  np->tio.c_cc[1] = (cc_t )'\000';
#line 728
  if (flow == 0) {
#line 732
    np->tio.c_cc[8] = (cc_t )'\000';
#line 737
    np->tio.c_cc[9] = (cc_t )'\000';
#line 740
    np->tio.c_iflag &= (unsigned int )(~ 1024);
  }
#line 744
  np->tio.c_cc[13] = (cc_t )'\000';
#line 749
  np->tio.c_cc[15] = (cc_t )'\000';
#line 759
  np->tio.c_cc[10] = (cc_t )'\000';
#line 764
  np->tio.c_cc[2] = (cc_t )'\000';
#line 769
  np->tio.c_cc[3] = (cc_t )'\000';
#line 787
  np->tio.c_cc[12] = (cc_t )'\000';
#line 792
  np->tio.c_cc[14] = (cc_t )'\000';
}
}
#line 820 "/tmp/screen-3.9.15/tty.c"
void SetFlow(int on ) 
{ 
  int tmp ;
  int __cil_tmp3 ;

  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  if (display->d_flow == on) {
#line 825
    return;
  }
#line 827
  if (on) {
#line 829
    if (iflag) {
#line 829
      tmp = (int )display->d_OldMode.tio.c_cc[0];
    } else {
#line 829
      tmp = '\000';
    }
#line 829
    display->d_NewMode.tio.c_cc[0] = (cc_t )tmp;
#line 832
    display->d_NewMode.tio.c_cc[8] = display->d_OldMode.tio.c_cc[8];
#line 837
    display->d_NewMode.tio.c_cc[9] = display->d_OldMode.tio.c_cc[9];
#line 840
    display->d_NewMode.tio.c_iflag |= display->d_OldMode.tio.c_iflag & 1024U;
  } else {
#line 844
    display->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 847
    display->d_NewMode.tio.c_cc[8] = (cc_t )'\000';
#line 852
    display->d_NewMode.tio.c_cc[9] = (cc_t )'\000';
#line 855
    display->d_NewMode.tio.c_iflag &= (unsigned int )(~ 1024);
  }
  {
#line 858
  __cil_tmp3 = tcsetattr(display->d_userfd, 0, & display->d_NewMode.tio);
  }
#line 858
  if (__cil_tmp3) {
    {
#line 862
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 862
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 879
  display->d_flow = on;
}
}
#line 884 "/tmp/screen-3.9.15/tty.c"
int SttyMode(struct mode *m , char *opt ) 
{ 
  static char const   sep[] ;
  char *__cil_tmp4 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 888
  sep = " \t:;,";
#line 890
  if (! opt) {
#line 891
    return (0);
  }
  {
#line 893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 893
    if (! *opt) {
#line 893
      goto while_break;
    }
    {
#line 895
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 895
      if (! __cil_tmp4) {
#line 895
        goto while_break___0;
      }
#line 895
      opt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 896
    if ((int )*opt >= 48) {
#line 896
      if ((int )*opt <= 57) {
        {
#line 898
        __cil_tmp6 = atoi((char const   *)opt);
        }
        {
#line 898
        __cil_tmp7 = atoi((char const   *)opt);
#line 898
        __cil_tmp8 = SetBaud(m, __cil_tmp6, __cil_tmp7);
        }
#line 898
        if (__cil_tmp8) {
#line 899
          return (- 1);
        }
      } else {
#line 896
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 901
      __cil_tmp9 = strncmp((char const   *)((char *)"cs7"), (char const   *)opt, (unsigned long )3);
      }
#line 901
      if (! __cil_tmp9) {
#line 904
        m->tio.c_cflag &= (unsigned int )(~ 48);
#line 905
        m->tio.c_cflag |= (unsigned int )32;
      } else {
        {
#line 910
        __cil_tmp10 = strncmp((char const   *)((char *)"cs8"), (char const   *)opt,
                              (unsigned long )3);
        }
#line 910
        if (! __cil_tmp10) {
#line 913
          m->tio.c_cflag &= (unsigned int )(~ 48);
#line 914
          m->tio.c_cflag |= (unsigned int )48;
        } else {
          {
#line 919
          __cil_tmp11 = strncmp((char const   *)((char *)"istrip"), (char const   *)opt,
                                (unsigned long )6);
          }
#line 919
          if (! __cil_tmp11) {
#line 922
            m->tio.c_iflag |= (unsigned int )32;
          } else {
            {
#line 927
            __cil_tmp12 = strncmp((char const   *)((char *)"-istrip"), (char const   *)opt,
                                  (unsigned long )7);
            }
#line 927
            if (! __cil_tmp12) {
#line 930
              m->tio.c_iflag &= (unsigned int )(~ 32);
            } else {
              {
#line 935
              __cil_tmp13 = strncmp((char const   *)((char *)"ixon"), (char const   *)opt,
                                    (unsigned long )4);
              }
#line 935
              if (! __cil_tmp13) {
#line 938
                m->tio.c_iflag |= (unsigned int )1024;
              } else {
                {
#line 943
                __cil_tmp14 = strncmp((char const   *)((char *)"-ixon"), (char const   *)opt,
                                      (unsigned long )5);
                }
#line 943
                if (! __cil_tmp14) {
#line 946
                  m->tio.c_iflag &= (unsigned int )(~ 1024);
                } else {
                  {
#line 951
                  __cil_tmp15 = strncmp((char const   *)((char *)"ixoff"), (char const   *)opt,
                                        (unsigned long )5);
                  }
#line 951
                  if (! __cil_tmp15) {
#line 954
                    m->tio.c_iflag |= (unsigned int )4096;
                  } else {
                    {
#line 959
                    __cil_tmp16 = strncmp((char const   *)((char *)"-ixoff"), (char const   *)opt,
                                          (unsigned long )6);
                    }
#line 959
                    if (! __cil_tmp16) {
#line 962
                      m->tio.c_iflag &= (unsigned int )(~ 4096);
                    } else {
                      {
#line 967
                      __cil_tmp17 = strncmp((char const   *)((char *)"crtscts"), (char const   *)opt,
                                            (unsigned long )7);
                      }
#line 967
                      if (! __cil_tmp17) {
#line 970
                        m->tio.c_cflag |= 2147483648U;
                      } else {
                        {
#line 973
                        __cil_tmp18 = strncmp((char const   *)((char *)"-crtscts"),
                                              (char const   *)opt, (unsigned long )8);
                        }
#line 973
                        if (! __cil_tmp18) {
#line 976
                          m->tio.c_cflag &= ~ 2147483648U;
                        } else {
#line 980
                          return (- 1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 981
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 981
      if (! ((int )*opt && ! __cil_tmp19)) {
#line 981
        goto while_break___1;
      }
#line 981
      opt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  return (0);
}
}
#line 995 "/tmp/screen-3.9.15/tty.c"
void brktty(int fd ) 
{ 


  {
#line 999
  if (separate_sids) {
    {
#line 1000
    setsid();
    }
  }
}
}
#line 1025 "/tmp/screen-3.9.15/tty.c"
int fgtty(int fd ) 
{ 
  int mypid ;
  int __cil_tmp4 ;

  {
  {
#line 1031
  mypid = getpid();
  }
#line 1048
  if (separate_sids) {
    {
#line 1049
    __cil_tmp4 = tcsetpgrp(fd, mypid);
    }
#line 1049
    if (__cil_tmp4) {
      {
#line 1051
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1051
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1052
      return (- 1);
    }
  }
#line 1064
  return (0);
}
}
#line 1073 "/tmp/screen-3.9.15/tty.c"
int breaktype  =    2;
#line 1094 "/tmp/screen-3.9.15/tty.c"
static void DoSendBreak(int fd , int n , int type ) 
{ 
  int i ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;
  int i___0 ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  int tmp ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;

  {
  {
#line 1099
  if (type == 2) {
#line 1099
    goto case_2;
  }
#line 1141
  if (type == 1) {
#line 1141
    goto case_1;
  }
#line 1165
  if (type == 0) {
#line 1165
    goto case_0;
  }
#line 1188
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1126
  if (! n) {
#line 1127
    n ++;
  }
#line 1128
  i = 0;
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! (i < n)) {
#line 1128
      goto while_break___0;
    }
    {
#line 1129
    __cil_tmp6 = tcsendbreak(fd, 0);
    }
#line 1129
    if (__cil_tmp6 < 0) {
      {
#line 1131
      __cil_tmp7 = __errno_location();
#line 1131
      Msg(*__cil_tmp7, (char *)"cannot send BREAK (tcsendbreak SVR4)");
      }
#line 1132
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1128
  i ++;
#line 1139
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1143
  if (! n) {
#line 1144
    n ++;
  }
  {
#line 1149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1149
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1153
  i___0 = 0;
  {
#line 1153
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1153
    if (! (i___0 < n)) {
#line 1153
      goto while_break___2;
    }
    {
#line 1154
    __cil_tmp11 = ioctl(fd, (unsigned long )21513, (char *)0);
    }
#line 1154
    if (__cil_tmp11 < 0) {
      {
#line 1156
      __cil_tmp12 = __errno_location();
#line 1156
      Msg(*__cil_tmp12, (char *)"Cannot send BREAK (TCSBRK)");
      }
#line 1157
      return;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1153
  i___0 ++;
#line 1163
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1171
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1171
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1172
  __cil_tmp14 = ioctl(fd, (unsigned long )21543, (char *)0);
  }
#line 1172
  if (__cil_tmp14 < 0) {
    {
#line 1174
    __cil_tmp15 = __errno_location();
#line 1174
    Msg(*__cil_tmp15, (char *)"Can\'t send BREAK (TIOCSBRK)");
    }
#line 1175
    return;
  }
#line 1177
  if (n) {
#line 1177
    tmp = n * 250;
  } else {
#line 1177
    tmp = 250;
  }
  {
#line 1177
  sleep1000(tmp);
#line 1178
  __cil_tmp17 = ioctl(fd, (unsigned long )21544, (char *)0);
  }
#line 1178
  if (__cil_tmp17 < 0) {
    {
#line 1180
    __cil_tmp18 = __errno_location();
#line 1180
    Msg(*__cil_tmp18, (char *)"BREAK stuck!!! -- HELP! (TIOCCBRK)");
    }
#line 1181
    return;
  }
#line 1186
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1189
  Msg(0, (char *)"Internal SendBreak error: method %d unknown", type);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1199 "/tmp/screen-3.9.15/tty.c"
void SendBreak(struct win *wp , int n , int closeopen ) 
{ 
  void (*sigalrm)(int  ) ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp8 ;

  {
#line 1212
  if (wp->w_type != 1) {
#line 1213
    return;
  }
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1218
  __cil_tmp5 = tcflush(wp->w_ptyfd, 2);
  }
#line 1225
  if (closeopen) {
    {
#line 1227
    close(wp->w_ptyfd);
    }
#line 1228
    if (n) {
#line 1228
      tmp = n * 250;
    } else {
#line 1228
      tmp = 250;
    }
    {
#line 1228
    sleep1000(tmp);
#line 1229
    wp->w_ptyfd = OpenTTY((char *)wp->w_tty, wp->w_cmdargs[1]);
    }
#line 1229
    if (wp->w_ptyfd < 1) {
      {
#line 1231
      Msg(0, (char *)"Ouch, cannot reopen line %s, please try harder", (char *)wp->w_tty);
      }
#line 1232
      return;
    }
    {
#line 1234
    __cil_tmp8 = fcntl(wp->w_ptyfd, 4, 2048);
    }
  } else {
    {
#line 1238
    sigalrm = xsignal(14, (void (*)(int  ))SigAlrmDummy);
#line 1239
    alarm((unsigned int )15);
#line 1241
    DoSendBreak(wp->w_ptyfd, n, breaktype);
#line 1243
    alarm((unsigned int )0);
#line 1244
    xsignal(14, sigalrm);
    }
  }
  {
#line 1246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1246
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1255
static struct event consredir_ev ;
#line 1256 "/tmp/screen-3.9.15/tty.c"
static int consredirfd[2]  = {      - 1,      - 1};
#line 1259 "/tmp/screen-3.9.15/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  char *n ;
  char buf[256] ;
  int l ;
  ssize_t __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1266
  __cil_tmp7 = read(consredirfd[0], (void *)((char *)buf), sizeof(buf));
#line 1266
  l = (int )__cil_tmp7;
  }
#line 1266
  if (! console_window) {
    {
    {
#line 1268
    close(consredirfd[0]);
    }
    {
#line 1269
    close(consredirfd[1]);
    }
#line 1270
    consredirfd[1] = - 1;
#line 1270
    consredirfd[0] = consredirfd[1];
    {
#line 1271
    evdeq(ev);
    }
    }
#line 1272
    return;
  } else
#line 1266
  if (l <= 0) {
    {
    {
#line 1268
    close(consredirfd[0]);
    }
    {
#line 1269
    close(consredirfd[1]);
    }
#line 1270
    consredirfd[1] = - 1;
#line 1270
    consredirfd[0] = consredirfd[1];
    {
#line 1271
    evdeq(ev);
    }
    }
#line 1272
    return;
  }
#line 1274
  n = (char *)buf;
#line 1274
  p = n;
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1274
    if (! (l > 0)) {
#line 1274
      goto while_break;
    }
#line 1275
    if ((int )*n == 10) {
#line 1277
      if (n > p) {
        {
#line 1278
        WriteString(console_window, p, (int )(n - p));
        }
      }
      {
#line 1279
      WriteString(console_window, (char *)"\r\n", 2);
#line 1280
      p = n + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1274
  __cil_tmp9 = l;
#line 1274
  l --;
#line 1274
  __cil_tmp8 = n;
#line 1274
  n ++;
#line 1282
  if (n > p) {
    {
#line 1283
    WriteString(console_window, p, (int )(n - p));
    }
  }
}
}
#line 1290 "/tmp/screen-3.9.15/tty.c"
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) 
{ 
  struct display *d ;
  struct mode new1 ;
  struct mode new2 ;
  char *slave ;
  int __cil_tmp8 ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int *__cil_tmp16 ;

  {
#line 1355
  if (on > 0) {
#line 1357
    if (displays == (struct display *)0) {
      {
#line 1359
      Msg(0, (char *)"I need a display");
      }
#line 1360
      return (- 1);
    }
#line 1362
    d = displays;
    {
#line 1362
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1362
      if (! d) {
#line 1362
        goto while_break;
      }
      {
#line 1363
      __cil_tmp8 = strcmp((char const   *)((char *)d->d_usertty), (char const   *)((char *)"/dev/console"));
      }
#line 1363
      if (__cil_tmp8 == 0) {
#line 1364
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1362
    d = d->d_next;
#line 1365
    if (d) {
      {
#line 1367
      Msg(0, (char *)"too dangerous - screen is running on /dev/console");
      }
#line 1368
      return (- 1);
    }
  }
#line 1371
  if (consredirfd[0] >= 0) {
    {
#line 1373
    evdeq(& consredir_ev);
#line 1374
    close(consredirfd[0]);
#line 1375
    close(consredirfd[1]);
#line 1376
    consredirfd[1] = - 1;
#line 1376
    consredirfd[0] = consredirfd[1];
    }
  }
#line 1378
  if (on <= 0) {
#line 1379
    return (0);
  }
  {
#line 1405
  consredirfd[0] = OpenPTY(& slave);
  }
#line 1405
  if (consredirfd[0] < 0) {
    {
#line 1407
    __cil_tmp10 = __errno_location();
#line 1407
    Msg(*__cil_tmp10, (char *)"%s: could not open detach pty master", rc_name___0);
    }
#line 1408
    return (- 1);
  }
  {
#line 1410
  consredirfd[1] = open((char const   *)slave, 258);
  }
#line 1410
  if (consredirfd[1] < 0) {
    {
#line 1412
    __cil_tmp12 = __errno_location();
#line 1412
    Msg(*__cil_tmp12, (char *)"%s: could not open detach pty slave", rc_name___0);
#line 1413
    close(consredirfd[0]);
    }
#line 1414
    return (- 1);
  }
  {
#line 1416
  InitTTY(& new1, 0);
#line 1417
  SetMode(& new1, & new2, 0, 0);
#line 1418
  SetTTY(consredirfd[1], & new2);
#line 1419
  __cil_tmp13 = UserContext();
  }
#line 1419
  if (__cil_tmp13 == 1) {
    {
#line 1420
    __cil_tmp14 = ioctl(consredirfd[1], (unsigned long )21533, (char *)(& on));
#line 1420
    UserReturn(__cil_tmp14);
    }
  }
  {
#line 1421
  __cil_tmp15 = UserStatus();
  }
#line 1421
  if (__cil_tmp15) {
    {
#line 1423
    __cil_tmp16 = __errno_location();
#line 1423
    Msg(*__cil_tmp16, (char *)"%s: ioctl TIOCCONS failed", rc_name___0);
#line 1424
    close(consredirfd[0]);
#line 1425
    close(consredirfd[1]);
    }
#line 1426
    return (- 1);
  }
  {
#line 1429
  consredir_ev.fd = consredirfd[0];
#line 1430
  consredir_ev.type = 1;
#line 1431
  consredir_ev.handler = (void (*)(struct event * , char * ))consredir_readev_fn;
#line 1432
  evenq(& consredir_ev);
  }
#line 1433
  return (0);
}
}
#line 1449 "/tmp/screen-3.9.15/tty.c"
char *TtyGetModemStatus(int fd , char *buf ) 
{ 
  char *p ;
  unsigned int softcar ;
  unsigned int mflags ;
  struct mode mtio ;
  int rtscts ;
  int clocal ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *tmp ;
  size_t __cil_tmp13 ;
  char *s ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1453
  p = buf;
#line 1492
  GetTTY(fd, & mtio);
#line 1494
  clocal = 0;
  }
#line 1496
  if (mtio.tio.c_cflag & 2048U) {
#line 1498
    clocal = 1;
#line 1499
    __cil_tmp9 = p;
#line 1499
    p ++;
#line 1499
    *__cil_tmp9 = (char )'{';
  }
#line 1505
  if (! (mtio.tio.c_cflag & 2147483648U)) {
#line 1506
    rtscts = 0;
  } else {
#line 1509
    rtscts = 1;
  }
  {
#line 1513
  __cil_tmp10 = ioctl(fd, (unsigned long )21529, (char *)(& softcar));
  }
#line 1513
  if (__cil_tmp10 < 0) {
#line 1514
    softcar = (unsigned int )0;
  }
  {
#line 1519
  __cil_tmp11 = ioctl(fd, (unsigned long )21525, (char *)(& mflags));
  }
#line 1519
  if (__cil_tmp11 < 0) {
#line 1529
    if (softcar) {
#line 1529
      tmp = (char *)"(CD)";
    } else {
#line 1529
      tmp = (char *)"CD";
    }
    {
#line 1529
    sprintf(p, (char const   *)((char *)"NO-TTY? %s"), tmp);
#line 1533
    __cil_tmp13 = strlen((char const   *)p);
    }
#line 1533
    p += __cil_tmp13;
  } else {
#line 1546
    s = (char *)"!RTS ";
#line 1546
    if (mflags & 4U) {
#line 1546
      s ++;
    }
    {
#line 1547
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1547
      if (! *s) {
#line 1547
        goto while_break;
      }
#line 1547
      __cil_tmp17 = s;
#line 1547
      s ++;
#line 1547
      __cil_tmp16 = p;
#line 1547
      p ++;
#line 1547
      *__cil_tmp16 = *__cil_tmp17;
    }
    while_break: /* CIL Label */ ;
    }
#line 1550
    s = (char *)"!CTS ";
#line 1551
    if (! rtscts) {
#line 1553
      __cil_tmp18 = p;
#line 1553
      p ++;
#line 1553
      *__cil_tmp18 = (char )'(';
#line 1554
      s = (char *)"!CTS) ";
    }
#line 1556
    if (mflags & 32U) {
#line 1556
      s ++;
    }
    {
#line 1557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1557
      if (! *s) {
#line 1557
        goto while_break___0;
      }
#line 1557
      __cil_tmp21 = s;
#line 1557
      s ++;
#line 1557
      __cil_tmp20 = p;
#line 1557
      p ++;
#line 1557
      *__cil_tmp20 = *__cil_tmp21;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1561
    s = (char *)"!DTR ";
#line 1561
    if (mflags & 2U) {
#line 1561
      s ++;
    }
    {
#line 1562
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1562
      if (! *s) {
#line 1562
        goto while_break___1;
      }
#line 1562
      __cil_tmp24 = s;
#line 1562
      s ++;
#line 1562
      __cil_tmp23 = p;
#line 1562
      p ++;
#line 1562
      *__cil_tmp23 = *__cil_tmp24;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1565
    s = (char *)"!DSR ";
#line 1565
    if (mflags & 256U) {
#line 1565
      s ++;
    }
    {
#line 1566
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1566
      if (! *s) {
#line 1566
        goto while_break___2;
      }
#line 1566
      __cil_tmp27 = s;
#line 1566
      s ++;
#line 1566
      __cil_tmp26 = p;
#line 1566
      p ++;
#line 1566
      *__cil_tmp26 = *__cil_tmp27;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1569
    s = (char *)"!CD ";
#line 1571
    if (softcar) {
#line 1573
      __cil_tmp28 = p;
#line 1573
      p ++;
#line 1573
      *__cil_tmp28 = (char )'(';
#line 1574
      s = (char *)"!CD) ";
    }
#line 1578
    if (mflags & 64U) {
#line 1578
      s ++;
    }
    {
#line 1582
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1582
      if (! *s) {
#line 1582
        goto while_break___3;
      }
#line 1582
      __cil_tmp31 = s;
#line 1582
      s ++;
#line 1582
      __cil_tmp30 = p;
#line 1582
      p ++;
#line 1582
      *__cil_tmp30 = *__cil_tmp31;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1586
    if (mflags & 128U) {
#line 1590
      s = (char *)"RI ";
      {
#line 1590
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1590
        if (! *s) {
#line 1590
          goto while_break___4;
        }

      }
      while_break___4: /* CIL Label */ ;
      }
#line 1590
      __cil_tmp33 = s;
#line 1590
      s ++;
#line 1590
      __cil_tmp32 = p;
#line 1590
      p ++;
#line 1590
      *__cil_tmp32 = *__cil_tmp33;
    }
#line 1602
    if (p > buf) {
#line 1602
      if ((int )*(p + -1) == 32) {
#line 1603
        __cil_tmp34 = p;
#line 1603
        p --;
      }
    }
#line 1604
    *p = (char )'\000';
  }
#line 1612
  if (clocal) {
#line 1613
    __cil_tmp35 = p;
#line 1613
    p ++;
#line 1613
    *__cil_tmp35 = (char )'}';
  }
#line 1614
  *p = (char )'\000';
#line 1615
  return (buf);
}
}
#line 1684 "/tmp/screen-3.9.15/tty.c"
static struct baud_values btable[]  = 
#line 1684
  {      {13, 9600, 13}, 
        {14, 19200, 14}, 
        {14, 19200, 14}, 
        {15, 38400, 15}, 
        {15, 38400, 15}, 
        {16, 57600, 4097}, 
        {17, 115200, 4098}, 
        {18, 230400, 4099}, 
        {19, 460800, 4100}, 
        {12, 4800, 12}, 
        {11, 2400, 11}, 
        {10, 1800, 10}, 
        {9, 1200, 9}, 
        {8, 600, 8}, 
        {7, 300, 7}, 
        {6, 200, 6}, 
        {5, 150, 5}, 
        {4, 134, 4}, 
        {3, 110, 3}, 
        {2, 75, 2}, 
        {1, 50, 1}, 
        {0, 0, 0}, 
        {- 1, - 1, - 1}};
#line 1769 "/tmp/screen-3.9.15/tty.c"
struct baud_values *lookup_baud(int baud ) 
{ 
  struct baud_values *p ;

  {
#line 1774
  p = (struct baud_values *)btable;
  {
#line 1774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1774
    if (! (p->idx >= 0)) {
#line 1774
      goto while_break;
    }
#line 1775
    if (baud == p->bps) {
#line 1776
      return (p);
    } else
#line 1775
    if (baud == p->sym) {
#line 1776
      return (p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1774
  p ++;
#line 1777
  return ((struct baud_values *)((void *)0));
}
}
#line 1787 "/tmp/screen-3.9.15/tty.c"
int SetBaud(struct mode *m , int ibaud , int obaud ) 
{ 
  struct baud_values *ip ;
  struct baud_values *op ;

  {
  {
#line 1793
  op = lookup_baud(obaud);
  }
  {
#line 1793
  ip = lookup_baud(ibaud);
  }
#line 1793
  if (! ip) {
#line 1793
    if (ibaud != -1) {
#line 1795
      return (- 1);
    } else {
#line 1793
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1793
  if (! op) {
#line 1793
    if (obaud != -1) {
#line 1795
      return (- 1);
    }
  }
#line 1798
  if (ip) {
    {
#line 1798
    cfsetispeed(& m->tio, (speed_t )ip->sym);
    }
  }
#line 1799
  if (op) {
    {
#line 1799
    cfsetospeed(& m->tio, (speed_t )op->sym);
    }
  }
#line 1822
  return (0);
}
}
#line 104 "./extern.h"
void revto_line(int tx , int ty , int line ) ;
#line 105
void revto(int tx , int ty ) ;
#line 111
void Search(int dir ) ;
#line 112
void ISearch(int dir ) ;
#line 47 "/tmp/screen-3.9.15/search.c"
static int matchword(char *pattern , int y , int sx , int ex ) ;
#line 48
static void searchend(char *buf , int len , char *data ) ;
#line 49
static void backsearchend(char *buf , int len , char *data ) ;
#line 52 "/tmp/screen-3.9.15/search.c"
void Search(int dir ) 
{ 
  struct markdata *markdata___0 ;
  char *tmp ;
  void tmp___330(char * , int  , char * ) ;

  {
#line 56
  if (dir == 0) {
#line 58
    markdata___0 = (struct markdata *)flayer->l_data;
#line 59
    if (markdata___0->isdir > 0) {
      {
#line 60
      searchend((char *)0, 0, (char *)((void *)0));
      }
    } else
#line 61
    if (markdata___0->isdir < 0) {
      {
#line 62
      backsearchend((char *)0, 0, (char *)((void *)0));
      }
    } else {
      {
#line 64
      LMsg(0, (char *)"No previous pattern");
      }
    }
  } else {
#line 67
    if (dir > 0) {
#line 67
      tmp = (char *)"/";
    } else {
#line 67
      tmp = (char *)"?";
    }
#line 67
    if (dir > 0) {
#line 67
      tmp___330 = searchend;
    } else {
#line 67
      tmp___330 = backsearchend;
    }
    {
#line 67
    Input(tmp, (int )(sizeof(markdata___0->isstr) - 1UL), 0, tmp___330, (char *)((void *)0));
    }
  }
}
}
#line 72 "/tmp/screen-3.9.15/search.c"
static void searchend(char *buf , int len , char *data ) 
{ 
  int x ;
  int sx ;
  int ex ;
  int y ;
  struct markdata *markdata___0 ;
  struct win *p ;
  int __cil_tmp11 ;

  {
#line 77
  x = 0;
#line 81
  markdata___0 = (struct markdata *)flayer->l_data;
#line 82
  p = markdata___0->md_window;
#line 83
  markdata___0->isdir = 1;
#line 84
  if (len) {
    {
#line 85
    strcpy((char *)markdata___0->isstr, (char const   *)buf);
    }
  }
#line 86
  sx = markdata___0->cx + 1;
#line 87
  ex = flayer->l_width - 1;
#line 88
  y = markdata___0->cy;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (y < p->w_histheight + flayer->l_height)) {
#line 88
      goto while_break;
    }
    {
#line 90
    x = matchword((char *)markdata___0->isstr, y, sx, ex);
    }
#line 90
    if (x >= 0) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  sx = 0;
#line 88
  __cil_tmp11 = y;
#line 88
  y ++;
#line 93
  if (y >= p->w_histheight + flayer->l_height) {
    {
#line 95
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 96
    LMsg(0, (char *)"Pattern not found");
    }
  } else {
    {
#line 99
    revto(x, y);
    }
  }
}
}
#line 103 "/tmp/screen-3.9.15/search.c"
static void backsearchend(char *buf , int len , char *data ) 
{ 
  int sx ;
  int ex ;
  int x ;
  int y ;
  struct markdata *markdata___0 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 108
  x = - 1;
#line 111
  markdata___0 = (struct markdata *)flayer->l_data;
#line 112
  markdata___0->isdir = - 1;
#line 113
  if (len) {
    {
#line 114
    strcpy((char *)markdata___0->isstr, (char const   *)buf);
    }
  }
#line 115
  ex = markdata___0->cx - 1;
#line 116
  y = markdata___0->cy;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (y >= 0)) {
#line 116
      goto while_break;
    }
#line 118
    sx = 0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! (sx >= 0)) {
#line 119
        goto while_break___0;
      }
#line 120
      __cil_tmp10 = sx;
#line 120
      sx ++;
#line 120
      x = __cil_tmp10;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    if (x >= 0) {
#line 122
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  ex = flayer->l_width - 1;
#line 116
  __cil_tmp11 = y;
#line 116
  y --;
#line 124
  if (y < 0) {
    {
#line 126
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 127
    LMsg(0, (char *)"Pattern not found");
    }
  } else {
    {
#line 130
    revto(x, y);
    }
  }
}
}
#line 134 "/tmp/screen-3.9.15/search.c"
static int matchword(char *pattern , int y , int sx , int ex ) 
{ 
  unsigned char *ip ;
  unsigned char *ipe ;
  unsigned char *cp ;
  unsigned char *pp ;
  struct mline *ml ;
  struct mline *tmp ;
  unsigned char *__cil_tmp11 ;

  {
#line 142
  fore = ((struct markdata *)flayer->l_data)->md_window;
#line 144
  if (y < fore->w_histheight) {
#line 144
    tmp = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 144
    tmp = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 144
  ml = tmp;
#line 145
  ip = ml->image + sx;
#line 146
  ipe = ml->image + flayer->l_width;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (sx <= ex)) {
#line 147
      goto while_break;
    }
#line 149
    __cil_tmp11 = ip;
#line 149
    ip ++;
#line 149
    cp = __cil_tmp11;
#line 150
    pp = (unsigned char *)pattern;
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 151
      if (! 1) {
#line 151
        goto while_break___0;
      }
#line 153
      if ((int )*cp != (int )*pp) {
#line 154
        if (! search_ic) {
#line 155
          goto while_break___0;
        } else
#line 154
        if (((int )*cp ^ (int )*pp) & 223) {
#line 155
          goto while_break___0;
        } else
#line 154
        if (((int )*cp | 32) < 97) {
#line 155
          goto while_break___0;
        } else
#line 154
        if (((int )*cp | 32) > 122) {
#line 155
          goto while_break___0;
        }
      }
#line 156
      cp ++;
#line 157
      pp ++;
#line 158
      if ((int )*pp == 0) {
#line 159
        return (sx);
      }
#line 160
      if (cp == ipe) {
#line 161
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  sx ++;
#line 164
  return (- 1);
}
}
#line 172 "/tmp/screen-3.9.15/search.c"
static char *isprompts[]  = {      (char *)"I-search backward: ",      (char *)"failing I-search backward: ",      (char *)"I-search: ",      (char *)"failing I-search: "};
#line 178
static int is_redo(struct markdata *markdata___0 ) ;
#line 179
static void is_process(char *p , int n , char *data ) ;
#line 180
static int is_bm(char *str , int l , int p , int end , int dir ) ;
#line 184 "/tmp/screen-3.9.15/search.c"
static int is_bm(char *str , int l , int p , int end , int dir ) 
{ 
  int tab[256] ;
  int i ;
  int q ;
  unsigned char *s ;
  unsigned char c ;
  int w ;
  int __cil_tmp13 ;
  struct mline *tmp ;
  int tmp___331 ;

  {
#line 191
  w = flayer->l_width;
#line 194
  fore = ((struct markdata *)(flayer->l_next)->l_data)->md_window;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 197
  if (p < 0) {
#line 198
    return (- 1);
  } else
#line 197
  if (p + l > end) {
#line 198
    return (- 1);
  }
#line 199
  if (l == 0) {
#line 200
    return (p);
  }
#line 201
  if (dir < 0) {
#line 202
    str += l - 1;
  }
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (! (i < 256)) {
#line 203
      goto while_break___1;
    }
#line 204
    tab[i] = l * dir;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 203
  i ++;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 205
    if (! (i < l - 1)) {
#line 205
      goto while_break___2;
    }
#line 207
    q = (int )*((unsigned char *)str);
#line 208
    tab[q] = ((l - 1) - i) * dir;
#line 209
    if (search_ic) {
#line 209
      if ((q | 32) >= 97) {
#line 209
        if ((q | 32) <= 122) {
#line 210
          tab[q ^ 32] = ((l - 1) - i) * dir;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 205
  str += dir;
#line 205
  __cil_tmp13 = i;
#line 205
  i ++;
#line 212
  if (dir > 0) {
#line 213
    p += l - 1;
  }
  {
#line 214
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 214
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 215
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 215
    if (! (p >= 0 && p < end)) {
#line 215
      goto while_break___4;
    }
#line 217
    q = p;
#line 218
    s = (unsigned char *)str;
#line 219
    i = 0;
    {
#line 219
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 219
      if (! 1) {
#line 219
        goto while_break___5;
      }
#line 221
      c = *(tmp->image + q % w);
#line 222
      if (i == 0) {
#line 223
        p += tab[(int )c];
      }
#line 224
      if ((int )c != (int )*s) {
#line 225
        if (! search_ic) {
#line 226
          goto while_break___5;
        } else
#line 225
        if (((int )c ^ (int )*s) & 223) {
#line 226
          goto while_break___5;
        } else
#line 225
        if (((int )c | 32) < 97) {
#line 226
          goto while_break___5;
        } else
#line 225
        if (((int )c | 32) > 122) {
#line 226
          goto while_break___5;
        }
      }
#line 227
      q -= dir;
#line 228
      s -= dir;
#line 229
      i ++;
#line 229
      if (i == l) {
#line 230
        if (dir > 0) {
#line 230
          tmp___331 = 1;
        } else {
#line 230
          tmp___331 = - l;
        }
#line 230
        return (q + tmp___331);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 233
  return (- 1);
}
}
#line 239 "/tmp/screen-3.9.15/search.c"
static void is_process(char *p , int n , char *data ) 
{ 
  int pos ;
  int x ;
  int y ;
  int dir ;
  struct markdata *markdata___0 ;
  int __cil_tmp9 ;
  int tmp ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 247
  if (n == 0) {
#line 248
    return;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  markdata___0 = (struct markdata *)(flayer->l_next)->l_data;
#line 252
  pos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 253
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
  }
  {
#line 257
  if ((int )*p == '\a') {
#line 257
    goto case_7;
  }
#line 260
  if ((int )*p == '\033') {
#line 260
    goto case_27;
  }
#line 264
  if ((int )*p == '\027') {
#line 264
    goto case_23;
  }
#line 264
  if ((int )*p == '\v') {
#line 264
    goto case_23;
  }
#line 268
  if ((int )*p == '\177') {
#line 268
    goto case_127;
  }
#line 268
  if ((int )*p == '\b') {
#line 268
    goto case_127;
  }
#line 276
  if ((int )*p == '\022') {
#line 276
    goto case_18;
  }
#line 276
  if ((int )*p == '\023') {
#line 276
    goto case_18;
  }
#line 290
  goto switch_default;
  case_7: /* CIL Label */ 
#line 258
  pos = markdata___0->isstartpos;
  case_27: /* CIL Label */ 
#line 261
  *p = (char )0;
#line 262
  goto switch_break;
  case_23: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 265
  markdata___0->isistrl = 1;
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 269
  if (markdata___0->isistrl == 0) {
#line 270
    return;
  }
  {
#line 271
  __cil_tmp9 = markdata___0->isistrl;
#line 271
  (markdata___0->isistrl) --;
#line 272
  pos = is_redo(markdata___0);
#line 273
  *p = (char )'\b';
  }
#line 274
  goto switch_break;
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 277
  if ((unsigned long )markdata___0->isistrl >= sizeof(markdata___0->isistr)) {
#line 278
    return;
  }
#line 279
  if ((int )*p == 19) {
#line 279
    tmp = 1;
  } else {
#line 279
    tmp = - 1;
  }
#line 279
  dir = tmp;
#line 280
  pos += dir;
#line 281
  if (markdata___0->isdir == dir) {
#line 281
    if (markdata___0->isistrl == 0) {
      {
#line 283
      strcpy((char *)markdata___0->isistr, (char const   *)((char *)markdata___0->isstr));
#line 284
      __cil_tmp12 = strlen((char const   *)((char *)markdata___0->isstr));
#line 284
      markdata___0->isstrl = (int )__cil_tmp12;
#line 284
      markdata___0->isistrl = markdata___0->isstrl;
      }
#line 285
      goto switch_break;
    }
  }
#line 287
  markdata___0->isdir = dir;
#line 288
  __cil_tmp13 = markdata___0->isistrl;
#line 288
  (markdata___0->isistrl) ++;
#line 288
  markdata___0->isistr[__cil_tmp13] = *p;
#line 289
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 291
  if ((int )*p < 32) {
#line 293
    return;
  } else
#line 291
  if ((unsigned long )markdata___0->isistrl >= sizeof(markdata___0->isistr)) {
#line 293
    return;
  } else
#line 291
  if ((unsigned long )markdata___0->isstrl >= sizeof(markdata___0->isstr) - 1UL) {
#line 293
    return;
  }
#line 294
  __cil_tmp14 = markdata___0->isstrl;
#line 294
  (markdata___0->isstrl) ++;
#line 294
  markdata___0->isstr[__cil_tmp14] = *p;
#line 295
  __cil_tmp15 = markdata___0->isistrl;
#line 295
  (markdata___0->isistrl) ++;
#line 295
  markdata___0->isistr[__cil_tmp15] = *p;
#line 296
  markdata___0->isstr[markdata___0->isstrl] = (char )0;
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 297
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 299
  if ((int )*p) {
#line 299
    if ((int )*p != 8) {
      {
#line 300
      pos = is_bm((char *)markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                  markdata___0->isdir);
      }
    }
  }
#line 301
  if (pos >= 0) {
#line 303
    x = pos % flayer->l_width;
#line 304
    y = pos / flayer->l_width;
    {
#line 305
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 305
      oldlay = flayer;
      {
#line 305
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 305
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 305
      flayer = flayer->l_next;
#line 305
      oldcvlist = flayer->l_cvlist;
      {
#line 305
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 305
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 305
      flayer->l_cvlist = oldlay->l_cvlist;
#line 305
      cv = flayer->l_cvlist;
      {
#line 305
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 305
        if (! cv) {
#line 305
          goto while_break___4;
        }
#line 305
        cv->c_layer = flayer;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 305
      cv = cv->c_lnext;
#line 305
      ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1,
                                                                                        0,
                                                                                        flayer->l_width - 1,
                                                                                        0);
#line 305
      revto(x, y);
      }
#line 305
      if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 305
        if (flayer->l_height - 1 > 0) {
#line 305
          tmp___0 = (flayer->l_height - 1) - 1;
        } else {
#line 305
          tmp___0 = 1;
        }
        {
#line 305
        revto_line(markdata___0->cx, markdata___0->cy, tmp___0);
        }
      }
#line 305
      flayer = oldlay;
#line 305
      cv = flayer->l_cvlist;
      {
#line 305
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 305
        if (! cv) {
#line 305
          goto while_break___5;
        }
#line 305
        cv->c_layer = flayer;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 305
      cv = cv->c_lnext;
#line 305
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 305
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 313
  if (*p) {
#line 314
    if (markdata___0->isstrl) {
#line 314
      tmp___1 = (char *)markdata___0->isstr;
    } else {
#line 314
      tmp___1 = (char *)"";
    }
    {
#line 314
    inp_setprompt(isprompts[(markdata___0->isdir + (pos < 0)) + 1], tmp___1);
    }
  }
  {
#line 315
  flayer->l_x = markdata___0->cx;
#line 316
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
#line 317
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 318
  if (! *p) {
#line 321
    (flayer->l_next)->l_x = markdata___0->cx;
#line 322
    (flayer->l_next)->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
}
}
#line 327 "/tmp/screen-3.9.15/search.c"
static int is_redo(struct markdata *markdata___0 ) 
{ 
  int i ;
  int pos ;
  int npos ;
  int dir ;
  char c ;
  int __cil_tmp7 ;

  {
#line 333
  pos = markdata___0->isstartpos;
#line 333
  npos = pos;
#line 334
  dir = markdata___0->isstartdir;
#line 335
  markdata___0->isstrl = 0;
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < markdata___0->isistrl)) {
#line 336
      goto while_break;
    }
#line 338
    c = markdata___0->isistr[i];
#line 339
    if ((int )c == 18) {
#line 340
      dir = - 1;
#line 340
      pos += dir;
    } else
#line 341
    if ((int )c == 19) {
#line 342
      dir = 1;
#line 342
      pos += dir;
    } else {
#line 344
      __cil_tmp7 = markdata___0->isstrl;
#line 344
      (markdata___0->isstrl) ++;
#line 344
      markdata___0->isstr[__cil_tmp7] = c;
    }
#line 345
    if (pos >= 0) {
      {
#line 347
      npos = is_bm((char *)markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                   dir);
      }
#line 348
      if (npos >= 0) {
#line 349
        pos = npos;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  i ++;
#line 352
  markdata___0->isstr[markdata___0->isstrl] = (char )0;
#line 353
  markdata___0->isdir = dir;
#line 354
  return (npos);
}
}
#line 358 "/tmp/screen-3.9.15/search.c"
void ISearch(int dir ) 
{ 
  struct markdata *markdata___0 ;
  int tmp ;

  {
#line 363
  markdata___0 = (struct markdata *)flayer->l_data;
#line 364
  markdata___0->isstartdir = dir;
#line 364
  markdata___0->isdir = markdata___0->isstartdir;
#line 365
  markdata___0->isstartpos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 366
  markdata___0->isstrl = 0;
#line 366
  markdata___0->isistrl = markdata___0->isstrl;
#line 367
  if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 368
    if (flayer->l_height - 1 > 0) {
#line 368
      tmp = (flayer->l_height - 1) - 1;
    } else {
#line 368
      tmp = 1;
    }
    {
#line 368
    revto_line(markdata___0->cx, markdata___0->cy, tmp);
    }
  }
  {
#line 369
  Input(isprompts[dir + 1], (int )(sizeof(markdata___0->isstr) - 1UL), 2, (void (*)(char * ,
                                                                                    int  ,
                                                                                    char * ))is_process,
        (char *)((void *)0));
#line 371
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 372
  flayer->l_x = markdata___0->cx;
#line 373
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
}
}
#line 346 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 828
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 32 "./extern.h"
void SigHup(int sigsig ) ;
#line 69
void StartRc(char *rcfilename ) ;
#line 321
int MakeServerSocket(void) ;
#line 322
int RecoverSocket(void) ;
#line 324
void ReceiveMsg(void) ;
#line 325
void SendCreateMsg(char *sty , struct NewWindow *nwin ) ;
#line 326
int SendErrorMsg(char *tty , char *buf ) ;
#line 51 "/tmp/screen-3.9.15/socket.c"
static int CheckPid(int pid ) ;
#line 52
static void ExecCreate(struct msg *mp ) ;
#line 53
static void DoCommandMsg(struct msg *mp ) ;
#line 58
static void FinishAttach(struct msg *m ) ;
#line 59
static void AskPassword(struct msg *m ) ;
#line 62
char *RcFileName ;
#line 63
int ServerSocket ;
#line 64
int lsflag ;
#line 64
int wipeflag ;
#line 77
struct event serv_read ;
#line 109 "/tmp/screen-3.9.15/socket.c"
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  struct stat st ;
  int mode ;
  int sdirlen ;
  int matchlen ;
  char *name ;
  char *n ;
  int firsts ;
  int sockfd ;
  char *firstn ;
  int nfound ;
  int ngood ;
  int ndead ;
  int nwipe ;
  int npriv ;
  struct sent *slist ;
  struct sent **slisttail ;
  struct sent *sent ;
  struct sent *nsent ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  int *__cil_tmp28 ;
  size_t __cil_tmp30 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  void *__cil_tmp39 ;
  int __cil_tmp44 ;
  int __cil_tmp48 ;
  char *tmp ;
  char *tmp___343 ;
  char *m ;
  char *tmp___344 ;
  char *tmp___345 ;
  char *tmp___346 ;

  {
#line 119
  matchlen = 0;
#line 121
  firsts = - 1;
#line 122
  firstn = (char *)((void *)0);
#line 123
  nfound = 0;
#line 123
  ngood = 0;
#line 123
  ndead = 0;
#line 123
  nwipe = 0;
#line 123
  npriv = 0;
#line 131
  if (match) {
    {
#line 133
    __cil_tmp25 = strlen((char const   *)match);
#line 133
    matchlen = (int )__cil_tmp25;
    }
#line 135
    if (matchlen > 255) {
#line 136
      matchlen = 255;
    }
  }
  {
#line 145
  __cil_tmp26 = strlen((char const   *)((char *)SockPath));
#line 145
  sdirlen = (int )__cil_tmp26;
#line 148
  xseteuid(real_uid);
#line 149
  xsetegid(real_gid);
#line 152
  dirp = opendir((char const   *)((char *)SockPath));
  }
#line 152
  if (dirp == (DIR *)0) {
    {
#line 153
    __cil_tmp28 = __errno_location();
#line 153
    Panic(*__cil_tmp28, (char *)"Cannot opendir %s", (char *)SockPath);
    }
  }
#line 155
  slist = (struct sent *)0;
#line 156
  slisttail = & slist;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! dp) {
#line 157
      goto while_break;
    }
#line 159
    name = (char *)dp->d_name;
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    __cil_tmp30 = strlen((char const   *)name);
    }
#line 161
    if ((int )*name == 0) {
#line 162
      goto while_continue;
    } else
#line 161
    if ((int )*name == 46) {
#line 162
      goto while_continue;
    } else
#line 161
    if (__cil_tmp30 > 512UL) {
#line 162
      goto while_continue;
    }
#line 163
    if (matchlen) {
#line 165
      n = name;
#line 167
      if ((int )*match <= 48) {
        _L: /* CIL Label */ 
#line 167
        if ((int )*n > 48) {
#line 167
          if ((int )*n <= 57) {
            {
#line 169
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 169
              if (! ((int )*n >= 48 && (int )*n <= 57)) {
#line 169
                goto while_break___1;
              }
#line 170
              n ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 171
            if ((int )*n == 46) {
#line 172
              n ++;
            }
          }
        }
      } else
#line 167
      if ((int )*match > 57) {
#line 167
        goto _L;
      }
      {
#line 175
      __cil_tmp34 = strncmp((char const   *)n, (char const   *)((char *)"tty"), (unsigned long )3);
      }
      {
#line 175
      __cil_tmp33 = strncmp((char const   *)match, (char const   *)((char *)"tty"),
                            (unsigned long )3);
      }
#line 175
      if (__cil_tmp33) {
#line 175
        if (__cil_tmp34 == 0) {
#line 176
          n += 3;
        }
      }
      {
#line 177
      __cil_tmp35 = strncmp((char const   *)match, (char const   *)n, (unsigned long )matchlen);
      }
#line 177
      if (__cil_tmp35) {
#line 178
        goto while_continue;
      }
      {
#line 179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 179
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 181
    sprintf((char *)SockPath + sdirlen, (char const   *)((char *)"/%s"), name);
    }
    {
#line 183
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 183
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 184
    __cil_tmp36 = __errno_location();
#line 184
    *__cil_tmp36 = 0;
    }
    {
#line 185
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 185
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 186
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 186
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 187
    __cil_tmp37 = stat((char const   *)((char *)SockPath), & st);
    }
#line 187
    if (__cil_tmp37) {
      {
#line 189
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 189
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 190
      goto while_continue;
    }
    {
#line 196
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 196
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 197
    if (! ((st.st_mode & 61440U) == 4096U)) {
#line 198
      goto while_continue;
    }
    {
#line 209
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 209
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 210
    if (st.st_uid != (unsigned int )real_uid) {
#line 211
      goto while_continue;
    }
#line 212
    mode = (int )st.st_mode & 511;
    {
#line 213
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 213
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 215
    if (multi) {
#line 215
      if ((mode & 447) != 385) {
        {
#line 217
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 217
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 218
        __cil_tmp38 = strcmp((char const   *)multi, (char const   *)LoginName);
        }
#line 218
        if (__cil_tmp38) {
          {
#line 220
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 220
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 221
          mode = - 4;
        } else {
          {
#line 225
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 225
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 229
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 229
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 230
    __cil_tmp39 = malloc(sizeof(struct sent ));
#line 230
    sent = (struct sent *)__cil_tmp39;
    }
#line 230
    if (sent == (struct sent *)0) {
#line 231
      goto while_continue;
    }
    {
#line 232
    sent->next = (struct sent *)0;
#line 233
    sent->name = SaveStr((char const   *)name);
#line 234
    sent->mode = mode;
#line 235
    *slisttail = sent;
#line 236
    slisttail = & sent->next;
#line 237
    nfound ++;
#line 238
    sockfd = MakeClientSocket(0);
#line 241
    xseteuid(real_uid);
#line 242
    xsetegid(real_gid);
    }
#line 244
    if (sockfd == -1) {
      {
#line 246
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 246
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 248
      sent->mode = - 3;
#line 262
      ndead ++;
#line 263
      sent->mode = - 1;
#line 264
      if (wipeflag) {
        {
#line 266
        __cil_tmp44 = unlink((char const   *)((char *)SockPath));
        }
#line 266
        if (__cil_tmp44 == 0) {
#line 268
          sent->mode = - 2;
#line 269
          nwipe ++;
        }
      }
#line 272
      goto while_continue;
    }
#line 275
    mode &= 510;
    {
#line 277
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 277
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 278
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 278
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 290
    if (mode != 448) {
#line 290
      if (mode != 384) {
        _L___332: /* CIL Label */ 
        {
#line 295
        close(sockfd);
        }
        {
#line 296
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 296
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 297
        npriv ++;
#line 298
        goto while_continue;
      } else {
#line 290
        goto _L___341;
      }
    } else
    _L___341: /* CIL Label */ 
#line 290
    if (dflag) {
#line 290
      if (! rflag) {
#line 290
        if (! xflag) {
#line 290
          if (mode == 384) {
#line 290
            goto _L___332;
          } else {
#line 290
            goto _L___338;
          }
        } else {
#line 290
          goto _L___338;
        }
      } else {
#line 290
        goto _L___338;
      }
    } else
    _L___338: /* CIL Label */ 
#line 290
    if (! dflag) {
#line 290
      if (rflag) {
#line 290
        if (mode == 448) {
#line 290
          if (! xflag) {
#line 290
            goto _L___332;
          } else {
#line 290
            goto _L___334;
          }
        } else {
#line 290
          goto _L___334;
        }
      } else {
#line 290
        goto _L___334;
      }
    } else
    _L___334: /* CIL Label */ 
#line 290
    if (! dflag) {
#line 290
      if (! rflag) {
#line 290
        if (! xflag) {
#line 290
          goto _L___332;
        }
      }
    }
#line 300
    ngood ++;
#line 301
    if (fdp) {
#line 301
      if (firsts == -1) {
#line 303
        firsts = sockfd;
#line 304
        firstn = sent->name;
        {
#line 305
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 305
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      } else {
#line 301
        goto _L___342;
      }
    } else {
      _L___342: /* CIL Label */ 
      {
#line 309
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 309
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 310
      close(sockfd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  __cil_tmp48 = closedir(dirp);
  }
#line 314
  if (nfound) {
#line 314
    if (lsflag) {
      _L___344: /* CIL Label */ 
#line 314
      if (! quietflag) {
        {
#line 318
        if (ngood == 0) {
#line 318
          goto case_0;
        }
#line 321
        if (ngood == 1) {
#line 321
          goto case_1;
        }
#line 324
        goto switch_default;
        case_0: /* CIL Label */ 
#line 319
        if (nfound > 1) {
#line 319
          tmp = (char *)"There are screens on:";
        } else {
#line 319
          tmp = (char *)"There is a screen on:";
        }
        {
#line 319
        Msg(0, tmp);
        }
#line 320
        goto switch_break;
        case_1: /* CIL Label */ 
#line 322
        if (nfound > 1) {
#line 322
          tmp___343 = (char *)"There are several screens on:";
        } else {
#line 322
          tmp___343 = (char *)"There is a suitable screen on:";
        }
        {
#line 322
        Msg(0, tmp___343);
        }
#line 323
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 325
        Msg(0, (char *)"There are several suitable screens on:");
        }
#line 326
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 328
        sent = slist;
        {
#line 328
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 328
          if (! sent) {
#line 328
            goto while_break___20;
          }
          {
#line 332
          if (sent->mode == 448) {
#line 332
            goto case_448;
          }
#line 335
          if (sent->mode == 384) {
#line 335
            goto case_384;
          }
#line 339
          if (sent->mode == 449) {
#line 339
            goto case_449;
          }
#line 342
          if (sent->mode == 385) {
#line 342
            goto case_385;
          }
#line 346
          if (sent->mode == - 1) {
#line 346
            goto case_exp;
          }
#line 350
          if (sent->mode == - 2) {
#line 350
            goto case_exp___0;
          }
#line 353
          if (sent->mode == - 3) {
#line 353
            goto case_exp___1;
          }
#line 356
          if (sent->mode == - 4) {
#line 356
            goto case_exp___2;
          }
#line 330
          goto switch_break___0;
          case_448: /* CIL Label */ 
          {
#line 333
          printf((char const   *)((char *)"\t%s\t(Attached)\n"), sent->name);
          }
#line 334
          goto switch_break___0;
          case_384: /* CIL Label */ 
          {
#line 336
          printf((char const   *)((char *)"\t%s\t(Detached)\n"), sent->name);
          }
#line 337
          goto switch_break___0;
          case_449: /* CIL Label */ 
          {
#line 340
          printf((char const   *)((char *)"\t%s\t(Multi, attached)\n"), sent->name);
          }
#line 341
          goto switch_break___0;
          case_385: /* CIL Label */ 
          {
#line 343
          printf((char const   *)((char *)"\t%s\t(Multi, detached)\n"), sent->name);
          }
#line 344
          goto switch_break___0;
          case_exp: /* CIL Label */ 
          {
#line 348
          printf((char const   *)((char *)"\t%s\t(Dead ?%c?)\n"), sent->name, '?');
          }
#line 349
          goto switch_break___0;
          case_exp___0: /* CIL Label */ 
          {
#line 351
          printf((char const   *)((char *)"\t%s\t(Removed)\n"), sent->name);
          }
#line 352
          goto switch_break___0;
          case_exp___1: /* CIL Label */ 
          {
#line 354
          printf((char const   *)((char *)"\t%s\t(Remote or dead)\n"), sent->name);
          }
#line 355
          goto switch_break___0;
          case_exp___2: /* CIL Label */ 
          {
#line 357
          printf((char const   *)((char *)"\t%s\t(Private)\n"), sent->name);
          }
#line 358
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
        while_break___20: /* CIL Label */ ;
        }
#line 328
        sent = sent->next;
      }
    } else
#line 314
    if (ngood != 1) {
#line 314
      goto _L___344;
    }
  }
#line 362
  if (ndead) {
#line 362
    if (! quietflag) {
#line 364
      m = (char *)"Remove dead screens with \'screen -wipe\'.";
#line 365
      if (wipeflag) {
#line 366
        if (nwipe > 1) {
#line 366
          tmp___344 = (char *)"s";
        } else {
#line 366
          tmp___344 = (char *)"";
        }
        {
#line 366
        Msg(0, (char *)"%d socket%s wiped out.", nwipe, tmp___344);
        }
      } else {
#line 368
        if (ndead > 1) {
#line 368
          tmp___345 = (char *)"s";
        } else {
#line 368
          tmp___345 = (char *)"";
        }
#line 368
        if (ndead > 1) {
#line 368
          tmp___346 = (char *)"";
        } else {
#line 368
          tmp___346 = (char *)"es";
        }
        {
#line 368
        Msg(0, m, tmp___345, tmp___346);
        }
      }
    }
  }
#line 370
  if (firsts != -1) {
    {
#line 372
    sprintf((char *)SockPath + sdirlen, (char const   *)((char *)"/%s"), firstn);
#line 373
    *fdp = firsts;
    }
  } else {
#line 376
    SockPath[sdirlen] = (char )0;
  }
#line 377
  sent = slist;
  {
#line 377
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 377
    if (! sent) {
#line 377
      goto while_break___21;
    }
    {
#line 379
    nsent = sent->next;
#line 380
    free((void *)sent->name);
#line 381
    free((void *)((char *)sent));
    }
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 377
  sent = nsent;
#line 384
  xseteuid(eff_uid);
#line 385
  xsetegid(eff_gid);
  }
#line 387
  if (notherp) {
#line 388
    *notherp = npriv;
  }
#line 389
  if (nfoundp) {
#line 390
    *nfoundp = nfound - nwipe;
  }
#line 391
  return (ngood);
}
}
#line 404 "/tmp/screen-3.9.15/socket.c"
int MakeServerSocket(void) 
{ 
  register int s ;
  struct stat st ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;
  int tmp___347 ;
  int __cil_tmp10 ;
  int *__cil_tmp12 ;

  {
  {
#line 410
  xseteuid(real_uid);
#line 411
  xsetegid(real_gid);
#line 413
  s = open((char const   *)((char *)SockPath), 2049);
  }
#line 413
  if (s >= 0) {
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 416
    if (quietflag) {
      {
#line 418
      Kill(display->d_userpid, 1);
#line 419
      eexit(11);
      }
    }
    {
#line 421
    __cil_tmp4 = Filename((char *)SockPath);
#line 421
    Msg(0, (char *)"There is already a screen running on %s.", __cil_tmp4);
#line 422
    __cil_tmp5 = stat((char const   *)((char *)SockPath), & st);
    }
#line 422
    if (__cil_tmp5 == -1) {
      {
#line 423
      __cil_tmp6 = __errno_location();
#line 423
      Panic(*__cil_tmp6, (char *)"stat");
      }
    }
#line 424
    if (st.st_uid != (unsigned int )real_uid) {
      {
#line 425
      Panic(0, (char *)"Unfortunatelly you are not its owner.");
      }
    }
#line 426
    if ((st.st_mode & 448U) == 384U) {
      {
#line 427
      Panic(0, (char *)"To resume it, use \"screen -r\"");
      }
    } else {
      {
#line 429
      Panic(0, (char *)"It is not detached.");
      }
    }
  }
  {
#line 433
  __cil_tmp7 = unlink((char const   *)((char *)SockPath));
  }
#line 434
  if (multi) {
#line 434
    tmp___347 = 1;
  } else {
#line 434
    tmp___347 = 0;
  }
#line 434
  if (displays) {
#line 434
    tmp = 64;
  } else {
#line 434
    tmp = 0;
  }
  {
#line 434
  __cil_tmp10 = mkfifo((char const   *)((char *)SockPath), (__mode_t )((384 | tmp) | tmp___347));
  }
#line 434
  if (__cil_tmp10) {
    {
#line 435
    Panic(0, (char *)"mkfifo %s failed", (char *)SockPath);
    }
  }
  {
#line 439
  s = open((char const   *)((char *)SockPath), 2048, 0);
  }
#line 439
  if (s < 0) {
    {
#line 441
    __cil_tmp12 = __errno_location();
#line 441
    Panic(*__cil_tmp12, (char *)"open fifo %s", (char *)SockPath);
    }
  }
  {
#line 442
  xseteuid(eff_uid);
#line 443
  xsetegid(eff_gid);
  }
#line 444
  return (s);
}
}
#line 465 "/tmp/screen-3.9.15/socket.c"
int MakeClientSocket(int err ) 
{ 
  register int s ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 468
  s = 0;
#line 470
  s = secopen((char *)SockPath, 2049, 0);
  }
#line 470
  if (s >= 0) {
    {
#line 472
    __cil_tmp4 = fcntl(s, 4, 0);
    }
#line 473
    return (s);
  }
#line 475
  if (err) {
    {
#line 476
    __cil_tmp5 = __errno_location();
#line 476
    Msg(*__cil_tmp5, (char *)"%s", (char *)SockPath);
    }
  }
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return (- 1);
}
}
#line 607 "/tmp/screen-3.9.15/socket.c"
void SendCreateMsg(char *sty , struct NewWindow *nwin ) 
{ 
  int s ;
  struct msg m ;
  register char *p ;
  register int len ;
  register int n ;
  char **av ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  char *__cil_tmp15 ;
  int *__cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  int *__cil_tmp18 ;

  {
  {
#line 615
  av = nwin->args;
#line 618
  __cil_tmp9 = strlen((char const   *)sty);
  }
#line 618
  if (__cil_tmp9 > 255UL) {
#line 619
    *(sty + 255) = (char )0;
  }
  {
#line 621
  __cil_tmp10 = strlen((char const   *)sty);
  }
#line 621
  if (__cil_tmp10 > 511UL) {
#line 622
    *(sty + 511) = (char )0;
  }
  {
#line 623
  __cil_tmp11 = strlen((char const   *)((char *)SockPath));
#line 623
  sprintf((char *)SockPath + __cil_tmp11, (char const   *)((char *)"/%s"), sty);
#line 624
  s = MakeClientSocket(1);
  }
#line 624
  if (s == -1) {
    {
#line 625
    exit(1);
    }
  }
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 627
  bzero((void *)((char *)(& m)), sizeof(m));
#line 628
  m.type = 0;
#line 629
  strncpy((char *)m.m_tty, (char const   *)attach_tty, sizeof(m.m_tty) - 1UL);
#line 630
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
#line 631
  p = (char *)m.m.create.line;
#line 632
  n = 0;
  }
#line 633
  if (nwin->args != nwin_undef.args) {
#line 634
    av = nwin->args;
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 634
      if (! (*av && n < 63)) {
#line 634
        goto while_break___0;
      }
      {
#line 636
      __cil_tmp13 = strlen((char const   *)*av);
#line 636
      len = (int )(__cil_tmp13 + 1UL);
      }
#line 637
      if (p + len >= ((char *)m.m.create.line + sizeof(m.m.create.line)) - 1) {
#line 638
        goto while_break___0;
      }
      {
#line 639
      strcpy(p, (char const   *)*av);
#line 640
      p += len;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 634
    n ++;
#line 634
    av ++;
  }
  {
#line 642
  __cil_tmp14 = strlen((char const   *)nwin->aka);
  }
#line 642
  if (nwin->aka != nwin_undef.aka) {
#line 642
    if ((p + __cil_tmp14) + 1 < (char *)m.m.create.line + sizeof(m.m.create.line)) {
      {
#line 643
      strcpy(p, (char const   *)nwin->aka);
      }
    } else {
#line 645
      *p = (char )'\000';
    }
  } else {
#line 645
    *p = (char )'\000';
  }
  {
#line 646
  m.m.create.nargs = n;
#line 647
  m.m.create.aflag = nwin->aflag;
#line 648
  m.m.create.flowflag = nwin->flowflag;
#line 649
  m.m.create.lflag = nwin->lflag;
#line 650
  m.m.create.hheight = nwin->histheight;
#line 651
  __cil_tmp15 = getcwd((char *)m.m.create.dir, sizeof(m.m.create.dir));
  }
#line 651
  if (__cil_tmp15 == (char *)0) {
    {
#line 653
    __cil_tmp16 = __errno_location();
#line 653
    Msg(*__cil_tmp16, (char *)"getcwd");
    }
#line 654
    return;
  }
#line 656
  if (nwin->term != nwin_undef.term) {
    {
#line 657
    strncpy((char *)m.m.create.screenterm, (char const   *)nwin->term, (unsigned long )19);
    }
  }
#line 658
  m.m.create.screenterm[19] = (char )'\000';
#line 659
  m.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 660
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 661
  __cil_tmp17 = write(s, (void const   *)((char *)(& m)), sizeof(m));
  }
#line 661
  if ((unsigned long )__cil_tmp17 != sizeof(m)) {
    {
#line 662
    __cil_tmp18 = __errno_location();
#line 662
    Msg(*__cil_tmp18, (char *)"write");
    }
  }
  {
#line 663
  close(s);
  }
}
}
#line 667 "/tmp/screen-3.9.15/socket.c"
int SendErrorMsg(char *tty , char *buf ) 
{ 
  int s ;
  struct msg m ;
  ssize_t __cil_tmp6 ;

  {
  {
#line 673
  strncpy((char *)m.m.message, (char const   *)buf, sizeof(m.m.message) - 1UL);
#line 674
  m.m.message[sizeof(m.m.message) - 1UL] = (char )0;
#line 675
  s = MakeClientSocket(0);
  }
#line 676
  if (s < 0) {
#line 677
    return (- 1);
  }
  {
#line 678
  m.type = 1;
#line 679
  strncpy((char *)m.m_tty, (char const   *)tty, sizeof(m.m_tty) - 1UL);
#line 680
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
#line 681
  m.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  }
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 683
  __cil_tmp6 = write(s, (void const   *)((char *)(& m)), sizeof(m));
#line 684
  close(s);
  }
#line 685
  return (0);
}
}
#line 689 "/tmp/screen-3.9.15/socket.c"
static void ExecCreate(struct msg *mp ) 
{ 
  struct NewWindow nwin ;
  char *args[64] ;
  register int n ;
  register char **pp ;
  register char *p ;
  int l ;
  int num ;
  char buf[20] ;
  size_t __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  char **__cil_tmp14 ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 695
  pp = (char **)args;
#line 695
  p = (char *)mp->m.create.line;
#line 697
  nwin = nwin_undef;
#line 698
  n = mp->m.create.nargs;
#line 699
  if (n > 63) {
#line 700
    n = 63;
  }
#line 702
  if (n) {
    {
#line 707
    __cil_tmp10 = strlen((char const   *)p);
#line 707
    l = (int )__cil_tmp10;
#line 708
    __cil_tmp11 = IsNumColon(p, 10, (char *)buf, (int )sizeof(buf));
    }
#line 708
    if (__cil_tmp11) {
#line 710
      if (*((char *)buf)) {
#line 711
        nwin.aka = (char *)buf;
      }
      {
#line 712
      num = atoi((char const   *)p);
      }
#line 713
      if (num < 0) {
#line 714
        num = 0;
      } else
#line 713
      if (num > 39) {
#line 714
        num = 0;
      }
#line 715
      nwin.StartAt = num;
#line 716
      p += l + 1;
#line 717
      __cil_tmp13 = n;
#line 717
      n --;
    }
  }
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! (n > 0)) {
#line 720
      goto while_break;
    }
    {
#line 722
    __cil_tmp14 = pp;
#line 722
    pp ++;
#line 722
    *__cil_tmp14 = p;
#line 723
    __cil_tmp15 = strlen((char const   *)p);
    }
#line 723
    p += __cil_tmp15 + 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  __cil_tmp16 = n;
#line 720
  n --;
#line 725
  *pp = (char *)0;
#line 726
  if (*p) {
#line 727
    nwin.aka = p;
  }
#line 728
  if (*((char **)args)) {
#line 729
    nwin.args = (char **)args;
  }
#line 730
  nwin.aflag = mp->m.create.aflag;
#line 731
  nwin.flowflag = mp->m.create.flowflag;
#line 732
  if (*((char *)mp->m.create.dir)) {
#line 733
    nwin.dir = (char *)mp->m.create.dir;
  }
#line 734
  nwin.lflag = mp->m.create.lflag;
#line 735
  nwin.histheight = mp->m.create.hheight;
#line 736
  if (*((char *)mp->m.create.screenterm)) {
#line 737
    nwin.term = (char *)mp->m.create.screenterm;
  }
  {
#line 738
  MakeWindow(& nwin);
  }
}
}
#line 742 "/tmp/screen-3.9.15/socket.c"
static int CheckPid(int pid ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  if (pid < 2) {
#line 747
    return (- 1);
  }
#line 748
  if (eff_uid == real_uid) {
    {
#line 749
    __cil_tmp2 = kill(pid, 0);
    }
#line 749
    return (__cil_tmp2);
  }
  {
#line 750
  __cil_tmp3 = UserContext();
  }
#line 750
  if (__cil_tmp3 > 0) {
    {
#line 751
    __cil_tmp4 = kill(pid, 0);
#line 751
    UserReturn(__cil_tmp4);
    }
  }
  {
#line 752
  __cil_tmp5 = UserStatus();
  }
#line 752
  return (__cil_tmp5);
}
}
#line 783 "/tmp/screen-3.9.15/socket.c"
void ReceiveMsg(void) 
{ 
  int left ;
  int len ;
  int i ;
  static struct msg m ;
  char *p ;
  int ns ;
  struct mode Mode ;
  struct win *wi ;
  struct display *next ;
  struct display *olddisplays ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  ssize_t __cil_tmp13 ;
  int *__cil_tmp14 ;
  int *__cil_tmp16 ;
  int *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  struct display *tmp ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int *__cil_tmp24 ;
  int __cil_tmp25 ;
  struct acluser **__cil_tmp26 ;
  struct display *__cil_tmp27 ;
  int tmp___0 ;
  int tmp___348 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  int *__cil_tmp32 ;

  {
#line 788
  ns = ServerSocket;
#line 794
  olddisplays = displays;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  __cil_tmp11 = fcntl(ServerSocket, 4, 0);
  }
#line 798
  if (__cil_tmp11 == -1) {
    {
#line 799
    __cil_tmp12 = __errno_location();
#line 799
    Panic(*__cil_tmp12, (char *)"BLOCK fcntl");
    }
  }
#line 812
  p = (char *)(& m);
#line 813
  left = (int )sizeof(m);
  {
#line 814
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 814
    if (! (left > 0)) {
#line 814
      goto while_break___0;
    }
    {
#line 816
    __cil_tmp13 = read(ns, (void *)p, (size_t )left);
#line 816
    len = (int )__cil_tmp13;
#line 817
    __cil_tmp14 = __errno_location();
    }
#line 817
    if (len < 0) {
#line 817
      if (*__cil_tmp14 == 4) {
#line 818
        goto while_continue___0;
      }
    }
#line 819
    if (len <= 0) {
#line 820
      goto while_break___0;
    }
#line 821
    p += len;
#line 822
    left -= len;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 828
  close(ServerSocket);
#line 829
  ServerSocket = secopen((char *)SockPath, 2048, 0);
  }
#line 829
  if (ServerSocket < 0) {
    {
#line 830
    __cil_tmp16 = __errno_location();
#line 830
    Panic(*__cil_tmp16, (char *)"reopen fifo %s", (char *)SockPath);
    }
  }
  {
#line 831
  evdeq(& serv_read);
#line 832
  serv_read.fd = ServerSocket;
#line 833
  evenq(& serv_read);
  }
#line 839
  if (len < 0) {
    {
#line 841
    __cil_tmp17 = __errno_location();
#line 841
    Msg(*__cil_tmp17, (char *)"read");
    }
#line 842
    return;
  }
#line 844
  if (left > 0) {
#line 846
    if ((unsigned long )left != sizeof(m)) {
      {
#line 847
      Msg(0, (char *)"Message %d of %d bytes too small", left, (int )sizeof(m));
      }
    } else {
      {
#line 849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 849
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 850
    return;
  }
#line 852
  if (m.protocol_revision != (((109 << 24) | (115 << 16)) | (103 << 8))) {
    {
#line 854
    Msg(0, (char *)"Invalid message (magic 0x%08x).", m.protocol_revision);
    }
#line 855
    return;
  }
  {
#line 858
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 858
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 859
  display = displays;
  {
#line 859
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 859
    if (! display) {
#line 859
      goto while_break___3;
    }
    {
#line 860
    __cil_tmp18 = strcmp((char const   *)((char *)display->d_usertty), (char const   *)((char *)m.m_tty));
    }
#line 860
    if (__cil_tmp18 == 0) {
#line 861
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 859
  display = display->d_next;
  {
#line 862
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 862
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 863
  wi = (struct win *)0;
#line 864
  if (! display) {
#line 866
    wi = windows;
    {
#line 866
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 866
      if (! wi) {
#line 866
        goto while_break___5;
      }
      {
#line 867
      __cil_tmp19 = strcmp((char const   *)((char *)m.m_tty), (char const   *)((char *)wi->w_tty));
      }
#line 867
      if (! __cil_tmp19) {
#line 870
        if (wi->w_layer.l_cvlist) {
#line 870
          tmp = (wi->w_layer.l_cvlist)->c_display;
        } else {
#line 870
          tmp = (struct display *)0;
        }
#line 870
        display = tmp;
        {
#line 871
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 871
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 873
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 866
    wi = wi->w_next;
  }
#line 878
  if (display) {
#line 878
    if (display->d_status) {
      {
#line 879
      RemoveStatus();
      }
    }
  }
#line 881
  if (display) {
#line 881
    if (! display->d_tcinited) {
#line 881
      if (m.type != 7) {
#line 882
        return;
      }
    }
  }
  {
#line 886
  if (m.type == 6) {
#line 886
    goto case_6;
  }
#line 890
  if (m.type == 0) {
#line 890
    goto case_0;
  }
#line 902
  if (m.type == 3) {
#line 902
    goto case_3;
  }
#line 908
  if (m.type == 2) {
#line 908
    goto case_2;
  }
#line 1003
  if (m.type == 1) {
#line 1003
    goto case_1;
  }
#line 1006
  if (m.type == 7) {
#line 1006
    goto case_7;
  }
#line 1013
  if (m.type == 5) {
#line 1013
    goto case_5;
  }
#line 1013
  if (m.type == 4) {
#line 1013
    goto case_5;
  }
#line 1028
  if (m.type == 8) {
#line 1028
    goto case_8;
  }
#line 1031
  goto switch_default;
  case_6: /* CIL Label */ 
#line 887
  if (display) {
    {
#line 888
    CheckScreenSize(1);
    }
  }
#line 889
  goto switch_break;
  case_0: /* CIL Label */ 
#line 899
  if (displays) {
    {
#line 900
    ExecCreate(& m);
    }
  }
#line 901
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 903
  __cil_tmp21 = kill(display->d_userpid, 0);
  }
#line 903
  if (display) {
#line 903
    if (display->d_userpid != 0) {
#line 903
      if (__cil_tmp21 == 0) {
#line 904
        goto switch_break;
      }
    }
  }
  {
#line 905
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 905
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
  {
#line 909
  __cil_tmp22 = CheckPid(m.m.attach.apid);
  }
#line 909
  if (__cil_tmp22) {
    {
#line 911
    Msg(0, (char *)"Attach attempt with bad pid(%d)!", m.m.attach.apid);
    }
#line 912
    goto switch_break;
  }
  {
#line 914
  i = secopen((char *)m.m_tty, 2050, 0);
  }
#line 914
  if (i < 0) {
    {
#line 916
    __cil_tmp24 = __errno_location();
#line 916
    Msg(*__cil_tmp24, (char *)"Attach: Could not open %s!", (char *)m.m_tty);
#line 917
    Kill(m.m.attach.apid, 1);
    }
#line 918
    goto switch_break;
  }
  {
#line 921
  Kill(m.m.attach.apid, 18);
  }
#line 928
  if (display) {
    {
    {
#line 930
    write(i, (void const   *)((char *)"Attaching from inside of screen?\n"), (size_t )33);
    }
    {
#line 931
    close(i);
    }
    {
#line 932
    Kill(m.m.attach.apid, 1);
    }
    {
#line 933
    Msg(0, (char *)"Attach msg ignored: coming from inside.");
    }
    }
#line 934
    goto switch_break;
  } else
#line 928
  if (wi) {
    {
    {
#line 930
    write(i, (void const   *)((char *)"Attaching from inside of screen?\n"), (size_t )33);
    }
    {
#line 931
    close(i);
    }
    {
#line 932
    Kill(m.m.attach.apid, 1);
    }
    {
#line 933
    Msg(0, (char *)"Attach msg ignored: coming from inside.");
    }
    }
#line 934
    goto switch_break;
  }
  {
#line 938
  __cil_tmp25 = strcmp((char const   *)((char *)m.m.attach.auser), (char const   *)LoginName);
  }
#line 938
  if (__cil_tmp25) {
    {
#line 939
    __cil_tmp26 = FindUserPtr((char *)m.m.attach.auser);
    }
#line 939
    if (*__cil_tmp26 == (struct acluser *)0) {
      {
#line 941
      write(i, (void const   *)((char *)"Access to session denied.\n"), (size_t )26);
#line 942
      close(i);
#line 943
      Kill(m.m.attach.apid, 1);
#line 944
      Msg(0, (char *)"Attach: access denied for user %s.", (char *)m.m.attach.auser);
      }
#line 945
      goto switch_break;
    }
  }
  {
#line 949
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 949
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 961
  GetTTY(i, & Mode);
#line 962
  __cil_tmp27 = MakeDisplay((char *)m.m.attach.auser, (char *)m.m_tty, (char *)m.m.attach.envterm,
                            i, m.m.attach.apid, & Mode);
  }
#line 962
  if (__cil_tmp27 == (struct display *)0) {
    {
#line 964
    write(i, (void const   *)((char *)"Could not make display.\n"), (size_t )24);
#line 965
    close(i);
#line 966
    Msg(0, (char *)"Attach: could not make display for user %s", (char *)m.m.attach.auser);
#line 967
    Kill(m.m.attach.apid, 1);
    }
#line 968
    goto switch_break;
  }
#line 972
  if (m.m.attach.encoding == 1) {
#line 972
    tmp___348 = 8;
  } else {
#line 972
    if (m.m.attach.encoding) {
#line 972
      tmp___0 = m.m.attach.encoding - 1;
    } else {
#line 972
      tmp___0 = 0;
    }
#line 972
    tmp___348 = tmp___0;
  }
  {
#line 972
  display->d_encoding = tmp___348;
#line 976
  __cil_tmp30 = EncodingName(display->d_encoding);
  }
#line 976
  if (display->d_encoding < 0) {
#line 977
    display->d_encoding = 0;
  } else
#line 976
  if (! __cil_tmp30) {
#line 977
    display->d_encoding = 0;
  }
#line 980
  if (iflag) {
#line 980
    if (olddisplays) {
      {
#line 982
      iflag = 0;
#line 984
      olddisplays->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 985
      olddisplays->d_NewMode.tio.c_lflag &= (unsigned int )(~ 1);
#line 989
      SetTTY(olddisplays->d_userfd, & olddisplays->d_NewMode);
      }
    }
  }
  {
#line 991
  SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 992
  SetTTY(display->d_userfd, & display->d_NewMode);
#line 993
  __cil_tmp31 = fcntl(display->d_userfd, 4, 2048);
  }
#line 993
  if (__cil_tmp31) {
    {
#line 994
    __cil_tmp32 = __errno_location();
#line 994
    Msg(*__cil_tmp32, (char *)"Warning: NBLOCK fcntl failed");
    }
  }
#line 997
  if ((display->d_user)->u_password) {
#line 997
    if ((int )*((display->d_user)->u_password)) {
      {
#line 998
      AskPassword(& m);
      }
    } else {
      {
      {
#line 1001
      FinishAttach(& m);
      }
      }
    }
  } else {
    {
    {
#line 1001
    FinishAttach(& m);
    }
    }
  }
#line 1002
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1004
  Msg(0, (char *)"%s", (char *)m.m.message);
  }
#line 1005
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1007
  if (! wi) {
    {
#line 1008
    Hangup();
    }
  }
#line 1009
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1015
  display = displays;
  {
#line 1015
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1015
    if (! display) {
#line 1015
      goto while_break___9;
    }
#line 1017
    next = display->d_next;
#line 1019
    if (m.type == 5) {
      {
#line 1020
      Detach(4);
      }
    } else
#line 1023
    if (m.type == 4) {
      {
#line 1024
      Detach(2);
      }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1015
  display = next;
#line 1026
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1029
  DoCommandMsg(& m);
  }
#line 1030
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1032
  Msg(0, (char *)"Invalid message (type %d).", m.type);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1065 "/tmp/screen-3.9.15/socket.c"
int chsock(void) 
{ 
  int r ;
  int euid ;
  __uid_t __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int tmp ;
  int tmp___349 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1067
  __cil_tmp3 = geteuid();
#line 1067
  euid = (int )__cil_tmp3;
  }
#line 1068
  if (euid != real_uid) {
    {
#line 1070
    __cil_tmp4 = UserContext();
    }
#line 1070
    if (__cil_tmp4 <= 0) {
      {
#line 1071
      __cil_tmp5 = UserStatus();
      }
#line 1071
      return (__cil_tmp5);
    }
  }
#line 1073
  if (multi) {
#line 1073
    tmp___349 = 1;
  } else {
#line 1073
    tmp___349 = 0;
  }
#line 1073
  if (displays) {
#line 1073
    tmp = 64;
  } else {
#line 1073
    tmp = 0;
  }
  {
#line 1073
  __cil_tmp8 = chmod((char const   *)((char *)SockPath), (__mode_t )((384 | tmp) | tmp___349));
#line 1073
  r = __cil_tmp8;
#line 1079
  __cil_tmp9 = utimes((char const   *)((char *)SockPath), (struct timeval [2])((void *)0));
  }
#line 1081
  if (euid != real_uid) {
    {
#line 1082
    UserReturn(r);
    }
  }
#line 1083
  return (r);
}
}
#line 1090 "/tmp/screen-3.9.15/socket.c"
int RecoverSocket(void) 
{ 
  __uid_t __cil_tmp1 ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 1092
  close(ServerSocket);
#line 1093
  __cil_tmp1 = geteuid();
  }
#line 1093
  if (__cil_tmp1 != (unsigned int )real_uid) {
    {
#line 1095
    __cil_tmp2 = UserContext();
    }
#line 1095
    if (__cil_tmp2 > 0) {
      {
#line 1096
      __cil_tmp3 = unlink((char const   *)((char *)SockPath));
#line 1096
      UserReturn(__cil_tmp3);
      }
    }
    {
#line 1097
    __cil_tmp4 = UserStatus();
    }
  } else {
    {
#line 1100
    __cil_tmp5 = unlink((char const   *)((char *)SockPath));
    }
  }
  {
#line 1102
  ServerSocket = MakeServerSocket();
  }
#line 1102
  if (ServerSocket < 0) {
#line 1103
    return (0);
  }
  {
#line 1104
  evdeq(& serv_read);
#line 1105
  serv_read.fd = ServerSocket;
#line 1106
  evenq(& serv_read);
  }
#line 1107
  return (1);
}
}
#line 1112 "/tmp/screen-3.9.15/socket.c"
static void FinishAttach(struct msg *m ) 
{ 
  char *p ;
  int pid ;
  int noshowwin ;
  struct win *wi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1121
  pid = display->d_userpid;
#line 1140
  if (extra_outcap) {
    {
#line 1141
    free((void *)extra_outcap);
    }
  }
#line 1142
  if (extra_incap) {
    {
#line 1143
    free((void *)extra_incap);
    }
  }
#line 1144
  extra_outcap = (char *)0;
#line 1144
  extra_incap = extra_outcap;
  {
#line 1145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1145
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1148
  p = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1148
  if (p) {
    {
#line 1149
    StartRc(p);
    }
  } else {
    {
#line 1152
    StartRc((char *)"./etc/screenrc");
    }
  }
  {
#line 1154
  StartRc(RcFileName);
#line 1155
  __cil_tmp7 = InitTermcap(m->m.attach.columns, m->m.attach.lines);
  }
#line 1155
  if (__cil_tmp7) {
    {
#line 1157
    FreeDisplay();
#line 1158
    Kill(pid, 1);
    }
#line 1159
    return;
  }
  {
#line 1161
  MakeDefaultCanvas();
#line 1162
  InitTerm(m->m.attach.adaptflag);
  }
#line 1163
  if (displays->d_next == (struct display *)0) {
    {
#line 1164
    __cil_tmp8 = chsock();
    }
  }
  {
#line 1165
  xsignal(1, SigHup);
  }
#line 1166
  if (m->m.attach.esc != -1) {
#line 1166
    if (m->m.attach.meta_esc != -1) {
#line 1168
      (display->d_user)->u_Esc = m->m.attach.esc;
#line 1169
      (display->d_user)->u_MetaEsc = m->m.attach.meta_esc;
    }
  }
  {
#line 1178
  RemoveLoginSlot();
  }
#line 1179
  if (displays->d_next == (struct display *)0) {
#line 1180
    wi = windows;
    {
#line 1180
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1180
      if (! wi) {
#line 1180
        goto while_break___1;
      }
#line 1181
      if (wi->w_ptyfd >= 0) {
#line 1181
        if (wi->w_slot != (slot_t )-1) {
          {
#line 1182
          SetUtmp(wi);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1180
    wi = wi->w_next;
  }
#line 1185
  display->d_fore = (struct win *)((void *)0);
  {
#line 1189
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1189
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1190
  if ((display->d_user)->u_detachwin >= 0) {
#line 1191
    fore = wtab[(display->d_user)->u_detachwin];
  } else {
#line 1193
    fore = (struct win *)0;
  }
#line 1196
  if ((display->d_user)->u_detachotherwin >= 0) {
#line 1197
    display->d_other = wtab[(display->d_user)->u_detachotherwin];
  }
#line 1199
  noshowwin = 0;
#line 1200
  if (*((char *)m->m.attach.preselect)) {
    {
#line 1202
    __cil_tmp9 = strcmp((char const   *)((char *)m->m.attach.preselect), (char const   *)((char *)"="));
    }
#line 1202
    if (! __cil_tmp9) {
#line 1203
      fore = (struct win *)0;
    } else {
      {
#line 1204
      __cil_tmp10 = strcmp((char const   *)((char *)m->m.attach.preselect), (char const   *)((char *)"-"));
      }
#line 1204
      if (! __cil_tmp10) {
#line 1206
        fore = (struct win *)0;
#line 1207
        noshowwin = 1;
      } else {
        {
#line 1210
        fore = FindNiceWindow(fore, (char *)m->m.attach.preselect);
        }
      }
    }
  } else {
    {
#line 1213
    fore = FindNiceWindow(fore, (char *)0);
    }
  }
#line 1214
  if (fore) {
    {
#line 1215
    SetForeWindow(fore);
    }
  } else
#line 1216
  if (! noshowwin) {
    {
#line 1219
    __cil_tmp13 = AclCheckPermCmd(display->d_user, 0, & comms[162]);
    }
#line 1219
    if (! __cil_tmp13) {
      {
#line 1222
      flayer = (display->d_forecv)->c_layer;
#line 1223
      display_wlist(1);
#line 1224
      noshowwin = 1;
      }
    }
  }
  {
#line 1227
  Activate(0);
  }
#line 1228
  if (! display->d_fore) {
#line 1228
    if (! noshowwin) {
      {
#line 1229
      ShowWindows(- 1);
      }
    }
  }
#line 1230
  if (displays->d_next == (struct display *)0) {
#line 1230
    if (console_window) {
      {
#line 1232
      __cil_tmp14 = TtyGrabConsole(console_window->w_ptyfd, 1, (char *)"reattach");
      }
#line 1232
      if (__cil_tmp14 == 0) {
        {
#line 1233
        Msg(0, (char *)"console %s is on window %d", (char *)HostName, console_window->w_number);
        }
      }
    }
  }
  {
#line 1235
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1235
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 1249
static void PasswordProcessInput(char *ibuf , int ilen ) ;
#line 1258 "/tmp/screen-3.9.15/socket.c"
static void AskPassword(struct msg *m ) 
{ 
  struct pwdata *pwdata ;
  void *__cil_tmp3 ;

  {
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1263
  __cil_tmp3 = malloc(sizeof(struct pwdata ));
#line 1263
  pwdata = (struct pwdata *)__cil_tmp3;
  }
#line 1264
  if (! pwdata) {
    {
#line 1265
    Panic(0, (char *)strnomem);
    }
  }
  {
#line 1266
  pwdata->l = 0;
#line 1267
  pwdata->m = *m;
#line 1268
  display->d_processinputdata = (char *)pwdata;
#line 1269
  display->d_processinput = PasswordProcessInput;
#line 1270
  AddStr((char *)"Screen password: ");
  }
}
}
#line 1274 "/tmp/screen-3.9.15/socket.c"
static void PasswordProcessInput(char *ibuf , int ilen ) 
{ 
  struct pwdata *pwdata ;
  int c ;
  int l ;
  char *up ;
  int pid ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1281
  pid = display->d_userpid;
#line 1283
  pwdata = (struct pwdata *)display->d_processinputdata;
#line 1284
  l = pwdata->l;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if (! (__cil_tmp8 > 0)) {
#line 1285
      goto while_break;
    }
#line 1287
    __cil_tmp9 = ibuf;
#line 1287
    ibuf ++;
#line 1287
    c = (int )*((unsigned char *)__cil_tmp9);
#line 1288
    if (c == 13) {
      _L: /* CIL Label */ 
      {
#line 1290
      up = (display->d_user)->u_password;
#line 1291
      pwdata->buf[l] = (char )0;
#line 1292
      __cil_tmp10 = crypt((char *)pwdata->buf, up);
      }
      {
#line 1292
      __cil_tmp11 = strlen((char const   *)up);
#line 1292
      __cil_tmp12 = strncmp((char const   *)__cil_tmp10, (char const   *)up, __cil_tmp11);
      }
#line 1292
      if (__cil_tmp12) {
        {
#line 1295
        bzero((void *)((char *)pwdata->buf), sizeof(pwdata->buf));
#line 1296
        AddStr((char *)"\r\nPassword incorrect.\r\n");
#line 1297
        display->d_processinputdata = (char *)0;
#line 1298
        FreeDisplay();
#line 1299
        Msg(0, (char *)"Illegal reattach attempt from terminal %s.", (char *)pwdata->m.m_tty);
#line 1300
        free((void *)pwdata);
#line 1301
        Kill(pid, 1);
        }
#line 1302
        return;
      }
      {
#line 1305
      bzero((void *)((char *)pwdata->buf), sizeof(pwdata->buf));
#line 1306
      AddStr((char *)"\r\n");
#line 1307
      display->d_processinputdata = (char *)0;
#line 1308
      display->d_processinput = ProcessInput;
#line 1309
      FinishAttach(& pwdata->m);
#line 1310
      free((void *)pwdata);
      }
#line 1311
      return;
    } else
#line 1288
    if (c == 10) {
#line 1288
      goto _L;
    }
#line 1313
    if (c == 3) {
      {
#line 1315
      AddStr((char *)"\r\n");
#line 1316
      FreeDisplay();
#line 1317
      Kill(pid, 1);
      }
#line 1318
      return;
    }
#line 1320
    if (c == 8) {
      _L___350: /* CIL Label */ 
#line 1322
      if (l > 0) {
#line 1323
        __cil_tmp13 = l;
#line 1323
        l --;
      }
#line 1324
      goto while_continue;
    } else
#line 1320
    if (c == 127) {
#line 1320
      goto _L___350;
    }
#line 1326
    if (c == 21) {
#line 1328
      l = 0;
#line 1329
      goto while_continue;
    }
#line 1331
    if ((unsigned long )l < sizeof(pwdata->buf) - 1UL) {
#line 1332
      __cil_tmp14 = l;
#line 1332
      l ++;
#line 1332
      pwdata->buf[__cil_tmp14] = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1334
  pwdata->l = l;
}
}
#line 1339 "/tmp/screen-3.9.15/socket.c"
static void DoCommandMsg(struct msg *mp ) 
{ 
  char *args[64] ;
  int n ;
  register char **pp ;
  register char *p ;
  struct acluser *user ;
  extern struct acluser *EffectiveAclUser___0 ;
  char **__cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp12 ;
  struct display *tmp ;
  int i ;
  int __cil_tmp15 ;
  struct win *tmp___0 ;
  struct win *tmp___1 ;
  char *oldrcname ;
  struct layer *tmp___2 ;

  {
#line 1344
  pp = (char **)args;
#line 1344
  p = (char *)mp->m.command.cmd;
#line 1352
  n = mp->m.command.nargs;
#line 1353
  if (n > 63) {
#line 1354
    n = 63;
  }
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1355
    if (! (n > 0)) {
#line 1355
      goto while_break;
    }
    {
#line 1357
    __cil_tmp8 = pp;
#line 1357
    pp ++;
#line 1357
    *__cil_tmp8 = p;
#line 1358
    __cil_tmp9 = strlen((char const   *)p);
    }
#line 1358
    p += __cil_tmp9 + 1UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1355
  __cil_tmp10 = n;
#line 1355
  n --;
#line 1360
  *pp = (char *)0;
#line 1362
  user = (struct acluser *)FindUserPtr((char *)mp->m.attach.auser);
  }
#line 1363
  if (user == (struct acluser *)0) {
    {
#line 1365
    Msg(0, (char *)"Unknown user %s tried to send a command!", (char *)mp->m.attach.auser);
    }
#line 1366
    return;
  }
#line 1372
  if (user->u_password) {
#line 1372
    if ((int )*(user->u_password)) {
      {
#line 1374
      Msg(0, (char *)"User %s has a password, cannot use -X option.", (char *)mp->m.attach.auser);
      }
#line 1375
      return;
    }
  }
#line 1378
  if (! display) {
#line 1379
    display = displays;
    {
#line 1379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1379
      if (! display) {
#line 1379
        goto while_break___0;
      }
#line 1380
      if (display->d_user == user) {
#line 1381
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1379
    display = display->d_next;
  }
#line 1382
  fore = windows;
  {
#line 1382
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1382
    if (! fore) {
#line 1382
      goto while_break___1;
    }
    {
#line 1383
    __cil_tmp12 = strcmp((char const   *)((char *)mp->m_tty), (char const   *)((char *)fore->w_tty));
    }
#line 1383
    if (! __cil_tmp12) {
#line 1385
      if (! display) {
#line 1386
        if (fore->w_layer.l_cvlist) {
#line 1386
          tmp = (fore->w_layer.l_cvlist)->c_display;
        } else {
#line 1386
          tmp = (struct display *)0;
        }
#line 1386
        display = tmp;
      }
#line 1387
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1382
  fore = fore->w_next;
#line 1389
  if (! display) {
#line 1390
    display = displays;
  }
#line 1391
  if (*((char *)mp->m.command.preselect)) {
    {
#line 1393
    i = - 1;
#line 1394
    __cil_tmp15 = strcmp((char const   *)((char *)mp->m.command.preselect), (char const   *)((char *)"-"));
    }
#line 1394
    if (__cil_tmp15) {
      {
#line 1395
      i = WindowByNoN((char *)mp->m.command.preselect);
      }
    }
#line 1396
    if (i >= 0) {
#line 1396
      tmp___0 = wtab[i];
    } else {
#line 1396
      tmp___0 = (struct win *)0;
    }
#line 1396
    fore = tmp___0;
  } else
#line 1398
  if (! fore) {
#line 1400
    if (display) {
#line 1400
      if (display->d_user == user) {
#line 1401
        fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
      }
    }
#line 1402
    if (! fore) {
#line 1404
      if (user->u_detachwin >= 0) {
#line 1404
        tmp___1 = wtab[user->u_detachwin];
      } else {
#line 1404
        tmp___1 = (struct win *)0;
      }
      {
#line 1404
      fore = tmp___1;
#line 1405
      fore = FindNiceWindow(fore, (char *)0);
      }
    }
  }
#line 1409
  EffectiveAclUser___0 = user;
#line 1411
  if (*((char **)args)) {
#line 1413
    oldrcname = rc_name;
#line 1414
    rc_name = (char *)"-X";
    {
#line 1415
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1415
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1416
    if (fore) {
#line 1416
      tmp___2 = & fore->w_layer;
    } else {
#line 1416
      tmp___2 = (struct layer *)0;
    }
#line 1416
    flayer = tmp___2;
#line 1417
    if (fore) {
#line 1417
      if (fore->w_savelayer) {
#line 1417
        if (fore->w_blocked) {
#line 1418
          flayer = fore->w_savelayer;
        } else
#line 1417
        if ((fore->w_savelayer)->l_cvlist == (struct canvas *)0) {
#line 1418
          flayer = fore->w_savelayer;
        }
      }
    }
    {
#line 1419
    DoCommand((char **)args);
#line 1420
    rc_name = oldrcname;
    }
  }
#line 1423
  EffectiveAclUser___0 = (struct acluser *)0;
}
}
#line 304 "./extern.h"
char *xrealloc(char *mem , int len ) ;
#line 308
void FreeAltScreen(struct win *p ) ;
#line 309
void EnterAltScreen(struct win *p ) ;
#line 310
void LeaveAltScreen(struct win *p ) ;
#line 43 "/tmp/screen-3.9.15/resize.c"
static void CheckMaxSize(int wi ) ;
#line 44
static void FreeMline(struct mline *ml ) ;
#line 45
static int AllocMline(struct mline *ml , int w ) ;
#line 46
static void MakeBlankLine(unsigned char *p , int n ) ;
#line 47
static void kaablamm(void) ;
#line 48
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) ;
#line 49
static void SwapAltScreen(struct win *p ) ;
#line 63 "/tmp/screen-3.9.15/resize.c"
static struct mline mline_zero  =    {(unsigned char *)0, (unsigned char *)0, (unsigned char *)0, (unsigned char *)0};
#line 87 "/tmp/screen-3.9.15/resize.c"
void CheckScreenSize(int change_flag ) 
{ 
  int wi ;
  int he ;
  int __cil_tmp4 ;

  {
#line 92
  if (display == (struct display *)0) {
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 95
    return;
  }
  {
#line 98
  __cil_tmp4 = ioctl(display->d_userfd, (unsigned long )21523, (char *)(& glwz));
  }
#line 98
  if (__cil_tmp4 != 0) {
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    wi = display->d_tcs[1].num;
#line 102
    he = display->d_tcs[0].num;
  } else {
#line 106
    wi = (int )glwz.ws_col;
#line 107
    he = (int )glwz.ws_row;
#line 108
    if (wi == 0) {
#line 109
      wi = display->d_tcs[1].num;
    }
#line 110
    if (he == 0) {
#line 111
      he = display->d_tcs[0].num;
    }
  }
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 118
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  if (display->d_width == wi) {
#line 129
    if (display->d_height == he) {
      {
#line 131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 131
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 132
      return;
    }
  }
  {
#line 134
  ChangeScreenSize(wi, he, change_flag);
  }
}
}
#line 143 "/tmp/screen-3.9.15/resize.c"
void ChangeScreenSize(int wi , int he , int change_fore ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  int wwi ;
  int y ;
  int h ;
  int hn ;
  int __cil_tmp11 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  y = 0;
#line 161
  h = he;
#line 162
  if (display->d_has_hstatus == 1) {
#line 164
    if (h > 1) {
#line 165
      __cil_tmp11 = h;
#line 165
      h --;
    } else {
#line 167
      display->d_has_hstatus = 0;
    }
  }
#line 169
  cvpp = & display->d_cvlist;
  {
#line 169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 169
    if (! cv) {
#line 169
      goto while_break___1;
    }
#line 171
    if (h < 2) {
#line 171
      if (cvpp != & display->d_cvlist) {
        {
#line 174
        SetCanvasWindow(cv, (struct win *)0);
#line 175
        *cvpp = cv->c_next;
#line 176
        free((void *)cv);
        }
#line 177
        if (display->d_forecv == cv) {
#line 178
          display->d_forecv = (struct canvas *)0;
        }
#line 179
        goto while_continue___1;
      }
    }
#line 181
    hn = (((cv->c_ye - cv->c_ys) + 1) * he) / display->d_height;
#line 182
    if (hn == 0) {
#line 183
      hn = 1;
    }
#line 184
    if (hn + 2 >= h) {
#line 185
      hn = h - 1;
    } else
#line 184
    if (cv->c_next == (struct canvas *)0) {
#line 185
      hn = h - 1;
    }
#line 186
    if (! captionalways) {
#line 186
      if (cv == display->d_cvlist) {
#line 186
        if (h - hn < 2) {
#line 187
          hn = h;
        } else {
#line 186
          goto _L;
        }
      } else {
#line 186
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 186
    if (hn == 0) {
#line 187
      hn = h;
    }
    {
#line 188
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 188
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 189
    cv->c_xs = 0;
#line 190
    cv->c_xe = wi - 1;
#line 191
    cv->c_ys = y;
#line 192
    cv->c_ye = (y + hn) - 1;
#line 194
    cv->c_xoff = cv->c_xs;
#line 195
    cv->c_yoff = cv->c_ys;
#line 197
    y += hn + 1;
#line 198
    h -= hn + 1;
#line 199
    cvpp = & cv->c_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 201
  RethinkDisplayViewports();
  }
#line 202
  if (display->d_forecv == (struct canvas *)0) {
#line 203
    display->d_forecv = display->d_cvlist;
  }
#line 204
  if (display->d_forecv) {
#line 205
    display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
  }
  {
#line 207
  display->d_width = wi;
#line 208
  display->d_height = he;
#line 210
  CheckMaxSize(wi);
  }
#line 211
  if (display->d_tcs[44].str) {
#line 213
    display->d_defwidth = display->d_tcs[1].num;
#line 214
    display->d_defheight = display->d_tcs[0].num;
  } else {
#line 218
    if (display->d_tcs[45].str) {
#line 218
      if (wi == Z0width) {
        _L___352: /* CIL Label */ 
#line 218
        if (display->d_tcs[1].num == Z0width) {
#line 220
          display->d_defwidth = display->d_tcs[1].num;
        } else
#line 218
        if (display->d_tcs[1].num == Z1width) {
#line 220
          display->d_defwidth = display->d_tcs[1].num;
        } else {
#line 222
          display->d_defwidth = wi;
        }
      } else
#line 218
      if (wi == Z1width) {
#line 218
        goto _L___352;
      } else {
#line 222
        display->d_defwidth = wi;
      }
    } else {
#line 222
      display->d_defwidth = wi;
    }
#line 223
    display->d_defheight = he;
  }
  {
#line 225
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 225
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 226
  if (change_fore) {
    {
#line 227
    ResizeLayersToCanvases();
    }
  }
#line 228
  if (display->d_tcs[44].str == (char *)((void *)0)) {
#line 228
    if (displays->d_next == (struct display *)0) {
#line 231
      p = windows;
      {
#line 231
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 231
        if (! p) {
#line 231
          goto while_break___4;
        }
        {
#line 233
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 233
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 234
        wwi = wi;
#line 244
        if (p->w_savelayer) {
#line 244
          if ((p->w_savelayer)->l_cvlist == (struct canvas *)0) {
            {
#line 245
            ResizeLayer(p->w_savelayer, wwi, he, (struct display *)0);
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 231
      p = p->w_next;
    }
  }
}
}
#line 254 "/tmp/screen-3.9.15/resize.c"
void ResizeLayersToCanvases(void) 
{ 
  struct canvas *cv ;
  struct layer *l ;
  int lx ;
  int ly ;
  int __cil_tmp5 ;
  int n ;
  int n___0 ;

  {
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  display->d_kaablamm = 0;
#line 262
  cv = display->d_cvlist;
  {
#line 262
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 262
    if (! cv) {
#line 262
      goto while_break___0;
    }
#line 264
    l = cv->c_layer;
#line 265
    if (l == (struct layer *)0) {
#line 266
      goto while_continue___0;
    }
    {
#line 267
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 267
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 268
    if (l->l_width == (cv->c_xe - cv->c_xs) + 1) {
#line 268
      if (l->l_height == (cv->c_ye - cv->c_ys) + 1) {
        {
#line 271
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 271
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 272
        goto while_continue___0;
      }
    }
    {
#line 274
    __cil_tmp5 = MayResizeLayer(l);
    }
#line 274
    if (! __cil_tmp5) {
      {
#line 276
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 276
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 280
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 280
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 281
      ResizeLayer(l, (cv->c_xe - cv->c_xs) + 1, (cv->c_ye - cv->c_ys) + 1, display);
      }
    }
#line 285
    lx = (cv->c_layer)->l_x;
#line 286
    ly = (cv->c_layer)->l_y;
#line 287
    if (ly + cv->c_yoff < cv->c_ys) {
      {
#line 289
      cv->c_yoff = cv->c_ys - ly;
#line 290
      RethinkViewportOffsets(cv);
      }
    } else
#line 292
    if (ly + cv->c_yoff > cv->c_ye) {
      {
#line 294
      cv->c_yoff = cv->c_ye - ly;
#line 295
      RethinkViewportOffsets(cv);
      }
    }
#line 297
    if (lx + cv->c_xoff < cv->c_xs) {
#line 299
      n = cv->c_xs - (lx + cv->c_xoff);
#line 300
      if (n < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 301
        n = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 302
      if (cv->c_xoff + n > cv->c_xs) {
#line 303
        n = cv->c_xs - cv->c_xoff;
      }
      {
#line 304
      cv->c_xoff += n;
#line 305
      RethinkViewportOffsets(cv);
      }
    } else
#line 307
    if (lx + cv->c_xoff > cv->c_xe) {
#line 309
      n___0 = (lx + cv->c_xoff) - cv->c_xe;
#line 310
      if (n___0 < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 311
        n___0 = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 312
      if (((cv->c_xoff - n___0) + (cv->c_layer)->l_width) - 1 < cv->c_xe) {
#line 313
        n___0 = ((cv->c_xoff + (cv->c_layer)->l_width) - 1) - cv->c_xe;
      }
      {
#line 314
      cv->c_xoff -= n___0;
#line 315
      RethinkViewportOffsets(cv);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 262
  cv = cv->c_next;
#line 318
  Redisplay(0);
  }
#line 319
  if (display->d_kaablamm) {
    {
#line 321
    kaablamm();
#line 322
    display->d_kaablamm = 0;
    }
  }
}
}
#line 327 "/tmp/screen-3.9.15/resize.c"
int MayResizeLayer(struct layer *l ) 
{ 
  int cvs ;

  {
#line 330
  cvs = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! l) {
#line 332
      goto while_break___0;
    }
#line 334
    if (l->l_cvlist) {
#line 335
      cvs ++;
#line 335
      if (cvs > 1) {
        _L: /* CIL Label */ 
        {
#line 337
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 337
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 338
        return (0);
      } else
#line 335
      if ((l->l_cvlist)->c_lnext) {
#line 335
        goto _L;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 332
  l = l->l_next;
  {
#line 341
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 341
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 342
  return (1);
}
}
#line 353 "/tmp/screen-3.9.15/resize.c"
static void kaablamm(void) 
{ 


  {
  {
#line 355
  Msg(0, (char *)"Aborted because of window size change.");
  }
}
}
#line 359 "/tmp/screen-3.9.15/resize.c"
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  struct display *d ;
  struct display *olddisplay ;
  int __cil_tmp10 ;
  struct display *olddisplay___356 ;
  struct layer *oldflayer___357 ;
  struct layer *l___358 ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 366
  oldflayer = flayer;
#line 367
  olddisplay = display;
#line 369
  if (l->l_width == wi) {
#line 369
    if (l->l_height == he) {
#line 370
      return;
    }
  }
#line 371
  p = (struct win *)(l->l_bottom)->l_data;
#line 373
  if (oldflayer) {
#line 373
    if (l == oldflayer) {
      _L: /* CIL Label */ 
      {
#line 374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 374
        if (! oldflayer->l_next) {
#line 374
          goto while_break;
        }
#line 375
        oldflayer = oldflayer->l_next;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 373
    if ((struct win *)(oldflayer->l_bottom)->l_data == p) {
#line 373
      goto _L;
    }
  }
#line 377
  if (p) {
#line 379
    d = displays;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! d) {
#line 379
        goto while_break___0;
      }
#line 380
      cv = d->d_cvlist;
      {
#line 380
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 380
        if (! cv) {
#line 380
          goto while_break___1;
        }
#line 382
        if (p == (struct win *)((cv->c_layer)->l_bottom)->l_data) {
#line 384
          flayer = cv->c_layer;
#line 385
          if (flayer->l_next) {
#line 386
            d->d_kaablamm = 1;
          }
          {
#line 387
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 387
            if (! flayer->l_next) {
#line 387
              goto while_break___2;
            }
            {
#line 388
            ExitOverlayPage();
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 380
      cv = cv->c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 379
    d = d->d_next;
#line 391
    l = p->w_savelayer;
  }
  {
#line 393
  flayer = l;
#line 394
  __cil_tmp10 = ((int (*)(int  , int  ))*((flayer->l_layfn)->lf_LayResize))(wi, he);
  }
#line 394
  if (p == (struct win *)0) {
#line 394
    if (flayer->l_next) {
#line 394
      if ((flayer->l_next)->l_next == (struct layer *)0) {
#line 394
        if (__cil_tmp10 == 0) {
          {
#line 396
          flayer = flayer->l_next;
#line 397
          ((int (*)(int  , int  ))*((flayer->l_layfn)->lf_LayResize))(wi, he);
#line 398
          flayer = l;
          }
        } else {
#line 394
          goto _L___353;
        }
      } else {
#line 394
        goto _L___353;
      }
    } else {
#line 394
      goto _L___353;
    }
  } else {
    _L___353: /* CIL Label */ 
#line 402
    if (flayer->l_next) {
#line 402
      if (display) {
#line 403
        display->d_kaablamm = 1;
      }
    }
    {
#line 404
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 404
      if (! flayer->l_next) {
#line 404
        goto while_break___3;
      }
      {
#line 405
      ExitOverlayPage();
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 407
  if (p) {
#line 408
    flayer = & p->w_layer;
  }
  {
#line 409
  ((int (*)(int  , int  ))*((flayer->l_layfn)->lf_LayResize))(wi, he);
#line 411
  l = flayer;
#line 412
  display = displays;
  }
  {
#line 412
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 412
    if (! display) {
#line 412
      goto while_break___4;
    }
#line 414
    if (display == norefdisp) {
#line 415
      goto while_continue___4;
    }
#line 416
    cv = display->d_cvlist;
    {
#line 416
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 416
      if (! cv) {
#line 416
        goto while_break___5;
      }
#line 417
      if (cv->c_layer == l) {
        {
#line 419
        olddisplay___356 = display;
#line 419
        oldflayer___357 = flayer;
#line 419
        l___358 = cv->c_layer;
#line 419
        cvlist = l___358->l_cvlist;
#line 419
        cvlnext = cv->c_lnext;
#line 419
        flayer = l___358;
#line 419
        l___358->l_cvlist = cv;
#line 419
        cv->c_lnext = (struct canvas *)0;
#line 419
        ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                          - 1,
                                                                                          - 1,
                                                                                          0);
#line 419
        flayer = oldflayer___357;
#line 419
        l___358->l_cvlist = cvlist;
#line 419
        cv->c_lnext = cvlnext;
#line 419
        display = olddisplay___356;
#line 420
        RefreshArea(cv->c_xs, cv->c_ys, cv->c_xe, cv->c_ye, 0);
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 416
    cv = cv->c_next;
#line 422
    if (display->d_kaablamm) {
      {
#line 424
      kaablamm();
#line 425
      display->d_kaablamm = 0;
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 412
  display = display->d_next;
#line 428
  flayer = oldflayer;
#line 429
  display = olddisplay;
}
}
#line 434 "/tmp/screen-3.9.15/resize.c"
static void FreeMline(struct mline *ml ) 
{ 


  {
#line 437
  if (ml->image) {
    {
#line 438
    free((void *)ml->image);
    }
  }
#line 439
  if (ml->attr) {
#line 439
    if (ml->attr != null) {
      {
#line 440
      free((void *)ml->attr);
      }
    }
  }
#line 442
  if (ml->font) {
#line 442
    if (ml->font != null) {
      {
#line 443
      free((void *)ml->font);
      }
    }
  }
#line 446
  if (ml->color) {
#line 446
    if (ml->color != null) {
      {
#line 447
      free((void *)ml->color);
      }
    }
  }
#line 453
  *ml = mline_zero;
}
}
#line 457 "/tmp/screen-3.9.15/resize.c"
static int AllocMline(struct mline *ml , int w ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = malloc((unsigned long )w);
#line 461
  ml->image = (unsigned char *)__cil_tmp3;
#line 462
  ml->attr = null;
#line 464
  ml->font = null;
#line 467
  ml->color = null;
  }
#line 472
  if (ml->image == (unsigned char *)0) {
#line 473
    return (- 1);
  }
#line 474
  return (0);
}
}
#line 479 "/tmp/screen-3.9.15/resize.c"
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) 
{ 
  int r ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 483
  r = 0;
#line 485
  bcopy((void const   *)((char *)mlf->image + xf), (void *)((char *)mlt->image + xt),
        (size_t )l);
  }
#line 486
  if (mlf->attr != null) {
#line 486
    if (mlt->attr == null) {
      {
#line 488
      __cil_tmp8 = malloc((unsigned long )w);
#line 488
      mlt->attr = (unsigned char *)__cil_tmp8;
      }
#line 488
      if (mlt->attr == (unsigned char *)0) {
#line 489
        r = - 1;
#line 489
        mlt->attr = null;
      }
      {
#line 490
      bzero((void *)((char *)mlt->attr), (unsigned long )w);
      }
    }
  }
#line 492
  if (mlt->attr != null) {
    {
#line 493
    bcopy((void const   *)((char *)mlf->attr + xf), (void *)((char *)mlt->attr + xt),
          (size_t )l);
    }
  }
#line 495
  if (mlf->font != null) {
#line 495
    if (mlt->font == null) {
      {
#line 497
      __cil_tmp9 = malloc((unsigned long )w);
#line 497
      mlt->font = (unsigned char *)__cil_tmp9;
      }
#line 497
      if (mlt->font == (unsigned char *)0) {
#line 498
        r = - 1;
#line 498
        mlt->font = null;
      }
      {
#line 499
      bzero((void *)((char *)mlt->font), (unsigned long )w);
      }
    }
  }
#line 501
  if (mlt->font != null) {
    {
#line 502
    bcopy((void const   *)((char *)mlf->font + xf), (void *)((char *)mlt->font + xt),
          (size_t )l);
    }
  }
#line 505
  if (mlf->color != null) {
#line 505
    if (mlt->color == null) {
      {
#line 507
      __cil_tmp10 = malloc((unsigned long )w);
#line 507
      mlt->color = (unsigned char *)__cil_tmp10;
      }
#line 507
      if (mlt->color == (unsigned char *)0) {
#line 508
        r = - 1;
#line 508
        mlt->color = null;
      }
      {
#line 509
      bzero((void *)((char *)mlt->color), (unsigned long )w);
      }
    }
  }
#line 511
  if (mlt->color != null) {
    {
#line 512
    bcopy((void const   *)((char *)mlf->color + xf), (void *)((char *)mlt->color + xt),
          (size_t )l);
    }
  }
#line 524
  return (r);
}
}
#line 528
static int maxwidth ;
#line 531 "/tmp/screen-3.9.15/resize.c"
static void CheckMaxSize(int wi ) 
{ 
  unsigned char *oldnull ;
  struct win *p ;
  int i ;
  struct mline *ml ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  struct mline *__cil_tmp13 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;

  {
#line 534
  oldnull = null;
#line 539
  wi = ((wi + 1) + 255) & -256;
#line 540
  if (wi <= maxwidth) {
#line 541
    return;
  }
#line 542
  maxwidth = wi;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  __cil_tmp6 = xrealloc((char *)blank, maxwidth);
#line 544
  blank = (unsigned char *)__cil_tmp6;
#line 545
  __cil_tmp7 = xrealloc((char *)null, maxwidth);
#line 545
  null = (unsigned char *)__cil_tmp7;
#line 546
  __cil_tmp8 = xrealloc((char *)mline_old.image, maxwidth);
#line 546
  mline_old.image = (unsigned char *)__cil_tmp8;
#line 547
  __cil_tmp9 = xrealloc((char *)mline_old.attr, maxwidth);
#line 547
  mline_old.attr = (unsigned char *)__cil_tmp9;
#line 549
  __cil_tmp10 = xrealloc((char *)mline_old.font, maxwidth);
#line 549
  mline_old.font = (unsigned char *)__cil_tmp10;
#line 552
  __cil_tmp11 = xrealloc((char *)mline_old.color, maxwidth);
#line 552
  mline_old.color = (unsigned char *)__cil_tmp11;
  }
#line 557
  if (! (((((blank && null) && mline_old.image) && mline_old.attr) && mline_old.font) && mline_old.color)) {
    {
#line 558
    Panic(0, (char *)strnomem);
    }
  }
  {
#line 560
  MakeBlankLine(blank, maxwidth);
#line 561
  bzero((void *)((char *)null), (unsigned long )maxwidth);
#line 563
  mline_blank.image = blank;
#line 564
  mline_blank.attr = null;
#line 565
  mline_null.image = null;
#line 566
  mline_null.attr = null;
#line 568
  mline_blank.font = null;
#line 569
  mline_null.font = null;
#line 572
  mline_blank.color = null;
#line 573
  mline_null.color = null;
#line 583
  p = windows;
  }
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! p) {
#line 583
      goto while_break___0;
    }
#line 585
    ml = p->w_mlines;
#line 586
    i = 0;
    {
#line 586
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 586
      if (! (i < p->w_layer.l_height)) {
#line 586
        goto while_break___1;
      }
#line 588
      if (ml->attr == oldnull) {
#line 589
        ml->attr = null;
      }
#line 591
      if (ml->font == oldnull) {
#line 592
        ml->font = null;
      }
#line 595
      if (ml->color == oldnull) {
#line 596
        ml->color = null;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 586
    __cil_tmp13 = ml;
#line 586
    ml ++;
#line 586
    __cil_tmp12 = i;
#line 586
    i ++;
#line 604
    ml = p->w_hlines;
#line 605
    i = 0;
    {
#line 605
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 605
      if (! (i < p->w_histheight)) {
#line 605
        goto while_break___2;
      }
#line 607
      if (ml->attr == oldnull) {
#line 608
        ml->attr = null;
      }
#line 610
      if (ml->font == oldnull) {
#line 611
        ml->font = null;
      }
#line 614
      if (ml->color == oldnull) {
#line 615
        ml->color = null;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 605
    __cil_tmp15 = ml;
#line 605
    ml ++;
#line 605
    __cil_tmp14 = i;
#line 605
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 583
  p = p->w_next;
}
}
#line 628 "/tmp/screen-3.9.15/resize.c"
char *xrealloc(char *mem , int len ) 
{ 
  register char *nmem ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 634
  if (mem == (char *)0) {
    {
#line 635
    __cil_tmp4 = malloc((unsigned long )len);
    }
#line 635
    return ((char *)__cil_tmp4);
  }
  {
#line 636
  __cil_tmp5 = realloc((void *)mem, (unsigned long )len);
#line 636
  nmem = (char *)__cil_tmp5;
  }
#line 636
  if (nmem) {
#line 637
    return (nmem);
  }
  {
#line 638
  free((void *)mem);
  }
#line 639
  return ((char *)0);
}
}
#line 643 "/tmp/screen-3.9.15/resize.c"
static void MakeBlankLine(unsigned char *p , int n ) 
{ 
  int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! __cil_tmp3) {
#line 647
      goto while_break;
    }
#line 648
    __cil_tmp4 = p;
#line 648
    p ++;
#line 648
    *__cil_tmp4 = (unsigned char )' ';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 671 "/tmp/screen-3.9.15/resize.c"
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) 
{ 
  struct mline *mlf ;
  struct mline *mlt ;
  struct mline *ml ;
  struct mline *nmlines ;
  struct mline *nhlines ;
  int fy ;
  int ty ;
  int l ;
  int lx ;
  int lf ;
  int lt ;
  int yy ;
  int oty ;
  int addone ;
  int ncx ;
  int ncy ;
  int naka ;
  int t ;
  int y ;
  int shift ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  struct mline *tmp ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  struct mline *tmp___0 ;
  int __cil_tmp33 ;
  struct mline *tmp___1 ;
  struct mline *tmp___359 ;
  struct mline *tmp___360 ;
  struct mline *tmp___361 ;
  int __cil_tmp38 ;
  struct mline *tmp___362 ;
  int __cil_tmp41 ;
  int tmp___363 ;
  int __cil_tmp43 ;
  int tmp___364 ;
  int __cil_tmp45 ;
  int tmp___365 ;
  struct mline *tmp___366 ;
  struct mline *tmp___367 ;
  int __cil_tmp49 ;
  struct mline *tmp___368 ;
  int tmp___369 ;
  int tmp___370 ;
  struct mline *tmp___371 ;
  struct mline *tmp___372 ;
  struct mline *tmp___373 ;
  int __cil_tmp56 ;
  struct mline *tmp___374 ;
  int tmp___375 ;
  struct mline *tmp___376 ;
  int __cil_tmp61 ;
  int tmp___377 ;
  int __cil_tmp64 ;

  {
#line 675
  mlf = (struct mline *)0;
#line 675
  mlt = (struct mline *)0;
#line 680
  if (wi == 0) {
#line 681
    hi = 0;
#line 681
    he = hi;
  }
#line 683
  if (p->w_layer.l_width == wi) {
#line 683
    if (p->w_layer.l_height == he) {
#line 683
      if (p->w_histheight == hi) {
        {
#line 685
        while (1) {
          while_continue: /* CIL Label */ ;
#line 685
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 686
        return (0);
      }
    }
  }
  {
#line 689
  CheckMaxSize(wi);
  }
  {
#line 701
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 701
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 702
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 702
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 703
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 703
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 705
  fy = (p->w_histheight + p->w_layer.l_height) - 1;
#line 706
  ty = (hi + he) - 1;
#line 708
  nhlines = (struct mline *)0;
#line 708
  nmlines = nhlines;
#line 709
  ncx = 0;
#line 710
  ncy = 0;
#line 711
  naka = 0;
#line 713
  if (wi) {
#line 715
    if (wi != p->w_layer.l_width) {
      _L: /* CIL Label */ 
      {
#line 717
      __cil_tmp25 = calloc((unsigned long )he, sizeof(struct mline ));
#line 717
      nmlines = (struct mline *)__cil_tmp25;
      }
#line 717
      if (nmlines == (struct mline *)0) {
        {
#line 719
        KillWindow(p);
#line 720
        Msg(0, (char *)strnomem);
        }
#line 721
        return (- 1);
      }
    } else
#line 715
    if (he != p->w_layer.l_height) {
#line 715
      goto _L;
    } else {
      {
#line 726
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 726
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 727
      nmlines = p->w_mlines;
#line 728
      fy -= he;
#line 729
      ty -= he;
#line 730
      ncx = p->w_layer.l_x;
#line 731
      ncy = p->w_layer.l_y;
#line 732
      naka = p->w_autoaka;
    }
  }
#line 736
  if (hi) {
    {
#line 738
    __cil_tmp26 = calloc((unsigned long )hi, sizeof(struct mline ));
#line 738
    nhlines = (struct mline *)__cil_tmp26;
    }
#line 738
    if (nhlines == (struct mline *)0) {
      {
#line 740
      Msg(0, (char *)"No memory for history buffer - turned off");
#line 741
      hi = 0;
#line 742
      ty = he - 1;
      }
    }
  }
#line 748
  addone = 0;
#line 749
  if (p->w_layer.l_width) {
#line 749
    if (p->w_layer.l_x == p->w_layer.l_width) {
      {
#line 751
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 751
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 752
      addone = 1;
#line 753
      __cil_tmp27 = p->w_layer.l_x;
#line 753
      (p->w_layer.l_x) --;
    }
  }
#line 757
  if (p->w_layer.l_width == wi) {
#line 759
    ncx = p->w_layer.l_x + addone;
#line 760
    ncy = (p->w_layer.l_y + he) - p->w_layer.l_height;
#line 762
    shift = - ncy;
#line 763
    yy = (p->w_layer.l_y + p->w_histheight) - 1;
    {
#line 763
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 763
      if (! (yy >= 0 && ncy + shift < he)) {
#line 763
        goto while_break___5;
      }
#line 765
      if (yy < p->w_histheight) {
#line 765
        tmp = & *(p->w_hlines + (p->w_histidx + yy) % p->w_histheight);
      } else {
#line 765
        tmp = & *(p->w_mlines + (yy - p->w_histheight));
      }
#line 765
      ml = tmp;
#line 766
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 767
        goto while_break___5;
      }
#line 768
      shift ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 763
    __cil_tmp30 = yy;
#line 763
    yy --;
#line 770
    if (shift < 0) {
#line 771
      shift = 0;
    } else {
      {
#line 773
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 773
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 774
    ncy += shift;
#line 775
    if (p->w_autoaka > 0) {
#line 777
      naka = ((p->w_autoaka + he) - p->w_layer.l_height) + shift;
#line 778
      if (naka < 1) {
#line 779
        naka = 0;
      } else
#line 778
      if (naka > he) {
#line 779
        naka = 0;
      }
    }
    {
#line 781
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 781
      if (! (__cil_tmp31 > 0)) {
#line 781
        goto while_break___7;
      }
#line 783
      if (fy < p->w_histheight) {
#line 783
        tmp___0 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
      } else {
#line 783
        tmp___0 = & *(p->w_mlines + (fy - p->w_histheight));
      }
      {
#line 783
      ml = tmp___0;
#line 784
      FreeMline(ml);
#line 785
      __cil_tmp33 = fy;
#line 785
      fy --;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 788
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 788
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 789
  if (fy >= 0) {
#line 790
    if (fy < p->w_histheight) {
#line 790
      tmp___1 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
    } else {
#line 790
      tmp___1 = & *(p->w_mlines + (fy - p->w_histheight));
    }
#line 790
    mlf = tmp___1;
  }
#line 791
  if (ty >= 0) {
#line 792
    if (ty < hi) {
#line 792
      tmp___359 = & *(nhlines + ty);
    } else {
#line 792
      tmp___359 = & *(nmlines + (ty - hi));
    }
#line 792
    mlt = tmp___359;
  }
  {
#line 794
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 794
    if (! (fy >= 0 && ty >= 0)) {
#line 794
      goto while_break___9;
    }
#line 796
    if (p->w_layer.l_width == wi) {
#line 799
      *mlt = *mlf;
#line 800
      *mlf = mline_zero;
#line 801
      fy --;
#line 801
      if (fy >= 0) {
#line 802
        if (fy < p->w_histheight) {
#line 802
          tmp___360 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
        } else {
#line 802
          tmp___360 = & *(p->w_mlines + (fy - p->w_histheight));
        }
#line 802
        mlf = tmp___360;
      }
#line 803
      ty --;
#line 803
      if (ty >= 0) {
#line 804
        if (ty < hi) {
#line 804
          tmp___361 = & *(nhlines + ty);
        } else {
#line 804
          tmp___361 = & *(nmlines + (ty - hi));
        }
#line 804
        mlt = tmp___361;
      }
#line 805
      goto while_continue___9;
    }
#line 809
    l = p->w_layer.l_width - 1;
    {
#line 809
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 809
      if (! (l > 0)) {
#line 809
        goto while_break___10;
      }
#line 810
      if ((int )*(mlf->image + l) != 32) {
#line 811
        goto while_break___10;
      } else
#line 810
      if ((int )*(mlf->attr + l)) {
#line 811
        goto while_break___10;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 809
    __cil_tmp38 = l;
#line 809
    l --;
#line 812
    if (fy == p->w_layer.l_y + p->w_histheight) {
#line 812
      if (l < p->w_layer.l_x) {
#line 813
        l = p->w_layer.l_x;
      }
    }
#line 814
    l ++;
#line 815
    lf = l;
#line 818
    yy = fy - 1;
    {
#line 818
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 818
      if (! (yy >= 0)) {
#line 818
        goto while_break___11;
      }
#line 820
      if (yy < p->w_histheight) {
#line 820
        tmp___362 = & *(p->w_hlines + (p->w_histidx + yy) % p->w_histheight);
      } else {
#line 820
        tmp___362 = & *(p->w_mlines + (yy - p->w_histheight));
      }
#line 820
      ml = tmp___362;
#line 821
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 822
        goto while_break___11;
      }
#line 823
      l += p->w_layer.l_width;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 818
    __cil_tmp41 = yy;
#line 818
    yy --;
#line 827
    lt = (l - 1) % wi + 1;
#line 828
    oty = ty;
    {
#line 829
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 829
      if (! ((l > 0 && fy >= 0) && ty >= 0)) {
#line 829
        goto while_break___12;
      }
#line 831
      if (lt > lf) {
#line 831
        tmp___363 = lf;
      } else {
#line 831
        tmp___363 = lt;
      }
#line 831
      lx = tmp___363;
#line 832
      if (mlt->image == (unsigned char *)0) {
        {
#line 834
        __cil_tmp43 = AllocMline(mlt, wi + 1);
        }
#line 834
        if (__cil_tmp43) {
#line 835
          goto nomem;
        }
        {
#line 836
        MakeBlankLine(mlt->image + lt, wi - lt);
        }
#line 837
        if (oty == ty) {
#line 837
          tmp___364 = ' ';
        } else {
#line 837
          tmp___364 = 0;
        }
#line 837
        *(mlt->image + wi) = (unsigned char )tmp___364;
      }
      {
#line 839
      __cil_tmp45 = BcopyMline(mlf, lf - lx, mlt, lt - lx, lx, wi + 1);
      }
#line 839
      if (__cil_tmp45) {
#line 840
        goto nomem;
      }
#line 843
      if (fy == p->w_layer.l_y + p->w_histheight) {
#line 843
        if (lf - lx <= p->w_layer.l_x) {
#line 843
          if (lf > p->w_layer.l_x) {
#line 845
            ncx = ((p->w_layer.l_x + lt) - lf) + addone;
#line 846
            ncy = ty - hi;
#line 847
            if (wi) {
#line 847
              tmp___365 = - ncy + (l - lx) / wi;
            } else {
#line 847
              tmp___365 = 0;
            }
#line 847
            shift = tmp___365;
#line 848
            if (ty + shift > (hi + he) - 1) {
#line 849
              shift = ((hi + he) - 1) - ty;
            }
#line 850
            if (shift > 0) {
              {
#line 852
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 852
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 853
              y = (hi + he) - 1;
              {
#line 853
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 853
                if (! (y >= ty)) {
#line 853
                  goto while_break___14;
                }
#line 855
                if (y < hi) {
#line 855
                  tmp___366 = & *(nhlines + y);
                } else {
#line 855
                  tmp___366 = & *(nmlines + (y - hi));
                }
                {
#line 855
                mlt = tmp___366;
#line 856
                FreeMline(mlt);
                }
#line 857
                if (y - shift < ty) {
#line 858
                  goto while_continue___14;
                }
#line 859
                if (y - shift < hi) {
#line 859
                  tmp___367 = & *(nhlines + (y - shift));
                } else {
#line 859
                  tmp___367 = & *(nmlines + ((y - shift) - hi));
                }
#line 859
                ml = tmp___367;
#line 860
                *mlt = *ml;
#line 861
                *ml = mline_zero;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 853
              __cil_tmp49 = y;
#line 853
              y --;
#line 863
              ncy += shift;
#line 864
              ty += shift;
#line 865
              if (ty < hi) {
#line 865
                tmp___368 = & *(nhlines + ty);
              } else {
#line 865
                tmp___368 = & *(nmlines + (ty - hi));
              }
#line 865
              mlt = tmp___368;
#line 866
              if (naka > 0) {
#line 867
                if (naka + shift > he) {
#line 867
                  tmp___369 = 0;
                } else {
#line 867
                  tmp___369 = naka + shift;
                }
#line 867
                naka = tmp___369;
              }
            }
            {
#line 869
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 869
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
      }
#line 872
      if (p->w_autoaka > 0) {
#line 872
        if (fy == (p->w_autoaka - 1) + p->w_histheight) {
#line 872
          if (lf - lx <= 0) {
#line 873
            if (ty - hi >= 0) {
#line 873
              tmp___370 = (1 + ty) - hi;
            } else {
#line 873
              tmp___370 = 0;
            }
#line 873
            naka = tmp___370;
          }
        }
      }
#line 875
      lf -= lx;
#line 876
      lt -= lx;
#line 877
      l -= lx;
#line 878
      if (lf == 0) {
        {
#line 880
        FreeMline(mlf);
#line 881
        lf = p->w_layer.l_width;
#line 882
        fy --;
        }
#line 882
        if (fy >= 0) {
#line 883
          if (fy < p->w_histheight) {
#line 883
            tmp___371 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
          } else {
#line 883
            tmp___371 = & *(p->w_mlines + (fy - p->w_histheight));
          }
#line 883
          mlf = tmp___371;
        }
      }
#line 885
      if (lt == 0) {
#line 887
        lt = wi;
#line 888
        ty --;
#line 888
        if (ty >= 0) {
#line 889
          if (ty < hi) {
#line 889
            tmp___372 = & *(nhlines + ty);
          } else {
#line 889
            tmp___372 = & *(nmlines + (ty - hi));
          }
#line 889
          mlt = tmp___372;
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 892
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 892
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 894
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 894
    if (! (fy >= 0)) {
#line 894
      goto while_break___17;
    }
    {
#line 896
    FreeMline(mlf);
#line 897
    fy --;
    }
#line 897
    if (fy >= 0) {
#line 898
      if (fy < p->w_histheight) {
#line 898
        tmp___373 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
      } else {
#line 898
        tmp___373 = & *(p->w_mlines + (fy - p->w_histheight));
      }
#line 898
      mlf = tmp___373;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 900
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 900
    if (! (ty >= 0)) {
#line 900
      goto while_break___18;
    }
    {
#line 902
    __cil_tmp56 = AllocMline(mlt, wi + 1);
    }
#line 902
    if (__cil_tmp56) {
#line 903
      goto nomem;
    }
    {
#line 904
    MakeBlankLine(mlt->image, wi + 1);
#line 905
    ty --;
    }
#line 905
    if (ty >= 0) {
#line 906
      if (ty < hi) {
#line 906
        tmp___374 = & *(nhlines + ty);
      } else {
#line 906
        tmp___374 = & *(nmlines + (ty - hi));
      }
#line 906
      mlt = tmp___374;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 918
  if (p->w_mlines) {
#line 918
    if (p->w_mlines != nmlines) {
      {
#line 919
      free((void *)((char *)p->w_mlines));
      }
    }
  }
#line 920
  p->w_mlines = nmlines;
#line 922
  if (p->w_hlines) {
#line 922
    if (p->w_hlines != nhlines) {
      {
#line 923
      free((void *)((char *)p->w_hlines));
      }
    }
  }
#line 924
  p->w_hlines = nhlines;
#line 926
  nhlines = (struct mline *)0;
#line 926
  nmlines = nhlines;
#line 929
  if (p->w_layer.l_width != wi) {
#line 931
    if (wi) {
#line 933
      if (p->w_tabs) {
#line 933
        tmp___375 = p->w_layer.l_width;
      } else {
#line 933
        tmp___375 = 0;
      }
      {
#line 933
      t = tmp___375;
#line 934
      p->w_tabs = xrealloc(p->w_tabs, wi + 1);
      }
#line 935
      if (p->w_tabs == (char *)0) {
        nomem: 
#line 938
        if (nmlines) {
#line 940
          ty = (he + hi) - 1;
          {
#line 940
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 940
            if (! (ty >= 0)) {
#line 940
              goto while_break___19;
            }
#line 942
            if (ty < hi) {
#line 942
              tmp___376 = & *(nhlines + ty);
            } else {
#line 942
              tmp___376 = & *(nmlines + (ty - hi));
            }
            {
#line 942
            mlt = tmp___376;
#line 943
            FreeMline(mlt);
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 940
          __cil_tmp61 = ty;
#line 940
          ty --;
#line 945
          if (nmlines) {
#line 945
            if (p->w_mlines != nmlines) {
              {
#line 946
              free((void *)((char *)nmlines));
              }
            }
          }
#line 948
          if (nhlines) {
#line 948
            if (p->w_hlines != nhlines) {
              {
#line 949
              free((void *)((char *)nhlines));
              }
            }
          }
        }
        {
#line 952
        KillWindow(p);
#line 953
        Msg(0, (char *)strnomem);
        }
#line 954
        return (- 1);
      }
      {
#line 956
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 956
        if (! (t < wi)) {
#line 956
          goto while_break___20;
        }
#line 957
        if (t && ! (t & 7)) {
#line 957
          tmp___377 = 1;
        } else {
#line 957
          tmp___377 = 0;
        }
#line 957
        *(p->w_tabs + t) = (char )tmp___377;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 956
      t ++;
#line 958
      *(p->w_tabs + wi) = (char )0;
    } else {
#line 962
      if (p->w_tabs) {
        {
#line 963
        free((void *)p->w_tabs);
        }
      }
#line 964
      p->w_tabs = (char *)0;
    }
  }
#line 969
  p->w_Saved_y += ncy - p->w_layer.l_y;
#line 971
  p->w_layer.l_x = ncx;
#line 972
  p->w_layer.l_y = ncy;
#line 973
  if (p->w_autoaka > 0) {
#line 974
    p->w_autoaka = naka;
  }
#line 977
  if (p->w_layer.l_x > wi) {
#line 978
    p->w_layer.l_x = wi;
  }
#line 979
  if (p->w_layer.l_y >= he) {
#line 980
    p->w_layer.l_y = he - 1;
  }
#line 981
  if (p->w_Saved_x > wi) {
#line 982
    p->w_Saved_x = wi;
  }
#line 983
  if (p->w_Saved_y < 0) {
#line 984
    p->w_Saved_y = 0;
  }
#line 985
  if (p->w_Saved_y >= he) {
#line 986
    p->w_Saved_y = he - 1;
  }
#line 989
  p->w_top = 0;
#line 990
  p->w_bot = he - 1;
#line 994
  if (wi) {
#line 994
    if (p->w_layer.l_width != wi) {
      _L___378: /* CIL Label */ 
#line 994
      if (p->w_ptyfd >= 0) {
#line 994
        if (p->w_pid) {
#line 996
          glwz.ws_col = (unsigned short )wi;
#line 997
          glwz.ws_row = (unsigned short )he;
          {
#line 998
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 998
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 999
          __cil_tmp64 = ioctl(p->w_ptyfd, (unsigned long )21524, (char *)(& glwz));
          }
#line 999
          if (__cil_tmp64) {
            {
#line 1000
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 1000
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        }
      }
    } else
#line 994
    if (p->w_layer.l_height != he) {
#line 994
      goto _L___378;
    }
  }
#line 1005
  p->w_layer.l_width = wi;
#line 1006
  p->w_layer.l_height = he;
#line 1008
  p->w_histidx = 0;
#line 1009
  p->w_histheight = hi;
#line 1035
  return (0);
}
}
#line 1039 "/tmp/screen-3.9.15/resize.c"
void FreeAltScreen(struct win *p ) 
{ 
  int i ;

  {
#line 1044
  if (p->w_alt_mlines) {
#line 1045
    i = 0;
    {
#line 1045
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1045
      if (! (i < p->w_alt_height)) {
#line 1045
        goto while_break;
      }
      {
#line 1046
      FreeMline(p->w_alt_mlines + i);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1045
    i ++;
  }
#line 1047
  p->w_alt_mlines = (struct mline *)0;
#line 1048
  p->w_alt_width = 0;
#line 1049
  p->w_alt_height = 0;
#line 1050
  p->w_alt_x = 0;
#line 1051
  p->w_alt_y = 0;
#line 1053
  if (p->w_alt_hlines) {
#line 1054
    i = 0;
    {
#line 1054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1054
      if (! (i < p->w_alt_histheight)) {
#line 1054
        goto while_break___0;
      }
      {
#line 1055
      FreeMline(p->w_alt_hlines + i);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1054
    i ++;
  }
#line 1056
  p->w_alt_hlines = (struct mline *)0;
#line 1057
  p->w_alt_histidx = 0;
#line 1059
  p->w_alt_histheight = 0;
}
}
#line 1063 "/tmp/screen-3.9.15/resize.c"
static void SwapAltScreen(struct win *p ) 
{ 
  struct mline *ml ;
  int t ;

  {
#line 1069
  ml = p->w_alt_mlines;
#line 1069
  p->w_alt_mlines = p->w_mlines;
#line 1069
  p->w_mlines = ml;
#line 1070
  t = p->w_alt_width;
#line 1070
  p->w_alt_width = p->w_layer.l_width;
#line 1070
  p->w_layer.l_width = t;
#line 1071
  t = p->w_alt_height;
#line 1071
  p->w_alt_height = p->w_layer.l_height;
#line 1071
  p->w_layer.l_height = t;
#line 1072
  t = p->w_alt_histheight;
#line 1072
  p->w_alt_histheight = p->w_histheight;
#line 1072
  p->w_histheight = t;
#line 1073
  t = p->w_alt_x;
#line 1073
  p->w_alt_x = p->w_layer.l_x;
#line 1073
  p->w_layer.l_x = t;
#line 1074
  t = p->w_alt_y;
#line 1074
  p->w_alt_y = p->w_layer.l_y;
#line 1074
  p->w_layer.l_y = t;
#line 1076
  ml = p->w_alt_hlines;
#line 1076
  p->w_alt_hlines = p->w_hlines;
#line 1076
  p->w_hlines = ml;
#line 1077
  t = p->w_alt_histidx;
#line 1077
  p->w_alt_histidx = p->w_histidx;
#line 1077
  p->w_histidx = t;
}
}
#line 1082 "/tmp/screen-3.9.15/resize.c"
void EnterAltScreen(struct win *p ) 
{ 
  int ox ;
  int oy ;

  {
#line 1085
  ox = p->w_layer.l_x;
  {
#line 1085
  oy = p->w_layer.l_y;
#line 1086
  FreeAltScreen(p);
#line 1087
  SwapAltScreen(p);
#line 1088
  ChangeWindowSize(p, p->w_alt_width, p->w_alt_height, p->w_alt_histheight);
#line 1089
  p->w_layer.l_x = ox;
#line 1090
  p->w_layer.l_y = oy;
  }
}
}
#line 1094 "/tmp/screen-3.9.15/resize.c"
void LeaveAltScreen(struct win *p ) 
{ 


  {
#line 1097
  if (! p->w_alt_mlines) {
#line 1098
    return;
  }
  {
#line 1099
  SwapAltScreen(p);
#line 1100
  ChangeWindowSize(p, p->w_alt_width, p->w_alt_height, p->w_alt_histheight);
#line 1101
  FreeAltScreen(p);
  }
}
}
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 708
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 725
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 984
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 650 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 341 "./extern.h"
void bclear(char *p , int n ) ;
#line 359
char *expand_vars(char *ss , struct display *d ) ;
#line 48 "/tmp/screen-3.9.15/misc.c"
char *SaveStr(char const   *str ) 
{ 
  register char *cp ;
  size_t __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 53
  __cil_tmp3 = strlen(str);
#line 53
  __cil_tmp4 = malloc(__cil_tmp3 + 1UL);
#line 53
  cp = (char *)__cil_tmp4;
  }
#line 53
  if (cp == (char *)((void *)0)) {
    {
#line 54
    Panic(0, (char *)strnomem);
    }
  } else {
    {
#line 56
    strcpy(cp, str);
    }
  }
#line 57
  return (cp);
}
}
#line 62 "/tmp/screen-3.9.15/misc.c"
char *InStr(char *str , char const   *pat ) 
{ 
  int npat ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 66
  __cil_tmp4 = strlen(pat);
#line 66
  npat = (int )__cil_tmp4;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! *str) {
#line 67
      goto while_break;
    }
    {
#line 68
    __cil_tmp5 = strncmp((char const   *)str, pat, (unsigned long )npat);
    }
#line 68
    if (! __cil_tmp5) {
#line 69
      return (str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  str ++;
#line 70
  return ((char *)0);
}
}
#line 90 "/tmp/screen-3.9.15/misc.c"
void centerline(char *str , int y ) 
{ 
  int l ;
  int n ;
  size_t __cil_tmp5 ;

  {
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  __cil_tmp5 = strlen((char const   *)str);
#line 97
  n = (int )__cil_tmp5;
  }
#line 98
  if (n > flayer->l_width - 1) {
#line 99
    n = flayer->l_width - 1;
  }
  {
#line 100
  l = ((flayer->l_width - 1) - n) / 2;
#line 101
  LPutStr(flayer, str, n, & mchar_blank, l, y);
  }
}
}
#line 105 "/tmp/screen-3.9.15/misc.c"
void leftline(char *str , int y ) 
{ 
  int l ;
  int n ;
  struct mchar mchar_dol ;
  size_t __cil_tmp6 ;

  {
#line 112
  mchar_dol = mchar_blank;
#line 113
  mchar_dol.image = (unsigned char )'$';
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  __cil_tmp6 = strlen((char const   *)str);
#line 116
  n = (int )__cil_tmp6;
#line 116
  l = n;
  }
#line 117
  if (n > flayer->l_width - 1) {
#line 118
    n = flayer->l_width - 1;
  }
  {
#line 119
  LPutStr(flayer, str, n, & mchar_blank, 0, y);
  }
#line 120
  if (n != l) {
    {
#line 121
    LPutChar(flayer, & mchar_dol, n, y);
    }
  }
}
}
#line 126 "/tmp/screen-3.9.15/misc.c"
char *Filename(char *s ) 
{ 
  register char *p ;
  char *__cil_tmp3 ;

  {
#line 129
  p = s;
#line 131
  if (p) {
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! *p) {
#line 132
        goto while_break;
      }
#line 133
      __cil_tmp3 = p;
#line 133
      p ++;
#line 133
      if ((int )*__cil_tmp3 == 47) {
#line 134
        s = p;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 135
  return (s);
}
}
#line 139 "/tmp/screen-3.9.15/misc.c"
char *stripdev(char *nam ) 
{ 
  int __cil_tmp2 ;

  {
#line 159
  if (nam == (char *)((void *)0)) {
#line 160
    return ((char *)((void *)0));
  }
  {
#line 161
  __cil_tmp2 = strncmp((char const   *)nam, (char const   *)((char *)"/dev/"), (unsigned long )5);
  }
#line 161
  if (__cil_tmp2 == 0) {
#line 162
    return (nam + 5);
  }
#line 164
  return (nam);
}
}
#line 173 "/tmp/screen-3.9.15/misc.c"
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) 
{ 
  struct sigaction osa ;
  struct sigaction sa ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp7 ;

  {
  {
#line 183
  sa.__sigaction_handler.sa_handler = func;
#line 184
  __cil_tmp5 = sigemptyset(& sa.sa_mask);
  }
#line 186
  if (sig == 17) {
#line 186
    tmp = 268435456;
  } else {
#line 186
    tmp = 0;
  }
  {
#line 186
  sa.sa_flags = tmp;
#line 190
  __cil_tmp7 = sigaction(sig, & sa, & osa);
  }
#line 190
  if (__cil_tmp7) {
#line 191
    return ((void (*)(int  ))(- 1));
  }
#line 192
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 247 "/tmp/screen-3.9.15/misc.c"
void xseteuid(int euid ) 
{ 
  int oeuid ;
  __uid_t __cil_tmp3 ;
  __uid_t __cil_tmp4 ;
  __uid_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 252
  __cil_tmp3 = geteuid();
#line 252
  oeuid = (int )__cil_tmp3;
  }
#line 253
  if (oeuid == euid) {
#line 254
    return;
  }
  {
#line 255
  __cil_tmp4 = getuid();
  }
#line 255
  if (__cil_tmp4 != (unsigned int )euid) {
    {
#line 256
    __cil_tmp5 = getuid();
#line 256
    oeuid = (int )__cil_tmp5;
    }
  }
  {
#line 257
  __cil_tmp6 = setreuid((__uid_t )oeuid, (__uid_t )euid);
  }
#line 257
  if (__cil_tmp6) {
    {
#line 258
    __cil_tmp7 = __errno_location();
#line 258
    Panic(*__cil_tmp7, (char *)"setreuid");
    }
  }
}
}
#line 262 "/tmp/screen-3.9.15/misc.c"
void xsetegid(int egid ) 
{ 
  int oegid ;
  __gid_t __cil_tmp3 ;
  __gid_t __cil_tmp4 ;
  __gid_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 267
  __cil_tmp3 = getegid();
#line 267
  oegid = (int )__cil_tmp3;
  }
#line 268
  if (oegid == egid) {
#line 269
    return;
  }
  {
#line 270
  __cil_tmp4 = getgid();
  }
#line 270
  if (__cil_tmp4 != (unsigned int )egid) {
    {
#line 271
    __cil_tmp5 = getgid();
#line 271
    oegid = (int )__cil_tmp5;
    }
  }
  {
#line 272
  __cil_tmp6 = setregid((__gid_t )oegid, (__gid_t )egid);
  }
#line 272
  if (__cil_tmp6) {
    {
#line 273
    __cil_tmp7 = __errno_location();
#line 273
    Panic(*__cil_tmp7, (char *)"setregid");
    }
  }
}
}
#line 301 "/tmp/screen-3.9.15/misc.c"
void bclear(char *p , int n ) 
{ 


  {
  {
#line 305
  bcopy((void const   *)blank, (void *)p, (size_t )n);
  }
}
}
#line 310 "/tmp/screen-3.9.15/misc.c"
void Kill(int pid , int sig ) 
{ 
  int __cil_tmp3 ;

  {
#line 313
  if (pid < 2) {
#line 314
    return;
  }
  {
#line 315
  __cil_tmp3 = kill(pid, sig);
  }
}
}
#line 319 "/tmp/screen-3.9.15/misc.c"
void closeallfiles(int except ) 
{ 
  int f ;

  {
  {
#line 333
  f = getdtablesize();
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (f > 2)) {
#line 335
      goto while_break;
    }
#line 336
    if (f != except) {
      {
#line 337
      close(f);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 350
static int UserSTAT ;
#line 353 "/tmp/screen-3.9.15/misc.c"
int UserContext(void) 
{ 


  {
  {
#line 381
  xseteuid(real_uid);
#line 382
  xsetegid(real_gid);
  }
#line 383
  return (1);
}
}
#line 388 "/tmp/screen-3.9.15/misc.c"
void UserReturn(int val ) 
{ 


  {
  {
#line 397
  xseteuid(eff_uid);
#line 398
  xsetegid(eff_gid);
#line 399
  UserSTAT = val;
  }
}
}
#line 404 "/tmp/screen-3.9.15/misc.c"
int UserStatus(void) 
{ 


  {
#line 426
  return (UserSTAT);
}
}
#line 444 "/tmp/screen-3.9.15/misc.c"
int AddXChar(char *buf , int ch ) 
{ 
  char *p ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 448
  p = buf;
#line 450
  if (ch < 32) {
    _L: /* CIL Label */ 
#line 452
    __cil_tmp4 = p;
#line 452
    p ++;
#line 452
    *__cil_tmp4 = (char )'^';
#line 453
    __cil_tmp5 = p;
#line 453
    p ++;
#line 453
    *__cil_tmp5 = (char )(ch ^ 64);
  } else
#line 450
  if (ch == 127) {
#line 450
    goto _L;
  } else
#line 455
  if (ch >= 128) {
#line 457
    __cil_tmp6 = p;
#line 457
    p ++;
#line 457
    *__cil_tmp6 = (char )'\\';
#line 458
    __cil_tmp7 = p;
#line 458
    p ++;
#line 458
    *__cil_tmp7 = (char )(((ch >> 6) & 7) + 48);
#line 459
    __cil_tmp8 = p;
#line 459
    p ++;
#line 459
    *__cil_tmp8 = (char )(((ch >> 3) & 7) + 48);
#line 460
    __cil_tmp9 = p;
#line 460
    p ++;
#line 460
    *__cil_tmp9 = (char )((ch & 7) + 48);
  } else {
#line 463
    __cil_tmp10 = p;
#line 463
    p ++;
#line 463
    *__cil_tmp10 = (char )ch;
  }
#line 464
  return ((int )(p - buf));
}
}
#line 468 "/tmp/screen-3.9.15/misc.c"
int AddXChars(char *buf , int len , char *str ) 
{ 
  char *p ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 474
  if (str == (char *)0) {
#line 476
    *buf = (char )0;
#line 477
    return (0);
  }
#line 479
  len -= 4;
#line 480
  p = buf;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (p < buf + len && (int )*str)) {
#line 480
      goto while_break;
    }
#line 482
    if ((int )*str == 32) {
#line 483
      __cil_tmp5 = p;
#line 483
      p ++;
#line 483
      *__cil_tmp5 = *str;
    } else {
      {
#line 485
      __cil_tmp6 = AddXChar(p, (int )*str);
      }
#line 485
      p += __cil_tmp6;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  str ++;
#line 487
  *p = (char )0;
#line 488
  return ((int )(p - buf));
}
}
#line 520 "/tmp/screen-3.9.15/misc.c"
void sleep1000(int msec ) 
{ 
  struct timeval t ;

  {
  {
#line 526
  t.tv_sec = (long )(msec / 1000);
#line 527
  t.tv_usec = (long )((msec % 1000) * 1000);
#line 528
  select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, & t);
  }
}
}
#line 611 "/tmp/screen-3.9.15/misc.c"
void xsetenv(char *var , char *value ) 
{ 


  {
  {
#line 646
  setenv((char const   *)var, (char const   *)value, 1);
  }
}
}
#line 671 "/tmp/screen-3.9.15/misc.c"
char *expand_vars(char *ss , struct display *d ) 
{ 
  static char ebuf[2048] ;
  int esize ;
  int vtype ;
  int quofl ;
  register char *e ;
  register char *s ;
  register char *v ;
  char xbuf[11] ;
  int i ;
  char *p ;
  char c ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp17 ;
  char *tmp ;
  int __cil_tmp19 ;
  int tmp___379 ;
  int __cil_tmp21 ;
  int tmp___380 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int __cil_tmp32 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 676
  esize = (int )(sizeof(ebuf) - 1UL);
#line 676
  quofl = 0;
#line 677
  e = (char *)ebuf;
#line 678
  s = ss;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! ((((int )*s && (int )*s != 0) && (int )*s != 10) && esize > 0)) {
#line 683
      goto while_break;
    }
#line 685
    if ((int )*s == 39) {
#line 686
      quofl ^= 1;
    }
#line 687
    if ((int )*s == 36) {
#line 687
      if (! quofl) {
#line 691
        s ++;
#line 691
        p = s;
        {
#line 694
        if ((int )*s == '{') {
#line 694
          goto case_123;
        }
#line 701
        if ((int )*s == ':') {
#line 701
          goto case_58;
        }
#line 708
        goto switch_default;
        case_123: /* CIL Label */ 
#line 695
        s ++;
#line 695
        p = s;
        {
#line 696
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 696
          if (! ((int )*p != 125)) {
#line 696
            goto while_break___0;
          }
#line 697
          __cil_tmp14 = p;
#line 697
          p ++;
#line 697
          if ((int )*__cil_tmp14 == 0) {
#line 698
            return (ss);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 699
        vtype = 0;
#line 700
        goto switch_break;
        case_58: /* CIL Label */ 
#line 702
        s ++;
#line 702
        p = s;
        {
#line 703
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 703
          if (! ((int )*p != 58)) {
#line 703
            goto while_break___1;
          }
#line 704
          __cil_tmp15 = p;
#line 704
          p ++;
#line 704
          if ((int )*__cil_tmp15 == 0) {
#line 705
            return (ss);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 706
        vtype = 1;
#line 707
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 709
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 709
          if (! (((((int )*p >= 97 && (int )*p <= 122) || ((int )*p >= 65 && (int )*p <= 90)) || ((int )*p >= 48 && (int )*p <= 57)) || (int )*p == 95)) {
#line 709
            goto while_break___2;
          }
#line 710
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 711
        vtype = 0;
        switch_break: /* CIL Label */ ;
        }
#line 713
        c = *p;
        {
#line 714
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 714
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 715
        *p = (char )'\000';
#line 716
        if (vtype == 0) {
          {
#line 718
          v = (char *)xbuf;
#line 719
          __cil_tmp17 = strcmp((char const   *)s, (char const   *)((char *)"TERM"));
          }
#line 719
          if (__cil_tmp17 == 0) {
#line 720
            if (d) {
#line 720
              tmp = (char *)d->d_termname;
            } else {
#line 720
              tmp = (char *)"unknown";
            }
#line 720
            v = tmp;
          } else {
            {
#line 721
            __cil_tmp19 = strcmp((char const   *)s, (char const   *)((char *)"COLUMNS"));
            }
#line 721
            if (__cil_tmp19 == 0) {
#line 722
              if (d) {
#line 722
                tmp___379 = d->d_width;
              } else {
#line 722
                tmp___379 = - 1;
              }
              {
#line 722
              sprintf((char *)xbuf, (char const   *)((char *)"%d"), tmp___379);
              }
            } else {
              {
#line 723
              __cil_tmp21 = strcmp((char const   *)s, (char const   *)((char *)"LINES"));
              }
#line 723
              if (__cil_tmp21 == 0) {
#line 724
                if (d) {
#line 724
                  tmp___380 = d->d_height;
                } else {
#line 724
                  tmp___380 = - 1;
                }
                {
#line 724
                sprintf((char *)xbuf, (char const   *)((char *)"%d"), tmp___380);
                }
              } else {
                {
#line 726
                v = getenv((char const   *)s);
                }
              }
            }
          }
        } else {
          {
#line 729
          v = gettermcapstring(s);
          }
        }
#line 730
        if (v) {
          {
#line 732
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 732
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 733
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 733
            if (! ((int )*v && __cil_tmp25 > 0)) {
#line 733
              goto while_break___5;
            }
#line 734
            __cil_tmp27 = v;
#line 734
            v ++;
#line 734
            __cil_tmp26 = e;
#line 734
            e ++;
#line 734
            *__cil_tmp26 = *__cil_tmp27;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
          {
#line 737
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 737
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 738
        *p = c;
#line 738
        if ((int )*p == 125) {
#line 739
          p ++;
        } else
#line 738
        if ((int )c == 58) {
#line 739
          p ++;
        }
#line 740
        s = p;
      } else {
#line 687
        goto _L___384;
      }
    } else
    _L___384: /* CIL Label */ 
#line 742
    if ((int )*s == 94) {
#line 742
      if (! quofl) {
#line 744
        s ++;
#line 745
        __cil_tmp30 = s;
#line 745
        s ++;
#line 745
        i = (int )*__cil_tmp30;
#line 746
        if (i == 63) {
#line 747
          i = '\177';
        } else {
#line 749
          i &= 31;
        }
#line 750
        __cil_tmp31 = e;
#line 750
        e ++;
#line 750
        *__cil_tmp31 = (char )i;
#line 751
        __cil_tmp32 = esize;
#line 751
        esize --;
      } else {
#line 742
        goto _L___383;
      }
    } else {
      _L___383: /* CIL Label */ 
#line 759
      if ((int )*(s + 0) == 92) {
#line 759
        if (! quofl) {
#line 761
          if ((int )*(s + 1) >= 48) {
#line 761
            if ((int )*(s + 1) <= 55) {
#line 763
              s ++;
#line 764
              i = (int )*s - 48;
#line 765
              s ++;
#line 766
              if ((int )*s >= 48) {
#line 766
                if ((int )*s <= 55) {
#line 768
                  i = (i * 8 + (int )*s) - 48;
#line 769
                  s ++;
#line 770
                  if ((int )*s >= 48) {
#line 770
                    if ((int )*s <= 55) {
#line 772
                      i = (i * 8 + (int )*s) - 48;
#line 773
                      s ++;
                    }
                  }
                }
              }
              {
#line 776
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 776
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 777
              __cil_tmp37 = e;
#line 777
              e ++;
#line 777
              *__cil_tmp37 = (char )i;
#line 778
              __cil_tmp38 = esize;
#line 778
              esize --;
#line 779
              goto while_continue;
            } else {
#line 761
              goto _L___382;
            }
          } else
          _L___382: /* CIL Label */ 
#line 783
          if ((int )*(s + 1) == 36) {
#line 789
            s ++;
          } else
#line 783
          if ((int )*(s + 1) == 92) {
#line 783
            if ((int )*(s + 2) == 36) {
#line 789
              s ++;
            } else {
#line 783
              goto _L___381;
            }
          } else
          _L___381: /* CIL Label */ 
#line 783
          if ((int )*(s + 1) == 39) {
#line 789
            s ++;
          } else
#line 783
          if ((int )*(s + 1) == 92) {
#line 783
            if ((int )*(s + 2) == 39) {
#line 789
              s ++;
            } else {
#line 783
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 783
          if ((int )*(s + 1) == 94) {
#line 789
            s ++;
          } else
#line 783
          if ((int )*(s + 1) == 92) {
#line 783
            if ((int )*(s + 2) == 94) {
#line 789
              s ++;
            }
          }
        }
      }
#line 792
      __cil_tmp41 = s;
#line 792
      s ++;
#line 792
      __cil_tmp40 = e;
#line 792
      e ++;
#line 792
      *__cil_tmp40 = *__cil_tmp41;
#line 793
      __cil_tmp42 = esize;
#line 793
      esize --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if (esize <= 0) {
    {
#line 797
    Msg(0, (char *)"expand_vars: buffer overflow\n");
    }
  }
#line 798
  *e = (char )'\000';
  {
#line 799
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 799
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 800
  return ((char *)ebuf);
}
}
#line 809 "/tmp/screen-3.9.15/misc.c"
int _delay(int delay , int (*outc)(int  ) ) 
{ 
  int pad ;
  extern short ospeed___0 ;
  static short osp2pad[] ;
  int __cil_tmp6 ;

  {
#line 819
  if ((int )ospeed___0 <= 0) {
#line 820
    return (0);
  } else
#line 819
  if ((unsigned long )ospeed___0 >= sizeof(osp2pad) / sizeof(*((short *)osp2pad))) {
#line 820
    return (0);
  }
#line 821
  pad = (int )osp2pad[ospeed___0];
#line 822
  delay = (delay + pad / 2) / pad;
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (__cil_tmp6 > 0)) {
#line 823
      goto while_break;
    }
    {
#line 824
    ((int (*)(int  ))*outc)(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 825
  return (0);
}
}
#line 836
int (*save_outc)(int  ) ;
#line 841 "/tmp/screen-3.9.15/misc.c"
void xtputs(char *str , int affcnt , int (*outc)(int  ) ) 
{ 


  {
  {
#line 847
  save_outc = outc;
#line 848
  tputs((char const   *)str, affcnt, outc);
  }
}
}
#line 852 "/tmp/screen-3.9.15/misc.c"
int _nc_timed_wait(int mode , int ms , int *tlp ) 
{ 


  {
  {
#line 855
  _delay(ms * 10, save_outc);
  }
#line 856
  return (0);
}
}
#line 45 "/tmp/screen-3.9.15/mark.c"
static int is_letter(char c ) ;
#line 46
static void nextword(int *xp , int *yp , int flags , int num ) ;
#line 47
static int linestart(int y ) ;
#line 48
static int lineend(int y ) ;
#line 49
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) ;
#line 50
static int eq(int a , int b ) ;
#line 51
static int MarkScrollDownDisplay(int n ) ;
#line 52
static int MarkScrollUpDisplay(int n ) ;
#line 54
static void MarkProcess(char **inbufp , int *inlenp ) ;
#line 55
static void MarkAbort(void) ;
#line 56
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 57
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) ;
#line 66 "/tmp/screen-3.9.15/mark.c"
int pastefont  =    1;
#line 69 "/tmp/screen-3.9.15/mark.c"
static struct LayFuncs MarkLf  =    {MarkProcess, MarkAbort, MarkRedisplayLine, DefClearLine, MarkRewrite, DefResize,
    DefRestore};
#line 80 "/tmp/screen-3.9.15/mark.c"
int join_with_cr  =    0;
#line 81 "/tmp/screen-3.9.15/mark.c"
int compacthist  =    0;
#line 85
static struct markdata *markdata ;
#line 93 "/tmp/screen-3.9.15/mark.c"
static int is_letter(char c ) 
{ 


  {
#line 96
  if ((int )c >= 97) {
#line 96
    if ((int )c <= 122) {
#line 104
      return (1);
    } else {
#line 96
      goto _L___386;
    }
  } else
  _L___386: /* CIL Label */ 
#line 96
  if ((int )c >= 65) {
#line 96
    if ((int )c <= 90) {
#line 104
      return (1);
    } else {
#line 96
      goto _L___385;
    }
  } else
  _L___385: /* CIL Label */ 
#line 96
  if ((int )c >= 48) {
#line 96
    if ((int )c <= 57) {
#line 104
      return (1);
    } else {
#line 96
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 96
  if ((int )c == 95) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 46) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 64) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 58) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 37) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 33) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 45) {
#line 104
    return (1);
  } else
#line 96
  if ((int )c == 43) {
#line 104
    return (1);
  } else
#line 105
  if ((int )c != 32) {
#line 106
    return (2);
  }
#line 107
  return (0);
}
}
#line 111 "/tmp/screen-3.9.15/mark.c"
static int linestart(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *__cil_tmp5 ;

  {
#line 117
  i = tmp->image + x;
#line 117
  x = markdata->left_mar;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (x < fore->w_layer.l_width - 1)) {
#line 117
      goto while_break;
    }
#line 118
    __cil_tmp5 = i;
#line 118
    i ++;
#line 118
    if ((int )*__cil_tmp5 != 32) {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  x ++;
#line 120
  if (x == fore->w_layer.l_width - 1) {
#line 121
    x = markdata->left_mar;
  }
#line 122
  return (x);
}
}
#line 126 "/tmp/screen-3.9.15/mark.c"
static int lineend(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 132
  i = tmp->image + x;
#line 132
  x = markdata->right_mar;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (x >= 0)) {
#line 132
      goto while_break;
    }
#line 133
    __cil_tmp5 = i;
#line 133
    i --;
#line 133
    if ((int )*__cil_tmp5 != 32) {
#line 134
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  __cil_tmp6 = x;
#line 132
  x --;
#line 135
  if (x < 0) {
#line 136
    x = markdata->left_mar;
  }
#line 137
  return (x);
}
}
#line 156 "/tmp/screen-3.9.15/mark.c"
static void nextword(int *xp , int *yp , int flags , int num ) 
{ 
  int xx ;
  int yy ;
  register int sx ;
  register int oq ;
  register int q ;
  register int x ;
  register int y ;
  struct mline *ml ;
  int tmp ;
  struct mline *tmp___387 ;
  struct mline *tmp___389 ;
  struct mline *tmp___390 ;

  {
#line 159
  xx = fore->w_layer.l_width;
#line 159
  yy = fore->w_histheight + fore->w_layer.l_height;
#line 163
  x = *xp;
#line 164
  y = *yp;
#line 165
  if (flags & 1) {
#line 165
    tmp = - 1;
  } else {
#line 165
    tmp = 1;
  }
#line 165
  sx = tmp;
#line 166
  if (flags & (1 << 1)) {
#line 166
    if (flags & (1 << 2)) {
#line 167
      x += sx;
    }
  }
#line 168
  if (y < fore->w_histheight) {
#line 168
    tmp___387 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 168
    tmp___387 = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 168
  ml = tmp___387;
#line 169
  oq = - 1;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! 1) {
#line 169
      goto while_break;
    }
#line 171
    if (x >= xx) {
#line 172
      q = 0;
    } else
#line 171
    if (x < 0) {
#line 172
      q = 0;
    } else
#line 173
    if (flags & (1 << 3)) {
#line 174
      q = (int )*(ml->image + x) == 32;
    } else {
      {
#line 176
      q = is_letter((int )*(ml->image + x));
      }
    }
#line 177
    if (oq >= 0) {
#line 177
      if (oq != q) {
#line 179
        if (oq == 0) {
#line 180
          *xp = x;
        } else
#line 179
        if (! (flags & (1 << 1))) {
#line 180
          *xp = x;
        } else {
#line 182
          *xp = x - sx;
        }
#line 183
        *yp = y;
#line 184
        if (! (flags & (1 << 1))) {
#line 184
          if (q) {
            _L: /* CIL Label */ 
#line 187
            num --;
#line 187
            if (num <= 0) {
#line 188
              return;
            }
          } else {
#line 184
            goto _L___388;
          }
        } else
        _L___388: /* CIL Label */ 
#line 184
        if (flags & (1 << 1)) {
#line 184
          if (oq) {
#line 184
            goto _L;
          }
        }
      }
    }
#line 191
    if (x == xx) {
#line 193
      x = - 1;
#line 194
      y ++;
#line 194
      if (y >= yy) {
#line 195
        return;
      }
#line 196
      if (y < fore->w_histheight) {
#line 196
        tmp___389 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 196
        tmp___389 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 196
      ml = tmp___389;
    } else
#line 198
    if (x < 0) {
#line 200
      x = xx;
#line 201
      y --;
#line 201
      if (y < 0) {
#line 202
        return;
      }
#line 203
      if (y < fore->w_histheight) {
#line 203
        tmp___390 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 203
        tmp___390 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 203
      ml = tmp___390;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  oq = q;
#line 169
  x += sx;
}
}
#line 218 "/tmp/screen-3.9.15/mark.c"
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) 
{ 
  int i ;
  int j ;
  int from ;
  int to ;
  int ry ;
  int c ;
  int l ;
  unsigned char *im ;
  struct mline *ml ;
  int cf ;
  int font ;
  unsigned char *fo ;
  struct mline *tmp ;
  int tmp___391 ;
  unsigned char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp___392 ;
  int __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  unsigned char *__cil_tmp29 ;
  char *__cil_tmp33 ;
  char *__cil_tmp36 ;
  char *__cil_tmp38 ;
  char *__cil_tmp40 ;
  char *__cil_tmp42 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;

  {
#line 223
  l = 0;
#line 231
  markdata->second = 0;
#line 232
  if (y2 < y1) {
    _L: /* CIL Label */ 
#line 234
    i = y2;
#line 235
    y2 = y1;
#line 236
    y1 = i;
#line 237
    i = x2;
#line 238
    x2 = x1;
#line 239
    x1 = i;
  } else
#line 232
  if (y2 == y1) {
#line 232
    if (x2 < x1) {
#line 232
      goto _L;
    }
  }
#line 241
  ry = y1 - markdata->hist_offset;
#line 243
  i = y1;
#line 244
  if (redisplay != 2) {
#line 244
    if (pt == (char *)0) {
#line 244
      if (ry < 0) {
#line 246
        i -= ry;
#line 247
        ry = 0;
      }
    }
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i <= y2)) {
#line 249
      goto while_break;
    }
#line 251
    if (redisplay != 2) {
#line 251
      if (pt == (char *)0) {
#line 251
        if (ry > yend) {
#line 252
          goto while_break;
        }
      }
    }
#line 253
    if (i < fore->w_histheight) {
#line 253
      tmp = & *(fore->w_hlines + (fore->w_histidx + i) % fore->w_histheight);
    } else {
#line 253
      tmp = & *(fore->w_mlines + (i - fore->w_histheight));
    }
#line 253
    ml = tmp;
#line 254
    if (i == y1) {
#line 254
      tmp___391 = x1;
    } else {
#line 254
      tmp___391 = 0;
    }
#line 254
    from = tmp___391;
#line 255
    if (from < markdata->left_mar) {
#line 256
      from = markdata->left_mar;
    }
#line 257
    im = ml->image + to;
#line 257
    to = fore->w_layer.l_width;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (to >= 0)) {
#line 257
        goto while_break___0;
      }
#line 258
      __cil_tmp22 = im;
#line 258
      im --;
#line 258
      if ((int )*__cil_tmp22 != 32) {
#line 259
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 257
    __cil_tmp23 = to;
#line 257
    to --;
#line 260
    if (i == y2) {
#line 260
      if (x2 < to) {
#line 261
        to = x2;
      }
    }
#line 262
    if (to > markdata->right_mar) {
#line 263
      to = markdata->right_mar;
    }
#line 264
    if (redisplay == 1) {
#line 264
      if (from <= to) {
#line 264
        if (ry >= 0) {
#line 264
          if (ry <= yend) {
            {
#line 265
            MarkRedisplayLine(ry, from, to, 0);
            }
          }
        }
      }
    }
#line 266
    if (redisplay != 2) {
#line 266
      if (pt == (char *)0) {
#line 267
        goto while_continue;
      }
    }
#line 268
    j = from;
#line 270
    if (fore->w_layer.l_encoding == 8) {
#line 270
      tmp___392 = (int )*(ml->font + j) == 255 && (int )*(ml->image + j) == 255;
    } else {
#line 270
      tmp___392 = ((int )*(ml->font + j) & 224) == 128;
    }
#line 270
    if (tmp___392) {
#line 271
      __cil_tmp25 = j;
#line 271
      j --;
    }
#line 273
    im = ml->image + j;
#line 275
    fo = ml->font + j;
#line 276
    font = 0;
    {
#line 278
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 278
      if (! (j <= to)) {
#line 278
        goto while_break___1;
      }
#line 280
      __cil_tmp26 = im;
#line 280
      im ++;
#line 280
      c = (int )*__cil_tmp26;
#line 282
      __cil_tmp27 = fo;
#line 282
      fo ++;
#line 282
      cf = (int )*__cil_tmp27;
#line 284
      if (fore->w_layer.l_encoding == 8) {
#line 286
        c |= cf << 8;
#line 287
        if (c == 65535) {
#line 288
          goto while_continue___1;
        }
        {
#line 289
        c = ToUtf8_comb(pt, c);
#line 290
        l += c;
        }
#line 291
        if (pt) {
#line 292
          pt += c;
        }
#line 293
        goto while_continue___1;
      }
#line 297
      if (cf) {
#line 297
        if ((cf & 96) == 0) {
#line 299
          __cil_tmp29 = im;
#line 299
          im ++;
#line 299
          c = (c << 8) | (int )*__cil_tmp29;
#line 300
          fo ++;
#line 301
          j ++;
        }
      }
#line 304
      if (pastefont) {
        {
#line 306
        c = EncodeChar(pt, c | (cf << 16), fore->w_layer.l_encoding, & font);
#line 307
        l += c;
        }
#line 308
        if (pt) {
#line 309
          pt += c;
        }
#line 310
        goto while_continue___1;
      }
#line 313
      if (pt) {
#line 314
        __cil_tmp33 = pt;
#line 314
        pt ++;
#line 314
        *__cil_tmp33 = (char )c;
      }
#line 315
      l ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 278
    j ++;
#line 318
    if (pastefont) {
#line 318
      if (font != 0) {
#line 320
        if (pt) {
          {
#line 322
          strcpy(pt, (char const   *)((char *)"\033(B"));
#line 323
          pt += 3;
          }
        }
#line 325
        l += 3;
      }
    }
#line 328
    if (i != y2) {
#line 328
      if (to != fore->w_layer.l_width - 1) {
        _L___393: /* CIL Label */ 
        {
#line 335
        if (markdata->nonl == 0) {
#line 335
          goto case_0;
        }
#line 346
        if (markdata->nonl == 1) {
#line 346
          goto case_1;
        }
#line 348
        if (markdata->nonl == 2) {
#line 348
          goto case_2;
        }
#line 353
        if (markdata->nonl == 3) {
#line 353
          goto case_3;
        }
#line 333
        goto switch_break;
        case_0: /* CIL Label */ 
#line 336
        if (pt) {
#line 337
          __cil_tmp36 = pt;
#line 337
          pt ++;
#line 337
          *__cil_tmp36 = (char )'\r';
        }
#line 338
        l ++;
#line 339
        if (join_with_cr) {
#line 341
          if (pt) {
#line 342
            __cil_tmp38 = pt;
#line 342
            pt ++;
#line 342
            *__cil_tmp38 = (char )'\n';
          }
#line 343
          l ++;
        }
#line 345
        goto switch_break;
        case_1: /* CIL Label */ 
#line 347
        goto switch_break;
        case_2: /* CIL Label */ 
#line 349
        if (pt) {
#line 350
          __cil_tmp40 = pt;
#line 350
          pt ++;
#line 350
          *__cil_tmp40 = (char )' ';
        }
#line 351
        l ++;
#line 352
        goto switch_break;
        case_3: /* CIL Label */ 
#line 354
        if (pt) {
#line 355
          __cil_tmp42 = pt;
#line 355
          pt ++;
#line 355
          *__cil_tmp42 = (char )',';
        }
#line 356
        l ++;
#line 357
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else
#line 328
      if ((int )*(ml->image + (to + 1)) == 32) {
#line 328
        goto _L___393;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  __cil_tmp45 = ry;
#line 249
  ry ++;
#line 249
  __cil_tmp44 = i;
#line 249
  i ++;
#line 361
  return (l);
}
}
#line 369 "/tmp/screen-3.9.15/mark.c"
static int eq(int a , int b ) 
{ 


  {
#line 372
  if (a == b) {
#line 373
    return (1);
  }
#line 374
  if (a == 0) {
#line 375
    return (1);
  } else
#line 374
  if (b == 0) {
#line 375
    return (1);
  }
#line 376
  if (a <= 57) {
#line 376
    if (a >= 48) {
#line 376
      if (b <= 57) {
#line 376
        if (b >= 48) {
#line 377
          return (1);
        }
      }
    }
  }
#line 378
  return (0);
}
}
#line 385 "/tmp/screen-3.9.15/mark.c"
int GetHistory(void) 
{ 
  int i ;
  int q ;
  int xx ;
  int yy ;
  int x ;
  int y ;
  unsigned char *linep ;
  struct mline *ml ;
  struct mline *tmp ;
  unsigned char *__cil_tmp10 ;
  int __cil_tmp11 ;
  struct mline *tmp___394 ;
  int __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 387
  i = 0;
#line 387
  q = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  x = fore->w_layer.l_x;
#line 393
  if (x >= fore->w_layer.l_width) {
#line 394
    x = fore->w_layer.l_width - 1;
  }
#line 395
  y = fore->w_layer.l_y + fore->w_histheight;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 397
  if (y < fore->w_histheight) {
#line 397
    tmp = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 397
    tmp = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 397
  ml = tmp;
#line 398
  linep = ml->image + xx;
#line 398
  xx = x - 1;
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (! (xx >= 0)) {
#line 398
      goto while_break___1;
    }
#line 399
    __cil_tmp10 = linep;
#line 399
    linep --;
#line 399
    q = (int )*__cil_tmp10;
#line 399
    if (q != 32) {
#line 400
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 398
  __cil_tmp11 = xx;
#line 398
  xx --;
  {
#line 401
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 401
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 402
  yy = y - 1;
  {
#line 402
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 402
    if (! (yy >= 0)) {
#line 402
      goto while_break___3;
    }
#line 404
    if (yy < fore->w_histheight) {
#line 404
      tmp___394 = & *(fore->w_hlines + (fore->w_histidx + yy) % fore->w_histheight);
    } else {
#line 404
      tmp___394 = & *(fore->w_mlines + (yy - fore->w_histheight));
    }
    {
#line 404
    ml = tmp___394;
#line 405
    linep = ml->image;
#line 406
    __cil_tmp13 = eq((int )*(linep + xx), q);
    }
#line 406
    if (xx < 0) {
      _L: /* CIL Label */ 
#line 408
      linep += i;
#line 408
      i = fore->w_layer.l_width - 1;
      {
#line 408
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 408
        if (! (i >= x)) {
#line 408
          goto while_break___4;
        }
#line 409
        __cil_tmp14 = linep;
#line 409
        linep --;
#line 409
        if ((int )*__cil_tmp14 != 32) {
#line 410
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 408
      __cil_tmp15 = i;
#line 408
      i --;
#line 411
      if (i >= x) {
#line 412
        goto while_break___3;
      }
    } else
#line 406
    if (__cil_tmp13) {
#line 406
      goto _L;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 402
  __cil_tmp16 = yy;
#line 402
  yy --;
#line 415
  if (yy < 0) {
#line 416
    return (0);
  }
#line 417
  if ((display->d_user)->u_plop.buf) {
    {
#line 418
    UserFreeCopyBuffer(display->d_user);
    }
  }
  {
#line 419
  __cil_tmp17 = malloc((unsigned long )((unsigned int )((i - x) + 2)));
#line 419
  (display->d_user)->u_plop.buf = (char *)__cil_tmp17;
  }
#line 419
  if ((display->d_user)->u_plop.buf == (char *)((void *)0)) {
    {
#line 421
    LMsg(0, (char *)"Not enough memory... Sorry.");
    }
#line 422
    return (0);
  }
  {
#line 424
  bcopy((void const   *)((((char *)linep - i) + x) + 1), (void *)(display->d_user)->u_plop.buf,
        (size_t )((i - x) + 1));
#line 425
  (display->d_user)->u_plop.len = (i - x) + 1;
#line 427
  (display->d_user)->u_plop.enc = fore->w_layer.l_encoding;
  }
#line 429
  return (1);
}
}
#line 436 "/tmp/screen-3.9.15/mark.c"
void MarkRoutine(void) 
{ 
  int x ;
  int y ;
  int __cil_tmp3 ;

  {
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 445
  __cil_tmp3 = InitOverlayPage((int )sizeof(*markdata), & MarkLf, 1);
  }
#line 445
  if (__cil_tmp3) {
#line 446
    return;
  }
#line 447
  flayer->l_encoding = fore->w_layer.l_encoding;
#line 448
  markdata = (struct markdata *)flayer->l_data;
#line 449
  markdata->md_user = display->d_user;
#line 450
  markdata->md_window = fore;
#line 451
  markdata->second = 0;
#line 452
  markdata->rep_cnt = 0;
#line 453
  markdata->append_mode = 0;
#line 454
  markdata->write_buffer = 0;
#line 455
  markdata->nonl = 0;
#line 456
  markdata->left_mar = 0;
#line 457
  markdata->right_mar = fore->w_layer.l_width - 1;
#line 458
  markdata->hist_offset = fore->w_histheight;
#line 459
  x = fore->w_layer.l_x;
#line 460
  y = fore->w_layer.l_y + markdata->hist_offset;
#line 461
  if (x >= fore->w_layer.l_width) {
#line 462
    x = fore->w_layer.l_width - 1;
  }
  {
#line 464
  LGotoPos(flayer, x, y - markdata->hist_offset);
#line 465
  LMsg(0, (char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)", x + 1, (y + 1) - markdata->hist_offset,
       fore->w_histheight, fore->w_layer.l_width, fore->w_layer.l_height);
#line 467
  markdata->x1 = x;
#line 467
  markdata->cx = markdata->x1;
#line 468
  markdata->y1 = y;
#line 468
  markdata->cy = markdata->y1;
#line 469
  flayer->l_x = x;
#line 470
  flayer->l_y = y - markdata->hist_offset;
  }
}
}
#line 474 "/tmp/screen-3.9.15/mark.c"
static void MarkProcess(char **inbufp , int *inlenp ) 
{ 
  char *inbuf ;
  char *pt ;
  int inlen ;
  int cx ;
  int cy ;
  int x2 ;
  int y2 ;
  int j ;
  int yend ;
  int newcopylen ;
  int od ;
  int in_mark ;
  int rep_cnt ;
  struct acluser *md_user ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp25 ;
  int tmp ;
  int tmp___395 ;
  char *tmp___396 ;
  int __cil_tmp29 ;
  char *tmp___397 ;
  int __cil_tmp31 ;
  int __cil_tmp33 ;
  int append_mode ;
  int write_buffer ;
  int __cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  int __cil_tmp46 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
#line 481
  newcopylen = 0;
#line 490
  markdata = (struct markdata *)flayer->l_data;
#line 491
  fore = markdata->md_window;
#line 492
  md_user = markdata->md_user;
#line 493
  if (inbufp == (char **)0) {
    {
#line 495
    MarkAbort();
    }
#line 496
    return;
  }
  {
#line 499
  LGotoPos(flayer, markdata->cx, markdata->cy - markdata->hist_offset);
#line 500
  inbuf = *inbufp;
#line 501
  inlen = *inlenp;
#line 502
  pt = inbuf;
#line 503
  in_mark = 1;
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (in_mark && inlen)) {
#line 504
      goto while_break;
    }
#line 516
    __cil_tmp17 = pt;
#line 516
    pt ++;
#line 516
    od = (int )mark_key_tab[(int )((unsigned char )*__cil_tmp17)];
#line 517
    __cil_tmp18 = inlen;
#line 517
    inlen --;
#line 519
    rep_cnt = markdata->rep_cnt;
#line 520
    if (od >= 48) {
#line 520
      if (od <= 57) {
#line 522
        if (rep_cnt < 1001) {
#line 522
          if (od != 48) {
#line 524
            markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 525
            goto while_continue;
          } else
#line 522
          if (rep_cnt != 0) {
#line 524
            markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 525
            goto while_continue;
          }
        }
      }
    }
#line 538
    cx = markdata->cx;
#line 539
    cy = markdata->cy;
    {
#line 543
    if (od == 'x') {
#line 543
      goto case_120;
    }
#line 543
    if (od == 'o') {
#line 543
      goto case_120;
    }
#line 552
    if (od == '\f') {
#line 552
      goto case_12;
    }
#line 558
    if (od == 'h') {
#line 558
      goto case_104;
    }
#line 558
    if (od == '\b') {
#line 558
      goto case_104;
    }
#line 558
    if (od == 130) {
#line 558
      goto case_104;
    }
#line 565
    if (od == 'j') {
#line 565
      goto case_106;
    }
#line 565
    if (od == '\016') {
#line 565
      goto case_106;
    }
#line 565
    if (od == 142) {
#line 565
      goto case_106;
    }
#line 570
    if (od == '+') {
#line 570
      goto case_43;
    }
#line 578
    if (od == '-') {
#line 578
      goto case_45;
    }
#line 586
    if (od == '^') {
#line 586
      goto case_94;
    }
#line 589
    if (od == '\n') {
#line 589
      goto case_10;
    }
#line 594
    if (od == 'k') {
#line 594
      goto case_107;
    }
#line 594
    if (od == '\020') {
#line 594
      goto case_107;
    }
#line 594
    if (od == 144) {
#line 594
      goto case_107;
    }
#line 600
    if (od == 'l') {
#line 600
      goto case_108;
    }
#line 600
    if (od == 134) {
#line 600
      goto case_108;
    }
#line 606
    if (od == '0') {
#line 606
      goto case_48;
    }
#line 606
    if (od == '\001') {
#line 606
      goto case_48;
    }
#line 609
    if (od == '\004') {
#line 609
      goto case_4;
    }
#line 614
    if (od == '$') {
#line 614
      goto case_36;
    }
#line 617
    if (od == '\022') {
#line 617
      goto case_18;
    }
#line 621
    if (od == '\023') {
#line 621
      goto case_19;
    }
#line 625
    if (od == '\025') {
#line 625
      goto case_21;
    }
#line 630
    if (od == '\a') {
#line 630
      goto case_7;
    }
#line 638
    if (od == '\002') {
#line 638
      goto case_2;
    }
#line 644
    if (od == '\006') {
#line 644
      goto case_6;
    }
#line 650
    if (od == '\005') {
#line 650
      goto case_5;
    }
#line 659
    if (od == '\031') {
#line 659
      goto case_25;
    }
#line 668
    if (od == '@') {
#line 668
      goto case_64;
    }
#line 671
    if (od == '%') {
#line 671
      goto case_37;
    }
#line 681
    if (od == 'g') {
#line 681
      goto case_103;
    }
#line 681
    if (od == 129) {
#line 681
      goto case_103;
    }
#line 685
    if (od == 'G') {
#line 685
      goto case_71;
    }
#line 685
    if (od == 133) {
#line 685
      goto case_71;
    }
#line 691
    if (od == 'H') {
#line 691
      goto case_72;
    }
#line 694
    if (od == 'M') {
#line 694
      goto case_77;
    }
#line 697
    if (od == 'L') {
#line 697
      goto case_76;
    }
#line 700
    if (od == '|') {
#line 700
      goto case_124;
    }
#line 703
    if (od == 'w') {
#line 703
      goto case_119;
    }
#line 710
    if (od == 'E') {
#line 710
      goto case_69;
    }
#line 710
    if (od == 'e') {
#line 710
      goto case_69;
    }
#line 717
    if (od == 'B') {
#line 717
      goto case_66;
    }
#line 717
    if (od == 'b') {
#line 717
      goto case_66;
    }
#line 723
    if (od == 'a') {
#line 723
      goto case_97;
    }
#line 729
    if (od == 'V') {
#line 729
      goto case_86;
    }
#line 729
    if (od == 'v') {
#line 729
      goto case_86;
    }
#line 737
    if (od == 'C') {
#line 737
      goto case_67;
    }
#line 737
    if (od == 'c') {
#line 737
      goto case_67;
    }
#line 767
    if (od == 'J') {
#line 767
      goto case_74;
    }
#line 772
    if (od == 0) {
#line 772
      goto case_0;
    }
#line 778
    if (od == 1) {
#line 778
      goto case_1___0;
    }
#line 781
    if (od == 2) {
#line 781
      goto case_2___0;
    }
#line 784
    if (od == 3) {
#line 784
      goto case_3;
    }
#line 789
    if (od == '/') {
#line 789
      goto case_47;
    }
#line 793
    if (od == '?') {
#line 793
      goto case_63;
    }
#line 797
    if (od == 'n') {
#line 797
      goto case_110;
    }
#line 801
    if (od == 'Y') {
#line 801
      goto case_89;
    }
#line 801
    if (od == 'y') {
#line 801
      goto case_89;
    }
#line 815
    if (od == 'W') {
#line 815
      goto case_87;
    }
#line 834
    if (od == 'A') {
#line 834
      goto case_65;
    }
#line 838
    if (od == '>') {
#line 838
      goto case_62;
    }
#line 843
    if (od == '\r') {
#line 843
      goto case_13;
    }
#line 843
    if (od == ' ') {
#line 843
      goto case_13;
    }
#line 896
    if (od == 0) {
#line 896
      goto case_0___0;
    }
#line 905
    if (od == 1) {
#line 905
      goto case_1___1;
    }
#line 907
    if (od == 2) {
#line 907
      goto case_2___1;
    }
#line 911
    if (od == 3) {
#line 911
      goto case_3___0;
    }
#line 939
    goto switch_default;
    case_120: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 544
    if (! markdata->second) {
#line 545
      goto switch_break;
    }
    {
#line 546
    markdata->cx = markdata->x1;
#line 547
    markdata->cy = markdata->y1;
#line 548
    markdata->x1 = cx;
#line 549
    markdata->y1 = cy;
#line 550
    revto(markdata->cx, markdata->cy);
    }
#line 551
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 553
    Redisplay(0);
    }
    {
#line 554
    LGotoPos(flayer, cx, cy - markdata->hist_offset);
    }
#line 555
    goto switch_break;
    case_104: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_130: /* CIL Label */ 
#line 559
    if (rep_cnt == 0) {
#line 560
      rep_cnt = 1;
    }
    {
#line 561
    revto(cx - rep_cnt, cy);
    }
#line 562
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
#line 566
    if (rep_cnt == 0) {
#line 567
      rep_cnt = 1;
    }
    {
#line 568
    revto(cx, cy + rep_cnt);
    }
#line 569
    goto switch_break;
    case_43: /* CIL Label */ 
#line 571
    if (rep_cnt == 0) {
#line 572
      rep_cnt = 1;
    }
#line 573
    j = cy + rep_cnt;
#line 574
    if (j > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 575
      j = (fore->w_histheight + fore->w_layer.l_height) - 1;
    }
    {
#line 576
    __cil_tmp19 = linestart(j);
#line 576
    revto(__cil_tmp19, j);
    }
#line 577
    goto switch_break;
    case_45: /* CIL Label */ 
#line 579
    if (rep_cnt == 0) {
#line 580
      rep_cnt = 1;
    }
#line 581
    cy -= rep_cnt;
#line 582
    if (cy < 0) {
#line 583
      cy = 0;
    }
    {
#line 584
    __cil_tmp20 = linestart(cy);
#line 584
    revto(__cil_tmp20, cy);
    }
#line 585
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 587
    __cil_tmp21 = linestart(cy);
#line 587
    revto(__cil_tmp21, cy);
    }
#line 588
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 590
    revto(markdata->left_mar, cy + 1);
    }
#line 591
    goto switch_break;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
#line 595
    if (rep_cnt == 0) {
#line 596
      rep_cnt = 1;
    }
    {
#line 597
    revto(cx, cy - rep_cnt);
    }
#line 598
    goto switch_break;
    case_108: /* CIL Label */ 
    case_134: /* CIL Label */ 
#line 601
    if (rep_cnt == 0) {
#line 602
      rep_cnt = 1;
    }
    {
#line 603
    revto(cx + rep_cnt, cy);
    }
#line 604
    goto switch_break;
    case_48: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 607
    revto(markdata->left_mar, cy);
    }
#line 608
    goto switch_break;
    case_4: /* CIL Label */ 
#line 610
    if (rep_cnt == 0) {
#line 611
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 612
    revto_line(cx, cy + rep_cnt, cy - markdata->hist_offset);
    }
#line 613
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 615
    __cil_tmp22 = lineend(cy);
#line 615
    revto(__cil_tmp22, cy);
    }
#line 616
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 618
    ISearch(- 1);
    }
#line 619
    in_mark = 0;
#line 620
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 622
    ISearch(1);
    }
#line 623
    in_mark = 0;
#line 624
    goto switch_break;
    case_21: /* CIL Label */ 
#line 626
    if (rep_cnt == 0) {
#line 627
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 628
    revto_line(cx, cy - rep_cnt, cy - markdata->hist_offset);
    }
#line 629
    goto switch_break;
    case_7: /* CIL Label */ 
#line 631
    if (markdata->left_mar == 0) {
#line 631
      if (markdata->right_mar == fore->w_layer.l_width - 1) {
        {
#line 632
        LMsg(0, (char *)"Column %d Line %d(+%d)", cx + 1, (cy - markdata->hist_offset) + 1,
             markdata->hist_offset);
        }
      } else {
        {
        {
#line 635
        LMsg(0, (char *)"Column %d(%d..%d) Line %d(+%d)", cx + 1, markdata->left_mar + 1,
             markdata->right_mar + 1, (cy - markdata->hist_offset) + 1, markdata->hist_offset);
        }
        }
      }
    } else {
      {
      {
#line 635
      LMsg(0, (char *)"Column %d(%d..%d) Line %d(+%d)", cx + 1, markdata->left_mar + 1,
           markdata->right_mar + 1, (cy - markdata->hist_offset) + 1, markdata->hist_offset);
      }
      }
    }
#line 637
    goto switch_break;
    case_2: /* CIL Label */ 
#line 639
    if (rep_cnt == 0) {
#line 640
      rep_cnt = 1;
    }
    {
#line 641
    rep_cnt *= fore->w_layer.l_height;
#line 642
    revto(cx, cy - rep_cnt);
    }
#line 643
    goto switch_break;
    case_6: /* CIL Label */ 
#line 645
    if (rep_cnt == 0) {
#line 646
      rep_cnt = 1;
    }
    {
#line 647
    rep_cnt *= fore->w_layer.l_height;
#line 648
    revto(cx, cy + rep_cnt);
    }
#line 649
    goto switch_break;
    case_5: /* CIL Label */ 
#line 651
    if (rep_cnt == 0) {
#line 652
      rep_cnt = 1;
    }
    {
#line 653
    rep_cnt = MarkScrollUpDisplay(rep_cnt);
    }
#line 654
    if (cy < markdata->hist_offset) {
      {
#line 655
      revto(cx, markdata->hist_offset);
      }
    } else {
      {
#line 657
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 658
    goto switch_break;
    case_25: /* CIL Label */ 
#line 660
    if (rep_cnt == 0) {
#line 661
      rep_cnt = 1;
    }
    {
#line 662
    rep_cnt = MarkScrollDownDisplay(rep_cnt);
    }
#line 663
    if (cy > (fore->w_layer.l_height - 1) + markdata->hist_offset) {
      {
#line 664
      revto(cx, (fore->w_layer.l_height - 1) + markdata->hist_offset);
      }
    } else {
      {
#line 666
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 667
    goto switch_break;
    case_64: /* CIL Label */ 
#line 670
    goto switch_break;
    case_37: /* CIL Label */ 
#line 672
    __cil_tmp25 = rep_cnt;
#line 672
    rep_cnt --;
#line 674
    if (rep_cnt < 0) {
#line 675
      rep_cnt = 0;
    }
#line 676
    if (rep_cnt > 100) {
#line 677
      rep_cnt = 100;
    }
    {
#line 678
    revto_line(markdata->left_mar, (rep_cnt * (fore->w_histheight + fore->w_layer.l_height)) / 100,
               (fore->w_layer.l_height - 1) / 2);
    }
#line 679
    goto switch_break;
    case_103: /* CIL Label */ 
    case_129: /* CIL Label */ 
#line 682
    rep_cnt = 1;
    case_71: /* CIL Label */ 
    case_133: /* CIL Label */ 
#line 687
    if (rep_cnt == 0) {
#line 688
      rep_cnt = fore->w_histheight + fore->w_layer.l_height;
    }
    {
#line 689
    rep_cnt --;
#line 689
    revto_line(markdata->left_mar, rep_cnt, (fore->w_layer.l_height - 1) / 2);
    }
#line 690
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 692
    revto(markdata->left_mar, markdata->hist_offset);
    }
#line 693
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 695
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) / 2 + markdata->hist_offset);
    }
#line 696
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 698
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) + markdata->hist_offset);
    }
#line 699
    goto switch_break;
    case_124: /* CIL Label */ 
    {
#line 701
    rep_cnt --;
#line 701
    revto(rep_cnt, cy);
    }
#line 702
    goto switch_break;
    case_119: /* CIL Label */ 
#line 704
    if (rep_cnt == 0) {
#line 705
      rep_cnt = 1;
    }
    {
#line 706
    nextword(& cx, & cy, 1 << 2, rep_cnt);
#line 707
    revto(cx, cy);
    }
#line 708
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 711
    if (rep_cnt == 0) {
#line 712
      rep_cnt = 1;
    }
#line 713
    if (od == 69) {
#line 713
      tmp = 1 << 3;
    } else {
#line 713
      tmp = 0;
    }
    {
#line 713
    nextword(& cx, & cy, ((1 << 1) | (1 << 2)) | tmp, rep_cnt);
#line 714
    revto(cx, cy);
    }
#line 715
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 718
    if (rep_cnt == 0) {
#line 719
      rep_cnt = 1;
    }
#line 720
    if (od == 66) {
#line 720
      tmp___395 = 1 << 3;
    } else {
#line 720
      tmp___395 = 0;
    }
    {
#line 720
    nextword(& cx, & cy, ((1 | (1 << 1)) | (1 << 2)) | tmp___395, rep_cnt);
#line 721
    revto(cx, cy);
    }
#line 722
    goto switch_break;
    case_97: /* CIL Label */ 
#line 724
    markdata->append_mode = 1 - markdata->append_mode;
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 725
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 726
    if (markdata->append_mode) {
#line 726
      tmp___396 = (char *)":set append";
    } else {
#line 726
      tmp___396 = (char *)":set noappend";
    }
    {
#line 726
    LMsg(0, tmp___396);
    }
#line 727
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
#line 731
    if (markdata->left_mar == 8) {
#line 732
      rep_cnt = 1;
    } else {
#line 734
      rep_cnt = 9;
    }
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 739
    if (markdata->second) {
      {
#line 741
      rem(markdata->x1, markdata->y1, cx, cy, 1, (char *)0, fore->w_layer.l_height - 1);
#line 742
      markdata->second = 1;
      }
    }
#line 744
    __cil_tmp29 = rep_cnt;
#line 744
    rep_cnt --;
#line 745
    if (rep_cnt < 0) {
#line 746
      rep_cnt = cx;
    }
#line 747
    if (od != 67) {
#line 749
      markdata->left_mar = rep_cnt;
#line 750
      if (markdata->left_mar > markdata->right_mar) {
#line 751
        markdata->left_mar = markdata->right_mar;
      }
    } else {
#line 755
      markdata->right_mar = rep_cnt;
#line 756
      if (markdata->left_mar > markdata->right_mar) {
#line 757
        markdata->right_mar = markdata->left_mar;
      }
    }
#line 759
    if (markdata->second) {
      {
#line 761
      markdata->cx = markdata->x1;
#line 761
      markdata->cy = markdata->y1;
#line 762
      revto(cx, cy);
      }
    }
#line 764
    if (od == 118) {
      _L: /* CIL Label */ 
#line 765
      if (markdata->left_mar != 8) {
#line 765
        tmp___397 = (char *)":set nonu";
      } else {
#line 765
        tmp___397 = (char *)":set nu";
      }
      {
#line 765
      LMsg(0, tmp___397);
      }
    } else
#line 764
    if (od == 86) {
#line 764
      goto _L;
    }
#line 766
    goto switch_break;
    case_74: /* CIL Label */ 
#line 769
    markdata->nonl = (markdata->nonl + 1) % 4;
    {
#line 772
    if (markdata->nonl == 0) {
#line 772
      goto case_0;
    }
#line 778
    if (markdata->nonl == 1) {
#line 778
      goto case_1___0;
    }
#line 781
    if (markdata->nonl == 2) {
#line 781
      goto case_2___0;
    }
#line 784
    if (markdata->nonl == 3) {
#line 784
      goto case_3;
    }
#line 770
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 773
    if (join_with_cr) {
      {
#line 774
      LMsg(0, (char *)"Multiple lines (CR/LF)");
      }
    } else {
      {
#line 776
      LMsg(0, (char *)"Multiple lines (LF)");
      }
    }
#line 777
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 779
    LMsg(0, (char *)"Lines joined");
    }
#line 780
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 782
    LMsg(0, (char *)"Lines joined with blanks");
    }
#line 783
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 785
    LMsg(0, (char *)"Lines joined with comma");
    }
#line 786
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 788
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 790
    Search(1);
    }
#line 791
    in_mark = 0;
#line 792
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 794
    Search(- 1);
    }
#line 795
    in_mark = 0;
#line 796
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 798
    Search(0);
    }
#line 799
    goto switch_break;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 802
    if (markdata->second == 0) {
      {
#line 804
      __cil_tmp31 = linestart(cy);
#line 804
      revto(__cil_tmp31, cy);
#line 805
      (markdata->second) ++;
#line 806
      markdata->x1 = markdata->cx;
#line 806
      cx = markdata->x1;
#line 807
      markdata->y1 = markdata->cy;
#line 807
      cy = markdata->y1;
      }
    }
#line 809
    rep_cnt --;
#line 809
    if (rep_cnt > 0) {
      {
#line 810
      revto(cx, cy + rep_cnt);
      }
    }
    {
#line 811
    __cil_tmp33 = lineend(markdata->cy);
#line 811
    revto(__cil_tmp33, markdata->cy);
    }
#line 812
    if (od == 121) {
#line 813
      goto switch_break;
    }
    case_87: /* CIL Label */ 
#line 816
    if (od == 87) {
#line 818
      if (rep_cnt == 0) {
#line 819
        rep_cnt = 1;
      }
#line 820
      if (! markdata->second) {
        {
#line 822
        nextword(& cx, & cy, 1 | (1 << 1), 1);
#line 823
        revto(cx, cy);
#line 824
        (markdata->second) ++;
#line 825
        markdata->x1 = markdata->cx;
#line 825
        cx = markdata->x1;
#line 826
        markdata->y1 = markdata->cy;
#line 826
        cy = markdata->y1;
        }
      }
      {
#line 828
      nextword(& cx, & cy, 1 << 1, rep_cnt);
#line 829
      revto(cx, cy);
      }
    }
#line 831
    cx = markdata->cx;
#line 832
    cy = markdata->cy;
    case_65: /* CIL Label */ 
#line 835
    if (od == 65) {
#line 836
      markdata->append_mode = 1;
    }
    case_62: /* CIL Label */ 
#line 839
    if (od == 62) {
#line 840
      markdata->write_buffer = 1;
    }
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 844
    if (! markdata->second) {
      {
#line 846
      (markdata->second) ++;
#line 847
      markdata->x1 = cx;
#line 848
      markdata->y1 = cy;
#line 849
      revto(cx, cy);
#line 850
      LMsg(0, (char *)"First mark set - Column %d Line %d", cx + 1, (cy - markdata->hist_offset) + 1);
      }
#line 851
      goto switch_break;
    } else {
      {
#line 855
      append_mode = markdata->append_mode;
#line 856
      write_buffer = markdata->write_buffer;
#line 858
      x2 = cx;
#line 859
      y2 = cy;
#line 860
      newcopylen = rem(markdata->x1, markdata->y1, x2, y2, 2, (char *)0, 0);
      }
#line 861
      if (md_user->u_plop.buf) {
#line 861
        if (! append_mode) {
          {
#line 862
          UserFreeCopyBuffer(md_user);
          }
        }
      }
#line 863
      yend = fore->w_layer.l_height - 1;
#line 864
      if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
        {
#line 866
        markdata->second = 0;
#line 867
        __cil_tmp39 = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
        }
#line 867
        yend -= __cil_tmp39;
      }
#line 869
      if (newcopylen > 0) {
#line 872
        if (md_user->u_plop.buf) {
          {
#line 873
          __cil_tmp40 = realloc((void *)md_user->u_plop.buf, (unsigned long )((unsigned int )((md_user->u_plop.len + newcopylen) + 3)));
#line 873
          md_user->u_plop.buf = (char *)__cil_tmp40;
          }
        } else {
          {
#line 877
          md_user->u_plop.len = 0;
#line 878
          __cil_tmp41 = malloc((unsigned long )((unsigned int )(newcopylen + 3)));
#line 878
          md_user->u_plop.buf = (char *)__cil_tmp41;
          }
        }
#line 880
        if (! md_user->u_plop.buf) {
          {
#line 882
          MarkAbort();
#line 883
          in_mark = 0;
#line 884
          LMsg(0, (char *)"Not enough memory... Sorry.");
#line 885
          md_user->u_plop.len = 0;
#line 886
          md_user->u_plop.buf = (char *)0;
          }
#line 887
          goto switch_break;
        }
#line 889
        if (append_mode) {
          {
#line 896
          if (markdata->nonl == 0) {
#line 896
            goto case_0___0;
          }
#line 905
          if (markdata->nonl == 1) {
#line 905
            goto case_1___1;
          }
#line 907
          if (markdata->nonl == 2) {
#line 907
            goto case_2___1;
          }
#line 911
          if (markdata->nonl == 3) {
#line 911
            goto case_3___0;
          }
#line 891
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 897
          if (join_with_cr) {
#line 899
            *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\r';
#line 900
            (md_user->u_plop.len) ++;
          }
#line 902
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\n';
#line 903
          (md_user->u_plop.len) ++;
#line 904
          goto switch_break___1;
          case_1___1: /* CIL Label */ 
#line 906
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
#line 908
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )' ';
#line 909
          (md_user->u_plop.len) ++;
#line 910
          goto switch_break___1;
          case_3___0: /* CIL Label */ 
#line 912
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )',';
#line 913
          (md_user->u_plop.len) ++;
#line 914
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        }
        {
#line 917
        __cil_tmp46 = rem(markdata->x1, markdata->y1, x2, y2, markdata->hist_offset == fore->w_histheight,
                          md_user->u_plop.buf + md_user->u_plop.len, yend);
        }
#line 917
        md_user->u_plop.len += __cil_tmp46;
#line 921
        md_user->u_plop.enc = fore->w_layer.l_encoding;
      }
#line 924
      if (markdata->hist_offset != fore->w_histheight) {
        {
#line 926
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 926
          oldlay = flayer;
          {
#line 926
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 926
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 926
          flayer = flayer->l_next;
#line 926
          oldcvlist = flayer->l_cvlist;
          {
#line 926
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 926
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 926
          flayer->l_cvlist = oldlay->l_cvlist;
#line 926
          cv = flayer->l_cvlist;
          {
#line 926
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 926
            if (! cv) {
#line 926
              goto while_break___4;
            }
#line 926
            cv->c_layer = flayer;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 926
          cv = cv->c_lnext;
#line 926
          LRefreshAll(flayer, 0);
#line 926
          flayer = oldlay;
#line 926
          cv = flayer->l_cvlist;
          }
          {
#line 926
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 926
            if (! cv) {
#line 926
              goto while_break___5;
            }
#line 926
            cv->c_layer = flayer;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 926
          cv = cv->c_lnext;
#line 926
          (flayer->l_next)->l_cvlist = oldcvlist;
#line 926
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 928
      ExitOverlayPage();
      }
#line 929
      if (append_mode) {
        {
#line 930
        LMsg(0, (char *)"Appended %d characters to buffer", newcopylen);
        }
      } else {
        {
#line 933
        LMsg(0, (char *)"Copied %d characters into buffer", md_user->u_plop.len);
        }
      }
#line 934
      if (write_buffer) {
        {
#line 935
        WriteFile(md_user, (char *)0, 2);
        }
      }
#line 936
      in_mark = 0;
#line 937
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 940
    MarkAbort();
    }
    {
#line 941
    LMsg(0, (char *)"Copy mode aborted");
#line 942
    in_mark = 0;
    }
#line 943
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 945
    if (in_mark) {
#line 946
      markdata->rep_cnt = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  if (in_mark) {
#line 950
    flayer->l_x = markdata->cx;
#line 951
    flayer->l_y = markdata->cy - markdata->hist_offset;
  }
#line 953
  *inbufp = pt;
#line 954
  *inlenp = inlen;
}
}
#line 957 "/tmp/screen-3.9.15/mark.c"
void revto(int tx , int ty ) 
{ 


  {
  {
#line 960
  revto_line(tx, ty, - 1);
  }
}
}
#line 964 "/tmp/screen-3.9.15/mark.c"
void revto_line(int tx , int ty , int line ) 
{ 
  int fx ;
  int fy ;
  int x ;
  int y ;
  int t ;
  int revst ;
  int reven ;
  int qq ;
  int ff ;
  int tt ;
  int st ;
  int en ;
  int ce ;
  int ystart ;
  int yend ;
  int i ;
  int ry ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mc ;
  struct mline *tmp ;
  int tmp___398 ;
  int tmp___399 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp33 ;
  struct mline *tmp___400 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  struct mline *tmp___401 ;
  int __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  int tmp___403 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp___405 ;
  int tmp___406 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;

  {
#line 968
  ce = 0;
#line 969
  ystart = 0;
#line 969
  yend = fore->w_layer.l_height - 1;
#line 975
  if (tx < 0) {
#line 976
    tx = 0;
  } else
#line 977
  if (tx > fore->w_layer.l_width - 1) {
#line 978
    tx = fore->w_layer.l_width - 1;
  }
#line 979
  if (ty < 0) {
#line 980
    ty = 0;
  } else
#line 981
  if (ty > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 982
    ty = (fore->w_histheight + fore->w_layer.l_height) - 1;
  }
#line 984
  fx = markdata->cx;
#line 984
  fy = markdata->cy;
#line 988
  if (ty < fore->w_histheight) {
#line 988
    tmp = & *(fore->w_hlines + (fore->w_histidx + ty) % fore->w_histheight);
  } else {
#line 988
    tmp = & *(fore->w_mlines + (ty - fore->w_histheight));
  }
#line 988
  ml = tmp;
#line 989
  if (fore->w_layer.l_encoding == 8) {
#line 989
    tmp___398 = (int )*(ml->font + tx) == 255 && (int )*(ml->image + tx) == 255;
  } else {
#line 989
    tmp___398 = ((int )*(ml->font + tx) & 224) == 128;
  }
#line 989
  if (ty == fy) {
#line 989
    if (fx + 1 == tx) {
#line 989
      if (tmp___398) {
#line 989
        if (tx < display->d_width - 1) {
#line 990
          tx ++;
        }
      }
    }
  }
#line 991
  if (fore->w_layer.l_encoding == 8) {
#line 991
    tmp___399 = (int )*(ml->font + fx) == 255 && (int )*(ml->image + fx) == 255;
  } else {
#line 991
    tmp___399 = ((int )*(ml->font + fx) & 224) == 128;
  }
#line 991
  if (ty == fy) {
#line 991
    if (fx - 1 == tx) {
#line 991
      if (tmp___399) {
#line 991
        if (tx) {
#line 992
          __cil_tmp28 = tx;
#line 992
          tx --;
        }
      }
    }
  }
#line 995
  markdata->cx = tx;
#line 995
  markdata->cy = ty;
#line 1001
  i = 0;
#line 1002
  if (line >= 0) {
#line 1002
    if (line < fore->w_layer.l_height) {
#line 1003
      i = (ty - markdata->hist_offset) - line;
    } else {
#line 1002
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1004
  if (ty < markdata->hist_offset) {
#line 1005
    i = ty - markdata->hist_offset;
  } else
#line 1006
  if (ty > markdata->hist_offset + (fore->w_layer.l_height - 1)) {
#line 1007
    i = (ty - markdata->hist_offset) - (fore->w_layer.l_height - 1);
  }
#line 1008
  if (i > 0) {
    {
#line 1009
    __cil_tmp29 = MarkScrollUpDisplay(i);
    }
#line 1009
    yend -= __cil_tmp29;
  } else
#line 1010
  if (i < 0) {
    {
#line 1011
    __cil_tmp30 = MarkScrollDownDisplay(- i);
    }
#line 1011
    ystart += __cil_tmp30;
  }
#line 1013
  if (markdata->second == 0) {
    {
#line 1015
    LGotoPos(flayer, tx, ty - markdata->hist_offset);
    }
#line 1016
    return;
  }
#line 1019
  qq = markdata->x1 + markdata->y1 * fore->w_layer.l_width;
#line 1020
  ff = fx + fy * fore->w_layer.l_width;
#line 1021
  tt = tx + ty * fore->w_layer.l_width;
#line 1023
  if (ff > tt) {
#line 1025
    st = tt;
#line 1025
    en = ff;
#line 1026
    x = tx;
#line 1026
    y = ty;
  } else {
#line 1030
    st = ff;
#line 1030
    en = tt;
#line 1031
    x = fx;
#line 1031
    y = fy;
  }
#line 1033
  if (st > qq) {
#line 1035
    st ++;
#line 1036
    x ++;
  }
#line 1038
  if (en < qq) {
#line 1039
    __cil_tmp33 = en;
#line 1039
    en --;
  }
#line 1040
  if (tt > qq) {
#line 1042
    revst = qq;
#line 1042
    reven = tt;
  } else {
#line 1046
    revst = tt;
#line 1046
    reven = qq;
  }
#line 1048
  ry = y - markdata->hist_offset;
#line 1049
  if (ry < ystart) {
#line 1051
    y += ystart - ry;
#line 1052
    x = 0;
#line 1053
    st = y * fore->w_layer.l_width;
#line 1054
    ry = ystart;
  }
#line 1056
  if (y < fore->w_histheight) {
#line 1056
    tmp___400 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 1056
    tmp___400 = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 1056
  ml = tmp___400;
#line 1057
  t = st;
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (! (t <= en)) {
#line 1057
      goto while_break;
    }
#line 1059
    if (x >= fore->w_layer.l_width) {
#line 1061
      x = 0;
#line 1062
      __cil_tmp36 = ry;
#line 1062
      ry ++;
#line 1062
      __cil_tmp35 = y;
#line 1062
      y ++;
#line 1063
      if (y < fore->w_histheight) {
#line 1063
        tmp___401 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 1063
        tmp___401 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 1063
      ml = tmp___401;
    }
#line 1065
    if (ry > yend) {
#line 1066
      goto while_break;
    }
#line 1067
    if (t == st) {
      _L___402: /* CIL Label */ 
#line 1069
      wi = ml->image + fore->w_layer.l_width;
#line 1070
      ce = fore->w_layer.l_width;
      {
#line 1070
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1070
        if (! (ce >= 0)) {
#line 1070
          goto while_break___0;
        }
#line 1071
        if ((int )*wi != 32) {
#line 1072
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1070
      __cil_tmp39 = wi;
#line 1070
      wi --;
#line 1070
      __cil_tmp38 = ce;
#line 1070
      ce --;
    } else
#line 1067
    if (x == 0) {
#line 1067
      goto _L___402;
    }
#line 1074
    if (x <= ce) {
#line 1074
      if (x >= markdata->left_mar) {
#line 1074
        if (x <= markdata->right_mar) {
#line 1077
          if (fore->w_layer.l_encoding == 8) {
#line 1077
            tmp___403 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
          } else {
#line 1077
            tmp___403 = ((int )*(ml->font + x) & 224) == 128;
          }
#line 1077
          if (tmp___403) {
#line 1079
            if (t == revst) {
#line 1080
              __cil_tmp41 = revst;
#line 1080
              revst --;
            }
#line 1081
            __cil_tmp42 = t;
#line 1081
            t --;
#line 1082
            __cil_tmp43 = x;
#line 1082
            x --;
          }
#line 1085
          if (t >= revst) {
#line 1085
            if (t <= reven) {
#line 1087
              mc = mchar_so;
#line 1089
              if (pastefont) {
#line 1090
                mc.font = *(ml->font + x);
              }
#line 1092
              mc.image = *(ml->image + x);
            } else {
#line 1085
              goto _L___404;
            }
          } else {
            _L___404: /* CIL Label */ 
            {
#line 1095
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1095
              mc.image = *(ml->image + x);
#line 1095
              mc.attr = *(ml->attr + x);
#line 1095
              mc.font = *(ml->font + x);
#line 1095
              mc.color = *(ml->color + x);
#line 1095
              mc.mbcs = (unsigned char )0;
#line 1095
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 1097
          if (fore->w_layer.l_encoding == 8) {
#line 1097
            tmp___405 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
          } else {
#line 1097
            tmp___405 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
          }
#line 1097
          if (tmp___405) {
            {
#line 1099
            mc.mbcs = *(ml->image + (x + 1));
#line 1100
            LPutChar(flayer, & mc, x, y - markdata->hist_offset);
#line 1101
            t ++;
            }
          }
          {
#line 1104
          LPutChar(flayer, & mc, x, y - markdata->hist_offset);
          }
#line 1106
          if (fore->w_layer.l_encoding == 8) {
#line 1106
            tmp___406 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
          } else {
#line 1106
            tmp___406 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
          }
#line 1106
          if (tmp___406) {
#line 1107
            x ++;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1057
  __cil_tmp49 = x;
#line 1057
  x ++;
  {
#line 1057
  __cil_tmp48 = t;
#line 1057
  t ++;
#line 1111
  LGotoPos(flayer, tx, ty - markdata->hist_offset);
  }
}
}
#line 1115 "/tmp/screen-3.9.15/mark.c"
static void MarkAbort(void) 
{ 
  int yend ;
  int redisp ;
  int __cil_tmp3 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1120
  markdata = (struct markdata *)flayer->l_data;
#line 1121
  fore = markdata->md_window;
#line 1122
  yend = fore->w_layer.l_height - 1;
#line 1123
  redisp = markdata->second;
#line 1124
  if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
    {
#line 1126
    markdata->second = 0;
#line 1127
    __cil_tmp3 = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
    }
#line 1127
    yend -= __cil_tmp3;
  }
#line 1129
  if (markdata->hist_offset != fore->w_histheight) {
    {
#line 1131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1131
      oldlay = flayer;
      {
#line 1131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1131
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1131
      flayer = flayer->l_next;
#line 1131
      oldcvlist = flayer->l_cvlist;
      {
#line 1131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1131
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1131
      flayer->l_cvlist = oldlay->l_cvlist;
#line 1131
      cv = flayer->l_cvlist;
      {
#line 1131
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1131
        if (! cv) {
#line 1131
          goto while_break___3;
        }
#line 1131
        cv->c_layer = flayer;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1131
      cv = cv->c_lnext;
#line 1131
      LRefreshAll(flayer, 0);
#line 1131
      flayer = oldlay;
#line 1131
      cv = flayer->l_cvlist;
      }
      {
#line 1131
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1131
        if (! cv) {
#line 1131
          goto while_break___4;
        }
#line 1131
        cv->c_layer = flayer;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1131
      cv = cv->c_lnext;
#line 1131
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 1131
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1135
    rem(markdata->x1, markdata->y1, markdata->cx, markdata->cy, redisp, (char *)0,
        yend);
    }
  }
  {
#line 1137
  ExitOverlayPage();
  }
}
}
#line 1142 "/tmp/screen-3.9.15/mark.c"
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int wy ;
  int x ;
  int i ;
  int rm ;
  int sta ;
  int sto ;
  int cp ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  struct mline *tmp ;
  int tmp___407 ;
  int __cil_tmp17 ;
  int tmp___408 ;
  struct mline *tmp___409 ;
  int __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp___410 ;
  int __cil_tmp26 ;
  int tmp___411 ;
  int tmp___412 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 1153
  if (y < 0) {
#line 1154
    return;
  }
#line 1156
  markdata = (struct markdata *)flayer->l_data;
#line 1157
  fore = markdata->md_window;
#line 1159
  mchar_marked = mchar_so;
#line 1161
  wy = y + markdata->hist_offset;
#line 1162
  if (wy < fore->w_histheight) {
#line 1162
    tmp = & *(fore->w_hlines + (fore->w_histidx + wy) % fore->w_histheight);
  } else {
#line 1162
    tmp = & *(fore->w_mlines + (wy - fore->w_histheight));
  }
#line 1162
  ml = tmp;
#line 1164
  if (markdata->second == 0) {
#line 1166
    if (fore->w_layer.l_encoding == 8) {
#line 1166
      tmp___407 = (int )*(ml->font + xs) == 255 && (int )*(ml->image + xs) == 255;
    } else {
#line 1166
      tmp___407 = ((int )*(ml->font + xs) & 224) == 128;
    }
#line 1166
    if (tmp___407) {
#line 1166
      if (xs > 0) {
#line 1167
        __cil_tmp17 = xs;
#line 1167
        xs --;
      }
    }
#line 1168
    if (fore->w_layer.l_encoding == 8) {
#line 1168
      tmp___408 = (int )*(ml->font + (xe + 1)) == 255 && (int )*(ml->image + (xe + 1)) == 255;
    } else {
#line 1168
      tmp___408 = ((int )*(ml->font + xe) & 31) != 0 && ((int )*(ml->font + xe) & 224) == 0;
    }
#line 1168
    if (tmp___408) {
#line 1168
      if (xe < fore->w_layer.l_width - 1) {
#line 1169
        xe ++;
      }
    }
#line 1170
    if (xs == 0) {
#line 1170
      if (y > 0) {
#line 1170
        if (wy > 0) {
#line 1170
          if ((int )*(tmp___409->image + flayer->l_width) == 0) {
            {
#line 1171
            LCDisplayLineWrap(flayer, ml, y, xs, xe, isblank);
            }
          } else {
            {
            {
            {
            {
#line 1173
            LCDisplayLine(flayer, ml, y, xs, xe, isblank);
            }
            }
            }
            }
          }
        } else {
          {
          {
          {
          {
#line 1173
          LCDisplayLine(flayer, ml, y, xs, xe, isblank);
          }
          }
          }
          }
        }
      } else {
        {
        {
        {
        {
#line 1173
        LCDisplayLine(flayer, ml, y, xs, xe, isblank);
        }
        }
        }
        }
      }
    } else {
      {
      {
      {
      {
#line 1173
      LCDisplayLine(flayer, ml, y, xs, xe, isblank);
      }
      }
      }
      }
    }
#line 1174
    return;
  }
#line 1177
  sta = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1178
  sto = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1179
  if (sta > sto) {
#line 1181
    i = sta;
#line 1181
    sta = sto;
#line 1181
    sto = i;
  }
#line 1183
  cp = wy * fore->w_layer.l_width + xs;
#line 1185
  rm = markdata->right_mar;
#line 1186
  wi = ml->image + fore->w_layer.l_width;
#line 1186
  x = fore->w_layer.l_width;
  {
#line 1186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1186
    if (! (x >= 0)) {
#line 1186
      goto while_break;
    }
#line 1187
    if ((int )*wi != 32) {
#line 1188
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1186
  __cil_tmp22 = wi;
#line 1186
  wi --;
#line 1186
  __cil_tmp21 = x;
#line 1186
  x --;
#line 1189
  if (x < rm) {
#line 1190
    rm = x;
  }
#line 1192
  x = xs;
  {
#line 1192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1192
    if (! (x <= xe)) {
#line 1192
      goto while_break___0;
    }
#line 1193
    if (cp >= sta) {
#line 1193
      if (x >= markdata->left_mar) {
#line 1194
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1192
  __cil_tmp24 = cp;
#line 1192
  cp ++;
#line 1192
  __cil_tmp23 = x;
#line 1192
  x ++;
#line 1196
  if (fore->w_layer.l_encoding == 8) {
#line 1196
    tmp___410 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 1196
    tmp___410 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 1196
  if (tmp___410) {
#line 1197
    __cil_tmp26 = x;
#line 1197
    x --;
  }
#line 1199
  if (x > xs) {
    {
#line 1200
    LCDisplayLine(flayer, ml, y, xs, x - 1, isblank);
    }
  }
  {
#line 1201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1201
    if (! (x <= xe)) {
#line 1201
      goto while_break___1;
    }
#line 1203
    if (cp > sto) {
#line 1204
      goto while_break___1;
    } else
#line 1203
    if (x > rm) {
#line 1204
      goto while_break___1;
    }
#line 1206
    if (pastefont) {
#line 1207
      mchar_marked.font = *(ml->font + x);
    }
#line 1209
    mchar_marked.image = *(ml->image + x);
#line 1211
    mchar_marked.mbcs = (unsigned char )0;
#line 1212
    if (fore->w_layer.l_encoding == 8) {
#line 1212
      tmp___411 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 1212
      tmp___411 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 1212
    if (tmp___411) {
#line 1214
      mchar_marked.mbcs = *(ml->image + (x + 1));
#line 1215
      cp ++;
    }
    {
#line 1218
    LPutChar(flayer, & mchar_marked, x, y);
    }
#line 1220
    if (fore->w_layer.l_encoding == 8) {
#line 1220
      tmp___412 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 1220
      tmp___412 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 1220
    if (tmp___412) {
#line 1221
      x ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1201
  __cil_tmp32 = cp;
#line 1201
  cp ++;
#line 1201
  __cil_tmp31 = x;
#line 1201
  x ++;
#line 1224
  if (x <= xe) {
    {
#line 1225
    LCDisplayLine(flayer, ml, y, x, xe, isblank);
    }
  }
}
}
#line 1233 "/tmp/screen-3.9.15/mark.c"
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) 
{ 
  int dx ;
  int x ;
  int y ;
  int st ;
  int en ;
  int t ;
  int rm ;
  unsigned char *i ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  struct mline *tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 1242
  mchar_marked = mchar_so;
  {
#line 1244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1244
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1245
  markdata = (struct markdata *)flayer->l_data;
#line 1246
  fore = markdata->md_window;
#line 1247
  y = ry + markdata->hist_offset;
#line 1248
  if (y < fore->w_histheight) {
#line 1248
    tmp = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 1248
    tmp = & *(fore->w_mlines + (y - fore->w_histheight));
  }
  {
#line 1248
  ml = tmp;
#line 1250
  __cil_tmp17 = ContainsSpecialDeffont(ml, xs, xe, fore->w_layer.l_encoding);
  }
#line 1250
  if (fore->w_layer.l_encoding) {
#line 1250
    if (fore->w_layer.l_encoding != 8) {
#line 1250
      if (display->d_encoding == 8) {
#line 1250
        if (__cil_tmp17) {
#line 1251
          return (1000);
        }
      }
    }
  }
#line 1253
  dx = (xe - xs) + 1;
#line 1254
  if (doit) {
#line 1256
    i = ml->image + xs;
    {
#line 1257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1257
      if (! __cil_tmp18) {
#line 1257
        goto while_break___0;
      }
      {
#line 1258
      __cil_tmp19 = i;
#line 1258
      i ++;
#line 1258
      PUTCHAR((int )*__cil_tmp19);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1259
    return (0);
  }
#line 1262
  if (markdata->second == 0) {
#line 1263
    en = - 1;
#line 1263
    st = en;
  } else {
#line 1266
    st = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1267
    en = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1268
    if (st > en) {
#line 1270
      t = st;
#line 1270
      st = en;
#line 1270
      en = t;
    }
  }
#line 1273
  t = y * fore->w_layer.l_width + xs;
#line 1274
  i = ml->image + fore->w_layer.l_width;
#line 1274
  rm = fore->w_layer.l_width;
  {
#line 1274
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1274
    if (! (rm >= 0)) {
#line 1274
      goto while_break___1;
    }
#line 1275
    __cil_tmp20 = i;
#line 1275
    i --;
#line 1275
    if ((int )*__cil_tmp20 != 32) {
#line 1276
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1274
  __cil_tmp21 = rm;
#line 1274
  rm --;
#line 1277
  if (rm > markdata->right_mar) {
#line 1278
    rm = markdata->right_mar;
  }
#line 1279
  x = xs;
  {
#line 1280
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1280
    if (! __cil_tmp22) {
#line 1280
      goto while_break___2;
    }
#line 1282
    if (t >= st) {
#line 1282
      if (t <= en) {
#line 1282
        if (x >= markdata->left_mar) {
#line 1282
          if (x <= rm) {
#line 1285
            if (pastefont) {
#line 1286
              mchar_marked.font = *(ml->font + x);
            }
#line 1288
            rend->image = mchar_marked.image;
#line 1289
            if (! ((((int )rend->image == (int )mchar_marked.image && (int )rend->attr == (int )mchar_marked.attr) && (int )rend->font == (int )mchar_marked.font) && (int )rend->color == (int )mchar_marked.color)) {
#line 1290
              return (1000);
            }
          } else {
#line 1282
            goto _L;
          }
        } else {
#line 1282
          goto _L;
        }
      } else {
#line 1282
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1294
      rend->image = *(ml->image + x);
#line 1295
      if (! ((((int )rend->image == (int )*(ml->image + x) && (int )rend->attr == (int )*(ml->attr + x)) && (int )rend->font == (int )*(ml->font + x)) && (int )rend->color == (int )*(ml->color + x))) {
#line 1296
        return (1000);
      }
    }
#line 1298
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1300
  return ((xe - xs) + 1);
}
}
#line 1307 "/tmp/screen-3.9.15/mark.c"
static int MarkScrollUpDisplay(int n ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp4 ;

  {
  {
#line 1312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1312
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  if (n <= 0) {
#line 1314
    return (0);
  }
#line 1315
  if (n > fore->w_histheight - markdata->hist_offset) {
#line 1316
    n = fore->w_histheight - markdata->hist_offset;
  }
#line 1317
  markdata->hist_offset += n;
#line 1318
  if (n < flayer->l_height) {
#line 1318
    tmp = n;
  } else {
#line 1318
    tmp = flayer->l_height;
  }
  {
#line 1318
  i = tmp;
#line 1319
  LScrollV(flayer, i, 0, flayer->l_height - 1, 0);
  }
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1320
    if (! (__cil_tmp4 > 0)) {
#line 1320
      goto while_break___0;
    }
    {
#line 1321
    MarkRedisplayLine((flayer->l_height - i) - 1, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1322
  return (n);
}
}
#line 1326 "/tmp/screen-3.9.15/mark.c"
static int MarkScrollDownDisplay(int n ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp4 ;

  {
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1332
  if (n <= 0) {
#line 1333
    return (0);
  }
#line 1334
  if (n > markdata->hist_offset) {
#line 1335
    n = markdata->hist_offset;
  }
#line 1336
  markdata->hist_offset -= n;
#line 1337
  if (n < flayer->l_height) {
#line 1337
    tmp = n;
  } else {
#line 1337
    tmp = flayer->l_height;
  }
  {
#line 1337
  i = tmp;
#line 1338
  LScrollV(flayer, - i, 0, fore->w_layer.l_height - 1, 0);
  }
  {
#line 1339
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1339
    if (! (__cil_tmp4 > 0)) {
#line 1339
      goto while_break___0;
    }
    {
#line 1340
    MarkRedisplayLine(i, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1341
  return (n);
}
}
#line 1345 "/tmp/screen-3.9.15/mark.c"
int InMark(void) 
{ 


  {
#line 1347
  if (flayer) {
#line 1347
    if (flayer->l_layfn == & MarkLf) {
#line 1348
      return (1);
    }
  }
#line 1349
  return (0);
}
}
#line 1353 "/tmp/screen-3.9.15/mark.c"
void MakePaster(struct paster *pa , char *buf , int len , int bufiscopy ) 
{ 


  {
  {
#line 1359
  FreePaster(pa);
#line 1360
  pa->pa_pasteptr = buf;
#line 1361
  pa->pa_pastelen = len;
  }
#line 1362
  if (bufiscopy) {
#line 1363
    pa->pa_pastebuf = buf;
  }
  {
#line 1364
  pa->pa_pastelayer = flayer;
#line 1365
  DoProcess((struct win *)(flayer->l_bottom)->l_data, & pa->pa_pasteptr, & pa->pa_pastelen,
            pa);
  }
}
}
#line 1369 "/tmp/screen-3.9.15/mark.c"
void FreePaster(struct paster *pa ) 
{ 


  {
#line 1372
  if (pa->pa_pastebuf) {
    {
#line 1373
    free((void *)pa->pa_pastebuf);
    }
  }
  {
#line 1374
  pa->pa_pastebuf = (char *)0;
#line 1375
  pa->pa_pasteptr = (char *)0;
#line 1376
  pa->pa_pastelayer = (struct layer *)0;
#line 1377
  evdeq(& pa->pa_slowev);
  }
}
}
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 232 "/usr/include/stdio.h"
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 581
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 1017
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 63 "./extern.h"
void WMsg(struct win *p , int err , char *str ) ;
#line 70
void FinishRc(char *rcfilename ) ;
#line 77
int printpipe(struct win *p , char *cmd ) ;
#line 78
int readpipe(char **cmdv ) ;
#line 54 "/tmp/screen-3.9.15/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) ;
#line 55
static char *findrcfile(char *rcfile ) ;
#line 58 "/tmp/screen-3.9.15/fileio.c"
char *rc_name  =    (char *)"";
#line 59 "/tmp/screen-3.9.15/fileio.c"
int rc_recursion  =    0;
#line 62 "/tmp/screen-3.9.15/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) 
{ 
  register char *cp ;
  register int len1 ;
  register int len2 ;
  register int add_colon ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 68
  __cil_tmp7 = strlen((char const   *)str1);
#line 68
  len1 = (int )__cil_tmp7;
  }
#line 69
  if (len1 == 0) {
#line 70
    return (str2);
  }
#line 71
  add_colon = (int )*(str1 + (len1 - 1)) != 58;
#line 72
  if (str2) {
    {
#line 74
    __cil_tmp8 = strlen((char const   *)str2);
#line 74
    len2 = (int )__cil_tmp8;
#line 75
    __cil_tmp9 = realloc((void *)str2, (unsigned long )((((unsigned int )len1 + (unsigned int )len2) + (unsigned int )add_colon) + 1U));
#line 75
    cp = (char *)__cil_tmp9;
    }
#line 75
    if (cp == (char *)((void *)0)) {
      {
#line 76
      Panic(0, (char *)strnomem);
      }
    }
    {
#line 77
    bcopy((void const   *)cp, (void *)((cp + len1) + add_colon), (size_t )(len2 + 1));
    }
  } else {
#line 81
    if (len1 == 0) {
#line 82
      return ((char *)0);
    }
    {
#line 83
    __cil_tmp10 = malloc((unsigned long )(((unsigned int )len1 + (unsigned int )add_colon) + 1U));
#line 83
    cp = (char *)__cil_tmp10;
    }
#line 83
    if (cp == (char *)((void *)0)) {
      {
#line 84
      Panic(0, (char *)strnomem);
      }
    }
#line 85
    *(cp + (len1 + add_colon)) = (char )'\000';
  }
  {
#line 87
  bcopy((void const   *)str1, (void *)cp, (size_t )len1);
  }
#line 88
  if (add_colon) {
#line 89
    *(cp + len1) = (char )':';
  }
#line 91
  return (cp);
}
}
#line 95 "/tmp/screen-3.9.15/fileio.c"
static char *findrcfile(char *rcfile ) 
{ 
  char buf[256] ;
  char *p ;
  char *rcend ;
  char *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp11 ;
  size_t __cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 101
  if (rcfile) {
    {
#line 103
    __cil_tmp5 = rindex((char const   *)rc_name, '/');
#line 103
    rcend = __cil_tmp5;
#line 104
    __cil_tmp6 = strlen((char const   *)rcfile);
    }
#line 104
    if ((int )*rcfile != 47) {
#line 104
      if (rcend) {
#line 104
        if (((unsigned long )(rcend - rc_name) + __cil_tmp6) + 2UL < sizeof(buf)) {
          {
#line 106
          strncpy((char *)buf, (char const   *)rc_name, (unsigned long )((rcend - rc_name) + 1L));
#line 107
          strcpy(((char *)buf + (rcend - rc_name)) + 1, (char const   *)rcfile);
#line 108
          __cil_tmp7 = access((char const   *)((char *)buf), 4);
          }
#line 108
          if (__cil_tmp7 == 0) {
            {
#line 109
            __cil_tmp8 = SaveStr((char const   *)((char *)buf));
            }
#line 109
            return (__cil_tmp8);
          }
        }
      }
    }
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 112
    __cil_tmp9 = SaveStr((char const   *)rcfile);
    }
#line 112
    return (__cil_tmp9);
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 115
  p = getenv((char const   *)((char *)"SCREENRC"));
  }
#line 115
  if (p != (char *)((void *)0)) {
#line 115
    if ((int )*p != 0) {
      {
#line 117
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 117
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 118
      __cil_tmp11 = SaveStr((char const   *)p);
      }
#line 118
      return (__cil_tmp11);
    } else {
#line 115
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 122
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 122
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 123
    __cil_tmp12 = strlen((char const   *)home);
    }
#line 123
    if (__cil_tmp12 > sizeof(buf) - 12UL) {
      {
#line 124
      Panic(0, (char *)"Rc: home too large");
      }
    }
    {
#line 125
    sprintf((char *)buf, (char const   *)((char *)"%s/.screenrc"), home);
#line 126
    __cil_tmp13 = SaveStr((char const   *)((char *)buf));
    }
#line 126
    return (__cil_tmp13);
  }
}
}
#line 136 "/tmp/screen-3.9.15/fileio.c"
void StartRc(char *rcfilename ) 
{ 
  register int argc ;
  register int len ;
  register char *p ;
  register char *cp ;
  char buf[2048] ;
  char *args[64] ;
  FILE *fp ;
  char *oldrc_name ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp28 ;
  size_t __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp34 ;
  int __cil_tmp36 ;

  {
  {
#line 144
  oldrc_name = rc_name;
#line 147
  extra_incap = CatExtra((char *)"TF", extra_incap);
#line 150
  __cil_tmp12 = strncmp((char const   *)((char *)display->d_termname), (char const   *)((char *)"xterm"),
                        (unsigned long )5);
  }
  {
#line 150
  __cil_tmp11 = strncmp((char const   *)((char *)display->d_termname), (char const   *)((char *)"vt"),
                        (unsigned long )2);
  }
#line 150
  if (display) {
#line 150
    if (! __cil_tmp11) {
      {
      {
#line 151
      extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                             extra_incap);
      }
      }
    } else
#line 150
    if (! __cil_tmp12) {
      {
      {
#line 151
      extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                             extra_incap);
      }
      }
    }
  }
  {
#line 153
  rc_name = findrcfile(rcfilename);
#line 155
  fp = secfopen(rc_name, (char *)"r");
  }
#line 155
  if (fp == (FILE *)((void *)0)) {
    {
#line 157
    __cil_tmp16 = strcmp((char const   *)RcFileName, (char const   *)rc_name);
    }
#line 157
    if (! rc_recursion) {
#line 157
      if (RcFileName) {
#line 157
        if (! __cil_tmp16) {
          {
#line 164
          while (1) {
            while_continue: /* CIL Label */ ;
#line 164
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 165
          Panic(0, (char *)"Unable to open \"%s\".", rc_name);
          }
        }
      }
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    if (rc_name == (char *)0) {
      {
#line 169
      abort();
      }
    } else {
      {
#line 169
      free((void *)rc_name);
      }
    }
#line 169
    rc_name = (char *)0;
#line 170
    rc_name = oldrc_name;
#line 171
    return;
  }
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (__cil_tmp17 != (char *)((void *)0))) {
#line 173
      goto while_break___1;
    }
    {
#line 175
    p = rindex((char const   *)((char *)buf), '\n');
    }
#line 175
    if (p != (char *)((void *)0)) {
#line 176
      *p = (char )'\000';
    }
    {
#line 177
    __cil_tmp19 = expand_vars((char *)buf, display);
#line 177
    __cil_tmp20 = Parse(__cil_tmp19, (char **)args);
#line 177
    argc = __cil_tmp20;
    }
#line 177
    if (argc == 0) {
#line 178
      goto while_continue___1;
    }
    {
#line 179
    __cil_tmp21 = strcmp((char const   *)args[0], (char const   *)((char *)"echo"));
    }
#line 179
    if (__cil_tmp21 == 0) {
#line 181
      if (! display) {
#line 182
        goto while_continue___1;
      }
      {
#line 183
      __cil_tmp22 = strcmp((char const   *)args[1], (char const   *)((char *)"-n"));
      }
#line 183
      if (argc < 2) {
        {
        {
        {
#line 185
        Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
        }
        }
        }
#line 186
        goto while_continue___1;
      } else
#line 183
      if (argc == 3) {
#line 183
        if (__cil_tmp22) {
          {
          {
          {
#line 185
          Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
          }
          }
          }
#line 186
          goto while_continue___1;
        } else {
#line 183
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 183
      if (argc > 3) {
        {
        {
        {
#line 185
        Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
        }
        }
        }
#line 186
        goto while_continue___1;
      }
      {
#line 188
      AddStr(args[argc - 1]);
      }
#line 189
      if (argc != 3) {
        {
#line 191
        AddStr((char *)"\r\n");
#line 192
        Flush();
        }
      }
    } else {
      {
#line 195
      __cil_tmp23 = strcmp((char const   *)args[0], (char const   *)((char *)"sleep"));
      }
#line 195
      if (__cil_tmp23 == 0) {
#line 197
        if (! display) {
#line 198
          goto while_continue___1;
        }
        {
#line 199
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 199
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 200
        if (argc != 2) {
          {
#line 202
          Msg(0, (char *)"%s: sleep: one numeric argument expected.", rc_name);
          }
#line 203
          goto while_continue___1;
        }
        {
#line 205
        __cil_tmp24 = atoi((char const   *)args[1]);
#line 205
        DisplaySleep(__cil_tmp24, 1);
        }
      } else {
        {
#line 208
        __cil_tmp26 = strcmp((char const   *)args[0], (char const   *)((char *)"terminfo"));
        }
        {
#line 208
        __cil_tmp25 = strcmp((char const   *)args[0], (char const   *)((char *)"termcapinfo"));
        }
#line 208
        if (! __cil_tmp25) {
          _L___415: /* CIL Label */ 
#line 213
          if (! display) {
#line 214
            goto while_continue___1;
          }
#line 215
          if (argc < 3) {
            {
            {
#line 217
            Msg(0, (char *)"%s: %s: incorrect number of arguments.", rc_name, args[0]);
            }
            }
#line 218
            goto while_continue___1;
          } else
#line 215
          if (argc > 4) {
            {
            {
#line 217
            Msg(0, (char *)"%s: %s: incorrect number of arguments.", rc_name, args[0]);
            }
            }
#line 218
            goto while_continue___1;
          }
#line 220
          p = args[1];
          {
#line 220
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 220
            if (! (p && (int )*p)) {
#line 220
              goto while_break___3;
            }
            {
#line 222
            cp = index((char const   *)p, '|');
            }
#line 222
            if (cp != (char *)0) {
#line 223
              __cil_tmp28 = cp;
#line 223
              cp ++;
#line 223
              *__cil_tmp28 = (char )'\000';
            }
            {
#line 224
            __cil_tmp29 = strlen((char const   *)p);
#line 224
            len = (int )__cil_tmp29;
            }
#line 225
            if ((int )*(p + (len - 1)) == 42) {
              {
#line 227
              __cil_tmp30 = strncmp((char const   *)p, (char const   *)((char *)display->d_termname),
                                    (unsigned long )(len - 1));
              }
#line 227
              if (! (len - 1)) {
#line 228
                goto while_break___3;
              } else
#line 227
              if (! __cil_tmp30) {
#line 228
                goto while_break___3;
              }
            } else {
              {
#line 230
              __cil_tmp31 = strcmp((char const   *)p, (char const   *)((char *)display->d_termname));
              }
#line 230
              if (! __cil_tmp31) {
#line 231
                goto while_break___3;
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 220
          p = cp;
#line 233
          if (! (p && (int )*p)) {
#line 234
            goto while_continue___1;
          }
          {
#line 235
          extra_incap = CatExtra(args[2], extra_incap);
          }
#line 236
          if (argc == 4) {
            {
#line 237
            extra_outcap = CatExtra(args[3], extra_outcap);
            }
          }
        } else
#line 208
        if (! __cil_tmp26) {
#line 208
          goto _L___415;
        } else {
          {
#line 239
          __cil_tmp34 = strcmp((char const   *)args[0], (char const   *)((char *)"source"));
          }
#line 239
          if (! __cil_tmp34) {
#line 241
            if (rc_recursion <= 10) {
              {
#line 243
              rc_recursion ++;
#line 244
              StartRc(args[1]);
#line 245
              __cil_tmp36 = rc_recursion;
#line 245
              rc_recursion --;
              }
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 249
  fclose(fp);
  }
#line 250
  if (rc_name == (char *)0) {
    {
#line 250
    abort();
    }
  } else {
    {
#line 250
    free((void *)rc_name);
    }
  }
#line 250
  rc_name = (char *)0;
#line 251
  rc_name = oldrc_name;
}
}
#line 255 "/tmp/screen-3.9.15/fileio.c"
void FinishRc(char *rcfilename ) 
{ 
  char buf[2048] ;
  FILE *fp ;
  char *oldrc_name ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 260
  oldrc_name = rc_name;
#line 262
  rc_name = findrcfile(rcfilename);
#line 264
  fp = secfopen(rc_name, (char *)"r");
  }
#line 264
  if (fp == (FILE *)((void *)0)) {
#line 266
    if (rc_recursion) {
      {
#line 267
      __cil_tmp7 = __errno_location();
#line 267
      Msg(*__cil_tmp7, (char *)"%s: source %s", oldrc_name, rc_name);
      }
    } else {
      {
#line 268
      __cil_tmp8 = strcmp((char const   *)RcFileName, (char const   *)rc_name);
      }
#line 268
      if (RcFileName) {
#line 268
        if (! __cil_tmp8) {
          {
#line 275
          while (1) {
            while_continue: /* CIL Label */ ;
#line 275
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 276
          Panic(0, (char *)"Unable to open \"%s\".", rc_name);
          }
        }
      }
    }
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    if (rc_name == (char *)0) {
      {
#line 280
      abort();
      }
    } else {
      {
#line 280
      free((void *)rc_name);
      }
    }
#line 280
    rc_name = (char *)0;
#line 281
    rc_name = oldrc_name;
#line 282
    return;
  }
  {
#line 285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 285
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 286
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 286
    if (! (__cil_tmp9 != (char *)((void *)0))) {
#line 286
      goto while_break___2;
    }
    {
#line 287
    RcLine((char *)buf);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 288
  __cil_tmp10 = fclose(fp);
  }
#line 289
  if (rc_name == (char *)0) {
    {
#line 289
    abort();
    }
  } else {
    {
#line 289
    free((void *)rc_name);
    }
  }
#line 289
  rc_name = (char *)0;
#line 290
  rc_name = oldrc_name;
}
}
#line 294 "/tmp/screen-3.9.15/fileio.c"
void do_source(char *rcfilename ) 
{ 
  int __cil_tmp3 ;

  {
#line 297
  if (rc_recursion > 10) {
    {
#line 299
    Msg(0, (char *)"%s: source: recursion limit reached", rc_name);
    }
#line 300
    return;
  }
  {
#line 302
  rc_recursion ++;
#line 303
  FinishRc(rcfilename);
#line 304
  __cil_tmp3 = rc_recursion;
#line 304
  rc_recursion --;
  }
}
}
#line 314 "/tmp/screen-3.9.15/fileio.c"
void RcLine(char *ubuf ) 
{ 
  char *args[64] ;
  char *buf ;
  extern struct acluser *EffectiveAclUser___0 ;
  extern struct acluser *users___0 ;
  struct layer *tmp ;
  int __cil_tmp8 ;

  {
#line 323
  if (display) {
#line 325
    fore = display->d_fore;
#line 326
    flayer = (display->d_forecv)->c_layer;
  } else {
#line 329
    if (fore) {
#line 329
      tmp = fore->w_savelayer;
    } else {
#line 329
      tmp = (struct layer *)0;
    }
#line 329
    flayer = tmp;
  }
  {
#line 330
  buf = expand_vars(ubuf, display);
#line 331
  __cil_tmp8 = Parse(buf, (char **)args);
  }
#line 331
  if (__cil_tmp8 <= 0) {
#line 332
    return;
  }
#line 334
  if (! display) {
#line 337
    EffectiveAclUser___0 = users___0;
    {
#line 338
    while (1) {
      while_continue: /* CIL Label */ ;
#line 338
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 342
  DoCommand((char **)args);
#line 344
  EffectiveAclUser___0 = (struct acluser *)0;
  }
}
}
#line 352 "/tmp/screen-3.9.15/fileio.c"
void WriteFile(struct acluser *user , char *fn , int dump ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register char *p ;
  register FILE *f ;
  char fnbuf[1024] ;
  char *mode ;
  int public ;
  int old_umask ;
  struct stat stb ;
  struct stat stb2 ;
  int fd ;
  int exists ;
  size_t __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  __mode_t __cil_tmp22 ;
  int __cil_tmp24 ;
  FILE *__cil_tmp26 ;
  FILE *tmp ;
  int __cil_tmp29 ;
  struct mline *tmp___0 ;
  int __cil_tmp31 ;
  int __cil_tmp34 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  char *tmp___1 ;

  {
#line 368
  mode = (char *)"w";
#line 370
  public = 0;
#line 378
  exists = 0;
  {
#line 384
  if (dump == 0) {
#line 384
    goto case_0;
  }
#line 396
  if (dump == 3) {
#line 396
    goto case_3;
  }
#line 396
  if (dump == 1) {
#line 396
    goto case_3;
  }
#line 411
  if (dump == 2) {
#line 411
    goto case_2;
  }
#line 382
  goto switch_break;
  case_0: /* CIL Label */ 
#line 385
  if (fn == (char *)0) {
#line 387
    i = (int )(SockName - (char *)SockPath);
#line 388
    if ((unsigned long )i > sizeof(fnbuf) - 9UL) {
#line 389
      i = 0;
    }
    {
#line 390
    strncpy((char *)fnbuf, (char const   *)((char *)SockPath), (unsigned long )i);
#line 391
    strcpy((char *)fnbuf + i, (char const   *)((char *)".termcap"));
#line 392
    fn = (char *)fnbuf;
    }
  }
#line 394
  goto switch_break;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 397
  if (fn == (char *)0) {
#line 399
    if (fore == (struct win *)0) {
#line 400
      return;
    }
    {
#line 401
    __cil_tmp17 = strlen((char const   *)hardcopydir);
    }
#line 401
    if (hardcopydir) {
#line 401
      if ((int )*hardcopydir) {
#line 401
        if (__cil_tmp17 < sizeof(fnbuf) - 21UL) {
          {
#line 402
          sprintf((char *)fnbuf, (char const   *)((char *)"%s/hardcopy.%d"), hardcopydir,
                  fore->w_number);
          }
        } else {
          {
          {
          {
#line 404
          sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 404
        sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 404
      sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
      }
      }
      }
    }
#line 405
    fn = (char *)fnbuf;
  }
  {
#line 407
  __cil_tmp18 = access((char const   *)fn, 2);
  }
#line 407
  if (hardcopy_append) {
#line 407
    if (! __cil_tmp18) {
#line 408
      mode = (char *)"a";
    }
  }
#line 409
  goto switch_break;
  case_2: /* CIL Label */ 
#line 412
  if (fn == (char *)0) {
    {
#line 414
    strncpy((char *)fnbuf, (char const   *)BufferFile, sizeof(fnbuf) - 1UL);
#line 415
    fnbuf[sizeof(fnbuf) - 1UL] = (char )0;
#line 416
    fn = (char *)fnbuf;
    }
  }
  {
#line 418
  __cil_tmp19 = strcmp((char const   *)fn, (char const   *)((char *)"/tmp/screen-exchange"));
#line 418
  public = ! __cil_tmp19;
#line 420
  __cil_tmp20 = lstat((char const   *)fn, & stb);
#line 420
  exists = ! __cil_tmp20;
  }
#line 421
  if (public) {
#line 421
    if (exists) {
#line 421
      if ((stb.st_mode & 61440U) == 40960U) {
        {
        {
#line 423
        Msg(0, (char *)"No write to links, please.");
        }
        }
#line 424
        return;
      } else
#line 421
      if (stb.st_nlink > 1UL) {
        {
        {
#line 423
        Msg(0, (char *)"No write to links, please.");
        }
        }
#line 424
        return;
      }
    }
  }
#line 427
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  __cil_tmp21 = UserContext();
  }
#line 432
  if (__cil_tmp21 > 0) {
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 434
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 436
    if (dump == 2) {
#line 436
      if (public) {
        {
#line 438
        __cil_tmp22 = umask((__mode_t )0);
#line 438
        old_umask = (int )__cil_tmp22;
        }
#line 440
        if (exists) {
          {
#line 442
          fd = open((char const   *)fn, 1, 438);
          }
#line 442
          if (fd >= 0) {
            {
#line 444
            __cil_tmp24 = fstat(fd, & stb2);
            }
#line 444
            if (__cil_tmp24 == 0) {
#line 444
              if (stb.st_dev == stb2.st_dev) {
#line 444
                if (stb.st_ino == stb2.st_ino) {
                  {
#line 445
                  ftruncate(fd, (__off_t )0);
                  }
                } else {
                  {
                  {
                  {
#line 448
                  close(fd);
                  }
                  }
#line 449
                  fd = - 1;
                  }
                }
              } else {
                {
                {
                {
#line 448
                close(fd);
                }
                }
#line 449
                fd = - 1;
                }
              }
            } else {
              {
              {
              {
#line 448
              close(fd);
              }
              }
#line 449
              fd = - 1;
              }
            }
          }
        } else {
          {
#line 454
          fd = open((char const   *)fn, 193, 438);
          }
        }
#line 455
        if (fd >= 0) {
          {
#line 455
          __cil_tmp26 = fdopen(fd, (char const   *)mode);
#line 455
          tmp = __cil_tmp26;
          }
        } else {
#line 455
          tmp = (FILE *)0;
        }
        {
#line 455
        f = tmp;
#line 459
        umask((__mode_t )old_umask);
        }
      } else {
        {
        {
#line 463
        f = fopen((char const   *)fn, (char const   *)mode);
        }
        }
      }
    } else {
      {
      {
#line 463
      f = fopen((char const   *)fn, (char const   *)mode);
      }
      }
    }
#line 464
    if (f == (FILE *)((void *)0)) {
      {
#line 466
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 466
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 467
      UserReturn(0);
      }
    } else {
      {
#line 474
      if (dump == 3) {
#line 474
        goto case_3___0;
      }
#line 474
      if (dump == 1) {
#line 474
        goto case_3___0;
      }
#line 506
      if (dump == 0) {
#line 506
        goto case_0___0;
      }
#line 514
      if (dump == 2) {
#line 514
        goto case_2___0;
      }
#line 471
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 475
      if (! fore) {
#line 476
        goto switch_break___0;
      }
#line 477
      if ((int )*mode == 97) {
        {
#line 479
        _IO_putc('>', f);
#line 480
        j = fore->w_layer.l_width - 2;
        }
        {
#line 480
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 480
          if (! (j > 0)) {
#line 480
            goto while_break___2;
          }
          {
#line 481
          _IO_putc('=', f);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 480
        __cil_tmp29 = j;
#line 480
        j --;
#line 482
        fputs((char const   *)((char *)"<\n"), f);
        }
      }
#line 484
      if (dump == 3) {
#line 486
        i = 0;
        {
#line 486
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 486
          if (! (i < fore->w_histheight)) {
#line 486
            goto while_break___3;
          }
#line 488
          p = (char *)tmp___0->image;
#line 489
          k = fore->w_layer.l_width - 1;
          {
#line 489
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 489
            if (! (k >= 0 && (int )*(p + k) == 32)) {
#line 489
              goto while_break___4;
            }

          }
          while_break___4: /* CIL Label */ ;
          }
#line 489
          __cil_tmp31 = k;
#line 489
          k --;
#line 491
          j = 0;
          {
#line 491
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 491
            if (! (j <= k)) {
#line 491
              goto while_break___5;
            }
            {
#line 492
            _IO_putc((int )*(p + j), f);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 491
          j ++;
#line 493
          _IO_putc('\n', f);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 486
        i ++;
      }
#line 496
      i = 0;
      {
#line 496
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 496
        if (! (i < fore->w_layer.l_height)) {
#line 496
          goto while_break___6;
        }
#line 498
        p = (char *)(fore->w_mlines + i)->image;
#line 499
        k = fore->w_layer.l_width - 1;
        {
#line 499
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 499
          if (! (k >= 0 && (int )*(p + k) == 32)) {
#line 499
            goto while_break___7;
          }

        }
        while_break___7: /* CIL Label */ ;
        }
#line 499
        __cil_tmp34 = k;
#line 499
        k --;
#line 501
        j = 0;
        {
#line 501
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 501
          if (! (j <= k)) {
#line 501
            goto while_break___8;
          }
          {
#line 502
          _IO_putc((int )*(p + j), f);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 501
        j ++;
#line 503
        _IO_putc('\n', f);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 496
      i ++;
#line 505
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 507
      __cil_tmp37 = MakeTermcap(fore->w_aflag);
#line 507
      __cil_tmp38 = index((char const   *)__cil_tmp37, '=');
#line 507
      p = __cil_tmp38;
      }
#line 507
      if (p != (char *)((void *)0)) {
        {
#line 509
        p ++;
#line 509
        fputs((char const   *)p, f);
#line 510
        _IO_putc('\n', f);
        }
      }
#line 512
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 515
      p = user->u_plop.buf;
#line 516
      i = user->u_plop.len;
      {
#line 516
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 516
        if (! (__cil_tmp39 > 0)) {
#line 516
          goto while_break___9;
        }
#line 517
        if ((int )*p == 13) {
#line 517
          if (i == 0) {
            {
            {
#line 518
            _IO_putc('\n', f);
            }
            }
          } else
#line 517
          if ((int )*(p + 1) != 10) {
            {
            {
#line 518
            _IO_putc('\n', f);
            }
            }
          } else {
            {
            {
#line 520
            _IO_putc((int )*p, f);
            }
            }
          }
        } else {
          {
          {
#line 520
          _IO_putc((int )*p, f);
          }
          }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 516
      p ++;
#line 521
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 524
      __cil_tmp41 = fclose(f);
#line 525
      UserReturn(1);
      }
    }
  }
  {
#line 528
  __cil_tmp42 = UserStatus();
  }
#line 528
  if (__cil_tmp42 <= 0) {
    {
#line 529
    Msg(0, (char *)"Cannot open \"%s\"", fn);
    }
  } else
#line 530
  if (display) {
#line 530
    if (! *rc_name) {
      {
#line 534
      if (dump == 0) {
#line 534
        goto case_0___1;
      }
#line 538
      if (dump == 3) {
#line 538
        goto case_3___1;
      }
#line 538
      if (dump == 1) {
#line 538
        goto case_3___1;
      }
#line 543
      if (dump == 2) {
#line 543
        goto case_2___1;
      }
#line 532
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
      {
#line 535
      Msg(0, (char *)"Termcap entry written to \"%s\".", fn);
      }
#line 536
      goto switch_break___1;
      case_3___1: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 539
      if ((int )*mode == 97) {
#line 539
        tmp___1 = (char *)"appended";
      } else {
#line 539
        tmp___1 = (char *)"written";
      }
      {
#line 539
      Msg(0, (char *)"Screen image %s to \"%s\".", tmp___1, fn);
      }
#line 541
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 544
      Msg(0, (char *)"Copybuffer written to \"%s\".", fn);
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
}
}
#line 558 "/tmp/screen-3.9.15/fileio.c"
char *ReadFile(char *fn , int *lenp ) 
{ 
  int i ;
  int l ;
  int size ;
  char c ;
  char *bp ;
  char *buf ;
  struct stat stb ;
  int *__cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int *__cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  int *__cil_tmp17 ;
  ssize_t __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 567
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 568
  i = secopen(fn, 0, 0);
  }
#line 568
  if (i < 0) {
    {
#line 570
    __cil_tmp11 = __errno_location();
#line 570
    Msg(*__cil_tmp11, (char *)"no %s -- no slurp", fn);
    }
#line 571
    return ((char *)((void *)0));
  }
  {
#line 573
  __cil_tmp12 = fstat(i, & stb);
  }
#line 573
  if (__cil_tmp12) {
    {
#line 575
    __cil_tmp13 = __errno_location();
#line 575
    Msg(*__cil_tmp13, (char *)"no good %s -- no slurp", fn);
#line 576
    close(i);
    }
#line 577
    return ((char *)((void *)0));
  }
  {
#line 579
  size = (int )stb.st_size;
#line 580
  __cil_tmp14 = malloc((unsigned long )size);
#line 580
  buf = (char *)__cil_tmp14;
  }
#line 580
  if (buf == (char *)((void *)0)) {
    {
#line 582
    close(i);
#line 583
    Msg(0, (char *)strnomem);
    }
#line 584
    return ((char *)((void *)0));
  }
  {
#line 586
  __cil_tmp15 = __errno_location();
#line 586
  *__cil_tmp15 = 0;
#line 587
  __cil_tmp16 = read(i, (void *)buf, (size_t )size);
#line 587
  l = (int )__cil_tmp16;
  }
#line 587
  if (l != size) {
#line 589
    if (l < 0) {
#line 590
      l = 0;
    }
    {
#line 591
    __cil_tmp17 = __errno_location();
#line 591
    Msg(*__cil_tmp17, (char *)"Got only %d bytes from %s", l, fn);
#line 592
    close(i);
    }
  } else {
    {
#line 596
    __cil_tmp18 = read(i, (void *)(& c), (size_t )1);
    }
#line 596
    if (__cil_tmp18 > 0L) {
      {
#line 597
      Msg(0, (char *)"Slurped only %d characters (of %d) into buffer - try again",
          l, size);
      }
    } else {
      {
#line 600
      Msg(0, (char *)"Slurped %d characters into buffer", l);
      }
    }
  }
  {
#line 602
  close(i);
#line 603
  *lenp = l;
#line 604
  bp = buf;
  }
  {
#line 604
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 604
    if (! (__cil_tmp19 > 0)) {
#line 604
      goto while_break___1;
    }
#line 605
    if ((int )*bp == 10) {
#line 605
      if (bp == buf) {
#line 606
        *bp = (char )'\r';
      } else
#line 605
      if ((int )*(bp + -1) != 13) {
#line 606
        *bp = (char )'\r';
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 604
  bp ++;
#line 607
  return (buf);
}
}
#line 611 "/tmp/screen-3.9.15/fileio.c"
void KillBuffers(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;
  int *__cil_tmp3 ;
  int tmp ;
  int *__cil_tmp5 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  char *tmp___416 ;

  {
  {
#line 613
  __cil_tmp1 = UserContext();
  }
#line 613
  if (__cil_tmp1 > 0) {
    {
#line 614
    __cil_tmp2 = unlink((char const   *)BufferFile);
    }
#line 614
    if (__cil_tmp2) {
      {
#line 614
      __cil_tmp3 = __errno_location();
#line 614
      tmp = *__cil_tmp3;
      }
    } else {
#line 614
      tmp = 0;
    }
    {
#line 614
    UserReturn(tmp);
    }
  }
  {
#line 615
  __cil_tmp5 = __errno_location();
#line 615
  *__cil_tmp5 = UserStatus();
#line 616
  __cil_tmp7 = __errno_location();
  }
  {
#line 616
  __cil_tmp8 = __errno_location();
  }
#line 616
  if (*__cil_tmp8) {
#line 616
    tmp___416 = (char *)"not ";
  } else {
#line 616
    tmp___416 = (char *)"";
  }
  {
#line 616
  Msg(*__cil_tmp7, (char *)"%s %sremoved", BufferFile, tmp___416);
  }
}
}
#line 626 "/tmp/screen-3.9.15/fileio.c"
FILE *secfopen(char *name , char *mode ) 
{ 
  FILE *fi ;

  {
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 637
  xseteuid(real_uid);
#line 638
  xsetegid(real_gid);
#line 639
  fi = fopen((char const   *)name, (char const   *)mode);
#line 640
  xseteuid(eff_uid);
#line 641
  xsetegid(eff_gid);
  }
#line 642
  return (fi);
}
}
#line 672 "/tmp/screen-3.9.15/fileio.c"
int secopen(char *name , int flags , int mode ) 
{ 
  int fd ;

  {
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  xseteuid(real_uid);
#line 686
  xsetegid(real_gid);
#line 687
  fd = open((char const   *)name, flags, mode);
#line 688
  xseteuid(eff_uid);
#line 689
  xsetegid(eff_gid);
  }
#line 690
  return (fd);
}
}
#line 755 "/tmp/screen-3.9.15/fileio.c"
int printpipe(struct win *p , char *cmd ) 
{ 
  int pi[2] ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;
  __pid_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 760
  __cil_tmp4 = pipe((int *)pi);
  }
#line 760
  if (__cil_tmp4) {
    {
#line 762
    __cil_tmp5 = __errno_location();
#line 762
    WMsg(p, *__cil_tmp5, (char *)"printing pipe");
    }
#line 763
    return (- 1);
  }
  {
#line 765
  __cil_tmp6 = fork();
  }
  {
#line 767
  if (__cil_tmp6 == - 1) {
#line 767
    goto case_exp;
  }
#line 770
  if (__cil_tmp6 == 0) {
#line 770
    goto case_0;
  }
#line 787
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 768
  __cil_tmp7 = __errno_location();
#line 768
  WMsg(p, *__cil_tmp7, (char *)"printing fork");
  }
#line 769
  return (- 1);
  case_0: /* CIL Label */ 
#line 771
  display = p->w_pdisplay;
  {
#line 772
  displays = (struct display *)0;
#line 777
  close(0);
#line 778
  dup(pi[0]);
#line 779
  closeallfiles(0);
#line 780
  __cil_tmp9 = setuid((__uid_t )real_uid);
  }
  {
#line 780
  __cil_tmp8 = setgid((__gid_t )real_gid);
  }
#line 780
  if (__cil_tmp8) {
    {
    {
#line 781
    __cil_tmp10 = __errno_location();
    }
    {
#line 781
    Panic(*__cil_tmp10, (char *)"printpipe setuid");
    }
    }
  } else
#line 780
  if (__cil_tmp9) {
    {
    {
#line 781
    __cil_tmp10 = __errno_location();
    }
    {
#line 781
    Panic(*__cil_tmp10, (char *)"printpipe setuid");
    }
    }
  }
  {
#line 783
  xsignal(13, (__sighandler_t )0);
#line 785
  execl((char const   *)((char *)"/bin/sh"), (char const   *)((char *)"sh"), (char *)"-c",
        cmd, 0);
#line 786
  __cil_tmp11 = __errno_location();
#line 786
  Panic(*__cil_tmp11, (char *)"/bin/sh");
  }
  switch_default: /* CIL Label */ 
#line 788
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 790
  close(pi[0]);
  }
#line 791
  return (pi[1]);
}
}
#line 795 "/tmp/screen-3.9.15/fileio.c"
int readpipe(char **cmdv ) 
{ 
  int pi[2] ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  __pid_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 799
  __cil_tmp3 = pipe((int *)pi);
  }
#line 799
  if (__cil_tmp3) {
    {
#line 801
    __cil_tmp4 = __errno_location();
#line 801
    Msg(*__cil_tmp4, (char *)"pipe");
    }
#line 802
    return (- 1);
  }
  {
#line 804
  __cil_tmp5 = fork();
  }
  {
#line 806
  if (__cil_tmp5 == - 1) {
#line 806
    goto case_exp;
  }
#line 809
  if (__cil_tmp5 == 0) {
#line 809
    goto case_0;
  }
#line 826
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 807
  __cil_tmp6 = __errno_location();
#line 807
  Msg(*__cil_tmp6, (char *)"fork");
  }
#line 808
  return (- 1);
  case_0: /* CIL Label */ 
#line 810
  displays = (struct display *)0;
  {
#line 815
  close(1);
#line 816
  __cil_tmp7 = dup(pi[1]);
  }
#line 816
  if (__cil_tmp7 != 1) {
    {
#line 817
    Panic(0, (char *)"dup");
    }
  }
  {
#line 818
  closeallfiles(1);
#line 819
  __cil_tmp9 = setuid((__uid_t )real_uid);
  }
  {
#line 819
  __cil_tmp8 = setgid((__gid_t )real_gid);
  }
#line 819
  if (__cil_tmp8) {
    {
    {
#line 820
    __cil_tmp10 = __errno_location();
    }
    {
#line 820
    Panic(*__cil_tmp10, (char *)"setuid/setgid");
    }
    }
  } else
#line 819
  if (__cil_tmp9) {
    {
    {
#line 820
    __cil_tmp10 = __errno_location();
    }
    {
#line 820
    Panic(*__cil_tmp10, (char *)"setuid/setgid");
    }
    }
  }
  {
#line 822
  xsignal(13, (__sighandler_t )0);
#line 824
  execvp((char const   *)*cmdv, (char * const  [])cmdv);
#line 825
  __cil_tmp11 = __errno_location();
#line 825
  Panic(*__cil_tmp11, *cmdv);
  }
  switch_default: /* CIL Label */ 
#line 827
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 829
  close(pi[1]);
  }
#line 830
  return (pi[0]);
}
}
#line 64 "./extern.h"
void WChangeSize(struct win *p , int w , int h ) ;
#line 66
int MFindUsedLine(struct win *p , int ye , int ys ) ;
#line 42 "/tmp/screen-3.9.15/ansi.c"
int nversion ;
#line 58
static struct win *curr ;
#line 59
static int rows ;
#line 59
static int cols ;
#line 61 "/tmp/screen-3.9.15/ansi.c"
int visual_bell  =    0;
#line 62 "/tmp/screen-3.9.15/ansi.c"
int use_hardstatus  =    1;
#line 63 "/tmp/screen-3.9.15/ansi.c"
char *printcmd  =    (char *)0;
#line 64 "/tmp/screen-3.9.15/ansi.c"
int use_altscreen  =    0;
#line 74 "/tmp/screen-3.9.15/ansi.c"
struct mchar mchar_blank  =    {(unsigned char )' ', (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 75 "/tmp/screen-3.9.15/ansi.c"
struct mchar mchar_so  =    {(unsigned char )' ', (unsigned char )(1 << 4), (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
#line 78 "/tmp/screen-3.9.15/ansi.c"
static char *string_t_string[]  = 
#line 78
  {      (char *)"NONE",      (char *)"DCS",      (char *)"OSC",      (char *)"APC", 
        (char *)"PM",      (char *)"AKA",      (char *)"GM",      (char *)"STATUS"};
#line 92 "/tmp/screen-3.9.15/ansi.c"
static char *state_t_string[]  = 
#line 92
  {      (char *)"LIT",      (char *)"ESC",      (char *)"ASTR",      (char *)"STRESC", 
        (char *)"CSI",      (char *)"PRIN",      (char *)"PRINESC",      (char *)"PRINCSI", 
        (char *)"PRIN4"};
#line 105
static int Special(int c ) ;
#line 106
static void DoESC(int c , int intermediate ) ;
#line 107
static void DoCSI(int c , int intermediate ) ;
#line 108
static void StringStart(enum string_t type ) ;
#line 109
static void StringChar(int c ) ;
#line 110
static int StringEnd(void) ;
#line 111
static void PrintStart(void) ;
#line 112
static void PrintChar(int c ) ;
#line 113
static void PrintFlush(void) ;
#line 115
static void DesignateCharset(int c , int n ) ;
#line 116
static void MapCharset(int n ) ;
#line 117
static void MapCharsetR(int n ) ;
#line 119
static void SaveCursor(void) ;
#line 120
static void RestoreCursor(void) ;
#line 121
static void BackSpace(void) ;
#line 122
static void Return(void) ;
#line 123
static void LineFeed(int out_mode ) ;
#line 124
static void ReverseLineFeed(void) ;
#line 125
static void InsertChar(int n ) ;
#line 126
static void DeleteChar(int n ) ;
#line 127
static void DeleteLine(int n ) ;
#line 128
static void InsertLine(int n ) ;
#line 129
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) ;
#line 130
static void ForwardTab(void) ;
#line 131
static void BackwardTab(void) ;
#line 132
static void ClearScreen(void) ;
#line 133
static void ClearFromBOS(void) ;
#line 134
static void ClearToEOS(void) ;
#line 135
static void ClearLineRegion(int from , int to ) ;
#line 136
static void CursorRight(int n ) ;
#line 137
static void CursorUp(int n ) ;
#line 138
static void CursorDown(int n ) ;
#line 139
static void CursorLeft(int n ) ;
#line 140
static void ASetMode(int on ) ;
#line 141
static void SelectRendition(void) ;
#line 142
static void RestorePosRendition(void) ;
#line 143
static void FillWithEs(void) ;
#line 144
static void FindAKA(void) ;
#line 145
static void Report(char *fmt , int n1 , int n2 ) ;
#line 146
static void ScrollRegion(int n ) ;
#line 148
static void WAddLineToHist(struct win *wp , struct mline *ml ) ;
#line 150
static void WLogString(struct win *p , char *buf , int len ) ;
#line 151
static void WReverseVideo(struct win *p , int on ) ;
#line 152
static int WindowChangedCheck(char *s , int what , int *hp ) ;
#line 153
static void MFixLine(struct win *p , int y , struct mchar *mc ) ;
#line 154
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) ;
#line 155
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) ;
#line 156
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) ;
#line 157
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 158
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 159
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) ;
#line 160
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) ;
#line 162
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) ;
#line 172 "/tmp/screen-3.9.15/ansi.c"
void ResetAnsiState(struct win *p ) 
{ 


  {
#line 175
  p->w_state = (enum state_t )0;
#line 176
  p->w_StringType = (enum string_t )0;
}
}
#line 180 "/tmp/screen-3.9.15/ansi.c"
void ResetWindow(struct win *p ) 
{ 
  register int i ;

  {
  {
#line 185
  p->w_wrap = nwin_default.wrap;
#line 186
  p->w_origin = 0;
#line 187
  p->w_insert = 0;
#line 188
  p->w_revvid = 0;
#line 189
  p->w_mouse = 0;
#line 190
  p->w_curinv = 0;
#line 191
  p->w_curvvis = 0;
#line 192
  p->w_autolf = 0;
#line 193
  p->w_keypad = 0;
#line 194
  p->w_cursorkeys = 0;
#line 195
  p->w_top = 0;
#line 196
  p->w_bot = p->w_layer.l_height - 1;
#line 197
  p->w_saved = 0;
#line 198
  p->w_layer.l_y = 0;
#line 198
  p->w_layer.l_x = p->w_layer.l_y;
#line 199
  p->w_state = (enum state_t )0;
#line 200
  p->w_StringType = (enum string_t )0;
#line 201
  bzero((void *)p->w_tabs, (unsigned long )p->w_layer.l_width);
#line 202
  i = 8;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < p->w_layer.l_width)) {
#line 202
      goto while_break;
    }
#line 203
    *(p->w_tabs + i) = (char )1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  i += 8;
#line 204
  p->w_rend = mchar_null;
#line 206
  ResetCharsets(p);
#line 209
  p->w_bce = nwin_default.bce;
  }
}
}
#line 215 "/tmp/screen-3.9.15/ansi.c"
int GetAnsiStatus(struct win *w , char *buf ) 
{ 
  char *p ;
  size_t __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
#line 219
  p = buf;
#line 221
  if ((unsigned int )w->w_state == 0U) {
#line 222
    return (0);
  }
  {
#line 224
  strcpy(p, (char const   *)state_t_string[w->w_state]);
#line 225
  __cil_tmp4 = strlen((char const   *)p);
  }
#line 225
  p += __cil_tmp4;
#line 226
  if (w->w_intermediate) {
#line 228
    __cil_tmp5 = p;
#line 228
    p ++;
#line 228
    *__cil_tmp5 = (char )'-';
#line 229
    if (w->w_intermediate > 255) {
      {
#line 230
      __cil_tmp6 = AddXChar(p, w->w_intermediate >> 8);
      }
#line 230
      p += __cil_tmp6;
    }
    {
#line 231
    __cil_tmp7 = AddXChar(p, w->w_intermediate & 255);
    }
#line 231
    p += __cil_tmp7;
#line 232
    *p = (char )0;
  }
#line 234
  if ((unsigned int )w->w_state == 2U) {
    {
    {
#line 235
    sprintf(p, (char const   *)((char *)"-%s"), string_t_string[w->w_StringType]);
    }
    }
  } else
#line 234
  if ((unsigned int )w->w_state == 3U) {
    {
    {
#line 235
    sprintf(p, (char const   *)((char *)"-%s"), string_t_string[w->w_StringType]);
    }
    }
  }
  {
#line 236
  __cil_tmp8 = strlen((char const   *)p);
  }
#line 236
  p += __cil_tmp8;
#line 237
  return ((int )(p - buf));
}
}
#line 244 "/tmp/screen-3.9.15/ansi.c"
void ResetCharsets(struct win *p ) 
{ 


  {
  {
#line 247
  p->w_gr = nwin_default.gr;
#line 248
  p->w_c1 = nwin_default.c1;
#line 249
  SetCharsets(p, (char *)"BBBB02");
  }
#line 250
  if (nwin_default.charset) {
    {
#line 251
    SetCharsets(p, nwin_default.charset);
    }
  }
  {
#line 253
  ResetEncoding(p);
  }
}
}
#line 258 "/tmp/screen-3.9.15/ansi.c"
void SetCharsets(struct win *p , char *s ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 264
  i = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i < 4 && (int )*s)) {
#line 264
      goto while_break;
    }
#line 265
    if ((int )*s != 46) {
#line 266
      if ((int )*s == 66) {
#line 266
        tmp = 0;
      } else {
#line 266
        tmp = (int )*s;
      }
#line 266
      p->w_charsets[i] = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  __cil_tmp6 = s;
#line 264
  s ++;
#line 264
  __cil_tmp5 = i;
#line 264
  i ++;
#line 267
  __cil_tmp7 = s;
#line 267
  s ++;
#line 267
  if ((int )*s) {
#line 267
    if ((int )*__cil_tmp7 != 46) {
#line 268
      p->w_Charset = (int )*(s + -1) - 48;
    }
  }
#line 269
  if ((int )*s) {
#line 269
    if ((int )*s != 46) {
#line 270
      p->w_CharsetR = (int )*s - 48;
    }
  }
#line 271
  p->w_ss = 0;
#line 272
  p->w_FontL = (char )p->w_charsets[p->w_Charset];
#line 273
  p->w_FontR = (char )p->w_charsets[p->w_CharsetR];
}
}
#line 293 "/tmp/screen-3.9.15/ansi.c"
void WriteString(struct win *wp , char *buf , int len ) 
{ 
  register int c ;
  register int font ;
  struct canvas *cv ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  register int currx ;
  char *imp ;
  char *__cil_tmp12 ;
  char *__cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  int tmp ;
  struct mchar mc ;
  struct mchar *mcp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int ox ;
  int oy ;
  struct mchar omc ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int t ;
  int tmp___0 ;
  int __cil_tmp34 ;

  {
#line 304
  if (! len) {
#line 305
    return;
  }
#line 306
  if (wp->w_log) {
    {
#line 307
    WLogString(wp, buf, len);
    }
  }
#line 310
  curr = wp;
#line 311
  cols = curr->w_layer.l_width;
#line 312
  rows = curr->w_layer.l_height;
#line 315
  cv = wp->w_layer.l_cvlist;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! cv) {
#line 315
      goto while_break;
    }
#line 317
    display = cv->c_display;
#line 322
    if ((int )display->d_nonblock == 1) {
#line 322
      if (display->d_obufp - display->d_obuf > (long )display->d_obufmax) {
        {
#line 325
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 325
          (display->d_obuffree) --;
#line 325
          if (display->d_obuffree <= 0) {
            {
#line 325
            Resize_obuf();
            }
          }
#line 325
          __cil_tmp7 = display->d_obufp;
#line 325
          (display->d_obufp) ++;
#line 325
          *__cil_tmp7 = (char )'~';
#line 325
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 327
        display->d_nonblock = (char )2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  cv = cv->c_lnext;
#line 331
  if (curr->w_silence) {
    {
#line 332
    SetTimeout(& curr->w_silenceev, curr->w_silencewait * 1000);
    }
  }
#line 334
  if (curr->w_monitor == 1) {
    {
#line 336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 336
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    curr->w_monitor = 2;
  }
  {
#line 340
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 342
    __cil_tmp8 = buf;
#line 342
    buf ++;
#line 342
    c = (int )((unsigned char )*__cil_tmp8);
#line 345
    if (! curr->w_mbcs) {
#line 347
      curr->w_rend.font = (unsigned char )curr->w_FontL;
    }
#line 351
    if ((unsigned int )curr->w_state == 0U) {
#line 351
      if (curr->w_layer.l_encoding != 8) {
#line 351
        if (! ((int )curr->w_rend.font && ((int )curr->w_rend.font & 96) == 0)) {
#line 351
          if ((int )curr->w_rend.font != 73) {
#line 351
            if (! curr->w_mbcs) {
#line 351
              if ((int )curr->w_rend.font != 60) {
#line 351
                if (c >= 32) {
#line 351
                  if (c != 127) {
#line 351
                    if ((c & 128) == 0) {
                      _L___417: /* CIL Label */ 
#line 351
                      if (! curr->w_ss) {
#line 351
                        if (! curr->w_insert) {
#line 351
                          if (curr->w_layer.l_x < cols - 1) {
#line 368
                            currx = curr->w_layer.l_x;
#line 369
                            imp = buf - 1;
                            {
#line 371
                            while (1) {
                              while_continue___3: /* CIL Label */ ;
#line 371
                              if (! (currx < cols - 1)) {
#line 371
                                goto while_break___3;
                              }
#line 373
                              currx ++;
#line 374
                              len --;
#line 374
                              if (len == 0) {
#line 375
                                goto while_break___3;
                              }
#line 376
                              __cil_tmp12 = buf;
#line 376
                              buf ++;
#line 376
                              c = (int )((unsigned char )*__cil_tmp12);
#line 377
                              if (c < 32) {
#line 378
                                goto while_break___3;
                              } else
#line 377
                              if (c == 127) {
#line 378
                                goto while_break___3;
                              } else
#line 377
                              if (c & 128) {
#line 377
                                if (c < 160) {
#line 377
                                  if (curr->w_c1) {
#line 378
                                    goto while_break___3;
                                  } else {
#line 377
                                    goto _L;
                                  }
                                } else
                                _L: /* CIL Label */ 
#line 377
                                if (curr->w_gr) {
#line 378
                                  goto while_break___3;
                                }
                              }
                            }
                            while_break___3: /* CIL Label */ ;
                            }
#line 380
                            currx -= curr->w_layer.l_x;
#line 381
                            if (currx > 0) {
                              {
#line 383
                              MPutStr(curr, imp, currx, & curr->w_rend, curr->w_layer.l_x,
                                      curr->w_layer.l_y);
#line 384
                              LPutStr(& curr->w_layer, imp, currx, & curr->w_rend,
                                      curr->w_layer.l_x, curr->w_layer.l_y);
#line 385
                              curr->w_layer.l_x += currx;
                              }
                            }
#line 387
                            if (len == 0) {
#line 388
                              goto while_break___2;
                            }
                          }
                        }
                      }
                    } else
#line 351
                    if (c >= 160) {
                      _L___418: /* CIL Label */ 
#line 351
                      if (! curr->w_gr) {
#line 351
                        goto _L___417;
                      }
                    } else
#line 351
                    if (! curr->w_c1) {
#line 351
                      goto _L___418;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 393
    if (curr->w_layer.l_encoding == 8) {
      {
#line 395
      c = FromUtf8(c, & curr->w_decodestate);
      }
#line 396
      if (c == -1) {
#line 397
        goto while_continue___2;
      }
#line 398
      if (c == -2) {
#line 400
        c = 65533;
#line 402
        __cil_tmp14 = buf;
#line 402
        buf --;
#line 403
        len ++;
      }
#line 405
      if (c > 255) {
        {
#line 406
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 406
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    tryagain: 
    {
#line 413
    if ((unsigned int )curr->w_state == (unsigned int )5) {
#line 413
      goto case_5;
    }
#line 416
    if ((unsigned int )curr->w_state == '\033') {
#line 416
      goto case_27;
    }
#line 423
    if ((unsigned int )curr->w_state == (unsigned int )6) {
#line 423
      goto case_6;
    }
#line 426
    if ((unsigned int )curr->w_state == '[') {
#line 426
      goto case_91;
    }
#line 435
    if ((unsigned int )curr->w_state == (unsigned int )7) {
#line 435
      goto case_7;
    }
#line 438
    if ((unsigned int )curr->w_state == '4') {
#line 438
      goto case_52;
    }
#line 448
    if ((unsigned int )curr->w_state == (unsigned int )8) {
#line 448
      goto case_8;
    }
#line 451
    if ((unsigned int )curr->w_state == 'i') {
#line 451
      goto case_105;
    }
#line 469
    if ((unsigned int )curr->w_state == (unsigned int )2) {
#line 469
      goto case_2;
    }
#line 487
    if ((unsigned int )curr->w_state == (unsigned int )3) {
#line 487
      goto case_3;
    }
#line 490
    if ((unsigned int )curr->w_state == '\\') {
#line 490
      goto case_92;
    }
#line 509
    if ((unsigned int )curr->w_state == '\033') {
#line 509
      goto case_27___0;
    }
#line 519
    if ((unsigned int )curr->w_state == (unsigned int )1) {
#line 519
      goto case_1;
    }
#line 522
    if ((unsigned int )curr->w_state == '[') {
#line 522
      goto case_91___0;
    }
#line 528
    if ((unsigned int )curr->w_state == ']') {
#line 528
      goto case_93;
    }
#line 531
    if ((unsigned int )curr->w_state == '_') {
#line 531
      goto case_95;
    }
#line 534
    if ((unsigned int )curr->w_state == 'P') {
#line 534
      goto case_80;
    }
#line 537
    if ((unsigned int )curr->w_state == '^') {
#line 537
      goto case_94;
    }
#line 540
    if ((unsigned int )curr->w_state == '!') {
#line 540
      goto case_33;
    }
#line 544
    if ((unsigned int )curr->w_state == 'k') {
#line 544
      goto case_107;
    }
#line 544
    if ((unsigned int )curr->w_state == '\"') {
#line 544
      goto case_107;
    }
#line 579
    if ((unsigned int )curr->w_state == (unsigned int )4) {
#line 579
      goto case_4;
    }
#line 583
    if ((unsigned int )curr->w_state == '9') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '8') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '7') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '6') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '5') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '4') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '3') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '2') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '1') {
#line 583
      goto case_57;
    }
#line 583
    if ((unsigned int )curr->w_state == '0') {
#line 583
      goto case_57;
    }
#line 592
    if ((unsigned int )curr->w_state == ':') {
#line 592
      goto case_58;
    }
#line 592
    if ((unsigned int )curr->w_state == ';') {
#line 592
      goto case_58;
    }
#line 650
    if ((unsigned int )curr->w_state == 143) {
#line 650
      goto case_143;
    }
#line 650
    if ((unsigned int )curr->w_state == 142) {
#line 650
      goto case_143;
    }
#line 650
    if ((unsigned int )curr->w_state == 141) {
#line 650
      goto case_143;
    }
#line 650
    if ((unsigned int )curr->w_state == 136) {
#line 650
      goto case_143;
    }
#line 650
    if ((unsigned int )curr->w_state == 133) {
#line 650
      goto case_143;
    }
#line 650
    if ((unsigned int )curr->w_state == 132) {
#line 650
      goto case_143;
    }
#line 653
    if ((unsigned int )curr->w_state == 155) {
#line 653
      goto case_155;
    }
#line 661
    if ((unsigned int )curr->w_state == 144) {
#line 661
      goto case_144;
    }
#line 664
    goto switch_default___7;
    case_5: /* CIL Label */ 
    {
#line 416
    if (c == '\033') {
#line 416
      goto case_27;
    }
#line 419
    goto switch_default;
    case_27: /* CIL Label */ 
#line 417
    curr->w_state = (enum state_t )6;
#line 418
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 420
    PrintChar(c);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 422
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 426
    if (c == '[') {
#line 426
      goto case_91;
    }
#line 429
    goto switch_default___0;
    case_91: /* CIL Label */ 
#line 427
    curr->w_state = (enum state_t )7;
#line 428
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 430
    PrintChar('\033');
    }
    {
#line 431
    PrintChar(c);
#line 432
    curr->w_state = (enum state_t )5;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 434
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 438
    if (c == '4') {
#line 438
      goto case_52;
    }
#line 441
    goto switch_default___1;
    case_52: /* CIL Label */ 
#line 439
    curr->w_state = (enum state_t )8;
#line 440
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 442
    PrintChar('\033');
    }
    {
#line 443
    PrintChar('[');
#line 444
    PrintChar(c);
#line 445
    curr->w_state = (enum state_t )5;
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 447
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 451
    if (c == 'i') {
#line 451
      goto case_105;
    }
#line 461
    goto switch_default___2;
    case_105: /* CIL Label */ 
#line 452
    curr->w_state = (enum state_t )0;
    {
#line 453
    PrintFlush();
    }
#line 454
    if (curr->w_pdisplay) {
#line 454
      if ((curr->w_pdisplay)->d_printfd >= 0) {
        {
#line 456
        close((curr->w_pdisplay)->d_printfd);
#line 457
        (curr->w_pdisplay)->d_printfd = - 1;
        }
      }
    }
#line 459
    curr->w_pdisplay = (struct display *)0;
#line 460
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 462
    PrintChar('\033');
    }
    {
#line 463
    PrintChar('[');
#line 464
    PrintChar('4');
#line 465
    PrintChar(c);
#line 466
    curr->w_state = (enum state_t )5;
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 468
    goto switch_break;
    case_2: /* CIL Label */ 
#line 470
    if (c == 0) {
#line 471
      goto switch_break;
    }
#line 472
    if (c == 27) {
#line 474
      curr->w_state = (enum state_t )3;
#line 475
      goto switch_break;
    }
#line 479
    if (! (((unsigned int )curr->w_StringType == 2U && c < 32) && c != 5)) {
#line 480
      if (! curr->w_c1) {
        {
        {
#line 482
        StringChar(c);
        }
        }
#line 483
        goto switch_break;
      } else
#line 480
      if (c != 156) {
        {
        {
#line 482
        StringChar(c);
        }
        }
#line 483
        goto switch_break;
      }
    }
#line 485
    c = '\\';
    case_3: /* CIL Label */ 
    {
#line 490
    if (c == '\\') {
#line 490
      goto case_92;
    }
#line 509
    if (c == '\033') {
#line 509
      goto case_27___0;
    }
#line 512
    goto switch_default___3;
    case_92: /* CIL Label */ 
    {
#line 491
    __cil_tmp16 = StringEnd();
    }
#line 491
    if (__cil_tmp16 == 0) {
#line 492
      goto switch_break___4;
    } else
#line 491
    if (len <= 1) {
#line 492
      goto switch_break___4;
    }
#line 494
    cv = curr->w_layer.l_cvlist;
    {
#line 494
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 494
      if (! cv) {
#line 494
        goto while_break___5;
      }
#line 496
      display = cv->c_display;
#line 497
      if (display->d_status == 1) {
#line 498
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 494
    cv = cv->c_lnext;
#line 500
    if (cv) {
#line 502
      if (len > 4097) {
#line 503
        len = 4097;
      }
      {
#line 504
      curr->w_outlen = len - 1;
#line 505
      bcopy((void const   *)buf, (void *)((char *)curr->w_outbuf), (size_t )(len - 1));
      }
#line 506
      return;
    }
#line 508
    goto switch_break___4;
    case_27___0: /* CIL Label */ 
    {
#line 510
    StringChar('\033');
    }
#line 511
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 513
    curr->w_state = (enum state_t )2;
    {
#line 514
    StringChar('\033');
#line 515
    StringChar(c);
    }
#line 516
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 518
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 522
    if (c == '[') {
#line 522
      goto case_91___0;
    }
#line 528
    if (c == ']') {
#line 528
      goto case_93;
    }
#line 531
    if (c == '_') {
#line 531
      goto case_95;
    }
#line 534
    if (c == 'P') {
#line 534
      goto case_80;
    }
#line 537
    if (c == '^') {
#line 537
      goto case_94;
    }
#line 540
    if (c == '!') {
#line 540
      goto case_33;
    }
#line 544
    if (c == 'k') {
#line 544
      goto case_107;
    }
#line 544
    if (c == '\"') {
#line 544
      goto case_107;
    }
#line 547
    goto switch_default___4;
    case_91___0: /* CIL Label */ 
#line 523
    curr->w_NumArgs = 0;
    {
#line 524
    curr->w_intermediate = 0;
#line 525
    bzero((void *)((char *)((int *)curr->w_args)), 64UL * sizeof(int ));
#line 526
    curr->w_state = (enum state_t )4;
    }
#line 527
    goto switch_break___5;
    case_93: /* CIL Label */ 
    {
#line 529
    StringStart((enum string_t )2);
    }
#line 530
    goto switch_break___5;
    case_95: /* CIL Label */ 
    {
#line 532
    StringStart((enum string_t )3);
    }
#line 533
    goto switch_break___5;
    case_80: /* CIL Label */ 
    {
#line 535
    StringStart((enum string_t )1);
    }
#line 536
    goto switch_break___5;
    case_94: /* CIL Label */ 
    {
#line 538
    StringStart((enum string_t )4);
    }
#line 539
    goto switch_break___5;
    case_33: /* CIL Label */ 
    {
#line 541
    StringStart((enum string_t )6);
    }
#line 542
    goto switch_break___5;
    case_107: /* CIL Label */ 
    case_34: /* CIL Label */ 
    {
#line 545
    StringStart((enum string_t )5);
    }
#line 546
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
    {
#line 548
    __cil_tmp17 = Special(c);
    }
#line 548
    if (__cil_tmp17) {
#line 550
      curr->w_state = (enum state_t )0;
#line 551
      goto switch_break___5;
    }
    {
#line 553
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 553
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 554
    if (c >= 32) {
#line 554
      if (c <= 47) {
#line 556
        if (curr->w_intermediate) {
#line 559
          if (curr->w_intermediate == 36) {
#line 560
            c |= 36 << 8;
          } else {
#line 563
            c = - 1;
          }
        }
#line 565
        curr->w_intermediate = c;
      } else {
#line 554
        goto _L___419;
      }
    } else
    _L___419: /* CIL Label */ 
#line 567
    if (c >= 48) {
#line 567
      if (c <= 126) {
        {
#line 569
        DoESC(c, curr->w_intermediate);
#line 570
        curr->w_state = (enum state_t )0;
        }
      } else {
#line 574
        curr->w_state = (enum state_t )0;
#line 575
        goto tryagain;
      }
    } else {
#line 574
      curr->w_state = (enum state_t )0;
#line 575
      goto tryagain;
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 578
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 583
    if (c == '9') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '8') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '7') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '6') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '5') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '4') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '3') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '2') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '1') {
#line 583
      goto case_57;
    }
#line 583
    if (c == '0') {
#line 583
      goto case_57;
    }
#line 592
    if (c == ':') {
#line 592
      goto case_58;
    }
#line 592
    if (c == ';') {
#line 592
      goto case_58;
    }
#line 595
    goto switch_default___5;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52___0: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 584
    if (curr->w_NumArgs < 64) {
#line 586
      if (curr->w_args[curr->w_NumArgs] < 100000000) {
#line 587
        curr->w_args[curr->w_NumArgs] = 10 * curr->w_args[curr->w_NumArgs] + (c - 48);
      }
    }
#line 590
    goto switch_break___6;
    case_58: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 593
    (curr->w_NumArgs) ++;
#line 594
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 596
    __cil_tmp19 = Special(c);
    }
#line 596
    if (__cil_tmp19) {
#line 597
      goto switch_break___6;
    }
#line 598
    if (c >= 64) {
#line 598
      if (c <= 126) {
        {
#line 600
        (curr->w_NumArgs) ++;
#line 601
        DoCSI(c, curr->w_intermediate);
        }
#line 602
        if ((unsigned int )curr->w_state != 5U) {
#line 603
          curr->w_state = (enum state_t )0;
        }
      } else {
#line 598
        goto _L___422;
      }
    } else
    _L___422: /* CIL Label */ 
#line 605
    if (c >= 32) {
#line 605
      if (c <= 47) {
        _L___420: /* CIL Label */ 
#line 606
        if (curr->w_intermediate) {
#line 606
          tmp = - 1;
        } else {
#line 606
          tmp = c;
        }
#line 606
        curr->w_intermediate = tmp;
      } else {
#line 605
        goto _L___421;
      }
    } else
    _L___421: /* CIL Label */ 
#line 605
    if (c >= 60) {
#line 605
      if (c <= 63) {
#line 605
        goto _L___420;
      } else {
#line 609
        curr->w_state = (enum state_t )0;
#line 610
        goto tryagain;
      }
    } else {
#line 609
      curr->w_state = (enum state_t )0;
#line 610
      goto tryagain;
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 613
    goto switch_break;
    switch_default___6: /* CIL Label */ 
#line 617
    if (curr->w_mbcs) {
#line 618
      if (c <= 32) {
#line 619
        curr->w_mbcs = 0;
      } else
#line 618
      if (c == 127) {
#line 619
        curr->w_mbcs = 0;
      } else
#line 618
      if (c >= 128) {
#line 618
        if (c < 160) {
#line 618
          if (curr->w_c1) {
#line 619
            curr->w_mbcs = 0;
          }
        }
      }
    }
#line 621
    if (c < 32) {
#line 623
      if (c == 27) {
#line 625
        curr->w_intermediate = 0;
#line 626
        curr->w_state = (enum state_t )1;
#line 627
        if (curr->w_autoaka < 0) {
#line 628
          curr->w_autoaka = 0;
        }
      } else {
        {
#line 631
        Special(c);
        }
      }
#line 632
      goto switch_break;
    }
#line 634
    if (c >= 128) {
#line 634
      if (c < 160) {
#line 634
        if (curr->w_c1) {
#line 636
          if (((int )curr->w_FontR & 240) != 32) {
            _L___423: /* CIL Label */ 
            {
#line 650
            if (c == 143) {
#line 650
              goto case_143;
            }
#line 650
            if (c == 142) {
#line 650
              goto case_143;
            }
#line 650
            if (c == 141) {
#line 650
              goto case_143;
            }
#line 650
            if (c == 136) {
#line 650
              goto case_143;
            }
#line 650
            if (c == 133) {
#line 650
              goto case_143;
            }
#line 650
            if (c == 132) {
#line 650
              goto case_143;
            }
#line 653
            if (c == 155) {
#line 653
              goto case_155;
            }
#line 661
            if (c == 144) {
#line 661
              goto case_144;
            }
#line 664
            goto switch_default___7;
            case_143: /* CIL Label */ 
            case_142: /* CIL Label */ 
            case_141: /* CIL Label */ 
            case_136: /* CIL Label */ 
            case_133: /* CIL Label */ 
            case_132: /* CIL Label */ 
            {
#line 651
            DoESC(c ^ 192, 0);
            }
#line 652
            goto switch_break___7;
            case_155: /* CIL Label */ 
#line 654
            if (curr->w_autoaka < 0) {
#line 655
              curr->w_autoaka = 0;
            }
            {
#line 656
            curr->w_NumArgs = 0;
#line 657
            curr->w_intermediate = 0;
#line 658
            bzero((void *)((char *)((int *)curr->w_args)), 64UL * sizeof(int ));
#line 659
            curr->w_state = (enum state_t )4;
            }
#line 660
            goto switch_break___7;
            case_144: /* CIL Label */ 
            {
#line 662
            StringStart((enum string_t )1);
            }
#line 663
            goto switch_break___7;
            switch_default___7: /* CIL Label */ 
#line 665
            goto switch_break___7;
            switch_break___7: /* CIL Label */ ;
            }
#line 667
            goto switch_break;
          } else
#line 636
          if (curr->w_layer.l_encoding == 8) {
#line 636
            goto _L___423;
          }
        }
      }
    }
#line 672
    if (! curr->w_mbcs) {
#line 675
      if (c < 128) {
#line 676
        curr->w_rend.font = (unsigned char )curr->w_FontL;
      } else
#line 675
      if (curr->w_gr == 0) {
#line 676
        curr->w_rend.font = (unsigned char )curr->w_FontL;
      } else
#line 678
      if (curr->w_gr == 2) {
#line 678
        if (! curr->w_ss) {
#line 679
          curr->w_rend.font = (unsigned char )curr->w_FontE;
        } else {
#line 682
          curr->w_rend.font = (unsigned char )curr->w_FontR;
        }
      } else {
#line 682
        curr->w_rend.font = (unsigned char )curr->w_FontR;
      }
    }
#line 687
    if (curr->w_layer.l_encoding == 8) {
#line 689
      if ((int )curr->w_rend.font == 48) {
        {
#line 693
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 693
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 694
        mc.image = (unsigned char )c;
#line 695
        mc.mbcs = (unsigned char )0;
#line 696
        mc.font = (unsigned char )'0';
#line 697
        mcp = recode_mchar(& mc, 0, 8);
        }
        {
#line 698
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 698
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 699
        c = (int )mcp->image | ((int )mcp->font << 8);
      }
#line 701
      curr->w_rend.font = (unsigned char )0;
    }
    {
#line 704
    __cil_tmp25 = utf8_isdouble(c);
    }
#line 704
    if (curr->w_layer.l_encoding == 8) {
#line 704
      if (c >= 4352) {
#line 704
        if (__cil_tmp25) {
#line 705
          curr->w_mbcs = 255;
        }
      }
    }
    {
#line 707
    __cil_tmp26 = utf8_iscomb(c);
    }
#line 707
    if (curr->w_layer.l_encoding == 8) {
#line 707
      if (c >= 768) {
#line 707
        if (__cil_tmp26) {
#line 712
          ox = curr->w_layer.l_x - 1;
#line 713
          oy = curr->w_layer.l_y;
#line 714
          if (ox < 0) {
#line 716
            ox = curr->w_layer.l_width - 1;
#line 717
            __cil_tmp30 = oy;
#line 717
            oy --;
          }
#line 719
          if (oy < 0) {
#line 720
            oy = 0;
          }
          {
#line 721
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 721
            omc.image = *((curr->w_mlines + oy)->image + ox);
#line 721
            omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 721
            omc.font = *((curr->w_mlines + oy)->font + ox);
#line 721
            omc.color = *((curr->w_mlines + oy)->color + ox);
#line 721
            omc.mbcs = (unsigned char )0;
#line 721
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 722
          if ((int )omc.image == 255) {
#line 722
            if ((int )omc.font == 255) {
#line 724
              __cil_tmp31 = ox;
#line 724
              ox --;
#line 725
              if (ox >= 0) {
                {
#line 727
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 727
                  omc.image = *((curr->w_mlines + oy)->image + ox);
#line 727
                  omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 727
                  omc.font = *((curr->w_mlines + oy)->font + ox);
#line 727
                  omc.color = *((curr->w_mlines + oy)->color + ox);
#line 727
                  omc.mbcs = (unsigned char )0;
#line 727
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 728
                omc.mbcs = (unsigned char )255;
              }
            }
          }
#line 731
          if (ox >= 0) {
            {
#line 733
            utf8_handle_comb(c, & omc);
#line 734
            MFixLine(curr, oy, & omc);
            }
            {
#line 735
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 735
              *((curr->w_mlines + oy)->image + ox) = omc.image;
#line 735
              *((curr->w_mlines + oy)->attr + ox) = omc.attr;
#line 735
              *((curr->w_mlines + oy)->font + ox) = omc.font;
#line 735
              *((curr->w_mlines + oy)->color + ox) = omc.color;
#line 735
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
            {
#line 736
            LPutChar(& curr->w_layer, & omc, ox, oy);
#line 737
            LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
            }
          }
#line 739
          goto switch_break;
        }
      }
    }
#line 741
    font = (int )curr->w_rend.font;
#line 745
    if (font == 73) {
#line 745
      if (curr->w_layer.l_encoding == 2) {
#line 745
        if (curr->w_mbcs == 0) {
          {
#line 748
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 748
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 749
          if (129 <= c) {
#line 749
            if (c <= 159) {
              _L___424: /* CIL Label */ 
              {
#line 751
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 751
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 752
              curr->w_mbcs = c;
#line 753
              goto switch_break;
            } else {
#line 749
              goto _L___425;
            }
          } else
          _L___425: /* CIL Label */ 
#line 749
          if (224 <= c) {
#line 749
            if (c <= 239) {
#line 749
              goto _L___424;
            }
          }
        }
      }
    }
#line 757
    if (font == 25) {
#line 757
      if (c == 128) {
#line 758
        curr->w_rend.font = (unsigned char )0;
#line 758
        font = (int )curr->w_rend.font;
      }
    }
#line 759
    if (font) {
#line 759
      if ((font & 96) == 0) {
#line 759
        if (c == 32) {
#line 760
          curr->w_rend.font = (unsigned char )0;
#line 760
          font = (int )curr->w_rend.font;
        }
      }
    }
#line 761
    if (font) {
#line 761
      if ((font & 96) == 0) {
        _L___426: /* CIL Label */ 
#line 763
        t = c;
#line 764
        if (curr->w_mbcs == 0) {
#line 766
          curr->w_mbcs = c;
#line 767
          goto switch_break;
        }
#line 769
        if (curr->w_layer.l_x == cols - 1) {
#line 771
          if (curr->w_wrap) {
#line 771
            tmp___0 = 1;
          } else {
#line 771
            tmp___0 = - 1;
          }
#line 771
          curr->w_layer.l_x += tmp___0;
          {
#line 772
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 772
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 775
        if (curr->w_layer.l_encoding != 8) {
#line 778
          c = curr->w_mbcs;
#line 780
          if (font == 73) {
#line 780
            if (curr->w_layer.l_encoding == 2) {
              {
#line 782
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 782
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
#line 793
              if (64 <= t) {
#line 793
                if (t <= 252) {
#line 793
                  if (t != 127) {
#line 795
                    if (c <= 159) {
#line 795
                      c = (c - 129) * 2 + 33;
                    } else {
#line 796
                      c = (c - 193) * 2 + 33;
                    }
#line 797
                    if (t <= 126) {
#line 797
                      t -= 31;
                    } else
#line 798
                    if (t <= 158) {
#line 798
                      t -= 32;
                    } else {
#line 799
                      __cil_tmp34 = c;
#line 799
                      c ++;
#line 799
                      t -= 126;
                    }
#line 800
                    curr->w_rend.font = (unsigned char )2;
                  } else {
#line 805
                    c = t;
#line 806
                    t = 0;
                  }
                } else {
#line 805
                  c = t;
#line 806
                  t = 0;
                }
              } else {
#line 805
                c = t;
#line 806
                t = 0;
              }
              {
#line 808
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 808
                goto while_break___16;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
#line 811
          if (t) {
#line 811
            if (curr->w_gr) {
#line 811
              if (font != 24) {
#line 811
                if (font != 25) {
#line 813
                  t &= 127;
#line 814
                  if (t < 32) {
#line 815
                    goto tryagain;
                  }
                }
              }
            }
          }
#line 817
          if (t == 127) {
#line 818
            goto switch_break;
          }
#line 819
          curr->w_mbcs = t;
        }
      } else {
#line 761
        goto _L___427;
      }
    } else
    _L___427: /* CIL Label */ 
#line 761
    if (curr->w_mbcs) {
#line 761
      goto _L___426;
    }
#line 823
    if (font == 60) {
#line 823
      if (c >= 32) {
#line 825
        curr->w_rend.font = (unsigned char )0;
#line 825
        font = (int )curr->w_rend.font;
#line 826
        c |= 128;
      } else {
#line 823
        goto _L___428;
      }
    } else
    _L___428: /* CIL Label */ 
#line 829
    if (curr->w_gr) {
#line 829
      if (curr->w_layer.l_encoding != 8) {
#line 835
        if (c == 128) {
#line 835
          if (font == 0) {
#line 835
            if (curr->w_layer.l_encoding == 20) {
#line 836
              c = 164;
            } else {
#line 839
              c &= 127;
            }
          } else {
#line 839
            c &= 127;
          }
        } else {
#line 839
          c &= 127;
        }
#line 840
        if (c < 32) {
#line 841
          goto tryagain;
        }
      }
    }
#line 844
    if (c == 127) {
#line 845
      goto switch_break;
    }
#line 846
    curr->w_rend.image = (unsigned char )c;
#line 848
    if (curr->w_layer.l_encoding == 8) {
#line 849
      curr->w_rend.font = (unsigned char )(c >> 8);
    }
#line 852
    curr->w_rend.mbcs = (unsigned char )curr->w_mbcs;
#line 854
    if (curr->w_layer.l_x < cols - 1) {
#line 856
      if (curr->w_insert) {
        {
#line 858
        while (1) {
          while_continue___17: /* CIL Label */ ;
          {
#line 858
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->image),
                (void *)((char *)mline_old.image), (size_t )cols);
#line 858
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->attr),
                (void *)((char *)mline_old.attr), (size_t )cols);
#line 858
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->font),
                (void *)((char *)mline_old.font), (size_t )cols);
#line 858
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->color),
                (void *)((char *)mline_old.color), (size_t )cols);
          }
#line 858
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
        {
#line 859
        MInsChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 860
        LInsChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y,
                 & mline_old);
#line 861
        (curr->w_layer.l_x) ++;
        }
      } else {
        {
#line 865
        MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 866
        LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 867
        (curr->w_layer.l_x) ++;
        }
      }
    } else
#line 870
    if (curr->w_layer.l_x == cols - 1) {
      {
#line 872
      MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 873
      LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
      }
#line 874
      if (curr->w_wrap) {
#line 875
        (curr->w_layer.l_x) ++;
      }
    } else {
      {
#line 879
      MWrapChar(curr, & curr->w_rend, curr->w_layer.l_y, curr->w_top, curr->w_bot,
                curr->w_insert);
#line 880
      LWrapChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_y, curr->w_top, curr->w_bot,
                curr->w_insert);
      }
#line 881
      if (curr->w_layer.l_y != curr->w_bot) {
#line 881
        if (curr->w_layer.l_y != curr->w_layer.l_height - 1) {
#line 882
          (curr->w_layer.l_y) ++;
        }
      }
#line 883
      curr->w_layer.l_x = 1;
    }
#line 887
    if (curr->w_mbcs) {
#line 889
      curr->w_mbcs = 0;
#line 889
      curr->w_rend.mbcs = (unsigned char )curr->w_mbcs;
#line 890
      (curr->w_layer.l_x) ++;
    }
#line 893
    if (curr->w_ss) {
      {
#line 895
      curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 896
      curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 897
      curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 898
      LSetRendition(& curr->w_layer, & curr->w_rend);
#line 899
      curr->w_ss = 0;
      }
    }
#line 902
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 340
    if (! len) {
#line 340
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 906
  if (! printcmd) {
#line 906
    if ((unsigned int )curr->w_state == 5U) {
      {
#line 907
      PrintFlush();
      }
    }
  }
}
}
#line 911 "/tmp/screen-3.9.15/ansi.c"
static void WLogString(struct win *p , char *buf , int len ) 
{ 
  char *t ;
  char *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;

  {
#line 916
  if (! p->w_log) {
#line 917
    return;
  }
#line 918
  if (logtstamp_on) {
#line 918
    if (p->w_logsilence >= logtstamp_after * 2) {
      {
#line 920
      __cil_tmp5 = MakeWinMsg(logtstamp_string, p, '%');
#line 920
      t = __cil_tmp5;
#line 921
      __cil_tmp6 = strlen((char const   *)t);
#line 921
      logfwrite(p->w_log, t, (int )__cil_tmp6);
      }
    }
  }
  {
#line 923
  p->w_logsilence = 0;
#line 924
  __cil_tmp7 = logfwrite(p->w_log, buf, len);
  }
#line 924
  if (__cil_tmp7 < 1) {
    {
#line 926
    __cil_tmp8 = __errno_location();
#line 926
    WMsg(p, *__cil_tmp8, (char *)"Error writing logfile");
#line 927
    logfclose(p->w_log);
#line 928
    p->w_log = (struct logfile *)0;
    }
  }
#line 930
  if (! log_flush) {
    {
#line 931
    logfflush(p->w_log);
    }
  }
}
}
#line 935 "/tmp/screen-3.9.15/ansi.c"
static int Special(int c ) 
{ 


  {
  {
#line 940
  if (c == '\b') {
#line 940
    goto case_8;
  }
#line 943
  if (c == '\r') {
#line 943
    goto case_13;
  }
#line 946
  if (c == '\n') {
#line 946
    goto case_10;
  }
#line 951
  if (c == '\a') {
#line 951
    goto case_7;
  }
#line 954
  if (c == '\t') {
#line 954
    goto case_9;
  }
#line 958
  if (c == '\017') {
#line 958
    goto case_15;
  }
#line 961
  if (c == '\016') {
#line 961
    goto case_14;
  }
#line 938
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 941
  BackSpace();
  }
#line 942
  return (1);
  case_13: /* CIL Label */ 
  {
#line 944
  Return();
  }
#line 945
  return (1);
  case_10: /* CIL Label */ 
#line 947
  if (curr->w_autoaka) {
    {
#line 948
    FindAKA();
    }
  }
  {
#line 949
  LineFeed(0);
  }
#line 950
  return (1);
  case_7: /* CIL Label */ 
  {
#line 952
  WBell(curr, visual_bell);
  }
#line 953
  return (1);
  case_9: /* CIL Label */ 
  {
#line 955
  ForwardTab();
  }
#line 956
  return (1);
  case_15: /* CIL Label */ 
  {
#line 959
  MapCharset(0);
  }
#line 960
  return (1);
  case_14: /* CIL Label */ 
  {
#line 962
  MapCharset(1);
  }
#line 963
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 966
  return (0);
}
}
#line 970 "/tmp/screen-3.9.15/ansi.c"
static void DoESC(int c , int intermediate ) 
{ 


  {
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 976
  if (intermediate == 0) {
#line 976
    goto case_0;
  }
#line 979
  if (intermediate == 'E') {
#line 979
    goto case_69;
  }
#line 982
  if (intermediate == 'D') {
#line 982
    goto case_68;
  }
#line 985
  if (intermediate == 'M') {
#line 985
    goto case_77;
  }
#line 988
  if (intermediate == 'H') {
#line 988
    goto case_72;
  }
#line 991
  if (intermediate == 'Z') {
#line 991
    goto case_90;
  }
#line 994
  if (intermediate == '7') {
#line 994
    goto case_55;
  }
#line 997
  if (intermediate == '8') {
#line 997
    goto case_56;
  }
#line 1000
  if (intermediate == 'c') {
#line 1000
    goto case_99;
  }
#line 1015
  if (intermediate == '=') {
#line 1015
    goto case_61;
  }
#line 1021
  if (intermediate == '>') {
#line 1021
    goto case_62;
  }
#line 1028
  if (intermediate == 'n') {
#line 1028
    goto case_110;
  }
#line 1031
  if (intermediate == 'o') {
#line 1031
    goto case_111;
  }
#line 1034
  if (intermediate == '~') {
#line 1034
    goto case_126;
  }
#line 1038
  if (intermediate == '}') {
#line 1038
    goto case_125;
  }
#line 1041
  if (intermediate == '|') {
#line 1041
    goto case_124;
  }
#line 1044
  if (intermediate == 'N') {
#line 1044
    goto case_78;
  }
#line 1051
  if (intermediate == 'O') {
#line 1051
    goto case_79;
  }
#line 1059
  if (intermediate == 'g') {
#line 1059
    goto case_103;
  }
#line 1064
  if (intermediate == '#') {
#line 1064
    goto case_35;
  }
#line 1067
  if (intermediate == '8') {
#line 1067
    goto case_56___0;
  }
#line 1073
  if (intermediate == '(') {
#line 1073
    goto case_40;
  }
#line 1076
  if (intermediate == ')') {
#line 1076
    goto case_41;
  }
#line 1079
  if (intermediate == '*') {
#line 1079
    goto case_42;
  }
#line 1082
  if (intermediate == '+') {
#line 1082
    goto case_43;
  }
#line 1094
  if (intermediate == ((36 << 8) | 40)) {
#line 1094
    goto case_exp;
  }
#line 1094
  if (intermediate == '$') {
#line 1094
    goto case_exp;
  }
#line 1097
  if (intermediate == ((36 << 8) | 41)) {
#line 1097
    goto case_exp___0;
  }
#line 1100
  if (intermediate == ((36 << 8) | 42)) {
#line 1100
    goto case_exp___1;
  }
#line 1103
  if (intermediate == ((36 << 8) | 43)) {
#line 1103
    goto case_exp___2;
  }
#line 974
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 979
  if (c == 'E') {
#line 979
    goto case_69;
  }
#line 982
  if (c == 'D') {
#line 982
    goto case_68;
  }
#line 985
  if (c == 'M') {
#line 985
    goto case_77;
  }
#line 988
  if (c == 'H') {
#line 988
    goto case_72;
  }
#line 991
  if (c == 'Z') {
#line 991
    goto case_90;
  }
#line 994
  if (c == '7') {
#line 994
    goto case_55;
  }
#line 997
  if (c == '8') {
#line 997
    goto case_56;
  }
#line 1000
  if (c == 'c') {
#line 1000
    goto case_99;
  }
#line 1015
  if (c == '=') {
#line 1015
    goto case_61;
  }
#line 1021
  if (c == '>') {
#line 1021
    goto case_62;
  }
#line 1028
  if (c == 'n') {
#line 1028
    goto case_110;
  }
#line 1031
  if (c == 'o') {
#line 1031
    goto case_111;
  }
#line 1034
  if (c == '~') {
#line 1034
    goto case_126;
  }
#line 1038
  if (c == '}') {
#line 1038
    goto case_125;
  }
#line 1041
  if (c == '|') {
#line 1041
    goto case_124;
  }
#line 1044
  if (c == 'N') {
#line 1044
    goto case_78;
  }
#line 1051
  if (c == 'O') {
#line 1051
    goto case_79;
  }
#line 1059
  if (c == 'g') {
#line 1059
    goto case_103;
  }
#line 977
  goto switch_break___0;
  case_69: /* CIL Label */ 
  {
#line 980
  LineFeed(1);
  }
#line 981
  goto switch_break___0;
  case_68: /* CIL Label */ 
  {
#line 983
  LineFeed(0);
  }
#line 984
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 986
  ReverseLineFeed();
  }
#line 987
  goto switch_break___0;
  case_72: /* CIL Label */ 
#line 989
  *(curr->w_tabs + curr->w_layer.l_x) = (char )1;
#line 990
  goto switch_break___0;
  case_90: /* CIL Label */ 
  {
#line 992
  Report((char *)"\033[?%d;%dc", 1, 2);
  }
#line 993
  goto switch_break___0;
  case_55: /* CIL Label */ 
  {
#line 995
  SaveCursor();
  }
#line 996
  goto switch_break___0;
  case_56: /* CIL Label */ 
  {
#line 998
  RestoreCursor();
  }
#line 999
  goto switch_break___0;
  case_99: /* CIL Label */ 
  {
#line 1001
  ClearScreen();
  }
  {
#line 1002
  ResetWindow(curr);
#line 1003
  LKeypadMode(& curr->w_layer, 0);
#line 1004
  LCursorkeysMode(& curr->w_layer, 0);
#line 1013
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1014
  goto switch_break___0;
  case_61: /* CIL Label */ 
  {
#line 1016
  curr->w_keypad = 1;
#line 1016
  LKeypadMode(& curr->w_layer, curr->w_keypad);
  }
#line 1020
  goto switch_break___0;
  case_62: /* CIL Label */ 
  {
#line 1022
  curr->w_keypad = 0;
#line 1022
  LKeypadMode(& curr->w_layer, curr->w_keypad);
  }
#line 1026
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 1029
  MapCharset(2);
  }
#line 1030
  goto switch_break___0;
  case_111: /* CIL Label */ 
  {
#line 1032
  MapCharset(3);
  }
#line 1033
  goto switch_break___0;
  case_126: /* CIL Label */ 
  {
#line 1035
  MapCharsetR(1);
  }
#line 1036
  goto switch_break___0;
  case_125: /* CIL Label */ 
  {
#line 1039
  MapCharsetR(2);
  }
#line 1040
  goto switch_break___0;
  case_124: /* CIL Label */ 
  {
#line 1042
  MapCharsetR(3);
  }
#line 1043
  goto switch_break___0;
  case_78: /* CIL Label */ 
#line 1045
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[2]) {
#line 1047
    curr->w_ss = 2;
#line 1047
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1047
    curr->w_FontR = curr->w_FontL;
  } else
#line 1045
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[2]) {
#line 1047
    curr->w_ss = 2;
#line 1047
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1047
    curr->w_FontR = curr->w_FontL;
  } else {
#line 1049
    curr->w_ss = 0;
  }
#line 1050
  goto switch_break___0;
  case_79: /* CIL Label */ 
#line 1052
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[3]) {
#line 1054
    curr->w_ss = 3;
#line 1054
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1054
    curr->w_FontR = curr->w_FontL;
  } else
#line 1052
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[3]) {
#line 1054
    curr->w_ss = 3;
#line 1054
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1054
    curr->w_FontR = curr->w_FontL;
  } else {
#line 1056
    curr->w_ss = 0;
  }
#line 1057
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 1060
  WBell(curr, 1);
  }
#line 1061
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1063
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 1067
  if (c == '8') {
#line 1067
    goto case_56___0;
  }
#line 1065
  goto switch_break___1;
  case_56___0: /* CIL Label */ 
  {
#line 1068
  FillWithEs();
  }
#line 1069
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1071
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1074
  DesignateCharset(c, 0);
  }
#line 1075
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1077
  DesignateCharset(c, 1);
  }
#line 1078
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1080
  DesignateCharset(c, 2);
  }
#line 1081
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1083
  DesignateCharset(c, 3);
  }
#line 1084
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
#line 1095
  DesignateCharset(c & 31, 0);
  }
#line 1096
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 1098
  DesignateCharset(c & 31, 1);
  }
#line 1099
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  {
#line 1101
  DesignateCharset(c & 31, 2);
  }
#line 1102
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
#line 1104
  DesignateCharset(c & 31, 3);
  }
#line 1105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1112 "/tmp/screen-3.9.15/ansi.c"
static void DoCSI(int c , int intermediate ) 
{ 
  register int i ;
  register int a1 ;
  register int a2 ;
  int tmp ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___437 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___438 ;
  int tmp___439 ;
  int tmp___440 ;
  int tmp___441 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___448 ;

  {
#line 1115
  a1 = curr->w_args[0];
#line 1115
  a2 = curr->w_args[1];
#line 1117
  if (curr->w_NumArgs > 64) {
#line 1118
    curr->w_NumArgs = 64;
  }
  {
#line 1121
  if (intermediate == 0) {
#line 1121
    goto case_0;
  }
#line 1125
  if (intermediate == 'f') {
#line 1125
    goto case_102;
  }
#line 1125
  if (intermediate == 'H') {
#line 1125
    goto case_102;
  }
#line 1142
  if (intermediate == 'J') {
#line 1142
    goto case_74;
  }
#line 1147
  if (intermediate == 0) {
#line 1147
    goto case_0___0;
  }
#line 1150
  if (intermediate == 1) {
#line 1150
    goto case_1;
  }
#line 1153
  if (intermediate == 2) {
#line 1153
    goto case_2;
  }
#line 1159
  if (intermediate == 'K') {
#line 1159
    goto case_75;
  }
#line 1164
  if (intermediate == 0) {
#line 1164
    goto case_0___1;
  }
#line 1167
  if (intermediate == 1) {
#line 1167
    goto case_1___0;
  }
#line 1170
  if (intermediate == 2) {
#line 1170
    goto case_2___0;
  }
#line 1175
  if (intermediate == 'X') {
#line 1175
    goto case_88;
  }
#line 1179
  if (intermediate == 'A') {
#line 1179
    goto case_65;
  }
#line 1182
  if (intermediate == 'B') {
#line 1182
    goto case_66;
  }
#line 1185
  if (intermediate == 'C') {
#line 1185
    goto case_67;
  }
#line 1188
  if (intermediate == 'D') {
#line 1188
    goto case_68;
  }
#line 1191
  if (intermediate == 'E') {
#line 1191
    goto case_69;
  }
#line 1195
  if (intermediate == 'F') {
#line 1195
    goto case_70;
  }
#line 1200
  if (intermediate == '`') {
#line 1200
    goto case_96;
  }
#line 1200
  if (intermediate == 'G') {
#line 1200
    goto case_96;
  }
#line 1206
  if (intermediate == 'd') {
#line 1206
    goto case_100;
  }
#line 1212
  if (intermediate == 'm') {
#line 1212
    goto case_109;
  }
#line 1215
  if (intermediate == 'g') {
#line 1215
    goto case_103;
  }
#line 1221
  if (intermediate == 'r') {
#line 1221
    goto case_114;
  }
#line 1240
  if (intermediate == 's') {
#line 1240
    goto case_115;
  }
#line 1243
  if (intermediate == 't') {
#line 1243
    goto case_116;
  }
#line 1255
  if (intermediate == 'u') {
#line 1255
    goto case_117;
  }
#line 1258
  if (intermediate == 'I') {
#line 1258
    goto case_73;
  }
#line 1264
  if (intermediate == 'Z') {
#line 1264
    goto case_90;
  }
#line 1270
  if (intermediate == 'L') {
#line 1270
    goto case_76;
  }
#line 1273
  if (intermediate == 'M') {
#line 1273
    goto case_77;
  }
#line 1276
  if (intermediate == 'P') {
#line 1276
    goto case_80;
  }
#line 1279
  if (intermediate == '@') {
#line 1279
    goto case_64;
  }
#line 1282
  if (intermediate == 'h') {
#line 1282
    goto case_104;
  }
#line 1285
  if (intermediate == 'l') {
#line 1285
    goto case_108;
  }
#line 1288
  if (intermediate == 'i') {
#line 1288
    goto case_105;
  }
#line 1292
  if (intermediate == 'n') {
#line 1292
    goto case_110;
  }
#line 1298
  if (intermediate == 'c') {
#line 1298
    goto case_99;
  }
#line 1302
  if (intermediate == 'x') {
#line 1302
    goto case_120;
  }
#line 1306
  if (intermediate == 'p') {
#line 1306
    goto case_112;
  }
#line 1313
  if (intermediate == 'S') {
#line 1313
    goto case_83;
  }
#line 1317
  if (intermediate == '^') {
#line 1317
    goto case_94;
  }
#line 1317
  if (intermediate == 'T') {
#line 1317
    goto case_94;
  }
#line 1322
  if (intermediate == '?') {
#line 1322
    goto case_63;
  }
#line 1332
  if (intermediate == 1) {
#line 1332
    goto case_1___1;
  }
#line 1338
  if (intermediate == 2) {
#line 1338
    goto case_2___1;
  }
#line 1355
  if (intermediate == 3) {
#line 1355
    goto case_3;
  }
#line 1362
  if (intermediate == 5) {
#line 1362
    goto case_5;
  }
#line 1367
  if (intermediate == 6) {
#line 1367
    goto case_6;
  }
#line 1377
  if (intermediate == 7) {
#line 1377
    goto case_7;
  }
#line 1382
  if (intermediate == 9) {
#line 1382
    goto case_9;
  }
#line 1393
  if (intermediate == 25) {
#line 1393
    goto case_25;
  }
#line 1406
  if (intermediate == 1049) {
#line 1406
    goto case_1049;
  }
#line 1406
  if (intermediate == 1047) {
#line 1406
    goto case_1049;
  }
#line 1406
  if (intermediate == 47) {
#line 1406
    goto case_1049;
  }
#line 1424
  if (intermediate == 1003) {
#line 1424
    goto case_1003;
  }
#line 1424
  if (intermediate == 1002) {
#line 1424
    goto case_1003;
  }
#line 1424
  if (intermediate == 1001) {
#line 1424
    goto case_1003;
  }
#line 1424
  if (intermediate == 1000) {
#line 1424
    goto case_1003;
  }
#line 1431
  if (intermediate == '>') {
#line 1431
    goto case_62;
  }
#line 1434
  if (intermediate == 'c') {
#line 1434
    goto case_99___0;
  }
#line 1119
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1125
  if (c == 'f') {
#line 1125
    goto case_102;
  }
#line 1125
  if (c == 'H') {
#line 1125
    goto case_102;
  }
#line 1142
  if (c == 'J') {
#line 1142
    goto case_74;
  }
#line 1147
  if (c == 0) {
#line 1147
    goto case_0___0;
  }
#line 1150
  if (c == 1) {
#line 1150
    goto case_1;
  }
#line 1153
  if (c == 2) {
#line 1153
    goto case_2;
  }
#line 1159
  if (c == 'K') {
#line 1159
    goto case_75;
  }
#line 1164
  if (c == 0) {
#line 1164
    goto case_0___1;
  }
#line 1167
  if (c == 1) {
#line 1167
    goto case_1___0;
  }
#line 1170
  if (c == 2) {
#line 1170
    goto case_2___0;
  }
#line 1175
  if (c == 'X') {
#line 1175
    goto case_88;
  }
#line 1179
  if (c == 'A') {
#line 1179
    goto case_65;
  }
#line 1182
  if (c == 'B') {
#line 1182
    goto case_66;
  }
#line 1185
  if (c == 'C') {
#line 1185
    goto case_67;
  }
#line 1188
  if (c == 'D') {
#line 1188
    goto case_68;
  }
#line 1191
  if (c == 'E') {
#line 1191
    goto case_69;
  }
#line 1195
  if (c == 'F') {
#line 1195
    goto case_70;
  }
#line 1200
  if (c == '`') {
#line 1200
    goto case_96;
  }
#line 1200
  if (c == 'G') {
#line 1200
    goto case_96;
  }
#line 1206
  if (c == 'd') {
#line 1206
    goto case_100;
  }
#line 1212
  if (c == 'm') {
#line 1212
    goto case_109;
  }
#line 1215
  if (c == 'g') {
#line 1215
    goto case_103;
  }
#line 1221
  if (c == 'r') {
#line 1221
    goto case_114;
  }
#line 1240
  if (c == 's') {
#line 1240
    goto case_115;
  }
#line 1243
  if (c == 't') {
#line 1243
    goto case_116;
  }
#line 1255
  if (c == 'u') {
#line 1255
    goto case_117;
  }
#line 1258
  if (c == 'I') {
#line 1258
    goto case_73;
  }
#line 1264
  if (c == 'Z') {
#line 1264
    goto case_90;
  }
#line 1270
  if (c == 'L') {
#line 1270
    goto case_76;
  }
#line 1273
  if (c == 'M') {
#line 1273
    goto case_77;
  }
#line 1276
  if (c == 'P') {
#line 1276
    goto case_80;
  }
#line 1279
  if (c == '@') {
#line 1279
    goto case_64;
  }
#line 1282
  if (c == 'h') {
#line 1282
    goto case_104;
  }
#line 1285
  if (c == 'l') {
#line 1285
    goto case_108;
  }
#line 1288
  if (c == 'i') {
#line 1288
    goto case_105;
  }
#line 1292
  if (c == 'n') {
#line 1292
    goto case_110;
  }
#line 1298
  if (c == 'c') {
#line 1298
    goto case_99;
  }
#line 1302
  if (c == 'x') {
#line 1302
    goto case_120;
  }
#line 1306
  if (c == 'p') {
#line 1306
    goto case_112;
  }
#line 1313
  if (c == 'S') {
#line 1313
    goto case_83;
  }
#line 1317
  if (c == '^') {
#line 1317
    goto case_94;
  }
#line 1317
  if (c == 'T') {
#line 1317
    goto case_94;
  }
#line 1122
  goto switch_break___0;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 1126
  if (a1 < 1) {
#line 1127
    a1 = 1;
  }
#line 1128
  if (curr->w_origin) {
#line 1129
    a1 += curr->w_top;
  }
#line 1130
  if (a1 > rows) {
#line 1131
    a1 = rows;
  }
#line 1132
  if (a2 < 1) {
#line 1133
    a2 = 1;
  }
#line 1134
  if (a2 > cols) {
#line 1135
    a2 = cols;
  }
#line 1136
  a2 --;
  {
#line 1136
  a1 --;
#line 1136
  LGotoPos(& curr->w_layer, a2, a1);
#line 1137
  curr->w_layer.l_x = a2;
#line 1138
  curr->w_layer.l_y = a1;
  }
#line 1139
  if (curr->w_autoaka) {
#line 1140
    curr->w_autoaka = a1 + 1;
  }
#line 1141
  goto switch_break___0;
  case_74: /* CIL Label */ 
#line 1143
  if (a1 < 0) {
#line 1144
    a1 = 0;
  } else
#line 1143
  if (a1 > 2) {
#line 1144
    a1 = 0;
  }
  {
#line 1147
  if (a1 == 0) {
#line 1147
    goto case_0___0;
  }
#line 1150
  if (a1 == 1) {
#line 1150
    goto case_1;
  }
#line 1153
  if (a1 == 2) {
#line 1153
    goto case_2;
  }
#line 1145
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
  {
#line 1148
  ClearToEOS();
  }
#line 1149
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 1151
  ClearFromBOS();
  }
#line 1152
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 1154
  ClearScreen();
  }
  {
#line 1155
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1156
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1158
  goto switch_break___0;
  case_75: /* CIL Label */ 
#line 1160
  if (a1 < 0) {
#line 1161
    a1 %= 3;
  } else
#line 1160
  if (a1 > 2) {
#line 1161
    a1 %= 3;
  }
  {
#line 1164
  if (a1 == 0) {
#line 1164
    goto case_0___1;
  }
#line 1167
  if (a1 == 1) {
#line 1167
    goto case_1___0;
  }
#line 1170
  if (a1 == 2) {
#line 1170
    goto case_2___0;
  }
#line 1162
  goto switch_break___2;
  case_0___1: /* CIL Label */ 
  {
#line 1165
  ClearLineRegion(curr->w_layer.l_x, cols - 1);
  }
#line 1166
  goto switch_break___2;
  case_1___0: /* CIL Label */ 
  {
#line 1168
  ClearLineRegion(0, curr->w_layer.l_x);
  }
#line 1169
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
  {
#line 1171
  ClearLineRegion(0, cols - 1);
  }
#line 1172
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1174
  goto switch_break___0;
  case_88: /* CIL Label */ 
#line 1176
  if (a1) {
#line 1176
    tmp = a1 - 1;
  } else {
#line 1176
    tmp = 0;
  }
#line 1176
  a1 = curr->w_layer.l_x + tmp;
#line 1177
  if (a1 < cols) {
#line 1177
    tmp___429 = a1;
  } else {
#line 1177
    tmp___429 = cols - 1;
  }
  {
#line 1177
  ClearLineRegion(curr->w_layer.l_x, tmp___429);
  }
#line 1178
  goto switch_break___0;
  case_65: /* CIL Label */ 
#line 1180
  if (a1) {
#line 1180
    tmp___430 = a1;
  } else {
#line 1180
    tmp___430 = 1;
  }
  {
#line 1180
  CursorUp(tmp___430);
  }
#line 1181
  goto switch_break___0;
  case_66: /* CIL Label */ 
#line 1183
  if (a1) {
#line 1183
    tmp___431 = a1;
  } else {
#line 1183
    tmp___431 = 1;
  }
  {
#line 1183
  CursorDown(tmp___431);
  }
#line 1184
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 1186
  if (a1) {
#line 1186
    tmp___432 = a1;
  } else {
#line 1186
    tmp___432 = 1;
  }
  {
#line 1186
  CursorRight(tmp___432);
  }
#line 1187
  goto switch_break___0;
  case_68: /* CIL Label */ 
#line 1189
  if (a1) {
#line 1189
    tmp___433 = a1;
  } else {
#line 1189
    tmp___433 = 1;
  }
  {
#line 1189
  CursorLeft(tmp___433);
  }
#line 1190
  goto switch_break___0;
  case_69: /* CIL Label */ 
#line 1192
  curr->w_layer.l_x = 0;
#line 1193
  if (a1) {
#line 1193
    tmp___434 = a1;
  } else {
#line 1193
    tmp___434 = 1;
  }
  {
#line 1193
  CursorDown(tmp___434);
  }
#line 1194
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 1196
  curr->w_layer.l_x = 0;
#line 1197
  if (a1) {
#line 1197
    tmp___435 = a1;
  } else {
#line 1197
    tmp___435 = 1;
  }
  {
#line 1197
  CursorUp(tmp___435);
  }
#line 1198
  goto switch_break___0;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 1201
  if (a1) {
#line 1201
    tmp___436 = a1 - 1;
  } else {
#line 1201
    tmp___436 = 0;
  }
#line 1201
  curr->w_layer.l_x = tmp___436;
#line 1202
  if (curr->w_layer.l_x >= cols) {
#line 1203
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 1204
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1205
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 1207
  if (a1) {
#line 1207
    tmp___437 = a1 - 1;
  } else {
#line 1207
    tmp___437 = 0;
  }
#line 1207
  curr->w_layer.l_y = tmp___437;
#line 1208
  if (curr->w_layer.l_y >= rows) {
#line 1209
    curr->w_layer.l_y = rows - 1;
  }
  {
#line 1210
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1211
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 1213
  SelectRendition();
  }
#line 1214
  goto switch_break___0;
  case_103: /* CIL Label */ 
#line 1216
  if (a1 == 0) {
#line 1217
    *(curr->w_tabs + curr->w_layer.l_x) = (char )0;
  } else
#line 1218
  if (a1 == 3) {
    {
#line 1219
    bzero((void *)curr->w_tabs, (unsigned long )cols);
    }
  }
#line 1220
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 1222
  if (! a1) {
#line 1223
    a1 = 1;
  }
#line 1224
  if (! a2) {
#line 1225
    a2 = rows;
  }
#line 1226
  if (a1 < 1) {
#line 1227
    goto switch_break___0;
  } else
#line 1226
  if (a2 > rows) {
#line 1227
    goto switch_break___0;
  } else
#line 1226
  if (a1 >= a2) {
#line 1227
    goto switch_break___0;
  }
#line 1228
  curr->w_top = a1 - 1;
#line 1229
  curr->w_bot = a2 - 1;
#line 1231
  if (curr->w_origin) {
#line 1233
    curr->w_layer.l_y = curr->w_top;
#line 1234
    curr->w_layer.l_x = 0;
  } else {
#line 1237
    curr->w_layer.l_x = 0;
#line 1237
    curr->w_layer.l_y = curr->w_layer.l_x;
  }
  {
#line 1238
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1239
  goto switch_break___0;
  case_115: /* CIL Label */ 
  {
#line 1241
  SaveCursor();
  }
#line 1242
  goto switch_break___0;
  case_116: /* CIL Label */ 
#line 1244
  if (a1 != 8) {
#line 1245
    goto switch_break___0;
  }
#line 1246
  a1 = curr->w_args[2];
#line 1247
  if (a1 < 1) {
#line 1248
    a1 = curr->w_layer.l_width;
  }
#line 1249
  if (a2 < 1) {
#line 1250
    a2 = curr->w_layer.l_height;
  }
  {
#line 1251
  WChangeSize(curr, a1, a2);
#line 1252
  cols = curr->w_layer.l_width;
#line 1253
  rows = curr->w_layer.l_height;
  }
#line 1254
  goto switch_break___0;
  case_117: /* CIL Label */ 
  {
#line 1256
  RestoreCursor();
  }
#line 1257
  goto switch_break___0;
  case_73: /* CIL Label */ 
#line 1259
  if (! a1) {
#line 1260
    a1 = 1;
  }
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    if (! __cil_tmp16) {
#line 1261
      goto while_break;
    }
    {
#line 1262
    ForwardTab();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 1265
  if (! a1) {
#line 1266
    a1 = 1;
  }
  {
#line 1267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1267
    if (! __cil_tmp17) {
#line 1267
      goto while_break___0;
    }
    {
#line 1268
    BackwardTab();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1269
  goto switch_break___0;
  case_76: /* CIL Label */ 
#line 1271
  if (a1) {
#line 1271
    tmp___438 = a1;
  } else {
#line 1271
    tmp___438 = 1;
  }
  {
#line 1271
  InsertLine(tmp___438);
  }
#line 1272
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 1274
  if (a1) {
#line 1274
    tmp___439 = a1;
  } else {
#line 1274
    tmp___439 = 1;
  }
  {
#line 1274
  DeleteLine(tmp___439);
  }
#line 1275
  goto switch_break___0;
  case_80: /* CIL Label */ 
#line 1277
  if (a1) {
#line 1277
    tmp___440 = a1;
  } else {
#line 1277
    tmp___440 = 1;
  }
  {
#line 1277
  DeleteChar(tmp___440);
  }
#line 1278
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 1280
  if (a1) {
#line 1280
    tmp___441 = a1;
  } else {
#line 1280
    tmp___441 = 1;
  }
  {
#line 1280
  InsertChar(tmp___441);
  }
#line 1281
  goto switch_break___0;
  case_104: /* CIL Label */ 
  {
#line 1283
  ASetMode(1);
  }
#line 1284
  goto switch_break___0;
  case_108: /* CIL Label */ 
  {
#line 1286
  ASetMode(0);
  }
#line 1287
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 1289
  if (a1 == 5) {
    {
#line 1290
    PrintStart();
    }
  }
#line 1291
  goto switch_break___0;
  case_110: /* CIL Label */ 
#line 1293
  if (a1 == 5) {
    {
#line 1294
    Report((char *)"\033[0n", 0, 0);
    }
  } else
#line 1295
  if (a1 == 6) {
    {
#line 1296
    Report((char *)"\033[%d;%dR", curr->w_layer.l_y + 1, curr->w_layer.l_x + 1);
    }
  }
#line 1297
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 1299
  if (a1 == 0) {
    {
#line 1300
    Report((char *)"\033[?%d;%dc", 1, 2);
    }
  }
#line 1301
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 1303
  if (a1 == 0) {
    {
    {
#line 1304
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
    }
  } else
#line 1303
  if (a1 == 1) {
    {
    {
#line 1304
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
    }
  }
#line 1305
  goto switch_break___0;
  case_112: /* CIL Label */ 
#line 1307
  if (a1 == 6) {
    _L: /* CIL Label */ 
#line 1309
    curr->w_curinv = 7 - a1;
#line 1310
    if (curr->w_curinv) {
#line 1310
      tmp___442 = - 1;
    } else {
#line 1310
      tmp___442 = curr->w_curvvis;
    }
    {
#line 1310
    LCursorVisibility(& curr->w_layer, tmp___442);
    }
  } else
#line 1307
  if (a1 == 7) {
#line 1307
    goto _L;
  }
#line 1312
  goto switch_break___0;
  case_83: /* CIL Label */ 
#line 1314
  if (a1) {
#line 1314
    tmp___443 = a1;
  } else {
#line 1314
    tmp___443 = 1;
  }
  {
#line 1314
  ScrollRegion(tmp___443);
  }
#line 1315
  goto switch_break___0;
  case_94: /* CIL Label */ 
  case_84: /* CIL Label */ 
#line 1318
  if (a1) {
#line 1318
    tmp___444 = - a1;
  } else {
#line 1318
    tmp___444 = - 1;
  }
  {
#line 1318
  ScrollRegion(tmp___444);
  }
#line 1319
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1321
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1323
  a2 = 0;
  {
#line 1323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1323
    if (! (a2 < curr->w_NumArgs)) {
#line 1323
      goto while_break___1;
    }
#line 1325
    a1 = curr->w_args[a2];
    {
#line 1326
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1326
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1327
    if (c != 104) {
#line 1327
      if (c != 108) {
#line 1328
        goto while_break___1;
      }
    }
#line 1329
    i = c == 104;
    {
#line 1332
    if (a1 == 1) {
#line 1332
      goto case_1___1;
    }
#line 1338
    if (a1 == 2) {
#line 1338
      goto case_2___1;
    }
#line 1355
    if (a1 == 3) {
#line 1355
      goto case_3;
    }
#line 1362
    if (a1 == 5) {
#line 1362
      goto case_5;
    }
#line 1367
    if (a1 == 6) {
#line 1367
      goto case_6;
    }
#line 1377
    if (a1 == 7) {
#line 1377
      goto case_7;
    }
#line 1382
    if (a1 == 9) {
#line 1382
      goto case_9;
    }
#line 1393
    if (a1 == 25) {
#line 1393
      goto case_25;
    }
#line 1406
    if (a1 == 1049) {
#line 1406
      goto case_1049;
    }
#line 1406
    if (a1 == 1047) {
#line 1406
      goto case_1049;
    }
#line 1406
    if (a1 == 47) {
#line 1406
      goto case_1049;
    }
#line 1424
    if (a1 == 1003) {
#line 1424
      goto case_1003;
    }
#line 1424
    if (a1 == 1002) {
#line 1424
      goto case_1003;
    }
#line 1424
    if (a1 == 1001) {
#line 1424
      goto case_1003;
    }
#line 1424
    if (a1 == 1000) {
#line 1424
      goto case_1003;
    }
#line 1330
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
    {
#line 1333
    curr->w_cursorkeys = i;
#line 1333
    LCursorkeysMode(& curr->w_layer, curr->w_cursorkeys);
    }
#line 1337
    goto switch_break___3;
    case_2___1: /* CIL Label */ 
#line 1339
    if (i) {
#line 1343
      if (curr->w_layer.l_encoding) {
#line 1344
        goto switch_break___3;
      }
#line 1346
      curr->w_FontR = (char )0;
#line 1346
      curr->w_FontL = curr->w_FontR;
#line 1346
      curr->w_charsets[2] = (int )curr->w_FontL;
#line 1346
      curr->w_charsets[2] = curr->w_charsets[2];
#line 1346
      curr->w_charsets[1] = curr->w_charsets[2];
#line 1346
      curr->w_charsets[0] = curr->w_charsets[1];
#line 1349
      curr->w_Charset = 0;
#line 1350
      curr->w_CharsetR = 2;
#line 1351
      curr->w_ss = 0;
    }
#line 1354
    goto switch_break___3;
    case_3: /* CIL Label */ 
#line 1356
    if (i) {
#line 1356
      tmp___445 = Z0width;
    } else {
#line 1356
      tmp___445 = Z1width;
    }
    {
#line 1356
    i = tmp___445;
#line 1357
    WChangeSize(curr, i, curr->w_layer.l_height);
#line 1358
    cols = curr->w_layer.l_width;
#line 1359
    rows = curr->w_layer.l_height;
    }
#line 1360
    goto switch_break___3;
    case_5: /* CIL Label */ 
#line 1363
    if (i != curr->w_revvid) {
      {
#line 1364
      WReverseVideo(curr, i);
      }
    }
#line 1365
    curr->w_revvid = i;
#line 1366
    goto switch_break___3;
    case_6: /* CIL Label */ 
#line 1368
    curr->w_origin = i;
#line 1368
    if (curr->w_origin != 0) {
#line 1370
      curr->w_layer.l_y = curr->w_top;
#line 1371
      curr->w_layer.l_x = 0;
    } else {
#line 1374
      curr->w_layer.l_x = 0;
#line 1374
      curr->w_layer.l_y = curr->w_layer.l_x;
    }
    {
#line 1375
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1376
    goto switch_break___3;
    case_7: /* CIL Label */ 
#line 1378
    curr->w_wrap = i;
#line 1379
    goto switch_break___3;
    case_9: /* CIL Label */ 
#line 1383
    if (i) {
#line 1383
      tmp___446 = 9;
    } else {
#line 1383
      tmp___446 = 0;
    }
    {
#line 1383
    curr->w_mouse = tmp___446;
#line 1384
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1385
    goto switch_break___3;
    case_25: /* CIL Label */ 
#line 1394
    curr->w_curinv = ! i;
#line 1395
    if (curr->w_curinv) {
#line 1395
      tmp___447 = - 1;
    } else {
#line 1395
      tmp___447 = curr->w_curvvis;
    }
    {
#line 1395
    LCursorVisibility(& curr->w_layer, tmp___447);
    }
#line 1396
    goto switch_break___3;
    case_1049: /* CIL Label */ 
    case_1047: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 1407
    if (use_altscreen) {
#line 1409
      if (i) {
        {
#line 1410
        EnterAltScreen(curr);
        }
      } else {
        {
#line 1412
        LeaveAltScreen(curr);
        }
      }
#line 1413
      if (a1 == 47) {
#line 1413
        if (! i) {
#line 1414
          curr->w_saved = 0;
        }
      }
      {
#line 1415
      LRefreshAll(& curr->w_layer, 0);
#line 1416
      LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
      }
    }
#line 1418
    goto switch_break___3;
    case_1003: /* CIL Label */ 
    case_1002: /* CIL Label */ 
    case_1001: /* CIL Label */ 
    case_1000: /* CIL Label */ 
#line 1425
    if (i) {
#line 1425
      tmp___448 = a1;
    } else {
#line 1425
      tmp___448 = 0;
    }
    {
#line 1425
    curr->w_mouse = tmp___448;
#line 1426
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1427
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1323
  a2 ++;
#line 1430
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 1434
  if (c == 'c') {
#line 1434
    goto case_99___0;
  }
#line 1432
  goto switch_break___4;
  case_99___0: /* CIL Label */ 
#line 1435
  if (a1 == 0) {
    {
#line 1436
    Report((char *)"\033[>%d;%d;0c", 83, nversion);
    }
  }
#line 1437
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1439
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1445 "/tmp/screen-3.9.15/ansi.c"
static void StringStart(enum string_t type ) 
{ 


  {
#line 1448
  curr->w_StringType = type;
#line 1449
  curr->w_stringp = (char *)curr->w_string;
#line 1450
  curr->w_state = (enum state_t )2;
}
}
#line 1454 "/tmp/screen-3.9.15/ansi.c"
static void StringChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1457
  if (curr->w_stringp >= ((char *)curr->w_string + 256) - 1) {
#line 1458
    curr->w_state = (enum state_t )0;
  } else {
#line 1460
    __cil_tmp2 = curr->w_stringp;
#line 1460
    (curr->w_stringp) ++;
#line 1460
    *__cil_tmp2 = (char )c;
  }
}
}
#line 1468 "/tmp/screen-3.9.15/ansi.c"
static int StringEnd(void) 
{ 
  struct canvas *cv ;
  char *p ;
  int typ ;
  char *args[64] ;
  struct acluser *windowuser ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  struct display *olddisplay ;
  struct canvas *cv___448 ;

  {
#line 1474
  curr->w_state = (enum state_t )0;
#line 1475
  *(curr->w_stringp) = (char )'\000';
  {
#line 1478
  if ((unsigned int )curr->w_StringType == (unsigned int )2) {
#line 1478
    goto case_2;
  }
#line 1540
  if ((unsigned int )curr->w_StringType == (unsigned int )3) {
#line 1540
    goto case_3;
  }
#line 1553
  if ((unsigned int )curr->w_StringType == (unsigned int )6) {
#line 1553
    goto case_6;
  }
#line 1553
  if ((unsigned int )curr->w_StringType == (unsigned int )4) {
#line 1553
    goto case_6;
  }
#line 1563
  if ((unsigned int )curr->w_StringType == (unsigned int )1) {
#line 1563
    goto case_1;
  }
#line 1566
  if ((unsigned int )curr->w_StringType == (unsigned int )5) {
#line 1566
    goto case_5;
  }
#line 1573
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1479
  p = index((char const   *)((char *)curr->w_string), ';');
  }
#line 1479
  if ((int )curr->w_string[0] == 59) {
#line 1480
    goto switch_break;
  } else
#line 1479
  if (p == (char *)0) {
#line 1480
    goto switch_break;
  }
  {
#line 1481
  typ = atoi((char const   *)((char *)curr->w_string));
#line 1482
  p ++;
  }
#line 1484
  if (typ == 83) {
    {
#line 1490
    windowuser = (struct acluser *)FindUserPtr((char *)":window:");
#line 1491
    __cil_tmp10 = Parse(p, (char **)args);
    }
#line 1491
    if (windowuser) {
#line 1491
      if (__cil_tmp10) {
#line 1493
        display = displays;
        {
#line 1493
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1493
          if (! display) {
#line 1493
            goto while_break;
          }
#line 1494
          if (((display->d_forecv)->c_layer)->l_bottom == & curr->w_layer) {
#line 1495
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1493
        display = display->d_next;
#line 1496
        if (display == (struct display *)0) {
#line 1496
          if (curr->w_layer.l_cvlist) {
#line 1497
            display = (curr->w_layer.l_cvlist)->c_display;
          }
        }
        {
#line 1498
        EffectiveAclUser = windowuser;
#line 1499
        DoCommand((char **)args);
#line 1500
        EffectiveAclUser = (struct acluser *)0;
        }
      }
    }
#line 1502
    goto switch_break;
  }
#line 1531
  if (typ < 0) {
#line 1532
    goto switch_break;
  } else
#line 1531
  if (typ > 2) {
#line 1532
    goto switch_break;
  }
#line 1535
  curr->w_stringp -= p - (char *)curr->w_string;
#line 1536
  if (curr->w_stringp > (char *)curr->w_string) {
    {
#line 1537
    bcopy((void const   *)p, (void *)((char *)curr->w_string), (size_t )(curr->w_stringp - (char *)curr->w_string));
    }
  }
#line 1538
  *(curr->w_stringp) = (char )'\000';
  case_3: /* CIL Label */ 
#line 1541
  if (curr->w_hstatus) {
    {
#line 1543
    __cil_tmp11 = strcmp((char const   *)curr->w_hstatus, (char const   *)((char *)curr->w_string));
    }
#line 1543
    if (__cil_tmp11 == 0) {
#line 1544
      goto switch_break;
    }
    {
#line 1545
    free((void *)curr->w_hstatus);
#line 1546
    curr->w_hstatus = (char *)0;
    }
  }
#line 1548
  if ((char *)curr->w_string != curr->w_stringp) {
    {
#line 1549
    curr->w_hstatus = SaveStr((char const   *)((char *)curr->w_string));
    }
  }
  {
#line 1550
  WindowChanged(curr, 'h');
  }
#line 1551
  goto switch_break;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1554
  display = displays;
  {
#line 1554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1554
    if (! display) {
#line 1554
      goto while_break___0;
    }
#line 1556
    cv = display->d_cvlist;
    {
#line 1556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1556
      if (! cv) {
#line 1556
        goto while_break___1;
      }
#line 1557
      if ((cv->c_layer)->l_bottom == & curr->w_layer) {
#line 1558
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1556
    cv = cv->c_next;
#line 1559
    if (cv) {
      {
      {
#line 1560
      MakeStatus((char *)curr->w_string);
      }
      }
    } else
#line 1559
    if ((unsigned int )curr->w_StringType == 6U) {
      {
      {
#line 1560
      MakeStatus((char *)curr->w_string);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1554
  display = display->d_next;
#line 1562
  return (- 1);
  case_1: /* CIL Label */ 
  {
#line 1564
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1564
    olddisplay = display;
#line 1564
    display = displays;
    {
#line 1564
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1564
      if (! display) {
#line 1564
        goto while_break___3;
      }
#line 1564
      cv___448 = display->d_cvlist;
      {
#line 1564
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1564
        if (! cv___448) {
#line 1564
          goto while_break___4;
        }
#line 1564
        if (cv___448->c_layer == & curr->w_layer) {
#line 1564
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1564
      cv___448 = cv___448->c_next;
#line 1564
      if (cv___448 == (struct canvas *)0) {
#line 1564
        goto while_continue___3;
      }
      {
#line 1564
      AddStr((char *)curr->w_string);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1564
    display = display->d_next;
#line 1564
    display = olddisplay;
#line 1564
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1565
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1567
  if (curr->w_title == (char *)curr->w_akabuf) {
#line 1567
    if (! *((char *)curr->w_string)) {
#line 1568
      goto switch_break;
    }
  }
  {
#line 1569
  ChangeAKA(curr, (char *)curr->w_string, 20);
  }
#line 1570
  if (! *((char *)curr->w_string)) {
#line 1571
    curr->w_autoaka = curr->w_layer.l_y + 1;
  }
#line 1572
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1574
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1576
  return (0);
}
}
#line 1580 "/tmp/screen-3.9.15/ansi.c"
static void PrintStart(void) 
{ 
  struct canvas *cv ;

  {
#line 1582
  curr->w_pdisplay = (struct display *)0;
#line 1585
  display = displays;
  {
#line 1585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1585
    if (! display) {
#line 1585
      goto while_break;
    }
#line 1586
    if (curr == display->d_fore) {
#line 1586
      if (printcmd) {
#line 1587
        goto while_break;
      } else
#line 1586
      if (display->d_tcs[73].str) {
#line 1587
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1585
  display = display->d_next;
#line 1588
  if (! display) {
#line 1591
    cv = curr->w_layer.l_cvlist;
    {
#line 1591
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1591
      if (! cv) {
#line 1591
        goto while_break___0;
      }
#line 1593
      display = cv->c_display;
#line 1594
      if (printcmd) {
#line 1595
        goto while_break___0;
      } else
#line 1594
      if (display->d_tcs[73].str) {
#line 1595
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1591
    cv = cv->c_lnext;
#line 1597
    if (! cv) {
#line 1599
      display = displays;
#line 1600
      if (! display) {
#line 1601
        return;
      } else
#line 1600
      if (display->d_next) {
#line 1601
        return;
      } else
#line 1600
      if (! (printcmd || display->d_tcs[73].str)) {
#line 1601
        return;
      }
    }
  }
#line 1604
  curr->w_pdisplay = display;
#line 1605
  curr->w_stringp = (char *)curr->w_string;
#line 1606
  curr->w_state = (enum state_t )5;
#line 1607
  if (printcmd) {
#line 1607
    if ((curr->w_pdisplay)->d_printfd < 0) {
      {
#line 1608
      (curr->w_pdisplay)->d_printfd = printpipe(curr, printcmd);
      }
    }
  }
}
}
#line 1612 "/tmp/screen-3.9.15/ansi.c"
static void PrintChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1615
  if (curr->w_stringp >= ((char *)curr->w_string + 256) - 1) {
    {
#line 1616
    PrintFlush();
    }
  }
#line 1617
  __cil_tmp2 = curr->w_stringp;
#line 1617
  (curr->w_stringp) ++;
#line 1617
  *__cil_tmp2 = (char )c;
}
}
#line 1621 "/tmp/screen-3.9.15/ansi.c"
static void PrintFlush(void) 
{ 
  char *bp ;
  int len ;
  int r ;
  ssize_t __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
#line 1623
  display = curr->w_pdisplay;
#line 1624
  if (display) {
#line 1624
    if (printcmd) {
#line 1626
      bp = (char *)curr->w_string;
#line 1627
      len = (int )(curr->w_stringp - (char *)curr->w_string);
      {
#line 1629
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1629
        if (! (len && display->d_printfd >= 0)) {
#line 1629
          goto while_break;
        }
        {
#line 1631
        __cil_tmp4 = write(display->d_printfd, (void const   *)bp, (size_t )len);
#line 1631
        r = (int )__cil_tmp4;
        }
#line 1632
        if (r <= 0) {
          {
#line 1634
          __cil_tmp5 = __errno_location();
#line 1634
          WMsg(curr, *__cil_tmp5, (char *)"printing aborted");
#line 1635
          close(display->d_printfd);
#line 1636
          display->d_printfd = - 1;
          }
#line 1637
          goto while_break;
        }
#line 1639
        bp += r;
#line 1640
        len -= r;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1624
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1643
  if (display) {
#line 1643
    if (curr->w_stringp > (char *)curr->w_string) {
      {
#line 1645
      AddCStr(display->d_tcs[73].str);
#line 1646
      AddStrn((char *)curr->w_string, (int )(curr->w_stringp - (char *)curr->w_string));
#line 1647
      AddCStr(display->d_tcs[74].str);
#line 1648
      Flush();
      }
    }
  }
#line 1650
  curr->w_stringp = (char *)curr->w_string;
}
}
#line 1655 "/tmp/screen-3.9.15/ansi.c"
void WNewAutoFlow(struct win *win , int on ) 
{ 


  {
  {
#line 1659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1659
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  if (win->w_flow & (1 << 2)) {
#line 1661
    win->w_flow = (1 << 2) | ((1 << 1) | 1) * on;
  } else {
#line 1663
    win->w_flow = (win->w_flow & ~ (1 << 1)) | (1 << 1) * on;
  }
  {
#line 1664
  LSetFlow(& win->w_layer, win->w_flow & 1);
  }
}
}
#line 1671 "/tmp/screen-3.9.15/ansi.c"
static void DesignateCharset(int c , int n ) 
{ 


  {
#line 1674
  curr->w_ss = 0;
#line 1676
  if (c == 0) {
#line 1677
    c = 2;
  }
#line 1679
  if (c == 66) {
#line 1680
    c = 0;
  }
#line 1681
  if (curr->w_charsets[n] != c) {
#line 1683
    curr->w_charsets[n] = c;
#line 1684
    if (curr->w_Charset == n) {
      {
#line 1686
      curr->w_FontL = (char )c;
#line 1687
      curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1688
      LSetRendition(& curr->w_layer, & curr->w_rend);
      }
    }
#line 1690
    if (curr->w_CharsetR == n) {
#line 1691
      curr->w_FontR = (char )c;
    }
  }
}
}
#line 1696 "/tmp/screen-3.9.15/ansi.c"
static void MapCharset(int n ) 
{ 


  {
#line 1699
  curr->w_ss = 0;
#line 1700
  if (curr->w_Charset != n) {
    {
#line 1702
    curr->w_Charset = n;
#line 1703
    curr->w_FontL = (char )curr->w_charsets[n];
#line 1704
    curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1705
    LSetRendition(& curr->w_layer, & curr->w_rend);
    }
  }
}
}
#line 1710 "/tmp/screen-3.9.15/ansi.c"
static void MapCharsetR(int n ) 
{ 


  {
#line 1713
  curr->w_ss = 0;
#line 1714
  if (curr->w_CharsetR != n) {
#line 1716
    curr->w_CharsetR = n;
#line 1717
    curr->w_FontR = (char )curr->w_charsets[n];
  }
#line 1719
  curr->w_gr = 1;
}
}
#line 1725 "/tmp/screen-3.9.15/ansi.c"
static void SaveCursor(void) 
{ 


  {
  {
#line 1727
  curr->w_saved = 1;
#line 1728
  curr->w_Saved_x = curr->w_layer.l_x;
#line 1729
  curr->w_Saved_y = curr->w_layer.l_y;
#line 1730
  curr->w_SavedRend = curr->w_rend;
#line 1732
  curr->w_SavedCharset = curr->w_Charset;
#line 1733
  curr->w_SavedCharsetR = curr->w_CharsetR;
#line 1734
  bcopy((void const   *)((char *)((int *)curr->w_charsets)), (void *)((char *)((int *)curr->w_SavedCharsets)),
        4UL * sizeof(int ));
  }
}
}
#line 1740 "/tmp/screen-3.9.15/ansi.c"
static void RestoreCursor(void) 
{ 


  {
#line 1742
  if (! curr->w_saved) {
#line 1743
    return;
  }
  {
#line 1744
  LGotoPos(& curr->w_layer, curr->w_Saved_x, curr->w_Saved_y);
#line 1745
  curr->w_layer.l_x = curr->w_Saved_x;
#line 1746
  curr->w_layer.l_y = curr->w_Saved_y;
#line 1747
  curr->w_rend = curr->w_SavedRend;
#line 1749
  bcopy((void const   *)((char *)((int *)curr->w_SavedCharsets)), (void *)((char *)((int *)curr->w_charsets)),
        4UL * sizeof(int ));
#line 1751
  curr->w_Charset = curr->w_SavedCharset;
#line 1752
  curr->w_CharsetR = curr->w_SavedCharsetR;
#line 1753
  curr->w_ss = 0;
#line 1754
  curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 1755
  curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 1757
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
}
}
#line 1761 "/tmp/screen-3.9.15/ansi.c"
static void BackSpace(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 1763
  if (curr->w_layer.l_x > 0) {
#line 1765
    __cil_tmp1 = curr->w_layer.l_x;
#line 1765
    (curr->w_layer.l_x) --;
  } else
#line 1767
  if (curr->w_wrap) {
#line 1767
    if (curr->w_layer.l_y > 0) {
#line 1769
      curr->w_layer.l_x = cols - 1;
#line 1770
      __cil_tmp2 = curr->w_layer.l_y;
#line 1770
      (curr->w_layer.l_y) --;
    }
  }
  {
#line 1772
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1776 "/tmp/screen-3.9.15/ansi.c"
static void Return(void) 
{ 


  {
#line 1778
  if (curr->w_layer.l_x == 0) {
#line 1779
    return;
  }
  {
#line 1780
  curr->w_layer.l_x = 0;
#line 1781
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1785 "/tmp/screen-3.9.15/ansi.c"
static void LineFeed(int out_mode ) 
{ 
  int __cil_tmp3 ;
  int tmp ;
  int tmp___449 ;
  int tmp___450 ;
  int tmp___451 ;

  {
#line 1789
  if (out_mode) {
#line 1790
    curr->w_layer.l_x = 0;
  }
#line 1791
  if (curr->w_layer.l_y != curr->w_bot) {
#line 1793
    if (curr->w_layer.l_y < rows - 1) {
#line 1794
      (curr->w_layer.l_y) ++;
    }
    {
#line 1795
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1796
    return;
  }
#line 1798
  if (curr->w_autoaka > 1) {
#line 1799
    __cil_tmp3 = curr->w_autoaka;
#line 1799
    (curr->w_autoaka) --;
  }
#line 1800
  if (curr->w_bce) {
#line 1800
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1800
      tmp = 256;
    } else {
#line 1800
      tmp = 0;
    }
#line 1800
    tmp___449 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1800
    tmp___449 = 0;
  }
  {
#line 1800
  MScrollV(curr, 1, curr->w_top, curr->w_bot, tmp___449);
  }
#line 1801
  if (curr->w_bce) {
#line 1801
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1801
      tmp___450 = 256;
    } else {
#line 1801
      tmp___450 = 0;
    }
#line 1801
    tmp___451 = (((int )curr->w_rend.color & 240) >> 4) | tmp___450;
  } else {
#line 1801
    tmp___451 = 0;
  }
  {
#line 1801
  LScrollV(& curr->w_layer, 1, curr->w_top, curr->w_bot, tmp___451);
#line 1802
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1806 "/tmp/screen-3.9.15/ansi.c"
static void ReverseLineFeed(void) 
{ 
  int tmp ;
  int tmp___452 ;
  int tmp___453 ;
  int tmp___454 ;

  {
#line 1808
  if (curr->w_layer.l_y == curr->w_top) {
#line 1810
    if (curr->w_bce) {
#line 1810
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1810
        tmp = 256;
      } else {
#line 1810
        tmp = 0;
      }
#line 1810
      tmp___452 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
    } else {
#line 1810
      tmp___452 = 0;
    }
    {
#line 1810
    MScrollV(curr, - 1, curr->w_top, curr->w_bot, tmp___452);
    }
#line 1811
    if (curr->w_bce) {
#line 1811
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1811
        tmp___453 = 256;
      } else {
#line 1811
        tmp___453 = 0;
      }
#line 1811
      tmp___454 = (((int )curr->w_rend.color & 240) >> 4) | tmp___453;
    } else {
#line 1811
      tmp___454 = 0;
    }
    {
#line 1811
    LScrollV(& curr->w_layer, - 1, curr->w_top, curr->w_bot, tmp___454);
#line 1812
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
  } else
#line 1814
  if (curr->w_layer.l_y > 0) {
    {
#line 1815
    CursorUp(1);
    }
  }
}
}
#line 1819 "/tmp/screen-3.9.15/ansi.c"
static void InsertChar(int n ) 
{ 
  register int y ;
  register int x ;
  int __cil_tmp4 ;
  int tmp ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;

  {
#line 1822
  y = curr->w_layer.l_y;
#line 1822
  x = curr->w_layer.l_x;
#line 1824
  if (n <= 0) {
#line 1825
    return;
  }
#line 1826
  if (x == cols) {
#line 1827
    __cil_tmp4 = x;
#line 1827
    x --;
  }
  {
#line 1828
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1828
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1828
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1828
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1828
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1828
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1829
  if (curr->w_bce) {
#line 1829
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1829
      tmp = 256;
    } else {
#line 1829
      tmp = 0;
    }
#line 1829
    tmp___455 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1829
    tmp___455 = 0;
  }
  {
#line 1829
  MScrollH(curr, - n, y, x, curr->w_layer.l_width - 1, tmp___455);
  }
#line 1830
  if (curr->w_bce) {
#line 1830
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1830
      tmp___456 = 256;
    } else {
#line 1830
      tmp___456 = 0;
    }
#line 1830
    tmp___457 = (((int )curr->w_rend.color & 240) >> 4) | tmp___456;
  } else {
#line 1830
    tmp___457 = 0;
  }
  {
#line 1830
  LScrollH(& curr->w_layer, - n, y, x, curr->w_layer.l_width - 1, tmp___457, & mline_old);
#line 1831
  LGotoPos(& curr->w_layer, x, y);
  }
}
}
#line 1835 "/tmp/screen-3.9.15/ansi.c"
static void DeleteChar(int n ) 
{ 
  register int y ;
  register int x ;
  int __cil_tmp4 ;
  int tmp ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___460 ;

  {
#line 1838
  y = curr->w_layer.l_y;
#line 1838
  x = curr->w_layer.l_x;
#line 1840
  if (x == cols) {
#line 1841
    __cil_tmp4 = x;
#line 1841
    x --;
  }
  {
#line 1842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1842
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1842
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1842
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1842
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1842
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1843
  if (curr->w_bce) {
#line 1843
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1843
      tmp = 256;
    } else {
#line 1843
      tmp = 0;
    }
#line 1843
    tmp___458 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1843
    tmp___458 = 0;
  }
  {
#line 1843
  MScrollH(curr, n, y, x, curr->w_layer.l_width - 1, tmp___458);
  }
#line 1844
  if (curr->w_bce) {
#line 1844
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1844
      tmp___459 = 256;
    } else {
#line 1844
      tmp___459 = 0;
    }
#line 1844
    tmp___460 = (((int )curr->w_rend.color & 240) >> 4) | tmp___459;
  } else {
#line 1844
    tmp___460 = 0;
  }
  {
#line 1844
  LScrollH(& curr->w_layer, n, y, x, curr->w_layer.l_width - 1, tmp___460, & mline_old);
#line 1845
  LGotoPos(& curr->w_layer, x, y);
  }
}
}
#line 1849 "/tmp/screen-3.9.15/ansi.c"
static void DeleteLine(int n ) 
{ 
  int tmp ;
  int tmp___461 ;
  int tmp___462 ;
  int tmp___463 ;

  {
#line 1852
  if (curr->w_layer.l_y < curr->w_top) {
#line 1853
    return;
  } else
#line 1852
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1853
    return;
  }
#line 1854
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1855
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1856
  if (curr->w_bce) {
#line 1856
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1856
      tmp = 256;
    } else {
#line 1856
      tmp = 0;
    }
#line 1856
    tmp___461 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1856
    tmp___461 = 0;
  }
  {
#line 1856
  MScrollV(curr, n, curr->w_layer.l_y, curr->w_bot, tmp___461);
  }
#line 1857
  if (curr->w_bce) {
#line 1857
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1857
      tmp___462 = 256;
    } else {
#line 1857
      tmp___462 = 0;
    }
#line 1857
    tmp___463 = (((int )curr->w_rend.color & 240) >> 4) | tmp___462;
  } else {
#line 1857
    tmp___463 = 0;
  }
  {
#line 1857
  LScrollV(& curr->w_layer, n, curr->w_layer.l_y, curr->w_bot, tmp___463);
#line 1858
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1862 "/tmp/screen-3.9.15/ansi.c"
static void InsertLine(int n ) 
{ 
  int tmp ;
  int tmp___464 ;
  int tmp___465 ;
  int tmp___466 ;

  {
#line 1865
  if (curr->w_layer.l_y < curr->w_top) {
#line 1866
    return;
  } else
#line 1865
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1866
    return;
  }
#line 1867
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1868
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1869
  if (curr->w_bce) {
#line 1869
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1869
      tmp = 256;
    } else {
#line 1869
      tmp = 0;
    }
#line 1869
    tmp___464 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1869
    tmp___464 = 0;
  }
  {
#line 1869
  MScrollV(curr, - n, curr->w_layer.l_y, curr->w_bot, tmp___464);
  }
#line 1870
  if (curr->w_bce) {
#line 1870
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1870
      tmp___465 = 256;
    } else {
#line 1870
      tmp___465 = 0;
    }
#line 1870
    tmp___466 = (((int )curr->w_rend.color & 240) >> 4) | tmp___465;
  } else {
#line 1870
    tmp___466 = 0;
  }
  {
#line 1870
  LScrollV(& curr->w_layer, - n, curr->w_layer.l_y, curr->w_bot, tmp___466);
#line 1871
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1875 "/tmp/screen-3.9.15/ansi.c"
static void ScrollRegion(int n ) 
{ 
  int tmp ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;

  {
#line 1878
  if (curr->w_bce) {
#line 1878
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1878
      tmp = 256;
    } else {
#line 1878
      tmp = 0;
    }
#line 1878
    tmp___467 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1878
    tmp___467 = 0;
  }
  {
#line 1878
  MScrollV(curr, n, curr->w_top, curr->w_bot, tmp___467);
  }
#line 1879
  if (curr->w_bce) {
#line 1879
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1879
      tmp___468 = 256;
    } else {
#line 1879
      tmp___468 = 0;
    }
#line 1879
    tmp___469 = (((int )curr->w_rend.color & 240) >> 4) | tmp___468;
  } else {
#line 1879
    tmp___469 = 0;
  }
  {
#line 1879
  LScrollV(& curr->w_layer, n, curr->w_top, curr->w_bot, tmp___469);
#line 1880
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1885 "/tmp/screen-3.9.15/ansi.c"
static void ForwardTab(void) 
{ 
  register int x ;

  {
#line 1887
  x = curr->w_layer.l_x;
#line 1889
  if (x == cols) {
    {
#line 1891
    LineFeed(1);
#line 1892
    x = 0;
    }
  }
#line 1894
  if ((int )*(curr->w_tabs + x)) {
#line 1894
    if (x < cols - 1) {
#line 1895
      x ++;
    }
  }
  {
#line 1896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1896
    if (! (x < cols - 1 && ! *(curr->w_tabs + x))) {
#line 1896
      goto while_break;
    }
#line 1897
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1898
  curr->w_layer.l_x = x;
#line 1899
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1903 "/tmp/screen-3.9.15/ansi.c"
static void BackwardTab(void) 
{ 
  register int x ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 1905
  x = curr->w_layer.l_x;
#line 1907
  if ((int )*(curr->w_tabs + x)) {
#line 1907
    if (x > 0) {
#line 1908
      __cil_tmp2 = x;
#line 1908
      x --;
    }
  }
  {
#line 1909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1909
    if (! (x > 0 && ! *(curr->w_tabs + x))) {
#line 1909
      goto while_break;
    }
#line 1910
    __cil_tmp3 = x;
#line 1910
    x --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1911
  curr->w_layer.l_x = x;
#line 1912
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1916 "/tmp/screen-3.9.15/ansi.c"
static void ClearScreen(void) 
{ 
  int tmp ;
  int tmp___470 ;
  int tmp___471 ;
  int tmp___472 ;

  {
#line 1918
  if (curr->w_bce) {
#line 1918
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1918
      tmp = 256;
    } else {
#line 1918
      tmp = 0;
    }
#line 1918
    tmp___470 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1918
    tmp___470 = 0;
  }
  {
#line 1918
  LClearArea(& curr->w_layer, 0, 0, curr->w_layer.l_width - 1, curr->w_layer.l_height - 1,
             tmp___470, 1);
  }
#line 1920
  if (curr->w_bce) {
#line 1920
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1920
      tmp___471 = 256;
    } else {
#line 1920
      tmp___471 = 0;
    }
#line 1920
    tmp___472 = (((int )curr->w_rend.color & 240) >> 4) | tmp___471;
  } else {
#line 1920
    tmp___472 = 0;
  }
  {
#line 1920
  MScrollV(curr, curr->w_layer.l_height, 0, curr->w_layer.l_height - 1, tmp___472);
  }
}
}
#line 1927 "/tmp/screen-3.9.15/ansi.c"
static void ClearFromBOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___473 ;
  int tmp___474 ;
  int tmp___475 ;

  {
#line 1929
  y = curr->w_layer.l_y;
#line 1929
  x = curr->w_layer.l_x;
#line 1931
  if (curr->w_bce) {
#line 1931
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1931
      tmp = 256;
    } else {
#line 1931
      tmp = 0;
    }
#line 1931
    tmp___473 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1931
    tmp___473 = 0;
  }
  {
#line 1931
  LClearArea(& curr->w_layer, 0, 0, x, y, tmp___473, 1);
  }
#line 1932
  if (curr->w_bce) {
#line 1932
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1932
      tmp___474 = 256;
    } else {
#line 1932
      tmp___474 = 0;
    }
#line 1932
    tmp___475 = (((int )curr->w_rend.color & 240) >> 4) | tmp___474;
  } else {
#line 1932
    tmp___475 = 0;
  }
  {
#line 1932
  MClearArea(curr, 0, 0, x, y, tmp___475);
#line 1933
  RestorePosRendition();
  }
}
}
#line 1937 "/tmp/screen-3.9.15/ansi.c"
static void ClearToEOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;

  {
#line 1939
  y = curr->w_layer.l_y;
#line 1939
  x = curr->w_layer.l_x;
#line 1941
  if (x == 0) {
#line 1941
    if (y == 0) {
      {
#line 1943
      ClearScreen();
#line 1944
      RestorePosRendition();
      }
#line 1945
      return;
    }
  }
#line 1947
  if (curr->w_bce) {
#line 1947
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1947
      tmp = 256;
    } else {
#line 1947
      tmp = 0;
    }
#line 1947
    tmp___476 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1947
    tmp___476 = 0;
  }
  {
#line 1947
  LClearArea(& curr->w_layer, x, y, cols - 1, rows - 1, tmp___476, 1);
  }
#line 1948
  if (curr->w_bce) {
#line 1948
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1948
      tmp___477 = 256;
    } else {
#line 1948
      tmp___477 = 0;
    }
#line 1948
    tmp___478 = (((int )curr->w_rend.color & 240) >> 4) | tmp___477;
  } else {
#line 1948
    tmp___478 = 0;
  }
  {
#line 1948
  MClearArea(curr, x, y, cols - 1, rows - 1, tmp___478);
#line 1949
  RestorePosRendition();
  }
}
}
#line 1953 "/tmp/screen-3.9.15/ansi.c"
static void ClearLineRegion(int from , int to ) 
{ 
  register int y ;
  int tmp ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;

  {
#line 1956
  y = curr->w_layer.l_y;
#line 1957
  if (curr->w_bce) {
#line 1957
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1957
      tmp = 256;
    } else {
#line 1957
      tmp = 0;
    }
#line 1957
    tmp___479 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1957
    tmp___479 = 0;
  }
  {
#line 1957
  LClearArea(& curr->w_layer, from, y, to, y, tmp___479, 1);
  }
#line 1958
  if (curr->w_bce) {
#line 1958
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1958
      tmp___480 = 256;
    } else {
#line 1958
      tmp___480 = 0;
    }
#line 1958
    tmp___481 = (((int )curr->w_rend.color & 240) >> 4) | tmp___480;
  } else {
#line 1958
    tmp___481 = 0;
  }
  {
#line 1958
  MClearArea(curr, from, y, to, y, tmp___481);
#line 1959
  RestorePosRendition();
  }
}
}
#line 1963 "/tmp/screen-3.9.15/ansi.c"
static void CursorRight(int n ) 
{ 
  register int x ;

  {
#line 1966
  x = curr->w_layer.l_x;
#line 1968
  if (x == cols) {
    {
#line 1970
    LineFeed(1);
#line 1971
    x = 0;
    }
  }
#line 1973
  curr->w_layer.l_x += n;
#line 1973
  if (curr->w_layer.l_x >= cols) {
#line 1974
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 1975
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1979 "/tmp/screen-3.9.15/ansi.c"
static void CursorUp(int n ) 
{ 


  {
#line 1982
  if (curr->w_layer.l_y < curr->w_top) {
#line 1984
    curr->w_layer.l_y -= n;
#line 1984
    if (curr->w_layer.l_y < 0) {
#line 1985
      curr->w_layer.l_y = 0;
    }
  } else {
#line 1988
    curr->w_layer.l_y -= n;
#line 1988
    if (curr->w_layer.l_y < curr->w_top) {
#line 1989
      curr->w_layer.l_y = curr->w_top;
    }
  }
  {
#line 1990
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 1994 "/tmp/screen-3.9.15/ansi.c"
static void CursorDown(int n ) 
{ 


  {
#line 1997
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1999
    curr->w_layer.l_y += n;
#line 1999
    if (curr->w_layer.l_y > rows - 1) {
#line 2000
      curr->w_layer.l_y = rows - 1;
    }
  } else {
#line 2003
    curr->w_layer.l_y += n;
#line 2003
    if (curr->w_layer.l_y > curr->w_bot) {
#line 2004
      curr->w_layer.l_y = curr->w_bot;
    }
  }
  {
#line 2005
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 2009 "/tmp/screen-3.9.15/ansi.c"
static void CursorLeft(int n ) 
{ 


  {
#line 2012
  curr->w_layer.l_x -= n;
#line 2012
  if (curr->w_layer.l_x < 0) {
#line 2013
    curr->w_layer.l_x = 0;
  }
  {
#line 2014
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
}
}
#line 2018 "/tmp/screen-3.9.15/ansi.c"
static void ASetMode(int on ) 
{ 
  register int i ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int tmp ;

  {
#line 2023
  i = 0;
  {
#line 2023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2023
    if (! (i < curr->w_NumArgs)) {
#line 2023
      goto while_break;
    }
    {
#line 2028
    if (curr->w_args[i] == 4) {
#line 2028
      goto case_4;
    }
#line 2033
    if (curr->w_args[i] == 20) {
#line 2033
      goto case_20;
    }
#line 2036
    if (curr->w_args[i] == 34) {
#line 2036
      goto case_34;
    }
#line 2040
    goto switch_default;
    case_4: /* CIL Label */ 
#line 2029
    curr->w_insert = on;
    {
#line 2030
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2030
      olddisplay = display;
#line 2030
      display = displays;
      {
#line 2030
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2030
        if (! display) {
#line 2030
          goto while_break___1;
        }
#line 2030
        cv = display->d_cvlist;
        {
#line 2030
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2030
          if (! cv) {
#line 2030
            goto while_break___2;
          }
#line 2030
          if (cv->c_layer == & curr->w_layer) {
#line 2030
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2030
        cv = cv->c_next;
#line 2030
        if (cv == (struct canvas *)0) {
#line 2030
          goto while_continue___1;
        }
        {
#line 2030
        InsertMode(on);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2030
      display = display->d_next;
#line 2030
      display = olddisplay;
#line 2030
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2031
    goto switch_break;
    case_20: /* CIL Label */ 
#line 2034
    curr->w_autolf = on;
#line 2035
    goto switch_break;
    case_34: /* CIL Label */ 
#line 2037
    curr->w_curvvis = ! on;
#line 2038
    if (curr->w_curinv) {
#line 2038
      tmp = - 1;
    } else {
#line 2038
      tmp = curr->w_curvvis;
    }
    {
#line 2038
    LCursorVisibility(& curr->w_layer, tmp);
    }
#line 2039
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2041
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2023
  i ++;
}
}
#line 2046 "/tmp/screen-3.9.15/ansi.c"
static char rendlist[]  = 
#line 2046
  {      (char )(~ ((1 << 6) - 1)),      (char )(1 << 2),      (char )1,      (char )(1 << 4), 
        (char )(1 << 1),      (char )(1 << 5),      (char )0,      (char )(1 << 3), 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )(~ (((1 << 2) | (1 << 4)) | 1)),      (char )(~ (1 << 4)), 
        (char )(~ (1 << 1)),      (char )(~ (1 << 5)),      (char )0,      (char )(~ (1 << 3))};
#line 2054 "/tmp/screen-3.9.15/ansi.c"
static void SelectRendition(void) 
{ 
  register int j ;
  register int i ;
  register int a ;
  register int c ;
  int jj ;
  int __cil_tmp6 ;
  int tmp ;

  {
#line 2057
  i = 0;
#line 2057
  a = (int )curr->w_rend.attr;
#line 2057
  c = (int )curr->w_rend.color;
  {
#line 2065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2067
    j = curr->w_args[i];
#line 2069
    if (j == 38) {
      _L: /* CIL Label */ 
#line 2069
      if (i + 2 < curr->w_NumArgs) {
#line 2069
        if (curr->w_args[i + 1] == 5) {
#line 2073
          i += 2;
#line 2074
          jj = curr->w_args[i];
#line 2075
          if (jj < 0) {
#line 2076
            goto while_continue;
          } else
#line 2075
          if (jj > 255) {
#line 2076
            goto while_continue;
          }
          {
#line 2101
          __cil_tmp6 = color256to16(jj);
#line 2101
          jj = __cil_tmp6 + 30;
          }
#line 2102
          if (jj >= 38) {
#line 2103
            jj += 52;
          }
#line 2104
          if (j == 38) {
#line 2104
            tmp = jj;
          } else {
#line 2104
            tmp = jj + 10;
          }
#line 2104
          j = tmp;
        }
      }
    } else
#line 2069
    if (j == 48) {
#line 2069
      goto _L;
    }
#line 2108
    if (j == 0) {
#line 2109
      a &= 191;
    } else
#line 2108
    if (j >= 30) {
#line 2108
      if (j <= 39) {
#line 2108
        if (j != 38) {
#line 2109
          a &= 191;
        }
      }
    }
#line 2110
    if (j == 0) {
#line 2111
      a &= 127;
    } else
#line 2110
    if (j >= 40) {
#line 2110
      if (j <= 49) {
#line 2110
        if (j != 48) {
#line 2111
          a &= 127;
        }
      }
    }
#line 2112
    if (j >= 90) {
#line 2112
      if (j <= 97) {
#line 2113
        a |= 64;
      }
    }
#line 2114
    if (j >= 100) {
#line 2114
      if (j <= 107) {
#line 2115
        a |= 128;
      }
    }
#line 2117
    if (j >= 90) {
#line 2117
      if (j <= 97) {
#line 2118
        j -= 60;
      }
    }
#line 2119
    if (j >= 100) {
#line 2119
      if (j <= 107) {
#line 2120
        j -= 60;
      }
    }
#line 2121
    if (j >= 30) {
#line 2121
      if (j <= 39) {
#line 2121
        if (j != 38) {
#line 2122
          c = (c & 240) | ((j - 30) ^ 9);
        } else {
#line 2121
          goto _L___482;
        }
      } else {
#line 2121
        goto _L___482;
      }
    } else
    _L___482: /* CIL Label */ 
#line 2123
    if (j >= 40) {
#line 2123
      if (j <= 49) {
#line 2123
        if (j != 48) {
#line 2124
          c = (c & 15) | (((j - 40) ^ 9) << 4);
        }
      }
    }
#line 2125
    if (j == 0) {
#line 2126
      c = 0;
    }
#line 2134
    if (j < 0) {
#line 2135
      goto while_continue;
    } else
#line 2134
    if ((unsigned long )j >= sizeof(rendlist) / sizeof(*((char *)rendlist))) {
#line 2135
      goto while_continue;
    }
#line 2136
    j = (int )rendlist[j];
#line 2137
    if (j & (1 << 6)) {
#line 2138
      a &= j;
    } else {
#line 2140
      a |= j;
    }
#line 2065
    if (! (i < curr->w_NumArgs)) {
#line 2065
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2143
  curr->w_rend.attr = (unsigned char )a;
#line 2145
  curr->w_rend.color = (unsigned char )c;
#line 2150
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
}
}
#line 2154 "/tmp/screen-3.9.15/ansi.c"
static void FillWithEs(void) 
{ 
  register int i ;
  register unsigned char *p ;
  register unsigned char *ep ;
  unsigned char *__cil_tmp4 ;

  {
  {
#line 2159
  LClearAll(& curr->w_layer, 1);
#line 2160
  curr->w_layer.l_x = 0;
#line 2160
  curr->w_layer.l_y = curr->w_layer.l_x;
#line 2161
  i = 0;
  }
  {
#line 2161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2161
    if (! (i < rows)) {
#line 2161
      goto while_break;
    }
    {
#line 2163
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2163
      bclear((char *)(curr->w_mlines + i)->image + 0, cols + 1);
      }
#line 2163
      if ((curr->w_mlines + i)->attr != null) {
        {
#line 2163
        bzero((void *)((char *)(curr->w_mlines + i)->attr + 0), (unsigned long )(cols + 1));
        }
      }
#line 2163
      if ((curr->w_mlines + i)->font != null) {
        {
#line 2163
        bzero((void *)((char *)(curr->w_mlines + i)->font + 0), (unsigned long )(cols + 1));
        }
      }
#line 2163
      if ((curr->w_mlines + i)->color != null) {
        {
#line 2163
        bzero((void *)((char *)(curr->w_mlines + i)->color + 0), (unsigned long )(cols + 1));
        }
      }
#line 2163
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2164
    p = (curr->w_mlines + i)->image;
#line 2165
    ep = p + cols;
    {
#line 2166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2166
      if (! (p < ep)) {
#line 2166
        goto while_break___1;
      }
#line 2167
      __cil_tmp4 = p;
#line 2167
      p ++;
#line 2167
      *__cil_tmp4 = (unsigned char )'E';
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2161
  i ++;
#line 2169
  LRefreshAll(& curr->w_layer, 1);
  }
}
}
#line 2180 "/tmp/screen-3.9.15/ansi.c"
void ChangeAKA(struct win *p , char *s , int l ) 
{ 
  int i ;
  int c ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
#line 2187
  i = 0;
  {
#line 2187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2187
    if (! (i < 20 && l > 0)) {
#line 2187
      goto while_break;
    }
#line 2189
    __cil_tmp6 = s;
#line 2189
    s ++;
#line 2189
    c = (int )((unsigned char )*__cil_tmp6);
#line 2190
    if (c == 0) {
#line 2191
      goto while_break;
    }
#line 2192
    if (c < 32) {
#line 2193
      goto while_continue;
    } else
#line 2192
    if (c == 127) {
#line 2193
      goto while_continue;
    } else
#line 2192
    if (c >= 128) {
#line 2192
      if (c < 160) {
#line 2192
        if (p->w_c1) {
#line 2193
          goto while_continue;
        }
      }
    }
#line 2194
    __cil_tmp7 = i;
#line 2194
    i ++;
#line 2194
    *(p->w_akachange + __cil_tmp7) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 2187
  __cil_tmp8 = l;
#line 2187
  l --;
#line 2196
  *(p->w_akachange + i) = (char )0;
#line 2197
  p->w_title = p->w_akachange;
#line 2198
  if (p->w_akachange != (char *)p->w_akabuf) {
#line 2199
    if ((int )*(p->w_akachange + 0) == 0) {
      {
      {
#line 2200
      __cil_tmp9 = strlen((char const   *)((char *)p->w_akabuf));
      }
#line 2200
      p->w_title = ((char *)p->w_akabuf + __cil_tmp9) + 1;
      }
    } else
#line 2199
    if ((int )*(p->w_akachange + -1) == 58) {
      {
      {
#line 2200
      __cil_tmp9 = strlen((char const   *)((char *)p->w_akabuf));
      }
#line 2200
      p->w_title = ((char *)p->w_akabuf + __cil_tmp9) + 1;
      }
    }
  }
  {
#line 2201
  WindowChanged(p, 't');
#line 2202
  WindowChanged((struct win *)0, 'w');
#line 2203
  WindowChanged((struct win *)0, 'W');
  }
}
}
#line 2207 "/tmp/screen-3.9.15/ansi.c"
static void FindAKA(void) 
{ 
  register unsigned char *cp ;
  register unsigned char *line ;
  register struct win *wp ;
  register int len ;
  size_t __cil_tmp5 ;
  int y ;
  int tmp ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 2210
  wp = curr;
#line 2211
  __cil_tmp5 = strlen((char const   *)((char *)wp->w_akabuf));
#line 2211
  len = (int )__cil_tmp5;
  }
#line 2214
  if (wp->w_autoaka > 0 && wp->w_autoaka <= wp->w_layer.l_height) {
#line 2214
    tmp = wp->w_autoaka - 1;
  } else {
#line 2214
    tmp = wp->w_layer.l_y;
  }
#line 2214
  y = tmp;
#line 2215
  cols = wp->w_layer.l_width;
  try_line: 
#line 2217
  line = (wp->w_mlines + y)->image;
#line 2217
  cp = line;
#line 2218
  if (wp->w_autoaka > 0) {
#line 2218
    if ((int )*((char *)wp->w_akabuf) != 0) {
      {
#line 2220
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2220
        if (! 1) {
#line 2220
          goto while_break;
        }
#line 2222
        if (cp - line >= (long )(cols - len)) {
#line 2224
          y ++;
#line 2224
          if (y == wp->w_autoaka) {
#line 2224
            if (y < rows) {
#line 2225
              goto try_line;
            }
          }
#line 2226
          return;
        }
        {
#line 2228
        __cil_tmp8 = strncmp((char const   *)((char *)cp), (char const   *)((char *)wp->w_akabuf),
                             (unsigned long )len);
        }
#line 2228
        if (__cil_tmp8 == 0) {
#line 2229
          goto while_break;
        }
#line 2230
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2232
      cp += len;
    }
  }
#line 2234
  len = (int )((long )cols - (cp - line));
  {
#line 2234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2234
    if (! (len && (int )*cp == 32)) {
#line 2234
      goto while_break___0;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
#line 2234
  __cil_tmp11 = cp;
#line 2234
  cp ++;
#line 2234
  __cil_tmp10 = len;
#line 2234
  len --;
#line 2236
  if (len) {
#line 2238
    if (wp->w_autoaka > 0) {
#line 2238
      if ((int )*cp == 33) {
#line 2239
        wp->w_autoaka = - 1;
      } else
#line 2238
      if ((int )*cp == 37) {
#line 2239
        wp->w_autoaka = - 1;
      } else
#line 2238
      if ((int )*cp == 94) {
#line 2239
        wp->w_autoaka = - 1;
      } else {
#line 2241
        wp->w_autoaka = 0;
      }
    } else {
#line 2241
      wp->w_autoaka = 0;
    }
#line 2242
    line = cp;
    {
#line 2243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2243
      if (! (len && (int )*cp != 32)) {
#line 2243
        goto while_break___1;
      }
#line 2245
      __cil_tmp12 = cp;
#line 2245
      cp ++;
#line 2245
      if ((int )*__cil_tmp12 == 47) {
#line 2246
        line = cp;
      }
#line 2247
      __cil_tmp13 = len;
#line 2247
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2249
    ChangeAKA(wp, (char *)line, (int )(cp - line));
    }
  } else {
#line 2252
    wp->w_autoaka = 0;
  }
}
}
#line 2256 "/tmp/screen-3.9.15/ansi.c"
static void RestorePosRendition(void) 
{ 


  {
  {
#line 2258
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
#line 2259
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
}
}
#line 2264 "/tmp/screen-3.9.15/ansi.c"
static void Report(char *fmt , int n1 , int n2 ) 
{ 
  register int len ;
  char rbuf[40] ;
  size_t __cil_tmp6 ;

  {
  {
#line 2271
  sprintf((char *)rbuf, (char const   *)fmt, n1, n2);
#line 2272
  __cil_tmp6 = strlen((char const   *)((char *)rbuf));
#line 2272
  len = (int )__cil_tmp6;
  }
#line 2274
  if ((unsigned long )((unsigned int )(curr->w_inlen + len)) <= sizeof(curr->w_inbuf)) {
    {
#line 2276
    bcopy((void const   *)((char *)rbuf), (void *)((char *)curr->w_inbuf + curr->w_inlen),
          (size_t )len);
#line 2277
    curr->w_inlen += len;
    }
  }
}
}
#line 2295 "/tmp/screen-3.9.15/ansi.c"
static void MFixLine(struct win *p , int y , struct mchar *mc ) 
{ 
  struct mline *ml ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  int tmp ;
  int tmp___484 ;
  void *__cil_tmp9 ;

  {
#line 2300
  ml = & *(p->w_mlines + y);
#line 2301
  if ((int )mc->attr) {
#line 2301
    if (ml->attr == null) {
      {
#line 2303
      __cil_tmp5 = malloc((unsigned long )(p->w_layer.l_width + 1));
#line 2303
      ml->attr = (unsigned char *)__cil_tmp5;
      }
#line 2303
      if (ml->attr == (unsigned char *)0) {
        {
#line 2305
        ml->attr = null;
#line 2306
        p->w_rend.attr = (unsigned char )0;
#line 2306
        mc->attr = p->w_rend.attr;
#line 2307
        WMsg(p, 0, (char *)"Warning: no space for attr - turned off");
        }
      }
      {
#line 2309
      bzero((void *)((char *)ml->attr), (unsigned long )(p->w_layer.l_width + 1));
      }
    }
  }
#line 2312
  if ((int )mc->font) {
#line 2312
    if (ml->font == null) {
      {
#line 2314
      __cil_tmp6 = malloc((unsigned long )(p->w_layer.l_width + 1));
#line 2314
      ml->font = (unsigned char *)__cil_tmp6;
      }
#line 2314
      if (ml->font == (unsigned char *)0) {
#line 2316
        ml->font = null;
#line 2317
        if (p->w_ss) {
#line 2317
          tmp = p->w_ss;
        } else {
#line 2317
          tmp = p->w_Charset;
        }
#line 2317
        p->w_charsets[tmp] = 0;
#line 2317
        p->w_FontL = (char )p->w_charsets[tmp];
#line 2318
        if (p->w_ss) {
#line 2318
          tmp___484 = p->w_ss;
        } else {
#line 2318
          tmp___484 = p->w_CharsetR;
        }
        {
#line 2318
        p->w_charsets[tmp___484] = 0;
#line 2318
        p->w_FontR = (char )p->w_charsets[tmp___484];
#line 2319
        p->w_rend.font = (unsigned char )0;
#line 2319
        mc->font = p->w_rend.font;
#line 2320
        WMsg(p, 0, (char *)"Warning: no space for font - turned off");
        }
      }
      {
#line 2322
      bzero((void *)((char *)ml->font), (unsigned long )(p->w_layer.l_width + 1));
      }
    }
  }
#line 2326
  if ((int )mc->color) {
#line 2326
    if (ml->color == null) {
      {
#line 2328
      __cil_tmp9 = malloc((unsigned long )(p->w_layer.l_width + 1));
#line 2328
      ml->color = (unsigned char *)__cil_tmp9;
      }
#line 2328
      if (ml->color == (unsigned char *)0) {
        {
#line 2330
        ml->color = null;
#line 2331
        p->w_rend.color = (unsigned char )0;
#line 2331
        mc->color = p->w_rend.color;
#line 2332
        WMsg(p, 0, (char *)"Warning: no space for color - turned off");
        }
      }
      {
#line 2334
      bzero((void *)((char *)ml->color), (unsigned long )(p->w_layer.l_width + 1));
      }
    }
  }
}
}
#line 2374 "/tmp/screen-3.9.15/ansi.c"
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___485 ;
  int tmp___486 ;
  int tmp___487 ;

  {
#line 2380
  if (n == 0) {
#line 2381
    return;
  }
#line 2382
  ml = & *(p->w_mlines + y);
#line 2383
  if (p->w_layer.l_encoding == 8) {
#line 2383
    tmp = (int )*(ml->font + xs) == 255 && (int )*(ml->image + xs) == 255;
  } else {
#line 2383
    tmp = ((int )*(ml->font + xs) & 224) == 128;
  }
#line 2383
  if (tmp) {
#line 2383
    if (xs > 0) {
      {
#line 2383
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2383
        *(ml->image + (xs - 1)) = mchar_blank.image;
#line 2383
        *(ml->attr + (xs - 1)) = mchar_blank.attr;
#line 2383
        *(ml->font + (xs - 1)) = mchar_blank.font;
#line 2383
        *(ml->color + (xs - 1)) = mchar_blank.color;
#line 2383
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2383
      *(ml->image + xs) = mchar_blank.image;
#line 2383
      *(ml->attr + xs) = mchar_blank.attr;
#line 2383
      *(ml->font + xs) = mchar_blank.font;
#line 2383
      *(ml->color + xs) = mchar_blank.color;
#line 2383
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2384
  if (p->w_layer.l_encoding == 8) {
#line 2384
    tmp___485 = (int )*(ml->font + (xe + 1)) == 255 && (int )*(ml->image + (xe + 1)) == 255;
  } else {
#line 2384
    tmp___485 = ((int )*(ml->font + xe) & 31) != 0 && ((int )*(ml->font + xe) & 224) == 0;
  }
#line 2384
  if (tmp___485) {
    {
#line 2384
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2384
      *(ml->image + xe) = mchar_blank.image;
#line 2384
      *(ml->attr + xe) = mchar_blank.attr;
#line 2384
      *(ml->font + xe) = mchar_blank.font;
#line 2384
      *(ml->color + xe) = mchar_blank.color;
#line 2384
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2384
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2384
      *(ml->image + (xe + 1)) = mchar_blank.image;
#line 2384
      *(ml->attr + (xe + 1)) = mchar_blank.attr;
#line 2384
      *(ml->font + (xe + 1)) = mchar_blank.font;
#line 2384
      *(ml->color + (xe + 1)) = mchar_blank.color;
#line 2384
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }

#line 2385
  if (n > 0) {
#line 2387
    if ((xe - xs) + 1 > n) {
#line 2389
      if (p->w_layer.l_encoding == 8) {
#line 2389
        tmp___486 = (int )*(ml->font + (xs + n)) == 255 && (int )*(ml->image + (xs + n)) == 255;
      } else {
#line 2389
        tmp___486 = ((int )*(ml->font + (xs + n)) & 224) == 128;
      }
#line 2389
      if (tmp___486) {
#line 2389
        if (xs + n > 0) {
          {
#line 2389
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2389
            *(ml->image + ((xs + n) - 1)) = mchar_blank.image;
#line 2389
            *(ml->attr + ((xs + n) - 1)) = mchar_blank.attr;
#line 2389
            *(ml->font + ((xs + n) - 1)) = mchar_blank.font;
#line 2389
            *(ml->color + ((xs + n) - 1)) = mchar_blank.color;
#line 2389
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 2389
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2389
          *(ml->image + (xs + n)) = mchar_blank.image;
#line 2389
          *(ml->attr + (xs + n)) = mchar_blank.attr;
#line 2389
          *(ml->font + (xs + n)) = mchar_blank.font;
#line 2389
          *(ml->color + (xs + n)) = mchar_blank.color;
#line 2389
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }

      {
#line 2390
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2390
        bcopy((void const   *)((char *)ml->image + (xs + n)), (void *)((char *)ml->image + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2390
        bcopy((void const   *)((char *)ml->attr + (xs + n)), (void *)((char *)ml->attr + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2390
        bcopy((void const   *)((char *)ml->font + (xs + n)), (void *)((char *)ml->font + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2390
        bcopy((void const   *)((char *)ml->color + (xs + n)), (void *)((char *)ml->color + xs),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2390
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 2393
      n = (xe - xs) + 1;
    }
    {
#line 2394
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 2394
      bclear((char *)ml->image + ((xe + 1) - n), n);
      }
#line 2394
      if (ml->attr != null) {
        {
#line 2394
        bzero((void *)((char *)ml->attr + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2394
      if (ml->font != null) {
        {
#line 2394
        bzero((void *)((char *)ml->font + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2394
      if (ml->color != null) {
        {
#line 2394
        bzero((void *)((char *)ml->color + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2394
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2396
    if (bce) {
      {
#line 2397
      MBceLine(p, y, (xe + 1) - n, n, bce);
      }
    }
  } else {
#line 2402
    n = - n;
#line 2403
    if ((xe - xs) + 1 > n) {
#line 2405
      if (p->w_layer.l_encoding == 8) {
#line 2405
        tmp___487 = (int )*(ml->font + ((xe - n) + 1)) == 255 && (int )*(ml->image + ((xe - n) + 1)) == 255;
      } else {
#line 2405
        tmp___487 = ((int )*(ml->font + (xe - n)) & 31) != 0 && ((int )*(ml->font + (xe - n)) & 224) == 0;
      }
#line 2405
      if (tmp___487) {
        {
#line 2405
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2405
          *(ml->image + (xe - n)) = mchar_blank.image;
#line 2405
          *(ml->attr + (xe - n)) = mchar_blank.attr;
#line 2405
          *(ml->font + (xe - n)) = mchar_blank.font;
#line 2405
          *(ml->color + (xe - n)) = mchar_blank.color;
#line 2405
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2405
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2405
          *(ml->image + ((xe - n) + 1)) = mchar_blank.image;
#line 2405
          *(ml->attr + ((xe - n) + 1)) = mchar_blank.attr;
#line 2405
          *(ml->font + ((xe - n) + 1)) = mchar_blank.font;
#line 2405
          *(ml->color + ((xe - n) + 1)) = mchar_blank.color;
#line 2405
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }

      {
#line 2406
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 2406
        bcopy((void const   *)((char *)ml->image + xs), (void *)((char *)ml->image + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2406
        bcopy((void const   *)((char *)ml->attr + xs), (void *)((char *)ml->attr + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2406
        bcopy((void const   *)((char *)ml->font + xs), (void *)((char *)ml->font + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2406
        bcopy((void const   *)((char *)ml->color + xs), (void *)((char *)ml->color + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2406
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 2409
      n = (xe - xs) + 1;
    }
    {
#line 2410
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 2410
      bclear((char *)ml->image + xs, n);
      }
#line 2410
      if (ml->attr != null) {
        {
#line 2410
        bzero((void *)((char *)ml->attr + xs), (unsigned long )n);
        }
      }
#line 2410
      if (ml->font != null) {
        {
#line 2410
        bzero((void *)((char *)ml->font + xs), (unsigned long )n);
        }
      }
#line 2410
      if (ml->color != null) {
        {
#line 2410
        bzero((void *)((char *)ml->color + xs), (unsigned long )n);
        }
      }
#line 2410
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2412
    if (bce) {
      {
#line 2413
      MBceLine(p, y, xs, n, bce);
      }
    }
  }
}
}
#line 2419 "/tmp/screen-3.9.15/ansi.c"
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) 
{ 
  int i ;
  int cnt1 ;
  int cnt2 ;
  struct mline tmp[256] ;
  struct mline *ml ;
  int __cil_tmp12 ;
  struct mline *__cil_tmp13 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;

  {
#line 2427
  if (n == 0) {
#line 2428
    return;
  }
#line 2429
  if (n > 0) {
#line 2431
    if (n > 256) {
      {
#line 2433
      MScrollV(p, n - 256, ys, ye, bce);
#line 2434
      n = 256;
      }
    }
#line 2436
    if ((ye - ys) + 1 < n) {
#line 2437
      n = (ye - ys) + 1;
    }
#line 2439
    if (compacthist) {
      {
#line 2441
      ye = MFindUsedLine(p, ye, ys);
      }
#line 2442
      if ((ye - ys) + 1 < n) {
#line 2443
        n = (ye - ys) + 1;
      }
#line 2444
      if (n <= 0) {
#line 2445
        return;
      }
    }
#line 2449
    ml = p->w_mlines + ys;
#line 2450
    i = ys;
    {
#line 2450
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2450
      if (! (i < ys + n)) {
#line 2450
        goto while_break;
      }
#line 2453
      if (ys == p->w_top) {
        {
#line 2454
        WAddLineToHist(p, ml);
        }
      }
#line 2456
      if (ml->attr != null) {
        {
#line 2457
        free((void *)ml->attr);
        }
      }
#line 2458
      ml->attr = null;
#line 2460
      if (ml->font != null) {
        {
#line 2461
        free((void *)ml->font);
        }
      }
#line 2462
      ml->font = null;
#line 2465
      if (ml->color != null) {
        {
#line 2466
        free((void *)ml->color);
        }
      }
      {
#line 2467
      ml->color = null;
#line 2474
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2476
      if (bce) {
        {
#line 2477
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2450
    __cil_tmp13 = ml;
#line 2450
    ml ++;
#line 2450
    __cil_tmp12 = i;
#line 2450
    i ++;
#line 2481
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2482
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2483
    if (cnt1) {
#line 2483
      if (cnt2) {
        {
#line 2484
        Scroll((char *)(p->w_mlines + ys), cnt1, cnt2, (char *)((struct mline *)tmp));
        }
      }
    }
  } else {
#line 2488
    if (n < -256) {
      {
#line 2490
      MScrollV(p, n + 256, ys, ye, bce);
#line 2491
      n = - 256;
      }
    }
#line 2493
    n = - n;
#line 2494
    if ((ye - ys) + 1 < n) {
#line 2495
      n = (ye - ys) + 1;
    }
#line 2497
    ml = p->w_mlines + ye;
#line 2499
    i = ye;
    {
#line 2499
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2499
      if (! (i > ye - n)) {
#line 2499
        goto while_break___0;
      }
#line 2501
      if (ml->attr != null) {
        {
#line 2502
        free((void *)ml->attr);
        }
      }
#line 2503
      ml->attr = null;
#line 2505
      if (ml->font != null) {
        {
#line 2506
        free((void *)ml->font);
        }
      }
#line 2507
      ml->font = null;
#line 2510
      if (ml->color != null) {
        {
#line 2511
        free((void *)ml->color);
        }
      }
      {
#line 2512
      ml->color = null;
#line 2519
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2521
      if (bce) {
        {
#line 2522
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2499
    __cil_tmp15 = ml;
#line 2499
    ml --;
#line 2499
    __cil_tmp14 = i;
#line 2499
    i --;
#line 2525
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2526
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2527
    if (cnt1) {
#line 2527
      if (cnt2) {
        {
#line 2528
        Scroll((char *)(p->w_mlines + ys), cnt2, cnt1, (char *)((struct mline *)tmp));
        }
      }
    }
  }
}
}
#line 2533 "/tmp/screen-3.9.15/ansi.c"
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) 
{ 


  {
#line 2537
  if (! cnt1) {
#line 2538
    return;
  } else
#line 2537
  if (! cnt2) {
#line 2538
    return;
  }
#line 2539
  if (cnt1 <= cnt2) {
    {
#line 2541
    bcopy((void const   *)cp, (void *)tmp, (size_t )cnt1);
#line 2542
    bcopy((void const   *)(cp + cnt1), (void *)cp, (size_t )cnt2);
#line 2543
    bcopy((void const   *)tmp, (void *)(cp + cnt2), (size_t )cnt1);
    }
  } else {
    {
#line 2547
    bcopy((void const   *)(cp + cnt1), (void *)tmp, (size_t )cnt2);
#line 2548
    bcopy((void const   *)cp, (void *)(cp + cnt2), (size_t )cnt1);
#line 2549
    bcopy((void const   *)tmp, (void *)cp, (size_t )cnt2);
    }
  }
}
}
#line 2554 "/tmp/screen-3.9.15/ansi.c"
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) 
{ 
  int n ;
  int y ;
  int xxe ;
  struct mline *ml ;
  int tmp ;
  int tmp___488 ;
  int tmp___489 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;

  {
#line 2563
  if (xs >= p->w_layer.l_width) {
#line 2564
    xs = p->w_layer.l_width - 1;
  }
#line 2565
  if (xe >= p->w_layer.l_width) {
#line 2566
    xe = p->w_layer.l_width - 1;
  }
#line 2568
  if (p->w_layer.l_encoding == 8) {
#line 2568
    tmp = (int )*((p->w_mlines + ys)->font + xs) == 255 && (int )*((p->w_mlines + ys)->image + xs) == 255;
  } else {
#line 2568
    tmp = ((int )*((p->w_mlines + ys)->font + xs) & 224) == 128;
  }
#line 2568
  if (tmp) {
#line 2568
    if (xs > 0) {
      {
#line 2568
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2568
        *((p->w_mlines + ys)->image + (xs - 1)) = mchar_blank.image;
#line 2568
        *((p->w_mlines + ys)->attr + (xs - 1)) = mchar_blank.attr;
#line 2568
        *((p->w_mlines + ys)->font + (xs - 1)) = mchar_blank.font;
#line 2568
        *((p->w_mlines + ys)->color + (xs - 1)) = mchar_blank.color;
#line 2568
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2568
      *((p->w_mlines + ys)->image + xs) = mchar_blank.image;
#line 2568
      *((p->w_mlines + ys)->attr + xs) = mchar_blank.attr;
#line 2568
      *((p->w_mlines + ys)->font + xs) = mchar_blank.font;
#line 2568
      *((p->w_mlines + ys)->color + xs) = mchar_blank.color;
#line 2568
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2569
  if (p->w_layer.l_encoding == 8) {
#line 2569
    tmp___488 = (int )*((p->w_mlines + ye)->font + (xe + 1)) == 255 && (int )*((p->w_mlines + ye)->image + (xe + 1)) == 255;
  } else {
#line 2569
    tmp___488 = ((int )*((p->w_mlines + ye)->font + xe) & 31) != 0 && ((int )*((p->w_mlines + ye)->font + xe) & 224) == 0;
  }
#line 2569
  if (tmp___488) {
    {
#line 2569
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2569
      *((p->w_mlines + ye)->image + xe) = mchar_blank.image;
#line 2569
      *((p->w_mlines + ye)->attr + xe) = mchar_blank.attr;
#line 2569
      *((p->w_mlines + ye)->font + xe) = mchar_blank.font;
#line 2569
      *((p->w_mlines + ye)->color + xe) = mchar_blank.color;
#line 2569
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2569
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2569
      *((p->w_mlines + ye)->image + (xe + 1)) = mchar_blank.image;
#line 2569
      *((p->w_mlines + ye)->attr + (xe + 1)) = mchar_blank.attr;
#line 2569
      *((p->w_mlines + ye)->font + (xe + 1)) = mchar_blank.font;
#line 2569
      *((p->w_mlines + ye)->color + (xe + 1)) = mchar_blank.color;
#line 2569
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2571
  ml = p->w_mlines + ys;
#line 2572
  y = ys;
  {
#line 2572
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2572
    if (! (y <= ye)) {
#line 2572
      goto while_break___3;
    }
#line 2574
    if (y == ye) {
#line 2574
      tmp___489 = xe;
    } else {
#line 2574
      tmp___489 = p->w_layer.l_width - 1;
    }
#line 2574
    xxe = tmp___489;
#line 2575
    n = (xxe - xs) + 1;
#line 2576
    if (n > 0) {
      {
#line 2577
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2577
        bclear((char *)ml->image + xs, n);
        }
#line 2577
        if (ml->attr != null) {
          {
#line 2577
          bzero((void *)((char *)ml->attr + xs), (unsigned long )n);
          }
        }
#line 2577
        if (ml->font != null) {
          {
#line 2577
          bzero((void *)((char *)ml->font + xs), (unsigned long )n);
          }
        }
#line 2577
        if (ml->color != null) {
          {
#line 2577
          bzero((void *)((char *)ml->color + xs), (unsigned long )n);
          }
        }
#line 2577
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 2579
    if (n > 0) {
#line 2579
      if (bce) {
        {
#line 2580
        MBceLine(p, y, xs, (xs + n) - 1, bce);
        }
      }
    }
#line 2582
    xs = 0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2572
  __cil_tmp15 = ml;
#line 2572
  ml ++;
#line 2572
  __cil_tmp14 = y;
#line 2572
  y ++;
}
}
#line 2587 "/tmp/screen-3.9.15/ansi.c"
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  int n ;
  struct mline *ml ;
  int tmp ;
  int tmp___490 ;
  int tmp___491 ;

  {
  {
#line 2595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2595
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2596
  MFixLine(p, y, c);
#line 2597
  ml = p->w_mlines + y;
#line 2598
  n = (p->w_layer.l_width - x) - 1;
  }
#line 2599
  if (p->w_layer.l_encoding == 8) {
#line 2599
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2599
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2599
  if (tmp) {
#line 2599
    if (x > 0) {
      {
#line 2599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2599
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2599
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2599
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2599
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2599
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 2599
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2599
      *(ml->image + x) = mchar_blank.image;
#line 2599
      *(ml->attr + x) = mchar_blank.attr;
#line 2599
      *(ml->font + x) = mchar_blank.font;
#line 2599
      *(ml->color + x) = mchar_blank.color;
#line 2599
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }

#line 2600
  if (n > 0) {
#line 2602
    if (p->w_layer.l_encoding == 8) {
#line 2602
      tmp___490 = (int )*(ml->font + (p->w_layer.l_width - 1)) == 255 && (int )*(ml->image + (p->w_layer.l_width - 1)) == 255;
    } else {
#line 2602
      tmp___490 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
    }
#line 2602
    if (tmp___490) {
#line 2602
      if (p->w_layer.l_width - 1 > 0) {
        {
#line 2602
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2602
          *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2602
          *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2602
          *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2602
          *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2602
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 2602
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2602
        *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2602
        *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2602
        *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2602
        *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2602
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }

    {
#line 2603
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 2603
      bcopy((void const   *)((char *)ml->image + x), (void *)((char *)ml->image + (x + 1)),
            (size_t )n);
#line 2603
      bcopy((void const   *)((char *)ml->attr + x), (void *)((char *)ml->attr + (x + 1)),
            (size_t )n);
#line 2603
      bcopy((void const   *)((char *)ml->font + x), (void *)((char *)ml->font + (x + 1)),
            (size_t )n);
#line 2603
      bcopy((void const   *)((char *)ml->color + x), (void *)((char *)ml->color + (x + 1)),
            (size_t )n);
      }
#line 2603
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 2605
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2605
    *(ml->image + x) = c->image;
#line 2605
    *(ml->attr + x) = c->attr;
#line 2605
    *(ml->font + x) = c->font;
#line 2605
    *(ml->color + x) = c->color;
#line 2605
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2607
  if (c->mbcs) {
#line 2609
    n --;
#line 2609
    if (n > 0) {
#line 2611
      if (p->w_layer.l_encoding == 8) {
#line 2611
        tmp___491 = (int )*(ml->font + (p->w_layer.l_width - 1)) == 255 && (int )*(ml->image + (p->w_layer.l_width - 1)) == 255;
      } else {
#line 2611
        tmp___491 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
      }
#line 2611
      if (tmp___491) {
#line 2611
        if (p->w_layer.l_width - 1 > 0) {
          {
#line 2611
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2611
            *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2611
            *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2611
            *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2611
            *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2611
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
        {
#line 2611
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2611
          *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2611
          *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2611
          *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2611
          *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2611
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }

      {
#line 2612
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 2612
        bcopy((void const   *)((char *)ml->image + (x + 1)), (void *)((char *)ml->image + (x + 2)),
              (size_t )n);
#line 2612
        bcopy((void const   *)((char *)ml->attr + (x + 1)), (void *)((char *)ml->attr + (x + 2)),
              (size_t )n);
#line 2612
        bcopy((void const   *)((char *)ml->font + (x + 1)), (void *)((char *)ml->font + (x + 2)),
              (size_t )n);
#line 2612
        bcopy((void const   *)((char *)ml->color + (x + 1)), (void *)((char *)ml->color + (x + 2)),
              (size_t )n);
        }
#line 2612
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 2614
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2614
      *(ml->image + (x + 1)) = c->image;
#line 2614
      *(ml->attr + (x + 1)) = c->attr;
#line 2614
      *(ml->font + (x + 1)) = c->font;
#line 2614
      *(ml->color + (x + 1)) = c->color;
#line 2614
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2615
    *(ml->image + (x + 1)) = c->mbcs;
#line 2617
    if (p->w_layer.l_encoding != 8) {
#line 2618
      *(ml->font + (x + 1)) |= 128;
    } else
#line 2619
    if (p->w_layer.l_encoding == 8) {
#line 2619
      if ((int )c->mbcs) {
#line 2620
        *(ml->font + (x + 1)) = c->mbcs;
      }
    }
  }
}
}
#line 2629 "/tmp/screen-3.9.15/ansi.c"
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___492 ;

  {
  {
#line 2636
  MFixLine(p, y, c);
#line 2637
  ml = & *(p->w_mlines + y);
  }
#line 2638
  if (p->w_layer.l_encoding == 8) {
#line 2638
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2638
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2638
  if (tmp) {
#line 2638
    if (x > 0) {
      {
#line 2638
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2638
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2638
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2638
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2638
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2638
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2638
      *(ml->image + x) = mchar_blank.image;
#line 2638
      *(ml->attr + x) = mchar_blank.attr;
#line 2638
      *(ml->font + x) = mchar_blank.font;
#line 2638
      *(ml->color + x) = mchar_blank.color;
#line 2638
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

  {
#line 2639
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2639
    *(ml->image + x) = c->image;
#line 2639
    *(ml->attr + x) = c->attr;
#line 2639
    *(ml->font + x) = c->font;
#line 2639
    *(ml->color + x) = c->color;
#line 2639
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2641
  if (c->mbcs) {
#line 2643
    if (p->w_layer.l_encoding == 8) {
#line 2643
      tmp___492 = (int )*(ml->font + ((x + 1) + 1)) == 255 && (int )*(ml->image + ((x + 1) + 1)) == 255;
    } else {
#line 2643
      tmp___492 = ((int )*(ml->font + (x + 1)) & 31) != 0 && ((int )*(ml->font + (x + 1)) & 224) == 0;
    }
#line 2643
    if (tmp___492) {
      {
#line 2643
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2643
        *(ml->image + (x + 1)) = mchar_blank.image;
#line 2643
        *(ml->attr + (x + 1)) = mchar_blank.attr;
#line 2643
        *(ml->font + (x + 1)) = mchar_blank.font;
#line 2643
        *(ml->color + (x + 1)) = mchar_blank.color;
#line 2643
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2643
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2643
        *(ml->image + ((x + 1) + 1)) = mchar_blank.image;
#line 2643
        *(ml->attr + ((x + 1) + 1)) = mchar_blank.attr;
#line 2643
        *(ml->font + ((x + 1) + 1)) = mchar_blank.font;
#line 2643
        *(ml->color + ((x + 1) + 1)) = mchar_blank.color;
#line 2643
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }

    {
#line 2644
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2644
      *(ml->image + (x + 1)) = c->image;
#line 2644
      *(ml->attr + (x + 1)) = c->attr;
#line 2644
      *(ml->font + (x + 1)) = c->font;
#line 2644
      *(ml->color + (x + 1)) = c->color;
#line 2644
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2645
    *(ml->image + (x + 1)) = c->mbcs;
#line 2647
    if (p->w_layer.l_encoding != 8) {
#line 2648
      *(ml->font + (x + 1)) |= 128;
    } else
#line 2649
    if (p->w_layer.l_encoding == 8) {
#line 2649
      if ((int )c->mbcs) {
#line 2650
        *(ml->font + (x + 1)) = c->mbcs;
      }
    }
  }
}
}
#line 2660 "/tmp/screen-3.9.15/ansi.c"
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) 
{ 
  struct mline *ml ;
  int bce ;
  int tmp ;

  {
#line 2670
  if ((int )c->attr & (1 << 7)) {
#line 2670
    tmp = 256;
  } else {
#line 2670
    tmp = 0;
  }
  {
#line 2670
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 2674
  MFixLine(p, y, c);
#line 2675
  ml = & *(p->w_mlines + y);
  }
  {
#line 2676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2676
    *(ml->image + p->w_layer.l_width) = mchar_null.image;
#line 2676
    *(ml->attr + p->w_layer.l_width) = mchar_null.attr;
#line 2676
    *(ml->font + p->w_layer.l_width) = mchar_null.font;
#line 2676
    *(ml->color + p->w_layer.l_width) = mchar_null.color;
#line 2676
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2677
  if (y == bot) {
    {
#line 2678
    MScrollV(p, 1, top, bot, bce);
    }
  } else
#line 2679
  if (y < p->w_layer.l_height - 1) {
#line 2680
    y ++;
  }
#line 2681
  if (ins) {
    {
#line 2682
    MInsChar(p, c, 0, y);
    }
  } else {
    {
#line 2684
    MPutChar(p, c, 0, y);
    }
  }
}
}
#line 2688 "/tmp/screen-3.9.15/ansi.c"
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct mline *ml ;
  int i ;
  unsigned char *b ;
  int tmp ;
  int tmp___493 ;
  int __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;

  {
#line 2699
  if (n <= 0) {
#line 2700
    return;
  }
  {
#line 2701
  MFixLine(p, y, r);
#line 2702
  ml = & *(p->w_mlines + y);
  }
#line 2703
  if (p->w_layer.l_encoding == 8) {
#line 2703
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2703
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2703
  if (tmp) {
#line 2703
    if (x > 0) {
      {
#line 2703
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2703
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2703
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2703
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2703
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2703
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2703
      *(ml->image + x) = mchar_blank.image;
#line 2703
      *(ml->attr + x) = mchar_blank.attr;
#line 2703
      *(ml->font + x) = mchar_blank.font;
#line 2703
      *(ml->color + x) = mchar_blank.color;
#line 2703
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2704
  if (p->w_layer.l_encoding == 8) {
#line 2704
    tmp___493 = (int )*(ml->font + (((x + n) - 1) + 1)) == 255 && (int )*(ml->image + (((x + n) - 1) + 1)) == 255;
  } else {
#line 2704
    tmp___493 = ((int )*(ml->font + ((x + n) - 1)) & 31) != 0 && ((int )*(ml->font + ((x + n) - 1)) & 224) == 0;
  }
#line 2704
  if (tmp___493) {
    {
#line 2704
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2704
      *(ml->image + ((x + n) - 1)) = mchar_blank.image;
#line 2704
      *(ml->attr + ((x + n) - 1)) = mchar_blank.attr;
#line 2704
      *(ml->font + ((x + n) - 1)) = mchar_blank.font;
#line 2704
      *(ml->color + ((x + n) - 1)) = mchar_blank.color;
#line 2704
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2704
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2704
      *(ml->image + (((x + n) - 1) + 1)) = mchar_blank.image;
#line 2704
      *(ml->attr + (((x + n) - 1) + 1)) = mchar_blank.attr;
#line 2704
      *(ml->font + (((x + n) - 1) + 1)) = mchar_blank.font;
#line 2704
      *(ml->color + (((x + n) - 1) + 1)) = mchar_blank.color;
#line 2704
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2705
  bcopy((void const   *)s, (void *)((char *)ml->image + x), (size_t )n);
#line 2706
  b = ml->attr + x;
#line 2707
  i = n;
  }
  {
#line 2707
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2707
    if (! (__cil_tmp12 > 0)) {
#line 2707
      goto while_break___3;
    }
#line 2708
    __cil_tmp13 = b;
#line 2708
    b ++;
#line 2708
    *__cil_tmp13 = r->attr;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2710
  b = ml->font + x;
#line 2711
  i = n;
  {
#line 2711
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2711
    if (! (__cil_tmp14 > 0)) {
#line 2711
      goto while_break___4;
    }
#line 2712
    __cil_tmp15 = b;
#line 2712
    b ++;
#line 2712
    *__cil_tmp15 = r->font;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2715
  b = ml->color + x;
#line 2716
  i = n;
  {
#line 2716
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2716
    if (! (__cil_tmp16 > 0)) {
#line 2716
      goto while_break___5;
    }
#line 2717
    __cil_tmp17 = b;
#line 2717
    b ++;
#line 2717
    *__cil_tmp17 = r->color;
  }
  while_break___5: /* CIL Label */ ;
  }
}
}
#line 2728 "/tmp/screen-3.9.15/ansi.c"
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) 
{ 
  struct mchar mc ;
  struct mline *ml ;
  int x ;
  int tmp ;

  {
#line 2736
  mc = mchar_null;
#line 2737
  if (bce & 256) {
#line 2737
    tmp = 0;
  } else {
#line 2737
    tmp = 1 << 7;
  }
#line 2737
  mc.attr = (unsigned char )(((int )mc.attr | (1 << 7)) ^ tmp);
  {
#line 2737
  mc.color = (unsigned char )(((int )mc.color & 15) | ((bce << 4) & 240));
#line 2738
  MFixLine(p, y, & mc);
#line 2739
  ml = p->w_mlines + y;
  }
#line 2741
  if (mc.attr) {
#line 2742
    x = xs;
    {
#line 2742
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2742
      if (! (x <= xe)) {
#line 2742
        goto while_break;
      }
#line 2743
      *(ml->attr + x) = mc.attr;
    }
    while_break: /* CIL Label */ ;
    }
#line 2742
    x ++;
  }
#line 2745
  if (mc.color) {
#line 2746
    x = xs;
    {
#line 2746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2746
      if (! (x <= xe)) {
#line 2746
        goto while_break___0;
      }
#line 2747
      *(ml->color + x) = mc.color;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2746
    x ++;
  }
}
}
#line 2759 "/tmp/screen-3.9.15/ansi.c"
static void WAddLineToHist(struct win *wp , struct mline *ml ) 
{ 
  register unsigned char *q ;
  register unsigned char *o ;
  struct mline *hml ;

  {
#line 2766
  if (wp->w_histheight == 0) {
#line 2767
    return;
  }
#line 2768
  hml = & *(wp->w_hlines + wp->w_histidx);
#line 2769
  q = ml->image;
#line 2769
  ml->image = hml->image;
#line 2769
  hml->image = q;
#line 2771
  q = ml->attr;
#line 2771
  o = hml->attr;
#line 2771
  hml->attr = q;
#line 2771
  ml->attr = null;
#line 2772
  if (o != null) {
    {
#line 2773
    free((void *)o);
    }
  }
#line 2776
  q = ml->font;
#line 2776
  o = hml->font;
#line 2776
  hml->font = q;
#line 2776
  ml->font = null;
#line 2777
  if (o != null) {
    {
#line 2778
    free((void *)o);
    }
  }
#line 2782
  q = ml->color;
#line 2782
  o = hml->color;
#line 2782
  hml->color = q;
#line 2782
  ml->color = null;
#line 2783
  if (o != null) {
    {
#line 2784
    free((void *)o);
    }
  }
#line 2792
  (wp->w_histidx) ++;
#line 2792
  if (wp->w_histidx >= wp->w_histheight) {
#line 2793
    wp->w_histidx = 0;
  }
}
}
#line 2798 "/tmp/screen-3.9.15/ansi.c"
int MFindUsedLine(struct win *p , int ye , int ys ) 
{ 
  int y ;
  struct mline *ml ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  struct mline *__cil_tmp10 ;

  {
#line 2803
  ml = p->w_mlines + ye;
  {
#line 2805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2805
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2806
  y = ye;
  {
#line 2806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2806
    if (! (y >= ys)) {
#line 2806
      goto while_break___0;
    }
    {
#line 2808
    __cil_tmp6 = bcmp((void const   *)((char *)ml->image), (void const   *)blank,
                      (size_t )p->w_layer.l_width);
    }
#line 2808
    if (__cil_tmp6) {
#line 2809
      goto while_break___0;
    }
    {
#line 2810
    __cil_tmp7 = bcmp((void const   *)((char *)ml->attr), (void const   *)null, (size_t )p->w_layer.l_width);
    }
#line 2810
    if (ml->attr != null) {
#line 2810
      if (__cil_tmp7) {
#line 2811
        goto while_break___0;
      }
    }
    {
#line 2813
    __cil_tmp8 = bcmp((void const   *)((char *)ml->color), (void const   *)null, (size_t )p->w_layer.l_width);
    }
#line 2813
    if (ml->color != null) {
#line 2813
      if (__cil_tmp8) {
#line 2814
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2806
  __cil_tmp10 = ml;
#line 2806
  ml --;
#line 2806
  __cil_tmp9 = y;
#line 2806
  y --;
  {
#line 2821
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2821
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2822
  return (y);
}
}
#line 2836 "/tmp/screen-3.9.15/ansi.c"
void WBell(struct win *p , int visual ) 
{ 
  struct canvas *cv ;
  int tmp ;

  {
#line 2841
  display = displays;
  {
#line 2841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2841
    if (! display) {
#line 2841
      goto while_break;
    }
#line 2843
    cv = display->d_cvlist;
    {
#line 2843
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2843
      if (! cv) {
#line 2843
        goto while_break___0;
      }
#line 2844
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 2845
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2843
    cv = cv->c_next;
#line 2846
    if (cv) {
#line 2846
      if (! visual) {
        {
#line 2847
        AddCStr(display->d_tcs[42].str);
        }
      } else {
#line 2846
        goto _L___494;
      }
    } else
    _L___494: /* CIL Label */ 
#line 2848
    if (cv) {
#line 2848
      if (display->d_tcs[43].str) {
        {
#line 2849
        AddCStr(display->d_tcs[43].str);
        }
      } else {
#line 2848
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2851
      if (visual) {
#line 2851
        tmp = 3;
      } else {
#line 2851
        tmp = 1;
      }
#line 2851
      p->w_bell = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2841
  display = display->d_next;
}
}
#line 2863 "/tmp/screen-3.9.15/ansi.c"
static void WReverseVideo(struct win *p , int on ) 
{ 
  struct canvas *cv ;

  {
#line 2868
  cv = p->w_layer.l_cvlist;
  {
#line 2868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2868
    if (! cv) {
#line 2868
      goto while_break;
    }
#line 2870
    display = cv->c_display;
#line 2871
    if (cv != display->d_forecv) {
#line 2872
      goto while_continue;
    }
    {
#line 2873
    ReverseVideo(on);
    }
#line 2874
    if (! on) {
#line 2874
      if (p->w_revvid) {
#line 2874
        if (! display->d_tcs[93].str) {
#line 2876
          if (display->d_tcs[43].str) {
            {
#line 2877
            AddCStr(display->d_tcs[43].str);
            }
          } else {
#line 2879
            p->w_bell = 3;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2868
  cv = cv->c_lnext;
}
}
#line 2885 "/tmp/screen-3.9.15/ansi.c"
void WMsg(struct win *p , int err , char *str ) 
{ 
  extern struct layer *flayer___0 ;
  struct layer *oldflayer ;

  {
  {
#line 2891
  oldflayer = flayer___0;
#line 2892
  flayer___0 = & p->w_layer;
#line 2893
  LMsg(err, str);
#line 2894
  flayer___0 = oldflayer;
  }
}
}
#line 2898 "/tmp/screen-3.9.15/ansi.c"
void WChangeSize(struct win *p , int w , int h ) 
{ 
  int wok ;
  struct canvas *cv ;

  {
#line 2902
  wok = 0;
#line 2905
  if (p->w_layer.l_cvlist == (struct canvas *)0) {
    {
#line 2908
    ChangeWindowSize(p, w, h, p->w_histheight);
    }
#line 2909
    return;
  }
#line 2911
  cv = p->w_layer.l_cvlist;
  {
#line 2911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2911
    if (! cv) {
#line 2911
      goto while_break;
    }
#line 2913
    display = cv->c_display;
#line 2914
    if (p != display->d_fore) {
#line 2915
      goto while_continue;
    }
#line 2916
    if (display->d_tcs[44].str) {
#line 2917
      goto while_break;
    }
#line 2918
    if (display->d_tcs[45].str) {
#line 2918
      if (w == Z0width) {
#line 2919
        wok = 1;
      } else
#line 2918
      if (w == Z1width) {
#line 2919
        wok = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2911
  cv = cv->c_lnext;
#line 2921
  if (cv == (struct canvas *)0) {
#line 2921
    if (wok == 0) {
#line 2922
      return;
    }
  }
#line 2923
  if (! display->d_tcs[44].str) {
#line 2924
    h = p->w_layer.l_height;
  }
  {
#line 2925
  ChangeWindowSize(p, w, h, p->w_histheight);
#line 2926
  display = displays;
  }
  {
#line 2926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2926
    if (! display) {
#line 2926
      goto while_break___0;
    }
#line 2928
    if (p == display->d_fore) {
#line 2930
      if (display->d_cvlist) {
#line 2930
        if ((display->d_cvlist)->c_next == (struct canvas *)0) {
          {
#line 2931
          ResizeDisplay(w, h);
          }
        } else {
          {
          {
#line 2933
          ResizeDisplay(w, display->d_height);
          }
          }
        }
      } else {
        {
        {
#line 2933
        ResizeDisplay(w, display->d_height);
        }
        }
      }
      {
#line 2934
      ResizeLayersToCanvases();
      }
#line 2935
      goto while_continue___0;
    }
#line 2937
    cv = display->d_cvlist;
    {
#line 2937
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2937
      if (! cv) {
#line 2937
        goto while_break___1;
      }
#line 2938
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 2939
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2937
    cv = cv->c_next;
#line 2940
    if (cv) {
      {
#line 2941
      Redisplay(0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2926
  display = display->d_next;
}
}
#line 2946 "/tmp/screen-3.9.15/ansi.c"
static int WindowChangedCheck(char *s , int what , int *hp ) 
{ 
  int h ;
  int l ;
  char *__cil_tmp6 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2951
  h = 0;
  {
#line 2953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2953
    if (! *s) {
#line 2953
      goto while_break;
    }
#line 2955
    if (hp) {
#line 2955
      tmp = '%';
    } else {
#line 2955
      tmp = '\005';
    }
#line 2955
    __cil_tmp6 = s;
#line 2955
    s ++;
#line 2955
    if ((int )*__cil_tmp6 != tmp) {
#line 2956
      goto while_continue;
    }
#line 2957
    l = 0;
    {
#line 2958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2958
      if (! ((int )*s >= 48 && (int )*s <= 57)) {
#line 2958
        goto while_break___0;
      }
#line 2959
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2960
    if ((int )*s == 76) {
#line 2962
      s ++;
#line 2963
      l = 256;
    }
#line 2965
    if ((int )*s == 104) {
#line 2966
      h = 1;
    }
#line 2967
    if ((int )*s == what) {
#line 2968
      goto while_break;
    } else
#line 2967
    if (((int )*s | l) == what) {
#line 2968
      goto while_break;
    } else
#line 2967
    if (what == 100) {
#line 2968
      goto while_break;
    }
#line 2969
    if (*s) {
#line 2970
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2972
  if (hp) {
#line 2973
    *hp = h;
  }
#line 2974
  if ((int )*s) {
#line 2974
    tmp___0 = 1;
  } else {
#line 2974
    tmp___0 = 0;
  }
#line 2974
  return (tmp___0);
}
}
#line 2978 "/tmp/screen-3.9.15/ansi.c"
void WindowChanged(struct win *p , int what ) 
{ 
  int inwstr ;
  int inhstr ;
  int inlstr ;
  int inwstrh ;
  int inhstrh ;
  int inlstrh ;
  int got ;
  int ox ;
  int oy ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 2983
  inwstrh = 0;
#line 2983
  inhstrh = 0;
#line 2983
  inlstrh = 0;
#line 2985
  olddisplay = display;
#line 2988
  inhstr = 0;
#line 2988
  inwstr = inhstr;
#line 2990
  if (what == 102) {
    {
#line 2992
    WindowChanged((struct win *)0, 375);
#line 2993
    WindowChanged((struct win *)0, 343);
    }
  }
#line 2996
  if (what) {
    {
#line 2998
    inwstr = WindowChangedCheck(captionstring, what, & inwstrh);
#line 2999
    inhstr = WindowChangedCheck(hstatusstring, what, & inhstrh);
#line 3000
    inlstr = WindowChangedCheck(wliststr, what, & inlstrh);
    }
  } else {
#line 3004
    inhstr = 0;
#line 3004
    inwstr = inhstr;
#line 3005
    inlstr = 1;
  }
#line 3008
  if (p == (struct win *)0) {
#line 3010
    display = displays;
    {
#line 3010
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3010
      if (! display) {
#line 3010
        goto while_break;
      }
#line 3012
      ox = display->d_x;
#line 3013
      oy = display->d_y;
#line 3014
      cv = display->d_cvlist;
      {
#line 3014
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3014
        if (! cv) {
#line 3014
          goto while_break___0;
        }
        {
#line 3016
        __cil_tmp17 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
        }
#line 3016
        if (inlstr) {
          {
          {
#line 3017
          WListUpdatecv(cv, (struct win *)0);
          }
          }
        } else
#line 3016
        if (inlstrh) {
#line 3016
          if (p) {
#line 3016
            if (p->w_hstatus) {
#line 3016
              if ((int )*(p->w_hstatus)) {
#line 3016
                if (__cil_tmp17) {
                  {
                  {
#line 3017
                  WListUpdatecv(cv, (struct win *)0);
                  }
                  }
                }
              }
            }
          }
        }
        {
#line 3018
        p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 3019
        __cil_tmp18 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
        }
#line 3019
        if (inwstr) {
          _L: /* CIL Label */ 
#line 3020
          if (cv->c_ye + 1 < display->d_height) {
            {
#line 3021
            RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
            }
          }
        } else
#line 3019
        if (inwstrh) {
#line 3019
          if (p) {
#line 3019
            if (p->w_hstatus) {
#line 3019
              if ((int )*(p->w_hstatus)) {
#line 3019
                if (__cil_tmp18) {
#line 3019
                  goto _L;
                }
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3014
      cv = cv->c_next;
#line 3023
      p = display->d_fore;
#line 3024
      __cil_tmp19 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
      }
#line 3024
      if (inhstr) {
        {
        {
#line 3025
        RefreshHStatus();
        }
        }
      } else
#line 3024
      if (inhstrh) {
#line 3024
        if (p) {
#line 3024
          if (p->w_hstatus) {
#line 3024
            if ((int )*(p->w_hstatus)) {
#line 3024
              if (__cil_tmp19) {
                {
                {
#line 3025
                RefreshHStatus();
                }
                }
              }
            }
          }
        }
      }
#line 3026
      if (ox != -1) {
#line 3026
        if (ox != -1) {
          {
#line 3027
          GotoPos(ox, oy);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3010
    display = display->d_next;
#line 3029
    display = olddisplay;
#line 3030
    return;
  }
  {
#line 3033
  __cil_tmp20 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
  }
#line 3033
  if (p->w_hstatus) {
#line 3033
    if ((int )*(p->w_hstatus)) {
#line 3033
      if (inwstrh) {
        _L___495: /* CIL Label */ 
#line 3033
        if (__cil_tmp20) {
#line 3035
          inwstr |= inwstrh;
#line 3036
          inhstr |= inhstrh;
#line 3037
          inlstr |= inlstrh;
        }
      } else
#line 3033
      if (inhstrh) {
#line 3033
        goto _L___495;
      } else
#line 3033
      if (inlstrh) {
#line 3033
        goto _L___495;
      }
    }
  }
#line 3039
  if (! inwstr) {
#line 3039
    if (! inhstr) {
#line 3039
      if (! inlstr) {
#line 3040
        return;
      }
    }
  }
#line 3041
  display = displays;
  {
#line 3041
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3041
    if (! display) {
#line 3041
      goto while_break___1;
    }
#line 3043
    got = 0;
#line 3044
    ox = display->d_x;
#line 3045
    oy = display->d_y;
#line 3046
    cv = display->d_cvlist;
    {
#line 3046
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3046
      if (! cv) {
#line 3046
        goto while_break___2;
      }
#line 3048
      if (inlstr) {
        {
#line 3049
        WListUpdatecv(cv, p);
        }
      }
#line 3050
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data != p) {
#line 3051
        goto while_continue___2;
      }
#line 3052
      got = 1;
#line 3053
      if (inwstr) {
#line 3053
        if (cv->c_ye + 1 < display->d_height) {
          {
#line 3054
          RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3046
    cv = cv->c_next;
#line 3056
    if (got) {
#line 3056
      if (inhstr) {
#line 3056
        if (p == display->d_fore) {
          {
#line 3057
          RefreshHStatus();
          }
        }
      }
    }
#line 3058
    if (ox != -1) {
#line 3058
      if (ox != -1) {
        {
#line 3059
        GotoPos(ox, oy);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3041
  display = display->d_next;
#line 3061
  display = olddisplay;
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 119 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 238 "/usr/include/stdio.h"
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 606 "/usr/include/unistd.h"
extern void _exit(int __status ) ;
#line 851
extern char *getlogin(void) ;
#line 880
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len ) ;
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 70 "/usr/include/shadow.h"
extern void endspent(void) ;
#line 113 "/tmp/screen-3.9.15/screen.c"
extern char **environ ;
#line 114 "/tmp/screen-3.9.15/screen.c"
int force_vt  =    1;
#line 135
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) ;
#line 136
static void SigChldHandler(void) ;
#line 137
static void SigChld(int sigsig ) ;
#line 138
static void SigInt(int sigsig ) ;
#line 139
static void CoreDump(int sigsig ) ;
#line 140
static void FinitHandler(int sigsig ) ;
#line 141
static void DoWait(void) ;
#line 142
static void serv_read_fn(struct event *ev , char *data ) ;
#line 143
static void serv_select_fn(struct event *ev , char *data ) ;
#line 144
static void logflush_fn(struct event *ev , char *data ) ;
#line 145
static void backtick_filter(struct backtick *bt ) ;
#line 146
static void backtick_fn(struct event *ev , char *data ) ;
#line 147
static char *runbacktick(struct backtick *bt , int *tickp , time_t now , struct win *win ) ;
#line 148
static int IsSymbol(char *e , char *s ) ;
#line 164 "/tmp/screen-3.9.15/screen.c"
char *SockMatch  =    (char *)((void *)0);
#line 165 "/tmp/screen-3.9.15/screen.c"
int ServerSocket  =    - 1;
#line 167
struct event serv_select ;
#line 170 "/tmp/screen-3.9.15/screen.c"
char **NewEnv  =    (char **)((void *)0);
#line 172 "/tmp/screen-3.9.15/screen.c"
char *RcFileName  =    (char *)((void *)0);
#line 176 "/tmp/screen-3.9.15/screen.c"
int log_flush  =    10;
#line 177 "/tmp/screen-3.9.15/screen.c"
int logtstamp_on  =    0;
#line 179 "/tmp/screen-3.9.15/screen.c"
int logtstamp_after  =    120;
#line 180 "/tmp/screen-3.9.15/screen.c"
char *hardcopydir  =    (char *)((void *)0);
#line 195 "/tmp/screen-3.9.15/screen.c"
int auto_detach  =    1;
#line 197
int cmdflag ;
#line 202
char *multi_home ;
#line 207 "/tmp/screen-3.9.15/screen.c"
int tty_oldmode  =    - 1;
#line 215 "/tmp/screen-3.9.15/screen.c"
char *preselect  =    (char *)((void *)0);
#line 222 "/tmp/screen-3.9.15/screen.c"
int nethackflag  =    0;
#line 225 "/tmp/screen-3.9.15/screen.c"
int maptimeout  =    300000;
#line 227 "/tmp/screen-3.9.15/screen.c"
int maxwin  =    40;
#line 31 "./extern.h"
int main(int ac , char **av ) ;
#line 242 "/tmp/screen-3.9.15/screen.c"
char strnomem[]  =    "Out of memory.";
#line 245
static int InterruptPlease ;
#line 246
static int GotSigChld ;
#line 249 "/tmp/screen-3.9.15/screen.c"
static int lf_secreopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int __cil_tmp6 ;

  {
  {
#line 256
  close(wantfd);
#line 257
  __cil_tmp6 = lf_move_fd(got_fd, wantfd);
  }
  {
#line 257
  got_fd = secopen(name, 1089, 438);
  }
#line 257
  if (got_fd < 0) {
    _L: /* CIL Label */ 
    {
#line 260
    logfclose(l);
    }
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 261
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 262
    return (- 1);
  } else
#line 257
  if (__cil_tmp6 < 0) {
#line 257
    goto _L;
  }
#line 264
  (l->st)->st_dev = (__dev_t )0;
#line 264
  (l->st)->st_ino = (l->st)->st_dev;
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return (0);
}
}
#line 275 "/tmp/screen-3.9.15/screen.c"
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) 
{ 
  int n ;
  struct spwd *sss ;
  static char *spw ;
  int __cil_tmp7 ;
  char c ;
  size_t __cil_tmp12 ;

  {
  {
#line 281
  sss = (struct spwd *)((void *)0);
#line 282
  spw = (char *)((void *)0);
#line 285
  ppp___0 = getpwnam((char const   *)name);
  }
#line 285
  if (! ppp___0) {
#line 285
    if (! ppp___0) {
#line 286
      return ((struct passwd *)((void *)0));
    }
  }
  pw_try_again: 
#line 292
  n = 0;
  {
#line 293
  __cil_tmp7 = strcmp((char const   *)(ppp___0->pw_passwd + 2), (char const   *)ppp___0->pw_name);
  }
#line 293
  if ((int )*(ppp___0->pw_passwd + 0) == 35) {
#line 293
    if ((int )*(ppp___0->pw_passwd + 1) == 35) {
#line 293
      if (__cil_tmp7 == 0) {
#line 295
        n = 13;
      }
    }
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (n < 13)) {
#line 296
      goto while_break;
    }
#line 298
    c = *(ppp___0->pw_passwd + n);
#line 299
    if (! ((((((int )c == 46 || (int )c == 47) || (int )c == 36) || ((int )c >= 48 && (int )c <= 57)) || ((int )c >= 97 && (int )c <= 122)) || ((int )c >= 65 && (int )c <= 90))) {
#line 303
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  n ++;
#line 308
  if (n < 13) {
#line 308
    if (sss == (struct spwd *)0) {
      {
#line 310
      sss = getspnam((char const   *)ppp___0->pw_name);
      }
#line 311
      if (sss) {
#line 313
        if (spw) {
          {
#line 314
          free((void *)spw);
          }
        }
        {
#line 315
        ppp___0->pw_passwd = SaveStr((char const   *)sss->sp_pwdp);
#line 316
        endspent();
        }
#line 317
        goto pw_try_again;
      }
      {
#line 319
      endspent();
      }
    }
  }
#line 322
  if (n < 13) {
#line 323
    ppp___0->pw_passwd = (char *)0;
  }
  {
#line 325
  __cil_tmp12 = strlen((char const   *)ppp___0->pw_passwd);
  }
#line 325
  if (ppp___0->pw_passwd) {
#line 325
    if (__cil_tmp12 == 24UL) {
#line 326
      *(ppp___0->pw_passwd + 13) = (char )0;
    }
  }
#line 329
  return (ppp___0);
}
}
#line 334 "/tmp/screen-3.9.15/screen.c"
int main(int ac , char **av ) 
{ 
  register int n ;
  char *ap ;
  char *av0 ;
  char socknamebuf[512] ;
  int mflag ;
  char *myname ;
  char *tmp ;
  char *SockDir ;
  struct stat st ;
  int oumask ;
  struct NewWindow nwin ;
  int detached ;
  char *sockp ;
  int tmp___497 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  size_t __cil_tmp44 ;
  int __cil_tmp45 ;
  int tmp___498 ;
  int __cil_tmp47 ;
  char *__cil_tmp48 ;
  int tmp___499 ;
  __uid_t __cil_tmp50 ;
  __gid_t __cil_tmp51 ;
  __uid_t __cil_tmp52 ;
  __gid_t __cil_tmp53 ;
  char *__cil_tmp54 ;
  int __cil_tmp55 ;
  size_t __cil_tmp56 ;
  register char *sh ;
  char *tmp___500 ;
  char *__cil_tmp60 ;
  char *__cil_tmp62 ;
  char nethackrc[4096] ;
  size_t __cil_tmp64 ;
  int __cil_tmp65 ;
  struct passwd *mppp ;
  size_t __cil_tmp70 ;
  size_t __cil_tmp76 ;
  size_t __cil_tmp77 ;
  size_t __cil_tmp78 ;
  size_t __cil_tmp80 ;
  int __cil_tmp81 ;
  int *__cil_tmp82 ;
  size_t __cil_tmp85 ;
  __mode_t __cil_tmp86 ;
  int *__cil_tmp87 ;
  size_t __cil_tmp89 ;
  char *tmp___501 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  char *tmp___502 ;
  int __cil_tmp96 ;
  int tmp___503 ;
  int tmp___504 ;
  int __cil_tmp99 ;
  int *__cil_tmp100 ;
  int tmp___505 ;
  int tmp___506 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int *__cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int *__cil_tmp108 ;
  char *__cil_tmp109 ;
  size_t __cil_tmp110 ;
  __mode_t __cil_tmp111 ;
  int __cil_tmp112 ;
  int i ;
  int fo ;
  int oth ;
  int tmp___507 ;
  int tmp___508 ;
  char *tmp___509 ;
  char *sty ;
  size_t __cil_tmp123 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  char *tmp___510 ;
  register char *sty___0 ;
  int *__cil_tmp131 ;
  char *__cil_tmp132 ;
  size_t __cil_tmp134 ;
  size_t __cil_tmp135 ;
  size_t __cil_tmp136 ;
  int __cil_tmp137 ;
  char *__cil_tmp138 ;
  int __cil_tmp140 ;
  __pid_t __cil_tmp141 ;
  struct display *__cil_tmp142 ;
  int tmp___511 ;
  __pid_t __cil_tmp144 ;
  __pid_t __cil_tmp145 ;
  char *__cil_tmp146 ;
  size_t __cil_tmp148 ;
  size_t __cil_tmp149 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  int *__cil_tmp154 ;
  int __cil_tmp156 ;

  {
#line 342
  mflag = 0;
#line 343
  if (ac == 0) {
#line 343
    tmp = (char *)"screen";
  } else {
#line 343
    tmp = *(av + 0);
  }
  {
#line 343
  myname = tmp;
#line 355
  detached = 0;
#line 376
  closeallfiles(0);
#line 380
  sprintf((char *)version, (char const   *)((char *)"%d.%.2d.%.2d%s (%s) %s"), 3,
          9, 15, (char *)"", (char *)"FAU", (char *)"13-Mar-03");
#line 382
  nversion = 30915;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 388
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 397
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 397
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 403
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 403
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 412
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 412
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 415
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 415
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 418
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 418
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 421
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 421
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 424
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 424
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 427
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 427
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 430
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 430
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 433
  BellString = SaveStr((char const   *)((char *)"Bell in window %n"));
#line 434
  VisualBellString = SaveStr((char const   *)((char *)"   Wuff,  Wuff!!  "));
#line 435
  ActivityString = SaveStr((char const   *)((char *)"Activity in window %n"));
#line 436
  screenlogfile = SaveStr((char const   *)((char *)"screenlog.%n"));
#line 437
  logtstamp_string = SaveStr((char const   *)((char *)"-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\n"));
#line 438
  hstatusstring = SaveStr((char const   *)((char *)"%h"));
#line 439
  captionstring = SaveStr((char const   *)((char *)"%3n %t"));
#line 440
  timestring = SaveStr((char const   *)((char *)"%c:%s %M %d %H%? %l%?"));
#line 441
  wlisttit = SaveStr((char const   *)((char *)"Num Name%=Flags"));
#line 442
  wliststr = SaveStr((char const   *)((char *)"%3n %t%=%f"));
#line 444
  BufferFile = SaveStr((char const   *)((char *)"/tmp/screen-exchange"));
#line 446
  ShellProg = (char *)((void *)0);
#line 448
  PowDetachString = (char *)0;
  }
#line 450
  if (ac > 1) {
#line 450
    tmp___497 = 0;
  } else {
#line 450
    tmp___497 = 1;
  }
  {
#line 450
  default_startup = tmp___497;
#line 451
  adaptflag = 0;
#line 452
  VBellWait = 1;
#line 453
  MsgWait = 5;
#line 454
  MsgMinWait = 1;
#line 455
  SilenceWait = 30;
#line 461
  CompileKeys((char *)((void *)0), (unsigned char *)mark_key_tab);
#line 464
  InitBuiltinTabs();
#line 465
  screenencodings = SaveStr((char const   *)((char *)"./share/screen/utf8encodings"));
#line 467
  nwin = nwin_undef;
#line 468
  nwin_options = nwin_undef;
#line 469
  strcpy((char *)screenterm, (char const   *)((char *)"screen"));
#line 471
  logreopen_register((int (*)(char * , int  , struct logfile * ))lf_secreopen);
#line 473
  av0 = *av;
  }
#line 475
  if ((int )*av0 == 45) {
    {
#line 477
    rflag = 4;
#line 479
    xflag = 1;
#line 483
    ShellProg = SaveStr((char const   *)((char *)DefaultShell));
    }
  }
  {
#line 485
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 485
    if (! (ac > 0)) {
#line 485
      goto while_break___12;
    }
#line 487
    av ++;
#line 487
    ap = *av;
#line 488
    ac --;
#line 488
    if (ac > 0) {
#line 488
      if ((int )*ap == 45) {
#line 490
        if ((int )*(ap + 1) == 45) {
#line 490
          if ((int )*(ap + 2) == 0) {
#line 492
            av ++;
#line 493
            __cil_tmp31 = ac;
#line 493
            ac --;
#line 494
            goto while_break___12;
          }
        }
        {
#line 496
        __cil_tmp32 = strcmp((char const   *)ap, (char const   *)((char *)"--version"));
        }
#line 496
        if ((int )*(ap + 1) == 45) {
#line 496
          if (! __cil_tmp32) {
            {
#line 497
            Panic(0, (char *)"Screen version %s", (char *)version);
            }
          }
        }
        {
#line 498
        __cil_tmp33 = strcmp((char const   *)ap, (char const   *)((char *)"--help"));
        }
#line 498
        if ((int )*(ap + 1) == 45) {
#line 498
          if (! __cil_tmp33) {
            {
#line 499
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
        }
        {
#line 500
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 500
          if (! ((ap && (int )*ap) && (int )*ap)) {
#line 500
            goto while_break___13;
          }
          {
#line 504
          if ((int )*ap == 'a') {
#line 504
            goto case_97;
          }
#line 507
          if ((int )*ap == 'A') {
#line 507
            goto case_65;
          }
#line 510
          if ((int )*ap == 'p') {
#line 510
            goto case_112;
          }
#line 526
          if ((int )*ap == 'c') {
#line 526
            goto case_99;
          }
#line 537
          if ((int )*ap == 'e') {
#line 537
            goto case_101;
          }
#line 548
          if ((int )*ap == 'f') {
#line 548
            goto case_102;
          }
#line 553
          if ((int )*ap == '0') {
#line 553
            goto case_48;
          }
#line 553
          if ((int )*ap == 'n') {
#line 553
            goto case_48;
          }
#line 556
          if ((int )*ap == '\000') {
#line 556
            goto case_0;
          }
#line 560
          if ((int )*ap == '1') {
#line 560
            goto case_49;
          }
#line 560
          if ((int )*ap == 'y') {
#line 560
            goto case_49;
          }
#line 563
          if ((int )*ap == 'a') {
#line 563
            goto case_97___0;
          }
#line 570
          if ((int )*ap == 'h') {
#line 570
            goto case_104;
          }
#line 577
          if ((int )*ap == 'i') {
#line 577
            goto case_105;
          }
#line 580
          if ((int )*ap == 't') {
#line 580
            goto case_116;
          }
#line 585
          if ((int )*ap == 'l') {
#line 585
            goto case_108;
          }
#line 590
          if ((int )*ap == '0') {
#line 590
            goto case_48___0;
          }
#line 590
          if ((int )*ap == 'n') {
#line 590
            goto case_48___0;
          }
#line 593
          if ((int )*ap == '\000') {
#line 593
            goto case_0___0;
          }
#line 597
          if ((int )*ap == '1') {
#line 597
            goto case_49___0;
          }
#line 597
          if ((int )*ap == 'y') {
#line 597
            goto case_49___0;
          }
#line 600
          if ((int )*ap == 'a') {
#line 600
            goto case_97___1;
          }
#line 604
          if ((int )*ap == 'i') {
#line 604
            goto case_105___0;
          }
#line 604
          if ((int )*ap == 's') {
#line 604
            goto case_105___0;
          }
#line 617
          if ((int )*ap == 'w') {
#line 617
            goto case_119;
          }
#line 626
          if ((int )*ap == 'L') {
#line 626
            goto case_76;
          }
#line 629
          if ((int )*ap == 'm') {
#line 629
            goto case_109;
          }
#line 632
          if ((int )*ap == 'O') {
#line 632
            goto case_79;
          }
#line 635
          if ((int )*ap == 'T') {
#line 635
            goto case_84;
          }
#line 644
          if ((int )*ap == 'q') {
#line 644
            goto case_113;
          }
#line 650
          if ((int )*ap == 'x') {
#line 650
            goto case_120;
          }
#line 650
          if ((int )*ap == 'R') {
#line 650
            goto case_120;
          }
#line 650
          if ((int )*ap == 'r') {
#line 650
            goto case_120;
          }
#line 667
          if ((int )*ap == 'd') {
#line 667
            goto case_100;
          }
#line 670
          if ((int )*ap == 'D') {
#line 670
            goto case_68;
          }
#line 684
          if ((int )*ap == 's') {
#line 684
            goto case_115___0;
          }
#line 692
          if ((int )*ap == 'S') {
#line 692
            goto case_83;
          }
#line 702
          if ((int )*ap == 'X') {
#line 702
            goto case_88;
          }
#line 705
          if ((int )*ap == 'v') {
#line 705
            goto case_118;
          }
#line 709
          if ((int )*ap == 'U') {
#line 709
            goto case_85;
          }
#line 713
          goto switch_default___1;
          case_97: /* CIL Label */ 
#line 505
          nwin_options.aflag = 1;
#line 506
          goto switch_break;
          case_65: /* CIL Label */ 
#line 508
          adaptflag = 1;
#line 509
          goto switch_break;
          case_112: /* CIL Label */ 
#line 511
          ap ++;
#line 511
          if (*ap) {
#line 512
            preselect = ap;
          } else {
#line 515
            ac --;
#line 515
            if (! ac) {
              {
#line 516
              exit_with_usage(myname, (char *)"Specify a window to preselect with -p",
                              (char *)((void *)0));
              }
            }
#line 517
            av ++;
#line 517
            preselect = *av;
          }
#line 519
          ap = (char *)((void *)0);
#line 520
          goto switch_break;
          case_99: /* CIL Label */ 
#line 527
          ap ++;
#line 527
          if (*ap) {
#line 528
            RcFileName = ap;
          } else {
#line 531
            ac --;
#line 531
            if (ac == 0) {
              {
#line 532
              exit_with_usage(myname, (char *)"Specify an alternate rc-filename with -c",
                              (char *)((void *)0));
              }
            }
#line 533
            av ++;
#line 533
            RcFileName = *av;
          }
#line 535
          ap = (char *)((void *)0);
#line 536
          goto switch_break;
          case_101: /* CIL Label */ 
#line 538
          ap ++;
#line 538
          if (! *ap) {
#line 540
            ac --;
#line 540
            if (ac == 0) {
              {
#line 541
              exit_with_usage(myname, (char *)"Specify command characters with -e",
                              (char *)((void *)0));
              }
            }
#line 542
            av ++;
#line 542
            ap = *av;
          }
          {
#line 544
          __cil_tmp34 = ParseEscape((struct acluser *)((void *)0), ap);
          }
#line 544
          if (__cil_tmp34) {
            {
#line 545
            Panic(0, (char *)"Two characters are required with -e option, not \'%s\'.",
                  ap);
            }
          }
#line 546
          ap = (char *)((void *)0);
#line 547
          goto switch_break;
          case_102: /* CIL Label */ 
#line 549
          ap ++;
#line 550
          __cil_tmp36 = ap;
#line 550
          ap ++;
          {
#line 553
          if ((int )*__cil_tmp36 == '0') {
#line 553
            goto case_48;
          }
#line 553
          if ((int )*__cil_tmp36 == 'n') {
#line 553
            goto case_48;
          }
#line 556
          if ((int )*__cil_tmp36 == '\000') {
#line 556
            goto case_0;
          }
#line 560
          if ((int )*__cil_tmp36 == '1') {
#line 560
            goto case_49;
          }
#line 560
          if ((int )*__cil_tmp36 == 'y') {
#line 560
            goto case_49;
          }
#line 563
          if ((int )*__cil_tmp36 == 'a') {
#line 563
            goto case_97___0;
          }
#line 566
          goto switch_default;
          case_48: /* CIL Label */ 
          case_110: /* CIL Label */ 
#line 554
          nwin_options.flowflag = 0;
#line 555
          goto switch_break___0;
          case_0: /* CIL Label */ 
#line 557
          __cil_tmp37 = ap;
#line 557
          ap --;
          case_49: /* CIL Label */ 
          case_121: /* CIL Label */ 
#line 561
          nwin_options.flowflag = 1;
#line 562
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
#line 564
          nwin_options.flowflag = 1 << 2;
#line 565
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 567
          ap --;
#line 567
          exit_with_usage(myname, (char *)"Unknown flow option -%s", ap);
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 569
          goto switch_break;
          case_104: /* CIL Label */ 
#line 571
          ac --;
#line 571
          if (ac == 0) {
            {
#line 572
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
          {
#line 573
          av ++;
#line 573
          __cil_tmp38 = atoi((char const   *)*av);
#line 573
          nwin_options.histheight = __cil_tmp38;
          }
#line 574
          if (nwin_options.histheight < 0) {
            {
#line 575
            exit_with_usage(myname, (char *)"-h: %s: negative scrollback size?", *av);
            }
          }
#line 576
          goto switch_break;
          case_105: /* CIL Label */ 
#line 578
          iflag = 1;
#line 579
          goto switch_break;
          case_116: /* CIL Label */ 
#line 581
          ac --;
#line 581
          if (ac == 0) {
            {
#line 582
            exit_with_usage(myname, (char *)"Specify a new window-name with -t", (char *)((void *)0));
            }
          }
#line 583
          av ++;
#line 583
          nwin_options.aka = *av;
#line 584
          goto switch_break;
          case_108: /* CIL Label */ 
#line 586
          ap ++;
#line 587
          __cil_tmp40 = ap;
#line 587
          ap ++;
          {
#line 590
          if ((int )*__cil_tmp40 == '0') {
#line 590
            goto case_48___0;
          }
#line 590
          if ((int )*__cil_tmp40 == 'n') {
#line 590
            goto case_48___0;
          }
#line 593
          if ((int )*__cil_tmp40 == '\000') {
#line 593
            goto case_0___0;
          }
#line 597
          if ((int )*__cil_tmp40 == '1') {
#line 597
            goto case_49___0;
          }
#line 597
          if ((int )*__cil_tmp40 == 'y') {
#line 597
            goto case_49___0;
          }
#line 600
          if ((int )*__cil_tmp40 == 'a') {
#line 600
            goto case_97___1;
          }
#line 604
          if ((int )*__cil_tmp40 == 'i') {
#line 604
            goto case_105___0;
          }
#line 604
          if ((int )*__cil_tmp40 == 's') {
#line 604
            goto case_105___0;
          }
#line 613
          goto switch_default___0;
          case_48___0: /* CIL Label */ 
          case_110___0: /* CIL Label */ 
#line 591
          nwin_options.lflag = 0;
#line 592
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 594
          __cil_tmp41 = ap;
#line 594
          ap --;
          case_49___0: /* CIL Label */ 
          case_121___0: /* CIL Label */ 
#line 598
          nwin_options.lflag = 1;
#line 599
          goto switch_break___1;
          case_97___1: /* CIL Label */ 
#line 601
          nwin_options.lflag = 3;
#line 602
          goto switch_break___1;
          case_105___0: /* CIL Label */ 
          case_115: /* CIL Label */ 
#line 605
          lsflag = 1;
#line 606
          if (ac > 1) {
#line 606
            if (! SockMatch) {
#line 608
              av ++;
#line 608
              SockMatch = *av;
#line 609
              __cil_tmp42 = ac;
#line 609
              ac --;
            }
          }
#line 611
          ap = (char *)((void *)0);
#line 612
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
          {
#line 614
          ap --;
#line 614
          exit_with_usage(myname, (char *)"%s: Unknown suboption to -l", ap);
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 616
          goto switch_break;
          case_119: /* CIL Label */ 
#line 618
          lsflag = 1;
#line 619
          wipeflag = 1;
#line 620
          if (ac > 1) {
#line 620
            if (! SockMatch) {
#line 622
              av ++;
#line 622
              SockMatch = *av;
#line 623
              __cil_tmp43 = ac;
#line 623
              ac --;
            }
          }
#line 625
          goto switch_break;
          case_76: /* CIL Label */ 
#line 627
          nwin_options.Lflag = 1;
#line 628
          goto switch_break;
          case_109: /* CIL Label */ 
#line 630
          mflag = 1;
#line 631
          goto switch_break;
          case_79: /* CIL Label */ 
#line 633
          force_vt = 0;
#line 634
          goto switch_break;
          case_84: /* CIL Label */ 
#line 636
          ac --;
#line 636
          if (ac == 0) {
            {
#line 637
            exit_with_usage(myname, (char *)"Specify terminal-type with -T", (char *)((void *)0));
            }
          }
          {
#line 638
          av ++;
#line 638
          __cil_tmp44 = strlen((char const   *)*av);
          }
#line 638
          if (__cil_tmp44 < 20UL) {
            {
#line 639
            strcpy((char *)screenterm, (char const   *)*av);
            }
          } else {
            {
#line 641
            Panic(0, (char *)"-T: terminal name too long. (max. 20 char)");
            }
          }
#line 642
          nwin_options.term = (char *)screenterm;
#line 643
          goto switch_break;
          case_113: /* CIL Label */ 
#line 645
          quietflag = 1;
#line 646
          goto switch_break;
          case_120: /* CIL Label */ 
          case_82: /* CIL Label */ 
          case_114: /* CIL Label */ 
#line 652
          if (ac > 1) {
#line 652
            if ((int )*(*(av + 1)) != 45) {
#line 652
              if (! SockMatch) {
#line 654
                av ++;
#line 654
                SockMatch = *av;
#line 655
                __cil_tmp45 = ac;
#line 655
                ac --;
                {
#line 656
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 656
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
            }
          }
#line 659
          if ((int )*ap == 120) {
#line 660
            xflag = 1;
          }
#line 662
          if (rflag) {
#line 663
            rflag = 2;
          }
#line 664
          if ((int )*ap == 82) {
#line 664
            tmp___498 = 2;
          } else {
#line 664
            tmp___498 = 1;
          }
#line 664
          rflag += tmp___498;
#line 665
          goto switch_break;
          case_100: /* CIL Label */ 
#line 668
          dflag = 1;
          case_68: /* CIL Label */ 
#line 671
          if (! dflag) {
#line 672
            dflag = 2;
          }
#line 673
          if (ac == 2) {
#line 675
            if ((int )*(*(av + 1)) != 45) {
#line 675
              if (! SockMatch) {
#line 677
                av ++;
#line 677
                SockMatch = *av;
#line 678
                __cil_tmp47 = ac;
#line 678
                ac --;
                {
#line 679
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 679
                  goto while_break___15;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
            }
          }
#line 682
          goto switch_break;
          case_115___0: /* CIL Label */ 
#line 685
          ac --;
#line 685
          if (ac == 0) {
            {
#line 686
            exit_with_usage(myname, (char *)"Specify shell with -s", (char *)((void *)0));
            }
          }
#line 687
          if (ShellProg) {
            {
#line 688
            free((void *)ShellProg);
            }
          }
          {
#line 689
          av ++;
#line 689
          __cil_tmp48 = SaveStr((char const   *)*av);
#line 689
          ShellProg = __cil_tmp48;
          }
          {
#line 690
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 690
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 691
          goto switch_break;
          case_83: /* CIL Label */ 
#line 693
          if (! SockMatch) {
#line 695
            ac --;
#line 695
            if (ac == 0) {
              {
#line 696
              exit_with_usage(myname, (char *)"Specify session-name with -S", (char *)((void *)0));
              }
            }
#line 697
            av ++;
#line 697
            SockMatch = *av;
          }
#line 699
          if (! *SockMatch) {
            {
#line 700
            exit_with_usage(myname, (char *)"Empty session-name?", (char *)((void *)0));
            }
          }
#line 701
          goto switch_break;
          case_88: /* CIL Label */ 
#line 703
          cmdflag = 1;
#line 704
          goto switch_break;
          case_118: /* CIL Label */ 
          {
#line 706
          Panic(0, (char *)"Screen version %s", (char *)version);
          }
          case_85: /* CIL Label */ 
#line 710
          if (nwin_options.encoding == -1) {
#line 710
            tmp___499 = 8;
          } else {
#line 710
            tmp___499 = 0;
          }
#line 710
          nwin_options.encoding = tmp___499;
#line 711
          goto switch_break;
          switch_default___1: /* CIL Label */ 
          {
#line 714
          ap --;
#line 714
          exit_with_usage(myname, (char *)"Unknown option %s", ap);
          }
          switch_break: /* CIL Label */ ;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
      } else {
#line 719
        goto while_break___12;
      }
    } else {
#line 719
      goto while_break___12;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 722
  __cil_tmp50 = getuid();
#line 722
  real_uid = (int )__cil_tmp50;
#line 723
  __cil_tmp51 = getgid();
#line 723
  real_gid = (int )__cil_tmp51;
#line 724
  __cil_tmp52 = geteuid();
#line 724
  eff_uid = (int )__cil_tmp52;
#line 725
  __cil_tmp53 = getegid();
#line 725
  eff_gid = (int )__cil_tmp53;
  }
#line 726
  if (eff_uid != real_uid) {
    {
#line 733
    xsignal(7, CoreDump);
#line 735
    xsignal(11, CoreDump);
    }
  }
  {
#line 739
  setlocale(6, (char const   *)((char *)""));
  }
#line 742
  if (nwin_options.encoding == -1) {
    {
#line 749
    __cil_tmp54 = nl_langinfo(14);
#line 749
    __cil_tmp55 = FindEncoding(__cil_tmp54);
#line 749
    nwin_options.encoding = __cil_tmp55;
    }
    {
#line 750
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 750
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
  {
#line 762
  __cil_tmp56 = strlen((char const   *)SockMatch);
  }
#line 762
  if (SockMatch) {
#line 762
    if (__cil_tmp56 >= 256UL) {
      {
#line 763
      Panic(0, (char *)"Ridiculously long socketname - try again.");
      }
    }
  }
#line 764
  if (cmdflag) {
#line 764
    if (! rflag) {
#line 764
      if (! dflag) {
#line 764
        if (! xflag) {
#line 765
          xflag = 1;
        }
      }
    }
  }
#line 766
  if (! cmdflag) {
#line 766
    if (dflag) {
#line 766
      if (mflag) {
#line 766
        if (! (rflag || xflag)) {
#line 767
          detached = 1;
        }
      }
    }
  }
#line 768
  nwin = nwin_options;
#line 770
  nwin.encoding = nwin_undef.encoding;
#line 772
  if (ac) {
#line 773
    nwin.args = av;
  }
  {
#line 786
  xsignal(25, (__sighandler_t )1);
#line 790
  xsignal(13, (__sighandler_t )1);
  }
#line 793
  if (! ShellProg) {
    {
#line 797
    sh = getenv((char const   *)((char *)"SHELL"));
    }
#line 798
    if (sh) {
#line 798
      tmp___500 = sh;
    } else {
#line 798
      tmp___500 = (char *)DefaultShell;
    }
    {
#line 798
    __cil_tmp60 = SaveStr((char const   *)tmp___500);
#line 798
    ShellProg = __cil_tmp60;
    }
  }
  {
#line 800
  ShellArgs[0] = ShellProg;
#line 801
  home = getenv((char const   *)((char *)"HOME"));
#line 804
  __cil_tmp62 = getenv((char const   *)((char *)"NETHACKOPTIONS"));
#line 804
  nethackflag = __cil_tmp62 != (char *)((void *)0);
  }
#line 804
  if (! nethackflag) {
    {
#line 808
    __cil_tmp64 = strlen((char const   *)home);
    }
#line 808
    if (home) {
#line 808
      if (__cil_tmp64 < 4076UL) {
        {
#line 810
        sprintf((char *)nethackrc, (char const   *)((char *)"%s/.nethackrc"), home);
#line 811
        __cil_tmp65 = access((char const   *)((char *)nethackrc), 0);
#line 811
        nethackflag = ! __cil_tmp65;
        }
      }
    }
  }
  {
#line 817
  multi_uid = real_uid;
#line 817
  own_uid = multi_uid;
#line 818
  sockp = index((char const   *)SockMatch, '/');
  }
#line 818
  if (SockMatch) {
#line 818
    if (sockp) {
#line 820
      if (eff_uid) {
        {
#line 821
        Panic(0, (char *)"Must run suid root for multiuser support.");
        }
      }
#line 822
      *sockp = (char )0;
#line 823
      multi = SockMatch;
#line 824
      SockMatch = sockp + 1;
#line 825
      if (*multi) {
        {
#line 828
        mppp = getpwnam((char const   *)multi);
        }
#line 828
        if (mppp == (struct passwd *)0) {
          {
#line 829
          Panic(0, (char *)"Cannot identify account \'%s\'.", multi);
          }
        }
        {
#line 830
        multi_uid = (int )mppp->pw_uid;
#line 831
        multi_home = SaveStr((char const   *)mppp->pw_dir);
#line 832
        __cil_tmp70 = strlen((char const   *)multi_home);
        }
#line 832
        if (__cil_tmp70 > 4086UL) {
          {
#line 833
          Panic(0, (char *)"home directory path too long");
          }
        }
#line 836
        if (rflag) {
#line 837
          xflag = 1;
        } else
#line 836
        if (lsflag) {
#line 837
          xflag = 1;
        }
#line 839
        detached = 0;
#line 840
        multiattach = 1;
      }
    }
  }
#line 843
  if (SockMatch) {
#line 843
    if ((int )*SockMatch == 0) {
#line 844
      SockMatch = (char *)0;
    }
  }
  {
#line 847
  LoginName = getlogin();
  }
#line 847
  if (LoginName) {
#line 847
    if ((int )*(LoginName + 0) != 0) {
      {
#line 849
      ppp = getpwnam((char const   *)LoginName);
      }
#line 849
      if (ppp != (struct passwd *)0) {
#line 850
        if (ppp->pw_uid != (unsigned int )real_uid) {
#line 851
          ppp = (struct passwd *)0;
        }
      }
    }
  }
#line 853
  if (ppp == (struct passwd *)0) {
    {
#line 855
    ppp = getpwuid((__uid_t )real_uid);
    }
#line 855
    if (ppp == (struct passwd *)0) {
      {
#line 857
      Panic(0, (char *)"getpwuid() can\'t identify your account!");
#line 858
      exit(1);
      }
    }
#line 860
    LoginName = ppp->pw_name;
  }
  {
#line 862
  LoginName = SaveStr((char const   *)LoginName);
#line 864
  ppp = getpwbyname(LoginName, ppp);
  }
#line 874
  if (home == (char *)0) {
#line 875
    home = ppp->pw_dir;
  } else
#line 874
  if ((int )*home == 0) {
#line 875
    home = ppp->pw_dir;
  }
  {
#line 876
  __cil_tmp76 = strlen((char const   *)LoginName);
  }
#line 876
  if (__cil_tmp76 > 20UL) {
    {
#line 877
    Panic(0, (char *)"LoginName too long - sorry.");
    }
  }
  {
#line 879
  __cil_tmp77 = strlen((char const   *)multi);
  }
#line 879
  if (multi) {
#line 879
    if (__cil_tmp77 > 20UL) {
      {
#line 880
      Panic(0, (char *)"Screen owner name too long - sorry.");
      }
    }
  }
  {
#line 882
  __cil_tmp78 = strlen((char const   *)home);
  }
#line 882
  if (__cil_tmp78 > 4071UL) {
    {
#line 883
    Panic(0, (char *)"$HOME too long - sorry.");
    }
  }
#line 885
  attach_tty = (char *)"";
#line 886
  if (! detached) {
#line 886
    if (! lsflag) {
#line 886
      if (! cmdflag) {
#line 886
        if (! (((dflag && ! mflag) && ! rflag) && ! xflag)) {
          {
#line 889
          attach_tty = ttyname(0);
          }
#line 889
          if (! attach_tty) {
            {
#line 890
            Panic(0, (char *)"Must be connected to a terminal.");
            }
          }
          {
#line 891
          __cil_tmp80 = strlen((char const   *)attach_tty);
          }
#line 891
          if (__cil_tmp80 >= 4096UL) {
            {
#line 892
            Panic(0, (char *)"TtyName too long - sorry.");
            }
          }
          {
#line 893
          __cil_tmp81 = stat((char const   *)attach_tty, & st);
          }
#line 893
          if (__cil_tmp81) {
            {
#line 894
            __cil_tmp82 = __errno_location();
#line 894
            Panic(*__cil_tmp82, (char *)"Cannot access \'%s\'", attach_tty);
            }
          }
          {
#line 896
          tty_mode = (int )st.st_mode & 511;
#line 898
          n = secopen(attach_tty, 2050, 0);
          }
#line 898
          if (n < 0) {
            {
#line 899
            Panic(0, (char *)"Cannot open your terminal \'%s\' - please check.", attach_tty);
            }
          }
          {
#line 900
          close(n);
          }
          {
#line 901
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 901
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
          {
#line 902
          attach_term = getenv((char const   *)((char *)"TERM"));
          }
#line 902
          if (attach_term == (char *)0) {
            {
            {
#line 903
            Panic(0, (char *)"Please set a terminal type.");
            }
            }
          } else
#line 902
          if ((int )*attach_term == 0) {
            {
            {
#line 903
            Panic(0, (char *)"Please set a terminal type.");
            }
            }
          }
          {
#line 904
          __cil_tmp85 = strlen((char const   *)attach_term);
          }
#line 904
          if (__cil_tmp85 > sizeof(display->d_termname) - 1UL) {
            {
#line 905
            Panic(0, (char *)"$TERM too long - sorry.");
            }
          }
          {
#line 906
          GetTTY(0, & attach_Mode);
          }
        }
      }
    }
  }
  {
#line 915
  __cil_tmp86 = umask((__mode_t )0);
#line 915
  oumask = (int )__cil_tmp86;
  }
#line 915
  if (oumask == -1) {
    {
#line 916
    __cil_tmp87 = __errno_location();
#line 916
    Panic(*__cil_tmp87, (char *)"Cannot change umask to zero");
    }
  }
  {
#line 918
  SockDir = getenv((char const   *)((char *)"SCREENDIR"));
  }
#line 919
  if (SockDir) {
    {
#line 921
    __cil_tmp89 = strlen((char const   *)SockDir);
    }
#line 921
    if (__cil_tmp89 >= 4095UL) {
      {
#line 922
      Panic(0, (char *)"Ridiculously long $SCREENDIR - try again.");
      }
    }
#line 924
    if (multi) {
      {
#line 925
      Panic(0, (char *)"No $SCREENDIR with multi screens, please.");
      }
    }
  }
#line 929
  if (multiattach) {
#line 935
    if (eff_uid) {
#line 935
      tmp___501 = (char *)"/tmp/uscreens";
    } else {
#line 935
      tmp___501 = (char *)"/tmp/screens";
    }
    {
#line 935
    SockDir = tmp___501;
#line 936
    sprintf((char *)SockPath, (char const   *)((char *)"%s/S-%s"), SockDir, multi);
    }
  } else
#line 949
  if (SockDir) {
    {
#line 951
    __cil_tmp91 = access((char const   *)SockDir, 0);
    }
#line 951
    if (__cil_tmp91) {
      {
#line 953
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 953
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 954
      __cil_tmp92 = UserContext();
      }
#line 954
      if (__cil_tmp92 > 0) {
        {
#line 956
        __cil_tmp93 = mkdir((char const   *)SockDir, (__mode_t )448);
        }
#line 956
        if (__cil_tmp93) {
          {
#line 957
          UserReturn(0);
          }
        }
        {
#line 958
        UserReturn(1);
        }
      }
      {
#line 960
      __cil_tmp94 = UserStatus();
      }
#line 960
      if (__cil_tmp94 <= 0) {
        {
#line 961
        Panic(0, (char *)"Cannot make directory \'%s\'.", SockDir);
        }
      }
    }
#line 963
    if (SockDir != (char *)SockPath) {
      {
#line 964
      strcpy((char *)SockPath, (char const   *)SockDir);
      }
    }
  } else {
#line 969
    if (eff_uid) {
#line 969
      tmp___502 = (char *)"/tmp/uscreens";
    } else {
#line 969
      tmp___502 = (char *)"/tmp/screens";
    }
    {
#line 969
    SockDir = tmp___502;
#line 970
    __cil_tmp96 = lstat((char const   *)SockDir, & st);
    }
#line 970
    if (__cil_tmp96) {
#line 972
      if (eff_uid == 0 && (real_uid || eff_gid == real_gid)) {
#line 972
        tmp___504 = 493;
      } else {
#line 972
        if (eff_gid != real_gid) {
#line 972
          tmp___503 = 509;
        } else {
#line 972
          tmp___503 = 1023;
        }
#line 972
        tmp___504 = tmp___503;
      }
      {
#line 972
      n = tmp___504;
#line 979
      __cil_tmp99 = mkdir((char const   *)SockDir, (__mode_t )n);
      }
#line 979
      if (__cil_tmp99 == -1) {
        {
#line 980
        __cil_tmp100 = __errno_location();
#line 980
        Panic(*__cil_tmp100, (char *)"Cannot make directory \'%s\'", SockDir);
        }
      }
    } else {
#line 984
      if (! ((st.st_mode & 61440U) == 16384U)) {
        {
#line 985
        Panic(0, (char *)"\'%s\' must be a directory.", SockDir);
        }
      }
#line 986
      if (eff_uid == 0) {
#line 986
        if (real_uid) {
#line 986
          if (st.st_uid != (unsigned int )eff_uid) {
            {
#line 987
            Panic(0, (char *)"Directory \'%s\' must be owned by root.", SockDir);
            }
          }
        }
      }
#line 988
      if (eff_uid == 0 && (real_uid || (st.st_mode & 509U) != 509U)) {
#line 988
        tmp___506 = 493;
      } else {
#line 988
        if ((unsigned int )eff_gid == st.st_gid && eff_gid != real_gid) {
#line 988
          tmp___505 = 509;
        } else {
#line 988
          tmp___505 = 511;
        }
#line 988
        tmp___506 = tmp___505;
      }
#line 988
      n = tmp___506;
#line 991
      if ((st.st_mode & 511U) != (unsigned int )n) {
        {
#line 992
        Panic(0, (char *)"Directory \'%s\' must have mode %03o.", SockDir, n);
        }
      }
    }
    {
#line 994
    sprintf((char *)SockPath, (char const   *)((char *)"%s/S-%s"), SockDir, LoginName);
#line 995
    __cil_tmp103 = access((char const   *)((char *)SockPath), 0);
    }
#line 995
    if (__cil_tmp103) {
      {
#line 997
      __cil_tmp104 = mkdir((char const   *)((char *)SockPath), (__mode_t )448);
      }
#line 997
      if (__cil_tmp104 == -1) {
        {
#line 998
        __cil_tmp105 = __errno_location();
#line 998
        Panic(*__cil_tmp105, (char *)"Cannot make directory \'%s\'", (char *)SockPath);
        }
      }
      {
#line 999
      __cil_tmp106 = chown((char const   *)((char *)SockPath), (__uid_t )real_uid,
                           (__gid_t )real_gid);
      }
    }
  }
  {
#line 1005
  __cil_tmp107 = stat((char const   *)((char *)SockPath), & st);
  }
#line 1005
  if (__cil_tmp107 == -1) {
    {
#line 1006
    __cil_tmp108 = __errno_location();
#line 1006
    Panic(*__cil_tmp108, (char *)"Cannot access %s", (char *)SockPath);
    }
  } else
#line 1008
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 1009
    Panic(0, (char *)"%s is not a directory.", (char *)SockPath);
    }
  }
#line 1011
  if (multi) {
#line 1013
    if (st.st_uid != (unsigned int )multi_uid) {
      {
#line 1014
      Panic(0, (char *)"%s is not the owner of %s.", multi, (char *)SockPath);
      }
    }
  } else
#line 1019
  if (st.st_uid != (unsigned int )real_uid) {
    {
#line 1020
    Panic(0, (char *)"You are not the owner of %s.", (char *)SockPath);
    }
  }
#line 1022
  if ((st.st_mode & 511U) != 448U) {
    {
#line 1023
    Panic(0, (char *)"Directory %s must have mode 700.", (char *)SockPath);
    }
  }
  {
#line 1024
  __cil_tmp109 = index((char const   *)SockMatch, '/');
  }
#line 1024
  if (SockMatch) {
#line 1024
    if (__cil_tmp109) {
      {
#line 1025
      Panic(0, (char *)"Bad session name \'%s\'", SockMatch);
      }
    }
  }
  {
#line 1026
  __cil_tmp110 = strlen((char const   *)((char *)SockPath));
#line 1026
  SockName = ((char *)SockPath + __cil_tmp110) + 1;
#line 1027
  *SockName = (char )0;
#line 1028
  __cil_tmp111 = umask((__mode_t )oumask);
  }
  {
#line 1029
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1029
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 1037
  __cil_tmp112 = gethostname((char *)HostName, (size_t )256);
#line 1038
  HostName[255] = (char )'\000';
#line 1040
  ap = index((char const   *)((char *)HostName), '.');
  }
#line 1040
  if (ap != (char *)((void *)0)) {
#line 1041
    *ap = (char )'\000';
  }
#line 1043
  if (lsflag) {
#line 1048
    if (multi) {
#line 1049
      real_uid = multi_uid;
    }
    {
#line 1051
    setgid((__gid_t )real_gid);
#line 1052
    setuid((__uid_t )real_uid);
#line 1053
    eff_uid = real_uid;
#line 1054
    eff_gid = real_gid;
#line 1055
    i = FindSocket((int *)((void *)0), & fo, & oth, SockMatch);
    }
#line 1056
    if (quietflag) {
#line 1057
      if (fo) {
#line 1057
        if (oth || i) {
#line 1057
          tmp___507 = 2;
        } else {
#line 1057
          tmp___507 = 1;
        }
#line 1057
        tmp___508 = tmp___507;
      } else {
#line 1057
        tmp___508 = 0;
      }
      {
#line 1057
      exit((8 + tmp___508) + i);
      }
    }
#line 1058
    if (fo == 0) {
      {
#line 1059
      Panic(0, (char *)"No Sockets found in %s.\n", (char *)SockPath);
      }
    }
#line 1060
    if (fo > 1) {
#line 1060
      tmp___509 = (char *)"s";
    } else {
#line 1060
      tmp___509 = (char *)"";
    }
    {
#line 1060
    Panic(0, (char *)"%d Socket%s in %s.\n", fo, tmp___509, (char *)SockPath);
    }
  }
  {
#line 1063
  xsignal(1, AttacherFinit);
  }
#line 1064
  if (cmdflag) {
    {
#line 1066
    sty = (char *)0;
#line 1069
    attach_tty = ttyname(0);
    }
#line 1069
    if (attach_tty == (char *)0) {
#line 1070
      attach_tty = (char *)"";
    }
    {
#line 1071
    __cil_tmp123 = strlen((char const   *)attach_tty);
    }
#line 1071
    if (__cil_tmp123 >= 4096UL) {
      {
#line 1072
      Panic(0, (char *)"TtyName too long - sorry.");
      }
    }
#line 1073
    if (! *av) {
      {
#line 1074
      Panic(0, (char *)"Please specify a command.");
      }
    }
    {
#line 1075
    setgid((__gid_t )real_gid);
#line 1076
    setuid((__uid_t )real_uid);
#line 1077
    eff_uid = real_uid;
#line 1078
    eff_gid = real_gid;
    }
#line 1079
    if (! mflag) {
#line 1079
      if (! SockMatch) {
        {
#line 1081
        sty = getenv((char const   *)((char *)"STY"));
        }
#line 1082
        if (sty) {
#line 1082
          if ((int )*sty == 0) {
#line 1083
            sty = (char *)0;
          }
        }
      }
    }
    {
#line 1085
    SendCmdMessage(sty, SockMatch, av);
#line 1086
    exit(0);
    }
  } else
#line 1088
  if (rflag) {
    _L: /* CIL Label */ 
    {
#line 1090
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1090
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1091
    __cil_tmp125 = Attach(2);
    }
#line 1091
    if (__cil_tmp125) {
      {
#line 1093
      Attacher();
      }
    }
#line 1097
    if (multiattach) {
      {
#line 1098
      Panic(0, (char *)"Can\'t create sessions of other users.");
      }
    }
    {
#line 1100
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1100
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  } else
#line 1088
  if (xflag) {
#line 1088
    goto _L;
  } else
#line 1102
  if (dflag) {
#line 1102
    if (! mflag) {
      {
#line 1104
      __cil_tmp126 = Attach(4);
      }
#line 1105
      if (dflag > 1) {
#line 1105
        tmp___510 = (char *)"power ";
      } else {
#line 1105
        tmp___510 = (char *)"";
      }
      {
#line 1105
      Msg(0, (char *)"[%s %sdetached.]\n", SockName, tmp___510);
#line 1106
      eexit(0);
      }
    }
  }
#line 1109
  if (! SockMatch) {
#line 1109
    if (! mflag) {
      {
#line 1113
      sty___0 = getenv((char const   *)((char *)"STY"));
      }
#line 1113
      if (sty___0 != (char *)0) {
#line 1113
        if ((int )*sty___0 != 0) {
          {
#line 1115
          setgid((__gid_t )real_gid);
#line 1116
          setuid((__uid_t )real_uid);
#line 1117
          eff_uid = real_uid;
#line 1118
          eff_gid = real_gid;
#line 1119
          nwin_options.args = av;
#line 1120
          SendCreateMsg(sty___0, & nwin);
#line 1121
          exit(0);
          }
        }
      }
    }
  }
  {
#line 1125
  nwin_compose(& nwin_default, & nwin_options, & nwin_default);
  }
#line 1127
  if (! detached) {
    {
    {
#line 1128
    MasterPid = fork();
    }
    }
  } else
#line 1127
  if (dflag != 2) {
    {
    {
#line 1128
    MasterPid = fork();
    }
    }
  } else {
#line 1130
    MasterPid = 0;
  }
  {
#line 1134
  if (MasterPid == - 1) {
#line 1134
    goto case_exp;
  }
#line 1137
  if (MasterPid == 0) {
#line 1137
    goto case_0___1;
  }
#line 1139
  goto switch_default___2;
  case_exp: /* CIL Label */ 
  {
#line 1135
  __cil_tmp131 = __errno_location();
#line 1135
  Panic(*__cil_tmp131, (char *)"fork");
  }
  case_0___1: /* CIL Label */ 
#line 1138
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 1140
  if (detached) {
    {
#line 1141
    exit(0);
    }
  }
#line 1142
  if (SockMatch) {
    {
#line 1143
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s"), MasterPid, SockMatch);
    }
  } else {
    {
#line 1145
    __cil_tmp132 = stripdev(attach_tty);
#line 1145
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s.%s"), MasterPid,
            __cil_tmp132, (char *)HostName);
    }
  }
#line 1146
  ap = (char *)socknamebuf;
  {
#line 1146
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1146
    if (! *ap) {
#line 1146
      goto while_break___23;
    }
#line 1147
    if ((int )*ap == 47) {
#line 1148
      *ap = (char )'-';
    }
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 1146
  ap ++;
#line 1150
  __cil_tmp134 = strlen((char const   *)((char *)socknamebuf));
  }
#line 1150
  if (__cil_tmp134 > 255UL) {
#line 1151
    socknamebuf[255] = (char )0;
  }
  {
#line 1153
  __cil_tmp135 = strlen((char const   *)((char *)SockPath));
#line 1153
  sprintf((char *)SockPath + __cil_tmp135, (char const   *)((char *)"/%s"), (char *)socknamebuf);
#line 1154
  setgid((__gid_t )real_gid);
#line 1155
  setuid((__uid_t )real_uid);
#line 1156
  eff_uid = real_uid;
#line 1157
  eff_gid = real_gid;
#line 1158
  Attacher();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 1162
  if (DefaultEsc == -1) {
#line 1163
    DefaultEsc = 1;
  }
#line 1164
  if (DefaultMetaEsc == -1) {
#line 1165
    DefaultMetaEsc = 'a';
  }
  {
#line 1167
  __cil_tmp136 = strlen((char const   *)av0);
#line 1167
  ap = (av0 + __cil_tmp136) - 1;
  }
  {
#line 1168
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 1168
    if (! (ap >= av0)) {
#line 1168
      goto while_break___24;
    }
    {
#line 1170
    __cil_tmp137 = strncmp((char const   *)((char *)"screen"), (char const   *)ap,
                           (unsigned long )6);
    }
#line 1170
    if (! __cil_tmp137) {
      {
#line 1172
      strncpy(ap, (char const   *)((char *)"SCREEN"), (unsigned long )6);
      }
#line 1173
      goto while_break___24;
    }
#line 1175
    __cil_tmp138 = ap;
#line 1175
    ap --;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 1177
  if (ap < av0) {
#line 1178
    *av0 = (char )'S';
  }
#line 1193
  if (! detached) {
    {
#line 1196
    n = secopen(attach_tty, 2, 0);
    }
#line 1196
    if (n < 0) {
      {
#line 1197
      Panic(0, (char *)"Cannot reopen \'%s\' - please check.", attach_tty);
      }
    }
  } else {
#line 1200
    n = - 1;
  }
  {
#line 1201
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"r"), stdin);
#line 1202
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"w"), stdout);
#line 1207
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"w"), stderr);
  }
  {
#line 1208
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1208
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 1215
  __cil_tmp140 = UserAdd(LoginName, (char *)0, (struct acluser **)0);
  }
#line 1215
  if (__cil_tmp140 < 0) {
    {
#line 1216
    Panic(0, (char *)"Could not create user info");
    }
  }
#line 1217
  if (! detached) {
    {
#line 1219
    __cil_tmp141 = getppid();
#line 1219
    __cil_tmp142 = MakeDisplay(LoginName, attach_tty, attach_term, n, __cil_tmp141,
                               & attach_Mode);
    }
#line 1219
    if (__cil_tmp142 == (struct display *)0) {
      {
#line 1220
      Panic(0, (char *)"Could not alloc display");
      }
    }
#line 1222
    if (nwin_options.encoding > 0) {
#line 1222
      tmp___511 = nwin_options.encoding;
    } else {
#line 1222
      tmp___511 = 0;
    }
#line 1222
    display->d_encoding = tmp___511;
    {
#line 1223
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1223
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
  }
#line 1227
  if (SockMatch) {
    {
#line 1230
    __cil_tmp144 = getpid();
#line 1230
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s"), __cil_tmp144,
            SockMatch);
    }
  } else {
    {
#line 1234
    __cil_tmp145 = getpid();
    }
    {
#line 1234
    __cil_tmp146 = stripdev(attach_tty);
#line 1234
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s.%s"), __cil_tmp145,
            __cil_tmp146, (char *)HostName);
    }
  }
#line 1237
  ap = (char *)socknamebuf;
  {
#line 1237
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1237
    if (! *ap) {
#line 1237
      goto while_break___27;
    }
#line 1238
    if ((int )*ap == 47) {
#line 1239
      *ap = (char )'-';
    }
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 1237
  ap ++;
#line 1241
  __cil_tmp148 = strlen((char const   *)((char *)socknamebuf));
  }
#line 1241
  if (__cil_tmp148 > 255UL) {
    {
#line 1243
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1243
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 1244
    socknamebuf[255] = (char )0;
  }
  {
#line 1247
  __cil_tmp149 = strlen((char const   *)((char *)SockPath));
#line 1247
  sprintf((char *)SockPath + __cil_tmp149, (char const   *)((char *)"/%s"), (char *)socknamebuf);
#line 1249
  ServerSocket = MakeServerSocket();
#line 1250
  InitKeytab();
#line 1253
  ap = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1253
  if (ap) {
    {
#line 1254
    StartRc(ap);
    }
  } else {
    {
#line 1257
    StartRc((char *)"./etc/screenrc");
    }
  }
  {
#line 1259
  StartRc(RcFileName);
#line 1262
  InitUtmp();
  }
#line 1265
  if (display) {
    {
#line 1267
    __cil_tmp152 = InitTermcap(0, 0);
    }
#line 1267
    if (__cil_tmp152) {
      {
#line 1269
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 1269
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
      {
#line 1270
      fcntl(display->d_userfd, 4, 0);
#line 1271
      freetty();
      }
#line 1272
      if (display->d_userpid) {
        {
#line 1273
        Kill(display->d_userpid, 1);
        }
      }
      {
#line 1274
      eexit(1);
      }
    }
    {
#line 1276
    MakeDefaultCanvas();
#line 1277
    InitTerm(0);
#line 1279
    RemoveLoginSlot();
    }
  } else {
    {
#line 1283
    MakeTermcap(1);
    }
  }
  {
#line 1285
  InitLoadav();
#line 1287
  MakeNewEnv();
#line 1288
  xsignal(1, SigHup);
#line 1289
  xsignal(2, FinitHandler);
#line 1290
  xsignal(3, FinitHandler);
#line 1291
  xsignal(15, FinitHandler);
#line 1293
  xsignal(21, (__sighandler_t )1);
#line 1294
  xsignal(22, (__sighandler_t )1);
  }
#line 1297
  if (display) {
    {
#line 1299
    brktty(display->d_userfd);
#line 1300
    SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 1302
    SetTTY(display->d_userfd, & display->d_NewMode);
#line 1303
    __cil_tmp153 = fcntl(display->d_userfd, 4, 2048);
    }
#line 1303
    if (__cil_tmp153) {
      {
#line 1304
      __cil_tmp154 = __errno_location();
#line 1304
      Msg(*__cil_tmp154, (char *)"Warning: NBLOCK fcntl failed");
      }
    }
  } else {
    {
#line 1307
    brktty(- 1);
    }
  }
  {
#line 1310
  ap = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1310
  if (ap) {
    {
#line 1311
    FinishRc(ap);
    }
  } else {
    {
#line 1314
    FinishRc((char *)"./etc/screenrc");
    }
  }
  {
#line 1316
  FinishRc(RcFileName);
  }
  {
#line 1318
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 1318
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 1319
  if (windows == (struct win *)((void *)0)) {
    {
#line 1321
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1321
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 1322
    __cil_tmp156 = MakeWindow(& nwin);
    }
#line 1322
    if (__cil_tmp156 == -1) {
      {
#line 1324
      Msg(0, (char *)"Sorry, could not find a PTY.");
#line 1325
      sleep((unsigned int )5);
#line 1326
      Finit(0);
      }
    }
  }
#line 1335
  if (display) {
#line 1335
    if (default_startup) {
      {
#line 1336
      display_copyright();
      }
    }
  }
  {
#line 1337
  xsignal(17, SigChld);
#line 1338
  xsignal(2, SigInt);
  }
#line 1339
  if (rflag) {
#line 1339
    if ((rflag & 1) == 0) {
      {
#line 1341
      Msg(0, (char *)"New screen...");
#line 1342
      rflag = 0;
      }
    }
  }
  {
#line 1345
  serv_read.type = 1;
#line 1346
  serv_read.fd = ServerSocket;
#line 1347
  serv_read.handler = serv_read_fn;
#line 1348
  evenq(& serv_read);
#line 1350
  serv_select.pri = - 10;
#line 1351
  serv_select.type = 3;
#line 1352
  serv_select.handler = serv_select_fn;
#line 1353
  evenq(& serv_select);
#line 1355
  logflushev.type = 0;
#line 1356
  logflushev.handler = logflush_fn;
#line 1358
  sched();
  }
#line 1360
  return (0);
}
}
#line 1364 "/tmp/screen-3.9.15/screen.c"
void WindowDied(struct win *p ) 
{ 
  char buf[100] ;
  char *s ;
  time_t now ;
  time_t __cil_tmp5 ;
  size_t __cil_tmp7 ;
  char *tmp ;
  size_t __cil_tmp10 ;

  {
#line 1367
  if (ZombieKey_destroy) {
    {
#line 1372
    __cil_tmp5 = time(& now);
#line 1373
    s = ctime(& now);
    }
#line 1374
    if (s) {
#line 1374
      if ((int )*s) {
        {
#line 1375
        __cil_tmp7 = strlen((char const   *)s);
#line 1375
        *(s + (__cil_tmp7 - 1UL)) = (char )'\000';
        }
      }
    }
    {
#line 1376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1376
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1379
    if (p->w_slot != (slot_t )0) {
#line 1379
      if (p->w_slot != (slot_t )-1) {
        {
#line 1381
        RemoveUtmp(p);
#line 1382
        p->w_slot = (slot_t )0;
        }
      }
    }
    {
#line 1385
    CloseDevice(p);
#line 1387
    p->w_pid = 0;
#line 1388
    ResetWindow(p);
#line 1390
    p->w_layer.l_y = MFindUsedLine(p, p->w_bot, 1);
    }
#line 1391
    if (s) {
#line 1391
      tmp = s;
    } else {
#line 1391
      tmp = (char *)"?";
    }
    {
#line 1391
    sprintf((char *)buf, (char const   *)((char *)"\n\r=== Window terminated (%s) ==="),
            tmp);
#line 1392
    __cil_tmp10 = strlen((char const   *)((char *)buf));
#line 1392
    WriteString(p, (char *)buf, (int )__cil_tmp10);
#line 1393
    WindowChanged(p, 'f');
    }
  } else {
    {
#line 1396
    KillWindow(p);
    }
  }

}
}
#line 1403 "/tmp/screen-3.9.15/screen.c"
static void SigChldHandler(void) 
{ 
  struct stat st ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 1409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1409
    if (! GotSigChld) {
#line 1409
      goto while_break;
    }
    {
#line 1411
    GotSigChld = 0;
#line 1412
    DoWait();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1417
  __cil_tmp2 = stat((char const   *)((char *)SockPath), & st);
  }
#line 1417
  if (__cil_tmp2 == -1) {
    {
#line 1419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1419
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1420
    __cil_tmp3 = RecoverSocket();
    }
#line 1420
    if (! __cil_tmp3) {
      {
#line 1422
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1422
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1423
      Finit(1);
      }
    } else {
      {
#line 1426
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1426
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1429
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1429
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
}
}
#line 1433 "/tmp/screen-3.9.15/screen.c"
static void SigChld(int sigsig ) 
{ 


  {
  {
#line 1435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1435
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  GotSigChld = 1;
}
}
#line 1441 "/tmp/screen-3.9.15/screen.c"
void SigHup(int sigsig ) 
{ 


  {
  {
#line 1444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1444
    if (! (display != (struct display *)0)) {
#line 1444
      goto while_break;
    }
    {
#line 1445
    Hangup();
    }
  }
  while_break: /* CIL Label */ ;
  }

}
}
#line 1455 "/tmp/screen-3.9.15/screen.c"
static void SigInt(int sigsig ) 
{ 


  {
  {
#line 1472
  xsignal(2, (void (*)(int  ))SigInt);
  }
  {
#line 1473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1473
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1474
  InterruptPlease = 1;
}
}
#line 1480 "/tmp/screen-3.9.15/screen.c"
static void CoreDump(int sigsig ) 
{ 
  struct display *disp ;
  char buf[80] ;
  __gid_t __cil_tmp4 ;
  __uid_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  __pid_t __cil_tmp7 ;

  {
  {
#line 1488
  __cil_tmp4 = getgid();
#line 1488
  setgid(__cil_tmp4);
#line 1489
  __cil_tmp5 = getuid();
#line 1489
  setuid(__cil_tmp5);
#line 1490
  unlink((char const   *)((char *)"core"));
#line 1492
  sprintf((char *)buf, (char const   *)((char *)"\r\n[screen caught signal %d.%s]\r\n"),
          sigsig, (char *)"");
#line 1502
  disp = displays;
  }
  {
#line 1502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1502
    if (! disp) {
#line 1502
      goto while_break;
    }
    {
#line 1504
    fcntl(disp->d_userfd, 4, 0);
#line 1505
    SetTTY(disp->d_userfd, & display->d_OldMode);
#line 1506
    __cil_tmp6 = strlen((char const   *)((char *)buf));
#line 1506
    write(disp->d_userfd, (void const   *)((char *)buf), __cil_tmp6);
#line 1507
    Kill(disp->d_userpid, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1502
  disp = disp->d_next;
#line 1510
  __cil_tmp7 = getpid();
#line 1510
  Kill(__cil_tmp7, 9);
#line 1511
  eexit(11);
  }
}
}
#line 1519 "/tmp/screen-3.9.15/screen.c"
static void DoWait(void) 
{ 
  register int pid ;
  struct win *p ;
  struct win *next ;
  int wstat ;
  int __cil_tmp6 ;

  {
  {
#line 1531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1531
    if (! (pid > 0)) {
#line 1531
      goto while_break;
    }
#line 1551
    p = windows;
    {
#line 1551
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1551
      if (! p) {
#line 1551
        goto while_break___0;
      }
#line 1553
      next = p->w_next;
#line 1554
      if (pid == p->w_pid) {
#line 1557
        if ((wstat & 255) == 127) {
          {
#line 1559
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1559
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1561
          if ((wstat & 65280) >> 8 == 21) {
            {
#line 1563
            Msg(0, (char *)"Suspended (tty input)");
            }
#line 1564
            goto while_continue___0;
          }
#line 1568
          if ((wstat & 65280) >> 8 == 22) {
            {
#line 1570
            Msg(0, (char *)"Suspended (tty output)");
            }
#line 1571
            goto while_continue___0;
          }
          {
#line 1575
          Msg(0, (char *)"Child has been stopped, restarting.");
#line 1576
          __cil_tmp6 = killpg(p->w_pid, 18);
          }
#line 1576
          if (__cil_tmp6) {
            {
#line 1577
            kill(p->w_pid, 18);
            }
          }
        } else {
          {
#line 1582
          WindowDied(p);
          }
        }
#line 1584
        goto while_break___0;
      }
#line 1587
      if (p->w_pwin) {
#line 1587
        if (pid == (p->w_pwin)->p_pid) {
          {
#line 1589
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1589
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1590
          FreePseudowin(p);
          }
#line 1591
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1551
    p = next;
#line 1595
    if (p == (struct win *)0) {
      {
#line 1597
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1597
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1604 "/tmp/screen-3.9.15/screen.c"
static void FinitHandler(int sigsig ) 
{ 


  {
  {
#line 1607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1611
  Finit(1);
  }
}
}
#line 1616 "/tmp/screen-3.9.15/screen.c"
void Finit(int i ) 
{ 
  struct win *p ;
  struct win *next ;
  int __cil_tmp4 ;

  {
  {
#line 1621
  xsignal(17, (__sighandler_t )1);
#line 1622
  xsignal(1, (__sighandler_t )1);
  }
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1624
  p = windows;
  {
#line 1624
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1624
    if (! p) {
#line 1624
      goto while_break___0;
    }
    {
#line 1626
    next = p->w_next;
#line 1627
    FreeWindow(p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1624
  p = next;
#line 1629
  if (ServerSocket != -1) {
    {
#line 1631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1631
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1633
    xseteuid(real_uid);
#line 1634
    xsetegid(real_gid);
#line 1636
    __cil_tmp4 = unlink((char const   *)((char *)SockPath));
#line 1638
    xseteuid(eff_uid);
#line 1639
    xsetegid(eff_gid);
    }
  }
#line 1642
  display = displays;
  {
#line 1642
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1642
    if (! display) {
#line 1642
      goto while_break___2;
    }
#line 1644
    if (display->d_status) {
      {
#line 1645
      RemoveStatus();
      }
    }
    {
#line 1646
    FinitTerm();
#line 1648
    RestoreLoginSlot();
#line 1650
    AddStr((char *)"[screen is terminating]\r\n");
#line 1651
    Flush();
#line 1652
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 1653
    fcntl(display->d_userfd, 4, 0);
#line 1654
    freetty();
#line 1655
    Kill(display->d_userpid, 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1642
  display = display->d_next;
#line 1661
  exit(i);
  }
}
}
#line 1665 "/tmp/screen-3.9.15/screen.c"
void eexit(int e ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1669
  if (ServerSocket != -1) {
    {
#line 1671
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1671
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1672
    setgid((__gid_t )real_gid);
#line 1673
    setuid((__uid_t )real_uid);
#line 1674
    __cil_tmp2 = unlink((char const   *)((char *)SockPath));
    }
  }
  {
#line 1676
  exit(e);
  }
}
}
#line 1680 "/tmp/screen-3.9.15/screen.c"
void Hangup(void) 
{ 


  {
#line 1682
  if (display == (struct display *)0) {
#line 1683
    return;
  }
  {
#line 1684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1685
  if (display->d_userfd >= 0) {
    {
#line 1687
    close(display->d_userfd);
#line 1688
    display->d_userfd = - 1;
    }
  }
#line 1690
  if (auto_detach) {
    {
    {
#line 1691
    Detach(6);
    }
    }
  } else
#line 1690
  if (displays->d_next) {
    {
    {
#line 1691
    Detach(6);
    }
    }
  } else {
    {
#line 1693
    Finit(0);
    }
  }
}
}
#line 1710 "/tmp/screen-3.9.15/screen.c"
void Detach(int mode ) 
{ 
  int sign ;
  int pid ;
  struct canvas *cv ;
  struct win *p ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;

  {
#line 1713
  sign = 0;
#line 1717
  if (display == (struct display *)0) {
#line 1718
    return;
  }
  {
#line 1720
  xsignal(1, (__sighandler_t )1);
  }
  {
#line 1721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1721
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1722
  if (display->d_status) {
    {
#line 1723
    RemoveStatus();
    }
  }
  {
#line 1724
  FinitTerm();
  }
#line 1725
  if (! display) {
#line 1726
    return;
  }
  {
#line 1729
  if (mode == 6) {
#line 1729
    goto case_6;
  }
#line 1732
  if (mode == 0) {
#line 1732
    goto case_0;
  }
#line 1737
  if (mode == 1) {
#line 1737
    goto case_1;
  }
#line 1742
  if (mode == 2) {
#line 1742
    goto case_2;
  }
#line 1748
  if (mode == 3) {
#line 1748
    goto case_3;
  }
#line 1758
  if (mode == 4) {
#line 1758
    goto case_4;
  }
#line 1769
  if (mode == 5) {
#line 1769
    goto case_5;
  }
#line 1727
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1730
  sign = 1;
#line 1731
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1733
  AddStr((char *)"[detached]\r\n");
  }
#line 1734
  sign = 1;
#line 1735
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1738
  sign = 20;
#line 1739
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1743
  AddStr((char *)"[remote detached]\r\n");
  }
#line 1744
  sign = 1;
#line 1745
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1749
  AddStr((char *)"[power detached]\r\n");
  }
#line 1750
  if (PowDetachString) {
    {
#line 1752
    __cil_tmp6 = expand_vars(PowDetachString, display);
#line 1752
    AddStr(__cil_tmp6);
#line 1753
    AddStr((char *)"\r\n");
    }
  }
#line 1755
  sign = 10;
#line 1756
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1759
  AddStr((char *)"[remote power detached]\r\n");
  }
#line 1760
  if (PowDetachString) {
    {
#line 1762
    __cil_tmp7 = expand_vars(PowDetachString, display);
#line 1762
    AddStr(__cil_tmp7);
#line 1763
    AddStr((char *)"\r\n");
    }
  }
#line 1765
  sign = 10;
#line 1766
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1770
  ClearAll();
  }
#line 1771
  sign = 12;
#line 1773
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1776
  if (displays->d_next == (struct display *)0) {
#line 1778
    p = windows;
    {
#line 1778
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1778
      if (! p) {
#line 1778
        goto while_break___0;
      }
#line 1780
      if (p->w_slot != (slot_t )-1) {
#line 1780
        if (! (p->w_lflag & 2)) {
          {
#line 1782
          RemoveUtmp(p);
#line 1787
          p->w_slot = (slot_t )0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1778
    p = p->w_next;
  }
#line 1791
  if (mode != 6) {
    {
#line 1792
    RestoreLoginSlot();
    }
  }
#line 1794
  if (displays->d_next == (struct display *)0) {
#line 1794
    if (console_window) {
      {
#line 1796
      __cil_tmp8 = TtyGrabConsole(console_window->w_ptyfd, 0, (char *)"detach");
      }
#line 1796
      if (__cil_tmp8) {
        {
#line 1798
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1798
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1799
        KillWindow(console_window);
#line 1800
        display = displays;
        }
      }
    }
  }
#line 1803
  if (display->d_fore) {
    {
#line 1806
    ReleaseAutoWritelock(display, display->d_fore);
#line 1808
    (display->d_user)->u_detachwin = (display->d_fore)->w_number;
    }
#line 1809
    if (display->d_other) {
#line 1809
      tmp = (display->d_other)->w_number;
    } else {
#line 1809
      tmp = - 1;
    }
#line 1809
    (display->d_user)->u_detachotherwin = tmp;
  }
#line 1811
  cv = display->d_cvlist;
  {
#line 1811
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1811
    if (! cv) {
#line 1811
      goto while_break___2;
    }
    {
#line 1813
    p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 1814
    SetCanvasWindow(cv, (struct win *)0);
    }
#line 1815
    if (p) {
      {
#line 1816
      WindowChanged(p, 'u');
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1811
  cv = cv->c_next;
#line 1819
  pid = display->d_userpid;
  {
#line 1820
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1820
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1821
  FreeDisplay();
  }
#line 1822
  if (displays == (struct display *)0) {
    {
#line 1824
    __cil_tmp10 = chsock();
    }
  }
  {
#line 1830
  Kill(pid, sign);
  }
  {
#line 1831
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1831
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1832
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1832
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1833
  xsignal(1, (void (*)(int  ))SigHup);
  }
}
}
#line 1837 "/tmp/screen-3.9.15/screen.c"
static int IsSymbol(char *e , char *s ) 
{ 
  register int l ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 1842
  __cil_tmp4 = strlen((char const   *)s);
#line 1842
  l = (int )__cil_tmp4;
#line 1843
  __cil_tmp5 = strncmp((char const   *)e, (char const   *)s, (unsigned long )l);
  }
#line 1843
  return (__cil_tmp5 == 0 && (int )*(e + l) == 61);
}
}
#line 1847 "/tmp/screen-3.9.15/screen.c"
void MakeNewEnv(void) 
{ 
  register char **op ;
  register char **np ;
  static char stybuf[256] ;
  void *__cil_tmp4 ;
  size_t __cil_tmp5 ;
  char *tmp ;
  char **__cil_tmp7 ;
  char **__cil_tmp8 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char **__cil_tmp18 ;

  {
#line 1852
  op = environ;
  {
#line 1852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1852
    if (! *op) {
#line 1852
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 1852
  op ++;
#line 1854
  if (NewEnv) {
    {
#line 1855
    free((void *)((char *)NewEnv));
    }
  }
  {
#line 1856
  __cil_tmp4 = malloc((unsigned long )((unsigned int )(((op - environ) + 7L) + 1L)) * sizeof(char **));
#line 1856
  np = (char **)__cil_tmp4;
#line 1856
  NewEnv = np;
  }
#line 1857
  if (! NewEnv) {
    {
#line 1858
    Panic(0, (char *)strnomem);
    }
  }
  {
#line 1859
  __cil_tmp5 = strlen((char const   *)SockName);
  }
#line 1859
  if (__cil_tmp5 <= 251UL) {
#line 1859
    tmp = SockName;
  } else {
#line 1859
    tmp = (char *)"?";
  }
  {
#line 1859
  sprintf((char *)stybuf, (char const   *)((char *)"STY=%s"), tmp);
#line 1860
  __cil_tmp7 = np;
#line 1860
  np ++;
#line 1860
  *__cil_tmp7 = (char *)stybuf;
#line 1861
  __cil_tmp8 = np;
#line 1861
  np ++;
#line 1861
  *__cil_tmp8 = (char *)Term;
#line 1862
  np ++;
#line 1864
  np += 2;
#line 1869
  op = environ;
  }
  {
#line 1869
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1869
    if (! *op) {
#line 1869
      goto while_break___0;
    }
    {
#line 1871
    __cil_tmp17 = IsSymbol(*op, (char *)"COLUMNS");
    }
    {
#line 1871
    __cil_tmp16 = IsSymbol(*op, (char *)"LINES");
    }
    {
#line 1871
    __cil_tmp15 = IsSymbol(*op, (char *)"SHELL");
    }
    {
#line 1871
    __cil_tmp14 = IsSymbol(*op, (char *)"SCREENCAP");
    }
    {
#line 1871
    __cil_tmp13 = IsSymbol(*op, (char *)"WINDOW");
    }
    {
#line 1871
    __cil_tmp12 = IsSymbol(*op, (char *)"STY");
    }
    {
#line 1871
    __cil_tmp11 = IsSymbol(*op, (char *)"TERMCAP");
    }
    {
#line 1871
    __cil_tmp10 = IsSymbol(*op, (char *)"TERM");
    }
#line 1871
    if (! __cil_tmp10) {
#line 1871
      if (! __cil_tmp11) {
#line 1871
        if (! __cil_tmp12) {
#line 1871
          if (! __cil_tmp13) {
#line 1871
            if (! __cil_tmp14) {
#line 1871
              if (! __cil_tmp15) {
#line 1871
                if (! __cil_tmp16) {
#line 1871
                  if (! __cil_tmp17) {
#line 1876
                    __cil_tmp18 = np;
#line 1876
                    np ++;
#line 1876
                    *__cil_tmp18 = *op;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1869
  op ++;
#line 1878
  *np = (char *)0;
}
}
#line 1884 "/tmp/screen-3.9.15/screen.c"
void Msg(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf[8192] ;
  char *p ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *tty ;
  struct display *olddisplay ;

  {
  {
#line 1894
  p = (char *)buf;
#line 1896
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 1897
  fmt = DoNLS(fmt);
#line 1898
  __cil_tmp7 = vsnprintf(p, sizeof(buf) - 100UL, (char const   *)fmt, (__builtin_va_list *)ap);
#line 1899
  __builtin_va_end((__builtin_va_list *)ap);
  }
#line 1900
  if (err) {
    {
#line 1902
    __cil_tmp8 = strlen((char const   *)p);
    }
    {
#line 1902
    p += __cil_tmp8;
#line 1903
    __cil_tmp9 = p;
#line 1903
    p ++;
#line 1903
    *__cil_tmp9 = (char )':';
#line 1904
    __cil_tmp10 = p;
#line 1904
    p ++;
#line 1904
    *__cil_tmp10 = (char )' ';
#line 1905
    __cil_tmp11 = strerror(err);
#line 1905
    strncpy(p, (char const   *)__cil_tmp11, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 1906
    buf[sizeof(buf) - 1UL] = (char )0;
    }
  }
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1908
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1910
  if (display) {
#line 1910
    if (displays) {
      {
#line 1911
      MakeStatus((char *)buf);
      }
    } else {
#line 1910
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1912
  if (displays) {
#line 1914
    display = displays;
    {
#line 1914
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1914
      if (! display) {
#line 1914
        goto while_break___0;
      }
      {
#line 1915
      MakeStatus((char *)buf);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1914
    display = display->d_next;
  } else
#line 1917
  if (display) {
    {
#line 1922
    tty = (char *)display->d_usertty;
#line 1923
    olddisplay = display;
#line 1924
    display = (struct display *)0;
#line 1925
    SendErrorMsg(tty, (char *)buf);
#line 1926
    display = olddisplay;
    }
  } else {
    {
#line 1929
    printf((char const   *)((char *)"%s\r\n"), (char *)buf);
    }
  }
}
}
#line 1938 "/tmp/screen-3.9.15/screen.c"
void Panic(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf[8192] ;
  char *p ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *tty ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1948
  p = (char *)buf;
#line 1950
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 1951
  fmt = DoNLS(fmt);
#line 1952
  __cil_tmp7 = vsnprintf(p, sizeof(buf) - 100UL, (char const   *)fmt, (__builtin_va_list *)ap);
#line 1953
  __builtin_va_end((__builtin_va_list *)ap);
  }
#line 1954
  if (err) {
    {
#line 1956
    __cil_tmp8 = strlen((char const   *)p);
    }
    {
#line 1956
    p += __cil_tmp8;
#line 1957
    __cil_tmp9 = p;
#line 1957
    p ++;
#line 1957
    *__cil_tmp9 = (char )':';
#line 1958
    __cil_tmp10 = p;
#line 1958
    p ++;
#line 1958
    *__cil_tmp10 = (char )' ';
#line 1959
    __cil_tmp11 = strerror(err);
#line 1959
    strncpy(p, (char const   *)__cil_tmp11, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 1960
    buf[sizeof(buf) - 1UL] = (char )0;
    }
  }
  {
#line 1962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1962
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1963
  if (displays == (struct display *)0) {
#line 1963
    if (display == (struct display *)0) {
      {
#line 1964
      printf((char const   *)((char *)"%s\r\n"), (char *)buf);
      }
    } else {
#line 1963
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1965
  if (displays == (struct display *)0) {
    {
#line 1970
    tty = (char *)display->d_usertty;
#line 1971
    display = (struct display *)0;
#line 1972
    SendErrorMsg(tty, (char *)buf);
#line 1973
    sleep((unsigned int )2);
#line 1974
    _exit(1);
    }
  } else {
#line 1977
    display = displays;
    {
#line 1977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1977
      if (! display) {
#line 1977
        goto while_break___0;
      }
#line 1979
      if (display->d_status) {
        {
#line 1980
        RemoveStatus();
        }
      }
      {
#line 1981
      FinitTerm();
#line 1982
      Flush();
#line 1984
      RestoreLoginSlot();
#line 1986
      SetTTY(display->d_userfd, & display->d_OldMode);
#line 1987
      fcntl(display->d_userfd, 4, 0);
#line 1988
      __cil_tmp13 = strlen((char const   *)((char *)buf));
#line 1988
      write(display->d_userfd, (void const   *)((char *)buf), __cil_tmp13);
#line 1989
      write(display->d_userfd, (void const   *)((char *)"\n"), (size_t )1);
#line 1990
      freetty();
      }
#line 1991
      if (display->d_userpid) {
        {
#line 1992
        Kill(display->d_userpid, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1977
    display = display->d_next;
  }
#line 1995
  if (tty_oldmode >= 0) {
    {
#line 1998
    __cil_tmp14 = setuid((__uid_t )own_uid);
    }
#line 1998
    if (__cil_tmp14) {
      {
#line 1999
      xseteuid(own_uid);
      }
    }
    {
#line 2003
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2003
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2004
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 2007
  eexit(1);
  }
}
}
#line 2024
static char winmsg_buf[256] ;
#line 2026
static int winmsg_rend[16] ;
#line 2027
static int winmsg_rendpos[16] ;
#line 2028
static int winmsg_numrend ;
#line 2031 "/tmp/screen-3.9.15/screen.c"
static char *pad_expand(char *buf , char *p , int numpad , int padlen ) 
{ 
  char *pn ;
  char *pn2 ;
  int i ;
  int r ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int tmp ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 2040
  padlen = (int )((long )padlen - (p - buf));
#line 2041
  if (padlen < 0) {
#line 2042
    padlen = 0;
  }
#line 2043
  pn = p + padlen;
#line 2043
  pn2 = pn;
#line 2044
  r = winmsg_numrend;
  {
#line 2045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2045
    if (! (p >= buf)) {
#line 2045
      goto while_break;
    }
#line 2047
    if (r) {
#line 2047
      if (p - buf == (long )winmsg_rendpos[r - 1]) {
#line 2049
        r --;
#line 2049
        winmsg_rendpos[r] = (int )(pn - buf);
#line 2050
        goto while_continue;
      }
    }
#line 2052
    __cil_tmp9 = pn;
#line 2052
    pn --;
#line 2052
    *__cil_tmp9 = *p;
#line 2053
    __cil_tmp10 = p;
#line 2053
    p --;
#line 2053
    if ((int )*__cil_tmp10 == 127) {
#line 2055
      *(pn + 1) = (char )' ';
#line 2056
      if (numpad > 0) {
#line 2056
        tmp = ((padlen + numpad) - 1) / numpad;
      } else {
#line 2056
        tmp = 0;
      }
#line 2056
      i = tmp;
#line 2057
      padlen -= i;
      {
#line 2058
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2058
        if (! (__cil_tmp12 > 0)) {
#line 2058
          goto while_break___0;
        }
#line 2059
        __cil_tmp13 = pn;
#line 2059
        pn --;
#line 2059
        *__cil_tmp13 = (char )' ';
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2060
      __cil_tmp14 = numpad;
#line 2060
      numpad --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2063
  return (pn2);
}
}
#line 2079
struct backtick *backticks ;
#line 2082 "/tmp/screen-3.9.15/screen.c"
static void backtick_filter(struct backtick *bt ) 
{ 
  char *p ;
  char *q ;
  int c ;
  char *__cil_tmp6 ;

  {
#line 2088
  q = (char *)bt->result;
#line 2088
  p = q;
  {
#line 2088
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2088
    if (! (c != 0)) {
#line 2088
      goto while_break;
    }
#line 2090
    if (c == 9) {
#line 2091
      c = ' ';
    }
#line 2092
    if (c >= 32) {
#line 2093
      __cil_tmp6 = q;
#line 2093
      q ++;
#line 2093
      *__cil_tmp6 = (char )c;
    } else
#line 2092
    if (c == 5) {
#line 2093
      __cil_tmp6 = q;
#line 2093
      q ++;
#line 2093
      *__cil_tmp6 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2095
  *q = (char )0;
}
}
#line 2099 "/tmp/screen-3.9.15/screen.c"
static void backtick_fn(struct event *ev , char *data ) 
{ 
  struct backtick *bt ;
  int i ;
  int j ;
  int k ;
  int l ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp10 ;

  {
#line 2106
  bt = (struct backtick *)data;
  {
#line 2107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2108
  i = bt->bufi;
#line 2109
  __cil_tmp8 = read(ev->fd, (void *)(bt->buf + i), (size_t )(256 - i));
#line 2109
  l = (int )__cil_tmp8;
  }
#line 2110
  if (l <= 0) {
    {
#line 2112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2112
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2113
    evdeq(ev);
#line 2114
    close(ev->fd);
#line 2115
    ev->fd = - 1;
    }
#line 2116
    return;
  }
  {
#line 2118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2118
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2119
  i += l;
#line 2120
  j = 0;
  {
#line 2120
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2120
    if (! (j < l)) {
#line 2120
      goto while_break___2;
    }
#line 2121
    if ((int )*(bt->buf + ((i - j) - 1)) == 10) {
#line 2122
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2120
  j ++;
#line 2123
  if (j < l) {
#line 2125
    k = (i - j) - 2;
    {
#line 2125
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2125
      if (! (k >= 0)) {
#line 2125
        goto while_break___3;
      }
#line 2126
      if ((int )*(bt->buf + k) == 10) {
#line 2127
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2125
    __cil_tmp10 = k;
#line 2125
    k --;
#line 2128
    k ++;
#line 2129
    bcopy((void const   *)(bt->buf + k), (void *)((char *)bt->result), (size_t )((i - j) - k));
#line 2130
    bt->result[((i - j) - k) - 1] = (char )0;
#line 2131
    backtick_filter(bt);
#line 2132
    WindowChanged((struct win *)0, '`');
    }
  }
#line 2134
  if (j == l) {
#line 2134
    if (i == 256) {
#line 2136
      j = 128;
#line 2137
      l = j + 1;
    }
  }
#line 2139
  if (j < l) {
#line 2141
    if (j) {
      {
#line 2142
      bcopy((void const   *)((bt->buf + i) - j), (void *)bt->buf, (size_t )j);
      }
    }
#line 2143
    i = j;
  }
#line 2145
  bt->bufi = i;
}
}
#line 2149 "/tmp/screen-3.9.15/screen.c"
void setbacktick(int num , int lifespan , int tick , char **cmdv ) 
{ 
  struct backtick **btp ;
  struct backtick *bt ;
  char **v ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 2158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2159
  btp = & backticks;
  {
#line 2159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2159
    if (! (bt != (struct backtick *)0)) {
#line 2159
      goto while_break___0;
    }
#line 2160
    if (bt->num == num) {
#line 2161
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2159
  btp = & bt->next;
#line 2162
  if (! bt) {
#line 2162
    if (! cmdv) {
#line 2163
      return;
    }
  }
#line 2164
  if (bt) {
#line 2166
    v = bt->cmdv;
    {
#line 2166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2166
      if (! *v) {
#line 2166
        goto while_break___1;
      }
      {
#line 2167
      free((void *)*v);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2166
    v ++;
#line 2168
    free((void *)bt->cmdv);
    }
#line 2169
    if (bt->buf) {
      {
#line 2170
      free((void *)bt->buf);
      }
    }
#line 2171
    if (bt->ev.fd >= 0) {
      {
#line 2172
      close(bt->ev.fd);
      }
    }
    {
#line 2173
    evdeq(& bt->ev);
    }
  }
#line 2175
  if (bt) {
#line 2175
    if (! cmdv) {
      {
#line 2177
      *btp = bt->next;
#line 2178
      free((void *)bt);
      }
#line 2179
      return;
    }
  }
#line 2181
  if (! bt) {
    {
#line 2183
    __cil_tmp9 = malloc(sizeof(*bt));
#line 2183
    bt = (struct backtick *)__cil_tmp9;
    }
#line 2184
    if (! bt) {
      {
#line 2186
      Msg(0, (char *)strnomem);
      }
#line 2187
      return;
    }
    {
#line 2189
    bzero((void *)bt, sizeof(*bt));
#line 2190
    bt->next = (struct backtick *)0;
#line 2191
    *btp = bt;
    }
  }
#line 2193
  bt->num = num;
#line 2194
  bt->tick = tick;
#line 2195
  bt->lifespan = lifespan;
#line 2196
  bt->bestbefore = (time_t )0;
#line 2197
  bt->result[0] = (char )0;
#line 2198
  bt->buf = (char *)0;
#line 2199
  bt->bufi = 0;
#line 2200
  bt->cmdv = cmdv;
#line 2201
  bt->ev.fd = - 1;
#line 2202
  if (bt->tick == 0) {
#line 2202
    if (bt->lifespan == 0) {
      {
#line 2204
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2204
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2205
      __cil_tmp10 = malloc((unsigned long )256);
#line 2205
      bt->buf = (char *)__cil_tmp10;
      }
#line 2206
      if (bt->buf == (char *)0) {
        {
#line 2208
        Msg(0, (char *)strnomem);
#line 2209
        setbacktick(num, 0, 0, (char **)0);
        }
#line 2210
        return;
      }
      {
#line 2212
      bt->ev.type = 1;
#line 2213
      bt->ev.fd = readpipe(bt->cmdv);
#line 2214
      bt->ev.handler = (void (*)(struct event * , char * ))backtick_fn;
#line 2215
      bt->ev.data = (char *)bt;
      }
#line 2216
      if (bt->ev.fd >= 0) {
        {
#line 2217
        evenq(& bt->ev);
        }
      }
    }
  }
}
}
#line 2222 "/tmp/screen-3.9.15/screen.c"
static char *runbacktick(struct backtick *bt , int *tickp , time_t now , struct win *win ) 
{ 
  int f ;
  int i ;
  int l ;
  int j ;
  time_t now2 ;
  int __cil_tmp13 ;
  time_t __cil_tmp14 ;

  {
  {
#line 2231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2231
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2232
  if (bt->tick) {
#line 2232
    if (! *tickp) {
#line 2233
      *tickp = bt->tick;
    } else
#line 2232
    if (bt->tick < *tickp) {
#line 2233
      *tickp = bt->tick;
    }
  }
#line 2234
  if (bt->lifespan == 0) {
#line 2234
    if (bt->tick == 0) {
      _L: /* CIL Label */ 
      {
#line 2236
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2236
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2237
      return ((char *)bt->result);
    } else {
#line 2234
      goto _L___512;
    }
  } else
  _L___512: /* CIL Label */ 
#line 2234
  if (now < bt->bestbefore) {
#line 2234
    goto _L;
  }
  {
#line 2239
  f = readpipe(bt->cmdv);
  }
#line 2240
  if (f == -1) {
#line 2241
    return ((char *)bt->result);
  }
#line 2242
  i = 0;
  {
#line 2243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2243
    if (! (l > 0)) {
#line 2243
      goto while_break___1;
    }
    {
#line 2245
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2245
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2246
    i += l;
#line 2247
    j = 1;
    {
#line 2247
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2247
      if (! (j < l)) {
#line 2247
        goto while_break___3;
      }
#line 2248
      if ((int )bt->result[(i - j) - 1] == 10) {
#line 2249
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2247
    j ++;
#line 2250
    if (j == l) {
#line 2250
      if ((unsigned long )i == sizeof(bt->result)) {
#line 2252
        j = (int )(sizeof(bt->result) / 2UL);
#line 2253
        l = j + 1;
      }
    }
#line 2255
    if (j < l) {
      {
#line 2257
      bcopy((void const   *)(((char *)bt->result + i) - j), (void *)((char *)bt->result),
            (size_t )j);
#line 2258
      i = j;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2261
  close(f);
#line 2262
  bt->result[sizeof(bt->result) - 1UL] = (char )'\n';
  }
#line 2263
  if (i) {
#line 2263
    if ((int )bt->result[i - 1] == 10) {
#line 2264
      __cil_tmp13 = i;
#line 2264
      i --;
    }
  }
  {
#line 2265
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2265
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2266
  bt->result[i] = (char )0;
#line 2267
  backtick_filter(bt);
#line 2268
  __cil_tmp14 = time(& now2);
#line 2269
  bt->bestbefore = now2 + (long )bt->lifespan;
  }
#line 2270
  return ((char *)bt->result);
}
}
#line 2274 "/tmp/screen-3.9.15/screen.c"
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) 
{ 
  static int tick ;
  char *s ;
  register char *p ;
  register int ctrl ;
  struct timeval now ;
  struct tm *tm ;
  int l ;
  int i ;
  int r ;
  int num ;
  int zeroflg ;
  int longflg ;
  int minusflg ;
  int plusflg ;
  int qmflag ;
  int omflag ;
  int qmnumrend ;
  char *qmpos ;
  int numpad ;
  int lastpad ;
  int truncpos ;
  int truncper ;
  int trunclong ;
  struct backtick *bt ;
  char *__cil_tmp31 ;
  char *__cil_tmp35 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  time_t nowsec ;
  char *tmp ;
  char *tmp___515 ;
  char *tmp___516 ;
  char *tmp___517 ;
  char *tmp___518 ;
  char *tmp___519 ;
  size_t __cil_tmp47 ;
  size_t __cil_tmp48 ;
  size_t __cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char savebuf[256] ;
  int oldtick ;
  int oldnumrend ;
  char *__cil_tmp55 ;
  char *tmp___520 ;
  size_t __cil_tmp57 ;
  int __cil_tmp58 ;
  size_t __cil_tmp59 ;
  struct win *oldfore ;
  char *ss ;
  int tmp___521 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  char *__cil_tmp66 ;
  size_t __cil_tmp67 ;
  size_t __cil_tmp68 ;
  size_t __cil_tmp69 ;
  size_t __cil_tmp70 ;
  size_t __cil_tmp71 ;
  char rbuf[128] ;
  char *__cil_tmp77 ;
  size_t __cil_tmp78 ;
  size_t __cil_tmp79 ;
  char *__cil_tmp80 ;
  int tmp___525 ;
  char *__cil_tmp82 ;
  int tmp___526 ;
  int tmp___527 ;
  int left ;
  int trunc ;
  int __cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp93 ;
  char *tmp___530 ;
  size_t __cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;

  {
#line 2283
  s = str;
#line 2284
  p = (char *)winmsg_buf;
#line 2294
  qmflag = 0;
#line 2294
  omflag = 0;
#line 2294
  qmnumrend = 0;
#line 2295
  qmpos = (char *)0;
#line 2296
  numpad = 0;
#line 2297
  lastpad = 0;
#line 2298
  truncpos = - 1;
#line 2299
  truncper = 0;
#line 2300
  trunclong = 0;
#line 2303
  if (winmsg_numrend >= 0) {
#line 2304
    winmsg_numrend = 0;
  } else {
#line 2306
    winmsg_numrend = - winmsg_numrend;
  }
  {
#line 2308
  tick = 0;
#line 2309
  tm = (struct tm *)0;
#line 2310
  ctrl = 0;
#line 2311
  gettimeofday(& now, (struct timezone *)((void *)0));
  }
  {
#line 2312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2312
    if (! ((int )*s && l > 0)) {
#line 2312
      goto while_break;
    }
#line 2314
    *p = *s;
#line 2315
    if (ctrl) {
#line 2317
      ctrl = 0;
#line 2318
      if ((int )*s != 94) {
#line 2318
        if ((int )*s >= 64) {
#line 2319
          *p &= 31;
        }
      }
#line 2320
      goto while_continue;
    }
#line 2322
    if ((int )*s != esc) {
#line 2324
      if (esc == 37) {
        {
#line 2333
        if ((int )*s == '^') {
#line 2333
          goto case_94;
        }
#line 2337
        goto switch_default;
        case_94: /* CIL Label */ 
#line 2334
        ctrl = 1;
#line 2335
        __cil_tmp31 = p;
#line 2335
        p --;
#line 2335
        *__cil_tmp31 = (char )'^';
#line 2336
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2338
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 2341
      goto while_continue;
    }
#line 2343
    s ++;
#line 2343
    if ((int )*s == esc) {
#line 2344
      goto while_continue;
    }
#line 2345
    plusflg = (int )*s == 43;
#line 2345
    if (plusflg != 0) {
#line 2346
      s ++;
    }
#line 2347
    minusflg = (int )*s == 45;
#line 2347
    if (minusflg != 0) {
#line 2348
      s ++;
    }
#line 2349
    zeroflg = (int )*s == 48;
#line 2349
    if (zeroflg != 0) {
#line 2350
      s ++;
    }
#line 2351
    num = 0;
    {
#line 2352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2352
      if (! ((int )*s >= 48 && (int )*s <= 57)) {
#line 2352
        goto while_break___0;
      }
#line 2353
      __cil_tmp35 = s;
#line 2353
      s ++;
#line 2353
      num = num * 10 + ((int )*__cil_tmp35 - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2354
    longflg = (int )*s == 76;
#line 2354
    if (longflg != 0) {
#line 2355
      s ++;
    }
    {
#line 2358
    if ((int )*s == '?') {
#line 2358
      goto case_63;
    }
#line 2375
    if ((int )*s == ':') {
#line 2375
      goto case_58;
    }
#line 2394
    if ((int )*s == 'C') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'c') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 's') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'A') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'a') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'Y') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'y') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'M') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'm') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'D') {
#line 2394
      goto case_67;
    }
#line 2394
    if ((int )*s == 'd') {
#line 2394
      goto case_67;
    }
#line 2407
    if ((int )*s == 'd') {
#line 2407
      goto case_100___0;
    }
#line 2410
    if ((int )*s == 'D') {
#line 2410
      goto case_68___0;
    }
#line 2417
    if ((int )*s == 'm') {
#line 2417
      goto case_109___0;
    }
#line 2420
    if ((int )*s == 'M') {
#line 2420
      goto case_77___0;
    }
#line 2427
    if ((int )*s == 'y') {
#line 2427
      goto case_121___0;
    }
#line 2430
    if ((int )*s == 'Y') {
#line 2430
      goto case_89___0;
    }
#line 2433
    if ((int )*s == 'a') {
#line 2433
      goto case_97___0;
    }
#line 2436
    if ((int )*s == 'A') {
#line 2436
      goto case_65___0;
    }
#line 2439
    if ((int )*s == 's') {
#line 2439
      goto case_115___0;
    }
#line 2443
    if ((int )*s == 'c') {
#line 2443
      goto case_99___0;
    }
#line 2448
    if ((int )*s == 'C') {
#line 2448
      goto case_67___0;
    }
#line 2458
    if ((int )*s == 'l') {
#line 2458
      goto case_108;
    }
#line 2478
    if ((int )*s == 'h') {
#line 2478
      goto case_104;
    }
#line 2478
    if ((int )*s == '`') {
#line 2478
      goto case_104;
    }
#line 2518
    if ((int )*s == 'W') {
#line 2518
      goto case_87;
    }
#line 2518
    if ((int )*s == 'w') {
#line 2518
      goto case_87;
    }
#line 2538
    if ((int )*s == 'u') {
#line 2538
      goto case_117;
    }
#line 2546
    if ((int )*s == 'f') {
#line 2546
      goto case_102;
    }
#line 2554
    if ((int )*s == 't') {
#line 2554
      goto case_116;
    }
#line 2564
    if ((int )*s == '{') {
#line 2564
      goto case_123;
    }
#line 2591
    if ((int )*s == 'H') {
#line 2591
      goto case_72;
    }
#line 2601
    if ((int )*s == 'F') {
#line 2601
      goto case_70;
    }
#line 2607
    if ((int )*s == '>') {
#line 2607
      goto case_62;
    }
#line 2614
    if ((int )*s == '<') {
#line 2614
      goto case_60;
    }
#line 2614
    if ((int )*s == '=') {
#line 2614
      goto case_60;
    }
#line 2729
    if ((int )*s == 'n') {
#line 2729
      goto case_110;
    }
#line 2732
    goto switch_default___1;
    case_63: /* CIL Label */ 
#line 2359
    __cil_tmp37 = p;
#line 2359
    p --;
#line 2360
    if (qmpos) {
#line 2362
      if (! qmflag) {
#line 2362
        if (! omflag) {
          _L: /* CIL Label */ 
#line 2364
          p = qmpos;
#line 2365
          if (qmnumrend < winmsg_numrend) {
#line 2366
            winmsg_numrend = qmnumrend;
          }
        } else {
#line 2362
          goto _L___513;
        }
      } else
      _L___513: /* CIL Label */ 
#line 2362
      if (omflag == 1) {
#line 2362
        goto _L;
      }
#line 2368
      qmpos = (char *)0;
#line 2369
      goto switch_break___0;
    }
#line 2371
    qmpos = p;
#line 2372
    qmnumrend = winmsg_numrend;
#line 2373
    omflag = 0;
#line 2373
    qmflag = omflag;
#line 2374
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 2376
    __cil_tmp38 = p;
#line 2376
    p --;
#line 2377
    if (! qmpos) {
#line 2378
      goto switch_break___0;
    }
#line 2379
    if (qmflag) {
#line 2379
      if (omflag != 1) {
#line 2381
        omflag = 1;
#line 2382
        qmpos = p;
#line 2383
        qmnumrend = winmsg_numrend;
      } else {
#line 2379
        goto _L___514;
      }
    } else {
      _L___514: /* CIL Label */ 
#line 2387
      p = qmpos;
#line 2388
      if (qmnumrend < winmsg_numrend) {
#line 2389
        winmsg_numrend = qmnumrend;
      }
#line 2390
      omflag = - 1;
    }
#line 2392
    goto switch_break___0;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 2395
    if (l < 4) {
#line 2396
      goto switch_break___0;
    }
#line 2397
    if (tm == (struct tm *)0) {
      {
#line 2399
      nowsec = now.tv_sec;
#line 2400
      tm = localtime(& nowsec);
      }
    }
#line 2402
    qmflag = 1;
#line 2403
    if (! tick) {
#line 2404
      tick = 3600;
    } else
#line 2403
    if (tick > 3600) {
#line 2404
      tick = 3600;
    }
    {
#line 2407
    if ((int )*s == 'd') {
#line 2407
      goto case_100___0;
    }
#line 2410
    if ((int )*s == 'D') {
#line 2410
      goto case_68___0;
    }
#line 2417
    if ((int )*s == 'm') {
#line 2417
      goto case_109___0;
    }
#line 2420
    if ((int )*s == 'M') {
#line 2420
      goto case_77___0;
    }
#line 2427
    if ((int )*s == 'y') {
#line 2427
      goto case_121___0;
    }
#line 2430
    if ((int )*s == 'Y') {
#line 2430
      goto case_89___0;
    }
#line 2433
    if ((int )*s == 'a') {
#line 2433
      goto case_97___0;
    }
#line 2436
    if ((int )*s == 'A') {
#line 2436
      goto case_65___0;
    }
#line 2439
    if ((int )*s == 's') {
#line 2439
      goto case_115___0;
    }
#line 2443
    if ((int )*s == 'c') {
#line 2443
      goto case_99___0;
    }
#line 2448
    if ((int )*s == 'C') {
#line 2448
      goto case_67___0;
    }
#line 2453
    goto switch_default___0;
    case_100___0: /* CIL Label */ 
    {
#line 2408
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_mday % 100);
    }
#line 2409
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
#line 2412
    if (longflg) {
#line 2412
      tmp = (char *)"%A";
    } else {
#line 2412
      tmp = (char *)"%a";
    }
    {
#line 2412
    strftime(p, (size_t )l, (char const   *)tmp, tm);
    }
#line 2416
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    {
#line 2418
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_mon + 1);
    }
#line 2419
    goto switch_break___1;
    case_77___0: /* CIL Label */ 
#line 2422
    if (longflg) {
#line 2422
      tmp___515 = (char *)"%B";
    } else {
#line 2422
      tmp___515 = (char *)"%b";
    }
    {
#line 2422
    strftime(p, (size_t )l, (char const   *)tmp___515, tm);
    }
#line 2426
    goto switch_break___1;
    case_121___0: /* CIL Label */ 
    {
#line 2428
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_year % 100);
    }
#line 2429
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 2431
    sprintf(p, (char const   *)((char *)"%04d"), tm->tm_year + 1900);
    }
#line 2432
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 2434
    if (tm->tm_hour >= 12) {
#line 2434
      tmp___516 = (char *)"pm";
    } else {
#line 2434
      tmp___516 = (char *)"am";
    }
    {
#line 2434
    sprintf(p, (char const   *)tmp___516);
    }
#line 2435
    goto switch_break___1;
    case_65___0: /* CIL Label */ 
#line 2437
    if (tm->tm_hour >= 12) {
#line 2437
      tmp___517 = (char *)"PM";
    } else {
#line 2437
      tmp___517 = (char *)"AM";
    }
    {
#line 2437
    sprintf(p, (char const   *)tmp___517);
    }
#line 2438
    goto switch_break___1;
    case_115___0: /* CIL Label */ 
    {
#line 2440
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_sec);
    }
#line 2441
    tick = 1;
#line 2442
    goto switch_break___1;
    case_99___0: /* CIL Label */ 
#line 2444
    if (zeroflg) {
#line 2444
      tmp___518 = (char *)"%02d:%02d";
    } else {
#line 2444
      tmp___518 = (char *)"%2d:%02d";
    }
    {
#line 2444
    sprintf(p, (char const   *)tmp___518, tm->tm_hour, tm->tm_min);
    }
#line 2445
    if (! tick) {
#line 2446
      tick = 60;
    } else
#line 2445
    if (tick > 60) {
#line 2446
      tick = 60;
    }
#line 2447
    goto switch_break___1;
    case_67___0: /* CIL Label */ 
#line 2449
    if (zeroflg) {
#line 2449
      tmp___519 = (char *)"%02d:%02d";
    } else {
#line 2449
      tmp___519 = (char *)"%2d:%02d";
    }
    {
#line 2449
    sprintf(p, (char const   *)tmp___519, (tm->tm_hour + 11) % 12 + 1, tm->tm_min);
    }
#line 2450
    if (! tick) {
#line 2451
      tick = 60;
    } else
#line 2450
    if (tick > 60) {
#line 2451
      tick = 60;
    }
#line 2452
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2454
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 2456
    __cil_tmp47 = strlen((char const   *)p);
    }
#line 2456
    p += __cil_tmp47 - 1UL;
#line 2457
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 2460
    *p = (char )0;
#line 2461
    if (l > 20) {
      {
#line 2462
      AddLoadav(p);
      }
    }
#line 2463
    if (*p) {
      {
#line 2465
      qmflag = 1;
#line 2466
      __cil_tmp48 = strlen((char const   *)p);
      }
#line 2466
      p += __cil_tmp48 - 1UL;
    } else {
#line 2469
      *p = (char )'?';
    }
#line 2470
    if (! tick) {
#line 2471
      tick = 60;
    } else
#line 2470
    if (tick > 60) {
#line 2471
      tick = 60;
    }
    {
#line 2475
    __cil_tmp49 = strlen((char const   *)p);
    }
#line 2475
    p += __cil_tmp49 - 1UL;
#line 2476
    goto switch_break___0;
    case_104: /* CIL Label */ 
    case_96: /* CIL Label */ 
#line 2479
    if (rec >= 10) {
#line 2481
      __cil_tmp50 = p;
#line 2481
      p --;
#line 2482
      goto switch_break___0;
    } else
#line 2479
    if ((int )*s == 104) {
#line 2479
      if (win == (struct win *)0) {
#line 2481
        __cil_tmp50 = p;
#line 2481
        p --;
#line 2482
        goto switch_break___0;
      } else
#line 2479
      if (win->w_hstatus == (char *)0) {
#line 2481
        __cil_tmp50 = p;
#line 2481
        p --;
#line 2482
        goto switch_break___0;
      } else
#line 2479
      if ((int )*(win->w_hstatus) == 0) {
#line 2481
        __cil_tmp50 = p;
#line 2481
        p --;
#line 2482
        goto switch_break___0;
      }
    }
#line 2484
    if ((int )*s == 96) {
#line 2486
      bt = backticks;
      {
#line 2486
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2486
        if (! bt) {
#line 2486
          goto while_break___1;
        }
#line 2487
        if (bt->num == num) {
#line 2488
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2486
      bt = bt->next;
#line 2489
      if (bt == (struct backtick *)0) {
#line 2491
        __cil_tmp51 = p;
#line 2491
        p --;
#line 2492
        goto switch_break___0;
      }
    }
    {
#line 2497
    oldtick = tick;
#line 2498
    oldnumrend = winmsg_numrend;
#line 2500
    *p = (char )0;
#line 2501
    strcpy((char *)savebuf, (char const   *)((char *)winmsg_buf));
#line 2502
    winmsg_numrend = - winmsg_numrend;
    }
#line 2503
    if ((int )*s == 104) {
#line 2503
      tmp___520 = win->w_hstatus;
    } else {
      {
#line 2503
      __cil_tmp55 = runbacktick(bt, & oldtick, now.tv_sec, win);
#line 2503
      tmp___520 = __cil_tmp55;
      }
    }
    {
#line 2503
    MakeWinMsgEv(tmp___520, win, '\005', 0, (struct event *)0, rec + 1);
    }
    {
#line 2504
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2504
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2505
    if (! tick) {
#line 2506
      tick = oldtick;
    } else
#line 2505
    if (oldtick < tick) {
#line 2506
      tick = oldtick;
    }
    {
#line 2507
    __cil_tmp57 = strlen((char const   *)((char *)winmsg_buf));
    }
#line 2507
    if (__cil_tmp57 < (unsigned long )l) {
      {
#line 2508
      strcat((char *)savebuf, (char const   *)((char *)winmsg_buf));
      }
    }
    {
#line 2509
    strcpy((char *)winmsg_buf, (char const   *)((char *)savebuf));
    }
    {
#line 2510
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2510
      if (! (oldnumrend < winmsg_numrend)) {
#line 2510
        goto while_break___3;
      }
#line 2511
      __cil_tmp58 = oldnumrend;
#line 2511
      oldnumrend ++;
#line 2511
      winmsg_rendpos[__cil_tmp58] += p - (char *)winmsg_buf;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2512
    if (*p) {
#line 2513
      qmflag = 1;
    }
    {
#line 2514
    __cil_tmp59 = strlen((char const   *)p);
    }
#line 2514
    p += __cil_tmp59 - 1UL;
#line 2516
    goto switch_break___0;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 2520
    oldfore = (struct win *)0;
#line 2523
    if (display) {
#line 2525
      oldfore = display->d_fore;
#line 2526
      display->d_fore = win;
    }
#line 2528
    if (plusflg) {
#line 2528
      tmp___523 = 4;
    } else {
#line 2528
      tmp___523 = 0;
    }
#line 2528
    if (longflg) {
#line 2528
      tmp___522 = 0;
    } else {
#line 2528
      tmp___522 = 2;
    }
#line 2528
    if ((int )*s == 119) {
#line 2528
      tmp___521 = 0;
    } else {
#line 2528
      tmp___521 = 1;
    }
#line 2528
    if (win) {
#line 2528
      tmp___524 = win->w_number;
    } else {
#line 2528
      tmp___524 = - 1;
    }
    {
#line 2528
    __cil_tmp66 = AddWindows(p, l - 1, (tmp___521 | tmp___522) | tmp___523, tmp___524);
#line 2528
    ss = __cil_tmp66;
    }
#line 2529
    if (minusflg) {
#line 2530
      *ss = (char )0;
    }
#line 2531
    if (display) {
#line 2532
      display->d_fore = oldfore;
    }
#line 2534
    if (*p) {
#line 2535
      qmflag = 1;
    }
    {
#line 2536
    __cil_tmp67 = strlen((char const   *)p);
    }
#line 2536
    p += __cil_tmp67 - 1UL;
#line 2537
    goto switch_break___0;
    case_117: /* CIL Label */ 
#line 2539
    *p = (char )0;
#line 2540
    if (win) {
      {
#line 2541
      AddOtherUsers(p, l - 1, win);
      }
    }
#line 2542
    if (*p) {
#line 2543
      qmflag = 1;
    }
    {
#line 2544
    __cil_tmp68 = strlen((char const   *)p);
    }
#line 2544
    p += __cil_tmp68 - 1UL;
#line 2545
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 2547
    *p = (char )0;
#line 2548
    if (win) {
      {
#line 2549
      AddWindowFlags(p, l - 1, win);
      }
    }
#line 2550
    if (*p) {
#line 2551
      qmflag = 1;
    }
    {
#line 2552
    __cil_tmp69 = strlen((char const   *)p);
    }
#line 2552
    p += __cil_tmp69 - 1UL;
#line 2553
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 2555
    *p = (char )0;
    {
#line 2556
    __cil_tmp70 = strlen((char const   *)win->w_title);
    }
#line 2556
    if (win) {
#line 2556
      if (__cil_tmp70 < (unsigned long )l) {
        {
#line 2558
        strcpy(p, (char const   *)win->w_title);
        }
#line 2559
        if (*p) {
#line 2560
          qmflag = 1;
        }
      }
    }
    {
#line 2562
    __cil_tmp71 = strlen((char const   *)p);
    }
#line 2562
    p += __cil_tmp71 - 1UL;
#line 2563
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 2567
    s ++;
#line 2568
    i = 0;
    {
#line 2568
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2568
      if (! (i < 127)) {
#line 2568
        goto while_break___4;
      }
#line 2569
      if ((int )*(s + i)) {
#line 2569
        if ((int )*(s + i) != 125) {
#line 2570
          rbuf[i] = *(s + i);
        } else {
#line 2572
          goto while_break___4;
        }
      } else {
#line 2572
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2568
    i ++;
#line 2573
    if ((int )*(s + i) == 125) {
#line 2573
      if (winmsg_numrend < 16) {
#line 2575
        r = - 1;
#line 2576
        rbuf[i] = (char )0;
        {
#line 2577
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2577
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2578
        if (i != 1) {
          {
          {
#line 2579
          r = ParseAttrColor((char *)rbuf, (char *)0, 0);
          }
          }
        } else
#line 2578
        if ((int )rbuf[0] != 45) {
          {
          {
#line 2579
          r = ParseAttrColor((char *)rbuf, (char *)0, 0);
          }
          }
        }
#line 2580
        if (r != -1) {
#line 2582
          winmsg_rend[winmsg_numrend] = r;
#line 2583
          winmsg_rendpos[winmsg_numrend] = (int )(p - (char *)winmsg_buf);
#line 2584
          winmsg_numrend ++;
        } else
#line 2580
        if (i == 1) {
#line 2580
          if ((int )rbuf[0] == 45) {
#line 2582
            winmsg_rend[winmsg_numrend] = r;
#line 2583
            winmsg_rendpos[winmsg_numrend] = (int )(p - (char *)winmsg_buf);
#line 2584
            winmsg_numrend ++;
          }
        }
      }
    }
#line 2587
    s += i;
#line 2588
    __cil_tmp77 = p;
#line 2588
    p --;
#line 2590
    goto switch_break___0;
    case_72: /* CIL Label */ 
#line 2592
    *p = (char )0;
    {
#line 2593
    __cil_tmp78 = strlen((char const   *)((char *)HostName));
    }
#line 2593
    if (__cil_tmp78 < (unsigned long )l) {
      {
#line 2595
      strcpy(p, (char const   *)((char *)HostName));
      }
#line 2596
      if (*p) {
#line 2597
        qmflag = 1;
      }
    }
    {
#line 2599
    __cil_tmp79 = strlen((char const   *)p);
    }
#line 2599
    p += __cil_tmp79 - 1UL;
#line 2600
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 2602
    __cil_tmp80 = p;
#line 2602
    p --;
#line 2604
    if (ev) {
#line 2604
      if (ev == & (display->d_forecv)->c_captev) {
#line 2605
        qmflag = 1;
      } else {
#line 2604
        goto _L___523;
      }
    } else
    _L___523: /* CIL Label */ 
#line 2604
    if (! ev) {
#line 2604
      if (win) {
#line 2604
        if (win == display->d_fore) {
#line 2605
          qmflag = 1;
        }
      }
    }
#line 2606
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 2608
    truncpos = (int )(p - (char *)winmsg_buf);
#line 2609
    if (num > 100) {
#line 2609
      tmp___525 = 100;
    } else {
#line 2609
      tmp___525 = num;
    }
#line 2609
    truncper = tmp___525;
#line 2610
    trunclong = longflg;
#line 2611
    __cil_tmp82 = p;
#line 2611
    p --;
#line 2612
    goto switch_break___0;
    case_60: /* CIL Label */ 
    case_61: /* CIL Label */ 
#line 2615
    *p = (char )' ';
#line 2616
    if (num) {
      _L___526: /* CIL Label */ 
#line 2619
      if (minusflg) {
#line 2621
        if (plusflg) {
#line 2621
          tmp___526 = lastpad;
        } else {
#line 2621
          tmp___526 = padlen;
        }
#line 2621
        num = tmp___526 - num;
#line 2622
        if (! plusflg) {
#line 2622
          if (padlen == 0) {
#line 2623
            num = (int )(p - (char *)winmsg_buf);
          }
        }
#line 2624
        plusflg = 0;
      } else
#line 2626
      if (! zeroflg) {
#line 2628
        if ((int )*s != 61) {
#line 2628
          if (num == 0) {
#line 2628
            if (! plusflg) {
#line 2629
              num = 100;
            }
          }
        }
#line 2630
        if (num > 100) {
#line 2631
          num = 100;
        }
#line 2632
        if (padlen == 0) {
#line 2633
          num = (int )(p - (char *)winmsg_buf);
        } else {
#line 2635
          if (plusflg) {
#line 2635
            tmp___527 = lastpad;
          } else {
#line 2635
            tmp___527 = 0;
          }
#line 2635
          num = ((padlen - tmp___527) * num) / 100;
        }
      }
#line 2637
      if (num < 0) {
#line 2638
        num = 0;
      }
#line 2639
      if (plusflg) {
#line 2640
        num += lastpad;
      }
#line 2641
      if (num > 255) {
#line 2642
        num = 255;
      }
#line 2643
      if (numpad) {
        {
#line 2644
        p = pad_expand((char *)winmsg_buf, p, numpad, num);
        }
      }
#line 2645
      numpad = 0;
#line 2646
      if (p - (char *)winmsg_buf > (long )num) {
#line 2646
        if (! longflg) {
#line 2650
          if (truncpos == -1) {
#line 2652
            truncpos = lastpad;
#line 2653
            truncper = 0;
          }
#line 2655
          trunc = lastpad + (truncper * (num - lastpad)) / 100;
#line 2656
          if (trunc > num) {
#line 2657
            trunc = num;
          }
#line 2658
          if (trunc < lastpad) {
#line 2659
            trunc = lastpad;
          }
#line 2660
          left = truncpos - trunc;
#line 2661
          if ((long )left > (p - (char *)winmsg_buf) - (long )num) {
#line 2662
            left = (int )((p - (char *)winmsg_buf) - (long )num);
          }
          {
#line 2663
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2663
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 2664
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2664
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2665
          if (left > 0) {
#line 2667
            if ((long )(left + lastpad) > p - (char *)winmsg_buf) {
#line 2668
              left = (int )((p - (char *)winmsg_buf) - (long )lastpad);
            }
#line 2669
            if (((p - (char *)winmsg_buf) - (long )lastpad) - (long )left > 0L) {
              {
#line 2670
              bcopy((void const   *)(((char *)winmsg_buf + lastpad) + left), (void *)((char *)winmsg_buf + lastpad),
                    (size_t )(((p - (char *)winmsg_buf) - (long )lastpad) - (long )left));
              }
            }
#line 2671
            p -= left;
#line 2672
            r = winmsg_numrend;
            {
#line 2673
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 2673
              if (! (r && winmsg_rendpos[r - 1] > lastpad)) {
#line 2673
                goto while_break___8;
              }
#line 2675
              __cil_tmp88 = r;
#line 2675
              r --;
#line 2676
              winmsg_rendpos[r] -= left;
#line 2677
              if (winmsg_rendpos[r] < lastpad) {
#line 2678
                winmsg_rendpos[r] = lastpad;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
#line 2680
            if (trunclong) {
#line 2682
              if (p - (char *)winmsg_buf > (long )lastpad) {
#line 2683
                winmsg_buf[lastpad] = (char )'.';
              }
#line 2684
              if (p - (char *)winmsg_buf > (long )(lastpad + 1)) {
#line 2685
                winmsg_buf[lastpad + 1] = (char )'.';
              }
#line 2686
              if (p - (char *)winmsg_buf > (long )(lastpad + 2)) {
#line 2687
                winmsg_buf[lastpad + 2] = (char )'.';
              }
            }
          }
#line 2690
          if (p - (char *)winmsg_buf > (long )num) {
#line 2692
            p = (char *)winmsg_buf + num;
#line 2693
            if (trunclong) {
#line 2695
              if (num - 1 >= lastpad) {
#line 2696
                *(p + - 1) = (char )'.';
              }
#line 2697
              if (num - 2 >= lastpad) {
#line 2698
                *(p + - 2) = (char )'.';
              }
#line 2699
              if (num - 3 >= lastpad) {
#line 2700
                *(p + - 3) = (char )'.';
              }
            }
#line 2702
            r = winmsg_numrend;
            {
#line 2703
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2703
              if (! (r && winmsg_rendpos[r - 1] > num)) {
#line 2703
                goto while_break___9;
              }
#line 2704
              r --;
#line 2704
              winmsg_rendpos[r] = num;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 2706
          truncpos = - 1;
#line 2707
          trunclong = 0;
#line 2708
          if ((long )lastpad > p - (char *)winmsg_buf) {
#line 2709
            lastpad = (int )(p - (char *)winmsg_buf);
          }
          {
#line 2710
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2710
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
#line 2712
      if ((int )*s == 61) {
        {
#line 2714
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2714
          if (! (p - (char *)winmsg_buf < (long )num)) {
#line 2714
            goto while_break___11;
          }
#line 2715
          __cil_tmp89 = p;
#line 2715
          p ++;
#line 2715
          *__cil_tmp89 = (char )' ';
        }
        while_break___11: /* CIL Label */ ;
        }
#line 2716
        lastpad = (int )(p - (char *)winmsg_buf);
#line 2717
        truncpos = - 1;
#line 2718
        trunclong = 0;
        {
#line 2719
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2719
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 2721
      __cil_tmp90 = p;
#line 2721
      p --;
    } else
#line 2616
    if (zeroflg) {
#line 2616
      goto _L___526;
    } else
#line 2616
    if (plusflg) {
#line 2616
      goto _L___526;
    } else
#line 2616
    if (longflg) {
#line 2616
      goto _L___526;
    } else
#line 2616
    if ((int )*s != 61) {
#line 2616
      goto _L___526;
    } else
#line 2723
    if (padlen) {
#line 2725
      *p = (char )127;
#line 2726
      numpad ++;
    }
#line 2728
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 2730
    s ++;
    switch_default___1: /* CIL Label */ 
#line 2733
    __cil_tmp93 = s;
#line 2733
    s --;
#line 2734
    if (l > 10 + num) {
#line 2736
      if (num == 0) {
#line 2737
        num = 1;
      }
#line 2738
      if (! win) {
#line 2739
        if (num > 1) {
#line 2739
          tmp___530 = (char *)"--";
        } else {
#line 2739
          tmp___530 = (char *)"-";
        }
        {
#line 2739
        sprintf(p, (char const   *)((char *)"%*s"), num, tmp___530);
        }
      } else {
        {
#line 2741
        sprintf(p, (char const   *)((char *)"%*d"), num, win->w_number);
        }
      }
      {
#line 2742
      qmflag = 1;
#line 2743
      __cil_tmp95 = strlen((char const   *)p);
      }
#line 2743
      p += __cil_tmp95 - 1UL;
    }
#line 2745
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2312
  __cil_tmp97 = p;
#line 2312
  p ++;
#line 2312
  __cil_tmp96 = s;
#line 2312
  s ++;
#line 2748
  if (qmpos) {
#line 2748
    if (! qmflag) {
#line 2749
      p = qmpos + 1;
    }
  }
#line 2750
  *p = (char )'\000';
#line 2751
  if (numpad) {
#line 2753
    if (padlen > 255) {
#line 2754
      padlen = 255;
    }
    {
#line 2755
    p = pad_expand((char *)winmsg_buf, p, numpad, padlen);
    }
  }
#line 2757
  if (ev) {
    {
#line 2759
    evdeq(ev);
#line 2760
    ev->timeout.tv_sec = (__time_t )0;
#line 2761
    ev->timeout.tv_usec = (__suseconds_t )0;
    }
  }
#line 2763
  if (ev) {
#line 2763
    if (tick) {
#line 2765
      now.tv_usec = (__suseconds_t )100000;
#line 2766
      if (tick == 1) {
#line 2767
        (now.tv_sec) ++;
      } else {
#line 2769
        now.tv_sec += (long )tick - now.tv_sec % (long )tick;
      }
#line 2770
      ev->timeout = now;
      {
#line 2771
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2771
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
  }
#line 2773
  return ((char *)winmsg_buf);
}
}
#line 2777 "/tmp/screen-3.9.15/screen.c"
char *MakeWinMsg(char *s , struct win *win , int esc ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 2782
  __cil_tmp4 = MakeWinMsgEv(s, win, esc, 0, (struct event *)0, 0);
  }
#line 2782
  return (__cil_tmp4);
}
}
#line 2786 "/tmp/screen-3.9.15/screen.c"
int PutWinMsg(char *s , int start , int max ) 
{ 
  int i ;
  int p ;
  int l ;
  int r ;
  int n ;
  struct mchar rend ;
  struct mchar rendstack[16] ;
  int rendstackn ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp22 ;

  {
#line 2793
  rendstackn = 0;
#line 2795
  if (s != (char *)winmsg_buf) {
#line 2796
    return (0);
  }
  {
#line 2797
  rend = display->d_rend;
#line 2798
  p = 0;
#line 2799
  __cil_tmp12 = strlen((char const   *)s);
#line 2799
  l = (int )__cil_tmp12;
  }
  {
#line 2800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2801
  i = 0;
  {
#line 2801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2801
    if (! (i < winmsg_numrend && max > 0)) {
#line 2801
      goto while_break___0;
    }
#line 2803
    if (p > winmsg_rendpos[i]) {
#line 2804
      goto while_break___0;
    } else
#line 2803
    if (winmsg_rendpos[i] > l) {
#line 2804
      goto while_break___0;
    }
#line 2805
    if (p < winmsg_rendpos[i]) {
#line 2807
      n = winmsg_rendpos[i] - p;
#line 2808
      if (n > max) {
#line 2809
        n = max;
      }
#line 2810
      max -= n;
#line 2811
      p += n;
      {
#line 2812
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2812
        if (! (__cil_tmp13 > 0)) {
#line 2812
          goto while_break___1;
        }
#line 2814
        __cil_tmp14 = start;
#line 2814
        start --;
#line 2814
        if (__cil_tmp14 > 0) {
#line 2815
          s ++;
        } else {
          {
#line 2817
          __cil_tmp16 = s;
#line 2817
          s ++;
#line 2817
          PUTCHARLP((int )*__cil_tmp16);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2820
    r = winmsg_rend[i];
#line 2821
    if (r == -1) {
#line 2823
      if (rendstackn > 0) {
#line 2824
        rendstackn --;
#line 2824
        rend = rendstack[rendstackn];
      }
    } else {
      {
#line 2828
      __cil_tmp17 = rendstackn;
#line 2828
      rendstackn ++;
#line 2828
      rendstack[__cil_tmp17] = rend;
#line 2829
      ApplyAttrColor(r, & rend);
      }
    }
    {
#line 2831
    SetRendition(& rend);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2801
  i ++;
#line 2833
  if (p < l) {
#line 2835
    n = l - p;
#line 2836
    if (n > max) {
#line 2837
      n = max;
    }
    {
#line 2838
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2838
      if (! (__cil_tmp19 > 0)) {
#line 2838
        goto while_break___2;
      }
#line 2840
      __cil_tmp20 = start;
#line 2840
      start --;
#line 2840
      if (__cil_tmp20 > 0) {
#line 2841
        s ++;
      } else {
        {
#line 2843
        __cil_tmp22 = s;
#line 2843
        s ++;
#line 2843
        PUTCHARLP((int )*__cil_tmp22);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2846
  return (1);
}
}
#line 2850 "/tmp/screen-3.9.15/screen.c"
void DisplaySleep(int n , int eat ) 
{ 
  char buf ;
  fd_set r ;
  struct timeval t ;
  int __cil_tmp8 ;

  {
#line 2858
  if (! display) {
    {
#line 2860
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2860
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2861
    sleep((unsigned int )n);
    }
#line 2862
    return;
  }
#line 2864
  t.tv_usec = (__suseconds_t )0;
#line 2865
  t.tv_sec = (__time_t )n;
  {
#line 2866
  while (1) {
    while_continue___0: /* CIL Label */ ;
    __asm__  ("cld; rep; stosq":);
#line 2866
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2867
  r.__fds_bits[display->d_userfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << display->d_userfd % (8 * (int )sizeof(__fd_mask )));
#line 2868
  __cil_tmp8 = select(1024, & r, (fd_set *)0, (fd_set *)0, & t);
  }
#line 2868
  if (__cil_tmp8 > 0) {
    {
#line 2870
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2870
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2871
    if (eat) {
      {
#line 2872
      read(display->d_userfd, (void *)(& buf), (size_t )1);
      }
    }
  }
  {
#line 2874
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2874
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 2910 "/tmp/screen-3.9.15/screen.c"
static void serv_read_fn(struct event *ev , char *data ) 
{ 


  {
  {
#line 2914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2914
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2915
  ReceiveMsg();
  }
}
}
#line 2919 "/tmp/screen-3.9.15/screen.c"
static void serv_select_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char ibuf ;
  int tmp ;
  struct canvas *cv ;
  int visual ;
  char *__cil_tmp8 ;
  struct canvas *cv___0 ;
  char *__cil_tmp10 ;
  struct canvas *cv___1 ;
  int lx ;
  int ly ;
  int __cil_tmp14 ;
  int i ;
  int n ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int i___0 ;
  int n___0 ;
  struct display *olddisplay___0 ;
  struct layer *oldflayer___0 ;
  struct layer *l___0 ;
  struct canvas *cvlist___0 ;
  struct canvas *cvlnext___0 ;
  int i___1 ;
  int n___1 ;
  struct display *olddisplay___1 ;
  struct layer *oldflayer___1 ;
  struct layer *l___1 ;
  struct canvas *cvlist___1 ;
  struct canvas *cvlnext___1 ;
  int i___2 ;
  int n___2 ;
  struct display *olddisplay___2 ;
  struct layer *oldflayer___2 ;
  struct layer *l___2 ;
  struct canvas *cvlist___2 ;
  struct canvas *cvlnext___2 ;
  struct display *olddisplay___3 ;
  struct layer *oldflayer___3 ;
  struct layer *l___3 ;
  struct canvas *cvlist___3 ;
  struct canvas *cvlnext___3 ;

  {
  {
#line 2925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2925
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2927
  if (GotSigChld) {
    {
#line 2929
    SigChldHandler();
    }
  }
#line 2931
  if (InterruptPlease) {
    {
#line 2933
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2933
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2936
    if (fore) {
#line 2936
      if (displays) {
#line 2939
        ibuf = (char )displays->d_OldMode.tio.c_cc[0];
#line 2944
        if (fore->w_pwin && (fore->w_pwin)->p_fdpat & 4096) {
#line 2944
          tmp = (fore->w_pwin)->p_ptyfd;
        } else {
#line 2944
          tmp = fore->w_ptyfd;
        }
        {
#line 2944
        write(tmp, (void const   *)(& ibuf), (size_t )1);
        }
        {
#line 2946
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2946
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2947
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2947
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 2953
    InterruptPlease = 0;
  }
#line 2956
  p = windows;
  {
#line 2956
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2956
    if (! p) {
#line 2956
      goto while_break___3;
    }
#line 2958
    if (p->w_bell == 1) {
      _L___531: /* CIL Label */ 
#line 2961
      visual = p->w_bell == 3 || visual_bell;
#line 2962
      p->w_bell = 0;
#line 2963
      display = displays;
      {
#line 2963
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2963
        if (! display) {
#line 2963
          goto while_break___4;
        }
#line 2965
        cv = display->d_cvlist;
        {
#line 2965
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2965
          if (! cv) {
#line 2965
            goto while_break___5;
          }
#line 2966
          if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 2967
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2965
        cv = cv->c_next;
#line 2968
        if (cv == (struct canvas *)0) {
          {
#line 2970
          p->w_bell = 2;
#line 2971
          __cil_tmp8 = MakeWinMsg(BellString, p, '%');
#line 2971
          Msg(0, (char *)"%s", __cil_tmp8);
          }
        } else
#line 2973
        if (visual) {
#line 2973
          if (! display->d_tcs[43].str) {
#line 2973
            if (! display->d_status) {
              _L: /* CIL Label */ 
              {
#line 2975
              Msg(0, (char *)"%s", VisualBellString);
              }
#line 2976
              if (display->d_status) {
#line 2978
                display->d_status_bell = (char )1;
                {
#line 2979
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 2979
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 2980
                SetTimeout(& display->d_statusev, VBellWait * 1000);
                }
              }
            } else
#line 2973
            if (! display->d_status_bell) {
#line 2973
              goto _L;
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2963
      display = display->d_next;
#line 2985
      if (p->w_monitor == 2) {
#line 2986
        p->w_monitor = 3;
      }
      {
#line 2987
      WindowChanged(p, 'f');
      }
    } else
#line 2958
    if (p->w_bell == 3) {
#line 2958
      goto _L___531;
    }
#line 2989
    if (p->w_monitor == 2) {
#line 2992
      p->w_monitor = 1;
#line 2993
      display = displays;
      {
#line 2993
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2993
        if (! display) {
#line 2993
          goto while_break___7;
        }
#line 2995
        cv___0 = display->d_cvlist;
        {
#line 2995
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2995
          if (! cv___0) {
#line 2995
            goto while_break___8;
          }
#line 2996
          if ((cv___0->c_layer)->l_bottom == & p->w_layer) {
#line 2997
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2995
        cv___0 = cv___0->c_next;
#line 2998
        if (cv___0) {
#line 2999
          goto while_continue___7;
        }
#line 3001
        if (! ((int )*(p->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 3002
          goto while_continue___7;
        }
        {
#line 3004
        __cil_tmp10 = MakeWinMsg(ActivityString, p, '%');
#line 3004
        Msg(0, (char *)"%s", __cil_tmp10);
#line 3005
        p->w_monitor = 3;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 2993
      display = display->d_next;
#line 3007
      WindowChanged(p, 'f');
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2956
  p = p->w_next;
#line 3011
  display = displays;
  {
#line 3011
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3011
    if (! display) {
#line 3011
      goto while_break___9;
    }
#line 3014
    if (display->d_status == 1) {
#line 3015
      goto while_continue___9;
    }
#line 3017
    cv___1 = display->d_cvlist;
    {
#line 3017
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3017
      if (! cv___1) {
#line 3017
        goto while_break___10;
      }
#line 3022
      lx = (cv___1->c_layer)->l_x;
#line 3023
      ly = (cv___1->c_layer)->l_y;
#line 3024
      if (lx == (cv___1->c_layer)->l_width) {
#line 3025
        __cil_tmp14 = lx;
#line 3025
        lx --;
      }
#line 3026
      if (ly + cv___1->c_yoff < cv___1->c_ys) {
        {
#line 3028
        n = cv___1->c_ys - (ly + cv___1->c_yoff);
#line 3029
        cv___1->c_yoff = cv___1->c_ys - ly;
#line 3030
        RethinkViewportOffsets(cv___1);
        }
#line 3031
        if (n > (cv___1->c_layer)->l_height) {
#line 3032
          n = (cv___1->c_layer)->l_height;
        }
        {
#line 3033
        olddisplay = display;
#line 3033
        oldflayer = flayer;
#line 3033
        l = cv___1->c_layer;
#line 3033
        cvlist = l->l_cvlist;
#line 3033
        cvlnext = cv___1->c_lnext;
#line 3033
        flayer = l;
#line 3033
        l->l_cvlist = cv___1;
#line 3033
        cv___1->c_lnext = (struct canvas *)0;
#line 3033
        LScrollV(flayer, - n, 0, flayer->l_height - 1, 0);
#line 3033
        ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                          - 1,
                                                                                          - 1,
                                                                                          1);
#line 3033
        i = 0;
        }
        {
#line 3033
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 3033
          if (! (i < n)) {
#line 3033
            goto while_break___11;
          }
          {
#line 3033
          ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(i,
                                                                                            0,
                                                                                            flayer->l_width - 1,
                                                                                            1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 3033
        i ++;
#line 3033
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3033
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3033
        flayer = oldflayer;
#line 3033
        l->l_cvlist = cvlist;
#line 3033
        cv___1->c_lnext = cvlnext;
#line 3033
        display = olddisplay;
      } else
#line 3042
      if (ly + cv___1->c_yoff > cv___1->c_ye) {
        {
#line 3044
        n___0 = (ly + cv___1->c_yoff) - cv___1->c_ye;
#line 3045
        cv___1->c_yoff = cv___1->c_ye - ly;
#line 3046
        RethinkViewportOffsets(cv___1);
        }
#line 3047
        if (n___0 > (cv___1->c_layer)->l_height) {
#line 3048
          n___0 = (cv___1->c_layer)->l_height;
        }
        {
#line 3049
        olddisplay___0 = display;
#line 3049
        oldflayer___0 = flayer;
#line 3049
        l___0 = cv___1->c_layer;
#line 3049
        cvlist___0 = l___0->l_cvlist;
#line 3049
        cvlnext___0 = cv___1->c_lnext;
#line 3049
        flayer = l___0;
#line 3049
        l___0->l_cvlist = cv___1;
#line 3049
        cv___1->c_lnext = (struct canvas *)0;
#line 3049
        LScrollV(flayer, n___0, 0, (cv___1->c_layer)->l_height - 1, 0);
#line 3049
        ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                          - 1,
                                                                                          - 1,
                                                                                          1);
#line 3049
        i___0 = 0;
        }
        {
#line 3049
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 3049
          if (! (i___0 < n___0)) {
#line 3049
            goto while_break___12;
          }
          {
#line 3049
          ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))((i___0 + flayer->l_height) - n___0,
                                                                                            0,
                                                                                            flayer->l_width - 1,
                                                                                            1);
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 3049
        i___0 ++;
#line 3049
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3049
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3049
        flayer = oldflayer___0;
#line 3049
        l___0->l_cvlist = cvlist___0;
#line 3049
        cv___1->c_lnext = cvlnext___0;
#line 3049
        display = olddisplay___0;
      }
#line 3058
      if (lx + cv___1->c_xoff < cv___1->c_xs) {
#line 3060
        n___1 = cv___1->c_xs - (lx + cv___1->c_xoff);
#line 3061
        if (n___1 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3062
          n___1 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3063
        if (cv___1->c_xoff + n___1 > cv___1->c_xs) {
#line 3064
          n___1 = cv___1->c_xs - cv___1->c_xoff;
        }
        {
#line 3065
        cv___1->c_xoff += n___1;
#line 3066
        RethinkViewportOffsets(cv___1);
        }
#line 3067
        if (n___1 > (cv___1->c_layer)->l_width) {
#line 3068
          n___1 = (cv___1->c_layer)->l_width;
        }
        {
#line 3069
        olddisplay___1 = display;
#line 3069
        oldflayer___1 = flayer;
#line 3069
        l___1 = cv___1->c_layer;
#line 3069
        cvlist___1 = l___1->l_cvlist;
#line 3069
        cvlnext___1 = cv___1->c_lnext;
#line 3069
        flayer = l___1;
#line 3069
        l___1->l_cvlist = cv___1;
#line 3069
        cv___1->c_lnext = (struct canvas *)0;
#line 3069
        ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                          - 1,
                                                                                          - 1,
                                                                                          1);
#line 3069
        i___1 = 0;
        }
        {
#line 3069
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 3069
          if (! (i___1 < flayer->l_height)) {
#line 3069
            goto while_break___13;
          }
          {
#line 3069
          LScrollH(flayer, - n___1, i___1, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3069
          ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(i___1,
                                                                                            0,
                                                                                            n___1 - 1,
                                                                                            1);
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 3069
        i___1 ++;
#line 3069
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3069
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3069
        flayer = oldflayer___1;
#line 3069
        l___1->l_cvlist = cvlist___1;
#line 3069
        cv___1->c_lnext = cvlnext___1;
#line 3069
        display = olddisplay___1;
      } else
#line 3080
      if (lx + cv___1->c_xoff > cv___1->c_xe) {
#line 3082
        n___2 = (lx + cv___1->c_xoff) - cv___1->c_xe;
#line 3083
        if (n___2 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3084
          n___2 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3085
        if (((cv___1->c_xoff - n___2) + (cv___1->c_layer)->l_width) - 1 < cv___1->c_xe) {
#line 3086
          n___2 = ((cv___1->c_xoff + (cv___1->c_layer)->l_width) - 1) - cv___1->c_xe;
        }
        {
#line 3087
        cv___1->c_xoff -= n___2;
#line 3088
        RethinkViewportOffsets(cv___1);
        }
#line 3089
        if (n___2 > (cv___1->c_layer)->l_width) {
#line 3090
          n___2 = (cv___1->c_layer)->l_width;
        }
        {
#line 3091
        olddisplay___2 = display;
#line 3091
        oldflayer___2 = flayer;
#line 3091
        l___2 = cv___1->c_layer;
#line 3091
        cvlist___2 = l___2->l_cvlist;
#line 3091
        cvlnext___2 = cv___1->c_lnext;
#line 3091
        flayer = l___2;
#line 3091
        l___2->l_cvlist = cv___1;
#line 3091
        cv___1->c_lnext = (struct canvas *)0;
#line 3091
        ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1,
                                                                                          - 1,
                                                                                          - 1,
                                                                                          1);
#line 3091
        i___2 = 0;
        }
        {
#line 3091
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3091
          if (! (i___2 < flayer->l_height)) {
#line 3091
            goto while_break___14;
          }
          {
#line 3091
          LScrollH(flayer, n___2, i___2, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3091
          ((void (*)(int  , int  , int  , int  ))*((flayer->l_layfn)->lf_LayRedisplayLine))(i___2,
                                                                                            flayer->l_width - n___2,
                                                                                            flayer->l_width - 1,
                                                                                            1);
          }
        }
        while_break___14: /* CIL Label */ ;
        }
#line 3091
        i___2 ++;
#line 3091
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3091
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3091
        flayer = oldflayer___2;
#line 3091
        l___2->l_cvlist = cvlist___2;
#line 3091
        cv___1->c_lnext = cvlnext___2;
#line 3091
        display = olddisplay___2;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 3017
    cv___1 = cv___1->c_next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3011
  display = display->d_next;
#line 3105
  display = displays;
  {
#line 3105
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 3105
    if (! display) {
#line 3105
      goto while_break___15;
    }
#line 3107
    if (display->d_status == 1) {
#line 3108
      goto while_continue___15;
    } else
#line 3107
    if (display->d_cvlist == (struct canvas *)0) {
#line 3108
      goto while_continue___15;
    } else
#line 3107
    if ((display->d_cvlist)->c_next == (struct canvas *)0) {
#line 3108
      goto while_continue___15;
    }
    {
#line 3109
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3109
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 3110
    olddisplay___3 = display;
#line 3110
    oldflayer___3 = flayer;
#line 3110
    l___3 = (display->d_forecv)->c_layer;
#line 3110
    cvlist___3 = l___3->l_cvlist;
#line 3110
    cvlnext___3 = (display->d_forecv)->c_lnext;
#line 3110
    flayer = l___3;
#line 3110
    l___3->l_cvlist = display->d_forecv;
#line 3110
    (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 3110
    ((void (*)(void))*((flayer->l_layfn)->lf_LayRestore))();
#line 3110
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 3110
    flayer = oldflayer___3;
#line 3110
    l___3->l_cvlist = cvlist___3;
#line 3110
    (display->d_forecv)->c_lnext = cvlnext___3;
#line 3110
    display = olddisplay___3;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 3105
  display = display->d_next;
}
}
#line 3115 "/tmp/screen-3.9.15/screen.c"
static void logflush_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char *buf ;
  int n ;
  int __cil_tmp6 ;
  int tmp ;
  size_t __cil_tmp9 ;

  {
  {
#line 3123
  __cil_tmp6 = islogfile((char *)((void *)0));
  }
#line 3123
  if (! __cil_tmp6) {
#line 3124
    return;
  }
  {
#line 3125
  logfflush((struct logfile *)((void *)0));
  }
#line 3126
  if (log_flush) {
#line 3126
    tmp = log_flush;
  } else {
#line 3126
    tmp = (logtstamp_after + 4) / 5;
  }
#line 3126
  n = tmp;
#line 3127
  if (n) {
    {
#line 3129
    SetTimeout(ev, n * 1000);
#line 3130
    evenq(ev);
    }
  }
#line 3132
  if (! logtstamp_on) {
#line 3133
    return;
  }
#line 3135
  p = windows;
  {
#line 3135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3135
    if (! p) {
#line 3135
      goto while_break;
    }
#line 3137
    if (! p->w_log) {
#line 3138
      goto while_continue;
    }
#line 3139
    p->w_logsilence += n;
#line 3140
    if (p->w_logsilence < logtstamp_after) {
#line 3141
      goto while_continue;
    }
#line 3142
    if (p->w_logsilence - n >= logtstamp_after) {
#line 3143
      goto while_continue;
    }
    {
#line 3144
    buf = MakeWinMsg(logtstamp_string, p, '%');
#line 3145
    __cil_tmp9 = strlen((char const   *)buf);
#line 3145
    logfwrite(p->w_log, buf, (int )__cil_tmp9);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3135
  p = p->w_next;
}
}
