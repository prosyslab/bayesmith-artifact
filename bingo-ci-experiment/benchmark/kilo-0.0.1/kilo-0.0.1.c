/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios *__termios_p ) ;
#line 46 "/usr/include/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 549
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 592
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 614
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 32 "/usr/include/clang/9.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 149 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE ;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 137
extern _IO_FILE *stderr ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 312
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 340
extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __maxlen , char const   *__format 
                                                  , ...) ;
#line 344
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 385
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 400
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 775
extern void perror(char const   *__s ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 46
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 63
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 329
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s ) ;
#line 396
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 782
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 1017
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 157 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 93
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 70 "kilo.c"
struct editorSyntax {
   char **filematch ;
   char **keywords ;
   char singleline_comment_start[2] ;
   char multiline_comment_start[3] ;
   char multiline_comment_end[3] ;
   int flags ;
};
#line 80 "kilo.c"
struct erow {
   int idx ;
   int size ;
   int rsize ;
   char *chars ;
   char *render ;
   unsigned char *hl ;
   int hl_oc ;
};
#line 89 "kilo.c"
typedef struct erow erow;
#line 95 "kilo.c"
struct editorConfig {
   int cx ;
   int cy ;
   int rowoff ;
   int coloff ;
   int screenrows ;
   int screencols ;
   int numrows ;
   int rawmode ;
   erow *row ;
   int dirty ;
   char *filename ;
   char statusmsg[80] ;
   time_t statusmsg_time ;
   struct editorSyntax *syntax ;
};
#line 111
static struct editorConfig E ;
#line 140
void editorSetStatusMessage(char const   *fmt  , ...) ;
#line 164 "kilo.c"
char *C_HL_extensions[]  = {      (char *)".c",      (char *)".h",      (char *)".cpp",      (char *)".hpp", 
        (char *)".cc",      (char *)((void *)0)};
#line 165 "kilo.c"
char *C_HL_keywords[]  = 
#line 165
  {      (char *)"auto",      (char *)"break",      (char *)"case",      (char *)"continue", 
        (char *)"default",      (char *)"do",      (char *)"else",      (char *)"enum", 
        (char *)"extern",      (char *)"for",      (char *)"goto",      (char *)"if", 
        (char *)"register",      (char *)"return",      (char *)"sizeof",      (char *)"static", 
        (char *)"struct",      (char *)"switch",      (char *)"typedef",      (char *)"union", 
        (char *)"volatile",      (char *)"while",      (char *)"NULL",      (char *)"alignas", 
        (char *)"alignof",      (char *)"and",      (char *)"and_eq",      (char *)"asm", 
        (char *)"bitand",      (char *)"bitor",      (char *)"class",      (char *)"compl", 
        (char *)"constexpr",      (char *)"const_cast",      (char *)"deltype",      (char *)"delete", 
        (char *)"dynamic_cast",      (char *)"explicit",      (char *)"export",      (char *)"false", 
        (char *)"friend",      (char *)"inline",      (char *)"mutable",      (char *)"namespace", 
        (char *)"new",      (char *)"noexcept",      (char *)"not",      (char *)"not_eq", 
        (char *)"nullptr",      (char *)"operator",      (char *)"or",      (char *)"or_eq", 
        (char *)"private",      (char *)"protected",      (char *)"public",      (char *)"reinterpret_cast", 
        (char *)"static_assert",      (char *)"static_cast",      (char *)"template",      (char *)"this", 
        (char *)"thread_local",      (char *)"throw",      (char *)"true",      (char *)"try", 
        (char *)"typeid",      (char *)"typename",      (char *)"virtual",      (char *)"xor", 
        (char *)"xor_eq",      (char *)"int|",      (char *)"long|",      (char *)"double|", 
        (char *)"float|",      (char *)"char|",      (char *)"unsigned|",      (char *)"signed|", 
        (char *)"void|",      (char *)"short|",      (char *)"auto|",      (char *)"const|", 
        (char *)"bool|",      (char *)((void *)0)};
#line 187 "kilo.c"
struct editorSyntax HLDB[]  = {      {(char **)C_HL_extensions, (char **)C_HL_keywords, {"//", "/*"}, {"*/", 1 | (1 << 1),
                                                                       (char )0},
      {(char )0, (char )0, (char )0}, 0}};
#line 201
static struct termios orig_termios ;
#line 203 "kilo.c"
void disableRawMode(int fd ) 
{ 


  {
#line 205
  if (E.rawmode) {
    {
#line 206
    tcsetattr(fd, 2, & orig_termios);
#line 207
    E.rawmode = 0;
    }
  }
}
}
#line 212 "kilo.c"
void editorAtExit(void) 
{ 


  {
  {
#line 213
  disableRawMode(0);
  }
}
}
#line 217 "kilo.c"
int enableRawMode(int fd ) 
{ 
  struct termios raw ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 220
  if (E.rawmode) {
#line 220
    return (0);
  }
  {
#line 221
  __cil_tmp3 = isatty(0);
  }
#line 221
  if (! __cil_tmp3) {
#line 221
    goto fatal;
  }
  {
#line 222
  atexit(editorAtExit);
#line 223
  __cil_tmp4 = tcgetattr(fd, & orig_termios);
  }
#line 223
  if (__cil_tmp4 == -1) {
#line 223
    goto fatal;
  }
  {
#line 225
  raw = orig_termios;
#line 228
  raw.c_iflag &= (unsigned int )(~ 1330);
#line 230
  raw.c_oflag &= (unsigned int )(~ 1);
#line 232
  raw.c_cflag |= (unsigned int )48;
#line 235
  raw.c_lflag &= (unsigned int )(~ 32779);
#line 237
  raw.c_cc[6] = (cc_t )0;
#line 238
  raw.c_cc[5] = (cc_t )1;
#line 241
  __cil_tmp5 = tcsetattr(fd, 2, & raw);
  }
#line 241
  if (__cil_tmp5 < 0) {
#line 241
    goto fatal;
  }
#line 242
  E.rawmode = 1;
#line 243
  return (0);
  fatal: 
  {
#line 246
  __cil_tmp6 = __errno_location();
#line 246
  *__cil_tmp6 = 25;
  }
#line 247
  return (- 1);
}
}
#line 252 "kilo.c"
int editorReadKey(int fd ) 
{ 
  int nread ;
  char c ;
  char seq[3] ;
  ssize_t __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  ssize_t __cil_tmp8 ;

  {
  {
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;

#line 255
    if (! (nread == 0)) {
#line 255
      goto while_break;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (nread == -1) {
    {
#line 256
    exit(1);
    }
  }
  {
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 260
    if ((int )c == 27) {
#line 260
      goto case_27;
    }
#line 272
    if ((int )c == '3') {
#line 272
      goto case_51;
    }
#line 273
    if ((int )c == '5') {
#line 273
      goto case_53;
    }
#line 274
    if ((int )c == '6') {
#line 274
      goto case_54;
    }
#line 279
    if ((int )c == 'A') {
#line 279
      goto case_65;
    }
#line 280
    if ((int )c == 'B') {
#line 280
      goto case_66;
    }
#line 281
    if ((int )c == 'C') {
#line 281
      goto case_67;
    }
#line 282
    if ((int )c == 'D') {
#line 282
      goto case_68;
    }
#line 283
    if ((int )c == 'H') {
#line 283
      goto case_72;
    }
#line 284
    if ((int )c == 'F') {
#line 284
      goto case_70;
    }
#line 292
    if ((int )c == 'H') {
#line 292
      goto case_72___0;
    }
#line 293
    if ((int )c == 'F') {
#line 293
      goto case_70___0;
    }
#line 297
    goto switch_default;
    case_27: /* CIL Label */ 
    {
#line 262
    __cil_tmp6 = read(fd, (void *)((char *)seq), (size_t )1);
    }
#line 262
    if (__cil_tmp6 == 0L) {
#line 262
      return (27);
    }
    {
#line 263
    __cil_tmp7 = read(fd, (void *)((char *)seq + 1), (size_t )1);
    }
#line 263
    if (__cil_tmp7 == 0L) {
#line 263
      return (27);
    }
#line 266
    if ((int )seq[0] == 91) {
#line 267
      if ((int )seq[1] >= 48) {
#line 267
        if ((int )seq[1] <= 57) {
          {
#line 269
          __cil_tmp8 = read(fd, (void *)((char *)seq + 2), (size_t )1);
          }
#line 269
          if (__cil_tmp8 == 0L) {
#line 269
            return (27);
          }
#line 270
          if ((int )seq[2] == 126) {
            {
#line 272
            if ((int )seq[1] == '3') {
#line 272
              goto case_51;
            }
#line 273
            if ((int )seq[1] == '5') {
#line 273
              goto case_53;
            }
#line 274
            if ((int )seq[1] == '6') {
#line 274
              goto case_54;
            }
#line 271
            goto switch_break___0;
            case_51: /* CIL Label */ 
#line 272
            return (1004);
            case_53: /* CIL Label */ 
#line 273
            return (1007);
            case_54: /* CIL Label */ 
#line 274
            return (1008);
            switch_break___0: /* CIL Label */ ;
            }
          }
        } else {
#line 267
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 279
        if ((int )seq[1] == 'A') {
#line 279
          goto case_65;
        }
#line 280
        if ((int )seq[1] == 'B') {
#line 280
          goto case_66;
        }
#line 281
        if ((int )seq[1] == 'C') {
#line 281
          goto case_67;
        }
#line 282
        if ((int )seq[1] == 'D') {
#line 282
          goto case_68;
        }
#line 283
        if ((int )seq[1] == 'H') {
#line 283
          goto case_72;
        }
#line 284
        if ((int )seq[1] == 'F') {
#line 284
          goto case_70;
        }
#line 278
        goto switch_break___1;
        case_65: /* CIL Label */ 
#line 279
        return (1002);
        case_66: /* CIL Label */ 
#line 280
        return (1003);
        case_67: /* CIL Label */ 
#line 281
        return (1001);
        case_68: /* CIL Label */ 
#line 282
        return (1000);
        case_72: /* CIL Label */ 
#line 283
        return (1005);
        case_70: /* CIL Label */ 
#line 284
        return (1006);
        switch_break___1: /* CIL Label */ ;
        }
      }
    } else
#line 290
    if ((int )seq[0] == 79) {
      {
#line 292
      if ((int )seq[1] == 'H') {
#line 292
        goto case_72___0;
      }
#line 293
      if ((int )seq[1] == 'F') {
#line 293
        goto case_70___0;
      }
#line 291
      goto switch_break___2;
      case_72___0: /* CIL Label */ 
#line 292
      return (1005);
      case_70___0: /* CIL Label */ 
#line 293
      return (1006);
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 296
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 298
    return ((int )c);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  }
}
}
#line 306 "kilo.c"
int getCursorPosition(int ifd , int ofd , int *rows , int *cols ) 
{ 
  char buf[32] ;
  unsigned int i ;
  ssize_t __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp10 ;

  {
  {
#line 308
  i = (unsigned int )0;
#line 311
  __cil_tmp7 = write(ofd, (void const   *)((char *)"\033[6n"), (size_t )4);
  }
#line 311
  if (__cil_tmp7 != 4L) {
#line 311
    return (- 1);
  }
  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;

#line 314
    if (! ((unsigned long )i < sizeof(buf) - 1UL)) {
#line 314
      goto while_break;
    }
    {
#line 315
    __cil_tmp8 = read(ifd, (void *)((char *)buf + i), (size_t )1);
    }
#line 315
    if (__cil_tmp8 != 1L) {
#line 315
      goto while_break;
    }
#line 316
    if ((int )buf[i] == 82) {
#line 316
      goto while_break;
    }
#line 317
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  buf[i] = (char )'\000';
#line 322
  if ((int )buf[0] != 27) {
#line 322
    return (- 1);
  } else
#line 322
  if ((int )buf[1] != 91) {
#line 322
    return (- 1);
  }
  {
#line 323
  __cil_tmp10 = sscanf((char const   *)((char *)buf + 2), (char const   *)((char *)"%d;%d"),
                       rows, cols);
  }
#line 323
  if (__cil_tmp10 != 2) {
#line 323
    return (- 1);
  }
#line 324
  return (0);
}
}
#line 330 "kilo.c"
int getWindowSize(int ifd , int ofd , int *rows , int *cols ) 
{ 
  struct winsize ws ;
  int __cil_tmp6 ;
  int orig_row ;
  int orig_col ;
  int retval ;
  ssize_t __cil_tmp11 ;
  char seq[32] ;
  size_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 333
  __cil_tmp6 = ioctl(1, (unsigned long )21523, & ws);
  }
#line 333
  if (__cil_tmp6 == -1) {
    _L: /* CIL Label */ 
    {
#line 338
    retval = getCursorPosition(ifd, ofd, & orig_row, & orig_col);
    }
#line 339
    if (retval == -1) {
#line 339
      goto failed;
    }
    {
#line 342
    __cil_tmp11 = write(ofd, (void const   *)((char *)"\033[999C\033[999B"), (size_t )12);
    }
#line 342
    if (__cil_tmp11 != 12L) {
#line 342
      goto failed;
    }
    {
#line 343
    retval = getCursorPosition(ifd, ofd, rows, cols);
    }
#line 344
    if (retval == -1) {
#line 344
      goto failed;
    }
    {
#line 348
    snprintf((char *)seq, (unsigned long )32, (char const   *)((char *)"\033[%d;%dH"),
             orig_row, orig_col);
#line 349
    __cil_tmp14 = strlen((char const   *)((char *)seq));
#line 349
    __cil_tmp15 = write(ofd, (void const   *)((char *)seq), __cil_tmp14);
    }
#line 349
    if (__cil_tmp15 == -1L) {

    }
#line 352
    return (0);
  } else
#line 333
  if ((int )ws.ws_col == 0) {
#line 333
    goto _L;
  } else {
#line 354
    *cols = (int )ws.ws_col;
#line 355
    *rows = (int )ws.ws_row;
#line 356
    return (0);
  }
  failed: 
#line 360
  return (- 1);
}
}
#line 365 "kilo.c"
int is_separator(int c ) 
{ 
  unsigned short const   **__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 366
  __cil_tmp3 = strchr((char const   *)((char *)",.()+-/*=~%[];"), c);
  }
  {
#line 366
  __cil_tmp2 = __ctype_b_loc();
  }
#line 366
  return ((c == 0 || (int )((unsigned short )*(*__cil_tmp2 + c)) & 8192) || __cil_tmp3 != (char *)((void *)0));
}
}
#line 372 "kilo.c"
int editorRowHasOpenComment(erow *row ) 
{ 


  {
#line 373
  if (row->hl) {
#line 373
    if (row->rsize) {
#line 373
      if ((int )*(row->hl + (row->rsize - 1)) == 3) {
#line 373
        if (row->rsize < 2) {
#line 375
          return (1);
        } else
#line 373
        if ((int )*(row->render + (row->rsize - 2)) != 42) {
#line 375
          return (1);
        } else
#line 373
        if ((int )*(row->render + (row->rsize - 1)) != 47) {
#line 375
          return (1);
        }
      }
    }
  }
#line 376
  return (0);
}
}
#line 381 "kilo.c"
void editorUpdateSyntax(erow *row ) 
{ 
  void *__cil_tmp2 ;
  int i ;
  int prev_sep ;
  int in_string ;
  int in_comment ;
  char *p ;
  char **keywords ;
  char *scs ;
  char *mcs ;
  char *mce ;
  unsigned short const   **__cil_tmp12 ;
  int __cil_tmp15 ;
  unsigned short const   **__cil_tmp22 ;
  unsigned short const   **__cil_tmp25 ;
  int j ;
  int klen ;
  size_t __cil_tmp30 ;
  int kw2 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int tmp ;
  int oc ;
  int __cil_tmp41 ;

  {
  {
#line 382
  __cil_tmp2 = realloc((void *)row->hl, (unsigned long )row->rsize);
#line 382
  row->hl = (unsigned char *)__cil_tmp2;
#line 383
  memset((void *)row->hl, 0, (unsigned long )row->rsize);
  }
#line 385
  if (E.syntax == (struct editorSyntax *)((void *)0)) {
#line 385
    return;
  }
#line 389
  keywords = (E.syntax)->keywords;
#line 390
  scs = (char *)(E.syntax)->singleline_comment_start;
#line 391
  mcs = (char *)(E.syntax)->multiline_comment_start;
#line 392
  mce = (char *)(E.syntax)->multiline_comment_end;
#line 395
  p = row->render;
#line 396
  i = 0;
  {
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;

#line 397
    if (! ((int )*p && (int )((unsigned short )*(*__cil_tmp12 + (int )*p)) & 8192)) {
#line 397
      goto while_break;
    }
#line 398
    p ++;
#line 399
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  prev_sep = 1;
#line 402
  in_string = 0;
#line 403
  in_comment = 0;
#line 407
  __cil_tmp15 = editorRowHasOpenComment(& *(E.row + (row->idx - 1)));
  }
#line 407
  if (row->idx > 0) {
#line 407
    if (__cil_tmp15) {
#line 408
      in_comment = 1;
    }
  }
  {
  {
#line 410
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! *p) {
#line 410
      goto while_break___0;
    }
#line 412
    if (prev_sep) {
#line 412
      if ((int )*p == (int )*(scs + 0)) {
#line 412
        if ((int )*(p + 1) == (int )*(scs + 1)) {
          {
#line 414
          memset((void *)(row->hl + i), 2, (unsigned long )(row->size - i));
          }
#line 415
          return;
        }
      }
    }
#line 419
    if (in_comment) {
#line 420
      *(row->hl + i) = (unsigned char )3;
#line 421
      if ((int )*p == (int )*(mce + 0)) {
#line 421
        if ((int )*(p + 1) == (int )*(mce + 1)) {
#line 422
          *(row->hl + (i + 1)) = (unsigned char )3;
#line 423
          p += 2;
#line 423
          i += 2;
#line 424
          in_comment = 0;
#line 425
          prev_sep = 1;
#line 426
          goto while_continue___0;
        } else {
#line 428
          prev_sep = 0;
#line 429
          p ++;
#line 429
          i ++;
#line 430
          goto while_continue___0;
        }
      } else {
#line 428
        prev_sep = 0;
#line 429
        p ++;
#line 429
        i ++;
#line 430
        goto while_continue___0;
      }
    } else
#line 432
    if ((int )*p == (int )*(mcs + 0)) {
#line 432
      if ((int )*(p + 1) == (int )*(mcs + 1)) {
#line 433
        *(row->hl + i) = (unsigned char )3;
#line 434
        *(row->hl + (i + 1)) = (unsigned char )3;
#line 435
        p += 2;
#line 435
        i += 2;
#line 436
        in_comment = 1;
#line 437
        prev_sep = 0;
#line 438
        goto while_continue___0;
      }
    }
#line 442
    if (in_string) {
#line 443
      *(row->hl + i) = (unsigned char )6;
#line 444
      if ((int )*p == 92) {
#line 445
        *(row->hl + (i + 1)) = (unsigned char )6;
#line 446
        p += 2;
#line 446
        i += 2;
#line 447
        prev_sep = 0;
#line 448
        goto while_continue___0;
      }
#line 450
      if ((int )*p == in_string) {
#line 450
        in_string = 0;
      }
#line 451
      p ++;
#line 451
      i ++;
#line 452
      goto while_continue___0;
    } else
#line 454
    if ((int )*p == 34) {
#line 455
      in_string = (int )*p;
#line 456
      *(row->hl + i) = (unsigned char )6;
#line 457
      p ++;
#line 457
      i ++;
#line 458
      prev_sep = 0;
#line 459
      goto while_continue___0;
    } else
#line 454
    if ((int )*p == 39) {
#line 455
      in_string = (int )*p;
#line 456
      *(row->hl + i) = (unsigned char )6;
#line 457
      p ++;
#line 457
      i ++;
#line 458
      prev_sep = 0;
#line 459
      goto while_continue___0;
    }
    {
#line 464
    __cil_tmp22 = __ctype_b_loc();
    }
#line 464
    if (! ((int )((unsigned short )*(*__cil_tmp22 + (int )*p)) & 16384)) {
#line 465
      *(row->hl + i) = (unsigned char )1;
#line 466
      p ++;
#line 466
      i ++;
#line 467
      prev_sep = 0;
#line 468
      goto while_continue___0;
    }
    {
#line 472
    __cil_tmp25 = __ctype_b_loc();
    }
#line 472
    if ((int )((unsigned short )*(*__cil_tmp25 + (int )*p)) & 2048) {
#line 472
      if (prev_sep) {
#line 474
        *(row->hl + i) = (unsigned char )7;
#line 475
        p ++;
#line 475
        i ++;
#line 476
        prev_sep = 0;
#line 477
        goto while_continue___0;
      } else
#line 472
      if ((int )*(row->hl + (i - 1)) == 7) {
#line 474
        *(row->hl + i) = (unsigned char )7;
#line 475
        p ++;
#line 475
        i ++;
#line 476
        prev_sep = 0;
#line 477
        goto while_continue___0;
      } else {
#line 472
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 472
    if ((int )*p == 46) {
#line 472
      if (i > 0) {
#line 472
        if ((int )*(row->hl + (i - 1)) == 7) {
#line 474
          *(row->hl + i) = (unsigned char )7;
#line 475
          p ++;
#line 475
          i ++;
#line 476
          prev_sep = 0;
#line 477
          goto while_continue___0;
        }
      }
    }
#line 481
    if (prev_sep) {
#line 483
      j = 0;
      {
      {
#line 483
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 483
        if (! *(keywords + j)) {
#line 483
          goto while_break___1;
        }
        {
#line 484
        __cil_tmp30 = strlen((char const   *)*(keywords + j));
#line 484
        klen = (int )__cil_tmp30;
#line 485
        kw2 = (int )*(*(keywords + j) + (klen - 1)) == 124;
        }
#line 486
        if (kw2) {
#line 486
          __cil_tmp32 = klen;
#line 486
          klen --;
        }
        {
#line 488
        __cil_tmp34 = is_separator((int )*(p + klen));
        }
        {
#line 488
        __cil_tmp33 = memcmp((void const   *)p, (void const   *)*(keywords + j), (unsigned long )klen);
        }
#line 488
        if (! __cil_tmp33) {
#line 488
          if (__cil_tmp34) {
#line 492
            if (kw2) {
#line 492
              tmp = 5;
            } else {
#line 492
              tmp = 4;
            }
            {
#line 492
            memset((void *)(row->hl + i), tmp, (unsigned long )klen);
#line 493
            p += klen;
#line 494
            i += klen;
            }
#line 495
            goto while_break___1;
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 483
      j ++;
#line 498
      if (*(keywords + j) != (char *)((void *)0)) {
#line 499
        prev_sep = 0;
#line 500
        goto while_continue___0;
      }
    }
    {
#line 505
    prev_sep = is_separator((int )*p);
#line 506
    p ++;
#line 506
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 512
  __cil_tmp41 = editorRowHasOpenComment(row);
#line 512
  oc = __cil_tmp41;
  }
#line 513
  if (row->hl_oc != oc) {
#line 513
    if (row->idx + 1 < E.numrows) {
      {
#line 514
      editorUpdateSyntax(& *(E.row + (row->idx + 1)));
      }
    }
  }
#line 515
  row->hl_oc = oc;
}
}
#line 519 "kilo.c"
int editorSyntaxToColor(int hl ) 
{ 


  {
  {
#line 522
  if (hl == 3) {
#line 522
    goto case_3;
  }
#line 522
  if (hl == 2) {
#line 522
    goto case_3;
  }
#line 523
  if (hl == 4) {
#line 523
    goto case_4;
  }
#line 524
  if (hl == 5) {
#line 524
    goto case_5;
  }
#line 525
  if (hl == 6) {
#line 525
    goto case_6;
  }
#line 526
  if (hl == 7) {
#line 526
    goto case_7;
  }
#line 527
  if (hl == 8) {
#line 527
    goto case_8;
  }
#line 528
  goto switch_default;
  case_3: /* CIL Label */ 
#line 522
  return (36);
  case_4: /* CIL Label */ 
#line 523
  return (33);
  case_5: /* CIL Label */ 
#line 524
  return (32);
  case_6: /* CIL Label */ 
#line 525
  return (35);
  case_7: /* CIL Label */ 
#line 526
  return (31);
  case_8: /* CIL Label */ 
#line 527
  return (34);
  switch_default: /* CIL Label */ 
#line 528
  return (37);

  }
}
}
#line 534 "kilo.c"
void editorSelectSyntaxHighlight(char *filename ) 
{ 
  unsigned int j ;
  struct editorSyntax *s ;
  unsigned int i ;
  char *p ;
  int patlen ;
  size_t __cil_tmp7 ;

  {
#line 535
  j = (unsigned int )0;
  {
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;

#line 535
    if (! ((unsigned long )j < sizeof(HLDB) / sizeof(HLDB[0]))) {
#line 535
      goto while_break;
    }
#line 536
    s = (struct editorSyntax *)HLDB + j;
#line 537
    i = (unsigned int )0;
    {
    {
#line 538
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 538
      if (! *(s->filematch + i)) {
#line 538
        goto while_break___0;
      }
      {
#line 540
      __cil_tmp7 = strlen((char const   *)*(s->filematch + i));
#line 540
      patlen = (int )__cil_tmp7;
#line 541
      p = strstr((char const   *)filename, (char const   *)*(s->filematch + i));
      }
#line 541
      if (p != (char *)((void *)0)) {
#line 542
        if ((int )*(*(s->filematch + i) + 0) != 46) {
#line 543
          E.syntax = s;
#line 544
          return;
        } else
#line 542
        if ((int )*(p + patlen) == 0) {
#line 543
          E.syntax = s;
#line 544
          return;
        }
      }
#line 547
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  j ++;
}
}
#line 555 "kilo.c"
void editorUpdateRow(erow *row ) 
{ 
  int tabs ;
  int nonprint ;
  int j ;
  int idx ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 556
  tabs = 0;
  {
#line 556
  nonprint = 0;
#line 560
  free((void *)row->render);
#line 561
  j = 0;
  }
  {
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;

#line 561
    if (! (j < row->size)) {
#line 561
      goto while_break;
    }
#line 562
    if ((int )*(row->chars + j) == 9) {
#line 562
      tabs ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  j ++;
#line 564
  __cil_tmp8 = malloc((unsigned long )(((row->size + tabs * 8) + nonprint * 9) + 1));
#line 564
  row->render = (char *)__cil_tmp8;
#line 565
  idx = 0;
#line 566
  j = 0;
  }
  {
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 566
    if (! (j < row->size)) {
#line 566
      goto while_break___0;
    }
#line 567
    if ((int )*(row->chars + j) == 9) {
#line 568
      __cil_tmp9 = idx;
#line 568
      idx ++;
#line 568
      *(row->render + __cil_tmp9) = (char )' ';
      {
      {
#line 569
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 569
        if (! ((idx + 1) % 8 != 0)) {
#line 569
          goto while_break___1;
        }
#line 569
        __cil_tmp10 = idx;
#line 569
        idx ++;
#line 569
        *(row->render + __cil_tmp10) = (char )' ';
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 571
      __cil_tmp11 = idx;
#line 571
      idx ++;
#line 571
      *(row->render + __cil_tmp11) = *(row->chars + j);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 566
  j ++;
#line 574
  row->rsize = idx;
#line 575
  *(row->render + idx) = (char )'\000';
#line 578
  editorUpdateSyntax(row);
  }
}
}
#line 583 "kilo.c"
void editorInsertRow(int at , char *s , size_t len ) 
{ 
  void *__cil_tmp4 ;
  int j ;
  void *__cil_tmp8 ;

  {
#line 584
  if (at > E.numrows) {
#line 584
    return;
  }
  {
#line 585
  __cil_tmp4 = realloc((void *)E.row, sizeof(erow ) * (unsigned long )(E.numrows + 1));
#line 585
  E.row = (erow *)__cil_tmp4;
  }
#line 586
  if (at != E.numrows) {
    {
#line 587
    memmove((void *)((E.row + at) + 1), (void const   *)(E.row + at), sizeof(*(E.row + 0)) * (unsigned long )(E.numrows - at));
#line 588
    j = at + 1;
    }
    {
    {
#line 588
    while (1) {
      while_continue: /* CIL Label */ ;

#line 588
      if (! (j <= E.numrows)) {
#line 588
        goto while_break;
      }
#line 588
      ((E.row + j)->idx) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 588
    j ++;
  }
  {
#line 590
  (E.row + at)->size = (int )len;
#line 591
  __cil_tmp8 = malloc(len + 1UL);
#line 591
  (E.row + at)->chars = (char *)__cil_tmp8;
#line 592
  memcpy((void *)(E.row + at)->chars, (void const   *)s, len + 1UL);
#line 593
  (E.row + at)->hl = (unsigned char *)((void *)0);
#line 594
  (E.row + at)->hl_oc = 0;
#line 595
  (E.row + at)->render = (char *)((void *)0);
#line 596
  (E.row + at)->rsize = 0;
#line 597
  (E.row + at)->idx = at;
#line 598
  editorUpdateRow(E.row + at);
#line 599
  (E.numrows) ++;
#line 600
  (E.dirty) ++;
  }
}
}
#line 604 "kilo.c"
void editorFreeRow(erow *row ) 
{ 


  {
  {
#line 605
  free((void *)row->render);
#line 606
  free((void *)row->chars);
#line 607
  free((void *)row->hl);
  }
}
}
#line 612 "kilo.c"
void editorDelRow(int at ) 
{ 
  erow *row ;
  int j ;
  int __cil_tmp6 ;

  {
#line 615
  if (at >= E.numrows) {
#line 615
    return;
  }
  {
#line 616
  row = E.row + at;
#line 617
  editorFreeRow(row);
#line 618
  memmove((void *)(E.row + at), (void const   *)((E.row + at) + 1), sizeof(*(E.row + 0)) * (unsigned long )((E.numrows - at) - 1));
#line 619
  j = at;
  }
  {
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;

#line 619
    if (! (j < E.numrows - 1)) {
#line 619
      goto while_break;
    }
#line 619
    ((E.row + j)->idx) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  j ++;
#line 620
  __cil_tmp6 = E.numrows;
#line 620
  (E.numrows) --;
#line 621
  (E.dirty) ++;
}
}
#line 628 "kilo.c"
char *editorRowsToString(int *buflen ) 
{ 
  char *buf ;
  char *p ;
  int totlen ;
  int j ;
  void *__cil_tmp8 ;

  {
#line 629
  buf = (char *)((void *)0);
#line 630
  totlen = 0;
#line 634
  j = 0;
  {
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;

#line 634
    if (! (j < E.numrows)) {
#line 634
      goto while_break;
    }
#line 635
    totlen += (E.row + j)->size + 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  j ++;
#line 636
  *buflen = totlen;
#line 637
  totlen ++;
#line 639
  __cil_tmp8 = malloc((unsigned long )totlen);
#line 639
  buf = (char *)__cil_tmp8;
#line 639
  p = buf;
#line 640
  j = 0;
  }
  {
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 640
    if (! (j < E.numrows)) {
#line 640
      goto while_break___0;
    }
    {
#line 641
    memcpy((void *)p, (void const   *)(E.row + j)->chars, (unsigned long )(E.row + j)->size);
#line 642
    p += (E.row + j)->size;
#line 643
    *p = (char )'\n';
#line 644
    p ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  j ++;
#line 646
  *p = (char )'\000';
#line 647
  return (buf);
}
}
#line 652 "kilo.c"
void editorRowInsertChar(erow *row , int at , int c ) 
{ 
  int padlen ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 653
  if (at > row->size) {
    {
#line 656
    padlen = at - row->size;
#line 658
    __cil_tmp5 = realloc((void *)row->chars, (unsigned long )((row->size + padlen) + 2));
#line 658
    row->chars = (char *)__cil_tmp5;
#line 659
    memset((void *)(row->chars + row->size), ' ', (unsigned long )padlen);
#line 660
    *(row->chars + ((row->size + padlen) + 1)) = (char )'\000';
#line 661
    row->size += padlen + 1;
    }
  } else {
    {
#line 665
    __cil_tmp6 = realloc((void *)row->chars, (unsigned long )(row->size + 2));
#line 665
    row->chars = (char *)__cil_tmp6;
#line 666
    memmove((void *)((row->chars + at) + 1), (void const   *)(row->chars + at), (unsigned long )((row->size - at) + 1));
#line 667
    (row->size) ++;
    }
  }
  {
#line 669
  *(row->chars + at) = (char )c;
#line 670
  editorUpdateRow(row);
#line 671
  (E.dirty) ++;
  }
}
}
#line 675 "kilo.c"
void editorRowAppendString(erow *row , char *s , size_t len ) 
{ 
  void *__cil_tmp4 ;

  {
  {
#line 676
  __cil_tmp4 = realloc((void *)row->chars, ((unsigned long )row->size + len) + 1UL);
#line 676
  row->chars = (char *)__cil_tmp4;
#line 677
  memcpy((void *)(row->chars + row->size), (void const   *)s, len);
#line 678
  row->size += len;
#line 679
  *(row->chars + row->size) = (char )'\000';
#line 680
  editorUpdateRow(row);
#line 681
  (E.dirty) ++;
  }
}
}
#line 685 "kilo.c"
void editorRowDelChar(erow *row , int at ) 
{ 
  int __cil_tmp3 ;

  {
#line 686
  if (row->size <= at) {
#line 686
    return;
  }
  {
#line 687
  memmove((void *)(row->chars + at), (void const   *)((row->chars + at) + 1), (unsigned long )(row->size - at));
#line 688
  editorUpdateRow(row);
#line 689
  __cil_tmp3 = row->size;
#line 689
  (row->size) --;
#line 690
  (E.dirty) ++;
  }
}
}
#line 694 "kilo.c"
void editorInsertChar(int c ) 
{ 
  int filerow ;
  int filecol ;
  erow *row ;
  erow *tmp ;

  {
#line 695
  filerow = E.rowoff + E.cy;
#line 696
  filecol = E.coloff + E.cx;
#line 697
  if (filerow >= E.numrows) {
#line 697
    tmp = (erow *)((void *)0);
  } else {
#line 697
    tmp = & *(E.row + filerow);
  }
#line 697
  row = tmp;
#line 701
  if (! row) {
    {
    {
#line 702
    while (1) {
      while_continue: /* CIL Label */ ;

#line 702
      if (! (E.numrows <= filerow)) {
#line 702
        goto while_break;
      }
      {
#line 703
      editorInsertRow(E.numrows, (char *)"", (size_t )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 705
  row = & *(E.row + filerow);
#line 706
  editorRowInsertChar(row, filecol, c);
  }
#line 707
  if (E.cx == E.screencols - 1) {
#line 708
    (E.coloff) ++;
  } else {
#line 710
    (E.cx) ++;
  }
#line 711
  (E.dirty) ++;
}
}
#line 716 "kilo.c"
void editorInsertNewline(void) 
{ 
  int filerow ;
  int filecol ;
  erow *row ;
  erow *tmp ;

  {
#line 717
  filerow = E.rowoff + E.cy;
#line 718
  filecol = E.coloff + E.cx;
#line 719
  if (filerow >= E.numrows) {
#line 719
    tmp = (erow *)((void *)0);
  } else {
#line 719
    tmp = & *(E.row + filerow);
  }
#line 719
  row = tmp;
#line 721
  if (! row) {
#line 722
    if (filerow == E.numrows) {
      {
#line 723
      editorInsertRow(filerow, (char *)"", (size_t )0);
      }
#line 724
      goto fixcursor;
    }
#line 726
    return;
  }
#line 730
  if (filecol >= row->size) {
#line 730
    filecol = row->size;
  }
#line 731
  if (filecol == 0) {
    {
#line 732
    editorInsertRow(filerow, (char *)"", (size_t )0);
    }
  } else {
    {
#line 735
    editorInsertRow(filerow + 1, row->chars + filecol, (size_t )(row->size - filecol));
#line 736
    row = & *(E.row + filerow);
#line 737
    *(row->chars + filecol) = (char )'\000';
#line 738
    row->size = filecol;
#line 739
    editorUpdateRow(row);
    }
  }
  fixcursor: 
#line 742
  if (E.cy == E.screenrows - 1) {
#line 743
    (E.rowoff) ++;
  } else {
#line 745
    (E.cy) ++;
  }
#line 747
  E.cx = 0;
#line 748
  E.coloff = 0;
}
}
#line 752 "kilo.c"
void editorDelChar(void) 
{ 
  int filerow ;
  int filecol ;
  erow *row ;
  erow *tmp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int shift ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 753
  filerow = E.rowoff + E.cy;
#line 754
  filecol = E.coloff + E.cx;
#line 755
  if (filerow >= E.numrows) {
#line 755
    tmp = (erow *)((void *)0);
  } else {
#line 755
    tmp = & *(E.row + filerow);
  }
#line 755
  row = tmp;
#line 757
  if (! row) {
#line 757
    return;
  } else
#line 757
  if (filecol == 0) {
#line 757
    if (filerow == 0) {
#line 757
      return;
    }
  }
#line 758
  if (filecol == 0) {
    {
#line 761
    filecol = (E.row + (filerow - 1))->size;
#line 762
    editorRowAppendString(& *(E.row + (filerow - 1)), row->chars, (size_t )row->size);
#line 763
    editorDelRow(filerow);
#line 764
    row = (erow *)((void *)0);
    }
#line 765
    if (E.cy == 0) {
#line 766
      __cil_tmp5 = E.rowoff;
#line 766
      (E.rowoff) --;
    } else {
#line 768
      __cil_tmp6 = E.cy;
#line 768
      (E.cy) --;
    }
#line 769
    E.cx = filecol;
#line 770
    if (E.cx >= E.screencols) {
#line 771
      shift = (E.screencols - E.cx) + 1;
#line 772
      E.cx -= shift;
#line 773
      E.coloff += shift;
    }
  } else {
    {
#line 776
    editorRowDelChar(row, filecol - 1);
    }
#line 777
    if (E.cx == 0) {
#line 777
      if (E.coloff) {
#line 778
        __cil_tmp8 = E.coloff;
#line 778
        (E.coloff) --;
      } else {
#line 780
        __cil_tmp9 = E.cx;
#line 780
        (E.cx) --;
      }
    } else {
#line 780
      __cil_tmp9 = E.cx;
#line 780
      (E.cx) --;
    }
  }
#line 782
  if (row) {
    {
#line 782
    editorUpdateRow(row);
    }
  }
#line 783
  (E.dirty) ++;
}
}
#line 788 "kilo.c"
int editorOpen(char *filename ) 
{ 
  FILE *fp ;
  size_t fnlen ;
  size_t __cil_tmp4 ;
  void *__cil_tmp5 ;
  int *__cil_tmp7 ;
  char *line ;
  size_t linecap ;
  ssize_t linelen ;

  {
  {
#line 791
  E.dirty = 0;
#line 792
  free((void *)E.filename);
#line 793
  __cil_tmp4 = strlen((char const   *)filename);
#line 793
  fnlen = __cil_tmp4 + 1UL;
#line 794
  __cil_tmp5 = malloc(fnlen);
#line 794
  E.filename = (char *)__cil_tmp5;
#line 795
  memcpy((void *)E.filename, (void const   *)filename, fnlen);
#line 797
  fp = fopen((char const   *)filename, (char const   *)((char *)"r"));
  }
#line 798
  if (! fp) {
    {
#line 799
    __cil_tmp7 = __errno_location();
    }
#line 799
    if (*__cil_tmp7 != 2) {
      {
#line 800
      perror((char const   *)((char *)"Opening file"));
#line 801
      exit(1);
      }
    }
#line 803
    return (1);
  }
#line 806
  line = (char *)((void *)0);
#line 807
  linecap = (size_t )0;
  {
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;

#line 809
    if (! (linelen != -1L)) {
#line 809
      goto while_break;
    }
#line 810
    if (linelen) {
#line 810
      if ((int )*(line + (linelen - 1L)) == 10) {
#line 811
        linelen --;
#line 811
        *(line + linelen) = (char )'\000';
      } else
#line 810
      if ((int )*(line + (linelen - 1L)) == 13) {
#line 811
        linelen --;
#line 811
        *(line + linelen) = (char )'\000';
      }
    }
    {
#line 812
    editorInsertRow(E.numrows, line, (size_t )linelen);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 814
  free((void *)line);
#line 815
  fclose(fp);
#line 816
  E.dirty = 0;
  }
#line 817
  return (0);
}
}
#line 821 "kilo.c"
int editorSave(void) 
{ 
  int len ;
  char *buf ;
  char *__cil_tmp3 ;
  int fd ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  int *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 823
  __cil_tmp3 = editorRowsToString(& len);
#line 823
  buf = __cil_tmp3;
#line 824
  __cil_tmp5 = open((char const   *)E.filename, 66, 420);
#line 824
  fd = __cil_tmp5;
  }
#line 825
  if (fd == -1) {
#line 825
    goto writeerr;
  }
  {
#line 829
  __cil_tmp6 = ftruncate(fd, (__off_t )len);
  }
#line 829
  if (__cil_tmp6 == -1) {
#line 829
    goto writeerr;
  }
  {
#line 830
  __cil_tmp7 = write(fd, (void const   *)buf, (size_t )len);
  }
#line 830
  if (__cil_tmp7 != (long )len) {
#line 830
    goto writeerr;
  }
  {
#line 832
  close(fd);
#line 833
  free((void *)buf);
#line 834
  E.dirty = 0;
#line 835
  editorSetStatusMessage((char const   *)((char *)"%d bytes written on disk"), len);
  }
#line 836
  return (0);
  writeerr: 
  {
#line 839
  free((void *)buf);
  }
#line 840
  if (fd != -1) {
    {
#line 840
    close(fd);
    }
  }
  {
#line 841
  __cil_tmp8 = __errno_location();
#line 841
  __cil_tmp9 = strerror(*__cil_tmp8);
#line 841
  editorSetStatusMessage((char const   *)((char *)"Can\'t save! I/O error: %s"), __cil_tmp9);
  }
#line 842
  return (1);
}
}
#line 851 "kilo.c"
struct abuf {
   char *b ;
   int len ;
};
#line 858 "kilo.c"
void abAppend(struct abuf *ab , char const   *s , int len ) 
{ 
  char *new ;
  void *__cil_tmp5 ;

  {
  {
#line 859
  __cil_tmp5 = realloc((void *)ab->b, (unsigned long )(ab->len + len));
#line 859
  new = (char *)__cil_tmp5;
  }
#line 861
  if (new == (char *)((void *)0)) {
#line 861
    return;
  }
  {
#line 862
  memcpy((void *)(new + ab->len), (void const   *)s, (unsigned long )len);
#line 863
  ab->b = new;
#line 864
  ab->len += len;
  }
}
}
#line 867 "kilo.c"
void abFree(struct abuf *ab ) 
{ 


  {
  {
#line 868
  free((void *)ab->b);
  }
}
}
#line 873 "kilo.c"
void editorRefreshScreen(void) 
{ 
  int y ;
  erow *r ;
  char buf[32] ;
  struct abuf ab ;
  int filerow ;
  char welcome[80] ;
  int welcomelen ;
  int __cil_tmp8 ;
  int padding ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int len ;
  int current_color ;
  char *c ;
  unsigned char *hl ;
  int j ;
  char sym ;
  int color ;
  int __cil_tmp19 ;
  char buf___0[16] ;
  int clen ;
  int __cil_tmp22 ;
  char status[80] ;
  char rstatus[80] ;
  int len ;
  char *tmp ;
  int __cil_tmp29 ;
  int rlen ;
  int __cil_tmp31 ;
  int msglen ;
  size_t __cil_tmp34 ;
  time_t __cil_tmp35 ;
  int tmp___1 ;
  int j ;
  int cx ;
  int filerow ;
  erow *row ;
  erow *tmp___2 ;
  size_t __cil_tmp44 ;

  {
#line 877
  ab.b = (char *)((void *)0);
  {
#line 877
  ab.len = 0;
#line 879
  abAppend(& ab, (char const   *)((char *)"\033[?25l"), 6);
#line 880
  abAppend(& ab, (char const   *)((char *)"\033[H"), 3);
#line 881
  y = 0;
  }
  {
  {
#line 881
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 881
    if (! (y < E.screenrows)) {
#line 881
      goto while_break;
    }
#line 882
    filerow = E.rowoff + y;
#line 884
    if (filerow >= E.numrows) {
#line 885
      if (E.numrows == 0) {
#line 885
        if (y == E.screenrows / 3) {
          {
#line 887
          __cil_tmp8 = snprintf((char *)welcome, sizeof(welcome), (char const   *)((char *)"Kilo editor -- verison %s\033[0K\r\n"),
                                (char *)"0.0.1");
#line 887
          welcomelen = __cil_tmp8;
#line 889
          padding = (E.screencols - welcomelen) / 2;
          }
#line 890
          if (padding) {
            {
#line 891
            abAppend(& ab, (char const   *)((char *)"~"), 1);
#line 892
            __cil_tmp10 = padding;
#line 892
            padding --;
            }
          }
          {
          {
#line 894
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 894
            if (! __cil_tmp11) {
#line 894
              goto while_break___0;
            }
            {
#line 894
            abAppend(& ab, (char const   *)((char *)" "), 1);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 895
          abAppend(& ab, (char const   *)((char *)welcome), welcomelen);
          }
        } else {
          {
          {
#line 897
          abAppend(& ab, (char const   *)((char *)"~\033[0K\r\n"), 7);
          }
          }
        }
      } else {
        {
        {
#line 897
        abAppend(& ab, (char const   *)((char *)"~\033[0K\r\n"), 7);
        }
        }
      }
#line 899
      goto while_continue;
    }
#line 902
    r = & *(E.row + filerow);
#line 904
    len = r->rsize - E.coloff;
#line 905
    current_color = - 1;
#line 906
    if (len > 0) {
#line 907
      if (len > E.screencols) {
#line 907
        len = E.screencols;
      }
#line 908
      c = r->render + E.coloff;
#line 909
      hl = r->hl + E.coloff;
#line 911
      j = 0;
      {
      {
#line 911
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 911
        if (! (j < len)) {
#line 911
          goto while_break___1;
        }
#line 912
        if ((int )*(hl + j) == 1) {
          {
#line 914
          abAppend(& ab, (char const   *)((char *)"\033[7m"), 4);
          }
#line 915
          if ((int )*(c + j) <= 26) {
#line 916
            sym = (char )(64 + (int )*(c + j));
          } else {
#line 918
            sym = (char )'?';
          }
          {
#line 919
          abAppend(& ab, (char const   *)(& sym), 1);
#line 920
          abAppend(& ab, (char const   *)((char *)"\033[0m"), 4);
          }
        } else
#line 921
        if ((int )*(hl + j) == 0) {
#line 922
          if (current_color != -1) {
            {
#line 923
            abAppend(& ab, (char const   *)((char *)"\033[39m"), 5);
#line 924
            current_color = - 1;
            }
          }
          {
#line 926
          abAppend(& ab, (char const   *)(c + j), 1);
          }
        } else {
          {
#line 928
          __cil_tmp19 = editorSyntaxToColor((int )*(hl + j));
#line 928
          color = __cil_tmp19;
          }
#line 929
          if (color != current_color) {
            {
#line 931
            __cil_tmp22 = snprintf((char *)buf___0, sizeof(buf___0), (char const   *)((char *)"\033[%dm"),
                                   color);
#line 931
            clen = __cil_tmp22;
#line 932
            current_color = color;
#line 933
            abAppend(& ab, (char const   *)((char *)buf___0), clen);
            }
          }
          {
#line 935
          abAppend(& ab, (char const   *)(c + j), 1);
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 911
      j ++;
    }
    {
#line 939
    abAppend(& ab, (char const   *)((char *)"\033[39m"), 5);
#line 940
    abAppend(& ab, (char const   *)((char *)"\033[0K"), 4);
#line 941
    abAppend(& ab, (char const   *)((char *)"\r\n"), 2);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 881
  y ++;
#line 945
  abAppend(& ab, (char const   *)((char *)"\033[0K"), 4);
#line 946
  abAppend(& ab, (char const   *)((char *)"\033[7m"), 4);
  }
#line 948
  if (E.dirty) {
#line 948
    tmp = (char *)"(modified)";
  } else {
#line 948
    tmp = (char *)"";
  }
  {
#line 948
  __cil_tmp29 = snprintf((char *)status, sizeof(status), (char const   *)((char *)"%.20s - %d lines %s"),
                         E.filename, E.numrows, tmp);
#line 948
  len = __cil_tmp29;
#line 950
  __cil_tmp31 = snprintf((char *)rstatus, sizeof(rstatus), (char const   *)((char *)"%d/%d"),
                         (E.rowoff + E.cy) + 1, E.numrows);
#line 950
  rlen = __cil_tmp31;
  }
#line 952
  if (len > E.screencols) {
#line 952
    len = E.screencols;
  }
  {
#line 953
  abAppend(& ab, (char const   *)((char *)status), len);
  }
  {
  {
#line 954
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 954
    if (! (len < E.screencols)) {
#line 954
      goto while_break___2;
    }
#line 955
    if (E.screencols - len == rlen) {
      {
#line 956
      abAppend(& ab, (char const   *)((char *)rstatus), rlen);
      }
#line 957
      goto while_break___2;
    } else {
      {
#line 959
      abAppend(& ab, (char const   *)((char *)" "), 1);
#line 960
      len ++;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 963
  abAppend(& ab, (char const   *)((char *)"\033[0m\r\n"), 6);
#line 966
  abAppend(& ab, (char const   *)((char *)"\033[0K"), 4);
#line 967
  __cil_tmp34 = strlen((char const   *)((char *)E.statusmsg));
#line 967
  msglen = (int )__cil_tmp34;
#line 968
  __cil_tmp35 = time((time_t *)((void *)0));
  }
#line 968
  if (msglen) {
#line 968
    if (__cil_tmp35 - E.statusmsg_time < 5L) {
#line 969
      if (msglen <= E.screencols) {
#line 969
        tmp___1 = msglen;
      } else {
#line 969
        tmp___1 = E.screencols;
      }
      {
#line 969
      abAppend(& ab, (char const   *)((char *)E.statusmsg), tmp___1);
      }
    }
  }
#line 975
  cx = 1;
#line 976
  filerow = E.rowoff + E.cy;
#line 977
  if (filerow >= E.numrows) {
#line 977
    tmp___2 = (erow *)((void *)0);
  } else {
#line 977
    tmp___2 = & *(E.row + filerow);
  }
#line 977
  row = tmp___2;
#line 978
  if (row) {
#line 979
    j = E.coloff;
    {
    {
#line 979
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 979
      if (! (j < E.cx + E.coloff)) {
#line 979
        goto while_break___3;
      }
#line 980
      if (j < row->size) {
#line 980
        if ((int )*(row->chars + j) == 9) {
#line 980
          cx += 7 - cx % 8;
        }
      }
#line 981
      cx ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 979
    j ++;
  }
  {
#line 984
  snprintf((char *)buf, sizeof(buf), (char const   *)((char *)"\033[%d;%dH"), E.cy + 1,
           cx);
#line 985
  __cil_tmp44 = strlen((char const   *)((char *)buf));
#line 985
  abAppend(& ab, (char const   *)((char *)buf), (int )__cil_tmp44);
#line 986
  abAppend(& ab, (char const   *)((char *)"\033[?25h"), 6);
#line 987
  write(1, (void const   *)ab.b, (size_t )ab.len);
#line 988
  abFree(& ab);
  }
}
}
#line 993 "kilo.c"
void editorSetStatusMessage(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 995
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 996
  vsnprintf((char *)E.statusmsg, sizeof(E.statusmsg), fmt, (__builtin_va_list *)ap);
#line 997
  __builtin_va_end((__builtin_va_list *)ap);
#line 998
  E.statusmsg_time = time((time_t *)((void *)0));
  }
}
}
#line 1005 "kilo.c"
void editorFind(int fd ) 
{ 
  char query[257] ;
  unsigned int tmp ;
  int qlen ;
  int last_match ;
  int find_next ;
  int saved_hl_line ;
  char *saved_hl ;
  int saved_cx ;
  int saved_cy ;
  int saved_coloff ;
  int saved_rowoff ;
  int c ;
  int __cil_tmp14 ;
  unsigned short const   **__cil_tmp15 ;
  int __cil_tmp16 ;
  char *match ;
  int match_offset ;
  int i ;
  int current ;
  erow *row ;
  void *__cil_tmp24 ;
  int diff ;

  {
#line 1006
  query[0] = (char )0;
#line 1006
  tmp = (unsigned int )1;
  {
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1006
    if (tmp >= 257) {
#line 1006
      goto while_break;
    }
#line 1006
    query[tmp] = 0;
#line 1006
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1007
  qlen = 0;
#line 1008
  last_match = - 1;
#line 1009
  find_next = 0;
#line 1010
  saved_hl_line = - 1;
#line 1011
  saved_hl = (char *)((void *)0);
#line 1022
  saved_cx = E.cx;
#line 1022
  saved_cy = E.cy;
#line 1023
  saved_coloff = E.coloff;
#line 1023
  saved_rowoff = E.rowoff;
  {
  {
#line 1025
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 1026
    editorSetStatusMessage((char const   *)((char *)"Search: %s (Use ESC/Arrows/Enter)"),
                           (char *)query);
#line 1028
    editorRefreshScreen();
#line 1030
    __cil_tmp14 = editorReadKey(fd);
#line 1030
    c = __cil_tmp14;
    }
#line 1031
    if (c == 1004) {
      _L___3: /* CIL Label */ 
#line 1032
      if (qlen != 0) {
#line 1032
        qlen --;
#line 1032
        query[qlen] = (char )'\000';
      }
#line 1033
      last_match = - 1;
    } else
#line 1031
    if (c == 8) {
#line 1031
      goto _L___3;
    } else
#line 1031
    if (c == 127) {
#line 1031
      goto _L___3;
    } else
#line 1034
    if (c == 27) {
      _L: /* CIL Label */ 
#line 1035
      if (c == 27) {
#line 1036
        E.cx = saved_cx;
#line 1036
        E.cy = saved_cy;
#line 1037
        E.coloff = saved_coloff;
#line 1037
        E.rowoff = saved_rowoff;
      }
      {
      {
#line 1039
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1039
        if (saved_hl) {
          {
#line 1039
          memcpy((void *)(E.row + saved_hl_line)->hl, (void const   *)saved_hl, (unsigned long )(E.row + saved_hl_line)->rsize);
#line 1039
          free((void *)saved_hl);
#line 1039
          saved_hl = (char *)((void *)0);
          }
        }
#line 1039
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1040
      editorSetStatusMessage((char const   *)((char *)""));
      }
#line 1041
      return;
    } else
#line 1034
    if (c == 13) {
#line 1034
      goto _L;
    } else
#line 1042
    if (c == 1001) {
#line 1043
      find_next = 1;
    } else
#line 1042
    if (c == 1003) {
#line 1043
      find_next = 1;
    } else
#line 1044
    if (c == 1000) {
#line 1045
      find_next = - 1;
    } else
#line 1044
    if (c == 1002) {
#line 1045
      find_next = - 1;
    } else {
      {
#line 1046
      __cil_tmp15 = __ctype_b_loc();
      }
#line 1046
      if ((int )((unsigned short )*(*__cil_tmp15 + c)) & 16384) {
#line 1047
        if (qlen < 256) {
#line 1048
          __cil_tmp16 = qlen;
#line 1048
          qlen ++;
#line 1048
          query[__cil_tmp16] = (char )c;
#line 1049
          query[qlen] = (char )'\000';
#line 1050
          last_match = - 1;
        }
      }
    }
#line 1055
    if (last_match == -1) {
#line 1055
      find_next = 1;
    }
#line 1056
    if (find_next) {
#line 1057
      match = (char *)((void *)0);
#line 1058
      match_offset = 0;
#line 1059
      current = last_match;
#line 1061
      i = 0;
      {
      {
#line 1061
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1061
        if (! (i < E.numrows)) {
#line 1061
          goto while_break___2;
        }
#line 1062
        current += find_next;
#line 1063
        if (current == -1) {
#line 1063
          current = E.numrows - 1;
        } else
#line 1064
        if (current == E.numrows) {
#line 1064
          current = 0;
        }
        {
#line 1065
        match = strstr((char const   *)(E.row + current)->render, (char const   *)((char *)query));
        }
#line 1066
        if (match) {
#line 1067
          match_offset = (int )(match - (E.row + current)->render);
#line 1068
          goto while_break___2;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1061
      i ++;
#line 1071
      find_next = 0;
      {
      {
#line 1074
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1074
        if (saved_hl) {
          {
#line 1074
          memcpy((void *)(E.row + saved_hl_line)->hl, (void const   *)saved_hl, (unsigned long )(E.row + saved_hl_line)->rsize);
#line 1074
          free((void *)saved_hl);
#line 1074
          saved_hl = (char *)((void *)0);
          }
        }
#line 1074
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1076
      if (match) {
#line 1077
        row = & *(E.row + current);
#line 1078
        last_match = current;
#line 1079
        if (row->hl) {
          {
#line 1080
          saved_hl_line = current;
#line 1081
          __cil_tmp24 = malloc((unsigned long )row->rsize);
#line 1081
          saved_hl = (char *)__cil_tmp24;
#line 1082
          memcpy((void *)saved_hl, (void const   *)row->hl, (unsigned long )row->rsize);
#line 1083
          memset((void *)(row->hl + match_offset), 8, (unsigned long )qlen);
          }
        }
#line 1085
        E.cy = 0;
#line 1086
        E.cx = match_offset;
#line 1087
        E.rowoff = current;
#line 1088
        E.coloff = 0;
#line 1090
        if (E.cx > E.screencols) {
#line 1091
          diff = E.cx - E.screencols;
#line 1092
          E.cx -= diff;
#line 1093
          E.coloff += diff;
        }
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }

  }
}
}
#line 1103 "kilo.c"
void editorMoveCursor(int key ) 
{ 
  int filerow ;
  int filecol ;
  int rowlen ;
  erow *row ;
  erow *tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp11 ;
  erow *tmp___5 ;
  int tmp___6 ;

  {
#line 1104
  filerow = E.rowoff + E.cy;
#line 1105
  filecol = E.coloff + E.cx;
#line 1107
  if (filerow >= E.numrows) {
#line 1107
    tmp = (erow *)((void *)0);
  } else {
#line 1107
    tmp = & *(E.row + filerow);
  }
#line 1107
  row = tmp;
  {
#line 1110
  if (key == 1000) {
#line 1110
    goto case_1000;
  }
#line 1128
  if (key == 1001) {
#line 1128
    goto case_1001;
  }
#line 1145
  if (key == 1002) {
#line 1145
    goto case_1002;
  }
#line 1152
  if (key == 1003) {
#line 1152
    goto case_1003;
  }
#line 1109
  goto switch_break;
  case_1000: /* CIL Label */ 
#line 1111
  if (E.cx == 0) {
#line 1112
    if (E.coloff) {
#line 1113
      __cil_tmp7 = E.coloff;
#line 1113
      (E.coloff) --;
    } else
#line 1115
    if (filerow > 0) {
#line 1116
      __cil_tmp8 = E.cy;
#line 1116
      (E.cy) --;
#line 1117
      E.cx = (E.row + (filerow - 1))->size;
#line 1118
      if (E.cx > E.screencols - 1) {
#line 1119
        E.coloff = (E.cx - E.screencols) + 1;
#line 1120
        E.cx = E.screencols - 1;
      }
    }
  } else {
#line 1125
    (E.cx) --;
  }
#line 1127
  goto switch_break;
  case_1001: /* CIL Label */ 
#line 1129
  if (row) {
#line 1129
    if (filecol < row->size) {
#line 1130
      if (E.cx == E.screencols - 1) {
#line 1131
        (E.coloff) ++;
      } else {
#line 1133
        (E.cx) ++;
      }
    } else {
#line 1129
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1135
  if (row) {
#line 1135
    if (filecol == row->size) {
#line 1136
      E.cx = 0;
#line 1137
      E.coloff = 0;
#line 1138
      if (E.cy == E.screenrows - 1) {
#line 1139
        (E.rowoff) ++;
      } else {
#line 1141
        (E.cy) ++;
      }
    }
  }
#line 1144
  goto switch_break;
  case_1002: /* CIL Label */ 
#line 1146
  if (E.cy == 0) {
#line 1147
    if (E.rowoff) {
#line 1147
      __cil_tmp11 = E.rowoff;
#line 1147
      (E.rowoff) --;
    }
  } else {
#line 1149
    (E.cy) --;
  }
#line 1151
  goto switch_break;
  case_1003: /* CIL Label */ 
#line 1153
  if (filerow < E.numrows) {
#line 1154
    if (E.cy == E.screenrows - 1) {
#line 1155
      (E.rowoff) ++;
    } else {
#line 1157
      (E.cy) ++;
    }
  }
#line 1160
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1163
  filerow = E.rowoff + E.cy;
#line 1164
  filecol = E.coloff + E.cx;
#line 1165
  if (filerow >= E.numrows) {
#line 1165
    tmp___5 = (erow *)((void *)0);
  } else {
#line 1165
    tmp___5 = & *(E.row + filerow);
  }
#line 1165
  row = tmp___5;
#line 1166
  if (row) {
#line 1166
    tmp___6 = row->size;
  } else {
#line 1166
    tmp___6 = 0;
  }
#line 1166
  rowlen = tmp___6;
#line 1167
  if (filecol > rowlen) {
#line 1168
    E.cx -= filecol - rowlen;
#line 1169
    if (E.cx < 0) {
#line 1170
      E.coloff += E.cx;
#line 1171
      E.cx = 0;
    }
  }
}
}
#line 1179 "kilo.c"
void editorProcessKeypress(int fd ) 
{ 
  static int quit_times ;
  int c ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int times ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 1182
  quit_times = 3;
#line 1184
  __cil_tmp4 = editorReadKey(fd);
#line 1184
  c = __cil_tmp4;
  }
  {
#line 1186
  if (c == 13) {
#line 1186
    goto case_13;
  }
#line 1189
  if (c == 3) {
#line 1189
    goto case_3;
  }
#line 1193
  if (c == 17) {
#line 1193
    goto case_17;
  }
#line 1203
  if (c == 19) {
#line 1203
    goto case_19;
  }
#line 1206
  if (c == 6) {
#line 1206
    goto case_6;
  }
#line 1211
  if (c == 1004) {
#line 1211
    goto case_1004;
  }
#line 1211
  if (c == 8) {
#line 1211
    goto case_1004;
  }
#line 1211
  if (c == 127) {
#line 1211
    goto case_1004;
  }
#line 1215
  if (c == 1008) {
#line 1215
    goto case_1008;
  }
#line 1215
  if (c == 1007) {
#line 1215
    goto case_1008;
  }
#line 1231
  if (c == 1001) {
#line 1231
    goto case_1001;
  }
#line 1231
  if (c == 1000) {
#line 1231
    goto case_1001;
  }
#line 1231
  if (c == 1003) {
#line 1231
    goto case_1001;
  }
#line 1231
  if (c == 1002) {
#line 1231
    goto case_1001;
  }
#line 1234
  if (c == 12) {
#line 1234
    goto case_12;
  }
#line 1237
  if (c == 27) {
#line 1237
    goto case_27;
  }
#line 1240
  goto switch_default;
  case_13: /* CIL Label */ 
  {
#line 1187
  editorInsertNewline();
  }
#line 1188
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1192
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1195
  if (E.dirty) {
#line 1195
    if (quit_times) {
      {
#line 1196
      editorSetStatusMessage((char const   *)((char *)"WARNING!!! File has unsaved changes. Press Ctrl-Q %d more times to quit."),
                             quit_times);
#line 1198
      __cil_tmp5 = quit_times;
#line 1198
      quit_times --;
      }
#line 1199
      return;
    }
  }
  {
#line 1201
  exit(0);
  }
#line 1202
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1204
  editorSave();
  }
#line 1205
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1207
  editorFind(fd);
  }
#line 1208
  goto switch_break;
  case_1004: /* CIL Label */ 
  {
#line 1212
  editorDelChar();
  }
#line 1213
  goto switch_break;
  case_1008: /* CIL Label */ 
#line 1216
  if (c == 1007) {
#line 1216
    if (E.cy != 0) {
#line 1217
      E.cy = 0;
    } else {
#line 1216
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1218
  if (c == 1008) {
#line 1218
    if (E.cy != E.screenrows - 1) {
#line 1219
      E.cy = E.screenrows - 1;
    }
  }
#line 1221
  times = E.screenrows;
  {
  {
#line 1222
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1222
    if (! __cil_tmp7) {
#line 1222
      goto while_break;
    }
#line 1223
    if (c == 1007) {
#line 1223
      tmp = 1002;
    } else {
#line 1223
      tmp = 1003;
    }
    {
#line 1223
    editorMoveCursor(tmp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1226
  goto switch_break;
  case_1001: /* CIL Label */ 
  {
#line 1232
  editorMoveCursor(c);
  }
#line 1233
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1236
  goto switch_break;
  case_27: /* CIL Label */ 
#line 1239
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1241
  editorInsertChar(c);
  }
#line 1242
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1245
  quit_times = 3;
}
}
#line 1248 "kilo.c"
int editorFileWasModified(void) 
{ 


  {
#line 1249
  return (E.dirty);
}
}
#line 1252 "kilo.c"
void updateWindowSize(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 1253
  __cil_tmp1 = getWindowSize(0, 1, & E.screenrows, & E.screencols);
  }
#line 1253
  if (__cil_tmp1 == -1) {
    {
#line 1255
    perror((char const   *)((char *)"Unable to query the screen for size (columns / rows)"));
#line 1256
    exit(1);
    }
  }
#line 1258
  E.screenrows -= 2;
}
}
#line 1261 "kilo.c"
void handleSigWinCh(int unused ) 
{ 


  {
  {
#line 1262
  updateWindowSize();
  }
#line 1263
  if (E.cy > E.screenrows) {
#line 1263
    E.cy = E.screenrows - 1;
  }
#line 1264
  if (E.cx > E.screencols) {
#line 1264
    E.cx = E.screencols - 1;
  }
  {
#line 1265
  editorRefreshScreen();
  }
}
}
#line 1268 "kilo.c"
void initEditor(void) 
{ 


  {
  {
#line 1269
  E.cx = 0;
#line 1270
  E.cy = 0;
#line 1271
  E.rowoff = 0;
#line 1272
  E.coloff = 0;
#line 1273
  E.numrows = 0;
#line 1274
  E.row = (erow *)((void *)0);
#line 1275
  E.dirty = 0;
#line 1276
  E.filename = (char *)((void *)0);
#line 1277
  E.syntax = (struct editorSyntax *)((void *)0);
#line 1278
  updateWindowSize();
#line 1279
  signal(28, handleSigWinCh);
  }
}
}
#line 1282 "kilo.c"
int main(int argc , char **argv ) 
{ 


  {
#line 1283
  if (argc != 2) {
    {
#line 1284
    fprintf(stderr, (char const   *)((char *)"Usage: kilo <filename>\n"));
#line 1285
    exit(1);
    }
  }
  {
#line 1288
  initEditor();
#line 1289
  editorSelectSyntaxHighlight(*(argv + 1));
#line 1290
  editorOpen(*(argv + 1));
#line 1291
  enableRawMode(0);
#line 1292
  editorSetStatusMessage((char const   *)((char *)"HELP: Ctrl-S = save | Ctrl-Q = quit | Ctrl-F = find"));
  }
  {
  {
#line 1294
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 1295
    editorRefreshScreen();
#line 1296
    editorProcessKeypress(0);
    }
  }
  while_break: /* CIL Label */ ;
  }

  }
#line 1298
  return (0);
}
}
