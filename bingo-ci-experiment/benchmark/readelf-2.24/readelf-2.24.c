/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 270 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
struct xatexit {
   struct xatexit *next ;
   int ind ;
   void (*fns[32])(void) ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
struct signal_info {
   int const   value ;
   char const   * const  name ;
};
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
struct error_info {
   int const   value ;
   char const   * const  name ;
};
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 55 "./../include/splay-tree.h"
typedef uintptr_t splay_tree_key;
#line 56 "./../include/splay-tree.h"
typedef uintptr_t splay_tree_value;
#line 59
struct splay_tree_node_s ;
#line 59 "./../include/splay-tree.h"
typedef struct splay_tree_node_s *splay_tree_node;
#line 89 "./../include/splay-tree.h"
struct splay_tree_node_s {
   splay_tree_key key ;
   splay_tree_value value ;
   splay_tree_node left ;
   splay_tree_node right ;
};
#line 102 "./../include/splay-tree.h"
struct splay_tree_s {
   splay_tree_node root ;
   int (*comp)(splay_tree_key  , splay_tree_key  ) ;
   void (*delete_key)(splay_tree_key  ) ;
   void (*delete_value)(splay_tree_value  ) ;
   void *(*allocate)(int  , void * ) ;
   void (*deallocate)(void * , void * ) ;
   void *allocate_data ;
};
#line 125 "./../include/splay-tree.h"
typedef struct splay_tree_s *splay_tree;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sort.c"
typedef unsigned char digit_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 57 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 42 "./../include/simple-object.h"
struct simple_object_read_struct ;
#line 42 "./../include/simple-object.h"
typedef struct simple_object_read_struct simple_object_read;
#line 108
struct simple_object_attributes_struct ;
#line 108 "./../include/simple-object.h"
typedef struct simple_object_attributes_struct simple_object_attributes;
#line 137
struct simple_object_write_struct ;
#line 137 "./../include/simple-object.h"
typedef struct simple_object_write_struct simple_object_write;
#line 157
struct simple_object_write_section_struct ;
#line 157 "./../include/simple-object.h"
typedef struct simple_object_write_section_struct simple_object_write_section;
#line 21 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_functions ;
#line 25 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_read_struct {
   int descriptor ;
   off_t offset ;
   struct simple_object_functions  const  *functions ;
   void *data ;
};
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_attributes_struct {
   struct simple_object_functions  const  *functions ;
   void *data ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_write_struct {
   struct simple_object_functions  const  *functions ;
   char *segment_name ;
   simple_object_write_section *sections ;
   simple_object_write_section *last_section ;
   void *data ;
};
#line 65
struct simple_object_write_section_buffer ;
#line 65 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_write_section_struct {
   simple_object_write_section *next ;
   char *name ;
   unsigned int align ;
   struct simple_object_write_section_buffer *buffers ;
   struct simple_object_write_section_buffer *last_buffer ;
};
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_write_section_buffer {
   struct simple_object_write_section_buffer *next ;
   size_t size ;
   void const   *buffer ;
   void *free_buffer ;
};
#line 100 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_functions {
   void *(*match)(unsigned char *header , int descriptor , off_t offset , char const   *segment_name ,
                  char const   **errmsg , int *err ) ;
   char const   *(*find_sections)(simple_object_read * , int (*pfn)(void * , char const   * ,
                                                                    off_t offset ,
                                                                    off_t length ) ,
                                  void *data , int *err ) ;
   void *(*fetch_attributes)(simple_object_read *sobj , char const   **errmsg , int *err ) ;
   void (*release_read)(void * ) ;
   char const   *(*attributes_merge)(void * , void * , int *err ) ;
   void (*release_attributes)(void * ) ;
   void *(*start_write)(void *attributes_data , char const   **errmsg , int *err ) ;
   char const   *(*write_to_file)(simple_object_write *sobj , int descriptor , int *err ) ;
   void (*release_write)(void * ) ;
};
#line 181 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
struct find_one_section_data {
   char const   *name ;
   off_t *offset ;
   off_t *length ;
   int found ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
typedef uint64_t ulong_type;
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff32_112495712 {
   unsigned char f_symptr[4] ;
   unsigned char f_nsyms[4] ;
   unsigned char f_opthdr[2] ;
   unsigned char f_flags[2] ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff64_112495713 {
   unsigned char f_symptr[8] ;
   unsigned char f_opthdr[2] ;
   unsigned char f_flags[2] ;
   unsigned char f_nsyms[4] ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_u_520025980 {
   struct __anonstruct_xcoff32_112495712 xcoff32 ;
   struct __anonstruct_xcoff64_112495713 xcoff64 ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct external_filehdr {
   unsigned char f_magic[2] ;
   unsigned char f_nscns[2] ;
   unsigned char f_timdat[4] ;
   union __anonunion_u_520025980 u ;
};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff32_372952112 {
   unsigned char s_paddr[4] ;
   unsigned char s_vaddr[4] ;
   unsigned char s_size[4] ;
   unsigned char s_scnptr[4] ;
   unsigned char s_relptr[4] ;
   unsigned char s_lnnoptr[4] ;
   unsigned char s_nreloc[2] ;
   unsigned char s_nlnno[2] ;
   unsigned char s_flags[4] ;
};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff64_372952113 {
   unsigned char s_paddr[8] ;
   unsigned char s_vaddr[8] ;
   unsigned char s_size[8] ;
   unsigned char s_scnptr[8] ;
   unsigned char s_relptr[8] ;
   unsigned char s_lnnoptr[8] ;
   unsigned char s_nreloc[4] ;
   unsigned char s_nlnno[4] ;
   unsigned char s_flags[4] ;
};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_u_1065105464 {
   struct __anonstruct_xcoff32_372952112 xcoff32 ;
   struct __anonstruct_xcoff64_372952113 xcoff64 ;
};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct external_scnhdr {
   unsigned char s_name[8] ;
   union __anonunion_u_1065105464 u ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_n_443125039 {
   unsigned char n_zeroes[4] ;
   unsigned char n_offset[4] ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_n_68709925 {
   char n_name[8] ;
   struct __anonstruct_n_443125039 n ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff32_907530067 {
   union __anonunion_n_68709925 n ;
   unsigned char n_value[4] ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff64_443125040 {
   unsigned char n_value[8] ;
   unsigned char n_offset[4] ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_u_179524160 {
   struct __anonstruct_xcoff32_907530067 xcoff32 ;
   struct __anonstruct_xcoff64_443125040 xcoff64 ;
};
#line 136 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct external_syment {
   union __anonunion_u_179524160 u ;
   unsigned char n_scnum[2] ;
   unsigned char n_type[2] ;
   unsigned char n_sclass[1] ;
   unsigned char n_numaux[1] ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct__x_1065105465 {
   unsigned char x_zeroes[4] ;
   unsigned char x_offset[4] ;
   unsigned char x_pad[6] ;
   unsigned char x_ftype ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_x_file_945868478 {
   char x_fname[14] ;
   struct __anonstruct__x_1065105465 _x ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_x_scn_948896363 {
   unsigned char x_scnlen[4] ;
   unsigned char x_nreloc[2] ;
   unsigned char x_nlinno[2] ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_x_csect_834899447 {
   unsigned char x_scnlen[4] ;
   unsigned char x_parmhash[4] ;
   unsigned char x_snhash[2] ;
   unsigned char x_smtyp ;
   unsigned char x_smclas ;
   unsigned char x_stab ;
   unsigned char x_snstab[2] ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff32_58644090 {
   struct __anonstruct_x_csect_834899447 x_csect ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_x_csect_18596974 {
   unsigned char x_scnlen_lo[4] ;
   unsigned char x_parmhash[4] ;
   unsigned char x_snhash[2] ;
   unsigned char x_smtyp ;
   unsigned char x_smclas ;
   unsigned char x_scnlen_hi[4] ;
   unsigned char pad ;
   unsigned char x_auxtype ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_xcoff64_157170940 {
   struct __anonstruct_x_csect_18596974 x_csect ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_u_584269645 {
   struct __anonstruct_xcoff32_58644090 xcoff32 ;
   struct __anonstruct_xcoff64_157170940 xcoff64 ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct __anonstruct_x_sect_948896364 {
   unsigned char x_scnlen[4] ;
   unsigned char pad1[4] ;
   unsigned char x_nreloc[4] ;
};
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union external_auxent {
   union __anonunion_x_file_945868478 x_file ;
   struct __anonstruct_x_scn_948896363 x_scn ;
   union __anonunion_u_584269645 u ;
   struct __anonstruct_x_sect_948896364 x_sect ;
};
#line 263 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct simple_object_xcoff_read {
   unsigned short magic ;
   unsigned short nscns ;
   off_t symptr ;
   unsigned int nsyms ;
   unsigned short flags ;
   off_t scnhdr_offset ;
};
#line 281 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct simple_object_xcoff_attributes {
   unsigned short magic ;
   unsigned short flags ;
};
#line 716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
union __anonunion_syms_806857204 {
   struct external_syment sym ;
   union external_auxent aux ;
};
#line 48 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_header_32 {
   unsigned char magic[4] ;
   unsigned char cputype[4] ;
   unsigned char cpusubtype[4] ;
   unsigned char filetype[4] ;
   unsigned char ncmds[4] ;
   unsigned char sizeofcmds[4] ;
   unsigned char flags[4] ;
};
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_header_64 {
   unsigned char magic[4] ;
   unsigned char cputype[4] ;
   unsigned char cpusubtype[4] ;
   unsigned char filetype[4] ;
   unsigned char ncmds[4] ;
   unsigned char sizeofcmds[4] ;
   unsigned char flags[4] ;
   unsigned char reserved[4] ;
};
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_load_command {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
};
#line 98 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_segment_command_32 {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
   unsigned char segname[16] ;
   unsigned char vmaddr[4] ;
   unsigned char vmsize[4] ;
   unsigned char fileoff[4] ;
   unsigned char filesize[4] ;
   unsigned char maxprot[4] ;
   unsigned char initprot[4] ;
   unsigned char nsects[4] ;
   unsigned char flags[4] ;
};
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_segment_command_64 {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
   unsigned char segname[16] ;
   unsigned char vmaddr[8] ;
   unsigned char vmsize[8] ;
   unsigned char fileoff[8] ;
   unsigned char filesize[8] ;
   unsigned char maxprot[4] ;
   unsigned char initprot[4] ;
   unsigned char nsects[4] ;
   unsigned char flags[4] ;
};
#line 132 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_section_32 {
   unsigned char sectname[16] ;
   unsigned char segname[16] ;
   unsigned char addr[4] ;
   unsigned char size[4] ;
   unsigned char offset[4] ;
   unsigned char align[4] ;
   unsigned char reloff[4] ;
   unsigned char nreloc[4] ;
   unsigned char flags[4] ;
   unsigned char reserved1[4] ;
   unsigned char reserved2[4] ;
};
#line 149 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct mach_o_section_64 {
   unsigned char sectname[16] ;
   unsigned char segname[16] ;
   unsigned char addr[8] ;
   unsigned char size[8] ;
   unsigned char offset[4] ;
   unsigned char align[4] ;
   unsigned char reloff[4] ;
   unsigned char nreloc[4] ;
   unsigned char flags[4] ;
   unsigned char reserved1[4] ;
   unsigned char reserved2[4] ;
   unsigned char reserved3[4] ;
};
#line 188 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct simple_object_mach_o_read {
   char *segment_name ;
   unsigned int magic ;
   int is_big_endian ;
   unsigned int cputype ;
   unsigned int cpusubtype ;
   unsigned int ncmds ;
   unsigned int flags ;
   unsigned int reserved ;
};
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct simple_object_mach_o_attributes {
   unsigned int magic ;
   int is_big_endian ;
   unsigned int cputype ;
   unsigned int cpusubtype ;
   unsigned int flags ;
   unsigned int reserved ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Ehdr_45460738 {
   unsigned char e_ident[16] ;
   unsigned char e_type[2] ;
   unsigned char e_machine[2] ;
   unsigned char e_version[4] ;
   unsigned char e_entry[4] ;
   unsigned char e_phoff[4] ;
   unsigned char e_shoff[4] ;
   unsigned char e_flags[4] ;
   unsigned char e_ehsize[2] ;
   unsigned char e_phentsize[2] ;
   unsigned char e_phnum[2] ;
   unsigned char e_shentsize[2] ;
   unsigned char e_shnum[2] ;
   unsigned char e_shstrndx[2] ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Ehdr_45460738 Elf32_External_Ehdr;
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Ehdr_45460739 {
   unsigned char e_ident[16] ;
   unsigned char e_type[2] ;
   unsigned char e_machine[2] ;
   unsigned char e_version[4] ;
   unsigned char e_entry[8] ;
   unsigned char e_phoff[8] ;
   unsigned char e_shoff[8] ;
   unsigned char e_flags[4] ;
   unsigned char e_ehsize[2] ;
   unsigned char e_phentsize[2] ;
   unsigned char e_phnum[2] ;
   unsigned char e_shentsize[2] ;
   unsigned char e_shnum[2] ;
   unsigned char e_shstrndx[2] ;
};
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Ehdr_45460739 Elf64_External_Ehdr;
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Phdr_18596974 {
   unsigned char p_type[4] ;
   unsigned char p_offset[4] ;
   unsigned char p_vaddr[4] ;
   unsigned char p_paddr[4] ;
   unsigned char p_filesz[4] ;
   unsigned char p_memsz[4] ;
   unsigned char p_flags[4] ;
   unsigned char p_align[4] ;
};
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Phdr_18596974 Elf32_External_Phdr;
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Phdr_18596975 {
   unsigned char p_type[4] ;
   unsigned char p_flags[4] ;
   unsigned char p_offset[8] ;
   unsigned char p_vaddr[8] ;
   unsigned char p_paddr[8] ;
   unsigned char p_filesz[8] ;
   unsigned char p_memsz[8] ;
   unsigned char p_align[8] ;
};
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Phdr_18596975 Elf64_External_Phdr;
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Shdr_226953194 {
   unsigned char sh_name[4] ;
   unsigned char sh_type[4] ;
   unsigned char sh_flags[4] ;
   unsigned char sh_addr[4] ;
   unsigned char sh_offset[4] ;
   unsigned char sh_size[4] ;
   unsigned char sh_link[4] ;
   unsigned char sh_info[4] ;
   unsigned char sh_addralign[4] ;
   unsigned char sh_entsize[4] ;
};
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Shdr_226953194 Elf32_External_Shdr;
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Shdr_226953195 {
   unsigned char sh_name[4] ;
   unsigned char sh_type[4] ;
   unsigned char sh_flags[8] ;
   unsigned char sh_addr[8] ;
   unsigned char sh_offset[8] ;
   unsigned char sh_size[8] ;
   unsigned char sh_link[4] ;
   unsigned char sh_info[4] ;
   unsigned char sh_addralign[8] ;
   unsigned char sh_entsize[8] ;
};
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Shdr_226953195 Elf64_External_Shdr;
#line 192 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct elf_type_functions {
   unsigned short (*fetch_Elf_Half)(unsigned char const   * ) ;
   unsigned int (*fetch_Elf_Word)(unsigned char const   * ) ;
   ulong_type (*fetch_Elf_Addr)(unsigned char const   * ) ;
   void (*set_Elf_Half)(unsigned char * , unsigned short  ) ;
   void (*set_Elf_Word)(unsigned char * , unsigned int  ) ;
   void (*set_Elf_Addr)(unsigned char * , ulong_type  ) ;
};
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct simple_object_elf_read {
   struct elf_type_functions  const  *type_functions ;
   unsigned char ei_data ;
   unsigned char ei_class ;
   unsigned char ei_osabi ;
   unsigned short machine ;
   unsigned int flags ;
   ulong_type shoff ;
   unsigned int shnum ;
   unsigned int shstrndx ;
};
#line 335 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct simple_object_elf_attributes {
   struct elf_type_functions  const  *type_functions ;
   unsigned char ei_data ;
   unsigned char ei_class ;
   unsigned char ei_osabi ;
   unsigned short machine ;
   unsigned int flags ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct external_filehdr___0 {
   unsigned char f_magic[2] ;
   unsigned char f_nscns[2] ;
   unsigned char f_timdat[4] ;
   unsigned char f_symptr[4] ;
   unsigned char f_nsyms[4] ;
   unsigned char f_opthdr[2] ;
   unsigned char f_flags[2] ;
};
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct external_scnhdr___0 {
   unsigned char s_name[8] ;
   unsigned char s_paddr[4] ;
   unsigned char s_vaddr[4] ;
   unsigned char s_size[4] ;
   unsigned char s_scnptr[4] ;
   unsigned char s_relptr[4] ;
   unsigned char s_lnnoptr[4] ;
   unsigned char s_nreloc[2] ;
   unsigned char s_nlnno[2] ;
   unsigned char s_flags[4] ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct __anonstruct_e_443125039 {
   unsigned char e_zeroes[4] ;
   unsigned char e_offset[4] ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
union __anonunion_e_1032762424 {
   unsigned char e_name[8] ;
   struct __anonstruct_e_443125039 e ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct external_syment___0 {
   union __anonunion_e_1032762424 e ;
   unsigned char e_value[4] ;
   unsigned char e_scnum[2] ;
   unsigned char e_type[2] ;
   unsigned char e_sclass[1] ;
   unsigned char e_numaux[1] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct __anonstruct_x_n_969178060 {
   unsigned char x_zeroes[4] ;
   unsigned char x_offset[4] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
union __anonunion_x_file_969178059 {
   char x_fname[18] ;
   struct __anonstruct_x_n_969178060 x_n ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct __anonstruct_x_scn_441262567 {
   unsigned char x_scnlen[4] ;
   unsigned char x_nreloc[2] ;
   unsigned char x_nlinno[2] ;
   unsigned char x_checksum[4] ;
   unsigned char x_associated[2] ;
   unsigned char x_comdat[1] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
union external_auxent___0 {
   union __anonunion_x_file_969178059 x_file ;
   struct __anonstruct_x_scn_441262567 x_scn ;
};
#line 165 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct simple_object_coff_read {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short nscns ;
   off_t symptr ;
   unsigned int nsyms ;
   unsigned short flags ;
   off_t scnhdr_offset ;
};
#line 185 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct simple_object_coff_attributes {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short flags ;
};
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct coff_magic_struct {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short non_object_flags ;
};
#line 619 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
union __anonunion_syms_806857204___0 {
   struct external_syment___0 sym ;
   union external_auxent___0 aux ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 45 "./../include/sha1.h"
typedef uint32_t sha1_uint32;
#line 81 "./../include/sha1.h"
struct sha1_ctx {
   sha1_uint32 A ;
   sha1_uint32 B ;
   sha1_uint32 C ;
   sha1_uint32 D ;
   sha1_uint32 E ;
   sha1_uint32 total[2] ;
   sha1_uint32 buflen ;
   sha1_uint32 buffer[32] ;
};
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
struct __anonstruct_694274947 {
   char c ;
   sha1_uint32 x ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 47 "./../include/xregex2.h"
typedef unsigned long active_reg_t;
#line 54 "./../include/xregex2.h"
typedef unsigned long reg_syntax_t;
#line 291
enum __anonenum_reg_errcode_t_784080967 {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 291 "./../include/xregex2.h"
typedef enum __anonenum_reg_errcode_t_784080967 reg_errcode_t;
#line 331 "./../include/xregex2.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 399 "./../include/xregex2.h"
typedef struct re_pattern_buffer regex_t;
#line 402 "./../include/xregex2.h"
typedef int xregoff_t;
#line 407 "./../include/xregex2.h"
struct re_registers {
   unsigned int num_regs ;
   xregoff_t *start ;
   xregoff_t *end ;
};
#line 426 "./../include/xregex2.h"
struct __anonstruct_regmatch_t_986009469 {
   xregoff_t rm_so ;
   xregoff_t rm_eo ;
};
#line 426 "./../include/xregex2.h"
typedef struct __anonstruct_regmatch_t_986009469 regmatch_t;
#line 406 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef char boolean;
#line 455
enum __anonenum_re_opcode_t_433329371 {
    no_op = 0,
    succeed = 1,
    exactn = 2,
    anychar = 3,
    charset = 4,
    charset_not = 5,
    start_memory = 6,
    stop_memory = 7,
    duplicate = 8,
    begline = 9,
    endline = 10,
    begbuf = 11,
    endbuf = 12,
    jump = 13,
    jump_past_alt = 14,
    on_failure_jump = 15,
    on_failure_keep_string_jump = 16,
    pop_failure_jump = 17,
    maybe_pop_jump = 18,
    dummy_failure_jump = 19,
    push_dummy_failure = 20,
    succeed_n = 21,
    jump_n = 22,
    set_number_at = 23,
    wordchar = 24,
    notwordchar = 25,
    wordbeg = 26,
    wordend = 27,
    wordbound = 28,
    notwordbound = 29
} ;
#line 455 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef enum __anonenum_re_opcode_t_433329371 re_opcode_t;
#line 1467 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
union byte_fail_stack_elt {
   unsigned char *pointer ;
   int integer ;
};
#line 1473 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef union byte_fail_stack_elt byte_fail_stack_elt_t;
#line 1475 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
struct __anonstruct_byte_fail_stack_type_401414316 {
   byte_fail_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 1475 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef struct __anonstruct_byte_fail_stack_type_401414316 byte_fail_stack_type;
#line 1796 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
struct __anonstruct_bits_582056016 {
   unsigned int match_null_string_p : 2 ;
   unsigned int is_active : 1 ;
   unsigned int matched_something : 1 ;
   unsigned int ever_matched_something : 1 ;
};
#line 1796 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
union __anonunion_byte_register_info_type_936275296 {
   byte_fail_stack_elt_t word ;
   struct __anonstruct_bits_582056016 bits ;
};
#line 1796 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef union __anonunion_byte_register_info_type_936275296 byte_register_info_type;
#line 2109 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef unsigned int regnum_t;
#line 2117 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef long pattern_offset_t;
#line 2119 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
struct __anonstruct_compile_stack_elt_t_369398534 {
   pattern_offset_t begalt_offset ;
   pattern_offset_t fixup_alt_jump ;
   pattern_offset_t inner_group_offset ;
   pattern_offset_t laststart_offset ;
   regnum_t regnum ;
};
#line 2119 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef struct __anonstruct_compile_stack_elt_t_369398534 compile_stack_elt_t;
#line 2129 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
struct __anonstruct_compile_stack_type_541390256 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 2129 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
typedef struct __anonstruct_compile_stack_type_541390256 compile_stack_type;
#line 401 "./../include/libiberty.h"
struct pex_obj ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 559 "./../include/libiberty.h"
struct pex_time {
   unsigned long user_seconds ;
   unsigned long user_microseconds ;
   unsigned long system_seconds ;
   unsigned long system_microseconds ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 54 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.h"
struct pex_funcs ;
#line 54 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.h"
struct pex_obj {
   int flags ;
   char const   *pname ;
   char const   *tempbase ;
   int next_input ;
   char *next_input_name ;
   int next_input_name_allocated ;
   int stderr_pipe ;
   int count ;
   pid_t *children ;
   int *status ;
   struct pex_time *time ;
   int number_waited ;
   FILE *input_file ;
   FILE *read_output ;
   FILE *read_err ;
   int remove_count ;
   char **remove ;
   struct pex_funcs  const  *funcs ;
   void *sysdep ;
};
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.h"
struct pex_funcs {
   int (*open_read)(struct pex_obj * , char const   * , int  ) ;
   int (*open_write)(struct pex_obj * , char const   * , int  ) ;
   pid_t (*exec_child)(struct pex_obj * , int  , char const   * , char * const  * ,
                       char * const  * , int  , int  , int  , int  , char const   ** ,
                       int * ) ;
   int (*close)(struct pex_obj * , int  ) ;
   pid_t (*wait)(struct pex_obj * , pid_t  , int * , struct pex_time * , int  , char const   ** ,
                 int * ) ;
   int (*pipe)(struct pex_obj * , int * , int  ) ;
   FILE *(*fdopenr)(struct pex_obj * , int  , int  ) ;
   FILE *(*fdopenw)(struct pex_obj * , int  , int  ) ;
   void (*cleanup)(struct pex_obj * ) ;
};
#line 129 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField15 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField16 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField17 ;
};
#line 46 "./../include/partition.h"
struct partition_elem {
   int class_element ;
   struct partition_elem *next ;
   unsigned int class_count ;
};
#line 59 "./../include/partition.h"
struct partition_def {
   int num_elements ;
   struct partition_elem elements[1] ;
};
#line 59 "./../include/partition.h"
typedef struct partition_def *partition;
#line 44 "./../include/objalloc.h"
struct objalloc {
   char *current_ptr ;
   unsigned int current_space ;
   void *chunks ;
};
#line 53 "./../include/objalloc.h"
struct objalloc_align {
   char x ;
   double d ;
};
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./objalloc.c"
struct objalloc_chunk {
   struct objalloc_chunk *next ;
   char *current_ptr ;
};
#line 46 "./../include/md5.h"
typedef uint32_t md5_uint32;
#line 47 "./../include/md5.h"
typedef uintptr_t md5_uintptr;
#line 85 "./../include/md5.h"
struct md5_ctx {
   md5_uint32 A ;
   md5_uint32 B ;
   md5_uint32 C ;
   md5_uint32 D ;
   md5_uint32 total[2] ;
   md5_uint32 buflen ;
   char buffer[128]  __attribute__((__aligned__(__alignof__(md5_uint32 )))) ;
};
#line 47 "./../include/hashtab.h"
typedef unsigned int hashval_t;
#line 100 "./../include/hashtab.h"
struct htab {
   hashval_t (*hash_f)(void const   * ) ;
   int (*eq_f)(void const   * , void const   * ) ;
   void (*del_f)(void * ) ;
   void **entries ;
   size_t size ;
   size_t n_elements ;
   size_t n_deleted ;
   unsigned int searches ;
   unsigned int collisions ;
   void *(*alloc_f)(size_t  , size_t  ) ;
   void (*free_f)(void * ) ;
   void *alloc_arg ;
   void *(*alloc_with_arg_f)(void * , size_t  , size_t  ) ;
   void (*free_with_arg_f)(void * , void * ) ;
   unsigned int size_prime_index ;
};
#line 144 "./../include/hashtab.h"
typedef struct htab *htab_t;
#line 147
enum insert_option {
    NO_INSERT = 0,
    INSERT = 1
} ;
#line 127 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
struct prime_ent {
   hashval_t prime ;
   hashval_t inv ;
   hashval_t inv_m2 ;
   hashval_t shift ;
};
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
typedef uint64_t ull;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 34 "./../include/floatformat.h"
enum floatformat_byteorders {
    floatformat_little = 0,
    floatformat_big = 1,
    floatformat_littlebyte_bigword = 2,
    floatformat_vax = 3
} ;
#line 54
enum floatformat_intbit {
    floatformat_intbit_yes = 0,
    floatformat_intbit_no = 1
} ;
#line 56 "./../include/floatformat.h"
struct floatformat {
   enum floatformat_byteorders byteorder ;
   unsigned int totalsize ;
   unsigned int sign_start ;
   unsigned int exp_start ;
   unsigned int exp_len ;
   int exp_bias ;
   unsigned int exp_nan ;
   unsigned int man_start ;
   unsigned int man_len ;
   enum floatformat_intbit intbit ;
   char const   *name ;
   int (*is_valid)(struct floatformat  const  *fmt , void const   *from ) ;
   struct floatformat  const  *split_half ;
};
#line 50 "./../include/fibheap.h"
typedef long fibheapkey_t;
#line 52
struct fibnode ;
#line 52 "./../include/fibheap.h"
struct fibheap {
   size_t nodes ;
   struct fibnode *min ;
   struct fibnode *root ;
};
#line 52 "./../include/fibheap.h"
typedef struct fibheap *fibheap_t;
#line 59 "./../include/fibheap.h"
struct fibnode {
   struct fibnode *parent ;
   struct fibnode *child ;
   struct fibnode *left ;
   struct fibnode *right ;
   fibheapkey_t key ;
   void *data ;
   unsigned int degree : 31 ;
   unsigned int mark : 1 ;
};
#line 59 "./../include/fibheap.h"
typedef struct fibnode *fibnode_t;
#line 30 "./../include/dyn-string.h"
struct dyn_string {
   int allocated ;
   int length ;
   char *s ;
};
#line 30 "./../include/dyn-string.h"
typedef struct dyn_string *dyn_string_t;
#line 78 "./../include/demangle.h"
enum demangling_styles {
    no_demangling = -1,
    unknown_demangling = 0,
    auto_demangling = 256,
    gnu_demangling = 512,
    lucid_demangling = 1024,
    arm_demangling = 2048,
    hp_demangling = 4096,
    edg_demangling = 8192,
    gnu_v3_demangling = 16384,
    java_demangling = 4,
    gnat_demangling = 32768
} ;
#line 122 "./../include/demangle.h"
struct demangler_engine {
   char const   * const  demangling_style_name ;
   enum demangling_styles  const  demangling_style ;
   char const   * const  demangling_style_doc ;
};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
struct string {
   char *b ;
   char *p ;
   char *e ;
};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
typedef struct string string;
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
struct work_stuff {
   int options ;
   char **typevec ;
   char **ktypevec ;
   char **btypevec ;
   int numk ;
   int numb ;
   int ksize ;
   int bsize ;
   int ntypes ;
   int typevec_size ;
   int constructor ;
   int destructor ;
   int static_type ;
   int temp_start ;
   int type_quals ;
   int dllimported ;
   char **tmpl_argvec ;
   int ntmpl_args ;
   int forgetting_types ;
   string *previous_argument ;
   int nrepeats ;
};
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
struct optable {
   char const   * const  in ;
   char const   * const  out ;
   int const   flags ;
};
#line 235
enum type_kind_t {
    tk_none = 0,
    tk_pointer = 1,
    tk_reference = 2,
    tk_integral = 3,
    tk_bool = 4,
    tk_char = 5,
    tk_real = 6
} ;
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
typedef enum type_kind_t type_kind_t;
#line 172 "./../include/demangle.h"
enum gnu_v3_ctor_kinds {
    gnu_v3_complete_object_ctor = 1,
    gnu_v3_base_object_ctor = 2,
    gnu_v3_complete_object_allocating_ctor = 3,
    gnu_v3_object_ctor_group = 4
} ;
#line 187
enum gnu_v3_dtor_kinds {
    gnu_v3_deleting_dtor = 1,
    gnu_v3_complete_object_dtor = 2,
    gnu_v3_base_object_dtor = 3,
    gnu_v3_object_dtor_group = 4
} ;
#line 215
enum demangle_component_type {
    DEMANGLE_COMPONENT_NAME = 0,
    DEMANGLE_COMPONENT_QUAL_NAME = 1,
    DEMANGLE_COMPONENT_LOCAL_NAME = 2,
    DEMANGLE_COMPONENT_TYPED_NAME = 3,
    DEMANGLE_COMPONENT_TEMPLATE = 4,
    DEMANGLE_COMPONENT_TEMPLATE_PARAM = 5,
    DEMANGLE_COMPONENT_FUNCTION_PARAM = 6,
    DEMANGLE_COMPONENT_CTOR = 7,
    DEMANGLE_COMPONENT_DTOR = 8,
    DEMANGLE_COMPONENT_VTABLE = 9,
    DEMANGLE_COMPONENT_VTT = 10,
    DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE = 11,
    DEMANGLE_COMPONENT_TYPEINFO = 12,
    DEMANGLE_COMPONENT_TYPEINFO_NAME = 13,
    DEMANGLE_COMPONENT_TYPEINFO_FN = 14,
    DEMANGLE_COMPONENT_THUNK = 15,
    DEMANGLE_COMPONENT_VIRTUAL_THUNK = 16,
    DEMANGLE_COMPONENT_COVARIANT_THUNK = 17,
    DEMANGLE_COMPONENT_JAVA_CLASS = 18,
    DEMANGLE_COMPONENT_GUARD = 19,
    DEMANGLE_COMPONENT_TLS_INIT = 20,
    DEMANGLE_COMPONENT_TLS_WRAPPER = 21,
    DEMANGLE_COMPONENT_REFTEMP = 22,
    DEMANGLE_COMPONENT_HIDDEN_ALIAS = 23,
    DEMANGLE_COMPONENT_SUB_STD = 24,
    DEMANGLE_COMPONENT_RESTRICT = 25,
    DEMANGLE_COMPONENT_VOLATILE = 26,
    DEMANGLE_COMPONENT_CONST = 27,
    DEMANGLE_COMPONENT_RESTRICT_THIS = 28,
    DEMANGLE_COMPONENT_VOLATILE_THIS = 29,
    DEMANGLE_COMPONENT_CONST_THIS = 30,
    DEMANGLE_COMPONENT_REFERENCE_THIS = 31,
    DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS = 32,
    DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL = 33,
    DEMANGLE_COMPONENT_POINTER = 34,
    DEMANGLE_COMPONENT_REFERENCE = 35,
    DEMANGLE_COMPONENT_RVALUE_REFERENCE = 36,
    DEMANGLE_COMPONENT_COMPLEX = 37,
    DEMANGLE_COMPONENT_IMAGINARY = 38,
    DEMANGLE_COMPONENT_BUILTIN_TYPE = 39,
    DEMANGLE_COMPONENT_VENDOR_TYPE = 40,
    DEMANGLE_COMPONENT_FUNCTION_TYPE = 41,
    DEMANGLE_COMPONENT_ARRAY_TYPE = 42,
    DEMANGLE_COMPONENT_PTRMEM_TYPE = 43,
    DEMANGLE_COMPONENT_FIXED_TYPE = 44,
    DEMANGLE_COMPONENT_VECTOR_TYPE = 45,
    DEMANGLE_COMPONENT_ARGLIST = 46,
    DEMANGLE_COMPONENT_TEMPLATE_ARGLIST = 47,
    DEMANGLE_COMPONENT_INITIALIZER_LIST = 48,
    DEMANGLE_COMPONENT_OPERATOR = 49,
    DEMANGLE_COMPONENT_EXTENDED_OPERATOR = 50,
    DEMANGLE_COMPONENT_CAST = 51,
    DEMANGLE_COMPONENT_NULLARY = 52,
    DEMANGLE_COMPONENT_UNARY = 53,
    DEMANGLE_COMPONENT_BINARY = 54,
    DEMANGLE_COMPONENT_BINARY_ARGS = 55,
    DEMANGLE_COMPONENT_TRINARY = 56,
    DEMANGLE_COMPONENT_TRINARY_ARG1 = 57,
    DEMANGLE_COMPONENT_TRINARY_ARG2 = 58,
    DEMANGLE_COMPONENT_LITERAL = 59,
    DEMANGLE_COMPONENT_LITERAL_NEG = 60,
    DEMANGLE_COMPONENT_JAVA_RESOURCE = 61,
    DEMANGLE_COMPONENT_COMPOUND_NAME = 62,
    DEMANGLE_COMPONENT_CHARACTER = 63,
    DEMANGLE_COMPONENT_NUMBER = 64,
    DEMANGLE_COMPONENT_DECLTYPE = 65,
    DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS = 66,
    DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS = 67,
    DEMANGLE_COMPONENT_LAMBDA = 68,
    DEMANGLE_COMPONENT_DEFAULT_ARG = 69,
    DEMANGLE_COMPONENT_UNNAMED_TYPE = 70,
    DEMANGLE_COMPONENT_TRANSACTION_CLONE = 71,
    DEMANGLE_COMPONENT_NONTRANSACTION_CLONE = 72,
    DEMANGLE_COMPONENT_PACK_EXPANSION = 73,
    DEMANGLE_COMPONENT_TAGGED_NAME = 74,
    DEMANGLE_COMPONENT_CLONE = 75
} ;
#line 437
struct demangle_operator_info ;
#line 438
struct demangle_builtin_type_info ;
#line 445 "./../include/demangle.h"
struct __anonstruct_s_name_713894858 {
   char const   *s ;
   int len ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_operator_748683663 {
   struct demangle_operator_info  const  *op ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_extended_operator_590623169 {
   int args ;
   struct demangle_component *name ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_fixed_169630776 {
   struct demangle_component *length ;
   short accum ;
   short sat ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_ctor_307957940 {
   enum gnu_v3_ctor_kinds kind ;
   struct demangle_component *name ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_dtor_207014792 {
   enum gnu_v3_dtor_kinds kind ;
   struct demangle_component *name ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_builtin_158994218 {
   struct demangle_builtin_type_info  const  *type ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_string_748683664 {
   char const   *string ;
   int len ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_number_721778306 {
   long number ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_character_973126069 {
   int character ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_binary_1038925671 {
   struct demangle_component *left ;
   struct demangle_component *right ;
};
#line 445 "./../include/demangle.h"
struct __anonstruct_s_unary_num_402786937 {
   struct demangle_component *sub ;
   int num ;
};
#line 445 "./../include/demangle.h"
union __anonunion_u_781951050 {
   struct __anonstruct_s_name_713894858 s_name ;
   struct __anonstruct_s_operator_748683663 s_operator ;
   struct __anonstruct_s_extended_operator_590623169 s_extended_operator ;
   struct __anonstruct_s_fixed_169630776 s_fixed ;
   struct __anonstruct_s_ctor_307957940 s_ctor ;
   struct __anonstruct_s_dtor_207014792 s_dtor ;
   struct __anonstruct_s_builtin_158994218 s_builtin ;
   struct __anonstruct_s_string_748683664 s_string ;
   struct __anonstruct_s_number_721778306 s_number ;
   struct __anonstruct_s_character_973126069 s_character ;
   struct __anonstruct_s_binary_1038925671 s_binary ;
   struct __anonstruct_s_unary_num_402786937 s_unary_num ;
};
#line 445 "./../include/demangle.h"
struct demangle_component {
   enum demangle_component_type type ;
   union __anonunion_u_781951050 u ;
};
#line 37 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.h"
struct demangle_operator_info {
   char const   *code ;
   char const   *name ;
   int len ;
   int args ;
};
#line 51
enum d_builtin_type_print {
    D_PRINT_DEFAULT = 0,
    D_PRINT_INT = 1,
    D_PRINT_UNSIGNED = 2,
    D_PRINT_LONG = 3,
    D_PRINT_UNSIGNED_LONG = 4,
    D_PRINT_LONG_LONG = 5,
    D_PRINT_UNSIGNED_LONG_LONG = 6,
    D_PRINT_BOOL = 7,
    D_PRINT_FLOAT = 8,
    D_PRINT_VOID = 9
} ;
#line 77 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.h"
struct demangle_builtin_type_info {
   char const   *name ;
   int len ;
   char const   *java_name ;
   int java_len ;
   enum d_builtin_type_print print ;
};
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.h"
struct d_info {
   char const   *s ;
   char const   *send ;
   int options ;
   char const   *n ;
   struct demangle_component *comps ;
   int next_comp ;
   int num_comps ;
   struct demangle_component **subs ;
   int next_sub ;
   int num_subs ;
   int did_subs ;
   struct demangle_component *last_name ;
   int expansion ;
};
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct d_standard_sub_info {
   char code ;
   char const   *simple_expansion ;
   int simple_len ;
   char const   *full_expansion ;
   int full_len ;
   char const   *set_last_name ;
   int set_last_name_len ;
};
#line 241 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct d_print_template {
   struct d_print_template *next ;
   struct demangle_component  const  *template_decl ;
};
#line 251 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct d_print_mod {
   struct d_print_mod *next ;
   struct demangle_component  const  *mod ;
   int printed ;
   struct d_print_template *templates ;
};
#line 266 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct d_growable_string {
   char *buf ;
   size_t len ;
   size_t alc ;
   int allocation_failure ;
};
#line 279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct d_print_info {
   char buf[256] ;
   size_t len ;
   char last_char ;
   void (*callback)(char const   * , size_t  , void * ) ;
   void *opaque ;
   struct d_print_template *templates ;
   struct d_print_mod *modifiers ;
   int demangle_failure ;
   int pack_index ;
   unsigned long flush_count ;
};
#line 5369
enum __anonenum_type_117194467 {
    DCT_TYPE = 0,
    DCT_MANGLED = 1,
    DCT_GLOBAL_CTORS = 2,
    DCT_GLOBAL_DTORS = 3
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
struct __anonstruct_h_290956128 {
   union hdr *next ;
   char *deep ;
};
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
union hdr {
   char align[sizeof(double )] ;
   struct __anonstruct_h_290956128 h ;
};
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
typedef union hdr header;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 128 "../bfd/bfd.h"
typedef int bfd_boolean;
#line 44 "./../include/aout/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.h"
typedef unsigned long long elf_vma;
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.h"
struct archive_info {
   char *file_name ;
   FILE *file ;
   elf_vma index_num ;
   elf_vma *index_array ;
   char *sym_table ;
   unsigned long sym_size ;
   char *longnames ;
   unsigned long longnames_size ;
   unsigned long nested_member_origin ;
   unsigned long next_arhdr_offset ;
   bfd_boolean is_thin_archive ;
   bfd_boolean uses_64bit_indicies ;
   struct ar_hdr arhdr ;
};
#line 328 "./../include/dwarf2.h"
enum dwarf_macinfo_record_type {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
} ;
#line 21 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef unsigned long long dwarf_vma;
#line 22 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef long long dwarf_signed_vma;
#line 23 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef unsigned long long dwarf_size_type;
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_LineInfo_750835996 {
   dwarf_vma li_length ;
   unsigned short li_version ;
   unsigned int li_prologue_length ;
   unsigned char li_min_insn_length ;
   unsigned char li_max_ops_per_insn ;
   unsigned char li_default_is_stmt ;
   int li_line_base ;
   unsigned char li_line_range ;
   unsigned char li_opcode_base ;
};
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_LineInfo_750835996 DWARF2_Internal_LineInfo;
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_PubNames_63719989 {
   dwarf_vma pn_length ;
   unsigned short pn_version ;
   dwarf_vma pn_offset ;
   dwarf_vma pn_size ;
};
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_PubNames_63719989 DWARF2_Internal_PubNames;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_CompUnit_606514397 {
   dwarf_vma cu_length ;
   unsigned short cu_version ;
   dwarf_vma cu_abbrev_offset ;
   unsigned char cu_pointer_size ;
};
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_CompUnit_606514397 DWARF2_Internal_CompUnit;
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_ARange_813886262 {
   dwarf_vma ar_length ;
   unsigned short ar_version ;
   dwarf_vma ar_info_offset ;
   unsigned char ar_pointer_size ;
   unsigned char ar_segment_size ;
};
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_ARange_813886262 DWARF2_Internal_ARange;
#line 111
enum dwarf_section_display_enum {
    abbrev = 0,
    aranges = 1,
    frame = 2,
    info = 3,
    line = 4,
    pubnames = 5,
    eh_frame = 6,
    macinfo = 7,
    macro = 8,
    str = 9,
    loc = 10,
    pubtypes = 11,
    ranges = 12,
    static_func = 13,
    static_vars = 14,
    types = 15,
    weaknames = 16,
    gdb_index = 17,
    trace_info = 18,
    trace_abbrev = 19,
    trace_aranges = 20,
    info_dwo = 21,
    abbrev_dwo = 22,
    types_dwo = 23,
    line_dwo = 24,
    loc_dwo = 25,
    macro_dwo = 26,
    macinfo_dwo = 27,
    str_dwo = 28,
    str_index = 29,
    str_index_dwo = 30,
    debug_addr = 31,
    dwp_cu_index = 32,
    dwp_tu_index = 33,
    max = 34
} ;
#line 150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct dwarf_section {
   char const   *uncompressed_name ;
   char const   *compressed_name ;
   char const   *name ;
   unsigned char *start ;
   dwarf_vma address ;
   dwarf_size_type size ;
   enum dwarf_section_display_enum abbrev_sec ;
};
#line 167 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct dwarf_section_display {
   struct dwarf_section section ;
   int (*display)(struct dwarf_section * , void * ) ;
   int *enabled ;
   unsigned int relocate : 1 ;
};
#line 179 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct __anonstruct_debug_info_540759837 {
   unsigned int pointer_size ;
   unsigned int offset_size ;
   int dwarf_version ;
   dwarf_vma cu_offset ;
   dwarf_vma base_address ;
   dwarf_vma addr_base ;
   dwarf_vma ranges_base ;
   dwarf_vma *loc_offsets ;
   int *have_frame_base ;
   unsigned int num_loc_offsets ;
   unsigned int max_loc_offsets ;
   dwarf_vma *range_lists ;
   unsigned int num_range_lists ;
   unsigned int max_range_lists ;
};
#line 179 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
typedef struct __anonstruct_debug_info_540759837 debug_info;
#line 60 "./../include/gdb/gdb-index.h"
enum __anonenum_gdb_index_symbol_kind_213103833 {
    GDB_INDEX_SYMBOL_KIND_NONE = 0,
    GDB_INDEX_SYMBOL_KIND_TYPE = 1,
    GDB_INDEX_SYMBOL_KIND_VARIABLE = 2,
    GDB_INDEX_SYMBOL_KIND_FUNCTION = 3,
    GDB_INDEX_SYMBOL_KIND_OTHER = 4,
    GDB_INDEX_SYMBOL_KIND_UNUSED5 = 5,
    GDB_INDEX_SYMBOL_KIND_UNUSED6 = 6,
    GDB_INDEX_SYMBOL_KIND_UNUSED7 = 7
} ;
#line 60 "./../include/gdb/gdb-index.h"
typedef enum __anonenum_gdb_index_symbol_kind_213103833 gdb_index_symbol_kind;
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct cu_tu_set {
   uint64_t signature ;
   dwarf_vma section_offsets[8] ;
   size_t section_sizes[8] ;
};
#line 168 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct dwarf_vmatoa_buf {
   char place[64] ;
};
#line 355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct State_Machine_Registers {
   dwarf_vma address ;
   unsigned int file ;
   unsigned int line ;
   unsigned int column ;
   int is_stmt ;
   int basic_block ;
   unsigned char op_index ;
   unsigned char end_sequence ;
   unsigned int last_file_entry ;
};
#line 355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct State_Machine_Registers SMR;
#line 639 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct abbrev_attr {
   unsigned long attribute ;
   unsigned long form ;
   struct abbrev_attr *next ;
};
#line 639 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct abbrev_attr abbrev_attr;
#line 647 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct abbrev_entry {
   unsigned long entry ;
   unsigned long tag ;
   int children ;
   struct abbrev_attr *first_attr ;
   struct abbrev_attr *last_attr ;
   struct abbrev_entry *next ;
};
#line 647 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct abbrev_entry abbrev_entry;
#line 3007 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct __anonstruct_File_Entry_450790744 {
   unsigned char *name ;
   unsigned int directory_index ;
   unsigned int modification_date ;
   unsigned int length ;
};
#line 3007 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct __anonstruct_File_Entry_450790744 File_Entry;
#line 4744 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct range_entry {
   unsigned long ranges_offset ;
   debug_info *debug_info_p ;
};
#line 4916 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct Frame_Chunk {
   struct Frame_Chunk *next ;
   unsigned char *chunk_start ;
   int ncols ;
   short *col_type ;
   int *col_offset ;
   char *augmentation ;
   unsigned int code_factor ;
   int data_factor ;
   dwarf_vma pc_begin ;
   dwarf_vma pc_range ;
   int cfa_reg ;
   int cfa_offset ;
   int ra ;
   unsigned char fde_encoding ;
   unsigned char cfa_exp ;
   unsigned char ptr_size ;
   unsigned char segment_size ;
};
#line 4916 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct Frame_Chunk Frame_Chunk;
#line 6621 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct __anonstruct_debug_dump_long_opts_37437826 {
   char const   *option ;
   int *variable ;
   int val ;
};
#line 6621 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
typedef struct __anonstruct_debug_dump_long_opts_37437826 debug_dump_long_opts;
#line 140 "../bfd/bfd.h"
typedef unsigned long bfd_vma;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
typedef bfd_vma unw_word;
#line 1047 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
typedef unsigned char const   *(*unw_decoder)(unsigned char const   * , unsigned int  ,
                                              void * );
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_52749002 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_52749002 __mbstate_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 84 "/usr/include/zlib.h"
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 96 "../bfd/bfd.h"
typedef long bfd_int64_t;
#line 97 "../bfd/bfd.h"
typedef unsigned long bfd_uint64_t;
#line 117
struct bfd ;
#line 117 "../bfd/bfd.h"
typedef struct bfd bfd;
#line 141 "../bfd/bfd.h"
typedef long bfd_signed_vma;
#line 142 "../bfd/bfd.h"
typedef unsigned long bfd_size_type;
#line 143 "../bfd/bfd.h"
typedef unsigned long symvalue;
#line 195 "../bfd/bfd.h"
typedef long file_ptr;
#line 196 "../bfd/bfd.h"
typedef unsigned long ufile_ptr;
#line 204 "../bfd/bfd.h"
typedef unsigned int flagword;
#line 205 "../bfd/bfd.h"
typedef unsigned char bfd_byte;
#line 209
enum bfd_format {
    bfd_unknown = 0,
    bfd_object = 1,
    bfd_archive = 2,
    bfd_core = 3,
    bfd_type_end = 4
} ;
#line 209 "../bfd/bfd.h"
typedef enum bfd_format bfd_format;
#line 222 "../bfd/bfd.h"
typedef unsigned long symindex;
#line 225
struct reloc_howto_struct ;
#line 225 "../bfd/bfd.h"
typedef struct reloc_howto_struct  const  reloc_howto_type;
#line 256 "../bfd/bfd.h"
union __anonunion_u_849859159 {
   file_ptr pos ;
   bfd *abfd ;
};
#line 256 "../bfd/bfd.h"
struct orl {
   char **name ;
   union __anonunion_u_849859159 u ;
   int namidx ;
};
#line 268
struct bfd_symbol ;
#line 268 "../bfd/bfd.h"
union __anonunion_u_625080999 {
   struct bfd_symbol *sym ;
   bfd_vma offset ;
};
#line 268 "../bfd/bfd.h"
struct lineno_cache_entry {
   unsigned int line_number ;
   union __anonunion_u_625080999 u ;
};
#line 268 "../bfd/bfd.h"
typedef struct lineno_cache_entry alent;
#line 284
struct bfd_section ;
#line 284 "../bfd/bfd.h"
typedef struct bfd_section *sec_ptr;
#line 317
enum bfd_print_symbol {
    bfd_print_symbol_name = 0,
    bfd_print_symbol_more = 1,
    bfd_print_symbol_all = 2
} ;
#line 317 "../bfd/bfd.h"
typedef enum bfd_print_symbol bfd_print_symbol_type;
#line 326 "../bfd/bfd.h"
struct _symbol_info {
   symvalue value ;
   char type ;
   char const   *name ;
   unsigned char stab_type ;
   char stab_other ;
   short stab_desc ;
   char const   *stab_name ;
};
#line 326 "../bfd/bfd.h"
typedef struct _symbol_info symbol_info;
#line 346 "../bfd/bfd.h"
struct bfd_hash_entry {
   struct bfd_hash_entry *next ;
   char const   *string ;
   unsigned long hash ;
};
#line 359 "../bfd/bfd.h"
struct bfd_hash_table {
   struct bfd_hash_entry **table ;
   struct bfd_hash_entry *(*newfunc)(struct bfd_hash_entry * , struct bfd_hash_table * ,
                                     char const   * ) ;
   void *memory ;
   unsigned int size ;
   unsigned int count ;
   unsigned int entsize ;
   unsigned int frozen : 1 ;
};
#line 570
struct bfd_link_info ;
#line 571
struct bfd_link_hash_entry ;
#line 759
struct _bfd_window_internal ;
#line 762 "../bfd/bfd.h"
struct _bfd_window {
   void *data ;
   bfd_size_type size ;
   struct _bfd_window_internal *i ;
};
#line 762 "../bfd/bfd.h"
typedef struct _bfd_window bfd_window;
#line 1206
struct relax_table ;
#line 1206
struct reloc_cache_entry ;
#line 1206
struct relent_chain ;
#line 1206
struct bfd_link_order ;
#line 1206 "../bfd/bfd.h"
union __anonunion_map_head_422694991 {
   struct bfd_link_order *link_order ;
   struct bfd_section *s ;
};
#line 1206 "../bfd/bfd.h"
struct bfd_section {
   char const   *name ;
   int id ;
   int index ;
   struct bfd_section *next ;
   struct bfd_section *prev ;
   flagword flags ;
   unsigned int user_set_vma : 1 ;
   unsigned int linker_mark : 1 ;
   unsigned int linker_has_input : 1 ;
   unsigned int gc_mark : 1 ;
   unsigned int compress_status : 2 ;
   unsigned int segment_mark : 1 ;
   unsigned int sec_info_type : 3 ;
   unsigned int use_rela_p : 1 ;
   unsigned int sec_flg0 : 1 ;
   unsigned int sec_flg1 : 1 ;
   unsigned int sec_flg2 : 1 ;
   unsigned int sec_flg3 : 1 ;
   unsigned int sec_flg4 : 1 ;
   unsigned int sec_flg5 : 1 ;
   bfd_vma vma ;
   bfd_vma lma ;
   bfd_size_type size ;
   bfd_size_type rawsize ;
   bfd_size_type compressed_size ;
   struct relax_table *relax ;
   int relax_count ;
   bfd_vma output_offset ;
   struct bfd_section *output_section ;
   unsigned int alignment_power ;
   struct reloc_cache_entry *relocation ;
   struct reloc_cache_entry **orelocation ;
   unsigned int reloc_count ;
   file_ptr filepos ;
   file_ptr rel_filepos ;
   file_ptr line_filepos ;
   void *userdata ;
   unsigned char *contents ;
   alent *lineno ;
   unsigned int lineno_count ;
   unsigned int entsize ;
   struct bfd_section *kept_section ;
   file_ptr moving_line_filepos ;
   int target_index ;
   void *used_by_bfd ;
   struct relent_chain *constructor_chain ;
   bfd *owner ;
   struct bfd_symbol *symbol ;
   struct bfd_symbol **symbol_ptr_ptr ;
   union __anonunion_map_head_422694991 map_head ;
   union __anonunion_map_head_422694991 map_tail ;
};
#line 1206 "../bfd/bfd.h"
typedef struct bfd_section asection;
#line 1589 "../bfd/bfd.h"
struct relax_table {
   bfd_vma addr ;
   int size ;
};
#line 1824
enum bfd_architecture {
    bfd_arch_unknown = 0,
    bfd_arch_obscure = 1,
    bfd_arch_m68k = 2,
    bfd_arch_vax = 3,
    bfd_arch_i960 = 4,
    bfd_arch_or32 = 5,
    bfd_arch_sparc = 6,
    bfd_arch_spu = 7,
    bfd_arch_mips = 8,
    bfd_arch_i386 = 9,
    bfd_arch_l1om = 10,
    bfd_arch_k1om = 11,
    bfd_arch_we32k = 12,
    bfd_arch_tahoe = 13,
    bfd_arch_i860 = 14,
    bfd_arch_i370 = 15,
    bfd_arch_romp = 16,
    bfd_arch_convex = 17,
    bfd_arch_m88k = 18,
    bfd_arch_m98k = 19,
    bfd_arch_pyramid = 20,
    bfd_arch_h8300 = 21,
    bfd_arch_pdp11 = 22,
    bfd_arch_plugin = 23,
    bfd_arch_powerpc = 24,
    bfd_arch_rs6000 = 25,
    bfd_arch_hppa = 26,
    bfd_arch_d10v = 27,
    bfd_arch_d30v = 28,
    bfd_arch_dlx = 29,
    bfd_arch_m68hc11 = 30,
    bfd_arch_m68hc12 = 31,
    bfd_arch_m9s12x = 32,
    bfd_arch_m9s12xg = 33,
    bfd_arch_z8k = 34,
    bfd_arch_h8500 = 35,
    bfd_arch_sh = 36,
    bfd_arch_alpha = 37,
    bfd_arch_arm = 38,
    bfd_arch_ns32k = 39,
    bfd_arch_w65 = 40,
    bfd_arch_tic30 = 41,
    bfd_arch_tic4x = 42,
    bfd_arch_tic54x = 43,
    bfd_arch_tic6x = 44,
    bfd_arch_tic80 = 45,
    bfd_arch_v850 = 46,
    bfd_arch_v850_rh850 = 47,
    bfd_arch_arc = 48,
    bfd_arch_m32c = 49,
    bfd_arch_m32r = 50,
    bfd_arch_mn10200 = 51,
    bfd_arch_mn10300 = 52,
    bfd_arch_fr30 = 53,
    bfd_arch_frv = 54,
    bfd_arch_moxie = 55,
    bfd_arch_mcore = 56,
    bfd_arch_mep = 57,
    bfd_arch_metag = 58,
    bfd_arch_ia64 = 59,
    bfd_arch_ip2k = 60,
    bfd_arch_iq2000 = 61,
    bfd_arch_epiphany = 62,
    bfd_arch_mt = 63,
    bfd_arch_pj = 64,
    bfd_arch_avr = 65,
    bfd_arch_bfin = 66,
    bfd_arch_cr16 = 67,
    bfd_arch_cr16c = 68,
    bfd_arch_crx = 69,
    bfd_arch_cris = 70,
    bfd_arch_rl78 = 71,
    bfd_arch_rx = 72,
    bfd_arch_s390 = 73,
    bfd_arch_score = 74,
    bfd_arch_openrisc = 75,
    bfd_arch_mmix = 76,
    bfd_arch_xstormy16 = 77,
    bfd_arch_msp430 = 78,
    bfd_arch_xc16x = 79,
    bfd_arch_xgate = 80,
    bfd_arch_xtensa = 81,
    bfd_arch_z80 = 82,
    bfd_arch_lm32 = 83,
    bfd_arch_microblaze = 84,
    bfd_arch_tilepro = 85,
    bfd_arch_tilegx = 86,
    bfd_arch_aarch64 = 87,
    bfd_arch_nios2 = 88,
    bfd_arch_last = 89
} ;
#line 2243 "../bfd/bfd.h"
struct bfd_arch_info {
   int bits_per_word ;
   int bits_per_address ;
   int bits_per_byte ;
   enum bfd_architecture arch ;
   unsigned long mach ;
   char const   *arch_name ;
   char const   *printable_name ;
   unsigned int section_align_power ;
   bfd_boolean the_default ;
   struct bfd_arch_info  const  *(*compatible)(struct bfd_arch_info  const  *a , struct bfd_arch_info  const  *b ) ;
   bfd_boolean (*scan)(struct bfd_arch_info  const  * , char const   * ) ;
   void *(*fill)(bfd_size_type count , bfd_boolean is_bigendian , bfd_boolean code ) ;
   struct bfd_arch_info  const  *next ;
};
#line 2305
enum bfd_reloc_status {
    bfd_reloc_ok = 0,
    bfd_reloc_overflow = 1,
    bfd_reloc_outofrange = 2,
    bfd_reloc_continue = 3,
    bfd_reloc_notsupported = 4,
    bfd_reloc_other = 5,
    bfd_reloc_undefined = 6,
    bfd_reloc_dangerous = 7
} ;
#line 2305 "../bfd/bfd.h"
typedef enum bfd_reloc_status bfd_reloc_status_type;
#line 2337 "../bfd/bfd.h"
struct reloc_cache_entry {
   struct bfd_symbol **sym_ptr_ptr ;
   bfd_size_type address ;
   bfd_vma addend ;
   reloc_howto_type *howto ;
};
#line 2337 "../bfd/bfd.h"
typedef struct reloc_cache_entry arelent;
#line 2354
enum complain_overflow {
    complain_overflow_dont = 0,
    complain_overflow_bitfield = 1,
    complain_overflow_signed = 2,
    complain_overflow_unsigned = 3
} ;
#line 2373 "../bfd/bfd.h"
struct reloc_howto_struct {
   unsigned int type ;
   unsigned int rightshift ;
   int size ;
   unsigned int bitsize ;
   bfd_boolean pc_relative ;
   unsigned int bitpos ;
   enum complain_overflow complain_on_overflow ;
   bfd_reloc_status_type (*special_function)(bfd * , arelent * , struct bfd_symbol * ,
                                             void * , asection * , bfd * , char ** ) ;
   char *name ;
   bfd_boolean partial_inplace ;
   bfd_vma src_mask ;
   bfd_vma dst_mask ;
   bfd_boolean pcrel_offset ;
};
#line 2485 "../bfd/bfd.h"
struct relent_chain {
   arelent relent ;
   struct relent_chain *next ;
};
#line 2514
enum bfd_reloc_code_real {
    _dummy_first_bfd_reloc_code_real = 0,
    BFD_RELOC_64 = 1,
    BFD_RELOC_32 = 2,
    BFD_RELOC_26 = 3,
    BFD_RELOC_24 = 4,
    BFD_RELOC_16 = 5,
    BFD_RELOC_14 = 6,
    BFD_RELOC_8 = 7,
    BFD_RELOC_64_PCREL = 8,
    BFD_RELOC_32_PCREL = 9,
    BFD_RELOC_24_PCREL = 10,
    BFD_RELOC_16_PCREL = 11,
    BFD_RELOC_12_PCREL = 12,
    BFD_RELOC_8_PCREL = 13,
    BFD_RELOC_32_SECREL = 14,
    BFD_RELOC_32_GOT_PCREL = 15,
    BFD_RELOC_16_GOT_PCREL = 16,
    BFD_RELOC_8_GOT_PCREL = 17,
    BFD_RELOC_32_GOTOFF = 18,
    BFD_RELOC_16_GOTOFF = 19,
    BFD_RELOC_LO16_GOTOFF = 20,
    BFD_RELOC_HI16_GOTOFF = 21,
    BFD_RELOC_HI16_S_GOTOFF = 22,
    BFD_RELOC_8_GOTOFF = 23,
    BFD_RELOC_64_PLT_PCREL = 24,
    BFD_RELOC_32_PLT_PCREL = 25,
    BFD_RELOC_24_PLT_PCREL = 26,
    BFD_RELOC_16_PLT_PCREL = 27,
    BFD_RELOC_8_PLT_PCREL = 28,
    BFD_RELOC_64_PLTOFF = 29,
    BFD_RELOC_32_PLTOFF = 30,
    BFD_RELOC_16_PLTOFF = 31,
    BFD_RELOC_LO16_PLTOFF = 32,
    BFD_RELOC_HI16_PLTOFF = 33,
    BFD_RELOC_HI16_S_PLTOFF = 34,
    BFD_RELOC_8_PLTOFF = 35,
    BFD_RELOC_SIZE32 = 36,
    BFD_RELOC_SIZE64 = 37,
    BFD_RELOC_68K_GLOB_DAT = 38,
    BFD_RELOC_68K_JMP_SLOT = 39,
    BFD_RELOC_68K_RELATIVE = 40,
    BFD_RELOC_68K_TLS_GD32 = 41,
    BFD_RELOC_68K_TLS_GD16 = 42,
    BFD_RELOC_68K_TLS_GD8 = 43,
    BFD_RELOC_68K_TLS_LDM32 = 44,
    BFD_RELOC_68K_TLS_LDM16 = 45,
    BFD_RELOC_68K_TLS_LDM8 = 46,
    BFD_RELOC_68K_TLS_LDO32 = 47,
    BFD_RELOC_68K_TLS_LDO16 = 48,
    BFD_RELOC_68K_TLS_LDO8 = 49,
    BFD_RELOC_68K_TLS_IE32 = 50,
    BFD_RELOC_68K_TLS_IE16 = 51,
    BFD_RELOC_68K_TLS_IE8 = 52,
    BFD_RELOC_68K_TLS_LE32 = 53,
    BFD_RELOC_68K_TLS_LE16 = 54,
    BFD_RELOC_68K_TLS_LE8 = 55,
    BFD_RELOC_32_BASEREL = 56,
    BFD_RELOC_16_BASEREL = 57,
    BFD_RELOC_LO16_BASEREL = 58,
    BFD_RELOC_HI16_BASEREL = 59,
    BFD_RELOC_HI16_S_BASEREL = 60,
    BFD_RELOC_8_BASEREL = 61,
    BFD_RELOC_RVA = 62,
    BFD_RELOC_8_FFnn = 63,
    BFD_RELOC_32_PCREL_S2 = 64,
    BFD_RELOC_16_PCREL_S2 = 65,
    BFD_RELOC_23_PCREL_S2 = 66,
    BFD_RELOC_HI22 = 67,
    BFD_RELOC_LO10 = 68,
    BFD_RELOC_GPREL16 = 69,
    BFD_RELOC_GPREL32 = 70,
    BFD_RELOC_I960_CALLJ = 71,
    BFD_RELOC_NONE = 72,
    BFD_RELOC_SPARC_WDISP22 = 73,
    BFD_RELOC_SPARC22 = 74,
    BFD_RELOC_SPARC13 = 75,
    BFD_RELOC_SPARC_GOT10 = 76,
    BFD_RELOC_SPARC_GOT13 = 77,
    BFD_RELOC_SPARC_GOT22 = 78,
    BFD_RELOC_SPARC_PC10 = 79,
    BFD_RELOC_SPARC_PC22 = 80,
    BFD_RELOC_SPARC_WPLT30 = 81,
    BFD_RELOC_SPARC_COPY = 82,
    BFD_RELOC_SPARC_GLOB_DAT = 83,
    BFD_RELOC_SPARC_JMP_SLOT = 84,
    BFD_RELOC_SPARC_RELATIVE = 85,
    BFD_RELOC_SPARC_UA16 = 86,
    BFD_RELOC_SPARC_UA32 = 87,
    BFD_RELOC_SPARC_UA64 = 88,
    BFD_RELOC_SPARC_GOTDATA_HIX22 = 89,
    BFD_RELOC_SPARC_GOTDATA_LOX10 = 90,
    BFD_RELOC_SPARC_GOTDATA_OP_HIX22 = 91,
    BFD_RELOC_SPARC_GOTDATA_OP_LOX10 = 92,
    BFD_RELOC_SPARC_GOTDATA_OP = 93,
    BFD_RELOC_SPARC_JMP_IREL = 94,
    BFD_RELOC_SPARC_IRELATIVE = 95,
    BFD_RELOC_SPARC_BASE13 = 96,
    BFD_RELOC_SPARC_BASE22 = 97,
    BFD_RELOC_SPARC_10 = 98,
    BFD_RELOC_SPARC_11 = 99,
    BFD_RELOC_SPARC_OLO10 = 100,
    BFD_RELOC_SPARC_HH22 = 101,
    BFD_RELOC_SPARC_HM10 = 102,
    BFD_RELOC_SPARC_LM22 = 103,
    BFD_RELOC_SPARC_PC_HH22 = 104,
    BFD_RELOC_SPARC_PC_HM10 = 105,
    BFD_RELOC_SPARC_PC_LM22 = 106,
    BFD_RELOC_SPARC_WDISP16 = 107,
    BFD_RELOC_SPARC_WDISP19 = 108,
    BFD_RELOC_SPARC_7 = 109,
    BFD_RELOC_SPARC_6 = 110,
    BFD_RELOC_SPARC_5 = 111,
    BFD_RELOC_SPARC_PLT32 = 112,
    BFD_RELOC_SPARC_PLT64 = 113,
    BFD_RELOC_SPARC_HIX22 = 114,
    BFD_RELOC_SPARC_LOX10 = 115,
    BFD_RELOC_SPARC_H44 = 116,
    BFD_RELOC_SPARC_M44 = 117,
    BFD_RELOC_SPARC_L44 = 118,
    BFD_RELOC_SPARC_REGISTER = 119,
    BFD_RELOC_SPARC_H34 = 120,
    BFD_RELOC_SPARC_SIZE32 = 121,
    BFD_RELOC_SPARC_SIZE64 = 122,
    BFD_RELOC_SPARC_WDISP10 = 123,
    BFD_RELOC_SPARC_REV32 = 124,
    BFD_RELOC_SPARC_TLS_GD_HI22 = 125,
    BFD_RELOC_SPARC_TLS_GD_LO10 = 126,
    BFD_RELOC_SPARC_TLS_GD_ADD = 127,
    BFD_RELOC_SPARC_TLS_GD_CALL = 128,
    BFD_RELOC_SPARC_TLS_LDM_HI22 = 129,
    BFD_RELOC_SPARC_TLS_LDM_LO10 = 130,
    BFD_RELOC_SPARC_TLS_LDM_ADD = 131,
    BFD_RELOC_SPARC_TLS_LDM_CALL = 132,
    BFD_RELOC_SPARC_TLS_LDO_HIX22 = 133,
    BFD_RELOC_SPARC_TLS_LDO_LOX10 = 134,
    BFD_RELOC_SPARC_TLS_LDO_ADD = 135,
    BFD_RELOC_SPARC_TLS_IE_HI22 = 136,
    BFD_RELOC_SPARC_TLS_IE_LO10 = 137,
    BFD_RELOC_SPARC_TLS_IE_LD = 138,
    BFD_RELOC_SPARC_TLS_IE_LDX = 139,
    BFD_RELOC_SPARC_TLS_IE_ADD = 140,
    BFD_RELOC_SPARC_TLS_LE_HIX22 = 141,
    BFD_RELOC_SPARC_TLS_LE_LOX10 = 142,
    BFD_RELOC_SPARC_TLS_DTPMOD32 = 143,
    BFD_RELOC_SPARC_TLS_DTPMOD64 = 144,
    BFD_RELOC_SPARC_TLS_DTPOFF32 = 145,
    BFD_RELOC_SPARC_TLS_DTPOFF64 = 146,
    BFD_RELOC_SPARC_TLS_TPOFF32 = 147,
    BFD_RELOC_SPARC_TLS_TPOFF64 = 148,
    BFD_RELOC_SPU_IMM7 = 149,
    BFD_RELOC_SPU_IMM8 = 150,
    BFD_RELOC_SPU_IMM10 = 151,
    BFD_RELOC_SPU_IMM10W = 152,
    BFD_RELOC_SPU_IMM16 = 153,
    BFD_RELOC_SPU_IMM16W = 154,
    BFD_RELOC_SPU_IMM18 = 155,
    BFD_RELOC_SPU_PCREL9a = 156,
    BFD_RELOC_SPU_PCREL9b = 157,
    BFD_RELOC_SPU_PCREL16 = 158,
    BFD_RELOC_SPU_LO16 = 159,
    BFD_RELOC_SPU_HI16 = 160,
    BFD_RELOC_SPU_PPU32 = 161,
    BFD_RELOC_SPU_PPU64 = 162,
    BFD_RELOC_SPU_ADD_PIC = 163,
    BFD_RELOC_ALPHA_GPDISP_HI16 = 164,
    BFD_RELOC_ALPHA_GPDISP_LO16 = 165,
    BFD_RELOC_ALPHA_GPDISP = 166,
    BFD_RELOC_ALPHA_LITERAL = 167,
    BFD_RELOC_ALPHA_ELF_LITERAL = 168,
    BFD_RELOC_ALPHA_LITUSE = 169,
    BFD_RELOC_ALPHA_HINT = 170,
    BFD_RELOC_ALPHA_LINKAGE = 171,
    BFD_RELOC_ALPHA_CODEADDR = 172,
    BFD_RELOC_ALPHA_GPREL_HI16 = 173,
    BFD_RELOC_ALPHA_GPREL_LO16 = 174,
    BFD_RELOC_ALPHA_BRSGP = 175,
    BFD_RELOC_ALPHA_NOP = 176,
    BFD_RELOC_ALPHA_BSR = 177,
    BFD_RELOC_ALPHA_LDA = 178,
    BFD_RELOC_ALPHA_BOH = 179,
    BFD_RELOC_ALPHA_TLSGD = 180,
    BFD_RELOC_ALPHA_TLSLDM = 181,
    BFD_RELOC_ALPHA_DTPMOD64 = 182,
    BFD_RELOC_ALPHA_GOTDTPREL16 = 183,
    BFD_RELOC_ALPHA_DTPREL64 = 184,
    BFD_RELOC_ALPHA_DTPREL_HI16 = 185,
    BFD_RELOC_ALPHA_DTPREL_LO16 = 186,
    BFD_RELOC_ALPHA_DTPREL16 = 187,
    BFD_RELOC_ALPHA_GOTTPREL16 = 188,
    BFD_RELOC_ALPHA_TPREL64 = 189,
    BFD_RELOC_ALPHA_TPREL_HI16 = 190,
    BFD_RELOC_ALPHA_TPREL_LO16 = 191,
    BFD_RELOC_ALPHA_TPREL16 = 192,
    BFD_RELOC_MIPS_JMP = 193,
    BFD_RELOC_MICROMIPS_JMP = 194,
    BFD_RELOC_MIPS16_JMP = 195,
    BFD_RELOC_MIPS16_GPREL = 196,
    BFD_RELOC_HI16 = 197,
    BFD_RELOC_HI16_S = 198,
    BFD_RELOC_LO16 = 199,
    BFD_RELOC_HI16_PCREL = 200,
    BFD_RELOC_HI16_S_PCREL = 201,
    BFD_RELOC_LO16_PCREL = 202,
    BFD_RELOC_MIPS16_GOT16 = 203,
    BFD_RELOC_MIPS16_CALL16 = 204,
    BFD_RELOC_MIPS16_HI16 = 205,
    BFD_RELOC_MIPS16_HI16_S = 206,
    BFD_RELOC_MIPS16_LO16 = 207,
    BFD_RELOC_MIPS16_TLS_GD = 208,
    BFD_RELOC_MIPS16_TLS_LDM = 209,
    BFD_RELOC_MIPS16_TLS_DTPREL_HI16 = 210,
    BFD_RELOC_MIPS16_TLS_DTPREL_LO16 = 211,
    BFD_RELOC_MIPS16_TLS_GOTTPREL = 212,
    BFD_RELOC_MIPS16_TLS_TPREL_HI16 = 213,
    BFD_RELOC_MIPS16_TLS_TPREL_LO16 = 214,
    BFD_RELOC_MIPS_LITERAL = 215,
    BFD_RELOC_MICROMIPS_LITERAL = 216,
    BFD_RELOC_MICROMIPS_7_PCREL_S1 = 217,
    BFD_RELOC_MICROMIPS_10_PCREL_S1 = 218,
    BFD_RELOC_MICROMIPS_16_PCREL_S1 = 219,
    BFD_RELOC_MICROMIPS_GPREL16 = 220,
    BFD_RELOC_MICROMIPS_HI16 = 221,
    BFD_RELOC_MICROMIPS_HI16_S = 222,
    BFD_RELOC_MICROMIPS_LO16 = 223,
    BFD_RELOC_MIPS_GOT16 = 224,
    BFD_RELOC_MICROMIPS_GOT16 = 225,
    BFD_RELOC_MIPS_CALL16 = 226,
    BFD_RELOC_MICROMIPS_CALL16 = 227,
    BFD_RELOC_MIPS_GOT_HI16 = 228,
    BFD_RELOC_MICROMIPS_GOT_HI16 = 229,
    BFD_RELOC_MIPS_GOT_LO16 = 230,
    BFD_RELOC_MICROMIPS_GOT_LO16 = 231,
    BFD_RELOC_MIPS_CALL_HI16 = 232,
    BFD_RELOC_MICROMIPS_CALL_HI16 = 233,
    BFD_RELOC_MIPS_CALL_LO16 = 234,
    BFD_RELOC_MICROMIPS_CALL_LO16 = 235,
    BFD_RELOC_MIPS_SUB = 236,
    BFD_RELOC_MICROMIPS_SUB = 237,
    BFD_RELOC_MIPS_GOT_PAGE = 238,
    BFD_RELOC_MICROMIPS_GOT_PAGE = 239,
    BFD_RELOC_MIPS_GOT_OFST = 240,
    BFD_RELOC_MICROMIPS_GOT_OFST = 241,
    BFD_RELOC_MIPS_GOT_DISP = 242,
    BFD_RELOC_MICROMIPS_GOT_DISP = 243,
    BFD_RELOC_MIPS_SHIFT5 = 244,
    BFD_RELOC_MIPS_SHIFT6 = 245,
    BFD_RELOC_MIPS_INSERT_A = 246,
    BFD_RELOC_MIPS_INSERT_B = 247,
    BFD_RELOC_MIPS_DELETE = 248,
    BFD_RELOC_MIPS_HIGHEST = 249,
    BFD_RELOC_MICROMIPS_HIGHEST = 250,
    BFD_RELOC_MIPS_HIGHER = 251,
    BFD_RELOC_MICROMIPS_HIGHER = 252,
    BFD_RELOC_MIPS_SCN_DISP = 253,
    BFD_RELOC_MICROMIPS_SCN_DISP = 254,
    BFD_RELOC_MIPS_REL16 = 255,
    BFD_RELOC_MIPS_RELGOT = 256,
    BFD_RELOC_MIPS_JALR = 257,
    BFD_RELOC_MICROMIPS_JALR = 258,
    BFD_RELOC_MIPS_TLS_DTPMOD32 = 259,
    BFD_RELOC_MIPS_TLS_DTPREL32 = 260,
    BFD_RELOC_MIPS_TLS_DTPMOD64 = 261,
    BFD_RELOC_MIPS_TLS_DTPREL64 = 262,
    BFD_RELOC_MIPS_TLS_GD = 263,
    BFD_RELOC_MICROMIPS_TLS_GD = 264,
    BFD_RELOC_MIPS_TLS_LDM = 265,
    BFD_RELOC_MICROMIPS_TLS_LDM = 266,
    BFD_RELOC_MIPS_TLS_DTPREL_HI16 = 267,
    BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16 = 268,
    BFD_RELOC_MIPS_TLS_DTPREL_LO16 = 269,
    BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16 = 270,
    BFD_RELOC_MIPS_TLS_GOTTPREL = 271,
    BFD_RELOC_MICROMIPS_TLS_GOTTPREL = 272,
    BFD_RELOC_MIPS_TLS_TPREL32 = 273,
    BFD_RELOC_MIPS_TLS_TPREL64 = 274,
    BFD_RELOC_MIPS_TLS_TPREL_HI16 = 275,
    BFD_RELOC_MICROMIPS_TLS_TPREL_HI16 = 276,
    BFD_RELOC_MIPS_TLS_TPREL_LO16 = 277,
    BFD_RELOC_MICROMIPS_TLS_TPREL_LO16 = 278,
    BFD_RELOC_MIPS_EH = 279,
    BFD_RELOC_MIPS_COPY = 280,
    BFD_RELOC_MIPS_JUMP_SLOT = 281,
    BFD_RELOC_MOXIE_10_PCREL = 282,
    BFD_RELOC_FRV_LABEL16 = 283,
    BFD_RELOC_FRV_LABEL24 = 284,
    BFD_RELOC_FRV_LO16 = 285,
    BFD_RELOC_FRV_HI16 = 286,
    BFD_RELOC_FRV_GPREL12 = 287,
    BFD_RELOC_FRV_GPRELU12 = 288,
    BFD_RELOC_FRV_GPREL32 = 289,
    BFD_RELOC_FRV_GPRELHI = 290,
    BFD_RELOC_FRV_GPRELLO = 291,
    BFD_RELOC_FRV_GOT12 = 292,
    BFD_RELOC_FRV_GOTHI = 293,
    BFD_RELOC_FRV_GOTLO = 294,
    BFD_RELOC_FRV_FUNCDESC = 295,
    BFD_RELOC_FRV_FUNCDESC_GOT12 = 296,
    BFD_RELOC_FRV_FUNCDESC_GOTHI = 297,
    BFD_RELOC_FRV_FUNCDESC_GOTLO = 298,
    BFD_RELOC_FRV_FUNCDESC_VALUE = 299,
    BFD_RELOC_FRV_FUNCDESC_GOTOFF12 = 300,
    BFD_RELOC_FRV_FUNCDESC_GOTOFFHI = 301,
    BFD_RELOC_FRV_FUNCDESC_GOTOFFLO = 302,
    BFD_RELOC_FRV_GOTOFF12 = 303,
    BFD_RELOC_FRV_GOTOFFHI = 304,
    BFD_RELOC_FRV_GOTOFFLO = 305,
    BFD_RELOC_FRV_GETTLSOFF = 306,
    BFD_RELOC_FRV_TLSDESC_VALUE = 307,
    BFD_RELOC_FRV_GOTTLSDESC12 = 308,
    BFD_RELOC_FRV_GOTTLSDESCHI = 309,
    BFD_RELOC_FRV_GOTTLSDESCLO = 310,
    BFD_RELOC_FRV_TLSMOFF12 = 311,
    BFD_RELOC_FRV_TLSMOFFHI = 312,
    BFD_RELOC_FRV_TLSMOFFLO = 313,
    BFD_RELOC_FRV_GOTTLSOFF12 = 314,
    BFD_RELOC_FRV_GOTTLSOFFHI = 315,
    BFD_RELOC_FRV_GOTTLSOFFLO = 316,
    BFD_RELOC_FRV_TLSOFF = 317,
    BFD_RELOC_FRV_TLSDESC_RELAX = 318,
    BFD_RELOC_FRV_GETTLSOFF_RELAX = 319,
    BFD_RELOC_FRV_TLSOFF_RELAX = 320,
    BFD_RELOC_FRV_TLSMOFF = 321,
    BFD_RELOC_MN10300_GOTOFF24 = 322,
    BFD_RELOC_MN10300_GOT32 = 323,
    BFD_RELOC_MN10300_GOT24 = 324,
    BFD_RELOC_MN10300_GOT16 = 325,
    BFD_RELOC_MN10300_COPY = 326,
    BFD_RELOC_MN10300_GLOB_DAT = 327,
    BFD_RELOC_MN10300_JMP_SLOT = 328,
    BFD_RELOC_MN10300_RELATIVE = 329,
    BFD_RELOC_MN10300_SYM_DIFF = 330,
    BFD_RELOC_MN10300_ALIGN = 331,
    BFD_RELOC_MN10300_TLS_GD = 332,
    BFD_RELOC_MN10300_TLS_LD = 333,
    BFD_RELOC_MN10300_TLS_LDO = 334,
    BFD_RELOC_MN10300_TLS_GOTIE = 335,
    BFD_RELOC_MN10300_TLS_IE = 336,
    BFD_RELOC_MN10300_TLS_LE = 337,
    BFD_RELOC_MN10300_TLS_DTPMOD = 338,
    BFD_RELOC_MN10300_TLS_DTPOFF = 339,
    BFD_RELOC_MN10300_TLS_TPOFF = 340,
    BFD_RELOC_MN10300_32_PCREL = 341,
    BFD_RELOC_MN10300_16_PCREL = 342,
    BFD_RELOC_386_GOT32 = 343,
    BFD_RELOC_386_PLT32 = 344,
    BFD_RELOC_386_COPY = 345,
    BFD_RELOC_386_GLOB_DAT = 346,
    BFD_RELOC_386_JUMP_SLOT = 347,
    BFD_RELOC_386_RELATIVE = 348,
    BFD_RELOC_386_GOTOFF = 349,
    BFD_RELOC_386_GOTPC = 350,
    BFD_RELOC_386_TLS_TPOFF = 351,
    BFD_RELOC_386_TLS_IE = 352,
    BFD_RELOC_386_TLS_GOTIE = 353,
    BFD_RELOC_386_TLS_LE = 354,
    BFD_RELOC_386_TLS_GD = 355,
    BFD_RELOC_386_TLS_LDM = 356,
    BFD_RELOC_386_TLS_LDO_32 = 357,
    BFD_RELOC_386_TLS_IE_32 = 358,
    BFD_RELOC_386_TLS_LE_32 = 359,
    BFD_RELOC_386_TLS_DTPMOD32 = 360,
    BFD_RELOC_386_TLS_DTPOFF32 = 361,
    BFD_RELOC_386_TLS_TPOFF32 = 362,
    BFD_RELOC_386_TLS_GOTDESC = 363,
    BFD_RELOC_386_TLS_DESC_CALL = 364,
    BFD_RELOC_386_TLS_DESC = 365,
    BFD_RELOC_386_IRELATIVE = 366,
    BFD_RELOC_X86_64_GOT32 = 367,
    BFD_RELOC_X86_64_PLT32 = 368,
    BFD_RELOC_X86_64_COPY = 369,
    BFD_RELOC_X86_64_GLOB_DAT = 370,
    BFD_RELOC_X86_64_JUMP_SLOT = 371,
    BFD_RELOC_X86_64_RELATIVE = 372,
    BFD_RELOC_X86_64_GOTPCREL = 373,
    BFD_RELOC_X86_64_32S = 374,
    BFD_RELOC_X86_64_DTPMOD64 = 375,
    BFD_RELOC_X86_64_DTPOFF64 = 376,
    BFD_RELOC_X86_64_TPOFF64 = 377,
    BFD_RELOC_X86_64_TLSGD = 378,
    BFD_RELOC_X86_64_TLSLD = 379,
    BFD_RELOC_X86_64_DTPOFF32 = 380,
    BFD_RELOC_X86_64_GOTTPOFF = 381,
    BFD_RELOC_X86_64_TPOFF32 = 382,
    BFD_RELOC_X86_64_GOTOFF64 = 383,
    BFD_RELOC_X86_64_GOTPC32 = 384,
    BFD_RELOC_X86_64_GOT64 = 385,
    BFD_RELOC_X86_64_GOTPCREL64 = 386,
    BFD_RELOC_X86_64_GOTPC64 = 387,
    BFD_RELOC_X86_64_GOTPLT64 = 388,
    BFD_RELOC_X86_64_PLTOFF64 = 389,
    BFD_RELOC_X86_64_GOTPC32_TLSDESC = 390,
    BFD_RELOC_X86_64_TLSDESC_CALL = 391,
    BFD_RELOC_X86_64_TLSDESC = 392,
    BFD_RELOC_X86_64_IRELATIVE = 393,
    BFD_RELOC_X86_64_PC32_BND = 394,
    BFD_RELOC_X86_64_PLT32_BND = 395,
    BFD_RELOC_NS32K_IMM_8 = 396,
    BFD_RELOC_NS32K_IMM_16 = 397,
    BFD_RELOC_NS32K_IMM_32 = 398,
    BFD_RELOC_NS32K_IMM_8_PCREL = 399,
    BFD_RELOC_NS32K_IMM_16_PCREL = 400,
    BFD_RELOC_NS32K_IMM_32_PCREL = 401,
    BFD_RELOC_NS32K_DISP_8 = 402,
    BFD_RELOC_NS32K_DISP_16 = 403,
    BFD_RELOC_NS32K_DISP_32 = 404,
    BFD_RELOC_NS32K_DISP_8_PCREL = 405,
    BFD_RELOC_NS32K_DISP_16_PCREL = 406,
    BFD_RELOC_NS32K_DISP_32_PCREL = 407,
    BFD_RELOC_PDP11_DISP_8_PCREL = 408,
    BFD_RELOC_PDP11_DISP_6_PCREL = 409,
    BFD_RELOC_PJ_CODE_HI16 = 410,
    BFD_RELOC_PJ_CODE_LO16 = 411,
    BFD_RELOC_PJ_CODE_DIR16 = 412,
    BFD_RELOC_PJ_CODE_DIR32 = 413,
    BFD_RELOC_PJ_CODE_REL16 = 414,
    BFD_RELOC_PJ_CODE_REL32 = 415,
    BFD_RELOC_PPC_B26 = 416,
    BFD_RELOC_PPC_BA26 = 417,
    BFD_RELOC_PPC_TOC16 = 418,
    BFD_RELOC_PPC_B16 = 419,
    BFD_RELOC_PPC_B16_BRTAKEN = 420,
    BFD_RELOC_PPC_B16_BRNTAKEN = 421,
    BFD_RELOC_PPC_BA16 = 422,
    BFD_RELOC_PPC_BA16_BRTAKEN = 423,
    BFD_RELOC_PPC_BA16_BRNTAKEN = 424,
    BFD_RELOC_PPC_COPY = 425,
    BFD_RELOC_PPC_GLOB_DAT = 426,
    BFD_RELOC_PPC_JMP_SLOT = 427,
    BFD_RELOC_PPC_RELATIVE = 428,
    BFD_RELOC_PPC_LOCAL24PC = 429,
    BFD_RELOC_PPC_EMB_NADDR32 = 430,
    BFD_RELOC_PPC_EMB_NADDR16 = 431,
    BFD_RELOC_PPC_EMB_NADDR16_LO = 432,
    BFD_RELOC_PPC_EMB_NADDR16_HI = 433,
    BFD_RELOC_PPC_EMB_NADDR16_HA = 434,
    BFD_RELOC_PPC_EMB_SDAI16 = 435,
    BFD_RELOC_PPC_EMB_SDA2I16 = 436,
    BFD_RELOC_PPC_EMB_SDA2REL = 437,
    BFD_RELOC_PPC_EMB_SDA21 = 438,
    BFD_RELOC_PPC_EMB_MRKREF = 439,
    BFD_RELOC_PPC_EMB_RELSEC16 = 440,
    BFD_RELOC_PPC_EMB_RELST_LO = 441,
    BFD_RELOC_PPC_EMB_RELST_HI = 442,
    BFD_RELOC_PPC_EMB_RELST_HA = 443,
    BFD_RELOC_PPC_EMB_BIT_FLD = 444,
    BFD_RELOC_PPC_EMB_RELSDA = 445,
    BFD_RELOC_PPC_VLE_REL8 = 446,
    BFD_RELOC_PPC_VLE_REL15 = 447,
    BFD_RELOC_PPC_VLE_REL24 = 448,
    BFD_RELOC_PPC_VLE_LO16A = 449,
    BFD_RELOC_PPC_VLE_LO16D = 450,
    BFD_RELOC_PPC_VLE_HI16A = 451,
    BFD_RELOC_PPC_VLE_HI16D = 452,
    BFD_RELOC_PPC_VLE_HA16A = 453,
    BFD_RELOC_PPC_VLE_HA16D = 454,
    BFD_RELOC_PPC_VLE_SDA21 = 455,
    BFD_RELOC_PPC_VLE_SDA21_LO = 456,
    BFD_RELOC_PPC_VLE_SDAREL_LO16A = 457,
    BFD_RELOC_PPC_VLE_SDAREL_LO16D = 458,
    BFD_RELOC_PPC_VLE_SDAREL_HI16A = 459,
    BFD_RELOC_PPC_VLE_SDAREL_HI16D = 460,
    BFD_RELOC_PPC_VLE_SDAREL_HA16A = 461,
    BFD_RELOC_PPC_VLE_SDAREL_HA16D = 462,
    BFD_RELOC_PPC64_HIGHER = 463,
    BFD_RELOC_PPC64_HIGHER_S = 464,
    BFD_RELOC_PPC64_HIGHEST = 465,
    BFD_RELOC_PPC64_HIGHEST_S = 466,
    BFD_RELOC_PPC64_TOC16_LO = 467,
    BFD_RELOC_PPC64_TOC16_HI = 468,
    BFD_RELOC_PPC64_TOC16_HA = 469,
    BFD_RELOC_PPC64_TOC = 470,
    BFD_RELOC_PPC64_PLTGOT16 = 471,
    BFD_RELOC_PPC64_PLTGOT16_LO = 472,
    BFD_RELOC_PPC64_PLTGOT16_HI = 473,
    BFD_RELOC_PPC64_PLTGOT16_HA = 474,
    BFD_RELOC_PPC64_ADDR16_DS = 475,
    BFD_RELOC_PPC64_ADDR16_LO_DS = 476,
    BFD_RELOC_PPC64_GOT16_DS = 477,
    BFD_RELOC_PPC64_GOT16_LO_DS = 478,
    BFD_RELOC_PPC64_PLT16_LO_DS = 479,
    BFD_RELOC_PPC64_SECTOFF_DS = 480,
    BFD_RELOC_PPC64_SECTOFF_LO_DS = 481,
    BFD_RELOC_PPC64_TOC16_DS = 482,
    BFD_RELOC_PPC64_TOC16_LO_DS = 483,
    BFD_RELOC_PPC64_PLTGOT16_DS = 484,
    BFD_RELOC_PPC64_PLTGOT16_LO_DS = 485,
    BFD_RELOC_PPC64_ADDR16_HIGH = 486,
    BFD_RELOC_PPC64_ADDR16_HIGHA = 487,
    BFD_RELOC_PPC_TLS = 488,
    BFD_RELOC_PPC_TLSGD = 489,
    BFD_RELOC_PPC_TLSLD = 490,
    BFD_RELOC_PPC_DTPMOD = 491,
    BFD_RELOC_PPC_TPREL16 = 492,
    BFD_RELOC_PPC_TPREL16_LO = 493,
    BFD_RELOC_PPC_TPREL16_HI = 494,
    BFD_RELOC_PPC_TPREL16_HA = 495,
    BFD_RELOC_PPC_TPREL = 496,
    BFD_RELOC_PPC_DTPREL16 = 497,
    BFD_RELOC_PPC_DTPREL16_LO = 498,
    BFD_RELOC_PPC_DTPREL16_HI = 499,
    BFD_RELOC_PPC_DTPREL16_HA = 500,
    BFD_RELOC_PPC_DTPREL = 501,
    BFD_RELOC_PPC_GOT_TLSGD16 = 502,
    BFD_RELOC_PPC_GOT_TLSGD16_LO = 503,
    BFD_RELOC_PPC_GOT_TLSGD16_HI = 504,
    BFD_RELOC_PPC_GOT_TLSGD16_HA = 505,
    BFD_RELOC_PPC_GOT_TLSLD16 = 506,
    BFD_RELOC_PPC_GOT_TLSLD16_LO = 507,
    BFD_RELOC_PPC_GOT_TLSLD16_HI = 508,
    BFD_RELOC_PPC_GOT_TLSLD16_HA = 509,
    BFD_RELOC_PPC_GOT_TPREL16 = 510,
    BFD_RELOC_PPC_GOT_TPREL16_LO = 511,
    BFD_RELOC_PPC_GOT_TPREL16_HI = 512,
    BFD_RELOC_PPC_GOT_TPREL16_HA = 513,
    BFD_RELOC_PPC_GOT_DTPREL16 = 514,
    BFD_RELOC_PPC_GOT_DTPREL16_LO = 515,
    BFD_RELOC_PPC_GOT_DTPREL16_HI = 516,
    BFD_RELOC_PPC_GOT_DTPREL16_HA = 517,
    BFD_RELOC_PPC64_TPREL16_DS = 518,
    BFD_RELOC_PPC64_TPREL16_LO_DS = 519,
    BFD_RELOC_PPC64_TPREL16_HIGHER = 520,
    BFD_RELOC_PPC64_TPREL16_HIGHERA = 521,
    BFD_RELOC_PPC64_TPREL16_HIGHEST = 522,
    BFD_RELOC_PPC64_TPREL16_HIGHESTA = 523,
    BFD_RELOC_PPC64_DTPREL16_DS = 524,
    BFD_RELOC_PPC64_DTPREL16_LO_DS = 525,
    BFD_RELOC_PPC64_DTPREL16_HIGHER = 526,
    BFD_RELOC_PPC64_DTPREL16_HIGHERA = 527,
    BFD_RELOC_PPC64_DTPREL16_HIGHEST = 528,
    BFD_RELOC_PPC64_DTPREL16_HIGHESTA = 529,
    BFD_RELOC_PPC64_TPREL16_HIGH = 530,
    BFD_RELOC_PPC64_TPREL16_HIGHA = 531,
    BFD_RELOC_PPC64_DTPREL16_HIGH = 532,
    BFD_RELOC_PPC64_DTPREL16_HIGHA = 533,
    BFD_RELOC_I370_D12 = 534,
    BFD_RELOC_CTOR = 535,
    BFD_RELOC_ARM_PCREL_BRANCH = 536,
    BFD_RELOC_ARM_PCREL_BLX = 537,
    BFD_RELOC_THUMB_PCREL_BLX = 538,
    BFD_RELOC_ARM_PCREL_CALL = 539,
    BFD_RELOC_ARM_PCREL_JUMP = 540,
    BFD_RELOC_THUMB_PCREL_BRANCH7 = 541,
    BFD_RELOC_THUMB_PCREL_BRANCH9 = 542,
    BFD_RELOC_THUMB_PCREL_BRANCH12 = 543,
    BFD_RELOC_THUMB_PCREL_BRANCH20 = 544,
    BFD_RELOC_THUMB_PCREL_BRANCH23 = 545,
    BFD_RELOC_THUMB_PCREL_BRANCH25 = 546,
    BFD_RELOC_ARM_OFFSET_IMM = 547,
    BFD_RELOC_ARM_THUMB_OFFSET = 548,
    BFD_RELOC_ARM_TARGET1 = 549,
    BFD_RELOC_ARM_ROSEGREL32 = 550,
    BFD_RELOC_ARM_SBREL32 = 551,
    BFD_RELOC_ARM_TARGET2 = 552,
    BFD_RELOC_ARM_PREL31 = 553,
    BFD_RELOC_ARM_MOVW = 554,
    BFD_RELOC_ARM_MOVT = 555,
    BFD_RELOC_ARM_MOVW_PCREL = 556,
    BFD_RELOC_ARM_MOVT_PCREL = 557,
    BFD_RELOC_ARM_THUMB_MOVW = 558,
    BFD_RELOC_ARM_THUMB_MOVT = 559,
    BFD_RELOC_ARM_THUMB_MOVW_PCREL = 560,
    BFD_RELOC_ARM_THUMB_MOVT_PCREL = 561,
    BFD_RELOC_ARM_JUMP_SLOT = 562,
    BFD_RELOC_ARM_GLOB_DAT = 563,
    BFD_RELOC_ARM_GOT32 = 564,
    BFD_RELOC_ARM_PLT32 = 565,
    BFD_RELOC_ARM_RELATIVE = 566,
    BFD_RELOC_ARM_GOTOFF = 567,
    BFD_RELOC_ARM_GOTPC = 568,
    BFD_RELOC_ARM_GOT_PREL = 569,
    BFD_RELOC_ARM_TLS_GD32 = 570,
    BFD_RELOC_ARM_TLS_LDO32 = 571,
    BFD_RELOC_ARM_TLS_LDM32 = 572,
    BFD_RELOC_ARM_TLS_DTPOFF32 = 573,
    BFD_RELOC_ARM_TLS_DTPMOD32 = 574,
    BFD_RELOC_ARM_TLS_TPOFF32 = 575,
    BFD_RELOC_ARM_TLS_IE32 = 576,
    BFD_RELOC_ARM_TLS_LE32 = 577,
    BFD_RELOC_ARM_TLS_GOTDESC = 578,
    BFD_RELOC_ARM_TLS_CALL = 579,
    BFD_RELOC_ARM_THM_TLS_CALL = 580,
    BFD_RELOC_ARM_TLS_DESCSEQ = 581,
    BFD_RELOC_ARM_THM_TLS_DESCSEQ = 582,
    BFD_RELOC_ARM_TLS_DESC = 583,
    BFD_RELOC_ARM_ALU_PC_G0_NC = 584,
    BFD_RELOC_ARM_ALU_PC_G0 = 585,
    BFD_RELOC_ARM_ALU_PC_G1_NC = 586,
    BFD_RELOC_ARM_ALU_PC_G1 = 587,
    BFD_RELOC_ARM_ALU_PC_G2 = 588,
    BFD_RELOC_ARM_LDR_PC_G0 = 589,
    BFD_RELOC_ARM_LDR_PC_G1 = 590,
    BFD_RELOC_ARM_LDR_PC_G2 = 591,
    BFD_RELOC_ARM_LDRS_PC_G0 = 592,
    BFD_RELOC_ARM_LDRS_PC_G1 = 593,
    BFD_RELOC_ARM_LDRS_PC_G2 = 594,
    BFD_RELOC_ARM_LDC_PC_G0 = 595,
    BFD_RELOC_ARM_LDC_PC_G1 = 596,
    BFD_RELOC_ARM_LDC_PC_G2 = 597,
    BFD_RELOC_ARM_ALU_SB_G0_NC = 598,
    BFD_RELOC_ARM_ALU_SB_G0 = 599,
    BFD_RELOC_ARM_ALU_SB_G1_NC = 600,
    BFD_RELOC_ARM_ALU_SB_G1 = 601,
    BFD_RELOC_ARM_ALU_SB_G2 = 602,
    BFD_RELOC_ARM_LDR_SB_G0 = 603,
    BFD_RELOC_ARM_LDR_SB_G1 = 604,
    BFD_RELOC_ARM_LDR_SB_G2 = 605,
    BFD_RELOC_ARM_LDRS_SB_G0 = 606,
    BFD_RELOC_ARM_LDRS_SB_G1 = 607,
    BFD_RELOC_ARM_LDRS_SB_G2 = 608,
    BFD_RELOC_ARM_LDC_SB_G0 = 609,
    BFD_RELOC_ARM_LDC_SB_G1 = 610,
    BFD_RELOC_ARM_LDC_SB_G2 = 611,
    BFD_RELOC_ARM_V4BX = 612,
    BFD_RELOC_ARM_IRELATIVE = 613,
    BFD_RELOC_ARM_IMMEDIATE = 614,
    BFD_RELOC_ARM_ADRL_IMMEDIATE = 615,
    BFD_RELOC_ARM_T32_IMMEDIATE = 616,
    BFD_RELOC_ARM_T32_ADD_IMM = 617,
    BFD_RELOC_ARM_T32_IMM12 = 618,
    BFD_RELOC_ARM_T32_ADD_PC12 = 619,
    BFD_RELOC_ARM_SHIFT_IMM = 620,
    BFD_RELOC_ARM_SMC = 621,
    BFD_RELOC_ARM_HVC = 622,
    BFD_RELOC_ARM_SWI = 623,
    BFD_RELOC_ARM_MULTI = 624,
    BFD_RELOC_ARM_CP_OFF_IMM = 625,
    BFD_RELOC_ARM_CP_OFF_IMM_S2 = 626,
    BFD_RELOC_ARM_T32_CP_OFF_IMM = 627,
    BFD_RELOC_ARM_T32_CP_OFF_IMM_S2 = 628,
    BFD_RELOC_ARM_ADR_IMM = 629,
    BFD_RELOC_ARM_LDR_IMM = 630,
    BFD_RELOC_ARM_LITERAL = 631,
    BFD_RELOC_ARM_IN_POOL = 632,
    BFD_RELOC_ARM_OFFSET_IMM8 = 633,
    BFD_RELOC_ARM_T32_OFFSET_U8 = 634,
    BFD_RELOC_ARM_T32_OFFSET_IMM = 635,
    BFD_RELOC_ARM_HWLITERAL = 636,
    BFD_RELOC_ARM_THUMB_ADD = 637,
    BFD_RELOC_ARM_THUMB_IMM = 638,
    BFD_RELOC_ARM_THUMB_SHIFT = 639,
    BFD_RELOC_SH_PCDISP8BY2 = 640,
    BFD_RELOC_SH_PCDISP12BY2 = 641,
    BFD_RELOC_SH_IMM3 = 642,
    BFD_RELOC_SH_IMM3U = 643,
    BFD_RELOC_SH_DISP12 = 644,
    BFD_RELOC_SH_DISP12BY2 = 645,
    BFD_RELOC_SH_DISP12BY4 = 646,
    BFD_RELOC_SH_DISP12BY8 = 647,
    BFD_RELOC_SH_DISP20 = 648,
    BFD_RELOC_SH_DISP20BY8 = 649,
    BFD_RELOC_SH_IMM4 = 650,
    BFD_RELOC_SH_IMM4BY2 = 651,
    BFD_RELOC_SH_IMM4BY4 = 652,
    BFD_RELOC_SH_IMM8 = 653,
    BFD_RELOC_SH_IMM8BY2 = 654,
    BFD_RELOC_SH_IMM8BY4 = 655,
    BFD_RELOC_SH_PCRELIMM8BY2 = 656,
    BFD_RELOC_SH_PCRELIMM8BY4 = 657,
    BFD_RELOC_SH_SWITCH16 = 658,
    BFD_RELOC_SH_SWITCH32 = 659,
    BFD_RELOC_SH_USES = 660,
    BFD_RELOC_SH_COUNT = 661,
    BFD_RELOC_SH_ALIGN = 662,
    BFD_RELOC_SH_CODE = 663,
    BFD_RELOC_SH_DATA = 664,
    BFD_RELOC_SH_LABEL = 665,
    BFD_RELOC_SH_LOOP_START = 666,
    BFD_RELOC_SH_LOOP_END = 667,
    BFD_RELOC_SH_COPY = 668,
    BFD_RELOC_SH_GLOB_DAT = 669,
    BFD_RELOC_SH_JMP_SLOT = 670,
    BFD_RELOC_SH_RELATIVE = 671,
    BFD_RELOC_SH_GOTPC = 672,
    BFD_RELOC_SH_GOT_LOW16 = 673,
    BFD_RELOC_SH_GOT_MEDLOW16 = 674,
    BFD_RELOC_SH_GOT_MEDHI16 = 675,
    BFD_RELOC_SH_GOT_HI16 = 676,
    BFD_RELOC_SH_GOTPLT_LOW16 = 677,
    BFD_RELOC_SH_GOTPLT_MEDLOW16 = 678,
    BFD_RELOC_SH_GOTPLT_MEDHI16 = 679,
    BFD_RELOC_SH_GOTPLT_HI16 = 680,
    BFD_RELOC_SH_PLT_LOW16 = 681,
    BFD_RELOC_SH_PLT_MEDLOW16 = 682,
    BFD_RELOC_SH_PLT_MEDHI16 = 683,
    BFD_RELOC_SH_PLT_HI16 = 684,
    BFD_RELOC_SH_GOTOFF_LOW16 = 685,
    BFD_RELOC_SH_GOTOFF_MEDLOW16 = 686,
    BFD_RELOC_SH_GOTOFF_MEDHI16 = 687,
    BFD_RELOC_SH_GOTOFF_HI16 = 688,
    BFD_RELOC_SH_GOTPC_LOW16 = 689,
    BFD_RELOC_SH_GOTPC_MEDLOW16 = 690,
    BFD_RELOC_SH_GOTPC_MEDHI16 = 691,
    BFD_RELOC_SH_GOTPC_HI16 = 692,
    BFD_RELOC_SH_COPY64 = 693,
    BFD_RELOC_SH_GLOB_DAT64 = 694,
    BFD_RELOC_SH_JMP_SLOT64 = 695,
    BFD_RELOC_SH_RELATIVE64 = 696,
    BFD_RELOC_SH_GOT10BY4 = 697,
    BFD_RELOC_SH_GOT10BY8 = 698,
    BFD_RELOC_SH_GOTPLT10BY4 = 699,
    BFD_RELOC_SH_GOTPLT10BY8 = 700,
    BFD_RELOC_SH_GOTPLT32 = 701,
    BFD_RELOC_SH_SHMEDIA_CODE = 702,
    BFD_RELOC_SH_IMMU5 = 703,
    BFD_RELOC_SH_IMMS6 = 704,
    BFD_RELOC_SH_IMMS6BY32 = 705,
    BFD_RELOC_SH_IMMU6 = 706,
    BFD_RELOC_SH_IMMS10 = 707,
    BFD_RELOC_SH_IMMS10BY2 = 708,
    BFD_RELOC_SH_IMMS10BY4 = 709,
    BFD_RELOC_SH_IMMS10BY8 = 710,
    BFD_RELOC_SH_IMMS16 = 711,
    BFD_RELOC_SH_IMMU16 = 712,
    BFD_RELOC_SH_IMM_LOW16 = 713,
    BFD_RELOC_SH_IMM_LOW16_PCREL = 714,
    BFD_RELOC_SH_IMM_MEDLOW16 = 715,
    BFD_RELOC_SH_IMM_MEDLOW16_PCREL = 716,
    BFD_RELOC_SH_IMM_MEDHI16 = 717,
    BFD_RELOC_SH_IMM_MEDHI16_PCREL = 718,
    BFD_RELOC_SH_IMM_HI16 = 719,
    BFD_RELOC_SH_IMM_HI16_PCREL = 720,
    BFD_RELOC_SH_PT_16 = 721,
    BFD_RELOC_SH_TLS_GD_32 = 722,
    BFD_RELOC_SH_TLS_LD_32 = 723,
    BFD_RELOC_SH_TLS_LDO_32 = 724,
    BFD_RELOC_SH_TLS_IE_32 = 725,
    BFD_RELOC_SH_TLS_LE_32 = 726,
    BFD_RELOC_SH_TLS_DTPMOD32 = 727,
    BFD_RELOC_SH_TLS_DTPOFF32 = 728,
    BFD_RELOC_SH_TLS_TPOFF32 = 729,
    BFD_RELOC_SH_GOT20 = 730,
    BFD_RELOC_SH_GOTOFF20 = 731,
    BFD_RELOC_SH_GOTFUNCDESC = 732,
    BFD_RELOC_SH_GOTFUNCDESC20 = 733,
    BFD_RELOC_SH_GOTOFFFUNCDESC = 734,
    BFD_RELOC_SH_GOTOFFFUNCDESC20 = 735,
    BFD_RELOC_SH_FUNCDESC = 736,
    BFD_RELOC_ARC_B22_PCREL = 737,
    BFD_RELOC_ARC_B26 = 738,
    BFD_RELOC_BFIN_16_IMM = 739,
    BFD_RELOC_BFIN_16_HIGH = 740,
    BFD_RELOC_BFIN_4_PCREL = 741,
    BFD_RELOC_BFIN_5_PCREL = 742,
    BFD_RELOC_BFIN_16_LOW = 743,
    BFD_RELOC_BFIN_10_PCREL = 744,
    BFD_RELOC_BFIN_11_PCREL = 745,
    BFD_RELOC_BFIN_12_PCREL_JUMP = 746,
    BFD_RELOC_BFIN_12_PCREL_JUMP_S = 747,
    BFD_RELOC_BFIN_24_PCREL_CALL_X = 748,
    BFD_RELOC_BFIN_24_PCREL_JUMP_L = 749,
    BFD_RELOC_BFIN_GOT17M4 = 750,
    BFD_RELOC_BFIN_GOTHI = 751,
    BFD_RELOC_BFIN_GOTLO = 752,
    BFD_RELOC_BFIN_FUNCDESC = 753,
    BFD_RELOC_BFIN_FUNCDESC_GOT17M4 = 754,
    BFD_RELOC_BFIN_FUNCDESC_GOTHI = 755,
    BFD_RELOC_BFIN_FUNCDESC_GOTLO = 756,
    BFD_RELOC_BFIN_FUNCDESC_VALUE = 757,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4 = 758,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI = 759,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO = 760,
    BFD_RELOC_BFIN_GOTOFF17M4 = 761,
    BFD_RELOC_BFIN_GOTOFFHI = 762,
    BFD_RELOC_BFIN_GOTOFFLO = 763,
    BFD_RELOC_BFIN_GOT = 764,
    BFD_RELOC_BFIN_PLTPC = 765,
    BFD_ARELOC_BFIN_PUSH = 766,
    BFD_ARELOC_BFIN_CONST = 767,
    BFD_ARELOC_BFIN_ADD = 768,
    BFD_ARELOC_BFIN_SUB = 769,
    BFD_ARELOC_BFIN_MULT = 770,
    BFD_ARELOC_BFIN_DIV = 771,
    BFD_ARELOC_BFIN_MOD = 772,
    BFD_ARELOC_BFIN_LSHIFT = 773,
    BFD_ARELOC_BFIN_RSHIFT = 774,
    BFD_ARELOC_BFIN_AND = 775,
    BFD_ARELOC_BFIN_OR = 776,
    BFD_ARELOC_BFIN_XOR = 777,
    BFD_ARELOC_BFIN_LAND = 778,
    BFD_ARELOC_BFIN_LOR = 779,
    BFD_ARELOC_BFIN_LEN = 780,
    BFD_ARELOC_BFIN_NEG = 781,
    BFD_ARELOC_BFIN_COMP = 782,
    BFD_ARELOC_BFIN_PAGE = 783,
    BFD_ARELOC_BFIN_HWPAGE = 784,
    BFD_ARELOC_BFIN_ADDR = 785,
    BFD_RELOC_D10V_10_PCREL_R = 786,
    BFD_RELOC_D10V_10_PCREL_L = 787,
    BFD_RELOC_D10V_18 = 788,
    BFD_RELOC_D10V_18_PCREL = 789,
    BFD_RELOC_D30V_6 = 790,
    BFD_RELOC_D30V_9_PCREL = 791,
    BFD_RELOC_D30V_9_PCREL_R = 792,
    BFD_RELOC_D30V_15 = 793,
    BFD_RELOC_D30V_15_PCREL = 794,
    BFD_RELOC_D30V_15_PCREL_R = 795,
    BFD_RELOC_D30V_21 = 796,
    BFD_RELOC_D30V_21_PCREL = 797,
    BFD_RELOC_D30V_21_PCREL_R = 798,
    BFD_RELOC_D30V_32 = 799,
    BFD_RELOC_D30V_32_PCREL = 800,
    BFD_RELOC_DLX_HI16_S = 801,
    BFD_RELOC_DLX_LO16 = 802,
    BFD_RELOC_DLX_JMP26 = 803,
    BFD_RELOC_M32C_HI8 = 804,
    BFD_RELOC_M32C_RL_JUMP = 805,
    BFD_RELOC_M32C_RL_1ADDR = 806,
    BFD_RELOC_M32C_RL_2ADDR = 807,
    BFD_RELOC_M32R_24 = 808,
    BFD_RELOC_M32R_10_PCREL = 809,
    BFD_RELOC_M32R_18_PCREL = 810,
    BFD_RELOC_M32R_26_PCREL = 811,
    BFD_RELOC_M32R_HI16_ULO = 812,
    BFD_RELOC_M32R_HI16_SLO = 813,
    BFD_RELOC_M32R_LO16 = 814,
    BFD_RELOC_M32R_SDA16 = 815,
    BFD_RELOC_M32R_GOT24 = 816,
    BFD_RELOC_M32R_26_PLTREL = 817,
    BFD_RELOC_M32R_COPY = 818,
    BFD_RELOC_M32R_GLOB_DAT = 819,
    BFD_RELOC_M32R_JMP_SLOT = 820,
    BFD_RELOC_M32R_RELATIVE = 821,
    BFD_RELOC_M32R_GOTOFF = 822,
    BFD_RELOC_M32R_GOTOFF_HI_ULO = 823,
    BFD_RELOC_M32R_GOTOFF_HI_SLO = 824,
    BFD_RELOC_M32R_GOTOFF_LO = 825,
    BFD_RELOC_M32R_GOTPC24 = 826,
    BFD_RELOC_M32R_GOT16_HI_ULO = 827,
    BFD_RELOC_M32R_GOT16_HI_SLO = 828,
    BFD_RELOC_M32R_GOT16_LO = 829,
    BFD_RELOC_M32R_GOTPC_HI_ULO = 830,
    BFD_RELOC_M32R_GOTPC_HI_SLO = 831,
    BFD_RELOC_M32R_GOTPC_LO = 832,
    BFD_RELOC_V850_9_PCREL = 833,
    BFD_RELOC_V850_22_PCREL = 834,
    BFD_RELOC_V850_SDA_16_16_OFFSET = 835,
    BFD_RELOC_V850_SDA_15_16_OFFSET = 836,
    BFD_RELOC_V850_ZDA_16_16_OFFSET = 837,
    BFD_RELOC_V850_ZDA_15_16_OFFSET = 838,
    BFD_RELOC_V850_TDA_6_8_OFFSET = 839,
    BFD_RELOC_V850_TDA_7_8_OFFSET = 840,
    BFD_RELOC_V850_TDA_7_7_OFFSET = 841,
    BFD_RELOC_V850_TDA_16_16_OFFSET = 842,
    BFD_RELOC_V850_TDA_4_5_OFFSET = 843,
    BFD_RELOC_V850_TDA_4_4_OFFSET = 844,
    BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET = 845,
    BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET = 846,
    BFD_RELOC_V850_CALLT_6_7_OFFSET = 847,
    BFD_RELOC_V850_CALLT_16_16_OFFSET = 848,
    BFD_RELOC_V850_LONGCALL = 849,
    BFD_RELOC_V850_LONGJUMP = 850,
    BFD_RELOC_V850_ALIGN = 851,
    BFD_RELOC_V850_LO16_SPLIT_OFFSET = 852,
    BFD_RELOC_V850_16_PCREL = 853,
    BFD_RELOC_V850_17_PCREL = 854,
    BFD_RELOC_V850_23 = 855,
    BFD_RELOC_V850_32_PCREL = 856,
    BFD_RELOC_V850_32_ABS = 857,
    BFD_RELOC_V850_16_SPLIT_OFFSET = 858,
    BFD_RELOC_V850_16_S1 = 859,
    BFD_RELOC_V850_LO16_S1 = 860,
    BFD_RELOC_V850_CALLT_15_16_OFFSET = 861,
    BFD_RELOC_V850_32_GOTPCREL = 862,
    BFD_RELOC_V850_16_GOT = 863,
    BFD_RELOC_V850_32_GOT = 864,
    BFD_RELOC_V850_22_PLT_PCREL = 865,
    BFD_RELOC_V850_32_PLT_PCREL = 866,
    BFD_RELOC_V850_COPY = 867,
    BFD_RELOC_V850_GLOB_DAT = 868,
    BFD_RELOC_V850_JMP_SLOT = 869,
    BFD_RELOC_V850_RELATIVE = 870,
    BFD_RELOC_V850_16_GOTOFF = 871,
    BFD_RELOC_V850_32_GOTOFF = 872,
    BFD_RELOC_V850_CODE = 873,
    BFD_RELOC_V850_DATA = 874,
    BFD_RELOC_TIC30_LDP = 875,
    BFD_RELOC_TIC54X_PARTLS7 = 876,
    BFD_RELOC_TIC54X_PARTMS9 = 877,
    BFD_RELOC_TIC54X_23 = 878,
    BFD_RELOC_TIC54X_16_OF_23 = 879,
    BFD_RELOC_TIC54X_MS7_OF_23 = 880,
    BFD_RELOC_C6000_PCR_S21 = 881,
    BFD_RELOC_C6000_PCR_S12 = 882,
    BFD_RELOC_C6000_PCR_S10 = 883,
    BFD_RELOC_C6000_PCR_S7 = 884,
    BFD_RELOC_C6000_ABS_S16 = 885,
    BFD_RELOC_C6000_ABS_L16 = 886,
    BFD_RELOC_C6000_ABS_H16 = 887,
    BFD_RELOC_C6000_SBR_U15_B = 888,
    BFD_RELOC_C6000_SBR_U15_H = 889,
    BFD_RELOC_C6000_SBR_U15_W = 890,
    BFD_RELOC_C6000_SBR_S16 = 891,
    BFD_RELOC_C6000_SBR_L16_B = 892,
    BFD_RELOC_C6000_SBR_L16_H = 893,
    BFD_RELOC_C6000_SBR_L16_W = 894,
    BFD_RELOC_C6000_SBR_H16_B = 895,
    BFD_RELOC_C6000_SBR_H16_H = 896,
    BFD_RELOC_C6000_SBR_H16_W = 897,
    BFD_RELOC_C6000_SBR_GOT_U15_W = 898,
    BFD_RELOC_C6000_SBR_GOT_L16_W = 899,
    BFD_RELOC_C6000_SBR_GOT_H16_W = 900,
    BFD_RELOC_C6000_DSBT_INDEX = 901,
    BFD_RELOC_C6000_PREL31 = 902,
    BFD_RELOC_C6000_COPY = 903,
    BFD_RELOC_C6000_JUMP_SLOT = 904,
    BFD_RELOC_C6000_EHTYPE = 905,
    BFD_RELOC_C6000_PCR_H16 = 906,
    BFD_RELOC_C6000_PCR_L16 = 907,
    BFD_RELOC_C6000_ALIGN = 908,
    BFD_RELOC_C6000_FPHEAD = 909,
    BFD_RELOC_C6000_NOCMP = 910,
    BFD_RELOC_FR30_48 = 911,
    BFD_RELOC_FR30_20 = 912,
    BFD_RELOC_FR30_6_IN_4 = 913,
    BFD_RELOC_FR30_8_IN_8 = 914,
    BFD_RELOC_FR30_9_IN_8 = 915,
    BFD_RELOC_FR30_10_IN_8 = 916,
    BFD_RELOC_FR30_9_PCREL = 917,
    BFD_RELOC_FR30_12_PCREL = 918,
    BFD_RELOC_MCORE_PCREL_IMM8BY4 = 919,
    BFD_RELOC_MCORE_PCREL_IMM11BY2 = 920,
    BFD_RELOC_MCORE_PCREL_IMM4BY2 = 921,
    BFD_RELOC_MCORE_PCREL_32 = 922,
    BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2 = 923,
    BFD_RELOC_MCORE_RVA = 924,
    BFD_RELOC_MEP_8 = 925,
    BFD_RELOC_MEP_16 = 926,
    BFD_RELOC_MEP_32 = 927,
    BFD_RELOC_MEP_PCREL8A2 = 928,
    BFD_RELOC_MEP_PCREL12A2 = 929,
    BFD_RELOC_MEP_PCREL17A2 = 930,
    BFD_RELOC_MEP_PCREL24A2 = 931,
    BFD_RELOC_MEP_PCABS24A2 = 932,
    BFD_RELOC_MEP_LOW16 = 933,
    BFD_RELOC_MEP_HI16U = 934,
    BFD_RELOC_MEP_HI16S = 935,
    BFD_RELOC_MEP_GPREL = 936,
    BFD_RELOC_MEP_TPREL = 937,
    BFD_RELOC_MEP_TPREL7 = 938,
    BFD_RELOC_MEP_TPREL7A2 = 939,
    BFD_RELOC_MEP_TPREL7A4 = 940,
    BFD_RELOC_MEP_UIMM24 = 941,
    BFD_RELOC_MEP_ADDR24A4 = 942,
    BFD_RELOC_MEP_GNU_VTINHERIT = 943,
    BFD_RELOC_MEP_GNU_VTENTRY = 944,
    BFD_RELOC_METAG_HIADDR16 = 945,
    BFD_RELOC_METAG_LOADDR16 = 946,
    BFD_RELOC_METAG_RELBRANCH = 947,
    BFD_RELOC_METAG_GETSETOFF = 948,
    BFD_RELOC_METAG_HIOG = 949,
    BFD_RELOC_METAG_LOOG = 950,
    BFD_RELOC_METAG_REL8 = 951,
    BFD_RELOC_METAG_REL16 = 952,
    BFD_RELOC_METAG_HI16_GOTOFF = 953,
    BFD_RELOC_METAG_LO16_GOTOFF = 954,
    BFD_RELOC_METAG_GETSET_GOTOFF = 955,
    BFD_RELOC_METAG_GETSET_GOT = 956,
    BFD_RELOC_METAG_HI16_GOTPC = 957,
    BFD_RELOC_METAG_LO16_GOTPC = 958,
    BFD_RELOC_METAG_HI16_PLT = 959,
    BFD_RELOC_METAG_LO16_PLT = 960,
    BFD_RELOC_METAG_RELBRANCH_PLT = 961,
    BFD_RELOC_METAG_GOTOFF = 962,
    BFD_RELOC_METAG_PLT = 963,
    BFD_RELOC_METAG_COPY = 964,
    BFD_RELOC_METAG_JMP_SLOT = 965,
    BFD_RELOC_METAG_RELATIVE = 966,
    BFD_RELOC_METAG_GLOB_DAT = 967,
    BFD_RELOC_METAG_TLS_GD = 968,
    BFD_RELOC_METAG_TLS_LDM = 969,
    BFD_RELOC_METAG_TLS_LDO_HI16 = 970,
    BFD_RELOC_METAG_TLS_LDO_LO16 = 971,
    BFD_RELOC_METAG_TLS_LDO = 972,
    BFD_RELOC_METAG_TLS_IE = 973,
    BFD_RELOC_METAG_TLS_IENONPIC = 974,
    BFD_RELOC_METAG_TLS_IENONPIC_HI16 = 975,
    BFD_RELOC_METAG_TLS_IENONPIC_LO16 = 976,
    BFD_RELOC_METAG_TLS_TPOFF = 977,
    BFD_RELOC_METAG_TLS_DTPMOD = 978,
    BFD_RELOC_METAG_TLS_DTPOFF = 979,
    BFD_RELOC_METAG_TLS_LE = 980,
    BFD_RELOC_METAG_TLS_LE_HI16 = 981,
    BFD_RELOC_METAG_TLS_LE_LO16 = 982,
    BFD_RELOC_MMIX_GETA = 983,
    BFD_RELOC_MMIX_GETA_1 = 984,
    BFD_RELOC_MMIX_GETA_2 = 985,
    BFD_RELOC_MMIX_GETA_3 = 986,
    BFD_RELOC_MMIX_CBRANCH = 987,
    BFD_RELOC_MMIX_CBRANCH_J = 988,
    BFD_RELOC_MMIX_CBRANCH_1 = 989,
    BFD_RELOC_MMIX_CBRANCH_2 = 990,
    BFD_RELOC_MMIX_CBRANCH_3 = 991,
    BFD_RELOC_MMIX_PUSHJ = 992,
    BFD_RELOC_MMIX_PUSHJ_1 = 993,
    BFD_RELOC_MMIX_PUSHJ_2 = 994,
    BFD_RELOC_MMIX_PUSHJ_3 = 995,
    BFD_RELOC_MMIX_PUSHJ_STUBBABLE = 996,
    BFD_RELOC_MMIX_JMP = 997,
    BFD_RELOC_MMIX_JMP_1 = 998,
    BFD_RELOC_MMIX_JMP_2 = 999,
    BFD_RELOC_MMIX_JMP_3 = 1000,
    BFD_RELOC_MMIX_ADDR19 = 1001,
    BFD_RELOC_MMIX_ADDR27 = 1002,
    BFD_RELOC_MMIX_REG_OR_BYTE = 1003,
    BFD_RELOC_MMIX_REG = 1004,
    BFD_RELOC_MMIX_BASE_PLUS_OFFSET = 1005,
    BFD_RELOC_MMIX_LOCAL = 1006,
    BFD_RELOC_AVR_7_PCREL = 1007,
    BFD_RELOC_AVR_13_PCREL = 1008,
    BFD_RELOC_AVR_16_PM = 1009,
    BFD_RELOC_AVR_LO8_LDI = 1010,
    BFD_RELOC_AVR_HI8_LDI = 1011,
    BFD_RELOC_AVR_HH8_LDI = 1012,
    BFD_RELOC_AVR_MS8_LDI = 1013,
    BFD_RELOC_AVR_LO8_LDI_NEG = 1014,
    BFD_RELOC_AVR_HI8_LDI_NEG = 1015,
    BFD_RELOC_AVR_HH8_LDI_NEG = 1016,
    BFD_RELOC_AVR_MS8_LDI_NEG = 1017,
    BFD_RELOC_AVR_LO8_LDI_PM = 1018,
    BFD_RELOC_AVR_LO8_LDI_GS = 1019,
    BFD_RELOC_AVR_HI8_LDI_PM = 1020,
    BFD_RELOC_AVR_HI8_LDI_GS = 1021,
    BFD_RELOC_AVR_HH8_LDI_PM = 1022,
    BFD_RELOC_AVR_LO8_LDI_PM_NEG = 1023,
    BFD_RELOC_AVR_HI8_LDI_PM_NEG = 1024,
    BFD_RELOC_AVR_HH8_LDI_PM_NEG = 1025,
    BFD_RELOC_AVR_CALL = 1026,
    BFD_RELOC_AVR_LDI = 1027,
    BFD_RELOC_AVR_6 = 1028,
    BFD_RELOC_AVR_6_ADIW = 1029,
    BFD_RELOC_AVR_8_LO = 1030,
    BFD_RELOC_AVR_8_HI = 1031,
    BFD_RELOC_AVR_8_HLO = 1032,
    BFD_RELOC_RL78_NEG8 = 1033,
    BFD_RELOC_RL78_NEG16 = 1034,
    BFD_RELOC_RL78_NEG24 = 1035,
    BFD_RELOC_RL78_NEG32 = 1036,
    BFD_RELOC_RL78_16_OP = 1037,
    BFD_RELOC_RL78_24_OP = 1038,
    BFD_RELOC_RL78_32_OP = 1039,
    BFD_RELOC_RL78_8U = 1040,
    BFD_RELOC_RL78_16U = 1041,
    BFD_RELOC_RL78_24U = 1042,
    BFD_RELOC_RL78_DIR3U_PCREL = 1043,
    BFD_RELOC_RL78_DIFF = 1044,
    BFD_RELOC_RL78_GPRELB = 1045,
    BFD_RELOC_RL78_GPRELW = 1046,
    BFD_RELOC_RL78_GPRELL = 1047,
    BFD_RELOC_RL78_SYM = 1048,
    BFD_RELOC_RL78_OP_SUBTRACT = 1049,
    BFD_RELOC_RL78_OP_NEG = 1050,
    BFD_RELOC_RL78_OP_AND = 1051,
    BFD_RELOC_RL78_OP_SHRA = 1052,
    BFD_RELOC_RL78_ABS8 = 1053,
    BFD_RELOC_RL78_ABS16 = 1054,
    BFD_RELOC_RL78_ABS16_REV = 1055,
    BFD_RELOC_RL78_ABS32 = 1056,
    BFD_RELOC_RL78_ABS32_REV = 1057,
    BFD_RELOC_RL78_ABS16U = 1058,
    BFD_RELOC_RL78_ABS16UW = 1059,
    BFD_RELOC_RL78_ABS16UL = 1060,
    BFD_RELOC_RL78_RELAX = 1061,
    BFD_RELOC_RL78_HI16 = 1062,
    BFD_RELOC_RL78_HI8 = 1063,
    BFD_RELOC_RL78_LO16 = 1064,
    BFD_RELOC_RL78_CODE = 1065,
    BFD_RELOC_RX_NEG8 = 1066,
    BFD_RELOC_RX_NEG16 = 1067,
    BFD_RELOC_RX_NEG24 = 1068,
    BFD_RELOC_RX_NEG32 = 1069,
    BFD_RELOC_RX_16_OP = 1070,
    BFD_RELOC_RX_24_OP = 1071,
    BFD_RELOC_RX_32_OP = 1072,
    BFD_RELOC_RX_8U = 1073,
    BFD_RELOC_RX_16U = 1074,
    BFD_RELOC_RX_24U = 1075,
    BFD_RELOC_RX_DIR3U_PCREL = 1076,
    BFD_RELOC_RX_DIFF = 1077,
    BFD_RELOC_RX_GPRELB = 1078,
    BFD_RELOC_RX_GPRELW = 1079,
    BFD_RELOC_RX_GPRELL = 1080,
    BFD_RELOC_RX_SYM = 1081,
    BFD_RELOC_RX_OP_SUBTRACT = 1082,
    BFD_RELOC_RX_OP_NEG = 1083,
    BFD_RELOC_RX_ABS8 = 1084,
    BFD_RELOC_RX_ABS16 = 1085,
    BFD_RELOC_RX_ABS16_REV = 1086,
    BFD_RELOC_RX_ABS32 = 1087,
    BFD_RELOC_RX_ABS32_REV = 1088,
    BFD_RELOC_RX_ABS16U = 1089,
    BFD_RELOC_RX_ABS16UW = 1090,
    BFD_RELOC_RX_ABS16UL = 1091,
    BFD_RELOC_RX_RELAX = 1092,
    BFD_RELOC_390_12 = 1093,
    BFD_RELOC_390_GOT12 = 1094,
    BFD_RELOC_390_PLT32 = 1095,
    BFD_RELOC_390_COPY = 1096,
    BFD_RELOC_390_GLOB_DAT = 1097,
    BFD_RELOC_390_JMP_SLOT = 1098,
    BFD_RELOC_390_RELATIVE = 1099,
    BFD_RELOC_390_GOTPC = 1100,
    BFD_RELOC_390_GOT16 = 1101,
    BFD_RELOC_390_PC12DBL = 1102,
    BFD_RELOC_390_PLT12DBL = 1103,
    BFD_RELOC_390_PC16DBL = 1104,
    BFD_RELOC_390_PLT16DBL = 1105,
    BFD_RELOC_390_PC24DBL = 1106,
    BFD_RELOC_390_PLT24DBL = 1107,
    BFD_RELOC_390_PC32DBL = 1108,
    BFD_RELOC_390_PLT32DBL = 1109,
    BFD_RELOC_390_GOTPCDBL = 1110,
    BFD_RELOC_390_GOT64 = 1111,
    BFD_RELOC_390_PLT64 = 1112,
    BFD_RELOC_390_GOTENT = 1113,
    BFD_RELOC_390_GOTOFF64 = 1114,
    BFD_RELOC_390_GOTPLT12 = 1115,
    BFD_RELOC_390_GOTPLT16 = 1116,
    BFD_RELOC_390_GOTPLT32 = 1117,
    BFD_RELOC_390_GOTPLT64 = 1118,
    BFD_RELOC_390_GOTPLTENT = 1119,
    BFD_RELOC_390_PLTOFF16 = 1120,
    BFD_RELOC_390_PLTOFF32 = 1121,
    BFD_RELOC_390_PLTOFF64 = 1122,
    BFD_RELOC_390_TLS_LOAD = 1123,
    BFD_RELOC_390_TLS_GDCALL = 1124,
    BFD_RELOC_390_TLS_LDCALL = 1125,
    BFD_RELOC_390_TLS_GD32 = 1126,
    BFD_RELOC_390_TLS_GD64 = 1127,
    BFD_RELOC_390_TLS_GOTIE12 = 1128,
    BFD_RELOC_390_TLS_GOTIE32 = 1129,
    BFD_RELOC_390_TLS_GOTIE64 = 1130,
    BFD_RELOC_390_TLS_LDM32 = 1131,
    BFD_RELOC_390_TLS_LDM64 = 1132,
    BFD_RELOC_390_TLS_IE32 = 1133,
    BFD_RELOC_390_TLS_IE64 = 1134,
    BFD_RELOC_390_TLS_IEENT = 1135,
    BFD_RELOC_390_TLS_LE32 = 1136,
    BFD_RELOC_390_TLS_LE64 = 1137,
    BFD_RELOC_390_TLS_LDO32 = 1138,
    BFD_RELOC_390_TLS_LDO64 = 1139,
    BFD_RELOC_390_TLS_DTPMOD = 1140,
    BFD_RELOC_390_TLS_DTPOFF = 1141,
    BFD_RELOC_390_TLS_TPOFF = 1142,
    BFD_RELOC_390_20 = 1143,
    BFD_RELOC_390_GOT20 = 1144,
    BFD_RELOC_390_GOTPLT20 = 1145,
    BFD_RELOC_390_TLS_GOTIE20 = 1146,
    BFD_RELOC_390_IRELATIVE = 1147,
    BFD_RELOC_SCORE_GPREL15 = 1148,
    BFD_RELOC_SCORE_DUMMY2 = 1149,
    BFD_RELOC_SCORE_JMP = 1150,
    BFD_RELOC_SCORE_BRANCH = 1151,
    BFD_RELOC_SCORE_IMM30 = 1152,
    BFD_RELOC_SCORE_IMM32 = 1153,
    BFD_RELOC_SCORE16_JMP = 1154,
    BFD_RELOC_SCORE16_BRANCH = 1155,
    BFD_RELOC_SCORE_BCMP = 1156,
    BFD_RELOC_SCORE_GOT15 = 1157,
    BFD_RELOC_SCORE_GOT_LO16 = 1158,
    BFD_RELOC_SCORE_CALL15 = 1159,
    BFD_RELOC_SCORE_DUMMY_HI16 = 1160,
    BFD_RELOC_IP2K_FR9 = 1161,
    BFD_RELOC_IP2K_BANK = 1162,
    BFD_RELOC_IP2K_ADDR16CJP = 1163,
    BFD_RELOC_IP2K_PAGE3 = 1164,
    BFD_RELOC_IP2K_LO8DATA = 1165,
    BFD_RELOC_IP2K_HI8DATA = 1166,
    BFD_RELOC_IP2K_EX8DATA = 1167,
    BFD_RELOC_IP2K_LO8INSN = 1168,
    BFD_RELOC_IP2K_HI8INSN = 1169,
    BFD_RELOC_IP2K_PC_SKIP = 1170,
    BFD_RELOC_IP2K_TEXT = 1171,
    BFD_RELOC_IP2K_FR_OFFSET = 1172,
    BFD_RELOC_VPE4KMATH_DATA = 1173,
    BFD_RELOC_VPE4KMATH_INSN = 1174,
    BFD_RELOC_VTABLE_INHERIT = 1175,
    BFD_RELOC_VTABLE_ENTRY = 1176,
    BFD_RELOC_IA64_IMM14 = 1177,
    BFD_RELOC_IA64_IMM22 = 1178,
    BFD_RELOC_IA64_IMM64 = 1179,
    BFD_RELOC_IA64_DIR32MSB = 1180,
    BFD_RELOC_IA64_DIR32LSB = 1181,
    BFD_RELOC_IA64_DIR64MSB = 1182,
    BFD_RELOC_IA64_DIR64LSB = 1183,
    BFD_RELOC_IA64_GPREL22 = 1184,
    BFD_RELOC_IA64_GPREL64I = 1185,
    BFD_RELOC_IA64_GPREL32MSB = 1186,
    BFD_RELOC_IA64_GPREL32LSB = 1187,
    BFD_RELOC_IA64_GPREL64MSB = 1188,
    BFD_RELOC_IA64_GPREL64LSB = 1189,
    BFD_RELOC_IA64_LTOFF22 = 1190,
    BFD_RELOC_IA64_LTOFF64I = 1191,
    BFD_RELOC_IA64_PLTOFF22 = 1192,
    BFD_RELOC_IA64_PLTOFF64I = 1193,
    BFD_RELOC_IA64_PLTOFF64MSB = 1194,
    BFD_RELOC_IA64_PLTOFF64LSB = 1195,
    BFD_RELOC_IA64_FPTR64I = 1196,
    BFD_RELOC_IA64_FPTR32MSB = 1197,
    BFD_RELOC_IA64_FPTR32LSB = 1198,
    BFD_RELOC_IA64_FPTR64MSB = 1199,
    BFD_RELOC_IA64_FPTR64LSB = 1200,
    BFD_RELOC_IA64_PCREL21B = 1201,
    BFD_RELOC_IA64_PCREL21BI = 1202,
    BFD_RELOC_IA64_PCREL21M = 1203,
    BFD_RELOC_IA64_PCREL21F = 1204,
    BFD_RELOC_IA64_PCREL22 = 1205,
    BFD_RELOC_IA64_PCREL60B = 1206,
    BFD_RELOC_IA64_PCREL64I = 1207,
    BFD_RELOC_IA64_PCREL32MSB = 1208,
    BFD_RELOC_IA64_PCREL32LSB = 1209,
    BFD_RELOC_IA64_PCREL64MSB = 1210,
    BFD_RELOC_IA64_PCREL64LSB = 1211,
    BFD_RELOC_IA64_LTOFF_FPTR22 = 1212,
    BFD_RELOC_IA64_LTOFF_FPTR64I = 1213,
    BFD_RELOC_IA64_LTOFF_FPTR32MSB = 1214,
    BFD_RELOC_IA64_LTOFF_FPTR32LSB = 1215,
    BFD_RELOC_IA64_LTOFF_FPTR64MSB = 1216,
    BFD_RELOC_IA64_LTOFF_FPTR64LSB = 1217,
    BFD_RELOC_IA64_SEGREL32MSB = 1218,
    BFD_RELOC_IA64_SEGREL32LSB = 1219,
    BFD_RELOC_IA64_SEGREL64MSB = 1220,
    BFD_RELOC_IA64_SEGREL64LSB = 1221,
    BFD_RELOC_IA64_SECREL32MSB = 1222,
    BFD_RELOC_IA64_SECREL32LSB = 1223,
    BFD_RELOC_IA64_SECREL64MSB = 1224,
    BFD_RELOC_IA64_SECREL64LSB = 1225,
    BFD_RELOC_IA64_REL32MSB = 1226,
    BFD_RELOC_IA64_REL32LSB = 1227,
    BFD_RELOC_IA64_REL64MSB = 1228,
    BFD_RELOC_IA64_REL64LSB = 1229,
    BFD_RELOC_IA64_LTV32MSB = 1230,
    BFD_RELOC_IA64_LTV32LSB = 1231,
    BFD_RELOC_IA64_LTV64MSB = 1232,
    BFD_RELOC_IA64_LTV64LSB = 1233,
    BFD_RELOC_IA64_IPLTMSB = 1234,
    BFD_RELOC_IA64_IPLTLSB = 1235,
    BFD_RELOC_IA64_COPY = 1236,
    BFD_RELOC_IA64_LTOFF22X = 1237,
    BFD_RELOC_IA64_LDXMOV = 1238,
    BFD_RELOC_IA64_TPREL14 = 1239,
    BFD_RELOC_IA64_TPREL22 = 1240,
    BFD_RELOC_IA64_TPREL64I = 1241,
    BFD_RELOC_IA64_TPREL64MSB = 1242,
    BFD_RELOC_IA64_TPREL64LSB = 1243,
    BFD_RELOC_IA64_LTOFF_TPREL22 = 1244,
    BFD_RELOC_IA64_DTPMOD64MSB = 1245,
    BFD_RELOC_IA64_DTPMOD64LSB = 1246,
    BFD_RELOC_IA64_LTOFF_DTPMOD22 = 1247,
    BFD_RELOC_IA64_DTPREL14 = 1248,
    BFD_RELOC_IA64_DTPREL22 = 1249,
    BFD_RELOC_IA64_DTPREL64I = 1250,
    BFD_RELOC_IA64_DTPREL32MSB = 1251,
    BFD_RELOC_IA64_DTPREL32LSB = 1252,
    BFD_RELOC_IA64_DTPREL64MSB = 1253,
    BFD_RELOC_IA64_DTPREL64LSB = 1254,
    BFD_RELOC_IA64_LTOFF_DTPREL22 = 1255,
    BFD_RELOC_M68HC11_HI8 = 1256,
    BFD_RELOC_M68HC11_LO8 = 1257,
    BFD_RELOC_M68HC11_3B = 1258,
    BFD_RELOC_M68HC11_RL_JUMP = 1259,
    BFD_RELOC_M68HC11_RL_GROUP = 1260,
    BFD_RELOC_M68HC11_LO16 = 1261,
    BFD_RELOC_M68HC11_PAGE = 1262,
    BFD_RELOC_M68HC11_24 = 1263,
    BFD_RELOC_M68HC12_5B = 1264,
    BFD_RELOC_XGATE_RL_JUMP = 1265,
    BFD_RELOC_XGATE_RL_GROUP = 1266,
    BFD_RELOC_XGATE_LO16 = 1267,
    BFD_RELOC_XGATE_GPAGE = 1268,
    BFD_RELOC_XGATE_24 = 1269,
    BFD_RELOC_XGATE_PCREL_9 = 1270,
    BFD_RELOC_XGATE_PCREL_10 = 1271,
    BFD_RELOC_XGATE_IMM8_LO = 1272,
    BFD_RELOC_XGATE_IMM8_HI = 1273,
    BFD_RELOC_XGATE_IMM3 = 1274,
    BFD_RELOC_XGATE_IMM4 = 1275,
    BFD_RELOC_XGATE_IMM5 = 1276,
    BFD_RELOC_M68HC12_9B = 1277,
    BFD_RELOC_M68HC12_16B = 1278,
    BFD_RELOC_M68HC12_9_PCREL = 1279,
    BFD_RELOC_M68HC12_10_PCREL = 1280,
    BFD_RELOC_M68HC12_LO8XG = 1281,
    BFD_RELOC_M68HC12_HI8XG = 1282,
    BFD_RELOC_16C_NUM08 = 1283,
    BFD_RELOC_16C_NUM08_C = 1284,
    BFD_RELOC_16C_NUM16 = 1285,
    BFD_RELOC_16C_NUM16_C = 1286,
    BFD_RELOC_16C_NUM32 = 1287,
    BFD_RELOC_16C_NUM32_C = 1288,
    BFD_RELOC_16C_DISP04 = 1289,
    BFD_RELOC_16C_DISP04_C = 1290,
    BFD_RELOC_16C_DISP08 = 1291,
    BFD_RELOC_16C_DISP08_C = 1292,
    BFD_RELOC_16C_DISP16 = 1293,
    BFD_RELOC_16C_DISP16_C = 1294,
    BFD_RELOC_16C_DISP24 = 1295,
    BFD_RELOC_16C_DISP24_C = 1296,
    BFD_RELOC_16C_DISP24a = 1297,
    BFD_RELOC_16C_DISP24a_C = 1298,
    BFD_RELOC_16C_REG04 = 1299,
    BFD_RELOC_16C_REG04_C = 1300,
    BFD_RELOC_16C_REG04a = 1301,
    BFD_RELOC_16C_REG04a_C = 1302,
    BFD_RELOC_16C_REG14 = 1303,
    BFD_RELOC_16C_REG14_C = 1304,
    BFD_RELOC_16C_REG16 = 1305,
    BFD_RELOC_16C_REG16_C = 1306,
    BFD_RELOC_16C_REG20 = 1307,
    BFD_RELOC_16C_REG20_C = 1308,
    BFD_RELOC_16C_ABS20 = 1309,
    BFD_RELOC_16C_ABS20_C = 1310,
    BFD_RELOC_16C_ABS24 = 1311,
    BFD_RELOC_16C_ABS24_C = 1312,
    BFD_RELOC_16C_IMM04 = 1313,
    BFD_RELOC_16C_IMM04_C = 1314,
    BFD_RELOC_16C_IMM16 = 1315,
    BFD_RELOC_16C_IMM16_C = 1316,
    BFD_RELOC_16C_IMM20 = 1317,
    BFD_RELOC_16C_IMM20_C = 1318,
    BFD_RELOC_16C_IMM24 = 1319,
    BFD_RELOC_16C_IMM24_C = 1320,
    BFD_RELOC_16C_IMM32 = 1321,
    BFD_RELOC_16C_IMM32_C = 1322,
    BFD_RELOC_CR16_NUM8 = 1323,
    BFD_RELOC_CR16_NUM16 = 1324,
    BFD_RELOC_CR16_NUM32 = 1325,
    BFD_RELOC_CR16_NUM32a = 1326,
    BFD_RELOC_CR16_REGREL0 = 1327,
    BFD_RELOC_CR16_REGREL4 = 1328,
    BFD_RELOC_CR16_REGREL4a = 1329,
    BFD_RELOC_CR16_REGREL14 = 1330,
    BFD_RELOC_CR16_REGREL14a = 1331,
    BFD_RELOC_CR16_REGREL16 = 1332,
    BFD_RELOC_CR16_REGREL20 = 1333,
    BFD_RELOC_CR16_REGREL20a = 1334,
    BFD_RELOC_CR16_ABS20 = 1335,
    BFD_RELOC_CR16_ABS24 = 1336,
    BFD_RELOC_CR16_IMM4 = 1337,
    BFD_RELOC_CR16_IMM8 = 1338,
    BFD_RELOC_CR16_IMM16 = 1339,
    BFD_RELOC_CR16_IMM20 = 1340,
    BFD_RELOC_CR16_IMM24 = 1341,
    BFD_RELOC_CR16_IMM32 = 1342,
    BFD_RELOC_CR16_IMM32a = 1343,
    BFD_RELOC_CR16_DISP4 = 1344,
    BFD_RELOC_CR16_DISP8 = 1345,
    BFD_RELOC_CR16_DISP16 = 1346,
    BFD_RELOC_CR16_DISP20 = 1347,
    BFD_RELOC_CR16_DISP24 = 1348,
    BFD_RELOC_CR16_DISP24a = 1349,
    BFD_RELOC_CR16_SWITCH8 = 1350,
    BFD_RELOC_CR16_SWITCH16 = 1351,
    BFD_RELOC_CR16_SWITCH32 = 1352,
    BFD_RELOC_CR16_GOT_REGREL20 = 1353,
    BFD_RELOC_CR16_GOTC_REGREL20 = 1354,
    BFD_RELOC_CR16_GLOB_DAT = 1355,
    BFD_RELOC_CRX_REL4 = 1356,
    BFD_RELOC_CRX_REL8 = 1357,
    BFD_RELOC_CRX_REL8_CMP = 1358,
    BFD_RELOC_CRX_REL16 = 1359,
    BFD_RELOC_CRX_REL24 = 1360,
    BFD_RELOC_CRX_REL32 = 1361,
    BFD_RELOC_CRX_REGREL12 = 1362,
    BFD_RELOC_CRX_REGREL22 = 1363,
    BFD_RELOC_CRX_REGREL28 = 1364,
    BFD_RELOC_CRX_REGREL32 = 1365,
    BFD_RELOC_CRX_ABS16 = 1366,
    BFD_RELOC_CRX_ABS32 = 1367,
    BFD_RELOC_CRX_NUM8 = 1368,
    BFD_RELOC_CRX_NUM16 = 1369,
    BFD_RELOC_CRX_NUM32 = 1370,
    BFD_RELOC_CRX_IMM16 = 1371,
    BFD_RELOC_CRX_IMM32 = 1372,
    BFD_RELOC_CRX_SWITCH8 = 1373,
    BFD_RELOC_CRX_SWITCH16 = 1374,
    BFD_RELOC_CRX_SWITCH32 = 1375,
    BFD_RELOC_CRIS_BDISP8 = 1376,
    BFD_RELOC_CRIS_UNSIGNED_5 = 1377,
    BFD_RELOC_CRIS_SIGNED_6 = 1378,
    BFD_RELOC_CRIS_UNSIGNED_6 = 1379,
    BFD_RELOC_CRIS_SIGNED_8 = 1380,
    BFD_RELOC_CRIS_UNSIGNED_8 = 1381,
    BFD_RELOC_CRIS_SIGNED_16 = 1382,
    BFD_RELOC_CRIS_UNSIGNED_16 = 1383,
    BFD_RELOC_CRIS_LAPCQ_OFFSET = 1384,
    BFD_RELOC_CRIS_UNSIGNED_4 = 1385,
    BFD_RELOC_CRIS_COPY = 1386,
    BFD_RELOC_CRIS_GLOB_DAT = 1387,
    BFD_RELOC_CRIS_JUMP_SLOT = 1388,
    BFD_RELOC_CRIS_RELATIVE = 1389,
    BFD_RELOC_CRIS_32_GOT = 1390,
    BFD_RELOC_CRIS_16_GOT = 1391,
    BFD_RELOC_CRIS_32_GOTPLT = 1392,
    BFD_RELOC_CRIS_16_GOTPLT = 1393,
    BFD_RELOC_CRIS_32_GOTREL = 1394,
    BFD_RELOC_CRIS_32_PLT_GOTREL = 1395,
    BFD_RELOC_CRIS_32_PLT_PCREL = 1396,
    BFD_RELOC_CRIS_32_GOT_GD = 1397,
    BFD_RELOC_CRIS_16_GOT_GD = 1398,
    BFD_RELOC_CRIS_32_GD = 1399,
    BFD_RELOC_CRIS_DTP = 1400,
    BFD_RELOC_CRIS_32_DTPREL = 1401,
    BFD_RELOC_CRIS_16_DTPREL = 1402,
    BFD_RELOC_CRIS_32_GOT_TPREL = 1403,
    BFD_RELOC_CRIS_16_GOT_TPREL = 1404,
    BFD_RELOC_CRIS_32_TPREL = 1405,
    BFD_RELOC_CRIS_16_TPREL = 1406,
    BFD_RELOC_CRIS_DTPMOD = 1407,
    BFD_RELOC_CRIS_32_IE = 1408,
    BFD_RELOC_860_COPY = 1409,
    BFD_RELOC_860_GLOB_DAT = 1410,
    BFD_RELOC_860_JUMP_SLOT = 1411,
    BFD_RELOC_860_RELATIVE = 1412,
    BFD_RELOC_860_PC26 = 1413,
    BFD_RELOC_860_PLT26 = 1414,
    BFD_RELOC_860_PC16 = 1415,
    BFD_RELOC_860_LOW0 = 1416,
    BFD_RELOC_860_SPLIT0 = 1417,
    BFD_RELOC_860_LOW1 = 1418,
    BFD_RELOC_860_SPLIT1 = 1419,
    BFD_RELOC_860_LOW2 = 1420,
    BFD_RELOC_860_SPLIT2 = 1421,
    BFD_RELOC_860_LOW3 = 1422,
    BFD_RELOC_860_LOGOT0 = 1423,
    BFD_RELOC_860_SPGOT0 = 1424,
    BFD_RELOC_860_LOGOT1 = 1425,
    BFD_RELOC_860_SPGOT1 = 1426,
    BFD_RELOC_860_LOGOTOFF0 = 1427,
    BFD_RELOC_860_SPGOTOFF0 = 1428,
    BFD_RELOC_860_LOGOTOFF1 = 1429,
    BFD_RELOC_860_SPGOTOFF1 = 1430,
    BFD_RELOC_860_LOGOTOFF2 = 1431,
    BFD_RELOC_860_LOGOTOFF3 = 1432,
    BFD_RELOC_860_LOPC = 1433,
    BFD_RELOC_860_HIGHADJ = 1434,
    BFD_RELOC_860_HAGOT = 1435,
    BFD_RELOC_860_HAGOTOFF = 1436,
    BFD_RELOC_860_HAPC = 1437,
    BFD_RELOC_860_HIGH = 1438,
    BFD_RELOC_860_HIGOT = 1439,
    BFD_RELOC_860_HIGOTOFF = 1440,
    BFD_RELOC_OPENRISC_ABS_26 = 1441,
    BFD_RELOC_OPENRISC_REL_26 = 1442,
    BFD_RELOC_H8_DIR16A8 = 1443,
    BFD_RELOC_H8_DIR16R8 = 1444,
    BFD_RELOC_H8_DIR24A8 = 1445,
    BFD_RELOC_H8_DIR24R8 = 1446,
    BFD_RELOC_H8_DIR32A16 = 1447,
    BFD_RELOC_H8_DISP32A16 = 1448,
    BFD_RELOC_XSTORMY16_REL_12 = 1449,
    BFD_RELOC_XSTORMY16_12 = 1450,
    BFD_RELOC_XSTORMY16_24 = 1451,
    BFD_RELOC_XSTORMY16_FPTR16 = 1452,
    BFD_RELOC_RELC = 1453,
    BFD_RELOC_XC16X_PAG = 1454,
    BFD_RELOC_XC16X_POF = 1455,
    BFD_RELOC_XC16X_SEG = 1456,
    BFD_RELOC_XC16X_SOF = 1457,
    BFD_RELOC_VAX_GLOB_DAT = 1458,
    BFD_RELOC_VAX_JMP_SLOT = 1459,
    BFD_RELOC_VAX_RELATIVE = 1460,
    BFD_RELOC_MT_PC16 = 1461,
    BFD_RELOC_MT_HI16 = 1462,
    BFD_RELOC_MT_LO16 = 1463,
    BFD_RELOC_MT_GNU_VTINHERIT = 1464,
    BFD_RELOC_MT_GNU_VTENTRY = 1465,
    BFD_RELOC_MT_PCINSN8 = 1466,
    BFD_RELOC_MSP430_10_PCREL = 1467,
    BFD_RELOC_MSP430_16_PCREL = 1468,
    BFD_RELOC_MSP430_16 = 1469,
    BFD_RELOC_MSP430_16_PCREL_BYTE = 1470,
    BFD_RELOC_MSP430_16_BYTE = 1471,
    BFD_RELOC_MSP430_2X_PCREL = 1472,
    BFD_RELOC_MSP430_RL_PCREL = 1473,
    BFD_RELOC_MSP430_ABS8 = 1474,
    BFD_RELOC_MSP430X_PCR20_EXT_SRC = 1475,
    BFD_RELOC_MSP430X_PCR20_EXT_DST = 1476,
    BFD_RELOC_MSP430X_PCR20_EXT_ODST = 1477,
    BFD_RELOC_MSP430X_ABS20_EXT_SRC = 1478,
    BFD_RELOC_MSP430X_ABS20_EXT_DST = 1479,
    BFD_RELOC_MSP430X_ABS20_EXT_ODST = 1480,
    BFD_RELOC_MSP430X_ABS20_ADR_SRC = 1481,
    BFD_RELOC_MSP430X_ABS20_ADR_DST = 1482,
    BFD_RELOC_MSP430X_PCR16 = 1483,
    BFD_RELOC_MSP430X_PCR20_CALL = 1484,
    BFD_RELOC_MSP430X_ABS16 = 1485,
    BFD_RELOC_MSP430_ABS_HI16 = 1486,
    BFD_RELOC_MSP430_PREL31 = 1487,
    BFD_RELOC_MSP430_SYM_DIFF = 1488,
    BFD_RELOC_NIOS2_S16 = 1489,
    BFD_RELOC_NIOS2_U16 = 1490,
    BFD_RELOC_NIOS2_CALL26 = 1491,
    BFD_RELOC_NIOS2_IMM5 = 1492,
    BFD_RELOC_NIOS2_CACHE_OPX = 1493,
    BFD_RELOC_NIOS2_IMM6 = 1494,
    BFD_RELOC_NIOS2_IMM8 = 1495,
    BFD_RELOC_NIOS2_HI16 = 1496,
    BFD_RELOC_NIOS2_LO16 = 1497,
    BFD_RELOC_NIOS2_HIADJ16 = 1498,
    BFD_RELOC_NIOS2_GPREL = 1499,
    BFD_RELOC_NIOS2_UJMP = 1500,
    BFD_RELOC_NIOS2_CJMP = 1501,
    BFD_RELOC_NIOS2_CALLR = 1502,
    BFD_RELOC_NIOS2_ALIGN = 1503,
    BFD_RELOC_NIOS2_GOT16 = 1504,
    BFD_RELOC_NIOS2_CALL16 = 1505,
    BFD_RELOC_NIOS2_GOTOFF_LO = 1506,
    BFD_RELOC_NIOS2_GOTOFF_HA = 1507,
    BFD_RELOC_NIOS2_PCREL_LO = 1508,
    BFD_RELOC_NIOS2_PCREL_HA = 1509,
    BFD_RELOC_NIOS2_TLS_GD16 = 1510,
    BFD_RELOC_NIOS2_TLS_LDM16 = 1511,
    BFD_RELOC_NIOS2_TLS_LDO16 = 1512,
    BFD_RELOC_NIOS2_TLS_IE16 = 1513,
    BFD_RELOC_NIOS2_TLS_LE16 = 1514,
    BFD_RELOC_NIOS2_TLS_DTPMOD = 1515,
    BFD_RELOC_NIOS2_TLS_DTPREL = 1516,
    BFD_RELOC_NIOS2_TLS_TPREL = 1517,
    BFD_RELOC_NIOS2_COPY = 1518,
    BFD_RELOC_NIOS2_GLOB_DAT = 1519,
    BFD_RELOC_NIOS2_JUMP_SLOT = 1520,
    BFD_RELOC_NIOS2_RELATIVE = 1521,
    BFD_RELOC_NIOS2_GOTOFF = 1522,
    BFD_RELOC_IQ2000_OFFSET_16 = 1523,
    BFD_RELOC_IQ2000_OFFSET_21 = 1524,
    BFD_RELOC_IQ2000_UHI16 = 1525,
    BFD_RELOC_XTENSA_RTLD = 1526,
    BFD_RELOC_XTENSA_GLOB_DAT = 1527,
    BFD_RELOC_XTENSA_JMP_SLOT = 1528,
    BFD_RELOC_XTENSA_RELATIVE = 1529,
    BFD_RELOC_XTENSA_PLT = 1530,
    BFD_RELOC_XTENSA_DIFF8 = 1531,
    BFD_RELOC_XTENSA_DIFF16 = 1532,
    BFD_RELOC_XTENSA_DIFF32 = 1533,
    BFD_RELOC_XTENSA_SLOT0_OP = 1534,
    BFD_RELOC_XTENSA_SLOT1_OP = 1535,
    BFD_RELOC_XTENSA_SLOT2_OP = 1536,
    BFD_RELOC_XTENSA_SLOT3_OP = 1537,
    BFD_RELOC_XTENSA_SLOT4_OP = 1538,
    BFD_RELOC_XTENSA_SLOT5_OP = 1539,
    BFD_RELOC_XTENSA_SLOT6_OP = 1540,
    BFD_RELOC_XTENSA_SLOT7_OP = 1541,
    BFD_RELOC_XTENSA_SLOT8_OP = 1542,
    BFD_RELOC_XTENSA_SLOT9_OP = 1543,
    BFD_RELOC_XTENSA_SLOT10_OP = 1544,
    BFD_RELOC_XTENSA_SLOT11_OP = 1545,
    BFD_RELOC_XTENSA_SLOT12_OP = 1546,
    BFD_RELOC_XTENSA_SLOT13_OP = 1547,
    BFD_RELOC_XTENSA_SLOT14_OP = 1548,
    BFD_RELOC_XTENSA_SLOT0_ALT = 1549,
    BFD_RELOC_XTENSA_SLOT1_ALT = 1550,
    BFD_RELOC_XTENSA_SLOT2_ALT = 1551,
    BFD_RELOC_XTENSA_SLOT3_ALT = 1552,
    BFD_RELOC_XTENSA_SLOT4_ALT = 1553,
    BFD_RELOC_XTENSA_SLOT5_ALT = 1554,
    BFD_RELOC_XTENSA_SLOT6_ALT = 1555,
    BFD_RELOC_XTENSA_SLOT7_ALT = 1556,
    BFD_RELOC_XTENSA_SLOT8_ALT = 1557,
    BFD_RELOC_XTENSA_SLOT9_ALT = 1558,
    BFD_RELOC_XTENSA_SLOT10_ALT = 1559,
    BFD_RELOC_XTENSA_SLOT11_ALT = 1560,
    BFD_RELOC_XTENSA_SLOT12_ALT = 1561,
    BFD_RELOC_XTENSA_SLOT13_ALT = 1562,
    BFD_RELOC_XTENSA_SLOT14_ALT = 1563,
    BFD_RELOC_XTENSA_OP0 = 1564,
    BFD_RELOC_XTENSA_OP1 = 1565,
    BFD_RELOC_XTENSA_OP2 = 1566,
    BFD_RELOC_XTENSA_ASM_EXPAND = 1567,
    BFD_RELOC_XTENSA_ASM_SIMPLIFY = 1568,
    BFD_RELOC_XTENSA_TLSDESC_FN = 1569,
    BFD_RELOC_XTENSA_TLSDESC_ARG = 1570,
    BFD_RELOC_XTENSA_TLS_DTPOFF = 1571,
    BFD_RELOC_XTENSA_TLS_TPOFF = 1572,
    BFD_RELOC_XTENSA_TLS_FUNC = 1573,
    BFD_RELOC_XTENSA_TLS_ARG = 1574,
    BFD_RELOC_XTENSA_TLS_CALL = 1575,
    BFD_RELOC_Z80_DISP8 = 1576,
    BFD_RELOC_Z8K_DISP7 = 1577,
    BFD_RELOC_Z8K_CALLR = 1578,
    BFD_RELOC_Z8K_IMM4L = 1579,
    BFD_RELOC_LM32_CALL = 1580,
    BFD_RELOC_LM32_BRANCH = 1581,
    BFD_RELOC_LM32_16_GOT = 1582,
    BFD_RELOC_LM32_GOTOFF_HI16 = 1583,
    BFD_RELOC_LM32_GOTOFF_LO16 = 1584,
    BFD_RELOC_LM32_COPY = 1585,
    BFD_RELOC_LM32_GLOB_DAT = 1586,
    BFD_RELOC_LM32_JMP_SLOT = 1587,
    BFD_RELOC_LM32_RELATIVE = 1588,
    BFD_RELOC_MACH_O_SECTDIFF = 1589,
    BFD_RELOC_MACH_O_LOCAL_SECTDIFF = 1590,
    BFD_RELOC_MACH_O_PAIR = 1591,
    BFD_RELOC_MACH_O_X86_64_BRANCH32 = 1592,
    BFD_RELOC_MACH_O_X86_64_BRANCH8 = 1593,
    BFD_RELOC_MACH_O_X86_64_GOT = 1594,
    BFD_RELOC_MACH_O_X86_64_GOT_LOAD = 1595,
    BFD_RELOC_MACH_O_X86_64_SUBTRACTOR32 = 1596,
    BFD_RELOC_MACH_O_X86_64_SUBTRACTOR64 = 1597,
    BFD_RELOC_MACH_O_X86_64_PCREL32_1 = 1598,
    BFD_RELOC_MACH_O_X86_64_PCREL32_2 = 1599,
    BFD_RELOC_MACH_O_X86_64_PCREL32_4 = 1600,
    BFD_RELOC_MICROBLAZE_32_LO = 1601,
    BFD_RELOC_MICROBLAZE_32_LO_PCREL = 1602,
    BFD_RELOC_MICROBLAZE_32_ROSDA = 1603,
    BFD_RELOC_MICROBLAZE_32_RWSDA = 1604,
    BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM = 1605,
    BFD_RELOC_MICROBLAZE_64_NONE = 1606,
    BFD_RELOC_MICROBLAZE_64_GOTPC = 1607,
    BFD_RELOC_MICROBLAZE_64_GOT = 1608,
    BFD_RELOC_MICROBLAZE_64_PLT = 1609,
    BFD_RELOC_MICROBLAZE_64_GOTOFF = 1610,
    BFD_RELOC_MICROBLAZE_32_GOTOFF = 1611,
    BFD_RELOC_MICROBLAZE_COPY = 1612,
    BFD_RELOC_MICROBLAZE_64_TLS = 1613,
    BFD_RELOC_MICROBLAZE_64_TLSGD = 1614,
    BFD_RELOC_MICROBLAZE_64_TLSLD = 1615,
    BFD_RELOC_MICROBLAZE_32_TLSDTPMOD = 1616,
    BFD_RELOC_MICROBLAZE_32_TLSDTPREL = 1617,
    BFD_RELOC_MICROBLAZE_64_TLSDTPREL = 1618,
    BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL = 1619,
    BFD_RELOC_MICROBLAZE_64_TLSTPREL = 1620,
    BFD_RELOC_AARCH64_RELOC_START = 1621,
    BFD_RELOC_AARCH64_NONE = 1622,
    BFD_RELOC_AARCH64_64 = 1623,
    BFD_RELOC_AARCH64_32 = 1624,
    BFD_RELOC_AARCH64_16 = 1625,
    BFD_RELOC_AARCH64_64_PCREL = 1626,
    BFD_RELOC_AARCH64_32_PCREL = 1627,
    BFD_RELOC_AARCH64_16_PCREL = 1628,
    BFD_RELOC_AARCH64_MOVW_G0 = 1629,
    BFD_RELOC_AARCH64_MOVW_G0_NC = 1630,
    BFD_RELOC_AARCH64_MOVW_G1 = 1631,
    BFD_RELOC_AARCH64_MOVW_G1_NC = 1632,
    BFD_RELOC_AARCH64_MOVW_G2 = 1633,
    BFD_RELOC_AARCH64_MOVW_G2_NC = 1634,
    BFD_RELOC_AARCH64_MOVW_G3 = 1635,
    BFD_RELOC_AARCH64_MOVW_G0_S = 1636,
    BFD_RELOC_AARCH64_MOVW_G1_S = 1637,
    BFD_RELOC_AARCH64_MOVW_G2_S = 1638,
    BFD_RELOC_AARCH64_LD_LO19_PCREL = 1639,
    BFD_RELOC_AARCH64_ADR_LO21_PCREL = 1640,
    BFD_RELOC_AARCH64_ADR_HI21_PCREL = 1641,
    BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL = 1642,
    BFD_RELOC_AARCH64_ADD_LO12 = 1643,
    BFD_RELOC_AARCH64_LDST8_LO12 = 1644,
    BFD_RELOC_AARCH64_TSTBR14 = 1645,
    BFD_RELOC_AARCH64_BRANCH19 = 1646,
    BFD_RELOC_AARCH64_JUMP26 = 1647,
    BFD_RELOC_AARCH64_CALL26 = 1648,
    BFD_RELOC_AARCH64_LDST16_LO12 = 1649,
    BFD_RELOC_AARCH64_LDST32_LO12 = 1650,
    BFD_RELOC_AARCH64_LDST64_LO12 = 1651,
    BFD_RELOC_AARCH64_LDST128_LO12 = 1652,
    BFD_RELOC_AARCH64_GOT_LD_PREL19 = 1653,
    BFD_RELOC_AARCH64_ADR_GOT_PAGE = 1654,
    BFD_RELOC_AARCH64_LD64_GOT_LO12_NC = 1655,
    BFD_RELOC_AARCH64_LD32_GOT_LO12_NC = 1656,
    BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21 = 1657,
    BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC = 1658,
    BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1 = 1659,
    BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC = 1660,
    BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 = 1661,
    BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC = 1662,
    BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC = 1663,
    BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19 = 1664,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2 = 1665,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1 = 1666,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC = 1667,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0 = 1668,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC = 1669,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12 = 1670,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12 = 1671,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC = 1672,
    BFD_RELOC_AARCH64_TLSDESC_LD_PREL19 = 1673,
    BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21 = 1674,
    BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21 = 1675,
    BFD_RELOC_AARCH64_TLSDESC_LD64_LO12_NC = 1676,
    BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC = 1677,
    BFD_RELOC_AARCH64_TLSDESC_ADD_LO12_NC = 1678,
    BFD_RELOC_AARCH64_TLSDESC_OFF_G1 = 1679,
    BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC = 1680,
    BFD_RELOC_AARCH64_TLSDESC_LDR = 1681,
    BFD_RELOC_AARCH64_TLSDESC_ADD = 1682,
    BFD_RELOC_AARCH64_TLSDESC_CALL = 1683,
    BFD_RELOC_AARCH64_COPY = 1684,
    BFD_RELOC_AARCH64_GLOB_DAT = 1685,
    BFD_RELOC_AARCH64_JUMP_SLOT = 1686,
    BFD_RELOC_AARCH64_RELATIVE = 1687,
    BFD_RELOC_AARCH64_TLS_DTPMOD = 1688,
    BFD_RELOC_AARCH64_TLS_DTPREL = 1689,
    BFD_RELOC_AARCH64_TLS_TPREL = 1690,
    BFD_RELOC_AARCH64_TLSDESC = 1691,
    BFD_RELOC_AARCH64_IRELATIVE = 1692,
    BFD_RELOC_AARCH64_RELOC_END = 1693,
    BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP = 1694,
    BFD_RELOC_AARCH64_LDST_LO12 = 1695,
    BFD_RELOC_AARCH64_LD_GOT_LO12_NC = 1696,
    BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC = 1697,
    BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC = 1698,
    BFD_RELOC_TILEPRO_COPY = 1699,
    BFD_RELOC_TILEPRO_GLOB_DAT = 1700,
    BFD_RELOC_TILEPRO_JMP_SLOT = 1701,
    BFD_RELOC_TILEPRO_RELATIVE = 1702,
    BFD_RELOC_TILEPRO_BROFF_X1 = 1703,
    BFD_RELOC_TILEPRO_JOFFLONG_X1 = 1704,
    BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT = 1705,
    BFD_RELOC_TILEPRO_IMM8_X0 = 1706,
    BFD_RELOC_TILEPRO_IMM8_Y0 = 1707,
    BFD_RELOC_TILEPRO_IMM8_X1 = 1708,
    BFD_RELOC_TILEPRO_IMM8_Y1 = 1709,
    BFD_RELOC_TILEPRO_DEST_IMM8_X1 = 1710,
    BFD_RELOC_TILEPRO_MT_IMM15_X1 = 1711,
    BFD_RELOC_TILEPRO_MF_IMM15_X1 = 1712,
    BFD_RELOC_TILEPRO_IMM16_X0 = 1713,
    BFD_RELOC_TILEPRO_IMM16_X1 = 1714,
    BFD_RELOC_TILEPRO_IMM16_X0_LO = 1715,
    BFD_RELOC_TILEPRO_IMM16_X1_LO = 1716,
    BFD_RELOC_TILEPRO_IMM16_X0_HI = 1717,
    BFD_RELOC_TILEPRO_IMM16_X1_HI = 1718,
    BFD_RELOC_TILEPRO_IMM16_X0_HA = 1719,
    BFD_RELOC_TILEPRO_IMM16_X1_HA = 1720,
    BFD_RELOC_TILEPRO_IMM16_X0_PCREL = 1721,
    BFD_RELOC_TILEPRO_IMM16_X1_PCREL = 1722,
    BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL = 1723,
    BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL = 1724,
    BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL = 1725,
    BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL = 1726,
    BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL = 1727,
    BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL = 1728,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT = 1729,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT = 1730,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO = 1731,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO = 1732,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI = 1733,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI = 1734,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA = 1735,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA = 1736,
    BFD_RELOC_TILEPRO_MMSTART_X0 = 1737,
    BFD_RELOC_TILEPRO_MMEND_X0 = 1738,
    BFD_RELOC_TILEPRO_MMSTART_X1 = 1739,
    BFD_RELOC_TILEPRO_MMEND_X1 = 1740,
    BFD_RELOC_TILEPRO_SHAMT_X0 = 1741,
    BFD_RELOC_TILEPRO_SHAMT_X1 = 1742,
    BFD_RELOC_TILEPRO_SHAMT_Y0 = 1743,
    BFD_RELOC_TILEPRO_SHAMT_Y1 = 1744,
    BFD_RELOC_TILEPRO_TLS_GD_CALL = 1745,
    BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD = 1746,
    BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD = 1747,
    BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD = 1748,
    BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD = 1749,
    BFD_RELOC_TILEPRO_TLS_IE_LOAD = 1750,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD = 1751,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD = 1752,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO = 1753,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO = 1754,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI = 1755,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI = 1756,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA = 1757,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA = 1758,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE = 1759,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE = 1760,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO = 1761,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO = 1762,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI = 1763,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI = 1764,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA = 1765,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA = 1766,
    BFD_RELOC_TILEPRO_TLS_DTPMOD32 = 1767,
    BFD_RELOC_TILEPRO_TLS_DTPOFF32 = 1768,
    BFD_RELOC_TILEPRO_TLS_TPOFF32 = 1769,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE = 1770,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE = 1771,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO = 1772,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO = 1773,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI = 1774,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI = 1775,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA = 1776,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA = 1777,
    BFD_RELOC_TILEGX_HW0 = 1778,
    BFD_RELOC_TILEGX_HW1 = 1779,
    BFD_RELOC_TILEGX_HW2 = 1780,
    BFD_RELOC_TILEGX_HW3 = 1781,
    BFD_RELOC_TILEGX_HW0_LAST = 1782,
    BFD_RELOC_TILEGX_HW1_LAST = 1783,
    BFD_RELOC_TILEGX_HW2_LAST = 1784,
    BFD_RELOC_TILEGX_COPY = 1785,
    BFD_RELOC_TILEGX_GLOB_DAT = 1786,
    BFD_RELOC_TILEGX_JMP_SLOT = 1787,
    BFD_RELOC_TILEGX_RELATIVE = 1788,
    BFD_RELOC_TILEGX_BROFF_X1 = 1789,
    BFD_RELOC_TILEGX_JUMPOFF_X1 = 1790,
    BFD_RELOC_TILEGX_JUMPOFF_X1_PLT = 1791,
    BFD_RELOC_TILEGX_IMM8_X0 = 1792,
    BFD_RELOC_TILEGX_IMM8_Y0 = 1793,
    BFD_RELOC_TILEGX_IMM8_X1 = 1794,
    BFD_RELOC_TILEGX_IMM8_Y1 = 1795,
    BFD_RELOC_TILEGX_DEST_IMM8_X1 = 1796,
    BFD_RELOC_TILEGX_MT_IMM14_X1 = 1797,
    BFD_RELOC_TILEGX_MF_IMM14_X1 = 1798,
    BFD_RELOC_TILEGX_MMSTART_X0 = 1799,
    BFD_RELOC_TILEGX_MMEND_X0 = 1800,
    BFD_RELOC_TILEGX_SHAMT_X0 = 1801,
    BFD_RELOC_TILEGX_SHAMT_X1 = 1802,
    BFD_RELOC_TILEGX_SHAMT_Y0 = 1803,
    BFD_RELOC_TILEGX_SHAMT_Y1 = 1804,
    BFD_RELOC_TILEGX_IMM16_X0_HW0 = 1805,
    BFD_RELOC_TILEGX_IMM16_X1_HW0 = 1806,
    BFD_RELOC_TILEGX_IMM16_X0_HW1 = 1807,
    BFD_RELOC_TILEGX_IMM16_X1_HW1 = 1808,
    BFD_RELOC_TILEGX_IMM16_X0_HW2 = 1809,
    BFD_RELOC_TILEGX_IMM16_X1_HW2 = 1810,
    BFD_RELOC_TILEGX_IMM16_X0_HW3 = 1811,
    BFD_RELOC_TILEGX_IMM16_X1_HW3 = 1812,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST = 1813,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST = 1814,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST = 1815,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST = 1816,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST = 1817,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST = 1818,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL = 1819,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL = 1820,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL = 1821,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL = 1822,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL = 1823,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL = 1824,
    BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL = 1825,
    BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL = 1826,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL = 1827,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL = 1828,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL = 1829,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL = 1830,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL = 1831,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL = 1832,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT = 1833,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT = 1834,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL = 1835,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL = 1836,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL = 1837,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL = 1838,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL = 1839,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL = 1840,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT = 1841,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT = 1842,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT = 1843,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT = 1844,
    BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL = 1845,
    BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL = 1846,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD = 1847,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD = 1848,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE = 1849,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE = 1850,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE = 1851,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE = 1852,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE = 1853,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE = 1854,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD = 1855,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD = 1856,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD = 1857,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD = 1858,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE = 1859,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE = 1860,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL = 1861,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL = 1862,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL = 1863,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL = 1864,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL = 1865,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL = 1866,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE = 1867,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE = 1868,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE = 1869,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE = 1870,
    BFD_RELOC_TILEGX_TLS_DTPMOD64 = 1871,
    BFD_RELOC_TILEGX_TLS_DTPOFF64 = 1872,
    BFD_RELOC_TILEGX_TLS_TPOFF64 = 1873,
    BFD_RELOC_TILEGX_TLS_DTPMOD32 = 1874,
    BFD_RELOC_TILEGX_TLS_DTPOFF32 = 1875,
    BFD_RELOC_TILEGX_TLS_TPOFF32 = 1876,
    BFD_RELOC_TILEGX_TLS_GD_CALL = 1877,
    BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD = 1878,
    BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD = 1879,
    BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD = 1880,
    BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD = 1881,
    BFD_RELOC_TILEGX_TLS_IE_LOAD = 1882,
    BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD = 1883,
    BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD = 1884,
    BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD = 1885,
    BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD = 1886,
    BFD_RELOC_EPIPHANY_SIMM8 = 1887,
    BFD_RELOC_EPIPHANY_SIMM24 = 1888,
    BFD_RELOC_EPIPHANY_HIGH = 1889,
    BFD_RELOC_EPIPHANY_LOW = 1890,
    BFD_RELOC_EPIPHANY_SIMM11 = 1891,
    BFD_RELOC_EPIPHANY_IMM11 = 1892,
    BFD_RELOC_EPIPHANY_IMM8 = 1893,
    BFD_RELOC_UNUSED = 1894
} ;
#line 5766 "../bfd/bfd.h"
typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
#line 5776 "../bfd/bfd.h"
union __anonunion_udata_563736225 {
   void *p ;
   bfd_vma i ;
};
#line 5776 "../bfd/bfd.h"
struct bfd_symbol {
   struct bfd *the_bfd ;
   char const   *name ;
   symvalue value ;
   flagword flags ;
   struct bfd_section *section ;
   union __anonunion_udata_563736225 udata ;
};
#line 5776 "../bfd/bfd.h"
typedef struct bfd_symbol asymbol;
#line 5963
enum bfd_direction {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
} ;
#line 5971
struct bfd_target ;
#line 5971
struct bfd_iovec ;
#line 5971
struct aout_data_struct ;
#line 5971
struct artdata ;
#line 5971
struct _oasys_data ;
#line 5971
struct _oasys_ar_data ;
#line 5971
struct coff_tdata ;
#line 5971
struct pe_tdata ;
#line 5971
struct xcoff_tdata ;
#line 5971
struct ecoff_tdata ;
#line 5971
struct ieee_data_struct ;
#line 5971
struct ieee_ar_data_struct ;
#line 5971
struct srec_data_struct ;
#line 5971
struct verilog_data_struct ;
#line 5971
struct ihex_data_struct ;
#line 5971
struct tekhex_data_struct ;
#line 5971
struct elf_obj_tdata ;
#line 5971
struct nlm_obj_tdata ;
#line 5971
struct bout_data_struct ;
#line 5971
struct mmo_data_struct ;
#line 5971
struct sun_core_struct ;
#line 5971
struct sco5_core_struct ;
#line 5971
struct trad_core_struct ;
#line 5971
struct som_data_struct ;
#line 5971
struct hpux_core_struct ;
#line 5971
struct hppabsd_core_struct ;
#line 5971
struct sgi_core_struct ;
#line 5971
struct lynx_core_struct ;
#line 5971
struct osf_core_struct ;
#line 5971
struct cisco_core_struct ;
#line 5971
struct versados_data_struct ;
#line 5971
struct netbsd_core_struct ;
#line 5971
struct mach_o_data_struct ;
#line 5971
struct mach_o_fat_data_struct ;
#line 5971
struct plugin_data_struct ;
#line 5971
struct bfd_pef_data_struct ;
#line 5971
struct bfd_pef_xlib_data_struct ;
#line 5971
struct bfd_sym_data_struct ;
#line 5971 "../bfd/bfd.h"
union __anonunion_tdata_99884381 {
   struct aout_data_struct *aout_data ;
   struct artdata *aout_ar_data ;
   struct _oasys_data *oasys_obj_data ;
   struct _oasys_ar_data *oasys_ar_data ;
   struct coff_tdata *coff_obj_data ;
   struct pe_tdata *pe_obj_data ;
   struct xcoff_tdata *xcoff_obj_data ;
   struct ecoff_tdata *ecoff_obj_data ;
   struct ieee_data_struct *ieee_data ;
   struct ieee_ar_data_struct *ieee_ar_data ;
   struct srec_data_struct *srec_data ;
   struct verilog_data_struct *verilog_data ;
   struct ihex_data_struct *ihex_data ;
   struct tekhex_data_struct *tekhex_data ;
   struct elf_obj_tdata *elf_obj_data ;
   struct nlm_obj_tdata *nlm_obj_data ;
   struct bout_data_struct *bout_data ;
   struct mmo_data_struct *mmo_data ;
   struct sun_core_struct *sun_core_data ;
   struct sco5_core_struct *sco5_core_data ;
   struct trad_core_struct *trad_core_data ;
   struct som_data_struct *som_data ;
   struct hpux_core_struct *hpux_core_data ;
   struct hppabsd_core_struct *hppabsd_core_data ;
   struct sgi_core_struct *sgi_core_data ;
   struct lynx_core_struct *lynx_core_data ;
   struct osf_core_struct *osf_core_data ;
   struct cisco_core_struct *cisco_core_data ;
   struct versados_data_struct *versados_data ;
   struct netbsd_core_struct *netbsd_core_data ;
   struct mach_o_data_struct *mach_o_data ;
   struct mach_o_fat_data_struct *mach_o_fat_data ;
   struct plugin_data_struct *plugin_data ;
   struct bfd_pef_data_struct *pef_data ;
   struct bfd_pef_xlib_data_struct *pef_xlib_data ;
   struct bfd_sym_data_struct *sym_data ;
   void *any ;
};
#line 5971 "../bfd/bfd.h"
struct bfd {
   unsigned int id ;
   char const   *filename ;
   struct bfd_target  const  *xvec ;
   void *iostream ;
   struct bfd_iovec  const  *iovec ;
   struct bfd *lru_prev ;
   struct bfd *lru_next ;
   ufile_ptr where ;
   long mtime ;
   int ifd ;
   bfd_format format ;
   enum bfd_direction direction ;
   flagword flags ;
   ufile_ptr origin ;
   ufile_ptr proxy_origin ;
   struct bfd_hash_table section_htab ;
   struct bfd_section *sections ;
   struct bfd_section *section_last ;
   unsigned int section_count ;
   bfd_vma start_address ;
   unsigned int symcount ;
   struct bfd_symbol **outsymbols ;
   unsigned int dynsymcount ;
   struct bfd_arch_info  const  *arch_info ;
   void *arelt_data ;
   struct bfd *my_archive ;
   struct bfd *archive_next ;
   struct bfd *archive_head ;
   struct bfd *nested_archives ;
   struct bfd *link_next ;
   int archive_pass ;
   union __anonunion_tdata_99884381 tdata ;
   void *usrdata ;
   void *memory ;
   unsigned int cacheable : 1 ;
   unsigned int target_defaulted : 1 ;
   unsigned int opened_once : 1 ;
   unsigned int mtime_set : 1 ;
   unsigned int no_export : 1 ;
   unsigned int output_has_begun : 1 ;
   unsigned int has_armap : 1 ;
   unsigned int is_thin_archive : 1 ;
   unsigned int selective_search : 1 ;
};
#line 6483
enum bfd_flavour {
    bfd_target_unknown_flavour = 0,
    bfd_target_aout_flavour = 1,
    bfd_target_coff_flavour = 2,
    bfd_target_ecoff_flavour = 3,
    bfd_target_xcoff_flavour = 4,
    bfd_target_elf_flavour = 5,
    bfd_target_ieee_flavour = 6,
    bfd_target_nlm_flavour = 7,
    bfd_target_oasys_flavour = 8,
    bfd_target_tekhex_flavour = 9,
    bfd_target_srec_flavour = 10,
    bfd_target_verilog_flavour = 11,
    bfd_target_ihex_flavour = 12,
    bfd_target_som_flavour = 13,
    bfd_target_os9k_flavour = 14,
    bfd_target_versados_flavour = 15,
    bfd_target_msdos_flavour = 16,
    bfd_target_ovax_flavour = 17,
    bfd_target_evax_flavour = 18,
    bfd_target_mmo_flavour = 19,
    bfd_target_mach_o_flavour = 20,
    bfd_target_pef_flavour = 21,
    bfd_target_pef_xlib_flavour = 22,
    bfd_target_sym_flavour = 23
} ;
#line 6511
enum bfd_endian {
    BFD_ENDIAN_BIG = 0,
    BFD_ENDIAN_LITTLE = 1,
    BFD_ENDIAN_UNKNOWN = 2
} ;
#line 6517
struct flag_info ;
#line 6519
struct bfd_link_hash_table ;
#line 6519 "../bfd/bfd.h"
struct bfd_target {
   char *name ;
   enum bfd_flavour flavour ;
   enum bfd_endian byteorder ;
   enum bfd_endian header_byteorder ;
   flagword object_flags ;
   flagword section_flags ;
   char symbol_leading_char ;
   char ar_pad_char ;
   unsigned char ar_max_namelen ;
   unsigned char match_priority ;
   bfd_uint64_t (*bfd_getx64)(void const   * ) ;
   bfd_int64_t (*bfd_getx_signed_64)(void const   * ) ;
   void (*bfd_putx64)(bfd_uint64_t  , void * ) ;
   bfd_vma (*bfd_getx32)(void const   * ) ;
   bfd_signed_vma (*bfd_getx_signed_32)(void const   * ) ;
   void (*bfd_putx32)(bfd_vma  , void * ) ;
   bfd_vma (*bfd_getx16)(void const   * ) ;
   bfd_signed_vma (*bfd_getx_signed_16)(void const   * ) ;
   void (*bfd_putx16)(bfd_vma  , void * ) ;
   bfd_uint64_t (*bfd_h_getx64)(void const   * ) ;
   bfd_int64_t (*bfd_h_getx_signed_64)(void const   * ) ;
   void (*bfd_h_putx64)(bfd_uint64_t  , void * ) ;
   bfd_vma (*bfd_h_getx32)(void const   * ) ;
   bfd_signed_vma (*bfd_h_getx_signed_32)(void const   * ) ;
   void (*bfd_h_putx32)(bfd_vma  , void * ) ;
   bfd_vma (*bfd_h_getx16)(void const   * ) ;
   bfd_signed_vma (*bfd_h_getx_signed_16)(void const   * ) ;
   void (*bfd_h_putx16)(bfd_vma  , void * ) ;
   struct bfd_target  const  *(*_bfd_check_format[4])(bfd * ) ;
   bfd_boolean (*_bfd_set_format[4])(bfd * ) ;
   bfd_boolean (*_bfd_write_contents[4])(bfd * ) ;
   bfd_boolean (*_close_and_cleanup)(bfd * ) ;
   bfd_boolean (*_bfd_free_cached_info)(bfd * ) ;
   bfd_boolean (*_new_section_hook)(bfd * , sec_ptr  ) ;
   bfd_boolean (*_bfd_get_section_contents)(bfd * , sec_ptr  , void * , file_ptr  ,
                                            bfd_size_type  ) ;
   bfd_boolean (*_bfd_get_section_contents_in_window)(bfd * , sec_ptr  , bfd_window * ,
                                                      file_ptr  , bfd_size_type  ) ;
   bfd_boolean (*_bfd_copy_private_bfd_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_merge_private_bfd_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_init_private_section_data)(bfd * , sec_ptr  , bfd * , sec_ptr  ,
                                                 struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_copy_private_section_data)(bfd * , sec_ptr  , bfd * , sec_ptr  ) ;
   bfd_boolean (*_bfd_copy_private_symbol_data)(bfd * , asymbol * , bfd * , asymbol * ) ;
   bfd_boolean (*_bfd_copy_private_header_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_set_private_flags)(bfd * , flagword  ) ;
   bfd_boolean (*_bfd_print_private_bfd_data)(bfd * , void * ) ;
   char *(*_core_file_failing_command)(bfd * ) ;
   int (*_core_file_failing_signal)(bfd * ) ;
   bfd_boolean (*_core_file_matches_executable_p)(bfd * , bfd * ) ;
   int (*_core_file_pid)(bfd * ) ;
   bfd_boolean (*_bfd_slurp_armap)(bfd * ) ;
   bfd_boolean (*_bfd_slurp_extended_name_table)(bfd * ) ;
   bfd_boolean (*_bfd_construct_extended_name_table)(bfd * , char ** , bfd_size_type * ,
                                                     char const   ** ) ;
   void (*_bfd_truncate_arname)(bfd * , char const   * , char * ) ;
   bfd_boolean (*write_armap)(bfd * , unsigned int  , struct orl * , unsigned int  ,
                              int  ) ;
   void *(*_bfd_read_ar_hdr_fn)(bfd * ) ;
   bfd_boolean (*_bfd_write_ar_hdr_fn)(bfd * , bfd * ) ;
   bfd *(*openr_next_archived_file)(bfd * , bfd * ) ;
   bfd *(*_bfd_get_elt_at_index)(bfd * , symindex  ) ;
   int (*_bfd_stat_arch_elt)(bfd * , struct stat * ) ;
   bfd_boolean (*_bfd_update_armap_timestamp)(bfd * ) ;
   long (*_bfd_get_symtab_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_symtab)(bfd * , struct bfd_symbol ** ) ;
   struct bfd_symbol *(*_bfd_make_empty_symbol)(bfd * ) ;
   void (*_bfd_print_symbol)(bfd * , void * , struct bfd_symbol * , bfd_print_symbol_type  ) ;
   void (*_bfd_get_symbol_info)(bfd * , struct bfd_symbol * , symbol_info * ) ;
   bfd_boolean (*_bfd_is_local_label_name)(bfd * , char const   * ) ;
   bfd_boolean (*_bfd_is_target_special_symbol)(bfd * , asymbol * ) ;
   alent *(*_get_lineno)(bfd * , struct bfd_symbol * ) ;
   bfd_boolean (*_bfd_find_nearest_line)(bfd * , struct bfd_section * , struct bfd_symbol ** ,
                                         bfd_vma  , char const   ** , char const   ** ,
                                         unsigned int * ) ;
   bfd_boolean (*_bfd_find_nearest_line_discriminator)(bfd * , struct bfd_section * ,
                                                       struct bfd_symbol ** , bfd_vma  ,
                                                       char const   ** , char const   ** ,
                                                       unsigned int * , unsigned int * ) ;
   bfd_boolean (*_bfd_find_line)(bfd * , struct bfd_symbol ** , struct bfd_symbol * ,
                                 char const   ** , unsigned int * ) ;
   bfd_boolean (*_bfd_find_inliner_info)(bfd * , char const   ** , char const   ** ,
                                         unsigned int * ) ;
   asymbol *(*_bfd_make_debug_symbol)(bfd * , void * , unsigned long size ) ;
   long (*_read_minisymbols)(bfd * , bfd_boolean  , void ** , unsigned int * ) ;
   asymbol *(*_minisymbol_to_symbol)(bfd * , bfd_boolean  , void const   * , asymbol * ) ;
   long (*_get_reloc_upper_bound)(bfd * , sec_ptr  ) ;
   long (*_bfd_canonicalize_reloc)(bfd * , sec_ptr  , arelent ** , struct bfd_symbol ** ) ;
   reloc_howto_type *(*reloc_type_lookup)(bfd * , bfd_reloc_code_real_type  ) ;
   reloc_howto_type *(*reloc_name_lookup)(bfd * , char const   * ) ;
   bfd_boolean (*_bfd_set_arch_mach)(bfd * , enum bfd_architecture  , unsigned long  ) ;
   bfd_boolean (*_bfd_set_section_contents)(bfd * , sec_ptr  , void const   * , file_ptr  ,
                                            bfd_size_type  ) ;
   int (*_bfd_sizeof_headers)(bfd * , struct bfd_link_info * ) ;
   bfd_byte *(*_bfd_get_relocated_section_contents)(bfd * , struct bfd_link_info * ,
                                                    struct bfd_link_order * , bfd_byte * ,
                                                    bfd_boolean  , struct bfd_symbol ** ) ;
   bfd_boolean (*_bfd_relax_section)(bfd * , struct bfd_section * , struct bfd_link_info * ,
                                     bfd_boolean * ) ;
   struct bfd_link_hash_table *(*_bfd_link_hash_table_create)(bfd * ) ;
   void (*_bfd_link_hash_table_free)(struct bfd_link_hash_table * ) ;
   bfd_boolean (*_bfd_link_add_symbols)(bfd * , struct bfd_link_info * ) ;
   void (*_bfd_link_just_syms)(asection * , struct bfd_link_info * ) ;
   void (*_bfd_copy_link_hash_symbol_type)(bfd * , struct bfd_link_hash_entry * ,
                                           struct bfd_link_hash_entry * ) ;
   bfd_boolean (*_bfd_final_link)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_link_split_section)(bfd * , struct bfd_section * ) ;
   bfd_boolean (*_bfd_gc_sections)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_lookup_section_flags)(struct bfd_link_info * , struct flag_info * ,
                                            asection * ) ;
   bfd_boolean (*_bfd_merge_sections)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_is_group_section)(bfd * , struct bfd_section  const  * ) ;
   bfd_boolean (*_bfd_discard_group)(bfd * , struct bfd_section * ) ;
   bfd_boolean (*_section_already_linked)(bfd * , asection * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_define_common_symbol)(bfd * , struct bfd_link_info * , struct bfd_link_hash_entry * ) ;
   long (*_bfd_get_dynamic_symtab_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_dynamic_symtab)(bfd * , struct bfd_symbol ** ) ;
   long (*_bfd_get_synthetic_symtab)(bfd * , long  , struct bfd_symbol ** , long  ,
                                     struct bfd_symbol ** , struct bfd_symbol ** ) ;
   long (*_bfd_get_dynamic_reloc_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_dynamic_reloc)(bfd * , arelent ** , struct bfd_symbol ** ) ;
   struct bfd_target  const  *alternative_target ;
   void const   *backend_data ;
};
#line 141 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Sym_441262567 {
   unsigned char st_name[4] ;
   unsigned char st_value[4] ;
   unsigned char st_size[4] ;
   unsigned char st_info[1] ;
   unsigned char st_other[1] ;
   unsigned char st_shndx[2] ;
};
#line 141 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Sym_441262567 Elf32_External_Sym;
#line 150 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Sym_441262568 {
   unsigned char st_name[4] ;
   unsigned char st_info[1] ;
   unsigned char st_other[1] ;
   unsigned char st_shndx[2] ;
   unsigned char st_value[8] ;
   unsigned char st_size[8] ;
};
#line 150 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Sym_441262568 Elf64_External_Sym;
#line 159 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Sym_Shndx_184927680 {
   unsigned char est_shndx[4] ;
};
#line 159 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Sym_Shndx_184927680 Elf_External_Sym_Shndx;
#line 165 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Note_328036297 {
   unsigned char namesz[4] ;
   unsigned char descsz[4] ;
   unsigned char type[4] ;
   char name[1] ;
};
#line 165 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Note_328036297 Elf_External_Note;
#line 173 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Rel_443125039 {
   unsigned char r_offset[4] ;
   unsigned char r_info[4] ;
};
#line 173 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Rel_443125039 Elf32_External_Rel;
#line 178 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Rela_948896363 {
   unsigned char r_offset[4] ;
   unsigned char r_info[4] ;
   unsigned char r_addend[4] ;
};
#line 178 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Rela_948896363 Elf32_External_Rela;
#line 184 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Rel_948896364 {
   unsigned char r_offset[8] ;
   unsigned char r_info[8] ;
};
#line 184 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Rel_948896364 Elf64_External_Rel;
#line 189 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Rela_948896365 {
   unsigned char r_offset[8] ;
   unsigned char r_info[8] ;
   unsigned char r_addend[8] ;
};
#line 189 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Rela_948896365 Elf64_External_Rela;
#line 197 "./../include/elf/external.h"
union __anonunion_d_un_948896366 {
   unsigned char d_val[4] ;
   unsigned char d_ptr[4] ;
};
#line 197 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Dyn_590811386 {
   unsigned char d_tag[4] ;
   union __anonunion_d_un_948896366 d_un ;
};
#line 197 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Dyn_590811386 Elf32_External_Dyn;
#line 205 "./../include/elf/external.h"
union __anonunion_d_un_948896367 {
   unsigned char d_val[8] ;
   unsigned char d_ptr[8] ;
};
#line 205 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Dyn_214159709 {
   unsigned char d_tag[8] ;
   union __anonunion_d_un_948896367 d_un ;
};
#line 205 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Dyn_214159709 Elf64_External_Dyn;
#line 219 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verdef_834899447 {
   unsigned char vd_version[2] ;
   unsigned char vd_flags[2] ;
   unsigned char vd_ndx[2] ;
   unsigned char vd_cnt[2] ;
   unsigned char vd_hash[4] ;
   unsigned char vd_aux[4] ;
   unsigned char vd_next[4] ;
};
#line 219 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verdef_834899447 Elf_External_Verdef;
#line 231 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verdaux_948896368 {
   unsigned char vda_name[4] ;
   unsigned char vda_next[4] ;
};
#line 231 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verdaux_948896368 Elf_External_Verdaux;
#line 238 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verneed_948896369 {
   unsigned char vn_version[2] ;
   unsigned char vn_cnt[2] ;
   unsigned char vn_file[4] ;
   unsigned char vn_aux[4] ;
   unsigned char vn_next[4] ;
};
#line 238 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verneed_948896369 Elf_External_Verneed;
#line 248 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Vernaux_948896370 {
   unsigned char vna_hash[4] ;
   unsigned char vna_flags[2] ;
   unsigned char vna_other[2] ;
   unsigned char vna_name[4] ;
   unsigned char vna_next[4] ;
};
#line 248 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Vernaux_948896370 Elf_External_Vernaux;
#line 259 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Versym_948896371 {
   unsigned char vs_vers[2] ;
} __attribute__((__packed__)) ;
#line 259 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Versym_948896371 Elf_External_Versym;
#line 264 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Syminfo_948896372 {
   unsigned char si_boundto[2] ;
   unsigned char si_flags[2] ;
};
#line 264 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Syminfo_948896372 Elf_External_Syminfo;
#line 68 "./../include/elf/internal.h"
struct elf_internal_ehdr {
   unsigned char e_ident[16] ;
   bfd_vma e_entry ;
   bfd_size_type e_phoff ;
   bfd_size_type e_shoff ;
   unsigned long e_version ;
   unsigned long e_flags ;
   unsigned short e_type ;
   unsigned short e_machine ;
   unsigned int e_ehsize ;
   unsigned int e_phentsize ;
   unsigned int e_phnum ;
   unsigned int e_shentsize ;
   unsigned int e_shnum ;
   unsigned int e_shstrndx ;
};
#line 68 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr Elf_Internal_Ehdr;
#line 87 "./../include/elf/internal.h"
struct elf_internal_phdr {
   unsigned long p_type ;
   unsigned long p_flags ;
   bfd_vma p_offset ;
   bfd_vma p_vaddr ;
   bfd_vma p_paddr ;
   bfd_vma p_filesz ;
   bfd_vma p_memsz ;
   bfd_vma p_align ;
};
#line 98 "./../include/elf/internal.h"
typedef struct elf_internal_phdr Elf_Internal_Phdr;
#line 102 "./../include/elf/internal.h"
struct elf_internal_shdr {
   unsigned int sh_name ;
   unsigned int sh_type ;
   bfd_vma sh_flags ;
   bfd_vma sh_addr ;
   file_ptr sh_offset ;
   bfd_size_type sh_size ;
   unsigned int sh_link ;
   unsigned int sh_info ;
   bfd_vma sh_addralign ;
   bfd_size_type sh_entsize ;
   asection *bfd_section ;
   unsigned char *contents ;
};
#line 102 "./../include/elf/internal.h"
typedef struct elf_internal_shdr Elf_Internal_Shdr;
#line 121 "./../include/elf/internal.h"
struct elf_internal_sym {
   bfd_vma st_value ;
   bfd_vma st_size ;
   unsigned long st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   unsigned char st_target_internal ;
   unsigned int st_shndx ;
};
#line 131 "./../include/elf/internal.h"
typedef struct elf_internal_sym Elf_Internal_Sym;
#line 135 "./../include/elf/internal.h"
struct elf_internal_note {
   unsigned long namesz ;
   unsigned long descsz ;
   unsigned long type ;
   char *namedata ;
   char *descdata ;
   bfd_vma descpos ;
};
#line 135 "./../include/elf/internal.h"
typedef struct elf_internal_note Elf_Internal_Note;
#line 146 "./../include/elf/internal.h"
struct elf_internal_rela {
   bfd_vma r_offset ;
   bfd_vma r_info ;
   bfd_vma r_addend ;
};
#line 146 "./../include/elf/internal.h"
typedef struct elf_internal_rela Elf_Internal_Rela;
#line 154 "./../include/elf/internal.h"
union __anonunion_d_un_138939745 {
   bfd_vma d_val ;
   bfd_vma d_ptr ;
};
#line 154 "./../include/elf/internal.h"
struct elf_internal_dyn {
   bfd_vma d_tag ;
   union __anonunion_d_un_138939745 d_un ;
};
#line 154 "./../include/elf/internal.h"
typedef struct elf_internal_dyn Elf_Internal_Dyn;
#line 166
struct elf_internal_verdaux ;
#line 166 "./../include/elf/internal.h"
struct elf_internal_verdef {
   unsigned short vd_version ;
   unsigned short vd_flags ;
   unsigned short vd_ndx ;
   unsigned short vd_cnt ;
   unsigned long vd_hash ;
   unsigned long vd_aux ;
   unsigned long vd_next ;
   bfd *vd_bfd ;
   char const   *vd_nodename ;
   struct elf_internal_verdef *vd_nextdef ;
   struct elf_internal_verdaux *vd_auxptr ;
   unsigned int vd_exp_refno ;
};
#line 166 "./../include/elf/internal.h"
typedef struct elf_internal_verdef Elf_Internal_Verdef;
#line 186 "./../include/elf/internal.h"
struct elf_internal_verdaux {
   unsigned long vda_name ;
   unsigned long vda_next ;
   char const   *vda_nodename ;
   struct elf_internal_verdaux *vda_nextptr ;
};
#line 186 "./../include/elf/internal.h"
typedef struct elf_internal_verdaux Elf_Internal_Verdaux;
#line 198
struct elf_internal_vernaux ;
#line 198 "./../include/elf/internal.h"
struct elf_internal_verneed {
   unsigned short vn_version ;
   unsigned short vn_cnt ;
   unsigned long vn_file ;
   unsigned long vn_aux ;
   unsigned long vn_next ;
   bfd *vn_bfd ;
   char const   *vn_filename ;
   struct elf_internal_vernaux *vn_auxptr ;
   struct elf_internal_verneed *vn_nextref ;
};
#line 198 "./../include/elf/internal.h"
typedef struct elf_internal_verneed Elf_Internal_Verneed;
#line 215 "./../include/elf/internal.h"
struct elf_internal_vernaux {
   unsigned long vna_hash ;
   unsigned short vna_flags ;
   unsigned short vna_other ;
   unsigned long vna_name ;
   unsigned long vna_next ;
   char const   *vna_nodename ;
   struct elf_internal_vernaux *vna_nextptr ;
};
#line 215 "./../include/elf/internal.h"
typedef struct elf_internal_vernaux Elf_Internal_Vernaux;
#line 236 "./../include/elf/internal.h"
struct __anonstruct_Elf_Internal_Syminfo_674933912 {
   unsigned short si_boundto ;
   unsigned short si_flags ;
};
#line 236 "./../include/elf/internal.h"
typedef struct __anonstruct_Elf_Internal_Syminfo_674933912 Elf_Internal_Syminfo;
#line 218 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_IMAGE_FIXUP_948896375 {
   unsigned char fixup_offset[8] ;
   unsigned char type[4] ;
   unsigned char fixup_seg[4] ;
   unsigned char addend[8] ;
   unsigned char symvec_index[4] ;
   unsigned char data_type[4] ;
};
#line 218 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_IMAGE_FIXUP_948896375 Elf64_External_VMS_IMAGE_FIXUP;
#line 228 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_IMAGE_RELA_948896376 {
   unsigned char rela_offset[8] ;
   unsigned char type[4] ;
   unsigned char rela_seg[4] ;
   unsigned char addend[8] ;
   unsigned char sym_offset[8] ;
   unsigned char sym_seg[4] ;
   unsigned char fill_1[4] ;
};
#line 228 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_IMAGE_RELA_948896376 Elf64_External_VMS_IMAGE_RELA;
#line 241 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_Note_948896377 {
   unsigned char namesz[8] ;
   unsigned char descsz[8] ;
   unsigned char type[8] ;
   char name[1] ;
};
#line 241 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_Note_948896377 Elf64_External_VMS_Note;
#line 437 "./../include/elf/mips.h"
struct __anonstruct_Elf32_Lib_725717072 {
   unsigned long l_name ;
   unsigned long l_time_stamp ;
   unsigned long l_checksum ;
   unsigned long l_version ;
   unsigned long l_flags ;
};
#line 437 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_Lib_725717072 Elf32_Lib;
#line 452 "./../include/elf/mips.h"
struct __anonstruct_Elf32_External_Lib_948896379 {
   unsigned char l_name[4] ;
   unsigned char l_time_stamp[4] ;
   unsigned char l_checksum[4] ;
   unsigned char l_version[4] ;
   unsigned char l_flags[4] ;
};
#line 452 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_External_Lib_948896379 Elf32_External_Lib;
#line 485 "./../include/elf/mips.h"
typedef unsigned long Elf32_Conflict;
#line 486 "./../include/elf/mips.h"
typedef unsigned char Elf32_External_Conflict[4];
#line 489 "./../include/elf/mips.h"
typedef unsigned char Elf64_External_Conflict[8];
#line 535 "./../include/elf/mips.h"
struct __anonstruct_Elf32_RegInfo_948896382 {
   unsigned long ri_gprmask ;
   unsigned long ri_cprmask[4] ;
   long ri_gp_value ;
};
#line 535 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_RegInfo_948896382 Elf32_RegInfo;
#line 546 "./../include/elf/mips.h"
struct __anonstruct_Elf32_External_RegInfo_948896383 {
   unsigned char ri_gprmask[4] ;
   unsigned char ri_cprmask[4][4] ;
   unsigned char ri_gp_value[4] ;
};
#line 546 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_External_RegInfo_948896383 Elf32_External_RegInfo;
#line 958 "./../include/elf/mips.h"
struct __anonstruct_Elf_External_Options_948896386 {
   unsigned char kind[1] ;
   unsigned char size[1] ;
   unsigned char section[2] ;
   unsigned char info[4] ;
};
#line 958 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf_External_Options_948896386 Elf_External_Options;
#line 970 "./../include/elf/mips.h"
struct __anonstruct_Elf_Internal_Options_723972842 {
   unsigned char kind ;
   unsigned char size ;
   unsigned short section ;
   unsigned long info ;
};
#line 970 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf_Internal_Options_723972842 Elf_Internal_Options;
#line 1028 "./../include/elf/mips.h"
struct __anonstruct_Elf64_External_RegInfo_948896387 {
   unsigned char ri_gprmask[4] ;
   unsigned char ri_pad[4] ;
   unsigned char ri_cprmask[4][4] ;
   unsigned char ri_gp_value[8] ;
};
#line 1028 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf64_External_RegInfo_948896387 Elf64_External_RegInfo;
#line 1040 "./../include/elf/mips.h"
struct __anonstruct_Elf64_Internal_RegInfo_659547826 {
   unsigned long ri_gprmask ;
   unsigned long ri_pad ;
   unsigned long ri_cprmask[4] ;
   bfd_vma ri_gp_value ;
};
#line 1040 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf64_Internal_RegInfo_659547826 Elf64_Internal_RegInfo;
#line 82 "./../include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 211 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct group_list {
   struct group_list *next ;
   unsigned int section_index ;
};
#line 217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct group {
   struct group_list *root ;
   unsigned int group_index ;
};
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
typedef unsigned char dump_type;
#line 238 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct dump_list_entry {
   char *name ;
   dump_type type ;
   struct dump_list_entry *next ;
};
#line 261
enum print_mode {
    HEX = 0,
    DEC = 1,
    DEC_5 = 2,
    UNSIGNED = 3,
    PREFIX_HEX = 4,
    FULL_HEX = 5,
    LONG_HEX = 6
} ;
#line 261 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
typedef enum print_mode print_mode;
#line 4513 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_flags_713894858 {
   char const   *str ;
   int len ;
};
#line 5464 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct ia64_vms_dynfixup {
   bfd_vma needed_ident ;
   bfd_vma needed ;
   bfd_vma fixup_needed ;
   bfd_vma fixup_rela_cnt ;
   bfd_vma fixup_rela_off ;
};
#line 5475 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct ia64_vms_dynimgrela {
   bfd_vma img_rela_cnt ;
   bfd_vma img_rela_off ;
};
#line 5643 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_dynamic_relocations_602783530 {
   char const   *name ;
   int reloc ;
   int size ;
   int rela ;
};
#line 5813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct absaddr {
   unsigned short section ;
   bfd_vma offset ;
};
#line 5824 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct ia64_unw_table_entry {
   struct absaddr start ;
   struct absaddr end ;
   struct absaddr info ;
};
#line 5831 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct ia64_unw_aux_info {
   struct ia64_unw_table_entry *table ;
   unsigned long table_len ;
   unsigned char *info ;
   unsigned long info_size ;
   bfd_vma info_addr ;
   bfd_vma seg_base ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 6205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct hppa_unw_table_entry {
   struct absaddr start ;
   struct absaddr end ;
   unsigned int Cannot_unwind : 1 ;
   unsigned int Millicode : 1 ;
   unsigned int Millicode_save_sr0 : 1 ;
   unsigned int Region_description : 2 ;
   unsigned int reserved1 : 1 ;
   unsigned int Entry_SR : 1 ;
   unsigned int Entry_FR : 4 ;
   unsigned int Entry_GR : 5 ;
   unsigned int Args_stored : 1 ;
   unsigned int Variable_Frame : 1 ;
   unsigned int Separate_Package_Body : 1 ;
   unsigned int Frame_Extension_Millicode : 1 ;
   unsigned int Stack_Overflow_Check : 1 ;
   unsigned int Two_Instruction_SP_Increment : 1 ;
   unsigned int Ada_Region : 1 ;
   unsigned int cxx_info : 1 ;
   unsigned int cxx_try_catch : 1 ;
   unsigned int sched_entry_seq : 1 ;
   unsigned int reserved2 : 1 ;
   unsigned int Save_SP : 1 ;
   unsigned int Save_RP : 1 ;
   unsigned int Save_MRP_in_frame : 1 ;
   unsigned int extn_ptr_defined : 1 ;
   unsigned int Cleanup_defined : 1 ;
   unsigned int MPE_XL_interrupt_marker : 1 ;
   unsigned int HP_UX_interrupt_marker : 1 ;
   unsigned int Large_frame : 1 ;
   unsigned int Pseudo_SP_Set : 1 ;
   unsigned int reserved4 : 1 ;
   unsigned int Total_frame_size : 27 ;
};
#line 6242 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct hppa_unw_aux_info {
   struct hppa_unw_table_entry *table ;
   unsigned long table_len ;
   bfd_vma seg_base ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 6536 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct arm_section {
   unsigned char *data ;
   Elf_Internal_Shdr *sec ;
   Elf_Internal_Rela *rela ;
   unsigned long nrelas ;
   unsigned int rel_type ;
   Elf_Internal_Rela *next_rela ;
};
#line 6546 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct arm_unw_aux_info {
   FILE *file ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 7072 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_regpos_973678109 {
   unsigned int offset ;
   unsigned int reg ;
};
#line 7492 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct unwind_handler {
   int machtype ;
   void (*handler)(FILE * ) ;
};
#line 7600 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_flags_85572036 {
   long bit ;
   char const   *str ;
};
#line 11307 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_arm_attr_public_tag_862478845 {
   int tag ;
   char const   *name ;
   int type ;
   char const   **table ;
};
#line 11307 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
typedef struct __anonstruct_arm_attr_public_tag_862478845 arm_attr_public_tag;
#line 12487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
struct __anonstruct_l_flags_vals_973678110 {
   char const   *name ;
   int bit ;
};
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 301 "./../include/libiberty.h"
void *xmalloc(size_t size )  __attribute__((__malloc__)) ;
#line 320
char *xstrndup(char const   *s , size_t n )  __attribute__((__malloc__)) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrndup.c"
char *xstrndup(char const   *s , size_t n )  __attribute__((__malloc__)) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrndup.c"
char *xstrndup(char const   *s , size_t n ) 
{ 
  char *result ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 51
  tmp___0 = strlen(s);
#line 51
  len = tmp___0;
  }
#line 53
  if (n < len) {
#line 54
    len = n;
  }
  {
#line 56
  tmp___1 = xmalloc(sizeof(char ) * (len + 1UL));
#line 56
  result = (char *)tmp___1;
#line 58
  *(result + len) = (char )'\000';
#line 59
  tmp___2 = memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)s,
                   len);
  }
#line 59
  return ((char *)tmp___2);
}
}
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 259 "./../include/libiberty.h"
char *xstrerror(int errnum ) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrerror.c"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrerror.c"
static char xstrerror_buf[sizeof("undocumented error #%d") + 20UL]  ;
#line 53 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrerror.c"
char *xstrerror(int errnum ) 
{ 
  char *errstr ;

  {
  {
#line 69
  errstr = strerror(errnum);
  }
#line 73
  if (! errstr) {
    {
#line 75
    sprintf((char */* __restrict  */)(xstrerror_buf), (char const   */* __restrict  */)"undocumented error #%d",
            errnum);
#line 76
    errstr = xstrerror_buf;
    }
  }
#line 78
  return (errstr);
}
}
#line 316 "./../include/libiberty.h"
char *xstrdup(char const   *s )  __attribute__((__malloc__)) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrdup.c"
char *xstrdup(char const   *s )  __attribute__((__malloc__)) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xstrdup.c"
char *xstrdup(char const   *s ) 
{ 
  register size_t len ;
  size_t tmp___0 ;
  register char *ret ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 33
  tmp___0 = strlen(s);
#line 33
  len = tmp___0 + 1UL;
#line 34
  tmp___1 = xmalloc(sizeof(char ) * len);
#line 34
  ret = (char *)tmp___1;
#line 35
  tmp___2 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)s,
                   len);
  }
#line 35
  return ((char *)tmp___2);
}
}
#line 312 "./../include/libiberty.h"
void *xcalloc(size_t nelem , size_t elsize )  __attribute__((__malloc__)) ;
#line 324
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size )  __attribute__((__malloc__)) ;
#line 34 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmemdup.c"
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size )  __attribute__((__malloc__)) ;
#line 34 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmemdup.c"
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size ) 
{ 
  void *output ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 37
  tmp___0 = xcalloc((size_t )1, alloc_size);
#line 37
  output = tmp___0;
#line 38
  tmp___1 = memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)input,
                   copy_size);
  }
#line 38
  return (tmp___1);
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 288 "./../include/libiberty.h"
 __attribute__((__noreturn__)) void xexit(int code ) ;
#line 292
void xmalloc_set_program_name(char const   *s ) ;
#line 295
 __attribute__((__noreturn__)) void xmalloc_failed(size_t size ) ;
#line 307
void *xrealloc(void *oldmem , size_t size ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 1044 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta ) ;
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
static char const   *name  =    "";
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
static char *first_break  =    (char *)((void *)0);
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
void xmalloc_set_program_name(char const   *s ) 
{ 
  void *tmp___0 ;

  {
#line 108
  name = s;
#line 111
  if ((unsigned long )first_break == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___0 = sbrk((intptr_t )0);
#line 112
    first_break = (char *)tmp___0;
    }
  }
#line 114
  return;
}
}
#line 120
extern char **environ ;
#line 116
 __attribute__((__noreturn__)) void xmalloc_failed(size_t size ) ;
#line 116 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
void xmalloc_failed(size_t size ) 
{ 
  size_t allocated ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 123
  if ((unsigned long )first_break != (unsigned long )((void *)0)) {
    {
#line 124
    tmp___0 = sbrk((intptr_t )0);
#line 124
    allocated = (size_t )((char *)tmp___0 - first_break);
    }
  } else {
    {
#line 126
    tmp___1 = sbrk((intptr_t )0);
#line 126
    allocated = (size_t )((char *)tmp___1 - (char *)(& environ));
    }
  }
#line 127
  if (*name) {
#line 127
    tmp___2 = ": ";
  } else {
#line 127
    tmp___2 = "";
  }
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n",
          name, tmp___2, size, allocated);
#line 137
  xexit(1);
  }
}
}
#line 140
void *xmalloc(size_t size )  __attribute__((__malloc__)) ;
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  void *newmem ;

  {
#line 145
  if (size == 0UL) {
#line 146
    size = (size_t )1;
  }
  {
#line 147
  newmem = malloc(size);
  }
#line 148
  if (! newmem) {
    {
#line 149
    xmalloc_failed(size);
    }
  }
#line 151
  return (newmem);
}
}
#line 154
void *xcalloc(size_t nelem , size_t elsize )  __attribute__((__malloc__)) ;
#line 154 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
void *xcalloc(size_t nelem , size_t elsize ) 
{ 
  void *newmem ;

  {
#line 159
  if (nelem == 0UL) {
#line 160
    elsize = (size_t )1;
#line 160
    nelem = elsize;
  } else
#line 159
  if (elsize == 0UL) {
#line 160
    elsize = (size_t )1;
#line 160
    nelem = elsize;
  }
  {
#line 162
  newmem = calloc(nelem, elsize);
  }
#line 163
  if (! newmem) {
    {
#line 164
    xmalloc_failed(nelem * elsize);
    }
  }
#line 166
  return (newmem);
}
}
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xmalloc.c"
void *xrealloc(void *oldmem , size_t size ) 
{ 
  void *newmem ;

  {
#line 174
  if (size == 0UL) {
#line 175
    size = (size_t )1;
  }
#line 176
  if (! oldmem) {
    {
#line 177
    newmem = malloc(size);
    }
  } else {
    {
#line 179
    newmem = realloc(oldmem, size);
    }
  }
#line 180
  if (! newmem) {
    {
#line 181
    xmalloc_failed(size);
    }
  }
#line 183
  return (newmem);
}
}
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 44 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xexit.c"
void (*_xexit_cleanup)(void)  ;
#line 46
 __attribute__((__noreturn__)) void xexit(int code ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xexit.c"
void xexit(int code ) 
{ 


  {
#line 49
  if ((unsigned long )_xexit_cleanup != (unsigned long )((void *)0)) {
    {
#line 50
    (*_xexit_cleanup)();
    }
  }
  {
#line 51
  exit(code);
  }
}
}
#line 284 "./../include/libiberty.h"
int xatexit(void (*fn)(void) ) ;
#line 43 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
static void xatexit_cleanup(void) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
static struct xatexit xatexit_first  ;
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
static struct xatexit *xatexit_head  =    & xatexit_first;
#line 66 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
int xatexit(void (*fn)(void) ) 
{ 
  register struct xatexit *p ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 72
  if (! _xexit_cleanup) {
#line 73
    _xexit_cleanup = & xatexit_cleanup;
  }
#line 75
  p = xatexit_head;
#line 76
  if (p->ind >= 32) {
    {
#line 78
    tmp___0 = malloc(sizeof(*p));
#line 78
    p = (struct xatexit *)tmp___0;
    }
#line 78
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 79
      return (-1);
    }
#line 80
    p->ind = 0;
#line 81
    p->next = xatexit_head;
#line 82
    xatexit_head = p;
  }
#line 84
  tmp___1 = p->ind;
#line 84
  (p->ind) ++;
#line 84
  p->fns[tmp___1] = fn;
#line 85
  return (0);
}
}
#line 90 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./xatexit.c"
static void xatexit_cleanup(void) 
{ 
  register struct xatexit *p ;
  register int n ;

  {
#line 96
  p = xatexit_head;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! p) {
#line 96
      goto while_break;
    }
#line 97
    n = p->ind;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      n --;
#line 97
      if (! (n >= 0)) {
#line 97
        goto while_break___0;
      }
      {
#line 98
      (*(p->fns[n]))();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 96
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 828 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 259 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 237 "./../include/libiberty.h"
int unlink_if_ordinary(char const   *name___0 ) ;
#line 62 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./unlink-if-ordinary.c"
int unlink_if_ordinary(char const   *name___0 ) 
{ 
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 67
  tmp___1 = lstat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
  }
#line 67
  if (tmp___1 == 0) {
#line 67
    if ((st.st_mode & 61440U) == 32768U) {
      {
#line 69
      tmp___0 = unlink(name___0);
      }
#line 69
      return (tmp___0);
    } else
#line 67
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 69
      tmp___0 = unlink(name___0);
      }
#line 69
      return (tmp___0);
    }
  }
#line 71
  return (1);
}
}
#line 30 "./../include/timeval-utils.h"
void timeval_add(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) ;
#line 33
void timeval_sub(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./timeval-utils.c"
void timeval_add(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) 
{ 


  {
#line 56
  result->tv_sec = (__time_t )(a->tv_sec + b->tv_sec);
#line 57
  result->tv_usec = (__suseconds_t )(a->tv_usec + b->tv_usec);
#line 58
  if (result->tv_usec >= 1000000L) {
#line 60
    (result->tv_sec) ++;
#line 61
    result->tv_usec -= 1000000L;
  }
#line 63
  return;
}
}
#line 76 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./timeval-utils.c"
void timeval_sub(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) 
{ 


  {
#line 80
  result->tv_sec = (__time_t )(a->tv_sec - b->tv_sec);
#line 81
  result->tv_usec = (__suseconds_t )(a->tv_usec - b->tv_usec);
#line 82
  if (result->tv_usec < 0L) {
#line 84
    (result->tv_sec) --;
#line 85
    result->tv_usec += 1000000L;
  }
#line 87
  return;
}
}
#line 264 "./../include/libiberty.h"
int signo_max(void) ;
#line 276
char const   *strsigno(int signo ) ;
#line 280
int strtosigno(char const   *name___0 ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static void init_signal_tables(void) ;
#line 78 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static struct signal_info  const  signal_table[34]  = 
#line 78
  {      {(int const   )1, (char const   */* const  */)"SIGHUP"}, 
        {(int const   )2, (char const   */* const  */)"SIGINT"}, 
        {(int const   )3, (char const   */* const  */)"SIGQUIT"}, 
        {(int const   )4, (char const   */* const  */)"SIGILL"}, 
        {(int const   )5, (char const   */* const  */)"SIGTRAP"}, 
        {(int const   )6, (char const   */* const  */)"SIGIOT"}, 
        {(int const   )6, (char const   */* const  */)"SIGABRT"}, 
        {(int const   )8, (char const   */* const  */)"SIGFPE"}, 
        {(int const   )9, (char const   */* const  */)"SIGKILL"}, 
        {(int const   )7, (char const   */* const  */)"SIGBUS"}, 
        {(int const   )11, (char const   */* const  */)"SIGSEGV"}, 
        {(int const   )31, (char const   */* const  */)"SIGSYS"}, 
        {(int const   )13, (char const   */* const  */)"SIGPIPE"}, 
        {(int const   )14, (char const   */* const  */)"SIGALRM"}, 
        {(int const   )15, (char const   */* const  */)"SIGTERM"}, 
        {(int const   )10, (char const   */* const  */)"SIGUSR1"}, 
        {(int const   )12, (char const   */* const  */)"SIGUSR2"}, 
        {(int const   )17, (char const   */* const  */)"SIGCLD"}, 
        {(int const   )17, (char const   */* const  */)"SIGCHLD"}, 
        {(int const   )30, (char const   */* const  */)"SIGPWR"}, 
        {(int const   )28, (char const   */* const  */)"SIGWINCH"}, 
        {(int const   )23, (char const   */* const  */)"SIGURG"}, 
        {(int const   )29, (char const   */* const  */)"SIGIO"}, 
        {(int const   )29, (char const   */* const  */)"SIGPOLL"}, 
        {(int const   )19, (char const   */* const  */)"SIGSTOP"}, 
        {(int const   )20, (char const   */* const  */)"SIGTSTP"}, 
        {(int const   )18, (char const   */* const  */)"SIGCONT"}, 
        {(int const   )21, (char const   */* const  */)"SIGTTIN"}, 
        {(int const   )22, (char const   */* const  */)"SIGTTOU"}, 
        {(int const   )26, (char const   */* const  */)"SIGVTALRM"}, 
        {(int const   )27, (char const   */* const  */)"SIGPROF"}, 
        {(int const   )24, (char const   */* const  */)"SIGXCPU"}, 
        {(int const   )25, (char const   */* const  */)"SIGXFSZ"}, 
        {(int const   )0, (char const   */* const  */)((void *)0)}};
#line 228 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static char const   **signal_names  ;
#line 229 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static int num_signal_names  =    0;
#line 247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static int sys_nsig  =    65;
#line 286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static void init_signal_tables(void) 
{ 
  struct signal_info  const  *eip ;
  int nbytes ;
  void *tmp___0 ;

  {
#line 295
  if (num_signal_names == 0) {
#line 297
    eip = signal_table;
    {
#line 297
    while (1) {
      while_continue: /* CIL Label */ ;
#line 297
      if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 297
        goto while_break;
      }
#line 299
      if (eip->value >= (int const   )num_signal_names) {
#line 301
        num_signal_names = (int )(eip->value + 1);
      }
#line 297
      eip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 309
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 311
    nbytes = (int )((unsigned long )num_signal_names * sizeof(char *));
#line 312
    tmp___0 = malloc((size_t )nbytes);
#line 312
    signal_names = (char const   **)tmp___0;
    }
#line 312
    if ((unsigned long )signal_names != (unsigned long )((void *)0)) {
      {
#line 314
      memset((void *)signal_names, 0, (size_t )nbytes);
#line 315
      eip = signal_table;
      }
      {
#line 315
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 315
        if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 315
          goto while_break___0;
        }
#line 317
        *(signal_names + eip->value) = (char const   *)eip->name;
#line 315
        eip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 343
  return;
}
}
#line 367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
int signo_max(void) 
{ 
  int maxsize___0 ;

  {
#line 372
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 374
    init_signal_tables();
    }
  }
#line 376
  if (sys_nsig > num_signal_names) {
#line 376
    maxsize___0 = sys_nsig;
  } else {
#line 376
    maxsize___0 = num_signal_names;
  }
#line 377
  return (maxsize___0 - 1);
}
}
#line 472 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
static char buf[32]  ;
#line 468 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
char const   *strsigno(int signo ) 
{ 
  char const   *name___0 ;

  {
#line 474
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 476
    init_signal_tables();
    }
  }
#line 479
  if (signo < 0) {
#line 482
    name___0 = (char const   *)((void *)0);
  } else
#line 479
  if (signo >= num_signal_names) {
#line 482
    name___0 = (char const   *)((void *)0);
  } else
#line 484
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 487
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Signal %d",
            signo);
#line 488
    name___0 = (char const   *)(buf);
    }
  } else
#line 484
  if ((unsigned long )*(signal_names + signo) == (unsigned long )((void *)0)) {
    {
#line 487
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Signal %d",
            signo);
#line 488
    name___0 = (char const   *)(buf);
    }
  } else {
#line 493
    name___0 = *(signal_names + signo);
  }
#line 496
  return (name___0);
}
}
#line 511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strsignal.c"
int strtosigno(char const   *name___0 ) 
{ 
  int signo ;
  int tmp___0 ;

  {
#line 514
  signo = 0;
#line 516
  if ((unsigned long )name___0 != (unsigned long )((void *)0)) {
#line 518
    if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
      {
#line 520
      init_signal_tables();
      }
    }
#line 522
    signo = 0;
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;
#line 522
      if (! (signo < num_signal_names)) {
#line 522
        goto while_break;
      }
#line 524
      if ((unsigned long )*(signal_names + signo) != (unsigned long )((void *)0)) {
        {
#line 524
        tmp___0 = strcmp(name___0, *(signal_names + signo));
        }
#line 524
        if (tmp___0 == 0) {
#line 527
          goto while_break;
        }
      }
#line 522
      signo ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 530
    if (signo == num_signal_names) {
#line 532
      signo = 0;
    }
  }
#line 535
  return (signo);
}
}
#line 246 "./../include/libiberty.h"
int errno_max(void) ;
#line 251
char const   *strerrno(int errnoval ) ;
#line 255
int strtoerrno(char const   *name___0 ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static void init_error_tables(void) ;
#line 74 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static struct error_info  const  error_table[122]  = 
#line 74
  {      {(int const   )1, (char const   */* const  */)"EPERM"}, 
        {(int const   )2, (char const   */* const  */)"ENOENT"}, 
        {(int const   )3, (char const   */* const  */)"ESRCH"}, 
        {(int const   )4, (char const   */* const  */)"EINTR"}, 
        {(int const   )5, (char const   */* const  */)"EIO"}, 
        {(int const   )6, (char const   */* const  */)"ENXIO"}, 
        {(int const   )7, (char const   */* const  */)"E2BIG"}, 
        {(int const   )8, (char const   */* const  */)"ENOEXEC"}, 
        {(int const   )9, (char const   */* const  */)"EBADF"}, 
        {(int const   )10, (char const   */* const  */)"ECHILD"}, 
        {(int const   )11, (char const   */* const  */)"EWOULDBLOCK"}, 
        {(int const   )11, (char const   */* const  */)"EAGAIN"}, 
        {(int const   )12, (char const   */* const  */)"ENOMEM"}, 
        {(int const   )13, (char const   */* const  */)"EACCES"}, 
        {(int const   )14, (char const   */* const  */)"EFAULT"}, 
        {(int const   )15, (char const   */* const  */)"ENOTBLK"}, 
        {(int const   )16, (char const   */* const  */)"EBUSY"}, 
        {(int const   )17, (char const   */* const  */)"EEXIST"}, 
        {(int const   )18, (char const   */* const  */)"EXDEV"}, 
        {(int const   )19, (char const   */* const  */)"ENODEV"}, 
        {(int const   )20, (char const   */* const  */)"ENOTDIR"}, 
        {(int const   )21, (char const   */* const  */)"EISDIR"}, 
        {(int const   )22, (char const   */* const  */)"EINVAL"}, 
        {(int const   )23, (char const   */* const  */)"ENFILE"}, 
        {(int const   )24, (char const   */* const  */)"EMFILE"}, 
        {(int const   )25, (char const   */* const  */)"ENOTTY"}, 
        {(int const   )26, (char const   */* const  */)"ETXTBSY"}, 
        {(int const   )27, (char const   */* const  */)"EFBIG"}, 
        {(int const   )28, (char const   */* const  */)"ENOSPC"}, 
        {(int const   )29, (char const   */* const  */)"ESPIPE"}, 
        {(int const   )30, (char const   */* const  */)"EROFS"}, 
        {(int const   )31, (char const   */* const  */)"EMLINK"}, 
        {(int const   )32, (char const   */* const  */)"EPIPE"}, 
        {(int const   )33, (char const   */* const  */)"EDOM"}, 
        {(int const   )34, (char const   */* const  */)"ERANGE"}, 
        {(int const   )42, (char const   */* const  */)"ENOMSG"}, 
        {(int const   )43, (char const   */* const  */)"EIDRM"}, 
        {(int const   )44, (char const   */* const  */)"ECHRNG"}, 
        {(int const   )45, (char const   */* const  */)"EL2NSYNC"}, 
        {(int const   )46, (char const   */* const  */)"EL3HLT"}, 
        {(int const   )47, (char const   */* const  */)"EL3RST"}, 
        {(int const   )48, (char const   */* const  */)"ELNRNG"}, 
        {(int const   )49, (char const   */* const  */)"EUNATCH"}, 
        {(int const   )50, (char const   */* const  */)"ENOCSI"}, 
        {(int const   )51, (char const   */* const  */)"EL2HLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLK"}, 
        {(int const   )37, (char const   */* const  */)"ENOLCK"}, 
        {(int const   )52, (char const   */* const  */)"EBADE"}, 
        {(int const   )53, (char const   */* const  */)"EBADR"}, 
        {(int const   )54, (char const   */* const  */)"EXFULL"}, 
        {(int const   )55, (char const   */* const  */)"ENOANO"}, 
        {(int const   )56, (char const   */* const  */)"EBADRQC"}, 
        {(int const   )57, (char const   */* const  */)"EBADSLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLOCK"}, 
        {(int const   )59, (char const   */* const  */)"EBFONT"}, 
        {(int const   )60, (char const   */* const  */)"ENOSTR"}, 
        {(int const   )61, (char const   */* const  */)"ENODATA"}, 
        {(int const   )62, (char const   */* const  */)"ETIME"}, 
        {(int const   )63, (char const   */* const  */)"ENOSR"}, 
        {(int const   )64, (char const   */* const  */)"ENONET"}, 
        {(int const   )65, (char const   */* const  */)"ENOPKG"}, 
        {(int const   )66, (char const   */* const  */)"EREMOTE"}, 
        {(int const   )67, (char const   */* const  */)"ENOLINK"}, 
        {(int const   )68, (char const   */* const  */)"EADV"}, 
        {(int const   )69, (char const   */* const  */)"ESRMNT"}, 
        {(int const   )70, (char const   */* const  */)"ECOMM"}, 
        {(int const   )71, (char const   */* const  */)"EPROTO"}, 
        {(int const   )72, (char const   */* const  */)"EMULTIHOP"}, 
        {(int const   )73, (char const   */* const  */)"EDOTDOT"}, 
        {(int const   )74, (char const   */* const  */)"EBADMSG"}, 
        {(int const   )36, (char const   */* const  */)"ENAMETOOLONG"}, 
        {(int const   )75, (char const   */* const  */)"EOVERFLOW"}, 
        {(int const   )76, (char const   */* const  */)"ENOTUNIQ"}, 
        {(int const   )77, (char const   */* const  */)"EBADFD"}, 
        {(int const   )78, (char const   */* const  */)"EREMCHG"}, 
        {(int const   )79, (char const   */* const  */)"ELIBACC"}, 
        {(int const   )80, (char const   */* const  */)"ELIBBAD"}, 
        {(int const   )81, (char const   */* const  */)"ELIBSCN"}, 
        {(int const   )82, (char const   */* const  */)"ELIBMAX"}, 
        {(int const   )83, (char const   */* const  */)"ELIBEXEC"}, 
        {(int const   )84, (char const   */* const  */)"EILSEQ"}, 
        {(int const   )38, (char const   */* const  */)"ENOSYS"}, 
        {(int const   )40, (char const   */* const  */)"ELOOP"}, 
        {(int const   )85, (char const   */* const  */)"ERESTART"}, 
        {(int const   )86, (char const   */* const  */)"ESTRPIPE"}, 
        {(int const   )39, (char const   */* const  */)"ENOTEMPTY"}, 
        {(int const   )87, (char const   */* const  */)"EUSERS"}, 
        {(int const   )88, (char const   */* const  */)"ENOTSOCK"}, 
        {(int const   )89, (char const   */* const  */)"EDESTADDRREQ"}, 
        {(int const   )90, (char const   */* const  */)"EMSGSIZE"}, 
        {(int const   )91, (char const   */* const  */)"EPROTOTYPE"}, 
        {(int const   )92, (char const   */* const  */)"ENOPROTOOPT"}, 
        {(int const   )93, (char const   */* const  */)"EPROTONOSUPPORT"}, 
        {(int const   )94, (char const   */* const  */)"ESOCKTNOSUPPORT"}, 
        {(int const   )95, (char const   */* const  */)"EOPNOTSUPP"}, 
        {(int const   )96, (char const   */* const  */)"EPFNOSUPPORT"}, 
        {(int const   )97, (char const   */* const  */)"EAFNOSUPPORT"}, 
        {(int const   )98, (char const   */* const  */)"EADDRINUSE"}, 
        {(int const   )99, (char const   */* const  */)"EADDRNOTAVAIL"}, 
        {(int const   )100, (char const   */* const  */)"ENETDOWN"}, 
        {(int const   )101, (char const   */* const  */)"ENETUNREACH"}, 
        {(int const   )102, (char const   */* const  */)"ENETRESET"}, 
        {(int const   )103, (char const   */* const  */)"ECONNABORTED"}, 
        {(int const   )104, (char const   */* const  */)"ECONNRESET"}, 
        {(int const   )105, (char const   */* const  */)"ENOBUFS"}, 
        {(int const   )106, (char const   */* const  */)"EISCONN"}, 
        {(int const   )107, (char const   */* const  */)"ENOTCONN"}, 
        {(int const   )108, (char const   */* const  */)"ESHUTDOWN"}, 
        {(int const   )109, (char const   */* const  */)"ETOOMANYREFS"}, 
        {(int const   )110, (char const   */* const  */)"ETIMEDOUT"}, 
        {(int const   )111, (char const   */* const  */)"ECONNREFUSED"}, 
        {(int const   )112, (char const   */* const  */)"EHOSTDOWN"}, 
        {(int const   )113, (char const   */* const  */)"EHOSTUNREACH"}, 
        {(int const   )114, (char const   */* const  */)"EALREADY"}, 
        {(int const   )115, (char const   */* const  */)"EINPROGRESS"}, 
        {(int const   )116, (char const   */* const  */)"ESTALE"}, 
        {(int const   )117, (char const   */* const  */)"EUCLEAN"}, 
        {(int const   )118, (char const   */* const  */)"ENOTNAM"}, 
        {(int const   )119, (char const   */* const  */)"ENAVAIL"}, 
        {(int const   )120, (char const   */* const  */)"EISNAM"}, 
        {(int const   )121, (char const   */* const  */)"EREMOTEIO"}, 
        {(int const   )0, (char const   */* const  */)((void *)0)}};
#line 452 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static char const   **error_names  ;
#line 453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static int num_error_names  =    0;
#line 472
extern int sys_nerr ;
#line 505 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static void init_error_tables(void) 
{ 
  struct error_info  const  *eip ;
  int nbytes ;
  void *tmp___0 ;

  {
#line 514
  if (num_error_names == 0) {
#line 516
    eip = error_table;
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 516
        goto while_break;
      }
#line 518
      if (eip->value >= (int const   )num_error_names) {
#line 520
        num_error_names = (int )(eip->value + 1);
      }
#line 516
      eip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 528
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 530
    nbytes = (int )((unsigned long )num_error_names * sizeof(char *));
#line 531
    tmp___0 = malloc((size_t )nbytes);
#line 531
    error_names = (char const   **)tmp___0;
    }
#line 531
    if ((unsigned long )error_names != (unsigned long )((void *)0)) {
      {
#line 533
      memset((void *)error_names, 0, (size_t )nbytes);
#line 534
      eip = error_table;
      }
      {
#line 534
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 534
        if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 534
          goto while_break___0;
        }
#line 536
        *(error_names + eip->value) = (char const   *)eip->name;
#line 534
        eip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 562
  return;
}
}
#line 586 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
int errno_max(void) 
{ 
  int maxsize___0 ;

  {
#line 591
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 593
    init_error_tables();
    }
  }
#line 595
  if (sys_nerr > num_error_names) {
#line 595
    maxsize___0 = sys_nerr;
  } else {
#line 595
    maxsize___0 = num_error_names;
  }
#line 596
  return (maxsize___0 - 1);
}
}
#line 695 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
static char buf___0[32]  ;
#line 691 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
char const   *strerrno(int errnoval ) 
{ 
  char const   *name___0 ;

  {
#line 697
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 699
    init_error_tables();
    }
  }
#line 702
  if (errnoval < 0) {
#line 710
    name___0 = (char const   *)((void *)0);
  } else
#line 702
  if (errnoval >= num_error_names) {
#line 710
    name___0 = (char const   *)((void *)0);
  } else
#line 712
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name___0 = (char const   *)(buf___0);
    }
  } else
#line 712
  if ((unsigned long )*(error_names + errnoval) == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name___0 = (char const   *)(buf___0);
    }
  } else {
#line 721
    name___0 = *(error_names + errnoval);
  }
#line 724
  return (name___0);
}
}
#line 738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./strerror.c"
int strtoerrno(char const   *name___0 ) 
{ 
  int errnoval ;
  int tmp___0 ;

  {
#line 741
  errnoval = 0;
#line 743
  if ((unsigned long )name___0 != (unsigned long )((void *)0)) {
#line 745
    if ((unsigned long )error_names == (unsigned long )((void *)0)) {
      {
#line 747
      init_error_tables();
      }
    }
#line 749
    errnoval = 0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! (errnoval < num_error_names)) {
#line 749
        goto while_break;
      }
#line 751
      if ((unsigned long )*(error_names + errnoval) != (unsigned long )((void *)0)) {
        {
#line 751
        tmp___0 = strcmp(name___0, *(error_names + errnoval));
        }
#line 751
        if (tmp___0 == 0) {
#line 754
          goto while_break;
        }
      }
#line 749
      errnoval ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 757
    if (errnoval == num_error_names) {
#line 764
      errnoval = 0;
    }
  }
#line 767
  return (errnoval);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./stack-limit.c"
void stack_limit_increase(unsigned long pref  __attribute__((__unused__)) ) 
{ 
  struct rlimit rlim ;
  int tmp___0 ;

  {
  {
#line 52
  tmp___0 = getrlimit(3, & rlim);
  }
#line 52
  if (tmp___0 == 0) {
#line 52
    if (rlim.rlim_cur != 0xffffffffffffffffUL) {
#line 52
      if (rlim.rlim_cur < pref) {
#line 52
        if (rlim.rlim_max == 0xffffffffffffffffUL) {
#line 52
          goto _L;
        } else
#line 52
        if (rlim.rlim_cur < rlim.rlim_max) {
          _L: /* CIL Label */ 
#line 57
          rlim.rlim_cur = pref;
#line 58
          if (rlim.rlim_max != 0xffffffffffffffffUL) {
#line 58
            if (rlim.rlim_cur > rlim.rlim_max) {
#line 59
              rlim.rlim_cur = rlim.rlim_max;
            }
          }
          {
#line 60
          setrlimit(3, (struct rlimit  const  *)(& rlim));
          }
        }
      }
    }
  }
#line 63
  return;
}
}
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 127 "./../include/splay-tree.h"
splay_tree splay_tree_new(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                          void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ) ;
#line 130
splay_tree splay_tree_new_with_allocator(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                         void (*delete_key_fn)(splay_tree_key  ) ,
                                         void (*delete_value_fn)(splay_tree_value  ) ,
                                         void *(*allocate_fn)(int  , void * ) , void (*deallocate_fn)(void * ,
                                                                                                      void * ) ,
                                         void *allocate_data ) ;
#line 136
splay_tree splay_tree_new_typed_alloc(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                      void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ,
                                      void *(*tree_allocate_fn)(int  , void * ) ,
                                      void *(*node_allocate_fn)(int  , void * ) ,
                                      void (*deallocate_fn)(void * , void * ) , void *allocate_data ) ;
#line 143
void splay_tree_delete(splay_tree sp ) ;
#line 144
splay_tree_node splay_tree_insert(splay_tree sp , splay_tree_key key , splay_tree_value value ) ;
#line 147
void splay_tree_remove(splay_tree sp , splay_tree_key key ) ;
#line 148
splay_tree_node splay_tree_lookup(splay_tree sp , splay_tree_key key ) ;
#line 149
splay_tree_node splay_tree_predecessor(splay_tree sp , splay_tree_key key ) ;
#line 150
splay_tree_node splay_tree_successor(splay_tree sp , splay_tree_key key ) ;
#line 151
splay_tree_node splay_tree_max(splay_tree sp ) ;
#line 152
splay_tree_node splay_tree_min(splay_tree sp ) ;
#line 153
int splay_tree_foreach(splay_tree sp , int (*fn)(splay_tree_node  , void * ) , void *data ) ;
#line 154
int splay_tree_compare_ints(splay_tree_key k1 , splay_tree_key k2 ) ;
#line 155
int splay_tree_compare_pointers(splay_tree_key k1 , splay_tree_key k2 ) ;
#line 41 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static void splay_tree_delete_helper(splay_tree sp , splay_tree_node node ) ;
#line 42
__inline static void rotate_left(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) ;
#line 44
__inline static void rotate_right(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) ;
#line 46
static void splay_tree_splay(splay_tree sp , splay_tree_key key ) ;
#line 47
static int splay_tree_foreach_helper(splay_tree_node node , int (*fn)(splay_tree_node  ,
                                                                      void * ) , void *data ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static void splay_tree_delete_helper(splay_tree sp , splay_tree_node node ) 
{ 
  splay_tree_node pending ;
  splay_tree_node active ;
  splay_tree_node temp ;

  {
#line 55
  pending = (splay_tree_node )0;
#line 56
  active = (splay_tree_node )0;
#line 58
  if (! node) {
#line 59
    return;
  }
#line 64
  if (sp->delete_key) {
    {
#line 64
    (*(sp->delete_key))(node->key);
    }
  }
#line 65
  if (sp->delete_value) {
    {
#line 65
    (*(sp->delete_value))(node->value);
    }
  }
#line 68
  node->key = (splay_tree_key )pending;
#line 69
  pending = node;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! pending) {
#line 75
      goto while_break;
    }
#line 77
    active = pending;
#line 78
    pending = (splay_tree_node )0;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! active) {
#line 79
        goto while_break___0;
      }
#line 86
      if (active->left) {
#line 88
        if (sp->delete_key) {
          {
#line 88
          (*(sp->delete_key))((active->left)->key);
          }
        }
#line 89
        if (sp->delete_value) {
          {
#line 89
          (*(sp->delete_value))((active->left)->value);
          }
        }
#line 90
        (active->left)->key = (splay_tree_key )pending;
#line 91
        pending = active->left;
      }
#line 93
      if (active->right) {
#line 95
        if (sp->delete_key) {
          {
#line 95
          (*(sp->delete_key))((active->right)->key);
          }
        }
#line 96
        if (sp->delete_value) {
          {
#line 96
          (*(sp->delete_value))((active->right)->value);
          }
        }
#line 97
        (active->right)->key = (splay_tree_key )pending;
#line 98
        pending = active->right;
      }
      {
#line 101
      temp = active;
#line 102
      active = (splay_tree_node )temp->key;
#line 103
      (*(sp->deallocate))((void *)((char *)temp), sp->allocate_data);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 113 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
__inline static void rotate_left(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) 
{ 
  splay_tree_node tmp___0 ;

  {
#line 117
  tmp___0 = n->right;
#line 118
  n->right = p;
#line 119
  p->left = tmp___0;
#line 120
  *pp = n;
#line 121
  return;
}
}
#line 126 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
__inline static void rotate_right(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) 
{ 
  splay_tree_node tmp___0 ;

  {
#line 130
  tmp___0 = n->left;
#line 131
  n->left = p;
#line 132
  p->right = tmp___0;
#line 133
  *pp = n;
#line 134
  return;
}
}
#line 138 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static void splay_tree_splay(splay_tree sp , splay_tree_key key ) 
{ 
  int cmp1 ;
  int cmp2 ;
  splay_tree_node n ;
  splay_tree_node c ;

  {
#line 141
  if ((unsigned long )sp->root == (unsigned long )((splay_tree_node )0)) {
#line 142
    return;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    n = sp->root;
#line 149
    cmp1 = (*(sp->comp))(key, n->key);
    }
#line 152
    if (cmp1 == 0) {
#line 153
      return;
    }
#line 156
    if (cmp1 < 0) {
#line 157
      c = n->left;
    } else {
#line 159
      c = n->right;
    }
#line 160
    if (! c) {
#line 161
      return;
    }
    {
#line 165
    cmp2 = (*(sp->comp))(key, c->key);
    }
#line 166
    if (cmp2 == 0) {
#line 166
      goto _L;
    } else
#line 166
    if (cmp2 < 0) {
#line 166
      if (! c->left) {
#line 166
        goto _L;
      } else {
#line 166
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if (cmp2 > 0) {
#line 166
      if (! c->right) {
        _L: /* CIL Label */ 
#line 170
        if (cmp1 < 0) {
          {
#line 171
          rotate_left(& sp->root, n, c);
          }
        } else {
          {
#line 173
          rotate_right(& sp->root, n, c);
          }
        }
#line 174
        return;
      }
    }
#line 178
    if (cmp1 < 0) {
#line 178
      if (cmp2 < 0) {
        {
#line 180
        rotate_left(& n->left, c, c->left);
#line 181
        rotate_left(& sp->root, n, n->left);
        }
      } else {
#line 178
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 183
    if (cmp1 > 0) {
#line 183
      if (cmp2 > 0) {
        {
#line 185
        rotate_right(& n->right, c, c->right);
#line 186
        rotate_right(& sp->root, n, n->right);
        }
      } else {
#line 183
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 188
    if (cmp1 < 0) {
#line 188
      if (cmp2 > 0) {
        {
#line 190
        rotate_right(& n->left, c, c->right);
#line 191
        rotate_left(& sp->root, n, n->left);
        }
      } else {
#line 188
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 193
    if (cmp1 > 0) {
#line 193
      if (cmp2 < 0) {
        {
#line 195
        rotate_left(& n->right, c, c->left);
#line 196
        rotate_right(& sp->root, n, n->right);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static int splay_tree_foreach_helper(splay_tree_node node , int (*fn)(splay_tree_node  ,
                                                                      void * ) , void *data ) 
{ 
  int val ;
  splay_tree_node *stack ;
  int stack_ptr ;
  int stack_size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 219
  stack_size = 100;
#line 220
  stack_ptr = 0;
#line 221
  tmp___0 = xmalloc(sizeof(splay_tree_node ) * (unsigned long )stack_size);
#line 221
  stack = (splay_tree_node *)tmp___0;
#line 222
  val = 0;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 226
        goto while_break___0;
      }
#line 228
      if (stack_ptr == stack_size) {
        {
#line 230
        stack_size *= 2;
#line 231
        tmp___1 = xrealloc((void *)stack, sizeof(splay_tree_node ) * (unsigned long )stack_size);
#line 231
        stack = (splay_tree_node *)tmp___1;
        }
      }
#line 233
      tmp___2 = stack_ptr;
#line 233
      stack_ptr ++;
#line 233
      *(stack + tmp___2) = node;
#line 234
      node = node->left;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    if (stack_ptr == 0) {
#line 238
      goto while_break;
    }
    {
#line 240
    stack_ptr --;
#line 240
    node = *(stack + stack_ptr);
#line 242
    val = (*fn)(node, data);
    }
#line 243
    if (val) {
#line 244
      goto while_break;
    }
#line 246
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  free((void *)stack);
  }
#line 250
  return (val);
}
}
#line 254 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static void *splay_tree_xmalloc_allocate(int size , void *data  __attribute__((__unused__)) ) 
{ 
  void *tmp___0 ;

  {
  {
#line 257
  tmp___0 = xmalloc((size_t )size);
  }
#line 257
  return (tmp___0);
}
}
#line 260 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
static void splay_tree_xmalloc_deallocate(void *object , void *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 263
  free(object);
  }
#line 264
  return;
}
}
#line 272 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree splay_tree_new(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                          void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ) 
{ 
  splay_tree tmp___0 ;

  {
  {
#line 277
  tmp___0 = splay_tree_new_with_allocator(compare_fn, delete_key_fn, delete_value_fn,
                                          & splay_tree_xmalloc_allocate, & splay_tree_xmalloc_deallocate,
                                          (void *)0);
  }
#line 277
  return (tmp___0);
}
}
#line 287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree splay_tree_new_with_allocator(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                         void (*delete_key_fn)(splay_tree_key  ) ,
                                         void (*delete_value_fn)(splay_tree_value  ) ,
                                         void *(*allocate_fn)(int  , void * ) , void (*deallocate_fn)(void * ,
                                                                                                      void * ) ,
                                         void *allocate_data ) 
{ 
  splay_tree tmp___0 ;

  {
  {
#line 295
  tmp___0 = splay_tree_new_typed_alloc(compare_fn, delete_key_fn, delete_value_fn,
                                       allocate_fn, allocate_fn, deallocate_fn, allocate_data);
  }
#line 295
  return (tmp___0);
}
}
#line 325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree splay_tree_new_typed_alloc(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                      void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ,
                                      void *(*tree_allocate_fn)(int  , void * ) ,
                                      void *(*node_allocate_fn)(int  , void * ) ,
                                      void (*deallocate_fn)(void * , void * ) , void *allocate_data ) 
{ 
  splay_tree sp ;
  void *tmp___0 ;

  {
  {
#line 334
  tmp___0 = (*tree_allocate_fn)((int )sizeof(struct splay_tree_s ), allocate_data);
#line 334
  sp = (splay_tree )tmp___0;
#line 337
  sp->root = (splay_tree_node )0;
#line 338
  sp->comp = compare_fn;
#line 339
  sp->delete_key = delete_key_fn;
#line 340
  sp->delete_value = delete_value_fn;
#line 341
  sp->allocate = node_allocate_fn;
#line 342
  sp->deallocate = deallocate_fn;
#line 343
  sp->allocate_data = allocate_data;
  }
#line 345
  return (sp);
}
}
#line 350 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
void splay_tree_delete(splay_tree sp ) 
{ 


  {
  {
#line 353
  splay_tree_delete_helper(sp, sp->root);
#line 354
  (*(sp->deallocate))((void *)((char *)sp), sp->allocate_data);
  }
#line 355
  return;
}
}
#line 361 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_insert(splay_tree sp , splay_tree_key key , splay_tree_value value ) 
{ 
  int comparison ;
  splay_tree_node node ;
  void *tmp___0 ;
  splay_tree_node tmp___1 ;

  {
  {
#line 364
  comparison = 0;
#line 366
  splay_tree_splay(sp, key);
  }
#line 368
  if (sp->root) {
    {
#line 369
    comparison = (*(sp->comp))((sp->root)->key, key);
    }
  }
#line 371
  if (sp->root) {
#line 371
    if (comparison == 0) {
#line 375
      if (sp->delete_value) {
        {
#line 376
        (*(sp->delete_value))((sp->root)->value);
        }
      }
#line 377
      (sp->root)->value = value;
    } else {
#line 371
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 384
    tmp___0 = (*(sp->allocate))((int )sizeof(struct splay_tree_node_s ), sp->allocate_data);
#line 384
    node = (splay_tree_node )tmp___0;
#line 387
    node->key = key;
#line 388
    node->value = value;
    }
#line 390
    if (! sp->root) {
#line 391
      tmp___1 = (splay_tree_node )0;
#line 391
      node->right = tmp___1;
#line 391
      node->left = tmp___1;
    } else
#line 392
    if (comparison < 0) {
#line 394
      node->left = sp->root;
#line 395
      node->right = (node->left)->right;
#line 396
      (node->left)->right = (splay_tree_node )0;
    } else {
#line 400
      node->right = sp->root;
#line 401
      node->left = (node->right)->left;
#line 402
      (node->right)->left = (splay_tree_node )0;
    }
#line 405
    sp->root = node;
  }
#line 408
  return (sp->root);
}
}
#line 413 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
void splay_tree_remove(splay_tree sp , splay_tree_key key ) 
{ 
  splay_tree_node left ;
  splay_tree_node right ;
  int tmp___0 ;

  {
  {
#line 416
  splay_tree_splay(sp, key);
  }
#line 418
  if (sp->root) {
    {
#line 418
    tmp___0 = (*(sp->comp))((sp->root)->key, key);
    }
#line 418
    if (tmp___0 == 0) {
#line 422
      left = (sp->root)->left;
#line 423
      right = (sp->root)->right;
#line 426
      if (sp->delete_value) {
        {
#line 427
        (*(sp->delete_value))((sp->root)->value);
        }
      }
      {
#line 428
      (*(sp->deallocate))((void *)sp->root, sp->allocate_data);
      }
#line 432
      if (left) {
#line 434
        sp->root = left;
#line 438
        if (right) {
          {
#line 440
          while (1) {
            while_continue: /* CIL Label */ ;
#line 440
            if (! left->right) {
#line 440
              goto while_break;
            }
#line 441
            left = left->right;
          }
          while_break: /* CIL Label */ ;
          }
#line 442
          left->right = right;
        }
      } else {
#line 446
        sp->root = right;
      }
    }
  }
#line 448
  return;
}
}
#line 453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_lookup(splay_tree sp , splay_tree_key key ) 
{ 
  int tmp___0 ;

  {
  {
#line 456
  splay_tree_splay(sp, key);
  }
#line 458
  if (sp->root) {
    {
#line 458
    tmp___0 = (*(sp->comp))((sp->root)->key, key);
    }
#line 458
    if (tmp___0 == 0) {
#line 459
      return (sp->root);
    } else {
#line 461
      return ((splay_tree_node )0);
    }
  } else {
#line 461
    return ((splay_tree_node )0);
  }
}
}
#line 466 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_max(splay_tree sp ) 
{ 
  splay_tree_node n ;

  {
#line 469
  n = sp->root;
#line 471
  if (! n) {
#line 472
    return ((splay_tree_node )((void *)0));
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! n->right) {
#line 474
      goto while_break;
    }
#line 475
    n = n->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return (n);
}
}
#line 482 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_min(splay_tree sp ) 
{ 
  splay_tree_node n ;

  {
#line 485
  n = sp->root;
#line 487
  if (! n) {
#line 488
    return ((splay_tree_node )((void *)0));
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! n->left) {
#line 490
      goto while_break;
    }
#line 491
    n = n->left;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return (n);
}
}
#line 499 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_predecessor(splay_tree sp , splay_tree_key key ) 
{ 
  int comparison ;
  splay_tree_node node ;

  {
#line 506
  if (! sp->root) {
#line 507
    return ((splay_tree_node )((void *)0));
  }
  {
#line 511
  splay_tree_splay(sp, key);
#line 512
  comparison = (*(sp->comp))((sp->root)->key, key);
  }
#line 515
  if (comparison < 0) {
#line 516
    return (sp->root);
  }
#line 519
  node = (sp->root)->left;
#line 520
  if (node) {
    {
#line 521
    while (1) {
      while_continue: /* CIL Label */ ;
#line 521
      if (! node->right) {
#line 521
        goto while_break;
      }
#line 522
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 524
  return (node);
}
}
#line 530 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
splay_tree_node splay_tree_successor(splay_tree sp , splay_tree_key key ) 
{ 
  int comparison ;
  splay_tree_node node ;

  {
#line 537
  if (! sp->root) {
#line 538
    return ((splay_tree_node )((void *)0));
  }
  {
#line 542
  splay_tree_splay(sp, key);
#line 543
  comparison = (*(sp->comp))((sp->root)->key, key);
  }
#line 546
  if (comparison > 0) {
#line 547
    return (sp->root);
  }
#line 550
  node = (sp->root)->right;
#line 551
  if (node) {
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
#line 552
      if (! node->left) {
#line 552
        goto while_break;
      }
#line 553
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 555
  return (node);
}
}
#line 563 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
int splay_tree_foreach(splay_tree sp , int (*fn)(splay_tree_node  , void * ) , void *data ) 
{ 
  int tmp___0 ;

  {
  {
#line 566
  tmp___0 = splay_tree_foreach_helper(sp->root, fn, data);
  }
#line 566
  return (tmp___0);
}
}
#line 571 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
int splay_tree_compare_ints(splay_tree_key k1 , splay_tree_key k2 ) 
{ 


  {
#line 574
  if ((int )k1 < (int )k2) {
#line 575
    return (-1);
  } else
#line 576
  if ((int )k1 > (int )k2) {
#line 577
    return (1);
  } else {
#line 579
    return (0);
  }
}
}
#line 584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./splay-tree.c"
int splay_tree_compare_pointers(splay_tree_key k1 , splay_tree_key k2 ) 
{ 


  {
#line 587
  if ((unsigned long )((char *)k1) < (unsigned long )((char *)k2)) {
#line 588
    return (-1);
  } else
#line 589
  if ((unsigned long )((char *)k1) > (unsigned long )((char *)k2)) {
#line 590
    return (1);
  } else {
#line 592
    return (0);
  }
}
}
#line 241 "./../include/libiberty.h"
char const   *spaces(int count ) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./spaces.c"
static char *buf___1  ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./spaces.c"
static int maxsize  ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./spaces.c"
char const   *spaces(int count ) 
{ 
  register char *t ;
  void *tmp___0 ;

  {
#line 54
  if (count > maxsize) {
    {
#line 56
    free((void *)buf___1);
#line 57
    tmp___0 = malloc((size_t )(count + 1));
#line 57
    buf___1 = (char *)tmp___0;
    }
#line 58
    if ((unsigned long )buf___1 == (unsigned long )((char *)0)) {
#line 59
      return ((char const   *)0);
    }
#line 60
    t = buf___1 + count;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! ((unsigned long )t != (unsigned long )buf___1)) {
#line 60
        goto while_break;
      }
#line 62
      t --;
#line 62
      *t = (char )' ';
    }
    while_break: /* CIL Label */ ;
    }
#line 64
    maxsize = count;
#line 65
    *(buf___1 + count) = (char )'\000';
  }
#line 67
  return ((char const   *)((buf___1 + maxsize) - count));
}
}
#line 38 "./../include/sort.h"
void sort_pointers(size_t n , void **pointers , void **work ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sort.c"
void sort_pointers(size_t n , void **pointers , void **work ) 
{ 
  unsigned int count[256] ;
  int big_endian_p ;
  size_t i ;
  size_t j ;
  digit_t *digit ;
  digit_t *bias ;
  digit_t *top ;
  unsigned int *countp ;
  void **pointerp ;

  {
#line 70
  if ((sizeof(void *) / sizeof(digit_t )) % 2UL != 0UL) {
    {
#line 71
    abort();
    }
  }
#line 74
  i = (size_t )0;
#line 74
  j = (size_t )0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < sizeof(size_t ))) {
#line 74
      goto while_break;
    }
#line 76
    j *= 256UL;
#line 77
    j += i;
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  big_endian_p = (int )*((char *)(& j) + 0) == 0;
#line 83
  i = (size_t )0;
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! (i < sizeof(void *) / sizeof(digit_t ))) {
#line 83
      goto while_break___0;
    }
#line 93
    if (big_endian_p) {
#line 94
      j = sizeof(void *) / sizeof(digit_t ) - i;
    } else {
#line 96
      j = i;
    }
    {
#line 100
    memset((void *)(count), 0, 256UL * sizeof(unsigned int ));
#line 105
    bias = (digit_t *)pointers + j;
#line 106
    top = (digit_t *)(pointers + n) + j;
#line 111
    digit = bias;
    }
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 111
      if (! ((unsigned long )digit < (unsigned long )top)) {
#line 111
        goto while_break___1;
      }
#line 114
      (count[*digit]) ++;
#line 111
      digit += sizeof(void *) / sizeof(digit_t );
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    countp = count + 1;
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )countp < (unsigned long )(count + 256))) {
#line 118
        goto while_break___2;
      }
#line 119
      *countp += *(countp + -1);
#line 118
      countp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 122
    pointerp = (pointers + n) - 1;
    {
#line 122
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 122
      if (! ((unsigned long )pointerp >= (unsigned long )pointers)) {
#line 122
        goto while_break___3;
      }
#line 123
      (count[*((digit_t *)pointerp + j)]) --;
#line 123
      *(work + count[*((digit_t *)pointerp + j)]) = *pointerp;
#line 122
      pointerp --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 127
    pointerp = pointers;
#line 128
    pointers = work;
#line 129
    work = pointerp;
#line 83
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "./../include/simple-object.h"
simple_object_read *simple_object_start_read(int descriptor , off_t offset , char const   *segment_name ,
                                             char const   **errmsg , int *err ) ;
#line 70
char const   *simple_object_find_sections(simple_object_read *sobj , int (*pfn)(void *data ,
                                                                                char const   * ,
                                                                                off_t offset ,
                                                                                off_t length ) ,
                                          void *data , int *err ) ;
#line 93
int simple_object_find_section(simple_object_read *sobj , char const   *name___0 ,
                               off_t *offset , off_t *length , char const   **errmsg ,
                               int *err ) ;
#line 101
void simple_object_release_read(simple_object_read *sobj ) ;
#line 116
simple_object_attributes *simple_object_fetch_attributes(simple_object_read *sobj ,
                                                         char const   **errmsg , int *err ) ;
#line 125
char const   *simple_object_attributes_merge(simple_object_attributes *to , simple_object_attributes *from ,
                                             int *err ) ;
#line 132
void simple_object_release_attributes(simple_object_attributes *attrs ) ;
#line 149
simple_object_write *simple_object_start_write(simple_object_attributes *attrs , char const   *segment_name ,
                                               char const   **errmsg , int *err ) ;
#line 167
simple_object_write_section *simple_object_write_create_section(simple_object_write *sobj ,
                                                                char const   *name___0 ,
                                                                unsigned int align ,
                                                                char const   **errmsg  __attribute__((__unused__)) ,
                                                                int *err  __attribute__((__unused__)) ) ;
#line 179
char const   *simple_object_write_add_data(simple_object_write *sobj  __attribute__((__unused__)) ,
                                           simple_object_write_section *section ,
                                           void const   *buffer___2 , size_t size ,
                                           int copy , int *err  __attribute__((__unused__)) ) ;
#line 190
char const   *simple_object_write_to_file(simple_object_write *sobj , int descriptor ,
                                          int *err ) ;
#line 197
void simple_object_release_write(simple_object_write *sobj ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
struct simple_object_functions  const  simple_object_coff_functions ;
#line 149
struct simple_object_functions  const  simple_object_elf_functions ;
#line 150
struct simple_object_functions  const  simple_object_mach_o_functions ;
#line 151
struct simple_object_functions  const  simple_object_xcoff_functions ;
#line 157
int simple_object_internal_read(int descriptor , off_t offset , unsigned char *buffer___2 ,
                                size_t size , char const   **errmsg , int *err ) ;
#line 166
int simple_object_internal_write(int descriptor , off_t offset , unsigned char const   *buffer___2 ,
                                 size_t size , char const   **errmsg , int *err ) ;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
static struct simple_object_functions  const  * const  format_functions[4]  = {      (struct simple_object_functions  const  */* const  */)(& simple_object_elf_functions),      (struct simple_object_functions  const  */* const  */)(& simple_object_mach_o_functions),      (struct simple_object_functions  const  */* const  */)(& simple_object_coff_functions),      (struct simple_object_functions  const  */* const  */)(& simple_object_xcoff_functions)};
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
int simple_object_internal_read(int descriptor , off_t offset , unsigned char *buffer___2 ,
                                size_t size , char const   **errmsg , int *err ) 
{ 
  ssize_t got ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 68
  tmp___1 = lseek(descriptor, offset, 0);
  }
#line 68
  if (tmp___1 < 0L) {
    {
#line 70
    *errmsg = "lseek";
#line 71
    tmp___0 = __errno_location();
#line 71
    *err = *tmp___0;
    }
#line 72
    return (0);
  }
  {
#line 75
  got = read(descriptor, (void *)buffer___2, size);
  }
#line 76
  if (got < 0L) {
    {
#line 78
    *errmsg = "read";
#line 79
    tmp___2 = __errno_location();
#line 79
    *err = *tmp___2;
    }
#line 80
    return (0);
  }
#line 83
  if ((size_t )got < size) {
#line 85
    *errmsg = "file too short";
#line 86
    *err = 0;
#line 87
    return (0);
  }
#line 90
  return (1);
}
}
#line 96 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
int simple_object_internal_write(int descriptor , off_t offset , unsigned char const   *buffer___2 ,
                                 size_t size , char const   **errmsg , int *err ) 
{ 
  ssize_t wrote ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 103
  tmp___1 = lseek(descriptor, offset, 0);
  }
#line 103
  if (tmp___1 < 0L) {
    {
#line 105
    *errmsg = "lseek";
#line 106
    tmp___0 = __errno_location();
#line 106
    *err = *tmp___0;
    }
#line 107
    return (0);
  }
  {
#line 110
  wrote = write(descriptor, (void const   *)buffer___2, size);
  }
#line 111
  if (wrote < 0L) {
    {
#line 113
    *errmsg = "write";
#line 114
    tmp___2 = __errno_location();
#line 114
    *err = *tmp___2;
    }
#line 115
    return (0);
  }
#line 118
  if ((size_t )wrote < size) {
#line 120
    *errmsg = "short write";
#line 121
    *err = 0;
#line 122
    return (0);
  }
#line 125
  return (1);
}
}
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
simple_object_read *simple_object_start_read(int descriptor , off_t offset , char const   *segment_name ,
                                             char const   **errmsg , int *err ) 
{ 
  unsigned char header[16] ;
  size_t len ;
  size_t i ;
  int tmp___0 ;
  void *data ;
  simple_object_read *ret ;
  void *tmp___1 ;

  {
  {
#line 138
  tmp___0 = simple_object_internal_read(descriptor, offset, header, (size_t )16, errmsg,
                                        err);
  }
#line 138
  if (! tmp___0) {
#line 141
    return ((simple_object_read *)((void *)0));
  }
#line 143
  len = sizeof(format_functions) / sizeof(format_functions[0]);
#line 144
  i = (size_t )0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < len)) {
#line 144
      goto while_break;
    }
    {
#line 148
    data = (*((format_functions[i])->match))((unsigned char *)(header), descriptor,
                                             offset, segment_name, errmsg, err);
    }
#line 150
    if ((unsigned long )data != (unsigned long )((void *)0)) {
      {
#line 154
      tmp___1 = xmalloc(sizeof(simple_object_read ));
#line 154
      ret = (simple_object_read *)tmp___1;
#line 155
      ret->descriptor = descriptor;
#line 156
      ret->offset = offset;
#line 157
      ret->functions = (struct simple_object_functions  const  *)format_functions[i];
#line 158
      ret->data = data;
      }
#line 159
      return (ret);
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  *errmsg = "file not recognized";
#line 164
  *err = 0;
#line 165
  return ((simple_object_read *)((void *)0));
}
}
#line 170 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
char const   *simple_object_find_sections(simple_object_read *sobj , int (*pfn)(void *data ,
                                                                                char const   * ,
                                                                                off_t offset ,
                                                                                off_t length ) ,
                                          void *data , int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 176
  tmp___0 = (*((sobj->functions)->find_sections))(sobj, pfn, data, err);
  }
#line 176
  return (tmp___0);
}
}
#line 195 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
static int find_one_section(void *data , char const   *name___0 , off_t offset , off_t length ) 
{ 
  struct find_one_section_data *fosd ;
  int tmp___0 ;

  {
  {
#line 198
  fosd = (struct find_one_section_data *)data;
#line 200
  tmp___0 = strcmp(name___0, fosd->name);
  }
#line 200
  if (tmp___0 != 0) {
#line 201
    return (1);
  }
#line 203
  *(fosd->offset) = offset;
#line 204
  *(fosd->length) = length;
#line 205
  fosd->found = 1;
#line 208
  return (0);
}
}
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
int simple_object_find_section(simple_object_read *sobj , char const   *name___0 ,
                               off_t *offset , off_t *length , char const   **errmsg ,
                               int *err ) 
{ 
  struct find_one_section_data fosd ;

  {
  {
#line 220
  fosd.name = name___0;
#line 221
  fosd.offset = offset;
#line 222
  fosd.length = length;
#line 223
  fosd.found = 0;
#line 225
  *errmsg = simple_object_find_sections(sobj, & find_one_section, (void *)(& fosd),
                                        err);
  }
#line 227
  if ((unsigned long )*errmsg != (unsigned long )((void *)0)) {
#line 228
    return (0);
  }
#line 229
  if (! fosd.found) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 236 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
simple_object_attributes *simple_object_fetch_attributes(simple_object_read *sobj ,
                                                         char const   **errmsg , int *err ) 
{ 
  void *data ;
  simple_object_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 243
  data = (*((sobj->functions)->fetch_attributes))(sobj, errmsg, err);
  }
#line 244
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 245
    return ((simple_object_attributes *)((void *)0));
  }
  {
#line 246
  tmp___0 = xmalloc(sizeof(simple_object_attributes ));
#line 246
  ret = (simple_object_attributes *)tmp___0;
#line 247
  ret->functions = sobj->functions;
#line 248
  ret->data = data;
  }
#line 249
  return (ret);
}
}
#line 254 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
void simple_object_release_read(simple_object_read *sobj ) 
{ 


  {
  {
#line 257
  (*((sobj->functions)->release_read))(sobj->data);
#line 258
  free((void *)sobj);
  }
#line 259
  return;
}
}
#line 263 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
char const   *simple_object_attributes_merge(simple_object_attributes *to , simple_object_attributes *from ,
                                             int *err ) 
{ 
  char const   *tmp___0 ;

  {
#line 268
  if ((unsigned long )to->functions != (unsigned long )from->functions) {
#line 270
    *err = 0;
#line 271
    return ("different object file format");
  }
  {
#line 273
  tmp___0 = (*((to->functions)->attributes_merge))(to->data, from->data, err);
  }
#line 273
  return (tmp___0);
}
}
#line 278 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
void simple_object_release_attributes(simple_object_attributes *attrs ) 
{ 


  {
  {
#line 281
  (*((attrs->functions)->release_attributes))(attrs->data);
#line 282
  free((void *)attrs);
  }
#line 283
  return;
}
}
#line 287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
simple_object_write *simple_object_start_write(simple_object_attributes *attrs , char const   *segment_name ,
                                               char const   **errmsg , int *err ) 
{ 
  void *data ;
  simple_object_write *ret ;
  void *tmp___0 ;

  {
  {
#line 295
  data = (*((attrs->functions)->start_write))(attrs->data, errmsg, err);
  }
#line 296
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 297
    return ((simple_object_write *)((void *)0));
  }
  {
#line 298
  tmp___0 = xmalloc(sizeof(simple_object_write ));
#line 298
  ret = (simple_object_write *)tmp___0;
#line 299
  ret->functions = attrs->functions;
#line 300
  ret->segment_name = xstrdup(segment_name);
#line 301
  ret->sections = (simple_object_write_section *)((void *)0);
#line 302
  ret->last_section = (simple_object_write_section *)((void *)0);
#line 303
  ret->data = data;
  }
#line 304
  return (ret);
}
}
#line 309 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
simple_object_write_section *simple_object_write_create_section(simple_object_write *sobj ,
                                                                char const   *name___0 ,
                                                                unsigned int align ,
                                                                char const   **errmsg  __attribute__((__unused__)) ,
                                                                int *err  __attribute__((__unused__)) ) 
{ 
  simple_object_write_section *ret ;
  void *tmp___0 ;

  {
  {
#line 317
  tmp___0 = xmalloc(sizeof(simple_object_write_section ));
#line 317
  ret = (simple_object_write_section *)tmp___0;
#line 318
  ret->next = (simple_object_write_section *)((void *)0);
#line 319
  ret->name = xstrdup(name___0);
#line 320
  ret->align = align;
#line 321
  ret->buffers = (struct simple_object_write_section_buffer *)((void *)0);
#line 322
  ret->last_buffer = (struct simple_object_write_section_buffer *)((void *)0);
  }
#line 324
  if ((unsigned long )sobj->last_section == (unsigned long )((void *)0)) {
#line 326
    sobj->sections = ret;
#line 327
    sobj->last_section = ret;
  } else {
#line 331
    (sobj->last_section)->next = ret;
#line 332
    sobj->last_section = ret;
  }
#line 335
  return (ret);
}
}
#line 340 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
char const   *simple_object_write_add_data(simple_object_write *sobj  __attribute__((__unused__)) ,
                                           simple_object_write_section *section ,
                                           void const   *buffer___2 , size_t size ,
                                           int copy , int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_write_section_buffer *wsb ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 349
  tmp___0 = xmalloc(sizeof(struct simple_object_write_section_buffer ));
#line 349
  wsb = (struct simple_object_write_section_buffer *)tmp___0;
#line 350
  wsb->next = (struct simple_object_write_section_buffer *)((void *)0);
#line 351
  wsb->size = size;
  }
#line 353
  if (! copy) {
#line 355
    wsb->buffer = buffer___2;
#line 356
    wsb->free_buffer = (void *)0;
  } else {
    {
#line 360
    tmp___1 = xmalloc(sizeof(char ) * size);
#line 360
    wsb->free_buffer = (void *)((char *)tmp___1);
#line 361
    memcpy((void */* __restrict  */)wsb->free_buffer, (void const   */* __restrict  */)buffer___2,
           size);
#line 362
    wsb->buffer = (void const   *)wsb->free_buffer;
    }
  }
#line 365
  if ((unsigned long )section->last_buffer == (unsigned long )((void *)0)) {
#line 367
    section->buffers = wsb;
#line 368
    section->last_buffer = wsb;
  } else {
#line 372
    (section->last_buffer)->next = wsb;
#line 373
    section->last_buffer = wsb;
  }
#line 376
  return ((char const   *)((void *)0));
}
}
#line 381 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
char const   *simple_object_write_to_file(simple_object_write *sobj , int descriptor ,
                                          int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 385
  tmp___0 = (*((sobj->functions)->write_to_file))(sobj, descriptor, err);
  }
#line 385
  return (tmp___0);
}
}
#line 390 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object.c"
void simple_object_release_write(simple_object_write *sobj ) 
{ 
  simple_object_write_section *section ;
  struct simple_object_write_section_buffer *buffer___2 ;
  simple_object_write_section *next_section ;
  struct simple_object_write_section_buffer *next_buffer ;

  {
  {
#line 395
  free((void *)sobj->segment_name);
#line 397
  section = sobj->sections;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 398
      goto while_break;
    }
#line 403
    buffer___2 = section->buffers;
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 404
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 404
        goto while_break___0;
      }
#line 408
      if ((unsigned long )buffer___2->free_buffer != (unsigned long )((void *)0)) {
        {
#line 409
        free(buffer___2->free_buffer);
        }
      }
      {
#line 410
      next_buffer = buffer___2->next;
#line 411
      free((void *)buffer___2);
#line 412
      buffer___2 = next_buffer;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 415
    next_section = section->next;
#line 416
    free((void *)section->name);
#line 417
    free((void *)section);
#line 418
    section = next_section;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 421
  (*((sobj->functions)->release_write))(sobj->data);
#line 422
  free((void *)sobj);
  }
#line 423
  return;
}
}
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static unsigned short simple_object_fetch_big_16(unsigned char const   *buf___7 ) 
{ 


  {
#line 185
  return ((unsigned short )(((int )((unsigned short )*(buf___7 + 0)) << 8) | (int )((unsigned short )*(buf___7 + 1))));
}
}
#line 198 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static unsigned int simple_object_fetch_big_32(unsigned char const   *buf___7 ) 
{ 


  {
#line 201
  return (((((unsigned int )*(buf___7 + 0) << 24) | ((unsigned int )*(buf___7 + 1) << 16)) | ((unsigned int )*(buf___7 + 2) << 8)) | (unsigned int )*(buf___7 + 3));
}
}
#line 238 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_big_64(unsigned char const   *buf___7 ) 
{ 


  {
#line 241
  return (((((((((ulong_type )*(buf___7 + 0) << 56) | ((ulong_type )*(buf___7 + 1) << 48)) | ((ulong_type )*(buf___7 + 2) << 40)) | ((ulong_type )*(buf___7 + 3) << 32)) | ((ulong_type )*(buf___7 + 4) << 24)) | ((ulong_type )*(buf___7 + 5) << 16)) | ((ulong_type )*(buf___7 + 6) << 8)) | (ulong_type )*(buf___7 + 7));
}
}
#line 270 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_16(unsigned char *buf___7 , unsigned short val ) 
{ 


  {
#line 273
  *(buf___7 + 0) = (unsigned char )(((int )val >> 8) & 255);
#line 274
  *(buf___7 + 1) = (unsigned char )((int )val & 255);
#line 275
  return;
}
}
#line 288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_32(unsigned char *buf___7 , unsigned int val ) 
{ 


  {
#line 291
  *(buf___7 + 0) = (unsigned char )((val >> 24) & 255U);
#line 292
  *(buf___7 + 1) = (unsigned char )((val >> 16) & 255U);
#line 293
  *(buf___7 + 2) = (unsigned char )((val >> 8) & 255U);
#line 294
  *(buf___7 + 3) = (unsigned char )(val & 255U);
#line 295
  return;
}
}
#line 328 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_64(unsigned char *buf___7 , ulong_type val ) 
{ 


  {
#line 331
  *(buf___7 + 0) = (unsigned char )((val >> 56) & 255UL);
#line 332
  *(buf___7 + 1) = (unsigned char )((val >> 48) & 255UL);
#line 333
  *(buf___7 + 2) = (unsigned char )((val >> 40) & 255UL);
#line 334
  *(buf___7 + 3) = (unsigned char )((val >> 32) & 255UL);
#line 335
  *(buf___7 + 4) = (unsigned char )((val >> 24) & 255UL);
#line 336
  *(buf___7 + 5) = (unsigned char )((val >> 16) & 255UL);
#line 337
  *(buf___7 + 6) = (unsigned char )((val >> 8) & 255UL);
#line 338
  *(buf___7 + 7) = (unsigned char )(val & 255UL);
#line 339
  return;
}
}
#line 291 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void *simple_object_xcoff_match(unsigned char *header , int descriptor , off_t offset ,
                                       char const   *segment_name  __attribute__((__unused__)) ,
                                       char const   **errmsg , int *err ) 
{ 
  unsigned short magic ;
  unsigned short (*fetch_16)(unsigned char const   * ) ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  ulong_type (*fetch_64)(unsigned char const   * ) ;
  unsigned char hdrbuf[sizeof(struct external_filehdr )] ;
  struct simple_object_xcoff_read *ocr ;
  int u64 ;
  int tmp___0 ;
  void *tmp___1 ;
  ulong_type tmp___2 ;
  unsigned short tmp___3 ;
  unsigned int tmp___4 ;
  unsigned short tmp___5 ;

  {
  {
#line 305
  magic = simple_object_fetch_big_16((unsigned char const   *)header);
  }
#line 307
  if ((int )magic != 479) {
#line 307
    if ((int )magic != 503) {
#line 309
      *errmsg = (char const   *)((void *)0);
#line 310
      *err = 0;
#line 311
      return ((void *)0);
    }
  }
  {
#line 314
  fetch_16 = & simple_object_fetch_big_16;
#line 315
  fetch_32 = & simple_object_fetch_big_32;
#line 316
  fetch_64 = & simple_object_fetch_big_64;
#line 318
  tmp___0 = simple_object_internal_read(descriptor, offset, hdrbuf, sizeof(hdrbuf),
                                        errmsg, err);
  }
#line 318
  if (! tmp___0) {
#line 320
    return ((void *)0);
  }
  {
#line 322
  u64 = (int )magic == 503;
#line 324
  tmp___1 = xmalloc(sizeof(struct simple_object_xcoff_read ));
#line 324
  ocr = (struct simple_object_xcoff_read *)tmp___1;
#line 325
  ocr->magic = magic;
#line 326
  ocr->nscns = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_nscns)));
  }
#line 327
  if (u64) {
    {
#line 329
    tmp___2 = (*fetch_64)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_symptr)));
#line 329
    ocr->symptr = (off_t )tmp___2;
#line 332
    ocr->nsyms = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_nsyms)));
#line 334
    tmp___3 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_opthdr)));
#line 334
    ocr->scnhdr_offset = (off_t )(sizeof(struct external_filehdr ) + (unsigned long )tmp___3);
    }
  } else {
    {
#line 341
    tmp___4 = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff32.f_symptr)));
#line 341
    ocr->symptr = (off_t )tmp___4;
#line 344
    ocr->nsyms = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff32.f_nsyms)));
#line 346
    tmp___5 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff32.f_opthdr)));
#line 346
    ocr->scnhdr_offset = (off_t )((sizeof(struct external_filehdr ) - 4UL) + (unsigned long )tmp___5);
    }
  }
#line 352
  return ((void *)ocr);
}
}
#line 357 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static char *simple_object_xcoff_read_strtab(simple_object_read *sobj , size_t *strtab_size ,
                                             char const   **errmsg , int *err ) 
{ 
  struct simple_object_xcoff_read *ocr ;
  off_t strtab_offset ;
  unsigned char strsizebuf[4] ;
  size_t strsize ;
  char *strtab ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 361
  ocr = (struct simple_object_xcoff_read *)sobj->data;
#line 368
  strtab_offset = (sobj->offset + ocr->symptr) + (off_t )(ocr->nsyms * 18U);
#line 370
  tmp___0 = simple_object_internal_read(sobj->descriptor, strtab_offset, strsizebuf,
                                        (size_t )4, errmsg, err);
  }
#line 370
  if (! tmp___0) {
#line 372
    return ((char *)((void *)0));
  }
  {
#line 373
  tmp___1 = simple_object_fetch_big_32((unsigned char const   *)(strsizebuf));
#line 373
  strsize = (size_t )tmp___1;
#line 374
  tmp___2 = xmalloc(sizeof(char ) * strsize);
#line 374
  strtab = (char *)tmp___2;
#line 375
  tmp___3 = simple_object_internal_read(sobj->descriptor, strtab_offset, (unsigned char *)strtab,
                                        strsize, errmsg, err);
  }
#line 375
  if (! tmp___3) {
    {
#line 379
    free((void *)strtab);
    }
#line 380
    return ((char *)((void *)0));
  }
#line 382
  *strtab_size = strsize;
#line 383
  return (strtab);
}
}
#line 388 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static char const   *simple_object_xcoff_find_sections(simple_object_read *sobj ,
                                                       int (*pfn)(void * , char const   * ,
                                                                  off_t offset , off_t length ) ,
                                                       void *data , int *err ) 
{ 
  struct simple_object_xcoff_read *ocr ;
  int u64 ;
  size_t scnhdr_size ;
  unsigned char *scnbuf ;
  char const   *errmsg ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  ulong_type (*fetch_64)(unsigned char const   * ) ;
  unsigned int nscns ;
  char *strtab ;
  size_t strtab_size ;
  unsigned int i ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char *scnhdr ;
  unsigned char *scnname ;
  char namebuf[9] ;
  char *name___0 ;
  off_t scnptr ;
  unsigned int size ;
  size_t strindex ;
  char *end ;
  long tmp___2 ;
  ulong_type tmp___3 ;
  ulong_type tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 395
  ocr = (struct simple_object_xcoff_read *)sobj->data;
#line 397
  u64 = (int )ocr->magic == 503;
#line 408
  if (u64) {
#line 408
    scnhdr_size = (size_t )68;
  } else {
#line 408
    scnhdr_size = (size_t )40;
  }
  {
#line 409
  tmp___0 = xmalloc(sizeof(unsigned char ) * (scnhdr_size * (size_t )ocr->nscns));
#line 409
  scnbuf = (unsigned char *)tmp___0;
#line 410
  tmp___1 = simple_object_internal_read(sobj->descriptor, sobj->offset + ocr->scnhdr_offset,
                                        scnbuf, scnhdr_size * (size_t )ocr->nscns,
                                        & errmsg, err);
  }
#line 410
  if (! tmp___1) {
    {
#line 415
    free((void *)scnbuf);
    }
#line 416
    return (errmsg);
  }
#line 419
  fetch_32 = & simple_object_fetch_big_32;
#line 420
  fetch_64 = & simple_object_fetch_big_64;
#line 422
  nscns = (unsigned int )ocr->nscns;
#line 423
  strtab = (char *)((void *)0);
#line 424
  strtab_size = (size_t )0;
#line 425
  i = 0U;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i < nscns)) {
#line 425
      goto while_break;
    }
    {
#line 434
    scnhdr = scnbuf + (size_t )i * scnhdr_size;
#line 435
    scnname = scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name);
#line 436
    memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)scnname,
           (size_t )8);
#line 437
    namebuf[8] = (char )'\000';
#line 438
    name___0 = & namebuf[0];
    }
#line 439
    if ((int )namebuf[0] == 47) {
      {
#line 444
      tmp___2 = strtol((char const   */* __restrict  */)(namebuf + 1), (char **/* __restrict  */)(& end),
                       10);
#line 444
      strindex = (size_t )tmp___2;
      }
#line 445
      if ((int )*end == 0) {
#line 449
        if ((unsigned long )strtab == (unsigned long )((void *)0)) {
          {
#line 451
          strtab = simple_object_xcoff_read_strtab(sobj, & strtab_size, & errmsg,
                                                   err);
          }
#line 454
          if ((unsigned long )strtab == (unsigned long )((void *)0)) {
            {
#line 456
            free((void *)scnbuf);
            }
#line 457
            return (errmsg);
          }
        }
#line 461
        if (strindex < 4UL) {
          {
#line 463
          free((void *)strtab);
#line 464
          free((void *)scnbuf);
#line 465
          *err = 0;
          }
#line 466
          return ("section string index out of range");
        } else
#line 461
        if (strindex >= strtab_size) {
          {
#line 463
          free((void *)strtab);
#line 464
          free((void *)scnbuf);
#line 465
          *err = 0;
          }
#line 466
          return ("section string index out of range");
        }
#line 469
        name___0 = strtab + strindex;
      }
    }
#line 473
    if (u64) {
      {
#line 475
      tmp___3 = (*fetch_64)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff64.s_scnptr)));
#line 475
      scnptr = (off_t )tmp___3;
#line 477
      tmp___4 = (*fetch_64)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff64.s_size)));
#line 477
      size = (unsigned int )tmp___4;
      }
    } else {
      {
#line 482
      tmp___5 = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff32.s_scnptr)));
#line 482
      scnptr = (off_t )tmp___5;
#line 484
      size = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff32.s_size)));
      }
    }
    {
#line 488
    tmp___6 = (*pfn)(data, (char const   *)name___0, scnptr, (off_t )size);
    }
#line 488
    if (! tmp___6) {
#line 489
      goto while_break;
    }
#line 425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if ((unsigned long )strtab != (unsigned long )((void *)0)) {
    {
#line 493
    free((void *)strtab);
    }
  }
  {
#line 494
  free((void *)scnbuf);
  }
#line 496
  return ((char const   *)((void *)0));
}
}
#line 501 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void *simple_object_xcoff_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                  int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_xcoff_read *ocr ;
  struct simple_object_xcoff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 506
  ocr = (struct simple_object_xcoff_read *)sobj->data;
#line 510
  tmp___0 = xmalloc(sizeof(struct simple_object_xcoff_attributes ));
#line 510
  ret = (struct simple_object_xcoff_attributes *)tmp___0;
#line 511
  ret->magic = ocr->magic;
#line 512
  ret->flags = ocr->flags;
  }
#line 513
  return ((void *)ret);
}
}
#line 518 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void simple_object_xcoff_release_read(void *data ) 
{ 


  {
  {
#line 521
  free(data);
  }
#line 522
  return;
}
}
#line 526 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static char const   *simple_object_xcoff_attributes_merge(void *todata , void *fromdata ,
                                                          int *err ) 
{ 
  struct simple_object_xcoff_attributes *to ;
  struct simple_object_xcoff_attributes *from ;

  {
#line 529
  to = (struct simple_object_xcoff_attributes *)todata;
#line 531
  from = (struct simple_object_xcoff_attributes *)fromdata;
#line 534
  if ((int )to->magic != (int )from->magic) {
#line 536
    *err = 0;
#line 537
    return ("XCOFF object format mismatch");
  }
#line 539
  return ((char const   *)((void *)0));
}
}
#line 544 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void simple_object_xcoff_release_attributes(void *data ) 
{ 


  {
  {
#line 547
  free(data);
  }
#line 548
  return;
}
}
#line 552 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void *simple_object_xcoff_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                             int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_xcoff_attributes *attrs ;
  struct simple_object_xcoff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 557
  attrs = (struct simple_object_xcoff_attributes *)attributes_data;
#line 563
  tmp___0 = xmalloc(sizeof(struct simple_object_xcoff_attributes ));
#line 563
  ret = (struct simple_object_xcoff_attributes *)tmp___0;
#line 564
  *ret = *attrs;
  }
#line 565
  return ((void *)ret);
}
}
#line 570 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static int simple_object_xcoff_write_filehdr(simple_object_write *sobj , int descriptor ,
                                             unsigned int nscns , size_t symtab_offset ,
                                             unsigned int nsyms , char const   **errmsg ,
                                             int *err ) 
{ 
  struct simple_object_xcoff_attributes *attrs ;
  int u64 ;
  unsigned char hdrbuf[sizeof(struct external_filehdr )] ;
  unsigned char *hdr ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  void (*set_64)(unsigned char * , ulong_type  ) ;
  int tmp___0 ;

  {
  {
#line 576
  attrs = (struct simple_object_xcoff_attributes *)sobj->data;
#line 578
  u64 = (int )attrs->magic == 503;
#line 585
  hdr = & hdrbuf[0];
#line 587
  set_16 = & simple_object_set_big_16;
#line 588
  set_32 = & simple_object_set_big_32;
#line 589
  set_64 = & simple_object_set_big_64;
#line 591
  memset((void *)hdr, 0, sizeof(struct external_filehdr ));
#line 593
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_magic), attrs->magic);
#line 594
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_nscns), (unsigned short )nscns);
  }
#line 596
  if (u64) {
    {
#line 598
    (*set_64)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_symptr),
              symtab_offset);
#line 600
    (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_nsyms),
              nsyms);
#line 603
    (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_flags),
              attrs->flags);
    }
  } else {
    {
#line 608
    (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_symptr),
              (unsigned int )symtab_offset);
#line 610
    (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_nsyms),
              nsyms);
#line 613
    (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->u.xcoff64.f_flags),
              attrs->flags);
    }
  }
  {
#line 617
  tmp___0 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(hdrbuf),
                                         sizeof(struct external_filehdr ), errmsg,
                                         err);
  }
#line 617
  return (tmp___0);
}
}
#line 624 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static int simple_object_xcoff_write_scnhdr(simple_object_write *sobj , int descriptor ,
                                            char const   *name___0 , size_t *name_offset ,
                                            off_t scnhdr_offset , size_t scnsize ,
                                            off_t offset , unsigned int align , char const   **errmsg ,
                                            int *err ) 
{ 
  struct simple_object_xcoff_read *ocr ;
  int u64 ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  void (*set_64)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct external_scnhdr )] ;
  unsigned char *hdr ;
  size_t namelen ;
  unsigned int flags___1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 632
  ocr = (struct simple_object_xcoff_read *)sobj->data;
#line 634
  u64 = (int )ocr->magic == 503;
#line 642
  set_32 = & simple_object_set_big_32;
#line 643
  set_64 = & simple_object_set_big_32;
#line 645
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 646
  hdr = & hdrbuf[0];
#line 648
  namelen = strlen(name___0);
  }
#line 649
  if (namelen <= 8UL) {
    {
#line 650
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name)),
            (char const   */* __restrict  */)name___0, (size_t )8);
    }
  } else {
    {
#line 654
    snprintf((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name)),
             (size_t )8, (char const   */* __restrict  */)"/%lu", *name_offset);
#line 656
    *name_offset += namelen + 1UL;
    }
  }
#line 661
  if (u64) {
    {
#line 663
    (*set_64)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff64.s_size),
              (unsigned int )scnsize);
#line 665
    (*set_64)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff64.s_scnptr),
              (unsigned int )offset);
    }
  } else {
    {
#line 670
    (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff32.s_size),
              (unsigned int )scnsize);
#line 672
    (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff32.s_scnptr),
              (unsigned int )offset);
    }
  }
#line 679
  flags___1 = 64U;
#line 680
  if (align > 13U) {
#line 681
    align = 13U;
  }
#line 682
  if (u64) {
    {
#line 683
    (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff64.s_flags),
              flags___1);
    }
  } else {
    {
#line 685
    (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->u.xcoff32.s_flags),
              flags___1);
    }
  }
#line 687
  if (u64) {
#line 687
    tmp___0 = 68;
  } else {
#line 687
    tmp___0 = 40;
  }
  {
#line 687
  tmp___1 = simple_object_internal_write(descriptor, scnhdr_offset, (unsigned char const   *)(hdrbuf),
                                         (size_t )tmp___0, errmsg, err);
  }
#line 687
  return (tmp___1);
}
}
#line 694 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static char const   *simple_object_xcoff_write_to_file(simple_object_write *sobj ,
                                                       int descriptor , int *err ) 
{ 
  struct simple_object_xcoff_read *ocr ;
  int u64 ;
  unsigned int nscns ;
  unsigned int secnum ;
  simple_object_write_section *section ;
  off_t scnhdr_offset ;
  size_t symtab_offset ;
  off_t secsym_offset ;
  unsigned int nsyms ;
  size_t offset ;
  size_t name_offset ;
  char const   *errmsg ;
  unsigned char strsizebuf[4] ;
  char const   *source_filename ;
  size_t sflen ;
  union __anonunion_syms_806857204 syms[2] ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  int tmp___0 ;
  int tmp___1 ;
  size_t mask ;
  size_t new_offset ;
  size_t scnsize ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t namelen ;
  size_t scnsize___0 ;
  struct simple_object_write_section_buffer *buffer___3 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 698
  ocr = (struct simple_object_xcoff_read *)sobj->data;
#line 700
  u64 = (int )ocr->magic == 503;
#line 714
  source_filename = "fake";
#line 724
  set_16 = & simple_object_set_big_16;
#line 725
  set_32 = & simple_object_set_big_32;
#line 727
  nscns = 0U;
#line 728
  section = sobj->sections;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 728
      goto while_break;
    }
#line 729
    nscns ++;
#line 728
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  if (u64) {
#line 731
    tmp___0 = 4;
  } else {
#line 731
    tmp___0 = 0;
  }
#line 731
  scnhdr_offset = (off_t )(sizeof(struct external_filehdr ) - (unsigned long )tmp___0);
#line 732
  if (u64) {
#line 732
    tmp___1 = 68;
  } else {
#line 732
    tmp___1 = 40;
  }
#line 732
  offset = (size_t )(scnhdr_offset + (off_t )(nscns * (unsigned int )tmp___1));
#line 733
  name_offset = (size_t )4;
#line 734
  section = sobj->sections;
  {
#line 734
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 734
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 734
      goto while_break___0;
    }
#line 741
    mask = (size_t )((1U << section->align) - 1U);
#line 742
    new_offset = offset & mask;
#line 743
    new_offset &= ~ mask;
    {
#line 744
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 744
      if (! (new_offset > offset)) {
#line 744
        goto while_break___1;
      }
      {
#line 749
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 750
      write___0 = new_offset - offset;
      }
#line 751
      if (write___0 > sizeof(zeroes)) {
#line 752
        write___0 = sizeof(zeroes);
      }
      {
#line 753
      tmp___2 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(zeroes),
                                             write___0, & errmsg, err);
      }
#line 753
      if (! tmp___2) {
#line 755
        return (errmsg);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 758
    scnsize = (size_t )0;
#line 759
    buffer___2 = section->buffers;
    {
#line 759
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 759
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 759
        goto while_break___2;
      }
      {
#line 761
      tmp___3 = simple_object_internal_write(descriptor, (off_t )(offset + scnsize),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, & errmsg, err);
      }
#line 761
      if (! tmp___3) {
#line 765
        return (errmsg);
      }
#line 766
      scnsize += buffer___2->size;
#line 759
      buffer___2 = buffer___2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 769
    tmp___4 = simple_object_xcoff_write_scnhdr(sobj, descriptor, (char const   *)section->name,
                                               & name_offset, scnhdr_offset, scnsize,
                                               (off_t )offset, section->align, & errmsg,
                                               err);
    }
#line 769
    if (! tmp___4) {
#line 773
      return (errmsg);
    }
#line 775
    if (u64) {
#line 775
      tmp___5 = 68;
    } else {
#line 775
      tmp___5 = 40;
    }
#line 775
    scnhdr_offset += (off_t )tmp___5;
#line 776
    offset += scnsize;
#line 734
    section = section->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 780
  offset += offset & 1UL;
#line 783
  nsyms = 2U * (nscns + 1U);
#line 784
  symtab_offset = offset;
#line 787
  offset += (size_t )(nsyms * 18U);
#line 790
  memset((void *)(& syms[0]), 0, sizeof(syms));
  }
#line 791
  if (! u64) {
    {
#line 792
    strcpy((char */* __restrict  */)(& syms[0].sym.u.xcoff32.n.n_name[0]), (char const   */* __restrict  */)".file");
    }
  }
  {
#line 793
  (*set_16)(& syms[0].sym.n_scnum[0], (unsigned short)65534);
#line 794
  (*set_16)(& syms[0].sym.n_type[0], (unsigned short)0);
#line 795
  syms[0].sym.n_sclass[0] = (unsigned char)103;
#line 796
  syms[0].sym.n_numaux[0] = (unsigned char)1;
#line 799
  sflen = strlen(source_filename);
  }
#line 800
  if (sflen <= 14UL) {
    {
#line 801
    memcpy((void */* __restrict  */)(& syms[1].aux.x_file.x_fname[0]), (void const   */* __restrict  */)source_filename,
           sflen);
    }
  } else {
    {
#line 804
    (*set_32)(& syms[1].aux.x_file._x.x_offset[0], (unsigned int )name_offset);
#line 805
    tmp___6 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                           (unsigned char const   *)source_filename,
                                           sflen + 1UL, & errmsg, err);
    }
#line 805
    if (! tmp___6) {
#line 809
      return (errmsg);
    }
    {
#line 810
    tmp___7 = strlen(source_filename);
#line 810
    name_offset += tmp___7 + 1UL;
    }
  }
  {
#line 812
  tmp___8 = simple_object_internal_write(descriptor, (off_t )symtab_offset, (unsigned char const   *)(& syms[0]),
                                         sizeof(syms), & errmsg, err);
  }
#line 812
  if (! tmp___8) {
#line 815
    return (errmsg);
  }
  {
#line 819
  (*set_32)(strsizebuf, (unsigned int )name_offset);
#line 820
  tmp___9 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(strsizebuf),
                                         (size_t )4, & errmsg, err);
  }
#line 820
  if (! tmp___9) {
#line 822
    return (errmsg);
  }
  {
#line 824
  name_offset = (size_t )4;
#line 825
  secsym_offset = (off_t )(symtab_offset + sizeof(syms));
#line 826
  memset((void *)(& syms[0]), 0, sizeof(syms));
#line 827
  (*set_16)(& syms[0].sym.n_type[0], (unsigned short)0);
#line 828
  syms[0].sym.n_sclass[0] = (unsigned char)3;
#line 829
  syms[0].sym.n_numaux[0] = (unsigned char)1;
#line 830
  secnum = 1U;
#line 832
  section = sobj->sections;
  }
  {
#line 832
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 832
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 832
      goto while_break___3;
    }
    {
#line 838
    namelen = strlen((char const   *)section->name);
#line 839
    tmp___10 = secnum;
#line 839
    secnum ++;
#line 839
    (*set_16)(& syms[0].sym.n_scnum[0], (unsigned short )tmp___10);
#line 840
    scnsize___0 = (size_t )0;
#line 841
    buffer___3 = section->buffers;
    }
    {
#line 841
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 841
      if (! ((unsigned long )buffer___3 != (unsigned long )((void *)0))) {
#line 841
        goto while_break___4;
      }
#line 842
      scnsize___0 += buffer___3->size;
#line 841
      buffer___3 = buffer___3->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 843
    (*set_32)(& syms[1].aux.x_scn.x_scnlen[0], (unsigned int )scnsize___0);
    }
#line 844
    if (namelen > 8UL) {
      {
#line 846
      (*set_32)(& syms[0].sym.u.xcoff32.n.n.n_zeroes[0], 0U);
#line 847
      (*set_32)(& syms[0].sym.u.xcoff32.n.n.n_offset[0], (unsigned int )name_offset);
#line 848
      tmp___11 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                              (unsigned char const   *)section->name,
                                              namelen + 1UL, & errmsg, err);
      }
#line 848
      if (! tmp___11) {
#line 852
        return (errmsg);
      }
#line 853
      name_offset += namelen + 1UL;
    } else {
      {
#line 857
      tmp___12 = strlen((char const   *)section->name);
#line 857
      memcpy((void */* __restrict  */)(& syms[0].sym.u.xcoff32.n.n_name[0]), (void const   */* __restrict  */)section->name,
             tmp___12);
#line 859
      tmp___13 = strlen((char const   *)section->name);
#line 859
      tmp___14 = strlen((char const   *)section->name);
#line 859
      memset((void *)(& syms[0].sym.u.xcoff32.n.n_name[tmp___14]), 0, 8UL - tmp___13);
      }
    }
    {
#line 863
    tmp___15 = simple_object_internal_write(descriptor, secsym_offset, (unsigned char const   *)(& syms[0]),
                                            sizeof(syms), & errmsg, err);
    }
#line 863
    if (! tmp___15) {
#line 866
      return (errmsg);
    }
#line 867
    secsym_offset = (off_t )((unsigned long )secsym_offset + sizeof(syms));
#line 832
    section = section->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 870
  tmp___16 = simple_object_xcoff_write_filehdr(sobj, descriptor, nscns, symtab_offset,
                                               nsyms, & errmsg, err);
  }
#line 870
  if (! tmp___16) {
#line 872
    return (errmsg);
  }
#line 874
  return ((char const   *)((void *)0));
}
}
#line 879 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
static void simple_object_xcoff_release_write(void *data ) 
{ 


  {
  {
#line 882
  free(data);
  }
#line 883
  return;
}
}
#line 887 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-xcoff.c"
struct simple_object_functions  const  simple_object_xcoff_functions  = 
#line 887
     {& simple_object_xcoff_match, & simple_object_xcoff_find_sections, & simple_object_xcoff_fetch_attributes,
    & simple_object_xcoff_release_read, & simple_object_xcoff_attributes_merge, & simple_object_xcoff_release_attributes,
    & simple_object_xcoff_start_write, & simple_object_xcoff_write_to_file, & simple_object_xcoff_release_write};
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 209 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static unsigned int simple_object_fetch_little_32(unsigned char const   *buf___7 ) 
{ 


  {
#line 212
  return (((((unsigned int )*(buf___7 + 3) << 24) | ((unsigned int )*(buf___7 + 2) << 16)) | ((unsigned int )*(buf___7 + 1) << 8)) | (unsigned int )*(buf___7 + 0));
}
}
#line 253 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_little_64(unsigned char const   *buf___7 ) 
{ 


  {
#line 256
  return (((((((((ulong_type )*(buf___7 + 7) << 56) | ((ulong_type )*(buf___7 + 6) << 48)) | ((ulong_type )*(buf___7 + 5) << 40)) | ((ulong_type )*(buf___7 + 4) << 32)) | ((ulong_type )*(buf___7 + 3) << 24)) | ((ulong_type )*(buf___7 + 2) << 16)) | ((ulong_type )*(buf___7 + 1) << 8)) | (ulong_type )*(buf___7 + 0));
}
}
#line 299 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_32(unsigned char *buf___7 , unsigned int val ) 
{ 


  {
#line 302
  *(buf___7 + 3) = (unsigned char )((val >> 24) & 255U);
#line 303
  *(buf___7 + 2) = (unsigned char )((val >> 16) & 255U);
#line 304
  *(buf___7 + 1) = (unsigned char )((val >> 8) & 255U);
#line 305
  *(buf___7 + 0) = (unsigned char )(val & 255U);
#line 306
  return;
}
}
#line 343 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_64(unsigned char *buf___7 , ulong_type val ) 
{ 


  {
#line 346
  *(buf___7 + 7) = (unsigned char )((val >> 56) & 255UL);
#line 347
  *(buf___7 + 6) = (unsigned char )((val >> 48) & 255UL);
#line 348
  *(buf___7 + 5) = (unsigned char )((val >> 40) & 255UL);
#line 349
  *(buf___7 + 4) = (unsigned char )((val >> 32) & 255UL);
#line 350
  *(buf___7 + 3) = (unsigned char )((val >> 24) & 255UL);
#line 351
  *(buf___7 + 2) = (unsigned char )((val >> 16) & 255UL);
#line 352
  *(buf___7 + 1) = (unsigned char )((val >> 8) & 255UL);
#line 353
  *(buf___7 + 0) = (unsigned char )(val & 255UL);
#line 354
  return;
}
}
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_match(unsigned char *header , int descriptor , off_t offset ,
                                        char const   *segment_name , char const   **errmsg ,
                                        int *err ) 
{ 
  unsigned int magic ;
  int is_big_endian ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned int filetype ;
  struct simple_object_mach_o_read *omr ;
  unsigned char buf___7[sizeof(struct mach_o_header_64 )] ;
  unsigned char *b ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 256
  magic = simple_object_fetch_big_32((unsigned char const   *)header);
  }
#line 257
  if (magic == 4277009102U) {
#line 258
    is_big_endian = 1;
  } else
#line 257
  if (magic == 4277009103U) {
#line 258
    is_big_endian = 1;
  } else {
    {
#line 261
    magic = simple_object_fetch_little_32((unsigned char const   *)header);
    }
#line 262
    if (magic == 4277009102U) {
#line 263
      is_big_endian = 0;
    } else
#line 262
    if (magic == 4277009103U) {
#line 263
      is_big_endian = 0;
    } else {
#line 266
      *errmsg = (char const   *)((void *)0);
#line 267
      *err = 0;
#line 268
      return ((void *)0);
    }
  }
#line 284
  if ((unsigned long )segment_name == (unsigned long )((void *)0)) {
#line 286
    *errmsg = "Mach-O file found but no segment name specified";
#line 287
    *err = 0;
#line 288
    return ((void *)0);
  }
  {
#line 291
  tmp___0 = strlen(segment_name);
  }
#line 291
  if (tmp___0 > 16UL) {
#line 293
    *errmsg = "Mach-O segment name too long";
#line 294
    *err = 0;
#line 295
    return ((void *)0);
  }
#line 301
  if (is_big_endian) {
#line 301
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 301
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 305
  if (magic == 4277009102U) {
#line 305
    tmp___1 = sizeof(struct mach_o_header_32 );
  } else {
#line 305
    tmp___1 = sizeof(struct mach_o_header_64 );
  }
  {
#line 305
  tmp___2 = simple_object_internal_read(descriptor, offset, buf___7, tmp___1, errmsg,
                                        err);
  }
#line 305
  if (! tmp___2) {
#line 310
    return ((void *)0);
  }
  {
#line 312
  b = & buf___7[0];
#line 314
  filetype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->filetype)));
  }
#line 315
  if (filetype != 1U) {
#line 317
    *errmsg = "Mach-O file is not object file";
#line 318
    *err = 0;
#line 319
    return ((void *)0);
  }
  {
#line 322
  tmp___3 = xmalloc(sizeof(struct simple_object_mach_o_read ));
#line 322
  omr = (struct simple_object_mach_o_read *)tmp___3;
#line 323
  omr->segment_name = xstrdup(segment_name);
#line 324
  omr->magic = magic;
#line 325
  omr->is_big_endian = is_big_endian;
#line 326
  omr->cputype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->cputype)));
#line 327
  omr->cpusubtype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->cpusubtype)));
#line 330
  omr->ncmds = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->ncmds)));
#line 331
  omr->flags = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->flags)));
  }
#line 332
  if (magic == 4277009102U) {
#line 333
    omr->reserved = 0U;
  } else {
    {
#line 335
    omr->reserved = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_64 *)0)->reserved)));
    }
  }
#line 339
  return ((void *)omr);
}
}
#line 344 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_section_info(int is_big_endian , int is_32 , unsigned char const   *sechdr ,
                                              off_t *offset , size_t *size ) 
{ 
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  ulong_type (*fetch_64)(unsigned char const   * ) ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 352
  if (is_big_endian) {
#line 352
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 352
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 356
  fetch_64 = (ulong_type (*)(unsigned char const   * ))((void *)0);
#line 358
  if (is_big_endian) {
#line 358
    fetch_64 = & simple_object_fetch_big_64;
  } else {
#line 358
    fetch_64 = & simple_object_fetch_little_64;
  }
#line 363
  if (is_32) {
    {
#line 365
    tmp___0 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->offset));
#line 365
    *offset = (off_t )tmp___0;
#line 367
    tmp___1 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->size));
#line 367
    *size = (size_t )tmp___1;
    }
  } else {
    {
#line 372
    tmp___2 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->offset));
#line 372
    *offset = (off_t )tmp___2;
#line 374
    *size = (*fetch_64)(sechdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->size));
    }
  }
#line 377
  return;
}
}
#line 403 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_segment(simple_object_read *sobj , off_t offset ,
                                        unsigned char const   *segbuf , int (*pfn)(void * ,
                                                                                   char const   * ,
                                                                                   off_t offset ,
                                                                                   off_t length ) ,
                                        void *data , char const   **errmsg , int *err ) 
{ 
  struct simple_object_mach_o_read *omr ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  int is_32 ;
  size_t seghdrsize ;
  size_t sechdrsize ;
  size_t segname_offset ;
  size_t sectname_offset ;
  unsigned int nsects ;
  unsigned char *secdata ;
  unsigned int i ;
  unsigned int gnu_sections_found ;
  unsigned int strtab_index ;
  unsigned int index_index ;
  unsigned int nametab_index ;
  unsigned int sections_index ;
  char *strtab ;
  char *nametab ;
  unsigned char *index___0 ;
  size_t strtab_size ;
  size_t nametab_size ;
  size_t index_size ;
  unsigned int n_wrapped_sects ;
  size_t wrapper_sect_size ;
  off_t wrapper_sect_offset ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t nameoff ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  off_t nametab_offset ;
  off_t index_offset ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  off_t strtab_offset ;
  void *tmp___11 ;
  int tmp___12 ;
  unsigned char const   *sechdr ;
  char namebuf[34] ;
  char *name___0 ;
  off_t secoffset ;
  size_t secsize ;
  int l ;
  int tmp___13 ;
  unsigned int j ;
  unsigned int subsect_offset ;
  unsigned int subsect_length ;
  unsigned int name_offset ;
  int tmp___14 ;
  unsigned long stringoffset ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
#line 411
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 435
  wrapper_sect_offset = (off_t )0;
#line 437
  if (omr->is_big_endian) {
#line 437
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 437
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 441
  is_32 = omr->magic == 4277009102U;
#line 443
  if (is_32) {
    {
#line 445
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
#line 446
    sechdrsize = sizeof(struct mach_o_section_32 );
#line 447
    segname_offset = (unsigned long )(& ((struct mach_o_section_32 *)0)->segname);
#line 448
    sectname_offset = (unsigned long )(& ((struct mach_o_section_32 *)0)->sectname);
#line 449
    nsects = (*fetch_32)(segbuf + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->nsects));
    }
  } else {
    {
#line 455
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
#line 456
    sechdrsize = sizeof(struct mach_o_section_64 );
#line 457
    segname_offset = (unsigned long )(& ((struct mach_o_section_64 *)0)->segname);
#line 458
    sectname_offset = (unsigned long )(& ((struct mach_o_section_64 *)0)->sectname);
#line 459
    nsects = (*fetch_32)(segbuf + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->nsects));
    }
  }
  {
#line 466
  tmp___0 = xmalloc(sizeof(unsigned char ) * ((size_t )nsects * sechdrsize));
#line 466
  secdata = (unsigned char *)tmp___0;
#line 467
  tmp___1 = simple_object_internal_read(sobj->descriptor, (off_t )((size_t )offset + seghdrsize),
                                        secdata, (size_t )nsects * sechdrsize, errmsg,
                                        err);
  }
#line 467
  if (! tmp___1) {
    {
#line 470
    free((void *)secdata);
    }
#line 471
    return (0);
  }
#line 476
  gnu_sections_found = 0U;
#line 477
  index_index = nsects;
#line 478
  sections_index = nsects;
#line 479
  strtab_index = nsects;
#line 480
  nametab_index = nsects;
#line 481
  i = 0U;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < nsects)) {
#line 481
      goto while_break;
    }
    {
#line 485
    nameoff = (size_t )i * sechdrsize + segname_offset;
#line 486
    tmp___2 = strcmp((char const   *)((char *)secdata + nameoff), (char const   *)omr->segment_name);
    }
#line 486
    if (tmp___2 != 0) {
#line 487
      goto __Cont;
    }
    {
#line 489
    nameoff = (size_t )i * sechdrsize + sectname_offset;
#line 490
    tmp___6 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_names");
    }
#line 490
    if (tmp___6 == 0) {
#line 492
      nametab_index = i;
#line 493
      gnu_sections_found |= 4U;
    } else {
      {
#line 495
      tmp___5 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_index");
      }
#line 495
      if (tmp___5 == 0) {
#line 497
        index_index = i;
#line 498
        gnu_sections_found |= 2U;
      } else {
        {
#line 500
        tmp___4 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_sects");
        }
#line 500
        if (tmp___4 == 0) {
#line 502
          sections_index = i;
#line 503
          gnu_sections_found |= 1U;
        } else {
          {
#line 505
          tmp___3 = strcmp((char const   *)((char *)secdata + nameoff), "__section_names");
          }
#line 505
          if (tmp___3 == 0) {
#line 507
            strtab_index = i;
#line 508
            gnu_sections_found |= 8U;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if ((gnu_sections_found & 7U) != 0U) {
#line 520
    if ((gnu_sections_found & 7U) != 7U) {
      {
#line 522
      *errmsg = "GNU Mach-o section wrapper: required section missing";
#line 523
      *err = 0;
#line 524
      free((void *)secdata);
      }
#line 525
      return (0);
    }
    {
#line 530
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )nametab_index * sechdrsize),
                                      & nametab_offset, & nametab_size);
#line 533
    tmp___7 = xmalloc(sizeof(char ) * nametab_size);
#line 533
    nametab = (char *)tmp___7;
#line 534
    tmp___8 = simple_object_internal_read(sobj->descriptor, sobj->offset + nametab_offset,
                                          (unsigned char *)nametab, nametab_size,
                                          errmsg, err);
    }
#line 534
    if (! tmp___8) {
      {
#line 539
      free((void *)nametab);
#line 540
      free((void *)secdata);
      }
#line 541
      return (0);
    }
    {
#line 546
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )index_index * sechdrsize),
                                      & index_offset, & index_size);
#line 549
    tmp___9 = xmalloc(sizeof(unsigned char ) * index_size);
#line 549
    index___0 = (unsigned char *)tmp___9;
#line 550
    tmp___10 = simple_object_internal_read(sobj->descriptor, sobj->offset + index_offset,
                                           index___0, index_size, errmsg, err);
    }
#line 550
    if (! tmp___10) {
      {
#line 555
      free((void *)index___0);
#line 556
      free((void *)nametab);
#line 557
      free((void *)secdata);
      }
#line 558
      return (0);
    }
    {
#line 565
    n_wrapped_sects = (unsigned int )(index_size / 16UL);
#line 568
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )sections_index * sechdrsize),
                                      & wrapper_sect_offset, & wrapper_sect_size);
    }
  } else {
#line 575
    index___0 = (unsigned char *)((void *)0);
#line 576
    index_size = (size_t )0;
#line 577
    nametab = (char *)((void *)0);
#line 578
    nametab_size = (size_t )0;
#line 579
    n_wrapped_sects = 0U;
  }
#line 584
  if ((gnu_sections_found & 8U) != 0U) {
    {
#line 588
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )strtab_index * sechdrsize),
                                      & strtab_offset, & strtab_size);
#line 591
    tmp___11 = xmalloc(sizeof(char ) * strtab_size);
#line 591
    strtab = (char *)tmp___11;
#line 592
    tmp___12 = simple_object_internal_read(sobj->descriptor, sobj->offset + strtab_offset,
                                           (unsigned char *)strtab, strtab_size, errmsg,
                                           err);
    }
#line 592
    if (! tmp___12) {
      {
#line 597
      free((void *)strtab);
#line 598
      free((void *)index___0);
#line 599
      free((void *)nametab);
#line 600
      free((void *)secdata);
      }
#line 601
      return (0);
    }
  } else {
#line 606
    strtab = (char *)((void *)0);
#line 607
    strtab_size = (size_t )0;
#line 608
    strtab_index = nsects;
  }
#line 613
  i = 0U;
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (! (i < nsects)) {
#line 613
      goto while_break___0;
    }
#line 622
    sechdr = (unsigned char const   *)(secdata + (size_t )i * sechdrsize);
#line 626
    if ((gnu_sections_found & 8U) != 0U) {
#line 626
      if (i == strtab_index) {
#line 628
        goto __Cont___0;
      }
    }
    {
#line 632
    tmp___13 = strcmp((char const   *)((char *)sechdr + segname_offset), (char const   *)omr->segment_name);
    }
#line 632
    if (tmp___13 != 0) {
#line 633
      goto __Cont___0;
    }
#line 637
    if ((gnu_sections_found & 7U) != 0U) {
#line 639
      if (i == nametab_index) {
#line 640
        goto __Cont___0;
      } else
#line 639
      if (i == index_index) {
#line 640
        goto __Cont___0;
      }
#line 642
      if (i == sections_index) {
#line 645
        j = 0U;
        {
#line 645
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 645
          if (! (j < n_wrapped_sects)) {
#line 645
            goto while_break___1;
          }
          {
#line 648
          subsect_offset = (*fetch_32)((unsigned char const   *)(index___0 + 16U * j));
#line 649
          subsect_length = (*fetch_32)((unsigned char const   *)((index___0 + 16U * j) + 4));
#line 650
          name_offset = (*fetch_32)((unsigned char const   *)((index___0 + 16U * j) + 8));
#line 653
          secoffset = wrapper_sect_offset + (off_t )subsect_offset;
#line 654
          secsize = (size_t )subsect_length;
#line 655
          name___0 = nametab + name_offset;
#line 657
          tmp___14 = (*pfn)(data, (char const   *)name___0, secoffset, (off_t )secsize);
          }
#line 657
          if (! tmp___14) {
            {
#line 659
            *errmsg = (char const   *)((void *)0);
#line 660
            *err = 0;
#line 661
            free((void *)index___0);
#line 662
            free((void *)nametab);
#line 663
            free((void *)strtab);
#line 664
            free((void *)secdata);
            }
#line 665
            return (0);
          }
#line 645
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 668
        goto __Cont___0;
      }
    }
#line 672
    if ((gnu_sections_found & 8U) != 0U) {
      {
#line 674
      memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)(sechdr + sectname_offset),
             (size_t )16);
#line 675
      namebuf[16] = (char )'\000';
#line 677
      name___0 = & namebuf[0];
      }
#line 678
      if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 678
        if ((int )*(name___0 + 0) == 95) {
#line 678
          if ((int )*(name___0 + 1) == 95) {
            {
#line 682
            tmp___15 = sscanf((char const   */* __restrict  */)(name___0 + 2), (char const   */* __restrict  */)"%08lX",
                              & stringoffset);
            }
#line 682
            if (tmp___15 == 1) {
#line 684
              if (stringoffset >= strtab_size) {
                {
#line 686
                *errmsg = "section name offset out of range";
#line 687
                *err = 0;
#line 688
                free((void *)index___0);
#line 689
                free((void *)nametab);
#line 690
                free((void *)strtab);
#line 691
                free((void *)secdata);
                }
#line 692
                return (0);
              }
#line 695
              name___0 = strtab + stringoffset;
            }
          }
        }
      }
    } else {
      {
#line 703
      name___0 = & namebuf[0];
#line 704
      memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)((char *)sechdr + segname_offset),
             (size_t )16);
#line 705
      namebuf[16] = (char )'\000';
#line 706
      tmp___16 = strlen((char const   *)(namebuf));
#line 706
      l = (int )tmp___16;
#line 707
      namebuf[l] = (char )',';
#line 708
      memcpy((void */* __restrict  */)((namebuf + l) + 1), (void const   */* __restrict  */)((char *)sechdr + sectname_offset),
             (size_t )16);
#line 710
      namebuf[(l + 1) + 16] = (char )'\000';
      }
    }
    {
#line 713
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, sechdr, & secoffset,
                                      & secsize);
#line 716
    tmp___17 = (*pfn)(data, (char const   *)name___0, secoffset, (off_t )secsize);
    }
#line 716
    if (! tmp___17) {
      {
#line 718
      *errmsg = (char const   *)((void *)0);
#line 719
      *err = 0;
#line 720
      free((void *)index___0);
#line 721
      free((void *)nametab);
#line 722
      free((void *)strtab);
#line 723
      free((void *)secdata);
      }
#line 724
      return (0);
    }
    __Cont___0: /* CIL Label */ 
#line 613
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 728
  free((void *)index___0);
#line 729
  free((void *)nametab);
#line 730
  free((void *)strtab);
#line 731
  free((void *)secdata);
  }
#line 733
  return (1);
}
}
#line 738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_find_sections(simple_object_read *sobj ,
                                                        int (*pfn)(void * , char const   * ,
                                                                   off_t offset ,
                                                                   off_t length ) ,
                                                        void *data , int *err ) 
{ 
  struct simple_object_mach_o_read *omr ;
  off_t offset ;
  size_t seghdrsize ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  char const   *errmsg ;
  unsigned int i ;
  unsigned char loadbuf[sizeof(struct mach_o_load_command )] ;
  unsigned int cmd ;
  unsigned int cmdsize ;
  int tmp___0 ;
  unsigned char segbuf[sizeof(struct mach_o_segment_command_64 )] ;
  int r ;
  int tmp___1 ;

  {
#line 745
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 753
  if (omr->magic == 4277009102U) {
#line 755
    offset = (off_t )sizeof(struct mach_o_header_32 );
#line 756
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
  } else {
#line 760
    offset = (off_t )sizeof(struct mach_o_header_64 );
#line 761
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
  }
#line 764
  if (omr->is_big_endian) {
#line 764
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 764
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 768
  i = 0U;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (i < omr->ncmds)) {
#line 768
      goto while_break;
    }
    {
#line 774
    tmp___0 = simple_object_internal_read(sobj->descriptor, sobj->offset + offset,
                                          loadbuf, sizeof(struct mach_o_load_command ),
                                          & errmsg, err);
    }
#line 774
    if (! tmp___0) {
#line 779
      return (errmsg);
    }
    {
#line 781
    cmd = (*fetch_32)((unsigned char const   *)(loadbuf + (unsigned long )(& ((struct mach_o_load_command *)0)->cmd)));
#line 782
    cmdsize = (*fetch_32)((unsigned char const   *)(loadbuf + (unsigned long )(& ((struct mach_o_load_command *)0)->cmdsize)));
    }
#line 785
    if (cmd == 1U) {
#line 785
      goto _L;
    } else
#line 785
    if (cmd == 25U) {
      _L: /* CIL Label */ 
      {
#line 790
      tmp___1 = simple_object_internal_read(sobj->descriptor, sobj->offset + offset,
                                            segbuf, seghdrsize, & errmsg, err);
      }
#line 790
      if (! tmp___1) {
#line 793
        return (errmsg);
      }
      {
#line 795
      r = simple_object_mach_o_segment(sobj, offset, (unsigned char const   *)(segbuf),
                                       pfn, data, & errmsg, err);
      }
#line 797
      if (! r) {
#line 798
        return (errmsg);
      }
    }
#line 801
    offset += (off_t )cmdsize;
#line 768
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  return ((char const   *)((void *)0));
}
}
#line 809 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                   int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_mach_o_read *omr ;
  struct simple_object_mach_o_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 814
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 818
  tmp___0 = xmalloc(sizeof(struct simple_object_mach_o_attributes ));
#line 818
  ret = (struct simple_object_mach_o_attributes *)tmp___0;
#line 819
  ret->magic = omr->magic;
#line 820
  ret->is_big_endian = omr->is_big_endian;
#line 821
  ret->cputype = omr->cputype;
#line 822
  ret->cpusubtype = omr->cpusubtype;
#line 823
  ret->flags = omr->flags;
#line 824
  ret->reserved = omr->reserved;
  }
#line 825
  return ((void *)ret);
}
}
#line 830 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_read(void *data ) 
{ 
  struct simple_object_mach_o_read *omr ;

  {
  {
#line 833
  omr = (struct simple_object_mach_o_read *)data;
#line 836
  free((void *)omr->segment_name);
#line 837
  free((void *)omr);
  }
#line 838
  return;
}
}
#line 842 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_attributes_merge(void *todata , void *fromdata ,
                                                           int *err ) 
{ 
  struct simple_object_mach_o_attributes *to ;
  struct simple_object_mach_o_attributes *from ;

  {
#line 845
  to = (struct simple_object_mach_o_attributes *)todata;
#line 847
  from = (struct simple_object_mach_o_attributes *)fromdata;
#line 850
  if (to->magic != from->magic) {
#line 854
    *err = 0;
#line 855
    return ("Mach-O object format mismatch");
  } else
#line 850
  if (to->is_big_endian != from->is_big_endian) {
#line 854
    *err = 0;
#line 855
    return ("Mach-O object format mismatch");
  } else
#line 850
  if (to->cputype != from->cputype) {
#line 854
    *err = 0;
#line 855
    return ("Mach-O object format mismatch");
  }
#line 857
  return ((char const   *)((void *)0));
}
}
#line 862 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_attributes(void *data ) 
{ 


  {
  {
#line 865
  free(data);
  }
#line 866
  return;
}
}
#line 870 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                              int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  struct simple_object_mach_o_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 875
  attrs = (struct simple_object_mach_o_attributes *)attributes_data;
#line 881
  tmp___0 = xmalloc(sizeof(struct simple_object_mach_o_attributes ));
#line 881
  ret = (struct simple_object_mach_o_attributes *)tmp___0;
#line 882
  *ret = *attrs;
  }
#line 883
  return ((void *)ret);
}
}
#line 888 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_header(simple_object_write *sobj , int descriptor ,
                                             size_t nsects , char const   **errmsg ,
                                             int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct mach_o_header_64 )] ;
  unsigned char *hdr ;
  size_t wrsize ;
  int tmp___0 ;

  {
#line 893
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 900
  if (attrs->is_big_endian) {
#line 900
    set_32 = & simple_object_set_big_32;
  } else {
#line 900
    set_32 = & simple_object_set_little_32;
  }
  {
#line 904
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 908
  hdr = & hdrbuf[0];
#line 909
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->magic), attrs->magic);
#line 910
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->cputype), attrs->cputype);
#line 911
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->cpusubtype),
            attrs->cpusubtype);
#line 913
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->filetype), 1U);
#line 914
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->ncmds), 1U);
#line 915
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->flags), attrs->flags);
  }
#line 916
  if (attrs->magic == 4277009102U) {
    {
#line 918
    wrsize = sizeof(struct mach_o_header_32 );
#line 919
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->sizeofcmds),
              (unsigned int )(sizeof(struct mach_o_segment_command_32 ) + nsects * sizeof(struct mach_o_section_32 )));
    }
  } else {
    {
#line 925
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_64 *)0)->sizeofcmds),
              (unsigned int )(sizeof(struct mach_o_segment_command_64 ) + nsects * sizeof(struct mach_o_section_64 )));
#line 928
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_64 *)0)->reserved),
              attrs->reserved);
#line 930
    wrsize = sizeof(struct mach_o_header_64 );
    }
  }
  {
#line 933
  tmp___0 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(hdrbuf),
                                         wrsize, errmsg, err);
  }
#line 933
  return (tmp___0);
}
}
#line 939 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_section_header(simple_object_write *sobj , int descriptor ,
                                                     size_t sechdr_offset , char const   *name___0 ,
                                                     char const   *segn , size_t secaddr ,
                                                     size_t secsize , size_t offset ,
                                                     unsigned int align , char const   **errmsg ,
                                                     int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct mach_o_section_64 )] ;
  unsigned char *hdr ;
  size_t sechdrsize ;
  void (*set_64)(unsigned char * , ulong_type  ) ;
  int tmp___0 ;

  {
#line 948
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 955
  if (attrs->is_big_endian) {
#line 955
    set_32 = & simple_object_set_big_32;
  } else {
#line 955
    set_32 = & simple_object_set_little_32;
  }
  {
#line 959
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 961
  hdr = & hdrbuf[0];
  }
#line 962
  if (attrs->magic == 4277009102U) {
    {
#line 964
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->sectname)),
            (char const   */* __restrict  */)name___0, (size_t )16);
#line 966
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->segname)),
            (char const   */* __restrict  */)segn, (size_t )16);
#line 968
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->addr), (unsigned int )secaddr);
#line 969
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->size), (unsigned int )secsize);
#line 970
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->offset), (unsigned int )offset);
#line 971
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->align), align);
#line 974
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->flags), 33554432U);
#line 978
    sechdrsize = sizeof(struct mach_o_section_32 );
    }
  } else {
#line 985
    if (attrs->is_big_endian) {
#line 985
      set_64 = & simple_object_set_big_64;
    } else {
#line 985
      set_64 = & simple_object_set_little_64;
    }
    {
#line 989
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->sectname)),
            (char const   */* __restrict  */)name___0, (size_t )16);
#line 991
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->segname)),
            (char const   */* __restrict  */)segn, (size_t )16);
#line 993
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->addr), secaddr);
#line 994
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->size), secsize);
#line 995
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->offset), (unsigned int )offset);
#line 996
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->align), align);
#line 999
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->flags), 33554432U);
#line 1005
    sechdrsize = sizeof(struct mach_o_section_64 );
    }
  }
  {
#line 1008
  tmp___0 = simple_object_internal_write(descriptor, (off_t )sechdr_offset, (unsigned char const   *)hdr,
                                         sechdrsize, errmsg, err);
  }
#line 1008
  return (tmp___0);
}
}
#line 1028 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_segment(simple_object_write *sobj , int descriptor ,
                                              size_t *nsects , char const   **errmsg ,
                                              int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  size_t hdrsize ;
  size_t seghdrsize ;
  size_t sechdrsize ;
  size_t cmdsize ;
  size_t offset ;
  size_t sechdr_offset ;
  size_t secaddr ;
  unsigned int name_offset ;
  simple_object_write_section *section ;
  unsigned char hdrbuf[sizeof(struct mach_o_segment_command_64 )] ;
  unsigned char *hdr ;
  size_t nsects_in ;
  unsigned int *index___0 ;
  char *snames ;
  unsigned int sect ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t mask ;
  size_t new_offset ;
  size_t secsize ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___4 ;
  int tmp___5 ;
  char namebuf[17] ;
  char segnbuf[17] ;
  char *comma ;
  int len ;
  int tmp___6 ;
  size_t secsize___0 ;
  unsigned int i ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void (*set_64)(unsigned char * , ulong_type  ) ;
  int tmp___12 ;

  {
#line 1033
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 1052
  if (attrs->is_big_endian) {
#line 1052
    set_32 = & simple_object_set_big_32;
  } else {
#line 1052
    set_32 = & simple_object_set_little_32;
  }
#line 1058
  if (attrs->magic == 4277009102U) {
#line 1060
    hdrsize = sizeof(struct mach_o_header_32 );
#line 1061
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
#line 1062
    sechdrsize = sizeof(struct mach_o_section_32 );
  } else {
#line 1066
    hdrsize = sizeof(struct mach_o_header_64 );
#line 1067
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
#line 1068
    sechdrsize = sizeof(struct mach_o_section_64 );
  }
#line 1071
  name_offset = 0U;
#line 1072
  nsects_in = (size_t )0;
#line 1072
  *nsects = nsects_in;
#line 1076
  section = sobj->sections;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1076
      goto while_break;
    }
#line 1077
    nsects_in ++;
#line 1076
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1079
  if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
    {
#line 1083
    *nsects = (size_t )3;
#line 1093
    tmp___0 = xmalloc(sizeof(unsigned int ) * (nsects_in * 4UL));
#line 1093
    index___0 = (unsigned int *)tmp___0;
#line 1099
    section = sobj->sections;
#line 1099
    sect = 0U;
    }
    {
#line 1099
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1099
      if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1099
        goto while_break___0;
      }
      {
#line 1102
      *(index___0 + (sect * 4U + 2U)) = name_offset;
#line 1103
      tmp___1 = strlen((char const   *)section->name);
#line 1103
      *(index___0 + (sect * 4U + 3U)) = (unsigned int )(tmp___1 + 1UL);
#line 1104
      tmp___2 = strlen((char const   *)section->name);
#line 1104
      name_offset = (unsigned int )((size_t )name_offset + (tmp___2 + 1UL));
#line 1099
      section = section->next;
#line 1099
      sect ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1106
    tmp___3 = xmalloc(sizeof(char ) * (unsigned long )name_offset);
#line 1106
    snames = (char *)tmp___3;
    }
  } else {
#line 1110
    *nsects = nsects_in;
#line 1111
    index___0 = (unsigned int *)((void *)0);
#line 1112
    snames = (char *)((void *)0);
  }
#line 1115
  sechdr_offset = hdrsize + seghdrsize;
#line 1116
  cmdsize = seghdrsize + *nsects * sechdrsize;
#line 1117
  offset = hdrsize + cmdsize;
#line 1118
  secaddr = (size_t )0;
#line 1120
  section = sobj->sections;
#line 1120
  sect = 0U;
  {
#line 1120
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1120
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1120
      goto while_break___1;
    }
#line 1128
    mask = (size_t )((1U << section->align) - 1U);
#line 1129
    new_offset = offset + mask;
#line 1130
    new_offset &= ~ mask;
    {
#line 1131
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1131
      if (! (new_offset > offset)) {
#line 1131
        goto while_break___2;
      }
      {
#line 1136
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 1137
      write___0 = new_offset - offset;
      }
#line 1138
      if (write___0 > sizeof(zeroes)) {
#line 1139
        write___0 = sizeof(zeroes);
      }
      {
#line 1140
      tmp___4 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(zeroes),
                                             write___0, errmsg, err);
      }
#line 1140
      if (! tmp___4) {
#line 1142
        return (0);
      }
#line 1143
      offset += write___0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1146
    secsize = (size_t )0;
#line 1147
    buffer___2 = section->buffers;
    {
#line 1147
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1147
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 1147
        goto while_break___3;
      }
      {
#line 1149
      tmp___5 = simple_object_internal_write(descriptor, (off_t )(offset + secsize),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, errmsg, err);
      }
#line 1149
      if (! tmp___5) {
#line 1153
        return (0);
      }
#line 1154
      secsize += buffer___2->size;
#line 1147
      buffer___2 = buffer___2->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1157
    if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
      {
#line 1159
      *(index___0 + sect * 4U) = (unsigned int )offset;
#line 1160
      *(index___0 + (sect * 4U + 1U)) = (unsigned int )secsize;
#line 1162
      memcpy((void */* __restrict  */)(snames + *(index___0 + (sect * 4U + 2U))),
             (void const   */* __restrict  */)section->name, (size_t )*(index___0 + (sect * 4U + 3U)));
      }
    } else {
      {
#line 1173
      memset((void *)(namebuf), 0, sizeof(namebuf));
#line 1174
      memset((void *)(segnbuf), 0, sizeof(segnbuf));
#line 1175
      comma = strchr((char const   *)section->name, ',');
      }
#line 1176
      if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 1178
        len = (int )(comma - section->name);
#line 1179
        if (len > 16) {
#line 1179
          len = 16;
        } else {
#line 1179
          len = len;
        }
        {
#line 1180
        strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)section->name,
                (size_t )len);
#line 1181
        strncpy((char */* __restrict  */)(segnbuf), (char const   */* __restrict  */)(comma + 1),
                (size_t )16);
        }
      } else {
        {
#line 1184
        strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)section->name,
                (size_t )16);
        }
      }
      {
#line 1186
      tmp___6 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                          (char const   *)(namebuf),
                                                          (char const   *)(segnbuf),
                                                          secaddr, secsize, offset,
                                                          section->align, errmsg,
                                                          err);
      }
#line 1186
      if (! tmp___6) {
#line 1193
        return (0);
      }
#line 1194
      sechdr_offset += sechdrsize;
    }
#line 1197
    offset += secsize;
#line 1198
    secaddr += secsize;
#line 1120
    section = section->next;
#line 1120
    sect ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1201
  if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
    {
#line 1210
    secsize___0 = offset - (size_t )*(index___0 + 0);
#line 1211
    tmp___7 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                        "__wrapper_sects", (char const   *)sobj->segment_name,
                                                        (size_t )0, secsize___0, (size_t )*(index___0 + 0),
                                                        (sobj->sections)->align, errmsg,
                                                        err);
    }
#line 1211
    if (! tmp___7) {
#line 1219
      return (0);
    }
#line 1224
    i = 1U;
    {
#line 1224
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1224
      if (! ((size_t )i < nsects_in)) {
#line 1224
        goto while_break___4;
      }
#line 1225
      *(index___0 + 4U * i) -= *(index___0 + 0);
#line 1224
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1226
    *(index___0 + 0) = 0U;
#line 1228
    sechdr_offset += sechdrsize;
#line 1234
    tmp___8 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                        "__wrapper_names", (char const   *)sobj->segment_name,
                                                        (size_t )0, (size_t )name_offset,
                                                        offset, 0U, errmsg, err);
    }
#line 1234
    if (! tmp___8) {
#line 1242
      return (0);
    }
    {
#line 1245
    tmp___9 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)snames,
                                           (size_t )name_offset, errmsg, err);
    }
#line 1245
    if (! tmp___9) {
#line 1248
      return (0);
    }
    {
#line 1250
    sechdr_offset += sechdrsize;
#line 1251
    secaddr += (size_t )name_offset;
#line 1252
    offset += (size_t )name_offset;
#line 1257
    offset += 3UL;
#line 1258
    offset &= 0xfffffffffffffffcUL;
#line 1259
    tmp___10 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                         "__wrapper_index", (char const   *)sobj->segment_name,
                                                         (size_t )0, nsects_in * 16UL,
                                                         offset, 2U, errmsg, err);
    }
#line 1259
    if (! tmp___10) {
#line 1267
      return (0);
    }
    {
#line 1270
    tmp___11 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)index___0,
                                            nsects_in * 16UL, errmsg, err);
    }
#line 1270
    if (! tmp___11) {
#line 1273
      return (0);
    }
    {
#line 1275
    free((void *)index___0);
#line 1276
    free((void *)snames);
    }
  }
  {
#line 1281
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 1283
  hdr = & hdrbuf[0];
  }
#line 1284
  if (attrs->magic == 4277009102U) {
    {
#line 1286
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->cmd),
              1U);
#line 1288
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->cmdsize),
              (unsigned int )cmdsize);
#line 1294
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->fileoff),
              (unsigned int )(hdrsize + cmdsize));
#line 1296
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->filesize),
              (unsigned int )(offset - (hdrsize + cmdsize)));
#line 1300
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->nsects),
              (unsigned int )*nsects);
    }
  } else {
#line 1309
    if (attrs->is_big_endian) {
#line 1309
      set_64 = & simple_object_set_big_64;
    } else {
#line 1309
      set_64 = & simple_object_set_little_64;
    }
    {
#line 1313
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->cmd),
              1U);
#line 1315
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->cmdsize),
              (unsigned int )cmdsize);
#line 1321
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->fileoff),
              hdrsize + cmdsize);
#line 1323
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->filesize),
              offset - (hdrsize + cmdsize));
#line 1327
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->nsects),
              (unsigned int )*nsects);
    }
  }
  {
#line 1333
  tmp___12 = simple_object_internal_write(descriptor, (off_t )hdrsize, (unsigned char const   *)hdr,
                                          seghdrsize, errmsg, err);
  }
#line 1333
  return (tmp___12);
}
}
#line 1339 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_write_to_file(simple_object_write *sobj ,
                                                        int descriptor , int *err ) 
{ 
  size_t nsects ;
  char const   *errmsg ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1343
  nsects = (size_t )0;
#line 1346
  tmp___0 = simple_object_mach_o_write_segment(sobj, descriptor, & nsects, & errmsg,
                                               err);
  }
#line 1346
  if (! tmp___0) {
#line 1348
    return (errmsg);
  }
  {
#line 1350
  tmp___1 = simple_object_mach_o_write_header(sobj, descriptor, nsects, & errmsg,
                                              err);
  }
#line 1350
  if (! tmp___1) {
#line 1352
    return (errmsg);
  }
#line 1354
  return ((char const   *)((void *)0));
}
}
#line 1359 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_write(void *data ) 
{ 


  {
  {
#line 1362
  free(data);
  }
#line 1363
  return;
}
}
#line 1367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-mach-o.c"
struct simple_object_functions  const  simple_object_mach_o_functions  = 
#line 1367
     {& simple_object_mach_o_match, & simple_object_mach_o_find_sections, & simple_object_mach_o_fetch_attributes,
    & simple_object_mach_o_release_read, & simple_object_mach_o_attributes_merge,
    & simple_object_mach_o_release_attributes, & simple_object_mach_o_start_write,
    & simple_object_mach_o_write_to_file, & simple_object_mach_o_release_write};
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static unsigned short simple_object_fetch_little_16(unsigned char const   *buf___7 ) 
{ 


  {
#line 193
  return ((unsigned short )(((int )((unsigned short )*(buf___7 + 1)) << 8) | (int )((unsigned short )*(buf___7 + 0))));
}
}
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_big_32_ulong(unsigned char const   *buf___7 ) 
{ 
  unsigned int tmp___0 ;

  {
  {
#line 223
  tmp___0 = simple_object_fetch_big_32(buf___7);
  }
#line 223
  return ((ulong_type )tmp___0);
}
}
#line 228 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_little_32_ulong(unsigned char const   *buf___7 ) 
{ 
  unsigned int tmp___0 ;

  {
  {
#line 231
  tmp___0 = simple_object_fetch_little_32(buf___7);
  }
#line 231
  return ((ulong_type )tmp___0);
}
}
#line 279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_16(unsigned char *buf___7 , unsigned short val ) 
{ 


  {
#line 282
  *(buf___7 + 1) = (unsigned char )(((int )val >> 8) & 255);
#line 283
  *(buf___7 + 0) = (unsigned char )((int )val & 255);
#line 284
  return;
}
}
#line 310 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_32_ulong(unsigned char *buf___7 , ulong_type val ) 
{ 


  {
  {
#line 313
  simple_object_set_big_32(buf___7, (unsigned int )val);
  }
#line 314
  return;
}
}
#line 318 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_32_ulong(unsigned char *buf___7 , ulong_type val ) 
{ 


  {
  {
#line 321
  simple_object_set_little_32(buf___7, (unsigned int )val);
  }
#line 322
  return;
}
}
#line 202 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_big_32_functions  =    {& simple_object_fetch_big_16, & simple_object_fetch_big_32, & simple_object_fetch_big_32_ulong,
    & simple_object_set_big_16, & simple_object_set_big_32, & simple_object_set_big_32_ulong};
#line 212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_little_32_functions  =    {& simple_object_fetch_little_16, & simple_object_fetch_little_32, & simple_object_fetch_little_32_ulong,
    & simple_object_set_little_16, & simple_object_set_little_32, & simple_object_set_little_32_ulong};
#line 224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_big_64_functions  =    {& simple_object_fetch_big_16, & simple_object_fetch_big_32, & simple_object_fetch_big_64,
    & simple_object_set_big_16, & simple_object_set_big_32, & simple_object_set_big_64};
#line 234 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_little_64_functions  =    {& simple_object_fetch_little_16, & simple_object_fetch_little_32, & simple_object_fetch_little_64,
    & simple_object_set_little_16, & simple_object_set_little_32, & simple_object_set_little_64};
#line 353 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void *simple_object_elf_match(unsigned char *header , int descriptor , off_t offset ,
                                     char const   *segment_name  __attribute__((__unused__)) ,
                                     char const   **errmsg , int *err ) 
{ 
  unsigned char ei_data ;
  unsigned char ei_class ;
  struct elf_type_functions  const  *type_functions ;
  unsigned char ehdr[sizeof(Elf64_External_Ehdr )] ;
  struct simple_object_elf_read *eor ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  ulong_type tmp___6 ;
  ulong_type tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  unsigned char shdr[sizeof(Elf64_External_Shdr )] ;
  unsigned long tmp___12 ;
  int tmp___13 ;
  ulong_type tmp___14 ;
  ulong_type tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;

  {
#line 365
  if ((int )*(header + 0) != 127) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 1) != 69) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 2) != 76) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 3) != 70) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 6) != 1) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  }
#line 376
  ei_data = *(header + 5);
#line 377
  if ((int )ei_data != 1) {
#line 377
    if ((int )ei_data != 2) {
#line 379
      *errmsg = "unknown ELF endianness";
#line 380
      *err = 0;
#line 381
      return ((void *)0);
    }
  }
#line 384
  ei_class = *(header + 4);
  {
#line 387
  if ((int )ei_class == 1) {
#line 387
    goto case_1;
  }
#line 393
  if ((int )ei_class == 2) {
#line 393
    goto case_2;
  }
#line 405
  goto switch_default;
  case_1: /* CIL Label */ 
#line 388
  if ((int )ei_data == 1) {
#line 388
    type_functions = & elf_little_32_functions;
  } else {
#line 388
    type_functions = & elf_big_32_functions;
  }
#line 391
  goto switch_break;
  case_2: /* CIL Label */ 
#line 399
  if ((int )ei_data == 1) {
#line 399
    type_functions = & elf_little_64_functions;
  } else {
#line 399
    type_functions = & elf_big_64_functions;
  }
#line 402
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  *errmsg = "unrecognized ELF size";
#line 407
  *err = 0;
#line 408
  return ((void *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 411
  tmp___0 = simple_object_internal_read(descriptor, offset, ehdr, sizeof(ehdr), errmsg,
                                        err);
  }
#line 411
  if (! tmp___0) {
#line 413
    return ((void *)0);
  }
  {
#line 415
  tmp___1 = xmalloc(sizeof(struct simple_object_elf_read ));
#line 415
  eor = (struct simple_object_elf_read *)tmp___1;
#line 416
  eor->type_functions = type_functions;
#line 417
  eor->ei_data = ei_data;
#line 418
  eor->ei_class = ei_class;
#line 419
  eor->ei_osabi = *(header + 7);
  }
#line 420
  if ((int )ei_class == 1) {
    {
#line 420
    tmp___2 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_machine)));
#line 420
    eor->machine = tmp___2;
    }
  } else {
    {
#line 420
    tmp___3 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_machine)));
#line 420
    eor->machine = tmp___3;
    }
  }
#line 422
  if ((int )ei_class == 1) {
    {
#line 422
    tmp___4 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_flags)));
#line 422
    eor->flags = tmp___4;
    }
  } else {
    {
#line 422
    tmp___5 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_flags)));
#line 422
    eor->flags = tmp___5;
    }
  }
#line 424
  if ((int )ei_class == 1) {
    {
#line 424
    tmp___6 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shoff)));
#line 424
    eor->shoff = tmp___6;
    }
  } else {
    {
#line 424
    tmp___7 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shoff)));
#line 424
    eor->shoff = tmp___7;
    }
  }
#line 426
  if ((int )ei_class == 1) {
    {
#line 426
    tmp___8 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shnum)));
#line 426
    eor->shnum = (unsigned int )tmp___8;
    }
  } else {
    {
#line 426
    tmp___9 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shnum)));
#line 426
    eor->shnum = (unsigned int )tmp___9;
    }
  }
#line 428
  if ((int )ei_class == 1) {
    {
#line 428
    tmp___10 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shstrndx)));
#line 428
    eor->shstrndx = (unsigned int )tmp___10;
    }
  } else {
    {
#line 428
    tmp___11 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shstrndx)));
#line 428
    eor->shstrndx = (unsigned int )tmp___11;
    }
  }
#line 431
  if (eor->shnum == 0U) {
#line 431
    goto _L;
  } else
#line 431
  if (eor->shstrndx == 65535U) {
    _L: /* CIL Label */ 
#line 431
    if (eor->shoff != 0UL) {
#line 438
      if ((int )ei_class == 1) {
#line 438
        tmp___12 = sizeof(Elf32_External_Shdr );
      } else {
#line 438
        tmp___12 = sizeof(Elf64_External_Shdr );
      }
      {
#line 438
      tmp___13 = simple_object_internal_read(descriptor, (off_t )((ulong_type )offset + eor->shoff),
                                             shdr, tmp___12, errmsg, err);
      }
#line 438
      if (! tmp___13) {
        {
#line 444
        free((void *)eor);
        }
#line 445
        return ((void *)0);
      }
#line 448
      if (eor->shnum == 0U) {
#line 449
        if ((int )ei_class == 1) {
          {
#line 449
          tmp___14 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 449
          eor->shnum = (unsigned int )tmp___14;
          }
        } else {
          {
#line 449
          tmp___15 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 449
          eor->shnum = (unsigned int )tmp___15;
          }
        }
      }
#line 452
      if (eor->shstrndx == 65535U) {
#line 454
        if ((int )ei_class == 1) {
          {
#line 454
          tmp___16 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_link)));
#line 454
          eor->shstrndx = tmp___16;
          }
        } else {
          {
#line 454
          tmp___17 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_link)));
#line 454
          eor->shstrndx = tmp___17;
          }
        }
#line 468
        if (eor->shstrndx >= eor->shnum) {
#line 468
          if (eor->shstrndx >= 65536U) {
#line 470
            eor->shstrndx -= 256U;
          }
        }
      }
    }
  }
#line 474
  if (eor->shstrndx >= eor->shnum) {
    {
#line 476
    *errmsg = "invalid ELF shstrndx >= shnum";
#line 477
    *err = 0;
#line 478
    free((void *)eor);
    }
#line 479
    return ((void *)0);
  }
#line 482
  return ((void *)eor);
}
}
#line 487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_find_sections(simple_object_read *sobj , int (*pfn)(void * ,
                                                                                           char const   * ,
                                                                                           off_t offset ,
                                                                                           off_t length ) ,
                                                     void *data , int *err ) 
{ 
  struct simple_object_elf_read *eor ;
  struct elf_type_functions  const  *type_functions ;
  unsigned char ei_class ;
  size_t shdr_size ;
  unsigned int shnum ;
  unsigned char *shdrs ;
  char const   *errmsg ;
  unsigned char *shstrhdr ;
  size_t name_size ;
  off_t shstroff ;
  unsigned char *names ;
  unsigned int i ;
  void *tmp___0 ;
  int tmp___1 ;
  ulong_type tmp___2 ;
  ulong_type tmp___3 ;
  ulong_type tmp___4 ;
  ulong_type tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned char *shdr ;
  unsigned int sh_name ;
  char const   *name___0 ;
  off_t offset ;
  off_t length ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  ulong_type tmp___10 ;
  ulong_type tmp___11 ;
  ulong_type tmp___12 ;
  ulong_type tmp___13 ;
  int tmp___14 ;

  {
#line 494
  eor = (struct simple_object_elf_read *)sobj->data;
#line 496
  type_functions = eor->type_functions;
#line 497
  ei_class = eor->ei_class;
#line 508
  if ((int )ei_class == 1) {
#line 508
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 508
    shdr_size = sizeof(Elf64_External_Shdr );
  }
  {
#line 515
  shnum = eor->shnum;
#line 516
  tmp___0 = xmalloc(sizeof(unsigned char ) * (shdr_size * (size_t )(shnum - 1U)));
#line 516
  shdrs = (unsigned char *)tmp___0;
#line 518
  tmp___1 = simple_object_internal_read(sobj->descriptor, (off_t )(((ulong_type )sobj->offset + eor->shoff) + shdr_size),
                                        shdrs, shdr_size * (size_t )(shnum - 1U),
                                        & errmsg, err);
  }
#line 518
  if (! tmp___1) {
    {
#line 524
    free((void *)shdrs);
    }
#line 525
    return (errmsg);
  }
#line 530
  shstrhdr = shdrs + (size_t )(eor->shstrndx - 1U) * shdr_size;
#line 531
  if ((int )ei_class == 1) {
    {
#line 531
    tmp___2 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 531
    name_size = tmp___2;
    }
  } else {
    {
#line 531
    tmp___3 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 531
    name_size = tmp___3;
    }
  }
#line 533
  if ((int )ei_class == 1) {
    {
#line 533
    tmp___4 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset)));
#line 533
    shstroff = (off_t )tmp___4;
    }
  } else {
    {
#line 533
    tmp___5 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset)));
#line 533
    shstroff = (off_t )tmp___5;
    }
  }
  {
#line 535
  tmp___6 = xmalloc(sizeof(unsigned char ) * name_size);
#line 535
  names = (unsigned char *)tmp___6;
#line 536
  tmp___7 = simple_object_internal_read(sobj->descriptor, sobj->offset + shstroff,
                                        names, name_size, & errmsg, err);
  }
#line 536
  if (! tmp___7) {
    {
#line 540
    free((void *)names);
#line 541
    free((void *)shdrs);
    }
#line 542
    return (errmsg);
  }
#line 545
  i = 1U;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < shnum)) {
#line 545
      goto while_break;
    }
#line 553
    shdr = shdrs + (size_t )(i - 1U) * shdr_size;
#line 554
    if ((int )ei_class == 1) {
      {
#line 554
      tmp___8 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_name)));
#line 554
      sh_name = tmp___8;
      }
    } else {
      {
#line 554
      tmp___9 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_name)));
#line 554
      sh_name = tmp___9;
      }
    }
#line 556
    if ((size_t )sh_name >= name_size) {
      {
#line 558
      *err = 0;
#line 559
      free((void *)names);
#line 560
      free((void *)shdrs);
      }
#line 561
      return ("ELF section name out of range");
    }
#line 564
    name___0 = (char const   *)names + sh_name;
#line 565
    if ((int )ei_class == 1) {
      {
#line 565
      tmp___10 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset)));
#line 565
      offset = (off_t )tmp___10;
      }
    } else {
      {
#line 565
      tmp___11 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset)));
#line 565
      offset = (off_t )tmp___11;
      }
    }
#line 567
    if ((int )ei_class == 1) {
      {
#line 567
      tmp___12 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 567
      length = (off_t )tmp___12;
      }
    } else {
      {
#line 567
      tmp___13 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 567
      length = (off_t )tmp___13;
      }
    }
    {
#line 570
    tmp___14 = (*pfn)(data, name___0, offset, length);
    }
#line 570
    if (! tmp___14) {
#line 571
      goto while_break;
    }
#line 545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 574
  free((void *)names);
#line 575
  free((void *)shdrs);
  }
#line 577
  return ((char const   *)((void *)0));
}
}
#line 582 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void *simple_object_elf_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_elf_read *eor ;
  struct simple_object_elf_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 587
  eor = (struct simple_object_elf_read *)sobj->data;
#line 591
  tmp___0 = xmalloc(sizeof(struct simple_object_elf_attributes ));
#line 591
  ret = (struct simple_object_elf_attributes *)tmp___0;
#line 592
  ret->type_functions = eor->type_functions;
#line 593
  ret->ei_data = eor->ei_data;
#line 594
  ret->ei_class = eor->ei_class;
#line 595
  ret->ei_osabi = eor->ei_osabi;
#line 596
  ret->machine = eor->machine;
#line 597
  ret->flags = eor->flags;
  }
#line 598
  return ((void *)ret);
}
}
#line 603 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_read(void *data ) 
{ 


  {
  {
#line 606
  free(data);
  }
#line 607
  return;
}
}
#line 611 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_attributes_merge(void *todata , void *fromdata ,
                                                        int *err ) 
{ 
  struct simple_object_elf_attributes *to ;
  struct simple_object_elf_attributes *from ;
  int ok ;

  {
#line 614
  to = (struct simple_object_elf_attributes *)todata;
#line 616
  from = (struct simple_object_elf_attributes *)fromdata;
#line 619
  if ((int )to->ei_data != (int )from->ei_data) {
#line 621
    *err = 0;
#line 622
    return ("ELF object format mismatch");
  } else
#line 619
  if ((int )to->ei_class != (int )from->ei_class) {
#line 621
    *err = 0;
#line 622
    return ("ELF object format mismatch");
  }
#line 625
  if ((int )to->machine != (int )from->machine) {
#line 631
    ok = 0;
    {
#line 634
    if ((int )to->machine == 2) {
#line 634
      goto case_2;
    }
#line 642
    if ((int )to->machine == 18) {
#line 642
      goto case_18;
    }
#line 647
    goto switch_default;
    case_2: /* CIL Label */ 
#line 635
    if ((int )from->machine == 18) {
#line 637
      to->machine = from->machine;
#line 638
      ok = 1;
    }
#line 640
    goto switch_break;
    case_18: /* CIL Label */ 
#line 643
    if ((int )from->machine == 2) {
#line 644
      ok = 1;
    }
#line 645
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 648
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 651
    if (! ok) {
#line 653
      *err = 0;
#line 654
      return ("ELF machine number mismatch");
    }
  }
#line 658
  return ((char const   *)((void *)0));
}
}
#line 663 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_attributes(void *data ) 
{ 


  {
  {
#line 666
  free(data);
  }
#line 667
  return;
}
}
#line 671 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void *simple_object_elf_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                           int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct simple_object_elf_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 676
  attrs = (struct simple_object_elf_attributes *)attributes_data;
#line 682
  tmp___0 = xmalloc(sizeof(struct simple_object_elf_attributes ));
#line 682
  ret = (struct simple_object_elf_attributes *)tmp___0;
#line 683
  *ret = *attrs;
  }
#line 684
  return ((void *)ret);
}
}
#line 689 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static int simple_object_elf_write_ehdr(simple_object_write *sobj , int descriptor ,
                                        char const   **errmsg , int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct elf_type_functions  const  *fns ;
  unsigned char cl ;
  size_t ehdr_size ;
  unsigned char buf___7[sizeof(Elf64_External_Ehdr )] ;
  simple_object_write_section *section ;
  unsigned int shnum ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 693
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 702
  fns = attrs->type_functions;
#line 703
  cl = attrs->ei_class;
#line 705
  shnum = 0U;
#line 706
  section = sobj->sections;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 706
      goto while_break;
    }
#line 707
    shnum ++;
#line 706
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (shnum > 0U) {
#line 712
    shnum += 2U;
  }
#line 715
  if ((int )cl == 1) {
#line 715
    ehdr_size = sizeof(Elf32_External_Ehdr );
  } else {
#line 715
    ehdr_size = sizeof(Elf64_External_Ehdr );
  }
  {
#line 718
  memset((void *)(buf___7), 0, sizeof(Elf64_External_Ehdr ));
#line 720
  buf___7[0] = (unsigned char)127;
#line 721
  buf___7[1] = (unsigned char )'E';
#line 722
  buf___7[2] = (unsigned char )'L';
#line 723
  buf___7[3] = (unsigned char )'F';
#line 724
  buf___7[4] = cl;
#line 725
  buf___7[5] = attrs->ei_data;
#line 726
  buf___7[6] = (unsigned char)1;
#line 727
  buf___7[7] = attrs->ei_osabi;
  }
#line 729
  if ((int )cl == 1) {
    {
#line 729
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_type),
                           (unsigned short)1);
    }
  } else {
    {
#line 729
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_type),
                           (unsigned short)1);
    }
  }
#line 730
  if ((int )cl == 1) {
    {
#line 730
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_machine),
                           attrs->machine);
    }
  } else {
    {
#line 730
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_machine),
                           attrs->machine);
    }
  }
#line 731
  if ((int )cl == 1) {
    {
#line 731
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_version),
                           1U);
    }
  } else {
    {
#line 731
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_version),
                           1U);
    }
  }
#line 734
  if ((int )cl == 1) {
    {
#line 734
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shoff),
                           ehdr_size);
    }
  } else {
    {
#line 734
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shoff),
                           ehdr_size);
    }
  }
#line 735
  if ((int )cl == 1) {
    {
#line 735
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_flags),
                           attrs->flags);
    }
  } else {
    {
#line 735
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_flags),
                           attrs->flags);
    }
  }
#line 736
  if ((int )cl == 1) {
    {
#line 736
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_ehsize),
                           (unsigned short )ehdr_size);
    }
  } else {
    {
#line 736
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_ehsize),
                           (unsigned short )ehdr_size);
    }
  }
#line 737
  if ((int )cl == 1) {
#line 737
    if ((int )cl == 1) {
#line 737
      tmp___1 = sizeof(Elf32_External_Phdr );
    } else {
#line 737
      tmp___1 = sizeof(Elf64_External_Phdr );
    }
    {
#line 737
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_phentsize),
                           (unsigned short )tmp___1);
    }
  } else {
#line 737
    if ((int )cl == 1) {
#line 737
      tmp___0 = sizeof(Elf32_External_Phdr );
    } else {
#line 737
      tmp___0 = sizeof(Elf64_External_Phdr );
    }
    {
#line 737
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_phentsize),
                           (unsigned short )tmp___0);
    }
  }
#line 742
  if ((int )cl == 1) {
#line 742
    if ((int )cl == 1) {
#line 742
      tmp___3 = sizeof(Elf32_External_Shdr );
    } else {
#line 742
      tmp___3 = sizeof(Elf64_External_Shdr );
    }
    {
#line 742
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shentsize),
                           (unsigned short )tmp___3);
    }
  } else {
#line 742
    if ((int )cl == 1) {
#line 742
      tmp___2 = sizeof(Elf32_External_Shdr );
    } else {
#line 742
      tmp___2 = sizeof(Elf64_External_Shdr );
    }
    {
#line 742
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shentsize),
                           (unsigned short )tmp___2);
    }
  }
#line 746
  if ((int )cl == 1) {
    {
#line 746
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shnum),
                           (unsigned short )shnum);
    }
  } else {
    {
#line 746
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shnum),
                           (unsigned short )shnum);
    }
  }
#line 747
  if ((int )cl == 1) {
#line 747
    if (shnum == 0U) {
#line 747
      tmp___5 = 0U;
    } else {
#line 747
      tmp___5 = shnum - 1U;
    }
    {
#line 747
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shstrndx),
                           (unsigned short )tmp___5);
    }
  } else {
#line 747
    if (shnum == 0U) {
#line 747
      tmp___4 = 0U;
    } else {
#line 747
      tmp___4 = shnum - 1U;
    }
    {
#line 747
    (*(fns->set_Elf_Half))(buf___7 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shstrndx),
                           (unsigned short )tmp___4);
    }
  }
  {
#line 750
  tmp___6 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(buf___7),
                                         ehdr_size, errmsg, err);
  }
#line 750
  return (tmp___6);
}
}
#line 756 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static int simple_object_elf_write_shdr(simple_object_write *sobj , int descriptor ,
                                        off_t offset , unsigned int sh_name , unsigned int sh_type ,
                                        unsigned int sh_flags , unsigned int sh_offset ,
                                        unsigned int sh_size , unsigned int sh_addralign ,
                                        char const   **errmsg , int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct elf_type_functions  const  *fns ;
  unsigned char cl ;
  size_t shdr_size ;
  unsigned char buf___7[sizeof(Elf64_External_Shdr )] ;
  int tmp___0 ;

  {
#line 764
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 771
  fns = attrs->type_functions;
#line 772
  cl = attrs->ei_class;
#line 774
  if ((int )cl == 1) {
#line 774
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 774
    shdr_size = sizeof(Elf64_External_Shdr );
  }
  {
#line 777
  memset((void *)(buf___7), 0, sizeof(Elf64_External_Shdr ));
  }
#line 779
  if ((int )cl == 1) {
    {
#line 779
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_name),
                           sh_name);
    }
  } else {
    {
#line 779
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_name),
                           sh_name);
    }
  }
#line 780
  if ((int )cl == 1) {
    {
#line 780
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_type),
                           sh_type);
    }
  } else {
    {
#line 780
    (*(fns->set_Elf_Word))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_type),
                           sh_type);
    }
  }
#line 781
  if ((int )cl == 1) {
    {
#line 781
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_flags),
                           (ulong_type )sh_flags);
    }
  } else {
    {
#line 781
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_flags),
                           (ulong_type )sh_flags);
    }
  }
#line 782
  if ((int )cl == 1) {
    {
#line 782
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset),
                           (ulong_type )sh_offset);
    }
  } else {
    {
#line 782
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset),
                           (ulong_type )sh_offset);
    }
  }
#line 783
  if ((int )cl == 1) {
    {
#line 783
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size),
                           (ulong_type )sh_size);
    }
  } else {
    {
#line 783
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size),
                           (ulong_type )sh_size);
    }
  }
#line 786
  if ((int )cl == 1) {
    {
#line 786
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_addralign),
                           (ulong_type )sh_addralign);
    }
  } else {
    {
#line 786
    (*(fns->set_Elf_Addr))(buf___7 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_addralign),
                           (ulong_type )sh_addralign);
    }
  }
  {
#line 789
  tmp___0 = simple_object_internal_write(descriptor, offset, (unsigned char const   *)(buf___7),
                                         shdr_size, errmsg, err);
  }
#line 789
  return (tmp___0);
}
}
#line 801 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_write_to_file(simple_object_write *sobj , int descriptor ,
                                                     int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  unsigned char cl ;
  size_t ehdr_size ;
  size_t shdr_size ;
  char const   *errmsg ;
  simple_object_write_section *section ;
  unsigned int shnum ;
  size_t shdr_offset ;
  size_t sh_offset ;
  size_t sh_name ;
  unsigned char zero ;
  int tmp___0 ;
  int tmp___1 ;
  size_t mask ;
  size_t new_sh_offset ;
  size_t sh_size ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t len ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 805
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 818
  tmp___0 = simple_object_elf_write_ehdr(sobj, descriptor, & errmsg, err);
  }
#line 818
  if (! tmp___0) {
#line 819
    return (errmsg);
  }
#line 821
  cl = attrs->ei_class;
#line 822
  if ((int )cl == 1) {
#line 824
    ehdr_size = sizeof(Elf32_External_Ehdr );
#line 825
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 829
    ehdr_size = sizeof(Elf64_External_Ehdr );
#line 830
    shdr_size = sizeof(Elf64_External_Shdr );
  }
#line 833
  shnum = 0U;
#line 834
  section = sobj->sections;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 834
      goto while_break;
    }
#line 835
    shnum ++;
#line 834
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  if (shnum == 0U) {
#line 837
    return ((char const   *)((void *)0));
  }
  {
#line 840
  shnum += 2U;
#line 842
  shdr_offset = ehdr_size;
#line 843
  sh_offset = shdr_offset + (size_t )shnum * shdr_size;
#line 845
  tmp___1 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset, 0U,
                                         0U, 0U, 0U, 0U, 0U, & errmsg, err);
  }
#line 845
  if (! tmp___1) {
#line 847
    return (errmsg);
  }
#line 849
  shdr_offset += shdr_size;
#line 851
  sh_name = (size_t )1;
#line 852
  section = sobj->sections;
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 852
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 852
      goto while_break___0;
    }
#line 859
    mask = (size_t )((1U << section->align) - 1U);
#line 860
    new_sh_offset = sh_offset + mask;
#line 861
    new_sh_offset &= ~ mask;
    {
#line 862
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 862
      if (! (new_sh_offset > sh_offset)) {
#line 862
        goto while_break___1;
      }
      {
#line 867
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 868
      write___0 = new_sh_offset - sh_offset;
      }
#line 869
      if (write___0 > sizeof(zeroes)) {
#line 870
        write___0 = sizeof(zeroes);
      }
      {
#line 871
      tmp___2 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)(zeroes),
                                             write___0, & errmsg, err);
      }
#line 871
      if (! tmp___2) {
#line 873
        return (errmsg);
      }
#line 874
      sh_offset += write___0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 877
    sh_size = (size_t )0;
#line 878
    buffer___2 = section->buffers;
    {
#line 878
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 878
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 878
        goto while_break___2;
      }
      {
#line 880
      tmp___3 = simple_object_internal_write(descriptor, (off_t )(sh_offset + sh_size),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, & errmsg, err);
      }
#line 880
      if (! tmp___3) {
#line 884
        return (errmsg);
      }
#line 885
      sh_size += buffer___2->size;
#line 878
      buffer___2 = buffer___2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 888
    tmp___4 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset,
                                           (unsigned int )sh_name, 1U, 0U, (unsigned int )sh_offset,
                                           (unsigned int )sh_size, 1U << section->align,
                                           & errmsg, err);
    }
#line 888
    if (! tmp___4) {
#line 892
      return (errmsg);
    }
    {
#line 894
    shdr_offset += shdr_size;
#line 895
    tmp___5 = strlen((char const   *)section->name);
#line 895
    sh_name += tmp___5 + 1UL;
#line 896
    sh_offset += sh_size;
#line 852
    section = section->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 899
  tmp___6 = strlen(".shstrtab");
#line 899
  tmp___7 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset, (unsigned int )sh_name,
                                         3U, 0U, (unsigned int )sh_offset, (unsigned int )((sh_name + tmp___6) + 1UL),
                                         1U, & errmsg, err);
  }
#line 899
  if (! tmp___7) {
#line 903
    return (errmsg);
  }
  {
#line 906
  zero = (unsigned char)0;
#line 907
  tmp___8 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)(& zero),
                                         (size_t )1, & errmsg, err);
  }
#line 907
  if (! tmp___8) {
#line 909
    return (errmsg);
  }
#line 910
  sh_offset ++;
#line 912
  section = sobj->sections;
  {
#line 912
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 912
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 912
      goto while_break___3;
    }
    {
#line 916
    tmp___9 = strlen((char const   *)section->name);
#line 916
    len = tmp___9 + 1UL;
#line 917
    tmp___10 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)section->name,
                                            len, & errmsg, err);
    }
#line 917
    if (! tmp___10) {
#line 920
      return (errmsg);
    }
#line 921
    sh_offset += len;
#line 912
    section = section->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 924
  tmp___11 = strlen(".shstrtab");
#line 924
  tmp___12 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)".shstrtab",
                                          tmp___11 + 1UL, & errmsg, err);
  }
#line 924
  if (! tmp___12) {
#line 927
    return (errmsg);
  }
#line 929
  return ((char const   *)((void *)0));
}
}
#line 934 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_write(void *data ) 
{ 


  {
  {
#line 937
  free(data);
  }
#line 938
  return;
}
}
#line 942 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-elf.c"
struct simple_object_functions  const  simple_object_elf_functions  = 
#line 942
     {& simple_object_elf_match, & simple_object_elf_find_sections, & simple_object_elf_fetch_attributes,
    & simple_object_elf_release_read, & simple_object_elf_attributes_merge, & simple_object_elf_release_attributes,
    & simple_object_elf_start_write, & simple_object_elf_write_to_file, & simple_object_elf_release_write};
#line 217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static struct coff_magic_struct  const  coff_magic[2]  = {      {(unsigned short)332, (unsigned char)0, (unsigned short)12290}, 
        {(unsigned short)34404, (unsigned char)0, (unsigned short)12290}};
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void *simple_object_coff_match(unsigned char *header , int descriptor , off_t offset ,
                                      char const   *segment_name  __attribute__((__unused__)) ,
                                      char const   **errmsg , int *err ) 
{ 
  size_t c ;
  unsigned short magic_big ;
  unsigned short magic_little ;
  unsigned short magic ;
  size_t i ;
  int is_big_endian ;
  unsigned short (*fetch_16)(unsigned char const   * ) ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned char hdrbuf[sizeof(struct external_filehdr___0 )] ;
  unsigned short flags___1 ;
  struct simple_object_coff_read *ocr ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned short tmp___4 ;

  {
  {
#line 245
  c = sizeof(coff_magic) / sizeof(coff_magic[0]);
#line 246
  magic_big = simple_object_fetch_big_16((unsigned char const   *)header);
#line 247
  magic_little = simple_object_fetch_little_16((unsigned char const   *)header);
#line 248
  i = (size_t )0;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < c)) {
#line 248
      goto while_break;
    }
#line 250
    if (coff_magic[i].is_big_endian) {
#line 250
      tmp___0 = (int const   )coff_magic[i].magic == (int const   )magic_big;
    } else {
#line 250
      tmp___0 = (int const   )coff_magic[i].magic == (int const   )magic_little;
    }
#line 250
    if (tmp___0) {
#line 253
      goto while_break;
    }
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (i >= c) {
#line 257
    *errmsg = (char const   *)((void *)0);
#line 258
    *err = 0;
#line 259
    return ((void *)0);
  }
#line 261
  is_big_endian = (int )coff_magic[i].is_big_endian;
#line 263
  if (is_big_endian) {
#line 263
    magic = magic_big;
  } else {
#line 263
    magic = magic_little;
  }
#line 264
  if (is_big_endian) {
#line 264
    fetch_16 = & simple_object_fetch_big_16;
  } else {
#line 264
    fetch_16 = & simple_object_fetch_little_16;
  }
#line 267
  if (is_big_endian) {
#line 267
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 267
    fetch_32 = & simple_object_fetch_little_32;
  }
  {
#line 271
  tmp___1 = simple_object_internal_read(descriptor, offset, hdrbuf, sizeof(hdrbuf),
                                        errmsg, err);
  }
#line 271
  if (! tmp___1) {
#line 273
    return ((void *)0);
  }
  {
#line 275
  flags___1 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_flags)));
  }
#line 276
  if (((int )flags___1 & (int )coff_magic[i].non_object_flags) != 0) {
#line 278
    *errmsg = "not relocatable object file";
#line 279
    *err = 0;
#line 280
    return ((void *)0);
  }
  {
#line 283
  tmp___2 = xmalloc(sizeof(struct simple_object_coff_read ));
#line 283
  ocr = (struct simple_object_coff_read *)tmp___2;
#line 284
  ocr->magic = magic;
#line 285
  ocr->is_big_endian = (unsigned char )is_big_endian;
#line 286
  ocr->nscns = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_nscns)));
#line 287
  tmp___3 = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_symptr)));
#line 287
  ocr->symptr = (off_t )tmp___3;
#line 289
  ocr->nsyms = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_nsyms)));
#line 290
  ocr->flags = flags___1;
#line 291
  tmp___4 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_opthdr)));
#line 291
  ocr->scnhdr_offset = (off_t )(sizeof(struct external_filehdr___0 ) + (unsigned long )tmp___4);
  }
#line 295
  return ((void *)ocr);
}
}
#line 300 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static char *simple_object_coff_read_strtab(simple_object_read *sobj , size_t *strtab_size ,
                                            char const   **errmsg , int *err ) 
{ 
  struct simple_object_coff_read *ocr ;
  off_t strtab_offset ;
  unsigned char strsizebuf[4] ;
  size_t strsize ;
  char *strtab ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 304
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 311
  strtab_offset = (off_t )((unsigned long )(sobj->offset + ocr->symptr) + (unsigned long )ocr->nsyms * sizeof(struct external_syment___0 ));
#line 313
  tmp___0 = simple_object_internal_read(sobj->descriptor, strtab_offset, strsizebuf,
                                        (size_t )4, errmsg, err);
  }
#line 313
  if (! tmp___0) {
#line 315
    return ((char *)((void *)0));
  }
#line 316
  if (ocr->is_big_endian) {
    {
#line 316
    tmp___1 = simple_object_fetch_big_32((unsigned char const   *)(strsizebuf));
#line 316
    strsize = (size_t )tmp___1;
    }
  } else {
    {
#line 316
    tmp___2 = simple_object_fetch_little_32((unsigned char const   *)(strsizebuf));
#line 316
    strsize = (size_t )tmp___2;
    }
  }
  {
#line 319
  tmp___3 = xmalloc(sizeof(char ) * strsize);
#line 319
  strtab = (char *)tmp___3;
#line 320
  tmp___4 = simple_object_internal_read(sobj->descriptor, strtab_offset, (unsigned char *)strtab,
                                        strsize, errmsg, err);
  }
#line 320
  if (! tmp___4) {
    {
#line 324
    free((void *)strtab);
    }
#line 325
    return ((char *)((void *)0));
  }
#line 327
  *strtab_size = strsize;
#line 328
  return (strtab);
}
}
#line 333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_find_sections(simple_object_read *sobj , int (*pfn)(void * ,
                                                                                            char const   * ,
                                                                                            off_t offset ,
                                                                                            off_t length ) ,
                                                      void *data , int *err ) 
{ 
  struct simple_object_coff_read *ocr ;
  size_t scnhdr_size ;
  unsigned char *scnbuf ;
  char const   *errmsg ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned int nscns ;
  char *strtab ;
  size_t strtab_size ;
  unsigned int i ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char *scnhdr ;
  unsigned char *scnname ;
  char namebuf[9] ;
  char *name___0 ;
  off_t scnptr ;
  unsigned int size ;
  size_t strindex ;
  char *end ;
  long tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 340
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 351
  scnhdr_size = sizeof(struct external_scnhdr___0 );
#line 352
  tmp___0 = xmalloc(sizeof(unsigned char ) * (scnhdr_size * (size_t )ocr->nscns));
#line 352
  scnbuf = (unsigned char *)tmp___0;
#line 353
  tmp___1 = simple_object_internal_read(sobj->descriptor, sobj->offset + ocr->scnhdr_offset,
                                        scnbuf, scnhdr_size * (size_t )ocr->nscns,
                                        & errmsg, err);
  }
#line 353
  if (! tmp___1) {
    {
#line 358
    free((void *)scnbuf);
    }
#line 359
    return (errmsg);
  }
#line 362
  if (ocr->is_big_endian) {
#line 362
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 362
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 366
  nscns = (unsigned int )ocr->nscns;
#line 367
  strtab = (char *)((void *)0);
#line 368
  strtab_size = (size_t )0;
#line 369
  i = 0U;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i < nscns)) {
#line 369
      goto while_break;
    }
    {
#line 378
    scnhdr = scnbuf + (size_t )i * scnhdr_size;
#line 379
    scnname = scnhdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_name);
#line 380
    memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)scnname,
           (size_t )8);
#line 381
    namebuf[8] = (char )'\000';
#line 382
    name___0 = & namebuf[0];
    }
#line 383
    if ((int )namebuf[0] == 47) {
      {
#line 388
      tmp___2 = strtol((char const   */* __restrict  */)(namebuf + 1), (char **/* __restrict  */)(& end),
                       10);
#line 388
      strindex = (size_t )tmp___2;
      }
#line 389
      if ((int )*end == 0) {
#line 393
        if ((unsigned long )strtab == (unsigned long )((void *)0)) {
          {
#line 395
          strtab = simple_object_coff_read_strtab(sobj, & strtab_size, & errmsg, err);
          }
#line 398
          if ((unsigned long )strtab == (unsigned long )((void *)0)) {
            {
#line 400
            free((void *)scnbuf);
            }
#line 401
            return (errmsg);
          }
        }
#line 405
        if (strindex < 4UL) {
          {
#line 407
          free((void *)strtab);
#line 408
          free((void *)scnbuf);
#line 409
          *err = 0;
          }
#line 410
          return ("section string index out of range");
        } else
#line 405
        if (strindex >= strtab_size) {
          {
#line 407
          free((void *)strtab);
#line 408
          free((void *)scnbuf);
#line 409
          *err = 0;
          }
#line 410
          return ("section string index out of range");
        }
#line 413
        name___0 = strtab + strindex;
      }
    }
    {
#line 417
    tmp___3 = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_scnptr)));
#line 417
    scnptr = (off_t )tmp___3;
#line 418
    size = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_size)));
#line 420
    tmp___4 = (*pfn)(data, (char const   *)name___0, scnptr, (off_t )size);
    }
#line 420
    if (! tmp___4) {
#line 421
      goto while_break;
    }
#line 369
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  if ((unsigned long )strtab != (unsigned long )((void *)0)) {
    {
#line 425
    free((void *)strtab);
    }
  }
  {
#line 426
  free((void *)scnbuf);
  }
#line 428
  return ((char const   *)((void *)0));
}
}
#line 433 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void *simple_object_coff_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                 int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_coff_read *ocr ;
  struct simple_object_coff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 438
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 442
  tmp___0 = xmalloc(sizeof(struct simple_object_coff_attributes ));
#line 442
  ret = (struct simple_object_coff_attributes *)tmp___0;
#line 443
  ret->magic = ocr->magic;
#line 444
  ret->is_big_endian = ocr->is_big_endian;
#line 445
  ret->flags = ocr->flags;
  }
#line 446
  return ((void *)ret);
}
}
#line 451 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_read(void *data ) 
{ 


  {
  {
#line 454
  free(data);
  }
#line 455
  return;
}
}
#line 459 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_attributes_merge(void *todata , void *fromdata ,
                                                         int *err ) 
{ 
  struct simple_object_coff_attributes *to ;
  struct simple_object_coff_attributes *from ;

  {
#line 462
  to = (struct simple_object_coff_attributes *)todata;
#line 464
  from = (struct simple_object_coff_attributes *)fromdata;
#line 467
  if ((int )to->magic != (int )from->magic) {
#line 469
    *err = 0;
#line 470
    return ("COFF object format mismatch");
  } else
#line 467
  if ((int )to->is_big_endian != (int )from->is_big_endian) {
#line 469
    *err = 0;
#line 470
    return ("COFF object format mismatch");
  }
#line 472
  return ((char const   *)((void *)0));
}
}
#line 477 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_attributes(void *data ) 
{ 


  {
  {
#line 480
  free(data);
  }
#line 481
  return;
}
}
#line 485 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void *simple_object_coff_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                            int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  struct simple_object_coff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 490
  attrs = (struct simple_object_coff_attributes *)attributes_data;
#line 496
  tmp___0 = xmalloc(sizeof(struct simple_object_coff_attributes ));
#line 496
  ret = (struct simple_object_coff_attributes *)tmp___0;
#line 497
  *ret = *attrs;
  }
#line 498
  return ((void *)ret);
}
}
#line 503 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static int simple_object_coff_write_filehdr(simple_object_write *sobj , int descriptor ,
                                            unsigned int nscns , size_t symtab_offset ,
                                            unsigned int nsyms , char const   **errmsg ,
                                            int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  unsigned char hdrbuf[sizeof(struct external_filehdr___0 )] ;
  unsigned char *hdr ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  int tmp___0 ;

  {
#line 509
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 516
  hdr = & hdrbuf[0];
#line 518
  if (attrs->is_big_endian) {
#line 518
    set_16 = & simple_object_set_big_16;
  } else {
#line 518
    set_16 = & simple_object_set_little_16;
  }
#line 521
  if (attrs->is_big_endian) {
#line 521
    set_32 = & simple_object_set_big_32;
  } else {
#line 521
    set_32 = & simple_object_set_little_32;
  }
  {
#line 525
  memset((void *)hdr, 0, sizeof(struct external_filehdr___0 ));
#line 527
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_magic),
            attrs->magic);
#line 528
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_nscns),
            (unsigned short )nscns);
#line 530
  (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_symptr),
            (unsigned int )symtab_offset);
#line 531
  (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_nsyms),
            nsyms);
#line 533
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr___0 *)0)->f_flags),
            attrs->flags);
#line 535
  tmp___0 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(hdrbuf),
                                         sizeof(struct external_filehdr___0 ), errmsg,
                                         err);
  }
#line 535
  return (tmp___0);
}
}
#line 542 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static int simple_object_coff_write_scnhdr(simple_object_write *sobj , int descriptor ,
                                           char const   *name___0 , size_t *name_offset ,
                                           off_t scnhdr_offset , size_t scnsize ,
                                           off_t offset , unsigned int align , char const   **errmsg ,
                                           int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct external_scnhdr___0 )] ;
  unsigned char *hdr ;
  size_t namelen ;
  unsigned int flags___1 ;
  int tmp___0 ;

  {
#line 549
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 557
  if (attrs->is_big_endian) {
#line 557
    set_32 = & simple_object_set_big_32;
  } else {
#line 557
    set_32 = & simple_object_set_little_32;
  }
  {
#line 561
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 562
  hdr = & hdrbuf[0];
#line 564
  namelen = strlen(name___0);
  }
#line 565
  if (namelen <= 8UL) {
    {
#line 566
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_name)),
            (char const   */* __restrict  */)name___0, (size_t )8);
    }
  } else {
    {
#line 570
    snprintf((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_name)),
             (size_t )8, (char const   */* __restrict  */)"/%lu", *name_offset);
#line 572
    *name_offset += namelen + 1UL;
    }
  }
  {
#line 577
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_size), (unsigned int )scnsize);
#line 578
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_scnptr),
            (unsigned int )offset);
#line 583
  flags___1 = (unsigned int )((((1 << 6) | (1 << 25)) | (1 << 28)) | (1 << 30));
  }
#line 586
  if (align > 13U) {
#line 587
    align = 13U;
  }
  {
#line 588
  flags___1 |= (align + 1U) << 20;
#line 589
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr___0 *)0)->s_flags),
            flags___1);
#line 591
  tmp___0 = simple_object_internal_write(descriptor, scnhdr_offset, (unsigned char const   *)(hdrbuf),
                                         sizeof(struct external_scnhdr___0 ), errmsg,
                                         err);
  }
#line 591
  return (tmp___0);
}
}
#line 598 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_write_to_file(simple_object_write *sobj ,
                                                      int descriptor , int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  unsigned int nscns ;
  unsigned int secnum ;
  simple_object_write_section *section ;
  off_t scnhdr_offset ;
  size_t symtab_offset ;
  off_t secsym_offset ;
  unsigned int nsyms ;
  size_t offset ;
  size_t name_offset ;
  char const   *errmsg ;
  unsigned char strsizebuf[4] ;
  char const   *source_filename ;
  size_t sflen ;
  union __anonunion_syms_806857204___0 syms[2] ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  size_t mask ;
  size_t new_offset ;
  size_t scnsize ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t namelen ;
  size_t scnsize___0 ;
  struct simple_object_write_section_buffer *buffer___3 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 602
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 617
  source_filename = "fake";
#line 627
  if (attrs->is_big_endian) {
#line 627
    set_16 = & simple_object_set_big_16;
  } else {
#line 627
    set_16 = & simple_object_set_little_16;
  }
#line 630
  if (attrs->is_big_endian) {
#line 630
    set_32 = & simple_object_set_big_32;
  } else {
#line 630
    set_32 = & simple_object_set_little_32;
  }
#line 634
  nscns = 0U;
#line 635
  section = sobj->sections;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
#line 636
    nscns ++;
#line 635
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  scnhdr_offset = (off_t )sizeof(struct external_filehdr___0 );
#line 639
  offset = (unsigned long )scnhdr_offset + (unsigned long )nscns * sizeof(struct external_scnhdr___0 );
#line 640
  name_offset = (size_t )4;
#line 641
  section = sobj->sections;
  {
#line 641
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 641
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 641
      goto while_break___0;
    }
#line 648
    mask = (size_t )((1U << section->align) - 1U);
#line 649
    new_offset = offset & mask;
#line 650
    new_offset &= ~ mask;
    {
#line 651
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 651
      if (! (new_offset > offset)) {
#line 651
        goto while_break___1;
      }
      {
#line 656
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 657
      write___0 = new_offset - offset;
      }
#line 658
      if (write___0 > sizeof(zeroes)) {
#line 659
        write___0 = sizeof(zeroes);
      }
      {
#line 660
      tmp___0 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(zeroes),
                                             write___0, & errmsg, err);
      }
#line 660
      if (! tmp___0) {
#line 662
        return (errmsg);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 665
    scnsize = (size_t )0;
#line 666
    buffer___2 = section->buffers;
    {
#line 666
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 666
        goto while_break___2;
      }
      {
#line 668
      tmp___1 = simple_object_internal_write(descriptor, (off_t )(offset + scnsize),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, & errmsg, err);
      }
#line 668
      if (! tmp___1) {
#line 672
        return (errmsg);
      }
#line 673
      scnsize += buffer___2->size;
#line 666
      buffer___2 = buffer___2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 676
    tmp___2 = simple_object_coff_write_scnhdr(sobj, descriptor, (char const   *)section->name,
                                              & name_offset, scnhdr_offset, scnsize,
                                              (off_t )offset, section->align, & errmsg,
                                              err);
    }
#line 676
    if (! tmp___2) {
#line 680
      return (errmsg);
    }
#line 682
    scnhdr_offset = (off_t )((unsigned long )scnhdr_offset + sizeof(struct external_scnhdr___0 ));
#line 683
    offset += scnsize;
#line 641
    section = section->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 687
  offset += offset & 1UL;
#line 690
  nsyms = 2U * (nscns + 1U);
#line 691
  symtab_offset = offset;
#line 694
  offset += (unsigned long )nsyms * sizeof(struct external_syment___0 );
#line 697
  memset((void *)(& syms[0]), 0, sizeof(syms));
#line 698
  strcpy((char */* __restrict  */)((char *)(& syms[0].sym.e.e_name[0])), (char const   */* __restrict  */)".file");
#line 699
  (*set_16)(& syms[0].sym.e_scnum[0], (unsigned short)65534);
#line 700
  (*set_16)(& syms[0].sym.e_type[0], (unsigned short)0);
#line 701
  syms[0].sym.e_sclass[0] = (unsigned char)103;
#line 702
  syms[0].sym.e_numaux[0] = (unsigned char)1;
#line 705
  sflen = strlen(source_filename);
  }
#line 706
  if (sflen <= 18UL) {
    {
#line 707
    memcpy((void */* __restrict  */)(& syms[1].aux.x_file.x_fname[0]), (void const   */* __restrict  */)source_filename,
           sflen);
    }
  } else {
    {
#line 710
    (*set_32)(& syms[1].aux.x_file.x_n.x_offset[0], (unsigned int )name_offset);
#line 711
    tmp___3 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                           (unsigned char const   *)source_filename,
                                           sflen + 1UL, & errmsg, err);
    }
#line 711
    if (! tmp___3) {
#line 715
      return (errmsg);
    }
    {
#line 716
    tmp___4 = strlen(source_filename);
#line 716
    name_offset += tmp___4 + 1UL;
    }
  }
  {
#line 718
  tmp___5 = simple_object_internal_write(descriptor, (off_t )symtab_offset, (unsigned char const   *)(& syms[0]),
                                         sizeof(syms), & errmsg, err);
  }
#line 718
  if (! tmp___5) {
#line 721
    return (errmsg);
  }
  {
#line 725
  (*set_32)(strsizebuf, (unsigned int )name_offset);
#line 726
  tmp___6 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(strsizebuf),
                                         (size_t )4, & errmsg, err);
  }
#line 726
  if (! tmp___6) {
#line 728
    return (errmsg);
  }
  {
#line 730
  name_offset = (size_t )4;
#line 731
  secsym_offset = (off_t )(symtab_offset + sizeof(syms));
#line 732
  memset((void *)(& syms[0]), 0, sizeof(syms));
#line 733
  (*set_16)(& syms[0].sym.e_type[0], (unsigned short)0);
#line 734
  syms[0].sym.e_sclass[0] = (unsigned char)3;
#line 735
  syms[0].sym.e_numaux[0] = (unsigned char)1;
#line 736
  secnum = 1U;
#line 738
  section = sobj->sections;
  }
  {
#line 738
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 738
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 738
      goto while_break___3;
    }
    {
#line 744
    namelen = strlen((char const   *)section->name);
#line 745
    tmp___7 = secnum;
#line 745
    secnum ++;
#line 745
    (*set_16)(& syms[0].sym.e_scnum[0], (unsigned short )tmp___7);
#line 746
    scnsize___0 = (size_t )0;
#line 747
    buffer___3 = section->buffers;
    }
    {
#line 747
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 747
      if (! ((unsigned long )buffer___3 != (unsigned long )((void *)0))) {
#line 747
        goto while_break___4;
      }
#line 748
      scnsize___0 += buffer___3->size;
#line 747
      buffer___3 = buffer___3->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 749
    (*set_32)(& syms[1].aux.x_scn.x_scnlen[0], (unsigned int )scnsize___0);
    }
#line 750
    if (namelen > 8UL) {
      {
#line 752
      (*set_32)(& syms[0].sym.e.e.e_zeroes[0], 0U);
#line 753
      (*set_32)(& syms[0].sym.e.e.e_offset[0], (unsigned int )name_offset);
#line 754
      tmp___8 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                             (unsigned char const   *)section->name,
                                             namelen + 1UL, & errmsg, err);
      }
#line 754
      if (! tmp___8) {
#line 758
        return (errmsg);
      }
#line 759
      name_offset += namelen + 1UL;
    } else {
      {
#line 763
      tmp___9 = strlen((char const   *)section->name);
#line 763
      memcpy((void */* __restrict  */)(& syms[0].sym.e.e_name[0]), (void const   */* __restrict  */)section->name,
             tmp___9);
#line 765
      tmp___10 = strlen((char const   *)section->name);
#line 765
      tmp___11 = strlen((char const   *)section->name);
#line 765
      memset((void *)(& syms[0].sym.e.e_name[tmp___11]), 0, 8UL - tmp___10);
      }
    }
    {
#line 769
    tmp___12 = simple_object_internal_write(descriptor, secsym_offset, (unsigned char const   *)(& syms[0]),
                                            sizeof(syms), & errmsg, err);
    }
#line 769
    if (! tmp___12) {
#line 772
      return (errmsg);
    }
#line 773
    secsym_offset = (off_t )((unsigned long )secsym_offset + sizeof(syms));
#line 738
    section = section->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 776
  tmp___13 = simple_object_coff_write_filehdr(sobj, descriptor, nscns, symtab_offset,
                                              nsyms, & errmsg, err);
  }
#line 776
  if (! tmp___13) {
#line 778
    return (errmsg);
  }
#line 780
  return ((char const   *)((void *)0));
}
}
#line 785 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_write(void *data ) 
{ 


  {
  {
#line 788
  free(data);
  }
#line 789
  return;
}
}
#line 793 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./simple-object-coff.c"
struct simple_object_functions  const  simple_object_coff_functions  = 
#line 793
     {& simple_object_coff_match, & simple_object_coff_find_sections, & simple_object_coff_fetch_attributes,
    & simple_object_coff_release_read, & simple_object_coff_attributes_merge, & simple_object_coff_release_attributes,
    & simple_object_coff_start_write, & simple_object_coff_write_to_file, & simple_object_coff_release_write};
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 96 "./../include/sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 102
void sha1_process_block(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) ;
#line 109
void sha1_process_bytes(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) ;
#line 119
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 128
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 134
int sha1_stream(FILE *stream , void *resblock ) ;
#line 140
void *sha1_buffer(char const   *buffer___2 , size_t len , void *resblock ) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 57 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ 
  sha1_uint32 tmp___0 ;

  {
#line 60
  ctx->A = (sha1_uint32 )1732584193;
#line 61
  ctx->B = 4023233417U;
#line 62
  ctx->C = 2562383102U;
#line 63
  ctx->D = (sha1_uint32 )271733878;
#line 64
  ctx->E = 3285377520U;
#line 66
  tmp___0 = (sha1_uint32 )0;
#line 66
  ctx->total[1] = tmp___0;
#line 66
  ctx->total[0] = tmp___0;
#line 67
  ctx->buflen = (sha1_uint32 )0;
#line 68
  return;
}
}
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 78
  *((sha1_uint32 *)resbuf + 0) = (sha1_uint32 )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24));
#line 79
  *((sha1_uint32 *)resbuf + 1) = (sha1_uint32 )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24));
#line 80
  *((sha1_uint32 *)resbuf + 2) = (sha1_uint32 )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24));
#line 81
  *((sha1_uint32 *)resbuf + 3) = (sha1_uint32 )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24));
#line 82
  *((sha1_uint32 *)resbuf + 4) = (sha1_uint32 )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24));
#line 84
  return (resbuf);
}
}
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ 
  sha1_uint32 bytes ;
  size_t size ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 96
  bytes = ctx->buflen;
#line 97
  if (bytes < 56U) {
#line 97
    tmp___0 = 16;
  } else {
#line 97
    tmp___0 = 32;
  }
#line 97
  size = (size_t )tmp___0;
#line 100
  ctx->total[0] += bytes;
#line 101
  if (ctx->total[0] < bytes) {
#line 102
    (ctx->total[1]) ++;
  }
  {
#line 105
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 106
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 108
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 111
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 113
  tmp___1 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
  }
#line 113
  return (tmp___1);
}
}
#line 119 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  char buffer___2[4168] ;
  size_t sum ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 127
  sha1_init_ctx(& ctx);
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    sum = (size_t )0;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 141
      n = fread((void */* __restrict  */)(buffer___2 + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 143
      sum += n;
      }
#line 145
      if (sum == 4096UL) {
#line 146
        goto while_break___0;
      }
#line 148
      if (n == 0UL) {
        {
#line 153
        tmp___0 = ferror(stream);
        }
#line 153
        if (tmp___0) {
#line 154
          return (1);
        }
#line 155
        goto process_partial_block;
      }
      {
#line 161
      tmp___1 = feof(stream);
      }
#line 161
      if (tmp___1) {
#line 162
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 168
    sha1_process_block((void const   *)(buffer___2), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 174
  if (sum > 0UL) {
    {
#line 175
    sha1_process_bytes((void const   *)(buffer___2), sum, & ctx);
    }
  }
  {
#line 178
  sha1_finish_ctx(& ctx, resblock);
  }
#line 179
  return (0);
}
}
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void *sha1_buffer(char const   *buffer___2 , size_t len , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  void *tmp___0 ;

  {
  {
#line 192
  sha1_init_ctx(& ctx);
#line 195
  sha1_process_bytes((void const   *)buffer___2, len, & ctx);
#line 198
  tmp___0 = sha1_finish_ctx(& ctx, resblock);
  }
#line 198
  return (tmp___0);
}
}
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void sha1_process_bytes(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t left_over___0 ;

  {
#line 206
  if (ctx->buflen != 0U) {
#line 208
    left_over = (size_t )ctx->buflen;
#line 209
    if (128UL - left_over > len) {
#line 209
      tmp___0 = len;
    } else {
#line 209
      tmp___0 = 128UL - left_over;
    }
    {
#line 209
    add = tmp___0;
#line 211
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer___2,
           add);
#line 212
    ctx->buflen = (sha1_uint32 )((size_t )ctx->buflen + add);
    }
#line 214
    if (ctx->buflen > 64U) {
      {
#line 216
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
#line 218
      ctx->buflen &= 63U;
#line 220
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 225
    buffer___2 = (void const   *)((char const   *)buffer___2 + add);
#line 226
    len -= add;
  }
#line 230
  if (len >= 64UL) {
#line 235
    if ((size_t )buffer___2 % (unsigned long )(& ((struct __anonstruct_694274947 *)0)->x) != 0UL) {
      {
#line 236
      while (1) {
        while_continue: /* CIL Label */ ;
#line 236
        if (! (len > 64UL)) {
#line 236
          goto while_break;
        }
        {
#line 238
        tmp___1 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
                         (size_t )64);
#line 238
        sha1_process_block((void const   *)tmp___1, (size_t )64, ctx);
#line 239
        buffer___2 = (void const   *)((char const   *)buffer___2 + 64);
#line 240
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 245
      sha1_process_block(buffer___2, len & 0xffffffffffffffc0UL, ctx);
#line 246
      buffer___2 = (void const   *)((char const   *)buffer___2 + (len & 0xffffffffffffffc0UL));
#line 247
      len &= 63UL;
      }
    }
  }
#line 252
  if (len > 0UL) {
    {
#line 254
    left_over___0 = (size_t )ctx->buflen;
#line 256
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer___2,
           len);
#line 257
    left_over___0 += len;
    }
#line 258
    if (left_over___0 >= 64UL) {
      {
#line 260
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 261
      left_over___0 -= 64UL;
#line 262
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 264
    ctx->buflen = (sha1_uint32 )left_over___0;
  }
#line 266
  return;
}
}
#line 286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./sha1.c"
void sha1_process_block(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) 
{ 
  sha1_uint32 const   *words ;
  size_t nwords ;
  sha1_uint32 const   *endp ;
  sha1_uint32 x[16] ;
  sha1_uint32 a ;
  sha1_uint32 b ;
  sha1_uint32 c ;
  sha1_uint32 d ;
  sha1_uint32 e ;
  sha1_uint32 tm ;
  int t ;
  sha1_uint32 tmp___0 ;
  sha1_uint32 tmp___1 ;
  sha1_uint32 tmp___2 ;
  sha1_uint32 tmp___3 ;
  sha1_uint32 tmp___4 ;

  {
#line 289
  words = (sha1_uint32 const   *)buffer___2;
#line 290
  nwords = len / sizeof(sha1_uint32 );
#line 291
  endp = words + nwords;
#line 293
  a = ctx->A;
#line 294
  b = ctx->B;
#line 295
  c = ctx->C;
#line 296
  d = ctx->D;
#line 297
  e = ctx->E;
#line 302
  ctx->total[0] = (sha1_uint32 )((size_t )ctx->total[0] + len);
#line 303
  ctx->total[1] = (sha1_uint32 )((size_t )ctx->total[1] + (((len >> 31) >> 1) + (size_t )((size_t )ctx->total[0] < len)));
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 318
      goto while_break;
    }
#line 322
    t = 0;
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if (! (t < 16)) {
#line 322
        goto while_break___0;
      }
#line 324
      x[t] = (sha1_uint32 )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 325
      words ++;
#line 322
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 328
      b = (b << 30) | (b >> 2);
#line 328
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 329
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 329
      a = (a << 30) | (a >> 2);
#line 329
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 330
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 330
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 330
      e = (e << 30) | (e >> 2);
#line 330
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 331
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 331
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 331
      d = (d << 30) | (d >> 2);
#line 331
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 332
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 332
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 332
      c = (c << 30) | (c >> 2);
#line 332
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 333
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 333
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 333
      b = (b << 30) | (b >> 2);
#line 333
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 334
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 334
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 334
      a = (a << 30) | (a >> 2);
#line 334
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 335
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 335
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 335
      e = (e << 30) | (e >> 2);
#line 335
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 336
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 336
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 336
      d = (d << 30) | (d >> 2);
#line 336
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 337
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 337
      c = (c << 30) | (c >> 2);
#line 337
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 338
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 338
      b = (b << 30) | (b >> 2);
#line 338
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 339
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 339
      a = (a << 30) | (a >> 2);
#line 339
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 340
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 340
      e = (e << 30) | (e >> 2);
#line 340
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 341
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 341
      d = (d << 30) | (d >> 2);
#line 341
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 342
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 342
      c = (c << 30) | (c >> 2);
#line 342
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 343
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 343
      b = (b << 30) | (b >> 2);
#line 343
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 344
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 344
      x[0] = (tm << 1) | (tm >> 31);
#line 344
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 344
      a = (a << 30) | (a >> 2);
#line 344
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 345
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 345
      x[1] = (tm << 1) | (tm >> 31);
#line 345
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 345
      e = (e << 30) | (e >> 2);
#line 345
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 346
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 346
      x[2] = (tm << 1) | (tm >> 31);
#line 346
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 346
      d = (d << 30) | (d >> 2);
#line 346
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 347
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 347
      x[3] = (tm << 1) | (tm >> 31);
#line 347
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 347
      c = (c << 30) | (c >> 2);
#line 347
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 348
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 348
      x[4] = (tm << 1) | (tm >> 31);
#line 348
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 348
      b = (b << 30) | (b >> 2);
#line 348
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 349
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 349
      x[5] = (tm << 1) | (tm >> 31);
#line 349
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 349
      a = (a << 30) | (a >> 2);
#line 349
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 350
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 350
      x[6] = (tm << 1) | (tm >> 31);
#line 350
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 350
      e = (e << 30) | (e >> 2);
#line 350
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 351
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 351
      x[7] = (tm << 1) | (tm >> 31);
#line 351
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 351
      d = (d << 30) | (d >> 2);
#line 351
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 352
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 352
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 352
      x[8] = (tm << 1) | (tm >> 31);
#line 352
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 352
      c = (c << 30) | (c >> 2);
#line 352
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 353
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 353
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 353
      x[9] = (tm << 1) | (tm >> 31);
#line 353
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 353
      b = (b << 30) | (b >> 2);
#line 353
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 354
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 354
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 354
      x[10] = (tm << 1) | (tm >> 31);
#line 354
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 354
      a = (a << 30) | (a >> 2);
#line 354
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 355
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 355
      x[11] = (tm << 1) | (tm >> 31);
#line 355
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 355
      e = (e << 30) | (e >> 2);
#line 355
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 356
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 356
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 356
      x[12] = (tm << 1) | (tm >> 31);
#line 356
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 356
      d = (d << 30) | (d >> 2);
#line 356
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 357
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 357
      x[13] = (tm << 1) | (tm >> 31);
#line 357
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 357
      c = (c << 30) | (c >> 2);
#line 357
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 358
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 358
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 358
      x[14] = (tm << 1) | (tm >> 31);
#line 358
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 358
      b = (b << 30) | (b >> 2);
#line 358
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 359
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 359
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 359
      x[15] = (tm << 1) | (tm >> 31);
#line 359
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 359
      a = (a << 30) | (a >> 2);
#line 359
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 360
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 360
      x[0] = (tm << 1) | (tm >> 31);
#line 360
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 360
      e = (e << 30) | (e >> 2);
#line 360
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 361
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 361
      x[1] = (tm << 1) | (tm >> 31);
#line 361
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 361
      d = (d << 30) | (d >> 2);
#line 361
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 362
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 362
      x[2] = (tm << 1) | (tm >> 31);
#line 362
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 362
      c = (c << 30) | (c >> 2);
#line 362
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 363
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 363
      x[3] = (tm << 1) | (tm >> 31);
#line 363
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 363
      b = (b << 30) | (b >> 2);
#line 363
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 364
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 364
      x[4] = (tm << 1) | (tm >> 31);
#line 364
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 364
      a = (a << 30) | (a >> 2);
#line 364
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 365
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 365
      x[5] = (tm << 1) | (tm >> 31);
#line 365
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 365
      e = (e << 30) | (e >> 2);
#line 365
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 366
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 366
      x[6] = (tm << 1) | (tm >> 31);
#line 366
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 366
      d = (d << 30) | (d >> 2);
#line 366
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 367
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 367
      x[7] = (tm << 1) | (tm >> 31);
#line 367
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 367
      c = (c << 30) | (c >> 2);
#line 367
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 368
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 368
      x[8] = (tm << 1) | (tm >> 31);
#line 368
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 368
      b = (b << 30) | (b >> 2);
#line 368
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 369
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 369
      x[9] = (tm << 1) | (tm >> 31);
#line 369
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 369
      a = (a << 30) | (a >> 2);
#line 369
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 370
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 370
      x[10] = (tm << 1) | (tm >> 31);
#line 370
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 370
      e = (e << 30) | (e >> 2);
#line 370
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 371
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 371
      x[11] = (tm << 1) | (tm >> 31);
#line 371
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 371
      d = (d << 30) | (d >> 2);
#line 371
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 372
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 372
      x[12] = (tm << 1) | (tm >> 31);
#line 372
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 372
      c = (c << 30) | (c >> 2);
#line 372
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 373
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 373
      x[13] = (tm << 1) | (tm >> 31);
#line 373
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 373
      b = (b << 30) | (b >> 2);
#line 373
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 374
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 374
      x[14] = (tm << 1) | (tm >> 31);
#line 374
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 374
      a = (a << 30) | (a >> 2);
#line 374
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 375
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 375
      x[15] = (tm << 1) | (tm >> 31);
#line 375
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 375
      e = (e << 30) | (e >> 2);
#line 375
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 376
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 376
      x[0] = (tm << 1) | (tm >> 31);
#line 376
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 376
      d = (d << 30) | (d >> 2);
#line 376
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 377
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 377
      x[1] = (tm << 1) | (tm >> 31);
#line 377
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 377
      c = (c << 30) | (c >> 2);
#line 377
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 378
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 378
      x[2] = (tm << 1) | (tm >> 31);
#line 378
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 378
      b = (b << 30) | (b >> 2);
#line 378
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 379
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 379
      x[3] = (tm << 1) | (tm >> 31);
#line 379
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 379
      a = (a << 30) | (a >> 2);
#line 379
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 380
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 380
      x[4] = (tm << 1) | (tm >> 31);
#line 380
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 380
      e = (e << 30) | (e >> 2);
#line 380
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 381
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 381
      x[5] = (tm << 1) | (tm >> 31);
#line 381
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 381
      d = (d << 30) | (d >> 2);
#line 381
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 382
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 382
      x[6] = (tm << 1) | (tm >> 31);
#line 382
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 382
      c = (c << 30) | (c >> 2);
#line 382
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 383
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 383
      x[7] = (tm << 1) | (tm >> 31);
#line 383
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 383
      b = (b << 30) | (b >> 2);
#line 383
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 384
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 384
      x[8] = (tm << 1) | (tm >> 31);
#line 384
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 384
      a = (a << 30) | (a >> 2);
#line 384
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 385
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 385
      x[9] = (tm << 1) | (tm >> 31);
#line 385
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 385
      e = (e << 30) | (e >> 2);
#line 385
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 386
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 386
      x[10] = (tm << 1) | (tm >> 31);
#line 386
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 386
      d = (d << 30) | (d >> 2);
#line 386
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 387
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 387
      x[11] = (tm << 1) | (tm >> 31);
#line 387
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 387
      c = (c << 30) | (c >> 2);
#line 387
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 388
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 388
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 388
      x[12] = (tm << 1) | (tm >> 31);
#line 388
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 388
      b = (b << 30) | (b >> 2);
#line 388
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 389
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 389
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 389
      x[13] = (tm << 1) | (tm >> 31);
#line 389
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 389
      a = (a << 30) | (a >> 2);
#line 389
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 390
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 390
      x[14] = (tm << 1) | (tm >> 31);
#line 390
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 390
      e = (e << 30) | (e >> 2);
#line 390
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 391
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 391
      x[15] = (tm << 1) | (tm >> 31);
#line 391
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 391
      d = (d << 30) | (d >> 2);
#line 391
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 392
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 392
      x[0] = (tm << 1) | (tm >> 31);
#line 392
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 392
      c = (c << 30) | (c >> 2);
#line 392
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 393
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 393
      x[1] = (tm << 1) | (tm >> 31);
#line 393
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 393
      b = (b << 30) | (b >> 2);
#line 393
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 394
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 394
      x[2] = (tm << 1) | (tm >> 31);
#line 394
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 394
      a = (a << 30) | (a >> 2);
#line 394
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 395
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 395
      x[3] = (tm << 1) | (tm >> 31);
#line 395
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 395
      e = (e << 30) | (e >> 2);
#line 395
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 396
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 396
      x[4] = (tm << 1) | (tm >> 31);
#line 396
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 396
      d = (d << 30) | (d >> 2);
#line 396
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 397
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 397
      x[5] = (tm << 1) | (tm >> 31);
#line 397
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 397
      c = (c << 30) | (c >> 2);
#line 397
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 398
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 398
      x[6] = (tm << 1) | (tm >> 31);
#line 398
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 398
      b = (b << 30) | (b >> 2);
#line 398
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 399
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 399
      x[7] = (tm << 1) | (tm >> 31);
#line 399
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 399
      a = (a << 30) | (a >> 2);
#line 399
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 400
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 400
      x[8] = (tm << 1) | (tm >> 31);
#line 400
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 400
      e = (e << 30) | (e >> 2);
#line 400
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 401
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 401
      x[9] = (tm << 1) | (tm >> 31);
#line 401
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 401
      d = (d << 30) | (d >> 2);
#line 401
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 402
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 402
      x[10] = (tm << 1) | (tm >> 31);
#line 402
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 402
      c = (c << 30) | (c >> 2);
#line 402
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 403
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 403
      x[11] = (tm << 1) | (tm >> 31);
#line 403
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 403
      b = (b << 30) | (b >> 2);
#line 403
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 404
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 404
      x[12] = (tm << 1) | (tm >> 31);
#line 404
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 404
      a = (a << 30) | (a >> 2);
#line 404
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___78: /* CIL Label */ ;
#line 405
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 405
      x[13] = (tm << 1) | (tm >> 31);
#line 405
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 405
      e = (e << 30) | (e >> 2);
#line 405
      goto while_break___78;
    }
    while_break___78: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 406
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 406
      x[14] = (tm << 1) | (tm >> 31);
#line 406
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 406
      d = (d << 30) | (d >> 2);
#line 406
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___80: /* CIL Label */ ;
#line 407
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 407
      x[15] = (tm << 1) | (tm >> 31);
#line 407
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 407
      c = (c << 30) | (c >> 2);
#line 407
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 409
    tmp___0 = ctx->A + a;
#line 409
    ctx->A = tmp___0;
#line 409
    a = tmp___0;
#line 410
    tmp___1 = ctx->B + b;
#line 410
    ctx->B = tmp___1;
#line 410
    b = tmp___1;
#line 411
    tmp___2 = ctx->C + c;
#line 411
    ctx->C = tmp___2;
#line 411
    c = tmp___2;
#line 412
    tmp___3 = ctx->D + d;
#line 412
    ctx->D = tmp___3;
#line 412
    d = tmp___3;
#line 413
    tmp___4 = ctx->E + e;
#line 413
    ctx->E = tmp___4;
#line 413
    e = tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return;
}
}
#line 27 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) prctl)(int __option 
                                                                            , ...) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./setproctitle.c"
void setproctitle(char const   *name___0  __attribute__((__unused__))  , ...) 
{ 


  {
  {
#line 46
  prctl(15, name___0);
  }
#line 48
  return;
}
}
#line 85 "./../include/safe-ctype.h"
unsigned short const   _sch_istable[256] ;
#line 110
unsigned char const   _sch_toupper[256] ;
#line 111
unsigned char const   _sch_tolower[256] ;
#line 159 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./safe-ctype.c"
unsigned short const   _sch_istable[256]  = 
#line 159 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./safe-ctype.c"
  {      (unsigned short const   )2050,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2115,      (unsigned short const   )1090,      (unsigned short const   )2114, 
        (unsigned short const   )2114,      (unsigned short const   )1090,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2129,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912, 
        (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )560, 
        (unsigned short const   )48,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792, 
        (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )2, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0};
#line 191 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./safe-ctype.c"
unsigned char const   _sch_tolower[256]  = 
#line 191
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./safe-ctype.c"
unsigned char const   _sch_toupper[256]  = 
#line 220
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 174 "./../include/xregex2.h"
reg_syntax_t xre_syntax_options  ;
#line 442
reg_syntax_t xre_set_syntax(reg_syntax_t syntax ) ;
#line 447
char const   *xre_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 454
int xre_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 462
int xre_search(struct re_pattern_buffer *bufp , char const   *string , int size ,
               int startpos , int range , struct re_registers *regs ) ;
#line 469
int xre_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                 char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                 int stop ) ;
#line 477
int xre_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
              struct re_registers *regs ) ;
#line 482
int xre_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int pos , struct re_registers *regs ,
                int stop ) ;
#line 499
void xre_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                       unsigned int num_regs , xregoff_t *starts , xregoff_t *ends ) ;
#line 507
char *xre_comp(char const   *s ) ;
#line 508
int xre_exec(char const   *s ) ;
#line 535
int xregcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) ;
#line 542
int xregexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
             size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 547
size_t xregerror(int errcode , regex_t const   *preg  __attribute__((__unused__)) ,
                 char *errbuf , size_t errbuf_size ) ;
#line 550
void xregfree(regex_t *preg ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 274 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static char re_syntax_table[256]  ;
#line 276
static void init_syntax_once(void) ;
#line 282 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static int done  =    0;
#line 278 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static void init_syntax_once(void) 
{ 
  register int c ;
  unsigned short const   **tmp___0 ;

  {
#line 284
  if (done) {
#line 285
    return;
  }
  {
#line 286
  memset((void *)(re_syntax_table), '\000', sizeof(re_syntax_table));
#line 288
  c = 0;
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (c < 256)) {
#line 288
      goto while_break;
    }
    {
#line 289
    tmp___0 = __ctype_b_loc();
    }
#line 289
    if ((int const   )*(*tmp___0 + c) & 8) {
#line 290
      re_syntax_table[c] = (char)1;
    }
#line 288
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  re_syntax_table['_'] = (char)1;
#line 294
  done = 1;
#line 295
  return;
}
}
#line 410
static reg_errcode_t byte_regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                        struct re_pattern_buffer *bufp ) ;
#line 414
static int byte_re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                                    int size1 , char const   *string2 , int size2 ,
                                    int pos , struct re_registers *regs , int stop ) ;
#line 420
static int byte_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int size1 , char const   *string2 , int size2 , int startpos ,
                            int range , struct re_registers *regs , int stop ) ;
#line 425
static int byte_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 1461 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_max_failures  =    4000;
#line 1840 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static char byte_reg_unset_dummy  ;
#line 1845
static void byte_store_op1(re_opcode_t op , unsigned char *loc , int arg ) ;
#line 1846
static void byte_store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) ;
#line 1848
static void byte_insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) ;
#line 1850
static void byte_insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                            unsigned char *end ) ;
#line 1852
static boolean byte_at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) ;
#line 1855
static boolean byte_at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) ;
#line 1868
static reg_errcode_t byte_compile_range(unsigned int range_start_char , char const   **p_ptr ,
                                        char const   *pend , char *translate , reg_syntax_t syntax ,
                                        unsigned char *b ) ;
#line 2252
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) ;
#line 2283 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static reg_errcode_t byte_regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                        struct re_pattern_buffer *bufp ) 
{ 
  register unsigned char c ;
  register unsigned char c1 ;
  char const   *p1 ;
  register unsigned char *b ;
  compile_stack_type compile_stack ;
  char const   *p ;
  char const   *pend ;
  char *translate ;
  unsigned char *pending_exact ;
  unsigned char *laststart ;
  unsigned char *begalt ;
  unsigned char *fixup_alt_jump ;
  regnum_t regnum ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  unsigned char *old_buffer ;
  void *tmp___5 ;
  ptrdiff_t incr ;
  unsigned char *tmp___6 ;
  boolean tmp___7 ;
  unsigned char *old_buffer___0 ;
  void *tmp___8 ;
  ptrdiff_t incr___0 ;
  unsigned char *tmp___9 ;
  boolean tmp___10 ;
  boolean keep_string_p ;
  char zero_times_ok ;
  char many_times_ok ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  unsigned char *old_buffer___1 ;
  void *tmp___13 ;
  ptrdiff_t incr___1 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char *old_buffer___2 ;
  void *tmp___18 ;
  ptrdiff_t incr___2 ;
  int tmp___19 ;
  unsigned char *old_buffer___3 ;
  void *tmp___20 ;
  ptrdiff_t incr___3 ;
  unsigned char *old_buffer___4 ;
  void *tmp___21 ;
  ptrdiff_t incr___4 ;
  unsigned char *tmp___22 ;
  boolean had_char_class ;
  unsigned int range_start ;
  unsigned char *old_buffer___5 ;
  void *tmp___23 ;
  ptrdiff_t incr___5 ;
  unsigned char *old_buffer___6 ;
  void *tmp___24 ;
  ptrdiff_t incr___6 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned char *old_buffer___7 ;
  void *tmp___27 ;
  ptrdiff_t incr___7 ;
  unsigned char *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___31 ;
  reg_errcode_t ret___0 ;
  char const   *tmp___32 ;
  char str[7] ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  unsigned char tmp___35 ;
  int ch ;
  boolean is_alnum ;
  int tmp___36 ;
  boolean is_alpha ;
  int tmp___37 ;
  boolean is_blank ;
  int tmp___38 ;
  boolean is_cntrl ;
  int tmp___39 ;
  boolean is_digit ;
  int tmp___40 ;
  boolean is_graph ;
  int tmp___41 ;
  boolean is_lower ;
  int tmp___42 ;
  boolean is_print ;
  int tmp___43 ;
  boolean is_punct ;
  int tmp___44 ;
  boolean is_space ;
  int tmp___45 ;
  boolean is_upper ;
  int tmp___46 ;
  boolean is_xdigit ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  unsigned short const   **tmp___63 ;
  unsigned short const   **tmp___64 ;
  unsigned short const   **tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned short const   **tmp___70 ;
  unsigned short const   **tmp___71 ;
  unsigned short const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  unsigned short const   **tmp___74 ;
  unsigned char tmp___75 ;
  unsigned char str___0[17] ;
  char const   *tmp___76 ;
  char const   *tmp___77 ;
  unsigned char tmp___78 ;
  char const   *tmp___79 ;
  unsigned char tmp___80 ;
  unsigned char str___1[128] ;
  char const   *tmp___81 ;
  char const   *tmp___82 ;
  unsigned char tmp___83 ;
  char const   *tmp___84 ;
  unsigned char tmp___85 ;
  char const   *tmp___86 ;
  void *tmp___87 ;
  unsigned char *old_buffer___8 ;
  void *tmp___88 ;
  ptrdiff_t incr___8 ;
  unsigned char *tmp___89 ;
  unsigned char *tmp___90 ;
  unsigned char *tmp___91 ;
  unsigned char *old_buffer___9 ;
  void *tmp___92 ;
  ptrdiff_t incr___9 ;
  unsigned char *tmp___93 ;
  regnum_t this_group_regnum ;
  unsigned char *inner_group_loc ;
  unsigned char *old_buffer___10 ;
  void *tmp___94 ;
  ptrdiff_t incr___10 ;
  unsigned char *tmp___95 ;
  unsigned char *tmp___96 ;
  unsigned char *tmp___97 ;
  unsigned char *old_buffer___11 ;
  void *tmp___98 ;
  ptrdiff_t incr___11 ;
  unsigned char *old_buffer___12 ;
  void *tmp___99 ;
  ptrdiff_t incr___12 ;
  int lower_bound ;
  int upper_bound ;
  char const   *beg_interval ;
  char const   *tmp___100 ;
  char const   *tmp___101 ;
  char const   *tmp___102 ;
  unsigned char *old_buffer___13 ;
  void *tmp___103 ;
  ptrdiff_t incr___13 ;
  unsigned int nbytes ;
  unsigned char *old_buffer___14 ;
  void *tmp___104 ;
  ptrdiff_t incr___14 ;
  int tmp___105 ;
  unsigned char *old_buffer___15 ;
  void *tmp___106 ;
  ptrdiff_t incr___15 ;
  unsigned char *tmp___107 ;
  unsigned char *old_buffer___16 ;
  void *tmp___108 ;
  ptrdiff_t incr___16 ;
  unsigned char *tmp___109 ;
  unsigned char *old_buffer___17 ;
  void *tmp___110 ;
  ptrdiff_t incr___17 ;
  unsigned char *tmp___111 ;
  unsigned char *old_buffer___18 ;
  void *tmp___112 ;
  ptrdiff_t incr___18 ;
  unsigned char *tmp___113 ;
  unsigned char *old_buffer___19 ;
  void *tmp___114 ;
  ptrdiff_t incr___19 ;
  unsigned char *tmp___115 ;
  unsigned char *old_buffer___20 ;
  void *tmp___116 ;
  ptrdiff_t incr___20 ;
  unsigned char *tmp___117 ;
  unsigned char *old_buffer___21 ;
  void *tmp___118 ;
  ptrdiff_t incr___21 ;
  unsigned char *tmp___119 ;
  unsigned char *old_buffer___22 ;
  void *tmp___120 ;
  ptrdiff_t incr___22 ;
  unsigned char *tmp___121 ;
  boolean tmp___122 ;
  unsigned char *old_buffer___23 ;
  void *tmp___123 ;
  ptrdiff_t incr___23 ;
  unsigned char *tmp___124 ;
  unsigned char *tmp___125 ;
  unsigned char *old_buffer___24 ;
  void *tmp___126 ;
  ptrdiff_t incr___24 ;
  unsigned char *tmp___127 ;
  unsigned char *tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  unsigned char *old_buffer___25 ;
  void *tmp___134 ;
  ptrdiff_t incr___25 ;
  unsigned char *tmp___135 ;
  unsigned char *old_buffer___26 ;
  void *tmp___136 ;
  ptrdiff_t incr___26 ;
  unsigned char *tmp___137 ;

  {
  {
#line 2319
  p = pattern;
#line 2320
  pend = pattern + size;
#line 2324
  translate = bufp->translate;
#line 2330
  pending_exact = (unsigned char *)0;
#line 2335
  laststart = (unsigned char *)0;
#line 2343
  fixup_alt_jump = (unsigned char *)0;
#line 2348
  regnum = (regnum_t )0;
#line 2387
  tmp___0 = malloc(32UL * sizeof(compile_stack_elt_t ));
#line 2387
  compile_stack.stack = (compile_stack_elt_t *)tmp___0;
  }
#line 2388
  if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 2395
    return ((reg_errcode_t )12);
  }
  {
#line 2398
  compile_stack.size = 32U;
#line 2399
  compile_stack.avail = 0U;
#line 2402
  bufp->syntax = syntax;
#line 2403
  bufp->fastmap_accurate = 0U;
#line 2404
  tmp___1 = 0U;
#line 2404
  bufp->not_eol = tmp___1;
#line 2404
  bufp->not_bol = tmp___1;
#line 2409
  bufp->used = 0UL;
#line 2412
  bufp->re_nsub = (size_t )0;
#line 2416
  init_syntax_once();
  }
#line 2419
  if (bufp->allocated == 0UL) {
#line 2421
    if (bufp->buffer) {
      {
#line 2432
      tmp___2 = realloc((void *)bufp->buffer, (32UL * sizeof(unsigned char )) * sizeof(unsigned char ));
#line 2432
      bufp->buffer = (unsigned char *)tmp___2;
      }
    } else {
      {
#line 2437
      tmp___3 = malloc(((32UL * sizeof(unsigned char )) / sizeof(unsigned char )) * sizeof(unsigned char ));
#line 2437
      bufp->buffer = (unsigned char *)tmp___3;
      }
    }
#line 2441
    if (! bufp->buffer) {
      {
#line 2441
      free((void *)compile_stack.stack);
      }
#line 2441
      return ((reg_errcode_t )12);
    }
#line 2445
    bufp->allocated = 32UL * sizeof(unsigned char );
  }
#line 2452
  b = bufp->buffer;
#line 2452
  begalt = b;
  {
#line 2455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2455
    if (! ((unsigned long )p != (unsigned long )pend)) {
#line 2455
      goto while_break;
    }
    {
#line 2457
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2457
      if ((unsigned long )p == (unsigned long )pend) {
#line 2457
        return ((reg_errcode_t )14);
      }
#line 2457
      tmp___4 = p;
#line 2457
      p ++;
#line 2457
      c = (unsigned char )*tmp___4;
#line 2457
      if (translate) {
#line 2457
        c = (unsigned char )*(translate + c);
      }
#line 2457
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2461
    if ((int )c == 94) {
#line 2461
      goto case_94;
    }
#line 2476
    if ((int )c == 36) {
#line 2476
      goto case_36;
    }
#line 2492
    if ((int )c == 63) {
#line 2492
      goto case_63;
    }
#line 2492
    if ((int )c == 43) {
#line 2492
      goto case_63;
    }
#line 2497
    if ((int )c == 42) {
#line 2497
      goto handle_plus;
    }
#line 2628
    if ((int )c == 46) {
#line 2628
      goto case_46;
    }
#line 2634
    if ((int )c == 91) {
#line 2634
      goto case_91;
    }
#line 3609
    if ((int )c == 40) {
#line 3609
      goto case_40;
    }
#line 3616
    if ((int )c == 41) {
#line 3616
      goto case_41;
    }
#line 3623
    if ((int )c == 10) {
#line 3623
      goto case_10;
    }
#line 3630
    if ((int )c == 124) {
#line 3630
      goto case_124;
    }
#line 3637
    if ((int )c == 123) {
#line 3637
      goto case_123;
    }
#line 3644
    if ((int )c == 92) {
#line 3644
      goto case_92;
    }
#line 4095
    goto normal_char;
    case_94: /* CIL Label */ 
#line 2463
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
#line 2463
      goto _L;
    } else
#line 2463
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 2463
      goto _L;
    } else {
      {
#line 2463
      tmp___7 = byte_at_begline_loc_p(pattern, p, syntax);
      }
#line 2463
      if (tmp___7) {
        _L: /* CIL Label */ 
        {
#line 2469
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 2469
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2469
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2469
              goto while_break___2;
            }
            {
#line 2469
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2469
              old_buffer = bufp->buffer;
#line 2469
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2469
                return ((reg_errcode_t )15);
              }
#line 2469
              bufp->allocated <<= 1;
#line 2469
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2469
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 2469
              tmp___5 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2469
              bufp->buffer = (unsigned char *)tmp___5;
              }
#line 2469
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2469
                return ((reg_errcode_t )12);
              }
#line 2469
              if ((unsigned long )old_buffer != (unsigned long )bufp->buffer) {
#line 2469
                incr = bufp->buffer - old_buffer;
#line 2469
                b += incr;
#line 2469
                begalt += incr;
#line 2469
                if (fixup_alt_jump) {
#line 2469
                  fixup_alt_jump += incr;
                }
#line 2469
                if (laststart) {
#line 2469
                  laststart += incr;
                }
#line 2469
                if (pending_exact) {
#line 2469
                  pending_exact += incr;
                }
              }
#line 2469
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2469
          tmp___6 = b;
#line 2469
          b ++;
#line 2469
          *tmp___6 = (unsigned char)9;
#line 2469
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 2471
        goto normal_char;
      }
    }
#line 2473
    goto switch_break;
    case_36: /* CIL Label */ 
#line 2478
    if ((unsigned long )p == (unsigned long )pend) {
#line 2478
      goto _L___0;
    } else
#line 2478
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 2478
      goto _L___0;
    } else {
      {
#line 2478
      tmp___10 = byte_at_endline_loc_p(p, pend, syntax);
      }
#line 2478
      if (tmp___10) {
        _L___0: /* CIL Label */ 
        {
#line 2484
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 2484
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2484
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2484
              goto while_break___5;
            }
            {
#line 2484
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2484
              old_buffer___0 = bufp->buffer;
#line 2484
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2484
                return ((reg_errcode_t )15);
              }
#line 2484
              bufp->allocated <<= 1;
#line 2484
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2484
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 2484
              tmp___8 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2484
              bufp->buffer = (unsigned char *)tmp___8;
              }
#line 2484
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2484
                return ((reg_errcode_t )12);
              }
#line 2484
              if ((unsigned long )old_buffer___0 != (unsigned long )bufp->buffer) {
#line 2484
                incr___0 = bufp->buffer - old_buffer___0;
#line 2484
                b += incr___0;
#line 2484
                begalt += incr___0;
#line 2484
                if (fixup_alt_jump) {
#line 2484
                  fixup_alt_jump += incr___0;
                }
#line 2484
                if (laststart) {
#line 2484
                  laststart += incr___0;
                }
#line 2484
                if (pending_exact) {
#line 2484
                  pending_exact += incr___0;
                }
              }
#line 2484
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2484
          tmp___9 = b;
#line 2484
          b ++;
#line 2484
          *tmp___9 = (unsigned char)10;
#line 2484
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 2486
        goto normal_char;
      }
    }
#line 2488
    goto switch_break;
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 2493
    if (syntax & (1UL << 1)) {
#line 2495
      goto normal_char;
    } else
#line 2493
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2495
      goto normal_char;
    }
    handle_plus: 
    case_42: /* CIL Label */ 
#line 2499
    if (! laststart) {
#line 2501
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
#line 2502
        free((void *)compile_stack.stack);
        }
#line 2502
        return ((reg_errcode_t )13);
      } else
#line 2503
      if (! (syntax & ((((1UL << 1) << 1) << 1) << 1))) {
#line 2504
        goto normal_char;
      }
    }
#line 2509
    keep_string_p = (boolean )0;
#line 2512
    zero_times_ok = (char)0;
#line 2512
    many_times_ok = (char)0;
    {
#line 2519
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2521
      zero_times_ok = (char )((int )zero_times_ok | ((int )c != 43));
#line 2522
      many_times_ok = (char )((int )many_times_ok | ((int )c != 63));
#line 2524
      if ((unsigned long )p == (unsigned long )pend) {
#line 2525
        goto while_break___7;
      }
      {
#line 2527
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2527
        if ((unsigned long )p == (unsigned long )pend) {
#line 2527
          return ((reg_errcode_t )14);
        }
#line 2527
        tmp___11 = p;
#line 2527
        p ++;
#line 2527
        c = (unsigned char )*tmp___11;
#line 2527
        if (translate) {
#line 2527
          c = (unsigned char )*(translate + c);
        }
#line 2527
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2529
      if (! ((int )c == 42)) {
#line 2529
        if (! (syntax & (1UL << 1))) {
#line 2529
          if (! ((int )c == 43)) {
#line 2529
            if (! ((int )c == 63)) {
#line 2529
              goto _L___1;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 2533
        if (syntax & (1UL << 1)) {
#line 2533
          if ((int )c == 92) {
#line 2535
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 2535
              free((void *)compile_stack.stack);
              }
#line 2535
              return ((reg_errcode_t )5);
            }
            {
#line 2537
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2537
              if ((unsigned long )p == (unsigned long )pend) {
#line 2537
                return ((reg_errcode_t )14);
              }
#line 2537
              tmp___12 = p;
#line 2537
              p ++;
#line 2537
              c1 = (unsigned char )*tmp___12;
#line 2537
              if (translate) {
#line 2537
                c1 = (unsigned char )*(translate + c1);
              }
#line 2537
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 2538
            if (! ((int )c1 == 43)) {
#line 2538
              if (! ((int )c1 == 63)) {
#line 2540
                p --;
#line 2541
                p --;
#line 2542
                goto while_break___7;
              }
            }
#line 2545
            c = c1;
          } else {
#line 2549
            p --;
#line 2550
            goto while_break___7;
          }
        } else {
#line 2549
          p --;
#line 2550
          goto while_break___7;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2558
    if (! laststart) {
#line 2559
      goto switch_break;
    }
#line 2563
    if (many_times_ok) {
      {
#line 2577
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2577
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2577
          goto while_break___10;
        }
        {
#line 2577
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2577
          old_buffer___1 = bufp->buffer;
#line 2577
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2577
            return ((reg_errcode_t )15);
          }
#line 2577
          bufp->allocated <<= 1;
#line 2577
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2577
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2577
          tmp___13 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2577
          bufp->buffer = (unsigned char *)tmp___13;
          }
#line 2577
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2577
            return ((reg_errcode_t )12);
          }
#line 2577
          if ((unsigned long )old_buffer___1 != (unsigned long )bufp->buffer) {
#line 2577
            incr___1 = bufp->buffer - old_buffer___1;
#line 2577
            b += incr___1;
#line 2577
            begalt += incr___1;
#line 2577
            if (fixup_alt_jump) {
#line 2577
              fixup_alt_jump += incr___1;
            }
#line 2577
            if (laststart) {
#line 2577
              laststart += incr___1;
            }
#line 2577
            if (pending_exact) {
#line 2577
              pending_exact += incr___1;
            }
          }
#line 2577
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2584
      if (translate) {
#line 2584
        tmp___14 = (int )*(translate + (unsigned char )*(p - 2));
      } else {
#line 2584
        tmp___14 = (int )((char )*(p - 2));
      }
#line 2584
      if (translate) {
#line 2584
        tmp___15 = (int )*(translate + (unsigned char )'.');
      } else {
#line 2584
        tmp___15 = (int )((char )'.');
      }
#line 2584
      if (tmp___14 == tmp___15) {
#line 2584
        if (zero_times_ok) {
#line 2584
          if ((unsigned long )p < (unsigned long )pend) {
#line 2584
            if (translate) {
#line 2584
              tmp___16 = (int )*(translate + (unsigned char )*p);
            } else {
#line 2584
              tmp___16 = (int )((char )*p);
            }
#line 2584
            if (translate) {
#line 2584
              tmp___17 = (int )*(translate + (unsigned char )'\n');
            } else {
#line 2584
              tmp___17 = (int )((char )'\n');
            }
#line 2584
            if (tmp___16 == tmp___17) {
#line 2584
              if (! (syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
                {
#line 2589
                byte_store_op1((re_opcode_t )13, b, (int )((laststart - b) - 3L));
#line 2590
                keep_string_p = (boolean )1;
                }
              } else {
                {
#line 2594
                byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
                }
              }
            } else {
              {
#line 2594
              byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
              }
            }
          } else {
            {
#line 2594
            byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
            }
          }
        } else {
          {
#line 2594
          byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
          }
        }
      } else {
        {
#line 2594
        byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
        }
      }
#line 2598
      b += 3;
    }
    {
#line 2605
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2605
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2605
        goto while_break___12;
      }
      {
#line 2605
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2605
        old_buffer___2 = bufp->buffer;
#line 2605
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2605
          return ((reg_errcode_t )15);
        }
#line 2605
        bufp->allocated <<= 1;
#line 2605
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2605
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2605
        tmp___18 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2605
        bufp->buffer = (unsigned char *)tmp___18;
        }
#line 2605
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2605
          return ((reg_errcode_t )12);
        }
#line 2605
        if ((unsigned long )old_buffer___2 != (unsigned long )bufp->buffer) {
#line 2605
          incr___2 = bufp->buffer - old_buffer___2;
#line 2605
          b += incr___2;
#line 2605
          begalt += incr___2;
#line 2605
          if (fixup_alt_jump) {
#line 2605
            fixup_alt_jump += incr___2;
          }
#line 2605
          if (laststart) {
#line 2605
            laststart += incr___2;
          }
#line 2605
          if (pending_exact) {
#line 2605
            pending_exact += incr___2;
          }
        }
#line 2605
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2606
    if (keep_string_p) {
#line 2606
      tmp___19 = 16;
    } else {
#line 2606
      tmp___19 = 15;
    }
    {
#line 2606
    byte_insert_op1((re_opcode_t )tmp___19, laststart, (int )((((b + 1) + 2) - laststart) - 3L),
                    b);
#line 2609
    pending_exact = (unsigned char *)0;
#line 2610
    b += 3;
    }
#line 2612
    if (! zero_times_ok) {
      {
#line 2619
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2619
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2619
          goto while_break___14;
        }
        {
#line 2619
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2619
          old_buffer___3 = bufp->buffer;
#line 2619
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2619
            return ((reg_errcode_t )15);
          }
#line 2619
          bufp->allocated <<= 1;
#line 2619
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2619
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2619
          tmp___20 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2619
          bufp->buffer = (unsigned char *)tmp___20;
          }
#line 2619
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2619
            return ((reg_errcode_t )12);
          }
#line 2619
          if ((unsigned long )old_buffer___3 != (unsigned long )bufp->buffer) {
#line 2619
            incr___3 = bufp->buffer - old_buffer___3;
#line 2619
            b += incr___3;
#line 2619
            begalt += incr___3;
#line 2619
            if (fixup_alt_jump) {
#line 2619
              fixup_alt_jump += incr___3;
            }
#line 2619
            if (laststart) {
#line 2619
              laststart += incr___3;
            }
#line 2619
            if (pending_exact) {
#line 2619
              pending_exact += incr___3;
            }
          }
#line 2619
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 2620
      byte_insert_op1((re_opcode_t )19, laststart, (int )((((laststart + 2) + 4) - laststart) - 3L),
                      b);
#line 2622
      b += 3;
      }
    }
#line 2625
    goto switch_break;
    case_46: /* CIL Label */ 
#line 2629
    laststart = b;
    {
#line 2630
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 2630
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2630
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2630
          goto while_break___17;
        }
        {
#line 2630
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 2630
          old_buffer___4 = bufp->buffer;
#line 2630
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2630
            return ((reg_errcode_t )15);
          }
#line 2630
          bufp->allocated <<= 1;
#line 2630
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2630
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2630
          tmp___21 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2630
          bufp->buffer = (unsigned char *)tmp___21;
          }
#line 2630
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2630
            return ((reg_errcode_t )12);
          }
#line 2630
          if ((unsigned long )old_buffer___4 != (unsigned long )bufp->buffer) {
#line 2630
            incr___4 = bufp->buffer - old_buffer___4;
#line 2630
            b += incr___4;
#line 2630
            begalt += incr___4;
#line 2630
            if (fixup_alt_jump) {
#line 2630
              fixup_alt_jump += incr___4;
            }
#line 2630
            if (laststart) {
#line 2630
              laststart += incr___4;
            }
#line 2630
            if (pending_exact) {
#line 2630
              pending_exact += incr___4;
            }
          }
#line 2630
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2630
      tmp___22 = b;
#line 2630
      b ++;
#line 2630
      *tmp___22 = (unsigned char)3;
#line 2630
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2631
    goto switch_break;
    case_91: /* CIL Label */ 
#line 2636
    had_char_class = (boolean )0;
#line 2640
    range_start = 4294967295U;
#line 2642
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 2642
      free((void *)compile_stack.stack);
      }
#line 2642
      return ((reg_errcode_t )7);
    }
    {
#line 3109
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3109
      if (! ((unsigned long )((b - bufp->buffer) + 34L) > bufp->allocated)) {
#line 3109
        goto while_break___19;
      }
      {
#line 3109
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 3109
        old_buffer___5 = bufp->buffer;
#line 3109
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3109
          return ((reg_errcode_t )15);
        }
#line 3109
        bufp->allocated <<= 1;
#line 3109
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3109
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3109
        tmp___23 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3109
        bufp->buffer = (unsigned char *)tmp___23;
        }
#line 3109
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3109
          return ((reg_errcode_t )12);
        }
#line 3109
        if ((unsigned long )old_buffer___5 != (unsigned long )bufp->buffer) {
#line 3109
          incr___5 = bufp->buffer - old_buffer___5;
#line 3109
          b += incr___5;
#line 3109
          begalt += incr___5;
#line 3109
          if (fixup_alt_jump) {
#line 3109
            fixup_alt_jump += incr___5;
          }
#line 3109
          if (laststart) {
#line 3109
            laststart += incr___5;
          }
#line 3109
          if (pending_exact) {
#line 3109
            pending_exact += incr___5;
          }
        }
#line 3109
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 3111
    laststart = b;
    {
#line 3115
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 3115
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 3115
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3115
          goto while_break___22;
        }
        {
#line 3115
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 3115
          old_buffer___6 = bufp->buffer;
#line 3115
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3115
            return ((reg_errcode_t )15);
          }
#line 3115
          bufp->allocated <<= 1;
#line 3115
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3115
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3115
          tmp___24 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3115
          bufp->buffer = (unsigned char *)tmp___24;
          }
#line 3115
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3115
            return ((reg_errcode_t )12);
          }
#line 3115
          if ((unsigned long )old_buffer___6 != (unsigned long )bufp->buffer) {
#line 3115
            incr___6 = bufp->buffer - old_buffer___6;
#line 3115
            b += incr___6;
#line 3115
            begalt += incr___6;
#line 3115
            if (fixup_alt_jump) {
#line 3115
              fixup_alt_jump += incr___6;
            }
#line 3115
            if (laststart) {
#line 3115
              laststart += incr___6;
            }
#line 3115
            if (pending_exact) {
#line 3115
              pending_exact += incr___6;
            }
          }
#line 3115
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
#line 3115
      tmp___25 = b;
#line 3115
      b ++;
#line 3115
      if ((int const   )*p == 94) {
#line 3115
        tmp___26 = 5;
      } else {
#line 3115
        tmp___26 = 4;
      }
#line 3115
      *tmp___25 = (unsigned char )tmp___26;
#line 3115
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 3116
    if ((int const   )*p == 94) {
#line 3117
      p ++;
    }
#line 3120
    p1 = p;
    {
#line 3123
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 3123
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 3123
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3123
          goto while_break___25;
        }
        {
#line 3123
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 3123
          old_buffer___7 = bufp->buffer;
#line 3123
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3123
            return ((reg_errcode_t )15);
          }
#line 3123
          bufp->allocated <<= 1;
#line 3123
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3123
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3123
          tmp___27 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3123
          bufp->buffer = (unsigned char *)tmp___27;
          }
#line 3123
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3123
            return ((reg_errcode_t )12);
          }
#line 3123
          if ((unsigned long )old_buffer___7 != (unsigned long )bufp->buffer) {
#line 3123
            incr___7 = bufp->buffer - old_buffer___7;
#line 3123
            b += incr___7;
#line 3123
            begalt += incr___7;
#line 3123
            if (fixup_alt_jump) {
#line 3123
              fixup_alt_jump += incr___7;
            }
#line 3123
            if (laststart) {
#line 3123
              laststart += incr___7;
            }
#line 3123
            if (pending_exact) {
#line 3123
              pending_exact += incr___7;
            }
          }
#line 3123
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 3123
      tmp___28 = b;
#line 3123
      b ++;
#line 3123
      *tmp___28 = (unsigned char )((1 << 8) / 8);
#line 3123
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 3126
    memset((void *)b, '\000', (size_t )((1 << 8) / 8));
    }
#line 3129
    if ((unsigned int )((re_opcode_t )*(b + -2)) == 5U) {
#line 3129
      if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3131
        *(b + 1) = (unsigned char )((int )*(b + 1) | (1 << 2));
      }
    }
    {
#line 3134
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 3136
      if ((unsigned long )p == (unsigned long )pend) {
        {
#line 3136
        free((void *)compile_stack.stack);
        }
#line 3136
        return ((reg_errcode_t )7);
      }
      {
#line 3138
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 3138
        if ((unsigned long )p == (unsigned long )pend) {
#line 3138
          return ((reg_errcode_t )14);
        }
#line 3138
        tmp___29 = p;
#line 3138
        p ++;
#line 3138
        c = (unsigned char )*tmp___29;
#line 3138
        if (translate) {
#line 3138
          c = (unsigned char )*(translate + c);
        }
#line 3138
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 3141
      if (syntax & 1UL) {
#line 3141
        if ((int )c == 92) {
#line 3143
          if ((unsigned long )p == (unsigned long )pend) {
            {
#line 3143
            free((void *)compile_stack.stack);
            }
#line 3143
            return ((reg_errcode_t )5);
          }
          {
#line 3145
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 3145
            if ((unsigned long )p == (unsigned long )pend) {
#line 3145
              return ((reg_errcode_t )14);
            }
#line 3145
            tmp___30 = p;
#line 3145
            p ++;
#line 3145
            c1 = (unsigned char )*tmp___30;
#line 3145
            if (translate) {
#line 3145
              c1 = (unsigned char )*(translate + c1);
            }
#line 3145
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
#line 3146
          *(b + (int )c1 / 8) = (unsigned char )((int )*(b + (int )c1 / 8) | (1 << (int )c1 % 8));
#line 3147
          range_start = (unsigned int )c1;
#line 3148
          goto __Cont;
        }
      }
#line 3154
      if ((int )c == 93) {
#line 3154
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
#line 3155
          goto while_break___27;
        }
      }
#line 3159
      if (had_char_class) {
#line 3159
        if ((int )c == 45) {
#line 3159
          if ((int const   )*p != 93) {
            {
#line 3160
            free((void *)compile_stack.stack);
            }
#line 3160
            return ((reg_errcode_t )11);
          }
        }
      }
#line 3166
      if ((int )c == 45) {
#line 3166
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
#line 3166
          if ((int const   )*(p + -2) == 91) {
#line 3166
            goto _L___29;
          } else {
#line 3166
            goto _L___30;
          }
        } else
        _L___30: /* CIL Label */ 
#line 3166
        if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
#line 3166
          if ((int const   )*(p + -3) == 91) {
#line 3166
            if ((int const   )*(p + -2) == 94) {
#line 3166
              goto _L___29;
            } else {
#line 3166
              goto _L___28;
            }
          } else {
#line 3166
            goto _L___28;
          }
        } else
        _L___28: /* CIL Label */ 
#line 3166
        if ((int const   )*p != 93) {
          {
#line 3171
          tmp___31 = byte_compile_range(range_start, & p, pend, translate, syntax,
                                        b);
#line 3171
          ret = tmp___31;
          }
#line 3174
          if ((int )ret != 0) {
            {
#line 3174
            free((void *)compile_stack.stack);
            }
#line 3174
            return (ret);
          }
#line 3175
          range_start = 4294967295U;
        } else {
#line 3166
          goto _L___29;
        }
      } else
      _L___29: /* CIL Label */ 
#line 3178
      if ((int const   )*(p + 0) == 45) {
#line 3178
        if ((int const   )*(p + 1) != 93) {
          {
#line 3183
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 3183
            if ((unsigned long )p == (unsigned long )pend) {
#line 3183
              return ((reg_errcode_t )14);
            }
#line 3183
            tmp___32 = p;
#line 3183
            p ++;
#line 3183
            c1 = (unsigned char )*tmp___32;
#line 3183
            if (translate) {
#line 3183
              c1 = (unsigned char )*(translate + c1);
            }
#line 3183
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 3185
          ret___0 = byte_compile_range((unsigned int )c, & p, pend, translate, syntax,
                                       b);
          }
#line 3186
          if ((int )ret___0 != 0) {
            {
#line 3186
            free((void *)compile_stack.stack);
            }
#line 3186
            return (ret___0);
          }
#line 3187
          range_start = 4294967295U;
        } else {
#line 3178
          goto _L___24;
        }
      } else
      _L___24: /* CIL Label */ 
#line 3193
      if (syntax & ((1UL << 1) << 1)) {
#line 3193
        if ((int )c == 91) {
#line 3193
          if ((int const   )*p == 58) {
            {
#line 3197
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 3197
              if ((unsigned long )p == (unsigned long )pend) {
#line 3197
                return ((reg_errcode_t )14);
              }
#line 3197
              tmp___33 = p;
#line 3197
              p ++;
#line 3197
              c = (unsigned char )*tmp___33;
#line 3197
              if (translate) {
#line 3197
                c = (unsigned char )*(translate + c);
              }
#line 3197
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
#line 3198
            c1 = (unsigned char)0;
#line 3201
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3201
              free((void *)compile_stack.stack);
              }
#line 3201
              return ((reg_errcode_t )7);
            }
            {
#line 3203
            while (1) {
              while_continue___32: /* CIL Label */ ;
              {
#line 3205
              while (1) {
                while_continue___33: /* CIL Label */ ;
#line 3205
                if ((unsigned long )p == (unsigned long )pend) {
#line 3205
                  return ((reg_errcode_t )14);
                }
#line 3205
                tmp___34 = p;
#line 3205
                p ++;
#line 3205
                c = (unsigned char )*tmp___34;
#line 3205
                if (translate) {
#line 3205
                  c = (unsigned char )*(translate + c);
                }
#line 3205
                goto while_break___33;
              }
              while_break___33: /* CIL Label */ ;
              }
#line 3206
              if ((int )c == 58) {
#line 3206
                if ((int const   )*p == 93) {
#line 3207
                  goto while_break___32;
                } else {
#line 3206
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
#line 3206
              if ((unsigned long )p == (unsigned long )pend) {
#line 3207
                goto while_break___32;
              }
#line 3208
              if ((int )c1 < 6) {
#line 3209
                tmp___35 = c1;
#line 3209
                c1 = (unsigned char )((int )c1 + 1);
#line 3209
                str[tmp___35] = (char )c;
              } else {
#line 3212
                str[0] = (char )'\000';
              }
            }
            while_break___32: /* CIL Label */ ;
            }
#line 3214
            str[c1] = (char )'\000';
#line 3219
            if ((int )c == 58) {
#line 3219
              if ((int const   )*p == 93) {
                {
#line 3255
                tmp___36 = strcmp((char const   *)(str), "alnum");
#line 3255
                is_alnum = (boolean )(tmp___36 == 0);
#line 3256
                tmp___37 = strcmp((char const   *)(str), "alpha");
#line 3256
                is_alpha = (boolean )(tmp___37 == 0);
#line 3257
                tmp___38 = strcmp((char const   *)(str), "blank");
#line 3257
                is_blank = (boolean )(tmp___38 == 0);
#line 3258
                tmp___39 = strcmp((char const   *)(str), "cntrl");
#line 3258
                is_cntrl = (boolean )(tmp___39 == 0);
#line 3259
                tmp___40 = strcmp((char const   *)(str), "digit");
#line 3259
                is_digit = (boolean )(tmp___40 == 0);
#line 3260
                tmp___41 = strcmp((char const   *)(str), "graph");
#line 3260
                is_graph = (boolean )(tmp___41 == 0);
#line 3261
                tmp___42 = strcmp((char const   *)(str), "lower");
#line 3261
                is_lower = (boolean )(tmp___42 == 0);
#line 3262
                tmp___43 = strcmp((char const   *)(str), "print");
#line 3262
                is_print = (boolean )(tmp___43 == 0);
#line 3263
                tmp___44 = strcmp((char const   *)(str), "punct");
#line 3263
                is_punct = (boolean )(tmp___44 == 0);
#line 3264
                tmp___45 = strcmp((char const   *)(str), "space");
#line 3264
                is_space = (boolean )(tmp___45 == 0);
#line 3265
                tmp___46 = strcmp((char const   *)(str), "upper");
#line 3265
                is_upper = (boolean )(tmp___46 == 0);
#line 3266
                tmp___47 = strcmp((char const   *)(str), "xdigit");
#line 3266
                is_xdigit = (boolean )(tmp___47 == 0);
#line 3268
                tmp___48 = strcmp((char const   *)(str), "alpha");
                }
#line 3268
                if (! (tmp___48 == 0)) {
                  {
#line 3268
                  tmp___49 = strcmp((char const   *)(str), "upper");
                  }
#line 3268
                  if (! (tmp___49 == 0)) {
                    {
#line 3268
                    tmp___50 = strcmp((char const   *)(str), "lower");
                    }
#line 3268
                    if (! (tmp___50 == 0)) {
                      {
#line 3268
                      tmp___51 = strcmp((char const   *)(str), "digit");
                      }
#line 3268
                      if (! (tmp___51 == 0)) {
                        {
#line 3268
                        tmp___52 = strcmp((char const   *)(str), "alnum");
                        }
#line 3268
                        if (! (tmp___52 == 0)) {
                          {
#line 3268
                          tmp___53 = strcmp((char const   *)(str), "xdigit");
                          }
#line 3268
                          if (! (tmp___53 == 0)) {
                            {
#line 3268
                            tmp___54 = strcmp((char const   *)(str), "space");
                            }
#line 3268
                            if (! (tmp___54 == 0)) {
                              {
#line 3268
                              tmp___55 = strcmp((char const   *)(str), "print");
                              }
#line 3268
                              if (! (tmp___55 == 0)) {
                                {
#line 3268
                                tmp___56 = strcmp((char const   *)(str), "punct");
                                }
#line 3268
                                if (! (tmp___56 == 0)) {
                                  {
#line 3268
                                  tmp___57 = strcmp((char const   *)(str), "graph");
                                  }
#line 3268
                                  if (! (tmp___57 == 0)) {
                                    {
#line 3268
                                    tmp___58 = strcmp((char const   *)(str), "cntrl");
                                    }
#line 3268
                                    if (! (tmp___58 == 0)) {
                                      {
#line 3268
                                      tmp___59 = strcmp((char const   *)(str), "blank");
                                      }
#line 3268
                                      if (! (tmp___59 == 0)) {
                                        {
#line 3269
                                        free((void *)compile_stack.stack);
                                        }
#line 3269
                                        return ((reg_errcode_t )4);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                {
#line 3273
                while (1) {
                  while_continue___34: /* CIL Label */ ;
#line 3273
                  if ((unsigned long )p == (unsigned long )pend) {
#line 3273
                    return ((reg_errcode_t )14);
                  }
#line 3273
                  tmp___60 = p;
#line 3273
                  p ++;
#line 3273
                  c = (unsigned char )*tmp___60;
#line 3273
                  if (translate) {
#line 3273
                    c = (unsigned char )*(translate + c);
                  }
#line 3273
                  goto while_break___34;
                }
                while_break___34: /* CIL Label */ ;
                }
#line 3275
                if ((unsigned long )p == (unsigned long )pend) {
                  {
#line 3275
                  free((void *)compile_stack.stack);
                  }
#line 3275
                  return ((reg_errcode_t )7);
                }
#line 3277
                ch = 0;
                {
#line 3277
                while (1) {
                  while_continue___35: /* CIL Label */ ;
#line 3277
                  if (! (ch < 1 << 8)) {
#line 3277
                    goto while_break___35;
                  }
#line 3281
                  if (is_alnum) {
                    {
#line 3281
                    tmp___61 = __ctype_b_loc();
                    }
#line 3281
                    if ((int const   )*(*tmp___61 + ch) & 8) {
#line 3285
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3281
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
#line 3281
                  if (is_alpha) {
                    {
#line 3281
                    tmp___62 = __ctype_b_loc();
                    }
#line 3281
                    if ((int const   )*(*tmp___62 + ch) & 1024) {
#line 3285
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3281
                      goto _L___4;
                    }
                  } else
                  _L___4: /* CIL Label */ 
#line 3281
                  if (is_blank) {
                    {
#line 3281
                    tmp___63 = __ctype_b_loc();
                    }
#line 3281
                    if ((int const   )*(*tmp___63 + ch) & 1) {
#line 3285
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3281
                      goto _L___3;
                    }
                  } else
                  _L___3: /* CIL Label */ 
#line 3281
                  if (is_cntrl) {
                    {
#line 3281
                    tmp___64 = __ctype_b_loc();
                    }
#line 3281
                    if ((int const   )*(*tmp___64 + ch) & 2) {
#line 3285
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3286
                  if (is_digit) {
                    {
#line 3286
                    tmp___65 = __ctype_b_loc();
                    }
#line 3286
                    if ((int const   )*(*tmp___65 + ch) & 2048) {
#line 3290
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3286
                      goto _L___8;
                    }
                  } else
                  _L___8: /* CIL Label */ 
#line 3286
                  if (is_graph) {
                    {
#line 3286
                    tmp___66 = __ctype_b_loc();
                    }
#line 3286
                    if ((int const   )*(*tmp___66 + ch) & 32768) {
#line 3290
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3286
                      goto _L___7;
                    }
                  } else
                  _L___7: /* CIL Label */ 
#line 3286
                  if (is_lower) {
                    {
#line 3286
                    tmp___67 = __ctype_b_loc();
                    }
#line 3286
                    if ((int const   )*(*tmp___67 + ch) & 512) {
#line 3290
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3286
                      goto _L___6;
                    }
                  } else
                  _L___6: /* CIL Label */ 
#line 3286
                  if (is_print) {
                    {
#line 3286
                    tmp___68 = __ctype_b_loc();
                    }
#line 3286
                    if ((int const   )*(*tmp___68 + ch) & 16384) {
#line 3290
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3291
                  if (is_punct) {
                    {
#line 3291
                    tmp___69 = __ctype_b_loc();
                    }
#line 3291
                    if ((int const   )*(*tmp___69 + ch) & 4) {
#line 3295
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3291
                      goto _L___11;
                    }
                  } else
                  _L___11: /* CIL Label */ 
#line 3291
                  if (is_space) {
                    {
#line 3291
                    tmp___70 = __ctype_b_loc();
                    }
#line 3291
                    if ((int const   )*(*tmp___70 + ch) & 8192) {
#line 3295
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3291
                      goto _L___10;
                    }
                  } else
                  _L___10: /* CIL Label */ 
#line 3291
                  if (is_upper) {
                    {
#line 3291
                    tmp___71 = __ctype_b_loc();
                    }
#line 3291
                    if ((int const   )*(*tmp___71 + ch) & 256) {
#line 3295
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3291
                      goto _L___9;
                    }
                  } else
                  _L___9: /* CIL Label */ 
#line 3291
                  if (is_xdigit) {
                    {
#line 3291
                    tmp___72 = __ctype_b_loc();
                    }
#line 3291
                    if ((int const   )*(*tmp___72 + ch) & 4096) {
#line 3295
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3296
                  if (translate) {
#line 3296
                    if (is_upper) {
#line 3296
                      goto _L___12;
                    } else
#line 3296
                    if (is_lower) {
                      _L___12: /* CIL Label */ 
                      {
#line 3296
                      tmp___73 = __ctype_b_loc();
                      }
#line 3296
                      if ((int const   )*(*tmp___73 + ch) & 256) {
#line 3298
                        *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                      } else {
                        {
#line 3296
                        tmp___74 = __ctype_b_loc();
                        }
#line 3296
                        if ((int const   )*(*tmp___74 + ch) & 512) {
#line 3298
                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                        }
                      }
                    }
                  }
#line 3277
                  ch ++;
                }
                while_break___35: /* CIL Label */ ;
                }
#line 3300
                had_char_class = (boolean )1;
              } else {
#line 3219
                goto _L___13;
              }
            } else {
              _L___13: /* CIL Label */ 
#line 3305
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3306
              while (1) {
                while_continue___36: /* CIL Label */ ;
#line 3306
                tmp___75 = c1;
#line 3306
                c1 = (unsigned char )((int )c1 - 1);
#line 3306
                if (! tmp___75) {
#line 3306
                  goto while_break___36;
                }
#line 3307
                p --;
              }
              while_break___36: /* CIL Label */ ;
              }
#line 3308
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3309
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 2));
#line 3310
              range_start = (unsigned int )':';
#line 3311
              had_char_class = (boolean )0;
            }
          } else {
#line 3193
            goto _L___23;
          }
        } else {
#line 3193
          goto _L___23;
        }
      } else
      _L___23: /* CIL Label */ 
#line 3314
      if (syntax & ((1UL << 1) << 1)) {
#line 3314
        if ((int )c == 91) {
#line 3314
          if ((int const   )*p == 61) {
            {
#line 3322
            while (1) {
              while_continue___37: /* CIL Label */ ;
#line 3322
              if ((unsigned long )p == (unsigned long )pend) {
#line 3322
                return ((reg_errcode_t )14);
              }
#line 3322
              tmp___76 = p;
#line 3322
              p ++;
#line 3322
              c = (unsigned char )*tmp___76;
#line 3322
              if (translate) {
#line 3322
                c = (unsigned char )*(translate + c);
              }
#line 3322
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
#line 3323
            c1 = (unsigned char)0;
#line 3326
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3326
              free((void *)compile_stack.stack);
              }
#line 3326
              return ((reg_errcode_t )7);
            }
            {
#line 3328
            while (1) {
              while_continue___38: /* CIL Label */ ;
              {
#line 3330
              while (1) {
                while_continue___39: /* CIL Label */ ;
#line 3330
                if ((unsigned long )p == (unsigned long )pend) {
#line 3330
                  return ((reg_errcode_t )14);
                }
#line 3330
                tmp___77 = p;
#line 3330
                p ++;
#line 3330
                c = (unsigned char )*tmp___77;
#line 3330
                if (translate) {
#line 3330
                  c = (unsigned char )*(translate + c);
                }
#line 3330
                goto while_break___39;
              }
              while_break___39: /* CIL Label */ ;
              }
#line 3331
              if ((int )c == 61) {
#line 3331
                if ((int const   )*p == 93) {
#line 3332
                  goto while_break___38;
                } else {
#line 3331
                  goto _L___14;
                }
              } else
              _L___14: /* CIL Label */ 
#line 3331
              if ((unsigned long )p == (unsigned long )pend) {
#line 3332
                goto while_break___38;
              }
#line 3333
              if ((int )c1 < 16) {
#line 3334
                tmp___78 = c1;
#line 3334
                c1 = (unsigned char )((int )c1 + 1);
#line 3334
                str___0[tmp___78] = c;
              } else {
#line 3337
                str___0[0] = (unsigned char )'\000';
              }
            }
            while_break___38: /* CIL Label */ ;
            }
#line 3339
            str___0[c1] = (unsigned char )'\000';
#line 3341
            if ((int )c == 61) {
#line 3341
              if ((int const   )*p == 93) {
#line 3341
                if ((int )str___0[0] != 0) {
#line 3353
                  if ((int )c1 != 1) {
                    {
#line 3354
                    free((void *)compile_stack.stack);
                    }
#line 3354
                    return ((reg_errcode_t )3);
                  }
                  {
#line 3358
                  while (1) {
                    while_continue___40: /* CIL Label */ ;
#line 3358
                    if ((unsigned long )p == (unsigned long )pend) {
#line 3358
                      return ((reg_errcode_t )14);
                    }
#line 3358
                    tmp___79 = p;
#line 3358
                    p ++;
#line 3358
                    c = (unsigned char )*tmp___79;
#line 3358
                    if (translate) {
#line 3358
                      c = (unsigned char )*(translate + c);
                    }
#line 3358
                    goto while_break___40;
                  }
                  while_break___40: /* CIL Label */ ;
                  }
#line 3361
                  *(b + (int )str___0[0] / 8) = (unsigned char )((int )*(b + (int )str___0[0] / 8) | (1 << (int )str___0[0] % 8));
#line 3435
                  had_char_class = (boolean )1;
                } else {
#line 3341
                  goto _L___16;
                }
              } else {
#line 3341
                goto _L___16;
              }
            } else {
              _L___16: /* CIL Label */ 
#line 3439
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3440
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 3440
                tmp___80 = c1;
#line 3440
                c1 = (unsigned char )((int )c1 - 1);
#line 3440
                if (! tmp___80) {
#line 3440
                  goto while_break___41;
                }
#line 3441
                p --;
              }
              while_break___41: /* CIL Label */ ;
              }
#line 3442
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3443
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 5));
#line 3444
              range_start = (unsigned int )'=';
#line 3445
              had_char_class = (boolean )0;
            }
          } else {
#line 3314
            goto _L___21;
          }
        } else {
#line 3314
          goto _L___21;
        }
      } else
      _L___21: /* CIL Label */ 
#line 3448
      if (syntax & ((1UL << 1) << 1)) {
#line 3448
        if ((int )c == 91) {
#line 3448
          if ((int const   )*p == 46) {
            {
#line 3456
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 3456
              if ((unsigned long )p == (unsigned long )pend) {
#line 3456
                return ((reg_errcode_t )14);
              }
#line 3456
              tmp___81 = p;
#line 3456
              p ++;
#line 3456
              c = (unsigned char )*tmp___81;
#line 3456
              if (translate) {
#line 3456
                c = (unsigned char )*(translate + c);
              }
#line 3456
              goto while_break___42;
            }
            while_break___42: /* CIL Label */ ;
            }
#line 3457
            c1 = (unsigned char)0;
#line 3460
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3460
              free((void *)compile_stack.stack);
              }
#line 3460
              return ((reg_errcode_t )7);
            }
            {
#line 3462
            while (1) {
              while_continue___43: /* CIL Label */ ;
              {
#line 3464
              while (1) {
                while_continue___44: /* CIL Label */ ;
#line 3464
                if ((unsigned long )p == (unsigned long )pend) {
#line 3464
                  return ((reg_errcode_t )14);
                }
#line 3464
                tmp___82 = p;
#line 3464
                p ++;
#line 3464
                c = (unsigned char )*tmp___82;
#line 3464
                if (translate) {
#line 3464
                  c = (unsigned char )*(translate + c);
                }
#line 3464
                goto while_break___44;
              }
              while_break___44: /* CIL Label */ ;
              }
#line 3465
              if ((int )c == 46) {
#line 3465
                if ((int const   )*p == 93) {
#line 3466
                  goto while_break___43;
                } else {
#line 3465
                  goto _L___17;
                }
              } else
              _L___17: /* CIL Label */ 
#line 3465
              if ((unsigned long )p == (unsigned long )pend) {
#line 3466
                goto while_break___43;
              }
#line 3467
              if ((unsigned long )c1 < sizeof(str___1)) {
#line 3468
                tmp___83 = c1;
#line 3468
                c1 = (unsigned char )((int )c1 + 1);
#line 3468
                str___1[tmp___83] = c;
              } else {
#line 3471
                str___1[0] = (unsigned char )'\000';
              }
            }
            while_break___43: /* CIL Label */ ;
            }
#line 3473
            str___1[c1] = (unsigned char )'\000';
#line 3475
            if ((int )c == 46) {
#line 3475
              if ((int const   )*p == 93) {
#line 3475
                if ((int )str___1[0] != 0) {
#line 3488
                  if ((int )c1 != 1) {
                    {
#line 3489
                    free((void *)compile_stack.stack);
                    }
#line 3489
                    return ((reg_errcode_t )3);
                  }
                  {
#line 3493
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 3493
                    if ((unsigned long )p == (unsigned long )pend) {
#line 3493
                      return ((reg_errcode_t )14);
                    }
#line 3493
                    tmp___84 = p;
#line 3493
                    p ++;
#line 3493
                    c = (unsigned char )*tmp___84;
#line 3493
                    if (translate) {
#line 3493
                      c = (unsigned char )*(translate + c);
                    }
#line 3493
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
#line 3496
                  *(b + (int )str___1[0] / 8) = (unsigned char )((int )*(b + (int )str___1[0] / 8) | (1 << (int )str___1[0] % 8));
#line 3497
                  range_start = (unsigned int )*((unsigned char const   *)(str___1) + 0);
#line 3578
                  had_char_class = (boolean )0;
                } else {
#line 3475
                  goto _L___19;
                }
              } else {
#line 3475
                goto _L___19;
              }
            } else {
              _L___19: /* CIL Label */ 
#line 3582
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3583
              while (1) {
                while_continue___46: /* CIL Label */ ;
#line 3583
                tmp___85 = c1;
#line 3583
                c1 = (unsigned char )((int )c1 - 1);
#line 3583
                if (! tmp___85) {
#line 3583
                  goto while_break___46;
                }
#line 3584
                p --;
              }
              while_break___46: /* CIL Label */ ;
              }
#line 3585
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3586
              *(b + 5) = (unsigned char )((int )*(b + 5) | (1 << 6));
#line 3587
              range_start = (unsigned int )'.';
#line 3588
              had_char_class = (boolean )0;
            }
          } else {
#line 3593
            had_char_class = (boolean )0;
#line 3594
            *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3595
            range_start = (unsigned int )c;
          }
        } else {
#line 3593
          had_char_class = (boolean )0;
#line 3594
          *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3595
          range_start = (unsigned int )c;
        }
      } else {
#line 3593
        had_char_class = (boolean )0;
#line 3594
        *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3595
        range_start = (unsigned int )c;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 3601
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 3601
      if ((int )*(b + -1) > 0) {
#line 3601
        if (! ((int )*(b + ((int )*(b + -1) - 1)) == 0)) {
#line 3601
          goto while_break___47;
        }
      } else {
#line 3601
        goto while_break___47;
      }
#line 3602
      *(b + -1) = (unsigned char )((int )*(b + -1) - 1);
    }
    while_break___47: /* CIL Label */ ;
    }
#line 3603
    b += (int )*(b + -1);
#line 3606
    goto switch_break;
    case_40: /* CIL Label */ 
#line 3610
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3611
      goto handle_open;
    } else {
#line 3613
      goto normal_char;
    }
    case_41: /* CIL Label */ 
#line 3617
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3618
      goto handle_close;
    } else {
#line 3620
      goto normal_char;
    }
    case_10: /* CIL Label */ 
#line 3624
    if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3625
      goto handle_alt;
    } else {
#line 3627
      goto normal_char;
    }
    case_124: /* CIL Label */ 
#line 3631
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3632
      goto handle_alt;
    } else {
#line 3634
      goto normal_char;
    }
    case_123: /* CIL Label */ 
#line 3638
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3638
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3639
        goto handle_interval;
      } else {
#line 3641
        goto normal_char;
      }
    } else {
#line 3641
      goto normal_char;
    }
    case_92: /* CIL Label */ 
#line 3645
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 3645
      free((void *)compile_stack.stack);
      }
#line 3645
      return ((reg_errcode_t )5);
    }
    {
#line 3650
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 3650
      if ((unsigned long )p == (unsigned long )pend) {
#line 3650
        return ((reg_errcode_t )14);
      }
#line 3650
      tmp___86 = p;
#line 3650
      p ++;
#line 3650
      c = (unsigned char )*tmp___86;
#line 3650
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 3654
    if ((int )c == 40) {
#line 3654
      goto case_40___0;
    }
#line 3704
    if ((int )c == 41) {
#line 3704
      goto case_41___0;
    }
#line 3774
    if ((int )c == 124) {
#line 3774
      goto case_124___0;
    }
#line 3820
    if ((int )c == 123) {
#line 3820
      goto case_123___0;
    }
#line 4006
    if ((int )c == 119) {
#line 4006
      goto case_119;
    }
#line 4014
    if ((int )c == 87) {
#line 4014
      goto case_87;
    }
#line 4022
    if ((int )c == 60) {
#line 4022
      goto case_60;
    }
#line 4028
    if ((int )c == 62) {
#line 4028
      goto case_62;
    }
#line 4034
    if ((int )c == 98) {
#line 4034
      goto case_98;
    }
#line 4040
    if ((int )c == 66) {
#line 4040
      goto case_66;
    }
#line 4046
    if ((int )c == 96) {
#line 4046
      goto case_96;
    }
#line 4052
    if ((int )c == 39) {
#line 4052
      goto case_39;
    }
#line 4059
    if ((int )c == 57) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 56) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 55) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 54) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 53) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 52) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 51) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 50) {
#line 4059
      goto case_57;
    }
#line 4059
    if ((int )c == 49) {
#line 4059
      goto case_57;
    }
#line 4078
    if ((int )c == 63) {
#line 4078
      goto case_63___0;
    }
#line 4078
    if ((int )c == 43) {
#line 4078
      goto case_63___0;
    }
#line 4084
    goto normal_backslash;
    case_40___0: /* CIL Label */ 
#line 3655
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3656
      goto normal_backslash;
    }
    handle_open: 
#line 3659
    (bufp->re_nsub) ++;
#line 3660
    regnum ++;
#line 3662
    if (compile_stack.avail == compile_stack.size) {
      {
#line 3664
      tmp___87 = realloc((void *)compile_stack.stack, (unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t ));
#line 3664
      compile_stack.stack = (compile_stack_elt_t *)tmp___87;
      }
#line 3666
      if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 3666
        return ((reg_errcode_t )12);
      }
#line 3668
      compile_stack.size <<= 1;
    }
#line 3675
    (compile_stack.stack + compile_stack.avail)->begalt_offset = begalt - bufp->buffer;
#line 3676
    if (fixup_alt_jump) {
#line 3676
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (fixup_alt_jump - bufp->buffer) + 1L;
    } else {
#line 3676
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (pattern_offset_t )0;
    }
#line 3678
    (compile_stack.stack + compile_stack.avail)->laststart_offset = b - bufp->buffer;
#line 3679
    (compile_stack.stack + compile_stack.avail)->regnum = regnum;
#line 3685
    if (regnum <= 255U) {
#line 3687
      (compile_stack.stack + compile_stack.avail)->inner_group_offset = (b - bufp->buffer) + 2L;
      {
#line 3689
      while (1) {
        while_continue___49: /* CIL Label */ ;
        {
#line 3689
        while (1) {
          while_continue___50: /* CIL Label */ ;
#line 3689
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3689
            goto while_break___50;
          }
          {
#line 3689
          while (1) {
            while_continue___51: /* CIL Label */ ;
#line 3689
            old_buffer___8 = bufp->buffer;
#line 3689
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3689
              return ((reg_errcode_t )15);
            }
#line 3689
            bufp->allocated <<= 1;
#line 3689
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3689
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3689
            tmp___88 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3689
            bufp->buffer = (unsigned char *)tmp___88;
            }
#line 3689
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3689
              return ((reg_errcode_t )12);
            }
#line 3689
            if ((unsigned long )old_buffer___8 != (unsigned long )bufp->buffer) {
#line 3689
              incr___8 = bufp->buffer - old_buffer___8;
#line 3689
              b += incr___8;
#line 3689
              begalt += incr___8;
#line 3689
              if (fixup_alt_jump) {
#line 3689
                fixup_alt_jump += incr___8;
              }
#line 3689
              if (laststart) {
#line 3689
                laststart += incr___8;
              }
#line 3689
              if (pending_exact) {
#line 3689
                pending_exact += incr___8;
              }
            }
#line 3689
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
        }
        while_break___50: /* CIL Label */ ;
        }
#line 3689
        tmp___89 = b;
#line 3689
        b ++;
#line 3689
        *tmp___89 = (unsigned char)6;
#line 3689
        tmp___90 = b;
#line 3689
        b ++;
#line 3689
        *tmp___90 = (unsigned char )regnum;
#line 3689
        tmp___91 = b;
#line 3689
        b ++;
#line 3689
        *tmp___91 = (unsigned char)0;
#line 3689
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
    }
#line 3692
    (compile_stack.avail) ++;
#line 3694
    fixup_alt_jump = (unsigned char *)0;
#line 3695
    laststart = (unsigned char *)0;
#line 3696
    begalt = b;
#line 3700
    pending_exact = (unsigned char *)0;
#line 3701
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
#line 3705
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3705
      goto normal_backslash;
    }
#line 3707
    if (compile_stack.avail == 0U) {
#line 3709
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3710
        goto normal_backslash;
      } else {
        {
#line 3712
        free((void *)compile_stack.stack);
        }
#line 3712
        return ((reg_errcode_t )16);
      }
    }
    handle_close: 
#line 3716
    if (fixup_alt_jump) {
      {
#line 3721
      while (1) {
        while_continue___52: /* CIL Label */ ;
        {
#line 3721
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 3721
          if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3721
            goto while_break___53;
          }
          {
#line 3721
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 3721
            old_buffer___9 = bufp->buffer;
#line 3721
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3721
              return ((reg_errcode_t )15);
            }
#line 3721
            bufp->allocated <<= 1;
#line 3721
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3721
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3721
            tmp___92 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3721
            bufp->buffer = (unsigned char *)tmp___92;
            }
#line 3721
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3721
              return ((reg_errcode_t )12);
            }
#line 3721
            if ((unsigned long )old_buffer___9 != (unsigned long )bufp->buffer) {
#line 3721
              incr___9 = bufp->buffer - old_buffer___9;
#line 3721
              b += incr___9;
#line 3721
              begalt += incr___9;
#line 3721
              if (fixup_alt_jump) {
#line 3721
                fixup_alt_jump += incr___9;
              }
#line 3721
              if (laststart) {
#line 3721
                laststart += incr___9;
              }
#line 3721
              if (pending_exact) {
#line 3721
                pending_exact += incr___9;
              }
            }
#line 3721
            goto while_break___54;
          }
          while_break___54: /* CIL Label */ ;
          }
        }
        while_break___53: /* CIL Label */ ;
        }
#line 3721
        tmp___93 = b;
#line 3721
        b ++;
#line 3721
        *tmp___93 = (unsigned char)20;
#line 3721
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
      {
#line 3725
      byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )(((b - 1) - fixup_alt_jump) - 3L));
      }
    }
#line 3729
    if (compile_stack.avail == 0U) {
#line 3731
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3732
        goto normal_char;
      } else {
        {
#line 3734
        free((void *)compile_stack.stack);
        }
#line 3734
        return ((reg_errcode_t )16);
      }
    }
#line 3746
    (compile_stack.avail) --;
#line 3747
    begalt = bufp->buffer + (compile_stack.stack + compile_stack.avail)->begalt_offset;
#line 3748
    if ((compile_stack.stack + compile_stack.avail)->fixup_alt_jump) {
#line 3748
      fixup_alt_jump = (bufp->buffer + (compile_stack.stack + compile_stack.avail)->fixup_alt_jump) - 1;
    } else {
#line 3748
      fixup_alt_jump = (unsigned char *)0;
    }
#line 3752
    laststart = bufp->buffer + (compile_stack.stack + compile_stack.avail)->laststart_offset;
#line 3753
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
#line 3757
    pending_exact = (unsigned char *)0;
#line 3761
    if (this_group_regnum <= 255U) {
#line 3763
      inner_group_loc = bufp->buffer + (compile_stack.stack + compile_stack.avail)->inner_group_offset;
#line 3766
      *inner_group_loc = (unsigned char )(regnum - this_group_regnum);
      {
#line 3767
      while (1) {
        while_continue___55: /* CIL Label */ ;
        {
#line 3767
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 3767
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3767
            goto while_break___56;
          }
          {
#line 3767
          while (1) {
            while_continue___57: /* CIL Label */ ;
#line 3767
            old_buffer___10 = bufp->buffer;
#line 3767
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3767
              return ((reg_errcode_t )15);
            }
#line 3767
            bufp->allocated <<= 1;
#line 3767
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3767
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3767
            tmp___94 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3767
            bufp->buffer = (unsigned char *)tmp___94;
            }
#line 3767
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3767
              return ((reg_errcode_t )12);
            }
#line 3767
            if ((unsigned long )old_buffer___10 != (unsigned long )bufp->buffer) {
#line 3767
              incr___10 = bufp->buffer - old_buffer___10;
#line 3767
              b += incr___10;
#line 3767
              begalt += incr___10;
#line 3767
              if (fixup_alt_jump) {
#line 3767
                fixup_alt_jump += incr___10;
              }
#line 3767
              if (laststart) {
#line 3767
                laststart += incr___10;
              }
#line 3767
              if (pending_exact) {
#line 3767
                pending_exact += incr___10;
              }
            }
#line 3767
            goto while_break___57;
          }
          while_break___57: /* CIL Label */ ;
          }
        }
        while_break___56: /* CIL Label */ ;
        }
#line 3767
        tmp___95 = b;
#line 3767
        b ++;
#line 3767
        *tmp___95 = (unsigned char)7;
#line 3767
        tmp___96 = b;
#line 3767
        b ++;
#line 3767
        *tmp___96 = (unsigned char )this_group_regnum;
#line 3767
        tmp___97 = b;
#line 3767
        b ++;
#line 3767
        *tmp___97 = (unsigned char )(regnum - this_group_regnum);
#line 3767
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
    }
#line 3771
    goto switch_break___0;
    case_124___0: /* CIL Label */ 
#line 3775
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3776
      goto normal_backslash;
    } else
#line 3775
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3776
      goto normal_backslash;
    }
    handle_alt: 
#line 3778
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3779
      goto normal_char;
    }
    {
#line 3783
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 3783
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3783
        goto while_break___58;
      }
      {
#line 3783
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 3783
        old_buffer___11 = bufp->buffer;
#line 3783
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3783
          return ((reg_errcode_t )15);
        }
#line 3783
        bufp->allocated <<= 1;
#line 3783
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3783
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3783
        tmp___98 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3783
        bufp->buffer = (unsigned char *)tmp___98;
        }
#line 3783
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3783
          return ((reg_errcode_t )12);
        }
#line 3783
        if ((unsigned long )old_buffer___11 != (unsigned long )bufp->buffer) {
#line 3783
          incr___11 = bufp->buffer - old_buffer___11;
#line 3783
          b += incr___11;
#line 3783
          begalt += incr___11;
#line 3783
          if (fixup_alt_jump) {
#line 3783
            fixup_alt_jump += incr___11;
          }
#line 3783
          if (laststart) {
#line 3783
            laststart += incr___11;
          }
#line 3783
          if (pending_exact) {
#line 3783
            pending_exact += incr___11;
          }
        }
#line 3783
        goto while_break___59;
      }
      while_break___59: /* CIL Label */ ;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 3784
    byte_insert_op1((re_opcode_t )15, begalt, (int )((((b + 2) + 4) - begalt) - 3L),
                    b);
#line 3786
    pending_exact = (unsigned char *)0;
#line 3787
    b += 3;
    }
#line 3805
    if (fixup_alt_jump) {
      {
#line 3806
      byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
      }
    }
#line 3811
    fixup_alt_jump = b;
    {
#line 3812
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 3812
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3812
        goto while_break___60;
      }
      {
#line 3812
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 3812
        old_buffer___12 = bufp->buffer;
#line 3812
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3812
          return ((reg_errcode_t )15);
        }
#line 3812
        bufp->allocated <<= 1;
#line 3812
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3812
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3812
        tmp___99 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3812
        bufp->buffer = (unsigned char *)tmp___99;
        }
#line 3812
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3812
          return ((reg_errcode_t )12);
        }
#line 3812
        if ((unsigned long )old_buffer___12 != (unsigned long )bufp->buffer) {
#line 3812
          incr___12 = bufp->buffer - old_buffer___12;
#line 3812
          b += incr___12;
#line 3812
          begalt += incr___12;
#line 3812
          if (fixup_alt_jump) {
#line 3812
            fixup_alt_jump += incr___12;
          }
#line 3812
          if (laststart) {
#line 3812
            laststart += incr___12;
          }
#line 3812
          if (pending_exact) {
#line 3812
            pending_exact += incr___12;
          }
        }
#line 3812
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
    }
    while_break___60: /* CIL Label */ ;
    }
#line 3813
    b += 3;
#line 3815
    laststart = (unsigned char *)0;
#line 3816
    begalt = b;
#line 3817
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
#line 3822
    if (! (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3826
      goto normal_backslash;
    } else
#line 3822
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3826
      goto normal_backslash;
    }
    handle_interval: 
#line 3833
    lower_bound = -1;
#line 3833
    upper_bound = -1;
#line 3837
    beg_interval = p;
#line 3839
    if ((unsigned long )p == (unsigned long )pend) {
#line 3840
      goto invalid_interval;
    }
    {
#line 3842
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 3842
      if (! ((unsigned long )p != (unsigned long )pend)) {
#line 3842
        goto while_break___62;
      }
      {
#line 3842
      while (1) {
        while_continue___63: /* CIL Label */ ;
#line 3842
        if ((unsigned long )p == (unsigned long )pend) {
#line 3842
          return ((reg_errcode_t )14);
        }
#line 3842
        tmp___100 = p;
#line 3842
        p ++;
#line 3842
        c = (unsigned char )*tmp___100;
#line 3842
        if (translate) {
#line 3842
          c = (unsigned char )*(translate + c);
        }
#line 3842
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
#line 3842
      if ((int )c < 48) {
#line 3842
        goto while_break___62;
      } else
#line 3842
      if ((int )c > 57) {
#line 3842
        goto while_break___62;
      }
#line 3842
      if (lower_bound <= 32767) {
#line 3842
        if (lower_bound < 0) {
#line 3842
          lower_bound = 0;
        }
#line 3842
        lower_bound = (lower_bound * 10 + (int )c) - 48;
      }
    }
    while_break___62: /* CIL Label */ ;
    }
#line 3844
    if ((int )c == 44) {
      {
#line 3846
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 3846
        if (! ((unsigned long )p != (unsigned long )pend)) {
#line 3846
          goto while_break___64;
        }
        {
#line 3846
        while (1) {
          while_continue___65: /* CIL Label */ ;
#line 3846
          if ((unsigned long )p == (unsigned long )pend) {
#line 3846
            return ((reg_errcode_t )14);
          }
#line 3846
          tmp___101 = p;
#line 3846
          p ++;
#line 3846
          c = (unsigned char )*tmp___101;
#line 3846
          if (translate) {
#line 3846
            c = (unsigned char )*(translate + c);
          }
#line 3846
          goto while_break___65;
        }
        while_break___65: /* CIL Label */ ;
        }
#line 3846
        if ((int )c < 48) {
#line 3846
          goto while_break___64;
        } else
#line 3846
        if ((int )c > 57) {
#line 3846
          goto while_break___64;
        }
#line 3846
        if (upper_bound <= 32767) {
#line 3846
          if (upper_bound < 0) {
#line 3846
            upper_bound = 0;
          }
#line 3846
          upper_bound = (upper_bound * 10 + (int )c) - 48;
        }
      }
      while_break___64: /* CIL Label */ ;
      }
#line 3847
      if (upper_bound < 0) {
#line 3848
        upper_bound = 32767;
      }
    } else {
#line 3852
      upper_bound = lower_bound;
    }
#line 3854
    if (0 <= lower_bound) {
#line 3854
      if (! (lower_bound <= upper_bound)) {
#line 3855
        goto invalid_interval;
      }
    } else {
#line 3855
      goto invalid_interval;
    }
#line 3857
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3859
      if ((int )c != 92) {
#line 3860
        goto invalid_interval;
      } else
#line 3859
      if ((unsigned long )p == (unsigned long )pend) {
#line 3860
        goto invalid_interval;
      }
      {
#line 3861
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 3861
        if ((unsigned long )p == (unsigned long )pend) {
#line 3861
          return ((reg_errcode_t )14);
        }
#line 3861
        tmp___102 = p;
#line 3861
        p ++;
#line 3861
        c = (unsigned char )*tmp___102;
#line 3861
        if (translate) {
#line 3861
          c = (unsigned char )*(translate + c);
        }
#line 3861
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
    }
#line 3864
    if ((int )c != 125) {
#line 3865
      goto invalid_interval;
    }
#line 3868
    if (! laststart) {
#line 3870
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 3870
        if (! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 3872
          free((void *)compile_stack.stack);
          }
#line 3872
          return ((reg_errcode_t )13);
        } else {
#line 3870
          goto _L___31;
        }
      } else
      _L___31: /* CIL Label */ 
#line 3873
      if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
#line 3874
        laststart = b;
      } else {
#line 3876
        goto unfetch_interval;
      }
    }
#line 3881
    if (32767 < upper_bound) {
      {
#line 3882
      free((void *)compile_stack.stack);
      }
#line 3882
      return ((reg_errcode_t )10);
    }
#line 3889
    if (upper_bound == 0) {
      {
#line 3891
      while (1) {
        while_continue___67: /* CIL Label */ ;
#line 3891
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3891
          goto while_break___67;
        }
        {
#line 3891
        while (1) {
          while_continue___68: /* CIL Label */ ;
#line 3891
          old_buffer___13 = bufp->buffer;
#line 3891
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3891
            return ((reg_errcode_t )15);
          }
#line 3891
          bufp->allocated <<= 1;
#line 3891
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3891
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3891
          tmp___103 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3891
          bufp->buffer = (unsigned char *)tmp___103;
          }
#line 3891
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3891
            return ((reg_errcode_t )12);
          }
#line 3891
          if ((unsigned long )old_buffer___13 != (unsigned long )bufp->buffer) {
#line 3891
            incr___13 = bufp->buffer - old_buffer___13;
#line 3891
            b += incr___13;
#line 3891
            begalt += incr___13;
#line 3891
            if (fixup_alt_jump) {
#line 3891
              fixup_alt_jump += incr___13;
            }
#line 3891
            if (laststart) {
#line 3891
              laststart += incr___13;
            }
#line 3891
            if (pending_exact) {
#line 3891
              pending_exact += incr___13;
            }
          }
#line 3891
          goto while_break___68;
        }
        while_break___68: /* CIL Label */ ;
        }
      }
      while_break___67: /* CIL Label */ ;
      }
      {
#line 3892
      byte_insert_op1((re_opcode_t )13, laststart, (int )((((b + 1) + 2) - laststart) - 3L),
                      b);
#line 3894
      b += 3;
      }
    } else {
#line 3909
      nbytes = (unsigned int )(10 + (upper_bound > 1) * 10);
      {
#line 3912
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 3912
        if (! ((unsigned long )((b - bufp->buffer) + (long )nbytes) > bufp->allocated)) {
#line 3912
          goto while_break___69;
        }
        {
#line 3912
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 3912
          old_buffer___14 = bufp->buffer;
#line 3912
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3912
            return ((reg_errcode_t )15);
          }
#line 3912
          bufp->allocated <<= 1;
#line 3912
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3912
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3912
          tmp___104 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3912
          bufp->buffer = (unsigned char *)tmp___104;
          }
#line 3912
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3912
            return ((reg_errcode_t )12);
          }
#line 3912
          if ((unsigned long )old_buffer___14 != (unsigned long )bufp->buffer) {
#line 3912
            incr___14 = bufp->buffer - old_buffer___14;
#line 3912
            b += incr___14;
#line 3912
            begalt += incr___14;
#line 3912
            if (fixup_alt_jump) {
#line 3912
              fixup_alt_jump += incr___14;
            }
#line 3912
            if (laststart) {
#line 3912
              laststart += incr___14;
            }
#line 3912
            if (pending_exact) {
#line 3912
              pending_exact += incr___14;
            }
          }
#line 3912
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
      }
      while_break___69: /* CIL Label */ ;
      }
      {
#line 3919
      byte_insert_op2((re_opcode_t )21, laststart, (int )(((((b + 1) + 4) + (upper_bound > 1) * 5) - laststart) - 3L),
                      lower_bound, b);
#line 3923
      b += 5;
#line 3932
      byte_insert_op2((re_opcode_t )23, laststart, 5, lower_bound, b);
#line 3934
      b += 5;
      }
#line 3936
      if (upper_bound > 1) {
        {
#line 3944
        byte_store_op2((re_opcode_t )22, b, (int )((((laststart + 4) + 1) - b) - 3L),
                       upper_bound - 1);
#line 3947
        b += 5;
#line 3963
        byte_insert_op2((re_opcode_t )23, laststart, (int )(b - laststart), upper_bound - 1,
                        b);
#line 3966
        b += 5;
        }
      }
    }
#line 3969
    pending_exact = (unsigned char *)0;
#line 3970
    goto switch_break___0;
    invalid_interval: 
#line 3973
    if (! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
#line 3974
      free((void *)compile_stack.stack);
      }
#line 3974
      if ((unsigned long )p == (unsigned long )pend) {
#line 3974
        tmp___105 = 9;
      } else {
#line 3974
        tmp___105 = 10;
      }
#line 3974
      return ((reg_errcode_t )tmp___105);
    }
    unfetch_interval: 
#line 3977
    p = beg_interval;
#line 3978
    c = (unsigned char )'{';
#line 3979
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3980
      goto normal_char;
    } else {
#line 3982
      goto normal_backslash;
    }
    case_119: /* CIL Label */ 
#line 4007
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4008
      goto normal_char;
    }
#line 4009
    laststart = b;
    {
#line 4010
    while (1) {
      while_continue___71: /* CIL Label */ ;
      {
#line 4010
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 4010
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4010
          goto while_break___72;
        }
        {
#line 4010
        while (1) {
          while_continue___73: /* CIL Label */ ;
#line 4010
          old_buffer___15 = bufp->buffer;
#line 4010
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4010
            return ((reg_errcode_t )15);
          }
#line 4010
          bufp->allocated <<= 1;
#line 4010
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4010
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4010
          tmp___106 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4010
          bufp->buffer = (unsigned char *)tmp___106;
          }
#line 4010
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4010
            return ((reg_errcode_t )12);
          }
#line 4010
          if ((unsigned long )old_buffer___15 != (unsigned long )bufp->buffer) {
#line 4010
            incr___15 = bufp->buffer - old_buffer___15;
#line 4010
            b += incr___15;
#line 4010
            begalt += incr___15;
#line 4010
            if (fixup_alt_jump) {
#line 4010
              fixup_alt_jump += incr___15;
            }
#line 4010
            if (laststart) {
#line 4010
              laststart += incr___15;
            }
#line 4010
            if (pending_exact) {
#line 4010
              pending_exact += incr___15;
            }
          }
#line 4010
          goto while_break___73;
        }
        while_break___73: /* CIL Label */ ;
        }
      }
      while_break___72: /* CIL Label */ ;
      }
#line 4010
      tmp___107 = b;
#line 4010
      b ++;
#line 4010
      *tmp___107 = (unsigned char)24;
#line 4010
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 4011
    goto switch_break___0;
    case_87: /* CIL Label */ 
#line 4015
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4016
      goto normal_char;
    }
#line 4017
    laststart = b;
    {
#line 4018
    while (1) {
      while_continue___74: /* CIL Label */ ;
      {
#line 4018
      while (1) {
        while_continue___75: /* CIL Label */ ;
#line 4018
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4018
          goto while_break___75;
        }
        {
#line 4018
        while (1) {
          while_continue___76: /* CIL Label */ ;
#line 4018
          old_buffer___16 = bufp->buffer;
#line 4018
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4018
            return ((reg_errcode_t )15);
          }
#line 4018
          bufp->allocated <<= 1;
#line 4018
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4018
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4018
          tmp___108 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4018
          bufp->buffer = (unsigned char *)tmp___108;
          }
#line 4018
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4018
            return ((reg_errcode_t )12);
          }
#line 4018
          if ((unsigned long )old_buffer___16 != (unsigned long )bufp->buffer) {
#line 4018
            incr___16 = bufp->buffer - old_buffer___16;
#line 4018
            b += incr___16;
#line 4018
            begalt += incr___16;
#line 4018
            if (fixup_alt_jump) {
#line 4018
              fixup_alt_jump += incr___16;
            }
#line 4018
            if (laststart) {
#line 4018
              laststart += incr___16;
            }
#line 4018
            if (pending_exact) {
#line 4018
              pending_exact += incr___16;
            }
          }
#line 4018
          goto while_break___76;
        }
        while_break___76: /* CIL Label */ ;
        }
      }
      while_break___75: /* CIL Label */ ;
      }
#line 4018
      tmp___109 = b;
#line 4018
      b ++;
#line 4018
      *tmp___109 = (unsigned char)25;
#line 4018
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
#line 4019
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 4023
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4024
      goto normal_char;
    }
    {
#line 4025
    while (1) {
      while_continue___77: /* CIL Label */ ;
      {
#line 4025
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 4025
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4025
          goto while_break___78;
        }
        {
#line 4025
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 4025
          old_buffer___17 = bufp->buffer;
#line 4025
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4025
            return ((reg_errcode_t )15);
          }
#line 4025
          bufp->allocated <<= 1;
#line 4025
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4025
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4025
          tmp___110 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4025
          bufp->buffer = (unsigned char *)tmp___110;
          }
#line 4025
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4025
            return ((reg_errcode_t )12);
          }
#line 4025
          if ((unsigned long )old_buffer___17 != (unsigned long )bufp->buffer) {
#line 4025
            incr___17 = bufp->buffer - old_buffer___17;
#line 4025
            b += incr___17;
#line 4025
            begalt += incr___17;
#line 4025
            if (fixup_alt_jump) {
#line 4025
              fixup_alt_jump += incr___17;
            }
#line 4025
            if (laststart) {
#line 4025
              laststart += incr___17;
            }
#line 4025
            if (pending_exact) {
#line 4025
              pending_exact += incr___17;
            }
          }
#line 4025
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
      }
      while_break___78: /* CIL Label */ ;
      }
#line 4025
      tmp___111 = b;
#line 4025
      b ++;
#line 4025
      *tmp___111 = (unsigned char)26;
#line 4025
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
#line 4026
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 4029
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4030
      goto normal_char;
    }
    {
#line 4031
    while (1) {
      while_continue___80: /* CIL Label */ ;
      {
#line 4031
      while (1) {
        while_continue___81: /* CIL Label */ ;
#line 4031
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4031
          goto while_break___81;
        }
        {
#line 4031
        while (1) {
          while_continue___82: /* CIL Label */ ;
#line 4031
          old_buffer___18 = bufp->buffer;
#line 4031
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4031
            return ((reg_errcode_t )15);
          }
#line 4031
          bufp->allocated <<= 1;
#line 4031
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4031
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4031
          tmp___112 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4031
          bufp->buffer = (unsigned char *)tmp___112;
          }
#line 4031
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4031
            return ((reg_errcode_t )12);
          }
#line 4031
          if ((unsigned long )old_buffer___18 != (unsigned long )bufp->buffer) {
#line 4031
            incr___18 = bufp->buffer - old_buffer___18;
#line 4031
            b += incr___18;
#line 4031
            begalt += incr___18;
#line 4031
            if (fixup_alt_jump) {
#line 4031
              fixup_alt_jump += incr___18;
            }
#line 4031
            if (laststart) {
#line 4031
              laststart += incr___18;
            }
#line 4031
            if (pending_exact) {
#line 4031
              pending_exact += incr___18;
            }
          }
#line 4031
          goto while_break___82;
        }
        while_break___82: /* CIL Label */ ;
        }
      }
      while_break___81: /* CIL Label */ ;
      }
#line 4031
      tmp___113 = b;
#line 4031
      b ++;
#line 4031
      *tmp___113 = (unsigned char)27;
#line 4031
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 4032
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 4035
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4036
      goto normal_char;
    }
    {
#line 4037
    while (1) {
      while_continue___83: /* CIL Label */ ;
      {
#line 4037
      while (1) {
        while_continue___84: /* CIL Label */ ;
#line 4037
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4037
          goto while_break___84;
        }
        {
#line 4037
        while (1) {
          while_continue___85: /* CIL Label */ ;
#line 4037
          old_buffer___19 = bufp->buffer;
#line 4037
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4037
            return ((reg_errcode_t )15);
          }
#line 4037
          bufp->allocated <<= 1;
#line 4037
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4037
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4037
          tmp___114 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4037
          bufp->buffer = (unsigned char *)tmp___114;
          }
#line 4037
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4037
            return ((reg_errcode_t )12);
          }
#line 4037
          if ((unsigned long )old_buffer___19 != (unsigned long )bufp->buffer) {
#line 4037
            incr___19 = bufp->buffer - old_buffer___19;
#line 4037
            b += incr___19;
#line 4037
            begalt += incr___19;
#line 4037
            if (fixup_alt_jump) {
#line 4037
              fixup_alt_jump += incr___19;
            }
#line 4037
            if (laststart) {
#line 4037
              laststart += incr___19;
            }
#line 4037
            if (pending_exact) {
#line 4037
              pending_exact += incr___19;
            }
          }
#line 4037
          goto while_break___85;
        }
        while_break___85: /* CIL Label */ ;
        }
      }
      while_break___84: /* CIL Label */ ;
      }
#line 4037
      tmp___115 = b;
#line 4037
      b ++;
#line 4037
      *tmp___115 = (unsigned char)28;
#line 4037
      goto while_break___83;
    }
    while_break___83: /* CIL Label */ ;
    }
#line 4038
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 4041
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4042
      goto normal_char;
    }
    {
#line 4043
    while (1) {
      while_continue___86: /* CIL Label */ ;
      {
#line 4043
      while (1) {
        while_continue___87: /* CIL Label */ ;
#line 4043
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4043
          goto while_break___87;
        }
        {
#line 4043
        while (1) {
          while_continue___88: /* CIL Label */ ;
#line 4043
          old_buffer___20 = bufp->buffer;
#line 4043
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4043
            return ((reg_errcode_t )15);
          }
#line 4043
          bufp->allocated <<= 1;
#line 4043
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4043
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4043
          tmp___116 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4043
          bufp->buffer = (unsigned char *)tmp___116;
          }
#line 4043
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4043
            return ((reg_errcode_t )12);
          }
#line 4043
          if ((unsigned long )old_buffer___20 != (unsigned long )bufp->buffer) {
#line 4043
            incr___20 = bufp->buffer - old_buffer___20;
#line 4043
            b += incr___20;
#line 4043
            begalt += incr___20;
#line 4043
            if (fixup_alt_jump) {
#line 4043
              fixup_alt_jump += incr___20;
            }
#line 4043
            if (laststart) {
#line 4043
              laststart += incr___20;
            }
#line 4043
            if (pending_exact) {
#line 4043
              pending_exact += incr___20;
            }
          }
#line 4043
          goto while_break___88;
        }
        while_break___88: /* CIL Label */ ;
        }
      }
      while_break___87: /* CIL Label */ ;
      }
#line 4043
      tmp___117 = b;
#line 4043
      b ++;
#line 4043
      *tmp___117 = (unsigned char)29;
#line 4043
      goto while_break___86;
    }
    while_break___86: /* CIL Label */ ;
    }
#line 4044
    goto switch_break___0;
    case_96: /* CIL Label */ 
#line 4047
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4048
      goto normal_char;
    }
    {
#line 4049
    while (1) {
      while_continue___89: /* CIL Label */ ;
      {
#line 4049
      while (1) {
        while_continue___90: /* CIL Label */ ;
#line 4049
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4049
          goto while_break___90;
        }
        {
#line 4049
        while (1) {
          while_continue___91: /* CIL Label */ ;
#line 4049
          old_buffer___21 = bufp->buffer;
#line 4049
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4049
            return ((reg_errcode_t )15);
          }
#line 4049
          bufp->allocated <<= 1;
#line 4049
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4049
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4049
          tmp___118 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4049
          bufp->buffer = (unsigned char *)tmp___118;
          }
#line 4049
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4049
            return ((reg_errcode_t )12);
          }
#line 4049
          if ((unsigned long )old_buffer___21 != (unsigned long )bufp->buffer) {
#line 4049
            incr___21 = bufp->buffer - old_buffer___21;
#line 4049
            b += incr___21;
#line 4049
            begalt += incr___21;
#line 4049
            if (fixup_alt_jump) {
#line 4049
              fixup_alt_jump += incr___21;
            }
#line 4049
            if (laststart) {
#line 4049
              laststart += incr___21;
            }
#line 4049
            if (pending_exact) {
#line 4049
              pending_exact += incr___21;
            }
          }
#line 4049
          goto while_break___91;
        }
        while_break___91: /* CIL Label */ ;
        }
      }
      while_break___90: /* CIL Label */ ;
      }
#line 4049
      tmp___119 = b;
#line 4049
      b ++;
#line 4049
      *tmp___119 = (unsigned char)11;
#line 4049
      goto while_break___89;
    }
    while_break___89: /* CIL Label */ ;
    }
#line 4050
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 4053
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4054
      goto normal_char;
    }
    {
#line 4055
    while (1) {
      while_continue___92: /* CIL Label */ ;
      {
#line 4055
      while (1) {
        while_continue___93: /* CIL Label */ ;
#line 4055
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4055
          goto while_break___93;
        }
        {
#line 4055
        while (1) {
          while_continue___94: /* CIL Label */ ;
#line 4055
          old_buffer___22 = bufp->buffer;
#line 4055
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4055
            return ((reg_errcode_t )15);
          }
#line 4055
          bufp->allocated <<= 1;
#line 4055
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4055
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4055
          tmp___120 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4055
          bufp->buffer = (unsigned char *)tmp___120;
          }
#line 4055
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4055
            return ((reg_errcode_t )12);
          }
#line 4055
          if ((unsigned long )old_buffer___22 != (unsigned long )bufp->buffer) {
#line 4055
            incr___22 = bufp->buffer - old_buffer___22;
#line 4055
            b += incr___22;
#line 4055
            begalt += incr___22;
#line 4055
            if (fixup_alt_jump) {
#line 4055
              fixup_alt_jump += incr___22;
            }
#line 4055
            if (laststart) {
#line 4055
              laststart += incr___22;
            }
#line 4055
            if (pending_exact) {
#line 4055
              pending_exact += incr___22;
            }
          }
#line 4055
          goto while_break___94;
        }
        while_break___94: /* CIL Label */ ;
        }
      }
      while_break___93: /* CIL Label */ ;
      }
#line 4055
      tmp___121 = b;
#line 4055
      b ++;
#line 4055
      *tmp___121 = (unsigned char)12;
#line 4055
      goto while_break___92;
    }
    while_break___92: /* CIL Label */ ;
    }
#line 4056
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 4060
    if (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4061
      goto normal_char;
    }
#line 4063
    c1 = (unsigned char )((int )c - 48);
#line 4065
    if ((regnum_t )c1 > regnum) {
      {
#line 4066
      free((void *)compile_stack.stack);
      }
#line 4066
      return ((reg_errcode_t )6);
    }
    {
#line 4069
    tmp___122 = group_in_compile_stack(compile_stack, (regnum_t )c1);
    }
#line 4069
    if (tmp___122) {
#line 4070
      goto normal_char;
    }
#line 4072
    laststart = b;
    {
#line 4073
    while (1) {
      while_continue___95: /* CIL Label */ ;
      {
#line 4073
      while (1) {
        while_continue___96: /* CIL Label */ ;
#line 4073
        if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 4073
          goto while_break___96;
        }
        {
#line 4073
        while (1) {
          while_continue___97: /* CIL Label */ ;
#line 4073
          old_buffer___23 = bufp->buffer;
#line 4073
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4073
            return ((reg_errcode_t )15);
          }
#line 4073
          bufp->allocated <<= 1;
#line 4073
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4073
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4073
          tmp___123 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4073
          bufp->buffer = (unsigned char *)tmp___123;
          }
#line 4073
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4073
            return ((reg_errcode_t )12);
          }
#line 4073
          if ((unsigned long )old_buffer___23 != (unsigned long )bufp->buffer) {
#line 4073
            incr___23 = bufp->buffer - old_buffer___23;
#line 4073
            b += incr___23;
#line 4073
            begalt += incr___23;
#line 4073
            if (fixup_alt_jump) {
#line 4073
              fixup_alt_jump += incr___23;
            }
#line 4073
            if (laststart) {
#line 4073
              laststart += incr___23;
            }
#line 4073
            if (pending_exact) {
#line 4073
              pending_exact += incr___23;
            }
          }
#line 4073
          goto while_break___97;
        }
        while_break___97: /* CIL Label */ ;
        }
      }
      while_break___96: /* CIL Label */ ;
      }
#line 4073
      tmp___124 = b;
#line 4073
      b ++;
#line 4073
      *tmp___124 = (unsigned char)8;
#line 4073
      tmp___125 = b;
#line 4073
      b ++;
#line 4073
      *tmp___125 = c1;
#line 4073
      goto while_break___95;
    }
    while_break___95: /* CIL Label */ ;
    }
#line 4074
    goto switch_break___0;
    case_63___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
#line 4079
    if (syntax & (1UL << 1)) {
#line 4080
      goto handle_plus;
    }
    normal_backslash: 
    switch_default: /* CIL Label */ 
#line 4089
    if (translate) {
#line 4089
      c = (unsigned char )*(translate + c);
    } else {
#line 4089
      c = (unsigned char )((char )c);
    }
#line 4090
    goto normal_char;
    switch_break___0: /* CIL Label */ ;
    }
#line 4092
    goto switch_break;
    normal_char: 
    switch_default___0: /* CIL Label */ 
#line 4099
    if (! pending_exact) {
#line 4099
      goto _L___32;
    } else
#line 4099
    if ((unsigned long )((pending_exact + (int )*pending_exact) + 1) != (unsigned long )b) {
#line 4099
      goto _L___32;
    } else
#line 4099
    if ((int )*pending_exact == (1 << 8) - 1) {
#line 4099
      goto _L___32;
    } else
#line 4099
    if ((int const   )*p == 42) {
#line 4099
      goto _L___32;
    } else
#line 4099
    if ((int const   )*p == 94) {
#line 4099
      goto _L___32;
    } else {
#line 4099
      if (syntax & (1UL << 1)) {
#line 4099
        if ((int const   )*p == 92) {
#line 4099
          if ((int const   )*(p + 1) == 43) {
#line 4099
            tmp___129 = 1;
          } else
#line 4099
          if ((int const   )*(p + 1) == 63) {
#line 4099
            tmp___129 = 1;
          } else {
#line 4099
            tmp___129 = 0;
          }
        } else {
#line 4099
          tmp___129 = 0;
        }
#line 4099
        tmp___131 = tmp___129;
      } else {
#line 4099
        if ((int const   )*p == 43) {
#line 4099
          tmp___130 = 1;
        } else
#line 4099
        if ((int const   )*p == 63) {
#line 4099
          tmp___130 = 1;
        } else {
#line 4099
          tmp___130 = 0;
        }
#line 4099
        tmp___131 = tmp___130;
      }
#line 4099
      if (tmp___131) {
#line 4099
        goto _L___32;
      } else
#line 4099
      if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4099
        if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4099
          tmp___133 = (int const   )*p == 123;
        } else {
#line 4099
          if ((int const   )*(p + 0) == 92) {
#line 4099
            if ((int const   )*(p + 1) == 123) {
#line 4099
              tmp___132 = 1;
            } else {
#line 4099
              tmp___132 = 0;
            }
          } else {
#line 4099
            tmp___132 = 0;
          }
#line 4099
          tmp___133 = tmp___132;
        }
#line 4099
        if (tmp___133) {
          _L___32: /* CIL Label */ 
#line 4124
          laststart = b;
          {
#line 4134
          while (1) {
            while_continue___98: /* CIL Label */ ;
            {
#line 4134
            while (1) {
              while_continue___99: /* CIL Label */ ;
#line 4134
              if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 4134
                goto while_break___99;
              }
              {
#line 4134
              while (1) {
                while_continue___100: /* CIL Label */ ;
#line 4134
                old_buffer___24 = bufp->buffer;
#line 4134
                if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4134
                  return ((reg_errcode_t )15);
                }
#line 4134
                bufp->allocated <<= 1;
#line 4134
                if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4134
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                {
#line 4134
                tmp___126 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4134
                bufp->buffer = (unsigned char *)tmp___126;
                }
#line 4134
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4134
                  return ((reg_errcode_t )12);
                }
#line 4134
                if ((unsigned long )old_buffer___24 != (unsigned long )bufp->buffer) {
#line 4134
                  incr___24 = bufp->buffer - old_buffer___24;
#line 4134
                  b += incr___24;
#line 4134
                  begalt += incr___24;
#line 4134
                  if (fixup_alt_jump) {
#line 4134
                    fixup_alt_jump += incr___24;
                  }
#line 4134
                  if (laststart) {
#line 4134
                    laststart += incr___24;
                  }
#line 4134
                  if (pending_exact) {
#line 4134
                    pending_exact += incr___24;
                  }
                }
#line 4134
                goto while_break___100;
              }
              while_break___100: /* CIL Label */ ;
              }
            }
            while_break___99: /* CIL Label */ ;
            }
#line 4134
            tmp___127 = b;
#line 4134
            b ++;
#line 4134
            *tmp___127 = (unsigned char)2;
#line 4134
            tmp___128 = b;
#line 4134
            b ++;
#line 4134
            *tmp___128 = (unsigned char)0;
#line 4134
            goto while_break___98;
          }
          while_break___98: /* CIL Label */ ;
          }
#line 4136
          pending_exact = b - 1;
        }
      }
    }
    {
#line 4139
    while (1) {
      while_continue___101: /* CIL Label */ ;
      {
#line 4139
      while (1) {
        while_continue___102: /* CIL Label */ ;
#line 4139
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4139
          goto while_break___102;
        }
        {
#line 4139
        while (1) {
          while_continue___103: /* CIL Label */ ;
#line 4139
          old_buffer___25 = bufp->buffer;
#line 4139
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4139
            return ((reg_errcode_t )15);
          }
#line 4139
          bufp->allocated <<= 1;
#line 4139
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4139
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4139
          tmp___134 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4139
          bufp->buffer = (unsigned char *)tmp___134;
          }
#line 4139
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4139
            return ((reg_errcode_t )12);
          }
#line 4139
          if ((unsigned long )old_buffer___25 != (unsigned long )bufp->buffer) {
#line 4139
            incr___25 = bufp->buffer - old_buffer___25;
#line 4139
            b += incr___25;
#line 4139
            begalt += incr___25;
#line 4139
            if (fixup_alt_jump) {
#line 4139
              fixup_alt_jump += incr___25;
            }
#line 4139
            if (laststart) {
#line 4139
              laststart += incr___25;
            }
#line 4139
            if (pending_exact) {
#line 4139
              pending_exact += incr___25;
            }
          }
#line 4139
          goto while_break___103;
        }
        while_break___103: /* CIL Label */ ;
        }
      }
      while_break___102: /* CIL Label */ ;
      }
#line 4139
      tmp___135 = b;
#line 4139
      b ++;
#line 4139
      *tmp___135 = c;
#line 4139
      goto while_break___101;
    }
    while_break___101: /* CIL Label */ ;
    }
#line 4140
    *pending_exact = (unsigned char )((int )*pending_exact + 1);
#line 4141
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4148
  if (fixup_alt_jump) {
    {
#line 4149
    byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
    }
  }
#line 4151
  if (! (compile_stack.avail == 0U)) {
    {
#line 4152
    free((void *)compile_stack.stack);
    }
#line 4152
    return ((reg_errcode_t )8);
  }
#line 4156
  if (syntax & ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 4157
    while (1) {
      while_continue___104: /* CIL Label */ ;
      {
#line 4157
      while (1) {
        while_continue___105: /* CIL Label */ ;
#line 4157
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4157
          goto while_break___105;
        }
        {
#line 4157
        while (1) {
          while_continue___106: /* CIL Label */ ;
#line 4157
          old_buffer___26 = bufp->buffer;
#line 4157
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4157
            return ((reg_errcode_t )15);
          }
#line 4157
          bufp->allocated <<= 1;
#line 4157
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4157
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4157
          tmp___136 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4157
          bufp->buffer = (unsigned char *)tmp___136;
          }
#line 4157
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4157
            return ((reg_errcode_t )12);
          }
#line 4157
          if ((unsigned long )old_buffer___26 != (unsigned long )bufp->buffer) {
#line 4157
            incr___26 = bufp->buffer - old_buffer___26;
#line 4157
            b += incr___26;
#line 4157
            begalt += incr___26;
#line 4157
            if (fixup_alt_jump) {
#line 4157
              fixup_alt_jump += incr___26;
            }
#line 4157
            if (laststart) {
#line 4157
              laststart += incr___26;
            }
#line 4157
            if (pending_exact) {
#line 4157
              pending_exact += incr___26;
            }
          }
#line 4157
          goto while_break___106;
        }
        while_break___106: /* CIL Label */ ;
        }
      }
      while_break___105: /* CIL Label */ ;
      }
#line 4157
      tmp___137 = b;
#line 4157
      b ++;
#line 4157
      *tmp___137 = (unsigned char)1;
#line 4157
      goto while_break___104;
    }
    while_break___104: /* CIL Label */ ;
    }
  }
  {
#line 4164
  free((void *)compile_stack.stack);
#line 4170
  bufp->used = (unsigned long )(b - bufp->buffer);
  }
#line 4222
  return ((reg_errcode_t )0);
}
}
#line 4230 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static void byte_store_op1(re_opcode_t op , unsigned char *loc , int arg ) 
{ 


  {
#line 4233
  *loc = (unsigned char )op;
  {
#line 4234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4234
    *((loc + 1) + 0) = (unsigned char )(arg & 255);
#line 4234
    *((loc + 1) + 1) = (unsigned char )(arg >> 8);
#line 4234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4235
  return;
}
}
#line 4241 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static void byte_store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) 
{ 


  {
#line 4244
  *loc = (unsigned char )op;
  {
#line 4245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4245
    *((loc + 1) + 0) = (unsigned char )(arg1 & 255);
#line 4245
    *((loc + 1) + 1) = (unsigned char )(arg1 >> 8);
#line 4245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4246
    *(((loc + 1) + 2) + 0) = (unsigned char )(arg2 & 255);
#line 4246
    *(((loc + 1) + 2) + 1) = (unsigned char )(arg2 >> 8);
#line 4246
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4247
  return;
}
}
#line 4254 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static void byte_insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 4257
  pfrom = end;
#line 4258
  pto = (end + 1) + 2;
  {
#line 4260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4260
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 4260
      goto while_break;
    }
#line 4261
    pto --;
#line 4261
    pfrom --;
#line 4261
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4263
  byte_store_op1(op, loc, arg);
  }
#line 4264
  return;
}
}
#line 4270 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static void byte_insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                            unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 4274
  pfrom = end;
#line 4275
  pto = (end + 1) + 4;
  {
#line 4277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4277
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 4277
      goto while_break;
    }
#line 4278
    pto --;
#line 4278
    pfrom --;
#line 4278
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4280
  byte_store_op2(op, loc, arg1, arg2);
  }
#line 4281
  return;
}
}
#line 4288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean byte_at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) 
{ 
  char const   *prev ;
  boolean prev_prev_backslash ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4292
  prev = p - 2;
#line 4293
  if ((unsigned long )prev > (unsigned long )pattern) {
#line 4293
    if ((int const   )*(prev + -1) == 92) {
#line 4293
      tmp___0 = 1;
    } else {
#line 4293
      tmp___0 = 0;
    }
  } else {
#line 4293
    tmp___0 = 0;
  }
#line 4293
  prev_prev_backslash = (boolean )tmp___0;
#line 4295
  if ((int const   )*prev == 40) {
#line 4295
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4295
      tmp___1 = 1;
    } else
#line 4295
    if (prev_prev_backslash) {
#line 4295
      tmp___1 = 1;
    } else {
#line 4295
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4295
  if ((int const   )*prev == 124) {
#line 4295
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4295
      tmp___1 = 1;
    } else
#line 4295
    if (prev_prev_backslash) {
#line 4295
      tmp___1 = 1;
    } else {
#line 4295
      tmp___1 = 0;
    }
  } else {
#line 4295
    tmp___1 = 0;
  }
#line 4295
  return ((boolean )tmp___1);
}
}
#line 4306 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean byte_at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) 
{ 
  char const   *next ;
  boolean next_backslash ;
  char const   *next_next ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4310
  next = p;
#line 4311
  next_backslash = (boolean )((int const   )*next == 92);
#line 4312
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
#line 4312
    tmp___0 = p + 1;
  } else {
#line 4312
    tmp___0 = (char const   *)0;
  }
#line 4312
  next_next = tmp___0;
#line 4314
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4314
    tmp___2 = (int const   )*next == 41;
  } else {
#line 4314
    if (next_backslash) {
#line 4314
      if (next_next) {
#line 4314
        if ((int const   )*next_next == 41) {
#line 4314
          tmp___1 = 1;
        } else {
#line 4314
          tmp___1 = 0;
        }
      } else {
#line 4314
        tmp___1 = 0;
      }
    } else {
#line 4314
      tmp___1 = 0;
    }
#line 4314
    tmp___2 = tmp___1;
  }
#line 4314
  if (tmp___2) {
#line 4314
    tmp___5 = 1;
  } else {
#line 4314
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4314
      tmp___4 = (int const   )*next == 124;
    } else {
#line 4314
      if (next_backslash) {
#line 4314
        if (next_next) {
#line 4314
          if ((int const   )*next_next == 124) {
#line 4314
            tmp___3 = 1;
          } else {
#line 4314
            tmp___3 = 0;
          }
        } else {
#line 4314
          tmp___3 = 0;
        }
      } else {
#line 4314
        tmp___3 = 0;
      }
#line 4314
      tmp___4 = tmp___3;
    }
#line 4314
    if (tmp___4) {
#line 4314
      tmp___5 = 1;
    } else {
#line 4314
      tmp___5 = 0;
    }
  }
#line 4314
  return ((boolean )tmp___5);
}
}
#line 4443 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static reg_errcode_t byte_compile_range(unsigned int range_start_char , char const   **p_ptr ,
                                        char const   *pend , char *translate , reg_syntax_t syntax ,
                                        unsigned char *b ) 
{ 
  unsigned int this_char ;
  char const   *p ;
  reg_errcode_t ret ;
  unsigned int end_char ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4449
  p = *p_ptr;
#line 4459
  if ((unsigned long )p == (unsigned long )pend) {
#line 4460
    return ((reg_errcode_t )11);
  }
#line 4464
  (*p_ptr) ++;
#line 4467
  if (syntax & ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4467
    ret = (reg_errcode_t )11;
  } else {
#line 4467
    ret = (reg_errcode_t )0;
  }
#line 4489
  if (translate) {
#line 4489
    range_start_char = (unsigned int )*(translate + (unsigned char )range_start_char);
  } else {
#line 4489
    range_start_char = (unsigned int )((char )range_start_char);
  }
#line 4495
  if (translate) {
#line 4495
    tmp___0 = (int )*(translate + (unsigned char )*(p + 0));
  } else {
#line 4495
    tmp___0 = (int )((char )*(p + 0));
  }
#line 4495
  end_char = (unsigned int )tmp___0 & (unsigned int )((1 << 8) - 1);
#line 4497
  this_char = range_start_char;
  {
#line 4497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4497
    if (! (this_char <= end_char)) {
#line 4497
      goto while_break;
    }
#line 4499
    if (translate) {
#line 4499
      tmp___1 = (int )*(translate + (unsigned char )this_char);
    } else {
#line 4499
      tmp___1 = (int )((char )this_char);
    }
#line 4499
    if (translate) {
#line 4499
      tmp___2 = (int )*(translate + (unsigned char )this_char);
    } else {
#line 4499
      tmp___2 = (int )((char )this_char);
    }
#line 4499
    *(b + (int )((unsigned char )tmp___1) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )tmp___1) / 8) | (1 << (int )((unsigned char )tmp___2) % 8));
#line 4500
    ret = (reg_errcode_t )0;
#line 4497
    this_char ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4504
  return (ret);
}
}
#line 4542 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static int byte_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int j ;
  int k ;
  byte_fail_stack_type fail_stack ;
  char *destination ;
  register char *fastmap ;
  unsigned char *pattern ;
  register unsigned char *pend ;
  unsigned char *p ;
  boolean path_can_be_null ;
  boolean succeed_n_p ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int fastmap_newline ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 4553
  fastmap = bufp->fastmap;
#line 4561
  pattern = bufp->buffer;
#line 4562
  pend = pattern + bufp->used;
#line 4564
  p = pattern;
#line 4576
  path_can_be_null = (boolean )1;
#line 4579
  succeed_n_p = (boolean )0;
  {
#line 4583
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4583
    tmp___0 = __builtin_alloca(5UL * sizeof(byte_fail_stack_elt_t ));
#line 4583
    fail_stack.stack = (byte_fail_stack_elt_t *)tmp___0;
    }
#line 4583
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4583
      return (-2);
    }
#line 4583
    fail_stack.size = 5U;
#line 4583
    fail_stack.avail = 0U;
#line 4583
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4584
  memset((void *)fastmap, '\000', (size_t )(1 << 8));
#line 4585
  bufp->fastmap_accurate = 1U;
#line 4586
  bufp->can_be_null = 0U;
  }
  {
#line 4588
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4590
    if ((unsigned long )p == (unsigned long )pend) {
#line 4590
      goto _L;
    } else
#line 4590
    if ((int )*p == 1) {
      _L: /* CIL Label */ 
#line 4593
      if (! (fail_stack.avail == 0U)) {
#line 4595
        bufp->can_be_null |= (unsigned int )path_can_be_null;
#line 4598
        path_can_be_null = (boolean )1;
#line 4600
        (fail_stack.avail) --;
#line 4600
        p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 4602
        goto while_continue___0;
      } else {
#line 4605
        goto while_break___0;
      }
    }
#line 4611
    tmp___1 = p;
#line 4611
    p ++;
    {
#line 4619
    if ((unsigned int )((re_opcode_t )*tmp___1) == 8U) {
#line 4619
      goto case_8;
    }
#line 4632
    if ((unsigned int )((re_opcode_t )*tmp___1) == 2U) {
#line 4632
      goto case_2;
    }
#line 4652
    if ((unsigned int )((re_opcode_t )*tmp___1) == 4U) {
#line 4652
      goto case_4;
    }
#line 4659
    if ((unsigned int )((re_opcode_t )*tmp___1) == 5U) {
#line 4659
      goto case_5;
    }
#line 4670
    if ((unsigned int )((re_opcode_t )*tmp___1) == 24U) {
#line 4670
      goto case_24;
    }
#line 4677
    if ((unsigned int )((re_opcode_t )*tmp___1) == 25U) {
#line 4677
      goto case_25;
    }
#line 4684
    if ((unsigned int )((re_opcode_t )*tmp___1) == 3U) {
#line 4684
      goto case_3;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 20U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 27U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 26U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 29U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 28U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 12U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 11U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 10U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 9U) {
#line 4742
      goto case_20;
    }
#line 4742
    if ((unsigned int )((re_opcode_t )*tmp___1) == 0U) {
#line 4742
      goto case_20;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 19U) {
#line 4751
      goto case_19;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 14U) {
#line 4751
      goto case_19;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 13U) {
#line 4751
      goto case_19;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 18U) {
#line 4751
      goto case_19;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 17U) {
#line 4751
      goto case_19;
    }
#line 4751
    if ((unsigned int )((re_opcode_t )*tmp___1) == 22U) {
#line 4751
      goto case_19;
    }
#line 4779
    if ((unsigned int )((re_opcode_t )*tmp___1) == 16U) {
#line 4779
      goto handle_on_failure_jump;
    }
#line 4779
    if ((unsigned int )((re_opcode_t )*tmp___1) == 15U) {
#line 4779
      goto handle_on_failure_jump;
    }
#line 4810
    if ((unsigned int )((re_opcode_t )*tmp___1) == 21U) {
#line 4810
      goto case_21;
    }
#line 4825
    if ((unsigned int )((re_opcode_t )*tmp___1) == 23U) {
#line 4825
      goto case_23;
    }
#line 4831
    if ((unsigned int )((re_opcode_t )*tmp___1) == 7U) {
#line 4831
      goto case_7;
    }
#line 4831
    if ((unsigned int )((re_opcode_t )*tmp___1) == 6U) {
#line 4831
      goto case_7;
    }
#line 4836
    goto switch_default;
    case_8: /* CIL Label */ 
#line 4620
    bufp->can_be_null = 1U;
#line 4621
    goto done;
    case_2: /* CIL Label */ 
#line 4633
    *(fastmap + *(p + 1)) = (char)1;
#line 4634
    goto switch_break;
    case_4: /* CIL Label */ 
#line 4653
    tmp___2 = p;
#line 4653
    p ++;
#line 4653
    j = (int )*tmp___2 * 8 - 1;
    {
#line 4653
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4653
      if (! (j >= 0)) {
#line 4653
        goto while_break___1;
      }
#line 4654
      if ((int )*(p + j / 8) & (1 << j % 8)) {
#line 4655
        *(fastmap + j) = (char)1;
      }
#line 4653
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4656
    goto switch_break;
    case_5: /* CIL Label */ 
#line 4661
    j = (int )*p * 8;
    {
#line 4661
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4661
      if (! (j < 1 << 8)) {
#line 4661
        goto while_break___2;
      }
#line 4662
      *(fastmap + j) = (char)1;
#line 4661
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4664
    tmp___3 = p;
#line 4664
    p ++;
#line 4664
    j = (int )*tmp___3 * 8 - 1;
    {
#line 4664
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4664
      if (! (j >= 0)) {
#line 4664
        goto while_break___3;
      }
#line 4665
      if (! ((int )*(p + j / 8) & (1 << j % 8))) {
#line 4666
        *(fastmap + j) = (char)1;
      }
#line 4664
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4667
    goto switch_break;
    case_24: /* CIL Label */ 
#line 4671
    j = 0;
    {
#line 4671
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 4671
      if (! (j < 1 << 8)) {
#line 4671
        goto while_break___4;
      }
#line 4672
      if ((int )re_syntax_table[(unsigned char )j] == 1) {
#line 4673
        *(fastmap + j) = (char)1;
      }
#line 4671
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 4674
    goto switch_break;
    case_25: /* CIL Label */ 
#line 4678
    j = 0;
    {
#line 4678
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4678
      if (! (j < 1 << 8)) {
#line 4678
        goto while_break___5;
      }
#line 4679
      if ((int )re_syntax_table[(unsigned char )j] != 1) {
#line 4680
        *(fastmap + j) = (char)1;
      }
#line 4678
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4681
    goto switch_break;
    case_3: /* CIL Label */ 
#line 4686
    fastmap_newline = (int )*(fastmap + '\n');
#line 4689
    j = 0;
    {
#line 4689
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 4689
      if (! (j < 1 << 8)) {
#line 4689
        goto while_break___6;
      }
#line 4690
      *(fastmap + j) = (char)1;
#line 4689
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 4693
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4694
      *(fastmap + '\n') = (char )fastmap_newline;
    } else
#line 4698
    if (bufp->can_be_null) {
#line 4699
      goto done;
    }
#line 4702
    goto switch_break;
    case_20: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 4743
    goto while_continue___0;
    case_19: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 4752
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 4752
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 4752
        j = (int )*p & 255;
#line 4752
        j += (int )((signed char )*(p + 1)) << 8;
#line 4752
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 4752
      p += 2;
#line 4752
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 4753
    p += j;
#line 4754
    if (j > 0) {
#line 4755
      goto while_continue___0;
    }
#line 4762
    if ((unsigned int )((re_opcode_t )*p) != 15U) {
#line 4762
      if ((unsigned int )((re_opcode_t )*p) != 21U) {
#line 4764
        goto while_continue___0;
      }
    }
#line 4766
    p ++;
    {
#line 4767
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 4767
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 4767
        j = (int )*p & 255;
#line 4767
        j += (int )((signed char )*(p + 1)) << 8;
#line 4767
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 4767
      p += 2;
#line 4767
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 4768
    p += j;
#line 4771
    if (! (fail_stack.avail == 0U)) {
#line 4771
      if ((unsigned long )(fail_stack.stack + (fail_stack.avail - 1U))->pointer == (unsigned long )p) {
#line 4773
        (fail_stack.avail) --;
      }
    }
#line 4775
    goto while_continue___0;
    handle_on_failure_jump: 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    {
#line 4781
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 4781
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 4781
        j = (int )*p & 255;
#line 4781
        j += (int )((signed char )*(p + 1)) << 8;
#line 4781
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 4781
      p += 2;
#line 4781
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 4790
    if ((unsigned long )(p + j) < (unsigned long )pend) {
#line 4792
      if (fail_stack.avail == fail_stack.size) {
#line 4792
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 4792
          tmp___12 = 0;
        } else {
          {
#line 4792
          tmp___9 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 4792
          destination = (char *)tmp___9;
#line 4792
          tmp___10 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 4792
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___10;
          }
#line 4792
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4792
            tmp___11 = 0;
          } else {
#line 4792
            fail_stack.size <<= 1;
#line 4792
            tmp___11 = 1;
          }
#line 4792
          tmp___12 = tmp___11;
        }
#line 4792
        if (tmp___12) {
#line 4792
          tmp___7 = fail_stack.avail;
#line 4792
          (fail_stack.avail) ++;
#line 4792
          (fail_stack.stack + tmp___7)->pointer = p + j;
#line 4792
          tmp___8 = 1;
        } else {
#line 4792
          tmp___8 = 0;
        }
      } else {
#line 4792
        tmp___7 = fail_stack.avail;
#line 4792
        (fail_stack.avail) ++;
#line 4792
        (fail_stack.stack + tmp___7)->pointer = p + j;
#line 4792
        tmp___8 = 1;
      }
#line 4792
      if (! tmp___8) {
#line 4795
        return (-2);
      }
    } else {
#line 4799
      bufp->can_be_null = 1U;
    }
#line 4801
    if (succeed_n_p) {
      {
#line 4803
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 4803
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4803
          k = (int )*p & 255;
#line 4803
          k += (int )((signed char )*(p + 1)) << 8;
#line 4803
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 4803
        p += 2;
#line 4803
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 4804
      succeed_n_p = (boolean )0;
    }
#line 4807
    goto while_continue___0;
    case_21: /* CIL Label */ 
#line 4812
    p += 2;
    {
#line 4815
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 4815
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 4815
        k = (int )*p & 255;
#line 4815
        k += (int )((signed char )*(p + 1)) << 8;
#line 4815
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 4815
      p += 2;
#line 4815
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 4816
    if (k == 0) {
#line 4818
      p -= 4;
#line 4819
      succeed_n_p = (boolean )1;
#line 4820
      goto handle_on_failure_jump;
    }
#line 4822
    goto while_continue___0;
    case_23: /* CIL Label */ 
#line 4826
    p += 4;
#line 4827
    goto while_continue___0;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 4832
    p += 2;
#line 4833
    goto while_continue___0;
    switch_default: /* CIL Label */ 
    {
#line 4837
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 4846
    path_can_be_null = (boolean )0;
#line 4847
    p = pend;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4852
  bufp->can_be_null |= (unsigned int )path_can_be_null;
  done: ;
#line 4856
  return (0);
}
}
#line 5008 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static int byte_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int size1 , char const   *string2 , int size2 , int startpos ,
                            int range , struct re_registers *regs , int stop ) 
{ 
  int val ;
  register char *fastmap ;
  register char *translate ;
  int total_size ;
  int endpos ;
  int tmp___0 ;
  register char const   *d ;
  register int lim ;
  int irange ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  register char c ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5015
  fastmap = bufp->fastmap;
#line 5016
  translate = bufp->translate;
#line 5017
  total_size = size1 + size2;
#line 5018
  endpos = startpos + range;
#line 5031
  if (startpos < 0) {
#line 5032
    return (-1);
  } else
#line 5031
  if (startpos > total_size) {
#line 5032
    return (-1);
  }
#line 5037
  if (endpos < 0) {
#line 5038
    range = 0 - startpos;
  } else
#line 5039
  if (endpos > total_size) {
#line 5040
    range = total_size - startpos;
  }
#line 5044
  if (bufp->used > 0UL) {
#line 5044
    if (range > 0) {
#line 5044
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 11U) {
#line 5044
        goto _L;
      } else
#line 5044
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 9U) {
#line 5044
        if (! bufp->newline_anchor) {
          _L: /* CIL Label */ 
#line 5050
          if (startpos > 0) {
#line 5051
            return (-1);
          } else {
#line 5053
            range = 1;
          }
        }
      }
    }
  }
#line 5068
  if (fastmap) {
#line 5068
    if (! bufp->fastmap_accurate) {
      {
#line 5069
      tmp___0 = xre_compile_fastmap(bufp);
      }
#line 5069
      if (tmp___0 == -2) {
#line 5070
        return (-2);
      }
    }
  }
  {
#line 5148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5154
    if (fastmap) {
#line 5154
      if (startpos < total_size) {
#line 5154
        if (! bufp->can_be_null) {
#line 5156
          if (range > 0) {
#line 5159
            lim = 0;
#line 5160
            irange = range;
#line 5162
            if (startpos < size1) {
#line 5162
              if (startpos + range >= size1) {
#line 5163
                lim = range - (size1 - startpos);
              }
            }
#line 5165
            if (startpos >= size1) {
#line 5165
              tmp___1 = string2 - size1;
            } else {
#line 5165
              tmp___1 = string1;
            }
#line 5165
            d = tmp___1 + startpos;
#line 5169
            if (translate) {
              {
#line 5170
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 5170
                if (range > lim) {
#line 5170
                  tmp___2 = d;
#line 5170
                  d ++;
#line 5170
                  if (*(fastmap + (unsigned char )*(translate + (unsigned char )*tmp___2))) {
#line 5170
                    goto while_break___0;
                  }
                } else {
#line 5170
                  goto while_break___0;
                }
#line 5173
                range --;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
              {
#line 5175
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 5175
                if (range > lim) {
#line 5175
                  tmp___3 = d;
#line 5175
                  d ++;
#line 5175
                  if (*(fastmap + (unsigned char )*tmp___3)) {
#line 5175
                    goto while_break___1;
                  }
                } else {
#line 5175
                  goto while_break___1;
                }
#line 5176
                range --;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 5178
            startpos += irange - range;
          } else {
#line 5182
            if (size1 == 0) {
#line 5182
              tmp___4 = (int const   )*(string2 + (startpos - size1));
            } else
#line 5182
            if (startpos >= size1) {
#line 5182
              tmp___4 = (int const   )*(string2 + (startpos - size1));
            } else {
#line 5182
              tmp___4 = (int const   )*(string1 + startpos);
            }
#line 5182
            c = (char )tmp___4;
#line 5186
            if (translate) {
#line 5186
              tmp___5 = (int )*(translate + (unsigned char )c);
            } else {
#line 5186
              tmp___5 = (int )c;
            }
#line 5186
            if (! *(fastmap + (unsigned char )tmp___5)) {
#line 5187
              goto advance;
            }
          }
        }
      }
    }
#line 5192
    if (range >= 0) {
#line 5192
      if (startpos == total_size) {
#line 5192
        if (fastmap) {
#line 5192
          if (! bufp->can_be_null) {
#line 5198
            return (-1);
          }
        }
      }
    }
    {
#line 5208
    val = byte_re_match_2_internal(bufp, string1, size1, string2, size2, startpos,
                                   regs, stop);
    }
#line 5218
    if (val >= 0) {
#line 5223
      return (startpos);
    }
#line 5226
    if (val == -2) {
#line 5231
      return (-2);
    }
    advance: 
#line 5235
    if (! range) {
#line 5236
      goto while_break;
    } else
#line 5237
    if (range > 0) {
#line 5239
      range --;
#line 5240
      startpos ++;
    } else {
#line 5244
      range ++;
#line 5245
      startpos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5251
  return (-1);
}
}
#line 5423
static boolean byte_group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                              byte_register_info_type *reg_info ) ;
#line 5426
static boolean byte_alt_match_null_string_p(unsigned char *p , unsigned char *end ,
                                            byte_register_info_type *reg_info ) ;
#line 5429
static boolean byte_common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                                  byte_register_info_type *reg_info ) ;
#line 5432
static int byte_bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) ;
#line 5544 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static int byte_re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                                    int size1 , char const   *string2 , int size2 ,
                                    int pos , struct re_registers *regs , int stop ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  char const   *end1 ;
  char const   *end2 ;
  char const   *end_match_1 ;
  char const   *end_match_2 ;
  char const   *d ;
  char const   *dend ;
  unsigned char *p ;
  register unsigned char *pend ;
  unsigned char *just_past_start_mem ;
  char *translate ;
  byte_fail_stack_type fail_stack ;
  size_t num_regs ;
  active_reg_t lowest_active_reg ;
  active_reg_t highest_active_reg ;
  char const   **regstart ;
  char const   **regend ;
  char const   **old_regstart ;
  char const   **old_regend ;
  byte_register_info_type *reg_info ;
  unsigned int best_regs_set ;
  char const   **best_regstart ;
  char const   **best_regend ;
  char const   *match_end ;
  int set_regs_matched_done ;
  char const   **reg_dummy ;
  byte_register_info_type *reg_info_dummy ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  boolean same_str_p ;
  boolean best_match_p ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  xregoff_t tmp___18 ;
  xregoff_t tmp___19 ;
  xregoff_t tmp___20 ;
  size_t tmp___21 ;
  xregoff_t tmp___22 ;
  char const   *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  char const   *tmp___26 ;
  unsigned char *tmp___27 ;
  char const   *tmp___28 ;
  unsigned char *tmp___29 ;
  active_reg_t r ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  active_reg_t r___0 ;
  unsigned int tmp___33 ;
  register unsigned char c ;
  boolean negate ;
  active_reg_t r___1 ;
  unsigned int tmp___34 ;
  boolean tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  unsigned char r___2 ;
  boolean is_a_jump_n ;
  unsigned char *tmp___38 ;
  unsigned int r___3 ;
  char *destination ;
  active_reg_t this_reg ;
  void *tmp___39 ;
  void *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  register char const   *d2 ;
  register char const   *dend2 ;
  int regno ;
  unsigned char *tmp___50 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  active_reg_t r___4 ;
  unsigned int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  char *destination___0 ;
  active_reg_t this_reg___0 ;
  void *tmp___61 ;
  void *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  char *destination___1 ;
  active_reg_t this_reg___1 ;
  void *tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  unsigned int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned int tmp___78 ;
  unsigned int tmp___79 ;
  unsigned int tmp___80 ;
  unsigned int tmp___81 ;
  unsigned int tmp___82 ;
  register unsigned char *p2 ;
  register unsigned char c___0 ;
  int tmp___83 ;
  int negate___0 ;
  int idx___0 ;
  int idx___1 ;
  active_reg_t dummy_low_reg ;
  active_reg_t dummy_high_reg ;
  unsigned char *pdummy  __attribute__((__unused__)) ;
  char const   *sdummy  __attribute__((__unused__)) ;
  active_reg_t this_reg___2 ;
  unsigned char const   *string_temp ;
  char *destination___2 ;
  active_reg_t this_reg___3 ;
  void *tmp___84 ;
  void *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  char *destination___3 ;
  active_reg_t this_reg___4 ;
  void *tmp___95 ;
  void *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  unsigned int tmp___99 ;
  unsigned int tmp___100 ;
  unsigned int tmp___101 ;
  unsigned int tmp___102 ;
  unsigned int tmp___103 ;
  unsigned int tmp___104 ;
  unsigned int tmp___105 ;
  boolean prevchar ;
  boolean thischar ;
  char const   *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  boolean prevchar___0 ;
  boolean thischar___0 ;
  char const   *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  char const   *tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  char const   *tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  active_reg_t r___5 ;
  unsigned int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  active_reg_t r___6 ;
  unsigned int tmp___131 ;
  active_reg_t this_reg___5 ;
  unsigned char const   *string_temp___0 ;
  boolean is_a_jump_n___0 ;

  {
#line 5577
  p = bufp->buffer;
#line 5578
  pend = p + bufp->used;
#line 5583
  just_past_start_mem = (unsigned char *)0;
#line 5586
  translate = bufp->translate;
#line 5614
  num_regs = bufp->re_nsub + 1UL;
#line 5617
  lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 5618
  highest_active_reg = (active_reg_t )(1 << 8);
#line 5654
  best_regs_set = 0U;
#line 5667
  match_end = (char const   *)((void *)0);
#line 5670
  set_regs_matched_done = 0;
  {
#line 5685
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5685
    tmp___0 = __builtin_alloca(5UL * sizeof(byte_fail_stack_elt_t ));
#line 5685
    fail_stack.stack = (byte_fail_stack_elt_t *)tmp___0;
    }
#line 5685
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 5685
      return (-2);
    }
#line 5685
    fail_stack.size = 5U;
#line 5685
    fail_stack.avail = 0U;
#line 5685
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5693
  if (bufp->re_nsub) {
    {
#line 5695
    tmp___1 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5695
    regstart = (char const   **)tmp___1;
#line 5696
    tmp___2 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5696
    regend = (char const   **)tmp___2;
#line 5697
    tmp___3 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5697
    old_regstart = (char const   **)tmp___3;
#line 5698
    tmp___4 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5698
    old_regend = (char const   **)tmp___4;
#line 5699
    tmp___5 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5699
    best_regstart = (char const   **)tmp___5;
#line 5700
    tmp___6 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5700
    best_regend = (char const   **)tmp___6;
#line 5701
    tmp___7 = __builtin_alloca(num_regs * sizeof(byte_register_info_type ));
#line 5701
    reg_info = (byte_register_info_type *)tmp___7;
#line 5702
    tmp___8 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5702
    reg_dummy = (char const   **)tmp___8;
#line 5703
    tmp___9 = __builtin_alloca(num_regs * sizeof(byte_register_info_type ));
#line 5703
    reg_info_dummy = (byte_register_info_type *)tmp___9;
    }
#line 5705
    if (regstart) {
#line 5705
      if (regend) {
#line 5705
        if (old_regstart) {
#line 5705
          if (old_regend) {
#line 5705
            if (reg_info) {
#line 5705
              if (best_regstart) {
#line 5705
                if (best_regend) {
#line 5705
                  if (reg_dummy) {
#line 5705
                    if (! reg_info_dummy) {
#line 5705
                      goto _L___6;
                    }
                  } else {
#line 5705
                    goto _L___6;
                  }
                } else {
#line 5705
                  goto _L___6;
                }
              } else {
#line 5705
                goto _L___6;
              }
            } else {
#line 5705
              goto _L___6;
            }
          } else {
#line 5705
            goto _L___6;
          }
        } else {
#line 5705
          goto _L___6;
        }
      } else {
#line 5705
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 5708
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5708
        regstart = (char const   **)((void *)0);
#line 5708
        regend = (char const   **)((void *)0);
#line 5708
        old_regstart = (char const   **)((void *)0);
#line 5708
        old_regend = (char const   **)((void *)0);
#line 5708
        best_regstart = (char const   **)((void *)0);
#line 5708
        best_regend = (char const   **)((void *)0);
#line 5708
        reg_info = (byte_register_info_type *)((void *)0);
#line 5708
        reg_dummy = (char const   **)((void *)0);
#line 5708
        reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5708
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5709
      return (-2);
    }
  } else {
#line 5716
    reg_dummy = (char const   **)((void *)0);
#line 5716
    best_regend = reg_dummy;
#line 5716
    best_regstart = best_regend;
#line 5716
    old_regend = best_regstart;
#line 5716
    old_regstart = old_regend;
#line 5716
    regend = old_regstart;
#line 5716
    regstart = regend;
#line 5718
    reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5718
    reg_info = reg_info_dummy;
  }
#line 5726
  if (pos < 0) {
#line 5726
    goto _L___7;
  } else
#line 5726
  if (pos > size1 + size2) {
    _L___7: /* CIL Label */ 
    {
#line 5729
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5729
      regstart = (char const   **)((void *)0);
#line 5729
      regend = (char const   **)((void *)0);
#line 5729
      old_regstart = (char const   **)((void *)0);
#line 5729
      old_regend = (char const   **)((void *)0);
#line 5729
      best_regstart = (char const   **)((void *)0);
#line 5729
      best_regend = (char const   **)((void *)0);
#line 5729
      reg_info = (byte_register_info_type *)((void *)0);
#line 5729
      reg_dummy = (char const   **)((void *)0);
#line 5729
      reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5729
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5730
    return (-1);
  }
#line 5787
  mcnt = 1;
  {
#line 5787
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5787
    if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5787
      goto while_break___2;
    }
#line 5789
    tmp___12 = (char const   *)(& byte_reg_unset_dummy);
#line 5789
    *(old_regend + mcnt) = tmp___12;
#line 5789
    tmp___11 = tmp___12;
#line 5789
    *(old_regstart + mcnt) = tmp___11;
#line 5789
    tmp___10 = tmp___11;
#line 5789
    *(regend + mcnt) = tmp___10;
#line 5789
    *(regstart + mcnt) = tmp___10;
#line 5792
    (reg_info + mcnt)->bits.match_null_string_p = 3U;
#line 5793
    (reg_info + mcnt)->bits.is_active = 0U;
#line 5794
    (reg_info + mcnt)->bits.matched_something = 0U;
#line 5795
    (reg_info + mcnt)->bits.ever_matched_something = 0U;
#line 5787
    mcnt ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5800
  if (size2 == 0) {
#line 5800
    if ((unsigned long )string1 != (unsigned long )((void *)0)) {
#line 5802
      string2 = string1;
#line 5803
      size2 = size1;
#line 5804
      string1 = (char const   *)0;
#line 5805
      size1 = 0;
    }
  }
#line 5813
  end1 = string1 + size1;
#line 5814
  end2 = string2 + size2;
#line 5838
  if (stop <= size1) {
#line 5840
    end_match_1 = string1 + stop;
#line 5841
    end_match_2 = string2;
  } else {
#line 5845
    end_match_1 = end1;
#line 5846
    end_match_2 = (string2 + stop) - size1;
  }
#line 5876
  if (size1 > 0) {
#line 5876
    if (pos <= size1) {
#line 5878
      d = string1 + pos;
#line 5879
      dend = end_match_1;
    } else {
#line 5883
      d = (string2 + pos) - size1;
#line 5884
      dend = end_match_2;
    }
  } else {
#line 5883
    d = (string2 + pos) - size1;
#line 5884
    dend = end_match_2;
  }
  {
#line 5897
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5905
    if ((unsigned long )p == (unsigned long )pend) {
#line 5911
      if ((unsigned long )d != (unsigned long )end_match_2) {
#line 5920
        if (size1) {
#line 5920
          if ((unsigned long )string1 <= (unsigned long )match_end) {
#line 5920
            if ((unsigned long )match_end <= (unsigned long )(string1 + size1)) {
#line 5920
              tmp___13 = 1;
            } else {
#line 5920
              tmp___13 = 0;
            }
          } else {
#line 5920
            tmp___13 = 0;
          }
        } else {
#line 5920
          tmp___13 = 0;
        }
#line 5920
        same_str_p = (boolean )(tmp___13 == ((unsigned long )dend == (unsigned long )end_match_1));
#line 5925
        if (same_str_p) {
#line 5926
          best_match_p = (boolean )((unsigned long )d > (unsigned long )match_end);
        } else {
#line 5928
          best_match_p = (boolean )(! ((unsigned long )dend == (unsigned long )end_match_1));
        }
#line 5932
        if (! (fail_stack.avail == 0U)) {
#line 5936
          if (! best_regs_set) {
#line 5936
            goto _L___8;
          } else
#line 5936
          if (best_match_p) {
            _L___8: /* CIL Label */ 
#line 5938
            best_regs_set = 1U;
#line 5939
            match_end = d;
#line 5943
            mcnt = 1;
            {
#line 5943
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 5943
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5943
                goto while_break___4;
              }
#line 5945
              *(best_regstart + mcnt) = *(regstart + mcnt);
#line 5946
              *(best_regend + mcnt) = *(regend + mcnt);
#line 5943
              mcnt ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 5949
          goto fail;
        } else
#line 5955
        if (best_regs_set) {
#line 5955
          if (! best_match_p) {
            restore_best_regs: 
#line 5965
            d = match_end;
#line 5966
            if ((unsigned long )d >= (unsigned long )string1) {
#line 5966
              if ((unsigned long )d <= (unsigned long )end1) {
#line 5966
                dend = end_match_1;
              } else {
#line 5966
                dend = end_match_2;
              }
            } else {
#line 5966
              dend = end_match_2;
            }
#line 5969
            mcnt = 1;
            {
#line 5969
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 5969
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5969
                goto while_break___5;
              }
#line 5971
              *(regstart + mcnt) = *(best_regstart + mcnt);
#line 5972
              *(regend + mcnt) = *(best_regend + mcnt);
#line 5969
              mcnt ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      }
      succeed_label: ;
#line 5980
      if (regs) {
#line 5980
        if (! bufp->no_sub) {
#line 5983
          if (bufp->regs_allocated == 0U) {
#line 5987
            if (30UL > num_regs + 1UL) {
#line 5987
              regs->num_regs = 30U;
            } else {
#line 5987
              regs->num_regs = (unsigned int )(num_regs + 1UL);
            }
            {
#line 5988
            tmp___14 = malloc((unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 5988
            regs->start = (xregoff_t *)tmp___14;
#line 5989
            tmp___15 = malloc((unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 5989
            regs->end = (xregoff_t *)tmp___15;
            }
#line 5990
            if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 5990
              goto _L___9;
            } else
#line 5990
            if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
              _L___9: /* CIL Label */ 
              {
#line 5992
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 5992
                regstart = (char const   **)((void *)0);
#line 5992
                regend = (char const   **)((void *)0);
#line 5992
                old_regstart = (char const   **)((void *)0);
#line 5992
                old_regend = (char const   **)((void *)0);
#line 5992
                best_regstart = (char const   **)((void *)0);
#line 5992
                best_regend = (char const   **)((void *)0);
#line 5992
                reg_info = (byte_register_info_type *)((void *)0);
#line 5992
                reg_dummy = (char const   **)((void *)0);
#line 5992
                reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5992
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 5993
              return (-2);
            }
#line 5995
            bufp->regs_allocated = 1U;
          } else
#line 5997
          if (bufp->regs_allocated == 1U) {
#line 6001
            if ((size_t )regs->num_regs < num_regs + 1UL) {
              {
#line 6003
              regs->num_regs = (unsigned int )(num_regs + 1UL);
#line 6004
              tmp___16 = realloc((void *)regs->start, (unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 6004
              regs->start = (xregoff_t *)tmp___16;
#line 6005
              tmp___17 = realloc((void *)regs->end, (unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 6005
              regs->end = (xregoff_t *)tmp___17;
              }
#line 6006
              if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 6006
                goto _L___10;
              } else
#line 6006
              if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
                _L___10: /* CIL Label */ 
                {
#line 6008
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 6008
                  regstart = (char const   **)((void *)0);
#line 6008
                  regend = (char const   **)((void *)0);
#line 6008
                  old_regstart = (char const   **)((void *)0);
#line 6008
                  old_regend = (char const   **)((void *)0);
#line 6008
                  best_regstart = (char const   **)((void *)0);
#line 6008
                  best_regend = (char const   **)((void *)0);
#line 6008
                  reg_info = (byte_register_info_type *)((void *)0);
#line 6008
                  reg_dummy = (char const   **)((void *)0);
#line 6008
                  reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 6008
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 6009
                return (-2);
              }
            }
          }
#line 6023
          if (regs->num_regs > 0U) {
#line 6025
            *(regs->start + 0) = pos;
#line 6034
            if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 6034
              *(regs->end + 0) = (xregoff_t )(d - string1);
            } else {
#line 6034
              *(regs->end + 0) = (xregoff_t )((d - string2) + (long )size1);
            }
          }
#line 6042
          mcnt = 1;
          {
#line 6042
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 6042
            if (num_regs < (size_t )regs->num_regs) {
#line 6042
              tmp___21 = num_regs;
            } else {
#line 6042
              tmp___21 = (size_t )regs->num_regs;
            }
#line 6042
            if (! ((size_t )((unsigned int )mcnt) < tmp___21)) {
#line 6042
              goto while_break___8;
            }
#line 6045
            if ((unsigned long )*(regstart + mcnt) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6046
              tmp___18 = -1;
#line 6046
              *(regs->end + mcnt) = tmp___18;
#line 6046
              *(regs->start + mcnt) = tmp___18;
            } else
#line 6045
            if ((unsigned long )*(regend + mcnt) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6046
              tmp___18 = -1;
#line 6046
              *(regs->end + mcnt) = tmp___18;
#line 6046
              *(regs->start + mcnt) = tmp___18;
            } else {
#line 6049
              if (size1) {
#line 6049
                if ((unsigned long )string1 <= (unsigned long )*(regstart + mcnt)) {
#line 6049
                  if ((unsigned long )*(regstart + mcnt) <= (unsigned long )(string1 + size1)) {
#line 6049
                    tmp___19 = (xregoff_t )(*(regstart + mcnt) - string1);
                  } else {
#line 6049
                    tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 6049
                  tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                }
              } else {
#line 6049
                tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
              }
#line 6049
              *(regs->start + mcnt) = tmp___19;
#line 6051
              if (size1) {
#line 6051
                if ((unsigned long )string1 <= (unsigned long )*(regend + mcnt)) {
#line 6051
                  if ((unsigned long )*(regend + mcnt) <= (unsigned long )(string1 + size1)) {
#line 6051
                    tmp___20 = (xregoff_t )(*(regend + mcnt) - string1);
                  } else {
#line 6051
                    tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 6051
                  tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
                }
              } else {
#line 6051
                tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
              }
#line 6051
              *(regs->end + mcnt) = tmp___20;
            }
#line 6042
            mcnt ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 6061
          mcnt = (int )num_regs;
          {
#line 6061
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 6061
            if (! ((unsigned int )mcnt < regs->num_regs)) {
#line 6061
              goto while_break___9;
            }
#line 6062
            tmp___22 = -1;
#line 6062
            *(regs->end + mcnt) = tmp___22;
#line 6062
            *(regs->start + mcnt) = tmp___22;
#line 6061
            mcnt ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 6078
      if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 6078
        tmp___23 = string1;
      } else {
#line 6078
        tmp___23 = string2 - size1;
      }
#line 6078
      mcnt = (int )((d - pos) - tmp___23);
      {
#line 6085
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 6085
        regstart = (char const   **)((void *)0);
#line 6085
        regend = (char const   **)((void *)0);
#line 6085
        old_regstart = (char const   **)((void *)0);
#line 6085
        old_regend = (char const   **)((void *)0);
#line 6085
        best_regstart = (char const   **)((void *)0);
#line 6085
        best_regend = (char const   **)((void *)0);
#line 6085
        reg_info = (byte_register_info_type *)((void *)0);
#line 6085
        reg_dummy = (char const   **)((void *)0);
#line 6085
        reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 6085
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 6086
      return (mcnt);
    }
#line 6090
    tmp___24 = p;
#line 6090
    p ++;
    {
#line 6094
    if ((unsigned int )((re_opcode_t )*tmp___24) == 0U) {
#line 6094
      goto case_0;
    }
#line 6098
    if ((unsigned int )((re_opcode_t )*tmp___24) == 1U) {
#line 6098
      goto case_1;
    }
#line 6105
    if ((unsigned int )((re_opcode_t )*tmp___24) == 2U) {
#line 6105
      goto case_2;
    }
#line 6153
    if ((unsigned int )((re_opcode_t )*tmp___24) == 3U) {
#line 6153
      goto case_3;
    }
#line 6169
    if ((unsigned int )((re_opcode_t )*tmp___24) == 5U) {
#line 6169
      goto case_5;
    }
#line 6169
    if ((unsigned int )((re_opcode_t )*tmp___24) == 4U) {
#line 6169
      goto case_5;
    }
#line 6578
    if ((unsigned int )((re_opcode_t )*tmp___24) == 6U) {
#line 6578
      goto case_6;
    }
#line 6627
    if ((unsigned int )((re_opcode_t )*tmp___24) == 7U) {
#line 6627
      goto case_7;
    }
#line 6765
    if ((unsigned int )((re_opcode_t )*tmp___24) == 8U) {
#line 6765
      goto case_8;
    }
#line 6831
    if ((unsigned int )((re_opcode_t )*tmp___24) == 9U) {
#line 6831
      goto case_9;
    }
#line 6847
    if ((unsigned int )((re_opcode_t )*tmp___24) == 10U) {
#line 6847
      goto case_10;
    }
#line 6865
    if ((unsigned int )((re_opcode_t )*tmp___24) == 11U) {
#line 6865
      goto case_11;
    }
#line 6873
    if ((unsigned int )((re_opcode_t )*tmp___24) == 12U) {
#line 6873
      goto case_12;
    }
#line 6896
    if ((unsigned int )((re_opcode_t )*tmp___24) == 16U) {
#line 6896
      goto case_16;
    }
#line 6922
    if ((unsigned int )((re_opcode_t )*tmp___24) == 15U) {
#line 6922
      goto on_failure;
    }
#line 6969
    if ((unsigned int )((re_opcode_t )*tmp___24) == 18U) {
#line 6969
      goto case_18___0;
    }
#line 7137
    if ((unsigned int )((re_opcode_t )*tmp___24) == 17U) {
#line 7137
      goto case_17___0;
    }
#line 7164
    if ((unsigned int )((re_opcode_t )*tmp___24) == 13U) {
#line 7164
      goto case_13___0;
    }
#line 7178
    if ((unsigned int )((re_opcode_t )*tmp___24) == 14U) {
#line 7178
      goto case_14;
    }
#line 7188
    if ((unsigned int )((re_opcode_t )*tmp___24) == 19U) {
#line 7188
      goto case_19___0;
    }
#line 7201
    if ((unsigned int )((re_opcode_t )*tmp___24) == 20U) {
#line 7201
      goto case_20;
    }
#line 7210
    if ((unsigned int )((re_opcode_t )*tmp___24) == 21U) {
#line 7210
      goto case_21;
    }
#line 7249
    if ((unsigned int )((re_opcode_t )*tmp___24) == 22U) {
#line 7249
      goto case_22___0;
    }
#line 7273
    if ((unsigned int )((re_opcode_t )*tmp___24) == 23U) {
#line 7273
      goto case_23;
    }
#line 7307
    if ((unsigned int )((re_opcode_t )*tmp___24) == 28U) {
#line 7307
      goto case_28;
    }
#line 7322
    if ((unsigned int )((re_opcode_t )*tmp___24) == 29U) {
#line 7322
      goto case_29;
    }
#line 7338
    if ((unsigned int )((re_opcode_t )*tmp___24) == 26U) {
#line 7338
      goto case_26;
    }
#line 7345
    if ((unsigned int )((re_opcode_t )*tmp___24) == 27U) {
#line 7345
      goto case_27;
    }
#line 7406
    if ((unsigned int )((re_opcode_t )*tmp___24) == 24U) {
#line 7406
      goto case_24;
    }
#line 7415
    if ((unsigned int )((re_opcode_t )*tmp___24) == 25U) {
#line 7415
      goto case_25;
    }
#line 7425
    goto switch_default___0;
    case_0: /* CIL Label */ ;
#line 6096
    goto switch_break;
    case_1: /* CIL Label */ ;
#line 6100
    goto succeed_label;
    case_2: /* CIL Label */ 
#line 6109
    tmp___25 = p;
#line 6109
    p ++;
#line 6109
    mcnt = (int )*tmp___25;
#line 6114
    if (translate) {
      {
#line 6116
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 6118
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 6118
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6118
            goto while_break___12;
          }
#line 6118
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6118
            goto fail;
          }
#line 6118
          d = string2;
#line 6118
          dend = end_match_2;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 6132
        tmp___26 = d;
#line 6132
        d ++;
#line 6132
        tmp___27 = p;
#line 6132
        p ++;
#line 6132
        if ((int )((unsigned char )*(translate + (unsigned char )*tmp___26)) != (int )*tmp___27) {
#line 6134
          goto fail;
        }
#line 6116
        mcnt --;
#line 6116
        if (! mcnt) {
#line 6116
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 6141
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 6143
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 6143
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6143
            goto while_break___14;
          }
#line 6143
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6143
            goto fail;
          }
#line 6143
          d = string2;
#line 6143
          dend = end_match_2;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 6144
        tmp___28 = d;
#line 6144
        d ++;
#line 6144
        tmp___29 = p;
#line 6144
        p ++;
#line 6144
        if ((int const   )*tmp___28 != (int const   )((char )*tmp___29)) {
#line 6144
          goto fail;
        }
#line 6141
        mcnt --;
#line 6141
        if (! mcnt) {
#line 6141
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    {
#line 6148
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 6148
      if (! set_regs_matched_done) {
#line 6148
        set_regs_matched_done = 1;
#line 6148
        r = lowest_active_reg;
        {
#line 6148
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 6148
          if (! (r <= highest_active_reg)) {
#line 6148
            goto while_break___16;
          }
#line 6148
          tmp___30 = 1U;
#line 6148
          (reg_info + r)->bits.ever_matched_something = tmp___30;
#line 6148
          (reg_info + r)->bits.matched_something = tmp___30;
#line 6148
          r ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 6148
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 6149
    goto switch_break;
    case_3: /* CIL Label */ ;
    {
#line 6156
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 6156
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6156
        goto while_break___17;
      }
#line 6156
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6156
        goto fail;
      }
#line 6156
      d = string2;
#line 6156
      dend = end_match_2;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 6158
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 6158
      if (translate) {
#line 6158
        tmp___31 = (int )*(translate + (unsigned char )*d);
      } else {
#line 6158
        tmp___31 = (int )((char )*d);
      }
#line 6158
      if (tmp___31 == 10) {
#line 6160
        goto fail;
      } else {
#line 6158
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 6158
    if (bufp->syntax & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 6158
      if (translate) {
#line 6158
        tmp___32 = (int )*(translate + (unsigned char )*d);
      } else {
#line 6158
        tmp___32 = (int )((char )*d);
      }
#line 6158
      if (tmp___32 == 0) {
#line 6160
        goto fail;
      }
    }
    {
#line 6162
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 6162
      if (! set_regs_matched_done) {
#line 6162
        set_regs_matched_done = 1;
#line 6162
        r___0 = lowest_active_reg;
        {
#line 6162
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 6162
          if (! (r___0 <= highest_active_reg)) {
#line 6162
            goto while_break___19;
          }
#line 6162
          tmp___33 = 1U;
#line 6162
          (reg_info + r___0)->bits.ever_matched_something = tmp___33;
#line 6162
          (reg_info + r___0)->bits.matched_something = tmp___33;
#line 6162
          r___0 ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 6162
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 6164
    d ++;
#line 6165
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 6182
    negate = (boolean )((unsigned int )((re_opcode_t )*(p - 1)) == 5U);
    {
#line 6185
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 6185
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6185
        goto while_break___20;
      }
#line 6185
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6185
        goto fail;
      }
#line 6185
      d = string2;
#line 6185
      dend = end_match_2;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 6186
    if (translate) {
#line 6186
      c = (unsigned char )*(translate + (unsigned char )*d);
    } else {
#line 6186
      c = (unsigned char )((char )*d);
    }
#line 6558
    if ((unsigned int )c < (unsigned int )((int )*p * 8)) {
#line 6558
      if ((int )*(p + (1 + (int )c / 8)) & (1 << (int )c % 8)) {
#line 6560
        negate = (boolean )(! negate);
      }
    }
#line 6562
    p += 1 + (int )*p;
#line 6564
    if (! negate) {
#line 6564
      goto fail;
    }
    {
#line 6567
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 6567
      if (! set_regs_matched_done) {
#line 6567
        set_regs_matched_done = 1;
#line 6567
        r___1 = lowest_active_reg;
        {
#line 6567
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 6567
          if (! (r___1 <= highest_active_reg)) {
#line 6567
            goto while_break___22;
          }
#line 6567
          tmp___34 = 1U;
#line 6567
          (reg_info + r___1)->bits.ever_matched_something = tmp___34;
#line 6567
          (reg_info + r___1)->bits.matched_something = tmp___34;
#line 6567
          r___1 ++;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
#line 6567
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 6568
    d ++;
#line 6569
    goto switch_break;
    case_6: /* CIL Label */ 
#line 6583
    p1 = p;
#line 6585
    if ((reg_info + *p)->bits.match_null_string_p == 3U) {
      {
#line 6586
      tmp___35 = byte_group_match_null_string_p(& p1, pend, reg_info);
#line 6586
      (reg_info + *p)->bits.match_null_string_p = (unsigned int )tmp___35;
      }
    }
#line 6594
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 6594
      if ((unsigned long )*(regstart + *p) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6594
        tmp___36 = d;
      } else {
#line 6594
        tmp___36 = *(regstart + *p);
      }
#line 6594
      *(old_regstart + *p) = tmp___36;
    } else {
#line 6594
      *(old_regstart + *p) = *(regstart + *p);
    }
#line 6600
    *(regstart + *p) = d;
#line 6603
    (reg_info + *p)->bits.is_active = 1U;
#line 6604
    (reg_info + *p)->bits.matched_something = 0U;
#line 6607
    set_regs_matched_done = 0;
#line 6610
    highest_active_reg = (active_reg_t )*p;
#line 6614
    if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 6615
      lowest_active_reg = (active_reg_t )*p;
    }
#line 6618
    p += 2;
#line 6619
    just_past_start_mem = p;
#line 6621
    goto switch_break;
    case_7: /* CIL Label */ ;
#line 6636
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 6636
      if ((unsigned long )*(regend + *p) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6636
        tmp___37 = d;
      } else {
#line 6636
        tmp___37 = *(regend + *p);
      }
#line 6636
      *(old_regend + *p) = tmp___37;
    } else {
#line 6636
      *(old_regend + *p) = *(regend + *p);
    }
#line 6642
    *(regend + *p) = d;
#line 6646
    (reg_info + *p)->bits.is_active = 0U;
#line 6649
    set_regs_matched_done = 0;
#line 6653
    if (lowest_active_reg == highest_active_reg) {
#line 6655
      lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 6656
      highest_active_reg = (active_reg_t )(1 << 8);
    } else {
#line 6663
      r___2 = (unsigned char )((int )*p - 1);
      {
#line 6664
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 6664
        if ((int )r___2 > 0) {
#line 6664
          if (! (! (reg_info + r___2)->bits.is_active)) {
#line 6664
            goto while_break___23;
          }
        } else {
#line 6664
          goto while_break___23;
        }
#line 6665
        r___2 = (unsigned char )((int )r___2 - 1);
      }
      while_break___23: /* CIL Label */ ;
      }
#line 6674
      if ((int )r___2 == 0) {
#line 6676
        lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 6677
        highest_active_reg = (active_reg_t )(1 << 8);
      } else {
#line 6680
        highest_active_reg = (active_reg_t )r___2;
      }
    }
#line 6688
    if (! (reg_info + *p)->bits.matched_something) {
#line 6688
      goto _L___12;
    } else
#line 6688
    if ((unsigned long )just_past_start_mem == (unsigned long )(p - 1)) {
      _L___12: /* CIL Label */ 
#line 6688
      if ((unsigned long )(p + 2) < (unsigned long )pend) {
#line 6692
        is_a_jump_n = (boolean )0;
#line 6694
        p1 = p + 2;
#line 6695
        mcnt = 0;
#line 6696
        tmp___38 = p1;
#line 6696
        p1 ++;
        {
#line 6698
        if ((unsigned int )((re_opcode_t )*tmp___38) == 22U) {
#line 6698
          goto case_22;
        }
#line 6703
        if ((unsigned int )((re_opcode_t )*tmp___38) == 19U) {
#line 6703
          goto case_19;
        }
#line 6703
        if ((unsigned int )((re_opcode_t )*tmp___38) == 13U) {
#line 6703
          goto case_19;
        }
#line 6703
        if ((unsigned int )((re_opcode_t )*tmp___38) == 18U) {
#line 6703
          goto case_19;
        }
#line 6703
        if ((unsigned int )((re_opcode_t )*tmp___38) == 17U) {
#line 6703
          goto case_19;
        }
#line 6709
        goto switch_default;
        case_22: /* CIL Label */ 
#line 6699
        is_a_jump_n = (boolean )1;
        case_19: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        {
#line 6704
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 6704
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 6704
            mcnt = (int )*p1 & 255;
#line 6704
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 6704
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 6704
          p1 += 2;
#line 6704
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 6705
        if (is_a_jump_n) {
#line 6706
          p1 += 2;
        }
#line 6707
        goto switch_break___0;
        switch_default: /* CIL Label */ ;
        switch_break___0: /* CIL Label */ ;
        }
#line 6712
        p1 += mcnt;
#line 6719
        if (mcnt < 0) {
#line 6719
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 6719
            if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 6U) {
#line 6719
              if ((int )*(p1 + 4) == (int )*p) {
#line 6733
                if ((reg_info + *p)->bits.ever_matched_something) {
#line 6737
                  (reg_info + *p)->bits.ever_matched_something = 0U;
#line 6740
                  r___3 = (unsigned int )*p;
                  {
#line 6740
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 6740
                    if (! (r___3 < (unsigned int )*p + (unsigned int )*(p + 1))) {
#line 6740
                      goto while_break___26;
                    }
#line 6743
                    *(regstart + r___3) = *(old_regstart + r___3);
#line 6746
                    if ((unsigned long )*(old_regend + r___3) >= (unsigned long )*(regstart + r___3)) {
#line 6747
                      *(regend + r___3) = *(old_regend + r___3);
                    }
#line 6740
                    r___3 ++;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
#line 6750
                p1 ++;
                {
#line 6751
                while (1) {
                  while_continue___27: /* CIL Label */ ;
                  {
#line 6751
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
#line 6751
                    mcnt = (int )*p1 & 255;
#line 6751
                    mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 6751
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
#line 6751
                  p1 += 2;
#line 6751
                  goto while_break___27;
                }
                while_break___27: /* CIL Label */ ;
                }
                {
#line 6752
                while (1) {
                  while_continue___29: /* CIL Label */ ;
                  {
#line 6752
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
#line 6752
                    if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6752
                      goto while_break___30;
                    }
#line 6752
                    if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6752
                      tmp___42 = 0;
                    } else {
                      {
#line 6752
                      tmp___39 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6752
                      destination = (char *)tmp___39;
#line 6752
                      tmp___40 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                                        (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6752
                      fail_stack.stack = (byte_fail_stack_elt_t *)tmp___40;
                      }
#line 6752
                      if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6752
                        tmp___41 = 0;
                      } else {
#line 6752
                        fail_stack.size <<= 1;
#line 6752
                        tmp___41 = 1;
                      }
#line 6752
                      tmp___42 = tmp___41;
                    }
#line 6752
                    if (! tmp___42) {
#line 6752
                      return (-2);
                    }
                  }
                  while_break___30: /* CIL Label */ ;
                  }
#line 6752
                  this_reg = lowest_active_reg;
                  {
#line 6752
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
#line 6752
                    if (! (this_reg <= highest_active_reg)) {
#line 6752
                      goto while_break___31;
                    }
#line 6752
                    tmp___43 = fail_stack.avail;
#line 6752
                    (fail_stack.avail) ++;
#line 6752
                    (fail_stack.stack + tmp___43)->pointer = (unsigned char *)*(regstart + this_reg);
#line 6752
                    tmp___44 = fail_stack.avail;
#line 6752
                    (fail_stack.avail) ++;
#line 6752
                    (fail_stack.stack + tmp___44)->pointer = (unsigned char *)*(regend + this_reg);
#line 6752
                    tmp___45 = fail_stack.avail;
#line 6752
                    (fail_stack.avail) ++;
#line 6752
                    *(fail_stack.stack + tmp___45) = (reg_info + this_reg)->word;
#line 6752
                    this_reg ++;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
#line 6752
                  tmp___46 = fail_stack.avail;
#line 6752
                  (fail_stack.avail) ++;
#line 6752
                  (fail_stack.stack + tmp___46)->integer = (int )lowest_active_reg;
#line 6752
                  tmp___47 = fail_stack.avail;
#line 6752
                  (fail_stack.avail) ++;
#line 6752
                  (fail_stack.stack + tmp___47)->integer = (int )highest_active_reg;
#line 6752
                  tmp___48 = fail_stack.avail;
#line 6752
                  (fail_stack.avail) ++;
#line 6752
                  (fail_stack.stack + tmp___48)->pointer = p1 + mcnt;
#line 6752
                  tmp___49 = fail_stack.avail;
#line 6752
                  (fail_stack.avail) ++;
#line 6752
                  (fail_stack.stack + tmp___49)->pointer = (unsigned char *)d;
#line 6752
                  goto while_break___29;
                }
                while_break___29: /* CIL Label */ ;
                }
#line 6754
                goto fail;
              }
            }
          }
        }
      }
    }
#line 6759
    p += 2;
#line 6760
    goto switch_break;
    case_8: /* CIL Label */ 
#line 6768
    tmp___50 = p;
#line 6768
    p ++;
#line 6768
    regno = (int )*tmp___50;
#line 6772
    if ((unsigned long )*(regstart + regno) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6773
      goto fail;
    } else
#line 6772
    if ((unsigned long )*(regend + regno) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6773
      goto fail;
    }
#line 6776
    d2 = *(regstart + regno);
#line 6783
    if (size1) {
#line 6783
      if ((unsigned long )string1 <= (unsigned long )*(regstart + regno)) {
#line 6783
        if ((unsigned long )*(regstart + regno) <= (unsigned long )(string1 + size1)) {
#line 6783
          tmp___52 = 1;
        } else {
#line 6783
          tmp___52 = 0;
        }
      } else {
#line 6783
        tmp___52 = 0;
      }
    } else {
#line 6783
      tmp___52 = 0;
    }
#line 6783
    if (size1) {
#line 6783
      if ((unsigned long )string1 <= (unsigned long )*(regend + regno)) {
#line 6783
        if ((unsigned long )*(regend + regno) <= (unsigned long )(string1 + size1)) {
#line 6783
          tmp___53 = 1;
        } else {
#line 6783
          tmp___53 = 0;
        }
      } else {
#line 6783
        tmp___53 = 0;
      }
    } else {
#line 6783
      tmp___53 = 0;
    }
#line 6783
    if (tmp___52 == tmp___53) {
#line 6783
      dend2 = *(regend + regno);
    } else {
#line 6783
      dend2 = end_match_1;
    }
    {
#line 6786
    while (1) {
      while_continue___32: /* CIL Label */ ;
      {
#line 6790
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 6790
        if (! ((unsigned long )d2 == (unsigned long )dend2)) {
#line 6790
          goto while_break___33;
        }
#line 6792
        if ((unsigned long )dend2 == (unsigned long )end_match_2) {
#line 6792
          goto while_break___33;
        }
#line 6793
        if ((unsigned long )dend2 == (unsigned long )*(regend + regno)) {
#line 6793
          goto while_break___33;
        }
#line 6796
        d2 = string2;
#line 6797
        dend2 = *(regend + regno);
      }
      while_break___33: /* CIL Label */ ;
      }
#line 6800
      if ((unsigned long )d2 == (unsigned long )dend2) {
#line 6800
        goto while_break___32;
      }
      {
#line 6803
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 6803
        if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6803
          goto while_break___34;
        }
#line 6803
        if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6803
          goto fail;
        }
#line 6803
        d = string2;
#line 6803
        dend = end_match_2;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 6806
      mcnt = (int )(dend - d);
#line 6810
      if ((long )mcnt > dend2 - d2) {
#line 6811
        mcnt = (int )(dend2 - d2);
      }
#line 6815
      if (translate) {
        {
#line 6815
        tmp___54 = byte_bcmp_translate(d, d2, mcnt, translate);
#line 6815
        tmp___56 = tmp___54;
        }
      } else {
        {
#line 6815
        tmp___55 = memcmp((void const   *)d, (void const   *)d2, (unsigned long )mcnt * sizeof(unsigned char ));
#line 6815
        tmp___56 = tmp___55;
        }
      }
#line 6815
      if (tmp___56) {
#line 6818
        goto fail;
      }
#line 6819
      d += mcnt;
#line 6819
      d2 += mcnt;
      {
#line 6822
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 6822
        if (! set_regs_matched_done) {
#line 6822
          set_regs_matched_done = 1;
#line 6822
          r___4 = lowest_active_reg;
          {
#line 6822
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 6822
            if (! (r___4 <= highest_active_reg)) {
#line 6822
              goto while_break___36;
            }
#line 6822
            tmp___57 = 1U;
#line 6822
            (reg_info + r___4)->bits.ever_matched_something = tmp___57;
#line 6822
            (reg_info + r___4)->bits.matched_something = tmp___57;
#line 6822
            r___4 ++;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
#line 6822
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 6825
    goto switch_break;
    case_9: /* CIL Label */ ;
#line 6834
    if (size1) {
#line 6834
      tmp___58 = string1;
    } else {
#line 6834
      tmp___58 = string2;
    }
#line 6834
    if ((unsigned long )d == (unsigned long )tmp___58) {
#line 6834
      goto _L___13;
    } else
#line 6834
    if (! size2) {
      _L___13: /* CIL Label */ 
#line 6836
      if (! bufp->not_bol) {
#line 6836
        goto switch_break;
      }
    } else
#line 6838
    if ((int const   )*(d + -1) == 10) {
#line 6838
      if (bufp->newline_anchor) {
#line 6840
        goto switch_break;
      }
    }
#line 6843
    goto fail;
    case_10: /* CIL Label */ ;
#line 6850
    if ((unsigned long )d == (unsigned long )end2) {
#line 6852
      if (! bufp->not_eol) {
#line 6852
        goto switch_break;
      }
    } else {
#line 6856
      if ((unsigned long )d == (unsigned long )end1) {
#line 6856
        tmp___59 = (int const   )*string2;
      } else {
#line 6856
        tmp___59 = (int const   )*d;
      }
#line 6856
      if (tmp___59 == 10) {
#line 6856
        if (bufp->newline_anchor) {
#line 6859
          goto switch_break;
        }
      }
    }
#line 6861
    goto fail;
    case_11: /* CIL Label */ ;
#line 6867
    if (size1) {
#line 6867
      tmp___60 = string1;
    } else {
#line 6867
      tmp___60 = string2;
    }
#line 6867
    if ((unsigned long )d == (unsigned long )tmp___60) {
#line 6868
      goto switch_break;
    } else
#line 6867
    if (! size2) {
#line 6868
      goto switch_break;
    }
#line 6869
    goto fail;
    case_12: /* CIL Label */ ;
#line 6875
    if ((unsigned long )d == (unsigned long )end2) {
#line 6876
      goto switch_break;
    }
#line 6877
    goto fail;
    case_16: /* CIL Label */ ;
    {
#line 6899
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
#line 6899
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 6899
        mcnt = (int )*p & 255;
#line 6899
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6899
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 6899
      p += 2;
#line 6899
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 6906
    while (1) {
      while_continue___39: /* CIL Label */ ;
      {
#line 6906
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 6906
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6906
          goto while_break___40;
        }
#line 6906
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6906
          tmp___64 = 0;
        } else {
          {
#line 6906
          tmp___61 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6906
          destination___0 = (char *)tmp___61;
#line 6906
          tmp___62 = memcpy((void */* __restrict  */)destination___0, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6906
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___62;
          }
#line 6906
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6906
            tmp___63 = 0;
          } else {
#line 6906
            fail_stack.size <<= 1;
#line 6906
            tmp___63 = 1;
          }
#line 6906
          tmp___64 = tmp___63;
        }
#line 6906
        if (! tmp___64) {
#line 6906
          return (-2);
        }
      }
      while_break___40: /* CIL Label */ ;
      }
#line 6906
      this_reg___0 = lowest_active_reg;
      {
#line 6906
      while (1) {
        while_continue___41: /* CIL Label */ ;
#line 6906
        if (! (this_reg___0 <= highest_active_reg)) {
#line 6906
          goto while_break___41;
        }
#line 6906
        tmp___65 = fail_stack.avail;
#line 6906
        (fail_stack.avail) ++;
#line 6906
        (fail_stack.stack + tmp___65)->pointer = (unsigned char *)*(regstart + this_reg___0);
#line 6906
        tmp___66 = fail_stack.avail;
#line 6906
        (fail_stack.avail) ++;
#line 6906
        (fail_stack.stack + tmp___66)->pointer = (unsigned char *)*(regend + this_reg___0);
#line 6906
        tmp___67 = fail_stack.avail;
#line 6906
        (fail_stack.avail) ++;
#line 6906
        *(fail_stack.stack + tmp___67) = (reg_info + this_reg___0)->word;
#line 6906
        this_reg___0 ++;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 6906
      tmp___68 = fail_stack.avail;
#line 6906
      (fail_stack.avail) ++;
#line 6906
      (fail_stack.stack + tmp___68)->integer = (int )lowest_active_reg;
#line 6906
      tmp___69 = fail_stack.avail;
#line 6906
      (fail_stack.avail) ++;
#line 6906
      (fail_stack.stack + tmp___69)->integer = (int )highest_active_reg;
#line 6906
      tmp___70 = fail_stack.avail;
#line 6906
      (fail_stack.avail) ++;
#line 6906
      (fail_stack.stack + tmp___70)->pointer = p + mcnt;
#line 6906
      tmp___71 = fail_stack.avail;
#line 6906
      (fail_stack.avail) ++;
#line 6906
      (fail_stack.stack + tmp___71)->pointer = (unsigned char *)((void *)0);
#line 6906
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 6907
    goto switch_break;
    on_failure: 
    case_15: /* CIL Label */ ;
    {
#line 6926
    while (1) {
      while_continue___42: /* CIL Label */ ;
      {
#line 6926
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 6926
        mcnt = (int )*p & 255;
#line 6926
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6926
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 6926
      p += 2;
#line 6926
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 6942
    p1 = p;
    {
#line 6948
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 6948
      if ((unsigned long )p1 < (unsigned long )pend) {
#line 6948
        if (! ((unsigned int )((re_opcode_t )*p1) == 0U)) {
#line 6948
          goto while_break___44;
        }
      } else {
#line 6948
        goto while_break___44;
      }
#line 6949
      p1 ++;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 6951
    if ((unsigned long )p1 < (unsigned long )pend) {
#line 6951
      if ((unsigned int )((re_opcode_t )*p1) == 6U) {
#line 6957
        highest_active_reg = (active_reg_t )((int )*(p1 + 1) + (int )*(p1 + 2));
#line 6958
        if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 6959
          lowest_active_reg = (active_reg_t )*(p1 + 1);
        }
      }
    }
    {
#line 6963
    while (1) {
      while_continue___45: /* CIL Label */ ;
      {
#line 6963
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 6963
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6963
          goto while_break___46;
        }
#line 6963
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6963
          tmp___75 = 0;
        } else {
          {
#line 6963
          tmp___72 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6963
          destination___1 = (char *)tmp___72;
#line 6963
          tmp___73 = memcpy((void */* __restrict  */)destination___1, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6963
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___73;
          }
#line 6963
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6963
            tmp___74 = 0;
          } else {
#line 6963
            fail_stack.size <<= 1;
#line 6963
            tmp___74 = 1;
          }
#line 6963
          tmp___75 = tmp___74;
        }
#line 6963
        if (! tmp___75) {
#line 6963
          return (-2);
        }
      }
      while_break___46: /* CIL Label */ ;
      }
#line 6963
      this_reg___1 = lowest_active_reg;
      {
#line 6963
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 6963
        if (! (this_reg___1 <= highest_active_reg)) {
#line 6963
          goto while_break___47;
        }
#line 6963
        tmp___76 = fail_stack.avail;
#line 6963
        (fail_stack.avail) ++;
#line 6963
        (fail_stack.stack + tmp___76)->pointer = (unsigned char *)*(regstart + this_reg___1);
#line 6963
        tmp___77 = fail_stack.avail;
#line 6963
        (fail_stack.avail) ++;
#line 6963
        (fail_stack.stack + tmp___77)->pointer = (unsigned char *)*(regend + this_reg___1);
#line 6963
        tmp___78 = fail_stack.avail;
#line 6963
        (fail_stack.avail) ++;
#line 6963
        *(fail_stack.stack + tmp___78) = (reg_info + this_reg___1)->word;
#line 6963
        this_reg___1 ++;
      }
      while_break___47: /* CIL Label */ ;
      }
#line 6963
      tmp___79 = fail_stack.avail;
#line 6963
      (fail_stack.avail) ++;
#line 6963
      (fail_stack.stack + tmp___79)->integer = (int )lowest_active_reg;
#line 6963
      tmp___80 = fail_stack.avail;
#line 6963
      (fail_stack.avail) ++;
#line 6963
      (fail_stack.stack + tmp___80)->integer = (int )highest_active_reg;
#line 6963
      tmp___81 = fail_stack.avail;
#line 6963
      (fail_stack.avail) ++;
#line 6963
      (fail_stack.stack + tmp___81)->pointer = p + mcnt;
#line 6963
      tmp___82 = fail_stack.avail;
#line 6963
      (fail_stack.avail) ++;
#line 6963
      (fail_stack.stack + tmp___82)->pointer = (unsigned char *)d;
#line 6963
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 6964
    goto switch_break;
    case_18___0: /* CIL Label */ 
    {
#line 6970
    while (1) {
      while_continue___48: /* CIL Label */ ;
      {
#line 6970
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 6970
        mcnt = (int )*p & 255;
#line 6970
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6970
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 6970
      p += 2;
#line 6970
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 6973
    p2 = p;
    {
#line 6992
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 6994
      if ((unsigned long )(p2 + 2) < (unsigned long )pend) {
#line 6994
        if ((unsigned int )((re_opcode_t )*p2) == 7U) {
#line 6997
          p2 += 3;
        } else
#line 6994
        if ((unsigned int )((re_opcode_t )*p2) == 6U) {
#line 6997
          p2 += 3;
        } else {
#line 6994
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 6998
      if ((unsigned long )((p2 + 2) + 4) < (unsigned long )pend) {
#line 6998
        if ((unsigned int )((re_opcode_t )*p2) == 19U) {
#line 7000
          p2 += 6;
        } else {
#line 7002
          goto while_break___50;
        }
      } else {
#line 7002
        goto while_break___50;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
#line 7005
    p1 = p + mcnt;
#line 7011
    if ((unsigned long )p2 == (unsigned long )pend) {
#line 7016
      *(p + -3) = (unsigned char)17;
    } else
#line 7022
    if ((unsigned int )((re_opcode_t )*p2) == 2U) {
#line 7022
      goto _L___18;
    } else
#line 7022
    if (bufp->newline_anchor) {
#line 7022
      if ((unsigned int )((re_opcode_t )*p2) == 10U) {
        _L___18: /* CIL Label */ 
#line 7028
        if ((int )*p2 == 10) {
#line 7028
          tmp___83 = '\n';
        } else {
#line 7028
          tmp___83 = (int )*(p2 + 2);
        }
#line 7028
        c___0 = (unsigned char )tmp___83;
#line 7031
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 7031
          if ((int )*(p1 + 5) != (int )c___0) {
#line 7037
            *(p + -3) = (unsigned char)17;
          } else {
#line 7031
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 7051
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 7051
          goto _L___15;
        } else
#line 7051
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
          _L___15: /* CIL Label */ 
#line 7054
          negate___0 = (unsigned int )((re_opcode_t )*(p1 + 3)) == 5U;
#line 7056
          if ((unsigned int )c___0 < (unsigned int )((int )*(p1 + 4) * 8)) {
#line 7056
            if ((int )*(p1 + (5 + (int )c___0 / 8)) & (1 << (int )c___0 % 8)) {
#line 7058
              negate___0 = ! negate___0;
            }
          }
#line 7062
          if (! negate___0) {
#line 7064
            *(p + -3) = (unsigned char)17;
          }
        }
      } else {
#line 7022
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 7071
    if ((unsigned int )((re_opcode_t )*p2) == 4U) {
#line 7075
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 7075
        if ((int )*(p2 + 1) * 8 > (int )*(p1 + 5)) {
#line 7075
          if ((int )*(p2 + (2 + (int )*(p1 + 5) / 8)) & (1 << (int )*(p1 + 5) % 8)) {
#line 7075
            goto _L___17;
          } else {
#line 7080
            *(p + -3) = (unsigned char)17;
          }
        } else {
#line 7080
          *(p + -3) = (unsigned char)17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 7084
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
#line 7089
        idx___0 = 0;
        {
#line 7089
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 7089
          if (! (idx___0 < (int )*(p2 + 1))) {
#line 7089
            goto while_break___51;
          }
#line 7090
          if (! ((int )*(p2 + (2 + idx___0)) == 0)) {
#line 7090
            if (idx___0 < (int )*(p1 + 4)) {
#line 7090
              if (! (((int )*(p2 + (2 + idx___0)) & ~ ((int )*(p1 + (5 + idx___0)))) == 0)) {
#line 7093
                goto while_break___51;
              }
            } else {
#line 7093
              goto while_break___51;
            }
          }
#line 7089
          idx___0 ++;
        }
        while_break___51: /* CIL Label */ ;
        }
#line 7095
        if (idx___0 == (int )*(p2 + 1)) {
#line 7097
          *(p + -3) = (unsigned char)17;
        }
      } else
#line 7101
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 7106
        idx___1 = 0;
        {
#line 7106
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 7106
          if (idx___1 < (int )*(p2 + 1)) {
#line 7106
            if (! (idx___1 < (int )*(p1 + 4))) {
#line 7106
              goto while_break___52;
            }
          } else {
#line 7106
            goto while_break___52;
          }
#line 7109
          if (((int )*(p2 + (2 + idx___1)) & (int )*(p1 + (5 + idx___1))) != 0) {
#line 7110
            goto while_break___52;
          }
#line 7106
          idx___1 ++;
        }
        while_break___52: /* CIL Label */ ;
        }
#line 7112
        if (idx___1 == (int )*(p2 + 1)) {
#line 7114
          *(p + -3) = (unsigned char)17;
        } else
#line 7112
        if (idx___1 == (int )*(p1 + 4)) {
#line 7114
          *(p + -3) = (unsigned char)17;
        }
      }
    }
#line 7121
    p -= 2;
#line 7122
    if ((unsigned int )((re_opcode_t )*(p + -1)) != 17U) {
#line 7124
      *(p + -1) = (unsigned char)13;
#line 7126
      goto unconditional_jump;
    }
    case_17___0: /* CIL Label */ 
#line 7145
    pdummy = (unsigned char *)((void *)0);
#line 7146
    sdummy = (char const   *)((void *)0);
#line 7149
    (fail_stack.avail) --;
#line 7149
    string_temp = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7149
    if ((unsigned long )string_temp != (unsigned long )((void *)0)) {
#line 7149
      sdummy = (char const   *)string_temp;
    }
#line 7149
    (fail_stack.avail) --;
#line 7149
    pdummy = (fail_stack.stack + fail_stack.avail)->pointer;
#line 7149
    (fail_stack.avail) --;
#line 7149
    dummy_high_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7149
    (fail_stack.avail) --;
#line 7149
    dummy_low_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7149
    this_reg___2 = dummy_high_reg;
    {
#line 7149
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 7149
      if (! (this_reg___2 >= dummy_low_reg)) {
#line 7149
        goto while_break___53;
      }
#line 7149
      (fail_stack.avail) --;
#line 7149
      (reg_info_dummy + this_reg___2)->word = *(fail_stack.stack + fail_stack.avail);
#line 7149
      (fail_stack.avail) --;
#line 7149
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7149
      (fail_stack.avail) --;
#line 7149
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7149
      this_reg___2 --;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 7149
    set_regs_matched_done = 0;
    unconditional_jump: ;
    case_13___0: /* CIL Label */ 
    {
#line 7165
    while (1) {
      while_continue___54: /* CIL Label */ ;
      {
#line 7165
      while (1) {
        while_continue___55: /* CIL Label */ ;
#line 7165
        mcnt = (int )*p & 255;
#line 7165
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7165
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
#line 7165
      p += 2;
#line 7165
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
#line 7167
    p += mcnt;
#line 7173
    goto switch_break;
    case_14: /* CIL Label */ ;
#line 7180
    goto unconditional_jump;
    case_19___0: /* CIL Label */ ;
    {
#line 7192
    while (1) {
      while_continue___56: /* CIL Label */ ;
      {
#line 7192
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 7192
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 7192
          goto while_break___57;
        }
#line 7192
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 7192
          tmp___87 = 0;
        } else {
          {
#line 7192
          tmp___84 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 7192
          destination___2 = (char *)tmp___84;
#line 7192
          tmp___85 = memcpy((void */* __restrict  */)destination___2, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 7192
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___85;
          }
#line 7192
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 7192
            tmp___86 = 0;
          } else {
#line 7192
            fail_stack.size <<= 1;
#line 7192
            tmp___86 = 1;
          }
#line 7192
          tmp___87 = tmp___86;
        }
#line 7192
        if (! tmp___87) {
#line 7192
          return (-2);
        }
      }
      while_break___57: /* CIL Label */ ;
      }
#line 7192
      this_reg___3 = lowest_active_reg;
      {
#line 7192
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 7192
        if (! (this_reg___3 <= highest_active_reg)) {
#line 7192
          goto while_break___58;
        }
#line 7192
        tmp___88 = fail_stack.avail;
#line 7192
        (fail_stack.avail) ++;
#line 7192
        (fail_stack.stack + tmp___88)->pointer = (unsigned char *)*(regstart + this_reg___3);
#line 7192
        tmp___89 = fail_stack.avail;
#line 7192
        (fail_stack.avail) ++;
#line 7192
        (fail_stack.stack + tmp___89)->pointer = (unsigned char *)*(regend + this_reg___3);
#line 7192
        tmp___90 = fail_stack.avail;
#line 7192
        (fail_stack.avail) ++;
#line 7192
        *(fail_stack.stack + tmp___90) = (reg_info + this_reg___3)->word;
#line 7192
        this_reg___3 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 7192
      tmp___91 = fail_stack.avail;
#line 7192
      (fail_stack.avail) ++;
#line 7192
      (fail_stack.stack + tmp___91)->integer = (int )lowest_active_reg;
#line 7192
      tmp___92 = fail_stack.avail;
#line 7192
      (fail_stack.avail) ++;
#line 7192
      (fail_stack.stack + tmp___92)->integer = (int )highest_active_reg;
#line 7192
      tmp___93 = fail_stack.avail;
#line 7192
      (fail_stack.avail) ++;
#line 7192
      (fail_stack.stack + tmp___93)->pointer = (unsigned char *)((void *)0);
#line 7192
      tmp___94 = fail_stack.avail;
#line 7192
      (fail_stack.avail) ++;
#line 7192
      (fail_stack.stack + tmp___94)->pointer = (unsigned char *)((void *)0);
#line 7192
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
#line 7193
    goto unconditional_jump;
    case_20: /* CIL Label */ ;
    {
#line 7205
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 7205
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 7205
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 7205
          goto while_break___60;
        }
#line 7205
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 7205
          tmp___98 = 0;
        } else {
          {
#line 7205
          tmp___95 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 7205
          destination___3 = (char *)tmp___95;
#line 7205
          tmp___96 = memcpy((void */* __restrict  */)destination___3, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 7205
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___96;
          }
#line 7205
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 7205
            tmp___97 = 0;
          } else {
#line 7205
            fail_stack.size <<= 1;
#line 7205
            tmp___97 = 1;
          }
#line 7205
          tmp___98 = tmp___97;
        }
#line 7205
        if (! tmp___98) {
#line 7205
          return (-2);
        }
      }
      while_break___60: /* CIL Label */ ;
      }
#line 7205
      this_reg___4 = lowest_active_reg;
      {
#line 7205
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 7205
        if (! (this_reg___4 <= highest_active_reg)) {
#line 7205
          goto while_break___61;
        }
#line 7205
        tmp___99 = fail_stack.avail;
#line 7205
        (fail_stack.avail) ++;
#line 7205
        (fail_stack.stack + tmp___99)->pointer = (unsigned char *)*(regstart + this_reg___4);
#line 7205
        tmp___100 = fail_stack.avail;
#line 7205
        (fail_stack.avail) ++;
#line 7205
        (fail_stack.stack + tmp___100)->pointer = (unsigned char *)*(regend + this_reg___4);
#line 7205
        tmp___101 = fail_stack.avail;
#line 7205
        (fail_stack.avail) ++;
#line 7205
        *(fail_stack.stack + tmp___101) = (reg_info + this_reg___4)->word;
#line 7205
        this_reg___4 ++;
      }
      while_break___61: /* CIL Label */ ;
      }
#line 7205
      tmp___102 = fail_stack.avail;
#line 7205
      (fail_stack.avail) ++;
#line 7205
      (fail_stack.stack + tmp___102)->integer = (int )lowest_active_reg;
#line 7205
      tmp___103 = fail_stack.avail;
#line 7205
      (fail_stack.avail) ++;
#line 7205
      (fail_stack.stack + tmp___103)->integer = (int )highest_active_reg;
#line 7205
      tmp___104 = fail_stack.avail;
#line 7205
      (fail_stack.avail) ++;
#line 7205
      (fail_stack.stack + tmp___104)->pointer = (unsigned char *)((void *)0);
#line 7205
      tmp___105 = fail_stack.avail;
#line 7205
      (fail_stack.avail) ++;
#line 7205
      (fail_stack.stack + tmp___105)->pointer = (unsigned char *)((void *)0);
#line 7205
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 7206
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 7211
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 7211
      mcnt = (int )*(p + 2) & 255;
#line 7211
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 7211
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 7216
    if (mcnt > 0) {
#line 7218
      mcnt --;
#line 7219
      p += 2;
      {
#line 7220
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
#line 7220
        while (1) {
          while_continue___64: /* CIL Label */ ;
#line 7220
          *(p + 0) = (unsigned char )(mcnt & 255);
#line 7220
          *(p + 1) = (unsigned char )(mcnt >> 8);
#line 7220
          goto while_break___64;
        }
        while_break___64: /* CIL Label */ ;
        }
#line 7220
        p += 2;
#line 7220
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
    } else
#line 7229
    if (mcnt == 0) {
#line 7242
      *(p + 2) = (unsigned char)0;
#line 7243
      *(p + 3) = (unsigned char)0;
#line 7245
      goto on_failure;
    }
#line 7247
    goto switch_break;
    case_22___0: /* CIL Label */ 
    {
#line 7250
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 7250
      mcnt = (int )*(p + 2) & 255;
#line 7250
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 7250
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
#line 7254
    if (mcnt) {
#line 7256
      mcnt --;
      {
#line 7257
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 7257
        *((p + 2) + 0) = (unsigned char )(mcnt & 255);
#line 7257
        *((p + 2) + 1) = (unsigned char )(mcnt >> 8);
#line 7257
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 7266
      goto unconditional_jump;
    } else {
#line 7270
      p += 4;
    }
#line 7271
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 7277
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
#line 7277
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 7277
        mcnt = (int )*p & 255;
#line 7277
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7277
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
#line 7277
      p += 2;
#line 7277
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 7278
    p1 = p + mcnt;
    {
#line 7279
    while (1) {
      while_continue___69: /* CIL Label */ ;
      {
#line 7279
      while (1) {
        while_continue___70: /* CIL Label */ ;
#line 7279
        mcnt = (int )*p & 255;
#line 7279
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7279
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
#line 7279
      p += 2;
#line 7279
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 7285
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 7285
      *(p1 + 0) = (unsigned char )(mcnt & 255);
#line 7285
      *(p1 + 1) = (unsigned char )(mcnt >> 8);
#line 7285
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 7286
    goto switch_break;
    case_28: /* CIL Label */ 
#line 7312
    if (size1) {
#line 7312
      tmp___106 = string1;
    } else {
#line 7312
      tmp___106 = string2;
    }
#line 7312
    if ((unsigned long )d == (unsigned long )tmp___106) {
#line 7313
      goto switch_break;
    } else
#line 7312
    if (! size2) {
#line 7313
      goto switch_break;
    } else
#line 7312
    if ((unsigned long )d == (unsigned long )end2) {
#line 7313
      goto switch_break;
    }
#line 7315
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7315
      tmp___108 = (int const   )*string2;
    } else {
#line 7315
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7315
        tmp___107 = (int const   )*(end1 - 1);
      } else {
#line 7315
        tmp___107 = (int const   )*(d - 1);
      }
#line 7315
      tmp___108 = tmp___107;
    }
#line 7315
    prevchar = (boolean )((int )re_syntax_table[(unsigned char )tmp___108] == 1);
#line 7316
    if ((unsigned long )d == (unsigned long )end1) {
#line 7316
      tmp___110 = (int const   )*string2;
    } else {
#line 7316
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7316
        tmp___109 = (int const   )*(end1 - 1);
      } else {
#line 7316
        tmp___109 = (int const   )*d;
      }
#line 7316
      tmp___110 = tmp___109;
    }
#line 7316
    thischar = (boolean )((int )re_syntax_table[(unsigned char )tmp___110] == 1);
#line 7317
    if ((int )prevchar != (int )thischar) {
#line 7318
      goto switch_break;
    }
#line 7319
    goto fail;
    case_29: /* CIL Label */ 
#line 7327
    if (size1) {
#line 7327
      tmp___111 = string1;
    } else {
#line 7327
      tmp___111 = string2;
    }
#line 7327
    if ((unsigned long )d == (unsigned long )tmp___111) {
#line 7328
      goto fail;
    } else
#line 7327
    if (! size2) {
#line 7328
      goto fail;
    } else
#line 7327
    if ((unsigned long )d == (unsigned long )end2) {
#line 7328
      goto fail;
    }
#line 7330
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7330
      tmp___113 = (int const   )*string2;
    } else {
#line 7330
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7330
        tmp___112 = (int const   )*(end1 - 1);
      } else {
#line 7330
        tmp___112 = (int const   )*(d - 1);
      }
#line 7330
      tmp___113 = tmp___112;
    }
#line 7330
    prevchar___0 = (boolean )((int )re_syntax_table[(unsigned char )tmp___113] == 1);
#line 7331
    if ((unsigned long )d == (unsigned long )end1) {
#line 7331
      tmp___115 = (int const   )*string2;
    } else {
#line 7331
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7331
        tmp___114 = (int const   )*(end1 - 1);
      } else {
#line 7331
        tmp___114 = (int const   )*d;
      }
#line 7331
      tmp___115 = tmp___114;
    }
#line 7331
    thischar___0 = (boolean )((int )re_syntax_table[(unsigned char )tmp___115] == 1);
#line 7332
    if ((int )prevchar___0 != (int )thischar___0) {
#line 7333
      goto fail;
    }
#line 7334
    goto switch_break;
    case_26: /* CIL Label */ ;
#line 7340
    if (! ((unsigned long )d == (unsigned long )end2)) {
#line 7340
      if ((unsigned long )d == (unsigned long )end1) {
#line 7340
        tmp___117 = (int const   )*string2;
      } else {
#line 7340
        if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7340
          tmp___116 = (int const   )*(end1 - 1);
        } else {
#line 7340
          tmp___116 = (int const   )*d;
        }
#line 7340
        tmp___117 = tmp___116;
      }
#line 7340
      if ((int )re_syntax_table[(unsigned char )tmp___117] == 1) {
#line 7340
        if (size1) {
#line 7340
          tmp___118 = string1;
        } else {
#line 7340
          tmp___118 = string2;
        }
#line 7340
        if ((unsigned long )d == (unsigned long )tmp___118) {
#line 7342
          goto switch_break;
        } else
#line 7340
        if (! size2) {
#line 7342
          goto switch_break;
        } else {
#line 7340
          if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7340
            tmp___120 = (int const   )*string2;
          } else {
#line 7340
            if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7340
              tmp___119 = (int const   )*(end1 - 1);
            } else {
#line 7340
              tmp___119 = (int const   )*(d - 1);
            }
#line 7340
            tmp___120 = tmp___119;
          }
#line 7340
          if (! ((int )re_syntax_table[(unsigned char )tmp___120] == 1)) {
#line 7342
            goto switch_break;
          }
        }
      }
    }
#line 7343
    goto fail;
    case_27: /* CIL Label */ ;
#line 7347
    if (size1) {
#line 7347
      tmp___121 = string1;
    } else {
#line 7347
      tmp___121 = string2;
    }
#line 7347
    if (! ((unsigned long )d == (unsigned long )tmp___121)) {
#line 7347
      if (! (! size2)) {
#line 7347
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7347
          tmp___123 = (int const   )*string2;
        } else {
#line 7347
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7347
            tmp___122 = (int const   )*(end1 - 1);
          } else {
#line 7347
            tmp___122 = (int const   )*(d - 1);
          }
#line 7347
          tmp___123 = tmp___122;
        }
#line 7347
        if ((int )re_syntax_table[(unsigned char )tmp___123] == 1) {
#line 7347
          if ((unsigned long )d == (unsigned long )end2) {
#line 7349
            goto switch_break;
          } else {
#line 7347
            if ((unsigned long )d == (unsigned long )end1) {
#line 7347
              tmp___125 = (int const   )*string2;
            } else {
#line 7347
              if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7347
                tmp___124 = (int const   )*(end1 - 1);
              } else {
#line 7347
                tmp___124 = (int const   )*d;
              }
#line 7347
              tmp___125 = tmp___124;
            }
#line 7347
            if (! ((int )re_syntax_table[(unsigned char )tmp___125] == 1)) {
#line 7349
              goto switch_break;
            }
          }
        }
      }
    }
#line 7350
    goto fail;
    case_24: /* CIL Label */ ;
    {
#line 7408
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 7408
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 7408
        goto while_break___72;
      }
#line 7408
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 7408
        goto fail;
      }
#line 7408
      d = string2;
#line 7408
      dend = end_match_2;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 7409
    if ((unsigned long )d == (unsigned long )end1) {
#line 7409
      tmp___127 = (int const   )*string2;
    } else {
#line 7409
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7409
        tmp___126 = (int const   )*(end1 - 1);
      } else {
#line 7409
        tmp___126 = (int const   )*d;
      }
#line 7409
      tmp___127 = tmp___126;
    }
#line 7409
    if (! ((int )re_syntax_table[(unsigned char )tmp___127] == 1)) {
#line 7410
      goto fail;
    }
    {
#line 7411
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 7411
      if (! set_regs_matched_done) {
#line 7411
        set_regs_matched_done = 1;
#line 7411
        r___5 = lowest_active_reg;
        {
#line 7411
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 7411
          if (! (r___5 <= highest_active_reg)) {
#line 7411
            goto while_break___74;
          }
#line 7411
          tmp___128 = 1U;
#line 7411
          (reg_info + r___5)->bits.ever_matched_something = tmp___128;
#line 7411
          (reg_info + r___5)->bits.matched_something = tmp___128;
#line 7411
          r___5 ++;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
#line 7411
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
#line 7412
    d ++;
#line 7413
    goto switch_break;
    case_25: /* CIL Label */ ;
    {
#line 7417
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 7417
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 7417
        goto while_break___75;
      }
#line 7417
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 7417
        goto fail;
      }
#line 7417
      d = string2;
#line 7417
      dend = end_match_2;
    }
    while_break___75: /* CIL Label */ ;
    }
#line 7418
    if ((unsigned long )d == (unsigned long )end1) {
#line 7418
      tmp___130 = (int const   )*string2;
    } else {
#line 7418
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7418
        tmp___129 = (int const   )*(end1 - 1);
      } else {
#line 7418
        tmp___129 = (int const   )*d;
      }
#line 7418
      tmp___130 = tmp___129;
    }
#line 7418
    if ((int )re_syntax_table[(unsigned char )tmp___130] == 1) {
#line 7419
      goto fail;
    }
    {
#line 7420
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 7420
      if (! set_regs_matched_done) {
#line 7420
        set_regs_matched_done = 1;
#line 7420
        r___6 = lowest_active_reg;
        {
#line 7420
        while (1) {
          while_continue___77: /* CIL Label */ ;
#line 7420
          if (! (r___6 <= highest_active_reg)) {
#line 7420
            goto while_break___77;
          }
#line 7420
          tmp___131 = 1U;
#line 7420
          (reg_info + r___6)->bits.ever_matched_something = tmp___131;
#line 7420
          (reg_info + r___6)->bits.matched_something = tmp___131;
#line 7420
          r___6 ++;
        }
        while_break___77: /* CIL Label */ ;
        }
      }
#line 7420
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 7421
    d ++;
#line 7422
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 7426
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 7428
    goto __Cont;
    fail: 
#line 7433
    if (! (fail_stack.avail == 0U)) {
#line 7436
      (fail_stack.avail) --;
#line 7436
      string_temp___0 = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7436
      if ((unsigned long )string_temp___0 != (unsigned long )((void *)0)) {
#line 7436
        d = (char const   *)string_temp___0;
      }
#line 7436
      (fail_stack.avail) --;
#line 7436
      p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 7436
      (fail_stack.avail) --;
#line 7436
      highest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7436
      (fail_stack.avail) --;
#line 7436
      lowest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7436
      this_reg___5 = highest_active_reg;
      {
#line 7436
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 7436
        if (! (this_reg___5 >= lowest_active_reg)) {
#line 7436
          goto while_break___78;
        }
#line 7436
        (fail_stack.avail) --;
#line 7436
        (reg_info + this_reg___5)->word = *(fail_stack.stack + fail_stack.avail);
#line 7436
        (fail_stack.avail) --;
#line 7436
        *(regend + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7436
        (fail_stack.avail) --;
#line 7436
        *(regstart + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7436
        this_reg___5 --;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 7436
      set_regs_matched_done = 0;
#line 7441
      if (! p) {
#line 7442
        goto fail;
      }
#line 7446
      if ((unsigned long )p < (unsigned long )pend) {
#line 7448
        is_a_jump_n___0 = (boolean )0;
        {
#line 7454
        if ((unsigned int )((re_opcode_t )*p) == 22U) {
#line 7454
          goto case_22___1;
        }
#line 7458
        if ((unsigned int )((re_opcode_t )*p) == 13U) {
#line 7458
          goto case_13___1;
        }
#line 7458
        if ((unsigned int )((re_opcode_t )*p) == 17U) {
#line 7458
          goto case_13___1;
        }
#line 7458
        if ((unsigned int )((re_opcode_t )*p) == 18U) {
#line 7458
          goto case_13___1;
        }
#line 7468
        goto switch_default___1;
        case_22___1: /* CIL Label */ 
#line 7455
        is_a_jump_n___0 = (boolean )1;
        case_13___1: /* CIL Label */ 
        case_17___1: /* CIL Label */ 
        case_18___1: /* CIL Label */ 
#line 7459
        p1 = p + 1;
        {
#line 7460
        while (1) {
          while_continue___79: /* CIL Label */ ;
          {
#line 7460
          while (1) {
            while_continue___80: /* CIL Label */ ;
#line 7460
            mcnt = (int )*p1 & 255;
#line 7460
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7460
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
#line 7460
          p1 += 2;
#line 7460
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
#line 7461
        p1 += mcnt;
#line 7463
        if (is_a_jump_n___0) {
#line 7463
          if ((unsigned int )((re_opcode_t )*p1) == 21U) {
#line 7466
            goto fail;
          } else {
#line 7463
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 7463
        if (! is_a_jump_n___0) {
#line 7463
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7466
            goto fail;
          }
        }
#line 7467
        goto switch_break___1;
        switch_default___1: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 7473
      if ((unsigned long )d >= (unsigned long )string1) {
#line 7473
        if ((unsigned long )d <= (unsigned long )end1) {
#line 7474
          dend = end_match_1;
        }
      }
    } else {
#line 7477
      goto while_break___3;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 7480
  if (best_regs_set) {
#line 7481
    goto restore_best_regs;
  }
  {
#line 7483
  while (1) {
    while_continue___81: /* CIL Label */ ;
#line 7483
    regstart = (char const   **)((void *)0);
#line 7483
    regend = (char const   **)((void *)0);
#line 7483
    old_regstart = (char const   **)((void *)0);
#line 7483
    old_regend = (char const   **)((void *)0);
#line 7483
    best_regstart = (char const   **)((void *)0);
#line 7483
    best_regend = (char const   **)((void *)0);
#line 7483
    reg_info = (byte_register_info_type *)((void *)0);
#line 7483
    reg_dummy = (char const   **)((void *)0);
#line 7483
    reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 7483
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
#line 7485
  return (-1);
}
}
#line 7501 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean byte_group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                              byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;

  {
#line 7507
  p1 = *p + 2;
  {
#line 7509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7509
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 7509
      goto while_break;
    }
    {
#line 7518
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7518
      goto case_15;
    }
#line 7592
    if ((unsigned int )((re_opcode_t )*p1) == 7U) {
#line 7592
      goto case_7;
    }
#line 7598
    goto switch_default;
    case_15: /* CIL Label */ 
#line 7519
    p1 ++;
    {
#line 7520
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 7520
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7520
        mcnt = (int )*p1 & 255;
#line 7520
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7520
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 7520
      p1 += 2;
#line 7520
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7525
    if (mcnt >= 0) {
      {
#line 7545
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 7545
        if (! ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) == 14U)) {
#line 7545
          goto while_break___2;
        }
        {
#line 7552
        tmp___0 = byte_alt_match_null_string_p(p1, (p1 + mcnt) - 3, reg_info);
        }
#line 7552
        if (! tmp___0) {
#line 7555
          return ((boolean )0);
        }
#line 7559
        p1 += mcnt;
#line 7563
        if ((unsigned int )((re_opcode_t )*p1) != 15U) {
#line 7564
          goto while_break___2;
        }
#line 7568
        p1 ++;
        {
#line 7569
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 7569
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 7569
            mcnt = (int )*p1 & 255;
#line 7569
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7569
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 7569
          p1 += 2;
#line 7569
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 7570
        if ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) != 14U) {
#line 7574
          p1 -= 3;
#line 7575
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 7582
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 7582
        mcnt = (int )*(p1 - 2) & 255;
#line 7582
        mcnt += (int )((signed char )*((p1 - 2) + 1)) << 8;
#line 7582
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 7584
      tmp___1 = byte_alt_match_null_string_p(p1, p1 + mcnt, reg_info);
      }
#line 7584
      if (! tmp___1) {
#line 7585
        return ((boolean )0);
      }
#line 7587
      p1 += mcnt;
    }
#line 7589
    goto switch_break;
    case_7: /* CIL Label */ 
#line 7594
    *p = p1 + 2;
#line 7595
    return ((boolean )1);
    switch_default: /* CIL Label */ 
    {
#line 7599
    tmp___2 = byte_common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 7599
    if (! tmp___2) {
#line 7600
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7604
  return ((boolean )0);
}
}
#line 7612 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean byte_alt_match_null_string_p(unsigned char *p , unsigned char *end ,
                                            byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp___0 ;

  {
#line 7617
  p1 = p;
  {
#line 7619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7619
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 7619
      goto while_break;
    }
    {
#line 7627
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7627
      goto case_15;
    }
#line 7633
    goto switch_default;
    case_15: /* CIL Label */ 
#line 7628
    p1 ++;
    {
#line 7629
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 7629
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7629
        mcnt = (int )*p1 & 255;
#line 7629
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7629
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 7629
      p1 += 2;
#line 7629
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7630
    p1 += mcnt;
#line 7631
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 7634
    tmp___0 = byte_common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 7634
    if (! tmp___0) {
#line 7635
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7639
  return ((boolean )1);
}
}
#line 7648 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean byte_common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                                  byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  boolean ret ;
  int reg_no ;
  unsigned char *p1 ;
  unsigned char *tmp___0 ;

  {
#line 7655
  p1 = *p;
#line 7657
  tmp___0 = p1;
#line 7657
  p1 ++;
  {
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 29U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 28U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 27U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 26U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 12U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 11U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 10U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 9U) {
#line 7667
    goto case_29;
  }
#line 7667
  if ((unsigned int )((re_opcode_t )*tmp___0) == 0U) {
#line 7667
    goto case_29;
  }
#line 7675
  if ((unsigned int )((re_opcode_t )*tmp___0) == 6U) {
#line 7675
    goto case_6;
  }
#line 7691
  if ((unsigned int )((re_opcode_t )*tmp___0) == 13U) {
#line 7691
    goto case_13;
  }
#line 7699
  if ((unsigned int )((re_opcode_t )*tmp___0) == 21U) {
#line 7699
    goto case_21;
  }
#line 7714
  if ((unsigned int )((re_opcode_t )*tmp___0) == 8U) {
#line 7714
    goto case_8;
  }
#line 7719
  if ((unsigned int )((re_opcode_t )*tmp___0) == 23U) {
#line 7719
    goto case_23;
  }
#line 7722
  goto switch_default;
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 7673
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 7676
  reg_no = (int )*p1;
#line 7678
  ret = byte_group_match_null_string_p(& p1, end, reg_info);
  }
#line 7683
  if ((reg_info + reg_no)->bits.match_null_string_p == 3U) {
#line 7684
    (reg_info + reg_no)->bits.match_null_string_p = (unsigned int )ret;
  }
#line 7686
  if (! ret) {
#line 7687
    return ((boolean )0);
  }
#line 7688
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 7692
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 7692
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7692
      mcnt = (int )*p1 & 255;
#line 7692
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7692
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7692
    p1 += 2;
#line 7692
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 7693
  if (mcnt >= 0) {
#line 7694
    p1 += mcnt;
  } else {
#line 7696
    return ((boolean )0);
  }
#line 7697
  goto switch_break;
  case_21: /* CIL Label */ 
#line 7701
  p1 += 2;
  {
#line 7702
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 7702
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7702
      mcnt = (int )*p1 & 255;
#line 7702
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7702
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 7702
    p1 += 2;
#line 7702
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 7704
  if (mcnt == 0) {
#line 7706
    p1 -= 4;
    {
#line 7707
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 7707
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 7707
        mcnt = (int )*p1 & 255;
#line 7707
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7707
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 7707
      p1 += 2;
#line 7707
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 7708
    p1 += mcnt;
  } else {
#line 7711
    return ((boolean )0);
  }
#line 7712
  goto switch_break;
  case_8: /* CIL Label */ 
#line 7715
  if (! (reg_info + *p1)->bits.match_null_string_p) {
#line 7716
    return ((boolean )0);
  }
#line 7717
  goto switch_break;
  case_23: /* CIL Label */ 
#line 7720
  p1 += 4;
  switch_default: /* CIL Label */ 
#line 7724
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
#line 7727
  *p = p1;
#line 7728
  return ((boolean )1);
}
}
#line 7735 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static int byte_bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 7739
  p1 = (unsigned char const   *)s1;
#line 7740
  p2 = (unsigned char const   *)s2;
  {
#line 7741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7741
    if (! len) {
#line 7741
      goto while_break;
    }
#line 7748
    tmp___0 = p1;
#line 7748
    p1 ++;
#line 7748
    tmp___1 = p2;
#line 7748
    p2 ++;
#line 7748
    if ((int )*(translate + *tmp___0) != (int )*(translate + *tmp___1)) {
#line 7748
      return (1);
    }
#line 7750
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 7752
  return (0);
}
}
#line 1325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
reg_syntax_t xre_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 1328
  ret = xre_syntax_options;
#line 1330
  xre_syntax_options = syntax;
#line 1337
  return (ret);
}
}
#line 1348 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static char const   *re_error_msgid[17]  = 
#line 1348
  {      "Success",      "No match",      "Invalid regular expression",      "Invalid collation character", 
        "Invalid character class name",      "Trailing backslash",      "Invalid back reference",      "Unmatched [ or [^", 
        "Unmatched ( or \\(",      "Unmatched \\{",      "Invalid content of \\{\\}",      "Invalid range end", 
        "Memory exhausted",      "Invalid preceding regular expression",      "Premature end of regular expression",      "Regular expression too big", 
        "Unmatched ) or \\)"};
#line 4328 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) 
{ 
  int this_element ;

  {
#line 4333
  this_element = (int )(compile_stack.avail - 1U);
  {
#line 4333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4333
    if (! (this_element >= 0)) {
#line 4333
      goto while_break;
    }
#line 4336
    if ((compile_stack.stack + this_element)->regnum == regnum) {
#line 4337
      return ((boolean )1);
    }
#line 4333
    this_element --;
  }
  while_break: /* CIL Label */ ;
  }
#line 4339
  return ((boolean )0);
}
}
#line 4861 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int tmp___0 ;

  {
  {
#line 4869
  tmp___0 = byte_re_compile_fastmap(bufp);
  }
#line 4869
  return (tmp___0);
}
}
#line 4889 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
void xre_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                       unsigned int num_regs , xregoff_t *starts , xregoff_t *ends ) 
{ 
  xregoff_t *tmp___0 ;

  {
#line 4894
  if (num_regs) {
#line 4896
    bufp->regs_allocated = 1U;
#line 4897
    regs->num_regs = num_regs;
#line 4898
    regs->start = starts;
#line 4899
    regs->end = ends;
  } else {
#line 4903
    bufp->regs_allocated = 0U;
#line 4904
    regs->num_regs = 0U;
#line 4905
    tmp___0 = (xregoff_t *)0;
#line 4905
    regs->end = tmp___0;
#line 4905
    regs->start = tmp___0;
  }
#line 4907
  return;
}
}
#line 4917 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_search(struct re_pattern_buffer *bufp , char const   *string , int size ,
               int startpos , int range , struct re_registers *regs ) 
{ 
  int tmp___0 ;

  {
  {
#line 4921
  tmp___0 = xre_search_2(bufp, (char const   *)((void *)0), 0, string, size, startpos,
                         range, regs, size);
  }
#line 4921
  return (tmp___0);
}
}
#line 4950 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                 char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                 int stop ) 
{ 
  int tmp___0 ;

  {
  {
#line 4961
  tmp___0 = byte_re_search_2(bufp, string1, size1, string2, size2, startpos, range,
                             regs, stop);
  }
#line 4961
  return (tmp___0);
}
}
#line 5394 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
              struct re_registers *regs ) 
{ 
  int result ;

  {
  {
#line 5406
  result = byte_re_match_2_internal(bufp, (char const   *)((void *)0), 0, string,
                                    size, pos, regs, size);
  }
#line 5413
  return (result);
}
}
#line 5449 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int pos , struct re_registers *regs ,
                int stop ) 
{ 
  int result ;

  {
  {
#line 5462
  result = byte_re_match_2_internal(bufp, string1, size1, string2, size2, pos, regs,
                                    stop);
  }
#line 5470
  return (result);
}
}
#line 7769 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
char const   *xre_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;

  {
  {
#line 7777
  bufp->regs_allocated = 0U;
#line 7782
  bufp->no_sub = 0U;
#line 7785
  bufp->newline_anchor = 1U;
#line 7792
  ret = byte_regex_compile(pattern, length, xre_syntax_options, bufp);
  }
#line 7794
  if (! ret) {
#line 7795
    return ((char const   *)((void *)0));
  }
#line 7796
  return (re_error_msgid[(int )ret]);
}
}
#line 7808 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
static struct re_pattern_buffer re_comp_buf  ;
#line 7810 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
char *xre_comp(char const   *s ) 
{ 
  reg_errcode_t ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 7821
  if (! s) {
#line 7823
    if (! re_comp_buf.buffer) {
#line 7824
      return ((char *)"No previous regular expression");
    }
#line 7825
    return ((char *)0);
  }
#line 7828
  if (! re_comp_buf.buffer) {
    {
#line 7830
    tmp___0 = malloc((size_t )200);
#line 7830
    re_comp_buf.buffer = (unsigned char *)tmp___0;
    }
#line 7831
    if ((unsigned long )re_comp_buf.buffer == (unsigned long )((void *)0)) {
#line 7832
      return ((char *)re_error_msgid[12]);
    }
    {
#line 7833
    re_comp_buf.allocated = 200UL;
#line 7835
    tmp___1 = malloc((size_t )(1 << 8));
#line 7835
    re_comp_buf.fastmap = (char *)tmp___1;
    }
#line 7836
    if ((unsigned long )re_comp_buf.fastmap == (unsigned long )((void *)0)) {
#line 7837
      return ((char *)re_error_msgid[12]);
    }
  }
  {
#line 7844
  re_comp_buf.newline_anchor = 1U;
#line 7851
  tmp___2 = strlen(s);
#line 7851
  ret = byte_regex_compile(s, tmp___2, xre_syntax_options, & re_comp_buf);
  }
#line 7853
  if (! ret) {
#line 7854
    return ((char *)((void *)0));
  }
#line 7857
  return ((char *)re_error_msgid[(int )ret]);
}
}
#line 7861 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xre_exec(char const   *s ) 
{ 
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 7867
  tmp___0 = strlen(s);
#line 7867
  len = (int )tmp___0;
#line 7868
  tmp___1 = xre_search(& re_comp_buf, s, len, 0, len, (struct re_registers *)0);
  }
#line 7868
  return (0 <= tmp___1);
}
}
#line 7913 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xregcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  int i ;
  void *tmp___2 ;
  __int32_t const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 7917
  if (cflags & 1) {
#line 7917
    tmp___0 = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 7917
    tmp___0 = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
  {
#line 7917
  syntax = tmp___0;
#line 7922
  preg->buffer = (unsigned char *)0;
#line 7923
  preg->allocated = 0UL;
#line 7924
  preg->used = 0UL;
#line 7927
  tmp___1 = malloc((size_t )(1 << 8));
#line 7927
  preg->fastmap = (char *)tmp___1;
  }
#line 7929
  if (cflags & (1 << 1)) {
    {
#line 7933
    tmp___2 = malloc(256UL * sizeof(*((char *)0)));
#line 7933
    preg->translate = (char *)tmp___2;
    }
#line 7936
    if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
#line 7937
      return (12);
    }
#line 7940
    i = 0;
    {
#line 7940
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7940
      if (! (i < 256)) {
#line 7940
        goto while_break;
      }
      {
#line 7941
      tmp___4 = __ctype_b_loc();
      }
#line 7941
      if ((int const   )*(*tmp___4 + i) & 256) {
        {
#line 7941
        tmp___3 = __ctype_tolower_loc();
#line 7941
        *(preg->translate + i) = (char )((int )*(*tmp___3 + i));
        }
      } else {
#line 7941
        *(preg->translate + i) = (char )i;
      }
#line 7940
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 7944
    preg->translate = (char *)((void *)0);
  }
#line 7947
  if (cflags & ((1 << 1) << 1)) {
#line 7949
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 7950
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 7952
    preg->newline_anchor = 1U;
  } else {
#line 7955
    preg->newline_anchor = 0U;
  }
  {
#line 7957
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 7966
  tmp___5 = strlen((char const   *)pattern);
#line 7966
  ret = byte_regex_compile((char const   *)pattern, tmp___5, syntax, (struct re_pattern_buffer *)preg);
  }
#line 7970
  if ((int )ret == 16) {
#line 7970
    ret = (reg_errcode_t )8;
  }
#line 7972
  if ((int )ret == 0) {
#line 7972
    if (preg->fastmap) {
      {
#line 7976
      tmp___6 = xre_compile_fastmap((struct re_pattern_buffer *)preg);
      }
#line 7976
      if (tmp___6 == -2) {
        {
#line 7980
        free((void *)preg->fastmap);
#line 7981
        preg->fastmap = (char *)((void *)0);
        }
      }
    }
  }
#line 7985
  return ((int )ret);
}
}
#line 8006 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
int xregexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
             size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  int ret ;
  struct re_registers regs ;
  regex_t private_preg ;
  int len ;
  size_t tmp___0 ;
  boolean want_reg_info ;
  int tmp___1 ;
  void *tmp___2 ;
  struct re_registers *tmp___3 ;
  unsigned int r ;
  int tmp___4 ;

  {
  {
#line 8013
  tmp___0 = strlen((char const   *)string);
#line 8013
  len = (int )tmp___0;
  }
#line 8014
  if (! preg->no_sub) {
#line 8014
    if (nmatch > 0UL) {
#line 8014
      tmp___1 = 1;
    } else {
#line 8014
      tmp___1 = 0;
    }
  } else {
#line 8014
    tmp___1 = 0;
  }
#line 8014
  want_reg_info = (boolean )tmp___1;
#line 8016
  private_preg = (regex_t )*preg;
#line 8018
  private_preg.not_bol = (unsigned int )(! (! (eflags & 1)));
#line 8019
  private_preg.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
#line 8024
  private_preg.regs_allocated = 2U;
#line 8026
  if (want_reg_info) {
    {
#line 8028
    regs.num_regs = (unsigned int )nmatch;
#line 8029
    tmp___2 = malloc((nmatch * 2UL) * sizeof(xregoff_t ));
#line 8029
    regs.start = (xregoff_t *)tmp___2;
    }
#line 8030
    if ((unsigned long )regs.start == (unsigned long )((void *)0)) {
#line 8031
      return (1);
    }
#line 8032
    regs.end = regs.start + nmatch;
  }
#line 8036
  if (want_reg_info) {
#line 8036
    tmp___3 = & regs;
  } else {
#line 8036
    tmp___3 = (struct re_registers *)0;
  }
  {
#line 8036
  ret = xre_search(& private_preg, (char const   *)string, len, 0, len, tmp___3);
  }
#line 8041
  if (want_reg_info) {
#line 8043
    if (ret >= 0) {
#line 8047
      r = 0U;
      {
#line 8047
      while (1) {
        while_continue: /* CIL Label */ ;
#line 8047
        if (! ((size_t )r < nmatch)) {
#line 8047
          goto while_break;
        }
#line 8049
        (pmatch + r)->rm_so = *(regs.start + r);
#line 8050
        (pmatch + r)->rm_eo = *(regs.end + r);
#line 8047
        r ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 8055
    free((void *)regs.start);
    }
  }
#line 8059
  if (ret >= 0) {
#line 8059
    tmp___4 = 0;
  } else {
#line 8059
    tmp___4 = 1;
  }
#line 8059
  return (tmp___4);
}
}
#line 8069 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
size_t xregerror(int errcode , regex_t const   *preg  __attribute__((__unused__)) ,
                 char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  size_t tmp___0 ;

  {
#line 8076
  if (errcode < 0) {
    {
#line 8083
    abort();
    }
  } else
#line 8076
  if (errcode >= (int )(sizeof(re_error_msgid) / sizeof(re_error_msgid[0]))) {
    {
#line 8083
    abort();
    }
  }
  {
#line 8085
  msg = re_error_msgid[errcode];
#line 8087
  tmp___0 = strlen(msg);
#line 8087
  msg_size = tmp___0 + 1UL;
  }
#line 8089
  if (errbuf_size != 0UL) {
#line 8091
    if (msg_size > errbuf_size) {
      {
#line 8096
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             errbuf_size - 1UL);
#line 8097
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
#line 8101
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             msg_size);
      }
    }
  }
#line 8104
  return (msg_size);
}
}
#line 8113 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./regex.c"
void xregfree(regex_t *preg ) 
{ 


  {
  {
#line 8116
  free((void *)preg->buffer);
#line 8117
  preg->buffer = (unsigned char *)((void *)0);
#line 8119
  preg->allocated = 0UL;
#line 8120
  preg->used = 0UL;
#line 8122
  free((void *)preg->fastmap);
#line 8123
  preg->fastmap = (char *)((void *)0);
#line 8124
  preg->fastmap_accurate = 0U;
#line 8126
  free((void *)preg->translate);
#line 8127
  preg->translate = (char *)((void *)0);
  }
#line 8128
  return;
}
}
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 327 "./../include/libiberty.h"
double physmem_total(void) ;
#line 328
double physmem_available(void) ;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./physmem.c"
double physmem_total(void) 
{ 
  double pages ;
  long tmp___0 ;
  double pagesize ;
  long tmp___1 ;

  {
  {
#line 87
  tmp___0 = sysconf(85);
#line 87
  pages = (double )tmp___0;
#line 88
  tmp___1 = sysconf(30);
#line 88
  pagesize = (double )tmp___1;
  }
#line 89
  if ((double )0 <= pages) {
#line 89
    if ((double )0 <= pagesize) {
#line 90
      return (pages * pagesize);
    }
  }
#line 182
  return ((double )0);
}
}
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./physmem.c"
double physmem_available(void) 
{ 
  double pages ;
  long tmp___0 ;
  double pagesize ;
  long tmp___1 ;
  double tmp___2 ;

  {
  {
#line 191
  tmp___0 = sysconf(86);
#line 191
  pages = (double )tmp___0;
#line 192
  tmp___1 = sysconf(30);
#line 192
  pagesize = (double )tmp___1;
  }
#line 193
  if ((double )0 <= pages) {
#line 193
    if ((double )0 <= pagesize) {
#line 194
      return (pages * pagesize);
    }
  }
  {
#line 283
  tmp___2 = physmem_total();
  }
#line 283
  return (tmp___2 / (double )4);
}
}
#line 401 "./../include/libiberty.h"
struct pex_obj *pex_init(int flags___1 , char const   *pname , char const   *tempbase ) ;
#line 496
char const   *pex_run(struct pex_obj *obj , int flags___1 , char const   *executable ,
                      char * const  *argv , char const   *orig_outname , char const   *errname ,
                      int *err ) ;
#line 552
int pex_get_status(struct pex_obj *obj , int count , int *vector ) ;
#line 573
void pex_free(struct pex_obj *obj ) ;
#line 605
int pexecute(char const   *program , char * const  *argv , char const   *pname , char const   *temp_base ,
             char **errmsg_fmt , char **errmsg_arg , int flags___1 ) ;
#line 610
int pwait(int pid , int *status , int flags___1  __attribute__((__unused__)) ) ;
#line 35 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pexecute.c"
static struct pex_obj *pex  ;
#line 36 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pexecute.c"
static int idx  ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pexecute.c"
int pexecute(char const   *program , char * const  *argv , char const   *pname , char const   *temp_base ,
             char **errmsg_fmt , char **errmsg_arg , int flags___1 ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 46
  if ((flags___1 & 1) != 0) {
#line 48
    if ((unsigned long )pex != (unsigned long )((void *)0)) {
#line 50
      *errmsg_fmt = (char *)"pexecute already in progress";
#line 51
      *errmsg_arg = (char *)((void *)0);
#line 52
      return (-1);
    }
    {
#line 54
    pex = pex_init(2, pname, temp_base);
#line 55
    idx = 0;
    }
  } else
#line 59
  if ((unsigned long )pex == (unsigned long )((void *)0)) {
#line 61
    *errmsg_fmt = (char *)"pexecute not in progress";
#line 62
    *errmsg_arg = (char *)((void *)0);
#line 63
    return (-1);
  }
#line 67
  if ((flags___1 & 2) != 0) {
#line 67
    tmp___0 = 1;
  } else {
#line 67
    tmp___0 = 0;
  }
#line 67
  if ((flags___1 & 4) != 0) {
#line 67
    tmp___1 = 2;
  } else {
#line 67
    tmp___1 = 0;
  }
  {
#line 67
  errmsg = pex_run(pex, tmp___0 | tmp___1, program, argv, (char const   *)((void *)0),
                   (char const   *)((void *)0), & err);
  }
#line 71
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 73
    *errmsg_fmt = (char *)errmsg;
#line 74
    *errmsg_arg = (char *)((void *)0);
#line 75
    return (-1);
  }
#line 81
  idx ++;
#line 81
  return (idx);
}
}
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pexecute.c"
int pwait(int pid , int *status , int flags___1  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;
  int *vector ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 88
  pid --;
#line 90
  if ((unsigned long )pex == (unsigned long )((void *)0)) {
#line 91
    return (-1);
  } else
#line 90
  if (pid < 0) {
#line 91
    return (-1);
  } else
#line 90
  if (pid >= idx) {
#line 91
    return (-1);
  }
#line 93
  if (pid == 0) {
#line 93
    if (idx == 1) {
      {
#line 95
      tmp___0 = pex_get_status(pex, 1, status);
      }
#line 95
      if (! tmp___0) {
#line 96
        return (-1);
      }
    } else {
#line 93
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 102
    tmp___1 = xmalloc(sizeof(int ) * (unsigned long )idx);
#line 102
    vector = (int *)tmp___1;
#line 103
    tmp___2 = pex_get_status(pex, idx, vector);
    }
#line 103
    if (! tmp___2) {
      {
#line 105
      free((void *)vector);
      }
#line 106
      return (-1);
    }
    {
#line 108
    *status = *(vector + pid);
#line 109
    free((void *)vector);
    }
  }
#line 116
  if (pid + 1 == idx) {
    {
#line 118
    pex_free(pex);
#line 119
    pex = (struct pex_obj *)((void *)0);
#line 120
    idx = 0;
    }
  }
#line 123
  return (pid + 1);
}
}
#line 265 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.h"
struct pex_obj *pex_init_common(int flags___1 , char const   *pname , char const   *tempbase ,
                                struct pex_funcs  const  *funcs___0 ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 420
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 447
extern unsigned int sleep(unsigned int __seconds ) ;
#line 537
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 566
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 581
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 606
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 767
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 157
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 142
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , int *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 120 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static pid_t pex_wait(struct pex_obj *obj  __attribute__((__unused__)) , pid_t pid ,
                      int *status , struct pex_time *time ) ;
#line 124 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static pid_t pex_wait(struct pex_obj *obj  __attribute__((__unused__)) , pid_t pid ,
                      int *status , struct pex_time *time ) 
{ 
  pid_t ret ;
  struct rusage r ;
  __pid_t tmp___0 ;

  {
#line 132
  if ((unsigned long )time == (unsigned long )((void *)0)) {
    {
#line 133
    tmp___0 = waitpid(pid, status, 0);
    }
#line 133
    return (tmp___0);
  }
  {
#line 136
  ret = wait4(pid, status, 0, & r);
  }
#line 138
  if ((unsigned long )time != (unsigned long )((void *)0)) {
#line 140
    time->user_seconds = (unsigned long )r.ru_utime.tv_sec;
#line 141
    time->user_microseconds = (unsigned long )r.ru_utime.tv_usec;
#line 142
    time->system_seconds = (unsigned long )r.ru_stime.tv_sec;
#line 143
    time->system_microseconds = (unsigned long )r.ru_stime.tv_usec;
  }
#line 146
  return (ret);
}
}
#line 301
static  __attribute__((__noreturn__)) void pex_child_error(struct pex_obj *obj , char const   *executable ,
                                                           char const   *errmsg ,
                                                           int err ) ;
#line 303
static int pex_unix_open_read(struct pex_obj *obj  __attribute__((__unused__)) , char const   *name___0 ,
                              int binary  __attribute__((__unused__)) ) ;
#line 304
static int pex_unix_open_write(struct pex_obj *obj  __attribute__((__unused__)) ,
                               char const   *name___0 , int binary  __attribute__((__unused__)) ) ;
#line 305
static pid_t pex_unix_exec_child(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                 char * const  *argv , char * const  *env , int in ,
                                 int out , int errdes , int toclose , char const   **errmsg ,
                                 int *err ) ;
#line 309
static int pex_unix_close(struct pex_obj *obj  __attribute__((__unused__)) , int fd ) ;
#line 310
static int pex_unix_wait(struct pex_obj *obj , pid_t pid , int *status , struct pex_time *time ,
                         int done___0 , char const   **errmsg , int *err ) ;
#line 312
static int pex_unix_pipe(struct pex_obj *obj  __attribute__((__unused__)) , int *p ,
                         int binary  __attribute__((__unused__)) ) ;
#line 313
static FILE *pex_unix_fdopenr(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) ;
#line 314
static FILE *pex_unix_fdopenw(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) ;
#line 315
static void pex_unix_cleanup(struct pex_obj *obj  __attribute__((__unused__)) ) ;
#line 319 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
struct pex_funcs  const  funcs  = 
#line 319
     {& pex_unix_open_read, & pex_unix_open_write, & pex_unix_exec_child, & pex_unix_close,
    & pex_unix_wait, & pex_unix_pipe, & pex_unix_fdopenr, & pex_unix_fdopenw, & pex_unix_cleanup};
#line 334 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
struct pex_obj *pex_init(int flags___1 , char const   *pname , char const   *tempbase ) 
{ 
  struct pex_obj *tmp___0 ;

  {
  {
#line 337
  tmp___0 = pex_init_common(flags___1, pname, tempbase, & funcs);
  }
#line 337
  return (tmp___0);
}
}
#line 342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static int pex_unix_open_read(struct pex_obj *obj  __attribute__((__unused__)) , char const   *name___0 ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 346
  tmp___0 = open(name___0, 0);
  }
#line 346
  return (tmp___0);
}
}
#line 351 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static int pex_unix_open_write(struct pex_obj *obj  __attribute__((__unused__)) ,
                               char const   *name___0 , int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 357
  tmp___0 = open(name___0, 577, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
  }
#line 357
  return (tmp___0);
}
}
#line 362 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static int pex_unix_close(struct pex_obj *obj  __attribute__((__unused__)) , int fd ) 
{ 
  int tmp___0 ;

  {
  {
#line 365
  tmp___0 = close(fd);
  }
#line 365
  return (tmp___0);
}
}
#line 371
static  __attribute__((__noreturn__)) void pex_child_error(struct pex_obj *obj , char const   *executable ,
                                                           char const   *errmsg ,
                                                           int err ) ;
#line 371 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static void pex_child_error(struct pex_obj *obj , char const   *executable , char const   *errmsg ,
                            int err ) 
{ 
  int retval ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  size_t tmp___8 ;
  ssize_t tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  ssize_t tmp___15 ;
  size_t tmp___16 ;
  ssize_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 375
  retval = 0;
#line 377
  tmp___0 = strlen(obj->pname);
#line 377
  tmp___1 = write(2, (void const   *)obj->pname, tmp___0);
#line 377
  retval |= tmp___1 < 0L;
#line 378
  tmp___2 = strlen(": error trying to exec \'");
#line 378
  tmp___3 = write(2, (void const   *)": error trying to exec \'", tmp___2);
#line 378
  retval |= tmp___3 < 0L;
#line 379
  tmp___4 = strlen(executable);
#line 379
  tmp___5 = write(2, (void const   *)executable, tmp___4);
#line 379
  retval |= tmp___5 < 0L;
#line 380
  tmp___6 = strlen("\': ");
#line 380
  tmp___7 = write(2, (void const   *)"\': ", tmp___6);
#line 380
  retval |= tmp___7 < 0L;
#line 381
  tmp___8 = strlen(errmsg);
#line 381
  tmp___9 = write(2, (void const   *)errmsg, tmp___8);
#line 381
  retval |= tmp___9 < 0L;
#line 382
  tmp___10 = strlen(": ");
#line 382
  tmp___11 = write(2, (void const   *)": ", tmp___10);
#line 382
  retval |= tmp___11 < 0L;
#line 383
  tmp___12 = xstrerror(err);
#line 383
  tmp___13 = strlen((char const   *)tmp___12);
#line 383
  tmp___14 = xstrerror(err);
#line 383
  tmp___15 = write(2, (void const   *)tmp___14, tmp___13);
#line 383
  retval |= tmp___15 < 0L;
#line 384
  tmp___16 = strlen("\n");
#line 384
  tmp___17 = write(2, (void const   *)"\n", tmp___16);
#line 384
  retval |= tmp___17 < 0L;
  }
#line 387
  if (retval == 0) {
#line 387
    tmp___18 = -1;
  } else {
#line 387
    tmp___18 = -2;
  }
  {
#line 387
  _exit(tmp___18);
  }
}
}
#line 590 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static pid_t pex_unix_exec_child(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                 char * const  *argv , char * const  *env , int in ,
                                 int out , int errdes , int toclose , char const   **errmsg ,
                                 int *err ) 
{ 
  pid_t pid ;
  int volatile   sleep_interval ;
  int volatile   retries ;
  char **save_environ ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;

  {
#line 607
  save_environ = environ;
#line 609
  sleep_interval = (int volatile   )1;
#line 610
  pid = -1;
#line 611
  retries = (int volatile   )0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (retries < (int volatile   )4)) {
#line 611
      goto while_break;
    }
    {
#line 613
    pid = vfork();
    }
#line 614
    if (pid >= 0) {
#line 615
      goto while_break;
    }
    {
#line 616
    sleep((unsigned int )sleep_interval);
#line 617
    sleep_interval *= (int volatile   )2;
#line 611
    retries += (int volatile   )1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  if (pid == -1) {
#line 622
    goto case_neg_1;
  }
#line 627
  if (pid == 0) {
#line 627
    goto case_0;
  }
#line 683
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 623
  tmp___0 = __errno_location();
#line 623
  *err = *tmp___0;
#line 624
  *errmsg = "vfork";
  }
#line 625
  return (-1);
  case_0: /* CIL Label */ 
#line 629
  if (in != 0) {
    {
#line 631
    tmp___2 = dup2(in, 0);
    }
#line 631
    if (tmp___2 < 0) {
      {
#line 632
      tmp___1 = __errno_location();
#line 632
      pex_child_error(obj, executable, "dup2", *tmp___1);
      }
    }
    {
#line 633
    tmp___4 = close(in);
    }
#line 633
    if (tmp___4 < 0) {
      {
#line 634
      tmp___3 = __errno_location();
#line 634
      pex_child_error(obj, executable, "close", *tmp___3);
      }
    }
  }
#line 636
  if (out != 1) {
    {
#line 638
    tmp___6 = dup2(out, 1);
    }
#line 638
    if (tmp___6 < 0) {
      {
#line 639
      tmp___5 = __errno_location();
#line 639
      pex_child_error(obj, executable, "dup2", *tmp___5);
      }
    }
    {
#line 640
    tmp___8 = close(out);
    }
#line 640
    if (tmp___8 < 0) {
      {
#line 641
      tmp___7 = __errno_location();
#line 641
      pex_child_error(obj, executable, "close", *tmp___7);
      }
    }
  }
#line 643
  if (errdes != 2) {
    {
#line 645
    tmp___10 = dup2(errdes, 2);
    }
#line 645
    if (tmp___10 < 0) {
      {
#line 646
      tmp___9 = __errno_location();
#line 646
      pex_child_error(obj, executable, "dup2", *tmp___9);
      }
    }
    {
#line 647
    tmp___12 = close(errdes);
    }
#line 647
    if (tmp___12 < 0) {
      {
#line 648
      tmp___11 = __errno_location();
#line 648
      pex_child_error(obj, executable, "close", *tmp___11);
      }
    }
  }
#line 650
  if (toclose >= 0) {
    {
#line 652
    tmp___14 = close(toclose);
    }
#line 652
    if (tmp___14 < 0) {
      {
#line 653
      tmp___13 = __errno_location();
#line 653
      pex_child_error(obj, executable, "close", *tmp___13);
      }
    }
  }
#line 655
  if ((flags___1 & 8) != 0) {
    {
#line 657
    tmp___16 = dup2(1, 2);
    }
#line 657
    if (tmp___16 < 0) {
      {
#line 658
      tmp___15 = __errno_location();
#line 658
      pex_child_error(obj, executable, "dup2", *tmp___15);
      }
    }
  }
#line 661
  if (env) {
#line 666
    environ = (char **)env;
  }
#line 669
  if ((flags___1 & 2) != 0) {
    {
#line 671
    execvp(executable, argv);
#line 672
    tmp___17 = __errno_location();
#line 672
    pex_child_error(obj, executable, "execvp", *tmp___17);
    }
  } else {
    {
#line 676
    execv(executable, argv);
#line 677
    tmp___18 = __errno_location();
#line 677
    pex_child_error(obj, executable, "execv", *tmp___18);
    }
  }
#line 681
  return (-1);
  switch_default: /* CIL Label */ 
#line 691
  environ = save_environ;
#line 693
  if (in != 0) {
    {
#line 695
    tmp___20 = close(in);
    }
#line 695
    if (tmp___20 < 0) {
      {
#line 697
      tmp___19 = __errno_location();
#line 697
      *err = *tmp___19;
#line 698
      *errmsg = "close";
      }
#line 699
      return (-1);
    }
  }
#line 702
  if (out != 1) {
    {
#line 704
    tmp___22 = close(out);
    }
#line 704
    if (tmp___22 < 0) {
      {
#line 706
      tmp___21 = __errno_location();
#line 706
      *err = *tmp___21;
#line 707
      *errmsg = "close";
      }
#line 708
      return (-1);
    }
  }
#line 711
  if (errdes != 2) {
    {
#line 713
    tmp___24 = close(errdes);
    }
#line 713
    if (tmp___24 < 0) {
      {
#line 715
      tmp___23 = __errno_location();
#line 715
      *err = *tmp___23;
#line 716
      *errmsg = "close";
      }
#line 717
      return (-1);
    }
  }
#line 721
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 728 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static int pex_unix_wait(struct pex_obj *obj , pid_t pid , int *status , struct pex_time *time ,
                         int done___0 , char const   **errmsg , int *err ) 
{ 
  int *tmp___0 ;
  pid_t tmp___1 ;

  {
#line 735
  if (done___0) {
    {
#line 736
    kill(pid, 15);
    }
  }
  {
#line 738
  tmp___1 = pex_wait(obj, pid, status, time);
  }
#line 738
  if (tmp___1 < 0) {
    {
#line 740
    tmp___0 = __errno_location();
#line 740
    *err = *tmp___0;
#line 741
    *errmsg = "wait";
    }
#line 742
    return (-1);
  }
#line 745
  return (0);
}
}
#line 750 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static int pex_unix_pipe(struct pex_obj *obj  __attribute__((__unused__)) , int *p ,
                         int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 754
  tmp___0 = pipe((int *)p);
  }
#line 754
  return (tmp___0);
}
}
#line 759 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static FILE *pex_unix_fdopenr(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  FILE *tmp___0 ;

  {
  {
#line 763
  tmp___0 = fdopen(fd, "r");
  }
#line 763
  return (tmp___0);
}
}
#line 766 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static FILE *pex_unix_fdopenw(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;
  FILE *tmp___1 ;

  {
  {
#line 770
  tmp___0 = fcntl(fd, 2, 1);
  }
#line 770
  if (tmp___0 < 0) {
#line 771
    return ((FILE *)((void *)0));
  }
  {
#line 772
  tmp___1 = fdopen(fd, "w");
  }
#line 772
  return (tmp___1);
}
}
#line 775 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-unix.c"
static void pex_unix_cleanup(struct pex_obj *obj  __attribute__((__unused__)) ) 
{ 


  {
#line 790
  return;
}
}
#line 586 "./../include/libiberty.h"
char const   *pex_one(int flags___1 , char const   *executable , char * const  *argv ,
                      char const   *pname , char const   *outname , char const   *errname ,
                      int *status , int *err ) ;
#line 23 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-one.c"
char const   *pex_one(int flags___1 , char const   *executable , char * const  *argv ,
                      char const   *pname , char const   *outname , char const   *errname ,
                      int *status , int *err ) 
{ 
  struct pex_obj *obj ;
  char const   *errmsg ;
  int tmp___0 ;

  {
  {
#line 31
  obj = pex_init(0, pname, (char const   *)((void *)0));
#line 32
  errmsg = pex_run(obj, flags___1, executable, argv, outname, errname, err);
  }
#line 33
  if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
    {
#line 35
    tmp___0 = pex_get_status(obj, 1, status);
    }
#line 35
    if (! tmp___0) {
#line 37
      *err = 0;
#line 38
      errmsg = "pex_get_status failed";
    }
  }
  {
#line 41
  pex_free(obj);
  }
#line 42
  return (errmsg);
}
}
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 142 "./../include/libiberty.h"
char *concat(char const   *first  , ...)  __attribute__((__sentinel__, __malloc__)) ;
#line 233
char *make_temp_file(char const   *suffix )  __attribute__((__malloc__)) ;
#line 511
char const   *pex_run_in_environment(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                     char * const  *argv , char * const  *env , char const   *orig_outname ,
                                     char const   *errname , int *err ) ;
#line 522
FILE *pex_input_file(struct pex_obj *obj , int flags___1 , char const   *in_name ) ;
#line 530
FILE *pex_input_pipe(struct pex_obj *obj , int binary ) ;
#line 538
FILE *pex_read_output(struct pex_obj *obj , int binary ) ;
#line 546
FILE *pex_read_err(struct pex_obj *obj , int binary ) ;
#line 567
int pex_get_times(struct pex_obj *obj , int count , struct pex_time *vector ) ;
#line 707 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemps)(char *__template , int __suffixlen ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
static void pex_add_remove(struct pex_obj *obj , char const   *name___0 , int allocated ) ;
#line 47
static int pex_get_status_and_time(struct pex_obj *obj , int done___0 , char const   **errmsg ,
                                   int *err ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
struct pex_obj *pex_init_common(int flags___1 , char const   *pname , char const   *tempbase ,
                                struct pex_funcs  const  *funcs___0 ) 
{ 
  struct pex_obj *obj ;
  void *tmp___0 ;

  {
  {
#line 58
  tmp___0 = xmalloc(sizeof(struct pex_obj ));
#line 58
  obj = (struct pex_obj *)tmp___0;
#line 59
  obj->flags = flags___1;
#line 60
  obj->pname = pname;
#line 61
  obj->tempbase = tempbase;
#line 62
  obj->next_input = 0;
#line 63
  obj->next_input_name = (char *)((void *)0);
#line 64
  obj->next_input_name_allocated = 0;
#line 65
  obj->stderr_pipe = -1;
#line 66
  obj->count = 0;
#line 67
  obj->children = (pid_t *)((void *)0);
#line 68
  obj->status = (int *)((void *)0);
#line 69
  obj->time = (struct pex_time *)((void *)0);
#line 70
  obj->number_waited = 0;
#line 71
  obj->input_file = (FILE *)((void *)0);
#line 72
  obj->read_output = (FILE *)((void *)0);
#line 73
  obj->read_err = (FILE *)((void *)0);
#line 74
  obj->remove_count = 0;
#line 75
  obj->remove = (char **)((void *)0);
#line 76
  obj->funcs = funcs___0;
#line 77
  obj->sysdep = (void *)0;
  }
#line 78
  return (obj);
}
}
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
static void pex_add_remove(struct pex_obj *obj , char const   *name___0 , int allocated ) 
{ 
  char *add ;
  void *tmp___0 ;

  {
  {
#line 88
  (obj->remove_count) ++;
#line 89
  tmp___0 = xrealloc((void *)obj->remove, sizeof(char *) * (unsigned long )obj->remove_count);
#line 89
  obj->remove = (char **)tmp___0;
  }
#line 90
  if (allocated) {
#line 91
    add = (char *)name___0;
  } else {
    {
#line 93
    add = xstrdup(name___0);
    }
  }
#line 94
  *(obj->remove + (obj->remove_count - 1)) = add;
#line 95
  return;
}
}
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
static char *temp_file(struct pex_obj *obj , int flags___1 , char *name___0 ) 
{ 
  int len ;
  size_t tmp___0 ;
  int out ;
  int tmp___1 ;

  {
#line 105
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 107
    if ((unsigned long )obj->tempbase == (unsigned long )((void *)0)) {
      {
#line 109
      name___0 = make_temp_file((char const   *)((void *)0));
      }
    } else {
      {
#line 113
      tmp___0 = strlen(obj->tempbase);
#line 113
      len = (int )tmp___0;
      }
#line 116
      if (len >= 6) {
        {
#line 116
        tmp___1 = strcmp((obj->tempbase + len) - 6, "XXXXXX");
        }
#line 116
        if (tmp___1 == 0) {
          {
#line 118
          name___0 = xstrdup(obj->tempbase);
          }
        } else {
          {
#line 120
          name___0 = concat(obj->tempbase, "XXXXXX", (void *)0);
          }
        }
      } else {
        {
#line 120
        name___0 = concat(obj->tempbase, "XXXXXX", (void *)0);
        }
      }
      {
#line 122
      out = mkstemps(name___0, 0);
      }
#line 123
      if (out < 0) {
        {
#line 125
        free((void *)name___0);
        }
#line 126
        return ((char *)((void *)0));
      }
      {
#line 133
      close(out);
      }
    }
  } else
#line 136
  if ((flags___1 & 4) != 0) {
#line 138
    if ((unsigned long )obj->tempbase == (unsigned long )((void *)0)) {
      {
#line 139
      name___0 = make_temp_file((char const   *)name___0);
      }
    } else {
      {
#line 141
      name___0 = concat(obj->tempbase, name___0, (void *)0);
      }
    }
  }
#line 144
  return (name___0);
}
}
#line 151 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
char const   *pex_run_in_environment(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                     char * const  *argv , char * const  *env , char const   *orig_outname ,
                                     char const   *errname , int *err ) 
{ 
  char const   *errmsg ;
  int in ;
  int out ;
  int errdes ;
  char *outname ;
  int outname_allocated ;
  int p[2] ;
  int toclose ;
  pid_t pid ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  void *tmp___9 ;

  {
#line 165
  in = -1;
#line 166
  out = -1;
#line 167
  errdes = -1;
#line 168
  outname = (char *)orig_outname;
#line 169
  outname_allocated = 0;
#line 172
  if (obj->input_file) {
    {
#line 174
    tmp___0 = fclose(obj->input_file);
    }
#line 174
    if (tmp___0 == -1) {
#line 176
      errmsg = "closing pipeline input file";
#line 177
      goto error_exit;
    }
#line 179
    obj->input_file = (FILE *)((void *)0);
  }
#line 184
  if ((unsigned long )obj->next_input_name != (unsigned long )((void *)0)) {
    {
#line 188
    tmp___1 = pex_get_status_and_time(obj, 0, & errmsg, err);
    }
#line 188
    if (! tmp___1) {
#line 189
      goto error_exit;
    }
    {
#line 191
    in = (*((obj->funcs)->open_read))(obj, (char const   *)obj->next_input_name, (flags___1 & 16) != 0);
    }
#line 193
    if (in < 0) {
      {
#line 195
      tmp___2 = __errno_location();
#line 195
      *err = *tmp___2;
#line 196
      errmsg = "open temporary file";
      }
#line 197
      goto error_exit;
    }
#line 199
    if (obj->next_input_name_allocated) {
      {
#line 201
      free((void *)obj->next_input_name);
#line 202
      obj->next_input_name_allocated = 0;
      }
    }
#line 204
    obj->next_input_name = (char *)((void *)0);
  } else {
#line 208
    in = obj->next_input;
#line 209
    if (in < 0) {
#line 211
      *err = 0;
#line 212
      errmsg = "pipeline already complete";
#line 213
      goto error_exit;
    }
  }
#line 219
  if ((flags___1 & 1) != 0) {
#line 221
    if ((unsigned long )outname == (unsigned long )((void *)0)) {
#line 222
      out = 1;
    } else
#line 223
    if ((flags___1 & 4) != 0) {
      {
#line 225
      outname = concat(obj->tempbase, outname, (void *)0);
#line 226
      outname_allocated = 1;
      }
    }
#line 228
    obj->next_input = -1;
  } else
#line 230
  if ((obj->flags & 2) == 0) {
    {
#line 232
    outname = temp_file(obj, flags___1, outname);
    }
#line 233
    if (! outname) {
#line 235
      *err = 0;
#line 236
      errmsg = "could not create temporary file";
#line 237
      goto error_exit;
    }
#line 240
    if ((unsigned long )outname != (unsigned long )orig_outname) {
#line 241
      outname_allocated = 1;
    }
#line 243
    if ((obj->flags & 4) == 0) {
      {
#line 245
      pex_add_remove(obj, (char const   *)outname, outname_allocated);
#line 246
      outname_allocated = 0;
      }
    }
#line 250
    obj->next_input_name = outname;
#line 251
    obj->next_input_name_allocated = outname_allocated;
#line 252
    outname_allocated = 0;
  } else {
    {
#line 256
    tmp___4 = (*((obj->funcs)->pipe))(obj, p, (flags___1 & 32) != 0);
    }
#line 256
    if (tmp___4 < 0) {
      {
#line 258
      tmp___3 = __errno_location();
#line 258
      *err = *tmp___3;
#line 259
      errmsg = "pipe";
      }
#line 260
      goto error_exit;
    }
#line 263
    out = p[1];
#line 264
    obj->next_input = p[0];
  }
#line 267
  if (out < 0) {
    {
#line 269
    out = (*((obj->funcs)->open_write))(obj, (char const   *)outname, (flags___1 & 32) != 0);
    }
#line 271
    if (out < 0) {
      {
#line 273
      tmp___5 = __errno_location();
#line 273
      *err = *tmp___5;
#line 274
      errmsg = "open temporary output file";
      }
#line 275
      goto error_exit;
    }
  }
#line 279
  if (outname_allocated) {
    {
#line 281
    free((void *)outname);
#line 282
    outname_allocated = 0;
    }
  }
#line 287
  if ((unsigned long )errname != (unsigned long )((void *)0)) {
#line 287
    if ((flags___1 & 64) != 0) {
#line 289
      *err = 0;
#line 290
      errmsg = "both ERRNAME and PEX_STDERR_TO_PIPE specified.";
#line 291
      goto error_exit;
    }
  }
#line 294
  if (obj->stderr_pipe != -1) {
#line 296
    *err = 0;
#line 297
    errmsg = "PEX_STDERR_TO_PIPE used in the middle of pipeline";
#line 298
    goto error_exit;
  }
#line 301
  if ((unsigned long )errname == (unsigned long )((void *)0)) {
#line 303
    if (flags___1 & 64) {
      {
#line 305
      tmp___7 = (*((obj->funcs)->pipe))(obj, p, (flags___1 & 128) != 0);
      }
#line 305
      if (tmp___7 < 0) {
        {
#line 307
        tmp___6 = __errno_location();
#line 307
        *err = *tmp___6;
#line 308
        errmsg = "pipe";
        }
#line 309
        goto error_exit;
      }
#line 312
      errdes = p[1];
#line 313
      obj->stderr_pipe = p[0];
    } else {
#line 317
      errdes = 2;
    }
  } else {
    {
#line 322
    errdes = (*((obj->funcs)->open_write))(obj, errname, (flags___1 & 128) != 0);
    }
#line 324
    if (errdes < 0) {
      {
#line 326
      tmp___8 = __errno_location();
#line 326
      *err = *tmp___8;
#line 327
      errmsg = "open error file";
      }
#line 328
      goto error_exit;
    }
  }
#line 335
  if ((obj->flags & 2) == 0) {
#line 336
    toclose = -1;
  } else {
#line 338
    toclose = obj->next_input;
  }
  {
#line 342
  pid = (*((obj->funcs)->exec_child))(obj, flags___1, executable, argv, env, in, out,
                                      errdes, toclose, & errmsg, err);
  }
#line 344
  if (pid < 0) {
#line 345
    goto error_exit;
  }
  {
#line 347
  (obj->count) ++;
#line 348
  tmp___9 = xrealloc((void *)obj->children, sizeof(pid_t ) * (unsigned long )obj->count);
#line 348
  obj->children = (pid_t *)tmp___9;
#line 349
  *(obj->children + (obj->count - 1)) = pid;
  }
#line 351
  return ((char const   *)((void *)0));
  error_exit: 
#line 354
  if (in >= 0) {
#line 354
    if (in != 0) {
      {
#line 355
      (*((obj->funcs)->close))(obj, in);
      }
    }
  }
#line 356
  if (out >= 0) {
#line 356
    if (out != 1) {
      {
#line 357
      (*((obj->funcs)->close))(obj, out);
      }
    }
  }
#line 358
  if (errdes >= 0) {
#line 358
    if (errdes != 2) {
      {
#line 359
      (*((obj->funcs)->close))(obj, errdes);
      }
    }
  }
#line 360
  if (outname_allocated) {
    {
#line 361
    free((void *)outname);
    }
  }
#line 362
  return (errmsg);
}
}
#line 367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
char const   *pex_run(struct pex_obj *obj , int flags___1 , char const   *executable ,
                      char * const  *argv , char const   *orig_outname , char const   *errname ,
                      int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 372
  tmp___0 = pex_run_in_environment(obj, flags___1, executable, argv, (char * const  *)((void *)0),
                                   orig_outname, errname, err);
  }
#line 372
  return (tmp___0);
}
}
#line 378 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
FILE *pex_input_file(struct pex_obj *obj , int flags___1 , char const   *in_name ) 
{ 
  char *name___0 ;
  FILE *f ;
  int *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 381
  name___0 = (char *)in_name;
#line 386
  if (obj->count != 0) {
    {
#line 390
    tmp___0 = __errno_location();
#line 390
    *tmp___0 = 22;
    }
#line 391
    return ((FILE *)((void *)0));
  } else
#line 386
  if (obj->next_input >= 0) {
#line 386
    if (obj->next_input != 0) {
      {
#line 390
      tmp___0 = __errno_location();
#line 390
      *tmp___0 = 22;
      }
#line 391
      return ((FILE *)((void *)0));
    } else {
#line 386
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 386
  if (obj->next_input_name) {
    {
#line 390
    tmp___0 = __errno_location();
#line 390
    *tmp___0 = 22;
    }
#line 391
    return ((FILE *)((void *)0));
  }
  {
#line 394
  name___0 = temp_file(obj, flags___1, name___0);
  }
#line 395
  if (! name___0) {
#line 396
    return ((FILE *)((void *)0));
  }
#line 398
  if (flags___1 & 32) {
#line 398
    tmp___1 = "wb";
  } else {
#line 398
    tmp___1 = "w";
  }
  {
#line 398
  f = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)tmp___1);
  }
#line 399
  if (! f) {
    {
#line 401
    free((void *)name___0);
    }
#line 402
    return ((FILE *)((void *)0));
  }
#line 405
  obj->input_file = f;
#line 406
  obj->next_input_name = name___0;
#line 407
  obj->next_input_name_allocated = (unsigned long )name___0 != (unsigned long )in_name;
#line 409
  return (f);
}
}
#line 414 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
FILE *pex_input_pipe(struct pex_obj *obj , int binary ) 
{ 
  int p[2] ;
  FILE *f ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 421
  if (obj->count > 0) {
#line 422
    goto usage_error;
  }
#line 426
  if (! (obj->flags & 2)) {
#line 427
    goto usage_error;
  }
#line 431
  if (obj->next_input >= 0) {
#line 431
    if (obj->next_input != 0) {
#line 433
      goto usage_error;
    } else {
#line 431
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 431
  if (obj->next_input_name) {
#line 433
    goto usage_error;
  }
  {
#line 435
  tmp___0 = (*((obj->funcs)->pipe))(obj, p, binary != 0);
  }
#line 435
  if (tmp___0 < 0) {
#line 436
    return ((FILE *)((void *)0));
  }
  {
#line 438
  f = (*((obj->funcs)->fdopenw))(obj, p[1], binary != 0);
  }
#line 439
  if (! f) {
    {
#line 441
    tmp___1 = __errno_location();
#line 441
    saved_errno = *tmp___1;
#line 442
    (*((obj->funcs)->close))(obj, p[0]);
#line 443
    (*((obj->funcs)->close))(obj, p[1]);
#line 444
    tmp___2 = __errno_location();
#line 444
    *tmp___2 = saved_errno;
    }
#line 445
    return ((FILE *)((void *)0));
  }
#line 448
  obj->next_input = p[0];
#line 450
  return (f);
  usage_error: 
  {
#line 453
  tmp___3 = __errno_location();
#line 453
  *tmp___3 = 22;
  }
#line 454
  return ((FILE *)((void *)0));
}
}
#line 460 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
FILE *pex_read_output(struct pex_obj *obj , int binary ) 
{ 
  char const   *errmsg ;
  int err ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int o ;

  {
#line 463
  if ((unsigned long )obj->next_input_name != (unsigned long )((void *)0)) {
    {
#line 470
    tmp___1 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 470
    if (! tmp___1) {
      {
#line 472
      tmp___0 = __errno_location();
#line 472
      *tmp___0 = err;
      }
#line 473
      return ((FILE *)((void *)0));
    }
#line 476
    if (binary) {
#line 476
      tmp___2 = "rb";
    } else {
#line 476
      tmp___2 = "r";
    }
    {
#line 476
    obj->read_output = fopen((char const   */* __restrict  */)obj->next_input_name,
                             (char const   */* __restrict  */)tmp___2);
    }
#line 478
    if (obj->next_input_name_allocated) {
      {
#line 480
      free((void *)obj->next_input_name);
#line 481
      obj->next_input_name_allocated = 0;
      }
    }
#line 483
    obj->next_input_name = (char *)((void *)0);
  } else {
#line 489
    o = obj->next_input;
#line 490
    if (o < 0) {
#line 491
      return ((FILE *)((void *)0));
    } else
#line 490
    if (o == 0) {
#line 491
      return ((FILE *)((void *)0));
    }
    {
#line 492
    obj->read_output = (*((obj->funcs)->fdopenr))(obj, o, binary);
#line 493
    obj->next_input = -1;
    }
  }
#line 496
  return (obj->read_output);
}
}
#line 499 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
FILE *pex_read_err(struct pex_obj *obj , int binary ) 
{ 
  int o ;

  {
#line 504
  o = obj->stderr_pipe;
#line 505
  if (o < 0) {
#line 506
    return ((FILE *)((void *)0));
  } else
#line 505
  if (o == 0) {
#line 506
    return ((FILE *)((void *)0));
  }
  {
#line 507
  obj->read_err = (*((obj->funcs)->fdopenr))(obj, o, binary);
#line 508
  obj->stderr_pipe = -1;
  }
#line 509
  return (obj->read_err);
}
}
#line 515 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
static int pex_get_status_and_time(struct pex_obj *obj , int done___0 , char const   **errmsg ,
                                   int *err ) 
{ 
  int ret ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct pex_time *tmp___2 ;
  pid_t tmp___3 ;

  {
#line 522
  if (obj->number_waited == obj->count) {
#line 523
    return (1);
  }
  {
#line 525
  tmp___0 = xrealloc((void *)obj->status, sizeof(int ) * (unsigned long )obj->count);
#line 525
  obj->status = (int *)tmp___0;
  }
#line 526
  if ((obj->flags & 1) != 0) {
    {
#line 527
    tmp___1 = xrealloc((void *)obj->time, sizeof(struct pex_time ) * (unsigned long )obj->count);
#line 527
    obj->time = (struct pex_time *)tmp___1;
    }
  }
#line 529
  ret = 1;
#line 530
  i = obj->number_waited;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (i < obj->count)) {
#line 530
      goto while_break;
    }
#line 532
    if ((unsigned long )obj->time == (unsigned long )((void *)0)) {
#line 532
      tmp___2 = (struct pex_time *)((void *)0);
    } else {
#line 532
      tmp___2 = obj->time + i;
    }
    {
#line 532
    tmp___3 = (*((obj->funcs)->wait))(obj, *(obj->children + i), obj->status + i,
                                      tmp___2, done___0, errmsg, err);
    }
#line 532
    if (tmp___3 < 0) {
#line 535
      ret = 0;
    }
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  obj->number_waited = i;
#line 539
  return (ret);
}
}
#line 544 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
int pex_get_status(struct pex_obj *obj , int count , int *vector ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;

  {
#line 547
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 552
    tmp___0 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 552
    if (! tmp___0) {
#line 553
      return (0);
    }
  }
#line 556
  if (count > obj->count) {
    {
#line 558
    memset((void *)(vector + obj->count), 0, (unsigned long )(count - obj->count) * sizeof(int ));
#line 559
    count = obj->count;
    }
  }
  {
#line 562
  memcpy((void */* __restrict  */)vector, (void const   */* __restrict  */)obj->status,
         (unsigned long )count * sizeof(int ));
  }
#line 564
  return (1);
}
}
#line 569 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
int pex_get_times(struct pex_obj *obj , int count , struct pex_time *vector ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;

  {
#line 572
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 577
    tmp___0 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 577
    if (! tmp___0) {
#line 578
      return (0);
    }
  }
#line 581
  if ((unsigned long )obj->time == (unsigned long )((void *)0)) {
#line 582
    return (0);
  }
#line 584
  if (count > obj->count) {
    {
#line 586
    memset((void *)(vector + obj->count), 0, (unsigned long )(count - obj->count) * sizeof(struct pex_time ));
#line 588
    count = obj->count;
    }
  }
  {
#line 591
  memcpy((void */* __restrict  */)vector, (void const   */* __restrict  */)obj->time,
         (unsigned long )count * sizeof(struct pex_time ));
  }
#line 593
  return (1);
}
}
#line 598 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./pex-common.c"
void pex_free(struct pex_obj *obj ) 
{ 
  char const   *errmsg ;
  int err ;
  int i ;

  {
#line 604
  if (obj->next_input >= 0) {
#line 604
    if (obj->next_input != 0) {
      {
#line 605
      (*((obj->funcs)->close))(obj, obj->next_input);
      }
    }
  }
#line 606
  if (obj->stderr_pipe >= 0) {
#line 606
    if (obj->stderr_pipe != 0) {
      {
#line 607
      (*((obj->funcs)->close))(obj, obj->stderr_pipe);
      }
    }
  }
#line 608
  if ((unsigned long )obj->read_output != (unsigned long )((void *)0)) {
    {
#line 609
    fclose(obj->read_output);
    }
  }
#line 610
  if ((unsigned long )obj->read_err != (unsigned long )((void *)0)) {
    {
#line 611
    fclose(obj->read_err);
    }
  }
#line 615
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 620
    obj->flags &= -2;
#line 621
    pex_get_status_and_time(obj, 1, & errmsg, & err);
    }
  }
#line 624
  if (obj->next_input_name_allocated) {
    {
#line 625
    free((void *)obj->next_input_name);
    }
  }
  {
#line 626
  free((void *)obj->children);
#line 627
  free((void *)obj->status);
#line 628
  free((void *)obj->time);
  }
#line 630
  if (obj->remove_count > 0) {
#line 634
    i = 0;
    {
#line 634
    while (1) {
      while_continue: /* CIL Label */ ;
#line 634
      if (! (i < obj->remove_count)) {
#line 634
        goto while_break;
      }
      {
#line 636
      remove((char const   *)*(obj->remove + i));
#line 637
      free((void *)*(obj->remove + i));
#line 634
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 639
    free((void *)obj->remove);
    }
  }
#line 642
  if ((unsigned long )(obj->funcs)->cleanup != (unsigned long )((void *)0)) {
    {
#line 643
    (*((obj->funcs)->cleanup))(obj);
    }
  }
  {
#line 645
  free((void *)obj);
  }
#line 646
  return;
}
}
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 67 "./../include/partition.h"
partition partition_new(int num_elements ) ;
#line 68
void partition_delete(partition part ) ;
#line 69
int partition_union(partition part , int elem1 , int elem2 ) ;
#line 70
void partition_print(partition part , FILE *fp ) ;
#line 37 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
static int elem_compare(void const   *elem1 , void const   *elem2 ) ;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
partition partition_new(int num_elements ) 
{ 
  int e ;
  partition part ;
  void *tmp___0 ;

  {
  {
#line 47
  tmp___0 = xmalloc(sizeof(struct partition_def ) + (unsigned long )(num_elements - 1) * sizeof(struct partition_elem ));
#line 47
  part = (partition )tmp___0;
#line 50
  part->num_elements = num_elements;
#line 51
  e = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (e < num_elements)) {
#line 51
      goto while_break;
    }
#line 53
    part->elements[e].class_element = e;
#line 54
    part->elements[e].next = & part->elements[e];
#line 55
    part->elements[e].class_count = 1U;
#line 51
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (part);
}
}
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
void partition_delete(partition part ) 
{ 


  {
  {
#line 66
  free((void *)part);
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
int partition_union(partition part , int elem1 , int elem2 ) 
{ 
  struct partition_elem *elements ;
  struct partition_elem *e1 ;
  struct partition_elem *e2 ;
  struct partition_elem *p ;
  struct partition_elem *old_next ;
  int class_element ;
  int temp ;

  {
#line 77
  elements = part->elements;
#line 83
  class_element = (elements + elem1)->class_element;
#line 86
  if (class_element == (elements + elem2)->class_element) {
#line 87
    return (class_element);
  }
#line 91
  if ((elements + elem1)->class_count < (elements + elem2)->class_count) {
#line 93
    temp = elem1;
#line 94
    elem1 = elem2;
#line 95
    elem2 = temp;
#line 96
    class_element = (elements + elem1)->class_element;
  }
#line 99
  e1 = elements + elem1;
#line 100
  e2 = elements + elem2;
#line 103
  (elements + class_element)->class_count += (elements + e2->class_element)->class_count;
#line 107
  e2->class_element = class_element;
#line 108
  p = e2->next;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )p != (unsigned long )e2)) {
#line 108
      goto while_break;
    }
#line 109
    p->class_element = class_element;
#line 108
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  old_next = e1->next;
#line 114
  e1->next = e2->next;
#line 115
  e2->next = old_next;
#line 117
  return (class_element);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
static int elem_compare(void const   *elem1 , void const   *elem2 ) 
{ 
  int e1 ;
  int e2 ;

  {
#line 126
  e1 = (int )*((int const   *)elem1);
#line 127
  e2 = (int )*((int const   *)elem2);
#line 128
  if (e1 < e2) {
#line 129
    return (-1);
  } else
#line 130
  if (e1 > e2) {
#line 131
    return (1);
  } else {
#line 133
    return (0);
  }
}
}
#line 139 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./partition.c"
void partition_print(partition part , FILE *fp ) 
{ 
  char *done___0 ;
  int num_elements ;
  struct partition_elem *elements ;
  int *class_elements ;
  int e ;
  void *tmp___0 ;
  void *tmp___1 ;
  int c ;
  int count ;
  int i ;
  char const   *tmp___2 ;

  {
  {
#line 143
  num_elements = part->num_elements;
#line 144
  elements = part->elements;
#line 149
  tmp___0 = xmalloc((size_t )num_elements);
#line 149
  done___0 = (char *)tmp___0;
#line 150
  memset((void *)done___0, 0, (size_t )num_elements);
#line 153
  tmp___1 = xmalloc((unsigned long )num_elements * sizeof(int ));
#line 153
  class_elements = (int *)tmp___1;
#line 155
  fputc('[', fp);
#line 156
  e = 0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (e < num_elements)) {
#line 156
      goto while_break;
    }
#line 158
    if (! *(done___0 + e)) {
#line 160
      c = e;
#line 161
      count = (int )(elements + (elements + e)->class_element)->class_count;
#line 165
      i = 0;
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (! (i < count)) {
#line 165
          goto while_break___0;
        }
#line 166
        *(class_elements + i) = c;
#line 167
        *(done___0 + c) = (char)1;
#line 168
        c = (int )((elements + c)->next - elements);
#line 165
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 171
      qsort((void *)class_elements, (size_t )count, sizeof(int ), & elem_compare);
#line 173
      fputc('(', fp);
#line 174
      i = 0;
      }
      {
#line 174
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 174
        if (! (i < count)) {
#line 174
          goto while_break___1;
        }
#line 175
        if (i == 0) {
#line 175
          tmp___2 = "%d";
        } else {
#line 175
          tmp___2 = " %d";
        }
        {
#line 175
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___2,
                *(class_elements + i));
#line 174
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 176
      fputc(')', fp);
      }
    }
#line 156
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  fputc(']', fp);
#line 180
  free((void *)class_elements);
#line 181
  free((void *)done___0);
  }
#line 182
  return;
}
}
#line 67 "./../include/objalloc.h"
struct objalloc *objalloc_create(void) ;
#line 72
void *_objalloc_alloc(struct objalloc *o , unsigned long original_len ) ;
#line 108
void objalloc_free(struct objalloc *o ) ;
#line 113
void objalloc_free_block(struct objalloc *o , void *block ) ;
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./objalloc.c"
struct objalloc *objalloc_create(void) 
{ 
  struct objalloc *ret ;
  struct objalloc_chunk *chunk ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 91
  tmp___0 = malloc(sizeof(*ret));
#line 91
  ret = (struct objalloc *)tmp___0;
  }
#line 92
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 93
    return ((struct objalloc *)((void *)0));
  }
  {
#line 95
  tmp___1 = malloc((size_t )4064);
#line 95
  ret->chunks = tmp___1;
  }
#line 96
  if ((unsigned long )ret->chunks == (unsigned long )((void *)0)) {
    {
#line 98
    free((void *)ret);
    }
#line 99
    return ((struct objalloc *)((void *)0));
  }
#line 102
  chunk = (struct objalloc_chunk *)ret->chunks;
#line 103
  chunk->next = (struct objalloc_chunk *)((void *)0);
#line 104
  chunk->current_ptr = (char *)((void *)0);
#line 106
  ret->current_ptr = (char *)chunk + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL));
#line 107
  ret->current_space = (unsigned int )(4064UL - (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)));
#line 109
  return (ret);
}
}
#line 114 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./objalloc.c"
void *_objalloc_alloc(struct objalloc *o , unsigned long original_len ) 
{ 
  unsigned long len ;
  char *ret ;
  struct objalloc_chunk *chunk ;
  void *tmp___0 ;
  struct objalloc_chunk *chunk___0 ;
  void *tmp___1 ;
  struct objalloc *__o ;
  unsigned long __len ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 117
  len = original_len;
#line 121
  if (len == 0UL) {
#line 122
    len = 1UL;
  }
#line 124
  len = ((len + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL);
#line 128
  if (len + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)) < original_len) {
#line 129
    return ((void *)0);
  }
#line 131
  if (len <= (unsigned long )o->current_space) {
#line 133
    o->current_ptr += len;
#line 134
    o->current_space = (unsigned int )((unsigned long )o->current_space - len);
#line 135
    return ((void *)(o->current_ptr - len));
  }
#line 138
  if (len >= 512UL) {
    {
#line 143
    tmp___0 = malloc((((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)) + len);
#line 143
    ret = (char *)tmp___0;
    }
#line 144
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 145
      return ((void *)0);
    }
#line 147
    chunk = (struct objalloc_chunk *)ret;
#line 148
    chunk->next = (struct objalloc_chunk *)o->chunks;
#line 149
    chunk->current_ptr = o->current_ptr;
#line 151
    o->chunks = (void *)chunk;
#line 153
    return ((void *)(ret + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL))));
  } else {
    {
#line 159
    tmp___1 = malloc((size_t )4064);
#line 159
    chunk___0 = (struct objalloc_chunk *)tmp___1;
    }
#line 160
    if ((unsigned long )chunk___0 == (unsigned long )((void *)0)) {
#line 161
      return ((void *)0);
    }
#line 162
    chunk___0->next = (struct objalloc_chunk *)o->chunks;
#line 163
    chunk___0->current_ptr = (char *)((void *)0);
#line 165
    o->current_ptr = (char *)chunk___0 + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL));
#line 166
    o->current_space = (unsigned int )(4064UL - (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)));
#line 168
    o->chunks = (void *)chunk___0;
#line 170
    __o = o;
#line 170
    __len = len;
#line 170
    if (__len == 0UL) {
#line 170
      __len = 1UL;
    }
#line 170
    __len = ((__len + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL);
#line 170
    if (__len != 0UL) {
#line 170
      if (__len <= (unsigned long )__o->current_space) {
#line 170
        __o->current_ptr += __len;
#line 170
        __o->current_space = (unsigned int )((unsigned long )__o->current_space - __len);
#line 170
        tmp___3 = (void *)(__o->current_ptr - __len);
      } else {
        {
#line 170
        tmp___2 = _objalloc_alloc(__o, __len);
#line 170
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
#line 170
      tmp___2 = _objalloc_alloc(__o, __len);
#line 170
      tmp___3 = tmp___2;
      }
    }
#line 170
    return (tmp___3);
  }
}
}
#line 176 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./objalloc.c"
void objalloc_free(struct objalloc *o ) 
{ 
  struct objalloc_chunk *l ;
  struct objalloc_chunk *next ;

  {
#line 181
  l = (struct objalloc_chunk *)o->chunks;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
    {
#line 186
    next = l->next;
#line 187
    free((void *)l);
#line 188
    l = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  free((void *)o);
  }
#line 192
  return;
}
}
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./objalloc.c"
void objalloc_free_block(struct objalloc *o , void *block ) 
{ 
  struct objalloc_chunk *p ;
  struct objalloc_chunk *small ;
  char *b ;
  struct objalloc_chunk *q ;
  struct objalloc_chunk *first ;
  struct objalloc_chunk *next ;
  struct objalloc_chunk *q___0 ;
  char *current_ptr ;
  struct objalloc_chunk *next___0 ;

  {
#line 201
  b = (char *)block;
#line 205
  small = (struct objalloc_chunk *)((void *)0);
#line 206
  p = (struct objalloc_chunk *)o->chunks;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 206
      goto while_break;
    }
#line 208
    if ((unsigned long )p->current_ptr == (unsigned long )((void *)0)) {
#line 210
      if ((unsigned long )b > (unsigned long )((char *)p)) {
#line 210
        if ((unsigned long )b < (unsigned long )((char *)p + 4064)) {
#line 211
          goto while_break;
        }
      }
#line 212
      small = p;
    } else
#line 216
    if ((unsigned long )b == (unsigned long )((char *)p + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)))) {
#line 217
      goto while_break;
    }
#line 206
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 223
    abort();
    }
  }
#line 225
  if ((unsigned long )p->current_ptr == (unsigned long )((void *)0)) {
#line 237
    first = (struct objalloc_chunk *)((void *)0);
#line 238
    q = (struct objalloc_chunk *)o->chunks;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      if (! ((unsigned long )q != (unsigned long )p)) {
#line 239
        goto while_break___0;
      }
#line 243
      next = q->next;
#line 244
      if ((unsigned long )small != (unsigned long )((void *)0)) {
#line 246
        if ((unsigned long )small == (unsigned long )q) {
#line 247
          small = (struct objalloc_chunk *)((void *)0);
        }
        {
#line 248
        free((void *)q);
        }
      } else
#line 250
      if ((unsigned long )q->current_ptr > (unsigned long )b) {
        {
#line 251
        free((void *)q);
        }
      } else
#line 252
      if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 253
        first = q;
      }
#line 255
      q = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 259
      first = p;
    }
#line 260
    o->chunks = (void *)first;
#line 263
    o->current_ptr = b;
#line 264
    o->current_space = (unsigned int )(((char *)p + 4064) - b);
  } else {
#line 277
    current_ptr = p->current_ptr;
#line 278
    p = p->next;
#line 280
    q___0 = (struct objalloc_chunk *)o->chunks;
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 281
      if (! ((unsigned long )q___0 != (unsigned long )p)) {
#line 281
        goto while_break___1;
      }
      {
#line 285
      next___0 = q___0->next;
#line 286
      free((void *)q___0);
#line 287
      q___0 = next___0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    o->chunks = (void *)p;
    {
#line 292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 292
      if (! ((unsigned long )p->current_ptr != (unsigned long )((void *)0))) {
#line 292
        goto while_break___2;
      }
#line 293
      p = p->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 295
    o->current_ptr = current_ptr;
#line 296
    o->current_space = (unsigned int )(((char *)p + 4064) - current_ptr);
  }
#line 298
  return;
}
}
#line 104 "./../include/md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 110
void md5_process_block(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) ;
#line 117
void md5_process_bytes(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) ;
#line 127
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 136
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 142
int md5_stream(FILE *stream , void *resblock ) ;
#line 148
void *md5_buffer(char const   *buffer___2 , size_t len , void *resblock ) ;
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  md5_uint32 tmp___0 ;

  {
#line 67
  ctx->A = (md5_uint32 )1732584193;
#line 68
  ctx->B = 4023233417U;
#line 69
  ctx->C = 2562383102U;
#line 70
  ctx->D = (md5_uint32 )271733878;
#line 72
  tmp___0 = (md5_uint32 )0;
#line 72
  ctx->total[1] = tmp___0;
#line 72
  ctx->total[0] = tmp___0;
#line 73
  ctx->buflen = (md5_uint32 )0;
#line 74
  return;
}
}
#line 81 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  md5_uint32 buffer___2[4] ;

  {
  {
#line 86
  buffer___2[0] = (md5_uint32 )ctx->A;
#line 87
  buffer___2[1] = (md5_uint32 )ctx->B;
#line 88
  buffer___2[2] = (md5_uint32 )ctx->C;
#line 89
  buffer___2[3] = (md5_uint32 )ctx->D;
#line 91
  memcpy((void */* __restrict  */)resbuf, (void const   */* __restrict  */)(buffer___2),
         (size_t )16);
  }
#line 93
  return (resbuf);
}
}
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  md5_uint32 bytes ;
  md5_uint32 swap_bytes ;
  size_t pad ;
  void *tmp___0 ;

  {
#line 105
  bytes = ctx->buflen;
#line 110
  ctx->total[0] += bytes;
#line 111
  if (ctx->total[0] < bytes) {
#line 112
    (ctx->total[1]) ++;
  }
#line 114
  if (bytes >= 56U) {
#line 114
    pad = (size_t )(120U - bytes);
  } else {
#line 114
    pad = (size_t )(56U - bytes);
  }
  {
#line 115
  memcpy((void */* __restrict  */)(& ctx->buffer[bytes]), (void const   */* __restrict  */)(fillbuf___0),
         pad);
#line 120
  swap_bytes = ctx->total[0] << 3;
#line 121
  memcpy((void */* __restrict  */)(& ctx->buffer[(size_t )bytes + pad]), (void const   */* __restrict  */)(& swap_bytes),
         sizeof(swap_bytes));
#line 122
  swap_bytes = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 123
  memcpy((void */* __restrict  */)(& ctx->buffer[((size_t )bytes + pad) + 4UL]), (void const   */* __restrict  */)(& swap_bytes),
         sizeof(swap_bytes));
#line 126
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 128
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 128
  return (tmp___0);
}
}
#line 134 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer___2[4168] ;
  size_t sum ;
  size_t n ;
  int tmp___0 ;

  {
  {
#line 144
  md5_init_ctx(& ctx);
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    sum = (size_t )0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 158
      n = fread((void */* __restrict  */)(buffer___2 + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 160
      sum += n;
      }
#line 156
      if (sum < 4096UL) {
#line 156
        if (! (n != 0UL)) {
#line 156
          goto while_break___0;
        }
      } else {
#line 156
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    if (n == 0UL) {
      {
#line 163
      tmp___0 = ferror(stream);
      }
#line 163
      if (tmp___0) {
#line 164
        return (1);
      }
    }
#line 167
    if (n == 0UL) {
#line 168
      goto while_break;
    }
    {
#line 173
    md5_process_block((void const   *)(buffer___2), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (sum > 0UL) {
    {
#line 178
    md5_process_bytes((void const   *)(buffer___2), sum, & ctx);
    }
  }
  {
#line 181
  md5_finish_ctx(& ctx, resblock);
  }
#line 182
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void *md5_buffer(char const   *buffer___2 , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp___0 ;

  {
  {
#line 195
  md5_init_ctx(& ctx);
#line 198
  md5_process_bytes((void const   *)buffer___2, len, & ctx);
#line 201
  tmp___0 = md5_finish_ctx(& ctx, resblock);
  }
#line 201
  return (tmp___0);
}
}
#line 205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void md5_process_bytes(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp___0 ;

  {
#line 210
  if (ctx->buflen != 0U) {
#line 212
    left_over = (size_t )ctx->buflen;
#line 213
    if (128UL - left_over > len) {
#line 213
      tmp___0 = len;
    } else {
#line 213
      tmp___0 = 128UL - left_over;
    }
    {
#line 213
    add = tmp___0;
#line 215
    memcpy((void */* __restrict  */)(& ctx->buffer[left_over]), (void const   */* __restrict  */)buffer___2,
           add);
#line 216
    ctx->buflen = (md5_uint32 )((size_t )ctx->buflen + add);
    }
#line 218
    if (left_over + add > 64UL) {
      {
#line 220
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
#line 222
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL]),
             (left_over + add) & 63UL);
#line 224
      ctx->buflen = (md5_uint32 )((left_over + add) & 63UL);
      }
    }
#line 227
    buffer___2 = (void const   *)((char const   *)buffer___2 + add);
#line 228
    len -= add;
  }
#line 232
  if (len > 64UL) {
#line 242
    if ((md5_uintptr )buffer___2 % __alignof__(md5_uint32 ) != 0UL) {
      {
#line 243
      while (1) {
        while_continue: /* CIL Label */ ;
#line 243
        if (! (len > 64UL)) {
#line 243
          goto while_break;
        }
        {
#line 245
        memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
               (size_t )64);
#line 246
        md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 247
        buffer___2 = (void const   *)((char const   *)buffer___2 + 64);
#line 248
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 253
      md5_process_block(buffer___2, len & 0xffffffffffffffc0UL, ctx);
#line 254
      buffer___2 = (void const   *)((char const   *)buffer___2 + (len & 0xffffffffffffffc0UL));
#line 255
      len &= 63UL;
      }
    }
  }
#line 260
  if (len > 0UL) {
    {
#line 262
    memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
           len);
#line 263
    ctx->buflen = (md5_uint32 )len;
    }
  }
#line 265
  return;
}
}
#line 280 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./md5.c"
void md5_process_block(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) 
{ 
  md5_uint32 correct_words[16] ;
  md5_uint32 const   *words ;
  size_t nwords ;
  md5_uint32 const   *endp ;
  md5_uint32 A ;
  md5_uint32 B ;
  md5_uint32 C ;
  md5_uint32 D ;
  md5_uint32 *cwp ;
  md5_uint32 A_save ;
  md5_uint32 B_save ;
  md5_uint32 C_save ;
  md5_uint32 D_save ;
  md5_uint32 *tmp___0 ;
  md5_uint32 tmp___1 ;
  md5_uint32 *tmp___2 ;
  md5_uint32 tmp___3 ;
  md5_uint32 *tmp___4 ;
  md5_uint32 tmp___5 ;
  md5_uint32 *tmp___6 ;
  md5_uint32 tmp___7 ;
  md5_uint32 *tmp___8 ;
  md5_uint32 tmp___9 ;
  md5_uint32 *tmp___10 ;
  md5_uint32 tmp___11 ;
  md5_uint32 *tmp___12 ;
  md5_uint32 tmp___13 ;
  md5_uint32 *tmp___14 ;
  md5_uint32 tmp___15 ;
  md5_uint32 *tmp___16 ;
  md5_uint32 tmp___17 ;
  md5_uint32 *tmp___18 ;
  md5_uint32 tmp___19 ;
  md5_uint32 *tmp___20 ;
  md5_uint32 tmp___21 ;
  md5_uint32 *tmp___22 ;
  md5_uint32 tmp___23 ;
  md5_uint32 *tmp___24 ;
  md5_uint32 tmp___25 ;
  md5_uint32 *tmp___26 ;
  md5_uint32 tmp___27 ;
  md5_uint32 *tmp___28 ;
  md5_uint32 tmp___29 ;
  md5_uint32 *tmp___30 ;
  md5_uint32 tmp___31 ;

  {
#line 284
  words = (md5_uint32 const   *)buffer___2;
#line 285
  nwords = len / sizeof(md5_uint32 );
#line 286
  endp = words + nwords;
#line 287
  A = ctx->A;
#line 288
  B = ctx->B;
#line 289
  C = ctx->C;
#line 290
  D = ctx->D;
#line 295
  ctx->total[0] = (md5_uint32 )((size_t )ctx->total[0] + len);
#line 296
  ctx->total[1] = (md5_uint32 )((size_t )ctx->total[1] + (((len >> 31) >> 1) + (size_t )((size_t )ctx->total[0] < len)));
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 300
      goto while_break;
    }
#line 302
    cwp = correct_words;
#line 303
    A_save = A;
#line 304
    B_save = B;
#line 305
    C_save = C;
#line 306
    D_save = D;
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 336
      tmp___0 = cwp;
#line 336
      cwp ++;
#line 336
      tmp___1 = (md5_uint32 )*words;
#line 336
      *tmp___0 = tmp___1;
#line 336
      A += ((D ^ (B & (C ^ D))) + tmp___1) + 3614090360U;
#line 336
      words ++;
#line 336
      A = (A << 7) | (A >> 25);
#line 336
      A += B;
#line 336
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      tmp___2 = cwp;
#line 337
      cwp ++;
#line 337
      tmp___3 = (md5_uint32 )*words;
#line 337
      *tmp___2 = tmp___3;
#line 337
      D += ((C ^ (A & (B ^ C))) + tmp___3) + 3905402710U;
#line 337
      words ++;
#line 337
      D = (D << 12) | (D >> 20);
#line 337
      D += A;
#line 337
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 338
      tmp___4 = cwp;
#line 338
      cwp ++;
#line 338
      tmp___5 = (md5_uint32 )*words;
#line 338
      *tmp___4 = tmp___5;
#line 338
      C += ((B ^ (D & (A ^ B))) + tmp___5) + 606105819U;
#line 338
      words ++;
#line 338
      C = (C << 17) | (C >> 15);
#line 338
      C += D;
#line 338
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 339
      tmp___6 = cwp;
#line 339
      cwp ++;
#line 339
      tmp___7 = (md5_uint32 )*words;
#line 339
      *tmp___6 = tmp___7;
#line 339
      B += ((A ^ (C & (D ^ A))) + tmp___7) + 3250441966U;
#line 339
      words ++;
#line 339
      B = (B << 22) | (B >> 10);
#line 339
      B += C;
#line 339
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 340
      tmp___8 = cwp;
#line 340
      cwp ++;
#line 340
      tmp___9 = (md5_uint32 )*words;
#line 340
      *tmp___8 = tmp___9;
#line 340
      A += ((D ^ (B & (C ^ D))) + tmp___9) + 4118548399U;
#line 340
      words ++;
#line 340
      A = (A << 7) | (A >> 25);
#line 340
      A += B;
#line 340
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 341
      tmp___10 = cwp;
#line 341
      cwp ++;
#line 341
      tmp___11 = (md5_uint32 )*words;
#line 341
      *tmp___10 = tmp___11;
#line 341
      D += ((C ^ (A & (B ^ C))) + tmp___11) + 1200080426U;
#line 341
      words ++;
#line 341
      D = (D << 12) | (D >> 20);
#line 341
      D += A;
#line 341
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 342
      tmp___12 = cwp;
#line 342
      cwp ++;
#line 342
      tmp___13 = (md5_uint32 )*words;
#line 342
      *tmp___12 = tmp___13;
#line 342
      C += ((B ^ (D & (A ^ B))) + tmp___13) + 2821735955U;
#line 342
      words ++;
#line 342
      C = (C << 17) | (C >> 15);
#line 342
      C += D;
#line 342
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 343
      tmp___14 = cwp;
#line 343
      cwp ++;
#line 343
      tmp___15 = (md5_uint32 )*words;
#line 343
      *tmp___14 = tmp___15;
#line 343
      B += ((A ^ (C & (D ^ A))) + tmp___15) + 4249261313U;
#line 343
      words ++;
#line 343
      B = (B << 22) | (B >> 10);
#line 343
      B += C;
#line 343
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 344
      tmp___16 = cwp;
#line 344
      cwp ++;
#line 344
      tmp___17 = (md5_uint32 )*words;
#line 344
      *tmp___16 = tmp___17;
#line 344
      A += ((D ^ (B & (C ^ D))) + tmp___17) + 1770035416U;
#line 344
      words ++;
#line 344
      A = (A << 7) | (A >> 25);
#line 344
      A += B;
#line 344
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 345
      tmp___18 = cwp;
#line 345
      cwp ++;
#line 345
      tmp___19 = (md5_uint32 )*words;
#line 345
      *tmp___18 = tmp___19;
#line 345
      D += ((C ^ (A & (B ^ C))) + tmp___19) + 2336552879U;
#line 345
      words ++;
#line 345
      D = (D << 12) | (D >> 20);
#line 345
      D += A;
#line 345
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 346
      tmp___20 = cwp;
#line 346
      cwp ++;
#line 346
      tmp___21 = (md5_uint32 )*words;
#line 346
      *tmp___20 = tmp___21;
#line 346
      C += ((B ^ (D & (A ^ B))) + tmp___21) + 4294925233U;
#line 346
      words ++;
#line 346
      C = (C << 17) | (C >> 15);
#line 346
      C += D;
#line 346
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 347
      tmp___22 = cwp;
#line 347
      cwp ++;
#line 347
      tmp___23 = (md5_uint32 )*words;
#line 347
      *tmp___22 = tmp___23;
#line 347
      B += ((A ^ (C & (D ^ A))) + tmp___23) + 2304563134U;
#line 347
      words ++;
#line 347
      B = (B << 22) | (B >> 10);
#line 347
      B += C;
#line 347
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 348
      tmp___24 = cwp;
#line 348
      cwp ++;
#line 348
      tmp___25 = (md5_uint32 )*words;
#line 348
      *tmp___24 = tmp___25;
#line 348
      A += ((D ^ (B & (C ^ D))) + tmp___25) + 1804603682U;
#line 348
      words ++;
#line 348
      A = (A << 7) | (A >> 25);
#line 348
      A += B;
#line 348
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 349
      tmp___26 = cwp;
#line 349
      cwp ++;
#line 349
      tmp___27 = (md5_uint32 )*words;
#line 349
      *tmp___26 = tmp___27;
#line 349
      D += ((C ^ (A & (B ^ C))) + tmp___27) + 4254626195U;
#line 349
      words ++;
#line 349
      D = (D << 12) | (D >> 20);
#line 349
      D += A;
#line 349
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 350
      tmp___28 = cwp;
#line 350
      cwp ++;
#line 350
      tmp___29 = (md5_uint32 )*words;
#line 350
      *tmp___28 = tmp___29;
#line 350
      C += ((B ^ (D & (A ^ B))) + tmp___29) + 2792965006U;
#line 350
      words ++;
#line 350
      C = (C << 17) | (C >> 15);
#line 350
      C += D;
#line 350
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 351
      tmp___30 = cwp;
#line 351
      cwp ++;
#line 351
      tmp___31 = (md5_uint32 )*words;
#line 351
      *tmp___30 = tmp___31;
#line 351
      B += ((A ^ (C & (D ^ A))) + tmp___31) + 1236535329U;
#line 351
      words ++;
#line 351
      B = (B << 22) | (B >> 10);
#line 351
      B += C;
#line 351
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 369
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 369
      A = (A << 5) | (A >> 27);
#line 369
      A += B;
#line 369
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 370
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 370
      D = (D << 9) | (D >> 23);
#line 370
      D += A;
#line 370
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 371
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 371
      C = (C << 14) | (C >> 18);
#line 371
      C += D;
#line 371
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 372
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 372
      B = (B << 20) | (B >> 12);
#line 372
      B += C;
#line 372
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 373
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 373
      A = (A << 5) | (A >> 27);
#line 373
      A += B;
#line 373
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 374
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 374
      D = (D << 9) | (D >> 23);
#line 374
      D += A;
#line 374
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 375
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 375
      C = (C << 14) | (C >> 18);
#line 375
      C += D;
#line 375
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 376
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 376
      B = (B << 20) | (B >> 12);
#line 376
      B += C;
#line 376
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 377
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 377
      A = (A << 5) | (A >> 27);
#line 377
      A += B;
#line 377
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 378
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 378
      D = (D << 9) | (D >> 23);
#line 378
      D += A;
#line 378
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 379
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 379
      C = (C << 14) | (C >> 18);
#line 379
      C += D;
#line 379
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 380
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 380
      B = (B << 20) | (B >> 12);
#line 380
      B += C;
#line 380
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 381
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 381
      A = (A << 5) | (A >> 27);
#line 381
      A += B;
#line 381
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 382
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 382
      D = (D << 9) | (D >> 23);
#line 382
      D += A;
#line 382
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 383
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 383
      C = (C << 14) | (C >> 18);
#line 383
      C += D;
#line 383
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 384
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 384
      B = (B << 20) | (B >> 12);
#line 384
      B += C;
#line 384
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 390
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 390
      A = (A << 4) | (A >> 28);
#line 390
      A += B;
#line 390
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 391
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 391
      D = (D << 11) | (D >> 21);
#line 391
      D += A;
#line 391
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 392
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 392
      C = (C << 16) | (C >> 16);
#line 392
      C += D;
#line 392
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 393
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 393
      B = (B << 23) | (B >> 9);
#line 393
      B += C;
#line 393
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 394
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 394
      A = (A << 4) | (A >> 28);
#line 394
      A += B;
#line 394
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 395
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 395
      D = (D << 11) | (D >> 21);
#line 395
      D += A;
#line 395
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 396
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 396
      C = (C << 16) | (C >> 16);
#line 396
      C += D;
#line 396
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 397
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 397
      B = (B << 23) | (B >> 9);
#line 397
      B += C;
#line 397
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 398
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 398
      A = (A << 4) | (A >> 28);
#line 398
      A += B;
#line 398
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 399
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 399
      D = (D << 11) | (D >> 21);
#line 399
      D += A;
#line 399
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 400
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 400
      C = (C << 16) | (C >> 16);
#line 400
      C += D;
#line 400
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 401
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 401
      B = (B << 23) | (B >> 9);
#line 401
      B += C;
#line 401
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 402
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 402
      A = (A << 4) | (A >> 28);
#line 402
      A += B;
#line 402
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 403
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 403
      D = (D << 11) | (D >> 21);
#line 403
      D += A;
#line 403
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 404
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 404
      C = (C << 16) | (C >> 16);
#line 404
      C += D;
#line 404
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 405
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 405
      B = (B << 23) | (B >> 9);
#line 405
      B += C;
#line 405
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 411
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 411
      A = (A << 6) | (A >> 26);
#line 411
      A += B;
#line 411
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 412
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 412
      D = (D << 10) | (D >> 22);
#line 412
      D += A;
#line 412
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 413
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 413
      C = (C << 15) | (C >> 17);
#line 413
      C += D;
#line 413
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 414
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 414
      B = (B << 21) | (B >> 11);
#line 414
      B += C;
#line 414
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 415
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 415
      A = (A << 6) | (A >> 26);
#line 415
      A += B;
#line 415
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 416
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 416
      D = (D << 10) | (D >> 22);
#line 416
      D += A;
#line 416
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 417
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 417
      C = (C << 15) | (C >> 17);
#line 417
      C += D;
#line 417
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 418
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 418
      B = (B << 21) | (B >> 11);
#line 418
      B += C;
#line 418
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 419
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 419
      A = (A << 6) | (A >> 26);
#line 419
      A += B;
#line 419
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 420
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 420
      D = (D << 10) | (D >> 22);
#line 420
      D += A;
#line 420
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 421
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 421
      C = (C << 15) | (C >> 17);
#line 421
      C += D;
#line 421
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 422
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 422
      B = (B << 21) | (B >> 11);
#line 422
      B += C;
#line 422
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 423
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 423
      A = (A << 6) | (A >> 26);
#line 423
      A += B;
#line 423
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 424
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 424
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 424
      D = (D << 10) | (D >> 22);
#line 424
      D += A;
#line 424
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 425
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 425
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 425
      C = (C << 15) | (C >> 17);
#line 425
      C += D;
#line 425
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 426
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 426
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 426
      B = (B << 21) | (B >> 11);
#line 426
      B += C;
#line 426
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 429
    A += A_save;
#line 430
    B += B_save;
#line 431
    C += C_save;
#line 432
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  ctx->A = A;
#line 437
  ctx->B = B;
#line 438
  ctx->C = C;
#line 439
  ctx->D = D;
#line 440
  return;
}
}
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
__inline static char const   *try_dir(char const   *dir , char const   *base ) ;
#line 73 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
__inline static char const   *try_dir(char const   *dir , char const   *base ) 
{ 
  int tmp___0 ;

  {
#line 76
  if ((unsigned long )base != (unsigned long )((char const   *)0)) {
#line 77
    return (base);
  }
#line 78
  if ((unsigned long )dir != (unsigned long )((char const   *)0)) {
    {
#line 78
    tmp___0 = access(dir, 7);
    }
#line 78
    if (tmp___0 == 0) {
#line 80
      return (dir);
    }
  }
#line 81
  return ((char const   *)0);
}
}
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
static char const   tmp[5]  = {      (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
static char const   usrtmp[9]  = 
#line 85
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
static char const   vartmp[9]  = 
#line 87
  {      (char const   )'/',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
static char *memoized_tmpdir  ;
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
char *choose_tmpdir(void) 
{ 
  char const   *base ;
  char *tmpdir ;
  unsigned int len ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 108
  if (! memoized_tmpdir) {
    {
#line 111
    base = (char const   *)0;
#line 119
    tmp___0 = getenv("TMPDIR");
#line 119
    base = try_dir((char const   *)tmp___0, base);
#line 120
    tmp___1 = getenv("TMP");
#line 120
    base = try_dir((char const   *)tmp___1, base);
#line 121
    tmp___2 = getenv("TEMP");
#line 121
    base = try_dir((char const   *)tmp___2, base);
#line 127
    tmp___3 = strcmp("/tmp", "\\");
    }
#line 127
    if (tmp___3 == 0) {
      {
#line 128
      base = try_dir("\\.", base);
      }
    } else {
      {
#line 130
      base = try_dir("/tmp", base);
      }
    }
    {
#line 134
    base = try_dir(vartmp, base);
#line 135
    base = try_dir(usrtmp, base);
#line 136
    base = try_dir(tmp, base);
    }
#line 139
    if ((unsigned long )base == (unsigned long )((char const   *)0)) {
#line 140
      base = ".";
    }
    {
#line 143
    tmp___4 = strlen(base);
#line 143
    len = (unsigned int )tmp___4;
#line 144
    tmp___5 = xmalloc(sizeof(char ) * (unsigned long )(len + 2U));
#line 144
    tmpdir = (char *)tmp___5;
#line 145
    strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)base);
#line 146
    *(tmpdir + len) = (char )'/';
#line 147
    *(tmpdir + (len + 1U)) = (char )'\000';
#line 148
    memoized_tmpdir = tmpdir;
    }
  }
#line 169
  return (memoized_tmpdir);
}
}
#line 184
char *make_temp_file(char const   *suffix )  __attribute__((__malloc__)) ;
#line 184 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-temp-file.c"
char *make_temp_file(char const   *suffix ) 
{ 
  char const   *base ;
  char *tmp___0 ;
  char *temp_filename ;
  int base_len ;
  int suffix_len ;
  int fd ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 187
  tmp___0 = choose_tmpdir();
#line 187
  base = (char const   *)tmp___0;
  }
#line 192
  if ((unsigned long )suffix == (unsigned long )((char const   *)0)) {
#line 193
    suffix = "";
  }
  {
#line 195
  tmp___1 = strlen(base);
#line 195
  base_len = (int )tmp___1;
#line 196
  tmp___2 = strlen(suffix);
#line 196
  suffix_len = (int )tmp___2;
#line 198
  tmp___3 = xmalloc(sizeof(char ) * ((((unsigned long )base_len + (sizeof("ccXXXXXX") - 1UL)) + (unsigned long )suffix_len) + 1UL));
#line 198
  temp_filename = (char *)tmp___3;
#line 201
  strcpy((char */* __restrict  */)temp_filename, (char const   */* __restrict  */)base);
#line 202
  strcpy((char */* __restrict  */)(temp_filename + base_len), (char const   */* __restrict  */)"ccXXXXXX");
#line 203
  strcpy((char */* __restrict  */)((temp_filename + base_len) + (sizeof("ccXXXXXX") - 1UL)),
         (char const   */* __restrict  */)suffix);
#line 205
  fd = mkstemps(temp_filename, suffix_len);
  }
#line 207
  if (fd == -1) {
    {
#line 209
    tmp___4 = __errno_location();
#line 209
    tmp___5 = strerror(*tmp___4);
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create temporary file in %s: %s\n",
            base, tmp___5);
#line 211
    abort();
    }
  }
  {
#line 214
  tmp___6 = close(fd);
  }
#line 214
  if (tmp___6) {
    {
#line 215
    abort();
    }
  }
#line 216
  return (temp_filename);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 121 "./../include/libiberty.h"
char const   *lbasename(char const   *name___0 ) ;
#line 136
char *lrealpath(char const   *filename ) ;
#line 217
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix )  __attribute__((__malloc__)) ;
#line 224
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) ;
#line 103
static char **split_directories(char const   *name___0 , int *ptr_num_dirs ) ;
#line 104
static void free_split_directories(char **dirs ) ;
#line 106 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) 
{ 
  char *result ;
  void *tmp___0 ;

  {
  {
#line 109
  tmp___0 = malloc((size_t )(len + 1));
#line 109
  result = (char *)tmp___0;
#line 111
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)s, (size_t )len);
#line 112
  *(result + len) = (char)0;
  }
#line 113
  return (result);
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
static char **split_directories(char const   *name___0 , int *ptr_num_dirs ) 
{ 
  int num_dirs ;
  char **dirs ;
  char const   *p ;
  char const   *q ;
  int ch ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 121
  num_dirs = 0;
#line 128
  p = name___0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    tmp___0 = p;
#line 137
    p ++;
#line 137
    ch = (int )*tmp___0;
#line 137
    if (! (ch != 0)) {
#line 137
      goto while_break;
    }
#line 139
    if (ch == 47) {
#line 141
      num_dirs ++;
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 142
        if (! ((int const   )*p == 47)) {
#line 142
          goto while_break___0;
        }
#line 143
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp___1 = malloc(sizeof(char *) * (unsigned long )(num_dirs + 2));
#line 147
  dirs = (char **)tmp___1;
  }
#line 148
  if ((unsigned long )dirs == (unsigned long )((void *)0)) {
#line 149
    return ((char **)((void *)0));
  }
#line 152
  num_dirs = 0;
#line 153
  p = name___0;
#line 167
  q = p;
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 168
    tmp___3 = p;
#line 168
    p ++;
#line 168
    ch = (int )*tmp___3;
#line 168
    if (! (ch != 0)) {
#line 168
      goto while_break___1;
    }
#line 170
    if (ch == 47) {
      {
#line 172
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 172
        if (! ((int const   )*p == 47)) {
#line 172
          goto while_break___2;
        }
#line 173
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 175
      tmp___2 = num_dirs;
#line 175
      num_dirs ++;
#line 175
      *(dirs + tmp___2) = save_string(q, (int )(p - q));
      }
#line 176
      if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
        {
#line 178
        *(dirs + num_dirs) = (char *)((void *)0);
#line 179
        free_split_directories(dirs);
        }
#line 180
        return ((char **)((void *)0));
      }
#line 182
      q = p;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  if ((p - 1) - q > 0L) {
    {
#line 187
    tmp___4 = num_dirs;
#line 187
    num_dirs ++;
#line 187
    *(dirs + tmp___4) = save_string(q, (int )((p - 1) - q));
    }
  }
#line 188
  *(dirs + num_dirs) = (char *)((void *)0);
#line 190
  if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
    {
#line 192
    free_split_directories(dirs);
    }
#line 193
    return ((char **)((void *)0));
  }
#line 196
  if (ptr_num_dirs) {
#line 197
    *ptr_num_dirs = num_dirs;
  }
#line 198
  return (dirs);
}
}
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
static void free_split_directories(char **dirs ) 
{ 
  int i ;
  int tmp___0 ;

  {
#line 206
  i = 0;
#line 208
  if ((unsigned long )dirs != (unsigned long )((void *)0)) {
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 210
      if (! ((unsigned long )*(dirs + i) != (unsigned long )((void *)0))) {
#line 210
        goto while_break;
      }
      {
#line 211
      tmp___0 = i;
#line 211
      i ++;
#line 211
      free((void *)*(dirs + tmp___0));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 213
    free((void *)((char *)dirs));
    }
  }
#line 215
  return;
}
}
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
static char *make_relative_prefix_1(char const   *progname , char const   *bin_prefix ,
                                    char const   *prefix , int const   resolve_links ) 
{ 
  char **prog_dirs ;
  char **bin_dirs ;
  char **prefix_dirs ;
  int prog_num ;
  int bin_num ;
  int prefix_num ;
  int i ;
  int n ;
  int common ;
  int needed_len ;
  char *ret ;
  char *ptr ;
  char *full_progname ;
  char *temp ;
  char *startp ;
  char *endp ;
  char *nstore ;
  size_t prefixlen ;
  size_t tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  struct stat st ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;

  {
#line 231
  prog_dirs = (char **)((void *)0);
#line 231
  bin_dirs = (char **)((void *)0);
#line 231
  prefix_dirs = (char **)((void *)0);
#line 235
  ret = (char *)((void *)0);
#line 237
  if ((unsigned long )progname == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  } else
#line 237
  if ((unsigned long )bin_prefix == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  } else
#line 237
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  }
  {
#line 242
  tmp___5 = lbasename(progname);
  }
#line 242
  if ((unsigned long )tmp___5 == (unsigned long )progname) {
    {
#line 246
    temp = getenv("PATH");
    }
#line 247
    if (temp) {
      {
#line 250
      tmp___0 = strlen((char const   *)temp);
#line 250
      prefixlen = tmp___0 + 1UL;
      }
#line 252
      if (prefixlen < 2UL) {
#line 253
        prefixlen = (size_t )2;
      }
      {
#line 255
      tmp___1 = strlen(progname);
#line 255
      len = (prefixlen + tmp___1) + 1UL;
#line 259
      tmp___2 = __builtin_alloca(len);
#line 259
      nstore = (char *)tmp___2;
#line 261
      endp = temp;
#line 261
      startp = endp;
      }
      {
#line 262
      while (1) {
        while_continue: /* CIL Label */ ;
#line 264
        if ((int )*endp == 58) {
#line 264
          goto _L;
        } else
#line 264
        if ((int )*endp == 0) {
          _L: /* CIL Label */ 
#line 266
          if ((unsigned long )endp == (unsigned long )startp) {
#line 268
            *(nstore + 0) = (char )'.';
#line 269
            *(nstore + 1) = (char )'/';
#line 270
            *(nstore + 2) = (char )'\000';
          } else {
            {
#line 274
            memcpy((void */* __restrict  */)nstore, (void const   */* __restrict  */)startp,
                   (size_t )(endp - startp));
            }
#line 275
            if (! ((int )*(endp + -1) == 47)) {
#line 277
              *(nstore + (endp - startp)) = (char )'/';
#line 278
              *(nstore + ((endp - startp) + 1L)) = (char)0;
            } else {
#line 281
              *(nstore + (endp - startp)) = (char)0;
            }
          }
          {
#line 283
          strcat((char */* __restrict  */)nstore, (char const   */* __restrict  */)progname);
#line 284
          tmp___4 = access((char const   *)nstore, 1);
          }
#line 284
          if (! tmp___4) {
            {
#line 292
            tmp___3 = stat((char const   */* __restrict  */)nstore, (struct stat */* __restrict  */)(& st));
            }
#line 292
            if (tmp___3 >= 0) {
#line 292
              if ((st.st_mode & 61440U) == 32768U) {
#line 295
                progname = (char const   *)nstore;
#line 296
                goto while_break;
              }
            }
          }
#line 300
          if ((int )*endp == 0) {
#line 301
            goto while_break;
          }
#line 302
          startp = endp + 1;
#line 302
          endp = startp;
        } else {
#line 305
          endp ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 310
  if (resolve_links) {
    {
#line 311
    full_progname = lrealpath(progname);
    }
  } else {
    {
#line 313
    full_progname = strdup(progname);
    }
  }
#line 314
  if ((unsigned long )full_progname == (unsigned long )((void *)0)) {
#line 315
    return ((char *)((void *)0));
  }
  {
#line 317
  prog_dirs = split_directories((char const   *)full_progname, & prog_num);
#line 318
  free((void *)full_progname);
  }
#line 319
  if ((unsigned long )prog_dirs == (unsigned long )((void *)0)) {
#line 320
    return ((char *)((void *)0));
  }
  {
#line 322
  bin_dirs = split_directories(bin_prefix, & bin_num);
  }
#line 323
  if ((unsigned long )bin_dirs == (unsigned long )((void *)0)) {
#line 324
    goto bailout;
  }
#line 327
  prog_num --;
#line 333
  if (prog_num == bin_num) {
#line 335
    i = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (i < bin_num)) {
#line 335
        goto while_break___0;
      }
      {
#line 337
      tmp___6 = strcmp((char const   *)*(prog_dirs + i), (char const   *)*(bin_dirs + i));
      }
#line 337
      if (tmp___6 != 0) {
#line 338
        goto while_break___0;
      }
#line 335
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    if (prog_num <= 0) {
#line 342
      goto bailout;
    } else
#line 341
    if (i == bin_num) {
#line 342
      goto bailout;
    }
  }
  {
#line 345
  prefix_dirs = split_directories(prefix, & prefix_num);
  }
#line 346
  if ((unsigned long )prefix_dirs == (unsigned long )((void *)0)) {
#line 347
    goto bailout;
  }
#line 350
  if (prefix_num < bin_num) {
#line 350
    n = prefix_num;
  } else {
#line 350
    n = bin_num;
  }
#line 351
  common = 0;
  {
#line 351
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 351
    if (! (common < n)) {
#line 351
      goto while_break___1;
    }
    {
#line 353
    tmp___7 = strcmp((char const   *)*(bin_dirs + common), (char const   *)*(prefix_dirs + common));
    }
#line 353
    if (tmp___7 != 0) {
#line 354
      goto while_break___1;
    }
#line 351
    common ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 358
  if (common == 0) {
#line 359
    goto bailout;
  }
#line 363
  needed_len = 0;
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 364
    if (! (i < prog_num)) {
#line 364
      goto while_break___2;
    }
    {
#line 365
    tmp___8 = strlen((char const   *)*(prog_dirs + i));
#line 365
    needed_len = (int )((size_t )needed_len + tmp___8);
#line 364
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 366
  needed_len = (int )((unsigned long )needed_len + sizeof("..") * (unsigned long )(bin_num - common));
#line 367
  i = common;
  {
#line 367
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 367
    if (! (i < prefix_num)) {
#line 367
      goto while_break___3;
    }
    {
#line 368
    tmp___9 = strlen((char const   *)*(prefix_dirs + i));
#line 368
    needed_len = (int )((size_t )needed_len + tmp___9);
#line 367
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 369
  needed_len ++;
#line 371
  tmp___10 = malloc((size_t )needed_len);
#line 371
  ret = (char *)tmp___10;
  }
#line 372
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 373
    goto bailout;
  }
#line 376
  *ret = (char )'\000';
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 377
    if (! (i < prog_num)) {
#line 377
      goto while_break___4;
    }
    {
#line 378
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prog_dirs + i));
#line 377
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 381
  tmp___11 = strlen((char const   *)ret);
#line 381
  ptr = ret + tmp___11;
#line 382
  i = common;
  }
  {
#line 382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 382
    if (! (i < bin_num)) {
#line 382
      goto while_break___5;
    }
    {
#line 384
    strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"..");
#line 385
    ptr += sizeof("..") - 1UL;
#line 386
    tmp___12 = ptr;
#line 386
    ptr ++;
#line 386
    *tmp___12 = (char )'/';
#line 382
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 388
  *ptr = (char )'\000';
#line 391
  i = common;
  {
#line 391
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 391
    if (! (i < prefix_num)) {
#line 391
      goto while_break___6;
    }
    {
#line 392
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prefix_dirs + i));
#line 391
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  bailout: 
  {
#line 395
  free_split_directories(prog_dirs);
#line 396
  free_split_directories(bin_dirs);
#line 397
  free_split_directories(prefix_dirs);
  }
#line 399
  return (ret);
}
}
#line 408
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix )  __attribute__((__malloc__)) ;
#line 408 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix ) 
{ 
  char *tmp___0 ;

  {
  {
#line 412
  tmp___0 = make_relative_prefix_1(progname, bin_prefix, prefix, (int const   )1);
  }
#line 412
  return (tmp___0);
}
}
#line 420
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 420 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./make-relative-prefix.c"
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix ) 
{ 
  char *tmp___0 ;

  {
  {
#line 425
  tmp___0 = make_relative_prefix_1(progname, bin_prefix, prefix, (int const   )0);
  }
#line 425
  return (tmp___0);
}
}
#line 797 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 56 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./lrealpath.c"
extern char *canonicalize_file_name(char const   * ) ;
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./lrealpath.c"
char *lrealpath(char const   *filename ) 
{ 
  char buf___7[4096] ;
  char const   *rp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *rp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long path_max ;
  long tmp___4 ;
  char *buf___8 ;
  char *rp___1 ;
  char *ret ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 85
  tmp___0 = realpath((char const   */* __restrict  */)filename, (char */* __restrict  */)(buf___7));
#line 85
  rp = (char const   *)tmp___0;
  }
#line 86
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 87
    rp = filename;
  }
  {
#line 88
  tmp___1 = strdup(rp);
  }
#line 88
  return (tmp___1);
  {
#line 97
  tmp___2 = canonicalize_file_name(filename);
#line 97
  rp___0 = tmp___2;
  }
#line 98
  if ((unsigned long )rp___0 == (unsigned long )((void *)0)) {
    {
#line 99
    tmp___3 = strdup(filename);
    }
#line 99
    return (tmp___3);
  } else {
#line 101
    return (rp___0);
  }
  {
#line 115
  tmp___4 = pathconf("/", 4);
#line 115
  path_max = tmp___4;
  }
#line 116
  if (path_max > 0L) {
    {
#line 120
    tmp___5 = malloc((size_t )path_max);
#line 120
    buf___8 = (char *)tmp___5;
    }
#line 121
    if ((unsigned long )buf___8 == (unsigned long )((void *)0)) {
#line 122
      return ((char *)((void *)0));
    }
    {
#line 123
    rp___1 = realpath((char const   */* __restrict  */)filename, (char */* __restrict  */)buf___8);
    }
#line 124
    if (rp___1) {
#line 124
      tmp___6 = (char const   *)rp___1;
    } else {
#line 124
      tmp___6 = filename;
    }
    {
#line 124
    ret = strdup(tmp___6);
#line 125
    free((void *)buf___8);
    }
#line 126
    return (ret);
  }
  {
#line 156
  tmp___7 = strdup(filename);
  }
#line 156
  return (tmp___7);
}
}
#line 126 "./../include/libiberty.h"
char const   *dos_lbasename(char const   *name___0 ) ;
#line 132
char const   *unix_lbasename(char const   *name___0 ) ;
#line 48 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./lbasename.c"
char const   *unix_lbasename(char const   *name___0 ) 
{ 
  char const   *base ;

  {
#line 53
  base = name___0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! *name___0) {
#line 53
      goto while_break;
    }
#line 54
    if ((int const   )*name___0 == 47) {
#line 55
      base = name___0 + 1;
    } else
#line 54
    if ((int const   )*name___0 == 92) {

    }
#line 53
    name___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (base);
}
}
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./lbasename.c"
char const   *dos_lbasename(char const   *name___0 ) 
{ 
  char const   *base ;

  {
#line 66
  if ((int const   )_sch_istable[(int const   )*(name___0 + 0) & 255] & 136) {
#line 66
    if ((int const   )*(name___0 + 1) == 58) {
#line 67
      name___0 += 2;
    }
  }
#line 69
  base = name___0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! *name___0) {
#line 69
      goto while_break;
    }
#line 70
    if ((int const   )*name___0 == 47) {
#line 71
      base = name___0 + 1;
    } else
#line 70
    if ((int const   )*name___0 == 92) {
#line 71
      base = name___0 + 1;
    }
#line 69
    name___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (base);
}
}
#line 76 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./lbasename.c"
char const   *lbasename(char const   *name___0 ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 82
  tmp___0 = unix_lbasename(name___0);
  }
#line 82
  return (tmp___0);
}
}
#line 375 "./../include/libiberty.h"
unsigned char const   _hex_value[256] ;
#line 376
void hex_init(void) ;
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hex.c"
unsigned char const   _hex_value[256]  = 
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hex.c"
  {      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99};
#line 158 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hex.c"
void hex_init(void) 
{ 


  {
#line 192
  return;
}
}
#line 151 "./../include/hashtab.h"
htab_t htab_create_alloc(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                          void const   * ) ,
                         void (*del_f)(void * ) , void *(*alloc_f)(size_t  , size_t  ) ,
                         void (*free_f)(void * ) ) ;
#line 155
htab_t htab_create_alloc_ex(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                             void const   * ) ,
                            void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                        size_t  ,
                                                                                        size_t  ) ,
                            void (*free_f)(void * , void * ) ) ;
#line 160
htab_t htab_create_typed_alloc(size_t size , hashval_t (*hash_f)(void const   * ) ,
                               int (*eq_f)(void const   * , void const   * ) , void (*del_f)(void * ) ,
                               void *(*alloc_tab_f)(size_t  , size_t  ) , void *(*alloc_f)(size_t  ,
                                                                                           size_t  ) ,
                               void (*free_f)(void * ) ) ;
#line 164
htab_t htab_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                    void const   * ) ,
                   void (*del_f)(void * ) ) ;
#line 165
htab_t htab_try_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                        void const   * ) ,
                       void (*del_f)(void * ) ) ;
#line 167
void htab_set_functions_ex(htab_t htab , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                            void const   * ) ,
                           void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                       size_t  ,
                                                                                       size_t  ) ,
                           void (*free_f)(void * , void * ) ) ;
#line 172
void htab_delete(htab_t htab ) ;
#line 173
void htab_empty(htab_t htab ) ;
#line 175
void *htab_find(htab_t htab , void const   *element ) ;
#line 176
void **htab_find_slot(htab_t htab , void const   *element , enum insert_option insert ) ;
#line 177
void *htab_find_with_hash(htab_t htab , void const   *element , hashval_t hash ) ;
#line 178
void **htab_find_slot_with_hash(htab_t htab , void const   *element , hashval_t hash ,
                                enum insert_option insert ) ;
#line 180
void htab_clear_slot(htab_t htab , void **slot ) ;
#line 181
void htab_remove_elt(htab_t htab , void *element ) ;
#line 182
void htab_remove_elt_with_hash(htab_t htab , void *element , hashval_t hash ) ;
#line 184
void htab_traverse(htab_t htab , int (*callback)(void ** , void * ) , void *info ) ;
#line 185
void htab_traverse_noresize(htab_t htab , int (*callback)(void ** , void * ) , void *info ) ;
#line 187
size_t htab_size(htab_t htab ) ;
#line 188
size_t htab_elements(htab_t htab ) ;
#line 189
double htab_collisions(htab_t htab ) ;
#line 192
hashval_t (*htab_hash_pointer)(void const   * ) ;
#line 195
int (*htab_eq_pointer)(void const   * , void const   * ) ;
#line 198
hashval_t htab_hash_string(void const   *p ) ;
#line 201
hashval_t iterative_hash(void const   *k_in , size_t length , hashval_t initval ) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static unsigned int higher_prime_index(unsigned long n ) ;
#line 71
__inline static hashval_t htab_mod_1(hashval_t x , hashval_t y , hashval_t inv , int shift ) ;
#line 72
__inline static hashval_t htab_mod(hashval_t hash , htab_t htab ) ;
#line 73
__inline static hashval_t htab_mod_m2(hashval_t hash , htab_t htab ) ;
#line 74
static hashval_t hash_pointer(void const   *p ) ;
#line 75
static int eq_pointer(void const   *p1 , void const   *p2 ) ;
#line 76
static int htab_expand(htab_t htab ) ;
#line 77
static void **find_empty_slot_for_expand(htab_t htab , hashval_t hash ) ;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
hashval_t (*htab_hash_pointer)(void const   * )  =    & hash_pointer;
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
int (*htab_eq_pointer)(void const   * , void const   * )  =    & eq_pointer;
#line 135 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static struct prime_ent  const  prime_tab[30]  = 
#line 135
  {      {(hashval_t )7, (hashval_t )613566757, 2576980379U, (hashval_t )2}, 
        {(hashval_t )13, (hashval_t )991146300, (hashval_t )1952257863, (hashval_t )3}, 
        {(hashval_t )31,
      (hashval_t )138547333, (hashval_t )444306962, (hashval_t )4}, 
        {(hashval_t )61, (hashval_t )211227900, (hashval_t )363980280, (hashval_t )5}, 
        {(hashval_t )127,
      (hashval_t )33818641, (hashval_t )103079216, (hashval_t )6}, 
        {(hashval_t )251, (hashval_t )85557118, (hashval_t )120742053, (hashval_t )7}, 
        {(hashval_t )509,
      (hashval_t )25314150, (hashval_t )42356680, (hashval_t )8}, 
        {(hashval_t )1021, (hashval_t )12619885, (hashval_t )21074423, (hashval_t )9}, 
        {(hashval_t )2039,
      (hashval_t )18957679, (hashval_t )23193246, (hashval_t )10}, 
        {(hashval_t )4093, (hashval_t )3148034, (hashval_t )5249288, (hashval_t )11}, 
        {(hashval_t )8191,
      (hashval_t )524353, (hashval_t )1573441, (hashval_t )12}, 
        {(hashval_t )16381, (hashval_t )786577, (hashval_t )1311121, (hashval_t )13}, 
        {(hashval_t )32749,
      (hashval_t )2491813, (hashval_t )2754278, (hashval_t )14}, 
        {(hashval_t )65521, (hashval_t )983266, (hashval_t )1114402, (hashval_t )15}, 
        {(hashval_t )131071,
      (hashval_t )32769, (hashval_t )98307, (hashval_t )16}, 
        {(hashval_t )262139, (hashval_t )81922, (hashval_t )114692, (hashval_t )17}, 
        {(hashval_t )524287, (hashval_t )8193, (hashval_t )24577, (hashval_t )18}, 
        {(hashval_t )1048573, (hashval_t )12289, (hashval_t )20481, (hashval_t )19}, 
        {(hashval_t )2097143, (hashval_t )18433, (hashval_t )22529, (hashval_t )20}, 
        {(hashval_t )4194301, (hashval_t )3073, (hashval_t )5121, (hashval_t )21}, 
        {(hashval_t )8388593, (hashval_t )7681, (hashval_t )8705, (hashval_t )22}, 
        {(hashval_t )16777213, (hashval_t )769, (hashval_t )1281, (hashval_t )23}, 
        {(hashval_t )33554393, (hashval_t )4993, (hashval_t )5249, (hashval_t )24}, 
        {(hashval_t )67108859, (hashval_t )321, (hashval_t )449, (hashval_t )25}, 
        {(hashval_t )134217689, (hashval_t )1249, (hashval_t )1313, (hashval_t )26}, 
        {(hashval_t )268435399, (hashval_t )913, (hashval_t )945, (hashval_t )27}, 
        {(hashval_t )536870909, (hashval_t )25, (hashval_t )41, (hashval_t )28}, 
        {(hashval_t )1073741789, (hashval_t )141, (hashval_t )149, (hashval_t )29}, 
        {(hashval_t )2147483647, (hashval_t )3, (hashval_t )7, (hashval_t )30}, 
        {4294967291U, (hashval_t )6, (hashval_t )8, (hashval_t )31}};
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static unsigned int higher_prime_index(unsigned long n ) 
{ 
  unsigned int low ;
  unsigned int high ;
  unsigned int mid ;

  {
#line 175
  low = 0U;
#line 176
  high = (unsigned int )(sizeof(prime_tab) / sizeof(prime_tab[0]));
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (low != high)) {
#line 178
      goto while_break;
    }
#line 180
    mid = low + (high - low) / 2U;
#line 181
    if (n > (unsigned long )prime_tab[mid].prime) {
#line 182
      low = mid + 1U;
    } else {
#line 184
      high = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (n > (unsigned long )prime_tab[low].prime) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find prime bigger than %lu\n",
            n);
#line 191
    abort();
    }
  }
#line 194
  return (low);
}
}
#line 199 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static int eq_pointer(void const   *p1 , void const   *p2 ) 
{ 


  {
#line 202
  return ((unsigned long )p1 == (unsigned long )p2);
}
}
#line 215 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
size_t htab_size(htab_t htab ) 
{ 


  {
#line 218
  return (htab->size);
}
}
#line 225 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
size_t htab_elements(htab_t htab ) 
{ 


  {
#line 228
  return (htab->n_elements - htab->n_deleted);
}
}
#line 233 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
__inline static hashval_t htab_mod_1(hashval_t x , hashval_t y , hashval_t inv , int shift ) 
{ 
  hashval_t t1 ;
  hashval_t t2 ;
  hashval_t t3 ;
  hashval_t t4 ;
  hashval_t q ;
  hashval_t r ;

  {
#line 240
  if (sizeof(hashval_t ) * 8UL <= 32UL) {
#line 244
    t1 = (hashval_t )((ull )x * (ull )inv >> 32);
#line 245
    t2 = x - t1;
#line 246
    t3 = t2 >> 1;
#line 247
    t4 = t1 + t3;
#line 248
    q = t4 >> shift;
#line 249
    r = x - q * y;
#line 251
    return (r);
  }
#line 256
  return (x % y);
}
}
#line 261 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
__inline static hashval_t htab_mod(hashval_t hash , htab_t htab ) 
{ 
  struct prime_ent  const  *p ;
  hashval_t tmp___0 ;

  {
  {
#line 264
  p = & prime_tab[htab->size_prime_index];
#line 265
  tmp___0 = htab_mod_1(hash, (hashval_t )p->prime, (hashval_t )p->inv, (int )p->shift);
  }
#line 265
  return (tmp___0);
}
}
#line 270 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
__inline static hashval_t htab_mod_m2(hashval_t hash , htab_t htab ) 
{ 
  struct prime_ent  const  *p ;
  hashval_t tmp___0 ;

  {
  {
#line 273
  p = & prime_tab[htab->size_prime_index];
#line 274
  tmp___0 = htab_mod_1(hash, (hashval_t )(p->prime - 2U), (hashval_t )p->inv_m2, (int )p->shift);
  }
#line 274
  return (1U + tmp___0);
}
}
#line 282 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
htab_t htab_create_alloc(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                          void const   * ) ,
                         void (*del_f)(void * ) , void *(*alloc_f)(size_t  , size_t  ) ,
                         void (*free_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 286
  tmp___0 = htab_create_typed_alloc(size, hash_f, eq_f, del_f, alloc_f, alloc_f, free_f);
  }
#line 286
  return (tmp___0);
}
}
#line 293 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
htab_t htab_create_alloc_ex(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                             void const   * ) ,
                            void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                        size_t  ,
                                                                                        size_t  ) ,
                            void (*free_f)(void * , void * ) ) 
{ 
  htab_t result ;
  unsigned int size_prime_index ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 302
  size_prime_index = higher_prime_index(size);
#line 303
  size = (size_t )prime_tab[size_prime_index].prime;
#line 305
  tmp___0 = (*alloc_f)(alloc_arg, (size_t )1, sizeof(struct htab ));
#line 305
  result = (htab_t )tmp___0;
  }
#line 306
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 307
    return ((htab_t )((void *)0));
  }
  {
#line 308
  tmp___1 = (*alloc_f)(alloc_arg, size, sizeof(void *));
#line 308
  result->entries = (void **)tmp___1;
  }
#line 309
  if ((unsigned long )result->entries == (unsigned long )((void *)0)) {
#line 311
    if ((unsigned long )free_f != (unsigned long )((void *)0)) {
      {
#line 312
      (*free_f)(alloc_arg, (void *)result);
      }
    }
#line 313
    return ((htab_t )((void *)0));
  }
#line 315
  result->size = size;
#line 316
  result->size_prime_index = size_prime_index;
#line 317
  result->hash_f = hash_f;
#line 318
  result->eq_f = eq_f;
#line 319
  result->del_f = del_f;
#line 320
  result->alloc_arg = alloc_arg;
#line 321
  result->alloc_with_arg_f = alloc_f;
#line 322
  result->free_with_arg_f = free_f;
#line 323
  return (result);
}
}
#line 347 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
htab_t htab_create_typed_alloc(size_t size , hashval_t (*hash_f)(void const   * ) ,
                               int (*eq_f)(void const   * , void const   * ) , void (*del_f)(void * ) ,
                               void *(*alloc_tab_f)(size_t  , size_t  ) , void *(*alloc_f)(size_t  ,
                                                                                           size_t  ) ,
                               void (*free_f)(void * ) ) 
{ 
  htab_t result ;
  unsigned int size_prime_index ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 355
  size_prime_index = higher_prime_index(size);
#line 356
  size = (size_t )prime_tab[size_prime_index].prime;
#line 358
  tmp___0 = (*alloc_tab_f)((size_t )1, sizeof(struct htab ));
#line 358
  result = (htab_t )tmp___0;
  }
#line 359
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 360
    return ((htab_t )((void *)0));
  }
  {
#line 361
  tmp___1 = (*alloc_f)(size, sizeof(void *));
#line 361
  result->entries = (void **)tmp___1;
  }
#line 362
  if ((unsigned long )result->entries == (unsigned long )((void *)0)) {
#line 364
    if ((unsigned long )free_f != (unsigned long )((void *)0)) {
      {
#line 365
      (*free_f)((void *)result);
      }
    }
#line 366
    return ((htab_t )((void *)0));
  }
#line 368
  result->size = size;
#line 369
  result->size_prime_index = size_prime_index;
#line 370
  result->hash_f = hash_f;
#line 371
  result->eq_f = eq_f;
#line 372
  result->del_f = del_f;
#line 373
  result->alloc_f = alloc_f;
#line 374
  result->free_f = free_f;
#line 375
  return (result);
}
}
#line 381 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_set_functions_ex(htab_t htab , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                            void const   * ) ,
                           void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                       size_t  ,
                                                                                       size_t  ) ,
                           void (*free_f)(void * , void * ) ) 
{ 


  {
#line 386
  htab->hash_f = hash_f;
#line 387
  htab->eq_f = eq_f;
#line 388
  htab->del_f = del_f;
#line 389
  htab->alloc_arg = alloc_arg;
#line 390
  htab->alloc_with_arg_f = alloc_f;
#line 391
  htab->free_with_arg_f = free_f;
#line 392
  return;
}
}
#line 397 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
htab_t htab_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                    void const   * ) ,
                   void (*del_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 400
  tmp___0 = htab_create_alloc(size, hash_f, eq_f, del_f, & xcalloc, (void (*)(void * ))(& free));
  }
#line 400
  return (tmp___0);
}
}
#line 403 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
htab_t htab_try_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                        void const   * ) ,
                       void (*del_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 406
  tmp___0 = htab_create_alloc(size, hash_f, eq_f, del_f, (void *(*)(size_t  , size_t  ))(& calloc),
                              (void (*)(void * ))(& free));
  }
#line 406
  return (tmp___0);
}
}
#line 412 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_delete(htab_t htab ) 
{ 
  size_t size ;
  void **entries ;
  int i ;

  {
#line 415
  size = htab->size;
#line 416
  entries = htab->entries;
#line 419
  if (htab->del_f) {
#line 420
    i = (int )(size - 1UL);
    {
#line 420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 420
      if (! (i >= 0)) {
#line 420
        goto while_break;
      }
#line 421
      if ((unsigned long )*(entries + i) != (unsigned long )((void *)0)) {
#line 421
        if ((unsigned long )*(entries + i) != (unsigned long )((void *)1)) {
          {
#line 422
          (*(htab->del_f))(*(entries + i));
          }
        }
      }
#line 420
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 424
  if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
    {
#line 426
    (*(htab->free_f))((void *)entries);
#line 427
    (*(htab->free_f))((void *)htab);
    }
  } else
#line 429
  if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 431
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)entries);
#line 432
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)htab);
    }
  }
#line 434
  return;
}
}
#line 438 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_empty(htab_t htab ) 
{ 
  size_t size ;
  void **entries ;
  int i ;
  int nindex ;
  unsigned int tmp___0 ;
  int nsize ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 441
  size = htab->size;
#line 442
  entries = htab->entries;
#line 445
  if (htab->del_f) {
#line 446
    i = (int )(size - 1UL);
    {
#line 446
    while (1) {
      while_continue: /* CIL Label */ ;
#line 446
      if (! (i >= 0)) {
#line 446
        goto while_break;
      }
#line 447
      if ((unsigned long )*(entries + i) != (unsigned long )((void *)0)) {
#line 447
        if ((unsigned long )*(entries + i) != (unsigned long )((void *)1)) {
          {
#line 448
          (*(htab->del_f))(*(entries + i));
          }
        }
      }
#line 446
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 451
  if (size > 1048576UL / sizeof(void *)) {
    {
#line 453
    tmp___0 = higher_prime_index(1024UL / sizeof(void *));
#line 453
    nindex = (int )tmp___0;
#line 454
    nsize = (int )prime_tab[nindex].prime;
    }
#line 456
    if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
      {
#line 457
      (*(htab->free_f))((void *)htab->entries);
      }
    } else
#line 458
    if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
      {
#line 459
      (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)htab->entries);
      }
    }
#line 460
    if ((unsigned long )htab->alloc_with_arg_f != (unsigned long )((void *)0)) {
      {
#line 461
      tmp___1 = (*(htab->alloc_with_arg_f))(htab->alloc_arg, (size_t )nsize, sizeof(void **));
#line 461
      htab->entries = (void **)tmp___1;
      }
    } else {
      {
#line 464
      tmp___2 = (*(htab->alloc_f))((size_t )nsize, sizeof(void **));
#line 464
      htab->entries = (void **)tmp___2;
      }
    }
#line 465
    htab->size = (size_t )nsize;
#line 466
    htab->size_prime_index = (unsigned int )nindex;
  } else {
    {
#line 469
    memset((void *)entries, 0, size * sizeof(void *));
    }
  }
#line 470
  htab->n_deleted = (size_t )0;
#line 471
  htab->n_elements = (size_t )0;
#line 472
  return;
}
}
#line 481 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static void **find_empty_slot_for_expand(htab_t htab , hashval_t hash ) 
{ 
  hashval_t index___0 ;
  hashval_t tmp___0 ;
  size_t size ;
  void **slot ;
  hashval_t hash2 ;

  {
  {
#line 484
  tmp___0 = htab_mod(hash, htab);
#line 484
  index___0 = tmp___0;
#line 485
  size = htab->size;
#line 486
  slot = htab->entries + index___0;
  }
#line 489
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 490
    return (slot);
  } else
#line 491
  if ((unsigned long )*slot == (unsigned long )((void *)1)) {
    {
#line 492
    abort();
    }
  }
  {
#line 494
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    index___0 += hash2;
#line 498
    if ((size_t )index___0 >= size) {
#line 499
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 501
    slot = htab->entries + index___0;
#line 502
    if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 503
      return (slot);
    } else
#line 504
    if ((unsigned long )*slot == (unsigned long )((void *)1)) {
      {
#line 505
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 517 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static int htab_expand(htab_t htab ) 
{ 
  void **oentries ;
  void **olimit ;
  void **p ;
  void **nentries ;
  size_t nsize ;
  size_t osize ;
  size_t elts ;
  unsigned int oindex ;
  unsigned int nindex ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *x ;
  void **q ;
  hashval_t tmp___2 ;
  void **tmp___3 ;

  {
#line 527
  oentries = htab->entries;
#line 528
  oindex = htab->size_prime_index;
#line 529
  osize = htab->size;
#line 530
  olimit = oentries + osize;
#line 531
  elts = htab->n_elements - htab->n_deleted;
#line 535
  if (elts * 2UL > osize) {
    {
#line 537
    nindex = higher_prime_index(elts * 2UL);
#line 538
    nsize = (size_t )prime_tab[nindex].prime;
    }
  } else
#line 535
  if (elts * 8UL < osize) {
#line 535
    if (osize > 32UL) {
      {
#line 537
      nindex = higher_prime_index(elts * 2UL);
#line 538
      nsize = (size_t )prime_tab[nindex].prime;
      }
    } else {
#line 542
      nindex = oindex;
#line 543
      nsize = osize;
    }
  } else {
#line 542
    nindex = oindex;
#line 543
    nsize = osize;
  }
#line 546
  if ((unsigned long )htab->alloc_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 547
    tmp___0 = (*(htab->alloc_with_arg_f))(htab->alloc_arg, nsize, sizeof(void **));
#line 547
    nentries = (void **)tmp___0;
    }
  } else {
    {
#line 550
    tmp___1 = (*(htab->alloc_f))(nsize, sizeof(void **));
#line 550
    nentries = (void **)tmp___1;
    }
  }
#line 551
  if ((unsigned long )nentries == (unsigned long )((void *)0)) {
#line 552
    return (0);
  }
#line 553
  htab->entries = nentries;
#line 554
  htab->size = nsize;
#line 555
  htab->size_prime_index = nindex;
#line 556
  htab->n_elements -= htab->n_deleted;
#line 557
  htab->n_deleted = (size_t )0;
#line 559
  p = oentries;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    x = *p;
#line 564
    if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 564
      if ((unsigned long )x != (unsigned long )((void *)1)) {
        {
#line 566
        tmp___2 = (*(htab->hash_f))((void const   *)x);
#line 566
        tmp___3 = find_empty_slot_for_expand(htab, tmp___2);
#line 566
        q = tmp___3;
#line 568
        *q = x;
        }
      }
    }
#line 571
    p ++;
#line 560
    if (! ((unsigned long )p < (unsigned long )olimit)) {
#line 560
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
    {
#line 576
    (*(htab->free_f))((void *)oentries);
    }
  } else
#line 577
  if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 578
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)oentries);
    }
  }
#line 579
  return (1);
}
}
#line 585 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void *htab_find_with_hash(htab_t htab , void const   *element , hashval_t hash ) 
{ 
  hashval_t index___0 ;
  hashval_t hash2 ;
  size_t size ;
  void *entry ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 592
  (htab->searches) ++;
#line 593
  size = htab->size;
#line 594
  index___0 = htab_mod(hash, htab);
#line 596
  entry = *(htab->entries + index___0);
  }
#line 597
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 599
    return (entry);
  } else
#line 597
  if ((unsigned long )entry != (unsigned long )((void *)1)) {
    {
#line 597
    tmp___0 = (*(htab->eq_f))((void const   *)entry, element);
    }
#line 597
    if (tmp___0) {
#line 599
      return (entry);
    }
  }
  {
#line 601
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    (htab->collisions) ++;
#line 605
    index___0 += hash2;
#line 606
    if ((size_t )index___0 >= size) {
#line 607
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 609
    entry = *(htab->entries + index___0);
#line 610
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 612
      return (entry);
    } else
#line 610
    if ((unsigned long )entry != (unsigned long )((void *)1)) {
      {
#line 610
      tmp___1 = (*(htab->eq_f))((void const   *)entry, element);
      }
#line 610
      if (tmp___1) {
#line 612
        return (entry);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 619 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void *htab_find(htab_t htab , void const   *element ) 
{ 
  hashval_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 622
  tmp___0 = (*(htab->hash_f))(element);
#line 622
  tmp___1 = htab_find_with_hash(htab, element, tmp___0);
  }
#line 622
  return (tmp___1);
}
}
#line 633 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void **htab_find_slot_with_hash(htab_t htab , void const   *element , hashval_t hash ,
                                enum insert_option insert ) 
{ 
  void **first_deleted_slot ;
  hashval_t index___0 ;
  hashval_t hash2 ;
  size_t size ;
  void *entry ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 642
  size = htab->size;
#line 643
  if ((unsigned int )insert == 1U) {
#line 643
    if (size * 3UL <= htab->n_elements * 4UL) {
      {
#line 645
      tmp___0 = htab_expand(htab);
      }
#line 645
      if (tmp___0 == 0) {
#line 646
        return ((void **)((void *)0));
      }
#line 647
      size = htab->size;
    }
  }
  {
#line 650
  index___0 = htab_mod(hash, htab);
#line 652
  (htab->searches) ++;
#line 653
  first_deleted_slot = (void **)((void *)0);
#line 655
  entry = *(htab->entries + index___0);
  }
#line 656
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 657
    goto empty_entry;
  } else
#line 658
  if ((unsigned long )entry == (unsigned long )((void *)1)) {
#line 659
    first_deleted_slot = htab->entries + index___0;
  } else {
    {
#line 660
    tmp___1 = (*(htab->eq_f))((void const   *)entry, element);
    }
#line 660
    if (tmp___1) {
#line 661
      return (htab->entries + index___0);
    }
  }
  {
#line 663
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    (htab->collisions) ++;
#line 667
    index___0 += hash2;
#line 668
    if ((size_t )index___0 >= size) {
#line 669
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 671
    entry = *(htab->entries + index___0);
#line 672
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 673
      goto empty_entry;
    } else
#line 674
    if ((unsigned long )entry == (unsigned long )((void *)1)) {
#line 676
      if (! first_deleted_slot) {
#line 677
        first_deleted_slot = htab->entries + index___0;
      }
    } else {
      {
#line 679
      tmp___2 = (*(htab->eq_f))((void const   *)entry, element);
      }
#line 679
      if (tmp___2) {
#line 680
        return (htab->entries + index___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  empty_entry: 
#line 684
  if ((unsigned int )insert == 0U) {
#line 685
    return ((void **)((void *)0));
  }
#line 687
  if (first_deleted_slot) {
#line 689
    (htab->n_deleted) --;
#line 690
    *first_deleted_slot = (void *)0;
#line 691
    return (first_deleted_slot);
  }
#line 694
  (htab->n_elements) ++;
#line 695
  return (htab->entries + index___0);
}
}
#line 701 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void **htab_find_slot(htab_t htab , void const   *element , enum insert_option insert ) 
{ 
  hashval_t tmp___0 ;
  void **tmp___1 ;

  {
  {
#line 704
  tmp___0 = (*(htab->hash_f))(element);
#line 704
  tmp___1 = htab_find_slot_with_hash(htab, element, tmp___0, insert);
  }
#line 704
  return (tmp___1);
}
}
#line 712 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_remove_elt(htab_t htab , void *element ) 
{ 
  hashval_t tmp___0 ;

  {
  {
#line 715
  tmp___0 = (*(htab->hash_f))((void const   *)element);
#line 715
  htab_remove_elt_with_hash(htab, element, tmp___0);
  }
#line 716
  return;
}
}
#line 723 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_remove_elt_with_hash(htab_t htab , void *element , hashval_t hash ) 
{ 
  void **slot ;

  {
  {
#line 728
  slot = htab_find_slot_with_hash(htab, (void const   *)element, hash, (enum insert_option )0);
  }
#line 729
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 730
    return;
  }
#line 732
  if (htab->del_f) {
    {
#line 733
    (*(htab->del_f))(*slot);
    }
  }
#line 735
  *slot = (void *)1;
#line 736
  (htab->n_deleted) ++;
#line 737
  return;
}
}
#line 743 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_clear_slot(htab_t htab , void **slot ) 
{ 


  {
#line 746
  if ((unsigned long )slot < (unsigned long )htab->entries) {
    {
#line 748
    abort();
    }
  } else
#line 746
  if ((unsigned long )slot >= (unsigned long )(htab->entries + htab->size)) {
    {
#line 748
    abort();
    }
  } else
#line 746
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
    {
#line 748
    abort();
    }
  } else
#line 746
  if ((unsigned long )*slot == (unsigned long )((void *)1)) {
    {
#line 748
    abort();
    }
  }
#line 750
  if (htab->del_f) {
    {
#line 751
    (*(htab->del_f))(*slot);
    }
  }
#line 753
  *slot = (void *)1;
#line 754
  (htab->n_deleted) ++;
#line 755
  return;
}
}
#line 762 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_traverse_noresize(htab_t htab , int (*callback)(void ** , void * ) , void *info ) 
{ 
  void **slot ;
  void **limit ;
  void *x ;
  int tmp___0 ;

  {
#line 768
  slot = htab->entries;
#line 769
  limit = slot + htab->size;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    x = *slot;
#line 775
    if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 775
      if ((unsigned long )x != (unsigned long )((void *)1)) {
        {
#line 776
        tmp___0 = (*callback)(slot, info);
        }
#line 776
        if (! tmp___0) {
#line 777
          goto while_break;
        }
      }
    }
#line 771
    slot ++;
#line 771
    if (! ((unsigned long )slot < (unsigned long )limit)) {
#line 771
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  return;
}
}
#line 785 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
void htab_traverse(htab_t htab , int (*callback)(void ** , void * ) , void *info ) 
{ 
  size_t size ;

  {
#line 788
  size = htab->size;
#line 789
  if ((htab->n_elements - htab->n_deleted) * 8UL < size) {
#line 789
    if (size > 32UL) {
      {
#line 790
      htab_expand(htab);
      }
    }
  }
  {
#line 792
  htab_traverse_noresize(htab, callback, info);
  }
#line 793
  return;
}
}
#line 798 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
double htab_collisions(htab_t htab ) 
{ 


  {
#line 801
  if (htab->searches == 0U) {
#line 802
    return (0.0);
  }
#line 804
  return ((double )htab->collisions / (double )htab->searches);
}
}
#line 832 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
hashval_t htab_hash_string(void const   *p ) 
{ 
  unsigned char const   *str ;
  hashval_t r ;
  unsigned char c ;
  unsigned char const   *tmp___0 ;

  {
#line 835
  str = (unsigned char const   *)p;
#line 836
  r = (hashval_t )0;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    tmp___0 = str;
#line 839
    str ++;
#line 839
    c = (unsigned char )*tmp___0;
#line 839
    if (! ((int )c != 0)) {
#line 839
      goto while_break;
    }
#line 840
    r = (r * 67U + (hashval_t )c) - 113U;
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  return (r);
}
}
#line 922 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
hashval_t iterative_hash(void const   *k_in , size_t length , hashval_t initval ) 
{ 
  register unsigned char const   *k ;
  register hashval_t a ;
  register hashval_t b ;
  register hashval_t c ;
  register hashval_t len ;

  {
#line 928
  k = (unsigned char const   *)k_in;
#line 932
  len = (hashval_t )length;
#line 933
  b = 2654435769U;
#line 933
  a = b;
#line 934
  c = initval;
#line 941
  if (sizeof(hashval_t ) == 4UL) {
#line 941
    if (((size_t )k & 3UL) == 0UL) {
      {
#line 942
      while (1) {
        while_continue: /* CIL Label */ ;
#line 942
        if (! (len >= 12U)) {
#line 942
          goto while_break;
        }
#line 944
        a += *((hashval_t *)(k + 0));
#line 945
        b += *((hashval_t *)(k + 4));
#line 946
        c += *((hashval_t *)(k + 8));
#line 947
        a -= b;
#line 947
        a -= c;
#line 947
        a ^= c >> 13;
#line 947
        b -= c;
#line 947
        b -= a;
#line 947
        b ^= a << 8;
#line 947
        c -= a;
#line 947
        c -= b;
#line 947
        c ^= (b & 4294967295U) >> 13;
#line 947
        a -= b;
#line 947
        a -= c;
#line 947
        a ^= (c & 4294967295U) >> 12;
#line 947
        b -= c;
#line 947
        b -= a;
#line 947
        b = (b ^ (a << 16)) & 4294967295U;
#line 947
        c -= a;
#line 947
        c -= b;
#line 947
        c = (c ^ (b >> 5)) & 4294967295U;
#line 947
        a -= b;
#line 947
        a -= c;
#line 947
        a = (a ^ (c >> 3)) & 4294967295U;
#line 947
        b -= c;
#line 947
        b -= a;
#line 947
        b = (b ^ (a << 10)) & 4294967295U;
#line 947
        c -= a;
#line 947
        c -= b;
#line 947
        c = (c ^ (b >> 15)) & 4294967295U;
#line 948
        k += 12;
#line 948
        len -= 12U;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 941
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 952
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 952
      if (! (len >= 12U)) {
#line 952
        goto while_break___0;
      }
#line 954
      a += (((hashval_t )*(k + 0) + ((hashval_t )*(k + 1) << 8)) + ((hashval_t )*(k + 2) << 16)) + ((hashval_t )*(k + 3) << 24);
#line 955
      b += (((hashval_t )*(k + 4) + ((hashval_t )*(k + 5) << 8)) + ((hashval_t )*(k + 6) << 16)) + ((hashval_t )*(k + 7) << 24);
#line 956
      c += (((hashval_t )*(k + 8) + ((hashval_t )*(k + 9) << 8)) + ((hashval_t )*(k + 10) << 16)) + ((hashval_t )*(k + 11) << 24);
#line 957
      a -= b;
#line 957
      a -= c;
#line 957
      a ^= c >> 13;
#line 957
      b -= c;
#line 957
      b -= a;
#line 957
      b ^= a << 8;
#line 957
      c -= a;
#line 957
      c -= b;
#line 957
      c ^= (b & 4294967295U) >> 13;
#line 957
      a -= b;
#line 957
      a -= c;
#line 957
      a ^= (c & 4294967295U) >> 12;
#line 957
      b -= c;
#line 957
      b -= a;
#line 957
      b = (b ^ (a << 16)) & 4294967295U;
#line 957
      c -= a;
#line 957
      c -= b;
#line 957
      c = (c ^ (b >> 5)) & 4294967295U;
#line 957
      a -= b;
#line 957
      a -= c;
#line 957
      a = (a ^ (c >> 3)) & 4294967295U;
#line 957
      b -= c;
#line 957
      b -= a;
#line 957
      b = (b ^ (a << 10)) & 4294967295U;
#line 957
      c -= a;
#line 957
      c -= b;
#line 957
      c = (c ^ (b >> 15)) & 4294967295U;
#line 958
      k += 12;
#line 958
      len -= 12U;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  c = (hashval_t )((size_t )c + length);
  {
#line 965
  if (len == 11U) {
#line 965
    goto case_11;
  }
#line 966
  if (len == 10U) {
#line 966
    goto case_10;
  }
#line 967
  if (len == 9U) {
#line 967
    goto case_9;
  }
#line 969
  if (len == 8U) {
#line 969
    goto case_8;
  }
#line 970
  if (len == 7U) {
#line 970
    goto case_7;
  }
#line 971
  if (len == 6U) {
#line 971
    goto case_6;
  }
#line 972
  if (len == 5U) {
#line 972
    goto case_5;
  }
#line 973
  if (len == 4U) {
#line 973
    goto case_4;
  }
#line 974
  if (len == 3U) {
#line 974
    goto case_3;
  }
#line 975
  if (len == 2U) {
#line 975
    goto case_2;
  }
#line 976
  if (len == 1U) {
#line 976
    goto case_1;
  }
#line 963
  goto switch_break;
  case_11: /* CIL Label */ 
#line 965
  c += (hashval_t )*(k + 10) << 24;
  case_10: /* CIL Label */ 
#line 966
  c += (hashval_t )*(k + 9) << 16;
  case_9: /* CIL Label */ 
#line 967
  c += (hashval_t )*(k + 8) << 8;
  case_8: /* CIL Label */ 
#line 969
  b += (hashval_t )*(k + 7) << 24;
  case_7: /* CIL Label */ 
#line 970
  b += (hashval_t )*(k + 6) << 16;
  case_6: /* CIL Label */ 
#line 971
  b += (hashval_t )*(k + 5) << 8;
  case_5: /* CIL Label */ 
#line 972
  b += (hashval_t )*(k + 4);
  case_4: /* CIL Label */ 
#line 973
  a += (hashval_t )*(k + 3) << 24;
  case_3: /* CIL Label */ 
#line 974
  a += (hashval_t )*(k + 2) << 16;
  case_2: /* CIL Label */ 
#line 975
  a += (hashval_t )*(k + 1) << 8;
  case_1: /* CIL Label */ 
#line 976
  a += (hashval_t )*(k + 0);
  switch_break: /* CIL Label */ ;
  }
#line 979
  a -= b;
#line 979
  a -= c;
#line 979
  a ^= c >> 13;
#line 979
  b -= c;
#line 979
  b -= a;
#line 979
  b ^= a << 8;
#line 979
  c -= a;
#line 979
  c -= b;
#line 979
  c ^= (b & 4294967295U) >> 13;
#line 979
  a -= b;
#line 979
  a -= c;
#line 979
  a ^= (c & 4294967295U) >> 12;
#line 979
  b -= c;
#line 979
  b -= a;
#line 979
  b = (b ^ (a << 16)) & 4294967295U;
#line 979
  c -= a;
#line 979
  c -= b;
#line 979
  c = (c ^ (b >> 5)) & 4294967295U;
#line 979
  a -= b;
#line 979
  a -= c;
#line 979
  a = (a ^ (c >> 3)) & 4294967295U;
#line 979
  b -= c;
#line 979
  b -= a;
#line 979
  b = (b ^ (a << 10)) & 4294967295U;
#line 979
  c -= a;
#line 979
  c -= b;
#line 979
  c = (c ^ (b >> 15)) & 4294967295U;
#line 981
  return (c);
}
}
#line 986 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./hashtab.c"
static hashval_t hash_pointer(void const   *p ) 
{ 
  intptr_t v ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;

  {
#line 989
  v = (intptr_t )p;
#line 992
  b = 2654435769U;
#line 992
  a = b;
#line 993
  a = (unsigned int )((intptr_t )a + (v >> (sizeof(intptr_t ) * 8UL) / 2UL));
#line 994
  b = (unsigned int )((long )b + (v & ((1L << (sizeof(intptr_t ) * 8UL) / 2UL) - 1L)));
#line 995
  c = 1108562484U;
#line 996
  a -= b;
#line 996
  a -= c;
#line 996
  a ^= c >> 13;
#line 996
  b -= c;
#line 996
  b -= a;
#line 996
  b ^= a << 8;
#line 996
  c -= a;
#line 996
  c -= b;
#line 996
  c ^= (b & 4294967295U) >> 13;
#line 996
  a -= b;
#line 996
  a -= c;
#line 996
  a ^= (c & 4294967295U) >> 12;
#line 996
  b -= c;
#line 996
  b -= a;
#line 996
  b = (b ^ (a << 16)) & 4294967295U;
#line 996
  c -= a;
#line 996
  c -= b;
#line 996
  c = (c ^ (b >> 5)) & 4294967295U;
#line 996
  a -= b;
#line 996
  a -= c;
#line 996
  a = (a ^ (c >> 3)) & 4294967295U;
#line 996
  b -= c;
#line 996
  b -= a;
#line 996
  b = (b ^ (a << 10)) & 4294967295U;
#line 996
  c -= a;
#line 996
  c -= b;
#line 996
  c = (c ^ (b >> 15)) & 4294967295U;
#line 997
  return (c);
}
}
#line 212 "./../include/libiberty.h"
long get_run_time(void) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./getruntime.c"
long get_run_time(void) 
{ 
  struct rusage rusage ;

  {
  {
#line 98
  getrusage(0, & rusage);
  }
#line 99
  return (((rusage.ru_utime.tv_sec * 1000000L + rusage.ru_utime.tv_usec) + rusage.ru_stime.tv_sec * 1000000L) + rusage.ru_stime.tv_usec);
}
}
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 199 "./../include/libiberty.h"
char *getpwd(void) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./getpwd.c"
static char *pwd  ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./getpwd.c"
static int failure_errno  ;
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./getpwd.c"
char *getpwd(void) 
{ 
  char *p ;
  size_t s ;
  struct stat dotstat ;
  struct stat pwdstat ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 73
  p = pwd;
#line 77
  if (! p) {
    {
#line 77
    tmp___6 = __errno_location();
#line 77
    tmp___7 = failure_errno;
#line 77
    *tmp___6 = tmp___7;
    }
#line 77
    if (! tmp___7) {
      {
#line 79
      p = getenv("PWD");
      }
#line 79
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 79
        if ((int )*p == 47) {
          {
#line 79
          tmp___4 = stat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& pwdstat));
          }
#line 79
          if (tmp___4 == 0) {
            {
#line 79
            tmp___5 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& dotstat));
            }
#line 79
            if (tmp___5 == 0) {
#line 79
              if (dotstat.st_ino == pwdstat.st_ino) {
#line 79
                if (! (dotstat.st_dev == pwdstat.st_dev)) {
#line 79
                  goto _L___3;
                }
              } else {
#line 79
                goto _L___3;
              }
            } else {
#line 79
              goto _L___3;
            }
          } else {
#line 79
            goto _L___3;
          }
        } else {
#line 79
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 87
        s = (size_t )4097;
        {
#line 87
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 87
          tmp___2 = xmalloc(sizeof(char ) * s);
#line 87
          p = (char *)tmp___2;
#line 87
          tmp___3 = getcwd(p, s);
          }
#line 87
          if (tmp___3) {
#line 87
            goto while_break;
          }
          {
#line 89
          tmp___0 = __errno_location();
#line 89
          e = *tmp___0;
#line 90
          free((void *)p);
          }
#line 92
          if (e != 34) {
            {
#line 95
            tmp___1 = __errno_location();
#line 95
            failure_errno = e;
#line 95
            *tmp___1 = failure_errno;
#line 96
            p = (char *)0;
            }
#line 97
            goto while_break;
          }
#line 87
          s *= 2UL;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 103
      pwd = p;
    }
  }
#line 105
  return (p);
}
}
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 238
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 82 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fsetlocking)(FILE *__fp ,
                                                                                    int __type ) ;
#line 56 "./../include/libiberty.h"
void unlock_stream(FILE *fp ) ;
#line 62
void unlock_std_streams(void) ;
#line 68
FILE *fopen_unlocked(char const   *path , char const   *mode ) ;
#line 69
FILE *fdopen_unlocked(int fildes , char const   *mode ) ;
#line 70
FILE *freopen_unlocked(char const   *path , char const   *mode , FILE *stream ) ;
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
__inline static void unlock_1(FILE * const  fp  __attribute__((__unused__)) ) 
{ 


  {
#line 88
  if (fp) {
    {
#line 89
    __fsetlocking((FILE *)fp, 2);
    }
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
void unlock_stream(FILE *fp ) 
{ 


  {
  {
#line 96
  unlock_1((FILE */* const  */)fp);
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
void unlock_std_streams(void) 
{ 


  {
  {
#line 102
  unlock_1((FILE */* const  */)stdin);
#line 103
  unlock_1((FILE */* const  */)stdout);
#line 104
  unlock_1((FILE */* const  */)stderr);
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
FILE *fopen_unlocked(char const   *path , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 110
  tmp___0 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)mode);
#line 110
  fp = tmp___0;
#line 111
  unlock_1((FILE */* const  */)fp);
  }
#line 112
  return (fp);
}
}
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
FILE *fdopen_unlocked(int fildes , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 118
  tmp___0 = fdopen(fildes, mode);
#line 118
  fp = tmp___0;
#line 119
  unlock_1((FILE */* const  */)fp);
  }
#line 120
  return (fp);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fopen_unlocked.c"
FILE *freopen_unlocked(char const   *path , char const   *mode , FILE *stream ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 126
  tmp___0 = freopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)mode,
                    (FILE */* __restrict  */)stream);
#line 126
  fp = tmp___0;
#line 127
  unlock_1((FILE */* const  */)fp);
  }
#line 128
  return (fp);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 99 "./../include/floatformat.h"
struct floatformat  const  floatformat_ieee_half_big ;
#line 100
struct floatformat  const  floatformat_ieee_half_little ;
#line 101
struct floatformat  const  floatformat_ieee_single_big ;
#line 102
struct floatformat  const  floatformat_ieee_single_little ;
#line 103
struct floatformat  const  floatformat_ieee_double_big ;
#line 104
struct floatformat  const  floatformat_ieee_double_little ;
#line 108
struct floatformat  const  floatformat_ieee_double_littlebyte_bigword ;
#line 112
struct floatformat  const  floatformat_vax_f ;
#line 113
struct floatformat  const  floatformat_vax_d ;
#line 114
struct floatformat  const  floatformat_vax_g ;
#line 118
struct floatformat  const  floatformat_i387_ext ;
#line 119
struct floatformat  const  floatformat_m68881_ext ;
#line 120
struct floatformat  const  floatformat_i960_ext ;
#line 121
struct floatformat  const  floatformat_m88110_ext ;
#line 122
struct floatformat  const  floatformat_m88110_harris_ext ;
#line 123
struct floatformat  const  floatformat_arm_ext_big ;
#line 124
struct floatformat  const  floatformat_arm_ext_littlebyte_bigword ;
#line 126
struct floatformat  const  floatformat_ia64_spill_big ;
#line 127
struct floatformat  const  floatformat_ia64_spill_little ;
#line 128
struct floatformat  const  floatformat_ia64_quad_big ;
#line 129
struct floatformat  const  floatformat_ia64_quad_little ;
#line 131
struct floatformat  const  floatformat_ibm_long_double_big ;
#line 132
struct floatformat  const  floatformat_ibm_long_double_little ;
#line 138
void floatformat_to_double(struct floatformat  const  *fmt , void const   *from ,
                           double *to ) ;
#line 144
void floatformat_from_double(struct floatformat  const  *fmt , double const   *from ,
                             void *to ) ;
#line 149
int floatformat_is_valid(struct floatformat  const  *fmt , void const   *from ) ;
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static int mant_bits_set(struct floatformat  const  *fmt , unsigned char const   *ufrom ) ;
#line 60
static unsigned long get_field(unsigned char const   *data , enum floatformat_byteorders order ,
                               unsigned int total_len , unsigned int start , unsigned int len ) ;
#line 65
static int floatformat_always_valid(struct floatformat  const  *fmt  __attribute__((__unused__)) ,
                                    void const   *from  __attribute__((__unused__)) ) ;
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static int floatformat_always_valid(struct floatformat  const  *fmt  __attribute__((__unused__)) ,
                                    void const   *from  __attribute__((__unused__)) ) 
{ 


  {
#line 72
  return (1);
}
}
#line 81 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_half_big  = 
#line 81
     {(enum floatformat_byteorders )1, 16U, 0U, 1U, 5U, 15, 31U, 6U, 10U, (enum floatformat_intbit )1,
    "floatformat_ieee_half_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 89 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_half_little  = 
#line 89
     {(enum floatformat_byteorders )0, 16U, 0U, 1U, 5U, 15, 31U, 6U, 10U, (enum floatformat_intbit )1,
    "floatformat_ieee_half_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_single_big  = 
#line 97
     {(enum floatformat_byteorders )1, 32U, 0U, 1U, 8U, 127, 255U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_ieee_single_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_single_little  = 
#line 105
     {(enum floatformat_byteorders )0, 32U, 0U, 1U, 8U, 127, 255U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_ieee_single_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 113 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_big  = 
#line 113
     {(enum floatformat_byteorders )1, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 121 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_little  = 
#line 121
     {(enum floatformat_byteorders )0, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_littlebyte_bigword  = 
#line 133
     {(enum floatformat_byteorders )2, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_littlebyte_bigword", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 144 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_f  = 
#line 144
     {(enum floatformat_byteorders )3, 32U, 0U, 1U, 8U, 129, 0U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_vax_f", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 152 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_d  = 
#line 152
     {(enum floatformat_byteorders )3, 64U, 0U, 1U, 8U, 129, 0U, 9U, 55U, (enum floatformat_intbit )1,
    "floatformat_vax_d", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 160 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_g  = 
#line 160
     {(enum floatformat_byteorders )3, 64U, 0U, 1U, 11U, 1025, 0U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_vax_g", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 169
static int floatformat_i387_ext_is_valid(struct floatformat  const  *fmt , void const   *from ) ;
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static int floatformat_i387_ext_is_valid(struct floatformat  const  *fmt , void const   *from ) 
{ 
  unsigned long exponent ;
  unsigned long int_bit ;
  unsigned char const   *ufrom ;

  {
  {
#line 180
  ufrom = (unsigned char const   *)from;
#line 182
  exponent = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                       (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len);
#line 184
  int_bit = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->man_start, 1U);
  }
#line 187
  if ((exponent == 0UL) != (int_bit == 0UL)) {
#line 188
    return (0);
  } else {
#line 190
    return (1);
  }
}
}
#line 193 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_i387_ext  = 
#line 193
     {(enum floatformat_byteorders )0, 80U, 0U, 1U, 15U, 16383, 32767U, 16U, 64U, (enum floatformat_intbit )0,
    "floatformat_i387_ext", & floatformat_i387_ext_is_valid, (struct floatformat  const  *)((void *)0)};
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m68881_ext  = 
#line 201
     {(enum floatformat_byteorders )1, 96U, 0U, 1U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_m68881_ext", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_i960_ext  = 
#line 210
     {(enum floatformat_byteorders )0, 96U, 16U, 17U, 15U, 16383, 32767U, 32U, 64U,
    (enum floatformat_intbit )0, "floatformat_i960_ext", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m88110_ext  = 
#line 219
     {(enum floatformat_byteorders )1, 80U, 0U, 1U, 15U, 16383, 32767U, 16U, 64U, (enum floatformat_intbit )0,
    "floatformat_m88110_ext", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m88110_harris_ext  = 
#line 227
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_m88110_ext_harris", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 237 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_arm_ext_big  = 
#line 237
     {(enum floatformat_byteorders )1, 96U, 0U, 17U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_arm_ext_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_arm_ext_littlebyte_bigword  = 
#line 246
     {(enum floatformat_byteorders )2, 96U, 0U, 17U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_arm_ext_littlebyte_bigword", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 255 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_spill_big  = 
#line 255
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 17U, 65535, 131071U, 18U, 64U,
    (enum floatformat_intbit )0, "floatformat_ia64_spill_big", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 263 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_spill_little  = 
#line 263
     {(enum floatformat_byteorders )0, 128U, 0U, 1U, 17U, 65535, 131071U, 18U, 64U,
    (enum floatformat_intbit )0, "floatformat_ia64_spill_little", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 271 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_quad_big  = 
#line 271
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 15U, 16383, 32767U, 16U, 112U,
    (enum floatformat_intbit )1, "floatformat_ia64_quad_big", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_quad_little  = 
#line 279
     {(enum floatformat_byteorders )0, 128U, 0U, 1U, 15U, 16383, 32767U, 16U, 112U,
    (enum floatformat_intbit )1, "floatformat_ia64_quad_little", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static int floatformat_ibm_long_double_is_valid(struct floatformat  const  *fmt ,
                                                void const   *from ) 
{ 
  unsigned char const   *ufrom ;
  struct floatformat  const  *hfmt ;
  long top_exp ;
  long bot_exp ;
  int top_nan ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int first_bit ;
  int second_bit ;
  int cur_bit ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 292
  ufrom = (unsigned char const   *)from;
#line 293
  hfmt = (struct floatformat  const  *)fmt->split_half;
#line 295
  top_nan = 0;
#line 297
  tmp___0 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                      (unsigned int )hfmt->exp_start, (unsigned int )hfmt->exp_len);
#line 297
  top_exp = (long )tmp___0;
#line 299
  tmp___1 = get_field(ufrom + 8, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                      (unsigned int )hfmt->exp_start, (unsigned int )hfmt->exp_len);
#line 299
  bot_exp = (long )tmp___1;
  }
#line 302
  if ((unsigned long )top_exp == (unsigned long )hfmt->exp_nan) {
    {
#line 303
    top_nan = mant_bits_set(hfmt, ufrom);
    }
  }
#line 306
  if (top_nan) {
#line 307
    return (1);
  }
#line 311
  if ((unsigned long )top_exp == (unsigned long )hfmt->exp_nan) {
#line 311
    goto _L;
  } else
#line 311
  if (top_exp == 0L) {
    _L: /* CIL Label */ 
#line 313
    if (bot_exp != 0L) {
#line 314
      return (0);
    }
    {
#line 316
    tmp___2 = mant_bits_set(hfmt, ufrom + 8);
    }
#line 316
    if (tmp___2) {
#line 316
      tmp___3 = 0;
    } else {
#line 316
      tmp___3 = 1;
    }
#line 316
    return (tmp___3);
  }
#line 325
  if (bot_exp < top_exp - 53L) {
#line 326
    return (1);
  }
#line 327
  if (bot_exp > top_exp - 53L) {
#line 327
    if (bot_exp != 0L) {
#line 328
      return (0);
    }
  }
#line 329
  if (bot_exp == 0L) {
#line 333
    first_bit = -1;
#line 333
    second_bit = -1;
#line 334
    cur_bit = 0;
    {
#line 334
    while (1) {
      while_continue: /* CIL Label */ ;
#line 334
      if (! ((unsigned int )cur_bit < (unsigned int )hfmt->man_len)) {
#line 334
        goto while_break;
      }
      {
#line 335
      tmp___4 = get_field(ufrom + 8, (enum floatformat_byteorders )hfmt->byteorder,
                          (unsigned int )hfmt->totalsize, (unsigned int )(hfmt->man_start + (unsigned int const   )cur_bit),
                          1U);
      }
#line 335
      if (tmp___4) {
#line 338
        if (first_bit == -1) {
#line 339
          first_bit = cur_bit;
        } else {
#line 342
          second_bit = cur_bit;
#line 343
          goto while_break;
        }
      }
#line 334
      cur_bit ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 347
    if (first_bit == -1) {
#line 348
      return (1);
    }
#line 350
    if ((long )(- first_bit) < top_exp - 53L) {
#line 351
      return (1);
    }
#line 352
    if ((long )(- first_bit) > top_exp - 53L) {
#line 353
      return (0);
    }
#line 357
    if (second_bit != -1) {
#line 358
      return (0);
    }
    {
#line 359
    tmp___5 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                        (unsigned int )((hfmt->man_start + hfmt->man_len) - 1U), 1U);
    }
#line 359
    if (tmp___5) {
#line 359
      tmp___6 = 0;
    } else {
#line 359
      tmp___6 = 1;
    }
#line 359
    return (tmp___6);
  } else {
    {
#line 367
    tmp___7 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                        (unsigned int )((hfmt->man_start + hfmt->man_len) - 1U), 1U);
    }
#line 367
    if (tmp___7) {
#line 369
      return (0);
    }
    {
#line 370
    tmp___8 = mant_bits_set(hfmt, ufrom + 8);
    }
#line 370
    if (tmp___8) {
#line 370
      tmp___9 = 0;
    } else {
#line 370
      tmp___9 = 1;
    }
#line 370
    return (tmp___9);
  }
}
}
#line 374 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ibm_long_double_big  = 
#line 374
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ibm_long_double_big", & floatformat_ibm_long_double_is_valid, & floatformat_ieee_double_big};
#line 383 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ibm_long_double_little  = 
#line 383
     {(enum floatformat_byteorders )0, 128U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ibm_long_double_little", & floatformat_ibm_long_double_is_valid,
    & floatformat_ieee_double_little};
#line 399 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static int mant_bits_set(struct floatformat  const  *fmt , unsigned char const   *ufrom ) 
{ 
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  unsigned long tmp___0 ;

  {
#line 405
  mant_off = (unsigned int )fmt->man_start;
#line 406
  mant_bits_left = (int )fmt->man_len;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (mant_bits_left > 0)) {
#line 407
      goto while_break;
    }
#line 409
    if (mant_bits_left < 32) {
#line 409
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 409
      mant_bits = 32U;
    }
    {
#line 411
    tmp___0 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                        mant_off, mant_bits);
    }
#line 411
    if (tmp___0 != 0UL) {
#line 413
      return (1);
    }
#line 415
    mant_off += mant_bits;
#line 416
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return (0);
}
}
#line 423 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static unsigned long get_field(unsigned char const   *data , enum floatformat_byteorders order ,
                               unsigned int total_len , unsigned int start , unsigned int len ) 
{ 
  unsigned long result ;
  unsigned int cur_byte ;
  int lo_bit ;
  int hi_bit ;
  int cur_bitshift ;
  int nextbyte ;
  int tmp___0 ;
  unsigned int shifted ;
  unsigned int bits ;
  unsigned int mask ;

  {
#line 427
  result = 0UL;
#line 429
  cur_bitshift = 0;
#line 430
  if ((unsigned int )order == 0U) {
#line 430
    tmp___0 = 1;
  } else {
#line 430
    tmp___0 = -1;
  }
#line 430
  nextbyte = tmp___0;
#line 433
  start = total_len - (start + len);
#line 436
  if ((unsigned int )order == 0U) {
#line 437
    cur_byte = start / 8U;
  } else {
#line 439
    cur_byte = ((total_len - start) - 1U) / 8U;
  }
#line 441
  lo_bit = (int )(start % 8U);
#line 442
  if ((unsigned int )lo_bit + len < 8U) {
#line 442
    hi_bit = (int )((unsigned int )lo_bit + len);
  } else {
#line 442
    hi_bit = 8;
  }
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    shifted = (unsigned int )((int const   )*(data + cur_byte) >> lo_bit);
#line 447
    bits = (unsigned int )(hi_bit - lo_bit);
#line 448
    mask = (unsigned int )((1 << bits) - 1);
#line 449
    result |= (unsigned long )((shifted & mask) << cur_bitshift);
#line 450
    len -= bits;
#line 451
    cur_bitshift = (int )((unsigned int )cur_bitshift + bits);
#line 452
    cur_byte += (unsigned int )nextbyte;
#line 453
    lo_bit = 0;
#line 454
    if (len < 8U) {
#line 454
      hi_bit = (int )len;
    } else {
#line 454
      hi_bit = 8;
    }
#line 444
    if (! (len != 0U)) {
#line 444
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return (result);
}
}
#line 465 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
void floatformat_to_double(struct floatformat  const  *fmt , void const   *from ,
                           double *to ) 
{ 
  unsigned char const   *ufrom ;
  double dto ;
  long exponent ;
  unsigned long mant ;
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  unsigned long tmp___0 ;
  int nan___0 ;
  int tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  unsigned long tmp___4 ;
  double tmp___5 ;
  unsigned long tmp___6 ;

  {
  {
#line 469
  ufrom = (unsigned char const   *)from;
#line 480
  tmp___0 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len);
#line 480
  exponent = (long )tmp___0;
  }
#line 486
  if ((unsigned long )exponent == (unsigned long )fmt->exp_nan) {
    {
#line 488
    tmp___1 = mant_bits_set(fmt, ufrom);
#line 488
    nan___0 = tmp___1;
    }
#line 497
    if (nan___0) {
      {
#line 498
      tmp___2 = __builtin_nanf("");
#line 498
      dto = (double )tmp___2;
      }
    } else {
      {
#line 500
      tmp___3 = __builtin_inff();
#line 500
      dto = (double )tmp___3;
      }
    }
    {
#line 502
    tmp___4 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                        (unsigned int )fmt->sign_start, 1U);
    }
#line 502
    if (tmp___4) {
#line 503
      dto = - dto;
    }
#line 505
    *to = dto;
#line 507
    return;
  }
#line 510
  mant_bits_left = (int )fmt->man_len;
#line 511
  mant_off = (unsigned int )fmt->man_start;
#line 512
  dto = 0.0;
#line 518
  if (exponent == 0L) {
#line 519
    exponent = (long )(1 - (int )fmt->exp_bias);
  } else {
#line 522
    exponent -= (long )fmt->exp_bias;
#line 528
    if ((unsigned int const   )fmt->intbit == 1U) {
      {
#line 529
      dto = ldexp(1.0, (int )exponent);
      }
    } else {
#line 531
      exponent ++;
    }
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (mant_bits_left > 0)) {
#line 534
      goto while_break;
    }
#line 536
    if (mant_bits_left < 32) {
#line 536
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 536
      mant_bits = 32U;
    }
    {
#line 538
    mant = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                     mant_off, mant_bits);
#line 541
    tmp___5 = ldexp((double )mant, (int )(exponent - (long )mant_bits));
#line 541
    dto += tmp___5;
#line 542
    exponent -= (long )mant_bits;
#line 543
    mant_off += mant_bits;
#line 544
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 548
  tmp___6 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->sign_start, 1U);
  }
#line 548
  if (tmp___6) {
#line 549
    dto = - dto;
  }
#line 550
  *to = dto;
#line 551
  return;
}
}
#line 553
static void put_field(unsigned char *data , enum floatformat_byteorders order , unsigned int total_len ,
                      unsigned int start , unsigned int len , unsigned long stuff_to_put ) ;
#line 561 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
static void put_field(unsigned char *data , enum floatformat_byteorders order , unsigned int total_len ,
                      unsigned int start , unsigned int len , unsigned long stuff_to_put ) 
{ 
  unsigned int cur_byte ;
  int lo_bit ;
  int hi_bit ;
  int nextbyte ;
  int tmp___0 ;
  unsigned char *byte_ptr ;
  unsigned int bits ;
  unsigned int mask ;

  {
#line 568
  if ((unsigned int )order == 0U) {
#line 568
    tmp___0 = 1;
  } else {
#line 568
    tmp___0 = -1;
  }
#line 568
  nextbyte = tmp___0;
#line 571
  start = total_len - (start + len);
#line 574
  if ((unsigned int )order == 0U) {
#line 575
    cur_byte = start / 8U;
  } else {
#line 577
    cur_byte = ((total_len - start) - 1U) / 8U;
  }
#line 579
  lo_bit = (int )(start % 8U);
#line 580
  if ((unsigned int )lo_bit + len < 8U) {
#line 580
    hi_bit = (int )((unsigned int )lo_bit + len);
  } else {
#line 580
    hi_bit = 8;
  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    byte_ptr = data + cur_byte;
#line 585
    bits = (unsigned int )(hi_bit - lo_bit);
#line 586
    mask = (unsigned int )(((1 << bits) - 1) << lo_bit);
#line 587
    *byte_ptr = (unsigned char )((unsigned long )((unsigned int )*byte_ptr & ~ mask) | ((stuff_to_put << lo_bit) & (unsigned long )mask));
#line 588
    stuff_to_put >>= bits;
#line 589
    len -= bits;
#line 590
    cur_byte += (unsigned int )nextbyte;
#line 591
    lo_bit = 0;
#line 592
    if (len < 8U) {
#line 592
      hi_bit = (int )len;
    } else {
#line 592
      hi_bit = 8;
    }
#line 582
    if (! (len != 0U)) {
#line 582
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return;
}
}
#line 601 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
void floatformat_from_double(struct floatformat  const  *fmt , double const   *from ,
                             void *to ) 
{ 
  double dfrom ;
  int exponent ;
  double mant ;
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  unsigned char *uto ;
  unsigned long mant_long ;

  {
  {
#line 610
  uto = (unsigned char *)to;
#line 612
  dfrom = (double )*from;
#line 613
  memset((void *)uto, 0, (size_t )(fmt->totalsize / 8U));
  }
#line 620
  if (dfrom < (double )0) {
    {
#line 622
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->sign_start, 1U, 1UL);
#line 623
    dfrom = - dfrom;
    }
  }
#line 626
  if (dfrom == (double )0) {
#line 629
    return;
  }
#line 632
  if (dfrom != dfrom) {
    {
#line 635
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )fmt->exp_nan);
#line 638
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->man_start, 32U, 1UL);
    }
#line 640
    return;
  }
#line 643
  if (dfrom + dfrom == dfrom) {
    {
#line 647
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )fmt->exp_nan);
    }
#line 649
    return;
  }
  {
#line 652
  mant = frexp(dfrom, & exponent);
  }
#line 653
  if ((exponent + (int )fmt->exp_bias) - 1 > 0) {
    {
#line 654
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )((exponent + (int )fmt->exp_bias) - 1));
    }
  } else {
    {
#line 660
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, 0UL);
#line 662
    mant = ldexp(mant, (exponent + (int )fmt->exp_bias) - 1);
    }
  }
#line 665
  mant_bits_left = (int )fmt->man_len;
#line 666
  mant_off = (unsigned int )fmt->man_start;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (mant_bits_left > 0)) {
#line 667
      goto while_break;
    }
#line 670
    if (mant_bits_left < 32) {
#line 670
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 670
      mant_bits = 32U;
    }
#line 672
    mant *= 4294967296.0;
#line 673
    mant_long = (unsigned long )mant;
#line 674
    mant -= (double )mant_long;
#line 678
    if ((unsigned int )mant_bits_left == (unsigned int )fmt->man_len) {
#line 678
      if ((unsigned int const   )fmt->intbit == 1U) {
#line 678
        if ((exponent + (int )fmt->exp_bias) - 1 > 0) {
#line 682
          mant_long &= 2147483647UL;
#line 683
          mant_bits --;
        } else {
#line 678
          goto _L___0;
        }
      } else {
#line 678
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 685
    if (mant_bits < 32U) {
#line 689
      mant_long >>= 32U - mant_bits;
    }
    {
#line 692
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              mant_off, mant_bits, mant_long);
#line 694
    mant_off += mant_bits;
#line 695
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return;
}
}
#line 701 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./floatformat.c"
int floatformat_is_valid(struct floatformat  const  *fmt , void const   *from ) 
{ 
  int tmp___0 ;

  {
  {
#line 704
  tmp___0 = (*(fmt->is_valid))(fmt, from);
  }
#line 704
  return (tmp___0);
}
}
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 83 "./../include/filenames.h"
int filename_cmp(char const   *s1 , char const   *s2 ) ;
#line 86
int filename_ncmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 89
hashval_t filename_hash(void const   *s ) ;
#line 91
int filename_eq(void const   *s1 , void const   *s2 ) ;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./filename_cmp.c"
int filename_cmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp___0 ;

  {
  {
#line 55
  tmp___0 = strcmp(s1, s2);
  }
#line 55
  return (tmp___0);
}
}
#line 108 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./filename_cmp.c"
int filename_ncmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  int tmp___0 ;

  {
  {
#line 113
  tmp___0 = strncmp(s1, s2, n);
  }
#line 113
  return (tmp___0);
}
}
#line 157 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./filename_cmp.c"
hashval_t filename_hash(void const   *s ) 
{ 
  unsigned char const   *str ;
  hashval_t r ;
  unsigned char c ;
  unsigned char const   *tmp___0 ;

  {
#line 161
  str = (unsigned char const   *)s;
#line 162
  r = (hashval_t )0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    tmp___0 = str;
#line 165
    str ++;
#line 165
    c = (unsigned char )*tmp___0;
#line 165
    if (! ((int )c != 0)) {
#line 165
      goto while_break;
    }
#line 167
    if ((int )c == 92) {
#line 168
      c = (unsigned char )'/';
    }
#line 169
    c = (unsigned char )_sch_tolower[(int )c & 255];
#line 170
    r = (r * 67U + (hashval_t )c) - 113U;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (r);
}
}
#line 187 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./filename_cmp.c"
int filename_eq(void const   *s1 , void const   *s2 ) 
{ 
  int tmp___0 ;

  {
  {
#line 191
  tmp___0 = filename_cmp((char const   *)s1, (char const   *)s2);
  }
#line 191
  return (tmp___0 == 0);
}
}
#line 76 "./../include/fibheap.h"
fibheap_t fibheap_new(void) ;
#line 77
fibnode_t fibheap_insert(fibheap_t heap , fibheapkey_t key , void *data ) ;
#line 78
int fibheap_empty(fibheap_t heap ) ;
#line 79
fibheapkey_t fibheap_min_key(fibheap_t heap ) ;
#line 80
fibheapkey_t fibheap_replace_key(fibheap_t heap , fibnode_t node , fibheapkey_t key ) ;
#line 82
void *fibheap_replace_key_data(fibheap_t heap , fibnode_t node , fibheapkey_t key ,
                               void *data ) ;
#line 84
void *fibheap_extract_min(fibheap_t heap ) ;
#line 85
void *fibheap_min(fibheap_t heap ) ;
#line 86
void *fibheap_replace_data(fibheap_t heap , fibnode_t node , void *data ) ;
#line 87
void *fibheap_delete_node(fibheap_t heap , fibnode_t node ) ;
#line 88
void fibheap_delete(fibheap_t heap ) ;
#line 89
fibheap_t fibheap_union(fibheap_t heapa , fibheap_t heapb ) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_ins_root(fibheap_t heap , fibnode_t node ) ;
#line 41
static void fibheap_rem_root(fibheap_t heap , fibnode_t node ) ;
#line 42
static void fibheap_consolidate(fibheap_t heap ) ;
#line 43
static void fibheap_link(fibheap_t heap  __attribute__((__unused__)) , fibnode_t node ,
                         fibnode_t parent ) ;
#line 44
static void fibheap_cut(fibheap_t heap , fibnode_t node , fibnode_t parent ) ;
#line 45
static void fibheap_cascading_cut(fibheap_t heap , fibnode_t y ) ;
#line 46
static fibnode_t fibheap_extr_min_node(fibheap_t heap ) ;
#line 47
__inline static int fibheap_compare(fibheap_t heap  __attribute__((__unused__)) ,
                                    fibnode_t a , fibnode_t b ) ;
#line 48
__inline static int fibheap_comp_data(fibheap_t heap , fibheapkey_t key , void *data ,
                                      fibnode_t b ) ;
#line 49
static fibnode_t fibnode_new(void) ;
#line 50
static void fibnode_insert_after(fibnode_t a , fibnode_t b ) ;
#line 52
static fibnode_t fibnode_remove(fibnode_t node ) ;
#line 56 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
fibheap_t fibheap_new(void) 
{ 
  void *tmp___0 ;

  {
  {
#line 59
  tmp___0 = xcalloc((size_t )1, sizeof(struct fibheap ));
  }
#line 59
  return ((fibheap_t )tmp___0);
}
}
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static fibnode_t fibnode_new(void) 
{ 
  fibnode_t node ;
  void *tmp___0 ;

  {
  {
#line 68
  tmp___0 = xcalloc((size_t )1, sizeof(*node));
#line 68
  node = (fibnode_t )tmp___0;
#line 69
  node->left = node;
#line 70
  node->right = node;
  }
#line 72
  return (node);
}
}
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
__inline static int fibheap_compare(fibheap_t heap  __attribute__((__unused__)) ,
                                    fibnode_t a , fibnode_t b ) 
{ 


  {
#line 78
  if (a->key < b->key) {
#line 79
    return (-1);
  }
#line 80
  if (a->key > b->key) {
#line 81
    return (1);
  }
#line 82
  return (0);
}
}
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
__inline static int fibheap_comp_data(fibheap_t heap , fibheapkey_t key , void *data ,
                                      fibnode_t b ) 
{ 
  struct fibnode a ;
  int tmp___0 ;

  {
  {
#line 90
  a.key = key;
#line 91
  a.data = data;
#line 93
  tmp___0 = fibheap_compare(heap, & a, b);
  }
#line 93
  return (tmp___0);
}
}
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
fibnode_t fibheap_insert(fibheap_t heap , fibheapkey_t key , void *data ) 
{ 
  fibnode_t node ;

  {
  {
#line 103
  node = fibnode_new();
#line 106
  node->data = data;
#line 107
  node->key = key;
#line 110
  fibheap_ins_root(heap, node);
  }
#line 114
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 115
    heap->min = node;
  } else
#line 114
  if (node->key < (heap->min)->key) {
#line 115
    heap->min = node;
  }
#line 117
  (heap->nodes) ++;
#line 119
  return (node);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void *fibheap_min(fibheap_t heap ) 
{ 


  {
#line 127
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 128
    return ((void *)0);
  }
#line 129
  return ((heap->min)->data);
}
}
#line 133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
fibheapkey_t fibheap_min_key(fibheap_t heap ) 
{ 


  {
#line 137
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 138
    return ((fibheapkey_t )0);
  }
#line 139
  return ((heap->min)->key);
}
}
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
fibheap_t fibheap_union(fibheap_t heapa , fibheap_t heapb ) 
{ 
  fibnode_t a_root ;
  fibnode_t b_root ;
  fibnode_t temp ;
  int tmp___0 ;

  {
#line 149
  a_root = heapa->root;
#line 149
  if ((unsigned long )a_root == (unsigned long )((void *)0)) {
    {
#line 151
    free((void *)heapa);
    }
#line 152
    return (heapb);
  }
#line 154
  b_root = heapb->root;
#line 154
  if ((unsigned long )b_root == (unsigned long )((void *)0)) {
    {
#line 156
    free((void *)heapb);
    }
#line 157
    return (heapa);
  }
  {
#line 161
  (a_root->left)->right = b_root;
#line 162
  (b_root->left)->right = a_root;
#line 163
  temp = a_root->left;
#line 164
  a_root->left = b_root->left;
#line 165
  b_root->left = temp;
#line 166
  heapa->nodes += heapb->nodes;
#line 169
  tmp___0 = fibheap_compare(heapa, heapb->min, heapa->min);
  }
#line 169
  if (tmp___0 < 0) {
#line 170
    heapa->min = heapb->min;
  }
  {
#line 172
  free((void *)heapb);
  }
#line 173
  return (heapa);
}
}
#line 177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void *fibheap_extract_min(fibheap_t heap ) 
{ 
  fibnode_t z ;
  void *ret ;

  {
#line 181
  ret = (void *)0;
#line 184
  if ((unsigned long )heap->min != (unsigned long )((void *)0)) {
    {
#line 188
    z = fibheap_extr_min_node(heap);
#line 189
    ret = z->data;
#line 190
    free((void *)z);
    }
  }
#line 193
  return (ret);
}
}
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void *fibheap_replace_key_data(fibheap_t heap , fibnode_t node , fibheapkey_t key ,
                               void *data ) 
{ 
  void *odata ;
  fibheapkey_t okey ;
  fibnode_t y ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 208
  tmp___0 = fibheap_comp_data(heap, key, data, node);
  }
#line 208
  if (tmp___0 > 0) {
#line 209
    return ((void *)0);
  }
#line 211
  odata = node->data;
#line 212
  okey = node->key;
#line 213
  node->data = data;
#line 214
  node->key = key;
#line 215
  y = node->parent;
#line 220
  if (okey == key) {
#line 220
    if (okey != (-0x7FFFFFFFFFFFFFFF-1)) {
#line 221
      return (odata);
    }
  }
#line 226
  if ((unsigned long )y != (unsigned long )((void *)0)) {
    {
#line 226
    tmp___1 = fibheap_compare(heap, node, y);
    }
#line 226
    if (tmp___1 <= 0) {
      {
#line 228
      fibheap_cut(heap, node, y);
#line 229
      fibheap_cascading_cut(heap, y);
      }
    }
  }
  {
#line 232
  tmp___2 = fibheap_compare(heap, node, heap->min);
  }
#line 232
  if (tmp___2 <= 0) {
#line 233
    heap->min = node;
  }
#line 235
  return (odata);
}
}
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void *fibheap_replace_data(fibheap_t heap , fibnode_t node , void *data ) 
{ 
  void *tmp___0 ;

  {
  {
#line 242
  tmp___0 = fibheap_replace_key_data(heap, node, node->key, data);
  }
#line 242
  return (tmp___0);
}
}
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
fibheapkey_t fibheap_replace_key(fibheap_t heap , fibnode_t node , fibheapkey_t key ) 
{ 
  int okey ;

  {
  {
#line 249
  okey = (int )node->key;
#line 250
  fibheap_replace_key_data(heap, node, key, node->data);
  }
#line 251
  return ((fibheapkey_t )okey);
}
}
#line 255 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void *fibheap_delete_node(fibheap_t heap , fibnode_t node ) 
{ 
  void *ret ;

  {
  {
#line 258
  ret = node->data;
#line 261
  fibheap_replace_key(heap, node, (-0x7FFFFFFFFFFFFFFF-1));
  }
#line 262
  if ((unsigned long )node != (unsigned long )heap->min) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t force minimum on fibheap.\n");
#line 265
    abort();
    }
  }
  {
#line 267
  fibheap_extract_min(heap);
  }
#line 269
  return (ret);
}
}
#line 273 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
void fibheap_delete(fibheap_t heap ) 
{ 
  fibnode_t tmp___0 ;

  {
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )heap->min != (unsigned long )((void *)0))) {
#line 276
      goto while_break;
    }
    {
#line 277
    tmp___0 = fibheap_extr_min_node(heap);
#line 277
    free((void *)tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  free((void *)heap);
  }
#line 280
  return;
}
}
#line 283 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
int fibheap_empty(fibheap_t heap ) 
{ 


  {
#line 286
  return (heap->nodes == 0UL);
}
}
#line 290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static fibnode_t fibheap_extr_min_node(fibheap_t heap ) 
{ 
  fibnode_t ret ;
  fibnode_t x ;
  fibnode_t y ;
  fibnode_t orig ;

  {
#line 293
  ret = heap->min;
#line 298
  x = ret->child;
#line 298
  orig = (fibnode_t )((void *)0);
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if ((unsigned long )x != (unsigned long )orig) {
#line 298
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 298
        goto while_break;
      }
    } else {
#line 298
      goto while_break;
    }
#line 300
    if ((unsigned long )orig == (unsigned long )((void *)0)) {
#line 301
      orig = x;
    }
    {
#line 302
    y = x->right;
#line 303
    x->parent = (struct fibnode *)((void *)0);
#line 304
    fibheap_ins_root(heap, x);
#line 298
    x = y;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  fibheap_rem_root(heap, ret);
#line 309
  (heap->nodes) --;
  }
#line 312
  if (heap->nodes == 0UL) {
#line 313
    heap->min = (struct fibnode *)((void *)0);
  } else {
    {
#line 318
    heap->min = ret->right;
#line 319
    fibheap_consolidate(heap);
    }
  }
#line 322
  return (ret);
}
}
#line 326 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_ins_root(fibheap_t heap , fibnode_t node ) 
{ 


  {
#line 331
  if ((unsigned long )heap->root == (unsigned long )((void *)0)) {
#line 333
    heap->root = node;
#line 334
    node->left = node;
#line 335
    node->right = node;
#line 336
    return;
  }
  {
#line 341
  fibnode_insert_after(heap->root, node);
  }
#line 342
  return;
}
}
#line 345 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_rem_root(fibheap_t heap , fibnode_t node ) 
{ 


  {
#line 348
  if ((unsigned long )node->left == (unsigned long )node) {
#line 349
    heap->root = (struct fibnode *)((void *)0);
  } else {
    {
#line 351
    heap->root = fibnode_remove(node);
    }
  }
#line 352
  return;
}
}
#line 355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_consolidate(fibheap_t heap ) 
{ 
  fibnode_t a[1UL + 8UL * sizeof(long )] ;
  fibnode_t w ;
  fibnode_t y ;
  fibnode_t x ;
  int i ;
  int d ;
  int D ;
  fibnode_t temp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 366
  D = (int )(1UL + 8UL * sizeof(long ));
#line 368
  memset((void *)(a), 0, sizeof(fibnode_t ) * (unsigned long )D);
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    w = heap->root;
#line 370
    if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
    {
#line 372
    x = w;
#line 373
    fibheap_rem_root(heap, w);
#line 374
    d = (int )x->degree;
    }
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! ((unsigned long )a[d] != (unsigned long )((void *)0))) {
#line 375
        goto while_break___0;
      }
      {
#line 377
      y = a[d];
#line 378
      tmp___0 = fibheap_compare(heap, x, y);
      }
#line 378
      if (tmp___0 > 0) {
#line 381
        temp = x;
#line 382
        x = y;
#line 383
        y = temp;
      }
      {
#line 385
      fibheap_link(heap, y, x);
#line 386
      a[d] = (fibnode_t )((void *)0);
#line 387
      d ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    a[d] = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  heap->min = (struct fibnode *)((void *)0);
#line 392
  i = 0;
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 392
    if (! (i < D)) {
#line 392
      goto while_break___1;
    }
#line 393
    if ((unsigned long )a[i] != (unsigned long )((void *)0)) {
      {
#line 395
      fibheap_ins_root(heap, a[i]);
      }
#line 396
      if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 397
        heap->min = a[i];
      } else {
        {
#line 396
        tmp___1 = fibheap_compare(heap, a[i], heap->min);
        }
#line 396
        if (tmp___1 < 0) {
#line 397
          heap->min = a[i];
        }
      }
    }
#line 392
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 402 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_link(fibheap_t heap  __attribute__((__unused__)) , fibnode_t node ,
                         fibnode_t parent ) 
{ 


  {
#line 406
  if ((unsigned long )parent->child == (unsigned long )((void *)0)) {
#line 407
    parent->child = node;
  } else {
    {
#line 409
    fibnode_insert_after((parent->child)->left, node);
    }
  }
#line 410
  node->parent = parent;
#line 411
  (parent->degree) ++;
#line 412
  node->mark = 0U;
#line 413
  return;
}
}
#line 416 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_cut(fibheap_t heap , fibnode_t node , fibnode_t parent ) 
{ 


  {
  {
#line 419
  fibnode_remove(node);
#line 420
  (parent->degree) --;
#line 421
  fibheap_ins_root(heap, node);
#line 422
  node->parent = (struct fibnode *)((void *)0);
#line 423
  node->mark = 0U;
  }
#line 424
  return;
}
}
#line 426 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibheap_cascading_cut(fibheap_t heap , fibnode_t y ) 
{ 
  fibnode_t z ;

  {
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    z = y->parent;
#line 431
    if (! ((unsigned long )z != (unsigned long )((void *)0))) {
#line 431
      goto while_break;
    }
#line 433
    if (y->mark == 0U) {
#line 435
      y->mark = 1U;
#line 436
      return;
    } else {
      {
#line 440
      fibheap_cut(heap, y, z);
#line 441
      y = z;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return;
}
}
#line 446 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static void fibnode_insert_after(fibnode_t a , fibnode_t b ) 
{ 


  {
#line 449
  if ((unsigned long )a == (unsigned long )a->right) {
#line 451
    a->right = b;
#line 452
    a->left = b;
#line 453
    b->right = a;
#line 454
    b->left = a;
  } else {
#line 458
    b->right = a->right;
#line 459
    (a->right)->left = b;
#line 460
    a->right = b;
#line 461
    b->left = a;
  }
#line 463
  return;
}
}
#line 465 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fibheap.c"
static fibnode_t fibnode_remove(fibnode_t node ) 
{ 
  fibnode_t ret ;

  {
#line 470
  if ((unsigned long )node == (unsigned long )node->left) {
#line 471
    ret = (fibnode_t )((void *)0);
  } else {
#line 473
    ret = node->left;
  }
#line 475
  if ((unsigned long )node->parent != (unsigned long )((void *)0)) {
#line 475
    if ((unsigned long )(node->parent)->child == (unsigned long )node) {
#line 476
      (node->parent)->child = ret;
    }
  }
#line 478
  (node->right)->left = node->left;
#line 479
  (node->left)->right = node->right;
#line 481
  node->parent = (struct fibnode *)((void *)0);
#line 482
  node->left = node;
#line 483
  node->right = node;
#line 485
  return (ret);
}
}
#line 187 "./../include/libiberty.h"
int fdmatch(int fd1 , int fd2 ) ;
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./fdmatch.c"
int fdmatch(int fd1 , int fd2 ) 
{ 
  struct stat sbuf1 ;
  struct stat sbuf2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 57
  tmp___0 = fstat(fd1, & sbuf1);
  }
#line 57
  if (tmp___0 == 0) {
    {
#line 57
    tmp___1 = fstat(fd2, & sbuf2);
    }
#line 57
    if (tmp___1 == 0) {
#line 57
      if (sbuf1.st_dev == sbuf2.st_dev) {
#line 57
        if (sbuf1.st_ino == sbuf2.st_ino) {
#line 62
          return (1);
        } else {
#line 66
          return (0);
        }
      } else {
#line 66
        return (0);
      }
    } else {
#line 66
      return (0);
    }
  } else {
#line 66
    return (0);
  }
}
}
#line 50 "./../include/dyn-string.h"
int dyn_string_init(struct dyn_string *ds_struct_ptr , int space ) ;
#line 51
dyn_string_t dyn_string_new(int space ) ;
#line 52
void dyn_string_delete(dyn_string_t ds ) ;
#line 53
char *dyn_string_release(dyn_string_t ds ) ;
#line 54
dyn_string_t dyn_string_resize(dyn_string_t ds , int space ) ;
#line 55
void dyn_string_clear(dyn_string_t ds ) ;
#line 56
int dyn_string_copy(dyn_string_t dest , dyn_string_t src ) ;
#line 57
int dyn_string_copy_cstr(dyn_string_t dest , char const   *src ) ;
#line 58
int dyn_string_prepend(dyn_string_t dest , dyn_string_t src ) ;
#line 59
int dyn_string_prepend_cstr(dyn_string_t dest , char const   *src ) ;
#line 60
int dyn_string_insert(dyn_string_t dest , int pos , dyn_string_t src ) ;
#line 61
int dyn_string_insert_cstr(dyn_string_t dest , int pos , char const   *src ) ;
#line 62
int dyn_string_insert_char(dyn_string_t dest , int pos , int c ) ;
#line 63
int dyn_string_append(dyn_string_t dest , dyn_string_t s ) ;
#line 64
int dyn_string_append_cstr(dyn_string_t dest , char const   *s ) ;
#line 65
int dyn_string_append_char(dyn_string_t dest , int c ) ;
#line 66
int dyn_string_substring(dyn_string_t dest , dyn_string_t src , int start , int end ) ;
#line 67
int dyn_string_eq(dyn_string_t ds1 , dyn_string_t ds2 ) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_init(struct dyn_string *ds_struct_ptr , int space ) 
{ 
  void *tmp___0 ;

  {
#line 62
  if (space == 0) {
#line 63
    space = 1;
  }
  {
#line 70
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )space);
#line 70
  ds_struct_ptr->s = (char *)tmp___0;
#line 72
  ds_struct_ptr->allocated = space;
#line 73
  ds_struct_ptr->length = 0;
#line 74
  *(ds_struct_ptr->s + 0) = (char )'\000';
  }
#line 76
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
dyn_string_t dyn_string_new(int space ) 
{ 
  dyn_string_t result ;
  void *tmp___0 ;

  {
  {
#line 99
  tmp___0 = xmalloc(sizeof(struct dyn_string ));
#line 99
  result = (struct dyn_string *)tmp___0;
#line 100
  dyn_string_init(result, space);
  }
#line 102
  return (result);
}
}
#line 107 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
void dyn_string_delete(dyn_string_t ds ) 
{ 


  {
  {
#line 110
  free((void *)ds->s);
#line 111
  free((void *)ds);
  }
#line 112
  return;
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
char *dyn_string_release(dyn_string_t ds ) 
{ 
  char *result ;

  {
  {
#line 122
  result = ds->s;
#line 124
  ds->s = (char *)((void *)0);
#line 126
  free((void *)ds);
  }
#line 128
  return (result);
}
}
#line 138 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
dyn_string_t dyn_string_resize(dyn_string_t ds , int space ) 
{ 
  int new_allocated ;
  void *tmp___0 ;

  {
#line 141
  new_allocated = ds->allocated;
#line 144
  space ++;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (space > new_allocated)) {
#line 147
      goto while_break;
    }
#line 148
    new_allocated *= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (new_allocated != ds->allocated) {
    {
#line 152
    ds->allocated = new_allocated;
#line 162
    tmp___0 = xrealloc((void *)ds->s, sizeof(char ) * (unsigned long )ds->allocated);
#line 162
    ds->s = (char *)tmp___0;
    }
  }
#line 166
  return (ds);
}
}
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
void dyn_string_clear(dyn_string_t ds ) 
{ 


  {
#line 175
  *(ds->s + 0) = (char )'\000';
#line 176
  ds->length = 0;
#line 177
  return;
}
}
#line 183 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_copy(dyn_string_t dest , dyn_string_t src ) 
{ 
  dyn_string_t tmp___0 ;

  {
#line 186
  if ((unsigned long )dest == (unsigned long )src) {
    {
#line 187
    abort();
    }
  }
  {
#line 190
  tmp___0 = dyn_string_resize(dest, src->length);
  }
#line 190
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 191
    return (0);
  }
  {
#line 193
  strcpy((char */* __restrict  */)dest->s, (char const   */* __restrict  */)src->s);
#line 195
  dest->length = src->length;
  }
#line 196
  return (1);
}
}
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_copy_cstr(dyn_string_t dest , char const   *src ) 
{ 
  int length ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 206
  tmp___0 = strlen(src);
#line 206
  length = (int )tmp___0;
#line 208
  tmp___1 = dyn_string_resize(dest, length);
  }
#line 208
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 209
    return (0);
  }
  {
#line 211
  strcpy((char */* __restrict  */)dest->s, (char const   */* __restrict  */)src);
#line 213
  dest->length = length;
  }
#line 214
  return (1);
}
}
#line 222 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_prepend(dyn_string_t dest , dyn_string_t src ) 
{ 
  int tmp___0 ;

  {
  {
#line 225
  tmp___0 = dyn_string_insert(dest, 0, src);
  }
#line 225
  return (tmp___0);
}
}
#line 232 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_prepend_cstr(dyn_string_t dest , char const   *src ) 
{ 
  int tmp___0 ;

  {
  {
#line 235
  tmp___0 = dyn_string_insert_cstr(dest, 0, src);
  }
#line 235
  return (tmp___0);
}
}
#line 243 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_insert(dyn_string_t dest , int pos , dyn_string_t src ) 
{ 
  int i ;
  dyn_string_t tmp___0 ;

  {
#line 248
  if ((unsigned long )src == (unsigned long )dest) {
    {
#line 249
    abort();
    }
  }
  {
#line 251
  tmp___0 = dyn_string_resize(dest, dest->length + src->length);
  }
#line 251
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 252
    return (0);
  }
#line 254
  i = dest->length;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i >= pos)) {
#line 254
      goto while_break;
    }
#line 255
    *(dest->s + (i + src->length)) = *(dest->s + i);
#line 254
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  strncpy((char */* __restrict  */)(dest->s + pos), (char const   */* __restrict  */)src->s,
          (size_t )src->length);
#line 259
  dest->length += src->length;
  }
#line 260
  return (1);
}
}
#line 268 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_insert_cstr(dyn_string_t dest , int pos , char const   *src ) 
{ 
  int i ;
  int length ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 272
  tmp___0 = strlen(src);
#line 272
  length = (int )tmp___0;
#line 274
  tmp___1 = dyn_string_resize(dest, dest->length + length);
  }
#line 274
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 275
    return (0);
  }
#line 277
  i = dest->length;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i >= pos)) {
#line 277
      goto while_break;
    }
#line 278
    *(dest->s + (i + length)) = *(dest->s + i);
#line 277
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  strncpy((char */* __restrict  */)(dest->s + pos), (char const   */* __restrict  */)src,
          (size_t )length);
#line 282
  dest->length += length;
  }
#line 283
  return (1);
}
}
#line 290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_insert_char(dyn_string_t dest , int pos , int c ) 
{ 
  int i ;
  dyn_string_t tmp___0 ;

  {
  {
#line 295
  tmp___0 = dyn_string_resize(dest, dest->length + 1);
  }
#line 295
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 296
    return (0);
  }
#line 298
  i = dest->length;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i >= pos)) {
#line 298
      goto while_break;
    }
#line 299
    *(dest->s + (i + 1)) = *(dest->s + i);
#line 298
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  *(dest->s + pos) = (char )c;
#line 303
  (dest->length) ++;
#line 304
  return (1);
}
}
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_append(dyn_string_t dest , dyn_string_t s ) 
{ 
  dyn_string_t tmp___0 ;

  {
  {
#line 314
  tmp___0 = dyn_string_resize(dest, dest->length + s->length);
  }
#line 314
  if ((unsigned long )tmp___0 == (unsigned long )((dyn_string_t )0)) {
#line 315
    return (0);
  }
  {
#line 316
  strcpy((char */* __restrict  */)(dest->s + dest->length), (char const   */* __restrict  */)s->s);
#line 317
  dest->length += s->length;
  }
#line 318
  return (1);
}
}
#line 325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_append_cstr(dyn_string_t dest , char const   *s ) 
{ 
  int len ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 328
  tmp___0 = strlen(s);
#line 328
  len = (int )tmp___0;
#line 332
  tmp___1 = dyn_string_resize(dest, dest->length + len);
  }
#line 332
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 333
    return (0);
  }
  {
#line 334
  strcpy((char */* __restrict  */)(dest->s + dest->length), (char const   */* __restrict  */)s);
#line 335
  dest->length += len;
  }
#line 336
  return (1);
}
}
#line 342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_append_char(dyn_string_t dest , int c ) 
{ 
  dyn_string_t tmp___0 ;

  {
  {
#line 346
  tmp___0 = dyn_string_resize(dest, dest->length + 1);
  }
#line 346
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 347
    return (0);
  }
#line 349
  *(dest->s + dest->length) = (char )c;
#line 351
  *(dest->s + (dest->length + 1)) = (char )'\000';
#line 353
  (dest->length) ++;
#line 354
  return (1);
}
}
#line 363 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_substring(dyn_string_t dest , dyn_string_t src , int start , int end ) 
{ 
  int i ;
  int length ;
  dyn_string_t tmp___0 ;

  {
#line 368
  length = end - start;
#line 370
  if (start > end) {
    {
#line 371
    abort();
    }
  } else
#line 370
  if (start > src->length) {
    {
#line 371
    abort();
    }
  } else
#line 370
  if (end > src->length) {
    {
#line 371
    abort();
    }
  }
  {
#line 374
  tmp___0 = dyn_string_resize(dest, length);
  }
#line 374
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 375
    return (0);
  }
#line 377
  i = length;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    i --;
#line 377
    if (! (i >= 0)) {
#line 377
      goto while_break;
    }
#line 378
    *(dest->s + i) = *(src->s + (start + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  *(dest->s + length) = (char )'\000';
#line 382
  dest->length = length;
#line 384
  return (1);
}
}
#line 389 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./dyn-string.c"
int dyn_string_eq(dyn_string_t ds1 , dyn_string_t ds2 ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 393
  if (ds1->length != ds2->length) {
#line 394
    return (0);
  } else {
    {
#line 396
    tmp___0 = strcmp((char const   *)ds1->s, (char const   *)ds2->s);
    }
#line 396
    if (tmp___0) {
#line 396
      tmp___1 = 0;
    } else {
#line 396
      tmp___1 = 1;
    }
#line 396
    return (tmp___1);
  }
}
}
#line 400 "./../include/dwarf2.h"
char const   *get_DW_TAG_name(unsigned int tag ) ;
#line 404
char const   *get_DW_AT_name(unsigned int attr ) ;
#line 408
char const   *get_DW_FORM_name(unsigned int form ) ;
#line 412
char const   *get_DW_OP_name(unsigned int op ) ;
#line 416
char const   *get_DW_ATE_name(unsigned int enc ) ;
#line 420
char const   *get_DW_CFA_name(unsigned int opc ) ;
#line 73 "./../include/dwarf2.def"
char const   *get_DW_TAG_name(unsigned int tag ) 
{ 


  {
  {
#line 73
  if (tag == 0U) {
#line 73
    goto case_0;
  }
#line 74
  if (tag == 1U) {
#line 74
    goto case_1;
  }
#line 75
  if (tag == 2U) {
#line 75
    goto case_2;
  }
#line 76
  if (tag == 3U) {
#line 76
    goto case_3;
  }
#line 77
  if (tag == 4U) {
#line 77
    goto case_4;
  }
#line 78
  if (tag == 5U) {
#line 78
    goto case_5;
  }
#line 79
  if (tag == 8U) {
#line 79
    goto case_8;
  }
#line 80
  if (tag == 10U) {
#line 80
    goto case_10;
  }
#line 81
  if (tag == 11U) {
#line 81
    goto case_11;
  }
#line 82
  if (tag == 13U) {
#line 82
    goto case_13;
  }
#line 83
  if (tag == 15U) {
#line 83
    goto case_15;
  }
#line 84
  if (tag == 16U) {
#line 84
    goto case_16;
  }
#line 85
  if (tag == 17U) {
#line 85
    goto case_17;
  }
#line 86
  if (tag == 18U) {
#line 86
    goto case_18;
  }
#line 87
  if (tag == 19U) {
#line 87
    goto case_19;
  }
#line 88
  if (tag == 21U) {
#line 88
    goto case_21;
  }
#line 89
  if (tag == 22U) {
#line 89
    goto case_22;
  }
#line 90
  if (tag == 23U) {
#line 90
    goto case_23;
  }
#line 91
  if (tag == 24U) {
#line 91
    goto case_24;
  }
#line 92
  if (tag == 25U) {
#line 92
    goto case_25;
  }
#line 93
  if (tag == 26U) {
#line 93
    goto case_26;
  }
#line 94
  if (tag == 27U) {
#line 94
    goto case_27;
  }
#line 95
  if (tag == 28U) {
#line 95
    goto case_28;
  }
#line 96
  if (tag == 29U) {
#line 96
    goto case_29;
  }
#line 97
  if (tag == 30U) {
#line 97
    goto case_30;
  }
#line 98
  if (tag == 31U) {
#line 98
    goto case_31;
  }
#line 99
  if (tag == 32U) {
#line 99
    goto case_32;
  }
#line 100
  if (tag == 33U) {
#line 100
    goto case_33;
  }
#line 101
  if (tag == 34U) {
#line 101
    goto case_34;
  }
#line 102
  if (tag == 35U) {
#line 102
    goto case_35;
  }
#line 103
  if (tag == 36U) {
#line 103
    goto case_36;
  }
#line 104
  if (tag == 37U) {
#line 104
    goto case_37;
  }
#line 105
  if (tag == 38U) {
#line 105
    goto case_38;
  }
#line 106
  if (tag == 39U) {
#line 106
    goto case_39;
  }
#line 107
  if (tag == 40U) {
#line 107
    goto case_40;
  }
#line 108
  if (tag == 41U) {
#line 108
    goto case_41;
  }
#line 109
  if (tag == 42U) {
#line 109
    goto case_42;
  }
#line 110
  if (tag == 43U) {
#line 110
    goto case_43;
  }
#line 111
  if (tag == 44U) {
#line 111
    goto case_44;
  }
#line 112
  if (tag == 45U) {
#line 112
    goto case_45;
  }
#line 113
  if (tag == 46U) {
#line 113
    goto case_46;
  }
#line 114
  if (tag == 47U) {
#line 114
    goto case_47;
  }
#line 115
  if (tag == 48U) {
#line 115
    goto case_48;
  }
#line 116
  if (tag == 49U) {
#line 116
    goto case_49;
  }
#line 117
  if (tag == 50U) {
#line 117
    goto case_50;
  }
#line 118
  if (tag == 51U) {
#line 118
    goto case_51;
  }
#line 119
  if (tag == 52U) {
#line 119
    goto case_52;
  }
#line 120
  if (tag == 53U) {
#line 120
    goto case_53;
  }
#line 122
  if (tag == 54U) {
#line 122
    goto case_54;
  }
#line 123
  if (tag == 55U) {
#line 123
    goto case_55;
  }
#line 124
  if (tag == 56U) {
#line 124
    goto case_56;
  }
#line 125
  if (tag == 57U) {
#line 125
    goto case_57;
  }
#line 126
  if (tag == 58U) {
#line 126
    goto case_58;
  }
#line 127
  if (tag == 59U) {
#line 127
    goto case_59;
  }
#line 128
  if (tag == 60U) {
#line 128
    goto case_60;
  }
#line 129
  if (tag == 61U) {
#line 129
    goto case_61;
  }
#line 130
  if (tag == 63U) {
#line 130
    goto case_63;
  }
#line 131
  if (tag == 64U) {
#line 131
    goto case_64;
  }
#line 133
  if (tag == 65U) {
#line 133
    goto case_65;
  }
#line 134
  if (tag == 66U) {
#line 134
    goto case_66;
  }
#line 135
  if (tag == 67U) {
#line 135
    goto case_67;
  }
#line 141
  if (tag == 16513U) {
#line 141
    goto case_16513;
  }
#line 144
  if (tag == 16528U) {
#line 144
    goto case_16528;
  }
#line 145
  if (tag == 16529U) {
#line 145
    goto case_16529;
  }
#line 146
  if (tag == 16530U) {
#line 146
    goto case_16530;
  }
#line 149
  if (tag == 16641U) {
#line 149
    goto case_16641;
  }
#line 150
  if (tag == 16642U) {
#line 150
    goto case_16642;
  }
#line 151
  if (tag == 16643U) {
#line 151
    goto case_16643;
  }
#line 152
  if (tag == 16644U) {
#line 152
    goto case_16644;
  }
#line 153
  if (tag == 16645U) {
#line 153
    goto case_16645;
  }
#line 156
  if (tag == 16646U) {
#line 156
    goto case_16646;
  }
#line 162
  if (tag == 16647U) {
#line 162
    goto case_16647;
  }
#line 163
  if (tag == 16648U) {
#line 163
    goto case_16648;
  }
#line 168
  if (tag == 16649U) {
#line 168
    goto case_16649;
  }
#line 169
  if (tag == 16650U) {
#line 169
    goto case_16650;
  }
#line 171
  if (tag == 34661U) {
#line 171
    goto case_34661;
  }
#line 172
  if (tag == 34662U) {
#line 172
    goto case_34662;
  }
#line 173
  if (tag == 34663U) {
#line 173
    goto case_34663;
  }
#line 175
  if (tag == 40960U) {
#line 175
    goto case_40960;
  }
#line 176
  if (tag == 40992U) {
#line 176
    goto case_40992;
  }
#line 73
  goto switch_break;
  case_0: /* CIL Label */ 
#line 73
  return ("DW_TAG_padding");
  case_1: /* CIL Label */ 
#line 74
  return ("DW_TAG_array_type");
  case_2: /* CIL Label */ 
#line 75
  return ("DW_TAG_class_type");
  case_3: /* CIL Label */ 
#line 76
  return ("DW_TAG_entry_point");
  case_4: /* CIL Label */ 
#line 77
  return ("DW_TAG_enumeration_type");
  case_5: /* CIL Label */ 
#line 78
  return ("DW_TAG_formal_parameter");
  case_8: /* CIL Label */ 
#line 79
  return ("DW_TAG_imported_declaration");
  case_10: /* CIL Label */ 
#line 80
  return ("DW_TAG_label");
  case_11: /* CIL Label */ 
#line 81
  return ("DW_TAG_lexical_block");
  case_13: /* CIL Label */ 
#line 82
  return ("DW_TAG_member");
  case_15: /* CIL Label */ 
#line 83
  return ("DW_TAG_pointer_type");
  case_16: /* CIL Label */ 
#line 84
  return ("DW_TAG_reference_type");
  case_17: /* CIL Label */ 
#line 85
  return ("DW_TAG_compile_unit");
  case_18: /* CIL Label */ 
#line 86
  return ("DW_TAG_string_type");
  case_19: /* CIL Label */ 
#line 87
  return ("DW_TAG_structure_type");
  case_21: /* CIL Label */ 
#line 88
  return ("DW_TAG_subroutine_type");
  case_22: /* CIL Label */ 
#line 89
  return ("DW_TAG_typedef");
  case_23: /* CIL Label */ 
#line 90
  return ("DW_TAG_union_type");
  case_24: /* CIL Label */ 
#line 91
  return ("DW_TAG_unspecified_parameters");
  case_25: /* CIL Label */ 
#line 92
  return ("DW_TAG_variant");
  case_26: /* CIL Label */ 
#line 93
  return ("DW_TAG_common_block");
  case_27: /* CIL Label */ 
#line 94
  return ("DW_TAG_common_inclusion");
  case_28: /* CIL Label */ 
#line 95
  return ("DW_TAG_inheritance");
  case_29: /* CIL Label */ 
#line 96
  return ("DW_TAG_inlined_subroutine");
  case_30: /* CIL Label */ 
#line 97
  return ("DW_TAG_module");
  case_31: /* CIL Label */ 
#line 98
  return ("DW_TAG_ptr_to_member_type");
  case_32: /* CIL Label */ 
#line 99
  return ("DW_TAG_set_type");
  case_33: /* CIL Label */ 
#line 100
  return ("DW_TAG_subrange_type");
  case_34: /* CIL Label */ 
#line 101
  return ("DW_TAG_with_stmt");
  case_35: /* CIL Label */ 
#line 102
  return ("DW_TAG_access_declaration");
  case_36: /* CIL Label */ 
#line 103
  return ("DW_TAG_base_type");
  case_37: /* CIL Label */ 
#line 104
  return ("DW_TAG_catch_block");
  case_38: /* CIL Label */ 
#line 105
  return ("DW_TAG_const_type");
  case_39: /* CIL Label */ 
#line 106
  return ("DW_TAG_constant");
  case_40: /* CIL Label */ 
#line 107
  return ("DW_TAG_enumerator");
  case_41: /* CIL Label */ 
#line 108
  return ("DW_TAG_file_type");
  case_42: /* CIL Label */ 
#line 109
  return ("DW_TAG_friend");
  case_43: /* CIL Label */ 
#line 110
  return ("DW_TAG_namelist");
  case_44: /* CIL Label */ 
#line 111
  return ("DW_TAG_namelist_item");
  case_45: /* CIL Label */ 
#line 112
  return ("DW_TAG_packed_type");
  case_46: /* CIL Label */ 
#line 113
  return ("DW_TAG_subprogram");
  case_47: /* CIL Label */ 
#line 114
  return ("DW_TAG_template_type_param");
  case_48: /* CIL Label */ 
#line 115
  return ("DW_TAG_template_value_param");
  case_49: /* CIL Label */ 
#line 116
  return ("DW_TAG_thrown_type");
  case_50: /* CIL Label */ 
#line 117
  return ("DW_TAG_try_block");
  case_51: /* CIL Label */ 
#line 118
  return ("DW_TAG_variant_part");
  case_52: /* CIL Label */ 
#line 119
  return ("DW_TAG_variable");
  case_53: /* CIL Label */ 
#line 120
  return ("DW_TAG_volatile_type");
  case_54: /* CIL Label */ 
#line 122
  return ("DW_TAG_dwarf_procedure");
  case_55: /* CIL Label */ 
#line 123
  return ("DW_TAG_restrict_type");
  case_56: /* CIL Label */ 
#line 124
  return ("DW_TAG_interface_type");
  case_57: /* CIL Label */ 
#line 125
  return ("DW_TAG_namespace");
  case_58: /* CIL Label */ 
#line 126
  return ("DW_TAG_imported_module");
  case_59: /* CIL Label */ 
#line 127
  return ("DW_TAG_unspecified_type");
  case_60: /* CIL Label */ 
#line 128
  return ("DW_TAG_partial_unit");
  case_61: /* CIL Label */ 
#line 129
  return ("DW_TAG_imported_unit");
  case_63: /* CIL Label */ 
#line 130
  return ("DW_TAG_condition");
  case_64: /* CIL Label */ 
#line 131
  return ("DW_TAG_shared_type");
  case_65: /* CIL Label */ 
#line 133
  return ("DW_TAG_type_unit");
  case_66: /* CIL Label */ 
#line 134
  return ("DW_TAG_rvalue_reference_type");
  case_67: /* CIL Label */ 
#line 135
  return ("DW_TAG_template_alias");
  case_16513: /* CIL Label */ 
#line 141
  return ("DW_TAG_MIPS_loop");
  case_16528: /* CIL Label */ 
#line 144
  return ("DW_TAG_HP_array_descriptor");
  case_16529: /* CIL Label */ 
#line 145
  return ("DW_TAG_HP_Bliss_field");
  case_16530: /* CIL Label */ 
#line 146
  return ("DW_TAG_HP_Bliss_field_set");
  case_16641: /* CIL Label */ 
#line 149
  return ("DW_TAG_format_label");
  case_16642: /* CIL Label */ 
#line 150
  return ("DW_TAG_function_template");
  case_16643: /* CIL Label */ 
#line 151
  return ("DW_TAG_class_template");
  case_16644: /* CIL Label */ 
#line 152
  return ("DW_TAG_GNU_BINCL");
  case_16645: /* CIL Label */ 
#line 153
  return ("DW_TAG_GNU_EINCL");
  case_16646: /* CIL Label */ 
#line 156
  return ("DW_TAG_GNU_template_template_param");
  case_16647: /* CIL Label */ 
#line 162
  return ("DW_TAG_GNU_template_parameter_pack");
  case_16648: /* CIL Label */ 
#line 163
  return ("DW_TAG_GNU_formal_parameter_pack");
  case_16649: /* CIL Label */ 
#line 168
  return ("DW_TAG_GNU_call_site");
  case_16650: /* CIL Label */ 
#line 169
  return ("DW_TAG_GNU_call_site_parameter");
  case_34661: /* CIL Label */ 
#line 171
  return ("DW_TAG_upc_shared_type");
  case_34662: /* CIL Label */ 
#line 172
  return ("DW_TAG_upc_strict_type");
  case_34663: /* CIL Label */ 
#line 173
  return ("DW_TAG_upc_relaxed_type");
  case_40960: /* CIL Label */ 
#line 175
  return ("DW_TAG_PGI_kanji_type");
  case_40992: /* CIL Label */ 
#line 176
  return ("DW_TAG_PGI_interface_block");
  switch_break: /* CIL Label */ ;
  }
#line 177
  return ((char const   *)0);
}
}
#line 179 "./../include/dwarf2.def"
char const   *get_DW_FORM_name(unsigned int form ) 
{ 


  {
  {
#line 179
  if (form == 1U) {
#line 179
    goto case_1;
  }
#line 180
  if (form == 3U) {
#line 180
    goto case_3;
  }
#line 181
  if (form == 4U) {
#line 181
    goto case_4;
  }
#line 182
  if (form == 5U) {
#line 182
    goto case_5;
  }
#line 183
  if (form == 6U) {
#line 183
    goto case_6;
  }
#line 184
  if (form == 7U) {
#line 184
    goto case_7;
  }
#line 185
  if (form == 8U) {
#line 185
    goto case_8;
  }
#line 186
  if (form == 9U) {
#line 186
    goto case_9;
  }
#line 187
  if (form == 10U) {
#line 187
    goto case_10;
  }
#line 188
  if (form == 11U) {
#line 188
    goto case_11;
  }
#line 189
  if (form == 12U) {
#line 189
    goto case_12;
  }
#line 190
  if (form == 13U) {
#line 190
    goto case_13;
  }
#line 191
  if (form == 14U) {
#line 191
    goto case_14;
  }
#line 192
  if (form == 15U) {
#line 192
    goto case_15;
  }
#line 193
  if (form == 16U) {
#line 193
    goto case_16;
  }
#line 194
  if (form == 17U) {
#line 194
    goto case_17;
  }
#line 195
  if (form == 18U) {
#line 195
    goto case_18;
  }
#line 196
  if (form == 19U) {
#line 196
    goto case_19;
  }
#line 197
  if (form == 20U) {
#line 197
    goto case_20;
  }
#line 198
  if (form == 21U) {
#line 198
    goto case_21;
  }
#line 199
  if (form == 22U) {
#line 199
    goto case_22;
  }
#line 201
  if (form == 23U) {
#line 201
    goto case_23;
  }
#line 202
  if (form == 24U) {
#line 202
    goto case_24;
  }
#line 203
  if (form == 25U) {
#line 203
    goto case_25;
  }
#line 204
  if (form == 32U) {
#line 204
    goto case_32;
  }
#line 206
  if (form == 7937U) {
#line 206
    goto case_7937;
  }
#line 207
  if (form == 7938U) {
#line 207
    goto case_7938;
  }
#line 210
  if (form == 7968U) {
#line 210
    goto case_7968;
  }
#line 211
  if (form == 7969U) {
#line 211
    goto case_7969;
  }
#line 179
  goto switch_break;
  case_1: /* CIL Label */ 
#line 179
  return ("DW_FORM_addr");
  case_3: /* CIL Label */ 
#line 180
  return ("DW_FORM_block2");
  case_4: /* CIL Label */ 
#line 181
  return ("DW_FORM_block4");
  case_5: /* CIL Label */ 
#line 182
  return ("DW_FORM_data2");
  case_6: /* CIL Label */ 
#line 183
  return ("DW_FORM_data4");
  case_7: /* CIL Label */ 
#line 184
  return ("DW_FORM_data8");
  case_8: /* CIL Label */ 
#line 185
  return ("DW_FORM_string");
  case_9: /* CIL Label */ 
#line 186
  return ("DW_FORM_block");
  case_10: /* CIL Label */ 
#line 187
  return ("DW_FORM_block1");
  case_11: /* CIL Label */ 
#line 188
  return ("DW_FORM_data1");
  case_12: /* CIL Label */ 
#line 189
  return ("DW_FORM_flag");
  case_13: /* CIL Label */ 
#line 190
  return ("DW_FORM_sdata");
  case_14: /* CIL Label */ 
#line 191
  return ("DW_FORM_strp");
  case_15: /* CIL Label */ 
#line 192
  return ("DW_FORM_udata");
  case_16: /* CIL Label */ 
#line 193
  return ("DW_FORM_ref_addr");
  case_17: /* CIL Label */ 
#line 194
  return ("DW_FORM_ref1");
  case_18: /* CIL Label */ 
#line 195
  return ("DW_FORM_ref2");
  case_19: /* CIL Label */ 
#line 196
  return ("DW_FORM_ref4");
  case_20: /* CIL Label */ 
#line 197
  return ("DW_FORM_ref8");
  case_21: /* CIL Label */ 
#line 198
  return ("DW_FORM_ref_udata");
  case_22: /* CIL Label */ 
#line 199
  return ("DW_FORM_indirect");
  case_23: /* CIL Label */ 
#line 201
  return ("DW_FORM_sec_offset");
  case_24: /* CIL Label */ 
#line 202
  return ("DW_FORM_exprloc");
  case_25: /* CIL Label */ 
#line 203
  return ("DW_FORM_flag_present");
  case_32: /* CIL Label */ 
#line 204
  return ("DW_FORM_ref_sig8");
  case_7937: /* CIL Label */ 
#line 206
  return ("DW_FORM_GNU_addr_index");
  case_7938: /* CIL Label */ 
#line 207
  return ("DW_FORM_GNU_str_index");
  case_7968: /* CIL Label */ 
#line 210
  return ("DW_FORM_GNU_ref_alt");
  case_7969: /* CIL Label */ 
#line 211
  return ("DW_FORM_GNU_strp_alt");
  switch_break: /* CIL Label */ ;
  }
#line 212
  return ((char const   *)0);
}
}
#line 214 "./../include/dwarf2.def"
char const   *get_DW_AT_name(unsigned int attr ) 
{ 


  {
  {
#line 214
  if (attr == 1U) {
#line 214
    goto case_1;
  }
#line 215
  if (attr == 2U) {
#line 215
    goto case_2;
  }
#line 216
  if (attr == 3U) {
#line 216
    goto case_3;
  }
#line 217
  if (attr == 9U) {
#line 217
    goto case_9;
  }
#line 218
  if (attr == 10U) {
#line 218
    goto case_10;
  }
#line 219
  if (attr == 11U) {
#line 219
    goto case_11;
  }
#line 220
  if (attr == 12U) {
#line 220
    goto case_12;
  }
#line 221
  if (attr == 13U) {
#line 221
    goto case_13;
  }
#line 222
  if (attr == 15U) {
#line 222
    goto case_15;
  }
#line 223
  if (attr == 16U) {
#line 223
    goto case_16;
  }
#line 224
  if (attr == 17U) {
#line 224
    goto case_17;
  }
#line 225
  if (attr == 18U) {
#line 225
    goto case_18;
  }
#line 226
  if (attr == 19U) {
#line 226
    goto case_19;
  }
#line 227
  if (attr == 20U) {
#line 227
    goto case_20;
  }
#line 228
  if (attr == 21U) {
#line 228
    goto case_21;
  }
#line 229
  if (attr == 22U) {
#line 229
    goto case_22;
  }
#line 230
  if (attr == 23U) {
#line 230
    goto case_23;
  }
#line 231
  if (attr == 24U) {
#line 231
    goto case_24;
  }
#line 232
  if (attr == 25U) {
#line 232
    goto case_25;
  }
#line 233
  if (attr == 26U) {
#line 233
    goto case_26;
  }
#line 234
  if (attr == 27U) {
#line 234
    goto case_27;
  }
#line 235
  if (attr == 28U) {
#line 235
    goto case_28;
  }
#line 236
  if (attr == 29U) {
#line 236
    goto case_29;
  }
#line 237
  if (attr == 30U) {
#line 237
    goto case_30;
  }
#line 238
  if (attr == 32U) {
#line 238
    goto case_32;
  }
#line 239
  if (attr == 33U) {
#line 239
    goto case_33;
  }
#line 240
  if (attr == 34U) {
#line 240
    goto case_34;
  }
#line 241
  if (attr == 37U) {
#line 241
    goto case_37;
  }
#line 242
  if (attr == 39U) {
#line 242
    goto case_39;
  }
#line 243
  if (attr == 42U) {
#line 243
    goto case_42;
  }
#line 244
  if (attr == 44U) {
#line 244
    goto case_44;
  }
#line 245
  if (attr == 46U) {
#line 245
    goto case_46;
  }
#line 246
  if (attr == 47U) {
#line 246
    goto case_47;
  }
#line 247
  if (attr == 49U) {
#line 247
    goto case_49;
  }
#line 248
  if (attr == 50U) {
#line 248
    goto case_50;
  }
#line 249
  if (attr == 51U) {
#line 249
    goto case_51;
  }
#line 250
  if (attr == 52U) {
#line 250
    goto case_52;
  }
#line 251
  if (attr == 53U) {
#line 251
    goto case_53;
  }
#line 252
  if (attr == 54U) {
#line 252
    goto case_54;
  }
#line 253
  if (attr == 55U) {
#line 253
    goto case_55;
  }
#line 254
  if (attr == 56U) {
#line 254
    goto case_56;
  }
#line 255
  if (attr == 57U) {
#line 255
    goto case_57;
  }
#line 256
  if (attr == 58U) {
#line 256
    goto case_58;
  }
#line 257
  if (attr == 59U) {
#line 257
    goto case_59;
  }
#line 258
  if (attr == 60U) {
#line 258
    goto case_60;
  }
#line 259
  if (attr == 61U) {
#line 259
    goto case_61;
  }
#line 260
  if (attr == 62U) {
#line 260
    goto case_62;
  }
#line 261
  if (attr == 63U) {
#line 261
    goto case_63;
  }
#line 262
  if (attr == 64U) {
#line 262
    goto case_64;
  }
#line 263
  if (attr == 65U) {
#line 263
    goto case_65;
  }
#line 264
  if (attr == 66U) {
#line 264
    goto case_66;
  }
#line 265
  if (attr == 67U) {
#line 265
    goto case_67;
  }
#line 266
  if (attr == 68U) {
#line 266
    goto case_68;
  }
#line 267
  if (attr == 69U) {
#line 267
    goto case_69;
  }
#line 268
  if (attr == 70U) {
#line 268
    goto case_70;
  }
#line 269
  if (attr == 71U) {
#line 269
    goto case_71;
  }
#line 270
  if (attr == 72U) {
#line 270
    goto case_72;
  }
#line 271
  if (attr == 73U) {
#line 271
    goto case_73;
  }
#line 272
  if (attr == 74U) {
#line 272
    goto case_74;
  }
#line 273
  if (attr == 75U) {
#line 273
    goto case_75;
  }
#line 274
  if (attr == 76U) {
#line 274
    goto case_76;
  }
#line 275
  if (attr == 77U) {
#line 275
    goto case_77;
  }
#line 277
  if (attr == 78U) {
#line 277
    goto case_78;
  }
#line 278
  if (attr == 79U) {
#line 278
    goto case_79;
  }
#line 279
  if (attr == 80U) {
#line 279
    goto case_80;
  }
#line 280
  if (attr == 81U) {
#line 280
    goto case_81;
  }
#line 281
  if (attr == 82U) {
#line 281
    goto case_82;
  }
#line 282
  if (attr == 83U) {
#line 282
    goto case_83;
  }
#line 283
  if (attr == 84U) {
#line 283
    goto case_84;
  }
#line 284
  if (attr == 85U) {
#line 284
    goto case_85;
  }
#line 285
  if (attr == 86U) {
#line 285
    goto case_86;
  }
#line 286
  if (attr == 87U) {
#line 286
    goto case_87;
  }
#line 287
  if (attr == 88U) {
#line 287
    goto case_88;
  }
#line 288
  if (attr == 89U) {
#line 288
    goto case_89;
  }
#line 289
  if (attr == 90U) {
#line 289
    goto case_90;
  }
#line 290
  if (attr == 91U) {
#line 290
    goto case_91;
  }
#line 291
  if (attr == 92U) {
#line 291
    goto case_92;
  }
#line 292
  if (attr == 93U) {
#line 292
    goto case_93;
  }
#line 293
  if (attr == 94U) {
#line 293
    goto case_94;
  }
#line 294
  if (attr == 95U) {
#line 294
    goto case_95;
  }
#line 295
  if (attr == 96U) {
#line 295
    goto case_96;
  }
#line 296
  if (attr == 97U) {
#line 296
    goto case_97;
  }
#line 297
  if (attr == 98U) {
#line 297
    goto case_98;
  }
#line 298
  if (attr == 99U) {
#line 298
    goto case_99;
  }
#line 299
  if (attr == 100U) {
#line 299
    goto case_100;
  }
#line 300
  if (attr == 101U) {
#line 300
    goto case_101;
  }
#line 301
  if (attr == 102U) {
#line 301
    goto case_102;
  }
#line 302
  if (attr == 103U) {
#line 302
    goto case_103;
  }
#line 303
  if (attr == 104U) {
#line 303
    goto case_104;
  }
#line 305
  if (attr == 105U) {
#line 305
    goto case_105;
  }
#line 306
  if (attr == 106U) {
#line 306
    goto case_106;
  }
#line 307
  if (attr == 107U) {
#line 307
    goto case_107;
  }
#line 308
  if (attr == 108U) {
#line 308
    goto case_108;
  }
#line 309
  if (attr == 109U) {
#line 309
    goto case_109;
  }
#line 310
  if (attr == 110U) {
#line 310
    goto case_110;
  }
#line 316
  if (attr == 8193U) {
#line 316
    goto case_8193;
  }
#line 317
  if (attr == 8194U) {
#line 317
    goto case_8194;
  }
#line 318
  if (attr == 8195U) {
#line 318
    goto case_8195;
  }
#line 319
  if (attr == 8196U) {
#line 319
    goto case_8196;
  }
#line 320
  if (attr == 8197U) {
#line 320
    goto case_8197;
  }
#line 321
  if (attr == 8198U) {
#line 321
    goto case_8198;
  }
#line 322
  if (attr == 8199U) {
#line 322
    goto case_8199;
  }
#line 323
  if (attr == 8200U) {
#line 323
    goto case_8200;
  }
#line 324
  if (attr == 8201U) {
#line 324
    goto case_8201;
  }
#line 325
  if (attr == 8202U) {
#line 325
    goto case_8202;
  }
#line 326
  if (attr == 8203U) {
#line 326
    goto case_8203;
  }
#line 328
  if (attr == 8192U) {
#line 328
    goto case_8192;
  }
#line 332
  if (attr == 8208U) {
#line 332
    goto case_8208;
  }
#line 333
  if (attr == 8209U) {
#line 333
    goto case_8209;
  }
#line 334
  if (attr == 8210U) {
#line 334
    goto case_8210;
  }
#line 335
  if (attr == 8211U) {
#line 335
    goto case_8211;
  }
#line 336
  if (attr == 8212U) {
#line 336
    goto case_8212;
  }
#line 337
  if (attr == 8213U) {
#line 337
    goto case_8213;
  }
#line 338
  if (attr == 8214U) {
#line 338
    goto case_8214;
  }
#line 339
  if (attr == 8215U) {
#line 339
    goto case_8215;
  }
#line 340
  if (attr == 8216U) {
#line 340
    goto case_8216;
  }
#line 341
  if (attr == 8217U) {
#line 341
    goto case_8217;
  }
#line 342
  if (attr == 8218U) {
#line 342
    goto case_8218;
  }
#line 343
  if (attr == 8219U) {
#line 343
    goto case_8219;
  }
#line 344
  if (attr == 8223U) {
#line 344
    goto case_8223;
  }
#line 345
  if (attr == 8224U) {
#line 345
    goto case_8224;
  }
#line 346
  if (attr == 8225U) {
#line 346
    goto case_8225;
  }
#line 347
  if (attr == 8226U) {
#line 347
    goto case_8226;
  }
#line 348
  if (attr == 8227U) {
#line 348
    goto case_8227;
  }
#line 349
  if (attr == 8233U) {
#line 349
    goto case_8233;
  }
#line 352
  if (attr == 8449U) {
#line 352
    goto case_8449;
  }
#line 353
  if (attr == 8450U) {
#line 353
    goto case_8450;
  }
#line 354
  if (attr == 8451U) {
#line 354
    goto case_8451;
  }
#line 355
  if (attr == 8452U) {
#line 355
    goto case_8452;
  }
#line 356
  if (attr == 8453U) {
#line 356
    goto case_8453;
  }
#line 357
  if (attr == 8454U) {
#line 357
    goto case_8454;
  }
#line 358
  if (attr == 8455U) {
#line 358
    goto case_8455;
  }
#line 361
  if (attr == 8456U) {
#line 361
    goto case_8456;
  }
#line 362
  if (attr == 8457U) {
#line 362
    goto case_8457;
  }
#line 363
  if (attr == 8458U) {
#line 363
    goto case_8458;
  }
#line 364
  if (attr == 8459U) {
#line 364
    goto case_8459;
  }
#line 365
  if (attr == 8460U) {
#line 365
    goto case_8460;
  }
#line 366
  if (attr == 8461U) {
#line 366
    goto case_8461;
  }
#line 367
  if (attr == 8462U) {
#line 367
    goto case_8462;
  }
#line 370
  if (attr == 8463U) {
#line 370
    goto case_8463;
  }
#line 373
  if (attr == 8464U) {
#line 373
    goto case_8464;
  }
#line 376
  if (attr == 8465U) {
#line 376
    goto case_8465;
  }
#line 377
  if (attr == 8466U) {
#line 377
    goto case_8466;
  }
#line 378
  if (attr == 8467U) {
#line 378
    goto case_8467;
  }
#line 379
  if (attr == 8468U) {
#line 379
    goto case_8468;
  }
#line 380
  if (attr == 8469U) {
#line 380
    goto case_8469;
  }
#line 381
  if (attr == 8470U) {
#line 381
    goto case_8470;
  }
#line 382
  if (attr == 8471U) {
#line 382
    goto case_8471;
  }
#line 383
  if (attr == 8472U) {
#line 383
    goto case_8472;
  }
#line 385
  if (attr == 8473U) {
#line 385
    goto case_8473;
  }
#line 387
  if (attr == 8496U) {
#line 387
    goto case_8496;
  }
#line 388
  if (attr == 8497U) {
#line 388
    goto case_8497;
  }
#line 389
  if (attr == 8498U) {
#line 389
    goto case_8498;
  }
#line 390
  if (attr == 8499U) {
#line 390
    goto case_8499;
  }
#line 391
  if (attr == 8500U) {
#line 391
    goto case_8500;
  }
#line 392
  if (attr == 8501U) {
#line 392
    goto case_8501;
  }
#line 395
  if (attr == 8502U) {
#line 395
    goto case_8502;
  }
#line 397
  if (attr == 8705U) {
#line 397
    goto case_8705;
  }
#line 401
  if (attr == 8961U) {
#line 401
    goto case_8961;
  }
#line 402
  if (attr == 8962U) {
#line 402
    goto case_8962;
  }
#line 404
  if (attr == 12816U) {
#line 404
    goto case_12816;
  }
#line 406
  if (attr == 14848U) {
#line 406
    goto case_14848;
  }
#line 407
  if (attr == 14849U) {
#line 407
    goto case_14849;
  }
#line 408
  if (attr == 14850U) {
#line 408
    goto case_14850;
  }
#line 214
  goto switch_break;
  case_1: /* CIL Label */ 
#line 214
  return ("DW_AT_sibling");
  case_2: /* CIL Label */ 
#line 215
  return ("DW_AT_location");
  case_3: /* CIL Label */ 
#line 216
  return ("DW_AT_name");
  case_9: /* CIL Label */ 
#line 217
  return ("DW_AT_ordering");
  case_10: /* CIL Label */ 
#line 218
  return ("DW_AT_subscr_data");
  case_11: /* CIL Label */ 
#line 219
  return ("DW_AT_byte_size");
  case_12: /* CIL Label */ 
#line 220
  return ("DW_AT_bit_offset");
  case_13: /* CIL Label */ 
#line 221
  return ("DW_AT_bit_size");
  case_15: /* CIL Label */ 
#line 222
  return ("DW_AT_element_list");
  case_16: /* CIL Label */ 
#line 223
  return ("DW_AT_stmt_list");
  case_17: /* CIL Label */ 
#line 224
  return ("DW_AT_low_pc");
  case_18: /* CIL Label */ 
#line 225
  return ("DW_AT_high_pc");
  case_19: /* CIL Label */ 
#line 226
  return ("DW_AT_language");
  case_20: /* CIL Label */ 
#line 227
  return ("DW_AT_member");
  case_21: /* CIL Label */ 
#line 228
  return ("DW_AT_discr");
  case_22: /* CIL Label */ 
#line 229
  return ("DW_AT_discr_value");
  case_23: /* CIL Label */ 
#line 230
  return ("DW_AT_visibility");
  case_24: /* CIL Label */ 
#line 231
  return ("DW_AT_import");
  case_25: /* CIL Label */ 
#line 232
  return ("DW_AT_string_length");
  case_26: /* CIL Label */ 
#line 233
  return ("DW_AT_common_reference");
  case_27: /* CIL Label */ 
#line 234
  return ("DW_AT_comp_dir");
  case_28: /* CIL Label */ 
#line 235
  return ("DW_AT_const_value");
  case_29: /* CIL Label */ 
#line 236
  return ("DW_AT_containing_type");
  case_30: /* CIL Label */ 
#line 237
  return ("DW_AT_default_value");
  case_32: /* CIL Label */ 
#line 238
  return ("DW_AT_inline");
  case_33: /* CIL Label */ 
#line 239
  return ("DW_AT_is_optional");
  case_34: /* CIL Label */ 
#line 240
  return ("DW_AT_lower_bound");
  case_37: /* CIL Label */ 
#line 241
  return ("DW_AT_producer");
  case_39: /* CIL Label */ 
#line 242
  return ("DW_AT_prototyped");
  case_42: /* CIL Label */ 
#line 243
  return ("DW_AT_return_addr");
  case_44: /* CIL Label */ 
#line 244
  return ("DW_AT_start_scope");
  case_46: /* CIL Label */ 
#line 245
  return ("DW_AT_bit_stride");
  case_47: /* CIL Label */ 
#line 246
  return ("DW_AT_upper_bound");
  case_49: /* CIL Label */ 
#line 247
  return ("DW_AT_abstract_origin");
  case_50: /* CIL Label */ 
#line 248
  return ("DW_AT_accessibility");
  case_51: /* CIL Label */ 
#line 249
  return ("DW_AT_address_class");
  case_52: /* CIL Label */ 
#line 250
  return ("DW_AT_artificial");
  case_53: /* CIL Label */ 
#line 251
  return ("DW_AT_base_types");
  case_54: /* CIL Label */ 
#line 252
  return ("DW_AT_calling_convention");
  case_55: /* CIL Label */ 
#line 253
  return ("DW_AT_count");
  case_56: /* CIL Label */ 
#line 254
  return ("DW_AT_data_member_location");
  case_57: /* CIL Label */ 
#line 255
  return ("DW_AT_decl_column");
  case_58: /* CIL Label */ 
#line 256
  return ("DW_AT_decl_file");
  case_59: /* CIL Label */ 
#line 257
  return ("DW_AT_decl_line");
  case_60: /* CIL Label */ 
#line 258
  return ("DW_AT_declaration");
  case_61: /* CIL Label */ 
#line 259
  return ("DW_AT_discr_list");
  case_62: /* CIL Label */ 
#line 260
  return ("DW_AT_encoding");
  case_63: /* CIL Label */ 
#line 261
  return ("DW_AT_external");
  case_64: /* CIL Label */ 
#line 262
  return ("DW_AT_frame_base");
  case_65: /* CIL Label */ 
#line 263
  return ("DW_AT_friend");
  case_66: /* CIL Label */ 
#line 264
  return ("DW_AT_identifier_case");
  case_67: /* CIL Label */ 
#line 265
  return ("DW_AT_macro_info");
  case_68: /* CIL Label */ 
#line 266
  return ("DW_AT_namelist_items");
  case_69: /* CIL Label */ 
#line 267
  return ("DW_AT_priority");
  case_70: /* CIL Label */ 
#line 268
  return ("DW_AT_segment");
  case_71: /* CIL Label */ 
#line 269
  return ("DW_AT_specification");
  case_72: /* CIL Label */ 
#line 270
  return ("DW_AT_static_link");
  case_73: /* CIL Label */ 
#line 271
  return ("DW_AT_type");
  case_74: /* CIL Label */ 
#line 272
  return ("DW_AT_use_location");
  case_75: /* CIL Label */ 
#line 273
  return ("DW_AT_variable_parameter");
  case_76: /* CIL Label */ 
#line 274
  return ("DW_AT_virtuality");
  case_77: /* CIL Label */ 
#line 275
  return ("DW_AT_vtable_elem_location");
  case_78: /* CIL Label */ 
#line 277
  return ("DW_AT_allocated");
  case_79: /* CIL Label */ 
#line 278
  return ("DW_AT_associated");
  case_80: /* CIL Label */ 
#line 279
  return ("DW_AT_data_location");
  case_81: /* CIL Label */ 
#line 280
  return ("DW_AT_byte_stride");
  case_82: /* CIL Label */ 
#line 281
  return ("DW_AT_entry_pc");
  case_83: /* CIL Label */ 
#line 282
  return ("DW_AT_use_UTF8");
  case_84: /* CIL Label */ 
#line 283
  return ("DW_AT_extension");
  case_85: /* CIL Label */ 
#line 284
  return ("DW_AT_ranges");
  case_86: /* CIL Label */ 
#line 285
  return ("DW_AT_trampoline");
  case_87: /* CIL Label */ 
#line 286
  return ("DW_AT_call_column");
  case_88: /* CIL Label */ 
#line 287
  return ("DW_AT_call_file");
  case_89: /* CIL Label */ 
#line 288
  return ("DW_AT_call_line");
  case_90: /* CIL Label */ 
#line 289
  return ("DW_AT_description");
  case_91: /* CIL Label */ 
#line 290
  return ("DW_AT_binary_scale");
  case_92: /* CIL Label */ 
#line 291
  return ("DW_AT_decimal_scale");
  case_93: /* CIL Label */ 
#line 292
  return ("DW_AT_small");
  case_94: /* CIL Label */ 
#line 293
  return ("DW_AT_decimal_sign");
  case_95: /* CIL Label */ 
#line 294
  return ("DW_AT_digit_count");
  case_96: /* CIL Label */ 
#line 295
  return ("DW_AT_picture_string");
  case_97: /* CIL Label */ 
#line 296
  return ("DW_AT_mutable");
  case_98: /* CIL Label */ 
#line 297
  return ("DW_AT_threads_scaled");
  case_99: /* CIL Label */ 
#line 298
  return ("DW_AT_explicit");
  case_100: /* CIL Label */ 
#line 299
  return ("DW_AT_object_pointer");
  case_101: /* CIL Label */ 
#line 300
  return ("DW_AT_endianity");
  case_102: /* CIL Label */ 
#line 301
  return ("DW_AT_elemental");
  case_103: /* CIL Label */ 
#line 302
  return ("DW_AT_pure");
  case_104: /* CIL Label */ 
#line 303
  return ("DW_AT_recursive");
  case_105: /* CIL Label */ 
#line 305
  return ("DW_AT_signature");
  case_106: /* CIL Label */ 
#line 306
  return ("DW_AT_main_subprogram");
  case_107: /* CIL Label */ 
#line 307
  return ("DW_AT_data_bit_offset");
  case_108: /* CIL Label */ 
#line 308
  return ("DW_AT_const_expr");
  case_109: /* CIL Label */ 
#line 309
  return ("DW_AT_enum_class");
  case_110: /* CIL Label */ 
#line 310
  return ("DW_AT_linkage_name");
  case_8193: /* CIL Label */ 
#line 316
  return ("DW_AT_MIPS_fde");
  case_8194: /* CIL Label */ 
#line 317
  return ("DW_AT_MIPS_loop_begin");
  case_8195: /* CIL Label */ 
#line 318
  return ("DW_AT_MIPS_tail_loop_begin");
  case_8196: /* CIL Label */ 
#line 319
  return ("DW_AT_MIPS_epilog_begin");
  case_8197: /* CIL Label */ 
#line 320
  return ("DW_AT_MIPS_loop_unroll_factor");
  case_8198: /* CIL Label */ 
#line 321
  return ("DW_AT_MIPS_software_pipeline_depth");
  case_8199: /* CIL Label */ 
#line 322
  return ("DW_AT_MIPS_linkage_name");
  case_8200: /* CIL Label */ 
#line 323
  return ("DW_AT_MIPS_stride");
  case_8201: /* CIL Label */ 
#line 324
  return ("DW_AT_MIPS_abstract_name");
  case_8202: /* CIL Label */ 
#line 325
  return ("DW_AT_MIPS_clone_origin");
  case_8203: /* CIL Label */ 
#line 326
  return ("DW_AT_MIPS_has_inlines");
  case_8192: /* CIL Label */ 
#line 328
  return ("DW_AT_HP_block_index");
  case_8208: /* CIL Label */ 
#line 332
  return ("DW_AT_HP_actuals_stmt_list");
  case_8209: /* CIL Label */ 
#line 333
  return ("DW_AT_HP_proc_per_section");
  case_8210: /* CIL Label */ 
#line 334
  return ("DW_AT_HP_raw_data_ptr");
  case_8211: /* CIL Label */ 
#line 335
  return ("DW_AT_HP_pass_by_reference");
  case_8212: /* CIL Label */ 
#line 336
  return ("DW_AT_HP_opt_level");
  case_8213: /* CIL Label */ 
#line 337
  return ("DW_AT_HP_prof_version_id");
  case_8214: /* CIL Label */ 
#line 338
  return ("DW_AT_HP_opt_flags");
  case_8215: /* CIL Label */ 
#line 339
  return ("DW_AT_HP_cold_region_low_pc");
  case_8216: /* CIL Label */ 
#line 340
  return ("DW_AT_HP_cold_region_high_pc");
  case_8217: /* CIL Label */ 
#line 341
  return ("DW_AT_HP_all_variables_modifiable");
  case_8218: /* CIL Label */ 
#line 342
  return ("DW_AT_HP_linkage_name");
  case_8219: /* CIL Label */ 
#line 343
  return ("DW_AT_HP_prof_flags");
  case_8223: /* CIL Label */ 
#line 344
  return ("DW_AT_HP_unit_name");
  case_8224: /* CIL Label */ 
#line 345
  return ("DW_AT_HP_unit_size");
  case_8225: /* CIL Label */ 
#line 346
  return ("DW_AT_HP_widened_byte_size");
  case_8226: /* CIL Label */ 
#line 347
  return ("DW_AT_HP_definition_points");
  case_8227: /* CIL Label */ 
#line 348
  return ("DW_AT_HP_default_location");
  case_8233: /* CIL Label */ 
#line 349
  return ("DW_AT_HP_is_result_param");
  case_8449: /* CIL Label */ 
#line 352
  return ("DW_AT_sf_names");
  case_8450: /* CIL Label */ 
#line 353
  return ("DW_AT_src_info");
  case_8451: /* CIL Label */ 
#line 354
  return ("DW_AT_mac_info");
  case_8452: /* CIL Label */ 
#line 355
  return ("DW_AT_src_coords");
  case_8453: /* CIL Label */ 
#line 356
  return ("DW_AT_body_begin");
  case_8454: /* CIL Label */ 
#line 357
  return ("DW_AT_body_end");
  case_8455: /* CIL Label */ 
#line 358
  return ("DW_AT_GNU_vector");
  case_8456: /* CIL Label */ 
#line 361
  return ("DW_AT_GNU_guarded_by");
  case_8457: /* CIL Label */ 
#line 362
  return ("DW_AT_GNU_pt_guarded_by");
  case_8458: /* CIL Label */ 
#line 363
  return ("DW_AT_GNU_guarded");
  case_8459: /* CIL Label */ 
#line 364
  return ("DW_AT_GNU_pt_guarded");
  case_8460: /* CIL Label */ 
#line 365
  return ("DW_AT_GNU_locks_excluded");
  case_8461: /* CIL Label */ 
#line 366
  return ("DW_AT_GNU_exclusive_locks_required");
  case_8462: /* CIL Label */ 
#line 367
  return ("DW_AT_GNU_shared_locks_required");
  case_8463: /* CIL Label */ 
#line 370
  return ("DW_AT_GNU_odr_signature");
  case_8464: /* CIL Label */ 
#line 373
  return ("DW_AT_GNU_template_name");
  case_8465: /* CIL Label */ 
#line 376
  return ("DW_AT_GNU_call_site_value");
  case_8466: /* CIL Label */ 
#line 377
  return ("DW_AT_GNU_call_site_data_value");
  case_8467: /* CIL Label */ 
#line 378
  return ("DW_AT_GNU_call_site_target");
  case_8468: /* CIL Label */ 
#line 379
  return ("DW_AT_GNU_call_site_target_clobbered");
  case_8469: /* CIL Label */ 
#line 380
  return ("DW_AT_GNU_tail_call");
  case_8470: /* CIL Label */ 
#line 381
  return ("DW_AT_GNU_all_tail_call_sites");
  case_8471: /* CIL Label */ 
#line 382
  return ("DW_AT_GNU_all_call_sites");
  case_8472: /* CIL Label */ 
#line 383
  return ("DW_AT_GNU_all_source_call_sites");
  case_8473: /* CIL Label */ 
#line 385
  return ("DW_AT_GNU_macros");
  case_8496: /* CIL Label */ 
#line 387
  return ("DW_AT_GNU_dwo_name");
  case_8497: /* CIL Label */ 
#line 388
  return ("DW_AT_GNU_dwo_id");
  case_8498: /* CIL Label */ 
#line 389
  return ("DW_AT_GNU_ranges_base");
  case_8499: /* CIL Label */ 
#line 390
  return ("DW_AT_GNU_addr_base");
  case_8500: /* CIL Label */ 
#line 391
  return ("DW_AT_GNU_pubnames");
  case_8501: /* CIL Label */ 
#line 392
  return ("DW_AT_GNU_pubtypes");
  case_8502: /* CIL Label */ 
#line 395
  return ("DW_AT_GNU_discriminator");
  case_8705: /* CIL Label */ 
#line 397
  return ("DW_AT_VMS_rtnbeg_pd_address");
  case_8961: /* CIL Label */ 
#line 401
  return ("DW_AT_use_GNAT_descriptive_type");
  case_8962: /* CIL Label */ 
#line 402
  return ("DW_AT_GNAT_descriptive_type");
  case_12816: /* CIL Label */ 
#line 404
  return ("DW_AT_upc_threads_scaled");
  case_14848: /* CIL Label */ 
#line 406
  return ("DW_AT_PGI_lbase");
  case_14849: /* CIL Label */ 
#line 407
  return ("DW_AT_PGI_soffset");
  case_14850: /* CIL Label */ 
#line 408
  return ("DW_AT_PGI_lstride");
  switch_break: /* CIL Label */ ;
  }
#line 409
  return ((char const   *)0);
}
}
#line 411 "./../include/dwarf2.def"
char const   *get_DW_OP_name(unsigned int op ) 
{ 


  {
  {
#line 411
  if (op == 3U) {
#line 411
    goto case_3;
  }
#line 412
  if (op == 6U) {
#line 412
    goto case_6;
  }
#line 413
  if (op == 8U) {
#line 413
    goto case_8;
  }
#line 414
  if (op == 9U) {
#line 414
    goto case_9;
  }
#line 415
  if (op == 10U) {
#line 415
    goto case_10;
  }
#line 416
  if (op == 11U) {
#line 416
    goto case_11;
  }
#line 417
  if (op == 12U) {
#line 417
    goto case_12;
  }
#line 418
  if (op == 13U) {
#line 418
    goto case_13;
  }
#line 419
  if (op == 14U) {
#line 419
    goto case_14;
  }
#line 420
  if (op == 15U) {
#line 420
    goto case_15;
  }
#line 421
  if (op == 16U) {
#line 421
    goto case_16;
  }
#line 422
  if (op == 17U) {
#line 422
    goto case_17;
  }
#line 423
  if (op == 18U) {
#line 423
    goto case_18;
  }
#line 424
  if (op == 19U) {
#line 424
    goto case_19;
  }
#line 425
  if (op == 20U) {
#line 425
    goto case_20;
  }
#line 426
  if (op == 21U) {
#line 426
    goto case_21;
  }
#line 427
  if (op == 22U) {
#line 427
    goto case_22;
  }
#line 428
  if (op == 23U) {
#line 428
    goto case_23;
  }
#line 429
  if (op == 24U) {
#line 429
    goto case_24;
  }
#line 430
  if (op == 25U) {
#line 430
    goto case_25;
  }
#line 431
  if (op == 26U) {
#line 431
    goto case_26;
  }
#line 432
  if (op == 27U) {
#line 432
    goto case_27;
  }
#line 433
  if (op == 28U) {
#line 433
    goto case_28;
  }
#line 434
  if (op == 29U) {
#line 434
    goto case_29;
  }
#line 435
  if (op == 30U) {
#line 435
    goto case_30;
  }
#line 436
  if (op == 31U) {
#line 436
    goto case_31;
  }
#line 437
  if (op == 32U) {
#line 437
    goto case_32;
  }
#line 438
  if (op == 33U) {
#line 438
    goto case_33;
  }
#line 439
  if (op == 34U) {
#line 439
    goto case_34;
  }
#line 440
  if (op == 35U) {
#line 440
    goto case_35;
  }
#line 441
  if (op == 36U) {
#line 441
    goto case_36;
  }
#line 442
  if (op == 37U) {
#line 442
    goto case_37;
  }
#line 443
  if (op == 38U) {
#line 443
    goto case_38;
  }
#line 444
  if (op == 39U) {
#line 444
    goto case_39;
  }
#line 445
  if (op == 40U) {
#line 445
    goto case_40;
  }
#line 446
  if (op == 41U) {
#line 446
    goto case_41;
  }
#line 447
  if (op == 42U) {
#line 447
    goto case_42;
  }
#line 448
  if (op == 43U) {
#line 448
    goto case_43;
  }
#line 449
  if (op == 44U) {
#line 449
    goto case_44;
  }
#line 450
  if (op == 45U) {
#line 450
    goto case_45;
  }
#line 451
  if (op == 46U) {
#line 451
    goto case_46;
  }
#line 452
  if (op == 47U) {
#line 452
    goto case_47;
  }
#line 453
  if (op == 48U) {
#line 453
    goto case_48;
  }
#line 454
  if (op == 49U) {
#line 454
    goto case_49;
  }
#line 455
  if (op == 50U) {
#line 455
    goto case_50;
  }
#line 456
  if (op == 51U) {
#line 456
    goto case_51;
  }
#line 457
  if (op == 52U) {
#line 457
    goto case_52;
  }
#line 458
  if (op == 53U) {
#line 458
    goto case_53;
  }
#line 459
  if (op == 54U) {
#line 459
    goto case_54;
  }
#line 460
  if (op == 55U) {
#line 460
    goto case_55;
  }
#line 461
  if (op == 56U) {
#line 461
    goto case_56;
  }
#line 462
  if (op == 57U) {
#line 462
    goto case_57;
  }
#line 463
  if (op == 58U) {
#line 463
    goto case_58;
  }
#line 464
  if (op == 59U) {
#line 464
    goto case_59;
  }
#line 465
  if (op == 60U) {
#line 465
    goto case_60;
  }
#line 466
  if (op == 61U) {
#line 466
    goto case_61;
  }
#line 467
  if (op == 62U) {
#line 467
    goto case_62;
  }
#line 468
  if (op == 63U) {
#line 468
    goto case_63;
  }
#line 469
  if (op == 64U) {
#line 469
    goto case_64;
  }
#line 470
  if (op == 65U) {
#line 470
    goto case_65;
  }
#line 471
  if (op == 66U) {
#line 471
    goto case_66;
  }
#line 472
  if (op == 67U) {
#line 472
    goto case_67;
  }
#line 473
  if (op == 68U) {
#line 473
    goto case_68;
  }
#line 474
  if (op == 69U) {
#line 474
    goto case_69;
  }
#line 475
  if (op == 70U) {
#line 475
    goto case_70;
  }
#line 476
  if (op == 71U) {
#line 476
    goto case_71;
  }
#line 477
  if (op == 72U) {
#line 477
    goto case_72;
  }
#line 478
  if (op == 73U) {
#line 478
    goto case_73;
  }
#line 479
  if (op == 74U) {
#line 479
    goto case_74;
  }
#line 480
  if (op == 75U) {
#line 480
    goto case_75;
  }
#line 481
  if (op == 76U) {
#line 481
    goto case_76;
  }
#line 482
  if (op == 77U) {
#line 482
    goto case_77;
  }
#line 483
  if (op == 78U) {
#line 483
    goto case_78;
  }
#line 484
  if (op == 79U) {
#line 484
    goto case_79;
  }
#line 485
  if (op == 80U) {
#line 485
    goto case_80;
  }
#line 486
  if (op == 81U) {
#line 486
    goto case_81;
  }
#line 487
  if (op == 82U) {
#line 487
    goto case_82;
  }
#line 488
  if (op == 83U) {
#line 488
    goto case_83;
  }
#line 489
  if (op == 84U) {
#line 489
    goto case_84;
  }
#line 490
  if (op == 85U) {
#line 490
    goto case_85;
  }
#line 491
  if (op == 86U) {
#line 491
    goto case_86;
  }
#line 492
  if (op == 87U) {
#line 492
    goto case_87;
  }
#line 493
  if (op == 88U) {
#line 493
    goto case_88;
  }
#line 494
  if (op == 89U) {
#line 494
    goto case_89;
  }
#line 495
  if (op == 90U) {
#line 495
    goto case_90;
  }
#line 496
  if (op == 91U) {
#line 496
    goto case_91;
  }
#line 497
  if (op == 92U) {
#line 497
    goto case_92;
  }
#line 498
  if (op == 93U) {
#line 498
    goto case_93;
  }
#line 499
  if (op == 94U) {
#line 499
    goto case_94;
  }
#line 500
  if (op == 95U) {
#line 500
    goto case_95;
  }
#line 501
  if (op == 96U) {
#line 501
    goto case_96;
  }
#line 502
  if (op == 97U) {
#line 502
    goto case_97;
  }
#line 503
  if (op == 98U) {
#line 503
    goto case_98;
  }
#line 504
  if (op == 99U) {
#line 504
    goto case_99;
  }
#line 505
  if (op == 100U) {
#line 505
    goto case_100;
  }
#line 506
  if (op == 101U) {
#line 506
    goto case_101;
  }
#line 507
  if (op == 102U) {
#line 507
    goto case_102;
  }
#line 508
  if (op == 103U) {
#line 508
    goto case_103;
  }
#line 509
  if (op == 104U) {
#line 509
    goto case_104;
  }
#line 510
  if (op == 105U) {
#line 510
    goto case_105;
  }
#line 511
  if (op == 106U) {
#line 511
    goto case_106;
  }
#line 512
  if (op == 107U) {
#line 512
    goto case_107;
  }
#line 513
  if (op == 108U) {
#line 513
    goto case_108;
  }
#line 514
  if (op == 109U) {
#line 514
    goto case_109;
  }
#line 515
  if (op == 110U) {
#line 515
    goto case_110;
  }
#line 516
  if (op == 111U) {
#line 516
    goto case_111;
  }
#line 517
  if (op == 112U) {
#line 517
    goto case_112;
  }
#line 518
  if (op == 113U) {
#line 518
    goto case_113;
  }
#line 519
  if (op == 114U) {
#line 519
    goto case_114;
  }
#line 520
  if (op == 115U) {
#line 520
    goto case_115;
  }
#line 521
  if (op == 116U) {
#line 521
    goto case_116;
  }
#line 522
  if (op == 117U) {
#line 522
    goto case_117;
  }
#line 523
  if (op == 118U) {
#line 523
    goto case_118;
  }
#line 524
  if (op == 119U) {
#line 524
    goto case_119;
  }
#line 525
  if (op == 120U) {
#line 525
    goto case_120;
  }
#line 526
  if (op == 121U) {
#line 526
    goto case_121;
  }
#line 527
  if (op == 122U) {
#line 527
    goto case_122;
  }
#line 528
  if (op == 123U) {
#line 528
    goto case_123;
  }
#line 529
  if (op == 124U) {
#line 529
    goto case_124;
  }
#line 530
  if (op == 125U) {
#line 530
    goto case_125;
  }
#line 531
  if (op == 126U) {
#line 531
    goto case_126;
  }
#line 532
  if (op == 127U) {
#line 532
    goto case_127;
  }
#line 533
  if (op == 128U) {
#line 533
    goto case_128;
  }
#line 534
  if (op == 129U) {
#line 534
    goto case_129;
  }
#line 535
  if (op == 130U) {
#line 535
    goto case_130;
  }
#line 536
  if (op == 131U) {
#line 536
    goto case_131;
  }
#line 537
  if (op == 132U) {
#line 537
    goto case_132;
  }
#line 538
  if (op == 133U) {
#line 538
    goto case_133;
  }
#line 539
  if (op == 134U) {
#line 539
    goto case_134;
  }
#line 540
  if (op == 135U) {
#line 540
    goto case_135;
  }
#line 541
  if (op == 136U) {
#line 541
    goto case_136;
  }
#line 542
  if (op == 137U) {
#line 542
    goto case_137;
  }
#line 543
  if (op == 138U) {
#line 543
    goto case_138;
  }
#line 544
  if (op == 139U) {
#line 544
    goto case_139;
  }
#line 545
  if (op == 140U) {
#line 545
    goto case_140;
  }
#line 546
  if (op == 141U) {
#line 546
    goto case_141;
  }
#line 547
  if (op == 142U) {
#line 547
    goto case_142;
  }
#line 548
  if (op == 143U) {
#line 548
    goto case_143;
  }
#line 549
  if (op == 144U) {
#line 549
    goto case_144;
  }
#line 550
  if (op == 145U) {
#line 550
    goto case_145;
  }
#line 551
  if (op == 146U) {
#line 551
    goto case_146;
  }
#line 552
  if (op == 147U) {
#line 552
    goto case_147;
  }
#line 553
  if (op == 148U) {
#line 553
    goto case_148;
  }
#line 554
  if (op == 149U) {
#line 554
    goto case_149;
  }
#line 555
  if (op == 150U) {
#line 555
    goto case_150;
  }
#line 557
  if (op == 151U) {
#line 557
    goto case_151;
  }
#line 558
  if (op == 152U) {
#line 558
    goto case_152;
  }
#line 559
  if (op == 153U) {
#line 559
    goto case_153;
  }
#line 560
  if (op == 154U) {
#line 560
    goto case_154;
  }
#line 561
  if (op == 155U) {
#line 561
    goto case_155;
  }
#line 562
  if (op == 156U) {
#line 562
    goto case_156;
  }
#line 563
  if (op == 157U) {
#line 563
    goto case_157;
  }
#line 566
  if (op == 158U) {
#line 566
    goto case_158;
  }
#line 567
  if (op == 159U) {
#line 567
    goto case_159;
  }
#line 573
  if (op == 224U) {
#line 573
    goto case_224;
  }
#line 575
  if (op == 240U) {
#line 575
    goto case_240;
  }
#line 576
  if (op == 241U) {
#line 576
    goto case_241;
  }
#line 579
  if (op == 242U) {
#line 579
    goto case_242;
  }
#line 582
  if (op == 243U) {
#line 582
    goto case_243;
  }
#line 585
  if (op == 244U) {
#line 585
    goto case_244;
  }
#line 586
  if (op == 245U) {
#line 586
    goto case_245;
  }
#line 587
  if (op == 246U) {
#line 587
    goto case_246;
  }
#line 588
  if (op == 247U) {
#line 588
    goto case_247;
  }
#line 589
  if (op == 249U) {
#line 589
    goto case_249;
  }
#line 591
  if (op == 250U) {
#line 591
    goto case_250;
  }
#line 593
  if (op == 251U) {
#line 593
    goto case_251;
  }
#line 594
  if (op == 252U) {
#line 594
    goto case_252;
  }
#line 597
  if (op == 225U) {
#line 597
    goto case_225;
  }
#line 598
  if (op == 226U) {
#line 598
    goto case_226;
  }
#line 599
  if (op == 227U) {
#line 599
    goto case_227;
  }
#line 600
  if (op == 228U) {
#line 600
    goto case_228;
  }
#line 601
  if (op == 229U) {
#line 601
    goto case_229;
  }
#line 602
  if (op == 230U) {
#line 602
    goto case_230;
  }
#line 604
  if (op == 248U) {
#line 604
    goto case_248;
  }
#line 411
  goto switch_break;
  case_3: /* CIL Label */ 
#line 411
  return ("DW_OP_addr");
  case_6: /* CIL Label */ 
#line 412
  return ("DW_OP_deref");
  case_8: /* CIL Label */ 
#line 413
  return ("DW_OP_const1u");
  case_9: /* CIL Label */ 
#line 414
  return ("DW_OP_const1s");
  case_10: /* CIL Label */ 
#line 415
  return ("DW_OP_const2u");
  case_11: /* CIL Label */ 
#line 416
  return ("DW_OP_const2s");
  case_12: /* CIL Label */ 
#line 417
  return ("DW_OP_const4u");
  case_13: /* CIL Label */ 
#line 418
  return ("DW_OP_const4s");
  case_14: /* CIL Label */ 
#line 419
  return ("DW_OP_const8u");
  case_15: /* CIL Label */ 
#line 420
  return ("DW_OP_const8s");
  case_16: /* CIL Label */ 
#line 421
  return ("DW_OP_constu");
  case_17: /* CIL Label */ 
#line 422
  return ("DW_OP_consts");
  case_18: /* CIL Label */ 
#line 423
  return ("DW_OP_dup");
  case_19: /* CIL Label */ 
#line 424
  return ("DW_OP_drop");
  case_20: /* CIL Label */ 
#line 425
  return ("DW_OP_over");
  case_21: /* CIL Label */ 
#line 426
  return ("DW_OP_pick");
  case_22: /* CIL Label */ 
#line 427
  return ("DW_OP_swap");
  case_23: /* CIL Label */ 
#line 428
  return ("DW_OP_rot");
  case_24: /* CIL Label */ 
#line 429
  return ("DW_OP_xderef");
  case_25: /* CIL Label */ 
#line 430
  return ("DW_OP_abs");
  case_26: /* CIL Label */ 
#line 431
  return ("DW_OP_and");
  case_27: /* CIL Label */ 
#line 432
  return ("DW_OP_div");
  case_28: /* CIL Label */ 
#line 433
  return ("DW_OP_minus");
  case_29: /* CIL Label */ 
#line 434
  return ("DW_OP_mod");
  case_30: /* CIL Label */ 
#line 435
  return ("DW_OP_mul");
  case_31: /* CIL Label */ 
#line 436
  return ("DW_OP_neg");
  case_32: /* CIL Label */ 
#line 437
  return ("DW_OP_not");
  case_33: /* CIL Label */ 
#line 438
  return ("DW_OP_or");
  case_34: /* CIL Label */ 
#line 439
  return ("DW_OP_plus");
  case_35: /* CIL Label */ 
#line 440
  return ("DW_OP_plus_uconst");
  case_36: /* CIL Label */ 
#line 441
  return ("DW_OP_shl");
  case_37: /* CIL Label */ 
#line 442
  return ("DW_OP_shr");
  case_38: /* CIL Label */ 
#line 443
  return ("DW_OP_shra");
  case_39: /* CIL Label */ 
#line 444
  return ("DW_OP_xor");
  case_40: /* CIL Label */ 
#line 445
  return ("DW_OP_bra");
  case_41: /* CIL Label */ 
#line 446
  return ("DW_OP_eq");
  case_42: /* CIL Label */ 
#line 447
  return ("DW_OP_ge");
  case_43: /* CIL Label */ 
#line 448
  return ("DW_OP_gt");
  case_44: /* CIL Label */ 
#line 449
  return ("DW_OP_le");
  case_45: /* CIL Label */ 
#line 450
  return ("DW_OP_lt");
  case_46: /* CIL Label */ 
#line 451
  return ("DW_OP_ne");
  case_47: /* CIL Label */ 
#line 452
  return ("DW_OP_skip");
  case_48: /* CIL Label */ 
#line 453
  return ("DW_OP_lit0");
  case_49: /* CIL Label */ 
#line 454
  return ("DW_OP_lit1");
  case_50: /* CIL Label */ 
#line 455
  return ("DW_OP_lit2");
  case_51: /* CIL Label */ 
#line 456
  return ("DW_OP_lit3");
  case_52: /* CIL Label */ 
#line 457
  return ("DW_OP_lit4");
  case_53: /* CIL Label */ 
#line 458
  return ("DW_OP_lit5");
  case_54: /* CIL Label */ 
#line 459
  return ("DW_OP_lit6");
  case_55: /* CIL Label */ 
#line 460
  return ("DW_OP_lit7");
  case_56: /* CIL Label */ 
#line 461
  return ("DW_OP_lit8");
  case_57: /* CIL Label */ 
#line 462
  return ("DW_OP_lit9");
  case_58: /* CIL Label */ 
#line 463
  return ("DW_OP_lit10");
  case_59: /* CIL Label */ 
#line 464
  return ("DW_OP_lit11");
  case_60: /* CIL Label */ 
#line 465
  return ("DW_OP_lit12");
  case_61: /* CIL Label */ 
#line 466
  return ("DW_OP_lit13");
  case_62: /* CIL Label */ 
#line 467
  return ("DW_OP_lit14");
  case_63: /* CIL Label */ 
#line 468
  return ("DW_OP_lit15");
  case_64: /* CIL Label */ 
#line 469
  return ("DW_OP_lit16");
  case_65: /* CIL Label */ 
#line 470
  return ("DW_OP_lit17");
  case_66: /* CIL Label */ 
#line 471
  return ("DW_OP_lit18");
  case_67: /* CIL Label */ 
#line 472
  return ("DW_OP_lit19");
  case_68: /* CIL Label */ 
#line 473
  return ("DW_OP_lit20");
  case_69: /* CIL Label */ 
#line 474
  return ("DW_OP_lit21");
  case_70: /* CIL Label */ 
#line 475
  return ("DW_OP_lit22");
  case_71: /* CIL Label */ 
#line 476
  return ("DW_OP_lit23");
  case_72: /* CIL Label */ 
#line 477
  return ("DW_OP_lit24");
  case_73: /* CIL Label */ 
#line 478
  return ("DW_OP_lit25");
  case_74: /* CIL Label */ 
#line 479
  return ("DW_OP_lit26");
  case_75: /* CIL Label */ 
#line 480
  return ("DW_OP_lit27");
  case_76: /* CIL Label */ 
#line 481
  return ("DW_OP_lit28");
  case_77: /* CIL Label */ 
#line 482
  return ("DW_OP_lit29");
  case_78: /* CIL Label */ 
#line 483
  return ("DW_OP_lit30");
  case_79: /* CIL Label */ 
#line 484
  return ("DW_OP_lit31");
  case_80: /* CIL Label */ 
#line 485
  return ("DW_OP_reg0");
  case_81: /* CIL Label */ 
#line 486
  return ("DW_OP_reg1");
  case_82: /* CIL Label */ 
#line 487
  return ("DW_OP_reg2");
  case_83: /* CIL Label */ 
#line 488
  return ("DW_OP_reg3");
  case_84: /* CIL Label */ 
#line 489
  return ("DW_OP_reg4");
  case_85: /* CIL Label */ 
#line 490
  return ("DW_OP_reg5");
  case_86: /* CIL Label */ 
#line 491
  return ("DW_OP_reg6");
  case_87: /* CIL Label */ 
#line 492
  return ("DW_OP_reg7");
  case_88: /* CIL Label */ 
#line 493
  return ("DW_OP_reg8");
  case_89: /* CIL Label */ 
#line 494
  return ("DW_OP_reg9");
  case_90: /* CIL Label */ 
#line 495
  return ("DW_OP_reg10");
  case_91: /* CIL Label */ 
#line 496
  return ("DW_OP_reg11");
  case_92: /* CIL Label */ 
#line 497
  return ("DW_OP_reg12");
  case_93: /* CIL Label */ 
#line 498
  return ("DW_OP_reg13");
  case_94: /* CIL Label */ 
#line 499
  return ("DW_OP_reg14");
  case_95: /* CIL Label */ 
#line 500
  return ("DW_OP_reg15");
  case_96: /* CIL Label */ 
#line 501
  return ("DW_OP_reg16");
  case_97: /* CIL Label */ 
#line 502
  return ("DW_OP_reg17");
  case_98: /* CIL Label */ 
#line 503
  return ("DW_OP_reg18");
  case_99: /* CIL Label */ 
#line 504
  return ("DW_OP_reg19");
  case_100: /* CIL Label */ 
#line 505
  return ("DW_OP_reg20");
  case_101: /* CIL Label */ 
#line 506
  return ("DW_OP_reg21");
  case_102: /* CIL Label */ 
#line 507
  return ("DW_OP_reg22");
  case_103: /* CIL Label */ 
#line 508
  return ("DW_OP_reg23");
  case_104: /* CIL Label */ 
#line 509
  return ("DW_OP_reg24");
  case_105: /* CIL Label */ 
#line 510
  return ("DW_OP_reg25");
  case_106: /* CIL Label */ 
#line 511
  return ("DW_OP_reg26");
  case_107: /* CIL Label */ 
#line 512
  return ("DW_OP_reg27");
  case_108: /* CIL Label */ 
#line 513
  return ("DW_OP_reg28");
  case_109: /* CIL Label */ 
#line 514
  return ("DW_OP_reg29");
  case_110: /* CIL Label */ 
#line 515
  return ("DW_OP_reg30");
  case_111: /* CIL Label */ 
#line 516
  return ("DW_OP_reg31");
  case_112: /* CIL Label */ 
#line 517
  return ("DW_OP_breg0");
  case_113: /* CIL Label */ 
#line 518
  return ("DW_OP_breg1");
  case_114: /* CIL Label */ 
#line 519
  return ("DW_OP_breg2");
  case_115: /* CIL Label */ 
#line 520
  return ("DW_OP_breg3");
  case_116: /* CIL Label */ 
#line 521
  return ("DW_OP_breg4");
  case_117: /* CIL Label */ 
#line 522
  return ("DW_OP_breg5");
  case_118: /* CIL Label */ 
#line 523
  return ("DW_OP_breg6");
  case_119: /* CIL Label */ 
#line 524
  return ("DW_OP_breg7");
  case_120: /* CIL Label */ 
#line 525
  return ("DW_OP_breg8");
  case_121: /* CIL Label */ 
#line 526
  return ("DW_OP_breg9");
  case_122: /* CIL Label */ 
#line 527
  return ("DW_OP_breg10");
  case_123: /* CIL Label */ 
#line 528
  return ("DW_OP_breg11");
  case_124: /* CIL Label */ 
#line 529
  return ("DW_OP_breg12");
  case_125: /* CIL Label */ 
#line 530
  return ("DW_OP_breg13");
  case_126: /* CIL Label */ 
#line 531
  return ("DW_OP_breg14");
  case_127: /* CIL Label */ 
#line 532
  return ("DW_OP_breg15");
  case_128: /* CIL Label */ 
#line 533
  return ("DW_OP_breg16");
  case_129: /* CIL Label */ 
#line 534
  return ("DW_OP_breg17");
  case_130: /* CIL Label */ 
#line 535
  return ("DW_OP_breg18");
  case_131: /* CIL Label */ 
#line 536
  return ("DW_OP_breg19");
  case_132: /* CIL Label */ 
#line 537
  return ("DW_OP_breg20");
  case_133: /* CIL Label */ 
#line 538
  return ("DW_OP_breg21");
  case_134: /* CIL Label */ 
#line 539
  return ("DW_OP_breg22");
  case_135: /* CIL Label */ 
#line 540
  return ("DW_OP_breg23");
  case_136: /* CIL Label */ 
#line 541
  return ("DW_OP_breg24");
  case_137: /* CIL Label */ 
#line 542
  return ("DW_OP_breg25");
  case_138: /* CIL Label */ 
#line 543
  return ("DW_OP_breg26");
  case_139: /* CIL Label */ 
#line 544
  return ("DW_OP_breg27");
  case_140: /* CIL Label */ 
#line 545
  return ("DW_OP_breg28");
  case_141: /* CIL Label */ 
#line 546
  return ("DW_OP_breg29");
  case_142: /* CIL Label */ 
#line 547
  return ("DW_OP_breg30");
  case_143: /* CIL Label */ 
#line 548
  return ("DW_OP_breg31");
  case_144: /* CIL Label */ 
#line 549
  return ("DW_OP_regx");
  case_145: /* CIL Label */ 
#line 550
  return ("DW_OP_fbreg");
  case_146: /* CIL Label */ 
#line 551
  return ("DW_OP_bregx");
  case_147: /* CIL Label */ 
#line 552
  return ("DW_OP_piece");
  case_148: /* CIL Label */ 
#line 553
  return ("DW_OP_deref_size");
  case_149: /* CIL Label */ 
#line 554
  return ("DW_OP_xderef_size");
  case_150: /* CIL Label */ 
#line 555
  return ("DW_OP_nop");
  case_151: /* CIL Label */ 
#line 557
  return ("DW_OP_push_object_address");
  case_152: /* CIL Label */ 
#line 558
  return ("DW_OP_call2");
  case_153: /* CIL Label */ 
#line 559
  return ("DW_OP_call4");
  case_154: /* CIL Label */ 
#line 560
  return ("DW_OP_call_ref");
  case_155: /* CIL Label */ 
#line 561
  return ("DW_OP_form_tls_address");
  case_156: /* CIL Label */ 
#line 562
  return ("DW_OP_call_frame_cfa");
  case_157: /* CIL Label */ 
#line 563
  return ("DW_OP_bit_piece");
  case_158: /* CIL Label */ 
#line 566
  return ("DW_OP_implicit_value");
  case_159: /* CIL Label */ 
#line 567
  return ("DW_OP_stack_value");
  case_224: /* CIL Label */ 
#line 573
  return ("DW_OP_GNU_push_tls_address");
  case_240: /* CIL Label */ 
#line 575
  return ("DW_OP_GNU_uninit");
  case_241: /* CIL Label */ 
#line 576
  return ("DW_OP_GNU_encoded_addr");
  case_242: /* CIL Label */ 
#line 579
  return ("DW_OP_GNU_implicit_pointer");
  case_243: /* CIL Label */ 
#line 582
  return ("DW_OP_GNU_entry_value");
  case_244: /* CIL Label */ 
#line 585
  return ("DW_OP_GNU_const_type");
  case_245: /* CIL Label */ 
#line 586
  return ("DW_OP_GNU_regval_type");
  case_246: /* CIL Label */ 
#line 587
  return ("DW_OP_GNU_deref_type");
  case_247: /* CIL Label */ 
#line 588
  return ("DW_OP_GNU_convert");
  case_249: /* CIL Label */ 
#line 589
  return ("DW_OP_GNU_reinterpret");
  case_250: /* CIL Label */ 
#line 591
  return ("DW_OP_GNU_parameter_ref");
  case_251: /* CIL Label */ 
#line 593
  return ("DW_OP_GNU_addr_index");
  case_252: /* CIL Label */ 
#line 594
  return ("DW_OP_GNU_const_index");
  case_225: /* CIL Label */ 
#line 597
  return ("DW_OP_HP_is_value");
  case_226: /* CIL Label */ 
#line 598
  return ("DW_OP_HP_fltconst4");
  case_227: /* CIL Label */ 
#line 599
  return ("DW_OP_HP_fltconst8");
  case_228: /* CIL Label */ 
#line 600
  return ("DW_OP_HP_mod_range");
  case_229: /* CIL Label */ 
#line 601
  return ("DW_OP_HP_unmod_range");
  case_230: /* CIL Label */ 
#line 602
  return ("DW_OP_HP_tls");
  case_248: /* CIL Label */ 
#line 604
  return ("DW_OP_PGI_omp_thread_num");
  switch_break: /* CIL Label */ ;
  }
#line 605
  return ((char const   *)0);
}
}
#line 607 "./../include/dwarf2.def"
char const   *get_DW_ATE_name(unsigned int enc ) 
{ 


  {
  {
#line 607
  if (enc == 0U) {
#line 607
    goto case_0;
  }
#line 608
  if (enc == 1U) {
#line 608
    goto case_1;
  }
#line 609
  if (enc == 2U) {
#line 609
    goto case_2;
  }
#line 610
  if (enc == 3U) {
#line 610
    goto case_3;
  }
#line 611
  if (enc == 4U) {
#line 611
    goto case_4;
  }
#line 612
  if (enc == 5U) {
#line 612
    goto case_5;
  }
#line 613
  if (enc == 6U) {
#line 613
    goto case_6;
  }
#line 614
  if (enc == 7U) {
#line 614
    goto case_7;
  }
#line 615
  if (enc == 8U) {
#line 615
    goto case_8;
  }
#line 617
  if (enc == 9U) {
#line 617
    goto case_9;
  }
#line 618
  if (enc == 10U) {
#line 618
    goto case_10;
  }
#line 619
  if (enc == 11U) {
#line 619
    goto case_11;
  }
#line 620
  if (enc == 12U) {
#line 620
    goto case_12;
  }
#line 621
  if (enc == 13U) {
#line 621
    goto case_13;
  }
#line 622
  if (enc == 14U) {
#line 622
    goto case_14;
  }
#line 623
  if (enc == 15U) {
#line 623
    goto case_15;
  }
#line 625
  if (enc == 16U) {
#line 625
    goto case_16;
  }
#line 631
  if (enc == 128U) {
#line 631
    goto case_128;
  }
#line 632
  if (enc == 129U) {
#line 632
    goto case_129;
  }
#line 633
  if (enc == 130U) {
#line 633
    goto case_130;
  }
#line 634
  if (enc == 131U) {
#line 634
    goto case_131;
  }
#line 635
  if (enc == 132U) {
#line 635
    goto case_132;
  }
#line 636
  if (enc == 133U) {
#line 636
    goto case_133;
  }
#line 637
  if (enc == 134U) {
#line 637
    goto case_134;
  }
#line 638
  if (enc == 136U) {
#line 638
    goto case_136;
  }
#line 639
  if (enc == 137U) {
#line 639
    goto case_137;
  }
#line 640
  if (enc == 138U) {
#line 640
    goto case_138;
  }
#line 641
  if (enc == 139U) {
#line 641
    goto case_139;
  }
#line 642
  if (enc == 140U) {
#line 642
    goto case_140;
  }
#line 643
  if (enc == 141U) {
#line 643
    goto case_141;
  }
#line 644
  if (enc == 142U) {
#line 644
    goto case_142;
  }
#line 645
  if (enc == 143U) {
#line 645
    goto case_143;
  }
#line 646
  if (enc == 144U) {
#line 646
    goto case_144;
  }
#line 607
  goto switch_break;
  case_0: /* CIL Label */ 
#line 607
  return ("DW_ATE_void");
  case_1: /* CIL Label */ 
#line 608
  return ("DW_ATE_address");
  case_2: /* CIL Label */ 
#line 609
  return ("DW_ATE_boolean");
  case_3: /* CIL Label */ 
#line 610
  return ("DW_ATE_complex_float");
  case_4: /* CIL Label */ 
#line 611
  return ("DW_ATE_float");
  case_5: /* CIL Label */ 
#line 612
  return ("DW_ATE_signed");
  case_6: /* CIL Label */ 
#line 613
  return ("DW_ATE_signed_char");
  case_7: /* CIL Label */ 
#line 614
  return ("DW_ATE_unsigned");
  case_8: /* CIL Label */ 
#line 615
  return ("DW_ATE_unsigned_char");
  case_9: /* CIL Label */ 
#line 617
  return ("DW_ATE_imaginary_float");
  case_10: /* CIL Label */ 
#line 618
  return ("DW_ATE_packed_decimal");
  case_11: /* CIL Label */ 
#line 619
  return ("DW_ATE_numeric_string");
  case_12: /* CIL Label */ 
#line 620
  return ("DW_ATE_edited");
  case_13: /* CIL Label */ 
#line 621
  return ("DW_ATE_signed_fixed");
  case_14: /* CIL Label */ 
#line 622
  return ("DW_ATE_unsigned_fixed");
  case_15: /* CIL Label */ 
#line 623
  return ("DW_ATE_decimal_float");
  case_16: /* CIL Label */ 
#line 625
  return ("DW_ATE_UTF");
  case_128: /* CIL Label */ 
#line 631
  return ("DW_ATE_HP_float80");
  case_129: /* CIL Label */ 
#line 632
  return ("DW_ATE_HP_complex_float80");
  case_130: /* CIL Label */ 
#line 633
  return ("DW_ATE_HP_float128");
  case_131: /* CIL Label */ 
#line 634
  return ("DW_ATE_HP_complex_float128");
  case_132: /* CIL Label */ 
#line 635
  return ("DW_ATE_HP_floathpintel");
  case_133: /* CIL Label */ 
#line 636
  return ("DW_ATE_HP_imaginary_float80");
  case_134: /* CIL Label */ 
#line 637
  return ("DW_ATE_HP_imaginary_float128");
  case_136: /* CIL Label */ 
#line 638
  return ("DW_ATE_HP_VAX_float");
  case_137: /* CIL Label */ 
#line 639
  return ("DW_ATE_HP_VAX_float_d");
  case_138: /* CIL Label */ 
#line 640
  return ("DW_ATE_HP_packed_decimal");
  case_139: /* CIL Label */ 
#line 641
  return ("DW_ATE_HP_zoned_decimal");
  case_140: /* CIL Label */ 
#line 642
  return ("DW_ATE_HP_edited");
  case_141: /* CIL Label */ 
#line 643
  return ("DW_ATE_HP_signed_fixed");
  case_142: /* CIL Label */ 
#line 644
  return ("DW_ATE_HP_unsigned_fixed");
  case_143: /* CIL Label */ 
#line 645
  return ("DW_ATE_HP_VAX_complex_float");
  case_144: /* CIL Label */ 
#line 646
  return ("DW_ATE_HP_VAX_complex_float_d");
  switch_break: /* CIL Label */ ;
  }
#line 648
  return ((char const   *)0);
}
}
#line 650 "./../include/dwarf2.def"
char const   *get_DW_CFA_name(unsigned int opc ) 
{ 


  {
  {
#line 650
  if (opc == 64U) {
#line 650
    goto case_64;
  }
#line 651
  if (opc == 128U) {
#line 651
    goto case_128;
  }
#line 652
  if (opc == 192U) {
#line 652
    goto case_192;
  }
#line 653
  if (opc == 0U) {
#line 653
    goto case_0;
  }
#line 654
  if (opc == 1U) {
#line 654
    goto case_1;
  }
#line 655
  if (opc == 2U) {
#line 655
    goto case_2;
  }
#line 656
  if (opc == 3U) {
#line 656
    goto case_3;
  }
#line 657
  if (opc == 4U) {
#line 657
    goto case_4;
  }
#line 658
  if (opc == 5U) {
#line 658
    goto case_5;
  }
#line 659
  if (opc == 6U) {
#line 659
    goto case_6;
  }
#line 660
  if (opc == 7U) {
#line 660
    goto case_7;
  }
#line 661
  if (opc == 8U) {
#line 661
    goto case_8;
  }
#line 662
  if (opc == 9U) {
#line 662
    goto case_9;
  }
#line 663
  if (opc == 10U) {
#line 663
    goto case_10;
  }
#line 664
  if (opc == 11U) {
#line 664
    goto case_11;
  }
#line 665
  if (opc == 12U) {
#line 665
    goto case_12;
  }
#line 666
  if (opc == 13U) {
#line 666
    goto case_13;
  }
#line 667
  if (opc == 14U) {
#line 667
    goto case_14;
  }
#line 669
  if (opc == 15U) {
#line 669
    goto case_15;
  }
#line 670
  if (opc == 16U) {
#line 670
    goto case_16;
  }
#line 671
  if (opc == 17U) {
#line 671
    goto case_17;
  }
#line 672
  if (opc == 18U) {
#line 672
    goto case_18;
  }
#line 673
  if (opc == 19U) {
#line 673
    goto case_19;
  }
#line 674
  if (opc == 20U) {
#line 674
    goto case_20;
  }
#line 675
  if (opc == 21U) {
#line 675
    goto case_21;
  }
#line 676
  if (opc == 22U) {
#line 676
    goto case_22;
  }
#line 678
  if (opc == 28U) {
#line 678
    goto case_28;
  }
#line 679
  if (opc == 63U) {
#line 679
    goto case_63;
  }
#line 682
  if (opc == 29U) {
#line 682
    goto case_29;
  }
#line 684
  if (opc == 45U) {
#line 684
    goto case_45;
  }
#line 685
  if (opc == 46U) {
#line 685
    goto case_46;
  }
#line 686
  if (opc == 47U) {
#line 686
    goto case_47;
  }
#line 650
  goto switch_break;
  case_64: /* CIL Label */ 
#line 650
  return ("DW_CFA_advance_loc");
  case_128: /* CIL Label */ 
#line 651
  return ("DW_CFA_offset");
  case_192: /* CIL Label */ 
#line 652
  return ("DW_CFA_restore");
  case_0: /* CIL Label */ 
#line 653
  return ("DW_CFA_nop");
  case_1: /* CIL Label */ 
#line 654
  return ("DW_CFA_set_loc");
  case_2: /* CIL Label */ 
#line 655
  return ("DW_CFA_advance_loc1");
  case_3: /* CIL Label */ 
#line 656
  return ("DW_CFA_advance_loc2");
  case_4: /* CIL Label */ 
#line 657
  return ("DW_CFA_advance_loc4");
  case_5: /* CIL Label */ 
#line 658
  return ("DW_CFA_offset_extended");
  case_6: /* CIL Label */ 
#line 659
  return ("DW_CFA_restore_extended");
  case_7: /* CIL Label */ 
#line 660
  return ("DW_CFA_undefined");
  case_8: /* CIL Label */ 
#line 661
  return ("DW_CFA_same_value");
  case_9: /* CIL Label */ 
#line 662
  return ("DW_CFA_register");
  case_10: /* CIL Label */ 
#line 663
  return ("DW_CFA_remember_state");
  case_11: /* CIL Label */ 
#line 664
  return ("DW_CFA_restore_state");
  case_12: /* CIL Label */ 
#line 665
  return ("DW_CFA_def_cfa");
  case_13: /* CIL Label */ 
#line 666
  return ("DW_CFA_def_cfa_register");
  case_14: /* CIL Label */ 
#line 667
  return ("DW_CFA_def_cfa_offset");
  case_15: /* CIL Label */ 
#line 669
  return ("DW_CFA_def_cfa_expression");
  case_16: /* CIL Label */ 
#line 670
  return ("DW_CFA_expression");
  case_17: /* CIL Label */ 
#line 671
  return ("DW_CFA_offset_extended_sf");
  case_18: /* CIL Label */ 
#line 672
  return ("DW_CFA_def_cfa_sf");
  case_19: /* CIL Label */ 
#line 673
  return ("DW_CFA_def_cfa_offset_sf");
  case_20: /* CIL Label */ 
#line 674
  return ("DW_CFA_val_offset");
  case_21: /* CIL Label */ 
#line 675
  return ("DW_CFA_val_offset_sf");
  case_22: /* CIL Label */ 
#line 676
  return ("DW_CFA_val_expression");
  case_28: /* CIL Label */ 
#line 678
  return ("DW_CFA_lo_user");
  case_63: /* CIL Label */ 
#line 679
  return ("DW_CFA_hi_user");
  case_29: /* CIL Label */ 
#line 682
  return ("DW_CFA_MIPS_advance_loc8");
  case_45: /* CIL Label */ 
#line 684
  return ("DW_CFA_GNU_window_save");
  case_46: /* CIL Label */ 
#line 685
  return ("DW_CFA_GNU_args_size");
  case_47: /* CIL Label */ 
#line 686
  return ("DW_CFA_GNU_negative_offset_extended");
  switch_break: /* CIL Label */ ;
  }
#line 688
  return ((char const   *)0);
}
}
#line 331 "./../include/libiberty.h"
unsigned int xcrc32(unsigned char const   *buf___7 , int len , unsigned int init ) ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./crc32.c"
static unsigned int const   crc32_table[256]  = 
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./crc32.c"
  {      (unsigned int const   )0,      (unsigned int const   )79764919,      (unsigned int const   )159529838,      (unsigned int const   )222504665, 
        (unsigned int const   )319059676,      (unsigned int const   )398814059,      (unsigned int const   )445009330,      (unsigned int const   )507990021, 
        (unsigned int const   )638119352,      (unsigned int const   )583659535,      (unsigned int const   )797628118,      (unsigned int const   )726387553, 
        (unsigned int const   )890018660,      (unsigned int const   )835552979,      (unsigned int const   )1015980042,      (unsigned int const   )944750013, 
        (unsigned int const   )1276238704,      (unsigned int const   )1221641927,      (unsigned int const   )1167319070,      (unsigned int const   )1095957929, 
        (unsigned int const   )1595256236,      (unsigned int const   )1540665371,      (unsigned int const   )1452775106,      (unsigned int const   )1381403509, 
        (unsigned int const   )1780037320,      (unsigned int const   )1859660671,      (unsigned int const   )1671105958,      (unsigned int const   )1733955601, 
        (unsigned int const   )2031960084,      (unsigned int const   )2111593891,      (unsigned int const   )1889500026,      (unsigned int const   )1952343757, 
        (unsigned int const   )2552477408U,      (unsigned int const   )2632100695U,      (unsigned int const   )2443283854U,      (unsigned int const   )2506133561U, 
        (unsigned int const   )2334638140U,      (unsigned int const   )2414271883U,      (unsigned int const   )2191915858U,      (unsigned int const   )2254759653U, 
        (unsigned int const   )3190512472U,      (unsigned int const   )3135915759U,      (unsigned int const   )3081330742U,      (unsigned int const   )3009969537U, 
        (unsigned int const   )2905550212U,      (unsigned int const   )2850959411U,      (unsigned int const   )2762807018U,      (unsigned int const   )2691435357U, 
        (unsigned int const   )3560074640U,      (unsigned int const   )3505614887U,      (unsigned int const   )3719321342U,      (unsigned int const   )3648080713U, 
        (unsigned int const   )3342211916U,      (unsigned int const   )3287746299U,      (unsigned int const   )3467911202U,      (unsigned int const   )3396681109U, 
        (unsigned int const   )4063920168U,      (unsigned int const   )4143685023U,      (unsigned int const   )4223187782U,      (unsigned int const   )4286162673U, 
        (unsigned int const   )3779000052U,      (unsigned int const   )3858754371U,      (unsigned int const   )3904687514U,      (unsigned int const   )3967668269U, 
        (unsigned int const   )881225847,      (unsigned int const   )809987520,      (unsigned int const   )1023691545,      (unsigned int const   )969234094, 
        (unsigned int const   )662832811,      (unsigned int const   )591600412,      (unsigned int const   )771767749,      (unsigned int const   )717299826, 
        (unsigned int const   )311336399,      (unsigned int const   )374308984,      (unsigned int const   )453813921,      (unsigned int const   )533576470, 
        (unsigned int const   )25881363,      (unsigned int const   )88864420,      (unsigned int const   )134795389,      (unsigned int const   )214552010, 
        (unsigned int const   )2023205639,      (unsigned int const   )2086057648,      (unsigned int const   )1897238633,      (unsigned int const   )1976864222, 
        (unsigned int const   )1804852699,      (unsigned int const   )1867694188,      (unsigned int const   )1645340341,      (unsigned int const   )1724971778, 
        (unsigned int const   )1587496639,      (unsigned int const   )1516133128,      (unsigned int const   )1461550545,      (unsigned int const   )1406951526, 
        (unsigned int const   )1302016099,      (unsigned int const   )1230646740,      (unsigned int const   )1142491917,      (unsigned int const   )1087903418, 
        (unsigned int const   )2896545431U,      (unsigned int const   )2825181984U,      (unsigned int const   )2770861561U,      (unsigned int const   )2716262478U, 
        (unsigned int const   )3215044683U,      (unsigned int const   )3143675388U,      (unsigned int const   )3055782693U,      (unsigned int const   )3001194130U, 
        (unsigned int const   )2326604591U,      (unsigned int const   )2389456536U,      (unsigned int const   )2200899649U,      (unsigned int const   )2280525302U, 
        (unsigned int const   )2578013683U,      (unsigned int const   )2640855108U,      (unsigned int const   )2418763421U,      (unsigned int const   )2498394922U, 
        (unsigned int const   )3769900519U,      (unsigned int const   )3832873040U,      (unsigned int const   )3912640137U,      (unsigned int const   )3992402750U, 
        (unsigned int const   )4088425275U,      (unsigned int const   )4151408268U,      (unsigned int const   )4197601365U,      (unsigned int const   )4277358050U, 
        (unsigned int const   )3334271071U,      (unsigned int const   )3263032808U,      (unsigned int const   )3476998961U,      (unsigned int const   )3422541446U, 
        (unsigned int const   )3585640067U,      (unsigned int const   )3514407732U,      (unsigned int const   )3694837229U,      (unsigned int const   )3640369242U, 
        (unsigned int const   )1762451694,      (unsigned int const   )1842216281,      (unsigned int const   )1619975040,      (unsigned int const   )1682949687, 
        (unsigned int const   )2047383090,      (unsigned int const   )2127137669,      (unsigned int const   )1938468188,      (unsigned int const   )2001449195, 
        (unsigned int const   )1325665622,      (unsigned int const   )1271206113,      (unsigned int const   )1183200824,      (unsigned int const   )1111960463, 
        (unsigned int const   )1543535498,      (unsigned int const   )1489069629,      (unsigned int const   )1434599652,      (unsigned int const   )1363369299, 
        (unsigned int const   )622672798,      (unsigned int const   )568075817,      (unsigned int const   )748617968,      (unsigned int const   )677256519, 
        (unsigned int const   )907627842,      (unsigned int const   )853037301,      (unsigned int const   )1067152940,      (unsigned int const   )995781531, 
        (unsigned int const   )51762726,      (unsigned int const   )131386257,      (unsigned int const   )177728840,      (unsigned int const   )240578815, 
        (unsigned int const   )269590778,      (unsigned int const   )349224269,      (unsigned int const   )429104020,      (unsigned int const   )491947555, 
        (unsigned int const   )4046411278U,      (unsigned int const   )4126034873U,      (unsigned int const   )4172115296U,      (unsigned int const   )4234965207U, 
        (unsigned int const   )3794477266U,      (unsigned int const   )3874110821U,      (unsigned int const   )3953728444U,      (unsigned int const   )4016571915U, 
        (unsigned int const   )3609705398U,      (unsigned int const   )3555108353U,      (unsigned int const   )3735388376U,      (unsigned int const   )3664026991U, 
        (unsigned int const   )3290680682U,      (unsigned int const   )3236090077U,      (unsigned int const   )3449943556U,      (unsigned int const   )3378572211U, 
        (unsigned int const   )3174993278U,      (unsigned int const   )3120533705U,      (unsigned int const   )3032266256U,      (unsigned int const   )2961025959U, 
        (unsigned int const   )2923101090U,      (unsigned int const   )2868635157U,      (unsigned int const   )2813903052U,      (unsigned int const   )2742672763U, 
        (unsigned int const   )2604032198U,      (unsigned int const   )2683796849U,      (unsigned int const   )2461293480U,      (unsigned int const   )2524268063U, 
        (unsigned int const   )2284983834U,      (unsigned int const   )2364738477U,      (unsigned int const   )2175806836U,      (unsigned int const   )2238787779U, 
        (unsigned int const   )1569362073,      (unsigned int const   )1498123566,      (unsigned int const   )1409854455,      (unsigned int const   )1355396672, 
        (unsigned int const   )1317987909,      (unsigned int const   )1246755826,      (unsigned int const   )1192025387,      (unsigned int const   )1137557660, 
        (unsigned int const   )2072149281,      (unsigned int const   )2135122070,      (unsigned int const   )1912620623,      (unsigned int const   )1992383480, 
        (unsigned int const   )1753615357,      (unsigned int const   )1816598090,      (unsigned int const   )1627664531,      (unsigned int const   )1707420964, 
        (unsigned int const   )295390185,      (unsigned int const   )358241886,      (unsigned int const   )404320391,      (unsigned int const   )483945776, 
        (unsigned int const   )43990325,      (unsigned int const   )106832002,      (unsigned int const   )186451547,      (unsigned int const   )266083308, 
        (unsigned int const   )932423249,      (unsigned int const   )861060070,      (unsigned int const   )1041341759,      (unsigned int const   )986742920, 
        (unsigned int const   )613929101,      (unsigned int const   )542559546,      (unsigned int const   )756411363,      (unsigned int const   )701822548, 
        (unsigned int const   )3316196985U,      (unsigned int const   )3244833742U,      (unsigned int const   )3425377559U,      (unsigned int const   )3370778784U, 
        (unsigned int const   )3601682597U,      (unsigned int const   )3530312978U,      (unsigned int const   )3744426955U,      (unsigned int const   )3689838204U, 
        (unsigned int const   )3819031489U,      (unsigned int const   )3881883254U,      (unsigned int const   )3928223919U,      (unsigned int const   )4007849240U, 
        (unsigned int const   )4037393693U,      (unsigned int const   )4100235434U,      (unsigned int const   )4180117107U,      (unsigned int const   )4259748804U, 
        (unsigned int const   )2310601993U,      (unsigned int const   )2373574846U,      (unsigned int const   )2151335527U,      (unsigned int const   )2231098320U, 
        (unsigned int const   )2596047829U,      (unsigned int const   )2659030626U,      (unsigned int const   )2470359227U,      (unsigned int const   )2550115596U, 
        (unsigned int const   )2947551409U,      (unsigned int const   )2876312838U,      (unsigned int const   )2788305887U,      (unsigned int const   )2733848168U, 
        (unsigned int const   )3165939309U,      (unsigned int const   )3094707162U,      (unsigned int const   )3040238851U,      (unsigned int const   )2985771188U};
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./crc32.c"
unsigned int xcrc32(unsigned char const   *buf___7 , int len , unsigned int init ) 
{ 
  unsigned int crc ;
  int tmp___0 ;

  {
#line 174
  crc = init;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    tmp___0 = len;
#line 175
    len --;
#line 175
    if (! tmp___0) {
#line 175
      goto while_break;
    }
#line 177
    crc = (crc << 8) ^ (unsigned int )crc32_table[((crc >> 24) ^ (unsigned int )*buf___7) & 255U];
#line 178
    buf___7 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (crc);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 272
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 78 "./../include/demangle.h"
enum demangling_styles current_demangling_style ;
#line 122
struct demangler_engine  const  libiberty_demanglers[11] ;
#line 129
char *cplus_demangle(char const   *mangled , int options___0 ) ;
#line 132
int cplus_demangle_opname(char const   *opname , char *result , int options___0 ) ;
#line 135
char const   *cplus_mangle_opname(char const   *opname , int options___0 ) ;
#line 140
void set_cplus_marker_for_demangling(int ch ) ;
#line 143
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) ;
#line 146
enum demangling_styles cplus_demangle_name_to_style(char const   *name___0 ) ;
#line 159
char *cplus_demangle_v3(char const   *mangled , int options___0 ) ;
#line 166
char *java_demangle_v3(char const   *mangled ) ;
#line 169
char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) ;
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
enum demangling_styles current_demangling_style  =    (enum demangling_styles )256;
#line 95 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char cplus_markers[4]  = {      (char )'$',      (char )'.',      (char )'$',      (char )'\000'};
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char char_str[2]  = {      (char )'\000',      (char )'\000'};
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
void set_cplus_marker_for_demangling(int ch ) 
{ 


  {
#line 102
  cplus_markers[0] = (char )ch;
#line 103
  return;
}
}
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static struct optable  const  optable[79]  = 
#line 145
  {      {(char const   */* const  */)"nw", (char const   */* const  */)" new", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"dl",
      (char const   */* const  */)" delete", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"new", (char const   */* const  */)" new", (int const   )0}, 
        {(char const   */* const  */)"delete",
      (char const   */* const  */)" delete", (int const   )0}, 
        {(char const   */* const  */)"vn", (char const   */* const  */)" new []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"vd",
      (char const   */* const  */)" delete []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"as", (char const   */* const  */)"=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ne",
      (char const   */* const  */)"!=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"eq", (char const   */* const  */)"==", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ge",
      (char const   */* const  */)">=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"gt", (char const   */* const  */)">", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"le",
      (char const   */* const  */)"<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"lt", (char const   */* const  */)"<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"plus",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"pl", (char const   */* const  */)"+", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"apl",
      (char const   */* const  */)"+=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"minus", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"mi",
      (char const   */* const  */)"-", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ami", (char const   */* const  */)"-=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"mult",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"ml", (char const   */* const  */)"*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amu",
      (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aml", (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"convert",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"negate", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"trunc_mod",
      (char const   */* const  */)"%", (int const   )0}, 
        {(char const   */* const  */)"md", (char const   */* const  */)"%", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amd",
      (char const   */* const  */)"%=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"trunc_div", (char const   */* const  */)"/", (int const   )0}, 
        {(char const   */* const  */)"dv",
      (char const   */* const  */)"/", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"adv", (char const   */* const  */)"/=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_andif",
      (char const   */* const  */)"&&", (int const   )0}, 
        {(char const   */* const  */)"aa", (char const   */* const  */)"&&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_orif",
      (char const   */* const  */)"||", (int const   )0}, 
        {(char const   */* const  */)"oo", (char const   */* const  */)"||", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_not",
      (char const   */* const  */)"!", (int const   )0}, 
        {(char const   */* const  */)"nt", (char const   */* const  */)"!", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postincrement",
      (char const   */* const  */)"++", (int const   )0}, 
        {(char const   */* const  */)"pp", (char const   */* const  */)"++", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postdecrement",
      (char const   */* const  */)"--", (int const   )0}, 
        {(char const   */* const  */)"mm", (char const   */* const  */)"--", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_ior",
      (char const   */* const  */)"|", (int const   )0}, 
        {(char const   */* const  */)"or", (char const   */* const  */)"|", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aor",
      (char const   */* const  */)"|=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_xor", (char const   */* const  */)"^", (int const   )0}, 
        {(char const   */* const  */)"er",
      (char const   */* const  */)"^", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aer", (char const   */* const  */)"^=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_and",
      (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"ad", (char const   */* const  */)"&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aad",
      (char const   */* const  */)"&=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_not", (char const   */* const  */)"~", (int const   )0}, 
        {(char const   */* const  */)"co",
      (char const   */* const  */)"~", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"call", (char const   */* const  */)"()", (int const   )0}, 
        {(char const   */* const  */)"cl",
      (char const   */* const  */)"()", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"alshift", (char const   */* const  */)"<<", (int const   )0}, 
        {(char const   */* const  */)"ls",
      (char const   */* const  */)"<<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"als", (char const   */* const  */)"<<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"arshift",
      (char const   */* const  */)">>", (int const   )0}, 
        {(char const   */* const  */)"rs", (char const   */* const  */)">>", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ars",
      (char const   */* const  */)">>=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"component", (char const   */* const  */)"->", (int const   )0}, 
        {(char const   */* const  */)"pt",
      (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"rf", (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"indirect",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"method_call", (char const   */* const  */)"->()",
      (int const   )0}, 
        {(char const   */* const  */)"addr", (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"array",
      (char const   */* const  */)"[]", (int const   )0}, 
        {(char const   */* const  */)"vc", (char const   */* const  */)"[]", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"compound",
      (char const   */* const  */)", ", (int const   )0}, 
        {(char const   */* const  */)"cm", (char const   */* const  */)", ", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"cond",
      (char const   */* const  */)"?:", (int const   )0}, 
        {(char const   */* const  */)"cn", (char const   */* const  */)"?:", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"max",
      (char const   */* const  */)">?", (int const   )0}, 
        {(char const   */* const  */)"mx", (char const   */* const  */)">?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"min",
      (char const   */* const  */)"<?", (int const   )0}, 
        {(char const   */* const  */)"mn", (char const   */* const  */)"<?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"nop",
      (char const   */* const  */)"", (int const   )0}, 
        {(char const   */* const  */)"rm", (char const   */* const  */)"->*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"sz",
      (char const   */* const  */)"sizeof ", (int const   )(1 << 1)}};
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
struct demangler_engine  const  libiberty_demanglers[11]  = 
#line 246
  {      {(char const   */* const  */)"none", (enum demangling_styles  const  )-1, (char const   */* const  */)"Demangling disabled"}, 
        {(char const   */* const  */)"auto",
      (enum demangling_styles  const  )256, (char const   */* const  */)"Automatic selection based on executable"}, 
        {(char const   */* const  */)"gnu",
      (enum demangling_styles  const  )512, (char const   */* const  */)"GNU (g++) style demangling"}, 
        {(char const   */* const  */)"lucid",
      (enum demangling_styles  const  )1024, (char const   */* const  */)"Lucid (lcc) style demangling"}, 
        {(char const   */* const  */)"arm",
      (enum demangling_styles  const  )2048, (char const   */* const  */)"ARM style demangling"}, 
        {(char const   */* const  */)"hp",
      (enum demangling_styles  const  )4096, (char const   */* const  */)"HP (aCC) style demangling"}, 
        {(char const   */* const  */)"edg",
      (enum demangling_styles  const  )8192, (char const   */* const  */)"EDG style demangling"}, 
        {(char const   */* const  */)"gnu-v3",
      (enum demangling_styles  const  )16384, (char const   */* const  */)"GNU (g++) V3 ABI-style demangling"}, 
        {(char const   */* const  */)"java",
      (enum demangling_styles  const  )4, (char const   */* const  */)"Java style demangling"}, 
        {(char const   */* const  */)"gnat",
      (enum demangling_styles  const  )32768, (char const   */* const  */)"GNAT style demangling"}, 
        {(char const   */* const  */)((void *)0),
      (enum demangling_styles  const  )0, (char const   */* const  */)((void *)0)}};
#line 327
static void delete_work_stuff(struct work_stuff *work ) ;
#line 329
static void delete_non_B_K_work_stuff(struct work_stuff *work ) ;
#line 331
static char *mop_up(struct work_stuff *work , string *declp , int success ) ;
#line 333
static void squangle_mop_up(struct work_stuff *work ) ;
#line 335
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) ;
#line 342
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) ;
#line 345
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string *tname ) ;
#line 349
static int demangle_template(struct work_stuff *work , char const   **mangled , string *tname ,
                             string *trawname , int is_type , int remember ) ;
#line 353
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) ;
#line 357
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string *declp ) ;
#line 360
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string *result ,
                              int isfuncname , int append ) ;
#line 364
static int demangle_class(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 366
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 368
static int demangle_signature(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 370
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 372
static int gnu_special(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 374
static int arm_special(char const   **mangled , string *declp ) ;
#line 376
static void string_need(string *s , int n ) ;
#line 378
static void string_delete(string *s ) ;
#line 380
static void string_init(string *s ) ;
#line 383
static void string_clear(string *s ) ;
#line 389
static void string_append(string *p , char const   *s ) ;
#line 391
static void string_appends(string *p , string *s ) ;
#line 393
static void string_appendn(string *p , char const   *s , int n ) ;
#line 395
static void string_prepend(string *p , char const   *s ) ;
#line 397
static void string_prependn(string *p , char const   *s , int n ) ;
#line 399
static void string_append_template_idx(string *s , int idx___0 ) ;
#line 401
static int get_count(char const   **type , int *count ) ;
#line 403
static int consume_count(char const   **type ) ;
#line 405
static int consume_count_with_underscores(char const   **mangled ) ;
#line 407
static int demangle_args(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 409
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string *declp ) ;
#line 411
static int do_type(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 413
static int do_arg(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 415
static int demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                  string *declp , char const   *scan ) ;
#line 419
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string *declp , char const   *scan ) ;
#line 423
static void remember_type(struct work_stuff *work , char const   *start , int len ) ;
#line 425
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) ;
#line 427
static int register_Btype(struct work_stuff *work ) ;
#line 429
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) ;
#line 431
static void forget_types(struct work_stuff *work ) ;
#line 433
static void forget_B_and_K_types(struct work_stuff *work ) ;
#line 435
static void string_prepends(string *p , string *s ) ;
#line 437
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string *s , type_kind_t tk ) ;
#line 441
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string *result ) ;
#line 444
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string *result ) ;
#line 447
static int snarf_numeric_literal(char const   **args , string *arg ) ;
#line 458
static int code_for_qualifier(int c ) ;
#line 460
static char const   *qualifier_string(int type_quals ) ;
#line 462
static char const   *demangle_qualifier(int c ) ;
#line 464
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string *s , type_kind_t tk ) ;
#line 467
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string *s ) ;
#line 470
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string *s ) ;
#line 473
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string *declp ) ;
#line 476
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string *result , int namelength ) ;
#line 487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int consume_count(char const   **type ) 
{ 
  int count ;

  {
#line 490
  count = 0;
#line 492
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 493
    return (-1);
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 495
      goto while_break;
    }
#line 497
    count *= 10;
#line 504
    if (count % 10 != 0) {
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 506
        if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 506
          goto while_break___0;
        }
#line 507
        (*type) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 508
      return (-1);
    }
#line 511
    count += (int )((int const   )*(*type) - 48);
#line 512
    (*type) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if (count < 0) {
#line 516
    count = -1;
  }
#line 518
  return (count);
}
}
#line 526 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int consume_count_with_underscores(char const   **mangled ) 
{ 
  int idx___0 ;

  {
#line 531
  if ((int const   )*(*mangled) == 95) {
#line 533
    (*mangled) ++;
#line 534
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 535
      return (-1);
    }
    {
#line 537
    idx___0 = consume_count(mangled);
    }
#line 538
    if ((int const   )*(*mangled) != 95) {
#line 540
      return (-1);
    }
#line 542
    (*mangled) ++;
  } else {
#line 546
    if ((int const   )*(*mangled) < 48) {
#line 547
      return (-1);
    } else
#line 546
    if ((int const   )*(*mangled) > 57) {
#line 547
      return (-1);
    }
#line 549
    idx___0 = (int )((int const   )*(*mangled) - 48);
#line 550
    (*mangled) ++;
  }
#line 553
  return (idx___0);
}
}
#line 559 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int code_for_qualifier(int c ) 
{ 


  {
  {
#line 564
  if (c == 67) {
#line 564
    goto case_67;
  }
#line 567
  if (c == 86) {
#line 567
    goto case_86;
  }
#line 570
  if (c == 117) {
#line 570
    goto case_117;
  }
#line 573
  goto switch_default;
  case_67: /* CIL Label */ 
#line 565
  return (1);
  case_86: /* CIL Label */ 
#line 568
  return (2);
  case_117: /* CIL Label */ 
#line 571
  return (4);
  switch_default: /* CIL Label */ 
#line 574
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 578
  abort();
  }
}
}
#line 584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char const   *qualifier_string(int type_quals ) 
{ 


  {
  {
#line 589
  if (type_quals == 0) {
#line 589
    goto case_0;
  }
#line 592
  if (type_quals == 1) {
#line 592
    goto case_1;
  }
#line 595
  if (type_quals == 2) {
#line 595
    goto case_2;
  }
#line 598
  if (type_quals == 4) {
#line 598
    goto case_4;
  }
#line 601
  if (type_quals == 3) {
#line 601
    goto case_3;
  }
#line 604
  if (type_quals == 5) {
#line 604
    goto case_5;
  }
#line 607
  if (type_quals == 6) {
#line 607
    goto case_6;
  }
#line 610
  if (type_quals == 7) {
#line 610
    goto case_7;
  }
#line 613
  goto switch_default;
  case_0: /* CIL Label */ 
#line 590
  return ("");
  case_1: /* CIL Label */ 
#line 593
  return ("const");
  case_2: /* CIL Label */ 
#line 596
  return ("volatile");
  case_4: /* CIL Label */ 
#line 599
  return ("__restrict");
  case_3: /* CIL Label */ 
#line 602
  return ("const volatile");
  case_5: /* CIL Label */ 
#line 605
  return ("const __restrict");
  case_6: /* CIL Label */ 
#line 608
  return ("volatile __restrict");
  case_7: /* CIL Label */ 
#line 611
  return ("const volatile __restrict");
  switch_default: /* CIL Label */ 
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 618
  abort();
  }
}
}
#line 625 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char const   *demangle_qualifier(int c ) 
{ 
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 628
  tmp___0 = code_for_qualifier(c);
#line 628
  tmp___1 = qualifier_string(tmp___0);
  }
#line 628
  return (tmp___1);
}
}
#line 631 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
int cplus_demangle_opname(char const   *opname , char *result , int options___0 ) 
{ 
  int len ;
  int len1 ;
  int ret ;
  string type ;
  struct work_stuff work[1] ;
  char const   *tem ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t i___0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t i___1 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t i___2 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 639
  tmp___0 = strlen(opname);
#line 639
  len = (int )tmp___0;
#line 640
  *(result + 0) = (char )'\000';
#line 641
  ret = 0;
#line 642
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 643
  work[0].options = options___0;
  }
#line 645
  if ((int const   )*(opname + 0) == 95) {
#line 645
    if ((int const   )*(opname + 1) == 95) {
#line 645
      if ((int const   )*(opname + 2) == 111) {
#line 645
        if ((int const   )*(opname + 3) == 112) {
          {
#line 650
          tem = opname + 4;
#line 651
          tmp___1 = do_type(work, & tem, & type);
          }
#line 651
          if (tmp___1) {
            {
#line 653
            strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 654
            strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                    (size_t )(type.p - type.b));
#line 655
            string_delete(& type);
#line 656
            ret = 1;
            }
          }
        } else {
#line 645
          goto _L___8;
        }
      } else {
#line 645
        goto _L___8;
      }
    } else {
#line 645
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 659
  if ((int const   )*(opname + 0) == 95) {
#line 659
    if ((int const   )*(opname + 1) == 95) {
#line 659
      if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 2)) & 255] & 8) {
#line 659
        if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 3)) & 255] & 8) {
#line 663
          if ((int const   )*(opname + 4) == 0) {
#line 667
            i = (size_t )0;
            {
#line 667
            while (1) {
              while_continue: /* CIL Label */ ;
#line 667
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 667
                goto while_break;
              }
              {
#line 669
              tmp___2 = strlen((char const   *)optable[i].in);
              }
#line 669
              if (tmp___2 == 2UL) {
                {
#line 669
                tmp___3 = memcmp((void const   *)optable[i].in, (void const   *)(opname + 2),
                                 (size_t )2);
                }
#line 669
                if (tmp___3 == 0) {
                  {
#line 672
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 673
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i].out);
#line 674
                  ret = 1;
                  }
#line 675
                  goto while_break;
                }
              }
#line 667
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else
#line 681
          if ((int const   )*(opname + 2) == 97) {
#line 681
            if ((int const   )*(opname + 5) == 0) {
#line 685
              i___0 = (size_t )0;
              {
#line 685
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 685
                if (! (i___0 < sizeof(optable) / sizeof(optable[0]))) {
#line 685
                  goto while_break___0;
                }
                {
#line 687
                tmp___4 = strlen((char const   *)optable[i___0].in);
                }
#line 687
                if (tmp___4 == 3UL) {
                  {
#line 687
                  tmp___5 = memcmp((void const   *)optable[i___0].in, (void const   *)(opname + 2),
                                   (size_t )3);
                  }
#line 687
                  if (tmp___5 == 0) {
                    {
#line 690
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 691
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___0].out);
#line 692
                    ret = 1;
                    }
#line 693
                    goto while_break___0;
                  }
                }
#line 685
                i___0 ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
          }
        } else {
#line 659
          goto _L___5;
        }
      } else {
#line 659
        goto _L___5;
      }
    } else {
#line 659
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 699
  if (len >= 3) {
#line 699
    if ((int const   )*(opname + 0) == 111) {
#line 699
      if ((int const   )*(opname + 1) == 112) {
        {
#line 699
        tmp___14 = strchr((char const   *)(cplus_markers), (int )*(opname + 2));
        }
#line 699
        if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 705
          if (len >= 10) {
            {
#line 705
            tmp___10 = memcmp((void const   *)(opname + 3), (void const   *)"assign_",
                              (size_t )7);
            }
#line 705
            if (tmp___10 == 0) {
#line 709
              i___1 = (size_t )0;
              {
#line 709
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 709
                if (! (i___1 < sizeof(optable) / sizeof(optable[0]))) {
#line 709
                  goto while_break___1;
                }
                {
#line 711
                len1 = len - 10;
#line 712
                tmp___6 = strlen((char const   *)optable[i___1].in);
                }
#line 712
                if ((int )tmp___6 == len1) {
                  {
#line 712
                  tmp___7 = memcmp((void const   *)optable[i___1].in, (void const   *)(opname + 10),
                                   (size_t )len1);
                  }
#line 712
                  if (tmp___7 == 0) {
                    {
#line 715
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 716
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___1].out);
#line 717
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"=");
#line 718
                    ret = 1;
                    }
#line 719
                    goto while_break___1;
                  }
                }
#line 709
                i___1 ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 705
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 726
            i___2 = (size_t )0;
            {
#line 726
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 726
              if (! (i___2 < sizeof(optable) / sizeof(optable[0]))) {
#line 726
                goto while_break___2;
              }
              {
#line 728
              len1 = len - 3;
#line 729
              tmp___8 = strlen((char const   *)optable[i___2].in);
              }
#line 729
              if ((int )tmp___8 == len1) {
                {
#line 729
                tmp___9 = memcmp((void const   *)optable[i___2].in, (void const   *)(opname + 3),
                                 (size_t )len1);
                }
#line 729
                if (tmp___9 == 0) {
                  {
#line 732
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 733
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___2].out);
#line 734
                  ret = 1;
                  }
#line 735
                  goto while_break___2;
                }
              }
#line 726
              i___2 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 699
          goto _L___2;
        }
      } else {
#line 699
        goto _L___2;
      }
    } else {
#line 699
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 740
  if (len >= 5) {
    {
#line 740
    tmp___12 = memcmp((void const   *)opname, (void const   *)"type", (size_t )4);
    }
#line 740
    if (tmp___12 == 0) {
      {
#line 740
      tmp___13 = strchr((char const   *)(cplus_markers), (int )*(opname + 4));
      }
#line 740
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
        {
#line 744
        tem = opname + 5;
#line 745
        tmp___11 = do_type(work, & tem, & type);
        }
#line 745
        if (tmp___11) {
          {
#line 747
          strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 748
          strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                  (size_t )(type.p - type.b));
#line 749
          string_delete(& type);
#line 750
          ret = 1;
          }
        }
      }
    }
  }
  {
#line 753
  squangle_mop_up(work);
  }
#line 754
  return (ret);
}
}
#line 764 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
char const   *cplus_mangle_opname(char const   *opname , int options___0 ) 
{ 
  size_t i ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 770
  tmp___0 = strlen(opname);
#line 770
  len = (int )tmp___0;
#line 771
  i = (size_t )0;
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 771
      goto while_break;
    }
    {
#line 773
    tmp___1 = strlen((char const   *)optable[i].out);
    }
#line 773
    if ((int )tmp___1 == len) {
#line 773
      if ((options___0 & (1 << 1)) == (int )(optable[i].flags & (int const   )(1 << 1))) {
        {
#line 773
        tmp___2 = memcmp((void const   *)optable[i].out, (void const   *)opname, (size_t )len);
        }
#line 773
        if (tmp___2 == 0) {
#line 776
          return ((char const   *)optable[i].in);
        }
      }
    }
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return ((char const   *)0);
}
}
#line 784 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) 
{ 
  struct demangler_engine  const  *demangler ;

  {
#line 787
  demangler = libiberty_demanglers;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 789
      goto while_break;
    }
#line 790
    if ((int )style == (int )demangler->demangling_style) {
#line 792
      current_demangling_style = style;
#line 793
      return (current_demangling_style);
    }
#line 789
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  return ((enum demangling_styles )0);
}
}
#line 801 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_name_to_style(char const   *name___0 ) 
{ 
  struct demangler_engine  const  *demangler ;
  int tmp___0 ;

  {
#line 804
  demangler = libiberty_demanglers;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 806
      goto while_break;
    }
    {
#line 807
    tmp___0 = strcmp(name___0, (char const   *)demangler->demangling_style_name);
    }
#line 807
    if (tmp___0 == 0) {
#line 808
      return ((enum demangling_styles )demangler->demangling_style);
    }
#line 806
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 810
  return ((enum demangling_styles )0);
}
}
#line 841 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
char *cplus_demangle(char const   *mangled , int options___0 ) 
{ 
  char *ret ;
  struct work_stuff work[1] ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 847
  if ((int )current_demangling_style == -1) {
    {
#line 848
    tmp___0 = xstrdup(mangled);
    }
#line 848
    return (tmp___0);
  }
  {
#line 850
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 851
  work[0].options = options___0;
  }
#line 852
  if ((work[0].options & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15))) == 0) {
#line 853
    work[0].options |= (int )current_demangling_style & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15));
  }
#line 856
  if (work[0].options & (1 << 14)) {
#line 856
    goto _L;
  } else
#line 856
  if (work[0].options & (1 << 8)) {
    _L: /* CIL Label */ 
    {
#line 858
    ret = cplus_demangle_v3(mangled, work[0].options);
    }
#line 859
    if (ret) {
#line 860
      return (ret);
    } else
#line 859
    if (work[0].options & (1 << 14)) {
#line 860
      return (ret);
    }
  }
#line 863
  if (work[0].options & (1 << 2)) {
    {
#line 865
    ret = java_demangle_v3(mangled);
    }
#line 866
    if (ret) {
#line 867
      return (ret);
    }
  }
#line 870
  if (work[0].options & (1 << 15)) {
    {
#line 871
    tmp___1 = ada_demangle(mangled, options___0);
    }
#line 871
    return (tmp___1);
  }
  {
#line 873
  ret = internal_cplus_demangle(work, mangled);
#line 874
  squangle_mop_up(work);
  }
#line 875
  return (ret);
}
}
#line 920 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char const   * const  operators[20][2]  = 
#line 920
  { {        (char const   */* const  */)"Oabs",        (char const   */* const  */)"abs"}, 
   {        (char const   */* const  */)"Oand",        (char const   */* const  */)"and"}, 
   {        (char const   */* const  */)"Omod",        (char const   */* const  */)"mod"}, 
   {        (char const   */* const  */)"Onot",        (char const   */* const  */)"not"}, 
   {        (char const   */* const  */)"Oor",        (char const   */* const  */)"or"}, 
   {        (char const   */* const  */)"Orem",        (char const   */* const  */)"rem"}, 
   {        (char const   */* const  */)"Oxor",        (char const   */* const  */)"xor"}, 
   {        (char const   */* const  */)"Oeq",        (char const   */* const  */)"="}, 
   {        (char const   */* const  */)"One",        (char const   */* const  */)"/="}, 
   {        (char const   */* const  */)"Olt",        (char const   */* const  */)"<"}, 
   {        (char const   */* const  */)"Ole",        (char const   */* const  */)"<="}, 
   {        (char const   */* const  */)"Ogt",        (char const   */* const  */)">"}, 
   {        (char const   */* const  */)"Oge",        (char const   */* const  */)">="}, 
   {        (char const   */* const  */)"Oadd",        (char const   */* const  */)"+"}, 
   {        (char const   */* const  */)"Osubtract",        (char const   */* const  */)"-"}, 
   {        (char const   */* const  */)"Oconcat",        (char const   */* const  */)"&"}, 
   {        (char const   */* const  */)"Omultiply",        (char const   */* const  */)"*"}, 
   {        (char const   */* const  */)"Odivide",        (char const   */* const  */)"/"}, 
   {        (char const   */* const  */)"Oexpon",        (char const   */* const  */)"**"}, 
   {        (char const   */* const  */)((void *)0),        (char const   */* const  */)((void *)0)}};
#line 1064 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char const   * const  special[6][2]  = { {        (char const   */* const  */)"_elabb",        (char const   */* const  */)"\'Elab_Body"}, 
   {        (char const   */* const  */)"_elabs",        (char const   */* const  */)"\'Elab_Spec"}, 
   {        (char const   */* const  */)"_size",        (char const   */* const  */)"\'Size"}, 
   {        (char const   */* const  */)"_alignment",        (char const   */* const  */)"\'Alignment"}, 
   {        (char const   */* const  */)"_assign",        (char const   */* const  */)".\":=\""}, 
   {        (char const   */* const  */)((void *)0),        (char const   */* const  */)((void *)0)}};
#line 880 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) 
{ 
  int len0 ;
  char const   *p ;
  char *d ;
  char *demangled ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int k ;
  size_t slen ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *name___0 ;
  size_t tmp___10 ;
  char const   *name___1 ;
  size_t tmp___11 ;
  int k___0 ;
  size_t slen___0 ;
  size_t tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;

  {
  {
#line 889
  tmp___0 = strncmp(mangled, "_ada_", (size_t )5);
  }
#line 889
  if (tmp___0 == 0) {
#line 890
    mangled += 5;
  }
#line 893
  if (! ((int const   )_sch_istable[(int const   )*(mangled + 0) & 255] & 8)) {
#line 894
    goto unknown;
  }
  {
#line 901
  tmp___1 = strlen(mangled);
#line 901
  len0 = (int )((tmp___1 + 7UL) + 1UL);
#line 902
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )len0);
#line 902
  demangled = (char *)tmp___2;
#line 904
  d = demangled;
#line 905
  p = mangled;
  }
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if ((int const   )_sch_istable[(int const   )*p & 255] & 8) {
      {
#line 912
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 913
        tmp___3 = d;
#line 913
        d ++;
#line 913
        tmp___4 = p;
#line 913
        p ++;
#line 913
        *tmp___3 = (char )*tmp___4;
#line 912
        if (! ((int const   )_sch_istable[(int const   )*p & 255] & 8)) {
#line 912
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 912
            if ((int const   )*(p + 0) == 95) {
#line 912
              if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 8)) {
#line 912
                if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4)) {
#line 912
                  goto while_break___0;
                }
              }
            } else {
#line 912
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 917
    if ((int const   )*(p + 0) == 79) {
#line 930
      k = 0;
      {
#line 930
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 930
        if (! ((unsigned long )operators[k][0] != (unsigned long )((void *)0))) {
#line 930
          goto while_break___1;
        }
        {
#line 932
        tmp___5 = strlen((char const   *)operators[k][0]);
#line 932
        slen = tmp___5;
#line 933
        tmp___8 = strncmp(p, (char const   *)operators[k][0], slen);
        }
#line 933
        if (tmp___8 == 0) {
          {
#line 935
          p += slen;
#line 936
          slen = strlen((char const   *)operators[k][1]);
#line 937
          tmp___6 = d;
#line 937
          d ++;
#line 937
          *tmp___6 = (char )'\"';
#line 938
          memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)operators[k][1],
                 slen);
#line 939
          d += slen;
#line 940
          tmp___7 = d;
#line 940
          d ++;
#line 940
          *tmp___7 = (char )'\"';
          }
#line 941
          goto while_break___1;
        }
#line 930
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 945
      if ((unsigned long )operators[k][0] == (unsigned long )((void *)0)) {
#line 946
        goto unknown;
      }
    } else {
#line 951
      goto unknown;
    }
#line 955
    if ((int const   )*(p + 0) == 84) {
#line 955
      if ((int const   )*(p + 1) == 75) {
#line 958
        if ((int const   )*(p + 2) == 66) {
#line 958
          if ((int const   )*(p + 3) == 0) {
#line 961
            goto while_break;
          } else {
#line 958
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 963
        if ((int const   )*(p + 2) == 95) {
#line 963
          if ((int const   )*(p + 3) == 95) {
#line 966
            p += 4;
#line 967
            tmp___9 = d;
#line 967
            d ++;
#line 967
            *tmp___9 = (char )'.';
#line 968
            goto while_continue;
          } else {
#line 971
            goto unknown;
          }
        } else {
#line 971
          goto unknown;
        }
      }
    }
#line 973
    if ((int const   )*(p + 0) == 69) {
#line 973
      if ((int const   )*(p + 1) == 0) {
#line 976
        goto unknown;
      }
    }
#line 978
    if ((int const   )*(p + 0) == 80) {
#line 978
      goto _L___0;
    } else
#line 978
    if ((int const   )*(p + 0) == 78) {
      _L___0: /* CIL Label */ 
#line 978
      if ((int const   )*(p + 1) == 0) {
#line 981
        goto while_break;
      }
    }
#line 983
    if ((int const   )*p == 78) {
#line 983
      goto _L___1;
    } else
#line 983
    if ((int const   )*p == 83) {
      _L___1: /* CIL Label */ 
#line 983
      if ((int const   )*(p + 1) == 0) {
#line 986
        goto unknown;
      }
    }
#line 988
    if ((int const   )*(p + 0) == 88) {
#line 991
      p ++;
      {
#line 992
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 992
        if (! ((int const   )*(p + 0) == 110)) {
#line 992
          if (! ((int const   )*(p + 0) == 98)) {
#line 992
            goto while_break___2;
          }
        }
#line 993
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 995
    if ((int const   )*(p + 0) == 83) {
#line 995
      if ((int const   )*(p + 1) != 0) {
#line 995
        if ((int const   )*(p + 2) == 95) {
#line 995
          goto _L___3;
        } else
#line 995
        if ((int const   )*(p + 2) == 0) {
          _L___3: /* CIL Label */ 
          {
#line 1001
          if ((int const   )*(p + 1) == 82) {
#line 1001
            goto case_82;
          }
#line 1004
          if ((int const   )*(p + 1) == 87) {
#line 1004
            goto case_87;
          }
#line 1007
          if ((int const   )*(p + 1) == 73) {
#line 1007
            goto case_73;
          }
#line 1010
          if ((int const   )*(p + 1) == 79) {
#line 1010
            goto case_79;
          }
#line 1013
          goto switch_default;
          case_82: /* CIL Label */ 
#line 1002
          name___0 = "\'Read";
#line 1003
          goto switch_break;
          case_87: /* CIL Label */ 
#line 1005
          name___0 = "\'Write";
#line 1006
          goto switch_break;
          case_73: /* CIL Label */ 
#line 1008
          name___0 = "\'Input";
#line 1009
          goto switch_break;
          case_79: /* CIL Label */ 
#line 1011
          name___0 = "\'Output";
#line 1012
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 1014
          goto unknown;
          switch_break: /* CIL Label */ ;
          }
          {
#line 1016
          p += 2;
#line 1017
          strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)name___0);
#line 1018
          tmp___10 = strlen(name___0);
#line 1018
          d += tmp___10;
          }
        } else {
#line 995
          goto _L___4;
        }
      } else {
#line 995
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1020
    if ((int const   )*(p + 0) == 68) {
      {
#line 1026
      if ((int const   )*(p + 1) == 70) {
#line 1026
        goto case_70;
      }
#line 1029
      if ((int const   )*(p + 1) == 65) {
#line 1029
        goto case_65;
      }
#line 1032
      goto switch_default___0;
      case_70: /* CIL Label */ 
#line 1027
      name___1 = ".Finalize";
#line 1028
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 1030
      name___1 = ".Adjust";
#line 1031
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1033
      goto unknown;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1035
      strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)name___1);
#line 1036
      tmp___11 = strlen(name___1);
#line 1036
      d += tmp___11;
      }
#line 1037
      goto while_break;
    }
#line 1040
    if ((int const   )*(p + 0) == 95) {
#line 1043
      if ((int const   )*(p + 1) == 95) {
#line 1046
        p += 2;
#line 1048
        if ((int const   )_sch_istable[(int const   )*p & 255] & 4) {
          {
#line 1051
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1052
            p ++;
#line 1051
            if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1051
              if ((int const   )*(p + 0) == 95) {
#line 1051
                if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4)) {
#line 1051
                  goto while_break___3;
                }
              } else {
#line 1051
                goto while_break___3;
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1054
          if ((int const   )*p == 88) {
#line 1056
            p ++;
            {
#line 1057
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1057
              if (! ((int const   )*(p + 0) == 110)) {
#line 1057
                if (! ((int const   )*(p + 0) == 98)) {
#line 1057
                  goto while_break___4;
                }
              }
#line 1058
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        } else
#line 1061
        if ((int const   )*(p + 0) == 95) {
#line 1061
          if ((int const   )*(p + 1) != 95) {
#line 1074
            k___0 = 0;
            {
#line 1074
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1074
              if (! ((unsigned long )special[k___0][0] != (unsigned long )((void *)0))) {
#line 1074
                goto while_break___5;
              }
              {
#line 1076
              tmp___12 = strlen((char const   *)special[k___0][0]);
#line 1076
              slen___0 = tmp___12;
#line 1077
              tmp___13 = strncmp(p, (char const   *)special[k___0][0], slen___0);
              }
#line 1077
              if (tmp___13 == 0) {
                {
#line 1079
                p += slen___0;
#line 1080
                slen___0 = strlen((char const   *)special[k___0][1]);
#line 1081
                memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)special[k___0][1],
                       slen___0);
#line 1082
                d += slen___0;
                }
#line 1083
                goto while_break___5;
              }
#line 1074
              k___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 1086
            if ((unsigned long )special[k___0][0] != (unsigned long )((void *)0)) {
#line 1087
              goto while_break;
            } else {
#line 1089
              goto unknown;
            }
          } else {
#line 1093
            tmp___14 = d;
#line 1093
            d ++;
#line 1093
            *tmp___14 = (char )'.';
#line 1094
            goto while_continue;
          }
        } else {
#line 1093
          tmp___14 = d;
#line 1093
          d ++;
#line 1093
          *tmp___14 = (char )'.';
#line 1094
          goto while_continue;
        }
      } else
#line 1097
      if ((int const   )*(p + 1) == 66) {
#line 1097
        goto _L___5;
      } else
#line 1097
      if ((int const   )*(p + 1) == 69) {
        _L___5: /* CIL Label */ 
#line 1100
        p += 2;
        {
#line 1101
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1101
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1101
            goto while_break___6;
          }
#line 1102
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1103
        if ((int const   )*(p + 0) == 115) {
#line 1103
          if ((int const   )*(p + 1) == 0) {
#line 1104
            goto while_break;
          } else {
#line 1106
            goto unknown;
          }
        } else {
#line 1106
          goto unknown;
        }
      } else {
#line 1109
        goto unknown;
      }
    }
#line 1112
    if ((int const   )*(p + 0) == 46) {
#line 1112
      if ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4) {
#line 1115
        p += 2;
        {
#line 1116
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1116
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1116
            goto while_break___7;
          }
#line 1117
          p ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 1119
    if ((int const   )*p == 0) {
#line 1122
      goto while_break;
    } else {
#line 1125
      goto unknown;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  *d = (char)0;
#line 1128
  return (demangled);
  unknown: 
  {
#line 1131
  tmp___15 = strlen(mangled);
#line 1131
  len0 = (int )tmp___15;
#line 1132
  tmp___16 = xmalloc(sizeof(char ) * (unsigned long )(len0 + 3));
#line 1132
  demangled = (char *)tmp___16;
  }
#line 1134
  if ((int const   )*(mangled + 0) == 60) {
    {
#line 1135
    strcpy((char */* __restrict  */)demangled, (char const   */* __restrict  */)mangled);
    }
  } else {
    {
#line 1137
    sprintf((char */* __restrict  */)demangled, (char const   */* __restrict  */)"<%s>",
            mangled);
    }
  }
#line 1139
  return (demangled);
}
}
#line 1148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) 
{ 
  string decl ;
  int success ;
  char *demangled ;
  int s1 ;
  int s2 ;
  int s3 ;
  int s4 ;
  int tmp___0 ;

  {
#line 1153
  success = 0;
#line 1154
  demangled = (char *)((void *)0);
#line 1156
  s1 = work->constructor;
#line 1157
  s2 = work->destructor;
#line 1158
  s3 = work->static_type;
#line 1159
  s4 = work->type_quals;
#line 1160
  tmp___0 = 0;
#line 1160
  work->destructor = tmp___0;
#line 1160
  work->constructor = tmp___0;
#line 1161
  work->type_quals = 0;
#line 1162
  work->dllimported = 0;
#line 1164
  if ((unsigned long )mangled != (unsigned long )((void *)0)) {
#line 1164
    if ((int const   )*mangled != 0) {
      {
#line 1166
      string_init(& decl);
      }
#line 1175
      if (work->options & (1 << 8)) {
        {
#line 1177
        success = gnu_special(work, & mangled, & decl);
        }
      } else
#line 1175
      if (work->options & (1 << 9)) {
        {
#line 1177
        success = gnu_special(work, & mangled, & decl);
        }
      }
#line 1179
      if (! success) {
        {
#line 1181
        success = demangle_prefix(work, & mangled, & decl);
        }
      }
#line 1183
      if (success) {
#line 1183
        if ((int const   )*mangled != 0) {
          {
#line 1185
          success = demangle_signature(work, & mangled, & decl);
          }
        }
      }
#line 1187
      if (work->constructor == 2) {
        {
#line 1189
        string_prepend(& decl, "global constructors keyed to ");
#line 1190
        work->constructor = 0;
        }
      } else
#line 1192
      if (work->destructor == 2) {
        {
#line 1194
        string_prepend(& decl, "global destructors keyed to ");
#line 1195
        work->destructor = 0;
        }
      } else
#line 1197
      if (work->dllimported == 1) {
        {
#line 1199
        string_prepend(& decl, "import stub for ");
#line 1200
        work->dllimported = 0;
        }
      }
      {
#line 1202
      demangled = mop_up(work, & decl, success);
      }
    }
  }
#line 1204
  work->constructor = s1;
#line 1205
  work->destructor = s2;
#line 1206
  work->static_type = s3;
#line 1207
  work->type_quals = s4;
#line 1208
  return (demangled);
}
}
#line 1213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void squangle_mop_up(struct work_stuff *work ) 
{ 


  {
  {
#line 1217
  forget_B_and_K_types(work);
  }
#line 1218
  if ((unsigned long )work->btypevec != (unsigned long )((void *)0)) {
    {
#line 1220
    free((void *)((char *)work->btypevec));
    }
  }
#line 1222
  if ((unsigned long )work->ktypevec != (unsigned long )((void *)0)) {
    {
#line 1224
    free((void *)((char *)work->ktypevec));
    }
  }
#line 1226
  return;
}
}
#line 1231 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) 
{ 
  int i ;
  void *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int len___0 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int len___1 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int len___2 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 1236
  delete_work_stuff(to);
#line 1239
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, sizeof(*to));
  }
#line 1242
  if (from->typevec_size) {
    {
#line 1243
    tmp___0 = xmalloc(sizeof(char *) * (unsigned long )from->typevec_size);
#line 1243
    to->typevec = (char **)tmp___0;
    }
  }
#line 1245
  i = 0;
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1245
    if (! (i < from->ntypes)) {
#line 1245
      goto while_break;
    }
    {
#line 1247
    tmp___1 = strlen((char const   *)*(from->typevec + i));
#line 1247
    len = (int )(tmp___1 + 1UL);
#line 1249
    tmp___2 = xmalloc(sizeof(char ) * (unsigned long )len);
#line 1249
    *(to->typevec + i) = (char *)tmp___2;
#line 1250
    memcpy((void */* __restrict  */)*(to->typevec + i), (void const   */* __restrict  */)*(from->typevec + i),
           (size_t )len);
#line 1245
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  if (from->ksize) {
    {
#line 1254
    tmp___3 = xmalloc(sizeof(char *) * (unsigned long )from->ksize);
#line 1254
    to->ktypevec = (char **)tmp___3;
    }
  }
#line 1256
  i = 0;
  {
#line 1256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1256
    if (! (i < from->numk)) {
#line 1256
      goto while_break___0;
    }
    {
#line 1258
    tmp___4 = strlen((char const   *)*(from->ktypevec + i));
#line 1258
    len___0 = (int )(tmp___4 + 1UL);
#line 1260
    tmp___5 = xmalloc(sizeof(char ) * (unsigned long )len___0);
#line 1260
    *(to->ktypevec + i) = (char *)tmp___5;
#line 1261
    memcpy((void */* __restrict  */)*(to->ktypevec + i), (void const   */* __restrict  */)*(from->ktypevec + i),
           (size_t )len___0);
#line 1256
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1264
  if (from->bsize) {
    {
#line 1265
    tmp___6 = xmalloc(sizeof(char *) * (unsigned long )from->bsize);
#line 1265
    to->btypevec = (char **)tmp___6;
    }
  }
#line 1267
  i = 0;
  {
#line 1267
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1267
    if (! (i < from->numb)) {
#line 1267
      goto while_break___1;
    }
    {
#line 1269
    tmp___7 = strlen((char const   *)*(from->btypevec + i));
#line 1269
    len___1 = (int )(tmp___7 + 1UL);
#line 1271
    tmp___8 = xmalloc(sizeof(char ) * (unsigned long )len___1);
#line 1271
    *(to->btypevec + i) = (char *)tmp___8;
#line 1272
    memcpy((void */* __restrict  */)*(to->btypevec + i), (void const   */* __restrict  */)*(from->btypevec + i),
           (size_t )len___1);
#line 1267
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1275
  if (from->ntmpl_args) {
    {
#line 1276
    tmp___9 = xmalloc(sizeof(char *) * (unsigned long )from->ntmpl_args);
#line 1276
    to->tmpl_argvec = (char **)tmp___9;
    }
  }
#line 1278
  i = 0;
  {
#line 1278
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1278
    if (! (i < from->ntmpl_args)) {
#line 1278
      goto while_break___2;
    }
    {
#line 1280
    tmp___10 = strlen((char const   *)*(from->tmpl_argvec + i));
#line 1280
    len___2 = (int )(tmp___10 + 1UL);
#line 1282
    tmp___11 = xmalloc(sizeof(char ) * (unsigned long )len___2);
#line 1282
    *(to->tmpl_argvec + i) = (char *)tmp___11;
#line 1283
    memcpy((void */* __restrict  */)*(to->tmpl_argvec + i), (void const   */* __restrict  */)*(from->tmpl_argvec + i),
           (size_t )len___2);
#line 1278
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1286
  if (from->previous_argument) {
    {
#line 1288
    tmp___12 = xmalloc(sizeof(string ));
#line 1288
    to->previous_argument = (string *)tmp___12;
#line 1289
    string_init(to->previous_argument);
#line 1290
    string_appends(to->previous_argument, from->previous_argument);
    }
  }
#line 1292
  return;
}
}
#line 1297 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void delete_non_B_K_work_stuff(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 1302
  forget_types(work);
  }
#line 1303
  if ((unsigned long )work->typevec != (unsigned long )((void *)0)) {
    {
#line 1305
    free((void *)((char *)work->typevec));
#line 1306
    work->typevec = (char **)((void *)0);
#line 1307
    work->typevec_size = 0;
    }
  }
#line 1309
  if (work->tmpl_argvec) {
#line 1313
    i = 0;
    {
#line 1313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1313
      if (! (i < work->ntmpl_args)) {
#line 1313
        goto while_break;
      }
      {
#line 1314
      free((void *)*(work->tmpl_argvec + i));
#line 1313
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1316
    free((void *)((char *)work->tmpl_argvec));
#line 1317
    work->tmpl_argvec = (char **)((void *)0);
    }
  }
#line 1319
  if (work->previous_argument) {
    {
#line 1321
    string_delete(work->previous_argument);
#line 1322
    free((void *)((char *)work->previous_argument));
#line 1323
    work->previous_argument = (string *)((void *)0);
    }
  }
#line 1325
  return;
}
}
#line 1329 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void delete_work_stuff(struct work_stuff *work ) 
{ 


  {
  {
#line 1332
  delete_non_B_K_work_stuff(work);
#line 1333
  squangle_mop_up(work);
  }
#line 1334
  return;
}
}
#line 1339 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static char *mop_up(struct work_stuff *work , string *declp , int success ) 
{ 
  char *demangled ;

  {
  {
#line 1342
  demangled = (char *)((void *)0);
#line 1344
  delete_non_B_K_work_stuff(work);
  }
#line 1349
  if (! success) {
    {
#line 1351
    string_delete(declp);
    }
  } else {
    {
#line 1355
    string_appendn(declp, "", 1);
#line 1356
    demangled = declp->b;
    }
  }
#line 1358
  return (demangled);
}
}
#line 1391 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_signature(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  int func_done ;
  int expect_func ;
  int expect_return_type ;
  char const   *oldmangled ;
  string trawname ;
  string tname ;
  int tmp___0 ;
  string s ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  string return_type ;
  char const   *tmp___3 ;

  {
#line 1395
  success = 1;
#line 1396
  func_done = 0;
#line 1397
  expect_func = 0;
#line 1398
  expect_return_type = 0;
#line 1399
  oldmangled = (char const   *)((void *)0);
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    if (success) {
#line 1403
      if (! ((int const   )*(*mangled) != 0)) {
#line 1403
        goto while_break;
      }
    } else {
#line 1403
      goto while_break;
    }
    {
#line 1407
    if ((int const   )*(*mangled) == 81) {
#line 1407
      goto case_81;
    }
#line 1417
    if ((int const   )*(*mangled) == 75) {
#line 1417
      goto case_75;
    }
#line 1427
    if ((int const   )*(*mangled) == 83) {
#line 1427
      goto case_83;
    }
#line 1439
    if ((int const   )*(*mangled) == 117) {
#line 1439
      goto case_117;
    }
#line 1439
    if ((int const   )*(*mangled) == 86) {
#line 1439
      goto case_117;
    }
#line 1439
    if ((int const   )*(*mangled) == 67) {
#line 1439
      goto case_117;
    }
#line 1448
    if ((int const   )*(*mangled) == 76) {
#line 1448
      goto case_76;
    }
#line 1464
    if ((int const   )*(*mangled) == 57) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 56) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 55) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 54) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 53) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 52) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 51) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 50) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 49) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 48) {
#line 1464
      goto case_57;
    }
#line 1485
    if ((int const   )*(*mangled) == 66) {
#line 1485
      goto case_66;
    }
#line 1500
    if ((int const   )*(*mangled) == 70) {
#line 1500
      goto case_70;
    }
#line 1534
    if ((int const   )*(*mangled) == 116) {
#line 1534
      goto case_116;
    }
#line 1568
    if ((int const   )*(*mangled) == 95) {
#line 1568
      goto case_95;
    }
#line 1601
    if ((int const   )*(*mangled) == 72) {
#line 1601
      goto case_72;
    }
#line 1616
    goto switch_default;
    case_81: /* CIL Label */ 
    {
#line 1408
    oldmangled = *mangled;
#line 1409
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1410
    if (success) {
      {
#line 1411
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1412
    if (work->options & (1 << 8)) {
#line 1413
      expect_func = 1;
    } else
#line 1412
    if (work->options & (1 << 9)) {
#line 1413
      expect_func = 1;
    }
#line 1414
    oldmangled = (char const   *)((void *)0);
#line 1415
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1418
    oldmangled = *mangled;
#line 1419
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1420
    if (work->options & (1 << 8)) {
#line 1422
      expect_func = 1;
    } else
#line 1420
    if (work->options & (1 << 9)) {
#line 1422
      expect_func = 1;
    }
#line 1424
    oldmangled = (char const   *)((void *)0);
#line 1425
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1429
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1431
      oldmangled = *mangled;
    }
#line 1433
    (*mangled) ++;
#line 1434
    work->static_type = 1;
#line 1435
    goto switch_break;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
    {
#line 1440
    tmp___0 = code_for_qualifier((int )*(*mangled));
#line 1440
    work->type_quals |= tmp___0;
    }
#line 1443
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1444
      oldmangled = *mangled;
    }
#line 1445
    (*mangled) ++;
#line 1446
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1450
    if (work->options & (1 << 12)) {
      {
#line 1452
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1452
        if (*(*mangled)) {
#line 1452
          if (! ((int const   )*(*mangled) != 95)) {
#line 1452
            goto while_break___0;
          }
        } else {
#line 1452
          goto while_break___0;
        }
#line 1453
        (*mangled) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1454
      if (! *(*mangled)) {
#line 1455
        success = 0;
      } else {
#line 1457
        (*mangled) ++;
      }
    } else {
#line 1460
      success = 0;
    }
#line 1461
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1465
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1467
      oldmangled = *mangled;
    }
    {
#line 1469
    work->temp_start = -1;
#line 1470
    success = demangle_class(work, mangled, declp);
    }
#line 1471
    if (success) {
      {
#line 1473
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1475
    if (work->options & (1 << 8)) {
#line 1475
      goto _L;
    } else
#line 1475
    if (work->options & (1 << 9)) {
#line 1475
      goto _L;
    } else
#line 1475
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
#line 1479
      if ((int const   )*(*mangled) != 70) {
#line 1480
        expect_func = 1;
      }
    }
#line 1482
    oldmangled = (char const   *)((void *)0);
#line 1483
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1488
    success = do_type(work, mangled, & s);
    }
#line 1489
    if (success) {
#line 1491
      if (work->options & (1 << 2)) {
#line 1491
        tmp___1 = ".";
      } else {
#line 1491
        tmp___1 = "::";
      }
      {
#line 1491
      string_append(& s, tmp___1);
#line 1492
      string_prepends(declp, & s);
#line 1493
      string_delete(& s);
      }
    }
#line 1495
    oldmangled = (char const   *)((void *)0);
#line 1496
    expect_func = 1;
#line 1498
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1507
    oldmangled = (char const   *)((void *)0);
#line 1508
    func_done = 1;
#line 1509
    (*mangled) ++;
#line 1516
    if (work->options & (1 << 10)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 11)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 12)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 13)) {
      {
#line 1518
      forget_types(work);
      }
    }
    {
#line 1520
    success = demangle_args(work, mangled, declp);
    }
#line 1524
    if (success) {
#line 1524
      if (work->options & (1 << 8)) {
#line 1524
        goto _L___0;
      } else
#line 1524
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 1524
        if ((int const   )*(*mangled) == 95) {
          {
#line 1526
          (*mangled) ++;
#line 1528
          success = do_type(work, mangled, & tname);
#line 1529
          string_delete(& tname);
          }
        }
      }
    }
#line 1532
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1536
    string_init(& trawname);
#line 1537
    string_init(& tname);
    }
#line 1538
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1540
      oldmangled = *mangled;
    }
    {
#line 1542
    success = demangle_template(work, mangled, & tname, & trawname, 1, 1);
    }
#line 1544
    if (success) {
      {
#line 1546
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1548
    if (work->options & (1 << 2)) {
#line 1548
      tmp___2 = ".";
    } else {
#line 1548
      tmp___2 = "::";
    }
    {
#line 1548
    string_append(& tname, tmp___2);
#line 1550
    string_prepends(declp, & tname);
    }
#line 1551
    if (work->destructor & 1) {
      {
#line 1553
      string_prepend(& trawname, "~");
#line 1554
      string_appends(declp, & trawname);
#line 1555
      (work->destructor) --;
      }
    }
#line 1557
    if (work->constructor & 1) {
      {
#line 1559
      string_appends(declp, & trawname);
#line 1560
      (work->constructor) --;
      }
    } else
#line 1557
    if (work->destructor & 1) {
      {
#line 1559
      string_appends(declp, & trawname);
#line 1560
      (work->constructor) --;
      }
    }
    {
#line 1562
    string_delete(& trawname);
#line 1563
    string_delete(& tname);
#line 1564
    oldmangled = (char const   *)((void *)0);
#line 1565
    expect_func = 1;
    }
#line 1566
    goto switch_break;
    case_95: /* CIL Label */ 
#line 1569
    if (work->options & (1 << 8)) {
#line 1569
      goto _L___2;
    } else
#line 1569
    if (work->options & (1 << 9)) {
      _L___2: /* CIL Label */ 
#line 1569
      if (expect_return_type) {
        {
#line 1574
        (*mangled) ++;
#line 1575
        success = do_type(work, mangled, & return_type);
        }
#line 1576
        if (! ((unsigned long )return_type.b == (unsigned long )return_type.p)) {
          {
#line 1576
          string_append(& return_type, " ");
          }
        }
        {
#line 1578
        string_prepends(declp, & return_type);
#line 1579
        string_delete(& return_type);
        }
#line 1580
        goto switch_break;
      } else {
#line 1569
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1591
    if (work->options & (1 << 12)) {
#line 1593
      (*mangled) ++;
      {
#line 1594
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1594
        if (*(*mangled)) {
#line 1594
          if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1594
            goto while_break___1;
          }
        } else {
#line 1594
          goto while_break___1;
        }
#line 1595
        (*mangled) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1598
      success = 0;
    }
#line 1599
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1602
    if (work->options & (1 << 8)) {
#line 1602
      goto _L___3;
    } else
#line 1602
    if (work->options & (1 << 9)) {
      _L___3: /* CIL Label */ 
      {
#line 1605
      success = demangle_template(work, mangled, declp, (string *)0, 0, 0);
      }
#line 1607
      if (! (work->constructor & 1)) {
#line 1608
        expect_return_type = 1;
      }
#line 1609
      (*mangled) ++;
#line 1610
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1617
    if (work->options & (1 << 8)) {
      {
#line 1621
      func_done = 1;
#line 1622
      success = demangle_args(work, mangled, declp);
      }
    } else
#line 1617
    if (work->options & (1 << 9)) {
      {
#line 1621
      func_done = 1;
#line 1622
      success = demangle_args(work, mangled, declp);
      }
    } else {
#line 1630
      success = 0;
    }
#line 1632
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1638
    if (success) {
#line 1638
      if (expect_func) {
#line 1640
        func_done = 1;
#line 1641
        if (work->options & (1 << 10)) {
          {
#line 1643
          forget_types(work);
          }
        } else
#line 1641
        if (work->options & (1 << 11)) {
          {
#line 1643
          forget_types(work);
          }
        } else
#line 1641
        if (work->options & (1 << 13)) {
          {
#line 1643
          forget_types(work);
          }
        }
        {
#line 1645
        success = demangle_args(work, mangled, declp);
#line 1649
        expect_func = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1653
  if (success) {
#line 1653
    if (! func_done) {
#line 1655
      if (work->options & (1 << 8)) {
        {
#line 1663
        success = demangle_args(work, mangled, declp);
        }
      } else
#line 1655
      if (work->options & (1 << 9)) {
        {
#line 1663
        success = demangle_args(work, mangled, declp);
        }
      }
    }
  }
#line 1666
  if (success) {
#line 1666
    if (work->options & 1) {
#line 1668
      if (work->static_type) {
        {
#line 1669
        string_append(declp, " static");
        }
      }
#line 1670
      if (work->type_quals != 0) {
#line 1672
        if (! ((unsigned long )declp->b == (unsigned long )declp->p)) {
          {
#line 1672
          string_append(declp, " ");
          }
        }
        {
#line 1673
        tmp___3 = qualifier_string(work->type_quals);
#line 1673
        string_append(declp, tmp___3);
        }
      }
    }
  }
#line 1677
  return (success);
}
}
#line 1703 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string *tname ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  string temp ;
  int tmp___0 ;

  {
  {
#line 1709
  need_comma = 0;
#line 1710
  success = 1;
#line 1713
  string_append(tname, "template <");
#line 1715
  tmp___0 = get_count(mangled, & r);
  }
#line 1715
  if (tmp___0) {
#line 1717
    i = 0;
    {
#line 1717
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1717
      if (! (i < r)) {
#line 1717
        goto while_break;
      }
#line 1719
      if (need_comma) {
        {
#line 1721
        string_append(tname, ", ");
        }
      }
#line 1725
      if ((int const   )*(*mangled) == 90) {
        {
#line 1727
        (*mangled) ++;
#line 1728
        string_append(tname, "class");
        }
      } else
#line 1731
      if ((int const   )*(*mangled) == 122) {
        {
#line 1733
        (*mangled) ++;
#line 1734
        success = demangle_template_template_parm(work, mangled, tname);
        }
#line 1736
        if (! success) {
#line 1738
          goto while_break;
        }
      } else {
        {
#line 1744
        success = do_type(work, mangled, & temp);
        }
#line 1745
        if (success) {
          {
#line 1747
          string_appends(tname, & temp);
          }
        }
        {
#line 1749
        string_delete(& temp);
        }
#line 1750
        if (! success) {
#line 1752
          goto while_break;
        }
      }
#line 1755
      need_comma = 1;
#line 1717
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1759
  if ((int )*(tname->p + -1) == 62) {
    {
#line 1760
    string_append(tname, " ");
    }
  }
  {
#line 1761
  string_append(tname, "> class");
  }
#line 1762
  return (success);
}
}
#line 1765 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string *s , type_kind_t tk ) 
{ 
  int need_operator ;
  int success ;
  size_t i ;
  size_t len ;
  size_t l ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1769
  need_operator = 0;
#line 1772
  success = 1;
#line 1773
  string_appendn(s, "(", 1);
#line 1774
  (*mangled) ++;
  }
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1775
    if (success) {
#line 1775
      if ((int const   )*(*mangled) != 87) {
#line 1775
        if (! ((int const   )*(*mangled) != 0)) {
#line 1775
          goto while_break;
        }
      } else {
#line 1775
        goto while_break;
      }
    } else {
#line 1775
      goto while_break;
    }
#line 1777
    if (need_operator) {
      {
#line 1782
      success = 0;
#line 1784
      len = strlen(*mangled);
#line 1786
      i = (size_t )0;
      }
      {
#line 1786
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1786
        if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 1786
          goto while_break___0;
        }
        {
#line 1788
        tmp___0 = strlen((char const   *)optable[i].in);
#line 1788
        l = tmp___0;
        }
#line 1790
        if (l <= len) {
          {
#line 1790
          tmp___1 = memcmp((void const   *)optable[i].in, (void const   *)*mangled,
                           l);
          }
#line 1790
          if (tmp___1 == 0) {
            {
#line 1793
            string_appendn(s, " ", 1);
#line 1794
            string_append(s, (char const   *)optable[i].out);
#line 1795
            string_appendn(s, " ", 1);
#line 1796
            success = 1;
#line 1797
            *mangled += l;
            }
#line 1798
            goto while_break___0;
          }
        }
#line 1786
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1802
      if (! success) {
#line 1803
        goto while_break;
      }
    } else {
#line 1806
      need_operator = 1;
    }
    {
#line 1808
    success = demangle_template_value_parm(work, mangled, s, tk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1811
  if ((int const   )*(*mangled) != 87) {
#line 1812
    success = 0;
  } else {
    {
#line 1815
    string_appendn(s, ")", 1);
#line 1816
    (*mangled) ++;
    }
  }
#line 1819
  return (success);
}
}
#line 1822 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string *s ) 
{ 
  int success ;
  int value ;
  int multidigit_without_leading_underscore ;
  int leave_following_underscore ;
  char buf___7[32] ;

  {
#line 1828
  if ((int const   )*(*mangled) == 69) {
    {
#line 1829
    success = demangle_expression(work, mangled, s, (type_kind_t )3);
    }
  } else
#line 1830
  if ((int const   )*(*mangled) == 81) {
    {
#line 1831
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else
#line 1830
  if ((int const   )*(*mangled) == 75) {
    {
#line 1831
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else {
#line 1838
    multidigit_without_leading_underscore = 0;
#line 1839
    leave_following_underscore = 0;
#line 1841
    success = 0;
#line 1843
    if ((int const   )*(*mangled) == 95) {
#line 1845
      if ((int const   )*(*(mangled + 0) + 1) == 109) {
        {
#line 1851
        multidigit_without_leading_underscore = 1;
#line 1852
        string_appendn(s, "-", 1);
#line 1853
        *mangled += 2;
        }
      } else {
#line 1860
        leave_following_underscore = 1;
      }
    } else {
#line 1866
      if ((int const   )*(*mangled) == 109) {
        {
#line 1868
        string_appendn(s, "-", 1);
#line 1869
        (*mangled) ++;
        }
      }
#line 1875
      multidigit_without_leading_underscore = 1;
#line 1878
      leave_following_underscore = 1;
    }
#line 1885
    if (multidigit_without_leading_underscore) {
      {
#line 1886
      value = consume_count(mangled);
      }
    } else {
      {
#line 1888
      value = consume_count_with_underscores(mangled);
      }
    }
#line 1890
    if (value != -1) {
      {
#line 1893
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
              value);
#line 1894
      string_append(s, (char const   *)(buf___7));
      }
#line 1903
      if (value > 9) {
#line 1903
        goto _L;
      } else
#line 1903
      if (multidigit_without_leading_underscore) {
        _L: /* CIL Label */ 
#line 1903
        if (! leave_following_underscore) {
#line 1903
          if ((int const   )*(*mangled) == 95) {
#line 1906
            (*mangled) ++;
          }
        }
      }
#line 1909
      success = 1;
    }
  }
#line 1913
  return (success);
}
}
#line 1918 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string *s ) 
{ 
  int tmp___0 ;

  {
#line 1922
  if ((int const   )*(*mangled) == 69) {
    {
#line 1923
    tmp___0 = demangle_expression(work, mangled, s, (type_kind_t )6);
    }
#line 1923
    return (tmp___0);
  }
#line 1925
  if ((int const   )*(*mangled) == 109) {
    {
#line 1927
    string_appendn(s, "-", 1);
#line 1928
    (*mangled) ++;
    }
  }
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1930
      goto while_break;
    }
    {
#line 1932
    string_appendn(s, *mangled, 1);
#line 1933
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1935
  if ((int const   )*(*mangled) == 46) {
    {
#line 1937
    string_appendn(s, ".", 1);
#line 1938
    (*mangled) ++;
    }
    {
#line 1939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1939
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1939
        goto while_break___0;
      }
      {
#line 1941
      string_appendn(s, *mangled, 1);
#line 1942
      (*mangled) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1945
  if ((int const   )*(*mangled) == 101) {
    {
#line 1947
    string_appendn(s, "e", 1);
#line 1948
    (*mangled) ++;
    }
    {
#line 1949
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1949
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1949
        goto while_break___1;
      }
      {
#line 1951
      string_appendn(s, *mangled, 1);
#line 1952
      (*mangled) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1956
  return (1);
}
}
#line 1959 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string *s , type_kind_t tk ) 
{ 
  int success ;
  int idx___0 ;
  int tmp___0 ;
  char tmp___1[2] ;
  int val ;
  int val___0 ;
  int tmp___2 ;
  int symbol_len ;
  int tmp___3 ;
  char *p ;
  void *tmp___4 ;
  char *q ;

  {
#line 1963
  success = 1;
#line 1965
  if ((int const   )*(*mangled) == 89) {
    {
#line 1970
    (*mangled) ++;
#line 1971
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 1972
    if (idx___0 == -1) {
#line 1975
      return (-1);
    } else
#line 1972
    if (work->tmpl_argvec) {
#line 1972
      if (idx___0 >= work->ntmpl_args) {
#line 1975
        return (-1);
      } else {
#line 1972
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1972
      tmp___0 = consume_count_with_underscores(mangled);
      }
#line 1972
      if (tmp___0 == -1) {
#line 1975
        return (-1);
      }
    }
#line 1976
    if (work->tmpl_argvec) {
      {
#line 1977
      string_append(s, (char const   *)*(work->tmpl_argvec + idx___0));
      }
    } else {
      {
#line 1979
      string_append_template_idx(s, idx___0);
      }
    }
  } else
#line 1981
  if ((unsigned int )tk == 3U) {
    {
#line 1982
    success = demangle_integral_value(work, mangled, s);
    }
  } else
#line 1983
  if ((unsigned int )tk == 5U) {
#line 1987
    if ((int const   )*(*mangled) == 109) {
      {
#line 1989
      string_appendn(s, "-", 1);
#line 1990
      (*mangled) ++;
      }
    }
    {
#line 1992
    string_appendn(s, "\'", 1);
#line 1993
    val = consume_count(mangled);
    }
#line 1994
    if (val <= 0) {
#line 1995
      success = 0;
    } else {
      {
#line 1998
      tmp___1[0] = (char )val;
#line 1999
      tmp___1[1] = (char )'\000';
#line 2000
      string_appendn(s, (char const   *)(& tmp___1[0]), 1);
#line 2001
      string_appendn(s, "\'", 1);
      }
    }
  } else
#line 2004
  if ((unsigned int )tk == 4U) {
    {
#line 2006
    tmp___2 = consume_count(mangled);
#line 2006
    val___0 = tmp___2;
    }
#line 2007
    if (val___0 == 0) {
      {
#line 2008
      string_appendn(s, "false", 5);
      }
    } else
#line 2009
    if (val___0 == 1) {
      {
#line 2010
      string_appendn(s, "true", 4);
      }
    } else {
#line 2012
      success = 0;
    }
  } else
#line 2014
  if ((unsigned int )tk == 6U) {
    {
#line 2015
    success = demangle_real_value(work, mangled, s);
    }
  } else
#line 2016
  if ((unsigned int )tk == 1U) {
#line 2016
    goto _L___0;
  } else
#line 2016
  if ((unsigned int )tk == 2U) {
    _L___0: /* CIL Label */ 
#line 2018
    if ((int const   )*(*mangled) == 81) {
      {
#line 2019
      success = demangle_qualified(work, mangled, s, 0, 1);
      }
    } else {
      {
#line 2024
      tmp___3 = consume_count(mangled);
#line 2024
      symbol_len = tmp___3;
      }
#line 2025
      if (symbol_len == -1) {
#line 2026
        return (-1);
      }
#line 2027
      if (symbol_len == 0) {
        {
#line 2028
        string_appendn(s, "0", 1);
        }
      } else {
        {
#line 2031
        tmp___4 = xmalloc(sizeof(char ) * (unsigned long )(symbol_len + 1));
#line 2031
        p = (char *)tmp___4;
#line 2032
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)*mangled,
                (size_t )symbol_len);
#line 2033
        *(p + symbol_len) = (char )'\000';
#line 2039
        q = cplus_demangle((char const   *)p, work->options);
        }
#line 2040
        if ((unsigned int )tk == 1U) {
          {
#line 2041
          string_appendn(s, "&", 1);
          }
        }
#line 2044
        if (q) {
          {
#line 2046
          string_append(s, (char const   *)q);
#line 2047
          free((void *)q);
          }
        } else {
          {
#line 2050
          string_append(s, (char const   *)p);
          }
        }
        {
#line 2051
        free((void *)p);
        }
      }
#line 2053
      *mangled += symbol_len;
    }
  }
#line 2057
  return (success);
}
}
#line 2068 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_template(struct work_stuff *work , char const   **mangled , string *tname ,
                             string *trawname , int is_type , int remember ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  int is_java_array ;
  string temp ;
  int idx___0 ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int len ;
  void *tmp___6 ;
  int r2 ;
  int len___0 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  string param ;
  string *s ;
  int len___1 ;
  void *tmp___9 ;
  int bindex ;
  int tmp___10 ;
  long tmp___11 ;

  {
#line 2075
  need_comma = 0;
#line 2076
  success = 0;
#line 2077
  is_java_array = 0;
#line 2080
  (*mangled) ++;
#line 2081
  if (is_type) {
#line 2084
    if ((int const   )*(*mangled) == 122) {
      {
#line 2087
      (*mangled) ++;
#line 2088
      (*mangled) ++;
#line 2090
      idx___0 = consume_count_with_underscores(mangled);
      }
#line 2091
      if (idx___0 == -1) {
#line 2094
        return (0);
      } else
#line 2091
      if (work->tmpl_argvec) {
#line 2091
        if (idx___0 >= work->ntmpl_args) {
#line 2094
          return (0);
        } else {
#line 2091
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2091
        tmp___0 = consume_count_with_underscores(mangled);
        }
#line 2091
        if (tmp___0 == -1) {
#line 2094
          return (0);
        }
      }
#line 2096
      if (work->tmpl_argvec) {
        {
#line 2098
        string_append(tname, (char const   *)*(work->tmpl_argvec + idx___0));
        }
#line 2099
        if (trawname) {
          {
#line 2100
          string_append(trawname, (char const   *)*(work->tmpl_argvec + idx___0));
          }
        }
      } else {
        {
#line 2104
        string_append_template_idx(tname, idx___0);
        }
#line 2105
        if (trawname) {
          {
#line 2106
          string_append_template_idx(trawname, idx___0);
          }
        }
      }
    } else {
      {
#line 2111
      r = consume_count(mangled);
      }
#line 2111
      if (r <= 0) {
#line 2114
        return (0);
      } else {
        {
#line 2111
        tmp___1 = strlen(*mangled);
        }
#line 2111
        if ((int )tmp___1 < r) {
#line 2114
          return (0);
        }
      }
#line 2116
      if (work->options & (1 << 2)) {
        {
#line 2116
        tmp___2 = strncmp(*mangled, "JArray1Z", (size_t )8);
        }
#line 2116
        if (tmp___2 == 0) {
#line 2116
          tmp___3 = 1;
        } else {
#line 2116
          tmp___3 = 0;
        }
      } else {
#line 2116
        tmp___3 = 0;
      }
#line 2116
      is_java_array = tmp___3;
#line 2118
      if (! is_java_array) {
        {
#line 2120
        string_appendn(tname, *mangled, r);
        }
      }
#line 2122
      if (trawname) {
        {
#line 2123
        string_appendn(trawname, *mangled, r);
        }
      }
#line 2124
      *mangled += r;
    }
  }
#line 2127
  if (! is_java_array) {
    {
#line 2128
    string_append(tname, "<");
    }
  }
  {
#line 2130
  tmp___4 = get_count(mangled, & r);
  }
#line 2130
  if (! tmp___4) {
#line 2132
    return (0);
  }
#line 2134
  if (! is_type) {
    {
#line 2137
    tmp___5 = xmalloc(sizeof(char *) * (unsigned long )r);
#line 2137
    work->tmpl_argvec = (char **)tmp___5;
#line 2138
    work->ntmpl_args = r;
#line 2139
    i = 0;
    }
    {
#line 2139
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2139
      if (! (i < r)) {
#line 2139
        goto while_break;
      }
#line 2140
      *(work->tmpl_argvec + i) = (char *)0;
#line 2139
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2142
  i = 0;
  {
#line 2142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2142
    if (! (i < r)) {
#line 2142
      goto while_break___0;
    }
#line 2144
    if (need_comma) {
      {
#line 2146
      string_append(tname, ", ");
      }
    }
#line 2149
    if ((int const   )*(*mangled) == 90) {
      {
#line 2151
      (*mangled) ++;
#line 2153
      success = do_type(work, mangled, & temp);
      }
#line 2154
      if (success) {
        {
#line 2156
        string_appends(tname, & temp);
        }
#line 2158
        if (! is_type) {
          {
#line 2161
          len = (int )(temp.p - temp.b);
#line 2162
          tmp___6 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 2162
          *(work->tmpl_argvec + i) = (char *)tmp___6;
#line 2163
          memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)temp.b,
                 (size_t )len);
#line 2164
          *(*(work->tmpl_argvec + i) + len) = (char )'\000';
          }
        }
      }
      {
#line 2167
      string_delete(& temp);
      }
#line 2168
      if (! success) {
#line 2170
        goto while_break___0;
      }
    } else
#line 2174
    if ((int const   )*(*mangled) == 122) {
      {
#line 2177
      (*mangled) ++;
#line 2178
      success = demangle_template_template_parm(work, mangled, tname);
      }
#line 2180
      if (success) {
        {
#line 2180
        r2 = consume_count(mangled);
        }
#line 2180
        if (r2 > 0) {
          {
#line 2180
          tmp___8 = strlen(*mangled);
          }
#line 2180
          if ((int )tmp___8 >= r2) {
            {
#line 2184
            string_append(tname, " ");
#line 2185
            string_appendn(tname, *mangled, r2);
            }
#line 2186
            if (! is_type) {
              {
#line 2189
              len___0 = r2;
#line 2190
              tmp___7 = xmalloc(sizeof(char ) * (unsigned long )(len___0 + 1));
#line 2190
              *(work->tmpl_argvec + i) = (char *)tmp___7;
#line 2191
              memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)*mangled,
                     (size_t )len___0);
#line 2192
              *(*(work->tmpl_argvec + i) + len___0) = (char )'\000';
              }
            }
#line 2194
            *mangled += r2;
          }
        }
      }
#line 2196
      if (! success) {
#line 2198
        goto while_break___0;
      }
    } else {
      {
#line 2209
      success = do_type(work, mangled, & temp);
#line 2210
      string_delete(& temp);
      }
#line 2211
      if (! success) {
#line 2212
        goto while_break___0;
      }
#line 2214
      if (! is_type) {
        {
#line 2216
        s = & param;
#line 2217
        string_init(s);
        }
      } else {
#line 2220
        s = tname;
      }
      {
#line 2222
      success = demangle_template_value_parm(work, mangled, s, (type_kind_t )success);
      }
#line 2225
      if (! success) {
#line 2227
        if (! is_type) {
          {
#line 2228
          string_delete(s);
          }
        }
#line 2229
        success = 0;
#line 2230
        goto while_break___0;
      }
#line 2233
      if (! is_type) {
        {
#line 2235
        len___1 = (int )(s->p - s->b);
#line 2236
        tmp___9 = xmalloc(sizeof(char ) * (unsigned long )(len___1 + 1));
#line 2236
        *(work->tmpl_argvec + i) = (char *)tmp___9;
#line 2237
        memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)s->b,
               (size_t )len___1);
#line 2238
        *(*(work->tmpl_argvec + i) + len___1) = (char )'\000';
#line 2240
        string_appends(tname, s);
#line 2241
        string_delete(s);
        }
      }
    }
#line 2244
    need_comma = 1;
#line 2142
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2246
  if (is_java_array) {
    {
#line 2248
    string_append(tname, "[]");
    }
  } else {
#line 2252
    if ((int )*(tname->p + -1) == 62) {
      {
#line 2253
      string_append(tname, " ");
      }
    }
    {
#line 2254
    string_append(tname, ">");
    }
  }
#line 2257
  if (is_type) {
#line 2257
    if (remember) {
      {
#line 2259
      tmp___10 = register_Btype(work);
#line 2259
      bindex = tmp___10;
      }
#line 2260
      if ((unsigned long )tname->b == (unsigned long )tname->p) {
#line 2260
        tmp___11 = 0L;
      } else {
#line 2260
        tmp___11 = tname->p - tname->b;
      }
      {
#line 2260
      remember_Btype(work, (char const   *)tname->b, (int )tmp___11, bindex);
      }
    }
  }
#line 2276
  return (success);
}
}
#line 2279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) 
{ 
  int len ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int len___0 ;
  int len___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
#line 2285
  if (work->options & (1 << 11)) {
#line 2285
    goto _L;
  } else
#line 2285
  if (work->options & (1 << 12)) {
    _L: /* CIL Label */ 
    {
#line 2285
    tmp___1 = strstr(mangled, "__pt__");
#line 2285
    tmp___0 = (char const   *)tmp___1;
#line 2285
    *anchor = tmp___0;
    }
#line 2285
    if (tmp___0) {
      {
#line 2288
      *args = *anchor + 6;
#line 2289
      len = consume_count(args);
      }
#line 2290
      if (len == -1) {
#line 2291
        return (0);
      }
#line 2292
      if ((unsigned long )(*args + len) == (unsigned long )(mangled + n)) {
#line 2292
        if ((int const   )*(*args) == 95) {
#line 2294
          (*args) ++;
#line 2295
          return (1);
        }
      }
    }
  }
#line 2298
  if (work->options & (1 << 8)) {
#line 2298
    goto _L___1;
  } else
#line 2298
  if (work->options & (1 << 13)) {
    _L___1: /* CIL Label */ 
    {
#line 2300
    tmp___5 = strstr(mangled, "__tm__");
#line 2300
    tmp___4 = (char const   *)tmp___5;
#line 2300
    *anchor = tmp___4;
    }
#line 2300
    if (tmp___4) {
#line 2300
      goto _L___0;
    } else {
      {
#line 2300
      tmp___7 = strstr(mangled, "__ps__");
#line 2300
      tmp___6 = (char const   *)tmp___7;
#line 2300
      *anchor = tmp___6;
      }
#line 2300
      if (tmp___6) {
#line 2300
        goto _L___0;
      } else {
        {
#line 2300
        tmp___9 = strstr(mangled, "__pt__");
#line 2300
        tmp___8 = (char const   *)tmp___9;
#line 2300
        *anchor = tmp___8;
        }
#line 2300
        if (tmp___8) {
          _L___0: /* CIL Label */ 
          {
#line 2305
          *args = *anchor + 6;
#line 2306
          len___0 = consume_count(args);
          }
#line 2307
          if (len___0 == -1) {
#line 2308
            return (0);
          }
#line 2309
          if ((unsigned long )(*args + len___0) == (unsigned long )(mangled + n)) {
#line 2309
            if ((int const   )*(*args) == 95) {
#line 2311
              (*args) ++;
#line 2312
              return (1);
            }
          }
        } else {
          {
#line 2315
          tmp___3 = strstr(mangled, "__S");
#line 2315
          tmp___2 = (char const   *)tmp___3;
#line 2315
          *anchor = tmp___2;
          }
#line 2315
          if (tmp___2) {
            {
#line 2318
            *args = *anchor + 3;
#line 2319
            len___1 = consume_count(args);
            }
#line 2320
            if (len___1 == -1) {
#line 2321
              return (0);
            }
#line 2322
            if ((unsigned long )(*args + len___1) == (unsigned long )(mangled + n)) {
#line 2322
              if ((int const   )*(*args) == 95) {
#line 2324
                (*args) ++;
#line 2325
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 2330
  return (0);
}
}
#line 2333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string *declp ) 
{ 
  char const   *p ;
  char const   *args ;
  char const   *e ;
  string arg ;
  char *start_spec_args ;
  int hold_options ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int hold_options___0 ;
  string type_str ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *old_args ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 2339
  e = *mangled + n;
#line 2344
  if (work->options & (1 << 12)) {
#line 2344
    if ((int const   )*(*mangled + n) == 88) {
      {
#line 2346
      start_spec_args = (char *)((void *)0);
#line 2351
      start_spec_args = strchr(*mangled, '<');
      }
#line 2352
      if (start_spec_args) {
#line 2352
        if (start_spec_args - (char *)*mangled < (long )n) {
          {
#line 2353
          string_appendn(declp, *mangled, (int )(start_spec_args - (char *)*mangled));
          }
        } else {
          {
#line 2355
          string_appendn(declp, *mangled, n);
          }
        }
      } else {
        {
#line 2355
        string_appendn(declp, *mangled, n);
        }
      }
      {
#line 2356
      *mangled += n + 1;
#line 2357
      string_init(& arg);
      }
#line 2358
      if (work->temp_start == -1) {
#line 2359
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2363
      hold_options = work->options;
#line 2364
      work->options |= 1;
#line 2366
      string_append(declp, "<");
      }
      {
#line 2367
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2369
        string_delete(& arg);
        }
        {
#line 2372
        if ((int const   )*(*mangled) == 84) {
#line 2372
          goto case_84;
        }
#line 2380
        if ((int const   )*(*mangled) == 83) {
#line 2380
          goto case_83;
        }
#line 2380
        if ((int const   )*(*mangled) == 85) {
#line 2380
          goto case_83;
        }
#line 2386
        if ((int const   )*(*mangled) == 65) {
#line 2386
          goto case_65;
        }
#line 2392
        goto switch_default;
        case_84: /* CIL Label */ 
        {
#line 2374
        (*mangled) ++;
#line 2375
        tmp___0 = do_type(work, mangled, & arg);
        }
#line 2375
        if (! tmp___0) {
#line 2376
          goto hpacc_template_args_done;
        }
#line 2377
        goto switch_break;
        case_83: /* CIL Label */ 
        case_85: /* CIL Label */ 
        {
#line 2382
        tmp___1 = do_hpacc_template_const_value(work, mangled, & arg);
        }
#line 2382
        if (! tmp___1) {
#line 2383
          goto hpacc_template_args_done;
        }
#line 2384
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 2388
        tmp___2 = do_hpacc_template_literal(work, mangled, & arg);
        }
#line 2388
        if (! tmp___2) {
#line 2389
          goto hpacc_template_args_done;
        }
#line 2390
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2396
        goto hpacc_template_args_done;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2398
        string_appends(declp, & arg);
        }
#line 2402
        if ((int const   )*(*mangled) == 0) {
#line 2403
          goto while_break;
        } else
#line 2402
        if ((int const   )*(*mangled) == 95) {
#line 2403
          goto while_break;
        } else {
          {
#line 2405
          string_append(declp, ",");
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      hpacc_template_args_done: 
      {
#line 2408
      string_append(declp, ">");
#line 2409
      string_delete(& arg);
      }
#line 2410
      if ((int const   )*(*mangled) == 95) {
#line 2411
        (*mangled) ++;
      }
#line 2412
      work->options = hold_options;
#line 2413
      return;
    } else {
#line 2344
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2416
    tmp___9 = arm_pt(work, *mangled, n, & p, & args);
    }
#line 2416
    if (tmp___9) {
      {
#line 2421
      string_init(& arg);
#line 2422
      string_appendn(declp, *mangled, (int )(p - *mangled));
      }
#line 2423
      if (work->temp_start == -1) {
#line 2424
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2428
      hold_options___0 = work->options;
#line 2429
      work->options |= 1;
#line 2431
      string_append(declp, "<");
      }
      {
#line 2433
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2433
        if (! ((unsigned long )args < (unsigned long )e)) {
#line 2433
          goto while_break___0;
        }
        {
#line 2434
        string_delete(& arg);
        }
        {
#line 2442
        if ((int const   )*args == 88) {
#line 2442
          goto case_88;
        }
#line 2459
        if ((int const   )*args == 76) {
#line 2459
          goto case_76;
        }
#line 2465
        goto switch_default___0;
        case_88: /* CIL Label */ 
        {
#line 2444
        args ++;
#line 2445
        tmp___3 = do_type(work, & args, & type_str);
        }
#line 2445
        if (! tmp___3) {
#line 2446
          goto cfront_template_args_done;
        }
        {
#line 2447
        string_append(& arg, "(");
#line 2448
        string_appends(& arg, & type_str);
#line 2449
        string_delete(& type_str);
#line 2450
        string_append(& arg, ")");
        }
#line 2451
        if ((int const   )*args != 76) {
#line 2452
          goto cfront_template_args_done;
        }
        {
#line 2453
        args ++;
#line 2455
        tmp___4 = snarf_numeric_literal(& args, & arg);
        }
#line 2455
        if (! tmp___4) {
#line 2456
          goto cfront_template_args_done;
        }
#line 2457
        goto switch_break___0;
        case_76: /* CIL Label */ 
        {
#line 2461
        args ++;
#line 2462
        tmp___5 = snarf_numeric_literal(& args, & arg);
        }
#line 2462
        if (! tmp___5) {
#line 2463
          goto cfront_template_args_done;
        }
#line 2464
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 2468
        old_args = args;
#line 2469
        tmp___6 = do_type(work, & args, & arg);
        }
#line 2469
        if (! tmp___6) {
#line 2470
          goto cfront_template_args_done;
        }
#line 2473
        if ((unsigned long )args == (unsigned long )old_args) {
#line 2475
          work->options = hold_options___0;
#line 2476
          return;
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 2480
        string_appends(declp, & arg);
#line 2481
        string_append(declp, ",");
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      cfront_template_args_done: 
      {
#line 2484
      string_delete(& arg);
      }
#line 2485
      if ((unsigned long )args >= (unsigned long )e) {
#line 2486
        (declp->p) --;
      }
      {
#line 2487
      string_append(declp, ">");
#line 2488
      work->options = hold_options___0;
      }
    } else
#line 2490
    if (n > 10) {
      {
#line 2490
      tmp___7 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2490
      if (tmp___7 == 0) {
#line 2490
        if ((int const   )*(*mangled + 9) == 78) {
#line 2490
          if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
            {
#line 2490
            tmp___8 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
            }
#line 2490
            if (tmp___8) {
              {
#line 2496
              string_append(declp, "{anonymous}");
              }
            } else {
#line 2490
              goto _L___2;
            }
          } else {
#line 2490
            goto _L___2;
          }
        } else {
#line 2490
          goto _L___2;
        }
      } else {
#line 2490
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 2500
      if (work->temp_start == -1) {
#line 2501
        work->temp_start = 0;
      }
      {
#line 2502
      string_appendn(declp, *mangled, n);
      }
    }
  }
#line 2504
  *mangled += n;
#line 2505
  return;
}
}
#line 2511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string *declp ) 
{ 
  int n ;
  int success ;
  size_t tmp___0 ;

  {
  {
#line 2516
  success = 0;
#line 2518
  n = consume_count(mangled);
  }
#line 2519
  if (n == -1) {
#line 2520
    return (0);
  }
  {
#line 2521
  tmp___0 = strlen(*mangled);
  }
#line 2521
  if ((int )tmp___0 >= n) {
    {
#line 2523
    demangle_arm_hp_template(work, mangled, n, declp);
#line 2524
    success = 1;
    }
  }
#line 2527
  return (success);
}
}
#line 2565 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_class(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  int btype ;
  string class_name ;
  char *save_class_name_end ;
  long tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2568
  success = 0;
#line 2571
  save_class_name_end = (char *)0;
#line 2573
  string_init(& class_name);
#line 2574
  btype = register_Btype(work);
#line 2575
  tmp___3 = demangle_class_name(work, mangled, & class_name);
  }
#line 2575
  if (tmp___3) {
#line 2577
    save_class_name_end = class_name.p;
#line 2578
    if (work->constructor & 1) {
#line 2578
      goto _L;
    } else
#line 2578
    if (work->destructor & 1) {
      _L: /* CIL Label */ 
#line 2581
      if (work->temp_start) {
#line 2581
        if (work->temp_start != -1) {
#line 2583
          class_name.p = class_name.b + work->temp_start;
        }
      }
      {
#line 2585
      string_prepends(declp, & class_name);
      }
#line 2586
      if (work->destructor & 1) {
        {
#line 2588
        string_prepend(declp, "~");
#line 2589
        (work->destructor) --;
        }
      } else {
#line 2593
        (work->constructor) --;
      }
    }
#line 2596
    class_name.p = save_class_name_end;
#line 2597
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2597
      tmp___0 = 0L;
    } else {
#line 2597
      tmp___0 = class_name.p - class_name.b;
    }
    {
#line 2597
    remember_Ktype(work, (char const   *)class_name.b, (int )tmp___0);
    }
#line 2598
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2598
      tmp___1 = 0L;
    } else {
#line 2598
      tmp___1 = class_name.p - class_name.b;
    }
    {
#line 2598
    remember_Btype(work, (char const   *)class_name.b, (int )tmp___1, btype);
    }
#line 2599
    if (work->options & (1 << 2)) {
#line 2599
      tmp___2 = ".";
    } else {
#line 2599
      tmp___2 = "::";
    }
    {
#line 2599
    string_prepend(declp, tmp___2);
#line 2600
    string_prepends(declp, & class_name);
#line 2601
    success = 1;
    }
  }
  {
#line 2603
  string_delete(& class_name);
  }
#line 2604
  return (success);
}
}
#line 2617 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string *declp , char const   *scan ) 
{ 
  char const   *mangle_init ;
  int success ;
  string decl_init ;
  struct work_stuff work_init ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2621
  mangle_init = *mangled;
#line 2622
  success = 0;
#line 2626
  if ((int const   )*(scan + 2) == 0) {
#line 2627
    return (0);
  }
#line 2631
  if (work->options & (1 << 11)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 10)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 12)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 13)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else {
    {
#line 2631
    tmp___1 = strstr(scan + 2, "__");
    }
#line 2631
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 2633
      tmp___0 = demangle_function_name(work, mangled, declp, scan);
      }
#line 2633
      return (tmp___0);
    }
  }
  {
#line 2637
  string_init(& decl_init);
#line 2638
  string_appends(& decl_init, declp);
#line 2639
  memset((void *)(& work_init), 0, sizeof(work_init));
#line 2640
  work_stuff_copy_to_from(& work_init, work);
  }
  {
#line 2648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2648
    if (! *(scan + 2)) {
#line 2648
      goto while_break;
    }
    {
#line 2650
    tmp___2 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2650
    if (tmp___2) {
      {
#line 2652
      success = demangle_signature(work, mangled, declp);
      }
#line 2653
      if (success) {
#line 2654
        goto while_break;
      }
    }
    {
#line 2658
    *mangled = mangle_init;
#line 2659
    string_clear(declp);
#line 2660
    string_appends(declp, & decl_init);
#line 2661
    work_stuff_copy_to_from(work, & work_init);
#line 2664
    scan += 2;
    }
    {
#line 2667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2667
      if (*scan) {
#line 2667
        if (! ((int const   )*(scan + 0) != 95)) {
#line 2667
          if (! ((int const   )*(scan + 1) != 95)) {
#line 2667
            goto while_break___0;
          }
        }
      } else {
#line 2667
        goto while_break___0;
      }
#line 2668
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2671
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2671
      if (*scan) {
#line 2671
        if (! ((int const   )*scan == 95)) {
#line 2671
          goto while_break___1;
        }
      } else {
#line 2671
        goto while_break___1;
      }
#line 2672
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2673
    scan -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2677
  delete_work_stuff(& work_init);
#line 2678
  string_delete(& decl_init);
  }
#line 2680
  return (success);
}
}
#line 2716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  char const   *scan ;
  int i ;
  char *marker ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;

  {
  {
#line 2720
  success = 1;
#line 2724
  tmp___7 = strlen(*mangled);
  }
#line 2724
  if (tmp___7 > 6UL) {
    {
#line 2724
    tmp___8 = strncmp(*mangled, "_imp__", (size_t )6);
    }
#line 2724
    if (tmp___8 == 0) {
#line 2731
      *mangled += 6;
#line 2732
      work->dllimported = 1;
    } else {
      {
#line 2724
      tmp___9 = strncmp(*mangled, "__imp_", (size_t )6);
      }
#line 2724
      if (tmp___9 == 0) {
#line 2731
        *mangled += 6;
#line 2732
        work->dllimported = 1;
      } else {
#line 2724
        goto _L___3;
      }
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2734
    tmp___5 = strlen(*mangled);
    }
#line 2734
    if (tmp___5 >= 11UL) {
      {
#line 2734
      tmp___6 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2734
      if (tmp___6 == 0) {
        {
#line 2736
        tmp___0 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
#line 2736
        marker = tmp___0;
        }
#line 2737
        if ((unsigned long )marker != (unsigned long )((void *)0)) {
#line 2737
          if ((int )*marker == (int )*(*mangled + 10)) {
#line 2739
            if ((int const   )*(*mangled + 9) == 68) {
              {
#line 2742
              *mangled += 11;
#line 2743
              work->destructor = 2;
#line 2744
              tmp___1 = gnu_special(work, mangled, declp);
              }
#line 2744
              if (tmp___1) {
#line 2745
                return (success);
              }
            } else
#line 2747
            if ((int const   )*(*mangled + 9) == 73) {
              {
#line 2750
              *mangled += 11;
#line 2751
              work->constructor = 2;
#line 2752
              tmp___2 = gnu_special(work, mangled, declp);
              }
#line 2752
              if (tmp___2) {
#line 2753
                return (success);
              }
            }
          }
        }
      } else {
#line 2734
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2757
    if (work->options & (1 << 11)) {
#line 2757
      goto _L___1;
    } else
#line 2757
    if (work->options & (1 << 12)) {
#line 2757
      goto _L___1;
    } else
#line 2757
    if (work->options & (1 << 13)) {
      _L___1: /* CIL Label */ 
      {
#line 2757
      tmp___4 = strncmp(*mangled, "__std__", (size_t )7);
      }
#line 2757
      if (tmp___4 == 0) {
#line 2760
        *mangled += 7;
#line 2761
        work->destructor = 2;
      } else {
#line 2757
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2763
    if (work->options & (1 << 11)) {
#line 2763
      goto _L;
    } else
#line 2763
    if (work->options & (1 << 12)) {
#line 2763
      goto _L;
    } else
#line 2763
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
      {
#line 2763
      tmp___3 = strncmp(*mangled, "__sti__", (size_t )7);
      }
#line 2763
      if (tmp___3 == 0) {
#line 2766
        *mangled += 7;
#line 2767
        work->constructor = 2;
      }
    }
  }
#line 2775
  scan = *mangled;
  {
#line 2777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2778
    tmp___10 = strchr(scan, '_');
#line 2778
    scan = (char const   *)tmp___10;
    }
#line 2777
    if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2777
      scan ++;
#line 2777
      if (! ((int const   )*scan != 95)) {
#line 2777
        goto while_break;
      }
    } else {
#line 2777
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2781
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2781
    scan --;
  }
#line 2784
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
    {
#line 2788
    tmp___11 = strspn(scan, "_");
#line 2788
    i = (int )tmp___11;
    }
#line 2789
    if (i > 2) {
#line 2791
      scan += i - 2;
    }
  }
#line 2795
  if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2797
    success = 0;
  } else
#line 2799
  if (work->static_type) {
#line 2801
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 0)) & 255] & 4)) {
#line 2801
      if ((int const   )*(scan + 0) != 116) {
#line 2803
        success = 0;
      }
    }
  } else
#line 2806
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2806
    if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 81) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 116) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 75) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 72) {
      _L___16: /* CIL Label */ 
#line 2813
      if (work->options & (1 << 10)) {
#line 2813
        goto _L___5;
      } else
#line 2813
      if (work->options & (1 << 11)) {
#line 2813
        goto _L___5;
      } else
#line 2813
      if (work->options & (1 << 12)) {
        _L___5: /* CIL Label */ 
#line 2813
        if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
          {
#line 2816
          *mangled = scan + 2;
#line 2817
          consume_count(mangled);
#line 2818
          string_append(declp, *mangled);
#line 2819
          tmp___12 = strlen(*mangled);
#line 2819
          *mangled += tmp___12;
#line 2820
          success = 1;
          }
        } else {
#line 2813
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 2828
        if (! (work->options & (1 << 10))) {
#line 2828
          if (! (work->options & (1 << 11))) {
#line 2828
            if (! (work->options & (1 << 12))) {
#line 2828
              if (! (work->options & (1 << 13))) {
#line 2829
                (work->constructor) ++;
              }
            }
          }
        }
#line 2830
        *mangled = scan + 2;
      }
    } else {
#line 2806
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 2833
  if (work->options & (1 << 11)) {
#line 2833
    if ((int const   )*(scan + 2) == 112) {
#line 2833
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2836
        success = 1;
#line 2839
        tmp___13 = strlen(*mangled);
#line 2839
        demangle_arm_hp_template(work, mangled, (int )tmp___13, declp);
        }
      } else {
#line 2833
        goto _L___14;
      }
    } else {
#line 2833
      goto _L___14;
    }
  } else
  _L___14: /* CIL Label */ 
#line 2841
  if (work->options & (1 << 13)) {
#line 2841
    if ((int const   )*(scan + 2) == 116) {
#line 2841
      if ((int const   )*(scan + 3) == 109) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 2841
    if ((int const   )*(scan + 2) == 112) {
#line 2841
      if ((int const   )*(scan + 3) == 115) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 2841
    if ((int const   )*(scan + 2) == 112) {
#line 2841
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___10;
      }
    } else {
#line 2841
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2851
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2851
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4)) {
#line 2851
      if ((int const   )*(scan + 2) != 116) {
#line 2857
        if (work->options & (1 << 11)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 10)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 12)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 13)) {
          _L___7: /* CIL Label */ 
          {
#line 2857
          tmp___17 = arm_special(mangled, declp);
          }
#line 2857
          if (tmp___17 == 0) {
            _L___6: /* CIL Label */ 
            {
#line 2860
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 2860
              if (! ((int const   )*scan == 95)) {
#line 2860
                goto while_break___0;
              }
#line 2862
              scan ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 2864
            tmp___16 = strstr(scan, "__");
#line 2864
            scan = (char const   *)tmp___16;
            }
#line 2864
            if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2868
              success = 0;
            } else
#line 2864
            if ((int const   )*(scan + 2) == 0) {
#line 2868
              success = 0;
            } else {
              {
#line 2871
              tmp___15 = iterate_demangle_function(work, mangled, declp, scan);
              }
#line 2871
              return (tmp___15);
            }
          }
        } else {
#line 2857
          goto _L___6;
        }
      } else {
#line 2851
        goto _L___9;
      }
    } else {
#line 2851
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2874
  if ((int const   )*(scan + 2) != 0) {
    {
#line 2880
    tmp___18 = iterate_demangle_function(work, mangled, declp, scan);
    }
#line 2880
    return (tmp___18);
  } else {
#line 2885
    success = 0;
  }
#line 2888
  if (! success) {
#line 2888
    if (work->constructor == 2) {
      {
#line 2890
      string_append(declp, *mangled);
#line 2891
      tmp___19 = strlen(*mangled);
#line 2891
      *mangled += tmp___19;
#line 2892
      success = 1;
      }
    } else
#line 2888
    if (work->destructor == 2) {
      {
#line 2890
      string_append(declp, *mangled);
#line 2891
      tmp___19 = strlen(*mangled);
#line 2891
      *mangled += tmp___19;
#line 2892
      success = 1;
      }
    }
  }
#line 2894
  return (success);
}
}
#line 2925 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int gnu_special(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int n ;
  int success ;
  char const   *p ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  int delta ;
  char *method ;
  char *tmp___10 ;
  char buf___7[50] ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 2929
  success = 1;
#line 2932
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 2932
    tmp___17 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 1));
    }
#line 2932
    if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 2932
      if ((int const   )*(*mangled + 2) == 95) {
#line 2937
        *mangled += 3;
#line 2938
        (work->destructor) ++;
      } else {
#line 2932
        goto _L___9;
      }
    } else {
#line 2932
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2940
  if ((int const   )*(*mangled + 0) == 95) {
#line 2940
    if ((int const   )*(*mangled + 1) == 95) {
#line 2940
      if ((int const   )*(*mangled + 2) == 118) {
#line 2940
        if ((int const   )*(*mangled + 3) == 116) {
#line 2940
          if ((int const   )*(*mangled + 4) == 95) {
#line 2940
            goto _L___4;
          } else {
#line 2940
            goto _L___7;
          }
        } else {
#line 2940
          goto _L___7;
        }
      } else {
#line 2940
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 2940
    if ((int const   )*(*mangled + 1) == 118) {
#line 2940
      if ((int const   )*(*mangled + 2) == 116) {
        {
#line 2940
        tmp___16 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 3));
        }
#line 2940
        if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
          _L___4: /* CIL Label */ 
#line 2953
          if ((int const   )*(*mangled + 2) == 118) {
#line 2954
            *mangled += 5;
          } else {
#line 2956
            *mangled += 4;
          }
          {
#line 2957
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2957
            if (! ((int const   )*(*mangled) != 0)) {
#line 2957
              goto while_break;
            }
            {
#line 2962
            if ((int const   )*(*mangled) == 75) {
#line 2962
              goto case_75;
            }
#line 2962
            if ((int const   )*(*mangled) == 81) {
#line 2962
              goto case_75;
            }
#line 2965
            if ((int const   )*(*mangled) == 116) {
#line 2965
              goto case_116;
            }
#line 2969
            goto switch_default;
            case_75: /* CIL Label */ 
            case_81: /* CIL Label */ 
            {
#line 2963
            success = demangle_qualified(work, mangled, declp, 0, 1);
            }
#line 2964
            goto switch_break;
            case_116: /* CIL Label */ 
            {
#line 2966
            success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
            }
#line 2968
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 2970
            if ((int const   )_sch_istable[(int )((unsigned char )*(*(mangled + 0))) & 255] & 4) {
              {
#line 2972
              n = consume_count(mangled);
#line 2977
              tmp___0 = strlen(*mangled);
              }
#line 2977
              if (n > (int )tmp___0) {
#line 2979
                success = 1;
#line 2980
                goto switch_break;
              }
            } else {
              {
#line 2985
              tmp___1 = strcspn(*mangled, (char const   *)(cplus_markers));
#line 2985
              n = (int )tmp___1;
              }
            }
            {
#line 2987
            string_appendn(declp, *mangled, n);
#line 2988
            *mangled += n;
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 2991
            tmp___2 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 2991
            p = (char const   *)tmp___2;
            }
#line 2992
            if (success) {
#line 2992
              if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2992
                goto _L;
              } else
#line 2992
              if ((unsigned long )p == (unsigned long )*mangled) {
                _L: /* CIL Label */ 
#line 2994
                if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2996
                  if (work->options & (1 << 2)) {
#line 2996
                    tmp___3 = ".";
                  } else {
#line 2996
                    tmp___3 = "::";
                  }
                  {
#line 2996
                  string_append(declp, tmp___3);
#line 2997
                  (*mangled) ++;
                  }
                }
              } else {
#line 3002
                success = 0;
#line 3003
                goto while_break;
              }
            } else {
#line 3002
              success = 0;
#line 3003
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 3006
          if (success) {
            {
#line 3007
            string_append(declp, " virtual table");
            }
          }
        } else {
#line 2940
          goto _L___3;
        }
      } else {
#line 2940
        goto _L___3;
      }
    } else {
#line 2940
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3009
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 3009
    tmp___14 = strchr("0123456789Qt", (int )*(*mangled + 1));
    }
#line 3009
    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
      {
#line 3009
      tmp___15 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 3009
      p = (char const   *)tmp___15;
      }
#line 3009
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 3014
        (*mangled) ++;
        {
#line 3018
        if ((int const   )*(*mangled) == 75) {
#line 3018
          goto case_75___0;
        }
#line 3018
        if ((int const   )*(*mangled) == 81) {
#line 3018
          goto case_75___0;
        }
#line 3021
        if ((int const   )*(*mangled) == 116) {
#line 3021
          goto case_116___0;
        }
#line 3024
        goto switch_default___0;
        case_75___0: /* CIL Label */ 
        case_81___0: /* CIL Label */ 
        {
#line 3019
        success = demangle_qualified(work, mangled, declp, 0, 1);
        }
#line 3020
        goto switch_break___0;
        case_116___0: /* CIL Label */ 
        {
#line 3022
        success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
        }
#line 3023
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 3025
        n = consume_count(mangled);
        }
#line 3026
        if (n < 0) {
#line 3028
          success = 0;
#line 3029
          goto switch_break___0;
        } else {
          {
#line 3026
          tmp___4 = strlen(*mangled);
          }
#line 3026
          if ((long )n > (long )tmp___4) {
#line 3028
            success = 0;
#line 3029
            goto switch_break___0;
          }
        }
#line 3032
        if (n > 10) {
          {
#line 3032
          tmp___6 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
          }
#line 3032
          if (tmp___6 == 0) {
#line 3032
            if ((int const   )*(*mangled + 9) == 78) {
#line 3032
              if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
                {
#line 3032
                tmp___7 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
                }
#line 3032
                if (tmp___7) {
                  {
#line 3041
                  string_append(declp, "{anonymous}");
#line 3042
                  *mangled += n;
#line 3046
                  tmp___5 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 3046
                  p = (char const   *)tmp___5;
                  }
#line 3047
                  goto switch_break___0;
                }
              }
            }
          }
        }
        {
#line 3050
        string_appendn(declp, *mangled, n);
#line 3051
        *mangled += n;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 3053
        if (success) {
#line 3053
          if ((unsigned long )p == (unsigned long )*mangled) {
#line 3057
            (*mangled) ++;
#line 3058
            if (work->options & (1 << 2)) {
#line 3058
              tmp___8 = ".";
            } else {
#line 3058
              tmp___8 = "::";
            }
            {
#line 3058
            string_append(declp, tmp___8);
#line 3059
            tmp___9 = strlen(*mangled);
#line 3059
            n = (int )tmp___9;
#line 3060
            string_appendn(declp, *mangled, n);
#line 3061
            *mangled += n;
            }
          } else {
#line 3065
            success = 0;
          }
        } else {
#line 3065
          success = 0;
        }
      } else {
#line 3009
        goto _L___2;
      }
    } else {
#line 3009
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 3068
    tmp___13 = strncmp(*mangled, "__thunk_", (size_t )8);
    }
#line 3068
    if (tmp___13 == 0) {
      {
#line 3072
      *mangled += 8;
#line 3073
      delta = consume_count(mangled);
      }
#line 3074
      if (delta == -1) {
#line 3075
        success = 0;
      } else {
        {
#line 3078
        (*mangled) ++;
#line 3078
        tmp___10 = internal_cplus_demangle(work, *mangled);
#line 3078
        method = tmp___10;
        }
#line 3080
        if (method) {
          {
#line 3083
          sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"virtual function thunk (delta:%d) for ",
                  - delta);
#line 3084
          string_append(declp, (char const   *)(buf___7));
#line 3085
          string_append(declp, (char const   *)method);
#line 3086
          free((void *)method);
#line 3087
          tmp___11 = strlen(*mangled);
#line 3087
          n = (int )tmp___11;
#line 3088
          *mangled += n;
          }
        } else {
#line 3092
          success = 0;
        }
      }
    } else {
      {
#line 3096
      tmp___12 = strncmp(*mangled, "__t", (size_t )3);
      }
#line 3096
      if (tmp___12 == 0) {
#line 3096
        if ((int const   )*(*mangled + 3) == 105) {
#line 3096
          goto _L___0;
        } else
#line 3096
        if ((int const   )*(*mangled + 3) == 102) {
          _L___0: /* CIL Label */ 
#line 3099
          if ((int const   )*(*mangled + 3) == 105) {
#line 3099
            p = " type_info node";
          } else {
#line 3099
            p = " type_info function";
          }
#line 3100
          *mangled += 4;
          {
#line 3104
          if ((int const   )*(*mangled) == 75) {
#line 3104
            goto case_75___1;
          }
#line 3104
          if ((int const   )*(*mangled) == 81) {
#line 3104
            goto case_75___1;
          }
#line 3107
          if ((int const   )*(*mangled) == 116) {
#line 3107
            goto case_116___1;
          }
#line 3110
          goto switch_default___1;
          case_75___1: /* CIL Label */ 
          case_81___1: /* CIL Label */ 
          {
#line 3105
          success = demangle_qualified(work, mangled, declp, 0, 1);
          }
#line 3106
          goto switch_break___1;
          case_116___1: /* CIL Label */ 
          {
#line 3108
          success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
          }
#line 3109
          goto switch_break___1;
          switch_default___1: /* CIL Label */ 
          {
#line 3111
          success = do_type(work, mangled, declp);
          }
#line 3112
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 3114
          if (success) {
#line 3114
            if ((int const   )*(*mangled) != 0) {
#line 3115
              success = 0;
            }
          }
#line 3116
          if (success) {
            {
#line 3117
            string_append(declp, p);
            }
          }
        } else {
#line 3121
          success = 0;
        }
      } else {
#line 3121
        success = 0;
      }
    }
  }
#line 3123
  return (success);
}
}
#line 3126 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string *result , int namelength ) 
{ 
  char *recurse ;
  char *recurse_dem ;
  void *tmp___0 ;

  {
  {
#line 3130
  recurse = (char *)((void *)0);
#line 3131
  recurse_dem = (char *)((void *)0);
#line 3133
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(namelength + 1));
#line 3133
  recurse = (char *)tmp___0;
#line 3134
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )namelength);
#line 3135
  *(recurse + namelength) = (char )'\000';
#line 3137
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 3139
  if (recurse_dem) {
    {
#line 3141
    string_append(result, (char const   *)recurse_dem);
#line 3142
    free((void *)recurse_dem);
    }
  } else {
    {
#line 3146
    string_appendn(result, *mangled, namelength);
    }
  }
  {
#line 3148
  free((void *)recurse);
#line 3149
  *mangled += namelength;
  }
#line 3150
  return;
}
}
#line 3175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int arm_special(char const   **mangled , string *declp ) 
{ 
  int n ;
  int success ;
  char const   *scan ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3179
  success = 1;
#line 3182
  tmp___1 = strncmp(*mangled, "__vtbl__", (size_t )8);
  }
#line 3182
  if (tmp___1 == 0) {
#line 3188
    scan = *mangled + 8;
    {
#line 3189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3189
      if (! ((int const   )*scan != 0)) {
#line 3189
        goto while_break;
      }
      {
#line 3191
      n = consume_count(& scan);
      }
#line 3192
      if (n == -1) {
#line 3194
        return (0);
      }
#line 3196
      scan += n;
#line 3197
      if ((int const   )*(scan + 0) == 95) {
#line 3197
        if ((int const   )*(scan + 1) == 95) {
#line 3199
          scan += 2;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3202
    *mangled += 8;
    {
#line 3203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3203
      if (! ((int const   )*(*mangled) != 0)) {
#line 3203
        goto while_break___0;
      }
      {
#line 3205
      n = consume_count(mangled);
      }
#line 3206
      if (n == -1) {
#line 3208
        return (0);
      } else {
        {
#line 3206
        tmp___0 = strlen(*mangled);
        }
#line 3206
        if ((long )n > (long )tmp___0) {
#line 3208
          return (0);
        }
      }
      {
#line 3209
      string_prependn(declp, *mangled, n);
#line 3210
      *mangled += n;
      }
#line 3211
      if ((int const   )*(*mangled + 0) == 95) {
#line 3211
        if ((int const   )*(*mangled + 1) == 95) {
          {
#line 3213
          string_prepend(declp, "::");
#line 3214
          *mangled += 2;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3217
    string_append(declp, " virtual table");
    }
  } else {
#line 3221
    success = 0;
  }
#line 3223
  return (success);
}
}
#line 3258 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string *result ,
                              int isfuncname , int append ) 
{ 
  int qualifiers ;
  int success ;
  char num[2] ;
  string temp ;
  string last_name ;
  int bindex ;
  int tmp___0 ;
  int tmp___1 ;
  int idx___0 ;
  int remember_K ;
  int idx___1 ;
  int namelength ;
  long tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 3262
  qualifiers = 0;
#line 3263
  success = 1;
#line 3267
  tmp___0 = register_Btype(work);
#line 3267
  bindex = tmp___0;
  }
#line 3271
  if (isfuncname) {
#line 3271
    if (work->constructor & 1) {
#line 3271
      tmp___1 = 1;
    } else
#line 3271
    if (work->destructor & 1) {
#line 3271
      tmp___1 = 1;
    } else {
#line 3271
      tmp___1 = 0;
    }
  } else {
#line 3271
    tmp___1 = 0;
  }
  {
#line 3271
  isfuncname = tmp___1;
#line 3274
  string_init(& temp);
#line 3275
  string_init(& last_name);
  }
#line 3277
  if ((int const   )*(*mangled + 0) == 75) {
    {
#line 3281
    (*mangled) ++;
#line 3282
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 3283
    if (idx___0 == -1) {
#line 3284
      success = 0;
    } else
#line 3283
    if (idx___0 >= work->numk) {
#line 3284
      success = 0;
    } else {
      {
#line 3286
      string_append(& temp, (char const   *)*(work->ktypevec + idx___0));
      }
    }
  } else {
    {
#line 3291
    if ((int const   )*(*mangled + 1) == 95) {
#line 3291
      goto case_95;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 57) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 56) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 55) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 54) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 53) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 52) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 51) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 50) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 49) {
#line 3309
      goto case_57;
    }
#line 3326
    goto switch_default;
    case_95: /* CIL Label */ 
    {
#line 3295
    (*mangled) ++;
#line 3296
    qualifiers = consume_count_with_underscores(mangled);
    }
#line 3297
    if (qualifiers == -1) {
#line 3298
      success = 0;
    }
#line 3299
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 3311
    num[0] = (char )*(*mangled + 1);
#line 3312
    num[1] = (char )'\000';
#line 3313
    qualifiers = atoi((char const   *)(num));
    }
#line 3318
    if ((int const   )*(*mangled + 2) == 95) {
#line 3320
      (*mangled) ++;
    }
#line 3322
    *mangled += 2;
#line 3323
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3327
    success = 0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3330
  if (! success) {
#line 3331
    return (success);
  }
  {
#line 3336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3336
    tmp___4 = qualifiers;
#line 3336
    qualifiers --;
#line 3336
    if (! (tmp___4 > 0)) {
#line 3336
      goto while_break;
    }
    {
#line 3338
    remember_K = 1;
#line 3339
    string_clear(& last_name);
    }
#line 3341
    if ((int const   )*(*(mangled + 0)) == 95) {
#line 3342
      (*mangled) ++;
    }
#line 3344
    if ((int const   )*(*(mangled + 0)) == 116) {
      {
#line 3352
      success = demangle_template(work, mangled, & temp, & last_name, 1, 0);
      }
#line 3354
      if (! success) {
#line 3355
        goto while_break;
      }
    } else
#line 3357
    if ((int const   )*(*(mangled + 0)) == 75) {
      {
#line 3360
      (*mangled) ++;
#line 3361
      idx___1 = consume_count_with_underscores(mangled);
      }
#line 3362
      if (idx___1 == -1) {
#line 3363
        success = 0;
      } else
#line 3362
      if (idx___1 >= work->numk) {
#line 3363
        success = 0;
      } else {
        {
#line 3365
        string_append(& temp, (char const   *)*(work->ktypevec + idx___1));
        }
      }
#line 3366
      remember_K = 0;
#line 3368
      if (! success) {
#line 3368
        goto while_break;
      }
    } else
#line 3372
    if (work->options & (1 << 13)) {
      {
#line 3378
      namelength = consume_count(mangled);
      }
#line 3379
      if (namelength == -1) {
#line 3381
        success = 0;
#line 3382
        goto while_break;
      }
      {
#line 3384
      recursively_demangle(work, mangled, & temp, namelength);
      }
    } else {
      {
#line 3388
      string_delete(& last_name);
#line 3389
      success = do_type(work, mangled, & last_name);
      }
#line 3390
      if (! success) {
#line 3391
        goto while_break;
      }
      {
#line 3392
      string_appends(& temp, & last_name);
      }
    }
#line 3396
    if (remember_K) {
#line 3397
      if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3397
        tmp___2 = 0L;
      } else {
#line 3397
        tmp___2 = temp.p - temp.b;
      }
      {
#line 3397
      remember_Ktype(work, (char const   *)temp.b, (int )tmp___2);
      }
    }
#line 3399
    if (qualifiers > 0) {
#line 3400
      if (work->options & (1 << 2)) {
#line 3400
        tmp___3 = ".";
      } else {
#line 3400
        tmp___3 = "::";
      }
      {
#line 3400
      string_append(& temp, tmp___3);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3403
  if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3403
    tmp___5 = 0L;
  } else {
#line 3403
    tmp___5 = temp.p - temp.b;
  }
  {
#line 3403
  remember_Btype(work, (char const   *)temp.b, (int )tmp___5, bindex);
  }
#line 3410
  if (isfuncname) {
#line 3412
    if (work->options & (1 << 2)) {
#line 3412
      tmp___6 = ".";
    } else {
#line 3412
      tmp___6 = "::";
    }
    {
#line 3412
    string_append(& temp, tmp___6);
    }
#line 3413
    if (work->destructor & 1) {
      {
#line 3414
      string_append(& temp, "~");
      }
    }
    {
#line 3415
    string_appends(& temp, & last_name);
    }
  }
#line 3421
  if (append) {
    {
#line 3422
    string_appends(result, & temp);
    }
  } else {
#line 3425
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
#line 3426
      if (work->options & (1 << 2)) {
#line 3426
        tmp___7 = ".";
      } else {
#line 3426
        tmp___7 = "::";
      }
      {
#line 3426
      string_append(& temp, tmp___7);
      }
    }
    {
#line 3427
    string_prepends(result, & temp);
    }
  }
  {
#line 3430
  string_delete(& last_name);
#line 3431
  string_delete(& temp);
  }
#line 3432
  return (success);
}
}
#line 3481 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int get_count(char const   **type , int *count ) 
{ 
  char const   *p ;
  int n ;

  {
#line 3487
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 3488
    return (0);
  } else {
#line 3491
    *count = (int )((int const   )*(*type) - 48);
#line 3492
    (*type) ++;
#line 3493
    if ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4) {
#line 3495
      p = *type;
#line 3496
      n = *count;
      {
#line 3497
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3499
        n *= 10;
#line 3500
        n += (int )((int const   )*p - 48);
#line 3501
        p ++;
#line 3497
        if (! ((int const   )_sch_istable[(int )((unsigned char )*p) & 255] & 4)) {
#line 3497
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3504
      if ((int const   )*p == 95) {
#line 3506
        *type = p + 1;
#line 3507
        *count = n;
      }
    }
  }
#line 3511
  return (1);
}
}
#line 3517 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int do_type(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  int n ;
  int done___0 ;
  int success ;
  string decl ;
  char const   *remembered_type ;
  int type_quals ;
  type_kind_t tk ;
  int member ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  string temp ;
  string temp___0 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int idx___0 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
  {
#line 3526
  tk = (type_kind_t )0;
#line 3528
  string_init(& decl);
#line 3529
  string_init(result);
#line 3531
  done___0 = 0;
#line 3532
  success = 1;
  }
  {
#line 3533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3533
    if (success) {
#line 3533
      if (! (! done___0)) {
#line 3533
        goto while_break;
      }
    } else {
#line 3533
      goto while_break;
    }
    {
#line 3541
    if ((int const   )*(*mangled) == 112) {
#line 3541
      goto case_112;
    }
#line 3541
    if ((int const   )*(*mangled) == 80) {
#line 3541
      goto case_112;
    }
#line 3550
    if ((int const   )*(*mangled) == 82) {
#line 3550
      goto case_82;
    }
#line 3558
    if ((int const   )*(*mangled) == 65) {
#line 3558
      goto case_65;
    }
#line 3578
    if ((int const   )*(*mangled) == 84) {
#line 3578
      goto case_84;
    }
#line 3592
    if ((int const   )*(*mangled) == 70) {
#line 3592
      goto case_70;
    }
#line 3614
    if ((int const   )*(*mangled) == 79) {
#line 3614
      goto case_79;
    }
#line 3614
    if ((int const   )*(*mangled) == 77) {
#line 3614
      goto case_79;
    }
#line 3715
    if ((int const   )*(*mangled) == 71) {
#line 3715
      goto case_71;
    }
#line 3721
    if ((int const   )*(*mangled) == 117) {
#line 3721
      goto case_117___0;
    }
#line 3721
    if ((int const   )*(*mangled) == 86) {
#line 3721
      goto case_117___0;
    }
#line 3721
    if ((int const   )*(*mangled) == 67) {
#line 3721
      goto case_117___0;
    }
#line 3736
    goto switch_default___0;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 3542
    (*mangled) ++;
#line 3543
    if (! (work->options & (1 << 2))) {
      {
#line 3544
      string_prepend(& decl, "*");
      }
    }
#line 3545
    if ((unsigned int )tk == 0U) {
#line 3546
      tk = (type_kind_t )1;
    }
#line 3547
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 3551
    (*mangled) ++;
#line 3552
    string_prepend(& decl, "&");
    }
#line 3553
    if ((unsigned int )tk == 0U) {
#line 3554
      tk = (type_kind_t )2;
    }
#line 3555
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3560
    (*mangled) ++;
#line 3561
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3561
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3564
        string_prepend(& decl, "(");
#line 3565
        string_append(& decl, ")");
        }
      } else
#line 3561
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3564
        string_prepend(& decl, "(");
#line 3565
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3567
    string_append(& decl, "[");
    }
#line 3568
    if ((int const   )*(*mangled) != 95) {
      {
#line 3569
      success = demangle_template_value_parm(work, mangled, & decl, (type_kind_t )3);
      }
    }
#line 3571
    if ((int const   )*(*mangled) == 95) {
#line 3572
      (*mangled) ++;
    }
    {
#line 3573
    string_append(& decl, "]");
    }
#line 3574
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 3579
    (*mangled) ++;
#line 3580
    tmp___0 = get_count(mangled, & n);
    }
#line 3580
    if (tmp___0) {
#line 3580
      if (n >= work->ntypes) {
#line 3582
        success = 0;
      } else {
#line 3586
        remembered_type = (char const   *)*(work->typevec + n);
#line 3587
        mangled = & remembered_type;
      }
    } else {
#line 3582
      success = 0;
    }
#line 3589
    goto switch_break;
    case_70: /* CIL Label */ 
#line 3593
    (*mangled) ++;
#line 3594
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3594
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3597
        string_prepend(& decl, "(");
#line 3598
        string_append(& decl, ")");
        }
      } else
#line 3594
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3597
        string_prepend(& decl, "(");
#line 3598
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3603
    tmp___1 = demangle_nested_args(work, mangled, & decl);
    }
#line 3603
    if (tmp___1) {
#line 3603
      if ((int const   )*(*mangled) != 95) {
#line 3603
        if ((int const   )*(*mangled) != 0) {
#line 3606
          success = 0;
#line 3607
          goto switch_break;
        }
      }
    } else {
#line 3606
      success = 0;
#line 3607
      goto switch_break;
    }
#line 3609
    if (success) {
#line 3609
      if ((int const   )*(*mangled) == 95) {
#line 3610
        (*mangled) ++;
      }
    }
#line 3611
    goto switch_break;
    case_79: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 3616
    type_quals = 0;
#line 3618
    member = (int const   )*(*mangled) == 77;
#line 3619
    (*mangled) ++;
#line 3621
    string_append(& decl, ")");
    }
#line 3625
    if ((int const   )*(*mangled) != 81) {
#line 3626
      if (work->options & (1 << 2)) {
#line 3626
        tmp___2 = ".";
      } else {
#line 3626
        tmp___2 = "::";
      }
      {
#line 3626
      string_prepend(& decl, tmp___2);
      }
    }
#line 3628
    if ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4) {
      {
#line 3630
      n = consume_count(mangled);
      }
#line 3631
      if (n == -1) {
#line 3634
        success = 0;
#line 3635
        goto switch_break;
      } else {
        {
#line 3631
        tmp___3 = strlen(*mangled);
        }
#line 3631
        if ((int )tmp___3 < n) {
#line 3634
          success = 0;
#line 3635
          goto switch_break;
        }
      }
      {
#line 3637
      string_prependn(& decl, *mangled, n);
#line 3638
      *mangled += n;
      }
    } else
#line 3640
    if ((int const   )*(*mangled) == 88) {
      {
#line 3643
      do_type(work, mangled, & temp);
#line 3644
      string_prepends(& decl, & temp);
#line 3645
      string_delete(& temp);
      }
    } else
#line 3640
    if ((int const   )*(*mangled) == 89) {
      {
#line 3643
      do_type(work, mangled, & temp);
#line 3644
      string_prepends(& decl, & temp);
#line 3645
      string_delete(& temp);
      }
    } else
#line 3647
    if ((int const   )*(*mangled) == 116) {
      {
#line 3650
      string_init(& temp___0);
#line 3651
      success = demangle_template(work, mangled, & temp___0, (string *)((void *)0),
                                  1, 1);
      }
#line 3653
      if (success) {
        {
#line 3655
        string_prependn(& decl, (char const   *)temp___0.b, (int )(temp___0.p - temp___0.b));
#line 3656
        string_delete(& temp___0);
        }
      } else {
#line 3659
        goto switch_break;
      }
    } else
#line 3661
    if ((int const   )*(*mangled) == 81) {
      {
#line 3663
      success = demangle_qualified(work, mangled, & decl, 0, 0);
      }
#line 3666
      if (! success) {
#line 3667
        goto switch_break;
      }
    } else {
#line 3671
      success = 0;
#line 3672
      goto switch_break;
    }
    {
#line 3675
    string_prepend(& decl, "(");
    }
#line 3676
    if (member) {
      {
#line 3682
      if ((int const   )*(*mangled) == 117) {
#line 3682
        goto case_117;
      }
#line 3682
      if ((int const   )*(*mangled) == 86) {
#line 3682
        goto case_117;
      }
#line 3682
      if ((int const   )*(*mangled) == 67) {
#line 3682
        goto case_117;
      }
#line 3687
      goto switch_default;
      case_117: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_67: /* CIL Label */ 
      {
#line 3683
      tmp___4 = code_for_qualifier((int )*(*mangled));
#line 3683
      type_quals |= tmp___4;
#line 3684
      (*mangled) ++;
      }
#line 3685
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 3688
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3691
      tmp___5 = *mangled;
#line 3691
      (*mangled) ++;
#line 3691
      if ((int const   )*tmp___5 != 70) {
#line 3693
        success = 0;
#line 3694
        goto switch_break;
      }
    }
#line 3697
    if (member) {
      {
#line 3697
      tmp___6 = demangle_nested_args(work, mangled, & decl);
      }
#line 3697
      if (tmp___6) {
#line 3697
        goto _L;
      } else {
#line 3700
        success = 0;
#line 3701
        goto switch_break;
      }
    } else
    _L: /* CIL Label */ 
#line 3697
    if ((int const   )*(*mangled) != 95) {
#line 3700
      success = 0;
#line 3701
      goto switch_break;
    }
#line 3703
    (*mangled) ++;
#line 3704
    if (! (work->options & (1 << 1))) {
#line 3706
      goto switch_break;
    }
#line 3708
    if (type_quals != 0) {
#line 3710
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3710
        string_append(& decl, " ");
        }
      }
      {
#line 3711
      tmp___7 = qualifier_string(type_quals);
#line 3711
      string_append(& decl, tmp___7);
      }
    }
#line 3713
    goto switch_break;
    case_71: /* CIL Label */ 
#line 3716
    (*mangled) ++;
#line 3717
    goto switch_break;
    case_117___0: /* CIL Label */ 
    case_86___0: /* CIL Label */ 
    case_67___0: /* CIL Label */ 
#line 3722
    if (work->options & (1 << 1)) {
#line 3724
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3725
        string_prepend(& decl, " ");
        }
      }
      {
#line 3727
      tmp___8 = demangle_qualifier((int )*(*mangled));
#line 3727
      string_prepend(& decl, tmp___8);
      }
    }
#line 3729
    (*mangled) ++;
#line 3730
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 3737
    done___0 = 1;
#line 3738
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3742
  if (success) {
    {
#line 3746
    if ((int const   )*(*mangled) == 75) {
#line 3746
      goto case_75;
    }
#line 3746
    if ((int const   )*(*mangled) == 81) {
#line 3746
      goto case_75;
    }
#line 3753
    if ((int const   )*(*mangled) == 66) {
#line 3753
      goto case_66;
    }
#line 3762
    if ((int const   )*(*mangled) == 89) {
#line 3762
      goto case_89;
    }
#line 3762
    if ((int const   )*(*mangled) == 88) {
#line 3762
      goto case_89;
    }
#line 3787
    goto switch_default___1;
    case_75: /* CIL Label */ 
    case_81: /* CIL Label */ 
    {
#line 3748
    success = demangle_qualified(work, mangled, result, 0, 1);
    }
#line 3749
    goto switch_break___1;
    case_66: /* CIL Label */ 
    {
#line 3754
    (*mangled) ++;
#line 3755
    tmp___9 = get_count(mangled, & n);
    }
#line 3755
    if (tmp___9) {
#line 3755
      if (n >= work->numb) {
#line 3756
        success = 0;
      } else {
        {
#line 3758
        string_append(result, (char const   *)*(work->btypevec + n));
        }
      }
    } else {
#line 3756
      success = 0;
    }
#line 3759
    goto switch_break___1;
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    {
#line 3767
    (*mangled) ++;
#line 3768
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 3770
    if (idx___0 == -1) {
#line 3774
      success = 0;
#line 3775
      goto switch_break___1;
    } else
#line 3770
    if (work->tmpl_argvec) {
#line 3770
      if (idx___0 >= work->ntmpl_args) {
#line 3774
        success = 0;
#line 3775
        goto switch_break___1;
      } else {
#line 3770
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 3770
      tmp___10 = consume_count_with_underscores(mangled);
      }
#line 3770
      if (tmp___10 == -1) {
#line 3774
        success = 0;
#line 3775
        goto switch_break___1;
      }
    }
#line 3778
    if (work->tmpl_argvec) {
      {
#line 3779
      string_append(result, (char const   *)*(work->tmpl_argvec + idx___0));
      }
    } else {
      {
#line 3781
      string_append_template_idx(result, idx___0);
      }
    }
#line 3783
    success = 1;
#line 3785
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 3788
    success = demangle_fund_type(work, mangled, result);
    }
#line 3789
    if ((unsigned int )tk == 0U) {
#line 3790
      tk = (type_kind_t )success;
    }
#line 3791
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 3794
  if (success) {
#line 3796
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
      {
#line 3798
      string_append(result, " ");
#line 3799
      string_appends(result, & decl);
      }
    }
  } else {
    {
#line 3803
    string_delete(result);
    }
  }
  {
#line 3804
  string_delete(& decl);
  }
#line 3806
  if (success) {
#line 3808
    if ((unsigned int )tk == 0U) {
#line 3808
      tmp___11 = 3U;
    } else {
#line 3808
      tmp___11 = (unsigned int )tk;
    }
#line 3808
    return ((int )tmp___11);
  } else {
#line 3810
    return (0);
  }
}
}
#line 3826 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  int done___0 ;
  int success ;
  char buf___7[37] ;
  unsigned int dec ;
  type_kind_t tk ;
  char const   *tmp___0 ;
  int i ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int bindex ;
  int tmp___4 ;
  string btype ;
  long tmp___5 ;
  int tmp___6 ;
  string btype___0 ;
  int tmp___7 ;

  {
#line 3830
  done___0 = 0;
#line 3831
  success = 1;
#line 3833
  dec = 0U;
#line 3834
  tk = (type_kind_t )3;
  {
#line 3838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3838
    if (! (! done___0)) {
#line 3838
      goto while_break;
    }
    {
#line 3844
    if ((int const   )*(*mangled) == 117) {
#line 3844
      goto case_117;
    }
#line 3844
    if ((int const   )*(*mangled) == 86) {
#line 3844
      goto case_117;
    }
#line 3844
    if ((int const   )*(*mangled) == 67) {
#line 3844
      goto case_117;
    }
#line 3853
    if ((int const   )*(*mangled) == 85) {
#line 3853
      goto case_85;
    }
#line 3858
    if ((int const   )*(*mangled) == 83) {
#line 3858
      goto case_83;
    }
#line 3863
    if ((int const   )*(*mangled) == 74) {
#line 3863
      goto case_74;
    }
#line 3868
    goto switch_default;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 3845
    if (work->options & (1 << 1)) {
#line 3847
      if (! ((unsigned long )result->b == (unsigned long )result->p)) {
        {
#line 3848
        string_prepend(result, " ");
        }
      }
      {
#line 3849
      tmp___0 = demangle_qualifier((int )*(*mangled));
#line 3849
      string_prepend(result, tmp___0);
      }
    }
#line 3851
    (*mangled) ++;
#line 3852
    goto switch_break;
    case_85: /* CIL Label */ 
#line 3854
    (*mangled) ++;
#line 3855
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3855
      string_append(result, " ");
      }
    }
    {
#line 3856
    string_append(result, "unsigned");
    }
#line 3857
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3859
    (*mangled) ++;
#line 3860
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3860
      string_append(result, " ");
      }
    }
    {
#line 3861
    string_append(result, "signed");
    }
#line 3862
    goto switch_break;
    case_74: /* CIL Label */ 
#line 3864
    (*mangled) ++;
#line 3865
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3865
      string_append(result, " ");
      }
    }
    {
#line 3866
    string_append(result, "__complex");
    }
#line 3867
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3869
    done___0 = 1;
#line 3870
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3879
  if ((int const   )*(*mangled) == 95) {
#line 3879
    goto case_95;
  }
#line 3879
  if ((int const   )*(*mangled) == 0) {
#line 3879
    goto case_95;
  }
#line 3881
  if ((int const   )*(*mangled) == 118) {
#line 3881
    goto case_118;
  }
#line 3886
  if ((int const   )*(*mangled) == 120) {
#line 3886
    goto case_120;
  }
#line 3891
  if ((int const   )*(*mangled) == 108) {
#line 3891
    goto case_108;
  }
#line 3896
  if ((int const   )*(*mangled) == 105) {
#line 3896
    goto case_105;
  }
#line 3901
  if ((int const   )*(*mangled) == 115) {
#line 3901
    goto case_115;
  }
#line 3906
  if ((int const   )*(*mangled) == 98) {
#line 3906
    goto case_98;
  }
#line 3912
  if ((int const   )*(*mangled) == 99) {
#line 3912
    goto case_99;
  }
#line 3918
  if ((int const   )*(*mangled) == 119) {
#line 3918
    goto case_119;
  }
#line 3924
  if ((int const   )*(*mangled) == 114) {
#line 3924
    goto case_114;
  }
#line 3930
  if ((int const   )*(*mangled) == 100) {
#line 3930
    goto case_100;
  }
#line 3936
  if ((int const   )*(*mangled) == 102) {
#line 3936
    goto case_102;
  }
#line 3942
  if ((int const   )*(*mangled) == 71) {
#line 3942
    goto case_71;
  }
#line 3949
  if ((int const   )*(*mangled) == 73) {
#line 3949
    goto case_73;
  }
#line 3990
  if ((int const   )*(*mangled) == 57) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 56) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 55) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 54) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 53) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 52) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 51) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 50) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 49) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 48) {
#line 3990
    goto case_57;
  }
#line 4005
  if ((int const   )*(*mangled) == 116) {
#line 4005
    goto case_116;
  }
#line 4014
  goto switch_default___0;
  case_95: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 3880
  goto switch_break___0;
  case_118: /* CIL Label */ 
#line 3882
  (*mangled) ++;
#line 3883
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3883
    string_append(result, " ");
    }
  }
  {
#line 3884
  string_append(result, "void");
  }
#line 3885
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 3887
  (*mangled) ++;
#line 3888
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3888
    string_append(result, " ");
    }
  }
  {
#line 3889
  string_append(result, "long long");
  }
#line 3890
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 3892
  (*mangled) ++;
#line 3893
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3893
    string_append(result, " ");
    }
  }
  {
#line 3894
  string_append(result, "long");
  }
#line 3895
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 3897
  (*mangled) ++;
#line 3898
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3898
    string_append(result, " ");
    }
  }
  {
#line 3899
  string_append(result, "int");
  }
#line 3900
  goto switch_break___0;
  case_115: /* CIL Label */ 
#line 3902
  (*mangled) ++;
#line 3903
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3903
    string_append(result, " ");
    }
  }
  {
#line 3904
  string_append(result, "short");
  }
#line 3905
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 3907
  (*mangled) ++;
#line 3908
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3908
    string_append(result, " ");
    }
  }
  {
#line 3909
  string_append(result, "bool");
#line 3910
  tk = (type_kind_t )4;
  }
#line 3911
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 3913
  (*mangled) ++;
#line 3914
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3914
    string_append(result, " ");
    }
  }
  {
#line 3915
  string_append(result, "char");
#line 3916
  tk = (type_kind_t )5;
  }
#line 3917
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 3919
  (*mangled) ++;
#line 3920
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3920
    string_append(result, " ");
    }
  }
  {
#line 3921
  string_append(result, "wchar_t");
#line 3922
  tk = (type_kind_t )5;
  }
#line 3923
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 3925
  (*mangled) ++;
#line 3926
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3926
    string_append(result, " ");
    }
  }
  {
#line 3927
  string_append(result, "long double");
#line 3928
  tk = (type_kind_t )6;
  }
#line 3929
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 3931
  (*mangled) ++;
#line 3932
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3932
    string_append(result, " ");
    }
  }
  {
#line 3933
  string_append(result, "double");
#line 3934
  tk = (type_kind_t )6;
  }
#line 3935
  goto switch_break___0;
  case_102: /* CIL Label */ 
#line 3937
  (*mangled) ++;
#line 3938
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3938
    string_append(result, " ");
    }
  }
  {
#line 3939
  string_append(result, "float");
#line 3940
  tk = (type_kind_t )6;
  }
#line 3941
  goto switch_break___0;
  case_71: /* CIL Label */ 
#line 3943
  (*mangled) ++;
#line 3944
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 3946
    success = 0;
#line 3947
    goto switch_break___0;
  }
  case_73: /* CIL Label */ 
#line 3950
  (*mangled) ++;
#line 3951
  if ((int const   )*(*mangled) == 95) {
#line 3954
    (*mangled) ++;
#line 3955
    i = 0;
    {
#line 3955
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3955
      if ((long )i < (long )sizeof(buf___7) - 1L) {
#line 3955
        if (*(*mangled)) {
#line 3955
          if (! ((int const   )*(*mangled) != 95)) {
#line 3955
            goto while_break___0;
          }
        } else {
#line 3955
          goto while_break___0;
        }
      } else {
#line 3955
        goto while_break___0;
      }
#line 3958
      buf___7[i] = (char )*(*mangled);
#line 3955
      (*mangled) ++;
#line 3955
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3959
    if ((int const   )*(*mangled) != 95) {
#line 3961
      success = 0;
#line 3962
      goto switch_break___0;
    }
#line 3964
    buf___7[i] = (char )'\000';
#line 3965
    (*mangled) ++;
  } else {
    {
#line 3969
    strncpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)*mangled,
            (size_t )2);
#line 3970
    buf___7[2] = (char )'\000';
#line 3971
    tmp___3 = strlen(*mangled);
    }
#line 3971
    if (tmp___3 < 2UL) {
      {
#line 3971
      tmp___1 = strlen(*mangled);
#line 3971
      tmp___2 = tmp___1;
      }
    } else {
#line 3971
      tmp___2 = (size_t )2;
    }
#line 3971
    *mangled += tmp___2;
  }
  {
#line 3973
  sscanf((char const   */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%x",
         & dec);
#line 3974
  sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"int%u_t",
          dec);
  }
#line 3975
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3975
    string_append(result, " ");
    }
  }
  {
#line 3976
  string_append(result, (char const   *)(buf___7));
  }
#line 3977
  goto switch_break___0;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 3992
  tmp___4 = register_Btype(work);
#line 3992
  bindex = tmp___4;
#line 3994
  string_init(& btype);
#line 3995
  tmp___6 = demangle_class_name(work, mangled, & btype);
  }
#line 3995
  if (tmp___6) {
#line 3996
    if ((unsigned long )btype.b == (unsigned long )btype.p) {
#line 3996
      tmp___5 = 0L;
    } else {
#line 3996
      tmp___5 = btype.p - btype.b;
    }
    {
#line 3996
    remember_Btype(work, (char const   *)btype.b, (int )tmp___5, bindex);
    }
#line 3997
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3997
      string_append(result, " ");
      }
    }
    {
#line 3998
    string_appends(result, & btype);
    }
  } else {
#line 4001
    success = 0;
  }
  {
#line 4002
  string_delete(& btype);
  }
#line 4003
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 4008
  string_init(& btype___0);
#line 4009
  success = demangle_template(work, mangled, & btype___0, (string *)0, 1, 1);
#line 4010
  string_appends(result, & btype___0);
#line 4011
  string_delete(& btype___0);
  }
#line 4012
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 4015
  success = 0;
#line 4016
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 4019
  if (success) {
#line 4019
    tmp___7 = (int )tk;
  } else {
#line 4019
    tmp___7 = 0;
  }
#line 4019
  return (tmp___7);
}
}
#line 4026 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string *result ) 
{ 
  int unsigned_const ;

  {
#line 4032
  if ((int const   )*(*mangled) != 85) {
#line 4032
    if ((int const   )*(*mangled) != 83) {
#line 4033
      return (0);
    }
  }
#line 4035
  unsigned_const = (int const   )*(*mangled) == 85;
#line 4037
  (*mangled) ++;
  {
#line 4041
  if ((int const   )*(*mangled) == 78) {
#line 4041
    goto case_78;
  }
#line 4044
  if ((int const   )*(*mangled) == 80) {
#line 4044
    goto case_80;
  }
#line 4047
  if ((int const   )*(*mangled) == 77) {
#line 4047
    goto case_77;
  }
#line 4052
  goto switch_default;
  case_78: /* CIL Label */ 
  {
#line 4042
  string_append(result, "-");
  }
  case_80: /* CIL Label */ 
#line 4045
  (*mangled) ++;
#line 4046
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 4049
  string_append(result, "-2147483648");
#line 4050
  (*mangled) ++;
  }
#line 4051
  return (1);
  switch_default: /* CIL Label */ 
#line 4053
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 4057
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 4058
    return (0);
  }
  {
#line 4062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4062
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 4062
      goto while_break;
    }
    {
#line 4064
    char_str[0] = (char )*(*mangled);
#line 4065
    string_append(result, (char const   *)(char_str));
#line 4066
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4069
  if (unsigned_const) {
    {
#line 4070
    string_append(result, "U");
    }
  }
#line 4075
  return (1);
}
}
#line 4081 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string *result ) 
{ 
  int literal_len ;
  char *recurse ;
  char *recurse_dem ;
  void *tmp___0 ;

  {
#line 4085
  literal_len = 0;
#line 4089
  if ((int const   )*(*mangled) != 65) {
#line 4090
    return (0);
  }
  {
#line 4092
  (*mangled) ++;
#line 4094
  literal_len = consume_count(mangled);
  }
#line 4096
  if (literal_len <= 0) {
#line 4097
    return (0);
  }
  {
#line 4101
  string_append(result, "&");
#line 4104
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(literal_len + 1));
#line 4104
  recurse = (char *)tmp___0;
#line 4105
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )literal_len);
#line 4106
  *(recurse + literal_len) = (char )'\000';
#line 4108
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 4110
  if (recurse_dem) {
    {
#line 4112
    string_append(result, (char const   *)recurse_dem);
#line 4113
    free((void *)recurse_dem);
    }
  } else {
    {
#line 4117
    string_appendn(result, *mangled, literal_len);
    }
  }
  {
#line 4119
  *mangled += literal_len;
#line 4120
  free((void *)recurse);
  }
#line 4122
  return (1);
}
}
#line 4125 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int snarf_numeric_literal(char const   **args , string *arg ) 
{ 


  {
#line 4128
  if ((int const   )*(*args) == 45) {
    {
#line 4130
    char_str[0] = (char )'-';
#line 4131
    string_append(arg, (char const   *)(char_str));
#line 4132
    (*args) ++;
    }
  } else
#line 4134
  if ((int const   )*(*args) == 43) {
#line 4135
    (*args) ++;
  }
#line 4137
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4138
    return (0);
  }
  {
#line 4140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4140
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4140
      goto while_break;
    }
    {
#line 4142
    char_str[0] = (char )*(*args);
#line 4143
    string_append(arg, (char const   *)(char_str));
#line 4144
    (*args) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4147
  return (1);
}
}
#line 4154 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int do_arg(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  char const   *start ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 4159
  start = *mangled;
#line 4161
  string_init(result);
  }
#line 4163
  if (work->nrepeats > 0) {
#line 4165
    (work->nrepeats) --;
#line 4167
    if ((unsigned long )work->previous_argument == (unsigned long )((string *)0)) {
#line 4168
      return (0);
    }
    {
#line 4171
    string_appends(result, work->previous_argument);
    }
#line 4172
    return (1);
  }
#line 4175
  if ((int const   )*(*mangled) == 110) {
    {
#line 4178
    (*mangled) ++;
#line 4179
    work->nrepeats = consume_count(mangled);
    }
#line 4181
    if (work->nrepeats <= 0) {
#line 4183
      return (0);
    }
#line 4185
    if (work->nrepeats > 9) {
#line 4187
      if ((int const   )*(*mangled) != 95) {
#line 4190
        return (0);
      } else {
#line 4192
        (*mangled) ++;
      }
    }
    {
#line 4196
    tmp___0 = do_arg(work, mangled, result);
    }
#line 4196
    return (tmp___0);
  }
#line 4203
  if (work->previous_argument) {
    {
#line 4204
    string_delete(work->previous_argument);
    }
  } else {
    {
#line 4206
    tmp___1 = xmalloc(sizeof(string ));
#line 4206
    work->previous_argument = (string *)tmp___1;
    }
  }
  {
#line 4208
  tmp___2 = do_type(work, mangled, work->previous_argument);
  }
#line 4208
  if (! tmp___2) {
#line 4209
    return (0);
  }
  {
#line 4211
  string_appends(result, work->previous_argument);
#line 4213
  remember_type(work, start, (int )(*mangled - start));
  }
#line 4214
  return (1);
}
}
#line 4217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void remember_type(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 4222
  if (work->forgetting_types) {
#line 4223
    return;
  }
#line 4225
  if (work->ntypes >= work->typevec_size) {
#line 4227
    if (work->typevec_size == 0) {
      {
#line 4229
      work->typevec_size = 3;
#line 4230
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->typevec_size);
#line 4230
      work->typevec = (char **)tmp___0;
      }
    } else {
      {
#line 4234
      work->typevec_size *= 2;
#line 4235
      tmp___1 = xrealloc((void *)work->typevec, sizeof(char *) * (unsigned long )work->typevec_size);
#line 4235
      work->typevec = (char **)tmp___1;
      }
    }
  }
  {
#line 4239
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4239
  tem = (char *)tmp___2;
#line 4240
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4241
  *(tem + len) = (char )'\000';
#line 4242
  tmp___3 = work->ntypes;
#line 4242
  (work->ntypes) ++;
#line 4242
  *(work->typevec + tmp___3) = tem;
  }
#line 4243
  return;
}
}
#line 4247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 4252
  if (work->numk >= work->ksize) {
#line 4254
    if (work->ksize == 0) {
      {
#line 4256
      work->ksize = 5;
#line 4257
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->ksize);
#line 4257
      work->ktypevec = (char **)tmp___0;
      }
    } else {
      {
#line 4261
      work->ksize *= 2;
#line 4262
      tmp___1 = xrealloc((void *)work->ktypevec, sizeof(char *) * (unsigned long )work->ksize);
#line 4262
      work->ktypevec = (char **)tmp___1;
      }
    }
  }
  {
#line 4266
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4266
  tem = (char *)tmp___2;
#line 4267
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4268
  *(tem + len) = (char )'\000';
#line 4269
  tmp___3 = work->numk;
#line 4269
  (work->numk) ++;
#line 4269
  *(work->ktypevec + tmp___3) = tem;
  }
#line 4270
  return;
}
}
#line 4276 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int register_Btype(struct work_stuff *work ) 
{ 
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 4281
  if (work->numb >= work->bsize) {
#line 4283
    if (work->bsize == 0) {
      {
#line 4285
      work->bsize = 5;
#line 4286
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->bsize);
#line 4286
      work->btypevec = (char **)tmp___0;
      }
    } else {
      {
#line 4290
      work->bsize *= 2;
#line 4291
      tmp___1 = xrealloc((void *)work->btypevec, sizeof(char *) * (unsigned long )work->bsize);
#line 4291
      work->btypevec = (char **)tmp___1;
      }
    }
  }
#line 4295
  tmp___2 = work->numb;
#line 4295
  (work->numb) ++;
#line 4295
  ret = tmp___2;
#line 4296
  *(work->btypevec + ret) = (char *)((void *)0);
#line 4297
  return (ret);
}
}
#line 4302 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) 
{ 
  char *tem ;
  void *tmp___0 ;

  {
  {
#line 4308
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4308
  tem = (char *)tmp___0;
#line 4309
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4310
  *(tem + len) = (char )'\000';
#line 4311
  *(work->btypevec + index___0) = tem;
  }
#line 4312
  return;
}
}
#line 4315 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void forget_B_and_K_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4320
    if (! (work->numk > 0)) {
#line 4320
      goto while_break;
    }
#line 4322
    (work->numk) --;
#line 4322
    i = work->numk;
#line 4323
    if ((unsigned long )*(work->ktypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4325
      free((void *)*(work->ktypevec + i));
#line 4326
      *(work->ktypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4330
    if (! (work->numb > 0)) {
#line 4330
      goto while_break___0;
    }
#line 4332
    (work->numb) --;
#line 4332
    i = work->numb;
#line 4333
    if ((unsigned long )*(work->btypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4335
      free((void *)*(work->btypevec + i));
#line 4336
      *(work->btypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4339
  return;
}
}
#line 4342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void forget_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4347
    if (! (work->ntypes > 0)) {
#line 4347
      goto while_break;
    }
#line 4349
    (work->ntypes) --;
#line 4349
    i = work->ntypes;
#line 4350
    if ((unsigned long )*(work->typevec + i) != (unsigned long )((void *)0)) {
      {
#line 4352
      free((void *)*(work->typevec + i));
#line 4353
      *(work->typevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4356
  return;
}
}
#line 4400 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_args(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  string arg ;
  int need_comma ;
  int r ;
  int t ;
  char const   *tem ;
  char temptype ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4405
  need_comma = 0;
#line 4411
  if (work->options & 1) {
    {
#line 4413
    string_append(declp, "(");
    }
#line 4414
    if ((int const   )*(*mangled) == 0) {
      {
#line 4416
      string_append(declp, "void");
      }
    }
  }
  {
#line 4420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4420
    if ((int const   )*(*mangled) != 95) {
#line 4420
      if ((int const   )*(*mangled) != 0) {
#line 4420
        if (! ((int const   )*(*mangled) != 101)) {
#line 4420
          goto _L___3;
        }
      } else {
#line 4420
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 4420
    if (! (work->nrepeats > 0)) {
#line 4420
      goto while_break;
    }
#line 4423
    if ((int const   )*(*mangled) == 78) {
#line 4423
      goto _L___1;
    } else
#line 4423
    if ((int const   )*(*mangled) == 84) {
      _L___1: /* CIL Label */ 
#line 4425
      tmp___0 = *mangled;
#line 4425
      (*mangled) ++;
#line 4425
      temptype = (char )*tmp___0;
#line 4427
      if ((int )temptype == 78) {
        {
#line 4429
        tmp___1 = get_count(mangled, & r);
        }
#line 4429
        if (! tmp___1) {
#line 4431
          return (0);
        }
      } else {
#line 4436
        r = 1;
      }
#line 4438
      if (work->options & (1 << 12)) {
#line 4438
        goto _L___0;
      } else
#line 4438
      if (work->options & (1 << 11)) {
#line 4438
        goto _L___0;
      } else
#line 4438
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 4438
        if (work->ntypes >= 10) {
          {
#line 4446
          t = consume_count(mangled);
          }
#line 4446
          if (t <= 0) {
#line 4448
            return (0);
          }
        } else {
#line 4438
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 4453
        tmp___2 = get_count(mangled, & t);
        }
#line 4453
        if (! tmp___2) {
#line 4455
          return (0);
        }
      }
#line 4458
      if (work->options & (1 << 10)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 11)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 12)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 13)) {
#line 4460
        t --;
      }
#line 4464
      if (t < 0) {
#line 4466
        return (0);
      } else
#line 4464
      if (t >= work->ntypes) {
#line 4466
        return (0);
      }
      {
#line 4468
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4468
        if (! (work->nrepeats > 0)) {
#line 4468
          r --;
#line 4468
          if (! (r >= 0)) {
#line 4468
            goto while_break___0;
          }
        }
#line 4470
        tem = (char const   *)*(work->typevec + t);
#line 4471
        if (need_comma) {
#line 4471
          if (work->options & 1) {
            {
#line 4473
            string_append(declp, ", ");
            }
          }
        }
        {
#line 4475
        tmp___3 = do_arg(work, & tem, & arg);
        }
#line 4475
        if (! tmp___3) {
#line 4477
          return (0);
        }
#line 4479
        if (work->options & 1) {
          {
#line 4481
          string_appends(declp, & arg);
          }
        }
        {
#line 4483
        string_delete(& arg);
#line 4484
        need_comma = 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 4489
      if (need_comma) {
#line 4489
        if (work->options & 1) {
          {
#line 4490
          string_append(declp, ", ");
          }
        }
      }
      {
#line 4491
      tmp___4 = do_arg(work, mangled, & arg);
      }
#line 4491
      if (! tmp___4) {
#line 4492
        return (0);
      }
#line 4493
      if (work->options & 1) {
        {
#line 4494
        string_appends(declp, & arg);
        }
      }
      {
#line 4495
      string_delete(& arg);
#line 4496
      need_comma = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4500
  if ((int const   )*(*mangled) == 101) {
#line 4502
    (*mangled) ++;
#line 4503
    if (work->options & 1) {
#line 4505
      if (need_comma) {
        {
#line 4507
        string_append(declp, ",");
        }
      }
      {
#line 4509
      string_append(declp, "...");
      }
    }
  }
#line 4513
  if (work->options & 1) {
    {
#line 4515
    string_append(declp, ")");
    }
  }
#line 4517
  return (1);
}
}
#line 4523 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string *declp ) 
{ 
  string *saved_previous_argument ;
  int result ;
  int saved_nrepeats ;

  {
  {
#line 4535
  (work->forgetting_types) ++;
#line 4539
  saved_previous_argument = work->previous_argument;
#line 4540
  saved_nrepeats = work->nrepeats;
#line 4541
  work->previous_argument = (string *)0;
#line 4542
  work->nrepeats = 0;
#line 4545
  result = demangle_args(work, mangled, declp);
  }
#line 4548
  if (work->previous_argument) {
    {
#line 4550
    string_delete(work->previous_argument);
#line 4551
    free((void *)((char *)work->previous_argument));
    }
  }
#line 4553
  work->previous_argument = saved_previous_argument;
#line 4554
  (work->forgetting_types) --;
#line 4555
  work->nrepeats = saved_nrepeats;
#line 4557
  return (result);
}
}
#line 4562 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static int demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                  string *declp , char const   *scan ) 
{ 
  size_t i ;
  string type ;
  char const   *tem ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int len___0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  long tmp___16 ;

  {
  {
#line 4570
  string_appendn(declp, *mangled, (int )(scan - *mangled));
#line 4571
  string_need(declp, 1);
#line 4572
  *(declp->p) = (char )'\000';
#line 4578
  *mangled = scan + 2;
  }
#line 4584
  if (work->options & (1 << 12)) {
#line 4584
    if ((int const   )*(*mangled) == 88) {
      {
#line 4586
      demangle_arm_hp_template(work, mangled, 0, declp);
      }
    }
  }
#line 4590
  if (work->options & (1 << 10)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 11)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 12)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 13)) {
    _L: /* CIL Label */ 
    {
#line 4598
    tmp___1 = strcmp((char const   *)declp->b, "__ct");
    }
#line 4598
    if (tmp___1 == 0) {
      {
#line 4600
      (work->constructor) ++;
#line 4601
      string_clear(declp);
      }
#line 4602
      return (1);
    } else {
      {
#line 4604
      tmp___0 = strcmp((char const   *)declp->b, "__dt");
      }
#line 4604
      if (tmp___0 == 0) {
        {
#line 4606
        (work->destructor) ++;
#line 4607
        string_clear(declp);
        }
#line 4608
        return (1);
      }
    }
  }
#line 4612
  if (declp->p - declp->b >= 3L) {
#line 4612
    if ((int )*(declp->b + 0) == 111) {
#line 4612
      if ((int )*(declp->b + 1) == 112) {
        {
#line 4612
        tmp___15 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 2));
        }
#line 4612
        if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 4618
          if (declp->p - declp->b >= 10L) {
            {
#line 4618
            tmp___6 = memcmp((void const   *)(declp->b + 3), (void const   *)"assign_",
                             (size_t )7);
            }
#line 4618
            if (tmp___6 == 0) {
#line 4621
              i = (size_t )0;
              {
#line 4621
              while (1) {
                while_continue: /* CIL Label */ ;
#line 4621
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4621
                  goto while_break;
                }
                {
#line 4623
                len = (int )((declp->p - declp->b) - 10L);
#line 4624
                tmp___2 = strlen((char const   *)optable[i].in);
                }
#line 4624
                if ((int )tmp___2 == len) {
                  {
#line 4624
                  tmp___3 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 10),
                                   (size_t )len);
                  }
#line 4624
                  if (tmp___3 == 0) {
                    {
#line 4627
                    string_clear(declp);
#line 4628
                    string_append(declp, "operator");
#line 4629
                    string_append(declp, (char const   *)optable[i].out);
#line 4630
                    string_append(declp, "=");
                    }
#line 4631
                    goto while_break;
                  }
                }
#line 4621
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 4618
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 4637
            i = (size_t )0;
            {
#line 4637
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4637
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4637
                goto while_break___0;
              }
              {
#line 4639
              len___0 = (int )((declp->p - declp->b) - 3L);
#line 4640
              tmp___4 = strlen((char const   *)optable[i].in);
              }
#line 4640
              if ((int )tmp___4 == len___0) {
                {
#line 4640
                tmp___5 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 3),
                                 (size_t )len___0);
                }
#line 4640
                if (tmp___5 == 0) {
                  {
#line 4643
                  string_clear(declp);
#line 4644
                  string_append(declp, "operator");
#line 4645
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4646
                  goto while_break___0;
                }
              }
#line 4637
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        } else {
#line 4612
          goto _L___8;
        }
      } else {
#line 4612
        goto _L___8;
      }
    } else {
#line 4612
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 4651
  if (declp->p - declp->b >= 5L) {
    {
#line 4651
    tmp___13 = memcmp((void const   *)declp->b, (void const   *)"type", (size_t )4);
    }
#line 4651
    if (tmp___13 == 0) {
      {
#line 4651
      tmp___14 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 4));
      }
#line 4651
      if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
        {
#line 4655
        tem = (char const   *)(declp->b + 5);
#line 4656
        tmp___7 = do_type(work, & tem, & type);
        }
#line 4656
        if (tmp___7) {
          {
#line 4658
          string_clear(declp);
#line 4659
          string_append(declp, "operator ");
#line 4660
          string_appends(declp, & type);
#line 4661
          string_delete(& type);
          }
        }
      } else {
#line 4651
        goto _L___5;
      }
    } else {
#line 4651
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 4664
  if ((int )*(declp->b + 0) == 95) {
#line 4664
    if ((int )*(declp->b + 1) == 95) {
#line 4664
      if ((int )*(declp->b + 2) == 111) {
#line 4664
        if ((int )*(declp->b + 3) == 112) {
          {
#line 4669
          tem = (char const   *)(declp->b + 4);
#line 4670
          tmp___8 = do_type(work, & tem, & type);
          }
#line 4670
          if (tmp___8) {
            {
#line 4672
            string_clear(declp);
#line 4673
            string_append(declp, "operator ");
#line 4674
            string_appends(declp, & type);
#line 4675
            string_delete(& type);
            }
          }
        } else {
#line 4664
          goto _L___3;
        }
      } else {
#line 4664
        goto _L___3;
      }
    } else {
#line 4664
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 4678
  if ((int )*(declp->b + 0) == 95) {
#line 4678
    if ((int )*(declp->b + 1) == 95) {
#line 4678
      if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 2)) & 255] & 8) {
#line 4678
        if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 3)) & 255] & 8) {
#line 4682
          if ((int )*(declp->b + 4) == 0) {
#line 4685
            i = (size_t )0;
            {
#line 4685
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4685
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4685
                goto while_break___1;
              }
              {
#line 4687
              tmp___9 = strlen((char const   *)optable[i].in);
              }
#line 4687
              if (tmp___9 == 2UL) {
                {
#line 4687
                tmp___10 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                  (size_t )2);
                }
#line 4687
                if (tmp___10 == 0) {
                  {
#line 4690
                  string_clear(declp);
#line 4691
                  string_append(declp, "operator");
#line 4692
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4693
                  goto while_break___1;
                }
              }
#line 4685
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else
#line 4699
          if ((int )*(declp->b + 2) == 97) {
#line 4699
            if ((int )*(declp->b + 5) == 0) {
#line 4702
              i = (size_t )0;
              {
#line 4702
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4702
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4702
                  goto while_break___2;
                }
                {
#line 4704
                tmp___11 = strlen((char const   *)optable[i].in);
                }
#line 4704
                if (tmp___11 == 3UL) {
                  {
#line 4704
                  tmp___12 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                    (size_t )3);
                  }
#line 4704
                  if (tmp___12 == 0) {
                    {
#line 4707
                    string_clear(declp);
#line 4708
                    string_append(declp, "operator");
#line 4709
                    string_append(declp, (char const   *)optable[i].out);
                    }
#line 4710
                    goto while_break___2;
                  }
                }
#line 4702
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
  }
#line 4719
  if ((unsigned long )declp->b == (unsigned long )declp->p) {
#line 4719
    tmp___16 = 0L;
  } else {
#line 4719
    tmp___16 = declp->p - declp->b;
  }
#line 4719
  if (tmp___16 == 1L) {
#line 4719
    if ((int )*(declp->b + 0) == 46) {
#line 4720
      return (0);
    } else {
#line 4722
      return (1);
    }
  } else {
#line 4722
    return (1);
  }
}
}
#line 4727 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_need(string *s , int n ) 
{ 
  int tem ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 4732
  if ((unsigned long )s->b == (unsigned long )((void *)0)) {
#line 4734
    if (n < 32) {
#line 4736
      n = 32;
    }
    {
#line 4738
    tmp___1 = xmalloc(sizeof(char ) * (unsigned long )n);
#line 4738
    tmp___0 = (char *)tmp___1;
#line 4738
    s->b = tmp___0;
#line 4738
    s->p = tmp___0;
#line 4739
    s->e = s->b + n;
    }
  } else
#line 4741
  if (s->e - s->p < (long )n) {
    {
#line 4743
    tem = (int )(s->p - s->b);
#line 4744
    n += tem;
#line 4745
    n *= 2;
#line 4746
    tmp___2 = xrealloc((void *)s->b, sizeof(char ) * (unsigned long )n);
#line 4746
    s->b = (char *)tmp___2;
#line 4747
    s->p = s->b + tem;
#line 4748
    s->e = s->b + n;
    }
  }
#line 4750
  return;
}
}
#line 4752 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_delete(string *s ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4755
  if ((unsigned long )s->b != (unsigned long )((void *)0)) {
    {
#line 4757
    free((void *)s->b);
#line 4758
    tmp___1 = (char *)((void *)0);
#line 4758
    s->p = tmp___1;
#line 4758
    tmp___0 = tmp___1;
#line 4758
    s->e = tmp___0;
#line 4758
    s->b = tmp___0;
    }
  }
#line 4760
  return;
}
}
#line 4762 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_init(string *s ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4765
  tmp___1 = (char *)((void *)0);
#line 4765
  s->e = tmp___1;
#line 4765
  tmp___0 = tmp___1;
#line 4765
  s->p = tmp___0;
#line 4765
  s->b = tmp___0;
#line 4766
  return;
}
}
#line 4768 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_clear(string *s ) 
{ 


  {
#line 4771
  s->p = s->b;
#line 4772
  return;
}
}
#line 4784 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_append(string *p , char const   *s ) 
{ 
  int n ;
  size_t tmp___0 ;

  {
#line 4788
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 4789
    return;
  } else
#line 4788
  if ((int const   )*s == 0) {
#line 4789
    return;
  }
  {
#line 4790
  tmp___0 = strlen(s);
#line 4790
  n = (int )tmp___0;
#line 4791
  string_need(p, n);
#line 4792
  memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4793
  p->p += n;
  }
#line 4794
  return;
}
}
#line 4796 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_appends(string *p , string *s ) 
{ 
  int n ;

  {
#line 4801
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4803
    n = (int )(s->p - s->b);
#line 4804
    string_need(p, n);
#line 4805
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s->b, (size_t )n);
#line 4806
    p->p += n;
    }
  }
#line 4808
  return;
}
}
#line 4810 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_appendn(string *p , char const   *s , int n ) 
{ 


  {
#line 4813
  if (n != 0) {
    {
#line 4815
    string_need(p, n);
#line 4816
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4817
    p->p += n;
    }
  }
#line 4819
  return;
}
}
#line 4821 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_prepend(string *p , char const   *s ) 
{ 
  size_t tmp___0 ;

  {
#line 4824
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 4824
    if ((int const   )*s != 0) {
      {
#line 4826
      tmp___0 = strlen(s);
#line 4826
      string_prependn(p, s, (int )tmp___0);
      }
    }
  }
#line 4828
  return;
}
}
#line 4830 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_prepends(string *p , string *s ) 
{ 


  {
#line 4833
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4835
    string_prependn(p, (char const   *)s->b, (int )(s->p - s->b));
    }
  }
#line 4837
  return;
}
}
#line 4839 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_prependn(string *p , char const   *s , int n ) 
{ 
  char *q ;

  {
#line 4844
  if (n != 0) {
    {
#line 4846
    string_need(p, n);
#line 4847
    q = p->p - 1;
    }
    {
#line 4847
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4847
      if (! ((unsigned long )q >= (unsigned long )p->b)) {
#line 4847
        goto while_break;
      }
#line 4849
      *(q + n) = *(q + 0);
#line 4847
      q --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4851
    memcpy((void */* __restrict  */)p->b, (void const   */* __restrict  */)s, (size_t )n);
#line 4852
    p->p += n;
    }
  }
#line 4854
  return;
}
}
#line 4856 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cplus-dem.c"
static void string_append_template_idx(string *s , int idx___0 ) 
{ 
  char buf___7[33] ;

  {
  {
#line 4860
  sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"T%d",
          idx___0);
#line 4861
  string_append(s, (char const   *)(buf___7));
  }
#line 4862
  return;
}
}
#line 563 "./../include/demangle.h"
int cplus_demangle_fill_component(struct demangle_component *p , enum demangle_component_type type ,
                                  struct demangle_component *left , struct demangle_component *right ) ;
#line 580
int cplus_demangle_fill_builtin_type(struct demangle_component *p , char const   *type_name ) ;
#line 590
int cplus_demangle_fill_operator(struct demangle_component *p , char const   *opname ,
                                 int args ) ;
#line 627
struct demangle_component *cplus_demangle_v3_components(char const   *mangled , int options___0 ,
                                                        void **mem ) ;
#line 148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.h"
struct demangle_operator_info  const  cplus_demangle_operators[62] ;
#line 153
struct demangle_builtin_type_info  const  cplus_demangle_builtin_types[33] ;
#line 157
struct demangle_component *cplus_demangle_mangled_name(struct d_info *di , int top_level ) ;
#line 161
struct demangle_component *cplus_demangle_type(struct d_info *di ) ;
#line 165
void cplus_demangle_init_info(char const   *mangled , int options___0 , size_t len ,
                              struct d_info *di ) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demint.c"
int cplus_demangle_fill_component(struct demangle_component *p , enum demangle_component_type type ,
                                  struct demangle_component *left , struct demangle_component *right ) 
{ 


  {
#line 64
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 65
    return (0);
  }
  {
#line 86
  if ((unsigned int )type == 60U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 59U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 58U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 57U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 56U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 55U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 54U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 53U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 47U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 46U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 43U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 42U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 41U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 33U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 11U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 4U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 3U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 2U) {
#line 86
    goto case_60;
  }
#line 86
  if ((unsigned int )type == 1U) {
#line 86
    goto case_60;
  }
#line 112
  if ((unsigned int )type == 51U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 40U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 38U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 37U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 35U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 34U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 30U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 29U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 28U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 27U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 26U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 25U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 22U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 19U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 18U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 17U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 16U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 15U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 14U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 13U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 12U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 10U) {
#line 112
    goto case_51;
  }
#line 112
  if ((unsigned int )type == 9U) {
#line 112
    goto case_51;
  }
#line 117
  goto switch_default;
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 87
  goto switch_break;
  case_51: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 113
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 114
    return (0);
  }
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 119
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 122
  p->type = type;
#line 123
  p->u.s_binary.left = left;
#line 124
  p->u.s_binary.right = right;
#line 126
  return (1);
}
}
#line 131 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demint.c"
int cplus_demangle_fill_builtin_type(struct demangle_component *p , char const   *type_name ) 
{ 
  int len ;
  unsigned int i ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 138
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 139
    return (0);
  } else
#line 138
  if ((unsigned long )type_name == (unsigned long )((void *)0)) {
#line 139
    return (0);
  }
  {
#line 140
  tmp___0 = strlen(type_name);
#line 140
  len = (int )tmp___0;
#line 141
  i = 0U;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < 33U)) {
#line 141
      goto while_break;
    }
#line 143
    if (len == (int )cplus_demangle_builtin_types[i].len) {
      {
#line 143
      tmp___1 = strcmp(type_name, (char const   *)cplus_demangle_builtin_types[i].name);
      }
#line 143
      if (tmp___1 == 0) {
#line 146
        p->type = (enum demangle_component_type )39;
#line 147
        p->u.s_builtin.type = & cplus_demangle_builtin_types[i];
#line 148
        return (1);
      }
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (0);
}
}
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demint.c"
int cplus_demangle_fill_operator(struct demangle_component *p , char const   *opname ,
                                 int args ) 
{ 
  int len ;
  unsigned int i ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 163
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 164
    return (0);
  } else
#line 163
  if ((unsigned long )opname == (unsigned long )((void *)0)) {
#line 164
    return (0);
  }
  {
#line 165
  tmp___0 = strlen(opname);
#line 165
  len = (int )tmp___0;
#line 166
  i = 0U;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )cplus_demangle_operators[i].name != (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
#line 168
    if (len == (int )cplus_demangle_operators[i].len) {
#line 168
      if (args == (int )cplus_demangle_operators[i].args) {
        {
#line 168
        tmp___1 = strcmp(opname, (char const   *)cplus_demangle_operators[i].name);
        }
#line 168
        if (tmp___1 == 0) {
#line 172
          p->type = (enum demangle_component_type )49;
#line 173
          p->u.s_operator.op = & cplus_demangle_operators[i];
#line 174
          return (1);
        }
      }
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (0);
}
}
#line 182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demint.c"
struct demangle_component *cplus_demangle_v3_components(char const   *mangled , int options___0 ,
                                                        void **mem ) 
{ 
  size_t len ;
  int type ;
  struct d_info di ;
  struct demangle_component *dc ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 190
  len = strlen(mangled);
  }
#line 192
  if ((int const   )*(mangled + 0) == 95) {
#line 192
    if ((int const   )*(mangled + 1) == 90) {
#line 193
      type = 0;
    } else {
#line 192
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 196
    if ((options___0 & (1 << 4)) == 0) {
#line 197
      return ((struct demangle_component *)((void *)0));
    }
#line 198
    type = 1;
  }
  {
#line 201
  cplus_demangle_init_info(mangled, options___0, len, & di);
#line 203
  tmp___0 = malloc((unsigned long )di.num_comps * sizeof(struct demangle_component ));
#line 203
  di.comps = (struct demangle_component *)tmp___0;
#line 205
  tmp___1 = malloc((unsigned long )di.num_subs * sizeof(struct demangle_component *));
#line 205
  di.subs = (struct demangle_component **)tmp___1;
  }
#line 207
  if ((unsigned long )di.comps == (unsigned long )((void *)0)) {
    {
#line 209
    free((void *)di.comps);
#line 210
    free((void *)di.subs);
    }
#line 211
    return ((struct demangle_component *)((void *)0));
  } else
#line 207
  if ((unsigned long )di.subs == (unsigned long )((void *)0)) {
    {
#line 209
    free((void *)di.comps);
#line 210
    free((void *)di.subs);
    }
#line 211
    return ((struct demangle_component *)((void *)0));
  }
#line 214
  if (! type) {
    {
#line 215
    dc = cplus_demangle_mangled_name(& di, 1);
    }
  } else {
    {
#line 217
    dc = cplus_demangle_type(& di);
    }
  }
#line 221
  if ((options___0 & 1) != 0) {
#line 221
    if ((int const   )*(di.n) != 0) {
#line 222
      dc = (struct demangle_component *)((void *)0);
    }
  }
  {
#line 224
  free((void *)di.subs);
  }
#line 226
  if ((unsigned long )dc != (unsigned long )((void *)0)) {
#line 227
    *mem = (void *)di.comps;
  } else {
    {
#line 229
    free((void *)di.comps);
    }
  }
#line 231
  return (dc);
}
}
#line 155 "./../include/demangle.h"
int cplus_demangle_v3_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) ;
#line 162
int java_demangle_v3_callback(char const   *mangled , void (*callback)(char const   * ,
                                                                       size_t  , void * ) ,
                              void *opaque ) ;
#line 183
enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor(char const   *name___0 ) ;
#line 198
enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor(char const   *name___0 ) ;
#line 572
int cplus_demangle_fill_name(struct demangle_component *p , char const   *s , int len ) ;
#line 598
int cplus_demangle_fill_extended_operator(struct demangle_component *p , int args ,
                                          struct demangle_component *name___0 ) ;
#line 606
int cplus_demangle_fill_ctor(struct demangle_component *p , enum gnu_v3_ctor_kinds kind ,
                             struct demangle_component *name___0 ) ;
#line 614
int cplus_demangle_fill_dtor(struct demangle_component *p , enum gnu_v3_dtor_kinds kind ,
                             struct demangle_component *name___0 ) ;
#line 642
char *cplus_demangle_print(int options___0 , struct demangle_component  const  *dc ,
                           int estimate , size_t *palc ) ;
#line 662
int cplus_demangle_print_callback(int options___0 , struct demangle_component  const  *dc ,
                                  void (*callback)(char const   * , size_t  , void * ) ,
                                  void *opaque ) ;
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_empty(struct d_info *di ) ;
#line 314
static struct demangle_component *d_make_comp(struct d_info *di , enum demangle_component_type type ,
                                              struct demangle_component *left , struct demangle_component *right ) ;
#line 319
static struct demangle_component *d_make_name(struct d_info *di , char const   *s ,
                                              int len ) ;
#line 322
static struct demangle_component *d_make_demangle_mangled_name(struct d_info *di ,
                                                               char const   *s ) ;
#line 325
static struct demangle_component *d_make_builtin_type(struct d_info *di , struct demangle_builtin_type_info  const  *type ) ;
#line 329
static struct demangle_component *d_make_operator(struct d_info *di , struct demangle_operator_info  const  *op ) ;
#line 333
static struct demangle_component *d_make_extended_operator(struct d_info *di , int args ,
                                                           struct demangle_component *name___0 ) ;
#line 337
static struct demangle_component *d_make_ctor(struct d_info *di , enum gnu_v3_ctor_kinds kind ,
                                              struct demangle_component *name___0 ) ;
#line 341
static struct demangle_component *d_make_dtor(struct d_info *di , enum gnu_v3_dtor_kinds kind ,
                                              struct demangle_component *name___0 ) ;
#line 345
static struct demangle_component *d_make_template_param(struct d_info *di , long i ) ;
#line 348
static struct demangle_component *d_make_sub(struct d_info *di , char const   *name___0 ,
                                             int len ) ;
#line 351
static int has_return_type(struct demangle_component *dc ) ;
#line 354
static int is_ctor_dtor_or_conversion(struct demangle_component *dc ) ;
#line 357
static struct demangle_component *d_encoding(struct d_info *di , int top_level ) ;
#line 359
static struct demangle_component *d_name(struct d_info *di ) ;
#line 361
static struct demangle_component *d_nested_name(struct d_info *di ) ;
#line 363
static struct demangle_component *d_prefix(struct d_info *di ) ;
#line 365
static struct demangle_component *d_unqualified_name(struct d_info *di ) ;
#line 367
static struct demangle_component *d_source_name(struct d_info *di ) ;
#line 369
static long d_number(struct d_info *di ) ;
#line 371
static struct demangle_component *d_identifier(struct d_info *di , int len ) ;
#line 373
static struct demangle_component *d_operator_name(struct d_info *di ) ;
#line 375
static struct demangle_component *d_special_name(struct d_info *di ) ;
#line 377
static int d_call_offset(struct d_info *di , int c ) ;
#line 379
static struct demangle_component *d_ctor_dtor_name(struct d_info *di ) ;
#line 381
static struct demangle_component **d_cv_qualifiers(struct d_info *di , struct demangle_component **pret ,
                                                   int member_fn ) ;
#line 384
static struct demangle_component *d_ref_qualifier(struct d_info *di , struct demangle_component *sub ) ;
#line 387
static struct demangle_component *d_function_type(struct d_info *di ) ;
#line 390
static struct demangle_component *d_bare_function_type(struct d_info *di , int has_return_type___0 ) ;
#line 393
static struct demangle_component *d_class_enum_type(struct d_info *di ) ;
#line 396
static struct demangle_component *d_array_type(struct d_info *di ) ;
#line 398
static struct demangle_component *d_vector_type(struct d_info *di ) ;
#line 400
static struct demangle_component *d_pointer_to_member_type(struct d_info *di ) ;
#line 403
static struct demangle_component *d_template_param(struct d_info *di ) ;
#line 406
static struct demangle_component *d_template_args(struct d_info *di ) ;
#line 408
static struct demangle_component *d_template_arg(struct d_info *di ) ;
#line 411
static struct demangle_component *d_expression(struct d_info *di ) ;
#line 413
static struct demangle_component *d_expr_primary(struct d_info *di ) ;
#line 415
static struct demangle_component *d_local_name(struct d_info *di ) ;
#line 417
static int d_discriminator(struct d_info *di ) ;
#line 419
static struct demangle_component *d_lambda(struct d_info *di ) ;
#line 421
static struct demangle_component *d_unnamed_type(struct d_info *di ) ;
#line 423
static struct demangle_component *d_clone_suffix(struct d_info *di , struct demangle_component *encoding ) ;
#line 426
static int d_add_substitution(struct d_info *di , struct demangle_component *dc ) ;
#line 429
static struct demangle_component *d_substitution(struct d_info *di , int prefix ) ;
#line 431
static void d_growable_string_init(struct d_growable_string *dgs , size_t estimate ) ;
#line 433
__inline static void d_growable_string_resize(struct d_growable_string *dgs , size_t need ) ;
#line 436
__inline static void d_growable_string_append_buffer(struct d_growable_string *dgs ,
                                                     char const   *s , size_t l ) ;
#line 439
static void d_growable_string_callback_adapter(char const   *s , size_t l , void *opaque ) ;
#line 442
static void d_print_init(struct d_print_info *dpi , void (*callback)(char const   * ,
                                                                     size_t  , void * ) ,
                         void *opaque ) ;
#line 445
__inline static void d_print_error(struct d_print_info *dpi ) ;
#line 447
__inline static int d_print_saw_error(struct d_print_info *dpi ) ;
#line 449
__inline static void d_print_flush(struct d_print_info *dpi ) ;
#line 451
__inline static void d_append_char(struct d_print_info *dpi , char c ) ;
#line 453
__inline static void d_append_buffer(struct d_print_info *dpi , char const   *s ,
                                     size_t l ) ;
#line 456
__inline static void d_append_string(struct d_print_info *dpi , char const   *s ) ;
#line 458
__inline static char d_last_char(struct d_print_info *dpi ) ;
#line 460
static void d_print_comp(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 463
static void d_print_java_identifier(struct d_print_info *dpi , char const   *name___0 ,
                                    int len ) ;
#line 466
static void d_print_mod_list(struct d_print_info *dpi , int options___0 , struct d_print_mod *mods ,
                             int suffix ) ;
#line 469
static void d_print_mod(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *mod ) ;
#line 472
static void d_print_function_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                                  struct d_print_mod *mods ) ;
#line 477
static void d_print_array_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                               struct d_print_mod *mods ) ;
#line 482
static void d_print_expr_op(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 485
static void d_print_cast(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 488
static int d_demangle_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) ;
#line 490
static char *d_demangle(char const   *mangled , int options___0 , size_t *palc ) ;
#line 738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_fill_name(struct demangle_component *p , char const   *s , int len ) 
{ 


  {
#line 741
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 742
    return (0);
  } else
#line 741
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 742
    return (0);
  } else
#line 741
  if (len == 0) {
#line 742
    return (0);
  }
#line 743
  p->type = (enum demangle_component_type )0;
#line 744
  p->u.s_name.s = s;
#line 745
  p->u.s_name.len = len;
#line 746
  return (1);
}
}
#line 752 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_fill_extended_operator(struct demangle_component *p , int args ,
                                          struct demangle_component *name___0 ) 
{ 


  {
#line 756
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 757
    return (0);
  } else
#line 756
  if (args < 0) {
#line 757
    return (0);
  } else
#line 756
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 757
    return (0);
  }
#line 758
  p->type = (enum demangle_component_type )50;
#line 759
  p->u.s_extended_operator.args = args;
#line 760
  p->u.s_extended_operator.name = name___0;
#line 761
  return (1);
}
}
#line 767 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_fill_ctor(struct demangle_component *p , enum gnu_v3_ctor_kinds kind ,
                             struct demangle_component *name___0 ) 
{ 


  {
#line 772
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 776
    return (0);
  } else
#line 772
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 776
    return (0);
  } else
#line 772
  if ((int )kind < 1) {
#line 776
    return (0);
  } else
#line 772
  if ((int )kind > 4) {
#line 776
    return (0);
  }
#line 777
  p->type = (enum demangle_component_type )7;
#line 778
  p->u.s_ctor.kind = kind;
#line 779
  p->u.s_ctor.name = name___0;
#line 780
  return (1);
}
}
#line 786 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_fill_dtor(struct demangle_component *p , enum gnu_v3_dtor_kinds kind ,
                             struct demangle_component *name___0 ) 
{ 


  {
#line 791
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 795
    return (0);
  } else
#line 791
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 795
    return (0);
  } else
#line 791
  if ((int )kind < 1) {
#line 795
    return (0);
  } else
#line 791
  if ((int )kind > 4) {
#line 795
    return (0);
  }
#line 796
  p->type = (enum demangle_component_type )8;
#line 797
  p->u.s_dtor.kind = kind;
#line 798
  p->u.s_dtor.name = name___0;
#line 799
  return (1);
}
}
#line 804 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_empty(struct d_info *di ) 
{ 
  struct demangle_component *p ;

  {
#line 809
  if (di->next_comp >= di->num_comps) {
#line 810
    return ((struct demangle_component *)((void *)0));
  }
#line 811
  p = di->comps + di->next_comp;
#line 812
  (di->next_comp) ++;
#line 813
  return (p);
}
}
#line 818 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_comp(struct d_info *di , enum demangle_component_type type ,
                                              struct demangle_component *left , struct demangle_component *right ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 848
  if ((unsigned int )type == 75U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 45U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 62U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 60U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 59U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 57U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 56U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 55U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 54U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 53U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 43U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 33U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 11U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 4U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 74U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 3U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 2U) {
#line 848
    goto case_75;
  }
#line 848
  if ((unsigned int )type == 1U) {
#line 848
    goto case_75;
  }
#line 883
  if ((unsigned int )type == 58U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 52U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 67U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 66U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 73U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 65U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 61U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 51U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 40U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 38U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 37U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 36U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 35U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 34U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 72U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 71U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 23U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 22U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 21U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 20U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 19U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 18U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 17U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 16U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 15U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 14U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 13U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 12U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 10U) {
#line 883
    goto case_58;
  }
#line 883
  if ((unsigned int )type == 9U) {
#line 883
    goto case_58;
  }
#line 891
  if ((unsigned int )type == 48U) {
#line 891
    goto case_48;
  }
#line 891
  if ((unsigned int )type == 42U) {
#line 891
    goto case_48;
  }
#line 908
  if ((unsigned int )type == 47U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 46U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 32U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 31U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 30U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 29U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 28U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 27U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 26U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 25U) {
#line 908
    goto case_47;
  }
#line 908
  if ((unsigned int )type == 41U) {
#line 908
    goto case_47;
  }
#line 912
  goto switch_default;
  case_75: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 849
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 850
    return ((struct demangle_component *)((void *)0));
  } else
#line 849
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 850
    return ((struct demangle_component *)((void *)0));
  }
#line 851
  goto switch_break;
  case_58: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 884
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 885
    return ((struct demangle_component *)((void *)0));
  }
#line 886
  goto switch_break;
  case_48: /* CIL Label */ 
  case_42: /* CIL Label */ 
#line 892
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 893
    return ((struct demangle_component *)((void *)0));
  }
#line 894
  goto switch_break;
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_41: /* CIL Label */ 
#line 909
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 913
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 916
  p = d_make_empty(di);
  }
#line 917
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 919
    p->type = type;
#line 920
    p->u.s_binary.left = left;
#line 921
    p->u.s_binary.right = right;
  }
#line 923
  return (p);
}
}
#line 928 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_demangle_mangled_name(struct d_info *di ,
                                                               char const   *s ) 
{ 
  size_t tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 931
  if ((int const   )*(di->n) != 95) {
    {
#line 932
    tmp___0 = strlen(s);
#line 932
    tmp___1 = d_make_name(di, s, (int )tmp___0);
    }
#line 932
    return (tmp___1);
  } else
#line 931
  if ((int const   )*(di->n + 1) != 90) {
    {
#line 932
    tmp___0 = strlen(s);
#line 932
    tmp___1 = d_make_name(di, s, (int )tmp___0);
    }
#line 932
    return (tmp___1);
  }
  {
#line 933
  di->n += 2;
#line 934
  tmp___2 = d_encoding(di, 0);
  }
#line 934
  return (tmp___2);
}
}
#line 939 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_name(struct d_info *di , char const   *s ,
                                              int len ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 944
  p = d_make_empty(di);
#line 945
  tmp___0 = cplus_demangle_fill_name(p, s, len);
  }
#line 945
  if (! tmp___0) {
#line 946
    return ((struct demangle_component *)((void *)0));
  }
#line 947
  return (p);
}
}
#line 952 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_builtin_type(struct d_info *di , struct demangle_builtin_type_info  const  *type ) 
{ 
  struct demangle_component *p ;

  {
#line 958
  if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 959
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 960
  p = d_make_empty(di);
  }
#line 961
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 963
    p->type = (enum demangle_component_type )39;
#line 964
    p->u.s_builtin.type = type;
  }
#line 966
  return (p);
}
}
#line 971 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_operator(struct d_info *di , struct demangle_operator_info  const  *op ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 976
  p = d_make_empty(di);
  }
#line 977
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 979
    p->type = (enum demangle_component_type )49;
#line 980
    p->u.s_operator.op = op;
  }
#line 982
  return (p);
}
}
#line 987 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_extended_operator(struct d_info *di , int args ,
                                                           struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 993
  p = d_make_empty(di);
#line 994
  tmp___0 = cplus_demangle_fill_extended_operator(p, args, name___0);
  }
#line 994
  if (! tmp___0) {
#line 995
    return ((struct demangle_component *)((void *)0));
  }
#line 996
  return (p);
}
}
#line 999 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_default_arg(struct d_info *di , int num ,
                                                     struct demangle_component *sub ) 
{ 
  struct demangle_component *p ;
  struct demangle_component *tmp___0 ;

  {
  {
#line 1003
  tmp___0 = d_make_empty(di);
#line 1003
  p = tmp___0;
  }
#line 1004
  if (p) {
#line 1006
    p->type = (enum demangle_component_type )69;
#line 1007
    p->u.s_unary_num.num = num;
#line 1008
    p->u.s_unary_num.sub = sub;
  }
#line 1010
  return (p);
}
}
#line 1015 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_ctor(struct d_info *di , enum gnu_v3_ctor_kinds kind ,
                                              struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 1021
  p = d_make_empty(di);
#line 1022
  tmp___0 = cplus_demangle_fill_ctor(p, kind, name___0);
  }
#line 1022
  if (! tmp___0) {
#line 1023
    return ((struct demangle_component *)((void *)0));
  }
#line 1024
  return (p);
}
}
#line 1029 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_dtor(struct d_info *di , enum gnu_v3_dtor_kinds kind ,
                                              struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 1035
  p = d_make_empty(di);
#line 1036
  tmp___0 = cplus_demangle_fill_dtor(p, kind, name___0);
  }
#line 1036
  if (! tmp___0) {
#line 1037
    return ((struct demangle_component *)((void *)0));
  }
#line 1038
  return (p);
}
}
#line 1043 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_template_param(struct d_info *di , long i ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1048
  p = d_make_empty(di);
  }
#line 1049
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1051
    p->type = (enum demangle_component_type )5;
#line 1052
    p->u.s_number.number = i;
  }
#line 1054
  return (p);
}
}
#line 1059 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_function_param(struct d_info *di , long i ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1064
  p = d_make_empty(di);
  }
#line 1065
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1067
    p->type = (enum demangle_component_type )6;
#line 1068
    p->u.s_number.number = i;
  }
#line 1070
  return (p);
}
}
#line 1075 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_sub(struct d_info *di , char const   *name___0 ,
                                             int len ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1080
  p = d_make_empty(di);
  }
#line 1081
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1083
    p->type = (enum demangle_component_type )24;
#line 1084
    p->u.s_string.string = name___0;
#line 1085
    p->u.s_string.len = len;
  }
#line 1087
  return (p);
}
}
#line 1095 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct demangle_component *cplus_demangle_mangled_name(struct d_info *di , int top_level ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1100
  if ((int const   )*(di->n) == 95) {
#line 1100
    (di->n) ++;
#line 1100
    tmp___0 = 1;
  } else {
#line 1100
    tmp___0 = 0;
  }
#line 1100
  if (! tmp___0) {
#line 1100
    if (top_level) {
#line 1105
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 1106
  if ((int const   )*(di->n) == 90) {
#line 1106
    (di->n) ++;
#line 1106
    tmp___1 = 1;
  } else {
#line 1106
    tmp___1 = 0;
  }
#line 1106
  if (! tmp___1) {
#line 1107
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1108
  p = d_encoding(di, top_level);
  }
#line 1112
  if (top_level) {
#line 1112
    if ((di->options & 1) != 0) {
      {
#line 1113
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1113
        if ((int const   )*(di->n) == 46) {
#line 1113
          if ((int const   )*(di->n + 1) >= 97) {
#line 1113
            if (! ((int const   )*(di->n + 1) <= 122)) {
#line 1113
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1113
          if (! ((int const   )*(di->n + 1) == 95)) {
#line 1113
            if ((int const   )*(di->n + 1) >= 48) {
#line 1113
              if (! ((int const   )*(di->n + 1) <= 57)) {
#line 1113
                goto while_break;
              }
            } else {
#line 1113
              goto while_break;
            }
          }
        } else {
#line 1113
          goto while_break;
        }
        {
#line 1117
        p = d_clone_suffix(di, p);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1119
  return (p);
}
}
#line 1131 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int has_return_type(struct demangle_component *dc ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1134
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1135
    return (0);
  }
  {
#line 1140
  if ((unsigned int )dc->type == 4U) {
#line 1140
    goto case_4;
  }
#line 1146
  if ((unsigned int )dc->type == 32U) {
#line 1146
    goto case_32;
  }
#line 1146
  if ((unsigned int )dc->type == 31U) {
#line 1146
    goto case_32;
  }
#line 1146
  if ((unsigned int )dc->type == 30U) {
#line 1146
    goto case_32;
  }
#line 1146
  if ((unsigned int )dc->type == 29U) {
#line 1146
    goto case_32;
  }
#line 1146
  if ((unsigned int )dc->type == 28U) {
#line 1146
    goto case_32;
  }
#line 1138
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1139
  return (0);
  case_4: /* CIL Label */ 
  {
#line 1141
  tmp___0 = is_ctor_dtor_or_conversion(dc->u.s_binary.left);
  }
#line 1141
  if (tmp___0) {
#line 1141
    tmp___1 = 0;
  } else {
#line 1141
    tmp___1 = 1;
  }
#line 1141
  return (tmp___1);
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  {
#line 1147
  tmp___2 = has_return_type(dc->u.s_binary.left);
  }
#line 1147
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1154 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int is_ctor_dtor_or_conversion(struct demangle_component *dc ) 
{ 
  int tmp___0 ;

  {
#line 1157
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1158
    return (0);
  }
  {
#line 1164
  if ((unsigned int )dc->type == 2U) {
#line 1164
    goto case_2;
  }
#line 1164
  if ((unsigned int )dc->type == 1U) {
#line 1164
    goto case_2;
  }
#line 1168
  if ((unsigned int )dc->type == 51U) {
#line 1168
    goto case_51;
  }
#line 1168
  if ((unsigned int )dc->type == 8U) {
#line 1168
    goto case_51;
  }
#line 1168
  if ((unsigned int )dc->type == 7U) {
#line 1168
    goto case_51;
  }
#line 1161
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1162
  return (0);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1165
  tmp___0 = is_ctor_dtor_or_conversion(dc->u.s_binary.right);
  }
#line 1165
  return (tmp___0);
  case_51: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1169
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_encoding(struct d_info *di , int top_level ) 
{ 
  char peek ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *dc ;
  struct demangle_component *dcr ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 1185
  peek = (char )*(di->n);
#line 1187
  if ((int )peek == 71) {
    {
#line 1188
    tmp___0 = d_special_name(di);
    }
#line 1188
    return (tmp___0);
  } else
#line 1187
  if ((int )peek == 84) {
    {
#line 1188
    tmp___0 = d_special_name(di);
    }
#line 1188
    return (tmp___0);
  } else {
    {
#line 1193
    dc = d_name(di);
    }
#line 1195
    if ((unsigned long )dc != (unsigned long )((void *)0)) {
#line 1195
      if (top_level) {
#line 1195
        if ((di->options & 1) == 0) {
          {
#line 1200
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1200
            if (! ((unsigned int )dc->type == 28U)) {
#line 1200
              if (! ((unsigned int )dc->type == 29U)) {
#line 1200
                if (! ((unsigned int )dc->type == 30U)) {
#line 1200
                  if (! ((unsigned int )dc->type == 31U)) {
#line 1200
                    if (! ((unsigned int )dc->type == 32U)) {
#line 1200
                      goto while_break;
                    }
                  }
                }
              }
            }
#line 1205
            dc = dc->u.s_binary.left;
          }
          while_break: /* CIL Label */ ;
          }
#line 1211
          if ((unsigned int )dc->type == 2U) {
#line 1215
            dcr = dc->u.s_binary.right;
            {
#line 1216
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1216
              if (! ((unsigned int )dcr->type == 28U)) {
#line 1216
                if (! ((unsigned int )dcr->type == 29U)) {
#line 1216
                  if (! ((unsigned int )dcr->type == 30U)) {
#line 1216
                    if (! ((unsigned int )dcr->type == 31U)) {
#line 1216
                      if (! ((unsigned int )dcr->type == 32U)) {
#line 1216
                        goto while_break___0;
                      }
                    }
                  }
                }
              }
#line 1221
              dcr = dcr->u.s_binary.left;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1222
            dc->u.s_binary.right = dcr;
          }
#line 1225
          return (dc);
        }
      }
    }
#line 1228
    peek = (char )*(di->n);
#line 1229
    if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1230
      return (dc);
    } else
#line 1229
    if ((int )peek == 0) {
#line 1230
      return (dc);
    } else
#line 1229
    if ((int )peek == 69) {
#line 1230
      return (dc);
    }
    {
#line 1231
    tmp___1 = has_return_type(dc);
#line 1231
    tmp___2 = d_bare_function_type(di, tmp___1);
#line 1231
    tmp___3 = d_make_comp(di, (enum demangle_component_type )3, dc, tmp___2);
    }
#line 1231
    return (tmp___3);
  }
}
}
#line 1238 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_abi_tags(struct d_info *di , struct demangle_component *dc ) 
{ 
  char peek ;
  struct demangle_component *tag ;

  {
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    peek = (char )*(di->n);
#line 1242
    if (! ((int )peek == 66)) {
#line 1242
      goto while_break;
    }
    {
#line 1246
    (di->n) ++;
#line 1247
    tag = d_source_name(di);
#line 1248
    dc = d_make_comp(di, (enum demangle_component_type )74, dc, tag);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1250
  return (dc);
}
}
#line 1265 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_name(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dc ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  int subst ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  int tmp___5 ;
  struct demangle_component *tmp___6 ;
  int tmp___7 ;
  struct demangle_component *tmp___8 ;

  {
#line 1268
  peek = (char )*(di->n);
  {
#line 1273
  if ((int )peek == 78) {
#line 1273
    goto case_78;
  }
#line 1276
  if ((int )peek == 90) {
#line 1276
    goto case_90;
  }
#line 1280
  if ((int )peek == 85) {
#line 1280
    goto case_85;
  }
#line 1280
  if ((int )peek == 76) {
#line 1280
    goto case_85;
  }
#line 1283
  if ((int )peek == 83) {
#line 1283
    goto case_83;
  }
#line 1326
  goto switch_default;
  case_78: /* CIL Label */ 
  {
#line 1274
  tmp___0 = d_nested_name(di);
  }
#line 1274
  return (tmp___0);
  case_90: /* CIL Label */ 
  {
#line 1277
  tmp___1 = d_local_name(di);
  }
#line 1277
  return (tmp___1);
  case_85: /* CIL Label */ 
  case_76: /* CIL Label */ 
  {
#line 1281
  tmp___2 = d_unqualified_name(di);
  }
#line 1281
  return (tmp___2);
  case_83: /* CIL Label */ 
#line 1287
  if ((int const   )*(di->n + 1) != 116) {
    {
#line 1289
    dc = d_substitution(di, 0);
#line 1290
    subst = 1;
    }
  } else {
    {
#line 1294
    di->n += 2;
#line 1295
    tmp___3 = d_unqualified_name(di);
#line 1295
    tmp___4 = d_make_name(di, "std", 3);
#line 1295
    dc = d_make_comp(di, (enum demangle_component_type )1, tmp___4, tmp___3);
#line 1298
    di->expansion += 3;
#line 1299
    subst = 0;
    }
  }
#line 1302
  if (! ((int const   )*(di->n) != 73)) {
#line 1314
    if (! subst) {
      {
#line 1316
      tmp___5 = d_add_substitution(di, dc);
      }
#line 1316
      if (! tmp___5) {
#line 1317
        return ((struct demangle_component *)((void *)0));
      }
    }
    {
#line 1319
    tmp___6 = d_template_args(di);
#line 1319
    dc = d_make_comp(di, (enum demangle_component_type )4, dc, tmp___6);
    }
  }
#line 1323
  return (dc);
  switch_default: /* CIL Label */ 
  {
#line 1327
  dc = d_unqualified_name(di);
  }
#line 1328
  if ((int const   )*(di->n) == 73) {
    {
#line 1333
    tmp___7 = d_add_substitution(di, dc);
    }
#line 1333
    if (! tmp___7) {
#line 1334
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1335
    tmp___8 = d_template_args(di);
#line 1335
    dc = d_make_comp(di, (enum demangle_component_type )4, dc, tmp___8);
    }
  }
#line 1338
  return (dc);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1346 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_nested_name(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  struct demangle_component **pret ;
  struct demangle_component *rqual ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1353
  if ((int const   )*(di->n) == 78) {
#line 1353
    (di->n) ++;
#line 1353
    tmp___0 = 1;
  } else {
#line 1353
    tmp___0 = 0;
  }
#line 1353
  if (! tmp___0) {
#line 1354
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1356
  pret = d_cv_qualifiers(di, & ret, 1);
  }
#line 1357
  if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 1358
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1362
  rqual = d_ref_qualifier(di, (struct demangle_component *)((void *)0));
#line 1364
  *pret = d_prefix(di);
  }
#line 1365
  if ((unsigned long )*pret == (unsigned long )((void *)0)) {
#line 1366
    return ((struct demangle_component *)((void *)0));
  }
#line 1368
  if (rqual) {
#line 1370
    rqual->u.s_binary.left = ret;
#line 1371
    ret = rqual;
  }
#line 1374
  if ((int const   )*(di->n) == 69) {
#line 1374
    (di->n) ++;
#line 1374
    tmp___1 = 1;
  } else {
#line 1374
    tmp___1 = 0;
  }
#line 1374
  if (! tmp___1) {
#line 1375
    return ((struct demangle_component *)((void *)0));
  }
#line 1377
  return (ret);
}
}
#line 1392 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_prefix(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  char peek ;
  enum demangle_component_type comb_type ;
  struct demangle_component *dc ;
  char peek2 ;
  int tmp___0 ;

  {
#line 1395
  ret = (struct demangle_component *)((void *)0);
  {
#line 1397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    peek = (char )*(di->n);
#line 1404
    if ((int )peek == 0) {
#line 1405
      return ((struct demangle_component *)((void *)0));
    }
#line 1411
    comb_type = (enum demangle_component_type )1;
#line 1412
    if ((int )peek == 68) {
#line 1414
      peek2 = (char )*(di->n + 1);
#line 1415
      if ((int )peek2 == 84) {
        {
#line 1417
        dc = cplus_demangle_type(di);
        }
      } else
#line 1415
      if ((int )peek2 == 116) {
        {
#line 1417
        dc = cplus_demangle_type(di);
        }
      } else {
        {
#line 1420
        dc = d_unqualified_name(di);
        }
      }
    } else
#line 1422
    if ((int )peek >= 48) {
#line 1422
      if ((int )peek <= 57) {
        {
#line 1427
        dc = d_unqualified_name(di);
        }
      } else {
#line 1422
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1422
    if ((int )peek >= 97) {
#line 1422
      if ((int )peek <= 122) {
        {
#line 1427
        dc = d_unqualified_name(di);
        }
      } else {
#line 1422
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1422
    if ((int )peek == 67) {
      {
#line 1427
      dc = d_unqualified_name(di);
      }
    } else
#line 1422
    if ((int )peek == 85) {
      {
#line 1427
      dc = d_unqualified_name(di);
      }
    } else
#line 1422
    if ((int )peek == 76) {
      {
#line 1427
      dc = d_unqualified_name(di);
      }
    } else
#line 1428
    if ((int )peek == 83) {
      {
#line 1429
      dc = d_substitution(di, 1);
      }
    } else
#line 1430
    if ((int )peek == 73) {
#line 1432
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1433
        return ((struct demangle_component *)((void *)0));
      }
      {
#line 1434
      comb_type = (enum demangle_component_type )4;
#line 1435
      dc = d_template_args(di);
      }
    } else
#line 1437
    if ((int )peek == 84) {
      {
#line 1438
      dc = d_template_param(di);
      }
    } else
#line 1439
    if ((int )peek == 69) {
#line 1440
      return (ret);
    } else
#line 1441
    if ((int )peek == 77) {
#line 1446
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1447
        return ((struct demangle_component *)((void *)0));
      }
#line 1448
      (di->n) ++;
#line 1449
      goto while_continue;
    } else {
#line 1452
      return ((struct demangle_component *)((void *)0));
    }
#line 1454
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1455
      ret = dc;
    } else {
      {
#line 1457
      ret = d_make_comp(di, comb_type, ret, dc);
      }
    }
#line 1459
    if ((int )peek != 83) {
#line 1459
      if ((int const   )*(di->n) != 69) {
        {
#line 1461
        tmp___0 = d_add_substitution(di, ret);
        }
#line 1461
        if (! tmp___0) {
#line 1462
          return ((struct demangle_component *)((void *)0));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1475 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_unqualified_name(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  char peek ;
  struct demangle_component *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1481
  peek = (char )*(di->n);
#line 1482
  if ((int )peek >= 48) {
#line 1482
    if ((int )peek <= 57) {
      {
#line 1483
      ret = d_source_name(di);
      }
    } else {
#line 1482
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1484
  if ((int )peek >= 97) {
#line 1484
    if ((int )peek <= 122) {
      {
#line 1486
      ret = d_operator_name(di);
      }
#line 1487
      if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 1487
        if ((unsigned int )ret->type == 49U) {
          {
#line 1489
          di->expansion = (int )((unsigned long )di->expansion + ((sizeof("operator") + (unsigned long )(ret->u.s_operator.op)->len) - 2UL));
#line 1490
          tmp___1 = strcmp((char const   *)(ret->u.s_operator.op)->code, "li");
          }
#line 1490
          if (! tmp___1) {
            {
#line 1491
            tmp___0 = d_source_name(di);
#line 1491
            ret = d_make_comp(di, (enum demangle_component_type )53, ret, tmp___0);
            }
          }
        }
      }
    } else {
#line 1484
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1495
  if ((int )peek == 67) {
    {
#line 1496
    ret = d_ctor_dtor_name(di);
    }
  } else
#line 1495
  if ((int )peek == 68) {
    {
#line 1496
    ret = d_ctor_dtor_name(di);
    }
  } else
#line 1497
  if ((int )peek == 76) {
    {
#line 1499
    (di->n) ++;
#line 1501
    ret = d_source_name(di);
    }
#line 1502
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1503
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1504
    tmp___2 = d_discriminator(di);
    }
#line 1504
    if (! tmp___2) {
#line 1505
      return ((struct demangle_component *)((void *)0));
    }
  } else
#line 1507
  if ((int )peek == 85) {
    {
#line 1511
    if ((int const   )*(di->n + 1) == 108) {
#line 1511
      goto case_108;
    }
#line 1514
    if ((int const   )*(di->n + 1) == 116) {
#line 1514
      goto case_116;
    }
#line 1517
    goto switch_default;
    case_108: /* CIL Label */ 
    {
#line 1512
    ret = d_lambda(di);
    }
#line 1513
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1515
    ret = d_unnamed_type(di);
    }
#line 1516
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1518
    return ((struct demangle_component *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1522
    return ((struct demangle_component *)((void *)0));
  }
#line 1524
  if ((int const   )*(di->n) == 66) {
    {
#line 1525
    ret = d_abi_tags(di, ret);
    }
  }
#line 1526
  return (ret);
}
}
#line 1531 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_source_name(struct d_info *di ) 
{ 
  long len ;
  struct demangle_component *ret ;

  {
  {
#line 1537
  len = d_number(di);
  }
#line 1538
  if (len <= 0L) {
#line 1539
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1540
  ret = d_identifier(di, (int )len);
#line 1541
  di->last_name = ret;
  }
#line 1542
  return (ret);
}
}
#line 1547 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static long d_number(struct d_info *di ) 
{ 
  int negative ;
  char peek ;
  long ret ;

  {
#line 1554
  negative = 0;
#line 1555
  peek = (char )*(di->n);
#line 1556
  if ((int )peek == 110) {
#line 1558
    negative = 1;
#line 1559
    (di->n) ++;
#line 1560
    peek = (char )*(di->n);
  }
#line 1563
  ret = 0L;
  {
#line 1564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1566
    if ((int )peek >= 48) {
#line 1566
      if (! ((int )peek <= 57)) {
#line 1566
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1568
      if (negative) {
#line 1569
        ret = - ret;
      }
#line 1570
      return (ret);
    }
#line 1572
    ret = (ret * 10L + (long )peek) - 48L;
#line 1573
    (di->n) ++;
#line 1574
    peek = (char )*(di->n);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1580 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_number_component(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  struct demangle_component *tmp___0 ;

  {
  {
#line 1583
  tmp___0 = d_make_empty(di);
#line 1583
  ret = tmp___0;
  }
#line 1584
  if (ret) {
    {
#line 1586
    ret->type = (enum demangle_component_type )64;
#line 1587
    ret->u.s_number.number = d_number(di);
    }
  }
#line 1589
  return (ret);
}
}
#line 1594 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_identifier(struct d_info *di , int len ) 
{ 
  char const   *name___0 ;
  char const   *s ;
  struct demangle_component *tmp___0 ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 1599
  name___0 = di->n;
#line 1601
  if (di->send - name___0 < (long )len) {
#line 1602
    return ((struct demangle_component *)((void *)0));
  }
#line 1604
  di->n += len;
#line 1609
  if ((di->options & (1 << 2)) != 0) {
#line 1609
    if ((int const   )*(di->n) == 36) {
#line 1611
      (di->n) ++;
    }
  }
#line 1616
  if (len >= (int )(sizeof("_GLOBAL_") - 1UL) + 2) {
    {
#line 1616
    tmp___1 = memcmp((void const   *)name___0, (void const   *)"_GLOBAL_", sizeof("_GLOBAL_") - 1UL);
    }
#line 1616
    if (tmp___1 == 0) {
#line 1622
      s = name___0 + (sizeof("_GLOBAL_") - 1UL);
#line 1623
      if ((int const   )*s == 46) {
#line 1623
        goto _L;
      } else
#line 1623
      if ((int const   )*s == 95) {
#line 1623
        goto _L;
      } else
#line 1623
      if ((int const   )*s == 36) {
        _L: /* CIL Label */ 
#line 1623
        if ((int const   )*(s + 1) == 78) {
          {
#line 1626
          di->expansion = (int )((unsigned long )di->expansion - ((unsigned long )len - sizeof("(anonymous namespace)")));
#line 1627
          tmp___0 = d_make_name(di, "(anonymous namespace)", (int )(sizeof("(anonymous namespace)") - 1UL));
          }
#line 1627
          return (tmp___0);
        }
      }
    }
  }
  {
#line 1632
  tmp___2 = d_make_name(di, name___0, len);
  }
#line 1632
  return (tmp___2);
}
}
#line 1644 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct demangle_operator_info  const  cplus_demangle_operators[62]  = 
#line 1644
  {      {"aN", "&=", (int )(sizeof("&=") - 1UL), 2}, 
        {"aS", "=", (int )(sizeof("=") - 1UL), 2}, 
        {"aa", "&&", (int )(sizeof("&&") - 1UL), 2}, 
        {"ad", "&", (int )(sizeof("&") - 1UL), 1}, 
        {"an", "&", (int )(sizeof("&") - 1UL), 2}, 
        {"at", "alignof ", (int )(sizeof("alignof ") - 1UL), 1}, 
        {"az", "alignof ", (int )(sizeof("alignof ") - 1UL), 1}, 
        {"cc", "const_cast", (int )(sizeof("const_cast") - 1UL), 2}, 
        {"cl", "()", (int )(sizeof("()") - 1UL), 2}, 
        {"cm", ",", (int )(sizeof(",") - 1UL), 2}, 
        {"co", "~", (int )(sizeof("~") - 1UL), 1}, 
        {"dV", "/=", (int )(sizeof("/=") - 1UL), 2}, 
        {"da", "delete[] ", (int )(sizeof("delete[] ") - 1UL), 1}, 
        {"dc", "dynamic_cast", (int )(sizeof("dynamic_cast") - 1UL), 2}, 
        {"de", "*", (int )(sizeof("*") - 1UL), 1}, 
        {"dl", "delete ", (int )(sizeof("delete ") - 1UL), 1}, 
        {"ds", ".*", (int )(sizeof(".*") - 1UL), 2}, 
        {"dt", ".", (int )(sizeof(".") - 1UL), 2}, 
        {"dv", "/", (int )(sizeof("/") - 1UL), 2}, 
        {"eO", "^=", (int )(sizeof("^=") - 1UL), 2}, 
        {"eo", "^", (int )(sizeof("^") - 1UL), 2}, 
        {"eq", "==", (int )(sizeof("==") - 1UL), 2}, 
        {"ge", ">=", (int )(sizeof(">=") - 1UL), 2}, 
        {"gs", "::", (int )(sizeof("::") - 1UL), 1}, 
        {"gt", ">", (int )(sizeof(">") - 1UL), 2}, 
        {"ix", "[]", (int )(sizeof("[]") - 1UL), 2}, 
        {"lS", "<<=", (int )(sizeof("<<=") - 1UL), 2}, 
        {"le", "<=", (int )(sizeof("<=") - 1UL), 2}, 
        {"li", "operator\"\" ", (int )(sizeof("operator\"\" ") - 1UL), 1}, 
        {"ls", "<<", (int )(sizeof("<<") - 1UL), 2}, 
        {"lt", "<", (int )(sizeof("<") - 1UL), 2}, 
        {"mI", "-=", (int )(sizeof("-=") - 1UL), 2}, 
        {"mL", "*=", (int )(sizeof("*=") - 1UL), 2}, 
        {"mi", "-", (int )(sizeof("-") - 1UL), 2}, 
        {"ml", "*", (int )(sizeof("*") - 1UL), 2}, 
        {"mm", "--", (int )(sizeof("--") - 1UL), 1}, 
        {"na", "new[]", (int )(sizeof("new[]") - 1UL), 3}, 
        {"ne", "!=", (int )(sizeof("!=") - 1UL), 2}, 
        {"ng", "-", (int )(sizeof("-") - 1UL), 1}, 
        {"nt", "!", (int )(sizeof("!") - 1UL), 1}, 
        {"nw", "new", (int )(sizeof("new") - 1UL), 3}, 
        {"oR", "|=", (int )(sizeof("|=") - 1UL), 2}, 
        {"oo", "||", (int )(sizeof("||") - 1UL), 2}, 
        {"or", "|", (int )(sizeof("|") - 1UL), 2}, 
        {"pL", "+=", (int )(sizeof("+=") - 1UL), 2}, 
        {"pl", "+", (int )(sizeof("+") - 1UL), 2}, 
        {"pm", "->*", (int )(sizeof("->*") - 1UL), 2}, 
        {"pp", "++", (int )(sizeof("++") - 1UL), 1}, 
        {"ps", "+", (int )(sizeof("+") - 1UL), 1}, 
        {"pt", "->", (int )(sizeof("->") - 1UL), 2}, 
        {"qu", "?", (int )(sizeof("?") - 1UL), 3}, 
        {"rM", "%=", (int )(sizeof("%=") - 1UL), 2}, 
        {"rS", ">>=", (int )(sizeof(">>=") - 1UL), 2}, 
        {"rc", "reinterpret_cast", (int )(sizeof("reinterpret_cast") - 1UL), 2}, 
        {"rm", "%", (int )(sizeof("%") - 1UL), 2}, 
        {"rs", ">>", (int )(sizeof(">>") - 1UL), 2}, 
        {"sc", "static_cast", (int )(sizeof("static_cast") - 1UL), 2}, 
        {"st", "sizeof ", (int )(sizeof("sizeof ") - 1UL), 1}, 
        {"sz", "sizeof ", (int )(sizeof("sizeof ") - 1UL), 1}, 
        {"tr", "throw", (int )(sizeof("throw") - 1UL), 0}, 
        {"tw", "throw ", (int )(sizeof("throw ") - 1UL), 1}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, 0}};
#line 1710 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_operator_name(struct d_info *di ) 
{ 
  char c1 ;
  char c2 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  int low ;
  int high ;
  int i ;
  struct demangle_operator_info  const  *p ;
  struct demangle_component *tmp___6 ;

  {
#line 1716
  if ((int const   )*(di->n) == 0) {
#line 1716
    c1 = (char )'\000';
  } else {
#line 1716
    tmp___0 = di->n;
#line 1716
    (di->n) ++;
#line 1716
    c1 = (char )*tmp___0;
  }
#line 1717
  if ((int const   )*(di->n) == 0) {
#line 1717
    c2 = (char )'\000';
  } else {
#line 1717
    tmp___1 = di->n;
#line 1717
    (di->n) ++;
#line 1717
    c2 = (char )*tmp___1;
  }
#line 1718
  if ((int )c1 == 118) {
#line 1718
    if ((int )c2 >= 48) {
#line 1718
      if ((int )c2 <= 57) {
        {
#line 1719
        tmp___2 = d_source_name(di);
#line 1719
        tmp___3 = d_make_extended_operator(di, (int )c2 - 48, tmp___2);
        }
#line 1719
        return (tmp___3);
      } else {
#line 1718
        goto _L___0;
      }
    } else {
#line 1718
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1720
  if ((int )c1 == 99) {
#line 1720
    if ((int )c2 == 118) {
      {
#line 1721
      tmp___4 = cplus_demangle_type(di);
#line 1721
      tmp___5 = d_make_comp(di, (enum demangle_component_type )51, tmp___4, (struct demangle_component *)((void *)0));
      }
#line 1721
      return (tmp___5);
    } else {
#line 1720
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1726
    low = 0;
#line 1729
    high = (int )(sizeof(cplus_demangle_operators) / sizeof(cplus_demangle_operators[0]) - 1UL);
    {
#line 1733
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1738
      i = low + (high - low) / 2;
#line 1739
      p = cplus_demangle_operators + i;
#line 1741
      if ((int )c1 == (int )*(p->code + 0)) {
#line 1741
        if ((int )c2 == (int )*(p->code + 1)) {
          {
#line 1742
          tmp___6 = d_make_operator(di, p);
          }
#line 1742
          return (tmp___6);
        }
      }
#line 1744
      if ((int )c1 < (int )*(p->code + 0)) {
#line 1745
        high = i;
      } else
#line 1744
      if ((int )c1 == (int )*(p->code + 0)) {
#line 1744
        if ((int )c2 < (int )*(p->code + 1)) {
#line 1745
          high = i;
        } else {
#line 1747
          low = i + 1;
        }
      } else {
#line 1747
        low = i + 1;
      }
#line 1748
      if (low == high) {
#line 1749
        return ((struct demangle_component *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
}
}
#line 1754 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_character(struct d_info *di , int c ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1758
  p = d_make_empty(di);
  }
#line 1759
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1761
    p->type = (enum demangle_component_type )63;
#line 1762
    p->u.s_character.character = c;
  }
#line 1764
  return (p);
}
}
#line 1767 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_java_resource(struct d_info *di ) 
{ 
  struct demangle_component *p ;
  struct demangle_component *next ;
  long len ;
  long i ;
  char c ;
  char const   *str ;
  char const   *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1770
  p = (struct demangle_component *)((void *)0);
#line 1771
  next = (struct demangle_component *)((void *)0);
#line 1776
  len = d_number(di);
  }
#line 1777
  if (len <= 1L) {
#line 1778
    return ((struct demangle_component *)((void *)0));
  }
#line 1781
  if ((int const   )*(di->n) == 0) {
#line 1781
    tmp___1 = '\000';
  } else {
#line 1781
    tmp___0 = di->n;
#line 1781
    (di->n) ++;
#line 1781
    tmp___1 = (int )*tmp___0;
  }
#line 1781
  if (tmp___1 != 95) {
#line 1782
    return ((struct demangle_component *)((void *)0));
  }
#line 1783
  len --;
#line 1785
  str = di->n;
#line 1786
  i = 0L;
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1788
    if (! (len > 0L)) {
#line 1788
      goto while_break;
    }
#line 1790
    c = (char )*(str + i);
#line 1791
    if (! c) {
#line 1792
      return ((struct demangle_component *)((void *)0));
    }
#line 1795
    if ((int )c == 36) {
#line 1797
      i ++;
#line 1798
      tmp___2 = i;
#line 1798
      i ++;
      {
#line 1800
      if ((int const   )*(str + tmp___2) == 83) {
#line 1800
        goto case_83;
      }
#line 1803
      if ((int const   )*(str + tmp___2) == 95) {
#line 1803
        goto case_95;
      }
#line 1806
      if ((int const   )*(str + tmp___2) == 36) {
#line 1806
        goto case_36;
      }
#line 1809
      goto switch_default;
      case_83: /* CIL Label */ 
#line 1801
      c = (char )'/';
#line 1802
      goto switch_break;
      case_95: /* CIL Label */ 
#line 1804
      c = (char )'.';
#line 1805
      goto switch_break;
      case_36: /* CIL Label */ 
#line 1807
      c = (char )'$';
#line 1808
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1810
      return ((struct demangle_component *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
      {
#line 1812
      next = d_make_character(di, (int )c);
#line 1813
      di->n += i;
#line 1814
      str = di->n;
#line 1815
      len -= i;
#line 1816
      i = 0L;
      }
#line 1817
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 1818
        return ((struct demangle_component *)((void *)0));
      }
    } else {
      {
#line 1823
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1823
        if (i < len) {
#line 1823
          if (*(str + i)) {
#line 1823
            if (! ((int const   )*(str + i) != 36)) {
#line 1823
              goto while_break___0;
            }
          } else {
#line 1823
            goto while_break___0;
          }
        } else {
#line 1823
          goto while_break___0;
        }
#line 1824
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1826
      next = d_make_name(di, str, (int )i);
#line 1827
      di->n += i;
#line 1828
      str = di->n;
#line 1829
      len -= i;
#line 1830
      i = 0L;
      }
#line 1831
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 1832
        return ((struct demangle_component *)((void *)0));
      }
    }
#line 1835
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1836
      p = next;
    } else {
      {
#line 1839
      p = d_make_comp(di, (enum demangle_component_type )62, p, next);
      }
#line 1840
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1841
        return ((struct demangle_component *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1845
  p = d_make_comp(di, (enum demangle_component_type )61, p, (struct demangle_component *)((void *)0));
  }
#line 1847
  return (p);
}
}
#line 1868 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_special_name(struct d_info *di ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  struct demangle_component *tmp___8 ;
  struct demangle_component *tmp___9 ;
  int tmp___10 ;
  struct demangle_component *tmp___11 ;
  struct demangle_component *tmp___12 ;
  int tmp___13 ;
  struct demangle_component *tmp___14 ;
  struct demangle_component *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  struct demangle_component *tmp___18 ;
  struct demangle_component *tmp___19 ;
  struct demangle_component *derived_type ;
  long offset ;
  struct demangle_component *base_type ;
  int tmp___20 ;
  struct demangle_component *tmp___21 ;
  struct demangle_component *tmp___22 ;
  struct demangle_component *tmp___23 ;
  struct demangle_component *tmp___24 ;
  struct demangle_component *tmp___25 ;
  struct demangle_component *tmp___26 ;
  struct demangle_component *tmp___27 ;
  struct demangle_component *tmp___28 ;
  struct demangle_component *tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  struct demangle_component *tmp___32 ;
  struct demangle_component *tmp___33 ;
  struct demangle_component *name___0 ;
  struct demangle_component *tmp___34 ;
  struct demangle_component *tmp___35 ;
  struct demangle_component *tmp___36 ;
  struct demangle_component *tmp___37 ;
  struct demangle_component *tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  struct demangle_component *tmp___41 ;
  struct demangle_component *tmp___42 ;
  struct demangle_component *tmp___43 ;
  struct demangle_component *tmp___44 ;
  struct demangle_component *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;

  {
#line 1871
  di->expansion += 20;
#line 1872
  if ((int const   )*(di->n) == 84) {
#line 1872
    (di->n) ++;
#line 1872
    tmp___47 = 1;
  } else {
#line 1872
    tmp___47 = 0;
  }
#line 1872
  if (tmp___47) {
#line 1874
    if ((int const   )*(di->n) == 0) {
#line 1874
      tmp___1 = '\000';
    } else {
#line 1874
      tmp___0 = di->n;
#line 1874
      (di->n) ++;
#line 1874
      tmp___1 = (int )*tmp___0;
    }
    {
#line 1876
    if (tmp___1 == 86) {
#line 1876
      goto case_86;
    }
#line 1880
    if (tmp___1 == 84) {
#line 1880
      goto case_84;
    }
#line 1884
    if (tmp___1 == 73) {
#line 1884
      goto case_73;
    }
#line 1887
    if (tmp___1 == 83) {
#line 1887
      goto case_83;
    }
#line 1891
    if (tmp___1 == 104) {
#line 1891
      goto case_104;
    }
#line 1897
    if (tmp___1 == 118) {
#line 1897
      goto case_118;
    }
#line 1903
    if (tmp___1 == 99) {
#line 1903
      goto case_99;
    }
#line 1911
    if (tmp___1 == 67) {
#line 1911
      goto case_67;
    }
#line 1931
    if (tmp___1 == 70) {
#line 1931
      goto case_70;
    }
#line 1934
    if (tmp___1 == 74) {
#line 1934
      goto case_74;
    }
#line 1938
    if (tmp___1 == 72) {
#line 1938
      goto case_72;
    }
#line 1942
    if (tmp___1 == 87) {
#line 1942
      goto case_87;
    }
#line 1946
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 1877
    di->expansion -= 5;
#line 1878
    tmp___2 = cplus_demangle_type(di);
#line 1878
    tmp___3 = d_make_comp(di, (enum demangle_component_type )9, tmp___2, (struct demangle_component *)((void *)0));
    }
#line 1878
    return (tmp___3);
    case_84: /* CIL Label */ 
    {
#line 1881
    di->expansion -= 10;
#line 1882
    tmp___4 = cplus_demangle_type(di);
#line 1882
    tmp___5 = d_make_comp(di, (enum demangle_component_type )10, tmp___4, (struct demangle_component *)((void *)0));
    }
#line 1882
    return (tmp___5);
    case_73: /* CIL Label */ 
    {
#line 1885
    tmp___6 = cplus_demangle_type(di);
#line 1885
    tmp___7 = d_make_comp(di, (enum demangle_component_type )12, tmp___6, (struct demangle_component *)((void *)0));
    }
#line 1885
    return (tmp___7);
    case_83: /* CIL Label */ 
    {
#line 1888
    tmp___8 = cplus_demangle_type(di);
#line 1888
    tmp___9 = d_make_comp(di, (enum demangle_component_type )13, tmp___8, (struct demangle_component *)((void *)0));
    }
#line 1888
    return (tmp___9);
    case_104: /* CIL Label */ 
    {
#line 1892
    tmp___10 = d_call_offset(di, 'h');
    }
#line 1892
    if (! tmp___10) {
#line 1893
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1894
    tmp___11 = d_encoding(di, 0);
#line 1894
    tmp___12 = d_make_comp(di, (enum demangle_component_type )15, tmp___11, (struct demangle_component *)((void *)0));
    }
#line 1894
    return (tmp___12);
    case_118: /* CIL Label */ 
    {
#line 1898
    tmp___13 = d_call_offset(di, 'v');
    }
#line 1898
    if (! tmp___13) {
#line 1899
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1900
    tmp___14 = d_encoding(di, 0);
#line 1900
    tmp___15 = d_make_comp(di, (enum demangle_component_type )16, tmp___14, (struct demangle_component *)((void *)0));
    }
#line 1900
    return (tmp___15);
    case_99: /* CIL Label */ 
    {
#line 1904
    tmp___16 = d_call_offset(di, '\000');
    }
#line 1904
    if (! tmp___16) {
#line 1905
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1906
    tmp___17 = d_call_offset(di, '\000');
    }
#line 1906
    if (! tmp___17) {
#line 1907
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1908
    tmp___18 = d_encoding(di, 0);
#line 1908
    tmp___19 = d_make_comp(di, (enum demangle_component_type )17, tmp___18, (struct demangle_component *)((void *)0));
    }
#line 1908
    return (tmp___19);
    case_67: /* CIL Label */ 
    {
#line 1917
    derived_type = cplus_demangle_type(di);
#line 1918
    offset = d_number(di);
    }
#line 1919
    if (offset < 0L) {
#line 1920
      return ((struct demangle_component *)((void *)0));
    }
#line 1921
    if ((int const   )*(di->n) == 95) {
#line 1921
      (di->n) ++;
#line 1921
      tmp___20 = 1;
    } else {
#line 1921
      tmp___20 = 0;
    }
#line 1921
    if (! tmp___20) {
#line 1922
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1923
    base_type = cplus_demangle_type(di);
#line 1926
    di->expansion += 5;
#line 1927
    tmp___21 = d_make_comp(di, (enum demangle_component_type )11, base_type, derived_type);
    }
#line 1927
    return (tmp___21);
    case_70: /* CIL Label */ 
    {
#line 1932
    tmp___22 = cplus_demangle_type(di);
#line 1932
    tmp___23 = d_make_comp(di, (enum demangle_component_type )14, tmp___22, (struct demangle_component *)((void *)0));
    }
#line 1932
    return (tmp___23);
    case_74: /* CIL Label */ 
    {
#line 1935
    tmp___24 = cplus_demangle_type(di);
#line 1935
    tmp___25 = d_make_comp(di, (enum demangle_component_type )18, tmp___24, (struct demangle_component *)((void *)0));
    }
#line 1935
    return (tmp___25);
    case_72: /* CIL Label */ 
    {
#line 1939
    tmp___26 = d_name(di);
#line 1939
    tmp___27 = d_make_comp(di, (enum demangle_component_type )20, tmp___26, (struct demangle_component *)((void *)0));
    }
#line 1939
    return (tmp___27);
    case_87: /* CIL Label */ 
    {
#line 1943
    tmp___28 = d_name(di);
#line 1943
    tmp___29 = d_make_comp(di, (enum demangle_component_type )21, tmp___28, (struct demangle_component *)((void *)0));
    }
#line 1943
    return (tmp___29);
    switch_default: /* CIL Label */ 
#line 1947
    return ((struct demangle_component *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1950
    if ((int const   )*(di->n) == 71) {
#line 1950
      (di->n) ++;
#line 1950
      tmp___46 = 1;
    } else {
#line 1950
      tmp___46 = 0;
    }
#line 1950
    if (tmp___46) {
#line 1952
      if ((int const   )*(di->n) == 0) {
#line 1952
        tmp___31 = '\000';
      } else {
#line 1952
        tmp___30 = di->n;
#line 1952
        (di->n) ++;
#line 1952
        tmp___31 = (int )*tmp___30;
      }
      {
#line 1954
      if (tmp___31 == 86) {
#line 1954
        goto case_86___0;
      }
#line 1957
      if (tmp___31 == 82) {
#line 1957
        goto case_82;
      }
#line 1964
      if (tmp___31 == 65) {
#line 1964
        goto case_65;
      }
#line 1968
      if (tmp___31 == 84) {
#line 1968
        goto case_84___0;
      }
#line 1985
      if (tmp___31 == 114) {
#line 1985
        goto case_114;
      }
#line 1988
      goto switch_default___1;
      case_86___0: /* CIL Label */ 
      {
#line 1955
      tmp___32 = d_name(di);
#line 1955
      tmp___33 = d_make_comp(di, (enum demangle_component_type )19, tmp___32, (struct demangle_component *)((void *)0));
      }
#line 1955
      return (tmp___33);
      case_82: /* CIL Label */ 
      {
#line 1959
      tmp___34 = d_name(di);
#line 1959
      name___0 = tmp___34;
#line 1960
      tmp___35 = d_number_component(di);
#line 1960
      tmp___36 = d_make_comp(di, (enum demangle_component_type )22, name___0, tmp___35);
      }
#line 1960
      return (tmp___36);
      case_65: /* CIL Label */ 
      {
#line 1965
      tmp___37 = d_encoding(di, 0);
#line 1965
      tmp___38 = d_make_comp(di, (enum demangle_component_type )23, tmp___37, (struct demangle_component *)((void *)0));
      }
#line 1965
      return (tmp___38);
      case_84___0: /* CIL Label */ 
#line 1969
      if ((int const   )*(di->n) == 0) {
#line 1969
        tmp___40 = '\000';
      } else {
#line 1969
        tmp___39 = di->n;
#line 1969
        (di->n) ++;
#line 1969
        tmp___40 = (int )*tmp___39;
      }
      {
#line 1971
      if (tmp___40 == 110) {
#line 1971
        goto case_110;
      }
#line 1974
      goto switch_default___0;
      case_110: /* CIL Label */ 
      {
#line 1972
      tmp___41 = d_encoding(di, 0);
#line 1972
      tmp___42 = d_make_comp(di, (enum demangle_component_type )72, tmp___41, (struct demangle_component *)((void *)0));
      }
#line 1972
      return (tmp___42);
      switch_default___0: /* CIL Label */ 
      {
#line 1981
      tmp___43 = d_encoding(di, 0);
#line 1981
      tmp___44 = d_make_comp(di, (enum demangle_component_type )71, tmp___43, (struct demangle_component *)((void *)0));
      }
#line 1981
      return (tmp___44);
      switch_break___1: /* CIL Label */ ;
      }
      case_114: /* CIL Label */ 
      {
#line 1986
      tmp___45 = d_java_resource(di);
      }
#line 1986
      return (tmp___45);
      switch_default___1: /* CIL Label */ 
#line 1989
      return ((struct demangle_component *)((void *)0));
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 1993
      return ((struct demangle_component *)((void *)0));
    }
  }
}
}
#line 2009 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int d_call_offset(struct d_info *di , int c ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2012
  if (c == 0) {
#line 2013
    if ((int const   )*(di->n) == 0) {
#line 2013
      c = '\000';
    } else {
#line 2013
      tmp___0 = di->n;
#line 2013
      (di->n) ++;
#line 2013
      c = (int )*tmp___0;
    }
  }
#line 2015
  if (c == 104) {
    {
#line 2016
    d_number(di);
    }
  } else
#line 2017
  if (c == 118) {
    {
#line 2019
    d_number(di);
    }
#line 2020
    if ((int const   )*(di->n) == 95) {
#line 2020
      (di->n) ++;
#line 2020
      tmp___1 = 1;
    } else {
#line 2020
      tmp___1 = 0;
    }
#line 2020
    if (! tmp___1) {
#line 2021
      return (0);
    }
    {
#line 2022
    d_number(di);
    }
  } else {
#line 2025
    return (0);
  }
#line 2027
  if ((int const   )*(di->n) == 95) {
#line 2027
    (di->n) ++;
#line 2027
    tmp___2 = 1;
  } else {
#line 2027
    tmp___2 = 0;
  }
#line 2027
  if (! tmp___2) {
#line 2028
    return (0);
  }
#line 2030
  return (1);
}
}
#line 2041 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_ctor_dtor_name(struct d_info *di ) 
{ 
  enum gnu_v3_ctor_kinds kind ;
  struct demangle_component *tmp___0 ;
  enum gnu_v3_dtor_kinds kind___0 ;
  struct demangle_component *tmp___1 ;

  {
#line 2044
  if ((unsigned long )di->last_name != (unsigned long )((void *)0)) {
#line 2046
    if ((unsigned int )(di->last_name)->type == 0U) {
#line 2047
      di->expansion += (di->last_name)->u.s_name.len;
    } else
#line 2048
    if ((unsigned int )(di->last_name)->type == 24U) {
#line 2049
      di->expansion += (di->last_name)->u.s_string.len;
    }
  }
  {
#line 2053
  if ((int const   )*(di->n) == 67) {
#line 2053
    goto case_67;
  }
#line 2078
  if ((int const   )*(di->n) == 68) {
#line 2078
    goto case_68;
  }
#line 2103
  goto switch_default___1;
  case_67: /* CIL Label */ 
  {
#line 2059
  if ((int const   )*(di->n + 1) == 49) {
#line 2059
    goto case_49;
  }
#line 2062
  if ((int const   )*(di->n + 1) == 50) {
#line 2062
    goto case_50;
  }
#line 2065
  if ((int const   )*(di->n + 1) == 51) {
#line 2065
    goto case_51;
  }
#line 2068
  if ((int const   )*(di->n + 1) == 53) {
#line 2068
    goto case_53;
  }
#line 2071
  goto switch_default;
  case_49: /* CIL Label */ 
#line 2060
  kind = (enum gnu_v3_ctor_kinds )1;
#line 2061
  goto switch_break___0;
  case_50: /* CIL Label */ 
#line 2063
  kind = (enum gnu_v3_ctor_kinds )2;
#line 2064
  goto switch_break___0;
  case_51: /* CIL Label */ 
#line 2066
  kind = (enum gnu_v3_ctor_kinds )3;
#line 2067
  goto switch_break___0;
  case_53: /* CIL Label */ 
#line 2069
  kind = (enum gnu_v3_ctor_kinds )4;
#line 2070
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2072
  return ((struct demangle_component *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2074
  di->n += 2;
#line 2075
  tmp___0 = d_make_ctor(di, kind, di->last_name);
  }
#line 2075
  return (tmp___0);
  case_68: /* CIL Label */ 
  {
#line 2084
  if ((int const   )*(di->n + 1) == 48) {
#line 2084
    goto case_48;
  }
#line 2087
  if ((int const   )*(di->n + 1) == 49) {
#line 2087
    goto case_49___0;
  }
#line 2090
  if ((int const   )*(di->n + 1) == 50) {
#line 2090
    goto case_50___0;
  }
#line 2093
  if ((int const   )*(di->n + 1) == 53) {
#line 2093
    goto case_53___0;
  }
#line 2096
  goto switch_default___0;
  case_48: /* CIL Label */ 
#line 2085
  kind___0 = (enum gnu_v3_dtor_kinds )1;
#line 2086
  goto switch_break___1;
  case_49___0: /* CIL Label */ 
#line 2088
  kind___0 = (enum gnu_v3_dtor_kinds )2;
#line 2089
  goto switch_break___1;
  case_50___0: /* CIL Label */ 
#line 2091
  kind___0 = (enum gnu_v3_dtor_kinds )3;
#line 2092
  goto switch_break___1;
  case_53___0: /* CIL Label */ 
#line 2094
  kind___0 = (enum gnu_v3_dtor_kinds )4;
#line 2095
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 2097
  return ((struct demangle_component *)((void *)0));
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 2099
  di->n += 2;
#line 2100
  tmp___1 = d_make_dtor(di, kind___0, di->last_name);
  }
#line 2100
  return (tmp___1);
  switch_default___1: /* CIL Label */ 
#line 2104
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2129 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct demangle_builtin_type_info  const  cplus_demangle_builtin_types[33]  = 
#line 2129
  {      {"signed char", (int )(sizeof("signed char") - 1UL), "signed char", (int )(sizeof("signed char") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"bool", (int )(sizeof("bool") - 1UL), "boolean", (int )(sizeof("boolean") - 1UL),
      (enum d_builtin_type_print )7}, 
        {"char", (int )(sizeof("char") - 1UL), "byte", (int )(sizeof("byte") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"double", (int )(sizeof("double") - 1UL), "double", (int )(sizeof("double") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"long double", (int )(sizeof("long double") - 1UL), "long double", (int )(sizeof("long double") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"float", (int )(sizeof("float") - 1UL), "float", (int )(sizeof("float") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"__float128", (int )(sizeof("__float128") - 1UL), "__float128", (int )(sizeof("__float128") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"unsigned char", (int )(sizeof("unsigned char") - 1UL), "unsigned char", (int )(sizeof("unsigned char") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"int", (int )(sizeof("int") - 1UL), "int", (int )(sizeof("int") - 1UL), (enum d_builtin_type_print )1}, 
        {"unsigned int",
      (int )(sizeof("unsigned int") - 1UL), "unsigned", (int )(sizeof("unsigned") - 1UL),
      (enum d_builtin_type_print )2}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"long",
      (int )(sizeof("long") - 1UL), "long", (int )(sizeof("long") - 1UL), (enum d_builtin_type_print )3}, 
        {"unsigned long",
      (int )(sizeof("unsigned long") - 1UL), "unsigned long", (int )(sizeof("unsigned long") - 1UL),
      (enum d_builtin_type_print )4}, 
        {"__int128", (int )(sizeof("__int128") - 1UL), "__int128", (int )(sizeof("__int128") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"unsigned __int128", (int )(sizeof("unsigned __int128") - 1UL), "unsigned __int128",
      (int )(sizeof("unsigned __int128") - 1UL), (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0),
      0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"short",
      (int )(sizeof("short") - 1UL), "short", (int )(sizeof("short") - 1UL), (enum d_builtin_type_print )0}, 
        {"unsigned short",
      (int )(sizeof("unsigned short") - 1UL), "unsigned short", (int )(sizeof("unsigned short") - 1UL),
      (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"void",
      (int )(sizeof("void") - 1UL), "void", (int )(sizeof("void") - 1UL), (enum d_builtin_type_print )9}, 
        {"wchar_t",
      (int )(sizeof("wchar_t") - 1UL), "char", (int )(sizeof("char") - 1UL), (enum d_builtin_type_print )0}, 
        {"long long",
      (int )(sizeof("long long") - 1UL), "long", (int )(sizeof("long") - 1UL), (enum d_builtin_type_print )5}, 
        {"unsigned long long",
      (int )(sizeof("unsigned long long") - 1UL), "unsigned long long", (int )(sizeof("unsigned long long") - 1UL),
      (enum d_builtin_type_print )6}, 
        {"...", (int )(sizeof("...") - 1UL), "...", (int )(sizeof("...") - 1UL), (enum d_builtin_type_print )0}, 
        {"decimal32",
      (int )(sizeof("decimal32") - 1UL), "decimal32", (int )(sizeof("decimal32") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decimal64", (int )(sizeof("decimal64") - 1UL), "decimal64", (int )(sizeof("decimal64") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decimal128", (int )(sizeof("decimal128") - 1UL), "decimal128", (int )(sizeof("decimal128") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"half", (int )(sizeof("half") - 1UL), "half", (int )(sizeof("half") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"char16_t", (int )(sizeof("char16_t") - 1UL), "char16_t", (int )(sizeof("char16_t") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"char32_t", (int )(sizeof("char32_t") - 1UL), "char32_t", (int )(sizeof("char32_t") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decltype(nullptr)", (int )(sizeof("decltype(nullptr)") - 1UL), "decltype(nullptr)",
      (int )(sizeof("decltype(nullptr)") - 1UL), (enum d_builtin_type_print )0}};
#line 2171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
struct demangle_component *cplus_demangle_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *ret ;
  int can_subst ;
  struct demangle_component **pret ;
  struct demangle_component *fn ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  int tmp___2 ;
  struct demangle_component *tmp___3 ;
  char peek_next ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  struct demangle_component *tmp___8 ;
  struct demangle_component *tmp___9 ;
  struct demangle_component *tmp___10 ;
  char const   *tmp___11 ;
  struct demangle_component *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  struct demangle_component *tmp___15 ;
  short tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;

  {
#line 2193
  peek = (char )*(di->n);
#line 2194
  if ((int )peek == 114) {
#line 2194
    goto _L;
  } else
#line 2194
  if ((int )peek == 86) {
#line 2194
    goto _L;
  } else
#line 2194
  if ((int )peek == 75) {
    _L: /* CIL Label */ 
    {
#line 2198
    pret = d_cv_qualifiers(di, & ret, 0);
    }
#line 2199
    if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 2200
      return ((struct demangle_component *)((void *)0));
    }
#line 2201
    if ((int const   )*(di->n) == 70) {
      {
#line 2206
      *pret = d_function_type(di);
      }
    } else {
      {
#line 2209
      *pret = cplus_demangle_type(di);
      }
    }
#line 2210
    if (! *pret) {
#line 2211
      return ((struct demangle_component *)((void *)0));
    }
#line 2212
    if ((unsigned int )(*pret)->type == 32U) {
#line 2217
      fn = (*pret)->u.s_binary.left;
#line 2218
      (*pret)->u.s_binary.left = ret;
#line 2219
      ret = *pret;
#line 2220
      *pret = fn;
    } else
#line 2212
    if ((unsigned int )(*pret)->type == 31U) {
#line 2217
      fn = (*pret)->u.s_binary.left;
#line 2218
      (*pret)->u.s_binary.left = ret;
#line 2219
      ret = *pret;
#line 2220
      *pret = fn;
    }
    {
#line 2222
    tmp___0 = d_add_substitution(di, ret);
    }
#line 2222
    if (! tmp___0) {
#line 2223
      return ((struct demangle_component *)((void *)0));
    }
#line 2224
    return (ret);
  }
#line 2227
  can_subst = 1;
  {
#line 2234
  if ((int )peek == 122) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 121) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 120) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 119) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 118) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 116) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 115) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 111) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 110) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 109) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 108) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 106) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 105) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 104) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 103) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 102) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 101) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 100) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 99) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 98) {
#line 2234
    goto case_122;
  }
#line 2234
  if ((int )peek == 97) {
#line 2234
    goto case_122;
  }
#line 2242
  if ((int )peek == 117) {
#line 2242
    goto case_117;
  }
#line 2248
  if ((int )peek == 70) {
#line 2248
    goto case_70;
  }
#line 2255
  if ((int )peek == 90) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 78) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 57) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 56) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 55) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 54) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 53) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 52) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 51) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 50) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 49) {
#line 2255
    goto case_90;
  }
#line 2255
  if ((int )peek == 48) {
#line 2255
    goto case_90;
  }
#line 2259
  if ((int )peek == 65) {
#line 2259
    goto case_65;
  }
#line 2263
  if ((int )peek == 77) {
#line 2263
    goto case_77;
  }
#line 2267
  if ((int )peek == 84) {
#line 2267
    goto case_84;
  }
#line 2281
  if ((int )peek == 83) {
#line 2281
    goto case_83;
  }
#line 2314
  if ((int )peek == 79) {
#line 2314
    goto case_79;
  }
#line 2320
  if ((int )peek == 80) {
#line 2320
    goto case_80;
  }
#line 2326
  if ((int )peek == 82) {
#line 2326
    goto case_82;
  }
#line 2332
  if ((int )peek == 67) {
#line 2332
    goto case_67;
  }
#line 2338
  if ((int )peek == 71) {
#line 2338
    goto case_71;
  }
#line 2344
  if ((int )peek == 85) {
#line 2344
    goto case_85;
  }
#line 2351
  if ((int )peek == 68) {
#line 2351
    goto case_68;
  }
#line 2441
  goto switch_default___0;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
#line 2235
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[(int )peek - 97]);
#line 2237
  di->expansion += (int )(ret->u.s_builtin.type)->len;
#line 2238
  can_subst = 0;
#line 2239
  (di->n) ++;
  }
#line 2240
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 2243
  (di->n) ++;
#line 2244
  tmp___1 = d_source_name(di);
#line 2244
  ret = d_make_comp(di, (enum demangle_component_type )40, tmp___1, (struct demangle_component *)((void *)0));
  }
#line 2246
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 2249
  ret = d_function_type(di);
  }
#line 2250
  goto switch_break;
  case_90: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 2256
  ret = d_class_enum_type(di);
  }
#line 2257
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 2260
  ret = d_array_type(di);
  }
#line 2261
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2264
  ret = d_pointer_to_member_type(di);
  }
#line 2265
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 2268
  ret = d_template_param(di);
  }
#line 2269
  if ((int const   )*(di->n) == 73) {
    {
#line 2274
    tmp___2 = d_add_substitution(di, ret);
    }
#line 2274
    if (! tmp___2) {
#line 2275
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2276
    tmp___3 = d_template_args(di);
#line 2276
    ret = d_make_comp(di, (enum demangle_component_type )4, ret, tmp___3);
    }
  }
#line 2279
  goto switch_break;
  case_83: /* CIL Label */ 
#line 2287
  peek_next = (char )*(di->n + 1);
#line 2288
  if ((int )peek_next >= 48) {
#line 2288
    if ((int )peek_next <= 57) {
#line 2288
      goto _L___0;
    } else {
#line 2288
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2288
  if ((int )peek_next == 95) {
#line 2288
    goto _L___0;
  } else
#line 2288
  if ((int )peek_next >= 65) {
#line 2288
    if ((int )peek_next <= 90) {
      _L___0: /* CIL Label */ 
      {
#line 2292
      ret = d_substitution(di, 0);
      }
#line 2295
      if ((int const   )*(di->n) == 73) {
        {
#line 2296
        tmp___4 = d_template_args(di);
#line 2296
        ret = d_make_comp(di, (enum demangle_component_type )4, ret, tmp___4);
        }
      } else {
#line 2299
        can_subst = 0;
      }
    } else {
#line 2288
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 2303
    ret = d_class_enum_type(di);
    }
#line 2308
    if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 2308
      if ((unsigned int )ret->type == 24U) {
#line 2309
        can_subst = 0;
      }
    }
  }
#line 2312
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 2315
  (di->n) ++;
#line 2316
  tmp___5 = cplus_demangle_type(di);
#line 2316
  ret = d_make_comp(di, (enum demangle_component_type )36, tmp___5, (struct demangle_component *)((void *)0));
  }
#line 2318
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 2321
  (di->n) ++;
#line 2322
  tmp___6 = cplus_demangle_type(di);
#line 2322
  ret = d_make_comp(di, (enum demangle_component_type )34, tmp___6, (struct demangle_component *)((void *)0));
  }
#line 2324
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 2327
  (di->n) ++;
#line 2328
  tmp___7 = cplus_demangle_type(di);
#line 2328
  ret = d_make_comp(di, (enum demangle_component_type )35, tmp___7, (struct demangle_component *)((void *)0));
  }
#line 2330
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 2333
  (di->n) ++;
#line 2334
  tmp___8 = cplus_demangle_type(di);
#line 2334
  ret = d_make_comp(di, (enum demangle_component_type )37, tmp___8, (struct demangle_component *)((void *)0));
  }
#line 2336
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 2339
  (di->n) ++;
#line 2340
  tmp___9 = cplus_demangle_type(di);
#line 2340
  ret = d_make_comp(di, (enum demangle_component_type )38, tmp___9, (struct demangle_component *)((void *)0));
  }
#line 2342
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 2345
  (di->n) ++;
#line 2346
  ret = d_source_name(di);
#line 2347
  tmp___10 = cplus_demangle_type(di);
#line 2347
  ret = d_make_comp(di, (enum demangle_component_type )33, tmp___10, ret);
  }
#line 2349
  goto switch_break;
  case_68: /* CIL Label */ 
#line 2352
  can_subst = 0;
#line 2353
  (di->n) ++;
#line 2354
  if ((int const   )*(di->n) == 0) {
#line 2354
    peek = (char )'\000';
  } else {
#line 2354
    tmp___11 = di->n;
#line 2354
    (di->n) ++;
#line 2354
    peek = (char )*tmp___11;
  }
  {
#line 2358
  if ((int )peek == 116) {
#line 2358
    goto case_116___0;
  }
#line 2358
  if ((int )peek == 84) {
#line 2358
    goto case_116___0;
  }
#line 2367
  if ((int )peek == 112) {
#line 2367
    goto case_112;
  }
#line 2374
  if ((int )peek == 97) {
#line 2374
    goto case_97___0;
  }
#line 2379
  if ((int )peek == 102) {
#line 2379
    goto case_102___0;
  }
#line 2384
  if ((int )peek == 100) {
#line 2384
    goto case_100___0;
  }
#line 2389
  if ((int )peek == 101) {
#line 2389
    goto case_101___0;
  }
#line 2394
  if ((int )peek == 104) {
#line 2394
    goto case_104___0;
  }
#line 2399
  if ((int )peek == 115) {
#line 2399
    goto case_115___0;
  }
#line 2404
  if ((int )peek == 105) {
#line 2404
    goto case_105___0;
  }
#line 2410
  if ((int )peek == 70) {
#line 2410
    goto case_70___0;
  }
#line 2425
  if ((int )peek == 118) {
#line 2425
    goto case_118___0;
  }
#line 2430
  if ((int )peek == 110) {
#line 2430
    goto case_110___0;
  }
#line 2436
  goto switch_default;
  case_116___0: /* CIL Label */ 
  case_84___0: /* CIL Label */ 
  {
#line 2360
  tmp___12 = d_expression(di);
#line 2360
  ret = d_make_comp(di, (enum demangle_component_type )65, tmp___12, (struct demangle_component *)((void *)0));
  }
#line 2362
  if (ret) {
#line 2362
    if ((int const   )*(di->n) == 0) {
#line 2362
      tmp___14 = '\000';
    } else {
#line 2362
      tmp___13 = di->n;
#line 2362
      (di->n) ++;
#line 2362
      tmp___14 = (int )*tmp___13;
    }
#line 2362
    if (tmp___14 != 69) {
#line 2363
      ret = (struct demangle_component *)((void *)0);
    }
  }
#line 2364
  can_subst = 1;
#line 2365
  goto switch_break___0;
  case_112: /* CIL Label */ 
  {
#line 2369
  tmp___15 = cplus_demangle_type(di);
#line 2369
  ret = d_make_comp(di, (enum demangle_component_type )73, tmp___15, (struct demangle_component *)((void *)0));
#line 2371
  can_subst = 1;
  }
#line 2372
  goto switch_break___0;
  case_97___0: /* CIL Label */ 
  {
#line 2376
  ret = d_make_name(di, "auto", 4);
  }
#line 2377
  goto switch_break___0;
  case_102___0: /* CIL Label */ 
  {
#line 2381
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[26]);
#line 2382
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2383
  goto switch_break___0;
  case_100___0: /* CIL Label */ 
  {
#line 2386
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[27]);
#line 2387
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2388
  goto switch_break___0;
  case_101___0: /* CIL Label */ 
  {
#line 2391
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[28]);
#line 2392
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2393
  goto switch_break___0;
  case_104___0: /* CIL Label */ 
  {
#line 2396
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[29]);
#line 2397
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2398
  goto switch_break___0;
  case_115___0: /* CIL Label */ 
  {
#line 2401
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[30]);
#line 2402
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2403
  goto switch_break___0;
  case_105___0: /* CIL Label */ 
  {
#line 2406
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[31]);
#line 2407
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2408
  goto switch_break___0;
  case_70___0: /* CIL Label */ 
  {
#line 2412
  ret = d_make_empty(di);
#line 2413
  ret->type = (enum demangle_component_type )44;
  }
#line 2414
  if ((int const   )*(di->n) >= 48) {
#line 2414
    if ((int const   )*(di->n) <= 57) {
#line 2414
      tmp___17 = 1;
    } else {
#line 2414
      tmp___17 = 0;
    }
  } else {
#line 2414
    tmp___17 = 0;
  }
#line 2414
  tmp___16 = (short )tmp___17;
#line 2414
  ret->u.s_fixed.accum = tmp___16;
#line 2414
  if (tmp___16) {
    {
#line 2416
    d_number(di);
    }
  }
  {
#line 2417
  ret->u.s_fixed.length = cplus_demangle_type(di);
  }
#line 2418
  if ((unsigned long )ret->u.s_fixed.length == (unsigned long )((void *)0)) {
#line 2419
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2420
  d_number(di);
  }
#line 2421
  if ((int const   )*(di->n) == 0) {
#line 2421
    peek = (char )'\000';
  } else {
#line 2421
    tmp___18 = di->n;
#line 2421
    (di->n) ++;
#line 2421
    peek = (char )*tmp___18;
  }
#line 2422
  ret->u.s_fixed.sat = (short )((int )peek == 115);
#line 2423
  goto switch_break___0;
  case_118___0: /* CIL Label */ 
  {
#line 2426
  ret = d_vector_type(di);
#line 2427
  can_subst = 1;
  }
#line 2428
  goto switch_break___0;
  case_110___0: /* CIL Label */ 
  {
#line 2432
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[32]);
#line 2433
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2434
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2437
  return ((struct demangle_component *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
#line 2439
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 2442
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 2445
  if (can_subst) {
    {
#line 2447
    tmp___19 = d_add_substitution(di, ret);
    }
#line 2447
    if (! tmp___19) {
#line 2448
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2451
  return (ret);
}
}
#line 2456 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component **d_cv_qualifiers(struct d_info *di , struct demangle_component **pret ,
                                                   int member_fn ) 
{ 
  struct demangle_component **pstart ;
  char peek ;
  enum demangle_component_type t ;

  {
#line 2463
  pstart = pret;
#line 2464
  peek = (char )*(di->n);
  {
#line 2465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2465
    if (! ((int )peek == 114)) {
#line 2465
      if (! ((int )peek == 86)) {
#line 2465
        if (! ((int )peek == 75)) {
#line 2465
          goto while_break;
        }
      }
    }
#line 2469
    (di->n) ++;
#line 2470
    if ((int )peek == 114) {
#line 2472
      if (member_fn) {
#line 2472
        t = (enum demangle_component_type )28;
      } else {
#line 2472
        t = (enum demangle_component_type )25;
      }
#line 2475
      di->expansion = (int )((unsigned long )di->expansion + sizeof("restrict"));
    } else
#line 2477
    if ((int )peek == 86) {
#line 2479
      if (member_fn) {
#line 2479
        t = (enum demangle_component_type )29;
      } else {
#line 2479
        t = (enum demangle_component_type )26;
      }
#line 2482
      di->expansion = (int )((unsigned long )di->expansion + sizeof("volatile"));
    } else {
#line 2486
      if (member_fn) {
#line 2486
        t = (enum demangle_component_type )30;
      } else {
#line 2486
        t = (enum demangle_component_type )27;
      }
#line 2489
      di->expansion = (int )((unsigned long )di->expansion + sizeof("const"));
    }
    {
#line 2492
    *pret = d_make_comp(di, t, (struct demangle_component *)((void *)0), (struct demangle_component *)((void *)0));
    }
#line 2493
    if ((unsigned long )*pret == (unsigned long )((void *)0)) {
#line 2494
      return ((struct demangle_component **)((void *)0));
    }
#line 2495
    pret = & (*pret)->u.s_binary.left;
#line 2497
    peek = (char )*(di->n);
  }
  while_break: /* CIL Label */ ;
  }
#line 2500
  if (! member_fn) {
#line 2500
    if ((int )peek == 70) {
      {
#line 2502
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2502
        if (! ((unsigned long )pstart != (unsigned long )pret)) {
#line 2502
          goto while_break___0;
        }
        {
#line 2506
        if ((unsigned int )(*pstart)->type == 25U) {
#line 2506
          goto case_25;
        }
#line 2509
        if ((unsigned int )(*pstart)->type == 26U) {
#line 2509
          goto case_26;
        }
#line 2512
        if ((unsigned int )(*pstart)->type == 27U) {
#line 2512
          goto case_27;
        }
#line 2515
        goto switch_default;
        case_25: /* CIL Label */ 
#line 2507
        (*pstart)->type = (enum demangle_component_type )28;
#line 2508
        goto switch_break;
        case_26: /* CIL Label */ 
#line 2510
        (*pstart)->type = (enum demangle_component_type )29;
#line 2511
        goto switch_break;
        case_27: /* CIL Label */ 
#line 2513
        (*pstart)->type = (enum demangle_component_type )30;
#line 2514
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2516
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 2518
        pstart = & (*pstart)->u.s_binary.left;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 2522
  return (pret);
}
}
#line 2528 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_ref_qualifier(struct d_info *di , struct demangle_component *sub ) 
{ 
  struct demangle_component *ret ;
  char peek ;
  enum demangle_component_type t ;

  {
#line 2531
  ret = sub;
#line 2534
  peek = (char )*(di->n);
#line 2535
  if ((int )peek == 82) {
#line 2535
    goto _L;
  } else
#line 2535
  if ((int )peek == 79) {
    _L: /* CIL Label */ 
#line 2538
    if ((int )peek == 82) {
#line 2540
      t = (enum demangle_component_type )31;
#line 2541
      di->expansion = (int )((unsigned long )di->expansion + sizeof("&"));
    } else {
#line 2545
      t = (enum demangle_component_type )32;
#line 2546
      di->expansion = (int )((unsigned long )di->expansion + sizeof("&&"));
    }
    {
#line 2548
    (di->n) ++;
#line 2550
    ret = d_make_comp(di, t, ret, (struct demangle_component *)((void *)0));
    }
  }
#line 2553
  return (ret);
}
}
#line 2558 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_function_type(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2563
  if ((int const   )*(di->n) == 70) {
#line 2563
    (di->n) ++;
#line 2563
    tmp___0 = 1;
  } else {
#line 2563
    tmp___0 = 0;
  }
#line 2563
  if (! tmp___0) {
#line 2564
    return ((struct demangle_component *)((void *)0));
  }
#line 2565
  if ((int const   )*(di->n) == 89) {
#line 2569
    (di->n) ++;
  }
  {
#line 2571
  ret = d_bare_function_type(di, 1);
#line 2572
  ret = d_ref_qualifier(di, ret);
  }
#line 2574
  if ((int const   )*(di->n) == 69) {
#line 2574
    (di->n) ++;
#line 2574
    tmp___1 = 1;
  } else {
#line 2574
    tmp___1 = 0;
  }
#line 2574
  if (! tmp___1) {
#line 2575
    return ((struct demangle_component *)((void *)0));
  }
#line 2576
  return (ret);
}
}
#line 2581 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_parmlist(struct d_info *di ) 
{ 
  struct demangle_component *tl ;
  struct demangle_component **ptl ;
  struct demangle_component *type ;
  char peek ;

  {
#line 2587
  tl = (struct demangle_component *)((void *)0);
#line 2588
  ptl = & tl;
  {
#line 2589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2593
    peek = (char )*(di->n);
#line 2594
    if ((int )peek == 0) {
#line 2595
      goto while_break;
    } else
#line 2594
    if ((int )peek == 69) {
#line 2595
      goto while_break;
    } else
#line 2594
    if ((int )peek == 46) {
#line 2595
      goto while_break;
    }
#line 2596
    if ((int )peek == 82) {
#line 2596
      goto _L;
    } else
#line 2596
    if ((int )peek == 79) {
      _L: /* CIL Label */ 
#line 2596
      if ((int const   )*(di->n + 1) == 69) {
#line 2599
        goto while_break;
      }
    }
    {
#line 2600
    type = cplus_demangle_type(di);
    }
#line 2601
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 2602
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2603
    *ptl = d_make_comp(di, (enum demangle_component_type )46, type, (struct demangle_component *)((void *)0));
    }
#line 2604
    if ((unsigned long )*ptl == (unsigned long )((void *)0)) {
#line 2605
      return ((struct demangle_component *)((void *)0));
    }
#line 2606
    ptl = & (*ptl)->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 2613
    return ((struct demangle_component *)((void *)0));
  }
#line 2616
  if ((unsigned long )tl->u.s_binary.right == (unsigned long )((void *)0)) {
#line 2616
    if ((unsigned int )(tl->u.s_binary.left)->type == 39U) {
#line 2616
      if ((unsigned int const   )((tl->u.s_binary.left)->u.s_builtin.type)->print == 9U) {
#line 2620
        di->expansion -= (int )((tl->u.s_binary.left)->u.s_builtin.type)->len;
#line 2621
        tl->u.s_binary.left = (struct demangle_component *)((void *)0);
      }
    }
  }
#line 2624
  return (tl);
}
}
#line 2629 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_bare_function_type(struct d_info *di , int has_return_type___0 ) 
{ 
  struct demangle_component *return_type ;
  struct demangle_component *tl ;
  char peek ;
  struct demangle_component *tmp___0 ;

  {
#line 2638
  peek = (char )*(di->n);
#line 2639
  if ((int )peek == 74) {
#line 2641
    (di->n) ++;
#line 2642
    has_return_type___0 = 1;
  }
#line 2645
  if (has_return_type___0) {
    {
#line 2647
    return_type = cplus_demangle_type(di);
    }
#line 2648
    if ((unsigned long )return_type == (unsigned long )((void *)0)) {
#line 2649
      return ((struct demangle_component *)((void *)0));
    }
  } else {
#line 2652
    return_type = (struct demangle_component *)((void *)0);
  }
  {
#line 2654
  tl = d_parmlist(di);
  }
#line 2655
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 2656
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2658
  tmp___0 = d_make_comp(di, (enum demangle_component_type )41, return_type, tl);
  }
#line 2658
  return (tmp___0);
}
}
#line 2664 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_class_enum_type(struct d_info *di ) 
{ 
  struct demangle_component *tmp___0 ;

  {
  {
#line 2667
  tmp___0 = d_name(di);
  }
#line 2667
  return (tmp___0);
}
}
#line 2674 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_array_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dim ;
  int tmp___0 ;
  char const   *s ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 2680
  if ((int const   )*(di->n) == 65) {
#line 2680
    (di->n) ++;
#line 2680
    tmp___0 = 1;
  } else {
#line 2680
    tmp___0 = 0;
  }
#line 2680
  if (! tmp___0) {
#line 2681
    return ((struct demangle_component *)((void *)0));
  }
#line 2683
  peek = (char )*(di->n);
#line 2684
  if ((int )peek == 95) {
#line 2685
    dim = (struct demangle_component *)((void *)0);
  } else
#line 2686
  if ((int )peek >= 48) {
#line 2686
    if ((int )peek <= 57) {
#line 2690
      s = di->n;
      {
#line 2691
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2693
        (di->n) ++;
#line 2694
        peek = (char )*(di->n);
#line 2691
        if ((int )peek >= 48) {
#line 2691
          if (! ((int )peek <= 57)) {
#line 2691
            goto while_break;
          }
        } else {
#line 2691
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2697
      dim = d_make_name(di, s, (int )(di->n - s));
      }
#line 2698
      if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2699
        return ((struct demangle_component *)((void *)0));
      }
    } else {
#line 2686
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2703
    dim = d_expression(di);
    }
#line 2704
    if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2705
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2708
  if ((int const   )*(di->n) == 95) {
#line 2708
    (di->n) ++;
#line 2708
    tmp___1 = 1;
  } else {
#line 2708
    tmp___1 = 0;
  }
#line 2708
  if (! tmp___1) {
#line 2709
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2711
  tmp___2 = cplus_demangle_type(di);
#line 2711
  tmp___3 = d_make_comp(di, (enum demangle_component_type )42, dim, tmp___2);
  }
#line 2711
  return (tmp___3);
}
}
#line 2718 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_vector_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dim ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 2724
  peek = (char )*(di->n);
#line 2725
  if ((int )peek == 95) {
    {
#line 2727
    (di->n) ++;
#line 2728
    dim = d_expression(di);
    }
  } else {
    {
#line 2731
    dim = d_number_component(di);
    }
  }
#line 2733
  if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2734
    return ((struct demangle_component *)((void *)0));
  }
#line 2736
  if ((int const   )*(di->n) == 95) {
#line 2736
    (di->n) ++;
#line 2736
    tmp___0 = 1;
  } else {
#line 2736
    tmp___0 = 0;
  }
#line 2736
  if (! tmp___0) {
#line 2737
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2739
  tmp___1 = cplus_demangle_type(di);
#line 2739
  tmp___2 = d_make_comp(di, (enum demangle_component_type )45, dim, tmp___1);
  }
#line 2739
  return (tmp___2);
}
}
#line 2745 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_pointer_to_member_type(struct d_info *di ) 
{ 
  struct demangle_component *cl ;
  struct demangle_component *mem ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;

  {
#line 2751
  if ((int const   )*(di->n) == 77) {
#line 2751
    (di->n) ++;
#line 2751
    tmp___0 = 1;
  } else {
#line 2751
    tmp___0 = 0;
  }
#line 2751
  if (! tmp___0) {
#line 2752
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2754
  cl = cplus_demangle_type(di);
  }
#line 2755
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2756
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2773
  mem = cplus_demangle_type(di);
  }
#line 2774
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 2775
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2777
  tmp___1 = d_make_comp(di, (enum demangle_component_type )43, cl, mem);
  }
#line 2777
  return (tmp___1);
}
}
#line 2782 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static long d_compact_number(struct d_info *di ) 
{ 
  long num ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 2786
  if ((int const   )*(di->n) == 95) {
#line 2787
    num = 0L;
  } else
#line 2788
  if ((int const   )*(di->n) == 110) {
#line 2789
    return (-1L);
  } else {
    {
#line 2791
    tmp___0 = d_number(di);
#line 2791
    num = tmp___0 + 1L;
    }
  }
#line 2793
  if ((int const   )*(di->n) == 95) {
#line 2793
    (di->n) ++;
#line 2793
    tmp___1 = 1;
  } else {
#line 2793
    tmp___1 = 0;
  }
#line 2793
  if (! tmp___1) {
#line 2794
    return (-1L);
  }
#line 2795
  return (num);
}
}
#line 2802 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_param(struct d_info *di ) 
{ 
  long param ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;

  {
#line 2807
  if ((int const   )*(di->n) == 84) {
#line 2807
    (di->n) ++;
#line 2807
    tmp___0 = 1;
  } else {
#line 2807
    tmp___0 = 0;
  }
#line 2807
  if (! tmp___0) {
#line 2808
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2810
  param = d_compact_number(di);
  }
#line 2811
  if (param < 0L) {
#line 2812
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2814
  (di->did_subs) ++;
#line 2816
  tmp___1 = d_make_template_param(di, param);
  }
#line 2816
  return (tmp___1);
}
}
#line 2821 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_args(struct d_info *di ) 
{ 
  struct demangle_component *hold_last_name ;
  struct demangle_component *al ;
  struct demangle_component **pal ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *a ;

  {
#line 2831
  hold_last_name = di->last_name;
#line 2833
  if ((int const   )*(di->n) != 73) {
#line 2833
    if ((int const   )*(di->n) != 74) {
#line 2835
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2836
  (di->n) ++;
#line 2838
  if ((int const   )*(di->n) == 69) {
    {
#line 2841
    (di->n) ++;
#line 2842
    tmp___0 = d_make_comp(di, (enum demangle_component_type )47, (struct demangle_component *)((void *)0),
                          (struct demangle_component *)((void *)0));
    }
#line 2842
    return (tmp___0);
  }
#line 2845
  al = (struct demangle_component *)((void *)0);
#line 2846
  pal = & al;
  {
#line 2847
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2851
    a = d_template_arg(di);
    }
#line 2852
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 2853
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2855
    *pal = d_make_comp(di, (enum demangle_component_type )47, a, (struct demangle_component *)((void *)0));
    }
#line 2856
    if ((unsigned long )*pal == (unsigned long )((void *)0)) {
#line 2857
      return ((struct demangle_component *)((void *)0));
    }
#line 2858
    pal = & (*pal)->u.s_binary.right;
#line 2860
    if ((int const   )*(di->n) == 69) {
#line 2862
      (di->n) ++;
#line 2863
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2867
  di->last_name = hold_last_name;
#line 2869
  return (al);
}
}
#line 2877 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_arg(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
  {
#line 2884
  if ((int const   )*(di->n) == 88) {
#line 2884
    goto case_88;
  }
#line 2891
  if ((int const   )*(di->n) == 76) {
#line 2891
    goto case_76;
  }
#line 2895
  if ((int const   )*(di->n) == 74) {
#line 2895
    goto case_74;
  }
#line 2895
  if ((int const   )*(di->n) == 73) {
#line 2895
    goto case_74;
  }
#line 2899
  goto switch_default;
  case_88: /* CIL Label */ 
  {
#line 2885
  (di->n) ++;
#line 2886
  ret = d_expression(di);
  }
#line 2887
  if ((int const   )*(di->n) == 69) {
#line 2887
    (di->n) ++;
#line 2887
    tmp___0 = 1;
  } else {
#line 2887
    tmp___0 = 0;
  }
#line 2887
  if (! tmp___0) {
#line 2888
    return ((struct demangle_component *)((void *)0));
  }
#line 2889
  return (ret);
  case_76: /* CIL Label */ 
  {
#line 2892
  tmp___1 = d_expr_primary(di);
  }
#line 2892
  return (tmp___1);
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  {
#line 2897
  tmp___2 = d_template_args(di);
  }
#line 2897
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 2900
  tmp___3 = cplus_demangle_type(di);
  }
#line 2900
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2907 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_exprlist(struct d_info *di , char terminator ) 
{ 
  struct demangle_component *list ;
  struct demangle_component **p ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *arg ;
  struct demangle_component *tmp___1 ;

  {
#line 2910
  list = (struct demangle_component *)((void *)0);
#line 2911
  p = & list;
#line 2913
  if ((int const   )*(di->n) == (int const   )terminator) {
    {
#line 2915
    (di->n) ++;
#line 2916
    tmp___0 = d_make_comp(di, (enum demangle_component_type )46, (struct demangle_component *)((void *)0),
                          (struct demangle_component *)((void *)0));
    }
#line 2916
    return (tmp___0);
  }
  {
#line 2919
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2921
    tmp___1 = d_expression(di);
#line 2921
    arg = tmp___1;
    }
#line 2922
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2923
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2925
    *p = d_make_comp(di, (enum demangle_component_type )46, arg, (struct demangle_component *)((void *)0));
    }
#line 2926
    if ((unsigned long )*p == (unsigned long )((void *)0)) {
#line 2927
      return ((struct demangle_component *)((void *)0));
    }
#line 2928
    p = & (*p)->u.s_binary.right;
#line 2930
    if ((int const   )*(di->n) == (int const   )terminator) {
#line 2932
      (di->n) ++;
#line 2933
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2937
  return (list);
}
}
#line 2943 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int op_is_new_cast(struct demangle_component *op ) 
{ 
  char const   *code ;
  int tmp___0 ;

  {
#line 2946
  code = (char const   *)(op->u.s_operator.op)->code;
#line 2947
  if ((int const   )*(code + 1) == 99) {
#line 2947
    if ((int const   )*(code + 0) == 115) {
#line 2947
      tmp___0 = 1;
    } else
#line 2947
    if ((int const   )*(code + 0) == 100) {
#line 2947
      tmp___0 = 1;
    } else
#line 2947
    if ((int const   )*(code + 0) == 99) {
#line 2947
      tmp___0 = 1;
    } else
#line 2947
    if ((int const   )*(code + 0) == 114) {
#line 2947
      tmp___0 = 1;
    } else {
#line 2947
      tmp___0 = 0;
    }
  } else {
#line 2947
    tmp___0 = 0;
  }
#line 2947
  return (tmp___0);
}
}
#line 2963 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_expression(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *type ;
  struct demangle_component *name___0 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  int index___0 ;
  long tmp___8 ;
  struct demangle_component *tmp___9 ;
  struct demangle_component *name___1 ;
  struct demangle_component *tmp___10 ;
  struct demangle_component *tmp___11 ;
  struct demangle_component *type___0 ;
  struct demangle_component *tmp___12 ;
  struct demangle_component *tmp___13 ;
  struct demangle_component *op ;
  char const   *code ;
  int args ;
  struct demangle_component *tmp___14 ;
  struct demangle_component *tmp___15 ;
  int tmp___16 ;
  struct demangle_component *tmp___17 ;
  struct demangle_component *operand ;
  int suffix ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct demangle_component *tmp___21 ;
  struct demangle_component *tmp___22 ;
  struct demangle_component *tmp___23 ;
  struct demangle_component *left ;
  struct demangle_component *right ;
  int tmp___24 ;
  struct demangle_component *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  struct demangle_component *tmp___29 ;
  struct demangle_component *tmp___30 ;
  struct demangle_component *first ;
  struct demangle_component *second ;
  struct demangle_component *third ;
  int tmp___31 ;
  struct demangle_component *tmp___32 ;
  struct demangle_component *tmp___33 ;
  struct demangle_component *tmp___34 ;

  {
#line 2968
  peek = (char )*(di->n);
#line 2969
  if ((int )peek == 76) {
    {
#line 2970
    tmp___0 = d_expr_primary(di);
    }
#line 2970
    return (tmp___0);
  } else
#line 2971
  if ((int )peek == 84) {
    {
#line 2972
    tmp___1 = d_template_param(di);
    }
#line 2972
    return (tmp___1);
  } else
#line 2973
  if ((int )peek == 115) {
#line 2973
    if ((int const   )*(di->n + 1) == 114) {
      {
#line 2978
      di->n += 2;
#line 2979
      type = cplus_demangle_type(di);
#line 2980
      name___0 = d_unqualified_name(di);
      }
#line 2981
      if ((int const   )*(di->n) != 73) {
        {
#line 2982
        tmp___2 = d_make_comp(di, (enum demangle_component_type )1, type, name___0);
        }
#line 2982
        return (tmp___2);
      } else {
        {
#line 2984
        tmp___3 = d_template_args(di);
#line 2984
        tmp___4 = d_make_comp(di, (enum demangle_component_type )4, name___0, tmp___3);
#line 2984
        tmp___5 = d_make_comp(di, (enum demangle_component_type )1, type, tmp___4);
        }
#line 2984
        return (tmp___5);
      }
    } else {
#line 2973
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2988
  if ((int )peek == 115) {
#line 2988
    if ((int const   )*(di->n + 1) == 112) {
      {
#line 2990
      di->n += 2;
#line 2991
      tmp___6 = d_expression(di);
#line 2991
      tmp___7 = d_make_comp(di, (enum demangle_component_type )73, tmp___6, (struct demangle_component *)((void *)0));
      }
#line 2991
      return (tmp___7);
    } else {
#line 2988
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2994
  if ((int )peek == 102) {
#line 2994
    if ((int const   )*(di->n + 1) == 112) {
#line 2998
      di->n += 2;
#line 2999
      if ((int const   )*(di->n) == 84) {
#line 3002
        (di->n) ++;
#line 3003
        index___0 = 0;
      } else {
        {
#line 3007
        tmp___8 = d_compact_number(di);
#line 3007
        index___0 = (int )(tmp___8 + 1L);
        }
#line 3008
        if (index___0 == 0) {
#line 3009
          return ((struct demangle_component *)((void *)0));
        }
      }
      {
#line 3011
      tmp___9 = d_make_function_param(di, (long )index___0);
      }
#line 3011
      return (tmp___9);
    } else {
#line 2994
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 3013
  if ((int )peek >= 48) {
#line 3013
    if ((int )peek <= 57) {
#line 3013
      goto _L___4;
    } else {
#line 3013
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 3013
  if ((int )peek == 111) {
#line 3013
    if ((int const   )*(di->n + 1) == 110) {
      _L___4: /* CIL Label */ 
#line 3020
      if ((int )peek == 111) {
#line 3022
        di->n += 2;
      }
      {
#line 3024
      name___1 = d_unqualified_name(di);
      }
#line 3025
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
#line 3026
        return ((struct demangle_component *)((void *)0));
      }
#line 3027
      if ((int const   )*(di->n) == 73) {
        {
#line 3028
        tmp___10 = d_template_args(di);
#line 3028
        tmp___11 = d_make_comp(di, (enum demangle_component_type )4, name___1, tmp___10);
        }
#line 3028
        return (tmp___11);
      } else {
#line 3031
        return (name___1);
      }
    } else {
#line 3013
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 3033
  if ((int )peek == 105) {
#line 3033
    goto _L___3;
  } else
#line 3033
  if ((int )peek == 116) {
    _L___3: /* CIL Label */ 
#line 3033
    if ((int const   )*(di->n + 1) == 108) {
#line 3037
      type___0 = (struct demangle_component *)((void *)0);
#line 3038
      if ((int )peek == 116) {
        {
#line 3039
        type___0 = cplus_demangle_type(di);
        }
      }
      {
#line 3040
      di->n += 2;
#line 3041
      tmp___12 = d_exprlist(di, (char )'E');
#line 3041
      tmp___13 = d_make_comp(di, (enum demangle_component_type )48, type___0, tmp___12);
      }
#line 3041
      return (tmp___13);
    } else {
#line 3033
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 3047
    code = (char const   *)((void *)0);
#line 3050
    op = d_operator_name(di);
    }
#line 3051
    if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 3052
      return ((struct demangle_component *)((void *)0));
    }
#line 3054
    if ((unsigned int )op->type == 49U) {
      {
#line 3056
      code = (char const   *)(op->u.s_operator.op)->code;
#line 3057
      di->expansion += (int )((op->u.s_operator.op)->len - 2);
#line 3058
      tmp___16 = strcmp(code, "st");
      }
#line 3058
      if (tmp___16 == 0) {
        {
#line 3059
        tmp___14 = cplus_demangle_type(di);
#line 3059
        tmp___15 = d_make_comp(di, (enum demangle_component_type )53, op, tmp___14);
        }
#line 3059
        return (tmp___15);
      }
    }
    {
#line 3067
    if ((unsigned int )op->type == 49U) {
#line 3067
      goto case_49;
    }
#line 3070
    if ((unsigned int )op->type == 50U) {
#line 3070
      goto case_50;
    }
#line 3073
    if ((unsigned int )op->type == 51U) {
#line 3073
      goto case_51;
    }
#line 3065
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 3066
    return ((struct demangle_component *)((void *)0));
    case_49: /* CIL Label */ 
#line 3068
    args = (int )(op->u.s_operator.op)->args;
#line 3069
    goto switch_break;
    case_50: /* CIL Label */ 
#line 3071
    args = op->u.s_extended_operator.args;
#line 3072
    goto switch_break;
    case_51: /* CIL Label */ 
#line 3074
    args = 1;
#line 3075
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3080
    if (args == 0) {
#line 3080
      goto case_0;
    }
#line 3083
    if (args == 1) {
#line 3083
      goto case_1;
    }
#line 3109
    if (args == 2) {
#line 3109
      goto case_2;
    }
#line 3135
    if (args == 3) {
#line 3135
      goto case_3;
    }
#line 3184
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 3081
    tmp___17 = d_make_comp(di, (enum demangle_component_type )52, op, (struct demangle_component *)((void *)0));
    }
#line 3081
    return (tmp___17);
    case_1: /* CIL Label */ 
#line 3086
    suffix = 0;
#line 3088
    if (code) {
#line 3088
      if ((int const   )*(code + 0) == 112) {
#line 3088
        goto _L;
      } else
#line 3088
      if ((int const   )*(code + 0) == 109) {
        _L: /* CIL Label */ 
#line 3088
        if ((int const   )*(code + 1) == (int const   )*(code + 0)) {
#line 3091
          if ((int const   )*(di->n) == 95) {
#line 3091
            (di->n) ++;
#line 3091
            tmp___18 = 1;
          } else {
#line 3091
            tmp___18 = 0;
          }
#line 3091
          if (tmp___18) {
#line 3091
            tmp___19 = 0;
          } else {
#line 3091
            tmp___19 = 1;
          }
#line 3091
          suffix = tmp___19;
        }
      }
    }
#line 3093
    if ((unsigned int )op->type == 51U) {
#line 3093
      if ((int const   )*(di->n) == 95) {
#line 3093
        (di->n) ++;
#line 3093
        tmp___20 = 1;
      } else {
#line 3093
        tmp___20 = 0;
      }
#line 3093
      if (tmp___20) {
        {
#line 3095
        operand = d_exprlist(di, (char )'E');
        }
      } else {
        {
#line 3097
        operand = d_expression(di);
        }
      }
    } else {
      {
#line 3097
      operand = d_expression(di);
      }
    }
#line 3099
    if (suffix) {
      {
#line 3101
      tmp___21 = d_make_comp(di, (enum demangle_component_type )55, operand, operand);
#line 3101
      tmp___22 = d_make_comp(di, (enum demangle_component_type )53, op, tmp___21);
      }
#line 3101
      return (tmp___22);
    } else {
      {
#line 3106
      tmp___23 = d_make_comp(di, (enum demangle_component_type )53, op, operand);
      }
#line 3106
      return (tmp___23);
    }
    case_2: /* CIL Label */ 
    {
#line 3114
    tmp___24 = op_is_new_cast(op);
    }
#line 3114
    if (tmp___24) {
      {
#line 3115
      left = cplus_demangle_type(di);
      }
    } else {
      {
#line 3117
      left = d_expression(di);
      }
    }
    {
#line 3118
    tmp___28 = strcmp(code, "cl");
    }
#line 3118
    if (tmp___28) {
      {
#line 3120
      tmp___26 = strcmp(code, "dt");
      }
#line 3120
      if (tmp___26) {
        {
#line 3120
        tmp___27 = strcmp(code, "pt");
        }
#line 3120
        if (tmp___27) {
          {
#line 3128
          right = d_expression(di);
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 3122
          right = d_unqualified_name(di);
          }
#line 3123
          if ((int const   )*(di->n) == 73) {
            {
#line 3124
            tmp___25 = d_template_args(di);
#line 3124
            right = d_make_comp(di, (enum demangle_component_type )4, right, tmp___25);
            }
          }
        }
      } else {
#line 3120
        goto _L___0;
      }
    } else {
      {
#line 3119
      right = d_exprlist(di, (char )'E');
      }
    }
    {
#line 3130
    tmp___29 = d_make_comp(di, (enum demangle_component_type )55, left, right);
#line 3130
    tmp___30 = d_make_comp(di, (enum demangle_component_type )54, op, tmp___29);
    }
#line 3130
    return (tmp___30);
    case_3: /* CIL Label */ 
    {
#line 3141
    tmp___31 = strcmp(code, "qu");
    }
#line 3141
    if (tmp___31) {
#line 3148
      if ((int const   )*(code + 0) == 110) {
#line 3151
        if ((int const   )*(code + 1) != 119) {
#line 3151
          if ((int const   )*(code + 1) != 97) {
#line 3152
            return ((struct demangle_component *)((void *)0));
          }
        }
        {
#line 3153
        first = d_exprlist(di, (char )'_');
#line 3154
        second = cplus_demangle_type(di);
        }
#line 3155
        if ((int const   )*(di->n) == 69) {
#line 3157
          (di->n) ++;
#line 3158
          third = (struct demangle_component *)((void *)0);
        } else
#line 3160
        if ((int const   )*(di->n) == 112) {
#line 3160
          if ((int const   )*(di->n + 1) == 105) {
            {
#line 3164
            di->n += 2;
#line 3165
            third = d_exprlist(di, (char )'E');
            }
          } else {
#line 3160
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3167
        if ((int const   )*(di->n) == 105) {
#line 3167
          if ((int const   )*(di->n + 1) == 108) {
            {
#line 3170
            third = d_expression(di);
            }
          } else {
#line 3172
            return ((struct demangle_component *)((void *)0));
          }
        } else {
#line 3172
          return ((struct demangle_component *)((void *)0));
        }
      } else {
#line 3175
        return ((struct demangle_component *)((void *)0));
      }
    } else {
      {
#line 3144
      first = d_expression(di);
#line 3145
      second = d_expression(di);
#line 3146
      third = d_expression(di);
      }
    }
    {
#line 3176
    tmp___32 = d_make_comp(di, (enum demangle_component_type )58, second, third);
#line 3176
    tmp___33 = d_make_comp(di, (enum demangle_component_type )57, first, tmp___32);
#line 3176
    tmp___34 = d_make_comp(di, (enum demangle_component_type )56, op, tmp___33);
    }
#line 3176
    return (tmp___34);
    switch_default___0: /* CIL Label */ 
#line 3185
    return ((struct demangle_component *)((void *)0));
    switch_break___0: /* CIL Label */ ;
    }
  }
}
}
#line 3195 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_expr_primary(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  struct demangle_component *type ;
  enum demangle_component_type t ;
  char const   *s ;
  struct demangle_component *tmp___1 ;
  int tmp___2 ;

  {
#line 3200
  if ((int const   )*(di->n) == 76) {
#line 3200
    (di->n) ++;
#line 3200
    tmp___0 = 1;
  } else {
#line 3200
    tmp___0 = 0;
  }
#line 3200
  if (! tmp___0) {
#line 3201
    return ((struct demangle_component *)((void *)0));
  }
#line 3202
  if ((int const   )*(di->n) == 95) {
    {
#line 3205
    ret = cplus_demangle_mangled_name(di, 0);
    }
  } else
#line 3202
  if ((int const   )*(di->n) == 90) {
    {
#line 3205
    ret = cplus_demangle_mangled_name(di, 0);
    }
  } else {
    {
#line 3212
    type = cplus_demangle_type(di);
    }
#line 3213
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3214
      return ((struct demangle_component *)((void *)0));
    }
#line 3218
    if ((unsigned int )type->type == 39U) {
#line 3218
      if ((unsigned int const   )(type->u.s_builtin.type)->print != 0U) {
#line 3220
        di->expansion -= (int )(type->u.s_builtin.type)->len;
      }
    }
#line 3233
    t = (enum demangle_component_type )59;
#line 3234
    if ((int const   )*(di->n) == 110) {
#line 3236
      t = (enum demangle_component_type )60;
#line 3237
      (di->n) ++;
    }
#line 3239
    s = di->n;
    {
#line 3240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3240
      if (! ((int const   )*(di->n) != 69)) {
#line 3240
        goto while_break;
      }
#line 3242
      if ((int const   )*(di->n) == 0) {
#line 3243
        return ((struct demangle_component *)((void *)0));
      }
#line 3244
      (di->n) ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3246
    tmp___1 = d_make_name(di, s, (int )(di->n - s));
#line 3246
    ret = d_make_comp(di, t, type, tmp___1);
    }
  }
#line 3248
  if ((int const   )*(di->n) == 69) {
#line 3248
    (di->n) ++;
#line 3248
    tmp___2 = 1;
  } else {
#line 3248
    tmp___2 = 0;
  }
#line 3248
  if (! tmp___2) {
#line 3249
    return ((struct demangle_component *)((void *)0));
  }
#line 3250
  return (ret);
}
}
#line 3258 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_local_name(struct d_info *di ) 
{ 
  struct demangle_component *function ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *name___0 ;
  int num ;
  long tmp___5 ;
  int tmp___6 ;
  struct demangle_component *tmp___7 ;

  {
#line 3263
  if ((int const   )*(di->n) == 90) {
#line 3263
    (di->n) ++;
#line 3263
    tmp___0 = 1;
  } else {
#line 3263
    tmp___0 = 0;
  }
#line 3263
  if (! tmp___0) {
#line 3264
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3266
  function = d_encoding(di, 0);
  }
#line 3268
  if ((int const   )*(di->n) == 69) {
#line 3268
    (di->n) ++;
#line 3268
    tmp___1 = 1;
  } else {
#line 3268
    tmp___1 = 0;
  }
#line 3268
  if (! tmp___1) {
#line 3269
    return ((struct demangle_component *)((void *)0));
  }
#line 3271
  if ((int const   )*(di->n) == 115) {
    {
#line 3273
    (di->n) ++;
#line 3274
    tmp___2 = d_discriminator(di);
    }
#line 3274
    if (! tmp___2) {
#line 3275
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 3276
    tmp___3 = d_make_name(di, "string literal", (int )(sizeof("string literal") - 1UL));
#line 3276
    tmp___4 = d_make_comp(di, (enum demangle_component_type )2, function, tmp___3);
    }
#line 3276
    return (tmp___4);
  } else {
#line 3283
    num = -1;
#line 3285
    if ((int const   )*(di->n) == 100) {
      {
#line 3288
      (di->n) ++;
#line 3289
      tmp___5 = d_compact_number(di);
#line 3289
      num = (int )tmp___5;
      }
#line 3290
      if (num < 0) {
#line 3291
        return ((struct demangle_component *)((void *)0));
      }
    }
    {
#line 3294
    name___0 = d_name(di);
    }
#line 3295
    if (name___0) {
      {
#line 3300
      if ((unsigned int )name___0->type == 70U) {
#line 3300
        goto case_70;
      }
#line 3300
      if ((unsigned int )name___0->type == 68U) {
#line 3300
        goto case_70;
      }
#line 3302
      goto switch_default;
      case_70: /* CIL Label */ 
      case_68: /* CIL Label */ 
#line 3301
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3303
      tmp___6 = d_discriminator(di);
      }
#line 3303
      if (! tmp___6) {
#line 3304
        return ((struct demangle_component *)((void *)0));
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 3306
    if (num >= 0) {
      {
#line 3307
      name___0 = d_make_default_arg(di, num, name___0);
      }
    }
    {
#line 3308
    tmp___7 = d_make_comp(di, (enum demangle_component_type )2, function, name___0);
    }
#line 3308
    return (tmp___7);
  }
}
}
#line 3317 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int d_discriminator(struct d_info *di ) 
{ 
  long discrim ;

  {
#line 3322
  if ((int const   )*(di->n) != 95) {
#line 3323
    return (1);
  }
  {
#line 3324
  (di->n) ++;
#line 3325
  discrim = d_number(di);
  }
#line 3326
  if (discrim < 0L) {
#line 3327
    return (0);
  }
#line 3328
  return (1);
}
}
#line 3333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_lambda(struct d_info *di ) 
{ 
  struct demangle_component *tl ;
  struct demangle_component *ret ;
  int num ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 3340
  if ((int const   )*(di->n) == 85) {
#line 3340
    (di->n) ++;
#line 3340
    tmp___0 = 1;
  } else {
#line 3340
    tmp___0 = 0;
  }
#line 3340
  if (! tmp___0) {
#line 3341
    return ((struct demangle_component *)((void *)0));
  }
#line 3342
  if ((int const   )*(di->n) == 108) {
#line 3342
    (di->n) ++;
#line 3342
    tmp___1 = 1;
  } else {
#line 3342
    tmp___1 = 0;
  }
#line 3342
  if (! tmp___1) {
#line 3343
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3345
  tl = d_parmlist(di);
  }
#line 3346
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 3347
    return ((struct demangle_component *)((void *)0));
  }
#line 3349
  if ((int const   )*(di->n) == 69) {
#line 3349
    (di->n) ++;
#line 3349
    tmp___2 = 1;
  } else {
#line 3349
    tmp___2 = 0;
  }
#line 3349
  if (! tmp___2) {
#line 3350
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3352
  tmp___3 = d_compact_number(di);
#line 3352
  num = (int )tmp___3;
  }
#line 3353
  if (num < 0) {
#line 3354
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3356
  ret = d_make_empty(di);
  }
#line 3357
  if (ret) {
#line 3359
    ret->type = (enum demangle_component_type )68;
#line 3360
    ret->u.s_unary_num.sub = tl;
#line 3361
    ret->u.s_unary_num.num = num;
  }
  {
#line 3364
  tmp___4 = d_add_substitution(di, ret);
  }
#line 3364
  if (! tmp___4) {
#line 3365
    return ((struct demangle_component *)((void *)0));
  }
#line 3367
  return (ret);
}
}
#line 3372 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_unnamed_type(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  long num ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3378
  if ((int const   )*(di->n) == 85) {
#line 3378
    (di->n) ++;
#line 3378
    tmp___0 = 1;
  } else {
#line 3378
    tmp___0 = 0;
  }
#line 3378
  if (! tmp___0) {
#line 3379
    return ((struct demangle_component *)((void *)0));
  }
#line 3380
  if ((int const   )*(di->n) == 116) {
#line 3380
    (di->n) ++;
#line 3380
    tmp___1 = 1;
  } else {
#line 3380
    tmp___1 = 0;
  }
#line 3380
  if (! tmp___1) {
#line 3381
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3383
  num = d_compact_number(di);
  }
#line 3384
  if (num < 0L) {
#line 3385
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3387
  ret = d_make_empty(di);
  }
#line 3388
  if (ret) {
#line 3390
    ret->type = (enum demangle_component_type )70;
#line 3391
    ret->u.s_number.number = num;
  }
  {
#line 3394
  tmp___2 = d_add_substitution(di, ret);
  }
#line 3394
  if (! tmp___2) {
#line 3395
    return ((struct demangle_component *)((void *)0));
  }
#line 3397
  return (ret);
}
}
#line 3403 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_clone_suffix(struct d_info *di , struct demangle_component *encoding ) 
{ 
  char const   *suffix ;
  char const   *pend ;
  struct demangle_component *n ;
  struct demangle_component *tmp___0 ;

  {
#line 3406
  suffix = di->n;
#line 3407
  pend = suffix;
#line 3410
  if ((int const   )*pend == 46) {
#line 3410
    if ((int const   )*(pend + 1) >= 97) {
#line 3410
      if ((int const   )*(pend + 1) <= 122) {
#line 3410
        goto _L___0;
      } else {
#line 3410
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3410
    if ((int const   )*(pend + 1) == 95) {
      _L___0: /* CIL Label */ 
#line 3412
      pend += 2;
      {
#line 3413
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3413
        if ((int const   )*pend >= 97) {
#line 3413
          if (! ((int const   )*pend <= 122)) {
#line 3413
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3413
        if (! ((int const   )*pend == 95)) {
#line 3413
          goto while_break;
        }
#line 3414
        pend ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 3416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3416
    if ((int const   )*pend == 46) {
#line 3416
      if ((int const   )*(pend + 1) >= 48) {
#line 3416
        if (! ((int const   )*(pend + 1) <= 57)) {
#line 3416
          goto while_break___0;
        }
      } else {
#line 3416
        goto while_break___0;
      }
    } else {
#line 3416
      goto while_break___0;
    }
#line 3418
    pend += 2;
    {
#line 3419
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3419
      if ((int const   )*pend >= 48) {
#line 3419
        if (! ((int const   )*pend <= 57)) {
#line 3419
          goto while_break___1;
        }
      } else {
#line 3419
        goto while_break___1;
      }
#line 3420
      pend ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3422
  di->n += pend - suffix;
#line 3423
  n = d_make_name(di, suffix, (int )(pend - suffix));
#line 3424
  tmp___0 = d_make_comp(di, (enum demangle_component_type )75, encoding, n);
  }
#line 3424
  return (tmp___0);
}
}
#line 3429 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int d_add_substitution(struct d_info *di , struct demangle_component *dc ) 
{ 


  {
#line 3432
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 3433
    return (0);
  }
#line 3434
  if (di->next_sub >= di->num_subs) {
#line 3435
    return (0);
  }
#line 3436
  *(di->subs + di->next_sub) = dc;
#line 3437
  (di->next_sub) ++;
#line 3438
  return (1);
}
}
#line 3460 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct d_standard_sub_info  const  standard_subs[7]  = {      {(char )'t', "std", (int )(sizeof("std") - 1UL), "std", (int )(sizeof("std") - 1UL),
      (char const   *)((void *)0), 0}, 
        {(char )'a', "std::allocator", (int )(sizeof("std::allocator") - 1UL), "std::allocator",
      (int )(sizeof("std::allocator") - 1UL), "allocator", (int )(sizeof("allocator") - 1UL)}, 
        {(char )'b',
      "std::basic_string", (int )(sizeof("std::basic_string") - 1UL), "std::basic_string",
      (int )(sizeof("std::basic_string") - 1UL), "basic_string", (int )(sizeof("basic_string") - 1UL)}, 
        {(char )'s',
      "std::string", (int )(sizeof("std::string") - 1UL), "std::basic_string<char, std::char_traits<char>, std::allocator<char> >",
      (int )(sizeof("std::basic_string<char, std::char_traits<char>, std::allocator<char> >") - 1UL),
      "basic_string", (int )(sizeof("basic_string") - 1UL)}, 
        {(char )'i', "std::istream", (int )(sizeof("std::istream") - 1UL), "std::basic_istream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_istream<char, std::char_traits<char> >") - 1UL), "basic_istream",
      (int )(sizeof("basic_istream") - 1UL)}, 
        {(char )'o', "std::ostream", (int )(sizeof("std::ostream") - 1UL), "std::basic_ostream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_ostream<char, std::char_traits<char> >") - 1UL), "basic_ostream",
      (int )(sizeof("basic_ostream") - 1UL)}, 
        {(char )'d', "std::iostream", (int )(sizeof("std::iostream") - 1UL), "std::basic_iostream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_iostream<char, std::char_traits<char> >") - 1UL),
      "basic_iostream", (int )(sizeof("basic_iostream") - 1UL)}};
#line 3485 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_substitution(struct d_info *di , int prefix ) 
{ 
  char c ;
  int tmp___0 ;
  char const   *tmp___1 ;
  unsigned int id ;
  unsigned int new_id ;
  char const   *tmp___2 ;
  int verbose ;
  struct d_standard_sub_info  const  *p ;
  struct d_standard_sub_info  const  *pend ;
  char peek ;
  char const   *s ;
  int len ;
  struct demangle_component *tmp___3 ;

  {
#line 3490
  if ((int const   )*(di->n) == 83) {
#line 3490
    (di->n) ++;
#line 3490
    tmp___0 = 1;
  } else {
#line 3490
    tmp___0 = 0;
  }
#line 3490
  if (! tmp___0) {
#line 3491
    return ((struct demangle_component *)((void *)0));
  }
#line 3493
  if ((int const   )*(di->n) == 0) {
#line 3493
    c = (char )'\000';
  } else {
#line 3493
    tmp___1 = di->n;
#line 3493
    (di->n) ++;
#line 3493
    c = (char )*tmp___1;
  }
#line 3494
  if ((int )c == 95) {
#line 3494
    goto _L___0;
  } else
#line 3494
  if ((int )c >= 48) {
#line 3494
    if ((int )c <= 57) {
#line 3494
      goto _L___0;
    } else {
#line 3494
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3494
  if ((int )c >= 65) {
#line 3494
    if ((int )c <= 90) {
      _L___0: /* CIL Label */ 
#line 3498
      id = 0U;
#line 3499
      if ((int )c != 95) {
        {
#line 3501
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3505
          if ((int )c >= 48) {
#line 3505
            if ((int )c <= 57) {
#line 3506
              new_id = (id * 36U + (unsigned int )c) - 48U;
            } else {
#line 3505
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 3507
          if ((int )c >= 65) {
#line 3507
            if ((int )c <= 90) {
#line 3508
              new_id = ((id * 36U + (unsigned int )c) - 65U) + 10U;
            } else {
#line 3510
              return ((struct demangle_component *)((void *)0));
            }
          } else {
#line 3510
            return ((struct demangle_component *)((void *)0));
          }
#line 3511
          if (new_id < id) {
#line 3512
            return ((struct demangle_component *)((void *)0));
          }
#line 3513
          id = new_id;
#line 3514
          if ((int const   )*(di->n) == 0) {
#line 3514
            c = (char )'\000';
          } else {
#line 3514
            tmp___2 = di->n;
#line 3514
            (di->n) ++;
#line 3514
            c = (char )*tmp___2;
          }
#line 3501
          if (! ((int )c != 95)) {
#line 3501
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 3518
        id ++;
      }
#line 3521
      if (id >= (unsigned int )di->next_sub) {
#line 3522
        return ((struct demangle_component *)((void *)0));
      }
#line 3524
      (di->did_subs) ++;
#line 3526
      return (*(di->subs + id));
    } else {
#line 3494
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 3534
    verbose = (di->options & (1 << 3)) != 0;
#line 3535
    if (! verbose) {
#line 3535
      if (prefix) {
#line 3539
        peek = (char )*(di->n);
#line 3540
        if ((int )peek == 67) {
#line 3541
          verbose = 1;
        } else
#line 3540
        if ((int )peek == 68) {
#line 3541
          verbose = 1;
        }
      }
    }
#line 3544
    pend = & standard_subs[0] + sizeof(standard_subs) / sizeof(standard_subs[0]);
#line 3546
    p = & standard_subs[0];
    {
#line 3546
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3546
      if (! ((unsigned long )p < (unsigned long )pend)) {
#line 3546
        goto while_break___0;
      }
#line 3548
      if ((int )c == (int )p->code) {
#line 3553
        if ((unsigned long )p->set_last_name != (unsigned long )((void *)0)) {
          {
#line 3554
          di->last_name = d_make_sub(di, (char const   *)p->set_last_name, (int )p->set_last_name_len);
          }
        }
#line 3556
        if (verbose) {
#line 3558
          s = (char const   *)p->full_expansion;
#line 3559
          len = (int )p->full_len;
        } else {
#line 3563
          s = (char const   *)p->simple_expansion;
#line 3564
          len = (int )p->simple_len;
        }
        {
#line 3566
        di->expansion += len;
#line 3567
        tmp___3 = d_make_sub(di, s, len);
        }
#line 3567
        return (tmp___3);
      }
#line 3546
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3571
    return ((struct demangle_component *)((void *)0));
  }
}
}
#line 3577 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_growable_string_init(struct d_growable_string *dgs , size_t estimate ) 
{ 


  {
#line 3580
  dgs->buf = (char *)((void *)0);
#line 3581
  dgs->len = (size_t )0;
#line 3582
  dgs->alc = (size_t )0;
#line 3583
  dgs->allocation_failure = 0;
#line 3585
  if (estimate > 0UL) {
    {
#line 3586
    d_growable_string_resize(dgs, estimate);
    }
  }
#line 3587
  return;
}
}
#line 3591 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_growable_string_resize(struct d_growable_string *dgs , size_t need ) 
{ 
  size_t newalc ;
  char *newbuf ;
  void *tmp___0 ;

  {
#line 3597
  if (dgs->allocation_failure) {
#line 3598
    return;
  }
#line 3603
  if (dgs->alc > 0UL) {
#line 3603
    newalc = dgs->alc;
  } else {
#line 3603
    newalc = (size_t )2;
  }
  {
#line 3604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3604
    if (! (newalc < need)) {
#line 3604
      goto while_break;
    }
#line 3605
    newalc <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3607
  tmp___0 = realloc((void *)dgs->buf, newalc);
#line 3607
  newbuf = (char *)tmp___0;
  }
#line 3608
  if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
    {
#line 3610
    free((void *)dgs->buf);
#line 3611
    dgs->buf = (char *)((void *)0);
#line 3612
    dgs->len = (size_t )0;
#line 3613
    dgs->alc = (size_t )0;
#line 3614
    dgs->allocation_failure = 1;
    }
#line 3615
    return;
  }
#line 3617
  dgs->buf = newbuf;
#line 3618
  dgs->alc = newalc;
#line 3619
  return;
}
}
#line 3623 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_growable_string_append_buffer(struct d_growable_string *dgs ,
                                                     char const   *s , size_t l ) 
{ 
  size_t need ;

  {
#line 3629
  need = (dgs->len + l) + 1UL;
#line 3630
  if (need > dgs->alc) {
    {
#line 3631
    d_growable_string_resize(dgs, need);
    }
  }
#line 3633
  if (dgs->allocation_failure) {
#line 3634
    return;
  }
  {
#line 3636
  memcpy((void */* __restrict  */)(dgs->buf + dgs->len), (void const   */* __restrict  */)s,
         l);
#line 3637
  *(dgs->buf + (dgs->len + l)) = (char )'\000';
#line 3638
  dgs->len += l;
  }
#line 3639
  return;
}
}
#line 3643 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_growable_string_callback_adapter(char const   *s , size_t l , void *opaque ) 
{ 
  struct d_growable_string *dgs ;

  {
  {
#line 3646
  dgs = (struct d_growable_string *)opaque;
#line 3648
  d_growable_string_append_buffer(dgs, s, l);
  }
#line 3649
  return;
}
}
#line 3653 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_init(struct d_print_info *dpi , void (*callback)(char const   * ,
                                                                     size_t  , void * ) ,
                         void *opaque ) 
{ 


  {
#line 3657
  dpi->len = (size_t )0;
#line 3658
  dpi->last_char = (char )'\000';
#line 3659
  dpi->templates = (struct d_print_template *)((void *)0);
#line 3660
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 3661
  dpi->pack_index = 0;
#line 3662
  dpi->flush_count = 0UL;
#line 3664
  dpi->callback = callback;
#line 3665
  dpi->opaque = opaque;
#line 3667
  dpi->demangle_failure = 0;
#line 3668
  return;
}
}
#line 3672 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_print_error(struct d_print_info *dpi ) 
{ 


  {
#line 3675
  dpi->demangle_failure = 1;
#line 3676
  return;
}
}
#line 3678 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static int d_print_saw_error(struct d_print_info *dpi ) 
{ 


  {
#line 3681
  return (dpi->demangle_failure != 0);
}
}
#line 3686 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_print_flush(struct d_print_info *dpi ) 
{ 


  {
  {
#line 3689
  dpi->buf[dpi->len] = (char )'\000';
#line 3690
  (*(dpi->callback))((char const   *)(dpi->buf), dpi->len, dpi->opaque);
#line 3691
  dpi->len = (size_t )0;
#line 3692
  (dpi->flush_count) ++;
  }
#line 3693
  return;
}
}
#line 3697 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_append_char(struct d_print_info *dpi , char c ) 
{ 
  size_t tmp___0 ;

  {
#line 3700
  if (dpi->len == sizeof(dpi->buf) - 1UL) {
    {
#line 3701
    d_print_flush(dpi);
    }
  }
#line 3703
  tmp___0 = dpi->len;
#line 3703
  (dpi->len) ++;
#line 3703
  dpi->buf[tmp___0] = c;
#line 3704
  dpi->last_char = c;
#line 3705
  return;
}
}
#line 3707 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_append_buffer(struct d_print_info *dpi , char const   *s ,
                                     size_t l ) 
{ 
  size_t i ;

  {
#line 3712
  i = (size_t )0;
  {
#line 3712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3712
    if (! (i < l)) {
#line 3712
      goto while_break;
    }
    {
#line 3713
    d_append_char(dpi, (char )*(s + i));
#line 3712
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3714
  return;
}
}
#line 3716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_append_string(struct d_print_info *dpi , char const   *s ) 
{ 
  size_t tmp___0 ;

  {
  {
#line 3719
  tmp___0 = strlen(s);
#line 3719
  d_append_buffer(dpi, s, tmp___0);
  }
#line 3720
  return;
}
}
#line 3722 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static void d_append_num(struct d_print_info *dpi , long l ) 
{ 
  char buf___7[25] ;

  {
  {
#line 3726
  sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%ld",
          l);
#line 3727
  d_append_string(dpi, (char const   *)(buf___7));
  }
#line 3728
  return;
}
}
#line 3730 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
__inline static char d_last_char(struct d_print_info *dpi ) 
{ 


  {
#line 3733
  return (dpi->last_char);
}
}
#line 3746 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_print_callback(int options___0 , struct demangle_component  const  *dc ,
                                  void (*callback)(char const   * , size_t  , void * ) ,
                                  void *opaque ) 
{ 
  struct d_print_info dpi ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3753
  d_print_init(& dpi, callback, opaque);
#line 3755
  d_print_comp(& dpi, options___0, dc);
#line 3757
  d_print_flush(& dpi);
#line 3759
  tmp___0 = d_print_saw_error(& dpi);
  }
#line 3759
  if (tmp___0) {
#line 3759
    tmp___1 = 0;
  } else {
#line 3759
    tmp___1 = 1;
  }
#line 3759
  return (tmp___1);
}
}
#line 3771 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
char *cplus_demangle_print(int options___0 , struct demangle_component  const  *dc ,
                           int estimate , size_t *palc ) 
{ 
  struct d_growable_string dgs ;
  int tmp___0 ;

  {
  {
#line 3777
  d_growable_string_init(& dgs, (size_t )estimate);
#line 3779
  tmp___0 = cplus_demangle_print_callback(options___0, dc, & d_growable_string_callback_adapter,
                                          (void *)(& dgs));
  }
#line 3779
  if (! tmp___0) {
    {
#line 3783
    free((void *)dgs.buf);
#line 3784
    *palc = (size_t )0;
    }
#line 3785
    return ((char *)((void *)0));
  }
#line 3788
  if (dgs.allocation_failure) {
#line 3788
    *palc = (size_t )1;
  } else {
#line 3788
    *palc = dgs.alc;
  }
#line 3789
  return (dgs.buf);
}
}
#line 3795 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_index_template_argument(struct demangle_component *args ,
                                                            int i ) 
{ 
  struct demangle_component *a ;

  {
#line 3800
  a = args;
  {
#line 3800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3800
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 3800
      goto while_break;
    }
#line 3804
    if ((unsigned int )a->type != 47U) {
#line 3805
      return ((struct demangle_component *)((void *)0));
    }
#line 3806
    if (i <= 0) {
#line 3807
      goto while_break;
    }
#line 3808
    i --;
#line 3800
    a = a->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 3810
  if (i != 0) {
#line 3811
    return ((struct demangle_component *)((void *)0));
  } else
#line 3810
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 3811
    return ((struct demangle_component *)((void *)0));
  }
#line 3813
  return (a->u.s_binary.left);
}
}
#line 3819 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_lookup_template_argument(struct d_print_info *dpi ,
                                                             struct demangle_component  const  *dc ) 
{ 
  struct demangle_component *tmp___0 ;

  {
#line 3823
  if ((unsigned long )dpi->templates == (unsigned long )((void *)0)) {
    {
#line 3825
    d_print_error(dpi);
    }
#line 3826
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3829
  tmp___0 = d_index_template_argument((struct demangle_component *)((dpi->templates)->template_decl)->u.s_binary.right,
                                      (int )dc->u.s_number.number);
  }
#line 3829
  return (tmp___0);
}
}
#line 3836 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static struct demangle_component *d_find_pack(struct d_print_info *dpi , struct demangle_component  const  *dc ) 
{ 
  struct demangle_component *a ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 3841
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 3842
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3846
  if ((unsigned int const   )dc->type == 5U) {
#line 3846
    goto case_5;
  }
#line 3852
  if ((unsigned int const   )dc->type == 73U) {
#line 3852
    goto case_73;
  }
#line 3863
  if ((unsigned int const   )dc->type == 70U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 6U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 63U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 24U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 39U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 49U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 74U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 0U) {
#line 3863
    goto case_70;
  }
#line 3863
  if ((unsigned int const   )dc->type == 68U) {
#line 3863
    goto case_70;
  }
#line 3866
  if ((unsigned int const   )dc->type == 50U) {
#line 3866
    goto case_50;
  }
#line 3868
  if ((unsigned int const   )dc->type == 7U) {
#line 3868
    goto case_7;
  }
#line 3870
  if ((unsigned int const   )dc->type == 8U) {
#line 3870
    goto case_8;
  }
#line 3873
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 3847
  a = d_lookup_template_argument(dpi, dc);
  }
#line 3848
  if (a) {
#line 3848
    if ((unsigned int )a->type == 47U) {
#line 3849
      return (a);
    }
  }
#line 3850
  return ((struct demangle_component *)((void *)0));
  case_73: /* CIL Label */ 
#line 3853
  return ((struct demangle_component *)((void *)0));
  case_70: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 3864
  return ((struct demangle_component *)((void *)0));
  case_50: /* CIL Label */ 
  {
#line 3867
  tmp___0 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_extended_operator.name);
  }
#line 3867
  return (tmp___0);
  case_7: /* CIL Label */ 
  {
#line 3869
  tmp___1 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_ctor.name);
  }
#line 3869
  return (tmp___1);
  case_8: /* CIL Label */ 
  {
#line 3871
  tmp___2 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_dtor.name);
  }
#line 3871
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 3874
  a = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 3875
  if (a) {
#line 3876
    return (a);
  }
  {
#line 3877
  tmp___3 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 3877
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3883 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int d_pack_length(struct demangle_component  const  *dc ) 
{ 
  int count ;

  {
#line 3886
  count = 0;
  {
#line 3887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3887
    if (dc) {
#line 3887
      if ((unsigned int const   )dc->type == 47U) {
#line 3887
        if (! ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0))) {
#line 3887
          goto while_break;
        }
      } else {
#line 3887
        goto while_break;
      }
    } else {
#line 3887
      goto while_break;
    }
#line 3890
    count ++;
#line 3891
    dc = (struct demangle_component  const  *)dc->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 3893
  return (count);
}
}
#line 3899 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_subexpr(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  int simple ;

  {
#line 3903
  simple = 0;
#line 3904
  if ((unsigned int const   )dc->type == 0U) {
#line 3908
    simple = 1;
  } else
#line 3904
  if ((unsigned int const   )dc->type == 1U) {
#line 3908
    simple = 1;
  } else
#line 3904
  if ((unsigned int const   )dc->type == 48U) {
#line 3908
    simple = 1;
  } else
#line 3904
  if ((unsigned int const   )dc->type == 6U) {
#line 3908
    simple = 1;
  }
#line 3909
  if (! simple) {
    {
#line 3910
    d_append_char(dpi, (char )'(');
    }
  }
  {
#line 3911
  d_print_comp(dpi, options___0, dc);
  }
#line 3912
  if (! simple) {
    {
#line 3913
    d_append_char(dpi, (char )')');
    }
  }
#line 3914
  return;
}
}
#line 3918 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_comp(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  struct demangle_component  const  *mod_inner ;
  int tmp___0 ;
  struct demangle_component *local_name ;
  struct d_print_mod *hold_modifiers ;
  struct demangle_component *typed_name ;
  struct d_print_mod adpm[4] ;
  unsigned int i ;
  struct d_print_template dpt ;
  struct demangle_component *local_name___0 ;
  struct d_print_mod *hold_dpm ;
  struct demangle_component *dcl ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  struct d_print_template *hold_dpt ;
  struct demangle_component *a ;
  struct demangle_component *tmp___4 ;
  struct d_print_mod *pdpm ;
  struct demangle_component  const  *sub ;
  struct demangle_component *a___0 ;
  struct demangle_component *tmp___5 ;
  struct d_print_mod dpm ;
  struct d_print_mod dpm___0 ;
  struct d_print_mod *hold_modifiers___0 ;
  struct d_print_mod adpm___0[4] ;
  unsigned int i___0 ;
  struct d_print_mod *pdpm___0 ;
  struct d_print_mod dpm___1 ;
  size_t len ;
  unsigned long flush_count ;
  struct demangle_component *type ;
  struct demangle_component *list ;
  struct demangle_operator_info  const  *op ;
  int len___0 ;
  struct demangle_component *op___0 ;
  struct demangle_component *operand ;
  char const   *code ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct demangle_component  const  *func ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct demangle_component *op___1 ;
  struct demangle_component *first ;
  struct demangle_component *second ;
  struct demangle_component *third ;
  int tmp___13 ;
  enum d_builtin_type_print tp ;
  int len___1 ;
  int i___1 ;
  struct demangle_component *a___1 ;
  struct demangle_component *tmp___14 ;
  long num ;

  {
#line 3924
  mod_inner = (struct demangle_component  const  *)((void *)0);
#line 3926
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
    {
#line 3928
    d_print_error(dpi);
    }
#line 3929
    return;
  }
  {
#line 3931
  tmp___0 = d_print_saw_error(dpi);
  }
#line 3931
  if (tmp___0) {
#line 3932
    return;
  }
  {
#line 3936
  if ((unsigned int const   )dc->type == 0U) {
#line 3936
    goto case_0;
  }
#line 3943
  if ((unsigned int const   )dc->type == 74U) {
#line 3943
    goto case_74;
  }
#line 3951
  if ((unsigned int const   )dc->type == 2U) {
#line 3951
    goto case_2;
  }
#line 3951
  if ((unsigned int const   )dc->type == 1U) {
#line 3951
    goto case_2;
  }
#line 3970
  if ((unsigned int const   )dc->type == 3U) {
#line 3970
    goto case_3;
  }
#line 4084
  if ((unsigned int const   )dc->type == 4U) {
#line 4084
    goto case_4;
  }
#line 4128
  if ((unsigned int const   )dc->type == 5U) {
#line 4128
    goto case_5;
  }
#line 4157
  if ((unsigned int const   )dc->type == 7U) {
#line 4157
    goto case_7;
  }
#line 4161
  if ((unsigned int const   )dc->type == 8U) {
#line 4161
    goto case_8;
  }
#line 4166
  if ((unsigned int const   )dc->type == 9U) {
#line 4166
    goto case_9;
  }
#line 4171
  if ((unsigned int const   )dc->type == 10U) {
#line 4171
    goto case_10;
  }
#line 4176
  if ((unsigned int const   )dc->type == 11U) {
#line 4176
    goto case_11;
  }
#line 4183
  if ((unsigned int const   )dc->type == 12U) {
#line 4183
    goto case_12;
  }
#line 4188
  if ((unsigned int const   )dc->type == 13U) {
#line 4188
    goto case_13;
  }
#line 4193
  if ((unsigned int const   )dc->type == 14U) {
#line 4193
    goto case_14;
  }
#line 4198
  if ((unsigned int const   )dc->type == 15U) {
#line 4198
    goto case_15;
  }
#line 4203
  if ((unsigned int const   )dc->type == 16U) {
#line 4203
    goto case_16;
  }
#line 4208
  if ((unsigned int const   )dc->type == 17U) {
#line 4208
    goto case_17;
  }
#line 4213
  if ((unsigned int const   )dc->type == 18U) {
#line 4213
    goto case_18;
  }
#line 4218
  if ((unsigned int const   )dc->type == 19U) {
#line 4218
    goto case_19;
  }
#line 4223
  if ((unsigned int const   )dc->type == 20U) {
#line 4223
    goto case_20;
  }
#line 4228
  if ((unsigned int const   )dc->type == 21U) {
#line 4228
    goto case_21;
  }
#line 4233
  if ((unsigned int const   )dc->type == 22U) {
#line 4233
    goto case_22;
  }
#line 4240
  if ((unsigned int const   )dc->type == 23U) {
#line 4240
    goto case_23;
  }
#line 4245
  if ((unsigned int const   )dc->type == 71U) {
#line 4245
    goto case_71;
  }
#line 4250
  if ((unsigned int const   )dc->type == 72U) {
#line 4250
    goto case_72;
  }
#line 4255
  if ((unsigned int const   )dc->type == 24U) {
#line 4255
    goto case_24;
  }
#line 4261
  if ((unsigned int const   )dc->type == 27U) {
#line 4261
    goto case_27;
  }
#line 4261
  if ((unsigned int const   )dc->type == 26U) {
#line 4261
    goto case_27;
  }
#line 4261
  if ((unsigned int const   )dc->type == 25U) {
#line 4261
    goto case_27;
  }
#line 4288
  if ((unsigned int const   )dc->type == 36U) {
#line 4288
    goto case_36;
  }
#line 4288
  if ((unsigned int const   )dc->type == 35U) {
#line 4288
    goto case_36;
  }
#line 4323
  if ((unsigned int const   )dc->type == 38U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 37U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 34U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 33U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 32U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 31U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 30U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 29U) {
#line 4323
    goto modifier;
  }
#line 4323
  if ((unsigned int const   )dc->type == 28U) {
#line 4323
    goto modifier;
  }
#line 4350
  if ((unsigned int const   )dc->type == 39U) {
#line 4350
    goto case_39;
  }
#line 4359
  if ((unsigned int const   )dc->type == 40U) {
#line 4359
    goto case_40;
  }
#line 4363
  if ((unsigned int const   )dc->type == 41U) {
#line 4363
    goto case_41;
  }
#line 4408
  if ((unsigned int const   )dc->type == 42U) {
#line 4408
    goto case_42;
  }
#line 4475
  if ((unsigned int const   )dc->type == 45U) {
#line 4475
    goto case_45;
  }
#line 4475
  if ((unsigned int const   )dc->type == 43U) {
#line 4475
    goto case_45;
  }
#line 4497
  if ((unsigned int const   )dc->type == 44U) {
#line 4497
    goto case_44;
  }
#line 4514
  if ((unsigned int const   )dc->type == 47U) {
#line 4514
    goto case_47;
  }
#line 4514
  if ((unsigned int const   )dc->type == 46U) {
#line 4514
    goto case_47;
  }
#line 4536
  if ((unsigned int const   )dc->type == 48U) {
#line 4536
    goto case_48;
  }
#line 4549
  if ((unsigned int const   )dc->type == 49U) {
#line 4549
    goto case_49;
  }
#line 4565
  if ((unsigned int const   )dc->type == 50U) {
#line 4565
    goto case_50;
  }
#line 4570
  if ((unsigned int const   )dc->type == 51U) {
#line 4570
    goto case_51;
  }
#line 4575
  if ((unsigned int const   )dc->type == 52U) {
#line 4575
    goto case_52;
  }
#line 4579
  if ((unsigned int const   )dc->type == 53U) {
#line 4579
    goto case_53;
  }
#line 4630
  if ((unsigned int const   )dc->type == 54U) {
#line 4630
    goto case_54;
  }
#line 4691
  if ((unsigned int const   )dc->type == 55U) {
#line 4691
    goto case_55;
  }
#line 4696
  if ((unsigned int const   )dc->type == 56U) {
#line 4696
    goto case_56;
  }
#line 4733
  if ((unsigned int const   )dc->type == 58U) {
#line 4733
    goto case_58;
  }
#line 4733
  if ((unsigned int const   )dc->type == 57U) {
#line 4733
    goto case_58;
  }
#line 4739
  if ((unsigned int const   )dc->type == 60U) {
#line 4739
    goto case_60;
  }
#line 4739
  if ((unsigned int const   )dc->type == 59U) {
#line 4739
    goto case_60;
  }
#line 4822
  if ((unsigned int const   )dc->type == 64U) {
#line 4822
    goto case_64;
  }
#line 4826
  if ((unsigned int const   )dc->type == 61U) {
#line 4826
    goto case_61;
  }
#line 4831
  if ((unsigned int const   )dc->type == 62U) {
#line 4831
    goto case_62;
  }
#line 4836
  if ((unsigned int const   )dc->type == 63U) {
#line 4836
    goto case_63;
  }
#line 4840
  if ((unsigned int const   )dc->type == 65U) {
#line 4840
    goto case_65;
  }
#line 4846
  if ((unsigned int const   )dc->type == 73U) {
#line 4846
    goto case_73;
  }
#line 4873
  if ((unsigned int const   )dc->type == 6U) {
#line 4873
    goto case_6___1;
  }
#line 4887
  if ((unsigned int const   )dc->type == 66U) {
#line 4887
    goto case_66;
  }
#line 4892
  if ((unsigned int const   )dc->type == 67U) {
#line 4892
    goto case_67;
  }
#line 4897
  if ((unsigned int const   )dc->type == 68U) {
#line 4897
    goto case_68;
  }
#line 4905
  if ((unsigned int const   )dc->type == 70U) {
#line 4905
    goto case_70;
  }
#line 4911
  if ((unsigned int const   )dc->type == 75U) {
#line 4911
    goto case_75;
  }
#line 4918
  goto switch_default___2;
  case_0: /* CIL Label */ 
#line 3937
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 3938
    d_append_buffer(dpi, (char const   *)dc->u.s_name.s, (size_t )dc->u.s_name.len);
    }
  } else {
    {
#line 3940
    d_print_java_identifier(dpi, (char const   *)dc->u.s_name.s, (int )dc->u.s_name.len);
    }
  }
#line 3941
  return;
  case_74: /* CIL Label */ 
  {
#line 3944
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 3945
  d_append_string(dpi, "[abi:");
#line 3946
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 3947
  d_append_char(dpi, (char )']');
  }
#line 3948
  return;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 3952
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 3953
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 3954
    d_append_string(dpi, "::");
    }
  } else {
    {
#line 3956
    d_append_char(dpi, (char )'.');
    }
  }
#line 3958
  local_name = (struct demangle_component *)dc->u.s_binary.right;
#line 3959
  if ((unsigned int )local_name->type == 69U) {
    {
#line 3961
    d_append_string(dpi, "{default arg#");
#line 3962
    d_append_num(dpi, (long )(local_name->u.s_unary_num.num + 1));
#line 3963
    d_append_string(dpi, "}::");
#line 3964
    local_name = local_name->u.s_unary_num.sub;
    }
  }
  {
#line 3966
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)local_name);
  }
#line 3968
  return;
  case_3: /* CIL Label */ 
#line 3981
  hold_modifiers = dpi->modifiers;
#line 3982
  dpi->modifiers = (struct d_print_mod *)0;
#line 3983
  i = 0U;
#line 3984
  typed_name = (struct demangle_component *)dc->u.s_binary.left;
  {
#line 3985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3985
    if (! ((unsigned long )typed_name != (unsigned long )((void *)0))) {
#line 3985
      goto while_break;
    }
#line 3987
    if ((unsigned long )i >= sizeof(adpm) / sizeof(adpm[0])) {
      {
#line 3989
      d_print_error(dpi);
      }
#line 3990
      return;
    }
#line 3993
    adpm[i].next = dpi->modifiers;
#line 3994
    dpi->modifiers = & adpm[i];
#line 3995
    adpm[i].mod = (struct demangle_component  const  *)typed_name;
#line 3996
    adpm[i].printed = 0;
#line 3997
    adpm[i].templates = dpi->templates;
#line 3998
    i ++;
#line 4000
    if ((unsigned int )typed_name->type != 28U) {
#line 4000
      if ((unsigned int )typed_name->type != 29U) {
#line 4000
        if ((unsigned int )typed_name->type != 30U) {
#line 4000
          if ((unsigned int )typed_name->type != 32U) {
#line 4000
            if ((unsigned int )typed_name->type != 31U) {
#line 4005
              goto while_break;
            }
          }
        }
      }
    }
#line 4007
    typed_name = typed_name->u.s_binary.left;
  }
  while_break: /* CIL Label */ ;
  }
#line 4010
  if ((unsigned long )typed_name == (unsigned long )((void *)0)) {
    {
#line 4012
    d_print_error(dpi);
    }
#line 4013
    return;
  }
#line 4018
  if ((unsigned int )typed_name->type == 4U) {
#line 4020
    dpt.next = dpi->templates;
#line 4021
    dpi->templates = & dpt;
#line 4022
    dpt.template_decl = (struct demangle_component  const  *)typed_name;
  }
#line 4029
  if ((unsigned int )typed_name->type == 2U) {
#line 4033
    local_name___0 = typed_name->u.s_binary.right;
#line 4034
    if ((unsigned int )local_name___0->type == 69U) {
#line 4035
      local_name___0 = local_name___0->u.s_unary_num.sub;
    }
    {
#line 4036
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4036
      if (! ((unsigned int )local_name___0->type == 28U)) {
#line 4036
        if (! ((unsigned int )local_name___0->type == 29U)) {
#line 4036
          if (! ((unsigned int )local_name___0->type == 30U)) {
#line 4036
            if (! ((unsigned int )local_name___0->type == 31U)) {
#line 4036
              if (! ((unsigned int )local_name___0->type == 32U)) {
#line 4036
                goto while_break___0;
              }
            }
          }
        }
      }
#line 4043
      if ((unsigned long )i >= sizeof(adpm) / sizeof(adpm[0])) {
        {
#line 4045
        d_print_error(dpi);
        }
#line 4046
        return;
      }
#line 4049
      adpm[i] = adpm[i - 1U];
#line 4050
      adpm[i].next = & adpm[i - 1U];
#line 4051
      dpi->modifiers = & adpm[i];
#line 4053
      adpm[i - 1U].mod = (struct demangle_component  const  *)local_name___0;
#line 4054
      adpm[i - 1U].printed = 0;
#line 4055
      adpm[i - 1U].templates = dpi->templates;
#line 4056
      i ++;
#line 4058
      local_name___0 = local_name___0->u.s_binary.left;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 4062
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4064
  if ((unsigned int )typed_name->type == 4U) {
#line 4065
    dpi->templates = dpt.next;
  }
  {
#line 4069
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4069
    if (! (i > 0U)) {
#line 4069
      goto while_break___1;
    }
#line 4071
    i --;
#line 4072
    if (! adpm[i].printed) {
      {
#line 4074
      d_append_char(dpi, (char )' ');
#line 4075
      d_print_mod(dpi, options___0, adpm[i].mod);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4079
  dpi->modifiers = hold_modifiers;
#line 4081
  return;
  case_4: /* CIL Label */ 
#line 4093
  hold_dpm = dpi->modifiers;
#line 4094
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 4096
  dcl = (struct demangle_component *)dc->u.s_binary.left;
#line 4098
  if ((options___0 & (1 << 2)) != 0) {
#line 4098
    if ((unsigned int )dcl->type == 0U) {
#line 4098
      if (dcl->u.s_name.len == 6) {
        {
#line 4098
        tmp___3 = strncmp(dcl->u.s_name.s, "JArray", (size_t )6);
        }
#line 4098
        if (tmp___3 == 0) {
          {
#line 4106
          d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4107
          d_append_string(dpi, "[]");
          }
        } else {
#line 4098
          goto _L___1;
        }
      } else {
#line 4098
        goto _L___1;
      }
    } else {
#line 4098
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 4111
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dcl);
#line 4112
    tmp___1 = d_last_char(dpi);
    }
#line 4112
    if ((int )tmp___1 == 60) {
      {
#line 4113
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 4114
    d_append_char(dpi, (char )'<');
#line 4115
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4118
    tmp___2 = d_last_char(dpi);
    }
#line 4118
    if ((int )tmp___2 == 62) {
      {
#line 4119
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 4120
    d_append_char(dpi, (char )'>');
    }
  }
#line 4123
  dpi->modifiers = hold_dpm;
#line 4125
  return;
  case_5: /* CIL Label */ 
  {
#line 4131
  tmp___4 = d_lookup_template_argument(dpi, dc);
#line 4131
  a = tmp___4;
  }
#line 4133
  if (a) {
#line 4133
    if ((unsigned int )a->type == 47U) {
      {
#line 4134
      a = d_index_template_argument(a, dpi->pack_index);
      }
    }
  }
#line 4136
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 4138
    d_print_error(dpi);
    }
#line 4139
    return;
  }
  {
#line 4147
  hold_dpt = dpi->templates;
#line 4148
  dpi->templates = hold_dpt->next;
#line 4150
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)a);
#line 4152
  dpi->templates = hold_dpt;
  }
#line 4154
  return;
  case_7: /* CIL Label */ 
  {
#line 4158
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_ctor.name);
  }
#line 4159
  return;
  case_8: /* CIL Label */ 
  {
#line 4162
  d_append_char(dpi, (char )'~');
#line 4163
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_dtor.name);
  }
#line 4164
  return;
  case_9: /* CIL Label */ 
  {
#line 4167
  d_append_string(dpi, "vtable for ");
#line 4168
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4169
  return;
  case_10: /* CIL Label */ 
  {
#line 4172
  d_append_string(dpi, "VTT for ");
#line 4173
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4174
  return;
  case_11: /* CIL Label */ 
  {
#line 4177
  d_append_string(dpi, "construction vtable for ");
#line 4178
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4179
  d_append_string(dpi, "-in-");
#line 4180
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4181
  return;
  case_12: /* CIL Label */ 
  {
#line 4184
  d_append_string(dpi, "typeinfo for ");
#line 4185
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4186
  return;
  case_13: /* CIL Label */ 
  {
#line 4189
  d_append_string(dpi, "typeinfo name for ");
#line 4190
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4191
  return;
  case_14: /* CIL Label */ 
  {
#line 4194
  d_append_string(dpi, "typeinfo fn for ");
#line 4195
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4196
  return;
  case_15: /* CIL Label */ 
  {
#line 4199
  d_append_string(dpi, "non-virtual thunk to ");
#line 4200
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4201
  return;
  case_16: /* CIL Label */ 
  {
#line 4204
  d_append_string(dpi, "virtual thunk to ");
#line 4205
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4206
  return;
  case_17: /* CIL Label */ 
  {
#line 4209
  d_append_string(dpi, "covariant return thunk to ");
#line 4210
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4211
  return;
  case_18: /* CIL Label */ 
  {
#line 4214
  d_append_string(dpi, "java Class for ");
#line 4215
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4216
  return;
  case_19: /* CIL Label */ 
  {
#line 4219
  d_append_string(dpi, "guard variable for ");
#line 4220
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4221
  return;
  case_20: /* CIL Label */ 
  {
#line 4224
  d_append_string(dpi, "TLS init function for ");
#line 4225
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4226
  return;
  case_21: /* CIL Label */ 
  {
#line 4229
  d_append_string(dpi, "TLS wrapper function for ");
#line 4230
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4231
  return;
  case_22: /* CIL Label */ 
  {
#line 4234
  d_append_string(dpi, "reference temporary #");
#line 4235
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4236
  d_append_string(dpi, " for ");
#line 4237
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4238
  return;
  case_23: /* CIL Label */ 
  {
#line 4241
  d_append_string(dpi, "hidden alias for ");
#line 4242
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4243
  return;
  case_71: /* CIL Label */ 
  {
#line 4246
  d_append_string(dpi, "transaction clone for ");
#line 4247
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4248
  return;
  case_72: /* CIL Label */ 
  {
#line 4251
  d_append_string(dpi, "non-transaction clone for ");
#line 4252
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4253
  return;
  case_24: /* CIL Label */ 
  {
#line 4256
  d_append_buffer(dpi, (char const   *)dc->u.s_string.string, (size_t )dc->u.s_string.len);
  }
#line 4257
  return;
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 4269
  pdpm = dpi->modifiers;
  {
#line 4269
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4269
    if (! ((unsigned long )pdpm != (unsigned long )((void *)0))) {
#line 4269
      goto while_break___2;
    }
#line 4271
    if (! pdpm->printed) {
#line 4273
      if ((unsigned int const   )(pdpm->mod)->type != 25U) {
#line 4273
        if ((unsigned int const   )(pdpm->mod)->type != 26U) {
#line 4273
          if ((unsigned int const   )(pdpm->mod)->type != 27U) {
#line 4276
            goto while_break___2;
          }
        }
      }
#line 4277
      if ((unsigned int const   )(pdpm->mod)->type == (unsigned int const   )dc->type) {
        {
#line 4279
        d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
        }
#line 4280
        return;
      }
    }
#line 4269
    pdpm = pdpm->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4285
  goto modifier;
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
#line 4291
  sub = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 4292
  if ((unsigned int const   )sub->type == 5U) {
    {
#line 4294
    tmp___5 = d_lookup_template_argument(dpi, sub);
#line 4294
    a___0 = tmp___5;
    }
#line 4295
    if (a___0) {
#line 4295
      if ((unsigned int )a___0->type == 47U) {
        {
#line 4296
        a___0 = d_index_template_argument(a___0, dpi->pack_index);
        }
      }
    }
#line 4298
    if ((unsigned long )a___0 == (unsigned long )((void *)0)) {
      {
#line 4300
      d_print_error(dpi);
      }
#line 4301
      return;
    }
#line 4304
    sub = (struct demangle_component  const  *)a___0;
  }
#line 4307
  if ((unsigned int const   )sub->type == 35U) {
#line 4309
    dc = sub;
  } else
#line 4307
  if ((unsigned int const   )sub->type == (unsigned int const   )dc->type) {
#line 4309
    dc = sub;
  } else
#line 4310
  if ((unsigned int const   )sub->type == 36U) {
#line 4311
    mod_inner = (struct demangle_component  const  *)sub->u.s_binary.left;
  }
  modifier: 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
#line 4329
  dpm.next = dpi->modifiers;
#line 4330
  dpi->modifiers = & dpm;
#line 4331
  dpm.mod = dc;
#line 4332
  dpm.printed = 0;
#line 4333
  dpm.templates = dpi->templates;
#line 4335
  if (! mod_inner) {
#line 4336
    mod_inner = (struct demangle_component  const  *)dc->u.s_binary.left;
  }
  {
#line 4338
  d_print_comp(dpi, options___0, mod_inner);
  }
#line 4342
  if (! dpm.printed) {
    {
#line 4343
    d_print_mod(dpi, options___0, dc);
    }
  }
#line 4345
  dpi->modifiers = dpm.next;
#line 4347
  return;
  case_39: /* CIL Label */ 
#line 4351
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 4352
    d_append_buffer(dpi, (char const   *)(dc->u.s_builtin.type)->name, (size_t )(dc->u.s_builtin.type)->len);
    }
  } else {
    {
#line 4355
    d_append_buffer(dpi, (char const   *)(dc->u.s_builtin.type)->java_name, (size_t )(dc->u.s_builtin.type)->java_len);
    }
  }
#line 4357
  return;
  case_40: /* CIL Label */ 
  {
#line 4360
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4361
  return;
  case_41: /* CIL Label */ 
#line 4365
  if ((options___0 & (1 << 5)) != 0) {
    {
#line 4366
    d_print_function_type(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), dc, dpi->modifiers);
    }
  }
#line 4371
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
#line 4371
    if ((options___0 & (1 << 5)) != 0) {
      {
#line 4372
      d_print_comp(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), (struct demangle_component  const  *)dc->u.s_binary.left);
      }
    } else {
#line 4371
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 4374
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
#line 4374
    if ((options___0 & (1 << 6)) == 0) {
      {
#line 4380
      dpm___0.next = dpi->modifiers;
#line 4381
      dpi->modifiers = & dpm___0;
#line 4382
      dpm___0.mod = dc;
#line 4383
      dpm___0.printed = 0;
#line 4384
      dpm___0.templates = dpi->templates;
#line 4386
      d_print_comp(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4389
      dpi->modifiers = dpm___0.next;
      }
#line 4391
      if (dpm___0.printed) {
#line 4392
        return;
      }
#line 4396
      if ((options___0 & (1 << 5)) == 0) {
        {
#line 4397
        d_append_char(dpi, (char )' ');
        }
      }
    }
  }
#line 4400
  if ((options___0 & (1 << 5)) == 0) {
    {
#line 4401
    d_print_function_type(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), dc, dpi->modifiers);
    }
  }
#line 4405
  return;
  case_42: /* CIL Label */ 
#line 4423
  hold_modifiers___0 = dpi->modifiers;
#line 4425
  adpm___0[0].next = hold_modifiers___0;
#line 4426
  dpi->modifiers = & adpm___0[0];
#line 4427
  adpm___0[0].mod = dc;
#line 4428
  adpm___0[0].printed = 0;
#line 4429
  adpm___0[0].templates = dpi->templates;
#line 4431
  i___0 = 1U;
#line 4432
  pdpm___0 = hold_modifiers___0;
  {
#line 4433
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4433
    if ((unsigned long )pdpm___0 != (unsigned long )((void *)0)) {
#line 4433
      if (! ((unsigned int const   )(pdpm___0->mod)->type == 25U)) {
#line 4433
        if (! ((unsigned int const   )(pdpm___0->mod)->type == 26U)) {
#line 4433
          if (! ((unsigned int const   )(pdpm___0->mod)->type == 27U)) {
#line 4433
            goto while_break___3;
          }
        }
      }
    } else {
#line 4433
      goto while_break___3;
    }
#line 4438
    if (! pdpm___0->printed) {
#line 4440
      if ((unsigned long )i___0 >= sizeof(adpm___0) / sizeof(adpm___0[0])) {
        {
#line 4442
        d_print_error(dpi);
        }
#line 4443
        return;
      }
#line 4446
      adpm___0[i___0] = *pdpm___0;
#line 4447
      adpm___0[i___0].next = dpi->modifiers;
#line 4448
      dpi->modifiers = & adpm___0[i___0];
#line 4449
      pdpm___0->printed = 1;
#line 4450
      i___0 ++;
    }
#line 4453
    pdpm___0 = pdpm___0->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 4456
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4458
  dpi->modifiers = hold_modifiers___0;
  }
#line 4460
  if (adpm___0[0].printed) {
#line 4461
    return;
  }
  {
#line 4463
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 4463
    if (! (i___0 > 1U)) {
#line 4463
      goto while_break___4;
    }
    {
#line 4465
    i___0 --;
#line 4466
    d_print_mod(dpi, options___0, adpm___0[i___0].mod);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 4469
  d_print_array_type(dpi, options___0, dc, dpi->modifiers);
  }
#line 4471
  return;
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  {
#line 4479
  dpm___1.next = dpi->modifiers;
#line 4480
  dpi->modifiers = & dpm___1;
#line 4481
  dpm___1.mod = dc;
#line 4482
  dpm___1.printed = 0;
#line 4483
  dpm___1.templates = dpi->templates;
#line 4485
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4489
  if (! dpm___1.printed) {
    {
#line 4490
    d_print_mod(dpi, options___0, dc);
    }
  }
#line 4492
  dpi->modifiers = dpm___1.next;
#line 4494
  return;
  case_44: /* CIL Label */ 
#line 4498
  if (dc->u.s_fixed.sat) {
    {
#line 4499
    d_append_string(dpi, "_Sat ");
    }
  }
#line 4501
  if ((unsigned long )(dc->u.s_fixed.length)->u.s_builtin.type != (unsigned long )(& cplus_demangle_builtin_types[8])) {
    {
#line 4504
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_fixed.length);
#line 4505
    d_append_char(dpi, (char )' ');
    }
  }
#line 4507
  if (dc->u.s_fixed.accum) {
    {
#line 4508
    d_append_string(dpi, "_Accum");
    }
  } else {
    {
#line 4510
    d_append_string(dpi, "_Fract");
    }
  }
#line 4511
  return;
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
#line 4515
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
    {
#line 4516
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  }
#line 4517
  if ((unsigned long )dc->u.s_binary.right != (unsigned long )((void *)0)) {
#line 4523
    if (dpi->len >= sizeof(dpi->buf) - 2UL) {
      {
#line 4524
      d_print_flush(dpi);
      }
    }
    {
#line 4525
    d_append_string(dpi, ", ");
#line 4526
    len = dpi->len;
#line 4527
    flush_count = dpi->flush_count;
#line 4528
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
    }
#line 4531
    if (dpi->flush_count == flush_count) {
#line 4531
      if (dpi->len == len) {
#line 4532
        dpi->len -= 2UL;
      }
    }
  }
#line 4534
  return;
  case_48: /* CIL Label */ 
#line 4538
  type = (struct demangle_component *)dc->u.s_binary.left;
#line 4539
  list = (struct demangle_component *)dc->u.s_binary.right;
#line 4541
  if (type) {
    {
#line 4542
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)type);
    }
  }
  {
#line 4543
  d_append_char(dpi, (char )'{');
#line 4544
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)list);
#line 4545
  d_append_char(dpi, (char )'}');
  }
#line 4547
  return;
  case_49: /* CIL Label */ 
  {
#line 4551
  op = (struct demangle_operator_info  const  *)dc->u.s_operator.op;
#line 4552
  len___0 = (int )op->len;
#line 4554
  d_append_string(dpi, "operator");
  }
#line 4556
  if ((int const   )*(op->name + 0) >= 97) {
#line 4556
    if ((int const   )*(op->name + 0) <= 122) {
      {
#line 4557
      d_append_char(dpi, (char )' ');
      }
    }
  }
#line 4559
  if ((int const   )*(op->name + (len___0 - 1)) == 32) {
#line 4560
    len___0 --;
  }
  {
#line 4561
  d_append_buffer(dpi, (char const   *)op->name, (size_t )len___0);
  }
#line 4562
  return;
  case_50: /* CIL Label */ 
  {
#line 4566
  d_append_string(dpi, "operator ");
#line 4567
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_extended_operator.name);
  }
#line 4568
  return;
  case_51: /* CIL Label */ 
  {
#line 4571
  d_append_string(dpi, "operator ");
#line 4572
  d_print_cast(dpi, options___0, dc);
  }
#line 4573
  return;
  case_52: /* CIL Label */ 
  {
#line 4576
  d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4577
  return;
  case_53: /* CIL Label */ 
#line 4581
  op___0 = (struct demangle_component *)dc->u.s_binary.left;
#line 4582
  operand = (struct demangle_component *)dc->u.s_binary.right;
#line 4583
  code = (char const   *)((void *)0);
#line 4585
  if ((unsigned int )op___0->type == 49U) {
    {
#line 4587
    code = (char const   *)(op___0->u.s_operator.op)->code;
#line 4588
    tmp___6 = strcmp(code, "ad");
    }
#line 4588
    if (! tmp___6) {
#line 4592
      if ((unsigned int )operand->type == 3U) {
#line 4592
        if ((unsigned int )(operand->u.s_binary.left)->type == 1U) {
#line 4592
          if ((unsigned int )(operand->u.s_binary.right)->type == 41U) {
#line 4595
            operand = operand->u.s_binary.left;
          }
        }
      }
    }
#line 4597
    if ((unsigned int )operand->type == 55U) {
      {
#line 4600
      operand = operand->u.s_binary.left;
#line 4601
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
#line 4602
      d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___0);
      }
#line 4603
      return;
    }
  }
#line 4607
  if ((unsigned int )op___0->type != 51U) {
    {
#line 4608
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___0);
    }
  } else {
    {
#line 4611
    d_append_char(dpi, (char )'(');
#line 4612
    d_print_cast(dpi, options___0, (struct demangle_component  const  *)op___0);
#line 4613
    d_append_char(dpi, (char )')');
    }
  }
#line 4615
  if (code) {
    {
#line 4615
    tmp___8 = strcmp(code, "gs");
    }
#line 4615
    if (tmp___8) {
#line 4615
      goto _L___3;
    } else {
      {
#line 4617
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)operand);
      }
    }
  } else
  _L___3: /* CIL Label */ 
#line 4618
  if (code) {
    {
#line 4618
    tmp___7 = strcmp(code, "st");
    }
#line 4618
    if (tmp___7) {
      {
#line 4626
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
      }
    } else {
      {
#line 4621
      d_append_char(dpi, (char )'(');
#line 4622
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)operand);
#line 4623
      d_append_char(dpi, (char )')');
      }
    }
  } else {
    {
#line 4626
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
    }
  }
#line 4628
  return;
  case_54: /* CIL Label */ 
#line 4631
  if ((unsigned int )(dc->u.s_binary.right)->type != 55U) {
    {
#line 4633
    d_print_error(dpi);
    }
#line 4634
    return;
  }
  {
#line 4637
  tmp___9 = op_is_new_cast((struct demangle_component *)dc->u.s_binary.left);
  }
#line 4637
  if (tmp___9) {
    {
#line 4639
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4640
    d_append_char(dpi, (char )'<');
#line 4641
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
#line 4642
    d_append_string(dpi, ">(");
#line 4643
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
#line 4644
    d_append_char(dpi, (char )')');
    }
#line 4645
    return;
  }
#line 4651
  if ((unsigned int )(dc->u.s_binary.left)->type == 49U) {
#line 4651
    if (((dc->u.s_binary.left)->u.s_operator.op)->len == 1) {
#line 4651
      if ((int const   )*(((dc->u.s_binary.left)->u.s_operator.op)->name + 0) == 62) {
        {
#line 4654
        d_append_char(dpi, (char )'(');
        }
      }
    }
  }
  {
#line 4656
  tmp___10 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                    "cl");
  }
#line 4656
  if (tmp___10 == 0) {
#line 4656
    if ((unsigned int )((dc->u.s_binary.right)->u.s_binary.left)->type == 3U) {
#line 4663
      func = (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left;
#line 4665
      if ((unsigned int )(func->u.s_binary.right)->type != 41U) {
        {
#line 4666
        d_print_error(dpi);
        }
      }
      {
#line 4667
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)func->u.s_binary.left);
      }
    } else {
      {
#line 4670
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
      }
    }
  } else {
    {
#line 4670
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
    }
  }
  {
#line 4671
  tmp___12 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                    "ix");
  }
#line 4671
  if (tmp___12 == 0) {
    {
#line 4673
    d_append_char(dpi, (char )'[');
#line 4674
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
#line 4675
    d_append_char(dpi, (char )']');
    }
  } else {
    {
#line 4679
    tmp___11 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                      "cl");
    }
#line 4679
    if (tmp___11 != 0) {
      {
#line 4680
      d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
      }
    }
    {
#line 4681
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
    }
  }
#line 4684
  if ((unsigned int )(dc->u.s_binary.left)->type == 49U) {
#line 4684
    if (((dc->u.s_binary.left)->u.s_operator.op)->len == 1) {
#line 4684
      if ((int const   )*(((dc->u.s_binary.left)->u.s_operator.op)->name + 0) == 62) {
        {
#line 4687
        d_append_char(dpi, (char )')');
        }
      }
    }
  }
#line 4689
  return;
  case_55: /* CIL Label */ 
  {
#line 4693
  d_print_error(dpi);
  }
#line 4694
  return;
  case_56: /* CIL Label */ 
#line 4697
  if ((unsigned int )(dc->u.s_binary.right)->type != 57U) {
    {
#line 4700
    d_print_error(dpi);
    }
#line 4701
    return;
  } else
#line 4697
  if ((unsigned int )((dc->u.s_binary.right)->u.s_binary.right)->type != 58U) {
    {
#line 4700
    d_print_error(dpi);
    }
#line 4701
    return;
  }
  {
#line 4704
  op___1 = (struct demangle_component *)dc->u.s_binary.left;
#line 4705
  first = (dc->u.s_binary.right)->u.s_binary.left;
#line 4706
  second = ((dc->u.s_binary.right)->u.s_binary.right)->u.s_binary.left;
#line 4707
  third = ((dc->u.s_binary.right)->u.s_binary.right)->u.s_binary.right;
#line 4709
  tmp___13 = strcmp((char const   *)(op___1->u.s_operator.op)->code, "qu");
  }
#line 4709
  if (tmp___13) {
    {
#line 4719
    d_append_string(dpi, "new ");
    }
#line 4720
    if ((unsigned long )first->u.s_binary.left != (unsigned long )((void *)0)) {
      {
#line 4722
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)first);
#line 4723
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 4725
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)second);
    }
#line 4726
    if (third) {
      {
#line 4727
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)third);
      }
    }
  } else {
    {
#line 4711
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)first);
#line 4712
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___1);
#line 4713
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)second);
#line 4714
    d_append_string(dpi, " : ");
#line 4715
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)third);
    }
  }
#line 4730
  return;
  case_58: /* CIL Label */ 
  case_57: /* CIL Label */ 
  {
#line 4735
  d_print_error(dpi);
  }
#line 4736
  return;
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
#line 4744
  tp = (enum d_builtin_type_print )0;
#line 4745
  if ((unsigned int )(dc->u.s_binary.left)->type == 39U) {
#line 4747
    tp = (enum d_builtin_type_print )((dc->u.s_binary.left)->u.s_builtin.type)->print;
    {
#line 4755
    if ((unsigned int )tp == 6U) {
#line 4755
      goto case_6;
    }
#line 4755
    if ((unsigned int )tp == 5U) {
#line 4755
      goto case_6;
    }
#line 4755
    if ((unsigned int )tp == 4U) {
#line 4755
      goto case_6;
    }
#line 4755
    if ((unsigned int )tp == 3U) {
#line 4755
      goto case_6;
    }
#line 4755
    if ((unsigned int )tp == 2U) {
#line 4755
      goto case_6;
    }
#line 4755
    if ((unsigned int )tp == 1U) {
#line 4755
      goto case_6;
    }
#line 4785
    if ((unsigned int )tp == 7U) {
#line 4785
      goto case_7___0;
    }
#line 4804
    goto switch_default___1;
    case_6: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 4756
    if ((unsigned int )(dc->u.s_binary.right)->type == 0U) {
#line 4758
      if ((unsigned int const   )dc->type == 60U) {
        {
#line 4759
        d_append_char(dpi, (char )'-');
        }
      }
      {
#line 4760
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
      }
      {
#line 4765
      if ((unsigned int )tp == 2U) {
#line 4765
        goto case_2___1;
      }
#line 4768
      if ((unsigned int )tp == 3U) {
#line 4768
        goto case_3___1;
      }
#line 4771
      if ((unsigned int )tp == 4U) {
#line 4771
        goto case_4___1;
      }
#line 4774
      if ((unsigned int )tp == 5U) {
#line 4774
        goto case_5___1;
      }
#line 4777
      if ((unsigned int )tp == 6U) {
#line 4777
        goto case_6___0;
      }
#line 4763
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 4764
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 4766
      d_append_char(dpi, (char )'u');
      }
#line 4767
      goto switch_break___1;
      case_3___1: /* CIL Label */ 
      {
#line 4769
      d_append_char(dpi, (char )'l');
      }
#line 4770
      goto switch_break___1;
      case_4___1: /* CIL Label */ 
      {
#line 4772
      d_append_string(dpi, "ul");
      }
#line 4773
      goto switch_break___1;
      case_5___1: /* CIL Label */ 
      {
#line 4775
      d_append_string(dpi, "ll");
      }
#line 4776
      goto switch_break___1;
      case_6___0: /* CIL Label */ 
      {
#line 4778
      d_append_string(dpi, "ull");
      }
#line 4779
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 4781
      return;
    }
#line 4783
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 4786
    if ((unsigned int )(dc->u.s_binary.right)->type == 0U) {
#line 4786
      if ((dc->u.s_binary.right)->u.s_name.len == 1) {
#line 4786
        if ((unsigned int const   )dc->type == 59U) {
          {
#line 4792
          if ((int const   )*((dc->u.s_binary.right)->u.s_name.s + 0) == 48) {
#line 4792
            goto case_48___0;
          }
#line 4795
          if ((int const   )*((dc->u.s_binary.right)->u.s_name.s + 0) == 49) {
#line 4795
            goto case_49___0;
          }
#line 4798
          goto switch_default___0;
          case_48___0: /* CIL Label */ 
          {
#line 4793
          d_append_string(dpi, "false");
          }
#line 4794
          return;
          case_49___0: /* CIL Label */ 
          {
#line 4796
          d_append_string(dpi, "true");
          }
#line 4797
          return;
          switch_default___0: /* CIL Label */ 
#line 4799
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 4802
    goto switch_break___0;
    switch_default___1: /* CIL Label */ 
#line 4805
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 4809
  d_append_char(dpi, (char )'(');
#line 4810
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4811
  d_append_char(dpi, (char )')');
  }
#line 4812
  if ((unsigned int const   )dc->type == 60U) {
    {
#line 4813
    d_append_char(dpi, (char )'-');
    }
  }
#line 4814
  if ((unsigned int )tp == 8U) {
    {
#line 4815
    d_append_char(dpi, (char )'[');
    }
  }
  {
#line 4816
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4817
  if ((unsigned int )tp == 8U) {
    {
#line 4818
    d_append_char(dpi, (char )']');
    }
  }
#line 4820
  return;
  case_64: /* CIL Label */ 
  {
#line 4823
  d_append_num(dpi, (long )dc->u.s_number.number);
  }
#line 4824
  return;
  case_61: /* CIL Label */ 
  {
#line 4827
  d_append_string(dpi, "java resource ");
#line 4828
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4829
  return;
  case_62: /* CIL Label */ 
  {
#line 4832
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4833
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4834
  return;
  case_63: /* CIL Label */ 
  {
#line 4837
  d_append_char(dpi, (char )dc->u.s_character.character);
  }
#line 4838
  return;
  case_65: /* CIL Label */ 
  {
#line 4841
  d_append_string(dpi, "decltype (");
#line 4842
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4843
  d_append_char(dpi, (char )')');
  }
#line 4844
  return;
  case_73: /* CIL Label */ 
  {
#line 4850
  tmp___14 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4850
  a___1 = tmp___14;
  }
#line 4851
  if ((unsigned long )a___1 == (unsigned long )((void *)0)) {
    {
#line 4856
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4857
    d_append_string(dpi, "...");
    }
#line 4858
    return;
  }
  {
#line 4861
  len___1 = d_pack_length((struct demangle_component  const  *)a___1);
#line 4862
  dc = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 4863
  i___1 = 0;
  }
  {
#line 4863
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 4863
    if (! (i___1 < len___1)) {
#line 4863
      goto while_break___5;
    }
    {
#line 4865
    dpi->pack_index = i___1;
#line 4866
    d_print_comp(dpi, options___0, dc);
    }
#line 4867
    if (i___1 < len___1 - 1) {
      {
#line 4868
      d_append_string(dpi, ", ");
      }
    }
#line 4863
    i___1 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 4871
  return;
  case_6___1: /* CIL Label */ 
#line 4875
  num = (long )dc->u.s_number.number;
#line 4876
  if (num == 0L) {
    {
#line 4877
    d_append_string(dpi, "this");
    }
  } else {
    {
#line 4880
    d_append_string(dpi, "{parm#");
#line 4881
    d_append_num(dpi, num);
#line 4882
    d_append_char(dpi, (char )'}');
    }
  }
#line 4885
  return;
  case_66: /* CIL Label */ 
  {
#line 4888
  d_append_string(dpi, "global constructors keyed to ");
#line 4889
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4890
  return;
  case_67: /* CIL Label */ 
  {
#line 4893
  d_append_string(dpi, "global destructors keyed to ");
#line 4894
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4895
  return;
  case_68: /* CIL Label */ 
  {
#line 4898
  d_append_string(dpi, "{lambda(");
#line 4899
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_unary_num.sub);
#line 4900
  d_append_string(dpi, ")#");
#line 4901
  d_append_num(dpi, (long )(dc->u.s_unary_num.num + 1));
#line 4902
  d_append_char(dpi, (char )'}');
  }
#line 4903
  return;
  case_70: /* CIL Label */ 
  {
#line 4906
  d_append_string(dpi, "{unnamed type#");
#line 4907
  d_append_num(dpi, (long )(dc->u.s_number.number + 1L));
#line 4908
  d_append_char(dpi, (char )'}');
  }
#line 4909
  return;
  case_75: /* CIL Label */ 
  {
#line 4912
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4913
  d_append_string(dpi, " [clone ");
#line 4914
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4915
  d_append_char(dpi, (char )']');
  }
#line 4916
  return;
  switch_default___2: /* CIL Label */ 
  {
#line 4919
  d_print_error(dpi);
  }
#line 4920
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4929 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_java_identifier(struct d_print_info *dpi , char const   *name___0 ,
                                    int len ) 
{ 
  char const   *p ;
  char const   *end ;
  unsigned long c ;
  char const   *q ;
  int dig ;

  {
#line 4935
  end = name___0 + len;
#line 4936
  p = name___0;
  {
#line 4936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4936
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 4936
      goto while_break;
    }
#line 4938
    if (end - p > 3L) {
#line 4938
      if ((int const   )*(p + 0) == 95) {
#line 4938
        if ((int const   )*(p + 1) == 95) {
#line 4938
          if ((int const   )*(p + 2) == 85) {
#line 4946
            c = 0UL;
#line 4947
            q = p + 3;
            {
#line 4947
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4947
              if (! ((unsigned long )q < (unsigned long )end)) {
#line 4947
                goto while_break___0;
              }
#line 4951
              if ((int const   )*q >= 48) {
#line 4951
                if ((int const   )*q <= 57) {
#line 4952
                  dig = (int )((int const   )*q - 48);
                } else {
#line 4951
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 4953
              if ((int const   )*q >= 65) {
#line 4953
                if ((int const   )*q <= 70) {
#line 4954
                  dig = (int )(((int const   )*q - 65) + 10);
                } else {
#line 4953
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 4955
              if ((int const   )*q >= 97) {
#line 4955
                if ((int const   )*q <= 102) {
#line 4956
                  dig = (int )(((int const   )*q - 97) + 10);
                } else {
#line 4958
                  goto while_break___0;
                }
              } else {
#line 4958
                goto while_break___0;
              }
#line 4960
              c = c * 16UL + (unsigned long )dig;
#line 4947
              q ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 4964
            if ((unsigned long )q < (unsigned long )end) {
#line 4964
              if ((int const   )*q == 95) {
#line 4964
                if (c < 256UL) {
                  {
#line 4966
                  d_append_char(dpi, (char )c);
#line 4967
                  p = q;
                  }
#line 4968
                  goto __Cont;
                }
              }
            }
          }
        }
      }
    }
    {
#line 4972
    d_append_char(dpi, (char )*p);
    }
    __Cont: /* CIL Label */ 
#line 4936
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4974
  return;
}
}
#line 4979 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_mod_list(struct d_print_info *dpi , int options___0 , struct d_print_mod *mods ,
                             int suffix ) 
{ 
  struct d_print_template *hold_dpt ;
  int tmp___0 ;
  struct d_print_mod *hold_modifiers ;
  struct demangle_component *dc ;

  {
#line 4985
  if ((unsigned long )mods == (unsigned long )((void *)0)) {
#line 4986
    return;
  } else {
    {
#line 4985
    tmp___0 = d_print_saw_error(dpi);
    }
#line 4985
    if (tmp___0) {
#line 4986
      return;
    }
  }
#line 4988
  if (mods->printed) {
    {
#line 4997
    d_print_mod_list(dpi, options___0, mods->next, suffix);
    }
#line 4998
    return;
  } else
#line 4988
  if (! suffix) {
#line 4988
    if ((unsigned int const   )(mods->mod)->type == 28U) {
      {
#line 4997
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4998
      return;
    } else
#line 4988
    if ((unsigned int const   )(mods->mod)->type == 29U) {
      {
#line 4997
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4998
      return;
    } else
#line 4988
    if ((unsigned int const   )(mods->mod)->type == 30U) {
      {
#line 4997
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4998
      return;
    } else
#line 4988
    if ((unsigned int const   )(mods->mod)->type == 31U) {
      {
#line 4997
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4998
      return;
    } else
#line 4988
    if ((unsigned int const   )(mods->mod)->type == 32U) {
      {
#line 4997
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4998
      return;
    }
  }
#line 5001
  mods->printed = 1;
#line 5003
  hold_dpt = dpi->templates;
#line 5004
  dpi->templates = mods->templates;
#line 5006
  if ((unsigned int const   )(mods->mod)->type == 41U) {
    {
#line 5008
    d_print_function_type(dpi, options___0, mods->mod, mods->next);
#line 5009
    dpi->templates = hold_dpt;
    }
#line 5010
    return;
  } else
#line 5012
  if ((unsigned int const   )(mods->mod)->type == 42U) {
    {
#line 5014
    d_print_array_type(dpi, options___0, mods->mod, mods->next);
#line 5015
    dpi->templates = hold_dpt;
    }
#line 5016
    return;
  } else
#line 5018
  if ((unsigned int const   )(mods->mod)->type == 2U) {
    {
#line 5028
    hold_modifiers = dpi->modifiers;
#line 5029
    dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 5030
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(mods->mod)->u.s_binary.left);
#line 5031
    dpi->modifiers = hold_modifiers;
    }
#line 5033
    if ((options___0 & (1 << 2)) == 0) {
      {
#line 5034
      d_append_string(dpi, "::");
      }
    } else {
      {
#line 5036
      d_append_char(dpi, (char )'.');
      }
    }
#line 5038
    dc = (struct demangle_component *)(mods->mod)->u.s_binary.right;
#line 5040
    if ((unsigned int )dc->type == 69U) {
      {
#line 5042
      d_append_string(dpi, "{default arg#");
#line 5043
      d_append_num(dpi, (long )(dc->u.s_unary_num.num + 1));
#line 5044
      d_append_string(dpi, "}::");
#line 5045
      dc = dc->u.s_unary_num.sub;
      }
    }
    {
#line 5048
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5048
      if (! ((unsigned int )dc->type == 28U)) {
#line 5048
        if (! ((unsigned int )dc->type == 29U)) {
#line 5048
          if (! ((unsigned int )dc->type == 30U)) {
#line 5048
            if (! ((unsigned int )dc->type == 31U)) {
#line 5048
              if (! ((unsigned int )dc->type == 32U)) {
#line 5048
                goto while_break;
              }
            }
          }
        }
      }
#line 5053
      dc = dc->u.s_binary.left;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5055
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc);
#line 5057
    dpi->templates = hold_dpt;
    }
#line 5058
    return;
  }
  {
#line 5061
  d_print_mod(dpi, options___0, mods->mod);
#line 5063
  dpi->templates = hold_dpt;
#line 5065
  d_print_mod_list(dpi, options___0, mods->next, suffix);
  }
#line 5066
  return;
}
}
#line 5070 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_mod(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *mod ) 
{ 
  char tmp___0 ;

  {
  {
#line 5077
  if ((unsigned int const   )mod->type == 28U) {
#line 5077
    goto case_28;
  }
#line 5077
  if ((unsigned int const   )mod->type == 25U) {
#line 5077
    goto case_28;
  }
#line 5081
  if ((unsigned int const   )mod->type == 29U) {
#line 5081
    goto case_29;
  }
#line 5081
  if ((unsigned int const   )mod->type == 26U) {
#line 5081
    goto case_29;
  }
#line 5085
  if ((unsigned int const   )mod->type == 30U) {
#line 5085
    goto case_30;
  }
#line 5085
  if ((unsigned int const   )mod->type == 27U) {
#line 5085
    goto case_30;
  }
#line 5088
  if ((unsigned int const   )mod->type == 33U) {
#line 5088
    goto case_33;
  }
#line 5092
  if ((unsigned int const   )mod->type == 34U) {
#line 5092
    goto case_34;
  }
#line 5097
  if ((unsigned int const   )mod->type == 31U) {
#line 5097
    goto case_31;
  }
#line 5100
  if ((unsigned int const   )mod->type == 35U) {
#line 5100
    goto case_35;
  }
#line 5103
  if ((unsigned int const   )mod->type == 32U) {
#line 5103
    goto case_32;
  }
#line 5105
  if ((unsigned int const   )mod->type == 36U) {
#line 5105
    goto case_36;
  }
#line 5108
  if ((unsigned int const   )mod->type == 37U) {
#line 5108
    goto case_37;
  }
#line 5111
  if ((unsigned int const   )mod->type == 38U) {
#line 5111
    goto case_38;
  }
#line 5114
  if ((unsigned int const   )mod->type == 43U) {
#line 5114
    goto case_43;
  }
#line 5120
  if ((unsigned int const   )mod->type == 3U) {
#line 5120
    goto case_3;
  }
#line 5123
  if ((unsigned int const   )mod->type == 45U) {
#line 5123
    goto case_45;
  }
#line 5129
  goto switch_default;
  case_28: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 5078
  d_append_string(dpi, " restrict");
  }
#line 5079
  return;
  case_29: /* CIL Label */ 
  case_26: /* CIL Label */ 
  {
#line 5082
  d_append_string(dpi, " volatile");
  }
#line 5083
  return;
  case_30: /* CIL Label */ 
  case_27: /* CIL Label */ 
  {
#line 5086
  d_append_string(dpi, " const");
  }
#line 5087
  return;
  case_33: /* CIL Label */ 
  {
#line 5089
  d_append_char(dpi, (char )' ');
#line 5090
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.right);
  }
#line 5091
  return;
  case_34: /* CIL Label */ 
#line 5094
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 5095
    d_append_char(dpi, (char )'*');
    }
  }
#line 5096
  return;
  case_31: /* CIL Label */ 
  {
#line 5099
  d_append_char(dpi, (char )' ');
  }
  case_35: /* CIL Label */ 
  {
#line 5101
  d_append_char(dpi, (char )'&');
  }
#line 5102
  return;
  case_32: /* CIL Label */ 
  {
#line 5104
  d_append_char(dpi, (char )' ');
  }
  case_36: /* CIL Label */ 
  {
#line 5106
  d_append_string(dpi, "&&");
  }
#line 5107
  return;
  case_37: /* CIL Label */ 
  {
#line 5109
  d_append_string(dpi, "complex ");
  }
#line 5110
  return;
  case_38: /* CIL Label */ 
  {
#line 5112
  d_append_string(dpi, "imaginary ");
  }
#line 5113
  return;
  case_43: /* CIL Label */ 
  {
#line 5115
  tmp___0 = d_last_char(dpi);
  }
#line 5115
  if ((int )tmp___0 != 40) {
    {
#line 5116
    d_append_char(dpi, (char )' ');
    }
  }
  {
#line 5117
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
#line 5118
  d_append_string(dpi, "::*");
  }
#line 5119
  return;
  case_3: /* CIL Label */ 
  {
#line 5121
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
  }
#line 5122
  return;
  case_45: /* CIL Label */ 
  {
#line 5124
  d_append_string(dpi, " __vector(");
#line 5125
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
#line 5126
  d_append_char(dpi, (char )')');
  }
#line 5127
  return;
  switch_default: /* CIL Label */ 
  {
#line 5132
  d_print_comp(dpi, options___0, mod);
  }
#line 5133
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 5139 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_function_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                                  struct d_print_mod *mods ) 
{ 
  int need_paren ;
  int need_space ;
  struct d_print_mod *p ;
  struct d_print_mod *hold_modifiers ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
#line 5149
  need_paren = 0;
#line 5150
  need_space = 0;
#line 5151
  p = mods;
  {
#line 5151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5151
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 5151
      goto while_break;
    }
#line 5153
    if (p->printed) {
#line 5154
      goto while_break;
    }
    {
#line 5160
    if ((unsigned int const   )(p->mod)->type == 36U) {
#line 5160
      goto case_36;
    }
#line 5160
    if ((unsigned int const   )(p->mod)->type == 35U) {
#line 5160
      goto case_36;
    }
#line 5160
    if ((unsigned int const   )(p->mod)->type == 34U) {
#line 5160
      goto case_36;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 43U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 38U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 37U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 33U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 27U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 26U) {
#line 5169
      goto case_43;
    }
#line 5169
    if ((unsigned int const   )(p->mod)->type == 25U) {
#line 5169
      goto case_43;
    }
#line 5177
    if ((unsigned int const   )(p->mod)->type == 32U) {
#line 5177
      goto case_32;
    }
#line 5177
    if ((unsigned int const   )(p->mod)->type == 31U) {
#line 5177
      goto case_32;
    }
#line 5177
    if ((unsigned int const   )(p->mod)->type == 30U) {
#line 5177
      goto case_32;
    }
#line 5177
    if ((unsigned int const   )(p->mod)->type == 29U) {
#line 5177
      goto case_32;
    }
#line 5177
    if ((unsigned int const   )(p->mod)->type == 28U) {
#line 5177
      goto case_32;
    }
#line 5179
    goto switch_default;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 5161
    need_paren = 1;
#line 5162
    goto switch_break;
    case_43: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 5170
    need_space = 1;
#line 5171
    need_paren = 1;
#line 5172
    goto switch_break;
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
#line 5178
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5180
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5182
    if (need_paren) {
#line 5183
      goto while_break;
    }
#line 5151
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5186
  if (need_paren) {
#line 5188
    if (! need_space) {
      {
#line 5190
      tmp___0 = d_last_char(dpi);
      }
#line 5190
      if ((int )tmp___0 != 40) {
        {
#line 5190
        tmp___1 = d_last_char(dpi);
        }
#line 5190
        if ((int )tmp___1 != 42) {
#line 5192
          need_space = 1;
        }
      }
    }
#line 5194
    if (need_space) {
      {
#line 5194
      tmp___2 = d_last_char(dpi);
      }
#line 5194
      if ((int )tmp___2 != 32) {
        {
#line 5195
        d_append_char(dpi, (char )' ');
        }
      }
    }
    {
#line 5196
    d_append_char(dpi, (char )'(');
    }
  }
  {
#line 5199
  hold_modifiers = dpi->modifiers;
#line 5200
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 5202
  d_print_mod_list(dpi, options___0, mods, 0);
  }
#line 5204
  if (need_paren) {
    {
#line 5205
    d_append_char(dpi, (char )')');
    }
  }
  {
#line 5207
  d_append_char(dpi, (char )'(');
  }
#line 5209
  if ((unsigned long )dc->u.s_binary.right != (unsigned long )((void *)0)) {
    {
#line 5210
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
    }
  }
  {
#line 5212
  d_append_char(dpi, (char )')');
#line 5214
  d_print_mod_list(dpi, options___0, mods, 1);
#line 5216
  dpi->modifiers = hold_modifiers;
  }
#line 5217
  return;
}
}
#line 5221 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_array_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                               struct d_print_mod *mods ) 
{ 
  int need_space ;
  int need_paren ;
  struct d_print_mod *p ;

  {
#line 5228
  need_space = 1;
#line 5229
  if ((unsigned long )mods != (unsigned long )((void *)0)) {
#line 5234
    need_paren = 0;
#line 5235
    p = mods;
    {
#line 5235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5235
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 5235
        goto while_break;
      }
#line 5237
      if (! p->printed) {
#line 5239
        if ((unsigned int const   )(p->mod)->type == 42U) {
#line 5241
          need_space = 0;
#line 5242
          goto while_break;
        } else {
#line 5246
          need_paren = 1;
#line 5247
          need_space = 1;
#line 5248
          goto while_break;
        }
      }
#line 5235
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 5253
    if (need_paren) {
      {
#line 5254
      d_append_string(dpi, " (");
      }
    }
    {
#line 5256
    d_print_mod_list(dpi, options___0, mods, 0);
    }
#line 5258
    if (need_paren) {
      {
#line 5259
      d_append_char(dpi, (char )')');
      }
    }
  }
#line 5262
  if (need_space) {
    {
#line 5263
    d_append_char(dpi, (char )' ');
    }
  }
  {
#line 5265
  d_append_char(dpi, (char )'[');
  }
#line 5267
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
    {
#line 5268
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  }
  {
#line 5270
  d_append_char(dpi, (char )']');
  }
#line 5271
  return;
}
}
#line 5275 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_expr_op(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 


  {
#line 5279
  if ((unsigned int const   )dc->type == 49U) {
    {
#line 5280
    d_append_buffer(dpi, (char const   *)(dc->u.s_operator.op)->name, (size_t )(dc->u.s_operator.op)->len);
    }
  } else {
    {
#line 5283
    d_print_comp(dpi, options___0, dc);
    }
  }
#line 5284
  return;
}
}
#line 5288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static void d_print_cast(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  struct d_print_mod *hold_dpm ;
  struct d_print_template dpt ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 5292
  if ((unsigned int )(dc->u.s_binary.left)->type != 4U) {
    {
#line 5293
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  } else {
    {
#line 5304
    hold_dpm = dpi->modifiers;
#line 5305
    dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 5307
    dpt.next = dpi->templates;
#line 5308
    dpi->templates = & dpt;
#line 5309
    dpt.template_decl = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 5311
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.left)->u.s_binary.left);
#line 5313
    dpi->templates = dpt.next;
#line 5315
    tmp___0 = d_last_char(dpi);
    }
#line 5315
    if ((int )tmp___0 == 60) {
      {
#line 5316
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 5317
    d_append_char(dpi, (char )'<');
#line 5318
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.left)->u.s_binary.right);
#line 5321
    tmp___1 = d_last_char(dpi);
    }
#line 5321
    if ((int )tmp___1 == 62) {
      {
#line 5322
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 5323
    d_append_char(dpi, (char )'>');
#line 5325
    dpi->modifiers = hold_dpm;
    }
  }
#line 5327
  return;
}
}
#line 5333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
void cplus_demangle_init_info(char const   *mangled , int options___0 , size_t len ,
                              struct d_info *di ) 
{ 


  {
#line 5337
  di->s = mangled;
#line 5338
  di->send = mangled + len;
#line 5339
  di->options = options___0;
#line 5341
  di->n = mangled;
#line 5346
  di->num_comps = (int )(2UL * len);
#line 5347
  di->next_comp = 0;
#line 5351
  di->num_subs = (int )len;
#line 5352
  di->next_sub = 0;
#line 5353
  di->did_subs = 0;
#line 5355
  di->last_name = (struct demangle_component *)((void *)0);
#line 5357
  di->expansion = 0;
#line 5358
  return;
}
}
#line 5365 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int d_demangle_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) 
{ 
  enum __anonenum_type_117194467 type ;
  struct d_info di ;
  struct demangle_component *dc ;
  int status ;
  int tmp___0 ;
  size_t tmp___1 ;
  struct demangle_component *comps ;
  unsigned long __lengthofcomps ;
  void *tmp___2 ;
  struct demangle_component **subs ;
  unsigned long __lengthofsubs ;
  void *tmp___3 ;
  struct demangle_component *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 5381
  if ((int const   )*(mangled + 0) == 95) {
#line 5381
    if ((int const   )*(mangled + 1) == 90) {
#line 5382
      type = (enum __anonenum_type_117194467 )1;
    } else {
#line 5381
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 5383
    tmp___0 = strncmp(mangled, "_GLOBAL_", (size_t )8);
    }
#line 5383
    if (tmp___0 == 0) {
#line 5383
      if ((int const   )*(mangled + 8) == 46) {
#line 5383
        goto _L___3;
      } else
#line 5383
      if ((int const   )*(mangled + 8) == 95) {
#line 5383
        goto _L___3;
      } else
#line 5383
      if ((int const   )*(mangled + 8) == 36) {
        _L___3: /* CIL Label */ 
#line 5383
        if ((int const   )*(mangled + 9) == 68) {
#line 5383
          goto _L___1;
        } else
#line 5383
        if ((int const   )*(mangled + 9) == 73) {
          _L___1: /* CIL Label */ 
#line 5383
          if ((int const   )*(mangled + 10) == 95) {
#line 5387
            if ((int const   )*(mangled + 9) == 73) {
#line 5387
              type = (enum __anonenum_type_117194467 )2;
            } else {
#line 5387
              type = (enum __anonenum_type_117194467 )3;
            }
          } else {
#line 5383
            goto _L___2;
          }
        } else {
#line 5383
          goto _L___2;
        }
      } else {
#line 5383
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 5390
      if ((options___0 & (1 << 4)) == 0) {
#line 5391
        return (0);
      }
#line 5392
      type = (enum __anonenum_type_117194467 )0;
    }
  }
  {
#line 5395
  tmp___1 = strlen(mangled);
#line 5395
  cplus_demangle_init_info(mangled, options___0, tmp___1, & di);
#line 5399
  __lengthofcomps = (unsigned long )di.num_comps;
#line 5399
  tmp___2 = __builtin_alloca(sizeof(*comps) * __lengthofcomps);
#line 5399
  comps = (struct demangle_component *)tmp___2;
#line 5400
  __lengthofsubs = (unsigned long )di.num_subs;
#line 5400
  tmp___3 = __builtin_alloca(sizeof(*subs) * __lengthofsubs);
#line 5400
  subs = (struct demangle_component **)tmp___3;
#line 5402
  di.comps = comps;
#line 5403
  di.subs = subs;
  }
  {
#line 5411
  if ((unsigned int )type == 0U) {
#line 5411
    goto case_0;
  }
#line 5414
  if ((unsigned int )type == 1U) {
#line 5414
    goto case_1;
  }
#line 5418
  if ((unsigned int )type == 3U) {
#line 5418
    goto case_3;
  }
#line 5418
  if ((unsigned int )type == 2U) {
#line 5418
    goto case_3;
  }
#line 5409
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 5412
  dc = cplus_demangle_type(& di);
  }
#line 5413
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 5415
  dc = cplus_demangle_mangled_name(& di, 1);
  }
#line 5416
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 5419
  di.n += 11;
#line 5420
  tmp___4 = d_make_demangle_mangled_name(& di, di.n);
  }
#line 5420
  if ((unsigned int )type == 2U) {
#line 5420
    tmp___5 = 66;
  } else {
#line 5420
    tmp___5 = 67;
  }
  {
#line 5420
  dc = d_make_comp(& di, (enum demangle_component_type )tmp___5, tmp___4, (struct demangle_component *)((void *)0));
#line 5426
  tmp___6 = strlen(di.n);
#line 5426
  di.n += tmp___6;
  }
#line 5427
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5434
  if ((options___0 & 1) != 0) {
#line 5434
    if ((int const   )*(di.n) != 0) {
#line 5435
      dc = (struct demangle_component *)((void *)0);
    }
  }
#line 5441
  if ((unsigned long )dc != (unsigned long )((void *)0)) {
    {
#line 5441
    tmp___7 = cplus_demangle_print_callback(options___0, (struct demangle_component  const  *)dc,
                                            callback, opaque);
#line 5441
    status = tmp___7;
    }
  } else {
#line 5441
    status = 0;
  }
#line 5446
  return (status);
}
}
#line 5456 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static char *d_demangle(char const   *mangled , int options___0 , size_t *palc ) 
{ 
  struct d_growable_string dgs ;
  int status ;

  {
  {
#line 5462
  d_growable_string_init(& dgs, (size_t )0);
#line 5464
  status = d_demangle_callback(mangled, options___0, & d_growable_string_callback_adapter,
                               (void *)(& dgs));
  }
#line 5466
  if (status == 0) {
    {
#line 5468
    free((void *)dgs.buf);
#line 5469
    *palc = (size_t )0;
    }
#line 5470
    return ((char *)((void *)0));
  }
#line 5473
  if (dgs.allocation_failure) {
#line 5473
    *palc = (size_t )1;
  } else {
#line 5473
    *palc = dgs.alc;
  }
#line 5474
  return (dgs.buf);
}
}
#line 5616 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
char *cplus_demangle_v3(char const   *mangled , int options___0 ) 
{ 
  size_t alc ;
  char *tmp___0 ;

  {
  {
#line 5621
  tmp___0 = d_demangle(mangled, options___0, & alc);
  }
#line 5621
  return (tmp___0);
}
}
#line 5624 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int cplus_demangle_v3_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) 
{ 
  int tmp___0 ;

  {
  {
#line 5628
  tmp___0 = d_demangle_callback(mangled, options___0, callback, opaque);
  }
#line 5628
  return (tmp___0);
}
}
#line 5637 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
char *java_demangle_v3(char const   *mangled ) 
{ 
  size_t alc ;
  char *tmp___0 ;

  {
  {
#line 5642
  tmp___0 = d_demangle(mangled, ((1 << 2) | 1) | (1 << 5), & alc);
  }
#line 5642
  return (tmp___0);
}
}
#line 5645 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
int java_demangle_v3_callback(char const   *mangled , void (*callback)(char const   * ,
                                                                       size_t  , void * ) ,
                              void *opaque ) 
{ 
  int tmp___0 ;

  {
  {
#line 5649
  tmp___0 = d_demangle_callback(mangled, ((1 << 2) | 1) | (1 << 5), callback, opaque);
  }
#line 5649
  return (tmp___0);
}
}
#line 5662 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
static int is_ctor_or_dtor(char const   *mangled , enum gnu_v3_ctor_kinds *ctor_kind ,
                           enum gnu_v3_dtor_kinds *dtor_kind ) 
{ 
  struct d_info di ;
  struct demangle_component *dc ;
  int ret ;
  size_t tmp___0 ;
  struct demangle_component *comps ;
  unsigned long __lengthofcomps ;
  void *tmp___1 ;
  struct demangle_component **subs ;
  unsigned long __lengthofsubs ;
  void *tmp___2 ;

  {
  {
#line 5671
  *ctor_kind = (enum gnu_v3_ctor_kinds )0;
#line 5672
  *dtor_kind = (enum gnu_v3_dtor_kinds )0;
#line 5674
  tmp___0 = strlen(mangled);
#line 5674
  cplus_demangle_init_info(mangled, 1 << 14, tmp___0, & di);
#line 5678
  __lengthofcomps = (unsigned long )di.num_comps;
#line 5678
  tmp___1 = __builtin_alloca(sizeof(*comps) * __lengthofcomps);
#line 5678
  comps = (struct demangle_component *)tmp___1;
#line 5679
  __lengthofsubs = (unsigned long )di.num_subs;
#line 5679
  tmp___2 = __builtin_alloca(sizeof(*subs) * __lengthofsubs);
#line 5679
  subs = (struct demangle_component **)tmp___2;
#line 5681
  di.comps = comps;
#line 5682
  di.subs = subs;
#line 5688
  dc = cplus_demangle_mangled_name(& di, 1);
#line 5693
  ret = 0;
  }
  {
#line 5694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5694
    if (! ((unsigned long )dc != (unsigned long )((void *)0))) {
#line 5694
      goto while_break;
    }
    {
#line 5708
    if ((unsigned int )dc->type == 4U) {
#line 5708
      goto case_4;
    }
#line 5708
    if ((unsigned int )dc->type == 3U) {
#line 5708
      goto case_4;
    }
#line 5712
    if ((unsigned int )dc->type == 2U) {
#line 5712
      goto case_2;
    }
#line 5712
    if ((unsigned int )dc->type == 1U) {
#line 5712
      goto case_2;
    }
#line 5715
    if ((unsigned int )dc->type == 7U) {
#line 5715
      goto case_7;
    }
#line 5720
    if ((unsigned int )dc->type == 8U) {
#line 5720
      goto case_8;
    }
#line 5704
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 5705
    dc = (struct demangle_component *)((void *)0);
#line 5706
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 5709
    dc = dc->u.s_binary.left;
#line 5710
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 5713
    dc = dc->u.s_binary.right;
#line 5714
    goto switch_break;
    case_7: /* CIL Label */ 
#line 5716
    *ctor_kind = dc->u.s_ctor.kind;
#line 5717
    ret = 1;
#line 5718
    dc = (struct demangle_component *)((void *)0);
#line 5719
    goto switch_break;
    case_8: /* CIL Label */ 
#line 5721
    *dtor_kind = dc->u.s_dtor.kind;
#line 5722
    ret = 1;
#line 5723
    dc = (struct demangle_component *)((void *)0);
#line 5724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5729
  return (ret);
}
}
#line 5735 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor(char const   *name___0 ) 
{ 
  enum gnu_v3_ctor_kinds ctor_kind ;
  enum gnu_v3_dtor_kinds dtor_kind ;
  int tmp___0 ;

  {
  {
#line 5741
  tmp___0 = is_ctor_or_dtor(name___0, & ctor_kind, & dtor_kind);
  }
#line 5741
  if (! tmp___0) {
#line 5742
    return ((enum gnu_v3_ctor_kinds )0);
  }
#line 5743
  return (ctor_kind);
}
}
#line 5750 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./cp-demangle.c"
enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor(char const   *name___0 ) 
{ 
  enum gnu_v3_ctor_kinds ctor_kind ;
  enum gnu_v3_dtor_kinds dtor_kind ;
  int tmp___0 ;

  {
  {
#line 5756
  tmp___0 = is_ctor_or_dtor(name___0, & ctor_kind, & dtor_kind);
  }
#line 5756
  if (! tmp___0) {
#line 5757
    return ((enum gnu_v3_dtor_kinds )0);
  }
#line 5758
  return (dtor_kind);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 151 "./../include/libiberty.h"
char *reconcat(char *optr , char const   *first  , ...)  __attribute__((__sentinel__,
__malloc__)) ;
#line 157
unsigned long concat_length(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 164
char *concat_copy(char *dst , char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 171
char *concat_copy2(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 175 "./../include/libiberty.h"
char *libiberty_concat_ptr  ;
#line 69 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
__inline static unsigned long vconcat_length(char const   *first , va_list args ) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
__inline static unsigned long vconcat_length(char const   *first , va_list args ) 
{ 
  unsigned long length ;
  char const   *arg ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 73
  length = 0UL;
#line 76
  arg = first;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! arg) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___1 = strlen(arg);
#line 77
    length += tmp___1;
#line 76
    tmp___0 = __builtin_va_arg(args, char const   *);
#line 76
    arg = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (length);
}
}
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
__inline static char *vconcat_copy(char *dst , char const   *first , va_list args ) 
{ 
  char *end ;
  char const   *arg ;
  char const   *tmp___0 ;
  unsigned long length ;
  size_t tmp___1 ;

  {
#line 85
  end = dst;
#line 88
  arg = first;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! arg) {
#line 88
      goto while_break;
    }
    {
#line 90
    tmp___1 = strlen(arg);
#line 90
    length = tmp___1;
#line 91
    memcpy((void */* __restrict  */)end, (void const   */* __restrict  */)arg, length);
#line 92
    end += length;
#line 88
    tmp___0 = __builtin_va_arg(args, char const   *);
#line 88
    arg = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  *end = (char )'\000';
#line 96
  return (dst);
}
}
#line 101
unsigned long concat_length(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
unsigned long concat_length(char const   *first  , ...) 
{ 
  unsigned long length ;
  va_list args ;

  {
  {
#line 106
  __builtin_va_start(args, first);
#line 108
  length = vconcat_length(first, args);
#line 109
  __builtin_va_end(args);
  }
#line 111
  return (length);
}
}
#line 116
char *concat_copy(char *dst , char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 116 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
char *concat_copy(char *dst , char const   *first  , ...) 
{ 
  char *save_dst ;
  va_list args ;

  {
  {
#line 121
  __builtin_va_start(args, first);
#line 124
  vconcat_copy(dst, first, args);
#line 125
  save_dst = dst;
#line 126
  __builtin_va_end(args);
  }
#line 128
  return (save_dst);
}
}
#line 141
char *concat_copy2(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 141 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
char *concat_copy2(char const   *first  , ...) 
{ 
  va_list args ;

  {
  {
#line 144
  __builtin_va_start(args, first);
#line 146
  vconcat_copy(libiberty_concat_ptr, first, args);
#line 147
  __builtin_va_end(args);
  }
#line 149
  return (libiberty_concat_ptr);
}
}
#line 152
char *concat(char const   *first  , ...)  __attribute__((__sentinel__, __malloc__)) ;
#line 152 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
char *concat(char const   *first  , ...) 
{ 
  char *newstr ;
  va_list args ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  va_list args___0 ;

  {
  {
#line 158
  __builtin_va_start(args, first);
#line 160
  tmp___0 = vconcat_length(first, args);
#line 160
  tmp___1 = xmalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 160
  newstr = (char *)tmp___1;
#line 161
  __builtin_va_end(args);
#line 164
  __builtin_va_start(args___0, first);
#line 166
  vconcat_copy(newstr, first, args___0);
#line 167
  __builtin_va_end(args___0);
  }
#line 169
  return (newstr);
}
}
#line 190
char *reconcat(char *optr , char const   *first  , ...)  __attribute__((__sentinel__,
__malloc__)) ;
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./concat.c"
char *reconcat(char *optr , char const   *first  , ...) 
{ 
  char *newstr ;
  va_list args ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  va_list args___0 ;

  {
  {
#line 196
  __builtin_va_start(args, first);
#line 199
  tmp___0 = vconcat_length(first, args);
#line 199
  tmp___1 = xmalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 199
  newstr = (char *)tmp___1;
#line 200
  __builtin_va_end(args);
#line 203
  __builtin_va_start(args___0, first);
#line 206
  vconcat_copy(newstr, first, args___0);
  }
#line 207
  if (optr) {
    {
#line 208
    free((void *)optr);
    }
  }
  {
#line 209
  __builtin_va_end(args___0);
  }
#line 211
  return (newstr);
}
}
#line 672 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 229 "./../include/libiberty.h"
char *choose_temp_base(void)  __attribute__((__malloc__)) ;
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./choose-temp.c"
char *choose_temp_base(void)  __attribute__((__malloc__)) ;
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./choose-temp.c"
char *choose_temp_base(void) 
{ 
  char const   *base ;
  char *tmp___0 ;
  char *temp_filename ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 63
  tmp___0 = choose_tmpdir();
#line 63
  base = (char const   *)tmp___0;
#line 67
  tmp___1 = strlen(base);
#line 67
  len = (int )tmp___1;
#line 68
  tmp___2 = xmalloc(sizeof(char ) * (((unsigned long )len + (sizeof("ccXXXXXX") - 1UL)) + 1UL));
#line 68
  temp_filename = (char *)tmp___2;
#line 69
  strcpy((char */* __restrict  */)temp_filename, (char const   */* __restrict  */)base);
#line 70
  strcpy((char */* __restrict  */)(temp_filename + len), (char const   */* __restrict  */)"ccXXXXXX");
#line 72
  tmp___3 = mktemp(temp_filename);
  }
#line 72
  if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
    {
#line 73
    abort();
    }
  }
#line 74
  return (temp_filename);
}
}
#line 684 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 75 "./../include/libiberty.h"
char **buildargv(char const   *input )  __attribute__((__malloc__)) ;
#line 79
void freeargv(char **vector ) ;
#line 84
char **dupargv(char **argv )  __attribute__((__malloc__)) ;
#line 88
void expandargv(int *argcp , char ***argvp ) ;
#line 92
int writeargv(char **argv , FILE *f ) ;
#line 96
int countargv(char **argv ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
char **dupargv(char **argv )  __attribute__((__malloc__)) ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
char **dupargv(char **argv ) 
{ 
  int argc ;
  char **copy ;
  void *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 70
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 71
    return ((char **)((void *)0));
  }
#line 74
  argc = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp___0 = xmalloc((unsigned long )(argc + 1) * sizeof(char *));
#line 75
  copy = (char **)tmp___0;
#line 78
  argc = 0;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 78
      goto while_break___0;
    }
    {
#line 80
    tmp___1 = strlen((char const   *)*(argv + argc));
#line 80
    len = (int )tmp___1;
#line 81
    tmp___2 = xmalloc((size_t )(len + 1));
#line 81
    *(copy + argc) = (char *)tmp___2;
#line 82
    strcpy((char */* __restrict  */)*(copy + argc), (char const   */* __restrict  */)*(argv + argc));
#line 78
    argc ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  *(copy + argc) = (char *)((void *)0);
#line 85
  return (copy);
}
}
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
void freeargv(char **vector ) 
{ 
  register char **scan ;

  {
#line 105
  if ((unsigned long )vector != (unsigned long )((void *)0)) {
#line 107
    scan = vector;
    {
#line 107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 107
      if (! ((unsigned long )*scan != (unsigned long )((void *)0))) {
#line 107
        goto while_break;
      }
      {
#line 109
      free((void *)*scan);
#line 107
      scan ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 111
    free((void *)vector);
    }
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
static void consume_whitespace(char const   **input ) 
{ 


  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((int const   )_sch_istable[(int const   )*(*input) & 255] & 64)) {
#line 118
      goto while_break;
    }
#line 120
    (*input) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
static int only_whitespace(char const   *input ) 
{ 


  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if ((int const   )*input != 0) {
#line 127
      if (! ((int const   )_sch_istable[(int const   )*input & 255] & 64)) {
#line 127
        goto while_break;
      }
    } else {
#line 127
      goto while_break;
    }
#line 128
    input ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((int const   )*input == 0);
}
}
#line 173
char **buildargv(char const   *input )  __attribute__((__malloc__)) ;
#line 173 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
char **buildargv(char const   *input ) 
{ 
  char *arg ;
  char *copybuf ;
  int squote ;
  int dquote ;
  int bsquote ;
  int argc ;
  int maxargc ;
  char **argv ;
  char **nargv ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 177
  squote = 0;
#line 178
  dquote = 0;
#line 179
  bsquote = 0;
#line 180
  argc = 0;
#line 181
  maxargc = 0;
#line 182
  argv = (char **)((void *)0);
#line 185
  if ((unsigned long )input != (unsigned long )((void *)0)) {
    {
#line 187
    tmp___0 = strlen(input);
#line 187
    tmp___1 = xmalloc(tmp___0 + 1UL);
#line 187
    copybuf = (char *)tmp___1;
    }
    {
#line 190
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 193
      consume_whitespace(& input);
      }
#line 195
      if (maxargc == 0) {
#line 195
        goto _L;
      } else
#line 195
      if (argc >= maxargc - 1) {
        _L: /* CIL Label */ 
#line 198
        if ((unsigned long )argv == (unsigned long )((void *)0)) {
          {
#line 200
          maxargc = 8;
#line 201
          tmp___2 = xmalloc((unsigned long )maxargc * sizeof(char *));
#line 201
          nargv = (char **)tmp___2;
          }
        } else {
          {
#line 205
          maxargc *= 2;
#line 206
          tmp___3 = xrealloc((void *)argv, (unsigned long )maxargc * sizeof(char *));
#line 206
          nargv = (char **)tmp___3;
          }
        }
#line 208
        argv = nargv;
#line 209
        *(argv + argc) = (char *)((void *)0);
      }
#line 212
      arg = copybuf;
      {
#line 213
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 213
        if (! ((int const   )*input != 0)) {
#line 213
          goto while_break___0;
        }
#line 215
        if ((int const   )_sch_istable[(int const   )*input & 255] & 64) {
#line 215
          if (! squote) {
#line 215
            if (! dquote) {
#line 215
              if (! bsquote) {
#line 217
                goto while_break___0;
              } else {
#line 215
                goto _L___2;
              }
            } else {
#line 215
              goto _L___2;
            }
          } else {
#line 215
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 221
          if (bsquote) {
#line 223
            bsquote = 0;
#line 224
            tmp___4 = arg;
#line 224
            arg ++;
#line 224
            *tmp___4 = (char )*input;
          } else
#line 226
          if ((int const   )*input == 92) {
#line 228
            bsquote = 1;
          } else
#line 230
          if (squote) {
#line 232
            if ((int const   )*input == 39) {
#line 234
              squote = 0;
            } else {
#line 238
              tmp___5 = arg;
#line 238
              arg ++;
#line 238
              *tmp___5 = (char )*input;
            }
          } else
#line 241
          if (dquote) {
#line 243
            if ((int const   )*input == 34) {
#line 245
              dquote = 0;
            } else {
#line 249
              tmp___6 = arg;
#line 249
              arg ++;
#line 249
              *tmp___6 = (char )*input;
            }
          } else
#line 254
          if ((int const   )*input == 39) {
#line 256
            squote = 1;
          } else
#line 258
          if ((int const   )*input == 34) {
#line 260
            dquote = 1;
          } else {
#line 264
            tmp___7 = arg;
#line 264
            arg ++;
#line 264
            *tmp___7 = (char )*input;
          }
#line 267
          input ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      *arg = (char )'\000';
#line 271
      *(argv + argc) = xstrdup((char const   *)copybuf);
#line 272
      argc ++;
#line 273
      *(argv + argc) = (char *)((void *)0);
#line 275
      consume_whitespace(& input);
      }
#line 190
      if (! ((int const   )*input != 0)) {
#line 190
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 279
    free((void *)copybuf);
    }
  }
#line 281
  return (argv);
}
}
#line 296 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
int writeargv(char **argv , FILE *f ) 
{ 
  int status ;
  char const   *arg ;
  char c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 299
  status = 0;
#line 301
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 302
    return (1);
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 304
      goto while_break;
    }
#line 306
    arg = (char const   *)*argv;
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! ((int const   )*arg != 0)) {
#line 308
        goto while_break___0;
      }
#line 310
      c = (char )*arg;
#line 312
      if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 312
        goto _L;
      } else
#line 312
      if ((int )c == 92) {
#line 312
        goto _L;
      } else
#line 312
      if ((int )c == 39) {
#line 312
        goto _L;
      } else
#line 312
      if ((int )c == 34) {
        _L: /* CIL Label */ 
        {
#line 313
        tmp___0 = fputc('\\', f);
        }
#line 313
        if (-1 == tmp___0) {
#line 315
          status = 1;
#line 316
          goto done;
        }
      }
      {
#line 319
      tmp___1 = fputc((int )c, f);
      }
#line 319
      if (-1 == tmp___1) {
#line 321
        status = 1;
#line 322
        goto done;
      }
#line 324
      arg ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 327
    tmp___2 = fputc('\n', f);
    }
#line 327
    if (-1 == tmp___2) {
#line 329
      status = 1;
#line 330
      goto done;
    }
#line 332
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 336
  return (status);
}
}
#line 362 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
void expandargv(int *argcp , char ***argvp ) 
{ 
  int i ;
  int argv_dynamic ;
  unsigned int iteration_limit ;
  char const   *filename ;
  FILE *f ;
  long pos ;
  size_t len ;
  char *buffer___2 ;
  char **file_argv ;
  size_t file_argc ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 366
  i = 0;
#line 368
  argv_dynamic = 0;
#line 371
  iteration_limit = 2000U;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    i ++;
#line 374
    if (! (i < *argcp)) {
#line 374
      goto while_break;
    }
#line 395
    filename = (char const   *)*(*argvp + i);
#line 396
    if ((int const   )*(filename + 0) != 64) {
#line 397
      goto while_continue;
    }
#line 399
    iteration_limit --;
#line 399
    if (iteration_limit == 0U) {
      {
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error: too many @-files encountered\n",
              *(*argvp + 0));
#line 402
      xexit(1);
      }
    }
    {
#line 405
    filename ++;
#line 405
    f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 406
    if (! f) {
#line 407
      goto while_continue;
    }
    {
#line 408
    tmp___0 = fseek(f, 0L, 2);
    }
#line 408
    if (tmp___0 == -1) {
#line 409
      goto error;
    }
    {
#line 410
    pos = ftell(f);
    }
#line 411
    if (pos == -1L) {
#line 412
      goto error;
    }
    {
#line 413
    tmp___1 = fseek(f, 0L, 0);
    }
#line 413
    if (tmp___1 == -1) {
#line 414
      goto error;
    }
    {
#line 415
    tmp___2 = xmalloc((unsigned long )pos * sizeof(char ) + 1UL);
#line 415
    buffer___2 = (char *)tmp___2;
#line 416
    len = fread((void */* __restrict  */)buffer___2, sizeof(char ), (size_t )pos,
                (FILE */* __restrict  */)f);
    }
#line 417
    if (len != (size_t )pos) {
      {
#line 417
      tmp___3 = ferror(f);
      }
#line 417
      if (tmp___3) {
#line 422
        goto error;
      }
    }
    {
#line 424
    *(buffer___2 + len) = (char )'\000';
#line 428
    tmp___5 = only_whitespace((char const   *)buffer___2);
    }
#line 428
    if (tmp___5) {
      {
#line 430
      tmp___4 = xmalloc(sizeof(char *));
#line 430
      file_argv = (char **)tmp___4;
#line 431
      *(file_argv + 0) = (char *)((void *)0);
      }
    } else {
      {
#line 435
      file_argv = buildargv((char const   *)buffer___2);
      }
    }
#line 437
    if (! argv_dynamic) {
      {
#line 438
      *argvp = dupargv(*argvp);
      }
    }
#line 440
    file_argc = (size_t )0;
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! *(file_argv + file_argc)) {
#line 441
        goto while_break___0;
      }
#line 442
      file_argc ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 445
    tmp___6 = xrealloc((void *)*argvp, (((size_t )*argcp + file_argc) + 1UL) * sizeof(char *));
#line 445
    *argvp = (char **)tmp___6;
#line 448
    memmove((void *)((*argvp + i) + file_argc), (void const   *)((*argvp + i) + 1),
            (unsigned long )(*argcp - i) * sizeof(char *));
#line 450
    memcpy((void */* __restrict  */)(*argvp + i), (void const   */* __restrict  */)file_argv,
           file_argc * sizeof(char *));
#line 453
    *argcp = (int )((size_t )*argcp + (file_argc - 1UL));
#line 457
    free((void *)file_argv);
#line 458
    free((void *)buffer___2);
#line 461
    i --;
    }
    error: 
    {
#line 464
    fclose(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 479 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./argv.c"
int countargv(char **argv ) 
{ 
  int argc ;

  {
#line 484
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 485
    return (0);
  }
#line 486
  argc = 0;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 486
      goto while_break;
    }
#line 487
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 486
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  return (argc);
}
}
#line 655 "./../include/libiberty.h"
void *C_alloca(size_t size )  __attribute__((__malloc__)) ;
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
char const   *libiberty_optr  ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
char *libiberty_nptr  ;
#line 65 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
unsigned long libiberty_len  ;
#line 150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
static header *last_alloca_header  =    (header *)((void *)0);
#line 161
void *C_alloca(size_t size )  __attribute__((__malloc__)) ;
#line 161 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/libiberty/./alloca.c"
void *C_alloca(size_t size ) 
{ 
  char probe ;
  register char *depth ;
  register header *hp ;
  register header *np ;
  register void *new_storage ;
  void *tmp___0 ;

  {
#line 165
  depth = & probe;
#line 178
  hp = last_alloca_header;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )hp->h.deep < (unsigned long )depth) {
      {
#line 182
      np = hp->h.next;
#line 184
      free((void *)hp);
#line 186
      hp = np;
      }
    } else {
#line 189
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  last_alloca_header = hp;
#line 194
  if (size == 0UL) {
#line 195
    return ((void *)0);
  }
  {
#line 200
  tmp___0 = xmalloc(sizeof(char ) * (sizeof(header ) + size));
#line 200
  new_storage = (void *)((char *)tmp___0);
  }
#line 203
  if ((unsigned long )new_storage == (unsigned long )((void *)0)) {
    {
#line 204
    abort();
    }
  }
#line 206
  ((header *)new_storage)->h.next = last_alloca_header;
#line 207
  ((header *)new_storage)->h.deep = depth;
#line 209
  last_alloca_header = (header *)new_storage;
#line 213
  return ((void *)((char *)new_storage + sizeof(header )));
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/bucomm.h"
char *program_name ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.h"
void ( /* format attribute */ __attribute__((__nonnull__(1))) error)(char const   *message 
                                                                     , ...) ;
#line 31
void ( /* format attribute */ __attribute__((__nonnull__(1))) warn)(char const   *message 
                                                                    , ...) ;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.h"
void (*byte_put)(unsigned char * , elf_vma  , int  )  ;
#line 43
void byte_put_little_endian(unsigned char *field , elf_vma value , int size ) ;
#line 44
void byte_put_big_endian(unsigned char *field , elf_vma value , int size ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.h"
elf_vma (*byte_get)(unsigned char * , int  )  ;
#line 47
elf_vma byte_get_signed(unsigned char *field , int size ) ;
#line 48
elf_vma byte_get_little_endian(unsigned char *field , int size ) ;
#line 49
elf_vma byte_get_big_endian(unsigned char *field , int size ) ;
#line 50
void byte_get_64(unsigned char *field , elf_vma *high , elf_vma *low ) ;
#line 81
char *adjust_relative_path(char const   *file_name , char const   *name___0 , int name_len ) ;
#line 84
int setup_archive(struct archive_info *arch , char const   *file_name , FILE *file ,
                  bfd_boolean is_thin_archive , bfd_boolean read_symbols ) ;
#line 88
int setup_nested_archive(struct archive_info *nested_arch , char const   *member_file_name ) ;
#line 91
void release_archive(struct archive_info *arch ) ;
#line 95
char *get_archive_member_name(struct archive_info *arch , struct archive_info *nested_arch ) ;
#line 101
char *get_archive_member_name_at(struct archive_info *arch , unsigned long offset ,
                                 struct archive_info *nested_arch ) ;
#line 108
char *make_qualified_name(struct archive_info *arch , struct archive_info *nested_arch ,
                          char const   *member_name ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 33 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void ( /* format attribute */ __attribute__((__nonnull__(1))) error)(char const   *message 
                                                                     , ...) 
{ 
  va_list args ;
  char *tmp___0 ;

  {
  {
#line 39
  fflush(stdout);
#line 41
  __builtin_va_start(args, message);
#line 42
  tmp___0 = gettext("%s: Error: ");
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          program_name);
#line 43
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 44
  __builtin_va_end(args);
  }
#line 45
  return;
}
}
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void ( /* format attribute */ __attribute__((__nonnull__(1))) warn)(char const   *message 
                                                                    , ...) 
{ 
  va_list args ;
  char *tmp___0 ;

  {
  {
#line 53
  fflush(stdout);
#line 55
  __builtin_va_start(args, message);
#line 56
  tmp___0 = gettext("%s: Warning: ");
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          program_name);
#line 57
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 58
  __builtin_va_end(args);
  }
#line 59
  return;
}
}
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void byte_put_little_endian(unsigned char *field , elf_vma value , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 68
  if (size == 8) {
#line 68
    goto case_8;
  }
#line 74
  if (size == 4) {
#line 74
    goto case_4;
  }
#line 77
  if (size == 3) {
#line 77
    goto case_3;
  }
#line 80
  if (size == 2) {
#line 80
    goto case_2;
  }
#line 83
  if (size == 1) {
#line 83
    goto case_1;
  }
#line 87
  goto switch_default;
  case_8: /* CIL Label */ 
#line 69
  *(field + 7) = (unsigned char )((((value >> 24) >> 24) >> 8) & 255ULL);
#line 70
  *(field + 6) = (unsigned char )(((value >> 24) >> 24) & 255ULL);
#line 71
  *(field + 5) = (unsigned char )(((value >> 24) >> 16) & 255ULL);
#line 72
  *(field + 4) = (unsigned char )(((value >> 24) >> 8) & 255ULL);
  case_4: /* CIL Label */ 
#line 75
  *(field + 3) = (unsigned char )((value >> 24) & 255ULL);
  case_3: /* CIL Label */ 
#line 78
  *(field + 2) = (unsigned char )((value >> 16) & 255ULL);
  case_2: /* CIL Label */ 
#line 81
  *(field + 1) = (unsigned char )((value >> 8) & 255ULL);
  case_1: /* CIL Label */ 
#line 84
  *(field + 0) = (unsigned char )(value & 255ULL);
#line 85
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 88
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 88
  error((char const   *)tmp___0, size);
#line 89
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void byte_put_big_endian(unsigned char *field , elf_vma value , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 98
  if (size == 8) {
#line 98
    goto case_8;
  }
#line 106
  if (size == 4) {
#line 106
    goto case_4;
  }
#line 110
  if (size == 3) {
#line 110
    goto case_3;
  }
#line 114
  if (size == 2) {
#line 114
    goto case_2;
  }
#line 118
  if (size == 1) {
#line 118
    goto case_1;
  }
#line 122
  goto switch_default;
  case_8: /* CIL Label */ 
#line 99
  *(field + 7) = (unsigned char )(value & 255ULL);
#line 100
  *(field + 6) = (unsigned char )((value >> 8) & 255ULL);
#line 101
  *(field + 5) = (unsigned char )((value >> 16) & 255ULL);
#line 102
  *(field + 4) = (unsigned char )((value >> 24) & 255ULL);
#line 103
  value >>= 16;
#line 104
  value >>= 16;
  case_4: /* CIL Label */ 
#line 107
  *(field + 3) = (unsigned char )(value & 255ULL);
#line 108
  value >>= 8;
  case_3: /* CIL Label */ 
#line 111
  *(field + 2) = (unsigned char )(value & 255ULL);
#line 112
  value >>= 8;
  case_2: /* CIL Label */ 
#line 115
  *(field + 1) = (unsigned char )(value & 255ULL);
#line 116
  value >>= 8;
  case_1: /* CIL Label */ 
#line 119
  *(field + 0) = (unsigned char )(value & 255ULL);
#line 120
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 123
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 123
  error((char const   *)tmp___0, size);
#line 124
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
elf_vma byte_get_little_endian(unsigned char *field , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 135
  if (size == 1) {
#line 135
    goto case_1;
  }
#line 138
  if (size == 2) {
#line 138
    goto case_2;
  }
#line 142
  if (size == 3) {
#line 142
    goto case_3;
  }
#line 147
  if (size == 4) {
#line 147
    goto case_4;
  }
#line 153
  if (size == 5) {
#line 153
    goto case_5;
  }
#line 169
  if (size == 6) {
#line 169
    goto case_6;
  }
#line 186
  if (size == 7) {
#line 186
    goto case_7;
  }
#line 204
  if (size == 8) {
#line 204
    goto case_8;
  }
#line 223
  goto switch_default;
  case_1: /* CIL Label */ 
#line 136
  return ((elf_vma )*field);
  case_2: /* CIL Label */ 
#line 139
  return ((elf_vma )((unsigned int )*(field + 0) | ((unsigned int )*(field + 1) << 8)));
  case_3: /* CIL Label */ 
#line 143
  return ((elf_vma )(((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)));
  case_4: /* CIL Label */ 
#line 148
  return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  case_5: /* CIL Label */ 
#line 154
  if (sizeof(elf_vma ) == 8UL) {
#line 155
    return (((((elf_vma )*(field + 0) | ((elf_vma )*(field + 1) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 4) << 32));
  } else
#line 160
  if (sizeof(elf_vma ) == 4UL) {
#line 164
    return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  }
  case_6: /* CIL Label */ 
#line 170
  if (sizeof(elf_vma ) == 8UL) {
#line 171
    return ((((((elf_vma )*(field + 0) | ((elf_vma )*(field + 1) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 4) << 32)) | ((elf_vma )*(field + 5) << 40));
  } else
#line 177
  if (sizeof(elf_vma ) == 4UL) {
#line 181
    return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  }
  case_7: /* CIL Label */ 
#line 187
  if (sizeof(elf_vma ) == 8UL) {
#line 188
    return (((((((elf_vma )*(field + 0) | ((elf_vma )*(field + 1) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 4) << 32)) | ((elf_vma )*(field + 5) << 40)) | ((elf_vma )*(field + 6) << 48));
  } else
#line 195
  if (sizeof(elf_vma ) == 4UL) {
#line 199
    return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  }
  case_8: /* CIL Label */ 
#line 205
  if (sizeof(elf_vma ) == 8UL) {
#line 206
    return ((((((((elf_vma )*(field + 0) | ((elf_vma )*(field + 1) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 4) << 32)) | ((elf_vma )*(field + 5) << 40)) | ((elf_vma )*(field + 6) << 48)) | ((elf_vma )*(field + 7) << 56));
  } else
#line 214
  if (sizeof(elf_vma ) == 4UL) {
#line 218
    return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  }
  switch_default: /* CIL Label */ 
  {
#line 224
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 224
  error((char const   *)tmp___0, size);
#line 225
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 229 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
elf_vma byte_get_big_endian(unsigned char *field , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 234
  if (size == 1) {
#line 234
    goto case_1;
  }
#line 237
  if (size == 2) {
#line 237
    goto case_2;
  }
#line 240
  if (size == 3) {
#line 240
    goto case_3;
  }
#line 245
  if (size == 4) {
#line 245
    goto case_4;
  }
#line 251
  if (size == 5) {
#line 251
    goto case_5;
  }
#line 269
  if (size == 6) {
#line 269
    goto case_6;
  }
#line 288
  if (size == 7) {
#line 288
    goto case_7;
  }
#line 308
  if (size == 8) {
#line 308
    goto case_8;
  }
#line 329
  goto switch_default;
  case_1: /* CIL Label */ 
#line 235
  return ((elf_vma )*field);
  case_2: /* CIL Label */ 
#line 238
  return ((elf_vma )((unsigned int )*(field + 1) | (unsigned int )((int )*(field + 0) << 8)));
  case_3: /* CIL Label */ 
#line 241
  return ((elf_vma )(((unsigned long )*(field + 2) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 0) << 16)));
  case_4: /* CIL Label */ 
#line 246
  return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  case_5: /* CIL Label */ 
#line 252
  if (sizeof(elf_vma ) == 8UL) {
#line 253
    return (((((elf_vma )*(field + 4) | ((elf_vma )*(field + 3) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 1) << 24)) | ((elf_vma )*(field + 0) << 32));
  } else
#line 258
  if (sizeof(elf_vma ) == 4UL) {
#line 262
    field ++;
#line 263
    return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  }
  case_6: /* CIL Label */ 
#line 270
  if (sizeof(elf_vma ) == 8UL) {
#line 271
    return ((((((elf_vma )*(field + 5) | ((elf_vma )*(field + 4) << 8)) | ((elf_vma )*(field + 3) << 16)) | ((elf_vma )*(field + 2) << 24)) | ((elf_vma )*(field + 1) << 32)) | ((elf_vma )*(field + 0) << 40));
  } else
#line 277
  if (sizeof(elf_vma ) == 4UL) {
#line 281
    field += 2;
#line 282
    return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  }
  case_7: /* CIL Label */ 
#line 289
  if (sizeof(elf_vma ) == 8UL) {
#line 290
    return (((((((elf_vma )*(field + 6) | ((elf_vma )*(field + 5) << 8)) | ((elf_vma )*(field + 4) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 2) << 32)) | ((elf_vma )*(field + 1) << 40)) | ((elf_vma )*(field + 0) << 48));
  } else
#line 297
  if (sizeof(elf_vma ) == 4UL) {
#line 301
    field += 3;
#line 302
    return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  }
  case_8: /* CIL Label */ 
#line 309
  if (sizeof(elf_vma ) == 8UL) {
#line 310
    return ((((((((elf_vma )*(field + 7) | ((elf_vma )*(field + 6) << 8)) | ((elf_vma )*(field + 5) << 16)) | ((elf_vma )*(field + 4) << 24)) | ((elf_vma )*(field + 3) << 32)) | ((elf_vma )*(field + 2) << 40)) | ((elf_vma )*(field + 1) << 48)) | ((elf_vma )*(field + 0) << 56));
  } else
#line 318
  if (sizeof(elf_vma ) == 4UL) {
#line 322
    field += 4;
#line 323
    return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  }
  switch_default: /* CIL Label */ 
  {
#line 330
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 330
  error((char const   *)tmp___0, size);
#line 331
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 335 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
elf_vma byte_get_signed(unsigned char *field , int size ) 
{ 
  elf_vma x ;
  elf_vma tmp___0 ;

  {
  {
#line 338
  tmp___0 = (*byte_get)(field, size);
#line 338
  x = tmp___0;
  }
  {
#line 342
  if (size == 1) {
#line 342
    goto case_1;
  }
#line 344
  if (size == 2) {
#line 344
    goto case_2;
  }
#line 346
  if (size == 3) {
#line 346
    goto case_3;
  }
#line 348
  if (size == 4) {
#line 348
    goto case_4;
  }
#line 353
  if (size == 8) {
#line 353
    goto case_8;
  }
#line 353
  if (size == 7) {
#line 353
    goto case_8;
  }
#line 353
  if (size == 6) {
#line 353
    goto case_8;
  }
#line 353
  if (size == 5) {
#line 353
    goto case_8;
  }
#line 359
  goto switch_default;
  case_1: /* CIL Label */ 
#line 343
  return ((x ^ 128ULL) - 128ULL);
  case_2: /* CIL Label */ 
#line 345
  return ((x ^ 32768ULL) - 32768ULL);
  case_3: /* CIL Label */ 
#line 347
  return ((x ^ 8388608ULL) - 8388608ULL);
  case_4: /* CIL Label */ 
#line 349
  return ((x ^ 2147483648ULL) - 2147483648ULL);
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 358
  return (x);
  switch_default: /* CIL Label */ 
  {
#line 360
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void byte_get_64(unsigned char *field , elf_vma *high , elf_vma *low ) 
{ 


  {
#line 370
  if ((unsigned long )byte_get == (unsigned long )(& byte_get_big_endian)) {
    {
#line 372
    *high = byte_get_big_endian(field, 4);
#line 373
    *low = byte_get_big_endian(field + 4, 4);
    }
  } else {
    {
#line 377
    *high = byte_get_little_endian(field + 4, 4);
#line 378
    *low = byte_get_little_endian(field, 4);
    }
  }
#line 380
  return;
}
}
#line 387 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
char *adjust_relative_path(char const   *file_name , char const   *name___0 , int name_len ) 
{ 
  char *member_file_name ;
  char const   *base_name ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t prefix_len ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 392
  tmp___0 = lbasename(file_name);
#line 392
  base_name = tmp___0;
  }
#line 400
  if ((int const   )*(name___0 + 0) == 47) {
#line 400
    goto _L;
  } else
#line 400
  if ((int const   )*(name___0 + 0) == 92) {
#line 400
    goto _L___2;
  } else
  _L___2: /* CIL Label */ 
#line 400
  if (*(name___0 + 0)) {
#line 400
    if ((int const   )*(name___0 + 1) == 58) {
#line 400
      goto _L___1;
    } else {
#line 400
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 400
  if ((unsigned long )base_name == (unsigned long )file_name) {
    _L: /* CIL Label */ 
    {
#line 402
    tmp___1 = malloc((size_t )(name_len + 1));
#line 402
    member_file_name = (char *)tmp___1;
    }
#line 403
    if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
      {
#line 405
      tmp___2 = gettext("Out of memory\n");
#line 405
      error((char const   *)tmp___2);
      }
#line 406
      return ((char *)((void *)0));
    }
    {
#line 408
    memcpy((void */* __restrict  */)member_file_name, (void const   */* __restrict  */)name___0,
           (size_t )name_len);
#line 409
    *(member_file_name + name_len) = (char )'\000';
    }
  } else {
    {
#line 415
    prefix_len = (size_t )(base_name - file_name);
#line 416
    tmp___3 = malloc((prefix_len + (size_t )name_len) + 1UL);
#line 416
    member_file_name = (char *)tmp___3;
    }
#line 417
    if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
      {
#line 419
      tmp___4 = gettext("Out of memory\n");
#line 419
      error((char const   *)tmp___4);
      }
#line 420
      return ((char *)((void *)0));
    }
    {
#line 422
    memcpy((void */* __restrict  */)member_file_name, (void const   */* __restrict  */)file_name,
           prefix_len);
#line 423
    memcpy((void */* __restrict  */)(member_file_name + prefix_len), (void const   */* __restrict  */)name___0,
           (size_t )name_len);
#line 424
    *(member_file_name + (prefix_len + (size_t )name_len)) = (char )'\000';
    }
  }
#line 426
  return (member_file_name);
}
}
#line 439 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
static bfd_boolean process_archive_index_and_symbols(struct archive_info *arch , unsigned int sizeof_ar_index ,
                                                     bfd_boolean read_symbols ) 
{ 
  size_t got ;
  unsigned long size ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned long i ;
  unsigned char integer_buffer[sizeof(arch->index_num)] ;
  unsigned char *index_buffer ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 447
  size = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_size), (char **/* __restrict  */)((void *)0),
                 10);
#line 448
  size += size & 1UL;
#line 450
  arch->next_arhdr_offset += sizeof(arch->arhdr) + size;
  }
#line 452
  if (! read_symbols) {
    {
#line 454
    tmp___1 = fseek(arch->file, (long )size, 1);
    }
#line 454
    if (tmp___1 != 0) {
      {
#line 456
      tmp___0 = gettext("%s: failed to skip archive symbol table\n");
#line 456
      error((char const   *)tmp___0, arch->file_name);
      }
#line 458
      return (0);
    }
  } else {
#line 470
    if (! ((unsigned long )sizeof_ar_index <= sizeof(integer_buffer))) {
      {
#line 470
      __assert_fail("sizeof_ar_index <= sizeof integer_buffer", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c",
                    470U, "process_archive_index_and_symbols");
      }
    }
#line 473
    if (size < (unsigned long )sizeof_ar_index) {
      {
#line 475
      tmp___2 = gettext("%s: the archive index is empty\n");
#line 475
      error((char const   *)tmp___2, arch->file_name);
      }
#line 476
      return (0);
    }
    {
#line 480
    got = fread((void */* __restrict  */)(integer_buffer), (size_t )1, (size_t )sizeof_ar_index,
                (FILE */* __restrict  */)arch->file);
    }
#line 481
    if (got != (size_t )sizeof_ar_index) {
      {
#line 483
      tmp___3 = gettext("%s: failed to read archive index\n");
#line 483
      error((char const   *)tmp___3, arch->file_name);
      }
#line 484
      return (0);
    }
    {
#line 487
    arch->index_num = byte_get_big_endian(integer_buffer, (int )sizeof_ar_index);
#line 488
    size -= (unsigned long )sizeof_ar_index;
    }
#line 490
    if ((elf_vma )size < arch->index_num * (elf_vma )sizeof_ar_index) {
      {
#line 492
      tmp___4 = gettext("%s: the archive index is supposed to have %ld entries of %d bytes, but the size is only %ld\n");
#line 492
      error((char const   *)tmp___4, arch->file_name, (long )arch->index_num, sizeof_ar_index,
            size);
      }
#line 494
      return (0);
    }
    {
#line 498
    tmp___5 = malloc((size_t )(arch->index_num * (elf_vma )sizeof_ar_index));
#line 498
    index_buffer = (unsigned char *)tmp___5;
    }
#line 500
    if ((unsigned long )index_buffer == (unsigned long )((void *)0)) {
      {
#line 502
      tmp___6 = gettext("Out of memory whilst trying to read archive symbol index\n");
#line 502
      error((char const   *)tmp___6);
      }
#line 503
      return (0);
    }
    {
#line 506
    got = fread((void */* __restrict  */)index_buffer, (size_t )sizeof_ar_index, (size_t )arch->index_num,
                (FILE */* __restrict  */)arch->file);
    }
#line 507
    if ((elf_vma )got != arch->index_num) {
      {
#line 509
      free((void *)index_buffer);
#line 510
      tmp___7 = gettext("%s: failed to read archive index\n");
#line 510
      error((char const   *)tmp___7, arch->file_name);
      }
#line 511
      return (0);
    }
    {
#line 514
    size = (unsigned long )((elf_vma )size - arch->index_num * (elf_vma )sizeof_ar_index);
#line 517
    tmp___8 = malloc((size_t )(arch->index_num * (elf_vma )sizeof(*(arch->index_array))));
#line 517
    arch->index_array = (elf_vma *)tmp___8;
    }
#line 519
    if ((unsigned long )arch->index_array == (unsigned long )((void *)0)) {
      {
#line 521
      free((void *)index_buffer);
#line 522
      tmp___9 = gettext("Out of memory whilst trying to convert the archive symbol index\n");
#line 522
      error((char const   *)tmp___9);
      }
#line 523
      return (0);
    }
#line 526
    i = 0UL;
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (! ((elf_vma )i < arch->index_num)) {
#line 526
        goto while_break;
      }
      {
#line 527
      *(arch->index_array + i) = byte_get_big_endian(index_buffer + i * (unsigned long )sizeof_ar_index,
                                                     (int )sizeof_ar_index);
#line 526
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 530
    free((void *)index_buffer);
    }
#line 533
    if (size < 1UL) {
      {
#line 535
      tmp___10 = gettext("%s: the archive has an index but no symbols\n");
#line 535
      error((char const   *)tmp___10, arch->file_name);
      }
#line 537
      return (0);
    }
    {
#line 540
    tmp___11 = malloc(size);
#line 540
    arch->sym_table = (char *)tmp___11;
    }
#line 541
    if ((unsigned long )arch->sym_table == (unsigned long )((void *)0)) {
      {
#line 543
      tmp___12 = gettext("Out of memory whilst trying to read archive index symbol table\n");
#line 543
      error((char const   *)tmp___12);
      }
#line 544
      return (0);
    }
    {
#line 547
    arch->sym_size = size;
#line 548
    got = fread((void */* __restrict  */)arch->sym_table, (size_t )1, size, (FILE */* __restrict  */)arch->file);
    }
#line 549
    if (got != size) {
      {
#line 551
      tmp___13 = gettext("%s: failed to read archive index symbol table\n");
#line 551
      error((char const   *)tmp___13, arch->file_name);
      }
#line 553
      return (0);
    }
  }
  {
#line 558
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)arch->file);
  }
#line 559
  if (got != sizeof(arch->arhdr)) {
#line 559
    if (got != 0UL) {
      {
#line 561
      tmp___14 = gettext("%s: failed to read archive header following archive index\n");
#line 561
      error((char const   *)tmp___14, arch->file_name);
      }
#line 563
      return (0);
    }
  }
#line 566
  return (1);
}
}
#line 571 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
int setup_archive(struct archive_info *arch , char const   *file_name , FILE *file ,
                  bfd_boolean is_thin_archive , bfd_boolean read_symbols ) 
{ 
  size_t got ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  bfd_boolean tmp___3 ;
  bfd_boolean tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 578
  arch->file_name = strdup(file_name);
#line 579
  arch->file = file;
#line 580
  arch->index_num = (elf_vma )0;
#line 581
  arch->index_array = (elf_vma *)((void *)0);
#line 582
  arch->sym_table = (char *)((void *)0);
#line 583
  arch->sym_size = 0UL;
#line 584
  arch->longnames = (char *)((void *)0);
#line 585
  arch->longnames_size = 0UL;
#line 586
  arch->nested_member_origin = 0UL;
#line 587
  arch->is_thin_archive = is_thin_archive;
#line 588
  arch->uses_64bit_indicies = 0;
#line 589
  arch->next_arhdr_offset = 8UL;
#line 592
  tmp___1 = fseek(file, 8L, 0);
  }
#line 592
  if (tmp___1 != 0) {
    {
#line 594
    tmp___0 = gettext("%s: failed to seek to first archive header\n");
#line 594
    error((char const   *)tmp___0, file_name);
    }
#line 595
    return (1);
  }
  {
#line 597
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)file);
  }
#line 598
  if (got != sizeof(arch->arhdr)) {
#line 600
    if (got == 0UL) {
#line 601
      return (0);
    }
    {
#line 603
    tmp___2 = gettext("%s: failed to read archive header\n");
#line 603
    error((char const   *)tmp___2, file_name);
    }
#line 604
    return (1);
  }
  {
#line 608
  tmp___7 = strncmp((char const   *)(arch->arhdr.ar_name), "/               ", sizeof("/               ") - 1UL);
  }
#line 608
  if (tmp___7 == 0) {
    {
#line 610
    tmp___3 = process_archive_index_and_symbols(arch, 4U, read_symbols);
    }
#line 610
    if (! tmp___3) {
#line 611
      return (1);
    }
  } else {
    {
#line 613
    tmp___6 = strncmp((char const   *)(arch->arhdr.ar_name), "/SYM64/         ", sizeof("/SYM64/         ") - 1UL);
    }
#line 613
    if (tmp___6 == 0) {
      {
#line 615
      arch->uses_64bit_indicies = 1;
#line 616
      tmp___4 = process_archive_index_and_symbols(arch, 8U, read_symbols);
      }
#line 616
      if (! tmp___4) {
#line 617
        return (1);
      }
    } else
#line 619
    if (read_symbols) {
      {
#line 620
      tmp___5 = gettext("%s has no archive index\n");
#line 620
      printf((char const   */* __restrict  */)tmp___5, file_name);
      }
    }
  }
  {
#line 622
  tmp___12 = strncmp((char const   *)(arch->arhdr.ar_name), "//              ", sizeof("//              ") - 1UL);
  }
#line 622
  if (tmp___12 == 0) {
    {
#line 625
    arch->longnames_size = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_size),
                                   (char **/* __restrict  */)((void *)0), 10);
#line 626
    arch->next_arhdr_offset += sizeof(arch->arhdr) + arch->longnames_size;
#line 628
    tmp___8 = malloc(arch->longnames_size);
#line 628
    arch->longnames = (char *)tmp___8;
    }
#line 629
    if ((unsigned long )arch->longnames == (unsigned long )((void *)0)) {
      {
#line 631
      tmp___9 = gettext("Out of memory reading long symbol names in archive\n");
#line 631
      error((char const   *)tmp___9);
      }
#line 632
      return (1);
    }
    {
#line 635
    tmp___11 = fread((void */* __restrict  */)arch->longnames, arch->longnames_size,
                     (size_t )1, (FILE */* __restrict  */)file);
    }
#line 635
    if (tmp___11 != 1UL) {
      {
#line 637
      free((void *)arch->longnames);
#line 638
      arch->longnames = (char *)((void *)0);
#line 639
      tmp___10 = gettext("%s: failed to read long symbol name string table\n");
#line 639
      error((char const   *)tmp___10, file_name);
      }
#line 641
      return (1);
    }
#line 644
    if ((arch->longnames_size & 1UL) != 0UL) {
      {
#line 645
      _IO_getc(file);
      }
    }
  }
#line 648
  return (0);
}
}
#line 653 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
int setup_nested_archive(struct archive_info *nested_arch , char const   *member_file_name ) 
{ 
  FILE *member_file ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 660
  if ((unsigned long )nested_arch->file_name != (unsigned long )((void *)0)) {
    {
#line 660
    tmp___0 = strcmp((char const   *)nested_arch->file_name, member_file_name);
    }
#line 660
    if (tmp___0 == 0) {
#line 662
      return (0);
    }
  }
#line 665
  if ((unsigned long )nested_arch->file != (unsigned long )((void *)0)) {
    {
#line 666
    fclose(nested_arch->file);
    }
  }
  {
#line 667
  release_archive(nested_arch);
#line 669
  member_file = fopen((char const   */* __restrict  */)member_file_name, (char const   */* __restrict  */)"rb");
  }
#line 670
  if ((unsigned long )member_file == (unsigned long )((void *)0)) {
#line 671
    return (1);
  }
  {
#line 672
  tmp___1 = setup_archive(nested_arch, member_file_name, member_file, 0, 0);
  }
#line 672
  return (tmp___1);
}
}
#line 678 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
void release_archive(struct archive_info *arch ) 
{ 


  {
#line 681
  if ((unsigned long )arch->file_name != (unsigned long )((void *)0)) {
    {
#line 682
    free((void *)arch->file_name);
    }
  }
#line 683
  if ((unsigned long )arch->index_array != (unsigned long )((void *)0)) {
    {
#line 684
    free((void *)arch->index_array);
    }
  }
#line 685
  if ((unsigned long )arch->sym_table != (unsigned long )((void *)0)) {
    {
#line 686
    free((void *)arch->sym_table);
    }
  }
#line 687
  if ((unsigned long )arch->longnames != (unsigned long )((void *)0)) {
    {
#line 688
    free((void *)arch->longnames);
    }
  }
#line 689
  return;
}
}
#line 698 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
char *get_archive_member_name(struct archive_info *arch , struct archive_info *nested_arch ) 
{ 
  unsigned long j ;
  unsigned long k ;
  char *endp ;
  char *member_file_name ;
  char *member_name ;
  char *tmp___0 ;
  int tmp___1 ;
  char *name___0 ;
  void *tmp___2 ;

  {
#line 704
  if ((int )arch->arhdr.ar_name[0] == 47) {
#line 711
    if ((unsigned long )arch->longnames == (unsigned long )((void *)0)) {
      {
#line 713
      tmp___0 = gettext("Archive member uses long names, but no longname table found\n");
#line 713
      error((char const   *)tmp___0);
      }
#line 714
      return ((char *)((void *)0));
    } else
#line 711
    if (arch->longnames_size == 0UL) {
      {
#line 713
      tmp___0 = gettext("Archive member uses long names, but no longname table found\n");
#line 713
      error((char const   *)tmp___0);
      }
#line 714
      return ((char *)((void *)0));
    }
    {
#line 717
    arch->nested_member_origin = 0UL;
#line 718
    j = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_name + 1), (char **/* __restrict  */)(& endp),
                10);
#line 718
    k = j;
    }
#line 719
    if (arch->is_thin_archive) {
#line 719
      if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 719
        if ((int )*endp == 58) {
          {
#line 720
          arch->nested_member_origin = strtoul((char const   */* __restrict  */)(endp + 1),
                                               (char **/* __restrict  */)((void *)0),
                                               10);
          }
        }
      }
    }
    {
#line 722
    while (1) {
      while_continue: /* CIL Label */ ;
#line 722
      if (j < arch->longnames_size) {
#line 722
        if ((int )*(arch->longnames + j) != 10) {
#line 722
          if (! ((int )*(arch->longnames + j) != 0)) {
#line 722
            goto while_break;
          }
        } else {
#line 722
          goto while_break;
        }
      } else {
#line 722
        goto while_break;
      }
#line 725
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 726
    if ((int )*(arch->longnames + (j - 1UL)) == 47) {
#line 727
      j --;
    }
#line 728
    *(arch->longnames + j) = (char )'\000';
#line 730
    if (! arch->is_thin_archive) {
#line 731
      return (arch->longnames + k);
    } else
#line 730
    if (arch->nested_member_origin == 0UL) {
#line 731
      return (arch->longnames + k);
    }
    {
#line 735
    member_file_name = adjust_relative_path((char const   *)arch->file_name, (char const   *)(arch->longnames + k),
                                            (int )(j - k));
    }
#line 737
    if ((unsigned long )member_file_name != (unsigned long )((void *)0)) {
      {
#line 737
      tmp___1 = setup_nested_archive(nested_arch, (char const   *)member_file_name);
      }
#line 737
      if (tmp___1 == 0) {
        {
#line 740
        member_name = get_archive_member_name_at(nested_arch, arch->nested_member_origin,
                                                 (struct archive_info *)((void *)0));
        }
#line 743
        if ((unsigned long )member_name != (unsigned long )((void *)0)) {
          {
#line 745
          free((void *)member_file_name);
          }
#line 746
          return (member_name);
        }
      }
    }
    {
#line 749
    free((void *)member_file_name);
    }
#line 752
    return (arch->longnames + k);
  }
#line 756
  j = 0UL;
  {
#line 756
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 756
    if (! (j < sizeof(arch->arhdr.ar_name))) {
#line 756
      goto while_break___0;
    }
#line 757
    if ((int )arch->arhdr.ar_name[j] == 47) {
#line 759
      arch->arhdr.ar_name[j] = (char )'\000';
#line 760
      return (arch->arhdr.ar_name);
    }
#line 756
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 766
  tmp___2 = xmalloc(sizeof(arch->arhdr.ar_name) + 1UL);
#line 766
  name___0 = (char *)tmp___2;
#line 767
  memcpy((void */* __restrict  */)name___0, (void const   */* __restrict  */)(arch->arhdr.ar_name),
         sizeof(arch->arhdr.ar_name));
#line 768
  *(name___0 + sizeof(arch->arhdr.ar_name)) = (char )'\000';
  }
#line 769
  return (name___0);
}
}
#line 776 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
char *get_archive_member_name_at(struct archive_info *arch , unsigned long offset ,
                                 struct archive_info *nested_arch ) 
{ 
  size_t got ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 783
  tmp___1 = fseek(arch->file, (long )offset, 0);
  }
#line 783
  if (tmp___1 != 0) {
    {
#line 785
    tmp___0 = gettext("%s: failed to seek to next file name\n");
#line 785
    error((char const   *)tmp___0, arch->file_name);
    }
#line 786
    return ((char *)((void *)0));
  }
  {
#line 788
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)arch->file);
  }
#line 789
  if (got != sizeof(arch->arhdr)) {
    {
#line 791
    tmp___2 = gettext("%s: failed to read archive header\n");
#line 791
    error((char const   *)tmp___2, arch->file_name);
    }
#line 792
    return ((char *)((void *)0));
  }
  {
#line 794
  tmp___4 = memcmp((void const   *)(arch->arhdr.ar_fmag), (void const   *)"`\n", (size_t )2);
  }
#line 794
  if (tmp___4 != 0) {
    {
#line 796
    tmp___3 = gettext("%s: did not find a valid archive header\n");
#line 796
    error((char const   *)tmp___3, arch->file_name);
    }
#line 798
    return ((char *)((void *)0));
  }
  {
#line 801
  tmp___5 = get_archive_member_name(arch, nested_arch);
  }
#line 801
  return (tmp___5);
}
}
#line 810 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/elfcomm.c"
char *make_qualified_name(struct archive_info *arch , struct archive_info *nested_arch ,
                          char const   *member_name ) 
{ 
  char const   *error_name ;
  char *tmp___0 ;
  size_t len ;
  char *name___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 815
  tmp___0 = gettext("<corrupt>");
#line 815
  error_name = (char const   *)tmp___0;
#line 819
  tmp___1 = strlen((char const   *)arch->file_name);
#line 819
  tmp___2 = strlen(member_name);
#line 819
  len = (tmp___1 + tmp___2) + 3UL;
  }
#line 820
  if (arch->is_thin_archive) {
#line 820
    if (arch->nested_member_origin != 0UL) {
#line 824
      if (nested_arch->file_name) {
        {
#line 825
        tmp___3 = strlen((char const   *)nested_arch->file_name);
#line 825
        len += tmp___3 + 2UL;
        }
      } else {
        {
#line 827
        tmp___4 = strlen(error_name);
#line 827
        len += tmp___4 + 2UL;
        }
      }
    }
  }
  {
#line 830
  tmp___5 = malloc(len);
#line 830
  name___0 = (char *)tmp___5;
  }
#line 831
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 833
    tmp___6 = gettext("Out of memory\n");
#line 833
    error((char const   *)tmp___6);
    }
#line 834
    return ((char *)((void *)0));
  }
#line 837
  if (arch->is_thin_archive) {
#line 837
    if (arch->nested_member_origin != 0UL) {
#line 840
      if (nested_arch->file_name) {
        {
#line 841
        snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s[%s(%s)]",
                 arch->file_name, nested_arch->file_name, member_name);
        }
      } else {
        {
#line 844
        snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s[%s(%s)]",
                 arch->file_name, error_name, member_name);
        }
      }
    } else {
#line 837
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 847
  if (arch->is_thin_archive) {
    {
#line 848
    snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s[%s]",
             arch->file_name, member_name);
    }
  } else {
    {
#line 850
    snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s(%s)",
             arch->file_name, member_name);
    }
  }
#line 852
  return (name___0);
}
}
#line 524 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 390
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
struct dwarf_section_display debug_displays[34] ;
#line 204 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int eh_addr_size  ;
#line 206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_info  ;
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_abbrevs  ;
#line 208 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_lines  ;
#line 209 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_pubnames  ;
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_pubtypes  ;
#line 211 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_aranges  ;
#line 212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_ranges  ;
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_frames  ;
#line 214 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_frames_interp  ;
#line 215 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_macinfo  ;
#line 216 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_str  ;
#line 217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_loc  ;
#line 218 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_gdb_index  ;
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_trace_info  ;
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_trace_abbrevs  ;
#line 221 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_trace_aranges  ;
#line 222 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_addr  ;
#line 223 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_debug_cu_index  ;
#line 224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
int do_wide  ;
#line 226
int dwarf_cutoff_level ;
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.h"
unsigned long dwarf_start_die  ;
#line 229
int dwarf_check ;
#line 231
void init_dwarf_regnames(unsigned int e_machine ) ;
#line 232
void init_dwarf_regnames_i386(void) ;
#line 233
void init_dwarf_regnames_x86_64(void) ;
#line 235
int load_debug_section(enum dwarf_section_display_enum debug , void *file ) ;
#line 236
void free_debug_section(enum dwarf_section_display_enum debug ) ;
#line 238
void free_debug_memory(void) ;
#line 240
void dwarf_select_sections_by_names(char const   *names ) ;
#line 241
void dwarf_select_sections_by_letters(char const   *letters ) ;
#line 242
void dwarf_select_sections_all(void) ;
#line 244
unsigned int *find_cu_tu_set(void *file , unsigned int shndx ) ;
#line 246
void *cmalloc(size_t nmemb , size_t size ) ;
#line 247
void *xcmalloc(size_t nmemb , size_t size ) ;
#line 248
void *xcrealloc(void *ptr , size_t nmemb , size_t size ) ;
#line 250
dwarf_vma read_leb128(unsigned char *data , unsigned int *length_return , bfd_boolean sign ,
                      unsigned char const   * const  end ) ;
#line 36 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *regname(unsigned int regno , int row ) ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int have_frame_base  ;
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int need_base_address  ;
#line 41 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int last_pointer_size  =    0U;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int warned_about_missing_comp_units  =    0;
#line 44 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int num_debug_info_entries  =    0U;
#line 45 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static debug_info *debug_information  =    (debug_info *)((void *)0);
#line 72 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
int dwarf_cutoff_level  =    -1;
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
int dwarf_check  =    0;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int cu_tu_indexes_read  =    0;
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int *shndx_pool  =    (unsigned int *)((void *)0);
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int shndx_pool_size  =    0U;
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int shndx_pool_used  =    0U;
#line 100 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int cu_count  =    0;
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int tu_count  =    0;
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static struct cu_tu_set *cu_sets  =    (struct cu_tu_set *)((void *)0);
#line 103 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static struct cu_tu_set *tu_sets  =    (struct cu_tu_set *)((void *)0);
#line 105
static void load_cu_tu_indexes(void *file ) ;
#line 111 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int size_of_encoded_value(int encoding ) 
{ 


  {
  {
#line 118
  if ((encoding & 7) == 2) {
#line 118
    goto case_2;
  }
#line 119
  if ((encoding & 7) == 3) {
#line 119
    goto case_3;
  }
#line 120
  if ((encoding & 7) == 4) {
#line 120
    goto case_4;
  }
#line 116
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 117
  return (eh_addr_size);
  case_2: /* CIL Label */ 
#line 118
  return (2);
  case_3: /* CIL Label */ 
#line 119
  return (4);
  case_4: /* CIL Label */ 
#line 120
  return (8);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 124 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static dwarf_vma get_encoded_value(unsigned char *data , int encoding , struct dwarf_section *section ) 
{ 
  int size ;
  int tmp___0 ;
  dwarf_vma val ;

  {
  {
#line 129
  tmp___0 = size_of_encoded_value(encoding);
#line 129
  size = tmp___0;
  }
#line 132
  if (encoding & 8) {
    {
#line 133
    val = byte_get_signed(data, size);
    }
  } else {
    {
#line 135
    val = (*byte_get)(data, size);
    }
  }
#line 137
  if ((encoding & 112) == 16) {
#line 138
    val += section->address + (dwarf_vma )(data - section->start);
  }
#line 139
  return (val);
}
}
#line 167
static char const   *dwarf_vmatoa_1(char const   *fmtch , dwarf_vma value , unsigned int num_bytes ) ;
#line 167 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int buf_pos  =    0;
#line 168 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static struct dwarf_vmatoa_buf buf___2[16]  ;
#line 161 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *dwarf_vmatoa_1(char const   *fmtch , dwarf_vma value , unsigned int num_bytes ) 
{ 
  char *ret ;
  int tmp___0 ;
  char fmt[32] ;

  {
#line 174
  tmp___0 = buf_pos;
#line 174
  buf_pos ++;
#line 174
  ret = buf___2[tmp___0].place;
#line 175
  buf_pos = (int )((unsigned long )buf_pos % (sizeof(buf___2) / sizeof(buf___2[0])));
#line 177
  if (num_bytes) {
    {
#line 182
    snprintf((char */* __restrict  */)ret, sizeof(buf___2[0].place), (char const   */* __restrict  */)"%16.16llx",
             value);
    }
#line 183
    if (num_bytes > 8U) {
#line 184
      num_bytes = 8U;
    }
#line 185
    return ((char const   *)(ret + (16U - 2U * num_bytes)));
  } else {
    {
#line 191
    sprintf((char */* __restrict  */)(fmt), (char const   */* __restrict  */)"%%%s%s",
            "ll", fmtch);
#line 192
    snprintf((char */* __restrict  */)ret, sizeof(buf___2[0].place), (char const   */* __restrict  */)(fmt),
             value);
    }
#line 193
    return ((char const   *)ret);
  }
}
}
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
__inline static char const   *dwarf_vmatoa(char const   *fmtch , dwarf_vma value ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 200
  tmp___0 = dwarf_vmatoa_1(fmtch, value, 0U);
  }
#line 200
  return (tmp___0);
}
}
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void print_dwarf_vma(dwarf_vma value , unsigned int num_bytes ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 210
  tmp___0 = dwarf_vmatoa_1((char const   *)((void *)0), value, num_bytes);
#line 210
  printf((char const   */* __restrict  */)"%s ", tmp___0);
  }
#line 211
  return;
}
}
#line 216 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *dwarf_vmatoa64(dwarf_vma hvalue , dwarf_vma lvalue , char *buf___7 ,
                                    unsigned int buf_len ) 
{ 
  int len ;

  {
#line 220
  len = 0;
#line 222
  if (hvalue == 0ULL) {
    {
#line 223
    snprintf((char */* __restrict  */)buf___7, (size_t )buf_len, (char const   */* __restrict  */)"%llx",
             lvalue);
    }
  } else {
    {
#line 226
    len = snprintf((char */* __restrict  */)buf___7, (size_t )buf_len, (char const   */* __restrict  */)"%llx",
                   hvalue);
#line 227
    snprintf((char */* __restrict  */)(buf___7 + len), (size_t )(buf_len - (unsigned int )len),
             (char const   */* __restrict  */)"%08llx", lvalue);
    }
  }
#line 231
  return ((char const   *)buf___7);
}
}
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
dwarf_vma read_leb128(unsigned char *data , unsigned int *length_return , bfd_boolean sign ,
                      unsigned char const   * const  end ) 
{ 
  dwarf_vma result ;
  unsigned int num_read ;
  unsigned int shift ;
  unsigned char byte ;
  unsigned char *tmp___0 ;

  {
#line 245
  result = (dwarf_vma )0;
#line 246
  num_read = 0U;
#line 247
  shift = 0U;
#line 248
  byte = (unsigned char)0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 250
      goto while_break;
    }
#line 252
    tmp___0 = data;
#line 252
    data ++;
#line 252
    byte = *tmp___0;
#line 253
    num_read ++;
#line 255
    result |= (dwarf_vma )((int )byte & 127) << shift;
#line 257
    shift += 7U;
#line 258
    if (((int )byte & 128) == 0) {
#line 259
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if ((unsigned long )length_return != (unsigned long )((void *)0)) {
#line 263
    *length_return = num_read;
  }
#line 265
  if (sign) {
#line 265
    if ((unsigned long )shift < 8UL * sizeof(result)) {
#line 265
      if ((int )byte & 64) {
#line 266
        result |= (unsigned long long )(-1L << shift);
      }
    }
  }
#line 268
  return (result);
}
}
#line 272 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
__inline static dwarf_signed_vma read_sleb128(unsigned char *data , unsigned int *length_return ,
                                              unsigned char const   * const  end ) 
{ 
  dwarf_vma tmp___0 ;

  {
  {
#line 277
  tmp___0 = read_leb128(data, length_return, 1, end);
  }
#line 277
  return ((dwarf_signed_vma )tmp___0);
}
}
#line 280 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
__inline static dwarf_vma read_uleb128(unsigned char *data , unsigned int *length_return ,
                                       unsigned char const   * const  end ) 
{ 
  dwarf_vma tmp___0 ;

  {
  {
#line 285
  tmp___0 = read_leb128(data, length_return, 0, end);
  }
#line 285
  return (tmp___0);
}
}
#line 370 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static SMR state_machine_regs  ;
#line 372 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void reset_state_machine(int is_stmt ) 
{ 


  {
#line 375
  state_machine_regs.address = (dwarf_vma )0;
#line 376
  state_machine_regs.op_index = (unsigned char)0;
#line 377
  state_machine_regs.file = 1U;
#line 378
  state_machine_regs.line = 1U;
#line 379
  state_machine_regs.column = 0U;
#line 380
  state_machine_regs.is_stmt = is_stmt;
#line 381
  state_machine_regs.basic_block = 0;
#line 382
  state_machine_regs.end_sequence = (unsigned char)0;
#line 383
  state_machine_regs.last_file_entry = 0U;
#line 384
  return;
}
}
#line 389 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int process_extended_line_op(unsigned char *data , int is_stmt , unsigned char *end ) 
{ 
  unsigned char op_code ;
  unsigned int bytes_read ;
  unsigned int len ;
  unsigned char *name___0 ;
  unsigned char *orig_data ;
  dwarf_vma adr ;
  dwarf_vma tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___6 ;
  unsigned int amount ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  dwarf_vma tmp___12 ;
  char const   *tmp___13 ;
  dwarf_vma tmp___14 ;
  char const   *tmp___15 ;
  dwarf_vma tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  dwarf_vma tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  unsigned char *edata ;
  unsigned int opc ;
  dwarf_vma tmp___22 ;
  dwarf_vma tmp___23 ;
  char const   *tmp___24 ;
  dwarf_vma tmp___25 ;
  char const   *tmp___26 ;
  dwarf_vma tmp___27 ;
  char const   *tmp___28 ;
  dwarf_vma tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  unsigned int rlen ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  unsigned char *tmp___35 ;

  {
  {
#line 398
  orig_data = data;
#line 401
  tmp___0 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 401
  len = (unsigned int )tmp___0;
#line 402
  data += bytes_read;
  }
#line 404
  if (len == 0U) {
    {
#line 406
    tmp___1 = gettext("badly formed extended line op encountered!\n");
#line 406
    warn((char const   *)tmp___1);
    }
#line 407
    return ((int )bytes_read);
  } else
#line 404
  if ((unsigned long )data == (unsigned long )end) {
    {
#line 406
    tmp___1 = gettext("badly formed extended line op encountered!\n");
#line 406
    warn((char const   *)tmp___1);
    }
#line 407
    return ((int )bytes_read);
  }
  {
#line 410
  len += bytes_read;
#line 411
  tmp___2 = data;
#line 411
  data ++;
#line 411
  op_code = *tmp___2;
#line 413
  tmp___3 = gettext("  Extended opcode %d: ");
#line 413
  printf((char const   */* __restrict  */)tmp___3, (int )op_code);
  }
  {
#line 417
  if ((int )op_code == 1) {
#line 417
    goto case_1;
  }
#line 422
  if ((int )op_code == 2) {
#line 422
    goto case_2;
  }
#line 429
  if ((int )op_code == 3) {
#line 429
    goto case_3;
  }
#line 448
  if ((int )op_code == 4) {
#line 448
    goto case_4;
  }
#line 454
  if ((int )op_code == 17) {
#line 454
    goto case_17;
  }
#line 457
  if ((int )op_code == 18) {
#line 457
    goto case_18;
  }
#line 460
  if ((int )op_code == 19) {
#line 460
    goto case_19;
  }
#line 463
  if ((int )op_code == 20) {
#line 463
    goto case_20;
  }
#line 466
  if ((int )op_code == 21) {
#line 466
    goto case_21;
  }
#line 469
  if ((int )op_code == 22) {
#line 469
    goto case_22;
  }
#line 472
  if ((int )op_code == 23) {
#line 472
    goto case_23;
  }
#line 475
  if ((int )op_code == 24) {
#line 475
    goto case_24;
  }
#line 478
  if ((int )op_code == 25) {
#line 478
    goto case_25;
  }
#line 481
  if ((int )op_code == 32) {
#line 481
    goto case_32;
  }
#line 484
  if ((int )op_code == 128) {
#line 484
    goto case_128;
  }
#line 532
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 418
  tmp___4 = gettext("End of Sequence\n\n");
#line 418
  printf((char const   */* __restrict  */)tmp___4);
#line 419
  reset_state_machine(is_stmt);
  }
#line 420
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (8UL < (unsigned long )((len - bytes_read) - 1U)) {
#line 423
      tmp___5 = -1;
    } else {
#line 423
      tmp___5 = 1;
    }
    {
#line 423
    __lengthofdummy = (unsigned long )tmp___5;
#line 423
    tmp___6 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 423
    dummy = (int *)tmp___6;
#line 423
    amount = (len - bytes_read) - 1U;
    }
#line 423
    if ((unsigned long )(data + amount) >= (unsigned long )end) {
#line 423
      if ((unsigned long )data < (unsigned long )end) {
#line 423
        amount = (unsigned int )(end - data);
      } else {
#line 423
        amount = 0U;
      }
    }
#line 423
    if (amount) {
      {
#line 423
      adr = (*byte_get)(data, (int )amount);
      }
    } else {
#line 423
      adr = (dwarf_vma )0;
    }
#line 423
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  tmp___7 = dwarf_vmatoa("x", adr);
#line 424
  tmp___8 = gettext("set Address to 0x%s\n");
#line 424
  printf((char const   */* __restrict  */)tmp___8, tmp___7);
#line 425
  state_machine_regs.address = adr;
#line 426
  state_machine_regs.op_index = (unsigned char)0;
  }
#line 427
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 430
  tmp___9 = gettext("define new File Table entry\n");
#line 430
  printf((char const   */* __restrict  */)tmp___9);
#line 431
  tmp___10 = gettext("  Entry\tDir\tTime\tSize\tName\n");
#line 431
  printf((char const   */* __restrict  */)tmp___10);
#line 432
  (state_machine_regs.last_file_entry) ++;
#line 432
  printf((char const   */* __restrict  */)"   %d\t", state_machine_regs.last_file_entry);
#line 434
  name___0 = data;
#line 435
  tmp___11 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 435
  data += tmp___11 + 1UL;
#line 436
  tmp___12 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 436
  tmp___13 = dwarf_vmatoa("u", tmp___12);
#line 436
  printf((char const   */* __restrict  */)"%s\t", tmp___13);
#line 437
  data += bytes_read;
#line 438
  tmp___14 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 438
  tmp___15 = dwarf_vmatoa("u", tmp___14);
#line 438
  printf((char const   */* __restrict  */)"%s\t", tmp___15);
#line 439
  data += bytes_read;
#line 440
  tmp___16 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 440
  tmp___17 = dwarf_vmatoa("u", tmp___16);
#line 440
  printf((char const   */* __restrict  */)"%s\t", tmp___17);
#line 441
  data += bytes_read;
#line 442
  printf((char const   */* __restrict  */)"%s\n\n", name___0);
  }
#line 444
  if ((unsigned int )(data - orig_data) != len) {
    {
#line 445
    tmp___18 = gettext("DW_LNE_define_file: Bad opcode length\n");
#line 445
    warn((char const   *)tmp___18);
    }
  } else
#line 444
  if ((unsigned long )data == (unsigned long )end) {
    {
#line 445
    tmp___18 = gettext("DW_LNE_define_file: Bad opcode length\n");
#line 445
    warn((char const   *)tmp___18);
    }
  }
#line 446
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 449
  tmp___19 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 449
  tmp___20 = dwarf_vmatoa("u", tmp___19);
#line 449
  tmp___21 = gettext("set Discriminator to %s\n");
#line 449
  printf((char const   */* __restrict  */)tmp___21, tmp___20);
  }
#line 451
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 455
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_is_UV_update\n");
  }
#line 456
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 458
  printf((char const   */* __restrict  */)"DW_LNE_HP_push_context\n");
  }
#line 459
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 461
  printf((char const   */* __restrict  */)"DW_LNE_HP_pop_context\n");
  }
#line 462
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 464
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_file_line_column\n");
  }
#line 465
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 467
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_routine_name\n");
  }
#line 468
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 470
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_sequence\n");
  }
#line 471
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 473
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_post_semantics\n");
  }
#line 474
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 476
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_function_exit\n");
  }
#line 477
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 479
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_front_end_logical\n");
  }
#line 480
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 482
  printf((char const   */* __restrict  */)"DW_LNE_HP_define_proc\n");
  }
#line 483
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 486
  edata = ((data + len) - bytes_read) - 1;
#line 488
  printf((char const   */* __restrict  */)"DW_LNE_HP_source_file_correlation\n");
  }
  {
#line 490
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 490
    if (! ((unsigned long )data < (unsigned long )edata)) {
#line 490
      goto while_break___0;
    }
    {
#line 494
    tmp___22 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)edata);
#line 494
    opc = (unsigned int )tmp___22;
#line 495
    data += bytes_read;
    }
    {
#line 499
    if (opc == 1U) {
#line 499
      goto case_1___0;
    }
#line 502
    if (opc == 2U) {
#line 502
      goto case_2___0;
    }
#line 508
    if (opc == 3U) {
#line 508
      goto case_3___0;
    }
#line 523
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 500
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_formfeed\n");
    }
#line 501
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 503
    tmp___23 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)edata);
#line 503
    tmp___24 = dwarf_vmatoa("u", tmp___23);
#line 503
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_set_listing_line (%s)\n",
           tmp___24);
#line 506
    data += bytes_read;
    }
#line 507
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 509
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_associate ");
#line 510
    tmp___25 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)edata);
#line 510
    tmp___26 = dwarf_vmatoa("u", tmp___25);
#line 510
    printf((char const   */* __restrict  */)"(%s", tmp___26);
#line 513
    data += bytes_read;
#line 514
    tmp___27 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)edata);
#line 514
    tmp___28 = dwarf_vmatoa("u", tmp___27);
#line 514
    printf((char const   */* __restrict  */)",%s", tmp___28);
#line 517
    data += bytes_read;
#line 518
    tmp___29 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)edata);
#line 518
    tmp___30 = dwarf_vmatoa("u", tmp___29);
#line 518
    printf((char const   */* __restrict  */)",%s)\n", tmp___30);
#line 521
    data += bytes_read;
    }
#line 522
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 524
    tmp___31 = gettext("    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n");
#line 524
    printf((char const   */* __restrict  */)tmp___31, opc);
#line 525
    data = edata;
    }
#line 526
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 530
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 534
  rlen = (len - bytes_read) - 1U;
#line 536
  if ((int )op_code >= 128) {
    {
#line 541
    tmp___32 = gettext("user defined: ");
#line 541
    printf((char const   */* __restrict  */)tmp___32);
    }
  } else {
    {
#line 543
    tmp___33 = gettext("UNKNOWN: ");
#line 543
    printf((char const   */* __restrict  */)tmp___33);
    }
  }
  {
#line 544
  tmp___34 = gettext("length %d [");
#line 544
  printf((char const   */* __restrict  */)tmp___34, rlen);
  }
  {
#line 545
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 545
    if (! rlen) {
#line 545
      goto while_break___1;
    }
    {
#line 546
    tmp___35 = data;
#line 546
    data ++;
#line 546
    printf((char const   */* __restrict  */)" %02x", (int )*tmp___35);
#line 545
    rlen --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 547
  printf((char const   */* __restrict  */)"]\n");
  }
#line 549
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 552
  return ((int )len);
}
}
#line 555 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char const   *fetch_indirect_string(dwarf_vma offset ) 
{ 
  struct dwarf_section *section ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 558
  section = & debug_displays[9].section;
#line 560
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
    {
#line 561
    tmp___0 = gettext("<no .debug_str section>");
    }
#line 561
    return ((unsigned char const   *)tmp___0);
  }
#line 564
  offset -= section->address;
#line 565
  if (offset > section->size) {
    {
#line 567
    tmp___1 = dwarf_vmatoa("x", offset);
#line 567
    tmp___2 = gettext("DW_FORM_strp offset too big: %s\n");
#line 567
    warn((char const   *)tmp___2, tmp___1);
#line 569
    tmp___3 = gettext("<offset is too big>");
    }
#line 569
    return ((unsigned char const   *)tmp___3);
  }
#line 572
  return ((unsigned char const   *)section->start + offset);
}
}
#line 575 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *fetch_indexed_string(dwarf_vma idx___0 , struct cu_tu_set *this_set ,
                                          dwarf_vma offset_size , int dwo ) 
{ 
  enum dwarf_section_display_enum str_sec_idx ;
  int tmp___0 ;
  enum dwarf_section_display_enum idx_sec_idx ;
  int tmp___1 ;
  struct dwarf_section *index_section ;
  struct dwarf_section *str_section ;
  dwarf_vma index_offset ;
  dwarf_vma str_offset ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 579
  if (dwo) {
#line 579
    tmp___0 = 28;
  } else {
#line 579
    tmp___0 = 9;
  }
#line 579
  str_sec_idx = (enum dwarf_section_display_enum )tmp___0;
#line 580
  if (dwo) {
#line 580
    tmp___1 = 30;
  } else {
#line 580
    tmp___1 = 29;
  }
#line 580
  idx_sec_idx = (enum dwarf_section_display_enum )tmp___1;
#line 581
  index_section = & debug_displays[idx_sec_idx].section;
#line 582
  str_section = & debug_displays[str_sec_idx].section;
#line 583
  index_offset = idx___0 * offset_size;
#line 586
  if ((unsigned long )index_section->start == (unsigned long )((void *)0)) {
#line 587
    if (dwo) {
      {
#line 587
      tmp___2 = gettext("<no .debug_str_offsets.dwo section>");
#line 587
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 587
      tmp___3 = gettext("<no .debug_str_offsets section>");
#line 587
      tmp___4 = tmp___3;
      }
    }
#line 587
    return ((char const   *)tmp___4);
  }
#line 591
  index_offset -= index_section->address;
#line 592
  if ((unsigned long )this_set != (unsigned long )((void *)0)) {
#line 593
    index_offset += this_set->section_offsets[6];
  }
#line 594
  if (index_offset > index_section->size) {
    {
#line 596
    tmp___5 = dwarf_vmatoa("x", index_offset);
#line 596
    tmp___6 = gettext("DW_FORM_GNU_str_index offset too big: %s\n");
#line 596
    warn((char const   *)tmp___6, tmp___5);
#line 598
    tmp___7 = gettext("<index offset is too big>");
    }
#line 598
    return ((char const   *)tmp___7);
  }
#line 601
  if ((unsigned long )str_section->start == (unsigned long )((void *)0)) {
#line 602
    if (dwo) {
      {
#line 602
      tmp___8 = gettext("<no .debug_str.dwo section>");
#line 602
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 602
      tmp___9 = gettext("<no .debug_str section>");
#line 602
      tmp___10 = tmp___9;
      }
    }
#line 602
    return ((char const   *)tmp___10);
  }
  {
#line 605
  str_offset = (*byte_get)(index_section->start + index_offset, (int )offset_size);
#line 606
  str_offset -= str_section->address;
  }
#line 607
  if (str_offset > str_section->size) {
    {
#line 609
    tmp___11 = dwarf_vmatoa("x", str_offset);
#line 609
    tmp___12 = gettext("DW_FORM_GNU_str_index indirect offset too big: %s\n");
#line 609
    warn((char const   *)tmp___12, tmp___11);
#line 611
    tmp___13 = gettext("<indirect index offset is too big>");
    }
#line 611
    return ((char const   *)tmp___13);
  }
#line 614
  return ((char const   *)str_section->start + str_offset);
}
}
#line 617 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *fetch_indexed_value(dwarf_vma offset , dwarf_vma bytes ) 
{ 
  struct dwarf_section *section ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  elf_vma tmp___3 ;
  char const   *tmp___4 ;

  {
#line 620
  section = & debug_displays[31].section;
#line 622
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
    {
#line 623
    tmp___0 = gettext("<no .debug_addr section>");
    }
#line 623
    return ((char const   *)tmp___0);
  }
#line 625
  if (offset + bytes > section->size) {
    {
#line 627
    tmp___1 = dwarf_vmatoa("x", offset);
#line 627
    tmp___2 = gettext("Offset into section %s too big: %s\n");
#line 627
    warn((char const   *)tmp___2, section->name, tmp___1);
    }
#line 629
    return ("<offset too big>");
  }
  {
#line 632
  tmp___3 = (*byte_get)(section->start + offset, (int )bytes);
#line 632
  tmp___4 = dwarf_vmatoa("x", tmp___3);
  }
#line 632
  return (tmp___4);
}
}
#line 658 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static abbrev_entry *first_abbrev  =    (abbrev_entry *)((void *)0);
#line 659 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static abbrev_entry *last_abbrev  =    (abbrev_entry *)((void *)0);
#line 661 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void free_abbrevs(void) 
{ 
  abbrev_entry *abbrv ;
  abbrev_entry *next_abbrev ;
  abbrev_attr *attr ;
  abbrev_attr *next_attr ;

  {
#line 666
  abbrv = first_abbrev;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! abbrv) {
#line 666
      goto while_break;
    }
#line 668
    next_abbrev = abbrv->next;
#line 671
    attr = abbrv->first_attr;
    {
#line 671
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 671
      if (! attr) {
#line 671
        goto while_break___0;
      }
      {
#line 673
      next_attr = attr->next;
#line 675
      free((void *)attr);
#line 676
      attr = next_attr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 679
    free((void *)abbrv);
#line 680
    abbrv = next_abbrev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  first_abbrev = (abbrev_entry *)((void *)0);
#line 683
  last_abbrev = first_abbrev;
#line 684
  return;
}
}
#line 686 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void add_abbrev(unsigned long number , unsigned long tag , int children ) 
{ 
  abbrev_entry *entry ;
  void *tmp___0 ;

  {
  {
#line 691
  tmp___0 = malloc(sizeof(*entry));
#line 691
  entry = (abbrev_entry *)tmp___0;
  }
#line 692
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 694
    return;
  }
#line 696
  entry->entry = number;
#line 697
  entry->tag = tag;
#line 698
  entry->children = children;
#line 699
  entry->first_attr = (struct abbrev_attr *)((void *)0);
#line 700
  entry->last_attr = (struct abbrev_attr *)((void *)0);
#line 701
  entry->next = (struct abbrev_entry *)((void *)0);
#line 703
  if ((unsigned long )first_abbrev == (unsigned long )((void *)0)) {
#line 704
    first_abbrev = entry;
  } else {
#line 706
    last_abbrev->next = entry;
  }
#line 708
  last_abbrev = entry;
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void add_abbrev_attr(unsigned long attribute , unsigned long form ) 
{ 
  abbrev_attr *attr ;
  void *tmp___0 ;

  {
  {
#line 716
  tmp___0 = malloc(sizeof(*attr));
#line 716
  attr = (abbrev_attr *)tmp___0;
  }
#line 717
  if ((unsigned long )attr == (unsigned long )((void *)0)) {
#line 719
    return;
  }
#line 721
  attr->attribute = attribute;
#line 722
  attr->form = form;
#line 723
  attr->next = (struct abbrev_attr *)((void *)0);
#line 725
  if ((unsigned long )last_abbrev->first_attr == (unsigned long )((void *)0)) {
#line 726
    last_abbrev->first_attr = attr;
  } else {
#line 728
    (last_abbrev->last_attr)->next = attr;
  }
#line 730
  last_abbrev->last_attr = attr;
#line 731
  return;
}
}
#line 738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *process_abbrev_section(unsigned char *start , unsigned char *end ) 
{ 
  unsigned int bytes_read ;
  unsigned long entry ;
  unsigned long tag ;
  unsigned long attribute ;
  int children ;
  dwarf_vma tmp___0 ;
  dwarf_vma tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long form ;
  dwarf_vma tmp___3 ;
  dwarf_vma tmp___4 ;
  char *tmp___5 ;

  {
#line 741
  if ((unsigned long )first_abbrev != (unsigned long )((void *)0)) {
#line 742
    return ((unsigned char *)((void *)0));
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 744
      goto while_break;
    }
    {
#line 752
    tmp___0 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)end);
#line 752
    entry = (unsigned long )tmp___0;
#line 753
    start += bytes_read;
    }
#line 758
    if ((unsigned long )start == (unsigned long )end) {
#line 759
      return ((unsigned char *)((void *)0));
    }
#line 760
    if (entry == 0UL) {
#line 761
      return (start);
    }
    {
#line 763
    tmp___1 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)end);
#line 763
    tag = (unsigned long )tmp___1;
#line 764
    start += bytes_read;
    }
#line 765
    if ((unsigned long )start == (unsigned long )end) {
#line 766
      return ((unsigned char *)((void *)0));
    }
    {
#line 768
    tmp___2 = start;
#line 768
    start ++;
#line 768
    children = (int )*tmp___2;
#line 770
    add_abbrev(entry, tag, children);
    }
    {
#line 772
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 776
      tmp___3 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)end);
#line 776
      attribute = (unsigned long )tmp___3;
#line 777
      start += bytes_read;
      }
#line 778
      if ((unsigned long )start == (unsigned long )end) {
#line 779
        goto while_break___0;
      }
      {
#line 781
      tmp___4 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)end);
#line 781
      form = (unsigned long )tmp___4;
#line 782
      start += bytes_read;
      }
#line 783
      if ((unsigned long )start == (unsigned long )end) {
#line 784
        goto while_break___0;
      }
      {
#line 786
      add_abbrev_attr(attribute, form);
      }
#line 772
      if (! (attribute != 0UL)) {
#line 772
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 792
  tmp___5 = gettext(".debug_abbrev section not zero terminated\n");
#line 792
  error((char const   *)tmp___5);
  }
#line 794
  return ((unsigned char *)((void *)0));
}
}
#line 804 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char buffer[100]  ;
#line 797 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *get_TAG_name(unsigned long tag ) 
{ 
  char const   *name___0 ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 800
  tmp___0 = get_DW_TAG_name((unsigned int )tag);
#line 800
  name___0 = tmp___0;
  }
#line 802
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 806
    tmp___1 = gettext("Unknown TAG value: %lx");
#line 806
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)tmp___1,
             tag);
    }
#line 807
    return ((char const   *)(buffer));
  }
#line 810
  return (name___0);
}
}
#line 824 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char buffer___0[100]  ;
#line 813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *get_FORM_name(unsigned long form ) 
{ 
  char const   *name___0 ;
  char *tmp___0 ;

  {
#line 818
  if (form == 0UL) {
#line 819
    return ("DW_FORM value: 0");
  }
  {
#line 821
  name___0 = get_DW_FORM_name((unsigned int )form);
  }
#line 822
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 826
    tmp___0 = gettext("Unknown FORM value: %lx");
#line 826
    snprintf((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)tmp___0,
             form);
    }
#line 827
    return ((char const   *)(buffer___0));
  }
#line 830
  return (name___0);
}
}
#line 833 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *display_block(unsigned char *data , dwarf_vma length , unsigned char const   * const  end ) 
{ 
  dwarf_vma maxlen ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  elf_vma tmp___3 ;
  dwarf_vma tmp___4 ;

  {
  {
#line 840
  tmp___0 = dwarf_vmatoa("u", length);
#line 840
  tmp___1 = gettext(" %s byte block: ");
#line 840
  printf((char const   */* __restrict  */)tmp___1, tmp___0);
#line 842
  maxlen = (dwarf_vma )(end - (unsigned char const   */* const  */)data);
  }
#line 843
  if (length > maxlen) {
#line 843
    length = maxlen;
  } else {
#line 843
    length = length;
  }
  {
#line 845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 845
    tmp___4 = length;
#line 845
    length --;
#line 845
    if (! tmp___4) {
#line 845
      goto while_break;
    }
    {
#line 846
    tmp___2 = data;
#line 846
    data ++;
#line 846
    tmp___3 = (*byte_get)(tmp___2, 1);
#line 846
    printf((char const   */* __restrict  */)"%lx ", (unsigned long )tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 848
  return (data);
}
}
#line 851 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int decode_location_expression(unsigned char *data , unsigned int pointer_size ,
                                      unsigned int offset_size , int dwarf_version ,
                                      dwarf_vma length , dwarf_vma cu_offset , struct dwarf_section *section ) 
{ 
  unsigned int op ;
  unsigned int bytes_read ;
  dwarf_vma uvalue ;
  dwarf_signed_vma svalue ;
  unsigned char *end ;
  int need_frame_base ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___2 ;
  unsigned int amount ;
  char const   *tmp___3 ;
  unsigned int amount___0 ;
  unsigned int amount___1 ;
  elf_vma tmp___4 ;
  unsigned int amount___2 ;
  unsigned int amount___3 ;
  elf_vma tmp___5 ;
  unsigned int amount___4 ;
  unsigned int amount___5 ;
  elf_vma tmp___6 ;
  unsigned int amount___6 ;
  unsigned int amount___7 ;
  unsigned int amount___8 ;
  elf_vma tmp___7 ;
  unsigned int amount___9 ;
  elf_vma tmp___8 ;
  dwarf_vma tmp___9 ;
  char const   *tmp___10 ;
  dwarf_signed_vma tmp___11 ;
  char const   *tmp___12 ;
  unsigned int amount___10 ;
  dwarf_vma tmp___13 ;
  char const   *tmp___14 ;
  unsigned int amount___11 ;
  elf_vma tmp___15 ;
  unsigned int amount___12 ;
  elf_vma tmp___16 ;
  char const   *tmp___17 ;
  dwarf_signed_vma tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  dwarf_signed_vma tmp___23 ;
  char const   *tmp___24 ;
  dwarf_signed_vma tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  dwarf_vma tmp___29 ;
  char const   *tmp___30 ;
  unsigned int amount___13 ;
  unsigned int amount___14 ;
  unsigned int amount___15 ;
  elf_vma tmp___31 ;
  char const   *tmp___32 ;
  unsigned int amount___16 ;
  elf_vma tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *dummy___8  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___8 ;
  void *tmp___37 ;
  unsigned int amount___17 ;
  int tmp___38 ;
  int *dummy___9  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___9 ;
  void *tmp___39 ;
  unsigned int amount___18 ;
  char const   *tmp___40 ;
  dwarf_vma tmp___41 ;
  char const   *tmp___42 ;
  char *tmp___43 ;
  dwarf_vma tmp___44 ;
  char const   *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  int encoding ;
  dwarf_vma addr ;
  unsigned char *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int *dummy___10  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___10 ;
  void *tmp___52 ;
  unsigned int amount___19 ;
  int tmp___53 ;
  int *dummy___11  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___11 ;
  void *tmp___54 ;
  unsigned int amount___20 ;
  dwarf_signed_vma tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  int tmp___58 ;
  char const   *tmp___59 ;
  unsigned int amount___21 ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  unsigned int amount___22 ;
  char const   *tmp___63 ;
  dwarf_vma tmp___64 ;
  char const   *tmp___65 ;
  dwarf_vma tmp___66 ;
  char const   *tmp___67 ;
  unsigned int amount___23 ;
  char const   *tmp___68 ;
  char const   *tmp___69 ;
  char const   *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;

  {
#line 864
  end = data + length;
#line 865
  need_frame_base = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 867
      goto while_break;
    }
#line 869
    tmp___0 = data;
#line 869
    data ++;
#line 869
    op = (unsigned int )*tmp___0;
    {
#line 873
    if (op == 3U) {
#line 873
      goto case_3;
    }
#line 877
    if (op == 6U) {
#line 877
      goto case_6;
    }
#line 880
    if (op == 8U) {
#line 880
      goto case_8;
    }
#line 884
    if (op == 9U) {
#line 884
      goto case_9;
    }
#line 888
    if (op == 10U) {
#line 888
      goto case_10;
    }
#line 892
    if (op == 11U) {
#line 892
      goto case_11;
    }
#line 896
    if (op == 12U) {
#line 896
      goto case_12;
    }
#line 900
    if (op == 13U) {
#line 900
      goto case_13;
    }
#line 904
    if (op == 14U) {
#line 904
      goto case_14;
    }
#line 910
    if (op == 15U) {
#line 910
      goto case_15;
    }
#line 916
    if (op == 16U) {
#line 916
      goto case_16;
    }
#line 921
    if (op == 17U) {
#line 921
      goto case_17;
    }
#line 926
    if (op == 18U) {
#line 926
      goto case_18;
    }
#line 929
    if (op == 19U) {
#line 929
      goto case_19;
    }
#line 932
    if (op == 20U) {
#line 932
      goto case_20;
    }
#line 935
    if (op == 21U) {
#line 935
      goto case_21;
    }
#line 939
    if (op == 22U) {
#line 939
      goto case_22;
    }
#line 942
    if (op == 23U) {
#line 942
      goto case_23;
    }
#line 945
    if (op == 24U) {
#line 945
      goto case_24;
    }
#line 948
    if (op == 25U) {
#line 948
      goto case_25;
    }
#line 951
    if (op == 26U) {
#line 951
      goto case_26;
    }
#line 954
    if (op == 27U) {
#line 954
      goto case_27;
    }
#line 957
    if (op == 28U) {
#line 957
      goto case_28;
    }
#line 960
    if (op == 29U) {
#line 960
      goto case_29;
    }
#line 963
    if (op == 30U) {
#line 963
      goto case_30;
    }
#line 966
    if (op == 31U) {
#line 966
      goto case_31;
    }
#line 969
    if (op == 32U) {
#line 969
      goto case_32;
    }
#line 972
    if (op == 33U) {
#line 972
      goto case_33;
    }
#line 975
    if (op == 34U) {
#line 975
      goto case_34;
    }
#line 978
    if (op == 35U) {
#line 978
      goto case_35;
    }
#line 983
    if (op == 36U) {
#line 983
      goto case_36;
    }
#line 986
    if (op == 37U) {
#line 986
      goto case_37;
    }
#line 989
    if (op == 38U) {
#line 989
      goto case_38;
    }
#line 992
    if (op == 39U) {
#line 992
      goto case_39;
    }
#line 995
    if (op == 40U) {
#line 995
      goto case_40;
    }
#line 999
    if (op == 41U) {
#line 999
      goto case_41;
    }
#line 1002
    if (op == 42U) {
#line 1002
      goto case_42;
    }
#line 1005
    if (op == 43U) {
#line 1005
      goto case_43;
    }
#line 1008
    if (op == 44U) {
#line 1008
      goto case_44;
    }
#line 1011
    if (op == 45U) {
#line 1011
      goto case_45;
    }
#line 1014
    if (op == 46U) {
#line 1014
      goto case_46;
    }
#line 1017
    if (op == 47U) {
#line 1017
      goto case_47;
    }
#line 1053
    if (op == 79U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 78U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 77U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 76U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 75U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 74U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 73U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 72U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 71U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 70U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 69U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 68U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 67U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 66U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 65U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 64U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 63U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 62U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 61U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 60U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 59U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 58U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 57U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 56U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 55U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 54U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 53U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 52U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 51U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 50U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 49U) {
#line 1053
      goto case_79;
    }
#line 1053
    if (op == 48U) {
#line 1053
      goto case_79;
    }
#line 1088
    if (op == 111U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 110U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 109U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 108U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 107U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 106U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 105U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 104U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 103U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 102U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 101U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 100U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 99U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 98U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 97U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 96U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 95U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 94U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 93U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 92U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 91U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 90U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 89U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 88U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 87U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 86U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 85U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 84U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 83U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 82U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 81U) {
#line 1088
      goto case_111;
    }
#line 1088
    if (op == 80U) {
#line 1088
      goto case_111;
    }
#line 1124
    if (op == 143U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 142U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 141U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 140U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 139U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 138U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 137U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 136U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 135U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 134U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 133U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 132U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 131U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 130U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 129U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 128U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 127U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 126U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 125U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 124U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 123U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 122U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 121U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 120U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 119U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 118U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 117U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 116U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 115U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 114U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 113U) {
#line 1124
      goto case_143;
    }
#line 1124
    if (op == 112U) {
#line 1124
      goto case_143;
    }
#line 1132
    if (op == 144U) {
#line 1132
      goto case_144;
    }
#line 1138
    if (op == 145U) {
#line 1138
      goto case_145;
    }
#line 1144
    if (op == 146U) {
#line 1144
      goto case_146;
    }
#line 1152
    if (op == 147U) {
#line 1152
      goto case_147;
    }
#line 1157
    if (op == 148U) {
#line 1157
      goto case_148;
    }
#line 1161
    if (op == 149U) {
#line 1161
      goto case_149;
    }
#line 1165
    if (op == 150U) {
#line 1165
      goto case_150;
    }
#line 1170
    if (op == 151U) {
#line 1170
      goto case_151;
    }
#line 1173
    if (op == 152U) {
#line 1173
      goto case_152;
    }
#line 1180
    if (op == 153U) {
#line 1180
      goto case_153;
    }
#line 1187
    if (op == 154U) {
#line 1187
      goto case_154;
    }
#line 1206
    if (op == 155U) {
#line 1206
      goto case_155;
    }
#line 1209
    if (op == 156U) {
#line 1209
      goto case_156;
    }
#line 1212
    if (op == 157U) {
#line 1212
      goto case_157;
    }
#line 1223
    if (op == 159U) {
#line 1223
      goto case_159;
    }
#line 1227
    if (op == 158U) {
#line 1227
      goto case_158;
    }
#line 1236
    if (op == 224U) {
#line 1236
      goto case_224;
    }
#line 1239
    if (op == 240U) {
#line 1239
      goto case_240;
    }
#line 1243
    if (op == 241U) {
#line 1243
      goto case_241;
    }
#line 1256
    if (op == 242U) {
#line 1256
      goto case_242;
    }
#line 1279
    if (op == 243U) {
#line 1279
      goto case_243;
    }
#line 1290
    if (op == 244U) {
#line 1290
      goto case_244;
    }
#line 1299
    if (op == 245U) {
#line 1299
      goto case_245;
    }
#line 1308
    if (op == 246U) {
#line 1308
      goto case_246;
    }
#line 1315
    if (op == 247U) {
#line 1315
      goto case_247;
    }
#line 1321
    if (op == 249U) {
#line 1321
      goto case_249;
    }
#line 1327
    if (op == 250U) {
#line 1327
      goto case_250;
    }
#line 1332
    if (op == 251U) {
#line 1332
      goto case_251;
    }
#line 1337
    if (op == 252U) {
#line 1337
      goto case_252;
    }
#line 1344
    if (op == 225U) {
#line 1344
      goto case_225;
    }
#line 1348
    if (op == 226U) {
#line 1348
      goto case_226;
    }
#line 1352
    if (op == 227U) {
#line 1352
      goto case_227;
    }
#line 1356
    if (op == 228U) {
#line 1356
      goto case_228;
    }
#line 1360
    if (op == 229U) {
#line 1360
      goto case_229;
    }
#line 1364
    if (op == 230U) {
#line 1364
      goto case_230;
    }
#line 1370
    if (op == 248U) {
#line 1370
      goto case_248;
    }
#line 1378
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 874
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 874
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 874
        if (8UL < (unsigned long )pointer_size) {
#line 874
          tmp___1 = -1;
        } else {
#line 874
          tmp___1 = 1;
        }
        {
#line 874
        __lengthofdummy = (unsigned long )tmp___1;
#line 874
        tmp___2 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 874
        dummy = (int *)tmp___2;
#line 874
        amount = pointer_size;
        }
#line 874
        if ((unsigned long )(data + amount) >= (unsigned long )end) {
#line 874
          if ((unsigned long )data < (unsigned long )end) {
#line 874
            amount = (unsigned int )(end - data);
          } else {
#line 874
            amount = 0U;
          }
        }
#line 874
        if (amount) {
          {
#line 874
          uvalue = (*byte_get)(data, (int )amount);
          }
        } else {
#line 874
          uvalue = (dwarf_vma )0;
        }
#line 874
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 874
      data += pointer_size;
#line 874
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 875
    tmp___3 = dwarf_vmatoa("x", uvalue);
#line 875
    printf((char const   */* __restrict  */)"DW_OP_addr: %s", tmp___3);
    }
#line 876
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 878
    printf((char const   */* __restrict  */)"DW_OP_deref");
    }
#line 879
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 881
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 881
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 881
        amount___0 = 1U;
#line 881
        if ((unsigned long )(data + amount___0) >= (unsigned long )end) {
#line 881
          if ((unsigned long )data < (unsigned long )end) {
#line 881
            amount___0 = (unsigned int )(end - data);
          } else {
#line 881
            amount___0 = 0U;
          }
        }
#line 881
        if (amount___0) {
          {
#line 881
          uvalue = (*byte_get)(data, (int )amount___0);
          }
        } else {
#line 881
          uvalue = (dwarf_vma )0;
        }
#line 881
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 881
      data ++;
#line 881
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 882
    printf((char const   */* __restrict  */)"DW_OP_const1u: %lu", (unsigned long )uvalue);
    }
#line 883
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 885
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 885
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 885
        amount___1 = 1U;
#line 885
        if ((unsigned long )(data + amount___1) >= (unsigned long )end) {
#line 885
          if ((unsigned long )data < (unsigned long )end) {
#line 885
            amount___1 = (unsigned int )(end - data);
          } else {
#line 885
            amount___1 = 0U;
          }
        }
#line 885
        if (amount___1) {
          {
#line 885
          tmp___4 = byte_get_signed(data, (int )amount___1);
#line 885
          svalue = (dwarf_signed_vma )tmp___4;
          }
        } else {
#line 885
          svalue = (dwarf_signed_vma )0;
        }
#line 885
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 885
      data ++;
#line 885
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 886
    printf((char const   */* __restrict  */)"DW_OP_const1s: %ld", (long )svalue);
    }
#line 887
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 889
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 889
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 889
        amount___2 = 2U;
#line 889
        if ((unsigned long )(data + amount___2) >= (unsigned long )end) {
#line 889
          if ((unsigned long )data < (unsigned long )end) {
#line 889
            amount___2 = (unsigned int )(end - data);
          } else {
#line 889
            amount___2 = 0U;
          }
        }
#line 889
        if (amount___2) {
          {
#line 889
          uvalue = (*byte_get)(data, (int )amount___2);
          }
        } else {
#line 889
          uvalue = (dwarf_vma )0;
        }
#line 889
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 889
      data += 2;
#line 889
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 890
    printf((char const   */* __restrict  */)"DW_OP_const2u: %lu", (unsigned long )uvalue);
    }
#line 891
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 893
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 893
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 893
        amount___3 = 2U;
#line 893
        if ((unsigned long )(data + amount___3) >= (unsigned long )end) {
#line 893
          if ((unsigned long )data < (unsigned long )end) {
#line 893
            amount___3 = (unsigned int )(end - data);
          } else {
#line 893
            amount___3 = 0U;
          }
        }
#line 893
        if (amount___3) {
          {
#line 893
          tmp___5 = byte_get_signed(data, (int )amount___3);
#line 893
          svalue = (dwarf_signed_vma )tmp___5;
          }
        } else {
#line 893
          svalue = (dwarf_signed_vma )0;
        }
#line 893
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 893
      data += 2;
#line 893
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 894
    printf((char const   */* __restrict  */)"DW_OP_const2s: %ld", (long )svalue);
    }
#line 895
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 897
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 897
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 897
        amount___4 = 4U;
#line 897
        if ((unsigned long )(data + amount___4) >= (unsigned long )end) {
#line 897
          if ((unsigned long )data < (unsigned long )end) {
#line 897
            amount___4 = (unsigned int )(end - data);
          } else {
#line 897
            amount___4 = 0U;
          }
        }
#line 897
        if (amount___4) {
          {
#line 897
          uvalue = (*byte_get)(data, (int )amount___4);
          }
        } else {
#line 897
          uvalue = (dwarf_vma )0;
        }
#line 897
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 897
      data += 4;
#line 897
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 898
    printf((char const   */* __restrict  */)"DW_OP_const4u: %lu", (unsigned long )uvalue);
    }
#line 899
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 901
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 901
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 901
        amount___5 = 4U;
#line 901
        if ((unsigned long )(data + amount___5) >= (unsigned long )end) {
#line 901
          if ((unsigned long )data < (unsigned long )end) {
#line 901
            amount___5 = (unsigned int )(end - data);
          } else {
#line 901
            amount___5 = 0U;
          }
        }
#line 901
        if (amount___5) {
          {
#line 901
          tmp___6 = byte_get_signed(data, (int )amount___5);
#line 901
          svalue = (dwarf_signed_vma )tmp___6;
          }
        } else {
#line 901
          svalue = (dwarf_signed_vma )0;
        }
#line 901
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 901
      data += 4;
#line 901
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 902
    printf((char const   */* __restrict  */)"DW_OP_const4s: %ld", (long )svalue);
    }
#line 903
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 905
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 905
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 905
        amount___6 = 4U;
#line 905
        if ((unsigned long )(data + amount___6) >= (unsigned long )end) {
#line 905
          if ((unsigned long )data < (unsigned long )end) {
#line 905
            amount___6 = (unsigned int )(end - data);
          } else {
#line 905
            amount___6 = 0U;
          }
        }
#line 905
        if (amount___6) {
          {
#line 905
          uvalue = (*byte_get)(data, (int )amount___6);
          }
        } else {
#line 905
          uvalue = (dwarf_vma )0;
        }
#line 905
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 905
      data += 4;
#line 905
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 906
    printf((char const   */* __restrict  */)"DW_OP_const8u: %lu ", (unsigned long )uvalue);
    }
    {
#line 907
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 907
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 907
        amount___7 = 4U;
#line 907
        if ((unsigned long )(data + amount___7) >= (unsigned long )end) {
#line 907
          if ((unsigned long )data < (unsigned long )end) {
#line 907
            amount___7 = (unsigned int )(end - data);
          } else {
#line 907
            amount___7 = 0U;
          }
        }
#line 907
        if (amount___7) {
          {
#line 907
          uvalue = (*byte_get)(data, (int )amount___7);
          }
        } else {
#line 907
          uvalue = (dwarf_vma )0;
        }
#line 907
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 907
      data += 4;
#line 907
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 908
    printf((char const   */* __restrict  */)"%lu", (unsigned long )uvalue);
    }
#line 909
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 911
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 911
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 911
        amount___8 = 4U;
#line 911
        if ((unsigned long )(data + amount___8) >= (unsigned long )end) {
#line 911
          if ((unsigned long )data < (unsigned long )end) {
#line 911
            amount___8 = (unsigned int )(end - data);
          } else {
#line 911
            amount___8 = 0U;
          }
        }
#line 911
        if (amount___8) {
          {
#line 911
          tmp___7 = byte_get_signed(data, (int )amount___8);
#line 911
          svalue = (dwarf_signed_vma )tmp___7;
          }
        } else {
#line 911
          svalue = (dwarf_signed_vma )0;
        }
#line 911
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 911
      data += 4;
#line 911
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 912
    printf((char const   */* __restrict  */)"DW_OP_const8s: %ld ", (long )svalue);
    }
    {
#line 913
    while (1) {
      while_continue___20: /* CIL Label */ ;
      {
#line 913
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 913
        amount___9 = 4U;
#line 913
        if ((unsigned long )(data + amount___9) >= (unsigned long )end) {
#line 913
          if ((unsigned long )data < (unsigned long )end) {
#line 913
            amount___9 = (unsigned int )(end - data);
          } else {
#line 913
            amount___9 = 0U;
          }
        }
#line 913
        if (amount___9) {
          {
#line 913
          tmp___8 = byte_get_signed(data, (int )amount___9);
#line 913
          svalue = (dwarf_signed_vma )tmp___8;
          }
        } else {
#line 913
          svalue = (dwarf_signed_vma )0;
        }
#line 913
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 913
      data += 4;
#line 913
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 914
    printf((char const   */* __restrict  */)"%ld", (long )svalue);
    }
#line 915
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 917
    tmp___9 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 917
    tmp___10 = dwarf_vmatoa("u", tmp___9);
#line 917
    printf((char const   */* __restrict  */)"DW_OP_constu: %s", tmp___10);
#line 919
    data += bytes_read;
    }
#line 920
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 922
    tmp___11 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 922
    tmp___12 = dwarf_vmatoa("d", (dwarf_vma )tmp___11);
#line 922
    printf((char const   */* __restrict  */)"DW_OP_consts: %s", tmp___12);
#line 924
    data += bytes_read;
    }
#line 925
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 927
    printf((char const   */* __restrict  */)"DW_OP_dup");
    }
#line 928
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 930
    printf((char const   */* __restrict  */)"DW_OP_drop");
    }
#line 931
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 933
    printf((char const   */* __restrict  */)"DW_OP_over");
    }
#line 934
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 936
    while (1) {
      while_continue___22: /* CIL Label */ ;
      {
#line 936
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 936
        amount___10 = 1U;
#line 936
        if ((unsigned long )(data + amount___10) >= (unsigned long )end) {
#line 936
          if ((unsigned long )data < (unsigned long )end) {
#line 936
            amount___10 = (unsigned int )(end - data);
          } else {
#line 936
            amount___10 = 0U;
          }
        }
#line 936
        if (amount___10) {
          {
#line 936
          uvalue = (*byte_get)(data, (int )amount___10);
          }
        } else {
#line 936
          uvalue = (dwarf_vma )0;
        }
#line 936
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 936
      data ++;
#line 936
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 937
    printf((char const   */* __restrict  */)"DW_OP_pick: %ld", (unsigned long )uvalue);
    }
#line 938
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 940
    printf((char const   */* __restrict  */)"DW_OP_swap");
    }
#line 941
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 943
    printf((char const   */* __restrict  */)"DW_OP_rot");
    }
#line 944
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 946
    printf((char const   */* __restrict  */)"DW_OP_xderef");
    }
#line 947
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 949
    printf((char const   */* __restrict  */)"DW_OP_abs");
    }
#line 950
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 952
    printf((char const   */* __restrict  */)"DW_OP_and");
    }
#line 953
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 955
    printf((char const   */* __restrict  */)"DW_OP_div");
    }
#line 956
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 958
    printf((char const   */* __restrict  */)"DW_OP_minus");
    }
#line 959
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 961
    printf((char const   */* __restrict  */)"DW_OP_mod");
    }
#line 962
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 964
    printf((char const   */* __restrict  */)"DW_OP_mul");
    }
#line 965
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 967
    printf((char const   */* __restrict  */)"DW_OP_neg");
    }
#line 968
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 970
    printf((char const   */* __restrict  */)"DW_OP_not");
    }
#line 971
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 973
    printf((char const   */* __restrict  */)"DW_OP_or");
    }
#line 974
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 976
    printf((char const   */* __restrict  */)"DW_OP_plus");
    }
#line 977
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 979
    tmp___13 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 979
    tmp___14 = dwarf_vmatoa("u", tmp___13);
#line 979
    printf((char const   */* __restrict  */)"DW_OP_plus_uconst: %s", tmp___14);
#line 981
    data += bytes_read;
    }
#line 982
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 984
    printf((char const   */* __restrict  */)"DW_OP_shl");
    }
#line 985
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 987
    printf((char const   */* __restrict  */)"DW_OP_shr");
    }
#line 988
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 990
    printf((char const   */* __restrict  */)"DW_OP_shra");
    }
#line 991
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 993
    printf((char const   */* __restrict  */)"DW_OP_xor");
    }
#line 994
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 996
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 996
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 996
        amount___11 = 2U;
#line 996
        if ((unsigned long )(data + amount___11) >= (unsigned long )end) {
#line 996
          if ((unsigned long )data < (unsigned long )end) {
#line 996
            amount___11 = (unsigned int )(end - data);
          } else {
#line 996
            amount___11 = 0U;
          }
        }
#line 996
        if (amount___11) {
          {
#line 996
          tmp___15 = byte_get_signed(data, (int )amount___11);
#line 996
          svalue = (dwarf_signed_vma )tmp___15;
          }
        } else {
#line 996
          svalue = (dwarf_signed_vma )0;
        }
#line 996
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 996
      data += 2;
#line 996
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 997
    printf((char const   */* __restrict  */)"DW_OP_bra: %ld", (long )svalue);
    }
#line 998
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 1000
    printf((char const   */* __restrict  */)"DW_OP_eq");
    }
#line 1001
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 1003
    printf((char const   */* __restrict  */)"DW_OP_ge");
    }
#line 1004
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 1006
    printf((char const   */* __restrict  */)"DW_OP_gt");
    }
#line 1007
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 1009
    printf((char const   */* __restrict  */)"DW_OP_le");
    }
#line 1010
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 1012
    printf((char const   */* __restrict  */)"DW_OP_lt");
    }
#line 1013
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 1015
    printf((char const   */* __restrict  */)"DW_OP_ne");
    }
#line 1016
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 1018
    while (1) {
      while_continue___26: /* CIL Label */ ;
      {
#line 1018
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 1018
        amount___12 = 2U;
#line 1018
        if ((unsigned long )(data + amount___12) >= (unsigned long )end) {
#line 1018
          if ((unsigned long )data < (unsigned long )end) {
#line 1018
            amount___12 = (unsigned int )(end - data);
          } else {
#line 1018
            amount___12 = 0U;
          }
        }
#line 1018
        if (amount___12) {
          {
#line 1018
          tmp___16 = byte_get_signed(data, (int )amount___12);
#line 1018
          svalue = (dwarf_signed_vma )tmp___16;
          }
        } else {
#line 1018
          svalue = (dwarf_signed_vma )0;
        }
#line 1018
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 1018
      data += 2;
#line 1018
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 1019
    printf((char const   */* __restrict  */)"DW_OP_skip: %ld", (long )svalue);
    }
#line 1020
    goto switch_break;
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 1054
    printf((char const   */* __restrict  */)"DW_OP_lit%d", op - 48U);
    }
#line 1055
    goto switch_break;
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    {
#line 1089
    tmp___17 = regname(op - 80U, 1);
#line 1089
    printf((char const   */* __restrict  */)"DW_OP_reg%d (%s)", op - 80U, tmp___17);
    }
#line 1091
    goto switch_break;
    case_143: /* CIL Label */ 
    case_142: /* CIL Label */ 
    case_141: /* CIL Label */ 
    case_140: /* CIL Label */ 
    case_139: /* CIL Label */ 
    case_138: /* CIL Label */ 
    case_137: /* CIL Label */ 
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    case_132: /* CIL Label */ 
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
    case_129: /* CIL Label */ 
    case_128: /* CIL Label */ 
    case_127: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    {
#line 1125
    tmp___18 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1125
    tmp___19 = dwarf_vmatoa("d", (dwarf_vma )tmp___18);
#line 1125
    tmp___20 = regname(op - 112U, 1);
#line 1125
    printf((char const   */* __restrict  */)"DW_OP_breg%d (%s): %s", op - 112U, tmp___20,
           tmp___19);
#line 1129
    data += bytes_read;
    }
#line 1130
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 1133
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1134
    data += bytes_read;
#line 1135
    tmp___21 = regname((unsigned int )uvalue, 1);
#line 1135
    tmp___22 = dwarf_vmatoa("u", uvalue);
#line 1135
    printf((char const   */* __restrict  */)"DW_OP_regx: %s (%s)", tmp___22, tmp___21);
    }
#line 1137
    goto switch_break;
    case_145: /* CIL Label */ 
    {
#line 1139
    need_frame_base = 1;
#line 1140
    tmp___23 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1140
    tmp___24 = dwarf_vmatoa("d", (dwarf_vma )tmp___23);
#line 1140
    printf((char const   */* __restrict  */)"DW_OP_fbreg: %s", tmp___24);
#line 1142
    data += bytes_read;
    }
#line 1143
    goto switch_break;
    case_146: /* CIL Label */ 
    {
#line 1145
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1146
    data += bytes_read;
#line 1147
    tmp___25 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1147
    tmp___26 = dwarf_vmatoa("d", (dwarf_vma )tmp___25);
#line 1147
    tmp___27 = regname((unsigned int )uvalue, 1);
#line 1147
    tmp___28 = dwarf_vmatoa("u", uvalue);
#line 1147
    printf((char const   */* __restrict  */)"DW_OP_bregx: %s (%s) %s", tmp___28, tmp___27,
           tmp___26);
#line 1150
    data += bytes_read;
    }
#line 1151
    goto switch_break;
    case_147: /* CIL Label */ 
    {
#line 1153
    tmp___29 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1153
    tmp___30 = dwarf_vmatoa("u", tmp___29);
#line 1153
    printf((char const   */* __restrict  */)"DW_OP_piece: %s", tmp___30);
#line 1155
    data += bytes_read;
    }
#line 1156
    goto switch_break;
    case_148: /* CIL Label */ 
    {
#line 1158
    while (1) {
      while_continue___28: /* CIL Label */ ;
      {
#line 1158
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 1158
        amount___13 = 1U;
#line 1158
        if ((unsigned long )(data + amount___13) >= (unsigned long )end) {
#line 1158
          if ((unsigned long )data < (unsigned long )end) {
#line 1158
            amount___13 = (unsigned int )(end - data);
          } else {
#line 1158
            amount___13 = 0U;
          }
        }
#line 1158
        if (amount___13) {
          {
#line 1158
          uvalue = (*byte_get)(data, (int )amount___13);
          }
        } else {
#line 1158
          uvalue = (dwarf_vma )0;
        }
#line 1158
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 1158
      data ++;
#line 1158
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 1159
    printf((char const   */* __restrict  */)"DW_OP_deref_size: %ld", (long )uvalue);
    }
#line 1160
    goto switch_break;
    case_149: /* CIL Label */ 
    {
#line 1162
    while (1) {
      while_continue___30: /* CIL Label */ ;
      {
#line 1162
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 1162
        amount___14 = 1U;
#line 1162
        if ((unsigned long )(data + amount___14) >= (unsigned long )end) {
#line 1162
          if ((unsigned long )data < (unsigned long )end) {
#line 1162
            amount___14 = (unsigned int )(end - data);
          } else {
#line 1162
            amount___14 = 0U;
          }
        }
#line 1162
        if (amount___14) {
          {
#line 1162
          uvalue = (*byte_get)(data, (int )amount___14);
          }
        } else {
#line 1162
          uvalue = (dwarf_vma )0;
        }
#line 1162
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 1162
      data ++;
#line 1162
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 1163
    printf((char const   */* __restrict  */)"DW_OP_xderef_size: %ld", (long )uvalue);
    }
#line 1164
    goto switch_break;
    case_150: /* CIL Label */ 
    {
#line 1166
    printf((char const   */* __restrict  */)"DW_OP_nop");
    }
#line 1167
    goto switch_break;
    case_151: /* CIL Label */ 
    {
#line 1171
    printf((char const   */* __restrict  */)"DW_OP_push_object_address");
    }
#line 1172
    goto switch_break;
    case_152: /* CIL Label */ 
    {
#line 1176
    while (1) {
      while_continue___32: /* CIL Label */ ;
      {
#line 1176
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 1176
        amount___15 = 2U;
#line 1176
        if ((unsigned long )(data + amount___15) >= (unsigned long )end) {
#line 1176
          if ((unsigned long )data < (unsigned long )end) {
#line 1176
            amount___15 = (unsigned int )(end - data);
          } else {
#line 1176
            amount___15 = 0U;
          }
        }
#line 1176
        if (amount___15) {
          {
#line 1176
          tmp___31 = byte_get_signed(data, (int )amount___15);
#line 1176
          svalue = (dwarf_signed_vma )tmp___31;
          }
        } else {
#line 1176
          svalue = (dwarf_signed_vma )0;
        }
#line 1176
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
#line 1176
      data += 2;
#line 1176
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 1177
    tmp___32 = dwarf_vmatoa("x", (dwarf_vma )svalue + cu_offset);
#line 1177
    printf((char const   */* __restrict  */)"DW_OP_call2: <0x%s>", tmp___32);
    }
#line 1179
    goto switch_break;
    case_153: /* CIL Label */ 
    {
#line 1183
    while (1) {
      while_continue___34: /* CIL Label */ ;
      {
#line 1183
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 1183
        amount___16 = 4U;
#line 1183
        if ((unsigned long )(data + amount___16) >= (unsigned long )end) {
#line 1183
          if ((unsigned long )data < (unsigned long )end) {
#line 1183
            amount___16 = (unsigned int )(end - data);
          } else {
#line 1183
            amount___16 = 0U;
          }
        }
#line 1183
        if (amount___16) {
          {
#line 1183
          tmp___33 = byte_get_signed(data, (int )amount___16);
#line 1183
          svalue = (dwarf_signed_vma )tmp___33;
          }
        } else {
#line 1183
          svalue = (dwarf_signed_vma )0;
        }
#line 1183
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 1183
      data += 4;
#line 1183
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 1184
    tmp___34 = dwarf_vmatoa("x", (dwarf_vma )svalue + cu_offset);
#line 1184
    printf((char const   */* __restrict  */)"DW_OP_call4: <0x%s>", tmp___34);
    }
#line 1186
    goto switch_break;
    case_154: /* CIL Label */ 
#line 1190
    if (dwarf_version == -1) {
      {
#line 1192
      tmp___35 = gettext("(DW_OP_call_ref in frame info)");
#line 1192
      printf((char const   */* __restrict  */)tmp___35);
      }
#line 1194
      return (need_frame_base);
    }
#line 1196
    if (dwarf_version == 2) {
      {
#line 1198
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 1198
        while (1) {
          while_continue___37: /* CIL Label */ ;
#line 1198
          if (8UL < (unsigned long )pointer_size) {
#line 1198
            tmp___36 = -1;
          } else {
#line 1198
            tmp___36 = 1;
          }
          {
#line 1198
          __lengthofdummy___8 = (unsigned long )tmp___36;
#line 1198
          tmp___37 = __builtin_alloca(sizeof(*dummy___8) * __lengthofdummy___8);
#line 1198
          dummy___8 = (int *)tmp___37;
#line 1198
          amount___17 = pointer_size;
          }
#line 1198
          if ((unsigned long )(data + amount___17) >= (unsigned long )end) {
#line 1198
            if ((unsigned long )data < (unsigned long )end) {
#line 1198
              amount___17 = (unsigned int )(end - data);
            } else {
#line 1198
              amount___17 = 0U;
            }
          }
#line 1198
          if (amount___17) {
            {
#line 1198
            uvalue = (*byte_get)(data, (int )amount___17);
            }
          } else {
#line 1198
            uvalue = (dwarf_vma )0;
          }
#line 1198
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
#line 1198
        data += pointer_size;
#line 1198
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
    } else {
      {
#line 1202
      while (1) {
        while_continue___38: /* CIL Label */ ;
        {
#line 1202
        while (1) {
          while_continue___39: /* CIL Label */ ;
#line 1202
          if (8UL < (unsigned long )offset_size) {
#line 1202
            tmp___38 = -1;
          } else {
#line 1202
            tmp___38 = 1;
          }
          {
#line 1202
          __lengthofdummy___9 = (unsigned long )tmp___38;
#line 1202
          tmp___39 = __builtin_alloca(sizeof(*dummy___9) * __lengthofdummy___9);
#line 1202
          dummy___9 = (int *)tmp___39;
#line 1202
          amount___18 = offset_size;
          }
#line 1202
          if ((unsigned long )(data + amount___18) >= (unsigned long )end) {
#line 1202
            if ((unsigned long )data < (unsigned long )end) {
#line 1202
              amount___18 = (unsigned int )(end - data);
            } else {
#line 1202
              amount___18 = 0U;
            }
          }
#line 1202
          if (amount___18) {
            {
#line 1202
            uvalue = (*byte_get)(data, (int )amount___18);
            }
          } else {
#line 1202
            uvalue = (dwarf_vma )0;
          }
#line 1202
          goto while_break___39;
        }
        while_break___39: /* CIL Label */ ;
        }
#line 1202
        data += offset_size;
#line 1202
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
    }
    {
#line 1204
    tmp___40 = dwarf_vmatoa("x", uvalue);
#line 1204
    printf((char const   */* __restrict  */)"DW_OP_call_ref: <0x%s>", tmp___40);
    }
#line 1205
    goto switch_break;
    case_155: /* CIL Label */ 
    {
#line 1207
    printf((char const   */* __restrict  */)"DW_OP_form_tls_address");
    }
#line 1208
    goto switch_break;
    case_156: /* CIL Label */ 
    {
#line 1210
    printf((char const   */* __restrict  */)"DW_OP_call_frame_cfa");
    }
#line 1211
    goto switch_break;
    case_157: /* CIL Label */ 
    {
#line 1213
    printf((char const   */* __restrict  */)"DW_OP_bit_piece: ");
#line 1214
    tmp___41 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1214
    tmp___42 = dwarf_vmatoa("u", tmp___41);
#line 1214
    tmp___43 = gettext("size: %s ");
#line 1214
    printf((char const   */* __restrict  */)tmp___43, tmp___42);
#line 1216
    data += bytes_read;
#line 1217
    tmp___44 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1217
    tmp___45 = dwarf_vmatoa("u", tmp___44);
#line 1217
    tmp___46 = gettext("offset: %s ");
#line 1217
    printf((char const   */* __restrict  */)tmp___46, tmp___45);
#line 1219
    data += bytes_read;
    }
#line 1220
    goto switch_break;
    case_159: /* CIL Label */ 
    {
#line 1224
    printf((char const   */* __restrict  */)"DW_OP_stack_value");
    }
#line 1225
    goto switch_break;
    case_158: /* CIL Label */ 
    {
#line 1228
    printf((char const   */* __restrict  */)"DW_OP_implicit_value");
#line 1229
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1230
    data += bytes_read;
#line 1231
    display_block(data, uvalue, (unsigned char const   */* const  */)end);
#line 1232
    data += uvalue;
    }
#line 1233
    goto switch_break;
    case_224: /* CIL Label */ 
    {
#line 1237
    tmp___47 = gettext("DW_OP_GNU_push_tls_address or DW_OP_HP_unknown");
#line 1237
    printf((char const   */* __restrict  */)tmp___47);
    }
#line 1238
    goto switch_break;
    case_240: /* CIL Label */ 
    {
#line 1240
    printf((char const   */* __restrict  */)"DW_OP_GNU_uninit");
    }
#line 1242
    goto switch_break;
    case_241: /* CIL Label */ 
    {
#line 1248
    tmp___48 = data;
#line 1248
    data ++;
#line 1248
    encoding = (int )*tmp___48;
#line 1249
    addr = get_encoded_value(data, encoding, section);
#line 1250
    tmp___49 = size_of_encoded_value(encoding);
#line 1250
    data += tmp___49;
#line 1252
    printf((char const   */* __restrict  */)"DW_OP_GNU_encoded_addr: fmt:%02x addr:",
           encoding);
#line 1253
    print_dwarf_vma(addr, pointer_size);
    }
#line 1255
    goto switch_break;
    case_242: /* CIL Label */ 
#line 1259
    if (dwarf_version == -1) {
      {
#line 1261
      tmp___50 = gettext("(DW_OP_GNU_implicit_pointer in frame info)");
#line 1261
      printf((char const   */* __restrict  */)tmp___50);
      }
#line 1263
      return (need_frame_base);
    }
#line 1265
    if (dwarf_version == 2) {
      {
#line 1267
      while (1) {
        while_continue___40: /* CIL Label */ ;
        {
#line 1267
        while (1) {
          while_continue___41: /* CIL Label */ ;
#line 1267
          if (8UL < (unsigned long )pointer_size) {
#line 1267
            tmp___51 = -1;
          } else {
#line 1267
            tmp___51 = 1;
          }
          {
#line 1267
          __lengthofdummy___10 = (unsigned long )tmp___51;
#line 1267
          tmp___52 = __builtin_alloca(sizeof(*dummy___10) * __lengthofdummy___10);
#line 1267
          dummy___10 = (int *)tmp___52;
#line 1267
          amount___19 = pointer_size;
          }
#line 1267
          if ((unsigned long )(data + amount___19) >= (unsigned long )end) {
#line 1267
            if ((unsigned long )data < (unsigned long )end) {
#line 1267
              amount___19 = (unsigned int )(end - data);
            } else {
#line 1267
              amount___19 = 0U;
            }
          }
#line 1267
          if (amount___19) {
            {
#line 1267
            uvalue = (*byte_get)(data, (int )amount___19);
            }
          } else {
#line 1267
            uvalue = (dwarf_vma )0;
          }
#line 1267
          goto while_break___41;
        }
        while_break___41: /* CIL Label */ ;
        }
#line 1267
        data += pointer_size;
#line 1267
        goto while_break___40;
      }
      while_break___40: /* CIL Label */ ;
      }
    } else {
      {
#line 1271
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
#line 1271
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 1271
          if (8UL < (unsigned long )offset_size) {
#line 1271
            tmp___53 = -1;
          } else {
#line 1271
            tmp___53 = 1;
          }
          {
#line 1271
          __lengthofdummy___11 = (unsigned long )tmp___53;
#line 1271
          tmp___54 = __builtin_alloca(sizeof(*dummy___11) * __lengthofdummy___11);
#line 1271
          dummy___11 = (int *)tmp___54;
#line 1271
          amount___20 = offset_size;
          }
#line 1271
          if ((unsigned long )(data + amount___20) >= (unsigned long )end) {
#line 1271
            if ((unsigned long )data < (unsigned long )end) {
#line 1271
              amount___20 = (unsigned int )(end - data);
            } else {
#line 1271
              amount___20 = 0U;
            }
          }
#line 1271
          if (amount___20) {
            {
#line 1271
            uvalue = (*byte_get)(data, (int )amount___20);
            }
          } else {
#line 1271
            uvalue = (dwarf_vma )0;
          }
#line 1271
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
#line 1271
        data += offset_size;
#line 1271
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
    }
    {
#line 1273
    tmp___55 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1273
    tmp___56 = dwarf_vmatoa("d", (dwarf_vma )tmp___55);
#line 1273
    tmp___57 = dwarf_vmatoa("x", uvalue);
#line 1273
    printf((char const   */* __restrict  */)"DW_OP_GNU_implicit_pointer: <0x%s> %s",
           tmp___57, tmp___56);
#line 1277
    data += bytes_read;
    }
#line 1278
    goto switch_break;
    case_243: /* CIL Label */ 
    {
#line 1280
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1281
    data += bytes_read;
#line 1282
    printf((char const   */* __restrict  */)"DW_OP_GNU_entry_value: (");
#line 1283
    tmp___58 = decode_location_expression(data, pointer_size, offset_size, dwarf_version,
                                          uvalue, cu_offset, section);
    }
#line 1283
    if (tmp___58) {
#line 1286
      need_frame_base = 1;
    }
    {
#line 1287
    putchar(')');
#line 1288
    data += uvalue;
    }
#line 1289
    goto switch_break;
    case_244: /* CIL Label */ 
    {
#line 1291
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1292
    data += bytes_read;
#line 1293
    tmp___59 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1293
    printf((char const   */* __restrict  */)"DW_OP_GNU_const_type: <0x%s> ", tmp___59);
    }
    {
#line 1295
    while (1) {
      while_continue___44: /* CIL Label */ ;
      {
#line 1295
      while (1) {
        while_continue___45: /* CIL Label */ ;
#line 1295
        amount___21 = 1U;
#line 1295
        if ((unsigned long )(data + amount___21) >= (unsigned long )end) {
#line 1295
          if ((unsigned long )data < (unsigned long )end) {
#line 1295
            amount___21 = (unsigned int )(end - data);
          } else {
#line 1295
            amount___21 = 0U;
          }
        }
#line 1295
        if (amount___21) {
          {
#line 1295
          uvalue = (*byte_get)(data, (int )amount___21);
          }
        } else {
#line 1295
          uvalue = (dwarf_vma )0;
        }
#line 1295
        goto while_break___45;
      }
      while_break___45: /* CIL Label */ ;
      }
#line 1295
      data ++;
#line 1295
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 1296
    display_block(data, uvalue, (unsigned char const   */* const  */)end);
#line 1297
    data += uvalue;
    }
#line 1298
    goto switch_break;
    case_245: /* CIL Label */ 
    {
#line 1300
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1301
    data += bytes_read;
#line 1302
    tmp___60 = regname((unsigned int )uvalue, 1);
#line 1302
    tmp___61 = dwarf_vmatoa("u", uvalue);
#line 1302
    printf((char const   */* __restrict  */)"DW_OP_GNU_regval_type: %s (%s)", tmp___61,
           tmp___60);
#line 1304
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1305
    data += bytes_read;
#line 1306
    tmp___62 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1306
    printf((char const   */* __restrict  */)" <0x%s>", tmp___62);
    }
#line 1307
    goto switch_break;
    case_246: /* CIL Label */ 
    {
#line 1309
    while (1) {
      while_continue___46: /* CIL Label */ ;
      {
#line 1309
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 1309
        amount___22 = 1U;
#line 1309
        if ((unsigned long )(data + amount___22) >= (unsigned long )end) {
#line 1309
          if ((unsigned long )data < (unsigned long )end) {
#line 1309
            amount___22 = (unsigned int )(end - data);
          } else {
#line 1309
            amount___22 = 0U;
          }
        }
#line 1309
        if (amount___22) {
          {
#line 1309
          uvalue = (*byte_get)(data, (int )amount___22);
          }
        } else {
#line 1309
          uvalue = (dwarf_vma )0;
        }
#line 1309
        goto while_break___47;
      }
      while_break___47: /* CIL Label */ ;
      }
#line 1309
      data ++;
#line 1309
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 1310
    printf((char const   */* __restrict  */)"DW_OP_GNU_deref_type: %ld", (long )uvalue);
#line 1311
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1312
    data += bytes_read;
#line 1313
    tmp___63 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1313
    printf((char const   */* __restrict  */)" <0x%s>", tmp___63);
    }
#line 1314
    goto switch_break;
    case_247: /* CIL Label */ 
    {
#line 1316
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1317
    data += bytes_read;
    }
#line 1318
    if (uvalue) {
#line 1318
      tmp___64 = cu_offset + uvalue;
    } else {
#line 1318
      tmp___64 = (dwarf_vma )0;
    }
    {
#line 1318
    tmp___65 = dwarf_vmatoa("x", tmp___64);
#line 1318
    printf((char const   */* __restrict  */)"DW_OP_GNU_convert <0x%s>", tmp___65);
    }
#line 1320
    goto switch_break;
    case_249: /* CIL Label */ 
    {
#line 1322
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1323
    data += bytes_read;
    }
#line 1324
    if (uvalue) {
#line 1324
      tmp___66 = cu_offset + uvalue;
    } else {
#line 1324
      tmp___66 = (dwarf_vma )0;
    }
    {
#line 1324
    tmp___67 = dwarf_vmatoa("x", tmp___66);
#line 1324
    printf((char const   */* __restrict  */)"DW_OP_GNU_reinterpret <0x%s>", tmp___67);
    }
#line 1326
    goto switch_break;
    case_250: /* CIL Label */ 
    {
#line 1328
    while (1) {
      while_continue___48: /* CIL Label */ ;
      {
#line 1328
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 1328
        amount___23 = 4U;
#line 1328
        if ((unsigned long )(data + amount___23) >= (unsigned long )end) {
#line 1328
          if ((unsigned long )data < (unsigned long )end) {
#line 1328
            amount___23 = (unsigned int )(end - data);
          } else {
#line 1328
            amount___23 = 0U;
          }
        }
#line 1328
        if (amount___23) {
          {
#line 1328
          uvalue = (*byte_get)(data, (int )amount___23);
          }
        } else {
#line 1328
          uvalue = (dwarf_vma )0;
        }
#line 1328
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 1328
      data += 4;
#line 1328
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 1329
    tmp___68 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1329
    printf((char const   */* __restrict  */)"DW_OP_GNU_parameter_ref: <0x%s>", tmp___68);
    }
#line 1331
    goto switch_break;
    case_251: /* CIL Label */ 
    {
#line 1333
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1334
    data += bytes_read;
#line 1335
    tmp___69 = dwarf_vmatoa("x", uvalue);
#line 1335
    printf((char const   */* __restrict  */)"DW_OP_GNU_addr_index <0x%s>", tmp___69);
    }
#line 1336
    goto switch_break;
    case_252: /* CIL Label */ 
    {
#line 1338
    uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1339
    data += bytes_read;
#line 1340
    tmp___70 = dwarf_vmatoa("x", uvalue);
#line 1340
    printf((char const   */* __restrict  */)"DW_OP_GNU_const_index <0x%s>", tmp___70);
    }
#line 1341
    goto switch_break;
    case_225: /* CIL Label */ 
    {
#line 1345
    printf((char const   */* __restrict  */)"DW_OP_HP_is_value");
    }
#line 1347
    goto switch_break;
    case_226: /* CIL Label */ 
    {
#line 1349
    printf((char const   */* __restrict  */)"DW_OP_HP_fltconst4");
    }
#line 1351
    goto switch_break;
    case_227: /* CIL Label */ 
    {
#line 1353
    printf((char const   */* __restrict  */)"DW_OP_HP_fltconst8");
    }
#line 1355
    goto switch_break;
    case_228: /* CIL Label */ 
    {
#line 1357
    printf((char const   */* __restrict  */)"DW_OP_HP_mod_range");
    }
#line 1359
    goto switch_break;
    case_229: /* CIL Label */ 
    {
#line 1361
    printf((char const   */* __restrict  */)"DW_OP_HP_unmod_range");
    }
#line 1363
    goto switch_break;
    case_230: /* CIL Label */ 
    {
#line 1365
    printf((char const   */* __restrict  */)"DW_OP_HP_tls");
    }
#line 1367
    goto switch_break;
    case_248: /* CIL Label */ 
    {
#line 1375
    printf((char const   */* __restrict  */)"DW_OP_PGI_omp_thread_num");
    }
#line 1376
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1379
    if (op >= 224U) {
#line 1379
      if (op <= 255U) {
        {
#line 1381
        tmp___71 = gettext("(User defined location op)");
#line 1381
        printf((char const   */* __restrict  */)tmp___71);
        }
      } else {
        {
#line 1383
        tmp___72 = gettext("(Unknown location op)");
#line 1383
        printf((char const   */* __restrict  */)tmp___72);
        }
      }
    } else {
      {
#line 1383
      tmp___72 = gettext("(Unknown location op)");
#line 1383
      printf((char const   */* __restrict  */)tmp___72);
      }
    }
#line 1385
    return (need_frame_base);
    switch_break: /* CIL Label */ ;
    }
#line 1389
    if ((unsigned long )data < (unsigned long )end) {
      {
#line 1390
      printf((char const   */* __restrict  */)"; ");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1393
  return (need_frame_base);
}
}
#line 1399 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static struct cu_tu_set *find_cu_tu_set_v2(dwarf_vma cu_offset , int do_types ) 
{ 
  struct cu_tu_set *p ;
  unsigned int nsets ;
  unsigned int dw_sect ;

  {
#line 1406
  if (do_types) {
#line 1408
    p = tu_sets;
#line 1409
    nsets = (unsigned int )tu_count;
#line 1410
    dw_sect = 2U;
  } else {
#line 1414
    p = cu_sets;
#line 1415
    nsets = (unsigned int )cu_count;
#line 1416
    dw_sect = 1U;
  }
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1418
    if (! (nsets > 0U)) {
#line 1418
      goto while_break;
    }
#line 1420
    if (p->section_offsets[dw_sect] == cu_offset) {
#line 1421
      return (p);
    }
#line 1422
    p ++;
#line 1423
    nsets --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1425
  return ((struct cu_tu_set *)((void *)0));
}
}
#line 1429 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void add64(dwarf_vma *high_bits , dwarf_vma *low_bits , dwarf_vma inc ) 
{ 
  dwarf_vma tmp___0 ;

  {
#line 1432
  tmp___0 = *low_bits;
#line 1434
  tmp___0 += inc;
#line 1442
  if (tmp___0 < *low_bits) {
#line 1444
    (*high_bits) ++;
  } else
#line 1446
  if (sizeof(tmp___0) > 8UL) {
#line 1446
    if (tmp___0 >> 31 > 1ULL) {
#line 1449
      (*high_bits) ++;
#line 1450
      tmp___0 &= 4294967295ULL;
    }
  }
#line 1453
  *low_bits = tmp___0;
#line 1454
  return;
}
}
#line 1456 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *read_and_display_attr_value(unsigned long attribute , unsigned long form ,
                                                  unsigned char *data , unsigned char *end ,
                                                  dwarf_vma cu_offset , dwarf_vma pointer_size ,
                                                  dwarf_vma offset_size , int dwarf_version ,
                                                  debug_info *debug_info_p , int do_loc ,
                                                  struct dwarf_section *section ,
                                                  struct cu_tu_set *this_set ) 
{ 
  dwarf_vma uvalue ;
  unsigned char *block_start ;
  unsigned char *orig_data ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  int tmp___1 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___2 ;
  unsigned int amount ;
  int tmp___3 ;
  int *dummy___0  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___0 ;
  void *tmp___4 ;
  unsigned int amount___0 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *dummy___1  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___1 ;
  void *tmp___7 ;
  unsigned int amount___1 ;
  int tmp___8 ;
  int *dummy___2  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___2 ;
  void *tmp___9 ;
  unsigned int amount___2 ;
  unsigned int amount___3 ;
  unsigned int amount___4 ;
  unsigned int amount___5 ;
  dwarf_signed_vma tmp___10 ;
  dwarf_vma tmp___11 ;
  char const   *tmp___12 ;
  unsigned char *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  dwarf_vma high_bits ;
  dwarf_vma utmp ;
  char buf___7[64] ;
  char const   *tmp___19 ;
  unsigned int amount___6 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  unsigned int amount___7 ;
  unsigned int amount___8 ;
  unsigned int amount___9 ;
  unsigned char const   *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char const   *suffix ;
  char *tmp___25 ;
  int dwo ;
  int tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  dwarf_vma high_bits___0 ;
  char buf___8[64] ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  unsigned int lmax ;
  unsigned int num ;
  void *tmp___38 ;
  void *tmp___39 ;
  unsigned int lmax___0 ;
  unsigned int num___0 ;
  void *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  char *tmp___46 ;
  char const   *tmp___47 ;
  char *tmp___48 ;
  char const   *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  int need_frame_base ;
  char *tmp___61 ;
  char const   *tmp___62 ;
  char *tmp___63 ;
  unsigned long abbrev_number ;
  abbrev_entry *entry ;
  dwarf_vma tmp___64 ;
  char *tmp___65 ;
  char const   *tmp___66 ;

  {
#line 1470
  uvalue = (dwarf_vma )0;
#line 1471
  block_start = (unsigned char *)((void *)0);
#line 1472
  orig_data = data;
#line 1475
  if ((unsigned long )data == (unsigned long )end) {
    {
#line 1477
    tmp___0 = gettext("corrupt attribute\n");
#line 1477
    warn((char const   *)tmp___0);
    }
#line 1478
    return (data);
  }
  {
#line 1486
  if (form == 16UL) {
#line 1486
    goto case_16;
  }
#line 1496
  if (form == 1UL) {
#line 1496
    goto case_1;
  }
#line 1503
  if (form == 7969UL) {
#line 1503
    goto case_7969;
  }
#line 1503
  if (form == 7968UL) {
#line 1503
    goto case_7969;
  }
#line 1503
  if (form == 23UL) {
#line 1503
    goto case_7969;
  }
#line 1503
  if (form == 14UL) {
#line 1503
    goto case_7969;
  }
#line 1507
  if (form == 25UL) {
#line 1507
    goto case_25;
  }
#line 1513
  if (form == 11UL) {
#line 1513
    goto case_11;
  }
#line 1513
  if (form == 12UL) {
#line 1513
    goto case_11;
  }
#line 1513
  if (form == 17UL) {
#line 1513
    goto case_11;
  }
#line 1518
  if (form == 5UL) {
#line 1518
    goto case_5;
  }
#line 1518
  if (form == 18UL) {
#line 1518
    goto case_5;
  }
#line 1523
  if (form == 6UL) {
#line 1523
    goto case_6;
  }
#line 1523
  if (form == 19UL) {
#line 1523
    goto case_6;
  }
#line 1527
  if (form == 13UL) {
#line 1527
    goto case_13;
  }
#line 1532
  if (form == 7938UL) {
#line 1532
    goto case_7938;
  }
#line 1538
  if (form == 15UL) {
#line 1538
    goto case_15;
  }
#line 1538
  if (form == 21UL) {
#line 1538
    goto case_15;
  }
#line 1543
  if (form == 22UL) {
#line 1543
    goto case_22;
  }
#line 1553
  if (form == 7937UL) {
#line 1553
    goto case_7937;
  }
#line 1483
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1484
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1487
  if (dwarf_version == 2) {
    {
#line 1488
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1488
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1488
        if (8ULL < pointer_size) {
#line 1488
          tmp___1 = -1;
        } else {
#line 1488
          tmp___1 = 1;
        }
        {
#line 1488
        __lengthofdummy = (unsigned long )tmp___1;
#line 1488
        tmp___2 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 1488
        dummy = (int *)tmp___2;
#line 1488
        amount = (unsigned int )pointer_size;
        }
#line 1488
        if ((unsigned long )(data + amount) >= (unsigned long )end) {
#line 1488
          if ((unsigned long )data < (unsigned long )end) {
#line 1488
            amount = (unsigned int )(end - data);
          } else {
#line 1488
            amount = 0U;
          }
        }
#line 1488
        if (amount) {
          {
#line 1488
          uvalue = (*byte_get)(data, (int )amount);
          }
        } else {
#line 1488
          uvalue = (dwarf_vma )0;
        }
#line 1488
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1488
      data += pointer_size;
#line 1488
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1489
  if (dwarf_version == 3) {
#line 1489
    goto _L;
  } else
#line 1489
  if (dwarf_version == 4) {
    _L: /* CIL Label */ 
    {
#line 1490
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1490
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1490
        if (8ULL < offset_size) {
#line 1490
          tmp___3 = -1;
        } else {
#line 1490
          tmp___3 = 1;
        }
        {
#line 1490
        __lengthofdummy___0 = (unsigned long )tmp___3;
#line 1490
        tmp___4 = __builtin_alloca(sizeof(*dummy___0) * __lengthofdummy___0);
#line 1490
        dummy___0 = (int *)tmp___4;
#line 1490
        amount___0 = (unsigned int )offset_size;
        }
#line 1490
        if ((unsigned long )(data + amount___0) >= (unsigned long )end) {
#line 1490
          if ((unsigned long )data < (unsigned long )end) {
#line 1490
            amount___0 = (unsigned int )(end - data);
          } else {
#line 1490
            amount___0 = 0U;
          }
        }
#line 1490
        if (amount___0) {
          {
#line 1490
          uvalue = (*byte_get)(data, (int )amount___0);
          }
        } else {
#line 1490
          uvalue = (dwarf_vma )0;
        }
#line 1490
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1490
      data += offset_size;
#line 1490
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1492
    tmp___5 = gettext("Internal error: DWARF version is not 2, 3 or 4.\n");
#line 1492
    error((char const   *)tmp___5);
    }
  }
#line 1494
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1497
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1497
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1497
      if (8ULL < pointer_size) {
#line 1497
        tmp___6 = -1;
      } else {
#line 1497
        tmp___6 = 1;
      }
      {
#line 1497
      __lengthofdummy___1 = (unsigned long )tmp___6;
#line 1497
      tmp___7 = __builtin_alloca(sizeof(*dummy___1) * __lengthofdummy___1);
#line 1497
      dummy___1 = (int *)tmp___7;
#line 1497
      amount___1 = (unsigned int )pointer_size;
      }
#line 1497
      if ((unsigned long )(data + amount___1) >= (unsigned long )end) {
#line 1497
        if ((unsigned long )data < (unsigned long )end) {
#line 1497
          amount___1 = (unsigned int )(end - data);
        } else {
#line 1497
          amount___1 = 0U;
        }
      }
#line 1497
      if (amount___1) {
        {
#line 1497
        uvalue = (*byte_get)(data, (int )amount___1);
        }
      } else {
#line 1497
        uvalue = (dwarf_vma )0;
      }
#line 1497
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1497
    data += pointer_size;
#line 1497
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1498
  goto switch_break;
  case_7969: /* CIL Label */ 
  case_7968: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 1504
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 1504
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1504
      if (8ULL < offset_size) {
#line 1504
        tmp___8 = -1;
      } else {
#line 1504
        tmp___8 = 1;
      }
      {
#line 1504
      __lengthofdummy___2 = (unsigned long )tmp___8;
#line 1504
      tmp___9 = __builtin_alloca(sizeof(*dummy___2) * __lengthofdummy___2);
#line 1504
      dummy___2 = (int *)tmp___9;
#line 1504
      amount___2 = (unsigned int )offset_size;
      }
#line 1504
      if ((unsigned long )(data + amount___2) >= (unsigned long )end) {
#line 1504
        if ((unsigned long )data < (unsigned long )end) {
#line 1504
          amount___2 = (unsigned int )(end - data);
        } else {
#line 1504
          amount___2 = 0U;
        }
      }
#line 1504
      if (amount___2) {
        {
#line 1504
        uvalue = (*byte_get)(data, (int )amount___2);
        }
      } else {
#line 1504
        uvalue = (dwarf_vma )0;
      }
#line 1504
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1504
    data += offset_size;
#line 1504
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1505
  goto switch_break;
  case_25: /* CIL Label */ 
#line 1508
  uvalue = (dwarf_vma )1;
#line 1509
  goto switch_break;
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_17: /* CIL Label */ 
  {
#line 1514
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 1514
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1514
      amount___3 = 1U;
#line 1514
      if ((unsigned long )(data + amount___3) >= (unsigned long )end) {
#line 1514
        if ((unsigned long )data < (unsigned long )end) {
#line 1514
          amount___3 = (unsigned int )(end - data);
        } else {
#line 1514
          amount___3 = 0U;
        }
      }
#line 1514
      if (amount___3) {
        {
#line 1514
        uvalue = (*byte_get)(data, (int )amount___3);
        }
      } else {
#line 1514
        uvalue = (dwarf_vma )0;
      }
#line 1514
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1514
    data ++;
#line 1514
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1515
  goto switch_break;
  case_5: /* CIL Label */ 
  case_18: /* CIL Label */ 
  {
#line 1519
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 1519
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1519
      amount___4 = 2U;
#line 1519
      if ((unsigned long )(data + amount___4) >= (unsigned long )end) {
#line 1519
        if ((unsigned long )data < (unsigned long )end) {
#line 1519
          amount___4 = (unsigned int )(end - data);
        } else {
#line 1519
          amount___4 = 0U;
        }
      }
#line 1519
      if (amount___4) {
        {
#line 1519
        uvalue = (*byte_get)(data, (int )amount___4);
        }
      } else {
#line 1519
        uvalue = (dwarf_vma )0;
      }
#line 1519
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1519
    data += 2;
#line 1519
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1520
  goto switch_break;
  case_6: /* CIL Label */ 
  case_19: /* CIL Label */ 
  {
#line 1524
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 1524
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1524
      amount___5 = 4U;
#line 1524
      if ((unsigned long )(data + amount___5) >= (unsigned long )end) {
#line 1524
        if ((unsigned long )data < (unsigned long )end) {
#line 1524
          amount___5 = (unsigned int )(end - data);
        } else {
#line 1524
          amount___5 = 0U;
        }
      }
#line 1524
      if (amount___5) {
        {
#line 1524
        uvalue = (*byte_get)(data, (int )amount___5);
        }
      } else {
#line 1524
        uvalue = (dwarf_vma )0;
      }
#line 1524
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1524
    data += 4;
#line 1524
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1525
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1528
  tmp___10 = read_sleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1528
  uvalue = (dwarf_vma )tmp___10;
#line 1529
  data += bytes_read;
  }
#line 1530
  goto switch_break;
  case_7938: /* CIL Label */ 
  {
#line 1533
  uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1534
  data += bytes_read;
  }
#line 1535
  goto switch_break;
  case_15: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1539
  uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1540
  data += bytes_read;
  }
#line 1541
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1544
  tmp___11 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1544
  form = (unsigned long )tmp___11;
#line 1545
  data += bytes_read;
  }
#line 1546
  if (! do_loc) {
    {
#line 1547
    tmp___12 = get_FORM_name(form);
#line 1547
    printf((char const   */* __restrict  */)" %s", tmp___12);
    }
  }
  {
#line 1548
  tmp___13 = read_and_display_attr_value(attribute, form, data, end, cu_offset, pointer_size,
                                         offset_size, dwarf_version, debug_info_p,
                                         do_loc, section, this_set);
  }
#line 1548
  return (tmp___13);
  case_7937: /* CIL Label */ 
  {
#line 1554
  uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1555
  data += bytes_read;
  }
#line 1556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1561
  if (form == 16UL) {
#line 1561
    goto case_16___0;
  }
#line 1566
  if (form == 7968UL) {
#line 1566
    goto case_7968___0;
  }
#line 1574
  if (form == 21UL) {
#line 1574
    goto case_21___0;
  }
#line 1574
  if (form == 19UL) {
#line 1574
    goto case_21___0;
  }
#line 1574
  if (form == 18UL) {
#line 1574
    goto case_21___0;
  }
#line 1574
  if (form == 17UL) {
#line 1574
    goto case_21___0;
  }
#line 1581
  if (form == 23UL) {
#line 1581
    goto case_23___0;
  }
#line 1581
  if (form == 1UL) {
#line 1581
    goto case_23___0;
  }
#line 1581
  if (form == 6UL) {
#line 1581
    goto case_23___0;
  }
#line 1591
  if (form == 15UL) {
#line 1591
    goto case_15___0;
  }
#line 1591
  if (form == 13UL) {
#line 1591
    goto case_15___0;
  }
#line 1591
  if (form == 5UL) {
#line 1591
    goto case_15___0;
  }
#line 1591
  if (form == 11UL) {
#line 1591
    goto case_15___0;
  }
#line 1591
  if (form == 12UL) {
#line 1591
    goto case_15___0;
  }
#line 1591
  if (form == 25UL) {
#line 1591
    goto case_15___0;
  }
#line 1597
  if (form == 7UL) {
#line 1597
    goto case_7;
  }
#line 1597
  if (form == 20UL) {
#line 1597
    goto case_7;
  }
#line 1624
  if (form == 8UL) {
#line 1624
    goto case_8;
  }
#line 1631
  if (form == 24UL) {
#line 1631
    goto case_24;
  }
#line 1631
  if (form == 9UL) {
#line 1631
    goto case_24;
  }
#line 1640
  if (form == 10UL) {
#line 1640
    goto case_10;
  }
#line 1649
  if (form == 3UL) {
#line 1649
    goto case_3;
  }
#line 1658
  if (form == 4UL) {
#line 1658
    goto case_4;
  }
#line 1667
  if (form == 14UL) {
#line 1667
    goto case_14___0;
  }
#line 1674
  if (form == 7938UL) {
#line 1674
    goto case_7938___0;
  }
#line 1686
  if (form == 7969UL) {
#line 1686
    goto case_7969___0;
  }
#line 1692
  if (form == 22UL) {
#line 1692
    goto case_22___0;
  }
#line 1696
  if (form == 32UL) {
#line 1696
    goto case_32;
  }
#line 1709
  if (form == 7937UL) {
#line 1709
    goto case_7937___0;
  }
#line 1716
  goto switch_default___0;
  case_16___0: /* CIL Label */ 
#line 1562
  if (! do_loc) {
    {
#line 1563
    tmp___14 = dwarf_vmatoa("x", uvalue);
#line 1563
    printf((char const   */* __restrict  */)" <0x%s>", tmp___14);
    }
  }
#line 1564
  goto switch_break___0;
  case_7968___0: /* CIL Label */ 
#line 1567
  if (! do_loc) {
    {
#line 1568
    tmp___15 = dwarf_vmatoa("x", uvalue);
#line 1568
    printf((char const   */* __restrict  */)" <alt 0x%s>", tmp___15);
    }
  }
#line 1569
  goto switch_break___0;
  case_21___0: /* CIL Label */ 
  case_19___0: /* CIL Label */ 
  case_18___0: /* CIL Label */ 
  case_17___0: /* CIL Label */ 
#line 1575
  if (! do_loc) {
    {
#line 1576
    tmp___16 = dwarf_vmatoa("x", uvalue + cu_offset);
#line 1576
    printf((char const   */* __restrict  */)" <0x%s>", tmp___16);
    }
  }
#line 1577
  goto switch_break___0;
  case_23___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
#line 1582
  if (! do_loc) {
    {
#line 1583
    tmp___17 = dwarf_vmatoa("x", uvalue);
#line 1583
    printf((char const   */* __restrict  */)" 0x%s", tmp___17);
    }
  }
#line 1584
  goto switch_break___0;
  case_15___0: /* CIL Label */ 
  case_13___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_25___0: /* CIL Label */ 
#line 1592
  if (! do_loc) {
    {
#line 1593
    tmp___18 = dwarf_vmatoa("d", uvalue);
#line 1593
    printf((char const   */* __restrict  */)" %s", tmp___18);
    }
  }
#line 1594
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_20: /* CIL Label */ 
#line 1598
  if (! do_loc) {
    {
#line 1604
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1604
      if ((unsigned long )(data + 8) <= (unsigned long )end) {
        {
#line 1604
        byte_get_64(data, & high_bits, & uvalue);
        }
      } else {
#line 1604
        high_bits = (dwarf_vma )0;
#line 1604
        uvalue = high_bits;
      }
#line 1604
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1605
    utmp = uvalue;
#line 1606
    if (form == 20UL) {
      {
#line 1607
      add64(& high_bits, & utmp, cu_offset);
      }
    }
    {
#line 1608
    tmp___19 = dwarf_vmatoa64(high_bits, utmp, buf___7, (unsigned int )sizeof(buf___7));
#line 1608
    printf((char const   */* __restrict  */)" 0x%s", tmp___19);
    }
  }
#line 1612
  if (do_loc) {
#line 1612
    goto _L___0;
  } else
#line 1612
  if (do_debug_loc) {
#line 1612
    goto _L___0;
  } else
#line 1612
  if (do_debug_ranges) {
    _L___0: /* CIL Label */ 
#line 1612
    if (num_debug_info_entries == 0U) {
#line 1615
      if (sizeof(uvalue) == 8UL) {
        {
#line 1616
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1616
          amount___6 = 8U;
#line 1616
          if ((unsigned long )(data + amount___6) >= (unsigned long )end) {
#line 1616
            if ((unsigned long )data < (unsigned long )end) {
#line 1616
              amount___6 = (unsigned int )(end - data);
            } else {
#line 1616
              amount___6 = 0U;
            }
          }
#line 1616
          if (amount___6) {
            {
#line 1616
            uvalue = (*byte_get)(data, (int )amount___6);
            }
          } else {
#line 1616
            uvalue = (dwarf_vma )0;
          }
#line 1616
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      } else {
        {
#line 1618
        tmp___20 = gettext("DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\n");
#line 1618
        error((char const   *)tmp___20);
        }
      }
    }
  }
#line 1621
  data += 8;
#line 1622
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 1625
  if (! do_loc) {
    {
#line 1626
    printf((char const   */* __restrict  */)" %.*s", (int )(end - data), data);
    }
  }
  {
#line 1627
  tmp___21 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 1627
  data += tmp___21 + 1UL;
  }
#line 1628
  goto switch_break___0;
  case_24: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
#line 1632
  uvalue = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 1633
  block_start = data + bytes_read;
  }
#line 1634
  if (do_loc) {
#line 1635
    data = block_start + uvalue;
  } else {
    {
#line 1637
    data = display_block(block_start, uvalue, (unsigned char const   */* const  */)end);
    }
  }
#line 1638
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 1641
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1641
    amount___7 = 1U;
#line 1641
    if ((unsigned long )(data + amount___7) >= (unsigned long )end) {
#line 1641
      if ((unsigned long )data < (unsigned long )end) {
#line 1641
        amount___7 = (unsigned int )(end - data);
      } else {
#line 1641
        amount___7 = 0U;
      }
    }
#line 1641
    if (amount___7) {
      {
#line 1641
      uvalue = (*byte_get)(data, (int )amount___7);
      }
    } else {
#line 1641
      uvalue = (dwarf_vma )0;
    }
#line 1641
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 1642
  block_start = data + 1;
#line 1643
  if (do_loc) {
#line 1644
    data = block_start + uvalue;
  } else {
    {
#line 1646
    data = display_block(block_start, uvalue, (unsigned char const   */* const  */)end);
    }
  }
#line 1647
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 1650
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1650
    amount___8 = 2U;
#line 1650
    if ((unsigned long )(data + amount___8) >= (unsigned long )end) {
#line 1650
      if ((unsigned long )data < (unsigned long )end) {
#line 1650
        amount___8 = (unsigned int )(end - data);
      } else {
#line 1650
        amount___8 = 0U;
      }
    }
#line 1650
    if (amount___8) {
      {
#line 1650
      uvalue = (*byte_get)(data, (int )amount___8);
      }
    } else {
#line 1650
      uvalue = (dwarf_vma )0;
    }
#line 1650
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1651
  block_start = data + 2;
#line 1652
  if (do_loc) {
#line 1653
    data = block_start + uvalue;
  } else {
    {
#line 1655
    data = display_block(block_start, uvalue, (unsigned char const   */* const  */)end);
    }
  }
#line 1656
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1659
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1659
    amount___9 = 4U;
#line 1659
    if ((unsigned long )(data + amount___9) >= (unsigned long )end) {
#line 1659
      if ((unsigned long )data < (unsigned long )end) {
#line 1659
        amount___9 = (unsigned int )(end - data);
      } else {
#line 1659
        amount___9 = 0U;
      }
    }
#line 1659
    if (amount___9) {
      {
#line 1659
      uvalue = (*byte_get)(data, (int )amount___9);
      }
    } else {
#line 1659
      uvalue = (dwarf_vma )0;
    }
#line 1659
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1660
  block_start = data + 4;
#line 1661
  if (do_loc) {
#line 1662
    data = block_start + uvalue;
  } else {
    {
#line 1664
    data = display_block(block_start, uvalue, (unsigned char const   */* const  */)end);
    }
  }
#line 1665
  goto switch_break___0;
  case_14___0: /* CIL Label */ 
#line 1668
  if (! do_loc) {
    {
#line 1669
    tmp___22 = fetch_indirect_string(uvalue);
#line 1669
    tmp___23 = dwarf_vmatoa("x", uvalue);
#line 1669
    tmp___24 = gettext(" (indirect string, offset: 0x%s): %s");
#line 1669
    printf((char const   */* __restrict  */)tmp___24, tmp___23, tmp___22);
    }
  }
#line 1672
  goto switch_break___0;
  case_7938___0: /* CIL Label */ 
#line 1675
  if (! do_loc) {
    {
#line 1677
    tmp___25 = strrchr(section->name, '.');
#line 1677
    suffix = (char const   *)tmp___25;
    }
#line 1678
    if (suffix) {
      {
#line 1678
      tmp___27 = strcmp(suffix, ".dwo");
      }
#line 1678
      if (tmp___27 == 0) {
#line 1678
        tmp___26 = 1;
      } else {
#line 1678
        tmp___26 = 0;
      }
    } else {
#line 1678
      tmp___26 = 0;
    }
    {
#line 1678
    dwo = tmp___26;
#line 1680
    tmp___28 = fetch_indexed_string(uvalue, this_set, offset_size, dwo);
#line 1680
    tmp___29 = dwarf_vmatoa("x", uvalue);
#line 1680
    tmp___30 = gettext(" (indexed string: 0x%s): %s");
#line 1680
    printf((char const   */* __restrict  */)tmp___30, tmp___29, tmp___28);
    }
  }
#line 1684
  goto switch_break___0;
  case_7969___0: /* CIL Label */ 
#line 1687
  if (! do_loc) {
    {
#line 1688
    tmp___31 = dwarf_vmatoa("x", uvalue);
#line 1688
    tmp___32 = gettext(" (alt indirect string, offset: 0x%s)");
#line 1688
    printf((char const   */* __restrict  */)tmp___32, tmp___31);
    }
  }
#line 1690
  goto switch_break___0;
  case_22___0: /* CIL Label */ 
#line 1694
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 1697
  if (! do_loc) {
    {
#line 1702
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1702
      if ((unsigned long )(data + 8) <= (unsigned long )end) {
        {
#line 1702
        byte_get_64(data, & high_bits___0, & uvalue);
        }
      } else {
#line 1702
        high_bits___0 = (dwarf_vma )0;
#line 1702
        uvalue = high_bits___0;
      }
#line 1702
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1703
    tmp___33 = dwarf_vmatoa64(high_bits___0, uvalue, buf___8, (unsigned int )sizeof(buf___8));
#line 1703
    printf((char const   */* __restrict  */)" signature: 0x%s", tmp___33);
    }
  }
#line 1706
  data += 8;
#line 1707
  goto switch_break___0;
  case_7937___0: /* CIL Label */ 
#line 1710
  if (! do_loc) {
    {
#line 1711
    tmp___34 = fetch_indexed_value(uvalue * pointer_size, pointer_size);
#line 1711
    tmp___35 = dwarf_vmatoa("x", uvalue);
#line 1711
    tmp___36 = gettext(" (addr_index: 0x%s): %s");
#line 1711
    printf((char const   */* __restrict  */)tmp___36, tmp___35, tmp___34);
    }
  }
#line 1714
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1717
  tmp___37 = gettext("Unrecognized form: %lu\n");
#line 1717
  warn((char const   *)tmp___37, form);
  }
#line 1718
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1721
  if (do_loc) {
#line 1721
    goto _L___6;
  } else
#line 1721
  if (do_debug_loc) {
#line 1721
    goto _L___6;
  } else
#line 1721
  if (do_debug_ranges) {
    _L___6: /* CIL Label */ 
#line 1721
    if (num_debug_info_entries == 0U) {
#line 1721
      if ((unsigned long )debug_info_p != (unsigned long )((void *)0)) {
        {
#line 1727
        if (attribute == 64UL) {
#line 1727
          goto case_64;
        }
#line 1740
        if (attribute == 8468UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 8467UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 8466UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 8465UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 74UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 72UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 70UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 77UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 56UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 42UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 25UL) {
#line 1740
          goto case_8468;
        }
#line 1740
        if (attribute == 2UL) {
#line 1740
          goto case_8468;
        }
#line 1768
        if (attribute == 17UL) {
#line 1768
          goto case_17___1;
        }
#line 1773
        if (attribute == 8499UL) {
#line 1773
          goto case_8499;
        }
#line 1777
        if (attribute == 8498UL) {
#line 1777
          goto case_8498;
        }
#line 1781
        if (attribute == 85UL) {
#line 1781
          goto case_85;
        }
#line 1803
        goto switch_default___1;
        case_64: /* CIL Label */ 
#line 1728
        have_frame_base = 1;
        case_8468: /* CIL Label */ 
        case_8467: /* CIL Label */ 
        case_8466: /* CIL Label */ 
        case_8465: /* CIL Label */ 
        case_74: /* CIL Label */ 
        case_72: /* CIL Label */ 
        case_70: /* CIL Label */ 
        case_77: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_42: /* CIL Label */ 
        case_25___1: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 1741
        if (dwarf_version < 4) {
#line 1741
          if (form == 6UL) {
#line 1741
            goto _L___2;
          } else
#line 1741
          if (form == 7UL) {
#line 1741
            goto _L___2;
          } else {
#line 1741
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 1741
        if (form == 23UL) {
          _L___2: /* CIL Label */ 
#line 1746
          lmax = debug_info_p->max_loc_offsets;
#line 1747
          num = debug_info_p->num_loc_offsets;
#line 1749
          if (lmax == 0U) {
#line 1749
            goto _L___1;
          } else
#line 1749
          if (num >= lmax) {
            _L___1: /* CIL Label */ 
            {
#line 1751
            lmax += 1024U;
#line 1752
            tmp___38 = xcrealloc((void *)debug_info_p->loc_offsets, (size_t )lmax,
                                 sizeof(*(debug_info_p->loc_offsets)));
#line 1752
            debug_info_p->loc_offsets = (dwarf_vma *)tmp___38;
#line 1755
            tmp___39 = xcrealloc((void *)debug_info_p->have_frame_base, (size_t )lmax,
                                 sizeof(*(debug_info_p->have_frame_base)));
#line 1755
            debug_info_p->have_frame_base = (int *)tmp___39;
#line 1758
            debug_info_p->max_loc_offsets = lmax;
            }
          }
#line 1760
          if ((unsigned long )this_set != (unsigned long )((void *)0)) {
#line 1761
            uvalue += this_set->section_offsets[5];
          }
#line 1762
          *(debug_info_p->loc_offsets + num) = uvalue;
#line 1763
          *(debug_info_p->have_frame_base + num) = have_frame_base;
#line 1764
          (debug_info_p->num_loc_offsets) ++;
        }
#line 1766
        goto switch_break___1;
        case_17___1: /* CIL Label */ 
#line 1769
        if (need_base_address) {
#line 1770
          debug_info_p->base_address = uvalue;
        }
#line 1771
        goto switch_break___1;
        case_8499: /* CIL Label */ 
#line 1774
        debug_info_p->addr_base = uvalue;
#line 1775
        goto switch_break___1;
        case_8498: /* CIL Label */ 
#line 1778
        debug_info_p->ranges_base = uvalue;
#line 1779
        goto switch_break___1;
        case_85: /* CIL Label */ 
#line 1782
        if (dwarf_version < 4) {
#line 1782
          if (form == 6UL) {
#line 1782
            goto _L___4;
          } else
#line 1782
          if (form == 7UL) {
#line 1782
            goto _L___4;
          } else {
#line 1782
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 1782
        if (form == 23UL) {
          _L___4: /* CIL Label */ 
#line 1787
          lmax___0 = debug_info_p->max_range_lists;
#line 1788
          num___0 = debug_info_p->num_range_lists;
#line 1790
          if (lmax___0 == 0U) {
            {
#line 1792
            lmax___0 += 1024U;
#line 1793
            tmp___40 = xcrealloc((void *)debug_info_p->range_lists, (size_t )lmax___0,
                                 sizeof(*(debug_info_p->range_lists)));
#line 1793
            debug_info_p->range_lists = (dwarf_vma *)tmp___40;
#line 1796
            debug_info_p->max_range_lists = lmax___0;
            }
          } else
#line 1790
          if (num___0 >= lmax___0) {
            {
#line 1792
            lmax___0 += 1024U;
#line 1793
            tmp___40 = xcrealloc((void *)debug_info_p->range_lists, (size_t )lmax___0,
                                 sizeof(*(debug_info_p->range_lists)));
#line 1793
            debug_info_p->range_lists = (dwarf_vma *)tmp___40;
#line 1796
            debug_info_p->max_range_lists = lmax___0;
            }
          }
#line 1798
          *(debug_info_p->range_lists + num___0) = uvalue;
#line 1799
          (debug_info_p->num_range_lists) ++;
        }
#line 1801
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 1804
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 1808
  if (do_loc) {
#line 1809
    return (data);
  } else
#line 1808
  if (attribute == 0UL) {
#line 1809
    return (data);
  }
  {
#line 1812
  printf((char const   */* __restrict  */)"\t");
  }
  {
#line 1816
  if (attribute == 32UL) {
#line 1816
    goto case_32___0;
  }
#line 1838
  if (attribute == 19UL) {
#line 1838
    goto case_19___1;
  }
#line 1881
  if (attribute == 62UL) {
#line 1881
    goto case_62;
  }
#line 1921
  if (attribute == 50UL) {
#line 1921
    goto case_50;
  }
#line 1933
  if (attribute == 23UL) {
#line 1933
    goto case_23___1;
  }
#line 1943
  if (attribute == 76UL) {
#line 1943
    goto case_76;
  }
#line 1953
  if (attribute == 66UL) {
#line 1953
    goto case_66;
  }
#line 1964
  if (attribute == 54UL) {
#line 1964
    goto case_54;
  }
#line 1979
  if (attribute == 9UL) {
#line 1979
    goto case_9___2;
  }
#line 1988
  if (attribute == 64UL) {
#line 1988
    goto case_64___0;
  }
#line 2001
  if (attribute == 8468UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 8467UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 8466UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 8465UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 74UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 72UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 70UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 77UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 56UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 42UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 25UL) {
#line 2001
    goto case_8468___0;
  }
#line 2001
  if (attribute == 2UL) {
#line 2001
    goto case_8468___0;
  }
#line 2012
  if (attribute == 34UL) {
#line 2012
    goto case_34;
  }
#line 2012
  if (attribute == 47UL) {
#line 2012
    goto case_34;
  }
#line 2012
  if (attribute == 81UL) {
#line 2012
    goto case_34;
  }
#line 2012
  if (attribute == 80UL) {
#line 2012
    goto case_34;
  }
#line 2012
  if (attribute == 79UL) {
#line 2012
    goto case_34;
  }
#line 2012
  if (attribute == 78UL) {
#line 2012
    goto case_34;
  }
#line 2030
  if (attribute == 24UL) {
#line 2030
    goto case_24___0;
  }
#line 2070
  goto switch_default___10;
  case_32___0: /* CIL Label */ 
  {
#line 1819
  if (uvalue == 0ULL) {
#line 1819
    goto case_0;
  }
#line 1822
  if (uvalue == 1ULL) {
#line 1822
    goto case_1___1;
  }
#line 1825
  if (uvalue == 2ULL) {
#line 1825
    goto case_2___0;
  }
#line 1828
  if (uvalue == 3ULL) {
#line 1828
    goto case_3___0;
  }
#line 1831
  goto switch_default___2;
  case_0: /* CIL Label */ 
  {
#line 1820
  tmp___41 = gettext("(not inlined)");
#line 1820
  printf((char const   */* __restrict  */)tmp___41);
  }
#line 1821
  goto switch_break___3;
  case_1___1: /* CIL Label */ 
  {
#line 1823
  tmp___42 = gettext("(inlined)");
#line 1823
  printf((char const   */* __restrict  */)tmp___42);
  }
#line 1824
  goto switch_break___3;
  case_2___0: /* CIL Label */ 
  {
#line 1826
  tmp___43 = gettext("(declared as inline but ignored)");
#line 1826
  printf((char const   */* __restrict  */)tmp___43);
  }
#line 1827
  goto switch_break___3;
  case_3___0: /* CIL Label */ 
  {
#line 1829
  tmp___44 = gettext("(declared as inline and inlined)");
#line 1829
  printf((char const   */* __restrict  */)tmp___44);
  }
#line 1830
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 1832
  tmp___45 = dwarf_vmatoa("x", uvalue);
#line 1832
  tmp___46 = gettext("  (Unknown inline attribute value: %s)");
#line 1832
  printf((char const   */* __restrict  */)tmp___46, tmp___45);
  }
#line 1834
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1836
  goto switch_break___2;
  case_19___1: /* CIL Label */ 
  {
#line 1842
  if (uvalue == 1ULL) {
#line 1842
    goto case_1___2;
  }
#line 1843
  if (uvalue == 2ULL) {
#line 1843
    goto case_2___1;
  }
#line 1844
  if (uvalue == 3ULL) {
#line 1844
    goto case_3___1;
  }
#line 1845
  if (uvalue == 4ULL) {
#line 1845
    goto case_4___0;
  }
#line 1846
  if (uvalue == 5ULL) {
#line 1846
    goto case_5___1;
  }
#line 1847
  if (uvalue == 6ULL) {
#line 1847
    goto case_6___1;
  }
#line 1848
  if (uvalue == 7ULL) {
#line 1848
    goto case_7___0;
  }
#line 1849
  if (uvalue == 8ULL) {
#line 1849
    goto case_8___0;
  }
#line 1850
  if (uvalue == 9ULL) {
#line 1850
    goto case_9___0;
  }
#line 1851
  if (uvalue == 10ULL) {
#line 1851
    goto case_10___0;
  }
#line 1853
  if (uvalue == 11ULL) {
#line 1853
    goto case_11___1;
  }
#line 1854
  if (uvalue == 12ULL) {
#line 1854
    goto case_12___1;
  }
#line 1855
  if (uvalue == 13ULL) {
#line 1855
    goto case_13___1;
  }
#line 1856
  if (uvalue == 14ULL) {
#line 1856
    goto case_14___1;
  }
#line 1858
  if (uvalue == 15ULL) {
#line 1858
    goto case_15___1;
  }
#line 1859
  if (uvalue == 16ULL) {
#line 1859
    goto case_16___1;
  }
#line 1860
  if (uvalue == 17ULL) {
#line 1860
    goto case_17___2;
  }
#line 1861
  if (uvalue == 18ULL) {
#line 1861
    goto case_18___1;
  }
#line 1862
  if (uvalue == 19ULL) {
#line 1862
    goto case_19___2;
  }
#line 1864
  if (uvalue == 20ULL) {
#line 1864
    goto case_20___0;
  }
#line 1866
  if (uvalue == 22ULL) {
#line 1866
    goto case_22___1;
  }
#line 1868
  if (uvalue == 32769ULL) {
#line 1868
    goto case_32769;
  }
#line 1870
  if (uvalue == 34661ULL) {
#line 1870
    goto case_34661;
  }
#line 1871
  goto switch_default___3;
  case_1___2: /* CIL Label */ 
  {
#line 1842
  printf((char const   */* __restrict  */)"(ANSI C)");
  }
#line 1842
  goto switch_break___4;
  case_2___1: /* CIL Label */ 
  {
#line 1843
  printf((char const   */* __restrict  */)"(non-ANSI C)");
  }
#line 1843
  goto switch_break___4;
  case_3___1: /* CIL Label */ 
  {
#line 1844
  printf((char const   */* __restrict  */)"(Ada)");
  }
#line 1844
  goto switch_break___4;
  case_4___0: /* CIL Label */ 
  {
#line 1845
  printf((char const   */* __restrict  */)"(C++)");
  }
#line 1845
  goto switch_break___4;
  case_5___1: /* CIL Label */ 
  {
#line 1846
  printf((char const   */* __restrict  */)"(Cobol 74)");
  }
#line 1846
  goto switch_break___4;
  case_6___1: /* CIL Label */ 
  {
#line 1847
  printf((char const   */* __restrict  */)"(Cobol 85)");
  }
#line 1847
  goto switch_break___4;
  case_7___0: /* CIL Label */ 
  {
#line 1848
  printf((char const   */* __restrict  */)"(FORTRAN 77)");
  }
#line 1848
  goto switch_break___4;
  case_8___0: /* CIL Label */ 
  {
#line 1849
  printf((char const   */* __restrict  */)"(Fortran 90)");
  }
#line 1849
  goto switch_break___4;
  case_9___0: /* CIL Label */ 
  {
#line 1850
  printf((char const   */* __restrict  */)"(ANSI Pascal)");
  }
#line 1850
  goto switch_break___4;
  case_10___0: /* CIL Label */ 
  {
#line 1851
  printf((char const   */* __restrict  */)"(Modula 2)");
  }
#line 1851
  goto switch_break___4;
  case_11___1: /* CIL Label */ 
  {
#line 1853
  printf((char const   */* __restrict  */)"(Java)");
  }
#line 1853
  goto switch_break___4;
  case_12___1: /* CIL Label */ 
  {
#line 1854
  printf((char const   */* __restrict  */)"(ANSI C99)");
  }
#line 1854
  goto switch_break___4;
  case_13___1: /* CIL Label */ 
  {
#line 1855
  printf((char const   */* __restrict  */)"(ADA 95)");
  }
#line 1855
  goto switch_break___4;
  case_14___1: /* CIL Label */ 
  {
#line 1856
  printf((char const   */* __restrict  */)"(Fortran 95)");
  }
#line 1856
  goto switch_break___4;
  case_15___1: /* CIL Label */ 
  {
#line 1858
  printf((char const   */* __restrict  */)"(PLI)");
  }
#line 1858
  goto switch_break___4;
  case_16___1: /* CIL Label */ 
  {
#line 1859
  printf((char const   */* __restrict  */)"(Objective C)");
  }
#line 1859
  goto switch_break___4;
  case_17___2: /* CIL Label */ 
  {
#line 1860
  printf((char const   */* __restrict  */)"(Objective C++)");
  }
#line 1860
  goto switch_break___4;
  case_18___1: /* CIL Label */ 
  {
#line 1861
  printf((char const   */* __restrict  */)"(Unified Parallel C)");
  }
#line 1861
  goto switch_break___4;
  case_19___2: /* CIL Label */ 
  {
#line 1862
  printf((char const   */* __restrict  */)"(D)");
  }
#line 1862
  goto switch_break___4;
  case_20___0: /* CIL Label */ 
  {
#line 1864
  printf((char const   */* __restrict  */)"(Python)");
  }
#line 1864
  goto switch_break___4;
  case_22___1: /* CIL Label */ 
  {
#line 1866
  printf((char const   */* __restrict  */)"(Go)");
  }
#line 1866
  goto switch_break___4;
  case_32769: /* CIL Label */ 
  {
#line 1868
  printf((char const   */* __restrict  */)"(MIPS assembler)");
  }
#line 1868
  goto switch_break___4;
  case_34661: /* CIL Label */ 
  {
#line 1870
  printf((char const   */* __restrict  */)"(Unified Parallel C)");
  }
#line 1870
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
#line 1872
  if (uvalue >= 32768ULL) {
#line 1872
    if (uvalue <= 65535ULL) {
      {
#line 1873
      tmp___47 = dwarf_vmatoa("x", uvalue);
#line 1873
      tmp___48 = gettext("(implementation defined: %s)");
#line 1873
      printf((char const   */* __restrict  */)tmp___48, tmp___47);
      }
    } else {
      {
#line 1876
      tmp___49 = dwarf_vmatoa("x", uvalue);
#line 1876
      tmp___50 = gettext("(Unknown: %s)");
#line 1876
      printf((char const   */* __restrict  */)tmp___50, tmp___49);
      }
    }
  } else {
    {
#line 1876
    tmp___49 = dwarf_vmatoa("x", uvalue);
#line 1876
    tmp___50 = gettext("(Unknown: %s)");
#line 1876
    printf((char const   */* __restrict  */)tmp___50, tmp___49);
    }
  }
#line 1877
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1879
  goto switch_break___2;
  case_62: /* CIL Label */ 
  {
#line 1884
  if (uvalue == 0ULL) {
#line 1884
    goto case_0___0;
  }
#line 1885
  if (uvalue == 1ULL) {
#line 1885
    goto case_1___3;
  }
#line 1886
  if (uvalue == 2ULL) {
#line 1886
    goto case_2___2;
  }
#line 1887
  if (uvalue == 3ULL) {
#line 1887
    goto case_3___2;
  }
#line 1888
  if (uvalue == 4ULL) {
#line 1888
    goto case_4___1;
  }
#line 1889
  if (uvalue == 5ULL) {
#line 1889
    goto case_5___2;
  }
#line 1890
  if (uvalue == 6ULL) {
#line 1890
    goto case_6___2;
  }
#line 1891
  if (uvalue == 7ULL) {
#line 1891
    goto case_7___1;
  }
#line 1892
  if (uvalue == 8ULL) {
#line 1892
    goto case_8___1;
  }
#line 1894
  if (uvalue == 9ULL) {
#line 1894
    goto case_9___1;
  }
#line 1895
  if (uvalue == 15ULL) {
#line 1895
    goto case_15___2;
  }
#line 1897
  if (uvalue == 10ULL) {
#line 1897
    goto case_10___1;
  }
#line 1898
  if (uvalue == 11ULL) {
#line 1898
    goto case_11___2;
  }
#line 1899
  if (uvalue == 12ULL) {
#line 1899
    goto case_12___2;
  }
#line 1900
  if (uvalue == 13ULL) {
#line 1900
    goto case_13___2;
  }
#line 1901
  if (uvalue == 14ULL) {
#line 1901
    goto case_14___2;
  }
#line 1903
  if (uvalue == 128ULL) {
#line 1903
    goto case_128;
  }
#line 1904
  if (uvalue == 129ULL) {
#line 1904
    goto case_129;
  }
#line 1905
  if (uvalue == 130ULL) {
#line 1905
    goto case_130;
  }
#line 1906
  if (uvalue == 131ULL) {
#line 1906
    goto case_131;
  }
#line 1907
  if (uvalue == 132ULL) {
#line 1907
    goto case_132;
  }
#line 1908
  if (uvalue == 133ULL) {
#line 1908
    goto case_133;
  }
#line 1909
  if (uvalue == 134ULL) {
#line 1909
    goto case_134;
  }
#line 1911
  goto switch_default___4;
  case_0___0: /* CIL Label */ 
  {
#line 1884
  printf((char const   */* __restrict  */)"(void)");
  }
#line 1884
  goto switch_break___5;
  case_1___3: /* CIL Label */ 
  {
#line 1885
  printf((char const   */* __restrict  */)"(machine address)");
  }
#line 1885
  goto switch_break___5;
  case_2___2: /* CIL Label */ 
  {
#line 1886
  printf((char const   */* __restrict  */)"(boolean)");
  }
#line 1886
  goto switch_break___5;
  case_3___2: /* CIL Label */ 
  {
#line 1887
  printf((char const   */* __restrict  */)"(complex float)");
  }
#line 1887
  goto switch_break___5;
  case_4___1: /* CIL Label */ 
  {
#line 1888
  printf((char const   */* __restrict  */)"(float)");
  }
#line 1888
  goto switch_break___5;
  case_5___2: /* CIL Label */ 
  {
#line 1889
  printf((char const   */* __restrict  */)"(signed)");
  }
#line 1889
  goto switch_break___5;
  case_6___2: /* CIL Label */ 
  {
#line 1890
  printf((char const   */* __restrict  */)"(signed char)");
  }
#line 1890
  goto switch_break___5;
  case_7___1: /* CIL Label */ 
  {
#line 1891
  printf((char const   */* __restrict  */)"(unsigned)");
  }
#line 1891
  goto switch_break___5;
  case_8___1: /* CIL Label */ 
  {
#line 1892
  printf((char const   */* __restrict  */)"(unsigned char)");
  }
#line 1892
  goto switch_break___5;
  case_9___1: /* CIL Label */ 
  {
#line 1894
  printf((char const   */* __restrict  */)"(imaginary float)");
  }
#line 1894
  goto switch_break___5;
  case_15___2: /* CIL Label */ 
  {
#line 1895
  printf((char const   */* __restrict  */)"(decimal float)");
  }
#line 1895
  goto switch_break___5;
  case_10___1: /* CIL Label */ 
  {
#line 1897
  printf((char const   */* __restrict  */)"(packed_decimal)");
  }
#line 1897
  goto switch_break___5;
  case_11___2: /* CIL Label */ 
  {
#line 1898
  printf((char const   */* __restrict  */)"(numeric_string)");
  }
#line 1898
  goto switch_break___5;
  case_12___2: /* CIL Label */ 
  {
#line 1899
  printf((char const   */* __restrict  */)"(edited)");
  }
#line 1899
  goto switch_break___5;
  case_13___2: /* CIL Label */ 
  {
#line 1900
  printf((char const   */* __restrict  */)"(signed_fixed)");
  }
#line 1900
  goto switch_break___5;
  case_14___2: /* CIL Label */ 
  {
#line 1901
  printf((char const   */* __restrict  */)"(unsigned_fixed)");
  }
#line 1901
  goto switch_break___5;
  case_128: /* CIL Label */ 
  {
#line 1903
  printf((char const   */* __restrict  */)"(HP_float80)");
  }
#line 1903
  goto switch_break___5;
  case_129: /* CIL Label */ 
  {
#line 1904
  printf((char const   */* __restrict  */)"(HP_complex_float80)");
  }
#line 1904
  goto switch_break___5;
  case_130: /* CIL Label */ 
  {
#line 1905
  printf((char const   */* __restrict  */)"(HP_float128)");
  }
#line 1905
  goto switch_break___5;
  case_131: /* CIL Label */ 
  {
#line 1906
  printf((char const   */* __restrict  */)"(HP_complex_float128)");
  }
#line 1906
  goto switch_break___5;
  case_132: /* CIL Label */ 
  {
#line 1907
  printf((char const   */* __restrict  */)"(HP_floathpintel)");
  }
#line 1907
  goto switch_break___5;
  case_133: /* CIL Label */ 
  {
#line 1908
  printf((char const   */* __restrict  */)"(HP_imaginary_float80)");
  }
#line 1908
  goto switch_break___5;
  case_134: /* CIL Label */ 
  {
#line 1909
  printf((char const   */* __restrict  */)"(HP_imaginary_float128)");
  }
#line 1909
  goto switch_break___5;
  switch_default___4: /* CIL Label */ 
#line 1912
  if (uvalue >= 128ULL) {
#line 1912
    if (uvalue <= 255ULL) {
      {
#line 1914
      tmp___51 = gettext("(user defined type)");
#line 1914
      printf((char const   */* __restrict  */)tmp___51);
      }
    } else {
      {
#line 1916
      tmp___52 = gettext("(unknown type)");
#line 1916
      printf((char const   */* __restrict  */)tmp___52);
      }
    }
  } else {
    {
#line 1916
    tmp___52 = gettext("(unknown type)");
#line 1916
    printf((char const   */* __restrict  */)tmp___52);
    }
  }
#line 1917
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1919
  goto switch_break___2;
  case_50: /* CIL Label */ 
  {
#line 1924
  if (uvalue == 1ULL) {
#line 1924
    goto case_1___4;
  }
#line 1925
  if (uvalue == 2ULL) {
#line 1925
    goto case_2___3;
  }
#line 1926
  if (uvalue == 3ULL) {
#line 1926
    goto case_3___3;
  }
#line 1927
  goto switch_default___5;
  case_1___4: /* CIL Label */ 
  {
#line 1924
  printf((char const   */* __restrict  */)"(public)");
  }
#line 1924
  goto switch_break___6;
  case_2___3: /* CIL Label */ 
  {
#line 1925
  printf((char const   */* __restrict  */)"(protected)");
  }
#line 1925
  goto switch_break___6;
  case_3___3: /* CIL Label */ 
  {
#line 1926
  printf((char const   */* __restrict  */)"(private)");
  }
#line 1926
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 1928
  tmp___53 = gettext("(unknown accessibility)");
#line 1928
  printf((char const   */* __restrict  */)tmp___53);
  }
#line 1929
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 1931
  goto switch_break___2;
  case_23___1: /* CIL Label */ 
  {
#line 1936
  if (uvalue == 1ULL) {
#line 1936
    goto case_1___5;
  }
#line 1937
  if (uvalue == 2ULL) {
#line 1937
    goto case_2___4;
  }
#line 1938
  if (uvalue == 3ULL) {
#line 1938
    goto case_3___4;
  }
#line 1939
  goto switch_default___6;
  case_1___5: /* CIL Label */ 
  {
#line 1936
  printf((char const   */* __restrict  */)"(local)");
  }
#line 1936
  goto switch_break___7;
  case_2___4: /* CIL Label */ 
  {
#line 1937
  printf((char const   */* __restrict  */)"(exported)");
  }
#line 1937
  goto switch_break___7;
  case_3___4: /* CIL Label */ 
  {
#line 1938
  printf((char const   */* __restrict  */)"(qualified)");
  }
#line 1938
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 1939
  tmp___54 = gettext("(unknown visibility)");
#line 1939
  printf((char const   */* __restrict  */)tmp___54);
  }
#line 1939
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 1941
  goto switch_break___2;
  case_76: /* CIL Label */ 
  {
#line 1946
  if (uvalue == 0ULL) {
#line 1946
    goto case_0___1;
  }
#line 1947
  if (uvalue == 1ULL) {
#line 1947
    goto case_1___6;
  }
#line 1948
  if (uvalue == 2ULL) {
#line 1948
    goto case_2___5;
  }
#line 1949
  goto switch_default___7;
  case_0___1: /* CIL Label */ 
  {
#line 1946
  printf((char const   */* __restrict  */)"(none)");
  }
#line 1946
  goto switch_break___8;
  case_1___6: /* CIL Label */ 
  {
#line 1947
  printf((char const   */* __restrict  */)"(virtual)");
  }
#line 1947
  goto switch_break___8;
  case_2___5: /* CIL Label */ 
  {
#line 1948
  printf((char const   */* __restrict  */)"(pure_virtual)");
  }
#line 1948
  goto switch_break___8;
  switch_default___7: /* CIL Label */ 
  {
#line 1949
  tmp___55 = gettext("(unknown virtuality)");
#line 1949
  printf((char const   */* __restrict  */)tmp___55);
  }
#line 1949
  goto switch_break___8;
  switch_break___8: /* CIL Label */ ;
  }
#line 1951
  goto switch_break___2;
  case_66: /* CIL Label */ 
  {
#line 1956
  if (uvalue == 0ULL) {
#line 1956
    goto case_0___2;
  }
#line 1957
  if (uvalue == 1ULL) {
#line 1957
    goto case_1___7;
  }
#line 1958
  if (uvalue == 2ULL) {
#line 1958
    goto case_2___6;
  }
#line 1959
  if (uvalue == 3ULL) {
#line 1959
    goto case_3___5;
  }
#line 1960
  goto switch_default___8;
  case_0___2: /* CIL Label */ 
  {
#line 1956
  printf((char const   */* __restrict  */)"(case_sensitive)");
  }
#line 1956
  goto switch_break___9;
  case_1___7: /* CIL Label */ 
  {
#line 1957
  printf((char const   */* __restrict  */)"(up_case)");
  }
#line 1957
  goto switch_break___9;
  case_2___6: /* CIL Label */ 
  {
#line 1958
  printf((char const   */* __restrict  */)"(down_case)");
  }
#line 1958
  goto switch_break___9;
  case_3___5: /* CIL Label */ 
  {
#line 1959
  printf((char const   */* __restrict  */)"(case_insensitive)");
  }
#line 1959
  goto switch_break___9;
  switch_default___8: /* CIL Label */ 
  {
#line 1960
  tmp___56 = gettext("(unknown case)");
#line 1960
  printf((char const   */* __restrict  */)tmp___56);
  }
#line 1960
  goto switch_break___9;
  switch_break___9: /* CIL Label */ ;
  }
#line 1962
  goto switch_break___2;
  case_54: /* CIL Label */ 
  {
#line 1967
  if (uvalue == 1ULL) {
#line 1967
    goto case_1___8;
  }
#line 1968
  if (uvalue == 2ULL) {
#line 1968
    goto case_2___7;
  }
#line 1969
  if (uvalue == 3ULL) {
#line 1969
    goto case_3___6;
  }
#line 1970
  goto switch_default___9;
  case_1___8: /* CIL Label */ 
  {
#line 1967
  printf((char const   */* __restrict  */)"(normal)");
  }
#line 1967
  goto switch_break___10;
  case_2___7: /* CIL Label */ 
  {
#line 1968
  printf((char const   */* __restrict  */)"(program)");
  }
#line 1968
  goto switch_break___10;
  case_3___6: /* CIL Label */ 
  {
#line 1969
  printf((char const   */* __restrict  */)"(nocall)");
  }
#line 1969
  goto switch_break___10;
  switch_default___9: /* CIL Label */ 
#line 1971
  if (uvalue >= 64ULL) {
#line 1971
    if (uvalue <= 255ULL) {
      {
#line 1973
      tmp___57 = gettext("(user defined)");
#line 1973
      printf((char const   */* __restrict  */)tmp___57);
      }
    } else {
      {
#line 1975
      tmp___58 = gettext("(unknown convention)");
#line 1975
      printf((char const   */* __restrict  */)tmp___58);
      }
    }
  } else {
    {
#line 1975
    tmp___58 = gettext("(unknown convention)");
#line 1975
    printf((char const   */* __restrict  */)tmp___58);
    }
  }
  switch_break___10: /* CIL Label */ ;
  }
#line 1977
  goto switch_break___2;
  case_9___2: /* CIL Label */ 
  {
#line 1982
  if (uvalue == 0xffffffffffffffffULL) {
#line 1982
    goto case_18446744073709551615;
  }
#line 1983
  if (uvalue == 0ULL) {
#line 1983
    goto case_0___3;
  }
#line 1984
  if (uvalue == 1ULL) {
#line 1984
    goto case_1___9;
  }
#line 1980
  goto switch_break___11;
  case_18446744073709551615: /* CIL Label */ 
  {
#line 1982
  tmp___59 = gettext("(undefined)");
#line 1982
  printf((char const   */* __restrict  */)tmp___59);
  }
#line 1982
  goto switch_break___11;
  case_0___3: /* CIL Label */ 
  {
#line 1983
  printf((char const   */* __restrict  */)"(row major)");
  }
#line 1983
  goto switch_break___11;
  case_1___9: /* CIL Label */ 
  {
#line 1984
  printf((char const   */* __restrict  */)"(column major)");
  }
#line 1984
  goto switch_break___11;
  switch_break___11: /* CIL Label */ ;
  }
#line 1986
  goto switch_break___2;
  case_64___0: /* CIL Label */ 
#line 1989
  have_frame_base = 1;
  case_8468___0: /* CIL Label */ 
  case_8467___0: /* CIL Label */ 
  case_8466___0: /* CIL Label */ 
  case_8465___0: /* CIL Label */ 
  case_74___0: /* CIL Label */ 
  case_72___0: /* CIL Label */ 
  case_70___0: /* CIL Label */ 
  case_77___0: /* CIL Label */ 
  case_56___0: /* CIL Label */ 
  case_42___0: /* CIL Label */ 
  case_25___2: /* CIL Label */ 
  case_2___8: /* CIL Label */ 
#line 2002
  if (dwarf_version < 4) {
#line 2002
    if (form == 6UL) {
      {
#line 2005
      tmp___60 = gettext("(location list)");
#line 2005
      printf((char const   */* __restrict  */)tmp___60);
      }
    } else
#line 2002
    if (form == 7UL) {
      {
#line 2005
      tmp___60 = gettext("(location list)");
#line 2005
      printf((char const   */* __restrict  */)tmp___60);
      }
    } else {
#line 2002
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2002
  if (form == 23UL) {
    {
#line 2005
    tmp___60 = gettext("(location list)");
#line 2005
    printf((char const   */* __restrict  */)tmp___60);
    }
  }
  case_34: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
#line 2013
  if (block_start) {
    {
#line 2017
    printf((char const   */* __restrict  */)"(");
#line 2018
    need_frame_base = decode_location_expression(block_start, (unsigned int )pointer_size,
                                                 (unsigned int )offset_size, dwarf_version,
                                                 uvalue, cu_offset, section);
#line 2024
    printf((char const   */* __restrict  */)")");
    }
#line 2025
    if (need_frame_base) {
#line 2025
      if (! have_frame_base) {
        {
#line 2026
        tmp___61 = gettext(" [without DW_AT_frame_base]");
#line 2026
        printf((char const   */* __restrict  */)tmp___61);
        }
      }
    }
  }
#line 2028
  goto switch_break___2;
  case_24___0: /* CIL Label */ 
#line 2032
  if (form == 32UL) {
#line 2034
    goto switch_break___2;
  } else
#line 2032
  if (form == 7968UL) {
#line 2034
    goto switch_break___2;
  }
#line 2036
  if (form == 17UL) {
#line 2040
    uvalue += cu_offset;
  } else
#line 2036
  if (form == 18UL) {
#line 2040
    uvalue += cu_offset;
  } else
#line 2036
  if (form == 19UL) {
#line 2040
    uvalue += cu_offset;
  } else
#line 2036
  if (form == 21UL) {
#line 2040
    uvalue += cu_offset;
  }
#line 2042
  if (uvalue >= section->size) {
    {
#line 2043
    tmp___62 = dwarf_vmatoa("x", uvalue);
#line 2043
    tmp___63 = gettext("Offset %s used as value for DW_AT_import attribute of DIE at offset %lx is too big.\n");
#line 2043
    warn((char const   *)tmp___63, tmp___62, (unsigned long )(orig_data - section->start));
    }
  } else {
    {
#line 2051
    tmp___64 = read_uleb128(section->start + uvalue, (unsigned int *)((void *)0),
                            (unsigned char const   */* const  */)end);
#line 2051
    abbrev_number = (unsigned long )tmp___64;
#line 2053
    tmp___65 = gettext("[Abbrev Number: %ld");
#line 2053
    printf((char const   */* __restrict  */)tmp___65, abbrev_number);
    }
#line 2057
    if (form != 16UL) {
#line 2059
      entry = first_abbrev;
      {
#line 2059
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 2059
        if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 2059
          goto while_break___19;
        }
#line 2060
        if (entry->entry == abbrev_number) {
#line 2061
          goto while_break___19;
        }
#line 2059
        entry = entry->next;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 2062
      if ((unsigned long )entry != (unsigned long )((void *)0)) {
        {
#line 2063
        tmp___66 = get_TAG_name(entry->tag);
#line 2063
        printf((char const   */* __restrict  */)" (%s)", tmp___66);
        }
      }
    }
    {
#line 2065
    printf((char const   */* __restrict  */)"]");
    }
  }
#line 2068
  goto switch_break___2;
  switch_default___10: /* CIL Label */ 
#line 2071
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 2074
  return (data);
}
}
#line 2093 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char buffer___1[100]  ;
#line 2077 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *get_AT_name(unsigned long attribute ) 
{ 
  char const   *name___0 ;
  char *tmp___0 ;

  {
#line 2082
  if (attribute == 0UL) {
#line 2083
    return ("DW_AT value: 0");
  }
#line 2086
  if (attribute == 8193UL) {
#line 2087
    return ("DW_AT_MIPS_fde or DW_AT_HP_unmodifiable");
  }
  {
#line 2089
  name___0 = get_DW_AT_name((unsigned int )attribute);
  }
#line 2091
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 2095
    tmp___0 = gettext("Unknown AT value: %lx");
#line 2095
    snprintf((char */* __restrict  */)(buffer___1), sizeof(buffer___1), (char const   */* __restrict  */)tmp___0,
             attribute);
    }
#line 2097
    return ((char const   *)(buffer___1));
  }
#line 2100
  return (name___0);
}
}
#line 2103 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *read_and_display_attr(unsigned long attribute , unsigned long form ,
                                            unsigned char *data , unsigned char *end ,
                                            dwarf_vma cu_offset , dwarf_vma pointer_size ,
                                            dwarf_vma offset_size , int dwarf_version ,
                                            debug_info *debug_info_p , int do_loc ,
                                            struct dwarf_section *section , struct cu_tu_set *this_set ) 
{ 
  char const   *tmp___0 ;

  {
#line 2117
  if (! do_loc) {
    {
#line 2118
    tmp___0 = get_AT_name(attribute);
#line 2118
    printf((char const   */* __restrict  */)"   %-18s:", tmp___0);
    }
  }
  {
#line 2119
  data = read_and_display_attr_value(attribute, form, data, end, cu_offset, pointer_size,
                                     offset_size, dwarf_version, debug_info_p, do_loc,
                                     section, this_set);
  }
#line 2123
  if (! do_loc) {
    {
#line 2124
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2125
  return (data);
}
}
#line 2425
static int process_debug_info(struct dwarf_section *section , void *file , enum dwarf_section_display_enum abbrev_sec ,
                              int do_loc , int do_types ) ;
#line 2425 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int num_bogus_warns  =    0U;
#line 2133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int process_debug_info(struct dwarf_section *section , void *file , enum dwarf_section_display_enum abbrev_sec ,
                              int do_loc , int do_types ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *section_begin ;
  unsigned int unit ;
  unsigned int num_units ;
  dwarf_vma length ;
  unsigned int amount ;
  unsigned int amount___0 ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  DWARF2_Internal_CompUnit compunit ;
  unsigned char *hdrptr ;
  unsigned char *tags ;
  int level ;
  int last_level ;
  int saved_level ;
  dwarf_vma cu_offset ;
  unsigned int offset_size ;
  int initial_length_size ;
  dwarf_vma signature_high ;
  dwarf_vma signature_low ;
  dwarf_vma type_offset ;
  struct cu_tu_set *this_set ;
  dwarf_vma abbrev_base ;
  size_t abbrev_size ;
  unsigned int amount___1 ;
  unsigned int amount___2 ;
  unsigned int amount___3 ;
  elf_vma tmp___9 ;
  int tmp___10 ;
  int *dummy___4  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___4 ;
  void *tmp___11 ;
  unsigned int amount___4 ;
  unsigned int amount___5 ;
  elf_vma tmp___12 ;
  int tmp___13 ;
  int *dummy___6  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___6 ;
  void *tmp___14 ;
  unsigned int amount___6 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char buf___7[64] ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  dwarf_vma *offsets ;
  size_t *sizes ;
  char *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char *tmp___43 ;
  char const   *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  unsigned int bytes_read ;
  unsigned long abbrev_number ;
  unsigned long die_offset ;
  abbrev_entry *entry ;
  abbrev_attr *attr ;
  int do_printing ;
  dwarf_vma tmp___47 ;
  unsigned char *chk ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char const   *tmp___55 ;
  debug_info *arg ;
  int tmp___56 ;

  {
#line 2140
  start = section->start;
#line 2141
  end = start + section->size;
#line 2144
  num_units = 0U;
#line 2146
  if (do_loc) {
#line 2146
    goto _L;
  } else
#line 2146
  if (do_debug_loc) {
#line 2146
    goto _L;
  } else
#line 2146
  if (do_debug_ranges) {
    _L: /* CIL Label */ 
#line 2146
    if (num_debug_info_entries == 0U) {
#line 2146
      if (! do_types) {
#line 2153
        section_begin = start;
#line 2153
        num_units = 0U;
        {
#line 2153
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2153
          if (! ((unsigned long )section_begin < (unsigned long )end)) {
#line 2153
            goto while_break;
          }
          {
#line 2159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2159
            amount = 4U;
#line 2159
            if ((unsigned long )(section_begin + amount) >= (unsigned long )end) {
#line 2159
              if ((unsigned long )section_begin < (unsigned long )end) {
#line 2159
                amount = (unsigned int )(end - section_begin);
              } else {
#line 2159
                amount = 0U;
              }
            }
#line 2159
            if (amount) {
              {
#line 2159
              length = (*byte_get)(section_begin, (int )amount);
              }
            } else {
#line 2159
              length = (dwarf_vma )0;
            }
#line 2159
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2161
          if (length == 4294967295ULL) {
            {
#line 2163
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2163
              amount___0 = 8U;
#line 2163
              if ((unsigned long )((section_begin + 4) + amount___0) >= (unsigned long )end) {
#line 2163
                if ((unsigned long )(section_begin + 4) < (unsigned long )end) {
#line 2163
                  amount___0 = (unsigned int )(end - (section_begin + 4));
                } else {
#line 2163
                  amount___0 = 0U;
                }
              }
#line 2163
              if (amount___0) {
                {
#line 2163
                length = (*byte_get)(section_begin + 4, (int )amount___0);
                }
              } else {
#line 2163
                length = (dwarf_vma )0;
              }
#line 2163
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 2164
            section_begin += length + 12ULL;
          } else
#line 2166
          if (length >= 4294967280ULL) {
#line 2166
            if (length < 4294967295ULL) {
              {
#line 2168
              tmp___0 = dwarf_vmatoa("x", length);
#line 2168
              tmp___1 = gettext("Reserved length value (0x%s) found in section %s\n");
#line 2168
              warn((char const   *)tmp___1, tmp___0, section->name);
              }
#line 2170
              return (0);
            } else {
#line 2173
              section_begin += length + 4ULL;
            }
          } else {
#line 2173
            section_begin += length + 4ULL;
          }
#line 2178
          if ((long )length <= 0L) {
            {
#line 2180
            tmp___2 = dwarf_vmatoa("x", length);
#line 2180
            tmp___3 = gettext("Corrupt unit length (0x%s) found in section %s\n");
#line 2180
            warn((char const   *)tmp___3, tmp___2, section->name);
            }
#line 2182
            return (0);
          }
#line 2153
          num_units ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 2186
        if (num_units == 0U) {
          {
#line 2188
          tmp___4 = gettext("No comp units in %s section ?");
#line 2188
          error((char const   *)tmp___4, section->name);
          }
#line 2189
          return (0);
        }
        {
#line 2193
        tmp___5 = cmalloc((size_t )num_units, sizeof(*debug_information));
#line 2193
        debug_information = (debug_info *)tmp___5;
        }
#line 2195
        if ((unsigned long )debug_information == (unsigned long )((void *)0)) {
          {
#line 2197
          tmp___6 = gettext("Not enough memory for a debug info array of %u entries");
#line 2197
          error((char const   *)tmp___6, num_units);
          }
#line 2199
          return (0);
        }
      }
    }
  }
#line 2203
  if (! do_loc) {
#line 2205
    if (dwarf_start_die == 0UL) {
      {
#line 2206
      tmp___7 = gettext("Contents of the %s section:\n\n");
#line 2206
      printf((char const   */* __restrict  */)tmp___7, section->name);
      }
    }
    {
#line 2208
    load_debug_section((enum dwarf_section_display_enum )9, file);
#line 2209
    load_debug_section((enum dwarf_section_display_enum )28, file);
#line 2210
    load_debug_section((enum dwarf_section_display_enum )29, file);
#line 2211
    load_debug_section((enum dwarf_section_display_enum )30, file);
#line 2212
    load_debug_section((enum dwarf_section_display_enum )31, file);
    }
  }
  {
#line 2215
  load_debug_section(abbrev_sec, file);
  }
#line 2216
  if ((unsigned long )debug_displays[abbrev_sec].section.start == (unsigned long )((void *)0)) {
    {
#line 2218
    tmp___8 = gettext("Unable to locate %s section!\n");
#line 2218
    warn((char const   *)tmp___8, debug_displays[abbrev_sec].section.name);
    }
#line 2220
    return (0);
  }
#line 2223
  section_begin = start;
#line 2223
  unit = 0U;
  {
#line 2223
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2223
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 2223
      goto while_break___2;
    }
#line 2232
    signature_high = (dwarf_vma )0;
#line 2233
    signature_low = (dwarf_vma )0;
#line 2234
    type_offset = (dwarf_vma )0;
#line 2239
    hdrptr = start;
    {
#line 2241
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 2241
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2241
        amount___1 = 4U;
#line 2241
        if ((unsigned long )(hdrptr + amount___1) >= (unsigned long )end) {
#line 2241
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2241
            amount___1 = (unsigned int )(end - hdrptr);
          } else {
#line 2241
            amount___1 = 0U;
          }
        }
#line 2241
        if (amount___1) {
          {
#line 2241
          compunit.cu_length = (*byte_get)(hdrptr, (int )amount___1);
          }
        } else {
#line 2241
          compunit.cu_length = (dwarf_vma )0;
        }
#line 2241
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2241
      hdrptr += 4;
#line 2241
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2243
    if (compunit.cu_length == 4294967295ULL) {
      {
#line 2245
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2245
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2245
          amount___2 = 8U;
#line 2245
          if ((unsigned long )(hdrptr + amount___2) >= (unsigned long )end) {
#line 2245
            if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2245
              amount___2 = (unsigned int )(end - hdrptr);
            } else {
#line 2245
              amount___2 = 0U;
            }
          }
#line 2245
          if (amount___2) {
            {
#line 2245
            compunit.cu_length = (*byte_get)(hdrptr, (int )amount___2);
            }
          } else {
#line 2245
            compunit.cu_length = (dwarf_vma )0;
          }
#line 2245
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2245
        hdrptr += 8;
#line 2245
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2246
      offset_size = 8U;
#line 2247
      initial_length_size = 12;
    } else {
#line 2251
      offset_size = 4U;
#line 2252
      initial_length_size = 4;
    }
    {
#line 2255
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 2255
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2255
        amount___3 = 2U;
#line 2255
        if ((unsigned long )(hdrptr + amount___3) >= (unsigned long )end) {
#line 2255
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2255
            amount___3 = (unsigned int )(end - hdrptr);
          } else {
#line 2255
            amount___3 = 0U;
          }
        }
#line 2255
        if (amount___3) {
          {
#line 2255
          tmp___9 = (*byte_get)(hdrptr, (int )amount___3);
#line 2255
          compunit.cu_version = (unsigned short )tmp___9;
          }
        } else {
#line 2255
          compunit.cu_version = (unsigned short)0;
        }
#line 2255
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2255
      hdrptr += 2;
#line 2255
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2257
    cu_offset = (dwarf_vma )(start - section_begin);
#line 2259
    this_set = find_cu_tu_set_v2(cu_offset, do_types);
    }
    {
#line 2261
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 2261
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2261
        if (8UL < (unsigned long )offset_size) {
#line 2261
          tmp___10 = -1;
        } else {
#line 2261
          tmp___10 = 1;
        }
        {
#line 2261
        __lengthofdummy___4 = (unsigned long )tmp___10;
#line 2261
        tmp___11 = __builtin_alloca(sizeof(*dummy___4) * __lengthofdummy___4);
#line 2261
        dummy___4 = (int *)tmp___11;
#line 2261
        amount___4 = offset_size;
        }
#line 2261
        if ((unsigned long )(hdrptr + amount___4) >= (unsigned long )end) {
#line 2261
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2261
            amount___4 = (unsigned int )(end - hdrptr);
          } else {
#line 2261
            amount___4 = 0U;
          }
        }
#line 2261
        if (amount___4) {
          {
#line 2261
          compunit.cu_abbrev_offset = (*byte_get)(hdrptr, (int )amount___4);
          }
        } else {
#line 2261
          compunit.cu_abbrev_offset = (dwarf_vma )0;
        }
#line 2261
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2261
      hdrptr += offset_size;
#line 2261
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2263
    if ((unsigned long )this_set == (unsigned long )((void *)0)) {
#line 2265
      abbrev_base = (dwarf_vma )0;
#line 2266
      abbrev_size = (size_t )debug_displays[abbrev_sec].section.size;
    } else {
#line 2270
      abbrev_base = this_set->section_offsets[3];
#line 2271
      abbrev_size = this_set->section_sizes[3];
    }
    {
#line 2274
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 2274
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 2274
        amount___5 = 1U;
#line 2274
        if ((unsigned long )(hdrptr + amount___5) >= (unsigned long )end) {
#line 2274
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2274
            amount___5 = (unsigned int )(end - hdrptr);
          } else {
#line 2274
            amount___5 = 0U;
          }
        }
#line 2274
        if (amount___5) {
          {
#line 2274
          tmp___12 = (*byte_get)(hdrptr, (int )amount___5);
#line 2274
          compunit.cu_pointer_size = (unsigned char )tmp___12;
          }
        } else {
#line 2274
          compunit.cu_pointer_size = (unsigned char)0;
        }
#line 2274
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 2274
      hdrptr ++;
#line 2274
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2276
    if (do_types) {
      {
#line 2278
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2278
        if ((unsigned long )(hdrptr + 8) <= (unsigned long )end) {
          {
#line 2278
          byte_get_64(hdrptr, & signature_high, & signature_low);
          }
        } else {
#line 2278
          signature_high = (dwarf_vma )0;
#line 2278
          signature_low = signature_high;
        }
#line 2278
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2279
      hdrptr += 8;
      {
#line 2280
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 2280
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2280
          if (8UL < (unsigned long )offset_size) {
#line 2280
            tmp___13 = -1;
          } else {
#line 2280
            tmp___13 = 1;
          }
          {
#line 2280
          __lengthofdummy___6 = (unsigned long )tmp___13;
#line 2280
          tmp___14 = __builtin_alloca(sizeof(*dummy___6) * __lengthofdummy___6);
#line 2280
          dummy___6 = (int *)tmp___14;
#line 2280
          amount___6 = offset_size;
          }
#line 2280
          if ((unsigned long )(hdrptr + amount___6) >= (unsigned long )end) {
#line 2280
            if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2280
              amount___6 = (unsigned int )(end - hdrptr);
            } else {
#line 2280
              amount___6 = 0U;
            }
          }
#line 2280
          if (amount___6) {
            {
#line 2280
            type_offset = (*byte_get)(hdrptr, (int )amount___6);
            }
          } else {
#line 2280
            type_offset = (dwarf_vma )0;
          }
#line 2280
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 2280
        hdrptr += offset_size;
#line 2280
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 2283
    if (do_loc) {
#line 2283
      goto _L___0;
    } else
#line 2283
    if (do_debug_loc) {
#line 2283
      goto _L___0;
    } else
#line 2283
    if (do_debug_ranges) {
      _L___0: /* CIL Label */ 
#line 2283
      if (num_debug_info_entries == 0U) {
#line 2283
        if (! do_types) {
#line 2287
          (debug_information + unit)->cu_offset = cu_offset;
#line 2288
          (debug_information + unit)->pointer_size = (unsigned int )compunit.cu_pointer_size;
#line 2290
          (debug_information + unit)->offset_size = offset_size;
#line 2291
          (debug_information + unit)->dwarf_version = (int )compunit.cu_version;
#line 2292
          (debug_information + unit)->base_address = (dwarf_vma )0;
#line 2293
          (debug_information + unit)->addr_base = (dwarf_vma )4294967295U;
#line 2294
          (debug_information + unit)->ranges_base = (dwarf_vma )4294967295U;
#line 2295
          (debug_information + unit)->loc_offsets = (dwarf_vma *)((void *)0);
#line 2296
          (debug_information + unit)->have_frame_base = (int *)((void *)0);
#line 2297
          (debug_information + unit)->max_loc_offsets = 0U;
#line 2298
          (debug_information + unit)->num_loc_offsets = 0U;
#line 2299
          (debug_information + unit)->range_lists = (dwarf_vma *)((void *)0);
#line 2300
          (debug_information + unit)->max_range_lists = 0U;
#line 2301
          (debug_information + unit)->num_range_lists = 0U;
        }
      }
    }
#line 2304
    if (! do_loc) {
#line 2304
      if (dwarf_start_die == 0UL) {
        {
#line 2306
        tmp___15 = dwarf_vmatoa("x", cu_offset);
#line 2306
        tmp___16 = gettext("  Compilation Unit @ offset 0x%s:\n");
#line 2306
        printf((char const   */* __restrict  */)tmp___16, tmp___15);
        }
#line 2308
        if (offset_size == 8U) {
#line 2308
          tmp___17 = "64-bit";
        } else {
#line 2308
          tmp___17 = "32-bit";
        }
        {
#line 2308
        tmp___18 = dwarf_vmatoa("x", compunit.cu_length);
#line 2308
        tmp___19 = gettext("   Length:        0x%s (%s)\n");
#line 2308
        printf((char const   */* __restrict  */)tmp___19, tmp___18, tmp___17);
#line 2311
        tmp___20 = gettext("   Version:       %d\n");
#line 2311
        printf((char const   */* __restrict  */)tmp___20, (int )compunit.cu_version);
#line 2312
        tmp___21 = dwarf_vmatoa("x", compunit.cu_abbrev_offset);
#line 2312
        tmp___22 = gettext("   Abbrev Offset: 0x%s\n");
#line 2312
        printf((char const   */* __restrict  */)tmp___22, tmp___21);
#line 2314
        tmp___23 = gettext("   Pointer Size:  %d\n");
#line 2314
        printf((char const   */* __restrict  */)tmp___23, (int )compunit.cu_pointer_size);
        }
#line 2315
        if (do_types) {
          {
#line 2319
          tmp___24 = dwarf_vmatoa64(signature_high, signature_low, buf___7, (unsigned int )sizeof(buf___7));
#line 2319
          tmp___25 = gettext("   Signature:     0x%s\n");
#line 2319
          printf((char const   */* __restrict  */)tmp___25, tmp___24);
#line 2322
          tmp___26 = dwarf_vmatoa("x", type_offset);
#line 2322
          tmp___27 = gettext("   Type Offset:   0x%s\n");
#line 2322
          printf((char const   */* __restrict  */)tmp___27, tmp___26);
          }
        }
#line 2325
        if ((unsigned long )this_set != (unsigned long )((void *)0)) {
          {
#line 2327
          offsets = this_set->section_offsets;
#line 2328
          sizes = this_set->section_sizes;
#line 2330
          tmp___28 = gettext("   Section contributions:\n");
#line 2330
          printf((char const   */* __restrict  */)tmp___28);
#line 2331
          tmp___29 = dwarf_vmatoa("x", (dwarf_vma )*(sizes + 3));
#line 2331
          tmp___30 = dwarf_vmatoa("x", *(offsets + 3));
#line 2331
          tmp___31 = gettext("    .debug_abbrev.dwo:       0x%s  0x%s\n");
#line 2331
          printf((char const   */* __restrict  */)tmp___31, tmp___30, tmp___29);
#line 2334
          tmp___32 = dwarf_vmatoa("x", (dwarf_vma )*(sizes + 4));
#line 2334
          tmp___33 = dwarf_vmatoa("x", *(offsets + 4));
#line 2334
          tmp___34 = gettext("    .debug_line.dwo:         0x%s  0x%s\n");
#line 2334
          printf((char const   */* __restrict  */)tmp___34, tmp___33, tmp___32);
#line 2337
          tmp___35 = dwarf_vmatoa("x", (dwarf_vma )*(sizes + 5));
#line 2337
          tmp___36 = dwarf_vmatoa("x", *(offsets + 5));
#line 2337
          tmp___37 = gettext("    .debug_loc.dwo:          0x%s  0x%s\n");
#line 2337
          printf((char const   */* __restrict  */)tmp___37, tmp___36, tmp___35);
#line 2340
          tmp___38 = dwarf_vmatoa("x", (dwarf_vma )*(sizes + 6));
#line 2340
          tmp___39 = dwarf_vmatoa("x", *(offsets + 6));
#line 2340
          tmp___40 = gettext("    .debug_str_offsets.dwo:  0x%s  0x%s\n");
#line 2340
          printf((char const   */* __restrict  */)tmp___40, tmp___39, tmp___38);
          }
        }
      }
    }
#line 2346
    if ((cu_offset + compunit.cu_length) + (dwarf_vma )initial_length_size > section->size) {
      {
#line 2349
      tmp___41 = dwarf_vmatoa("x", compunit.cu_length);
#line 2349
      tmp___42 = dwarf_vmatoa("x", cu_offset);
#line 2349
      tmp___43 = gettext("Debug info is corrupted, length of CU at %s extends beyond end of section (length = %s)\n");
#line 2349
      warn((char const   *)tmp___43, tmp___42, tmp___41);
      }
#line 2353
      goto while_break___2;
    }
#line 2355
    tags = hdrptr;
#line 2356
    start += compunit.cu_length + (dwarf_vma )initial_length_size;
#line 2358
    if ((int )compunit.cu_version != 2) {
#line 2358
      if ((int )compunit.cu_version != 3) {
#line 2358
        if ((int )compunit.cu_version != 4) {
          {
#line 2362
          tmp___44 = dwarf_vmatoa("x", cu_offset);
#line 2362
          tmp___45 = gettext("CU at offset %s contains corrupt or unsupported version number: %d.\n");
#line 2362
          warn((char const   *)tmp___45, tmp___44, (int )compunit.cu_version);
          }
#line 2365
          goto __Cont;
        }
      }
    }
    {
#line 2368
    free_abbrevs();
    }
#line 2372
    if (compunit.cu_abbrev_offset >= (dwarf_vma )abbrev_size) {
      {
#line 2373
      tmp___46 = gettext("Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n");
#line 2373
      warn((char const   *)tmp___46, (unsigned long )compunit.cu_abbrev_offset, abbrev_size);
      }
    } else {
      {
#line 2377
      process_abbrev_section((debug_displays[abbrev_sec].section.start + abbrev_base) + compunit.cu_abbrev_offset,
                             (debug_displays[abbrev_sec].section.start + abbrev_base) + abbrev_size);
      }
    }
#line 2383
    level = 0;
#line 2384
    last_level = level;
#line 2385
    saved_level = -1;
    {
#line 2386
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 2386
      if (! ((unsigned long )tags < (unsigned long )start)) {
#line 2386
        goto while_break___16;
      }
      {
#line 2393
      do_printing = 1;
#line 2395
      die_offset = (unsigned long )(tags - section_begin);
#line 2397
      tmp___47 = read_uleb128(tags, & bytes_read, (unsigned char const   */* const  */)start);
#line 2397
      abbrev_number = (unsigned long )tmp___47;
#line 2398
      tags += bytes_read;
      }
#line 2402
      if (abbrev_number == 0UL) {
#line 2405
        if (level == 0) {
#line 2405
          if ((unsigned long )start == (unsigned long )end) {
#line 2409
            chk = tags;
            {
#line 2409
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 2409
              if (! ((unsigned long )chk < (unsigned long )start)) {
#line 2409
                goto while_break___17;
              }
#line 2410
              if ((int )*chk != 0) {
#line 2411
                goto while_break___17;
              }
#line 2409
              chk ++;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 2412
            if ((unsigned long )chk == (unsigned long )start) {
#line 2413
              goto while_break___16;
            }
          }
        }
#line 2416
        if (! do_loc) {
#line 2416
          if (die_offset >= dwarf_start_die) {
#line 2416
            if (dwarf_cutoff_level == -1) {
              {
#line 2419
              tmp___48 = gettext(" <%d><%lx>: Abbrev Number: 0\n");
#line 2419
              printf((char const   */* __restrict  */)tmp___48, level, die_offset);
              }
            } else
#line 2416
            if (level < dwarf_cutoff_level) {
              {
#line 2419
              tmp___48 = gettext(" <%d><%lx>: Abbrev Number: 0\n");
#line 2419
              printf((char const   */* __restrict  */)tmp___48, level, die_offset);
              }
            }
          }
        }
#line 2422
        level --;
#line 2423
        if (level < 0) {
#line 2427
          if (num_bogus_warns < 3U) {
            {
#line 2429
            tmp___49 = gettext("Bogus end-of-siblings marker detected at offset %lx in %s section\n");
#line 2429
            warn((char const   *)tmp___49, die_offset, section->name);
#line 2431
            num_bogus_warns ++;
            }
#line 2432
            if (num_bogus_warns == 3U) {
              {
#line 2433
              tmp___50 = gettext("Further warnings about bogus end-of-sibling markers suppressed\n");
#line 2433
              warn((char const   *)tmp___50);
              }
            }
          }
        }
#line 2436
        if (dwarf_start_die != 0UL) {
#line 2436
          if (level < saved_level) {
#line 2437
            return (1);
          }
        }
#line 2438
        goto while_continue___16;
      }
#line 2441
      if (! do_loc) {
#line 2443
        if (dwarf_start_die != 0UL) {
#line 2443
          if (die_offset < dwarf_start_die) {
#line 2444
            do_printing = 0;
          } else {
#line 2443
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 2447
          if (dwarf_start_die != 0UL) {
#line 2447
            if (die_offset == dwarf_start_die) {
#line 2448
              saved_level = level;
            }
          }
#line 2449
          if (dwarf_cutoff_level == -1) {
#line 2449
            tmp___51 = 1;
          } else
#line 2449
          if (level < dwarf_cutoff_level) {
#line 2449
            tmp___51 = 1;
          } else {
#line 2449
            tmp___51 = 0;
          }
#line 2449
          do_printing = tmp___51;
#line 2451
          if (do_printing) {
            {
#line 2452
            tmp___52 = gettext(" <%d><%lx>: Abbrev Number: %lu");
#line 2452
            printf((char const   */* __restrict  */)tmp___52, level, die_offset, abbrev_number);
            }
          } else
#line 2454
          if (dwarf_cutoff_level == -1) {
            {
#line 2456
            tmp___53 = gettext(" <%d><%lx>: ...\n");
#line 2456
            printf((char const   */* __restrict  */)tmp___53, level, die_offset);
            }
          } else
#line 2454
          if (last_level < dwarf_cutoff_level) {
            {
#line 2456
            tmp___53 = gettext(" <%d><%lx>: ...\n");
#line 2456
            printf((char const   */* __restrict  */)tmp___53, level, die_offset);
            }
          }
#line 2457
          last_level = level;
        }
      }
#line 2463
      entry = first_abbrev;
      {
#line 2463
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2463
        if (entry) {
#line 2463
          if (! (entry->entry != abbrev_number)) {
#line 2463
            goto while_break___18;
          }
        } else {
#line 2463
          goto while_break___18;
        }
#line 2466
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2463
        entry = entry->next;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2468
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 2470
        if (! do_loc) {
#line 2470
          if (do_printing) {
            {
#line 2472
            printf((char const   */* __restrict  */)"\n");
#line 2473
            fflush(stdout);
            }
          }
        }
        {
#line 2475
        tmp___54 = gettext("DIE at offset %lx refers to abbreviation number %lu which does not exist\n");
#line 2475
        warn((char const   *)tmp___54, die_offset, abbrev_number);
        }
#line 2477
        return (0);
      }
#line 2480
      if (! do_loc) {
#line 2480
        if (do_printing) {
          {
#line 2481
          tmp___55 = get_TAG_name(entry->tag);
#line 2481
          printf((char const   */* __restrict  */)" (%s)\n", tmp___55);
          }
        }
      }
      {
#line 2488
      if (entry->tag == 17UL) {
#line 2488
        goto case_17;
      }
#line 2492
      if (entry->tag == 46UL) {
#line 2492
        goto case_46;
      }
#line 2492
      if (entry->tag == 3UL) {
#line 2492
        goto case_46;
      }
#line 2485
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 2486
      need_base_address = 0;
#line 2487
      goto switch_break;
      case_17: /* CIL Label */ 
#line 2489
      need_base_address = 1;
#line 2490
      goto switch_break;
      case_46: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 2493
      need_base_address = 0;
#line 2495
      have_frame_base = 0;
#line 2496
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2499
      attr = entry->first_attr;
      {
#line 2499
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 2499
        if (attr) {
#line 2499
          if (! attr->attribute) {
#line 2499
            goto while_break___19;
          }
        } else {
#line 2499
          goto while_break___19;
        }
#line 2505
        if (! do_loc) {
#line 2505
          if (do_printing) {
            {
#line 2507
            printf((char const   */* __restrict  */)"    <%lx>", (unsigned long )(tags - section_begin));
            }
          }
        }
#line 2509
        arg = debug_information;
#line 2510
        if (debug_information) {
#line 2511
          arg += unit;
        }
#line 2513
        if (do_loc) {
#line 2513
          tmp___56 = 1;
        } else
#line 2513
        if (! do_printing) {
#line 2513
          tmp___56 = 1;
        } else {
#line 2513
          tmp___56 = 0;
        }
        {
#line 2513
        tags = read_and_display_attr(attr->attribute, attr->form, tags, end, cu_offset,
                                     (dwarf_vma )compunit.cu_pointer_size, (dwarf_vma )offset_size,
                                     (int )compunit.cu_version, arg, tmp___56, section,
                                     this_set);
#line 2499
        attr = attr->next;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 2527
      if (entry->children) {
#line 2528
        level ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2223
    unit ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2534
  if (do_loc) {
#line 2534
    goto _L___2;
  } else
#line 2534
  if (do_debug_loc) {
#line 2534
    goto _L___2;
  } else
#line 2534
  if (do_debug_ranges) {
    _L___2: /* CIL Label */ 
#line 2534
    if (num_debug_info_entries == 0U) {
#line 2534
      if (! do_types) {
#line 2537
        num_debug_info_entries = num_units;
      }
    }
  }
#line 2539
  if (! do_loc) {
    {
#line 2540
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2542
  return (1);
}
}
#line 2551 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int load_debug_info(void *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2556
  last_pointer_size = 0U;
#line 2557
  warned_about_missing_comp_units = 0;
#line 2561
  if (num_debug_info_entries == 4294967295U) {
#line 2562
    return (0U);
  }
#line 2565
  if (num_debug_info_entries > 0U) {
#line 2566
    return (num_debug_info_entries);
  }
  {
#line 2569
  load_cu_tu_indexes(file);
#line 2571
  tmp___2 = load_debug_section((enum dwarf_section_display_enum )3, file);
  }
#line 2571
  if (tmp___2) {
    {
#line 2571
    tmp___3 = process_debug_info(& debug_displays[3].section, file, (enum dwarf_section_display_enum )0,
                                 1, 0);
    }
#line 2571
    if (tmp___3) {
#line 2573
      return (num_debug_info_entries);
    } else {
#line 2571
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2574
    tmp___0 = load_debug_section((enum dwarf_section_display_enum )21, file);
    }
#line 2574
    if (tmp___0) {
      {
#line 2574
      tmp___1 = process_debug_info(& debug_displays[21].section, file, (enum dwarf_section_display_enum )22,
                                   1, 0);
      }
#line 2574
      if (tmp___1) {
#line 2577
        return (num_debug_info_entries);
      }
    }
  }
#line 2579
  num_debug_info_entries = 4294967295U;
#line 2580
  return (0U);
}
}
#line 2588 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *read_debug_line_header(struct dwarf_section *section , unsigned char *data ,
                                             unsigned char *end , DWARF2_Internal_LineInfo *linfo ,
                                             unsigned char **end_of_sequence ) 
{ 
  unsigned char *hdrptr ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int amount ;
  unsigned int amount___0 ;
  char *tmp___0 ;
  unsigned int amount___1 ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *dummy___2  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___2 ;
  void *tmp___4 ;
  unsigned int amount___2 ;
  elf_vma tmp___5 ;
  unsigned int amount___3 ;
  elf_vma tmp___6 ;
  unsigned int amount___4 ;
  elf_vma tmp___7 ;
  char *tmp___8 ;
  unsigned int amount___5 ;
  elf_vma tmp___9 ;
  unsigned int amount___6 ;
  elf_vma tmp___10 ;
  unsigned int amount___7 ;
  elf_vma tmp___11 ;
  unsigned int amount___8 ;
  elf_vma tmp___12 ;

  {
#line 2601
  hdrptr = data;
  {
#line 2604
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2604
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2604
      amount = 4U;
#line 2604
      if ((unsigned long )(hdrptr + amount) >= (unsigned long )end) {
#line 2604
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2604
          amount = (unsigned int )(end - hdrptr);
        } else {
#line 2604
          amount = 0U;
        }
      }
#line 2604
      if (amount) {
        {
#line 2604
        linfo->li_length = (*byte_get)(hdrptr, (int )amount);
        }
      } else {
#line 2604
        linfo->li_length = (dwarf_vma )0;
      }
#line 2604
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2604
    hdrptr += 4;
#line 2604
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2606
  if (linfo->li_length == 4294967295ULL) {
    {
#line 2609
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2609
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2609
        amount___0 = 8U;
#line 2609
        if ((unsigned long )(hdrptr + amount___0) >= (unsigned long )end) {
#line 2609
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2609
            amount___0 = (unsigned int )(end - hdrptr);
          } else {
#line 2609
            amount___0 = 0U;
          }
        }
#line 2609
        if (amount___0) {
          {
#line 2609
          linfo->li_length = (*byte_get)(hdrptr, (int )amount___0);
          }
        } else {
#line 2609
          linfo->li_length = (dwarf_vma )0;
        }
#line 2609
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2609
      hdrptr += 8;
#line 2609
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2610
    offset_size = 8U;
#line 2611
    initial_length_size = 12U;
  } else {
#line 2615
    offset_size = 4U;
#line 2616
    initial_length_size = 4U;
  }
#line 2619
  if (linfo->li_length + (dwarf_vma )initial_length_size > section->size) {
#line 2626
    if (linfo->li_length == (dwarf_vma )(- initial_length_size)) {
#line 2628
      linfo->li_length = section->size - (dwarf_size_type )initial_length_size;
    } else {
      {
#line 2632
      tmp___0 = gettext("The line info appears to be corrupt - the section is too small\n");
#line 2632
      warn((char const   *)tmp___0);
      }
#line 2634
      return ((unsigned char *)((void *)0));
    }
  }
  {
#line 2639
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 2639
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2639
      amount___1 = 2U;
#line 2639
      if ((unsigned long )(hdrptr + amount___1) >= (unsigned long )end) {
#line 2639
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2639
          amount___1 = (unsigned int )(end - hdrptr);
        } else {
#line 2639
          amount___1 = 0U;
        }
      }
#line 2639
      if (amount___1) {
        {
#line 2639
        tmp___1 = (*byte_get)(hdrptr, (int )amount___1);
#line 2639
        linfo->li_version = (unsigned short )tmp___1;
        }
      } else {
#line 2639
        linfo->li_version = (unsigned short)0;
      }
#line 2639
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2639
    hdrptr += 2;
#line 2639
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2641
  if ((int )linfo->li_version != 2) {
#line 2641
    if ((int )linfo->li_version != 3) {
#line 2641
      if ((int )linfo->li_version != 4) {
        {
#line 2645
        tmp___2 = gettext("Only DWARF version 2, 3 and 4 line info is currently supported.\n");
#line 2645
        warn((char const   *)tmp___2);
        }
#line 2646
        return ((unsigned char *)((void *)0));
      }
    }
  }
  {
#line 2649
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 2649
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2649
      if (4UL < (unsigned long )offset_size) {
#line 2649
        tmp___3 = -1;
      } else {
#line 2649
        tmp___3 = 1;
      }
      {
#line 2649
      __lengthofdummy___2 = (unsigned long )tmp___3;
#line 2649
      tmp___4 = __builtin_alloca(sizeof(*dummy___2) * __lengthofdummy___2);
#line 2649
      dummy___2 = (int *)tmp___4;
#line 2649
      amount___2 = offset_size;
      }
#line 2649
      if ((unsigned long )(hdrptr + amount___2) >= (unsigned long )end) {
#line 2649
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2649
          amount___2 = (unsigned int )(end - hdrptr);
        } else {
#line 2649
          amount___2 = 0U;
        }
      }
#line 2649
      if (amount___2) {
        {
#line 2649
        tmp___5 = (*byte_get)(hdrptr, (int )amount___2);
#line 2649
        linfo->li_prologue_length = (unsigned int )tmp___5;
        }
      } else {
#line 2649
        linfo->li_prologue_length = 0U;
      }
#line 2649
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2649
    hdrptr += offset_size;
#line 2649
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2650
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 2650
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2650
      amount___3 = 1U;
#line 2650
      if ((unsigned long )(hdrptr + amount___3) >= (unsigned long )end) {
#line 2650
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2650
          amount___3 = (unsigned int )(end - hdrptr);
        } else {
#line 2650
          amount___3 = 0U;
        }
      }
#line 2650
      if (amount___3) {
        {
#line 2650
        tmp___6 = (*byte_get)(hdrptr, (int )amount___3);
#line 2650
        linfo->li_min_insn_length = (unsigned char )tmp___6;
        }
      } else {
#line 2650
        linfo->li_min_insn_length = (unsigned char)0;
      }
#line 2650
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2650
    hdrptr ++;
#line 2650
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2652
  if ((int )linfo->li_version >= 4) {
    {
#line 2654
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 2654
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2654
        amount___4 = 1U;
#line 2654
        if ((unsigned long )(hdrptr + amount___4) >= (unsigned long )end) {
#line 2654
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2654
            amount___4 = (unsigned int )(end - hdrptr);
          } else {
#line 2654
            amount___4 = 0U;
          }
        }
#line 2654
        if (amount___4) {
          {
#line 2654
          tmp___7 = (*byte_get)(hdrptr, (int )amount___4);
#line 2654
          linfo->li_max_ops_per_insn = (unsigned char )tmp___7;
          }
        } else {
#line 2654
          linfo->li_max_ops_per_insn = (unsigned char)0;
        }
#line 2654
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2654
      hdrptr ++;
#line 2654
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2656
    if ((int )linfo->li_max_ops_per_insn == 0) {
      {
#line 2658
      tmp___8 = gettext("Invalid maximum operations per insn.\n");
#line 2658
      warn((char const   *)tmp___8);
      }
#line 2659
      return ((unsigned char *)((void *)0));
    }
  } else {
#line 2663
    linfo->li_max_ops_per_insn = (unsigned char)1;
  }
  {
#line 2665
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 2665
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2665
      amount___5 = 1U;
#line 2665
      if ((unsigned long )(hdrptr + amount___5) >= (unsigned long )end) {
#line 2665
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2665
          amount___5 = (unsigned int )(end - hdrptr);
        } else {
#line 2665
          amount___5 = 0U;
        }
      }
#line 2665
      if (amount___5) {
        {
#line 2665
        tmp___9 = (*byte_get)(hdrptr, (int )amount___5);
#line 2665
        linfo->li_default_is_stmt = (unsigned char )tmp___9;
        }
      } else {
#line 2665
        linfo->li_default_is_stmt = (unsigned char)0;
      }
#line 2665
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2665
    hdrptr ++;
#line 2665
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2666
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 2666
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2666
      amount___6 = 1U;
#line 2666
      if ((unsigned long )(hdrptr + amount___6) >= (unsigned long )end) {
#line 2666
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2666
          amount___6 = (unsigned int )(end - hdrptr);
        } else {
#line 2666
          amount___6 = 0U;
        }
      }
#line 2666
      if (amount___6) {
        {
#line 2666
        tmp___10 = (*byte_get)(hdrptr, (int )amount___6);
#line 2666
        linfo->li_line_base = (int )tmp___10;
        }
      } else {
#line 2666
        linfo->li_line_base = 0;
      }
#line 2666
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 2666
    hdrptr ++;
#line 2666
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 2667
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 2667
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 2667
      amount___7 = 1U;
#line 2667
      if ((unsigned long )(hdrptr + amount___7) >= (unsigned long )end) {
#line 2667
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2667
          amount___7 = (unsigned int )(end - hdrptr);
        } else {
#line 2667
          amount___7 = 0U;
        }
      }
#line 2667
      if (amount___7) {
        {
#line 2667
        tmp___11 = (*byte_get)(hdrptr, (int )amount___7);
#line 2667
        linfo->li_line_range = (unsigned char )tmp___11;
        }
      } else {
#line 2667
        linfo->li_line_range = (unsigned char)0;
      }
#line 2667
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2667
    hdrptr ++;
#line 2667
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2668
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 2668
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2668
      amount___8 = 1U;
#line 2668
      if ((unsigned long )(hdrptr + amount___8) >= (unsigned long )end) {
#line 2668
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 2668
          amount___8 = (unsigned int )(end - hdrptr);
        } else {
#line 2668
          amount___8 = 0U;
        }
      }
#line 2668
      if (amount___8) {
        {
#line 2668
        tmp___12 = (*byte_get)(hdrptr, (int )amount___8);
#line 2668
        linfo->li_opcode_base = (unsigned char )tmp___12;
        }
      } else {
#line 2668
        linfo->li_opcode_base = (unsigned char)0;
      }
#line 2668
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2668
    hdrptr ++;
#line 2668
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 2671
  linfo->li_line_base <<= 24;
#line 2672
  linfo->li_line_base >>= 24;
#line 2674
  *end_of_sequence = (data + linfo->li_length) + initial_length_size;
#line 2675
  return (hdrptr);
}
}
#line 2690 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static DWARF2_Internal_LineInfo saved_linfo  ;
#line 2678 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_lines_raw(struct dwarf_section *section , unsigned char *data ,
                                   unsigned char *end ) 
{ 
  unsigned char *start ;
  char *tmp___0 ;
  DWARF2_Internal_LineInfo linfo ;
  unsigned char *standard_opcodes ;
  unsigned char *end_of_sequence ;
  unsigned int last_dir_entry ;
  int i ;
  unsigned char *hdrptr ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  unsigned char *name___0 ;
  unsigned int bytes_read ;
  size_t tmp___19 ;
  dwarf_vma tmp___20 ;
  char const   *tmp___21 ;
  dwarf_vma tmp___22 ;
  char const   *tmp___23 ;
  dwarf_vma tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned char op_code ;
  dwarf_signed_vma adv ;
  dwarf_vma uladv ;
  unsigned int bytes_read___0 ;
  unsigned char *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  char *tmp___47 ;
  char const   *tmp___48 ;
  char *tmp___49 ;
  dwarf_vma tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  char *tmp___54 ;
  char const   *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  char *tmp___63 ;
  unsigned int amount ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char const   *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char const   *tmp___72 ;
  dwarf_vma tmp___73 ;
  char const   *tmp___74 ;

  {
  {
#line 2683
  start = section->start;
#line 2685
  tmp___0 = gettext("Raw dump of debug contents of section %s:\n\n");
#line 2685
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 2688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2688
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 2688
      goto while_break;
    }
    {
#line 2694
    last_dir_entry = 0U;
#line 2697
    tmp___27 = strncmp(section->name, ".debug_line.", sizeof(".debug_line.") - 1UL);
    }
#line 2697
    if (tmp___27 == 0) {
      {
#line 2697
      tmp___28 = strcmp(section->name, ".debug_line.dwo");
      }
#line 2697
      if (tmp___28 != 0) {
        {
#line 2712
        end_of_sequence = end;
#line 2713
        standard_opcodes = (unsigned char *)((void *)0);
#line 2714
        linfo = saved_linfo;
#line 2715
        reset_state_machine((int )linfo.li_default_is_stmt);
        }
      } else {
#line 2697
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2721
      hdrptr = read_debug_line_header(section, data, end, & linfo, & end_of_sequence);
      }
#line 2721
      if ((unsigned long )hdrptr == (unsigned long )((void *)0)) {
#line 2723
        return (0);
      }
      {
#line 2725
      tmp___1 = gettext("  Offset:                      0x%lx\n");
#line 2725
      printf((char const   */* __restrict  */)tmp___1, data - start);
#line 2726
      tmp___2 = gettext("  Length:                      %ld\n");
#line 2726
      printf((char const   */* __restrict  */)tmp___2, (long )linfo.li_length);
#line 2727
      tmp___3 = gettext("  DWARF Version:               %d\n");
#line 2727
      printf((char const   */* __restrict  */)tmp___3, (int )linfo.li_version);
#line 2728
      tmp___4 = gettext("  Prologue Length:             %d\n");
#line 2728
      printf((char const   */* __restrict  */)tmp___4, linfo.li_prologue_length);
#line 2729
      tmp___5 = gettext("  Minimum Instruction Length:  %d\n");
#line 2729
      printf((char const   */* __restrict  */)tmp___5, (int )linfo.li_min_insn_length);
      }
#line 2730
      if ((int )linfo.li_version >= 4) {
        {
#line 2731
        tmp___6 = gettext("  Maximum Ops per Instruction: %d\n");
#line 2731
        printf((char const   */* __restrict  */)tmp___6, (int )linfo.li_max_ops_per_insn);
        }
      }
      {
#line 2732
      tmp___7 = gettext("  Initial value of \'is_stmt\':  %d\n");
#line 2732
      printf((char const   */* __restrict  */)tmp___7, (int )linfo.li_default_is_stmt);
#line 2733
      tmp___8 = gettext("  Line Base:                   %d\n");
#line 2733
      printf((char const   */* __restrict  */)tmp___8, linfo.li_line_base);
#line 2734
      tmp___9 = gettext("  Line Range:                  %d\n");
#line 2734
      printf((char const   */* __restrict  */)tmp___9, (int )linfo.li_line_range);
#line 2735
      tmp___10 = gettext("  Opcode Base:                 %d\n");
#line 2735
      printf((char const   */* __restrict  */)tmp___10, (int )linfo.li_opcode_base);
#line 2737
      reset_state_machine((int )linfo.li_default_is_stmt);
#line 2740
      standard_opcodes = hdrptr;
#line 2742
      tmp___11 = gettext("\n Opcodes:\n");
#line 2742
      printf((char const   */* __restrict  */)tmp___11);
#line 2744
      i = 1;
      }
      {
#line 2744
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2744
        if (! (i < (int )linfo.li_opcode_base)) {
#line 2744
          goto while_break___0;
        }
        {
#line 2745
        tmp___12 = gettext("  Opcode %d has %d args\n");
#line 2745
        printf((char const   */* __restrict  */)tmp___12, i, (int )*(standard_opcodes + (i - 1)));
#line 2744
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2748
      data = (standard_opcodes + (int )linfo.li_opcode_base) - 1;
#line 2750
      if ((int )*data == 0) {
        {
#line 2751
        tmp___13 = gettext("\n The Directory Table is empty.\n");
#line 2751
        printf((char const   */* __restrict  */)tmp___13);
        }
      } else {
        {
#line 2754
        tmp___14 = gettext("\n The Directory Table (offset 0x%lx):\n");
#line 2754
        printf((char const   */* __restrict  */)tmp___14, data - start);
        }
        {
#line 2757
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2757
          if (! ((int )*data != 0)) {
#line 2757
            goto while_break___1;
          }
          {
#line 2759
          last_dir_entry ++;
#line 2759
          printf((char const   */* __restrict  */)"  %d\t%s\n", last_dir_entry, data);
#line 2761
          tmp___15 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 2761
          data += tmp___15 + 1UL;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2766
      data ++;
#line 2769
      if ((int )*data == 0) {
        {
#line 2770
        tmp___16 = gettext("\n The File Name Table is empty.\n");
#line 2770
        printf((char const   */* __restrict  */)tmp___16);
        }
      } else {
        {
#line 2773
        tmp___17 = gettext("\n The File Name Table (offset 0x%lx):\n");
#line 2773
        printf((char const   */* __restrict  */)tmp___17, data - start);
#line 2775
        tmp___18 = gettext("  Entry\tDir\tTime\tSize\tName\n");
#line 2775
        printf((char const   */* __restrict  */)tmp___18);
        }
        {
#line 2777
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2777
          if (! ((int )*data != 0)) {
#line 2777
            goto while_break___2;
          }
          {
#line 2782
          (state_machine_regs.last_file_entry) ++;
#line 2782
          printf((char const   */* __restrict  */)"  %d\t", state_machine_regs.last_file_entry);
#line 2783
          name___0 = data;
#line 2784
          tmp___19 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 2784
          data += tmp___19 + 1UL;
#line 2786
          tmp___20 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 2786
          tmp___21 = dwarf_vmatoa("u", tmp___20);
#line 2786
          printf((char const   */* __restrict  */)"%s\t", tmp___21);
#line 2788
          data += bytes_read;
#line 2789
          tmp___22 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 2789
          tmp___23 = dwarf_vmatoa("u", tmp___22);
#line 2789
          printf((char const   */* __restrict  */)"%s\t", tmp___23);
#line 2791
          data += bytes_read;
#line 2792
          tmp___24 = read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 2792
          tmp___25 = dwarf_vmatoa("u", tmp___24);
#line 2792
          printf((char const   */* __restrict  */)"%s\t", tmp___25);
#line 2794
          data += bytes_read;
#line 2795
          printf((char const   */* __restrict  */)"%s\n", name___0);
          }
#line 2797
          if ((unsigned long )data == (unsigned long )end) {
            {
#line 2799
            tmp___26 = gettext("Corrupt file name table entry\n");
#line 2799
            warn((char const   *)tmp___26);
            }
#line 2800
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 2806
      data ++;
#line 2807
      putchar('\n');
#line 2808
      saved_linfo = linfo;
      }
    }
#line 2812
    if ((unsigned long )data >= (unsigned long )end_of_sequence) {
      {
#line 2813
      tmp___29 = gettext(" No Line Number Statements.\n");
#line 2813
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 2816
      tmp___30 = gettext(" Line Number Statements:\n");
#line 2816
      printf((char const   */* __restrict  */)tmp___30);
      }
      {
#line 2818
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2818
        if (! ((unsigned long )data < (unsigned long )end_of_sequence)) {
#line 2818
          goto while_break___3;
        }
        {
#line 2825
        printf((char const   */* __restrict  */)"  [0x%08lx]", data - start);
#line 2827
        tmp___31 = data;
#line 2827
        data ++;
#line 2827
        op_code = *tmp___31;
        }
#line 2829
        if ((int )op_code >= (int )linfo.li_opcode_base) {
#line 2831
          op_code = (unsigned char )((int )op_code - (int )linfo.li_opcode_base);
#line 2832
          uladv = (dwarf_vma )((int )op_code / (int )linfo.li_line_range);
#line 2833
          if ((int )linfo.li_max_ops_per_insn == 1) {
            {
#line 2835
            uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2836
            state_machine_regs.address += uladv;
#line 2837
            tmp___32 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2837
            tmp___33 = dwarf_vmatoa("u", uladv);
#line 2837
            tmp___34 = gettext("  Special opcode %d: advance Address by %s to 0x%s");
#line 2837
            printf((char const   */* __restrict  */)tmp___34, (int )op_code, tmp___33,
                   tmp___32);
            }
          } else {
            {
#line 2844
            state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2848
            state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2851
            tmp___35 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2851
            tmp___36 = dwarf_vmatoa("u", uladv);
#line 2851
            tmp___37 = gettext("  Special opcode %d: advance Address by %s to 0x%s[%d]");
#line 2851
            printf((char const   */* __restrict  */)tmp___37, (int )op_code, tmp___36,
                   tmp___35, (int )state_machine_regs.op_index);
            }
          }
          {
#line 2857
          adv = (dwarf_signed_vma )((int )op_code % (int )linfo.li_line_range + linfo.li_line_base);
#line 2858
          state_machine_regs.line = (unsigned int )((dwarf_signed_vma )state_machine_regs.line + adv);
#line 2859
          tmp___38 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2859
          tmp___39 = gettext(" and Line by %s to %d\n");
#line 2859
          printf((char const   */* __restrict  */)tmp___39, tmp___38, state_machine_regs.line);
          }
        } else {
          {
#line 2864
          if ((int )op_code == 0) {
#line 2864
            goto case_0;
          }
#line 2868
          if ((int )op_code == 1) {
#line 2868
            goto case_1;
          }
#line 2872
          if ((int )op_code == 2) {
#line 2872
            goto case_2;
          }
#line 2899
          if ((int )op_code == 3) {
#line 2899
            goto case_3;
          }
#line 2908
          if ((int )op_code == 4) {
#line 2908
            goto case_4;
          }
#line 2916
          if ((int )op_code == 5) {
#line 2916
            goto case_5;
          }
#line 2924
          if ((int )op_code == 6) {
#line 2924
            goto case_6;
          }
#line 2931
          if ((int )op_code == 7) {
#line 2931
            goto case_7;
          }
#line 2936
          if ((int )op_code == 8) {
#line 2936
            goto case_8;
          }
#line 2962
          if ((int )op_code == 9) {
#line 2962
            goto case_9;
          }
#line 2971
          if ((int )op_code == 10) {
#line 2971
            goto case_10;
          }
#line 2975
          if ((int )op_code == 11) {
#line 2975
            goto case_11;
          }
#line 2979
          if ((int )op_code == 12) {
#line 2979
            goto case_12;
          }
#line 2985
          goto switch_default;
          case_0: /* CIL Label */ 
          {
#line 2865
          tmp___40 = process_extended_line_op(data, (int )linfo.li_default_is_stmt,
                                              end);
#line 2865
          data += tmp___40;
          }
#line 2866
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 2869
          tmp___41 = gettext("  Copy\n");
#line 2869
          printf((char const   */* __restrict  */)tmp___41);
          }
#line 2870
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 2873
          uladv = read_uleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2874
          data += bytes_read___0;
          }
#line 2875
          if ((int )linfo.li_max_ops_per_insn == 1) {
            {
#line 2877
            uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2878
            state_machine_regs.address += uladv;
#line 2879
            tmp___42 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2879
            tmp___43 = dwarf_vmatoa("u", uladv);
#line 2879
            tmp___44 = gettext("  Advance PC by %s to 0x%s\n");
#line 2879
            printf((char const   */* __restrict  */)tmp___44, tmp___43, tmp___42);
            }
          } else {
            {
#line 2885
            state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2889
            state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2892
            tmp___45 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2892
            tmp___46 = dwarf_vmatoa("u", uladv);
#line 2892
            tmp___47 = gettext("  Advance PC by %s to 0x%s[%d]\n");
#line 2892
            printf((char const   */* __restrict  */)tmp___47, tmp___46, tmp___45,
                   (int )state_machine_regs.op_index);
            }
          }
#line 2897
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 2900
          adv = read_sleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2901
          data += bytes_read___0;
#line 2902
          state_machine_regs.line = (unsigned int )((dwarf_signed_vma )state_machine_regs.line + adv);
#line 2903
          tmp___48 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2903
          tmp___49 = gettext("  Advance Line by %s to %d\n");
#line 2903
          printf((char const   */* __restrict  */)tmp___49, tmp___48, state_machine_regs.line);
          }
#line 2906
          goto switch_break;
          case_4: /* CIL Label */ 
          {
#line 2909
          tmp___50 = read_uleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2909
          adv = (dwarf_signed_vma )tmp___50;
#line 2910
          data += bytes_read___0;
#line 2911
          tmp___51 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2911
          tmp___52 = gettext("  Set File Name to entry %s in the File Name Table\n");
#line 2911
          printf((char const   */* __restrict  */)tmp___52, tmp___51);
#line 2913
          state_machine_regs.file = (unsigned int )adv;
          }
#line 2914
          goto switch_break;
          case_5: /* CIL Label */ 
          {
#line 2917
          uladv = read_uleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2918
          data += bytes_read___0;
#line 2919
          tmp___53 = dwarf_vmatoa("u", uladv);
#line 2919
          tmp___54 = gettext("  Set column to %s\n");
#line 2919
          printf((char const   */* __restrict  */)tmp___54, tmp___53);
#line 2921
          state_machine_regs.column = (unsigned int )uladv;
          }
#line 2922
          goto switch_break;
          case_6: /* CIL Label */ 
          {
#line 2925
          adv = (dwarf_signed_vma )state_machine_regs.is_stmt;
#line 2926
          adv = (dwarf_signed_vma )(! adv);
#line 2927
          tmp___55 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2927
          tmp___56 = gettext("  Set is_stmt to %s\n");
#line 2927
          printf((char const   */* __restrict  */)tmp___56, tmp___55);
#line 2928
          state_machine_regs.is_stmt = (int )adv;
          }
#line 2929
          goto switch_break;
          case_7: /* CIL Label */ 
          {
#line 2932
          tmp___57 = gettext("  Set basic block\n");
#line 2932
          printf((char const   */* __restrict  */)tmp___57);
#line 2933
          state_machine_regs.basic_block = 1;
          }
#line 2934
          goto switch_break;
          case_8: /* CIL Label */ 
#line 2937
          uladv = (dwarf_vma )((255 - (int )linfo.li_opcode_base) / (int )linfo.li_line_range);
#line 2938
          if (linfo.li_max_ops_per_insn) {
            {
#line 2940
            uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2941
            state_machine_regs.address += uladv;
#line 2942
            tmp___58 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2942
            tmp___59 = dwarf_vmatoa("u", uladv);
#line 2942
            tmp___60 = gettext("  Advance PC by constant %s to 0x%s\n");
#line 2942
            printf((char const   */* __restrict  */)tmp___60, tmp___59, tmp___58);
            }
          } else {
            {
#line 2948
            state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2952
            state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2955
            tmp___61 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2955
            tmp___62 = dwarf_vmatoa("u", uladv);
#line 2955
            tmp___63 = gettext("  Advance PC by constant %s to 0x%s[%d]\n");
#line 2955
            printf((char const   */* __restrict  */)tmp___63, tmp___62, tmp___61,
                   (int )state_machine_regs.op_index);
            }
          }
#line 2960
          goto switch_break;
          case_9: /* CIL Label */ 
          {
#line 2963
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 2963
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2963
              amount = 2U;
#line 2963
              if ((unsigned long )(data + amount) >= (unsigned long )end) {
#line 2963
                if ((unsigned long )data < (unsigned long )end) {
#line 2963
                  amount = (unsigned int )(end - data);
                } else {
#line 2963
                  amount = 0U;
                }
              }
#line 2963
              if (amount) {
                {
#line 2963
                uladv = (*byte_get)(data, (int )amount);
                }
              } else {
#line 2963
                uladv = (dwarf_vma )0;
              }
#line 2963
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2963
            data += 2;
#line 2963
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 2964
          state_machine_regs.address += uladv;
#line 2965
          state_machine_regs.op_index = (unsigned char)0;
#line 2966
          tmp___64 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2966
          tmp___65 = dwarf_vmatoa("u", uladv);
#line 2966
          tmp___66 = gettext("  Advance PC by fixed size amount %s to 0x%s\n");
#line 2966
          printf((char const   */* __restrict  */)tmp___66, tmp___65, tmp___64);
          }
#line 2969
          goto switch_break;
          case_10: /* CIL Label */ 
          {
#line 2972
          tmp___67 = gettext("  Set prologue_end to true\n");
#line 2972
          printf((char const   */* __restrict  */)tmp___67);
          }
#line 2973
          goto switch_break;
          case_11: /* CIL Label */ 
          {
#line 2976
          tmp___68 = gettext("  Set epilogue_begin to true\n");
#line 2976
          printf((char const   */* __restrict  */)tmp___68);
          }
#line 2977
          goto switch_break;
          case_12: /* CIL Label */ 
          {
#line 2980
          uladv = read_uleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2981
          data += bytes_read___0;
#line 2982
          tmp___69 = dwarf_vmatoa("u", uladv);
#line 2982
          tmp___70 = gettext("  Set ISA to %s\n");
#line 2982
          printf((char const   */* __restrict  */)tmp___70, tmp___69);
          }
#line 2983
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 2986
          tmp___71 = gettext("  Unknown opcode %d with operands: ");
#line 2986
          printf((char const   */* __restrict  */)tmp___71, (int )op_code);
          }
#line 2988
          if ((unsigned long )standard_opcodes != (unsigned long )((void *)0)) {
#line 2989
            i = (int )*(standard_opcodes + ((int )op_code - 1));
            {
#line 2989
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2989
              if (! (i > 0)) {
#line 2989
                goto while_break___6;
              }
#line 2991
              if (i == 1) {
#line 2991
                tmp___72 = "";
              } else {
#line 2991
                tmp___72 = ", ";
              }
              {
#line 2991
              tmp___73 = read_uleb128(data, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 2991
              tmp___74 = dwarf_vmatoa("x", tmp___73);
#line 2991
              printf((char const   */* __restrict  */)"0x%s%s", tmp___74, tmp___72);
#line 2994
              data += bytes_read___0;
#line 2989
              i --;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          {
#line 2996
          putchar('\n');
          }
#line 2997
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 3000
      putchar('\n');
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3004
  return (1);
}
}
#line 3022 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static DWARF2_Internal_LineInfo saved_linfo___0  ;
#line 3017 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_lines_decoded(struct dwarf_section *section , unsigned char *data ,
                                       unsigned char *end ) 
{ 
  char *tmp___0 ;
  DWARF2_Internal_LineInfo linfo ;
  unsigned char *standard_opcodes ;
  unsigned char *end_of_sequence ;
  int i ;
  File_Entry *file_table ;
  unsigned int n_files ;
  unsigned char **directory_table ;
  unsigned int n_directories ;
  unsigned char *hdrptr ;
  unsigned char *ptr_directory_table ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *ptr_file_name_table ;
  unsigned int bytes_read ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned int bytes_read___0 ;
  size_t tmp___6 ;
  dwarf_vma tmp___7 ;
  dwarf_vma tmp___8 ;
  dwarf_vma tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned int ix ;
  char const   *directory ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char op_code ;
  int adv ;
  unsigned long uladv ;
  unsigned int bytes_read___1 ;
  int is_special_opcode ;
  unsigned char *tmp___18 ;
  unsigned int ext_op_code_len ;
  unsigned char ext_op_code ;
  unsigned char *op_code_data ;
  dwarf_vma tmp___19 ;
  char *tmp___20 ;
  unsigned char *tmp___21 ;
  int tmp___22 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___23 ;
  unsigned int amount ;
  void *tmp___24 ;
  size_t tmp___25 ;
  dwarf_vma tmp___26 ;
  dwarf_vma tmp___27 ;
  dwarf_vma tmp___28 ;
  char *tmp___29 ;
  dwarf_vma tmp___30 ;
  dwarf_signed_vma tmp___31 ;
  dwarf_vma tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  dwarf_vma tmp___35 ;
  unsigned int amount___0 ;
  elf_vma tmp___36 ;
  dwarf_vma tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  dwarf_vma tmp___41 ;
  char const   *tmp___42 ;
  unsigned int MAX_FILENAME_LENGTH ;
  char *fileName ;
  char *newFileName ;
  size_t fileNameLength ;
  void *tmp___43 ;
  void *tmp___44 ;

  {
  {
#line 3024
  tmp___0 = gettext("Decoded dump of debug contents of section %s:\n\n");
#line 3024
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3027
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 3027
      goto while_break;
    }
    {
#line 3034
    file_table = (File_Entry *)((void *)0);
#line 3035
    n_files = 0U;
#line 3036
    directory_table = (unsigned char **)((void *)0);
#line 3037
    n_directories = 0U;
#line 3039
    tmp___16 = strncmp(section->name, ".debug_line.", sizeof(".debug_line.") - 1UL);
    }
#line 3039
    if (tmp___16 == 0) {
      {
#line 3039
      tmp___17 = strcmp(section->name, ".debug_line.dwo");
      }
#line 3039
      if (tmp___17 != 0) {
        {
#line 3045
        end_of_sequence = end;
#line 3046
        standard_opcodes = (unsigned char *)((void *)0);
#line 3047
        linfo = saved_linfo___0;
#line 3048
        reset_state_machine((int )linfo.li_default_is_stmt);
        }
      } else {
#line 3039
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3054
      hdrptr = read_debug_line_header(section, data, end, & linfo, & end_of_sequence);
      }
#line 3054
      if ((unsigned long )hdrptr == (unsigned long )((void *)0)) {
#line 3056
        return (0);
      }
      {
#line 3058
      reset_state_machine((int )linfo.li_default_is_stmt);
#line 3061
      standard_opcodes = hdrptr;
#line 3064
      data = (standard_opcodes + (int )linfo.li_opcode_base) - 1;
      }
#line 3065
      if ((int )*data != 0) {
#line 3067
        ptr_directory_table = data;
        {
#line 3069
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3069
          if (! ((int )*data != 0)) {
#line 3069
            goto while_break___0;
          }
          {
#line 3071
          tmp___1 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 3071
          data += tmp___1 + 1UL;
#line 3072
          n_directories ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 3076
        tmp___2 = xmalloc((unsigned long )n_directories * sizeof(unsigned char *));
#line 3076
        directory_table = (unsigned char **)tmp___2;
#line 3079
        i = 0;
        }
        {
#line 3080
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3080
          if (! ((int )*ptr_directory_table != 0)) {
#line 3080
            goto while_break___1;
          }
          {
#line 3082
          *(directory_table + i) = ptr_directory_table;
#line 3083
          tmp___3 = strnlen((char const   *)((char *)ptr_directory_table), (size_t )(ptr_directory_table - end));
#line 3083
          ptr_directory_table += tmp___3 + 1UL;
#line 3085
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 3089
      data ++;
#line 3092
      if ((int )*data != 0) {
#line 3094
        ptr_file_name_table = data;
        {
#line 3096
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3096
          if (! ((int )*data != 0)) {
#line 3096
            goto while_break___2;
          }
          {
#line 3102
          tmp___4 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 3102
          data += tmp___4 + 1UL;
#line 3103
          read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 3104
          data += bytes_read;
#line 3105
          read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 3106
          data += bytes_read;
#line 3107
          read_uleb128(data, & bytes_read, (unsigned char const   */* const  */)end);
#line 3108
          data += bytes_read;
#line 3110
          n_files ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 3114
        tmp___5 = xmalloc((unsigned long )n_files * sizeof(File_Entry ));
#line 3114
        file_table = (File_Entry *)tmp___5;
#line 3116
        i = 0;
        }
        {
#line 3117
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3117
          if (! ((int )*ptr_file_name_table != 0)) {
#line 3117
            goto while_break___3;
          }
          {
#line 3121
          (file_table + i)->name = ptr_file_name_table;
#line 3122
          tmp___6 = strnlen((char const   *)((char *)ptr_file_name_table), (size_t )(end - ptr_file_name_table));
#line 3122
          ptr_file_name_table += tmp___6 + 1UL;
#line 3126
          tmp___7 = read_uleb128(ptr_file_name_table, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 3126
          (file_table + i)->directory_index = (unsigned int )tmp___7;
#line 3128
          ptr_file_name_table += bytes_read___0;
#line 3129
          tmp___8 = read_uleb128(ptr_file_name_table, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 3129
          (file_table + i)->modification_date = (unsigned int )tmp___8;
#line 3131
          ptr_file_name_table += bytes_read___0;
#line 3132
          tmp___9 = read_uleb128(ptr_file_name_table, & bytes_read___0, (unsigned char const   */* const  */)end);
#line 3132
          (file_table + i)->length = (unsigned int )tmp___9;
#line 3133
          ptr_file_name_table += bytes_read___0;
#line 3134
          i ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3136
        i = 0;
#line 3139
        if ((unsigned long )directory_table == (unsigned long )((void *)0)) {
          {
#line 3141
          tmp___10 = gettext("CU: %s:\n");
#line 3141
          printf((char const   */* __restrict  */)tmp___10, (file_table + 0)->name);
#line 3142
          tmp___11 = gettext("File name                            Line number    Starting address\n");
#line 3142
          printf((char const   */* __restrict  */)tmp___11);
          }
        } else {
#line 3146
          ix = (file_table + 0)->directory_index;
#line 3147
          if (ix) {
#line 3147
            tmp___12 = (char const   *)((char *)*(directory_table + (ix - 1U)));
          } else {
#line 3147
            tmp___12 = ".";
          }
#line 3147
          directory = tmp___12;
#line 3149
          if (do_wide) {
            {
#line 3150
            tmp___13 = gettext("CU: %s/%s:\n");
#line 3150
            printf((char const   */* __restrict  */)tmp___13, directory, (file_table + 0)->name);
            }
          } else {
            {
#line 3149
            tmp___14 = strlen(directory);
            }
#line 3149
            if (tmp___14 < 76UL) {
              {
#line 3150
              tmp___13 = gettext("CU: %s/%s:\n");
#line 3150
              printf((char const   */* __restrict  */)tmp___13, directory, (file_table + 0)->name);
              }
            } else {
              {
#line 3152
              printf((char const   */* __restrict  */)"%s:\n", (file_table + 0)->name);
              }
            }
          }
          {
#line 3154
          tmp___15 = gettext("File name                            Line number    Starting address\n");
#line 3154
          printf((char const   */* __restrict  */)tmp___15);
          }
        }
      }
#line 3159
      data ++;
#line 3161
      saved_linfo___0 = linfo;
    }
    {
#line 3165
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3165
      if (! ((unsigned long )data < (unsigned long )end_of_sequence)) {
#line 3165
        goto while_break___4;
      }
#line 3171
      is_special_opcode = 0;
#line 3173
      tmp___18 = data;
#line 3173
      data ++;
#line 3173
      op_code = *tmp___18;
#line 3175
      if ((int )op_code >= (int )linfo.li_opcode_base) {
#line 3177
        op_code = (unsigned char )((int )op_code - (int )linfo.li_opcode_base);
#line 3178
        uladv = (unsigned long )((int )op_code / (int )linfo.li_line_range);
#line 3179
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 3181
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 3182
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 3186
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 3190
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 3195
        adv = (int )op_code % (int )linfo.li_line_range + linfo.li_line_base;
#line 3196
        state_machine_regs.line += (unsigned int )adv;
#line 3197
        is_special_opcode = 1;
      } else {
        {
#line 3201
        if ((int )op_code == 0) {
#line 3201
          goto case_0;
        }
#line 3271
        if ((int )op_code == 1) {
#line 3271
          goto case_1___0;
        }
#line 3274
        if ((int )op_code == 2) {
#line 3274
          goto case_2___0;
        }
#line 3294
        if ((int )op_code == 3) {
#line 3294
          goto case_3___0;
        }
#line 3300
        if ((int )op_code == 4) {
#line 3300
          goto case_4___0;
        }
#line 3321
        if ((int )op_code == 5) {
#line 3321
          goto case_5;
        }
#line 3327
        if ((int )op_code == 6) {
#line 3327
          goto case_6;
        }
#line 3333
        if ((int )op_code == 7) {
#line 3333
          goto case_7;
        }
#line 3337
        if ((int )op_code == 8) {
#line 3337
          goto case_8;
        }
#line 3356
        if ((int )op_code == 9) {
#line 3356
          goto case_9;
        }
#line 3362
        if ((int )op_code == 10) {
#line 3362
          goto case_10;
        }
#line 3365
        if ((int )op_code == 11) {
#line 3365
          goto case_11;
        }
#line 3368
        if ((int )op_code == 12) {
#line 3368
          goto case_12;
        }
#line 3374
        goto switch_default___0;
        case_0: /* CIL Label */ 
        {
#line 3205
        op_code_data = data;
#line 3207
        tmp___19 = read_uleb128(op_code_data, & bytes_read___1, (unsigned char const   */* const  */)end_of_sequence);
#line 3207
        ext_op_code_len = (unsigned int )tmp___19;
#line 3209
        op_code_data += bytes_read___1;
        }
#line 3211
        if (ext_op_code_len == 0U) {
          {
#line 3213
          tmp___20 = gettext("badly formed extended line op encountered!\n");
#line 3213
          warn((char const   *)tmp___20);
          }
#line 3214
          goto switch_break;
        }
#line 3216
        ext_op_code_len += bytes_read___1;
#line 3217
        tmp___21 = op_code_data;
#line 3217
        op_code_data ++;
#line 3217
        ext_op_code = *tmp___21;
        {
#line 3221
        if ((int )ext_op_code == 1) {
#line 3221
          goto case_1;
        }
#line 3224
        if ((int )ext_op_code == 2) {
#line 3224
          goto case_2;
        }
#line 3231
        if ((int )ext_op_code == 3) {
#line 3231
          goto case_3;
        }
#line 3259
        if ((int )ext_op_code == 22) {
#line 3259
          goto case_22;
        }
#line 3259
        if ((int )ext_op_code == 4) {
#line 3259
          goto case_22;
        }
#line 3263
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 3222
        reset_state_machine((int )linfo.li_default_is_stmt);
        }
#line 3223
        goto switch_break___0;
        case_2: /* CIL Label */ 
        {
#line 3225
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3225
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3225
            if (8UL < (unsigned long )((ext_op_code_len - bytes_read___1) - 1U)) {
#line 3225
              tmp___22 = -1;
            } else {
#line 3225
              tmp___22 = 1;
            }
            {
#line 3225
            __lengthofdummy = (unsigned long )tmp___22;
#line 3225
            tmp___23 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 3225
            dummy = (int *)tmp___23;
#line 3225
            amount = (ext_op_code_len - bytes_read___1) - 1U;
            }
#line 3225
            if ((unsigned long )(op_code_data + amount) >= (unsigned long )end) {
#line 3225
              if ((unsigned long )op_code_data < (unsigned long )end) {
#line 3225
                amount = (unsigned int )(end - op_code_data);
              } else {
#line 3225
                amount = 0U;
              }
            }
#line 3225
            if (amount) {
              {
#line 3225
              state_machine_regs.address = (*byte_get)(op_code_data, (int )amount);
              }
            } else {
#line 3225
              state_machine_regs.address = (dwarf_vma )0;
            }
#line 3225
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 3225
          op_code_data += (ext_op_code_len - bytes_read___1) - 1U;
#line 3225
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3229
        state_machine_regs.op_index = (unsigned char)0;
#line 3230
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 3233
        tmp___24 = xrealloc((void *)file_table, (unsigned long )(n_files + 1U) * sizeof(File_Entry ));
#line 3233
        file_table = (File_Entry *)tmp___24;
#line 3236
        (state_machine_regs.last_file_entry) ++;
#line 3238
        (file_table + n_files)->name = op_code_data;
#line 3239
        tmp___25 = strlen((char const   *)((char *)op_code_data));
#line 3239
        op_code_data += tmp___25 + 1UL;
#line 3241
        tmp___26 = read_uleb128(op_code_data, & bytes_read___1, (unsigned char const   */* const  */)end_of_sequence);
#line 3241
        (file_table + n_files)->directory_index = (unsigned int )tmp___26;
#line 3244
        op_code_data += bytes_read___1;
#line 3246
        tmp___27 = read_uleb128(op_code_data, & bytes_read___1, (unsigned char const   */* const  */)end_of_sequence);
#line 3246
        (file_table + n_files)->modification_date = (unsigned int )tmp___27;
#line 3249
        op_code_data += bytes_read___1;
#line 3251
        tmp___28 = read_uleb128(op_code_data, & bytes_read___1, (unsigned char const   */* const  */)end_of_sequence);
#line 3251
        (file_table + n_files)->length = (unsigned int )tmp___28;
#line 3255
        n_files ++;
        }
#line 3256
        goto switch_break___0;
        case_22: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 3261
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 3264
        tmp___29 = gettext("UNKNOWN (%u): length %d\n");
#line 3264
        printf((char const   */* __restrict  */)tmp___29, (int )ext_op_code, ext_op_code_len - bytes_read___1);
        }
#line 3266
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 3268
        data += ext_op_code_len;
#line 3269
        goto switch_break;
        case_1___0: /* CIL Label */ 
#line 3272
        goto switch_break;
        case_2___0: /* CIL Label */ 
        {
#line 3275
        tmp___30 = read_uleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3275
        uladv = (unsigned long )tmp___30;
#line 3276
        data += bytes_read___1;
        }
#line 3277
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 3279
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 3280
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 3284
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 3288
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 3292
        goto switch_break;
        case_3___0: /* CIL Label */ 
        {
#line 3295
        tmp___31 = read_sleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3295
        adv = (int )tmp___31;
#line 3296
        data += bytes_read___1;
#line 3297
        state_machine_regs.line += (unsigned int )adv;
        }
#line 3298
        goto switch_break;
        case_4___0: /* CIL Label */ 
        {
#line 3301
        tmp___32 = read_uleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3301
        adv = (int )tmp___32;
#line 3302
        data += bytes_read___1;
#line 3303
        state_machine_regs.file = (unsigned int )adv;
        }
#line 3305
        if ((unsigned long )file_table == (unsigned long )((void *)0)) {
          {
#line 3306
          tmp___33 = gettext("\n [Use file table entry %d]\n");
#line 3306
          printf((char const   */* __restrict  */)tmp___33, state_machine_regs.file - 1U);
          }
        } else
#line 3307
        if ((file_table + (state_machine_regs.file - 1U))->directory_index == 0U) {
          {
#line 3309
          printf((char const   */* __restrict  */)"\n./%s:[++]\n", (file_table + (state_machine_regs.file - 1U))->name);
          }
        } else
#line 3311
        if ((unsigned long )directory_table == (unsigned long )((void *)0)) {
          {
#line 3312
          tmp___34 = gettext("\n [Use directory table entry %d]\n");
#line 3312
          printf((char const   */* __restrict  */)tmp___34, (file_table + (state_machine_regs.file - 1U))->directory_index - 1U);
          }
        } else {
          {
#line 3316
          printf((char const   */* __restrict  */)"\n%s/%s:\n", *(directory_table + ((file_table + (state_machine_regs.file - 1U))->directory_index - 1U)),
                 (file_table + (state_machine_regs.file - 1U))->name);
          }
        }
#line 3319
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 3322
        tmp___35 = read_uleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3322
        uladv = (unsigned long )tmp___35;
#line 3323
        data += bytes_read___1;
#line 3324
        state_machine_regs.column = (unsigned int )uladv;
        }
#line 3325
        goto switch_break;
        case_6: /* CIL Label */ 
#line 3328
        adv = state_machine_regs.is_stmt;
#line 3329
        adv = ! adv;
#line 3330
        state_machine_regs.is_stmt = adv;
#line 3331
        goto switch_break;
        case_7: /* CIL Label */ 
#line 3334
        state_machine_regs.basic_block = 1;
#line 3335
        goto switch_break;
        case_8: /* CIL Label */ 
#line 3338
        uladv = (unsigned long )((255 - (int )linfo.li_opcode_base) / (int )linfo.li_line_range);
#line 3339
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 3341
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 3342
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 3346
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 3350
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 3354
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 3357
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 3357
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 3357
            amount___0 = 2U;
#line 3357
            if ((unsigned long )(data + amount___0) >= (unsigned long )end) {
#line 3357
              if ((unsigned long )data < (unsigned long )end) {
#line 3357
                amount___0 = (unsigned int )(end - data);
              } else {
#line 3357
                amount___0 = 0U;
              }
            }
#line 3357
            if (amount___0) {
              {
#line 3357
              tmp___36 = (*byte_get)(data, (int )amount___0);
#line 3357
              uladv = (unsigned long )tmp___36;
              }
            } else {
#line 3357
              uladv = 0UL;
            }
#line 3357
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 3357
          data += 2;
#line 3357
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3358
        state_machine_regs.address += (dwarf_vma )uladv;
#line 3359
        state_machine_regs.op_index = (unsigned char)0;
#line 3360
        goto switch_break;
        case_10: /* CIL Label */ 
#line 3363
        goto switch_break;
        case_11: /* CIL Label */ 
#line 3366
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 3369
        tmp___37 = read_uleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3369
        uladv = (unsigned long )tmp___37;
#line 3370
        data += bytes_read___1;
#line 3371
        tmp___38 = gettext("  Set ISA to %lu\n");
#line 3371
        printf((char const   */* __restrict  */)tmp___38, uladv);
        }
#line 3372
        goto switch_break;
        switch_default___0: /* CIL Label */ 
        {
#line 3375
        tmp___39 = gettext("  Unknown opcode %d with operands: ");
#line 3375
        printf((char const   */* __restrict  */)tmp___39, (int )op_code);
        }
#line 3377
        if ((unsigned long )standard_opcodes != (unsigned long )((void *)0)) {
#line 3378
          i = (int )*(standard_opcodes + ((int )op_code - 1));
          {
#line 3378
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 3378
            if (! (i > 0)) {
#line 3378
              goto while_break___9;
            }
#line 3380
            if (i == 1) {
#line 3380
              tmp___40 = "";
            } else {
#line 3380
              tmp___40 = ", ";
            }
            {
#line 3380
            tmp___41 = read_uleb128(data, & bytes_read___1, (unsigned char const   */* const  */)end);
#line 3380
            tmp___42 = dwarf_vmatoa("x", tmp___41);
#line 3380
            printf((char const   */* __restrict  */)"0x%s%s", tmp___42, tmp___40);
#line 3383
            data += bytes_read___1;
#line 3378
            i --;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
        {
#line 3385
        putchar('\n');
        }
#line 3386
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 3391
      if (is_special_opcode) {
#line 3391
        goto _L___1;
      } else
#line 3391
      if ((int )op_code == 1) {
#line 3391
        goto _L___1;
      } else
#line 3391
      if ((int )op_code == 1) {
        _L___1: /* CIL Label */ 
#line 3394
        MAX_FILENAME_LENGTH = 35U;
#line 3396
        newFileName = (char *)((void *)0);
#line 3399
        if (file_table) {
#line 3400
          fileName = (char *)(file_table + (state_machine_regs.file - 1U))->name;
        } else {
#line 3402
          fileName = (char *)"<unknown>";
        }
        {
#line 3404
        fileNameLength = strlen((char const   *)fileName);
        }
#line 3406
        if (fileNameLength > (size_t )MAX_FILENAME_LENGTH) {
#line 3406
          if (! do_wide) {
            {
#line 3408
            tmp___43 = xmalloc((size_t )(MAX_FILENAME_LENGTH + 1U));
#line 3408
            newFileName = (char *)tmp___43;
#line 3410
            strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)((fileName + fileNameLength) - MAX_FILENAME_LENGTH),
                    (size_t )(MAX_FILENAME_LENGTH + 1U));
            }
          } else {
            {
#line 3416
            tmp___44 = xmalloc(fileNameLength + 1UL);
#line 3416
            newFileName = (char *)tmp___44;
#line 3417
            strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)fileName,
                    fileNameLength + 1UL);
            }
          }
        } else {
          {
#line 3416
          tmp___44 = xmalloc(fileNameLength + 1UL);
#line 3416
          newFileName = (char *)tmp___44;
#line 3417
          strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)fileName,
                  fileNameLength + 1UL);
          }
        }
#line 3420
        if (! do_wide) {
#line 3420
          goto _L___0;
        } else
#line 3420
        if (fileNameLength <= (size_t )MAX_FILENAME_LENGTH) {
          _L___0: /* CIL Label */ 
#line 3422
          if ((int )linfo.li_max_ops_per_insn == 1) {
            {
#line 3423
            printf((char const   */* __restrict  */)"%-35s  %11d  %#18llx\n", newFileName,
                   state_machine_regs.line, state_machine_regs.address);
            }
          } else {
            {
#line 3427
            printf((char const   */* __restrict  */)"%-35s  %11d  %#18llx[%d]\n",
                   newFileName, state_machine_regs.line, state_machine_regs.address,
                   (int )state_machine_regs.op_index);
            }
          }
        } else
#line 3434
        if ((int )linfo.li_max_ops_per_insn == 1) {
          {
#line 3435
          printf((char const   */* __restrict  */)"%s  %11d  %#18llx\n", newFileName,
                 state_machine_regs.line, state_machine_regs.address);
          }
        } else {
          {
#line 3439
          printf((char const   */* __restrict  */)"%s  %11d  %#18llx[%d]\n", newFileName,
                 state_machine_regs.line, state_machine_regs.address, (int )state_machine_regs.op_index);
          }
        }
#line 3445
        if ((int )op_code == 1) {
          {
#line 3446
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 3448
        free((void *)newFileName);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3452
    if (file_table) {
      {
#line 3454
      free((void *)file_table);
#line 3455
      file_table = (File_Entry *)((void *)0);
#line 3456
      n_files = 0U;
      }
    }
#line 3459
    if (directory_table) {
      {
#line 3461
      free((void *)directory_table);
#line 3462
      directory_table = (unsigned char **)((void *)0);
#line 3463
      n_directories = 0U;
      }
    }
    {
#line 3466
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3469
  return (1);
}
}
#line 3472 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_lines(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *data ;
  unsigned char *end ;
  int retValRaw ;
  int retValDecoded ;

  {
#line 3475
  data = section->start;
#line 3476
  end = data + section->size;
#line 3477
  retValRaw = 1;
#line 3478
  retValDecoded = 1;
#line 3480
  if (do_debug_lines == 0) {
#line 3481
    do_debug_lines |= 1;
  }
#line 3483
  if (do_debug_lines & 1) {
    {
#line 3484
    retValRaw = display_debug_lines_raw(section, data, end);
    }
  }
#line 3486
  if (do_debug_lines & 2) {
    {
#line 3487
    retValDecoded = display_debug_lines_decoded(section, data, end);
    }
  }
#line 3489
  if (! retValRaw) {
#line 3490
    return (0);
  } else
#line 3489
  if (! retValDecoded) {
#line 3490
    return (0);
  }
#line 3492
  return (1);
}
}
#line 3495 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static debug_info *find_debug_info_for_offset(unsigned long offset ) 
{ 
  unsigned int i ;

  {
#line 3500
  if (num_debug_info_entries == 4294967295U) {
#line 3501
    return ((debug_info *)((void *)0));
  }
#line 3503
  i = 0U;
  {
#line 3503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3503
    if (! (i < num_debug_info_entries)) {
#line 3503
      goto while_break;
    }
#line 3504
    if ((debug_information + i)->cu_offset == (dwarf_vma )offset) {
#line 3505
      return (debug_information + i);
    }
#line 3503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3507
  return ((debug_info *)((void *)0));
}
}
#line 3560
static int display_debug_pubnames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) ;
#line 3560 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int warned  =    0;
#line 3510 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_pubnames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  DWARF2_Internal_PubNames names ;
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *data ;
  unsigned long offset ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int amount ;
  unsigned int amount___0 ;
  unsigned int amount___1 ;
  elf_vma tmp___1 ;
  int tmp___2 ;
  int *dummy___2  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___2 ;
  void *tmp___3 ;
  unsigned int amount___2 ;
  char *tmp___4 ;
  debug_info *tmp___5 ;
  int tmp___6 ;
  int *dummy___3  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___3 ;
  void *tmp___7 ;
  unsigned int amount___3 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *dummy___4  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___4 ;
  void *tmp___15 ;
  unsigned int amount___4 ;
  elf_vma tmp___16 ;
  size_t tmp___17 ;

  {
  {
#line 3515
  start = section->start;
#line 3516
  end = start + section->size;
#line 3520
  load_debug_info(file);
#line 3522
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3522
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3524
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 3524
      goto while_break;
    }
#line 3530
    data = start;
    {
#line 3532
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3532
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3532
        amount = 4U;
#line 3532
        if ((unsigned long )(data + amount) >= (unsigned long )end) {
#line 3532
          if ((unsigned long )data < (unsigned long )end) {
#line 3532
            amount = (unsigned int )(end - data);
          } else {
#line 3532
            amount = 0U;
          }
        }
#line 3532
        if (amount) {
          {
#line 3532
          names.pn_length = (*byte_get)(data, (int )amount);
          }
        } else {
#line 3532
          names.pn_length = (dwarf_vma )0;
        }
#line 3532
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3532
      data += 4;
#line 3532
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3533
    if (names.pn_length == 4294967295ULL) {
      {
#line 3535
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 3535
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3535
          amount___0 = 8U;
#line 3535
          if ((unsigned long )(data + amount___0) >= (unsigned long )end) {
#line 3535
            if ((unsigned long )data < (unsigned long )end) {
#line 3535
              amount___0 = (unsigned int )(end - data);
            } else {
#line 3535
              amount___0 = 0U;
            }
          }
#line 3535
          if (amount___0) {
            {
#line 3535
            names.pn_length = (*byte_get)(data, (int )amount___0);
            }
          } else {
#line 3535
            names.pn_length = (dwarf_vma )0;
          }
#line 3535
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3535
        data += 8;
#line 3535
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3536
      offset_size = 8U;
#line 3537
      initial_length_size = 12U;
    } else {
#line 3541
      offset_size = 4U;
#line 3542
      initial_length_size = 4U;
    }
    {
#line 3545
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 3545
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3545
        amount___1 = 2U;
#line 3545
        if ((unsigned long )(data + amount___1) >= (unsigned long )end) {
#line 3545
          if ((unsigned long )data < (unsigned long )end) {
#line 3545
            amount___1 = (unsigned int )(end - data);
          } else {
#line 3545
            amount___1 = 0U;
          }
        }
#line 3545
        if (amount___1) {
          {
#line 3545
          tmp___1 = (*byte_get)(data, (int )amount___1);
#line 3545
          names.pn_version = (unsigned short )tmp___1;
          }
        } else {
#line 3545
          names.pn_version = (unsigned short)0;
        }
#line 3545
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3545
      data += 2;
#line 3545
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3546
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 3546
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 3546
        if (8UL < (unsigned long )offset_size) {
#line 3546
          tmp___2 = -1;
        } else {
#line 3546
          tmp___2 = 1;
        }
        {
#line 3546
        __lengthofdummy___2 = (unsigned long )tmp___2;
#line 3546
        tmp___3 = __builtin_alloca(sizeof(*dummy___2) * __lengthofdummy___2);
#line 3546
        dummy___2 = (int *)tmp___3;
#line 3546
        amount___2 = offset_size;
        }
#line 3546
        if ((unsigned long )(data + amount___2) >= (unsigned long )end) {
#line 3546
          if ((unsigned long )data < (unsigned long )end) {
#line 3546
            amount___2 = (unsigned int )(end - data);
          } else {
#line 3546
            amount___2 = 0U;
          }
        }
#line 3546
        if (amount___2) {
          {
#line 3546
          names.pn_offset = (*byte_get)(data, (int )amount___2);
          }
        } else {
#line 3546
          names.pn_offset = (dwarf_vma )0;
        }
#line 3546
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 3546
      data += offset_size;
#line 3546
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3548
    if (num_debug_info_entries != 4294967295U) {
#line 3548
      if (num_debug_info_entries > 0U) {
        {
#line 3548
        tmp___5 = find_debug_info_for_offset((unsigned long )names.pn_offset);
        }
#line 3548
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          {
#line 3551
          tmp___4 = gettext(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n");
#line 3551
          warn((char const   *)tmp___4, (unsigned long )names.pn_offset, section->name);
          }
        }
      }
    }
    {
#line 3554
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 3554
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 3554
        if (8UL < (unsigned long )offset_size) {
#line 3554
          tmp___6 = -1;
        } else {
#line 3554
          tmp___6 = 1;
        }
        {
#line 3554
        __lengthofdummy___3 = (unsigned long )tmp___6;
#line 3554
        tmp___7 = __builtin_alloca(sizeof(*dummy___3) * __lengthofdummy___3);
#line 3554
        dummy___3 = (int *)tmp___7;
#line 3554
        amount___3 = offset_size;
        }
#line 3554
        if ((unsigned long )(data + amount___3) >= (unsigned long )end) {
#line 3554
          if ((unsigned long )data < (unsigned long )end) {
#line 3554
            amount___3 = (unsigned int )(end - data);
          } else {
#line 3554
            amount___3 = 0U;
          }
        }
#line 3554
        if (amount___3) {
          {
#line 3554
          names.pn_size = (*byte_get)(data, (int )amount___3);
          }
        } else {
#line 3554
          names.pn_size = (dwarf_vma )0;
        }
#line 3554
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 3554
      data += offset_size;
#line 3554
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 3556
    start += names.pn_length + (dwarf_vma )initial_length_size;
#line 3558
    if ((int )names.pn_version != 2) {
#line 3558
      if ((int )names.pn_version != 3) {
#line 3562
        if (! warned) {
          {
#line 3564
          tmp___8 = gettext("Only DWARF 2 and 3 pubnames are currently supported\n");
#line 3564
          warn((char const   *)tmp___8);
#line 3565
          warned = 1;
          }
        }
#line 3568
        goto while_continue;
      }
    }
    {
#line 3571
    tmp___9 = gettext("  Length:                              %ld\n");
#line 3571
    printf((char const   */* __restrict  */)tmp___9, (long )names.pn_length);
#line 3573
    tmp___10 = gettext("  Version:                             %d\n");
#line 3573
    printf((char const   */* __restrict  */)tmp___10, (int )names.pn_version);
#line 3575
    tmp___11 = gettext("  Offset into .debug_info section:     0x%lx\n");
#line 3575
    printf((char const   */* __restrict  */)tmp___11, (unsigned long )names.pn_offset);
#line 3577
    tmp___12 = gettext("  Size of area in .debug_info section: %ld\n");
#line 3577
    printf((char const   */* __restrict  */)tmp___12, (long )names.pn_size);
#line 3580
    tmp___13 = gettext("\n    Offset\tName\n");
#line 3580
    printf((char const   */* __restrict  */)tmp___13);
    }
    {
#line 3582
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 3584
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 3584
        if (8UL < (unsigned long )offset_size) {
#line 3584
          tmp___14 = -1;
        } else {
#line 3584
          tmp___14 = 1;
        }
        {
#line 3584
        __lengthofdummy___4 = (unsigned long )tmp___14;
#line 3584
        tmp___15 = __builtin_alloca(sizeof(*dummy___4) * __lengthofdummy___4);
#line 3584
        dummy___4 = (int *)tmp___15;
#line 3584
        amount___4 = offset_size;
        }
#line 3584
        if ((unsigned long )(data + amount___4) >= (unsigned long )end) {
#line 3584
          if ((unsigned long )data < (unsigned long )end) {
#line 3584
            amount___4 = (unsigned int )(end - data);
          } else {
#line 3584
            amount___4 = 0U;
          }
        }
#line 3584
        if (amount___4) {
          {
#line 3584
          tmp___16 = (*byte_get)(data, (int )amount___4);
#line 3584
          offset = (unsigned long )tmp___16;
          }
        } else {
#line 3584
          offset = 0UL;
        }
#line 3584
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 3586
      if (offset != 0UL) {
        {
#line 3588
        data += offset_size;
#line 3589
        printf((char const   */* __restrict  */)"    %-6lx\t%s\n", offset, data);
#line 3590
        tmp___17 = strnlen((char const   *)((char *)data), (size_t )(end - data));
#line 3590
        data += tmp___17 + 1UL;
        }
      }
#line 3582
      if (! (offset != 0UL)) {
#line 3582
        goto while_break___10;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3596
  printf((char const   */* __restrict  */)"\n");
  }
#line 3597
  return (1);
}
}
#line 3600 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_macinfo(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *curr ;
  unsigned int bytes_read ;
  enum dwarf_macinfo_record_type op ;
  char *tmp___0 ;
  unsigned int lineno ;
  unsigned char const   *string ;
  unsigned int filenum ;
  dwarf_vma tmp___1 ;
  dwarf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  dwarf_vma tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  dwarf_vma tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  unsigned int constant ;
  dwarf_vma tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 3604
  start = section->start;
#line 3605
  end = start + section->size;
#line 3606
  curr = start;
#line 3610
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3610
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3612
    if (! ((unsigned long )curr < (unsigned long )end)) {
#line 3612
      goto while_break;
    }
#line 3617
    op = (enum dwarf_macinfo_record_type )*curr;
#line 3618
    curr ++;
    {
#line 3622
    if ((unsigned int )op == 3U) {
#line 3622
      goto case_3;
    }
#line 3636
    if ((unsigned int )op == 4U) {
#line 3636
      goto case_4;
    }
#line 3640
    if ((unsigned int )op == 1U) {
#line 3640
      goto case_1;
    }
#line 3649
    if ((unsigned int )op == 2U) {
#line 3649
      goto case_2;
    }
#line 3658
    if ((unsigned int )op == 255U) {
#line 3658
      goto case_255;
    }
#line 3620
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 3626
    tmp___1 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3626
    lineno = (unsigned int )tmp___1;
#line 3627
    curr += bytes_read;
#line 3628
    tmp___2 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3628
    filenum = (unsigned int )tmp___2;
#line 3629
    curr += bytes_read;
#line 3631
    tmp___3 = gettext(" DW_MACINFO_start_file - lineno: %d filenum: %d\n");
#line 3631
    printf((char const   */* __restrict  */)tmp___3, lineno, filenum);
    }
#line 3634
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3637
    tmp___4 = gettext(" DW_MACINFO_end_file\n");
#line 3637
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 3638
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3641
    tmp___5 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3641
    lineno = (unsigned int )tmp___5;
#line 3642
    curr += bytes_read;
#line 3643
    string = (unsigned char const   *)curr;
#line 3644
    tmp___6 = strnlen((char const   *)((char *)string), (size_t )(end - (unsigned char *)string));
#line 3644
    curr += tmp___6 + 1UL;
#line 3645
    tmp___7 = gettext(" DW_MACINFO_define - lineno : %d macro : %s\n");
#line 3645
    printf((char const   */* __restrict  */)tmp___7, lineno, string);
    }
#line 3647
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 3650
    tmp___8 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3650
    lineno = (unsigned int )tmp___8;
#line 3651
    curr += bytes_read;
#line 3652
    string = (unsigned char const   *)curr;
#line 3653
    tmp___9 = strnlen((char const   *)((char *)string), (size_t )(end - (unsigned char *)string));
#line 3653
    curr += tmp___9 + 1UL;
#line 3654
    tmp___10 = gettext(" DW_MACINFO_undef - lineno : %d macro : %s\n");
#line 3654
    printf((char const   */* __restrict  */)tmp___10, lineno, string);
    }
#line 3656
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 3662
    tmp___11 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3662
    constant = (unsigned int )tmp___11;
#line 3663
    curr += bytes_read;
#line 3664
    string = (unsigned char const   *)curr;
#line 3665
    tmp___12 = strnlen((char const   *)((char *)string), (size_t )(end - (unsigned char *)string));
#line 3665
    curr += tmp___12 + 1UL;
#line 3666
    tmp___13 = gettext(" DW_MACINFO_vendor_ext - constant : %d string : %s\n");
#line 3666
    printf((char const   */* __restrict  */)tmp___13, constant, string);
    }
#line 3669
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3673
  return (1);
}
}
#line 3680 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned char *get_line_filename_and_dirname(dwarf_vma line_offset , dwarf_vma fileidx ,
                                                    unsigned char **dir_name ) 
{ 
  struct dwarf_section *section ;
  unsigned char *hdrptr ;
  unsigned char *dirtable ;
  unsigned char *file_name ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int version ;
  unsigned int opcode_base ;
  unsigned int bytes_read ;
  dwarf_vma length ;
  dwarf_vma diridx ;
  unsigned char const   *end ;
  unsigned int amount ;
  unsigned int amount___0 ;
  unsigned int amount___1 ;
  elf_vma tmp___0 ;
  unsigned int amount___2 ;
  elf_vma tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 3685
  section = & debug_displays[4].section;
#line 3692
  *dir_name = (unsigned char *)((void *)0);
#line 3693
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 3696
    return ((unsigned char *)((void *)0));
  } else
#line 3693
  if (line_offset >= section->size) {
#line 3696
    return ((unsigned char *)((void *)0));
  } else
#line 3693
  if (fileidx == 0ULL) {
#line 3696
    return ((unsigned char *)((void *)0));
  }
#line 3698
  hdrptr = section->start + line_offset;
#line 3699
  end = (unsigned char const   *)(section->start + section->size);
  {
#line 3701
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3701
      amount = 4U;
#line 3701
      if ((unsigned long )(hdrptr + amount) >= (unsigned long )end) {
#line 3701
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 3701
          amount = (unsigned int )(end - (unsigned char const   *)hdrptr);
        } else {
#line 3701
          amount = 0U;
        }
      }
#line 3701
      if (amount) {
        {
#line 3701
        length = (*byte_get)(hdrptr, (int )amount);
        }
      } else {
#line 3701
        length = (dwarf_vma )0;
      }
#line 3701
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3701
    hdrptr += 4;
#line 3701
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3702
  if (length == 4294967295ULL) {
    {
#line 3705
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 3705
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3705
        amount___0 = 8U;
#line 3705
        if ((unsigned long )(hdrptr + amount___0) >= (unsigned long )end) {
#line 3705
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 3705
            amount___0 = (unsigned int )(end - (unsigned char const   *)hdrptr);
          } else {
#line 3705
            amount___0 = 0U;
          }
        }
#line 3705
        if (amount___0) {
          {
#line 3705
          length = (*byte_get)(hdrptr, (int )amount___0);
          }
        } else {
#line 3705
          length = (dwarf_vma )0;
        }
#line 3705
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3705
      hdrptr += 8;
#line 3705
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3706
    offset_size = 8U;
#line 3707
    initial_length_size = 12U;
  } else {
#line 3711
    offset_size = 4U;
#line 3712
    initial_length_size = 4U;
  }
#line 3714
  if (length + (dwarf_vma )initial_length_size > section->size) {
#line 3715
    return ((unsigned char *)((void *)0));
  }
  {
#line 3717
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3717
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3717
      amount___1 = 2U;
#line 3717
      if ((unsigned long )(hdrptr + amount___1) >= (unsigned long )end) {
#line 3717
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 3717
          amount___1 = (unsigned int )(end - (unsigned char const   *)hdrptr);
        } else {
#line 3717
          amount___1 = 0U;
        }
      }
#line 3717
      if (amount___1) {
        {
#line 3717
        tmp___0 = (*byte_get)(hdrptr, (int )amount___1);
#line 3717
        version = (unsigned int )tmp___0;
        }
      } else {
#line 3717
        version = 0U;
      }
#line 3717
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3717
    hdrptr += 2;
#line 3717
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3718
  if (version != 2U) {
#line 3718
    if (version != 3U) {
#line 3718
      if (version != 4U) {
#line 3719
        return ((unsigned char *)((void *)0));
      }
    }
  }
#line 3720
  hdrptr += offset_size + 1U;
#line 3721
  if (version >= 4U) {
#line 3722
    hdrptr ++;
  }
#line 3723
  hdrptr += 3;
  {
#line 3725
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 3725
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3725
      amount___2 = 1U;
#line 3725
      if ((unsigned long )(hdrptr + amount___2) >= (unsigned long )end) {
#line 3725
        if ((unsigned long )hdrptr < (unsigned long )end) {
#line 3725
          amount___2 = (unsigned int )(end - (unsigned char const   *)hdrptr);
        } else {
#line 3725
          amount___2 = 0U;
        }
      }
#line 3725
      if (amount___2) {
        {
#line 3725
        tmp___1 = (*byte_get)(hdrptr, (int )amount___2);
#line 3725
        opcode_base = (unsigned int )tmp___1;
        }
      } else {
#line 3725
        opcode_base = 0U;
      }
#line 3725
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3725
    hdrptr ++;
#line 3725
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3726
  if (opcode_base == 0U) {
#line 3727
    return ((unsigned char *)((void *)0));
  }
#line 3729
  hdrptr += opcode_base - 1U;
#line 3730
  dirtable = hdrptr;
  {
#line 3732
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3732
    if (! ((int )*hdrptr != 0)) {
#line 3732
      goto while_break___7;
    }
    {
#line 3733
    tmp___2 = strnlen((char const   *)((char *)hdrptr), (size_t )(end - (unsigned char const   *)hdrptr));
#line 3733
    hdrptr += tmp___2 + 1UL;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3734
  hdrptr ++;
  {
#line 3736
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 3736
    if ((int )*hdrptr != 0) {
#line 3736
      if (! (fileidx > 1ULL)) {
#line 3736
        goto while_break___8;
      }
    } else {
#line 3736
      goto while_break___8;
    }
    {
#line 3738
    tmp___3 = strnlen((char const   *)((char *)hdrptr), (size_t )(end - (unsigned char const   *)hdrptr));
#line 3738
    hdrptr += tmp___3 + 1UL;
#line 3739
    read_uleb128(hdrptr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3740
    hdrptr += bytes_read;
#line 3741
    read_uleb128(hdrptr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3742
    hdrptr += bytes_read;
#line 3743
    read_uleb128(hdrptr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3744
    hdrptr += bytes_read;
#line 3736
    fileidx --;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 3746
  if ((unsigned long )hdrptr == (unsigned long )end) {
#line 3747
    return ((unsigned char *)((void *)0));
  } else
#line 3746
  if ((int )*hdrptr == 0) {
#line 3747
    return ((unsigned char *)((void *)0));
  }
  {
#line 3748
  file_name = hdrptr;
#line 3749
  tmp___4 = strnlen((char const   *)((char *)hdrptr), (size_t )(end - (unsigned char const   *)hdrptr));
#line 3749
  hdrptr += tmp___4 + 1UL;
#line 3750
  diridx = read_uleb128(hdrptr, & bytes_read, (unsigned char const   */* const  */)end);
  }
#line 3751
  if (diridx == 0ULL) {
#line 3752
    return (file_name);
  }
  {
#line 3753
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3753
    if ((int )*dirtable != 0) {
#line 3753
      if (! (diridx > 1ULL)) {
#line 3753
        goto while_break___9;
      }
    } else {
#line 3753
      goto while_break___9;
    }
    {
#line 3754
    tmp___5 = strnlen((char const   *)((char *)dirtable), (size_t )(end - (unsigned char const   *)dirtable));
#line 3754
    dirtable += tmp___5 + 1UL;
#line 3753
    diridx --;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3755
  if ((int )*dirtable == 0) {
#line 3756
    return ((unsigned char *)((void *)0));
  }
#line 3757
  *dir_name = dirtable;
#line 3758
  return (file_name);
}
}
#line 3761 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_macro(struct dwarf_section *section , void *file ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *curr ;
  unsigned char *extended_op_buf[256] ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  unsigned int lineno ;
  unsigned int version ;
  unsigned int flags___1 ;
  unsigned int offset_size ;
  unsigned char const   *string ;
  dwarf_vma line_offset ;
  dwarf_vma sec_offset ;
  dwarf_vma offset ;
  unsigned char **extended_ops ;
  unsigned int amount ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  unsigned int amount___0 ;
  elf_vma tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *dummy___1  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___1 ;
  void *tmp___8 ;
  unsigned int amount___1 ;
  char *tmp___9 ;
  unsigned int i ;
  unsigned int count ;
  unsigned int op ;
  dwarf_vma nargs ;
  dwarf_vma n ;
  unsigned int amount___2 ;
  elf_vma tmp___10 ;
  char *tmp___11 ;
  unsigned int amount___3 ;
  elf_vma tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned int form ;
  unsigned int amount___4 ;
  elf_vma tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  unsigned int op___0 ;
  char *tmp___20 ;
  unsigned int amount___5 ;
  elf_vma tmp___21 ;
  unsigned int filenum ;
  unsigned char *file_name ;
  unsigned char *dir_name ;
  dwarf_vma tmp___22 ;
  dwarf_vma tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  dwarf_vma tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  dwarf_vma tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  dwarf_vma tmp___36 ;
  int tmp___37 ;
  int *dummy___6  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___6 ;
  void *tmp___38 ;
  unsigned int amount___6 ;
  char *tmp___39 ;
  dwarf_vma tmp___40 ;
  int tmp___41 ;
  int *dummy___7  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___7 ;
  void *tmp___42 ;
  unsigned int amount___7 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *dummy___8  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___8 ;
  void *tmp___45 ;
  unsigned int amount___8 ;
  char *tmp___46 ;
  dwarf_vma tmp___47 ;
  int tmp___48 ;
  int *dummy___9  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___9 ;
  void *tmp___49 ;
  unsigned int amount___9 ;
  char *tmp___50 ;
  dwarf_vma tmp___51 ;
  int tmp___52 ;
  int *dummy___10  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___10 ;
  void *tmp___53 ;
  unsigned int amount___10 ;
  char *tmp___54 ;
  int tmp___55 ;
  int *dummy___11  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___11 ;
  void *tmp___56 ;
  unsigned int amount___11 ;
  char *tmp___57 ;
  char *tmp___58 ;
  dwarf_vma nargs___0 ;
  dwarf_vma n___0 ;
  unsigned char *desc ;
  char *tmp___59 ;
  char *tmp___60 ;
  int val ;
  unsigned int amount___12 ;
  elf_vma tmp___61 ;

  {
  {
#line 3765
  start = section->start;
#line 3766
  end = start + section->size;
#line 3767
  curr = start;
#line 3771
  load_debug_section((enum dwarf_section_display_enum )9, file);
#line 3772
  load_debug_section((enum dwarf_section_display_enum )4, file);
#line 3774
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3774
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3776
    if (! ((unsigned long )curr < (unsigned long )end)) {
#line 3776
      goto while_break;
    }
#line 3779
    offset_size = 4U;
#line 3781
    line_offset = (dwarf_vma )0;
#line 3781
    sec_offset = (dwarf_vma )(curr - start);
#line 3782
    extended_ops = (unsigned char **)((void *)0);
    {
#line 3784
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3784
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3784
        amount = 2U;
#line 3784
        if ((unsigned long )(curr + amount) >= (unsigned long )end) {
#line 3784
          if ((unsigned long )curr < (unsigned long )end) {
#line 3784
            amount = (unsigned int )(end - curr);
          } else {
#line 3784
            amount = 0U;
          }
        }
#line 3784
        if (amount) {
          {
#line 3784
          tmp___1 = (*byte_get)(curr, (int )amount);
#line 3784
          version = (unsigned int )tmp___1;
          }
        } else {
#line 3784
          version = 0U;
        }
#line 3784
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3784
      curr += 2;
#line 3784
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3785
    if (version != 4U) {
      {
#line 3787
      tmp___2 = gettext("Only GNU extension to DWARF 4 of %s is currently supported.\n");
#line 3787
      error((char const   *)tmp___2, section->name);
      }
#line 3789
      return (0);
    }
    {
#line 3792
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 3792
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3792
        amount___0 = 1U;
#line 3792
        if ((unsigned long )(curr + amount___0) >= (unsigned long )end) {
#line 3792
          if ((unsigned long )curr < (unsigned long )end) {
#line 3792
            amount___0 = (unsigned int )(end - curr);
          } else {
#line 3792
            amount___0 = 0U;
          }
        }
#line 3792
        if (amount___0) {
          {
#line 3792
          tmp___3 = (*byte_get)(curr, (int )amount___0);
#line 3792
          flags___1 = (unsigned int )tmp___3;
          }
        } else {
#line 3792
          flags___1 = 0U;
        }
#line 3792
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3792
      curr ++;
#line 3792
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3793
    if (flags___1 & 1U) {
#line 3794
      offset_size = 8U;
    }
    {
#line 3795
    tmp___4 = gettext("  Offset:                      0x%lx\n");
#line 3795
    printf((char const   */* __restrict  */)tmp___4, (unsigned long )sec_offset);
#line 3797
    tmp___5 = gettext("  Version:                     %d\n");
#line 3797
    printf((char const   */* __restrict  */)tmp___5, version);
#line 3798
    tmp___6 = gettext("  Offset size:                 %d\n");
#line 3798
    printf((char const   */* __restrict  */)tmp___6, offset_size);
    }
#line 3799
    if (flags___1 & 2U) {
      {
#line 3801
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 3801
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3801
          if (8UL < (unsigned long )offset_size) {
#line 3801
            tmp___7 = -1;
          } else {
#line 3801
            tmp___7 = 1;
          }
          {
#line 3801
          __lengthofdummy___1 = (unsigned long )tmp___7;
#line 3801
          tmp___8 = __builtin_alloca(sizeof(*dummy___1) * __lengthofdummy___1);
#line 3801
          dummy___1 = (int *)tmp___8;
#line 3801
          amount___1 = offset_size;
          }
#line 3801
          if ((unsigned long )(curr + amount___1) >= (unsigned long )end) {
#line 3801
            if ((unsigned long )curr < (unsigned long )end) {
#line 3801
              amount___1 = (unsigned int )(end - curr);
            } else {
#line 3801
              amount___1 = 0U;
            }
          }
#line 3801
          if (amount___1) {
            {
#line 3801
            line_offset = (*byte_get)(curr, (int )amount___1);
            }
          } else {
#line 3801
            line_offset = (dwarf_vma )0;
          }
#line 3801
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3801
        curr += offset_size;
#line 3801
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 3802
      tmp___9 = gettext("  Offset into .debug_line:     0x%lx\n");
#line 3802
      printf((char const   */* __restrict  */)tmp___9, (unsigned long )line_offset);
      }
    }
#line 3805
    if (flags___1 & 4U) {
      {
#line 3810
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 3810
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3810
          amount___2 = 1U;
#line 3810
          if ((unsigned long )(curr + amount___2) >= (unsigned long )end) {
#line 3810
            if ((unsigned long )curr < (unsigned long )end) {
#line 3810
              amount___2 = (unsigned int )(end - curr);
            } else {
#line 3810
              amount___2 = 0U;
            }
          }
#line 3810
          if (amount___2) {
            {
#line 3810
            tmp___10 = (*byte_get)(curr, (int )amount___2);
#line 3810
            count = (unsigned int )tmp___10;
            }
          } else {
#line 3810
            count = 0U;
          }
#line 3810
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3810
        curr ++;
#line 3810
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 3812
      memset((void *)(extended_op_buf), 0, sizeof(extended_op_buf));
#line 3813
      extended_ops = extended_op_buf;
      }
#line 3814
      if (count) {
        {
#line 3816
        tmp___11 = gettext("  Extension opcode arguments:\n");
#line 3816
        printf((char const   */* __restrict  */)tmp___11);
#line 3817
        i = 0U;
        }
        {
#line 3817
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 3817
          if (! (i < count)) {
#line 3817
            goto while_break___8;
          }
          {
#line 3819
          while (1) {
            while_continue___9: /* CIL Label */ ;
            {
#line 3819
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 3819
              amount___3 = 1U;
#line 3819
              if ((unsigned long )(curr + amount___3) >= (unsigned long )end) {
#line 3819
                if ((unsigned long )curr < (unsigned long )end) {
#line 3819
                  amount___3 = (unsigned int )(end - curr);
                } else {
#line 3819
                  amount___3 = 0U;
                }
              }
#line 3819
              if (amount___3) {
                {
#line 3819
                tmp___12 = (*byte_get)(curr, (int )amount___3);
#line 3819
                op = (unsigned int )tmp___12;
                }
              } else {
#line 3819
                op = 0U;
              }
#line 3819
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 3819
            curr ++;
#line 3819
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 3820
          *(extended_ops + op) = curr;
#line 3821
          nargs = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3822
          curr += bytes_read;
          }
#line 3823
          if (nargs == 0ULL) {
            {
#line 3824
            tmp___13 = gettext("    DW_MACRO_GNU_%02x has no arguments\n");
#line 3824
            printf((char const   */* __restrict  */)tmp___13, op);
            }
          } else {
            {
#line 3827
            tmp___14 = gettext("    DW_MACRO_GNU_%02x arguments: ");
#line 3827
            printf((char const   */* __restrict  */)tmp___14, op);
#line 3828
            n = (dwarf_vma )0;
            }
            {
#line 3828
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 3828
              if (! (n < nargs)) {
#line 3828
                goto while_break___11;
              }
              {
#line 3832
              while (1) {
                while_continue___12: /* CIL Label */ ;
                {
#line 3832
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 3832
                  amount___4 = 1U;
#line 3832
                  if ((unsigned long )(curr + amount___4) >= (unsigned long )end) {
#line 3832
                    if ((unsigned long )curr < (unsigned long )end) {
#line 3832
                      amount___4 = (unsigned int )(end - curr);
                    } else {
#line 3832
                      amount___4 = 0U;
                    }
                  }
#line 3832
                  if (amount___4) {
                    {
#line 3832
                    tmp___15 = (*byte_get)(curr, (int )amount___4);
#line 3832
                    form = (unsigned int )tmp___15;
                    }
                  } else {
#line 3832
                    form = 0U;
                  }
#line 3832
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
#line 3832
                curr ++;
#line 3832
                goto while_break___12;
              }
              while_break___12: /* CIL Label */ ;
              }
#line 3833
              if (n == nargs - 1ULL) {
#line 3833
                tmp___16 = "\n";
              } else {
#line 3833
                tmp___16 = ", ";
              }
              {
#line 3833
              tmp___17 = get_FORM_name((unsigned long )form);
#line 3833
              printf((char const   */* __restrict  */)"%s%s", tmp___17, tmp___16);
              }
              {
#line 3850
              if (form == 23U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 14U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 8U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 12U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 4U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 3U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 10U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 9U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 15U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 13U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 7U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 6U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 5U) {
#line 3850
                goto case_23;
              }
#line 3850
              if (form == 11U) {
#line 3850
                goto case_23;
              }
#line 3852
              goto switch_default;
              case_23: /* CIL Label */ 
              case_14: /* CIL Label */ 
              case_8: /* CIL Label */ 
              case_12: /* CIL Label */ 
              case_4: /* CIL Label */ 
              case_3: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_15: /* CIL Label */ 
              case_13: /* CIL Label */ 
              case_7: /* CIL Label */ 
              case_6: /* CIL Label */ 
              case_5: /* CIL Label */ 
              case_11: /* CIL Label */ 
#line 3851
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 3853
              tmp___18 = get_FORM_name((unsigned long )form);
#line 3853
              tmp___19 = gettext("Invalid extension opcode form %s\n");
#line 3853
              error((char const   *)tmp___19, tmp___18);
              }
#line 3855
              return (0);
              switch_break: /* CIL Label */ ;
              }
#line 3828
              n ++;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
#line 3817
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
    {
#line 3862
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 3864
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 3868
      if ((unsigned long )curr >= (unsigned long )end) {
        {
#line 3870
        tmp___20 = gettext(".debug_macro section not zero terminated\n");
#line 3870
        error((char const   *)tmp___20);
        }
#line 3871
        return (0);
      }
      {
#line 3874
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 3874
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 3874
          amount___5 = 1U;
#line 3874
          if ((unsigned long )(curr + amount___5) >= (unsigned long )end) {
#line 3874
            if ((unsigned long )curr < (unsigned long )end) {
#line 3874
              amount___5 = (unsigned int )(end - curr);
            } else {
#line 3874
              amount___5 = 0U;
            }
          }
#line 3874
          if (amount___5) {
            {
#line 3874
            tmp___21 = (*byte_get)(curr, (int )amount___5);
#line 3874
            op___0 = (unsigned int )tmp___21;
            }
          } else {
#line 3874
            op___0 = 0U;
          }
#line 3874
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 3874
        curr ++;
#line 3874
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 3875
      if (op___0 == 0U) {
#line 3876
        goto while_break___14;
      }
      {
#line 3880
      if (op___0 == 3U) {
#line 3880
        goto case_3___0;
      }
#line 3907
      if (op___0 == 4U) {
#line 3907
        goto case_4___0;
      }
#line 3911
      if (op___0 == 1U) {
#line 3911
        goto case_1;
      }
#line 3920
      if (op___0 == 2U) {
#line 3920
        goto case_2;
      }
#line 3929
      if (op___0 == 5U) {
#line 3929
        goto case_5___0;
      }
#line 3938
      if (op___0 == 6U) {
#line 3938
        goto case_6___0;
      }
#line 3947
      if (op___0 == 7U) {
#line 3947
        goto case_7___0;
      }
#line 3953
      if (op___0 == 8U) {
#line 3953
        goto case_8___0;
      }
#line 3961
      if (op___0 == 9U) {
#line 3961
        goto case_9___0;
      }
#line 3969
      if (op___0 == 10U) {
#line 3969
        goto case_10___0;
      }
#line 3975
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
      {
#line 3883
      file_name = (unsigned char *)((void *)0);
#line 3883
      dir_name = (unsigned char *)((void *)0);
#line 3885
      tmp___22 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3885
      lineno = (unsigned int )tmp___22;
#line 3886
      curr += bytes_read;
#line 3887
      tmp___23 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3887
      filenum = (unsigned int )tmp___23;
#line 3888
      curr += bytes_read;
      }
#line 3890
      if ((flags___1 & 2U) == 0U) {
        {
#line 3891
        tmp___24 = gettext("DW_MACRO_GNU_start_file used, but no .debug_line offset provided.\n");
#line 3891
        error((char const   *)tmp___24);
        }
      } else {
        {
#line 3893
        file_name = get_line_filename_and_dirname(line_offset, (dwarf_vma )filenum,
                                                  & dir_name);
        }
      }
#line 3896
      if ((unsigned long )file_name == (unsigned long )((void *)0)) {
        {
#line 3897
        tmp___25 = gettext(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d\n");
#line 3897
        printf((char const   */* __restrict  */)tmp___25, lineno, filenum);
        }
      } else {
#line 3900
        if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
#line 3900
          tmp___26 = "/";
        } else {
#line 3900
          tmp___26 = "";
        }
#line 3900
        if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
#line 3900
          tmp___27 = (char const   *)dir_name;
        } else {
#line 3900
          tmp___27 = "";
        }
        {
#line 3900
        tmp___28 = gettext(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d filename: %s%s%s\n");
#line 3900
        printf((char const   */* __restrict  */)tmp___28, lineno, filenum, tmp___27,
               tmp___26, file_name);
        }
      }
#line 3905
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 3908
      tmp___29 = gettext(" DW_MACRO_GNU_end_file\n");
#line 3908
      printf((char const   */* __restrict  */)tmp___29);
      }
#line 3909
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 3912
      tmp___30 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3912
      lineno = (unsigned int )tmp___30;
#line 3913
      curr += bytes_read;
#line 3914
      string = (unsigned char const   *)curr;
#line 3915
      tmp___31 = strnlen((char const   *)((char *)string), (size_t )(end - (unsigned char *)string));
#line 3915
      curr += tmp___31 + 1UL;
#line 3916
      tmp___32 = gettext(" DW_MACRO_GNU_define - lineno : %d macro : %s\n");
#line 3916
      printf((char const   */* __restrict  */)tmp___32, lineno, string);
      }
#line 3918
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 3921
      tmp___33 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3921
      lineno = (unsigned int )tmp___33;
#line 3922
      curr += bytes_read;
#line 3923
      string = (unsigned char const   *)curr;
#line 3924
      tmp___34 = strnlen((char const   *)((char *)string), (size_t )(end - (unsigned char *)string));
#line 3924
      curr += tmp___34 + 1UL;
#line 3925
      tmp___35 = gettext(" DW_MACRO_GNU_undef - lineno : %d macro : %s\n");
#line 3925
      printf((char const   */* __restrict  */)tmp___35, lineno, string);
      }
#line 3927
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 3930
      tmp___36 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3930
      lineno = (unsigned int )tmp___36;
#line 3931
      curr += bytes_read;
      }
      {
#line 3932
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 3932
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 3932
          if (8UL < (unsigned long )offset_size) {
#line 3932
            tmp___37 = -1;
          } else {
#line 3932
            tmp___37 = 1;
          }
          {
#line 3932
          __lengthofdummy___6 = (unsigned long )tmp___37;
#line 3932
          tmp___38 = __builtin_alloca(sizeof(*dummy___6) * __lengthofdummy___6);
#line 3932
          dummy___6 = (int *)tmp___38;
#line 3932
          amount___6 = offset_size;
          }
#line 3932
          if ((unsigned long )(curr + amount___6) >= (unsigned long )end) {
#line 3932
            if ((unsigned long )curr < (unsigned long )end) {
#line 3932
              amount___6 = (unsigned int )(end - curr);
            } else {
#line 3932
              amount___6 = 0U;
            }
          }
#line 3932
          if (amount___6) {
            {
#line 3932
            offset = (*byte_get)(curr, (int )amount___6);
            }
          } else {
#line 3932
            offset = (dwarf_vma )0;
          }
#line 3932
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 3932
        curr += offset_size;
#line 3932
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 3933
      string = fetch_indirect_string(offset);
#line 3934
      tmp___39 = gettext(" DW_MACRO_GNU_define_indirect - lineno : %d macro : %s\n");
#line 3934
      printf((char const   */* __restrict  */)tmp___39, lineno, string);
      }
#line 3936
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      {
#line 3939
      tmp___40 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3939
      lineno = (unsigned int )tmp___40;
#line 3940
      curr += bytes_read;
      }
      {
#line 3941
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 3941
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 3941
          if (8UL < (unsigned long )offset_size) {
#line 3941
            tmp___41 = -1;
          } else {
#line 3941
            tmp___41 = 1;
          }
          {
#line 3941
          __lengthofdummy___7 = (unsigned long )tmp___41;
#line 3941
          tmp___42 = __builtin_alloca(sizeof(*dummy___7) * __lengthofdummy___7);
#line 3941
          dummy___7 = (int *)tmp___42;
#line 3941
          amount___7 = offset_size;
          }
#line 3941
          if ((unsigned long )(curr + amount___7) >= (unsigned long )end) {
#line 3941
            if ((unsigned long )curr < (unsigned long )end) {
#line 3941
              amount___7 = (unsigned int )(end - curr);
            } else {
#line 3941
              amount___7 = 0U;
            }
          }
#line 3941
          if (amount___7) {
            {
#line 3941
            offset = (*byte_get)(curr, (int )amount___7);
            }
          } else {
#line 3941
            offset = (dwarf_vma )0;
          }
#line 3941
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 3941
        curr += offset_size;
#line 3941
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 3942
      string = fetch_indirect_string(offset);
#line 3943
      tmp___43 = gettext(" DW_MACRO_GNU_undef_indirect - lineno : %d macro : %s\n");
#line 3943
      printf((char const   */* __restrict  */)tmp___43, lineno, string);
      }
#line 3945
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 3948
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 3948
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 3948
          if (8UL < (unsigned long )offset_size) {
#line 3948
            tmp___44 = -1;
          } else {
#line 3948
            tmp___44 = 1;
          }
          {
#line 3948
          __lengthofdummy___8 = (unsigned long )tmp___44;
#line 3948
          tmp___45 = __builtin_alloca(sizeof(*dummy___8) * __lengthofdummy___8);
#line 3948
          dummy___8 = (int *)tmp___45;
#line 3948
          amount___8 = offset_size;
          }
#line 3948
          if ((unsigned long )(curr + amount___8) >= (unsigned long )end) {
#line 3948
            if ((unsigned long )curr < (unsigned long )end) {
#line 3948
              amount___8 = (unsigned int )(end - curr);
            } else {
#line 3948
              amount___8 = 0U;
            }
          }
#line 3948
          if (amount___8) {
            {
#line 3948
            offset = (*byte_get)(curr, (int )amount___8);
            }
          } else {
#line 3948
            offset = (dwarf_vma )0;
          }
#line 3948
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
#line 3948
        curr += offset_size;
#line 3948
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 3949
      tmp___46 = gettext(" DW_MACRO_GNU_transparent_include - offset : 0x%lx\n");
#line 3949
      printf((char const   */* __restrict  */)tmp___46, (unsigned long )offset);
      }
#line 3951
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 3954
      tmp___47 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3954
      lineno = (unsigned int )tmp___47;
#line 3955
      curr += bytes_read;
      }
      {
#line 3956
      while (1) {
        while_continue___23: /* CIL Label */ ;
        {
#line 3956
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 3956
          if (8UL < (unsigned long )offset_size) {
#line 3956
            tmp___48 = -1;
          } else {
#line 3956
            tmp___48 = 1;
          }
          {
#line 3956
          __lengthofdummy___9 = (unsigned long )tmp___48;
#line 3956
          tmp___49 = __builtin_alloca(sizeof(*dummy___9) * __lengthofdummy___9);
#line 3956
          dummy___9 = (int *)tmp___49;
#line 3956
          amount___9 = offset_size;
          }
#line 3956
          if ((unsigned long )(curr + amount___9) >= (unsigned long )end) {
#line 3956
            if ((unsigned long )curr < (unsigned long )end) {
#line 3956
              amount___9 = (unsigned int )(end - curr);
            } else {
#line 3956
              amount___9 = 0U;
            }
          }
#line 3956
          if (amount___9) {
            {
#line 3956
            offset = (*byte_get)(curr, (int )amount___9);
            }
          } else {
#line 3956
            offset = (dwarf_vma )0;
          }
#line 3956
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 3956
        curr += offset_size;
#line 3956
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
      {
#line 3957
      tmp___50 = gettext(" DW_MACRO_GNU_define_indirect_alt - lineno : %d macro offset : 0x%lx\n");
#line 3957
      printf((char const   */* __restrict  */)tmp___50, lineno, (unsigned long )offset);
      }
#line 3959
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 3962
      tmp___51 = read_uleb128(curr, & bytes_read, (unsigned char const   */* const  */)end);
#line 3962
      lineno = (unsigned int )tmp___51;
#line 3963
      curr += bytes_read;
      }
      {
#line 3964
      while (1) {
        while_continue___25: /* CIL Label */ ;
        {
#line 3964
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 3964
          if (8UL < (unsigned long )offset_size) {
#line 3964
            tmp___52 = -1;
          } else {
#line 3964
            tmp___52 = 1;
          }
          {
#line 3964
          __lengthofdummy___10 = (unsigned long )tmp___52;
#line 3964
          tmp___53 = __builtin_alloca(sizeof(*dummy___10) * __lengthofdummy___10);
#line 3964
          dummy___10 = (int *)tmp___53;
#line 3964
          amount___10 = offset_size;
          }
#line 3964
          if ((unsigned long )(curr + amount___10) >= (unsigned long )end) {
#line 3964
            if ((unsigned long )curr < (unsigned long )end) {
#line 3964
              amount___10 = (unsigned int )(end - curr);
            } else {
#line 3964
              amount___10 = 0U;
            }
          }
#line 3964
          if (amount___10) {
            {
#line 3964
            offset = (*byte_get)(curr, (int )amount___10);
            }
          } else {
#line 3964
            offset = (dwarf_vma )0;
          }
#line 3964
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 3964
        curr += offset_size;
#line 3964
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 3965
      tmp___54 = gettext(" DW_MACRO_GNU_undef_indirect_alt - lineno : %d macro offset : 0x%lx\n");
#line 3965
      printf((char const   */* __restrict  */)tmp___54, lineno, (unsigned long )offset);
      }
#line 3967
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 3970
      while (1) {
        while_continue___27: /* CIL Label */ ;
        {
#line 3970
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 3970
          if (8UL < (unsigned long )offset_size) {
#line 3970
            tmp___55 = -1;
          } else {
#line 3970
            tmp___55 = 1;
          }
          {
#line 3970
          __lengthofdummy___11 = (unsigned long )tmp___55;
#line 3970
          tmp___56 = __builtin_alloca(sizeof(*dummy___11) * __lengthofdummy___11);
#line 3970
          dummy___11 = (int *)tmp___56;
#line 3970
          amount___11 = offset_size;
          }
#line 3970
          if ((unsigned long )(curr + amount___11) >= (unsigned long )end) {
#line 3970
            if ((unsigned long )curr < (unsigned long )end) {
#line 3970
              amount___11 = (unsigned int )(end - curr);
            } else {
#line 3970
              amount___11 = 0U;
            }
          }
#line 3970
          if (amount___11) {
            {
#line 3970
            offset = (*byte_get)(curr, (int )amount___11);
            }
          } else {
#line 3970
            offset = (dwarf_vma )0;
          }
#line 3970
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }
#line 3970
        curr += offset_size;
#line 3970
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
      {
#line 3971
      tmp___57 = gettext(" DW_MACRO_GNU_transparent_include_alt - offset : 0x%lx\n");
#line 3971
      printf((char const   */* __restrict  */)tmp___57, (unsigned long )offset);
      }
#line 3973
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3976
      if ((unsigned long )extended_ops == (unsigned long )((void *)0)) {
        {
#line 3978
        tmp___58 = gettext(" Unknown macro opcode %02x seen\n");
#line 3978
        error((char const   *)tmp___58, op___0);
        }
#line 3979
        return (0);
      } else
#line 3976
      if ((unsigned long )*(extended_ops + op___0) == (unsigned long )((void *)0)) {
        {
#line 3978
        tmp___58 = gettext(" Unknown macro opcode %02x seen\n");
#line 3978
        error((char const   *)tmp___58, op___0);
        }
#line 3979
        return (0);
      } else {
        {
#line 3985
        desc = *(extended_ops + op___0);
#line 3986
        nargs___0 = read_uleb128(desc, & bytes_read, (unsigned char const   */* const  */)end);
#line 3987
        desc += bytes_read;
        }
#line 3988
        if (nargs___0 == 0ULL) {
          {
#line 3990
          tmp___59 = gettext(" DW_MACRO_GNU_%02x\n");
#line 3990
          printf((char const   */* __restrict  */)tmp___59, op___0);
          }
#line 3991
          goto switch_break___0;
        }
        {
#line 3993
        tmp___60 = gettext(" DW_MACRO_GNU_%02x -");
#line 3993
        printf((char const   */* __restrict  */)tmp___60, op___0);
#line 3994
        n___0 = (dwarf_vma )0;
        }
        {
#line 3994
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 3994
          if (! (n___0 < nargs___0)) {
#line 3994
            goto while_break___29;
          }
          {
#line 3998
          while (1) {
            while_continue___30: /* CIL Label */ ;
            {
#line 3998
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 3998
              amount___12 = 1U;
#line 3998
              if ((unsigned long )(desc + amount___12) >= (unsigned long )end) {
#line 3998
                if ((unsigned long )desc < (unsigned long )end) {
#line 3998
                  amount___12 = (unsigned int )(end - desc);
                } else {
#line 3998
                  amount___12 = 0U;
                }
              }
#line 3998
              if (amount___12) {
                {
#line 3998
                tmp___61 = (*byte_get)(desc, (int )amount___12);
#line 3998
                val = (int )tmp___61;
                }
              } else {
#line 3998
                val = 0;
              }
#line 3998
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
#line 3998
            desc ++;
#line 3998
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 3999
          curr = read_and_display_attr_value(0UL, (unsigned long )val, curr, end,
                                             (dwarf_vma )0, (dwarf_vma )0, (dwarf_vma )offset_size,
                                             (int )version, (debug_info *)((void *)0),
                                             0, (struct dwarf_section *)((void *)0),
                                             (struct cu_tu_set *)((void *)0));
          }
#line 4004
          if (n___0 != nargs___0 - 1ULL) {
            {
#line 4005
            printf((char const   */* __restrict  */)",");
            }
          }
#line 3994
          n___0 ++;
        }
        while_break___29: /* CIL Label */ ;
        }
        {
#line 4007
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 4009
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 4013
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4016
  return (1);
}
}
#line 4019 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_abbrev(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  abbrev_entry *entry ;
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *last ;
  char *tmp___1 ;
  abbrev_attr *attr ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 4024
  start = section->start;
#line 4025
  end = start + section->size;
#line 4027
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 4027
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 4029
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4033
    free_abbrevs();
#line 4035
    last = start;
#line 4036
    start = process_abbrev_section(start, end);
    }
#line 4038
    if ((unsigned long )first_abbrev == (unsigned long )((void *)0)) {
#line 4039
      goto __Cont;
    }
    {
#line 4041
    tmp___1 = gettext("  Number TAG (0x%lx)\n");
#line 4041
    printf((char const   */* __restrict  */)tmp___1, last - section->start);
#line 4043
    entry = first_abbrev;
    }
    {
#line 4043
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4043
      if (! entry) {
#line 4043
        goto while_break___0;
      }
#line 4047
      if (entry->children) {
        {
#line 4047
        tmp___2 = gettext("has children");
#line 4047
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 4047
        tmp___3 = gettext("no children");
#line 4047
        tmp___4 = tmp___3;
        }
      }
      {
#line 4047
      tmp___5 = get_TAG_name(entry->tag);
#line 4047
      printf((char const   */* __restrict  */)"   %ld      %s    [%s]\n", entry->entry,
             tmp___5, tmp___4);
#line 4052
      attr = entry->first_attr;
      }
      {
#line 4052
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4052
        if (! attr) {
#line 4052
          goto while_break___1;
        }
        {
#line 4053
        tmp___6 = get_FORM_name(attr->form);
#line 4053
        tmp___7 = get_AT_name(attr->attribute);
#line 4053
        printf((char const   */* __restrict  */)"    %-18s %s\n", tmp___7, tmp___6);
#line 4052
        attr = attr->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4043
      entry = entry->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 4029
    if (! start) {
#line 4029
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4060
  printf((char const   */* __restrict  */)"\n");
  }
#line 4062
  return (1);
}
}
#line 4067 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void display_loc_list(struct dwarf_section *section , unsigned char **start_ptr ,
                             int debug_info_entry , unsigned long offset , unsigned long base_address ,
                             int has_frame_base ) 
{ 
  unsigned char *start ;
  unsigned char *section_end ;
  unsigned long cu_offset ;
  unsigned int pointer_size ;
  unsigned int offset_size ;
  int dwarf_version ;
  dwarf_vma begin ;
  dwarf_vma end ;
  unsigned short length ;
  int need_frame_base ;
  char *tmp___0 ;
  int tmp___1 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___2 ;
  unsigned int amount ;
  int tmp___3 ;
  int *dummy___0  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___0 ;
  void *tmp___4 ;
  unsigned int amount___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned int amount___1 ;
  elf_vma tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 4075
  start = *start_ptr;
#line 4076
  section_end = section->start + section->size;
#line 4077
  cu_offset = (unsigned long )(debug_information + debug_info_entry)->cu_offset;
#line 4078
  pointer_size = (debug_information + debug_info_entry)->pointer_size;
#line 4079
  offset_size = (debug_information + debug_info_entry)->offset_size;
#line 4080
  dwarf_version = (debug_information + debug_info_entry)->dwarf_version;
  {
#line 4087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4089
    if ((unsigned long )(start + 2U * pointer_size) > (unsigned long )section_end) {
      {
#line 4091
      tmp___0 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4091
      warn((char const   *)tmp___0, offset);
      }
#line 4093
      goto while_break;
    }
    {
#line 4096
    printf((char const   */* __restrict  */)"    %8.8lx ", offset + (unsigned long )(start - *start_ptr));
    }
    {
#line 4102
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4102
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4102
        if (8UL < (unsigned long )pointer_size) {
#line 4102
          tmp___1 = -1;
        } else {
#line 4102
          tmp___1 = 1;
        }
        {
#line 4102
        __lengthofdummy = (unsigned long )tmp___1;
#line 4102
        tmp___2 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 4102
        dummy = (int *)tmp___2;
#line 4102
        amount = pointer_size;
        }
#line 4102
        if ((unsigned long )(start + amount) >= (unsigned long )section_end) {
#line 4102
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4102
            amount = (unsigned int )(section_end - start);
          } else {
#line 4102
            amount = 0U;
          }
        }
#line 4102
        if (amount) {
          {
#line 4102
          begin = (*byte_get)(start, (int )amount);
          }
        } else {
#line 4102
          begin = (dwarf_vma )0;
        }
#line 4102
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4102
      start += pointer_size;
#line 4102
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4103
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 4103
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4103
        if (8UL < (unsigned long )pointer_size) {
#line 4103
          tmp___3 = -1;
        } else {
#line 4103
          tmp___3 = 1;
        }
        {
#line 4103
        __lengthofdummy___0 = (unsigned long )tmp___3;
#line 4103
        tmp___4 = __builtin_alloca(sizeof(*dummy___0) * __lengthofdummy___0);
#line 4103
        dummy___0 = (int *)tmp___4;
#line 4103
        amount___0 = pointer_size;
        }
#line 4103
        if ((unsigned long )(start + amount___0) >= (unsigned long )section_end) {
#line 4103
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4103
            amount___0 = (unsigned int )(section_end - start);
          } else {
#line 4103
            amount___0 = 0U;
          }
        }
#line 4103
        if (amount___0) {
          {
#line 4103
          end = (*byte_get)(start, (int )amount___0);
          }
        } else {
#line 4103
          end = (dwarf_vma )0;
        }
#line 4103
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4103
      start += pointer_size;
#line 4103
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4105
    if (begin == 0ULL) {
#line 4105
      if (end == 0ULL) {
        {
#line 4107
        tmp___5 = gettext("<End of list>\n");
#line 4107
        printf((char const   */* __restrict  */)tmp___5);
        }
#line 4108
        goto while_break;
      }
    }
#line 4112
    if (begin == 0xffffffffffffffffULL) {
#line 4112
      if (end != 0xffffffffffffffffULL) {
        {
#line 4114
        base_address = (unsigned long )end;
#line 4115
        print_dwarf_vma(begin, pointer_size);
#line 4116
        print_dwarf_vma(end, pointer_size);
#line 4117
        tmp___6 = gettext("(base address)\n");
#line 4117
        printf((char const   */* __restrict  */)tmp___6);
        }
#line 4118
        goto while_continue;
      }
    }
#line 4121
    if ((unsigned long )(start + 2) > (unsigned long )section_end) {
      {
#line 4123
      tmp___7 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4123
      warn((char const   *)tmp___7, offset);
      }
#line 4125
      goto while_break;
    }
    {
#line 4128
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 4128
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 4128
        amount___1 = 2U;
#line 4128
        if ((unsigned long )(start + amount___1) >= (unsigned long )section_end) {
#line 4128
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4128
            amount___1 = (unsigned int )(section_end - start);
          } else {
#line 4128
            amount___1 = 0U;
          }
        }
#line 4128
        if (amount___1) {
          {
#line 4128
          tmp___8 = (*byte_get)(start, (int )amount___1);
#line 4128
          length = (unsigned short )tmp___8;
          }
        } else {
#line 4128
          length = (unsigned short)0;
        }
#line 4128
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 4128
      start += 2;
#line 4128
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 4130
    if ((unsigned long )(start + (int )length) > (unsigned long )section_end) {
      {
#line 4132
      tmp___9 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4132
      warn((char const   *)tmp___9, offset);
      }
#line 4134
      goto while_break;
    }
    {
#line 4137
    print_dwarf_vma(begin + (dwarf_vma )base_address, pointer_size);
#line 4138
    print_dwarf_vma(end + (dwarf_vma )base_address, pointer_size);
#line 4140
    putchar('(');
#line 4141
    need_frame_base = decode_location_expression(start, pointer_size, offset_size,
                                                 dwarf_version, (dwarf_vma )length,
                                                 (dwarf_vma )cu_offset, section);
#line 4147
    putchar(')');
    }
#line 4149
    if (need_frame_base) {
#line 4149
      if (! has_frame_base) {
        {
#line 4150
        tmp___10 = gettext(" [without DW_AT_frame_base]");
#line 4150
        printf((char const   */* __restrict  */)tmp___10);
        }
      }
    }
#line 4152
    if (begin == end) {
      {
#line 4153
      tmp___11 = gettext(" (start == end)");
#line 4153
      fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stdout);
      }
    } else
#line 4154
    if (begin > end) {
      {
#line 4155
      tmp___12 = gettext(" (start > end)");
#line 4155
      fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 4157
    putchar('\n');
#line 4159
    start += (int )length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4162
  *start_ptr = start;
#line 4163
  return;
}
}
#line 4171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char buf___3[15]  ;
#line 4168 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void print_addr_index(unsigned int idx___0 , unsigned int len ) 
{ 


  {
  {
#line 4172
  snprintf((char */* __restrict  */)(buf___3), sizeof(buf___3), (char const   */* __restrict  */)"[%d]",
           idx___0);
#line 4173
  printf((char const   */* __restrict  */)"%*s ", len, buf___3);
  }
#line 4174
  return;
}
}
#line 4180 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void display_loc_list_dwo(struct dwarf_section *section , unsigned char **start_ptr ,
                                 int debug_info_entry , unsigned long offset , int has_frame_base ) 
{ 
  unsigned char *start ;
  unsigned char *section_end ;
  unsigned long cu_offset ;
  unsigned int pointer_size ;
  unsigned int offset_size ;
  int dwarf_version ;
  int entry_type ;
  unsigned short length ;
  int need_frame_base ;
  unsigned int idx___0 ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  unsigned int amount ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  dwarf_vma tmp___3 ;
  char *tmp___4 ;
  dwarf_vma tmp___5 ;
  dwarf_vma tmp___6 ;
  dwarf_vma tmp___7 ;
  unsigned int amount___0 ;
  elf_vma tmp___8 ;
  unsigned int amount___1 ;
  elf_vma tmp___9 ;
  unsigned int amount___2 ;
  elf_vma tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned int amount___3 ;
  elf_vma tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 4187
  start = *start_ptr;
#line 4188
  section_end = section->start + section->size;
#line 4189
  cu_offset = (unsigned long )(debug_information + debug_info_entry)->cu_offset;
#line 4190
  pointer_size = (debug_information + debug_info_entry)->pointer_size;
#line 4191
  offset_size = (debug_information + debug_info_entry)->offset_size;
#line 4192
  dwarf_version = (debug_information + debug_info_entry)->dwarf_version;
  {
#line 4199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4201
    printf((char const   */* __restrict  */)"    %8.8lx ", offset + (unsigned long )(start - *start_ptr));
    }
#line 4203
    if ((unsigned long )start >= (unsigned long )section_end) {
      {
#line 4205
      tmp___0 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4205
      warn((char const   *)tmp___0, offset);
      }
#line 4207
      goto while_break;
    }
    {
#line 4210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4210
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4210
        amount = 1U;
#line 4210
        if ((unsigned long )(start + amount) >= (unsigned long )section_end) {
#line 4210
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4210
            amount = (unsigned int )(section_end - start);
          } else {
#line 4210
            amount = 0U;
          }
        }
#line 4210
        if (amount) {
          {
#line 4210
          tmp___1 = (*byte_get)(start, (int )amount);
#line 4210
          entry_type = (int )tmp___1;
          }
        } else {
#line 4210
          entry_type = 0;
        }
#line 4210
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4210
      start ++;
#line 4210
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4213
    if (entry_type == 0) {
#line 4213
      goto case_0;
    }
#line 4217
    if (entry_type == 1) {
#line 4217
      goto case_1;
    }
#line 4224
    if (entry_type == 2) {
#line 4224
      goto case_2;
    }
#line 4232
    if (entry_type == 3) {
#line 4232
      goto case_3;
    }
#line 4239
    if (entry_type == 4) {
#line 4239
      goto case_4;
    }
#line 4245
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 4214
    *start_ptr = start;
#line 4215
    tmp___2 = gettext("<End of list>\n");
#line 4215
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 4216
    return;
    case_1: /* CIL Label */ 
    {
#line 4218
    tmp___3 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)section_end);
#line 4218
    idx___0 = (unsigned int )tmp___3;
#line 4219
    start += bytes_read;
#line 4220
    print_addr_index(idx___0, 8U);
#line 4221
    printf((char const   */* __restrict  */)"         ");
#line 4222
    tmp___4 = gettext("(base address selection entry)\n");
#line 4222
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 4223
    goto while_continue;
    case_2: /* CIL Label */ 
    {
#line 4225
    tmp___5 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)section_end);
#line 4225
    idx___0 = (unsigned int )tmp___5;
#line 4226
    start += bytes_read;
#line 4227
    print_addr_index(idx___0, 8U);
#line 4228
    tmp___6 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)section_end);
#line 4228
    idx___0 = (unsigned int )tmp___6;
#line 4229
    start += bytes_read;
#line 4230
    print_addr_index(idx___0, 8U);
    }
#line 4231
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 4233
    tmp___7 = read_uleb128(start, & bytes_read, (unsigned char const   */* const  */)section_end);
#line 4233
    idx___0 = (unsigned int )tmp___7;
#line 4234
    start += bytes_read;
#line 4235
    print_addr_index(idx___0, 8U);
    }
    {
#line 4236
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 4236
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4236
        amount___0 = 4U;
#line 4236
        if ((unsigned long )(start + amount___0) >= (unsigned long )section_end) {
#line 4236
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4236
            amount___0 = (unsigned int )(section_end - start);
          } else {
#line 4236
            amount___0 = 0U;
          }
        }
#line 4236
        if (amount___0) {
          {
#line 4236
          tmp___8 = (*byte_get)(start, (int )amount___0);
#line 4236
          idx___0 = (unsigned int )tmp___8;
          }
        } else {
#line 4236
          idx___0 = 0U;
        }
#line 4236
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4236
      start += 4;
#line 4236
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 4237
    printf((char const   */* __restrict  */)"%08x ", idx___0);
    }
#line 4238
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 4240
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 4240
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 4240
        amount___1 = 4U;
#line 4240
        if ((unsigned long )(start + amount___1) >= (unsigned long )section_end) {
#line 4240
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4240
            amount___1 = (unsigned int )(section_end - start);
          } else {
#line 4240
            amount___1 = 0U;
          }
        }
#line 4240
        if (amount___1) {
          {
#line 4240
          tmp___9 = (*byte_get)(start, (int )amount___1);
#line 4240
          idx___0 = (unsigned int )tmp___9;
          }
        } else {
#line 4240
          idx___0 = 0U;
        }
#line 4240
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 4240
      start += 4;
#line 4240
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 4241
    printf((char const   */* __restrict  */)"%08x ", idx___0);
    }
    {
#line 4242
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 4242
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 4242
        amount___2 = 4U;
#line 4242
        if ((unsigned long )(start + amount___2) >= (unsigned long )section_end) {
#line 4242
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4242
            amount___2 = (unsigned int )(section_end - start);
          } else {
#line 4242
            amount___2 = 0U;
          }
        }
#line 4242
        if (amount___2) {
          {
#line 4242
          tmp___10 = (*byte_get)(start, (int )amount___2);
#line 4242
          idx___0 = (unsigned int )tmp___10;
          }
        } else {
#line 4242
          idx___0 = 0U;
        }
#line 4242
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 4242
      start += 4;
#line 4242
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 4243
    printf((char const   */* __restrict  */)"%08x ", idx___0);
    }
#line 4244
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 4246
    tmp___11 = gettext("Unknown location list entry type 0x%x.\n");
#line 4246
    warn((char const   *)tmp___11, entry_type);
#line 4247
    *start_ptr = start;
    }
#line 4248
    return;
    switch_break: /* CIL Label */ ;
    }
#line 4251
    if ((unsigned long )(start + 2) > (unsigned long )section_end) {
      {
#line 4253
      tmp___12 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4253
      warn((char const   *)tmp___12, offset);
      }
#line 4255
      goto while_break;
    }
    {
#line 4258
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 4258
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 4258
        amount___3 = 2U;
#line 4258
        if ((unsigned long )(start + amount___3) >= (unsigned long )section_end) {
#line 4258
          if ((unsigned long )start < (unsigned long )section_end) {
#line 4258
            amount___3 = (unsigned int )(section_end - start);
          } else {
#line 4258
            amount___3 = 0U;
          }
        }
#line 4258
        if (amount___3) {
          {
#line 4258
          tmp___13 = (*byte_get)(start, (int )amount___3);
#line 4258
          length = (unsigned short )tmp___13;
          }
        } else {
#line 4258
          length = (unsigned short)0;
        }
#line 4258
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 4258
      start += 2;
#line 4258
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 4259
    if ((unsigned long )(start + (int )length) > (unsigned long )section_end) {
      {
#line 4261
      tmp___14 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 4261
      warn((char const   *)tmp___14, offset);
      }
#line 4263
      goto while_break;
    }
    {
#line 4266
    putchar('(');
#line 4267
    need_frame_base = decode_location_expression(start, pointer_size, offset_size,
                                                 dwarf_version, (dwarf_vma )length,
                                                 (dwarf_vma )cu_offset, section);
#line 4273
    putchar(')');
    }
#line 4275
    if (need_frame_base) {
#line 4275
      if (! has_frame_base) {
        {
#line 4276
        tmp___15 = gettext(" [without DW_AT_frame_base]");
#line 4276
        printf((char const   */* __restrict  */)tmp___15);
        }
      }
    }
    {
#line 4278
    putchar('\n');
#line 4280
    start += (int )length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4283
  *start_ptr = start;
#line 4284
  return;
}
}
#line 4288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static dwarf_vma *loc_offsets  ;
#line 4290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int loc_offsets_compar(void const   *ap , void const   *bp ) 
{ 
  dwarf_vma a ;
  dwarf_vma b ;

  {
#line 4293
  a = *(loc_offsets + *((unsigned int const   *)ap));
#line 4294
  b = *(loc_offsets + *((unsigned int const   *)bp));
#line 4296
  return ((a > b) - (b > a));
}
}
#line 4299 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_loc(struct dwarf_section *section , void *file ) 
{ 
  unsigned char *start ;
  unsigned long bytes ;
  unsigned char *section_begin ;
  unsigned int num_loc_list ;
  unsigned long last_offset ;
  unsigned int first ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int seen_first_offset ;
  int locs_sorted ;
  unsigned char *next ;
  unsigned int *array ;
  char const   *suffix ;
  char *tmp___0 ;
  int is_dwo ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int num ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned long offset ;
  unsigned long base_address ;
  int has_frame_base ;
  unsigned int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 4302
  start = section->start;
#line 4304
  section_begin = start;
#line 4305
  num_loc_list = 0U;
#line 4306
  last_offset = 0UL;
#line 4307
  first = 0U;
#line 4311
  seen_first_offset = 0;
#line 4312
  locs_sorted = 1;
#line 4314
  array = (unsigned int *)((void *)0);
#line 4315
  tmp___0 = strrchr(section->name, '.');
#line 4315
  suffix = (char const   *)tmp___0;
#line 4316
  is_dwo = 0;
  }
#line 4318
  if (suffix) {
    {
#line 4318
    tmp___1 = strcmp(suffix, ".dwo");
    }
#line 4318
    if (tmp___1 == 0) {
#line 4319
      is_dwo = 1;
    }
  }
#line 4321
  bytes = (unsigned long )section->size;
#line 4323
  if (bytes == 0UL) {
    {
#line 4325
    tmp___2 = gettext("\nThe %s section is empty.\n");
#line 4325
    printf((char const   */* __restrict  */)tmp___2, section->name);
    }
#line 4326
    return (0);
  }
  {
#line 4329
  tmp___4 = load_debug_info(file);
  }
#line 4329
  if (tmp___4 == 0U) {
    {
#line 4331
    tmp___3 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4331
    warn((char const   *)tmp___3, section->name);
    }
#line 4333
    return (0);
  }
#line 4339
  i = 0U;
  {
#line 4339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4339
    if (! (i < num_debug_info_entries)) {
#line 4339
      goto while_break;
    }
#line 4343
    num = (debug_information + i)->num_loc_offsets;
#line 4344
    if (num > num_loc_list) {
#line 4345
      num_loc_list = num;
    }
#line 4348
    if (locs_sorted) {
#line 4348
      if (num != 0U) {
#line 4350
        if (! seen_first_offset) {
#line 4353
          last_offset = (unsigned long )*((debug_information + i)->loc_offsets + 0);
#line 4354
          first = i;
#line 4355
          seen_first_offset = 1;
#line 4356
          j = 1U;
        } else {
#line 4359
          j = 0U;
        }
        {
#line 4361
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4361
          if (! (j < num)) {
#line 4361
            goto while_break___0;
          }
#line 4363
          if ((dwarf_vma )last_offset > *((debug_information + i)->loc_offsets + j)) {
#line 4366
            locs_sorted = 0;
#line 4367
            goto while_break___0;
          }
#line 4369
          last_offset = (unsigned long )*((debug_information + i)->loc_offsets + j);
#line 4361
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 4339
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4374
  if (! seen_first_offset) {
    {
#line 4375
    tmp___5 = gettext("No location lists in .debug_info section!\n");
#line 4375
    error((char const   *)tmp___5);
    }
  }
#line 4378
  if ((debug_information + first)->num_loc_offsets > 0U) {
#line 4378
    if (*((debug_information + first)->loc_offsets + 0) != section->address) {
      {
#line 4380
      tmp___6 = dwarf_vmatoa("x", *((debug_information + first)->loc_offsets + 0));
#line 4380
      tmp___7 = gettext("Location lists in %s section start at 0x%s\n");
#line 4380
      warn((char const   *)tmp___7, section->name, tmp___6);
      }
    }
  }
#line 4384
  if (! locs_sorted) {
    {
#line 4385
    tmp___8 = xcmalloc((size_t )num_loc_list, sizeof(unsigned int ));
#line 4385
    array = (unsigned int *)tmp___8;
    }
  }
  {
#line 4386
  tmp___9 = gettext("Contents of the %s section:\n\n");
#line 4386
  printf((char const   */* __restrict  */)tmp___9, section->name);
#line 4387
  tmp___10 = gettext("    Offset   Begin    End      Expression\n");
#line 4387
  printf((char const   */* __restrict  */)tmp___10);
#line 4389
  seen_first_offset = 0;
#line 4390
  i = first;
  }
  {
#line 4390
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4390
    if (! (i < num_debug_info_entries)) {
#line 4390
      goto while_break___1;
    }
#line 4396
    if (! locs_sorted) {
#line 4398
      k = 0U;
      {
#line 4398
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4398
        if (! (k < (debug_information + i)->num_loc_offsets)) {
#line 4398
          goto while_break___2;
        }
#line 4399
        *(array + k) = k;
#line 4398
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 4400
      loc_offsets = (debug_information + i)->loc_offsets;
#line 4401
      qsort((void *)array, (size_t )(debug_information + i)->num_loc_offsets, sizeof(*array),
            & loc_offsets_compar);
      }
    }
#line 4405
    k = 0U;
    {
#line 4405
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4405
      if (! (k < (debug_information + i)->num_loc_offsets)) {
#line 4405
        goto while_break___3;
      }
#line 4407
      if (locs_sorted) {
#line 4407
        j = k;
      } else {
#line 4407
        j = *(array + k);
      }
#line 4408
      if (k) {
#line 4408
        if (locs_sorted) {
#line 4408
          tmp___11 = k - 1U;
        } else {
#line 4408
          tmp___11 = *(array + (k - 1U));
        }
#line 4408
        if (*((debug_information + i)->loc_offsets + tmp___11) == *((debug_information + i)->loc_offsets + j)) {
#line 4412
          goto __Cont;
        }
      }
#line 4413
      has_frame_base = *((debug_information + i)->have_frame_base + j);
#line 4415
      offset = (unsigned long )(*((debug_information + i)->loc_offsets + j) - section->address);
#line 4416
      next = section_begin + offset;
#line 4417
      base_address = (unsigned long )(debug_information + i)->base_address;
#line 4419
      if (! seen_first_offset) {
#line 4420
        seen_first_offset = 1;
      } else
#line 4423
      if ((unsigned long )start < (unsigned long )next) {
        {
#line 4424
        tmp___12 = gettext("There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n");
#line 4424
        warn((char const   *)tmp___12, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin));
        }
      } else
#line 4427
      if ((unsigned long )start > (unsigned long )next) {
        {
#line 4428
        tmp___13 = gettext("There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n");
#line 4428
        warn((char const   *)tmp___13, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin));
        }
      }
#line 4432
      start = next;
#line 4434
      if (offset >= bytes) {
        {
#line 4436
        tmp___14 = gettext("Offset 0x%lx is bigger than .debug_loc section size.\n");
#line 4436
        warn((char const   *)tmp___14, offset);
        }
#line 4438
        goto __Cont;
      }
#line 4441
      if (is_dwo) {
        {
#line 4442
        display_loc_list_dwo(section, & start, (int )i, offset, has_frame_base);
        }
      } else {
        {
#line 4444
        display_loc_list(section, & start, (int )i, offset, base_address, has_frame_base);
        }
      }
      __Cont: /* CIL Label */ 
#line 4405
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4390
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4449
  if ((unsigned long )start < (unsigned long )(section->start + section->size)) {
    {
#line 4450
    tmp___15 = gettext("There are %ld unused bytes at the end of section %s\n");
#line 4450
    warn((char const   *)tmp___15, (section->start + section->size) - start, section->name);
    }
  }
  {
#line 4452
  putchar('\n');
#line 4453
  free((void *)array);
  }
#line 4454
  return (1);
}
}
#line 4457 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_str(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned long bytes ;
  dwarf_vma addr ;
  char *tmp___0 ;
  char *tmp___1 ;
  int j ;
  int k ;
  int lbytes ;

  {
#line 4461
  start = section->start;
#line 4462
  bytes = (unsigned long )section->size;
#line 4463
  addr = section->address;
#line 4465
  if (bytes == 0UL) {
    {
#line 4467
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4467
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4468
    return (0);
  }
  {
#line 4471
  tmp___1 = gettext("Contents of the %s section:\n\n");
#line 4471
  printf((char const   */* __restrict  */)tmp___1, section->name);
  }
  {
#line 4473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4473
    if (! bytes) {
#line 4473
      goto while_break;
    }
#line 4479
    if (bytes > 16UL) {
#line 4479
      lbytes = 16;
    } else {
#line 4479
      lbytes = (int )bytes;
    }
    {
#line 4481
    printf((char const   */* __restrict  */)"  0x%8.8lx ", (unsigned long )addr);
#line 4483
    j = 0;
    }
    {
#line 4483
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4483
      if (! (j < 16)) {
#line 4483
        goto while_break___0;
      }
#line 4485
      if (j < lbytes) {
        {
#line 4486
        printf((char const   */* __restrict  */)"%2.2x", (int )*(start + j));
        }
      } else {
        {
#line 4488
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 4490
      if ((j & 3) == 3) {
        {
#line 4491
        printf((char const   */* __restrict  */)" ");
        }
      }
#line 4483
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4494
    j = 0;
    {
#line 4494
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4494
      if (! (j < lbytes)) {
#line 4494
        goto while_break___1;
      }
#line 4496
      k = (int )*(start + j);
#line 4497
      if (k >= 32) {
#line 4497
        if (k < 128) {
          {
#line 4498
          printf((char const   */* __restrict  */)"%c", k);
          }
        } else {
          {
#line 4500
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 4500
        printf((char const   */* __restrict  */)".");
        }
      }
#line 4494
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4503
    putchar('\n');
#line 4505
    start += lbytes;
#line 4506
    addr += (dwarf_vma )lbytes;
#line 4507
    bytes -= (unsigned long )lbytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4510
  putchar('\n');
  }
#line 4512
  return (1);
}
}
#line 4515 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_info(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4518
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 0);
  }
#line 4518
  return (tmp___0);
}
}
#line 4521 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_types(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4524
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 1);
  }
#line 4524
  return (tmp___0);
}
}
#line 4527 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_trace_info(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4530
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 0);
  }
#line 4530
  return (tmp___0);
}
}
#line 4533 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_aranges(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *hdrptr ;
  DWARF2_Internal_ARange arange ;
  unsigned char *addr_ranges ;
  dwarf_vma length ;
  dwarf_vma address ;
  unsigned char address_size ;
  int excess ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int amount ;
  unsigned int amount___0 ;
  unsigned int amount___1 ;
  elf_vma tmp___1 ;
  int tmp___2 ;
  int *dummy___2  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___2 ;
  void *tmp___3 ;
  unsigned int amount___2 ;
  char *tmp___4 ;
  debug_info *tmp___5 ;
  unsigned int amount___3 ;
  elf_vma tmp___6 ;
  unsigned int amount___4 ;
  elf_vma tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *dummy___5  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___5 ;
  void *tmp___19 ;
  unsigned int amount___5 ;
  int tmp___20 ;
  int *dummy___6  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___6 ;
  void *tmp___21 ;
  unsigned int amount___6 ;

  {
  {
#line 4537
  start = section->start;
#line 4538
  end = start + section->size;
#line 4540
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 4540
  printf((char const   */* __restrict  */)tmp___0, section->name);
#line 4544
  load_debug_info(file);
  }
  {
#line 4546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4546
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 4546
      goto while_break;
    }
#line 4558
    hdrptr = start;
    {
#line 4560
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4560
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4560
        amount = 4U;
#line 4560
        if ((unsigned long )(hdrptr + amount) >= (unsigned long )end) {
#line 4560
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4560
            amount = (unsigned int )(end - hdrptr);
          } else {
#line 4560
            amount = 0U;
          }
        }
#line 4560
        if (amount) {
          {
#line 4560
          arange.ar_length = (*byte_get)(hdrptr, (int )amount);
          }
        } else {
#line 4560
          arange.ar_length = (dwarf_vma )0;
        }
#line 4560
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4560
      hdrptr += 4;
#line 4560
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4561
    if (arange.ar_length == 4294967295ULL) {
      {
#line 4563
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 4563
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4563
          amount___0 = 8U;
#line 4563
          if ((unsigned long )(hdrptr + amount___0) >= (unsigned long )end) {
#line 4563
            if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4563
              amount___0 = (unsigned int )(end - hdrptr);
            } else {
#line 4563
              amount___0 = 0U;
            }
          }
#line 4563
          if (amount___0) {
            {
#line 4563
            arange.ar_length = (*byte_get)(hdrptr, (int )amount___0);
            }
          } else {
#line 4563
            arange.ar_length = (dwarf_vma )0;
          }
#line 4563
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 4563
        hdrptr += 8;
#line 4563
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 4564
      offset_size = 8U;
#line 4565
      initial_length_size = 12U;
    } else {
#line 4569
      offset_size = 4U;
#line 4570
      initial_length_size = 4U;
    }
    {
#line 4573
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 4573
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 4573
        amount___1 = 2U;
#line 4573
        if ((unsigned long )(hdrptr + amount___1) >= (unsigned long )end) {
#line 4573
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4573
            amount___1 = (unsigned int )(end - hdrptr);
          } else {
#line 4573
            amount___1 = 0U;
          }
        }
#line 4573
        if (amount___1) {
          {
#line 4573
          tmp___1 = (*byte_get)(hdrptr, (int )amount___1);
#line 4573
          arange.ar_version = (unsigned short )tmp___1;
          }
        } else {
#line 4573
          arange.ar_version = (unsigned short)0;
        }
#line 4573
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 4573
      hdrptr += 2;
#line 4573
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 4574
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 4574
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 4574
        if (8UL < (unsigned long )offset_size) {
#line 4574
          tmp___2 = -1;
        } else {
#line 4574
          tmp___2 = 1;
        }
        {
#line 4574
        __lengthofdummy___2 = (unsigned long )tmp___2;
#line 4574
        tmp___3 = __builtin_alloca(sizeof(*dummy___2) * __lengthofdummy___2);
#line 4574
        dummy___2 = (int *)tmp___3;
#line 4574
        amount___2 = offset_size;
        }
#line 4574
        if ((unsigned long )(hdrptr + amount___2) >= (unsigned long )end) {
#line 4574
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4574
            amount___2 = (unsigned int )(end - hdrptr);
          } else {
#line 4574
            amount___2 = 0U;
          }
        }
#line 4574
        if (amount___2) {
          {
#line 4574
          arange.ar_info_offset = (*byte_get)(hdrptr, (int )amount___2);
          }
        } else {
#line 4574
          arange.ar_info_offset = (dwarf_vma )0;
        }
#line 4574
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 4574
      hdrptr += offset_size;
#line 4574
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 4576
    if (num_debug_info_entries != 4294967295U) {
#line 4576
      if (num_debug_info_entries > 0U) {
        {
#line 4576
        tmp___5 = find_debug_info_for_offset((unsigned long )arange.ar_info_offset);
        }
#line 4576
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          {
#line 4579
          tmp___4 = gettext(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n");
#line 4579
          warn((char const   *)tmp___4, (unsigned long )arange.ar_info_offset, section->name);
          }
        }
      }
    }
    {
#line 4582
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 4582
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 4582
        amount___3 = 1U;
#line 4582
        if ((unsigned long )(hdrptr + amount___3) >= (unsigned long )end) {
#line 4582
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4582
            amount___3 = (unsigned int )(end - hdrptr);
          } else {
#line 4582
            amount___3 = 0U;
          }
        }
#line 4582
        if (amount___3) {
          {
#line 4582
          tmp___6 = (*byte_get)(hdrptr, (int )amount___3);
#line 4582
          arange.ar_pointer_size = (unsigned char )tmp___6;
          }
        } else {
#line 4582
          arange.ar_pointer_size = (unsigned char)0;
        }
#line 4582
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 4582
      hdrptr ++;
#line 4582
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 4583
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 4583
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 4583
        amount___4 = 1U;
#line 4583
        if ((unsigned long )(hdrptr + amount___4) >= (unsigned long )end) {
#line 4583
          if ((unsigned long )hdrptr < (unsigned long )end) {
#line 4583
            amount___4 = (unsigned int )(end - hdrptr);
          } else {
#line 4583
            amount___4 = 0U;
          }
        }
#line 4583
        if (amount___4) {
          {
#line 4583
          tmp___7 = (*byte_get)(hdrptr, (int )amount___4);
#line 4583
          arange.ar_segment_size = (unsigned char )tmp___7;
          }
        } else {
#line 4583
          arange.ar_segment_size = (unsigned char)0;
        }
#line 4583
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 4583
      hdrptr ++;
#line 4583
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 4585
    if ((int )arange.ar_version != 2) {
#line 4585
      if ((int )arange.ar_version != 3) {
        {
#line 4587
        tmp___8 = gettext("Only DWARF 2 and 3 aranges are currently supported.\n");
#line 4587
        warn((char const   *)tmp___8);
        }
#line 4588
        goto while_break;
      }
    }
    {
#line 4591
    tmp___9 = gettext("  Length:                   %ld\n");
#line 4591
    printf((char const   */* __restrict  */)tmp___9, (long )arange.ar_length);
#line 4593
    tmp___10 = gettext("  Version:                  %d\n");
#line 4593
    printf((char const   */* __restrict  */)tmp___10, (int )arange.ar_version);
#line 4594
    tmp___11 = gettext("  Offset into .debug_info:  0x%lx\n");
#line 4594
    printf((char const   */* __restrict  */)tmp___11, (unsigned long )arange.ar_info_offset);
#line 4596
    tmp___12 = gettext("  Pointer Size:             %d\n");
#line 4596
    printf((char const   */* __restrict  */)tmp___12, (int )arange.ar_pointer_size);
#line 4597
    tmp___13 = gettext("  Segment Size:             %d\n");
#line 4597
    printf((char const   */* __restrict  */)tmp___13, (int )arange.ar_segment_size);
#line 4599
    address_size = (unsigned char )((int )arange.ar_pointer_size + (int )arange.ar_segment_size);
    }
#line 4601
    if ((int )address_size == 0) {
      {
#line 4603
      tmp___14 = gettext("Invalid address size in %s section!\n");
#line 4603
      error((char const   *)tmp___14, section->name);
      }
#line 4605
      goto while_break;
    }
#line 4611
    if (((int )address_size & ((int )address_size - 1)) != 0) {
      {
#line 4613
      tmp___15 = gettext("Pointer size + Segment size is not a power of two.\n");
#line 4613
      warn((char const   *)tmp___15);
      }
#line 4614
      goto while_break;
    }
#line 4617
    if ((int )address_size > 4) {
      {
#line 4618
      tmp___16 = gettext("\n    Address            Length\n");
#line 4618
      printf((char const   */* __restrict  */)tmp___16);
      }
    } else {
      {
#line 4620
      tmp___17 = gettext("\n    Address    Length\n");
#line 4620
      printf((char const   */* __restrict  */)tmp___17);
      }
    }
#line 4622
    addr_ranges = hdrptr;
#line 4625
    excess = (int )((hdrptr - start) % (long )(2 * (int )address_size));
#line 4626
    if (excess) {
#line 4627
      addr_ranges += 2 * (int )address_size - excess;
    }
#line 4629
    start += arange.ar_length + (dwarf_vma )initial_length_size;
    {
#line 4631
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 4631
      if (! ((unsigned long )(addr_ranges + 2 * (int )address_size) <= (unsigned long )start)) {
#line 4631
        goto while_break___12;
      }
      {
#line 4633
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 4633
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4633
          if (8UL < (unsigned long )address_size) {
#line 4633
            tmp___18 = -1;
          } else {
#line 4633
            tmp___18 = 1;
          }
          {
#line 4633
          __lengthofdummy___5 = (unsigned long )tmp___18;
#line 4633
          tmp___19 = __builtin_alloca(sizeof(*dummy___5) * __lengthofdummy___5);
#line 4633
          dummy___5 = (int *)tmp___19;
#line 4633
          amount___5 = (unsigned int )address_size;
          }
#line 4633
          if ((unsigned long )(addr_ranges + amount___5) >= (unsigned long )end) {
#line 4633
            if ((unsigned long )addr_ranges < (unsigned long )end) {
#line 4633
              amount___5 = (unsigned int )(end - addr_ranges);
            } else {
#line 4633
              amount___5 = 0U;
            }
          }
#line 4633
          if (amount___5) {
            {
#line 4633
            address = (*byte_get)(addr_ranges, (int )amount___5);
            }
          } else {
#line 4633
            address = (dwarf_vma )0;
          }
#line 4633
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 4633
        addr_ranges += (int )address_size;
#line 4633
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 4634
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 4634
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 4634
          if (8UL < (unsigned long )address_size) {
#line 4634
            tmp___20 = -1;
          } else {
#line 4634
            tmp___20 = 1;
          }
          {
#line 4634
          __lengthofdummy___6 = (unsigned long )tmp___20;
#line 4634
          tmp___21 = __builtin_alloca(sizeof(*dummy___6) * __lengthofdummy___6);
#line 4634
          dummy___6 = (int *)tmp___21;
#line 4634
          amount___6 = (unsigned int )address_size;
          }
#line 4634
          if ((unsigned long )(addr_ranges + amount___6) >= (unsigned long )end) {
#line 4634
            if ((unsigned long )addr_ranges < (unsigned long )end) {
#line 4634
              amount___6 = (unsigned int )(end - addr_ranges);
            } else {
#line 4634
              amount___6 = 0U;
            }
          }
#line 4634
          if (amount___6) {
            {
#line 4634
            length = (*byte_get)(addr_ranges, (int )amount___6);
            }
          } else {
#line 4634
            length = (dwarf_vma )0;
          }
#line 4634
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 4634
        addr_ranges += (int )address_size;
#line 4634
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 4636
      printf((char const   */* __restrict  */)"    ");
#line 4637
      print_dwarf_vma(address, (unsigned int )address_size);
#line 4638
      print_dwarf_vma(length, (unsigned int )address_size);
#line 4639
      putchar('\n');
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4643
  printf((char const   */* __restrict  */)"\n");
  }
#line 4645
  return (1);
}
}
#line 4649 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int comp_addr_base(void const   *v0 , void const   *v1 ) 
{ 
  debug_info *info0 ;
  debug_info *info1 ;

  {
#line 4652
  info0 = (debug_info *)v0;
#line 4653
  info1 = (debug_info *)v1;
#line 4654
  return ((int )(info0->addr_base - info1->addr_base));
}
}
#line 4658 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_addr(struct dwarf_section *section , void *file ) 
{ 
  debug_info **debug_addr_info ;
  unsigned char *entry ;
  unsigned char *end ;
  unsigned int i ;
  unsigned int count ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  void *tmp___6 ;
  unsigned int idx___0 ;
  unsigned int address_size ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  dwarf_vma base ;
  elf_vma tmp___10 ;
  char *tmp___11 ;

  {
#line 4668
  if (section->size == 0ULL) {
    {
#line 4670
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4670
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4671
    return (0);
  }
  {
#line 4674
  tmp___2 = load_debug_info(file);
  }
#line 4674
  if (tmp___2 == 0U) {
    {
#line 4676
    tmp___1 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4676
    warn((char const   *)tmp___1, section->name);
    }
#line 4678
    return (0);
  }
  {
#line 4681
  tmp___3 = gettext("Contents of the %s section:\n\n");
#line 4681
  printf((char const   */* __restrict  */)tmp___3, section->name);
#line 4683
  tmp___4 = xmalloc((unsigned long )(num_debug_info_entries + 1U) * sizeof(debug_info *));
#line 4683
  debug_addr_info = (debug_info **)tmp___4;
#line 4686
  count = 0U;
#line 4687
  i = 0U;
  }
  {
#line 4687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4687
    if (! (i < num_debug_info_entries)) {
#line 4687
      goto while_break;
    }
#line 4689
    if ((debug_information + i)->addr_base != 4294967295ULL) {
#line 4690
      tmp___5 = count;
#line 4690
      count ++;
#line 4690
      *(debug_addr_info + tmp___5) = debug_information + i;
    }
#line 4687
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4694
  tmp___6 = xmalloc(sizeof(debug_info ));
#line 4694
  *(debug_addr_info + count) = (debug_info *)tmp___6;
#line 4695
  (*(debug_addr_info + count))->addr_base = section->size;
#line 4697
  qsort((void *)debug_addr_info, (size_t )count, sizeof(debug_info *), & comp_addr_base);
#line 4698
  i = 0U;
  }
  {
#line 4698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4698
    if (! (i < count)) {
#line 4698
      goto while_break___0;
    }
    {
#line 4701
    address_size = (*(debug_addr_info + i))->pointer_size;
#line 4703
    tmp___7 = dwarf_vmatoa("x", (*(debug_addr_info + i))->cu_offset);
#line 4703
    tmp___8 = gettext("  For compilation unit at offset 0x%s:\n");
#line 4703
    printf((char const   */* __restrict  */)tmp___8, tmp___7);
#line 4706
    tmp___9 = gettext("\tIndex\tAddress\n");
#line 4706
    printf((char const   */* __restrict  */)tmp___9);
#line 4707
    entry = section->start + (*(debug_addr_info + i))->addr_base;
#line 4708
    end = section->start + (*(debug_addr_info + (i + 1U)))->addr_base;
#line 4709
    idx___0 = 0U;
    }
    {
#line 4710
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4710
      if (! ((unsigned long )entry < (unsigned long )end)) {
#line 4710
        goto while_break___1;
      }
      {
#line 4712
      tmp___10 = (*byte_get)(entry, (int )address_size);
#line 4712
      base = tmp___10;
#line 4713
      tmp___11 = gettext("\t%d:\t");
#line 4713
      printf((char const   */* __restrict  */)tmp___11, idx___0);
#line 4714
      print_dwarf_vma(base, address_size);
#line 4715
      printf((char const   */* __restrict  */)"\n");
#line 4716
      entry += address_size;
#line 4717
      idx___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4698
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4720
  printf((char const   */* __restrict  */)"\n");
#line 4722
  free((void *)debug_addr_info);
  }
#line 4723
  return (1);
}
}
#line 4727 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_str_offsets(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  char *tmp___0 ;

  {
#line 4731
  if (section->size == 0ULL) {
    {
#line 4733
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4733
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4734
    return (0);
  }
#line 4738
  return (1);
}
}
#line 4755 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int range_entry_compar(void const   *ap , void const   *bp ) 
{ 
  struct range_entry  const  *a_re ;
  struct range_entry  const  *b_re ;
  unsigned long a ;
  unsigned long b ;

  {
#line 4758
  a_re = (struct range_entry  const  *)ap;
#line 4759
  b_re = (struct range_entry  const  *)bp;
#line 4760
  a = (unsigned long )a_re->ranges_offset;
#line 4761
  b = (unsigned long )b_re->ranges_offset;
#line 4763
  return ((a > b) - (b > a));
}
}
#line 4766 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_ranges(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *last_start ;
  unsigned long bytes ;
  unsigned char *section_begin ;
  unsigned char *finish ;
  unsigned int num_range_list ;
  unsigned int i ;
  struct range_entry *range_entries ;
  struct range_entry *range_entry_fill ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  debug_info *debug_info_p ;
  unsigned int j ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct range_entry *range_entry ;
  debug_info *debug_info_p___0 ;
  unsigned int pointer_size ;
  unsigned long offset ;
  unsigned char *next ;
  unsigned long base_address ;
  char *tmp___8 ;
  char *tmp___9 ;
  dwarf_vma begin ;
  dwarf_vma end ;
  int tmp___10 ;
  int *dummy  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy ;
  void *tmp___11 ;
  unsigned int amount ;
  unsigned int amount___0 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 4770
  start = section->start;
#line 4771
  last_start = start;
#line 4772
  bytes = (unsigned long )section->size;
#line 4773
  section_begin = start;
#line 4774
  finish = start + bytes;
#line 4778
  if (bytes == 0UL) {
    {
#line 4780
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4780
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4781
    return (0);
  }
  {
#line 4784
  tmp___2 = load_debug_info(file);
  }
#line 4784
  if (tmp___2 == 0U) {
    {
#line 4786
    tmp___1 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4786
    warn((char const   *)tmp___1, section->name);
    }
#line 4788
    return (0);
  }
#line 4791
  num_range_list = 0U;
#line 4792
  i = 0U;
  {
#line 4792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4792
    if (! (i < num_debug_info_entries)) {
#line 4792
      goto while_break;
    }
#line 4793
    num_range_list += (debug_information + i)->num_range_lists;
#line 4792
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4795
  if (num_range_list == 0U) {
    {
#line 4799
    tmp___3 = gettext("No range lists in .debug_info section.\n");
#line 4799
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 4800
    return (1);
  }
  {
#line 4803
  tmp___4 = xmalloc(sizeof(*range_entries) * (unsigned long )num_range_list);
#line 4803
  range_entries = (struct range_entry *)tmp___4;
#line 4805
  range_entry_fill = range_entries;
#line 4807
  i = 0U;
  }
  {
#line 4807
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4807
    if (! (i < num_debug_info_entries)) {
#line 4807
      goto while_break___0;
    }
#line 4809
    debug_info_p = debug_information + i;
#line 4812
    j = 0U;
    {
#line 4812
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4812
      if (! (j < debug_info_p->num_range_lists)) {
#line 4812
        goto while_break___1;
      }
#line 4814
      range_entry_fill->ranges_offset = (unsigned long )*(debug_info_p->range_lists + j);
#line 4815
      range_entry_fill->debug_info_p = debug_info_p;
#line 4816
      range_entry_fill ++;
#line 4812
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4807
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4820
  qsort((void *)range_entries, (size_t )num_range_list, sizeof(*range_entries), & range_entry_compar);
  }
#line 4824
  if (dwarf_check != 0) {
#line 4824
    if ((dwarf_vma )(range_entries + 0)->ranges_offset != section->address) {
      {
#line 4825
      tmp___5 = gettext("Range lists in %s section start at 0x%lx\n");
#line 4825
      warn((char const   *)tmp___5, section->name, (range_entries + 0)->ranges_offset);
      }
    }
  }
  {
#line 4828
  tmp___6 = gettext("Contents of the %s section:\n\n");
#line 4828
  printf((char const   */* __restrict  */)tmp___6, section->name);
#line 4829
  tmp___7 = gettext("    Offset   Begin    End\n");
#line 4829
  printf((char const   */* __restrict  */)tmp___7);
#line 4831
  i = 0U;
  }
  {
#line 4831
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4831
    if (! (i < num_range_list)) {
#line 4831
      goto while_break___2;
    }
#line 4833
    range_entry = range_entries + i;
#line 4834
    debug_info_p___0 = range_entry->debug_info_p;
#line 4840
    pointer_size = debug_info_p___0->pointer_size;
#line 4843
    offset = (unsigned long )((dwarf_vma )range_entry->ranges_offset - section->address);
#line 4844
    next = section_begin + offset;
#line 4845
    base_address = (unsigned long )debug_info_p___0->base_address;
#line 4847
    if (dwarf_check != 0) {
#line 4847
      if (i > 0U) {
#line 4849
        if ((unsigned long )start < (unsigned long )next) {
          {
#line 4850
          tmp___8 = gettext("There is a hole [0x%lx - 0x%lx] in %s section.\n");
#line 4850
          warn((char const   *)tmp___8, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin),
               section->name);
          }
        } else
#line 4853
        if ((unsigned long )start > (unsigned long )next) {
#line 4855
          if ((unsigned long )next == (unsigned long )last_start) {
#line 4856
            goto __Cont;
          }
          {
#line 4857
          tmp___9 = gettext("There is an overlap [0x%lx - 0x%lx] in %s section.\n");
#line 4857
          warn((char const   *)tmp___9, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin),
               section->name);
          }
        }
      }
    }
#line 4862
    start = next;
#line 4863
    last_start = next;
    {
#line 4865
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4865
      if (! ((unsigned long )start < (unsigned long )finish)) {
#line 4865
        goto while_break___3;
      }
      {
#line 4875
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 4875
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 4875
          if (8UL < (unsigned long )pointer_size) {
#line 4875
            tmp___10 = -1;
          } else {
#line 4875
            tmp___10 = 1;
          }
          {
#line 4875
          __lengthofdummy = (unsigned long )tmp___10;
#line 4875
          tmp___11 = __builtin_alloca(sizeof(*dummy) * __lengthofdummy);
#line 4875
          dummy = (int *)tmp___11;
#line 4875
          amount = pointer_size;
          }
#line 4875
          if ((unsigned long )(start + amount) >= (unsigned long )finish) {
#line 4875
            if ((unsigned long )start < (unsigned long )finish) {
#line 4875
              amount = (unsigned int )(finish - start);
            } else {
#line 4875
              amount = 0U;
            }
          }
#line 4875
          if (amount) {
            {
#line 4875
            begin = (*byte_get)(start, (int )amount);
            }
          } else {
#line 4875
            begin = (dwarf_vma )0;
          }
#line 4875
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 4875
        start += pointer_size;
#line 4875
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4876
      if ((unsigned long )start >= (unsigned long )finish) {
#line 4877
        goto while_break___3;
      }
      {
#line 4878
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 4878
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 4878
          amount___0 = pointer_size;
#line 4878
          if ((unsigned long )(start + amount___0) >= (unsigned long )finish) {
#line 4878
            if ((unsigned long )start < (unsigned long )finish) {
#line 4878
              amount___0 = (unsigned int )(finish - start);
            } else {
#line 4878
              amount___0 = 0U;
            }
          }
#line 4878
          if (amount___0) {
            {
#line 4878
            end = byte_get_signed(start, (int )amount___0);
            }
          } else {
#line 4878
            end = (dwarf_vma )0;
          }
#line 4878
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 4878
        start += pointer_size;
#line 4878
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 4880
      printf((char const   */* __restrict  */)"    %8.8lx ", offset);
      }
#line 4882
      if (begin == 0ULL) {
#line 4882
        if (end == 0ULL) {
          {
#line 4884
          tmp___12 = gettext("<End of list>\n");
#line 4884
          printf((char const   */* __restrict  */)tmp___12);
          }
#line 4885
          goto while_break___3;
        }
      }
#line 4889
      if (begin == 0xffffffffffffffffULL) {
#line 4889
        if (end != 0xffffffffffffffffULL) {
          {
#line 4891
          base_address = (unsigned long )end;
#line 4892
          print_dwarf_vma(begin, pointer_size);
#line 4893
          print_dwarf_vma(end, pointer_size);
#line 4894
          printf((char const   */* __restrict  */)"(base address)\n");
          }
#line 4895
          goto while_continue___3;
        }
      }
      {
#line 4898
      print_dwarf_vma(begin + (dwarf_vma )base_address, pointer_size);
#line 4899
      print_dwarf_vma(end + (dwarf_vma )base_address, pointer_size);
      }
#line 4901
      if (begin == end) {
        {
#line 4902
        tmp___13 = gettext("(start == end)");
#line 4902
        fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stdout);
        }
      } else
#line 4903
      if (begin > end) {
        {
#line 4904
        tmp___14 = gettext("(start > end)");
#line 4904
        fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 4906
      putchar('\n');
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 4831
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 4909
  putchar('\n');
#line 4911
  free((void *)range_entries);
  }
#line 4913
  return (1);
}
}
#line 4939 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   * const  *dwarf_regnames  ;
#line 4940 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static unsigned int dwarf_regnames_count  ;
#line 4949 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int frame_need_space(Frame_Chunk *fc , unsigned int reg___0 ) 
{ 
  int prev ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4952
  prev = fc->ncols;
#line 4954
  if (reg___0 < (unsigned int )fc->ncols) {
#line 4955
    return (0);
  }
#line 4957
  if (dwarf_regnames_count) {
#line 4957
    if (reg___0 > dwarf_regnames_count) {
#line 4959
      return (-1);
    }
  }
  {
#line 4961
  fc->ncols = (int )(reg___0 + 1U);
#line 4962
  tmp___0 = xcrealloc((void *)fc->col_type, (size_t )fc->ncols, sizeof(short ));
#line 4962
  fc->col_type = (short *)tmp___0;
#line 4964
  tmp___1 = xcrealloc((void *)fc->col_offset, (size_t )fc->ncols, sizeof(int ));
#line 4964
  fc->col_offset = (int *)tmp___1;
  }
  {
#line 4966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4966
    if (! (prev < fc->ncols)) {
#line 4966
      goto while_break;
    }
#line 4968
    *(fc->col_type + prev) = (short)-1;
#line 4969
    *(fc->col_offset + prev) = 0;
#line 4970
    prev ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4972
  return (1);
}
}
#line 4975 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   * const  dwarf_regnames_i386[101]  = 
#line 4975
  {      (char const   */* const  */)"eax",      (char const   */* const  */)"ecx",      (char const   */* const  */)"edx",      (char const   */* const  */)"ebx", 
        (char const   */* const  */)"esp",      (char const   */* const  */)"ebp",      (char const   */* const  */)"esi",      (char const   */* const  */)"edi", 
        (char const   */* const  */)"eip",      (char const   */* const  */)"eflags",      (char const   */* const  */)((void *)0),      (char const   */* const  */)"st0", 
        (char const   */* const  */)"st1",      (char const   */* const  */)"st2",      (char const   */* const  */)"st3",      (char const   */* const  */)"st4", 
        (char const   */* const  */)"st5",      (char const   */* const  */)"st6",      (char const   */* const  */)"st7",      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)"xmm0",      (char const   */* const  */)"xmm1",      (char const   */* const  */)"xmm2", 
        (char const   */* const  */)"xmm3",      (char const   */* const  */)"xmm4",      (char const   */* const  */)"xmm5",      (char const   */* const  */)"xmm6", 
        (char const   */* const  */)"xmm7",      (char const   */* const  */)"mm0",      (char const   */* const  */)"mm1",      (char const   */* const  */)"mm2", 
        (char const   */* const  */)"mm3",      (char const   */* const  */)"mm4",      (char const   */* const  */)"mm5",      (char const   */* const  */)"mm6", 
        (char const   */* const  */)"mm7",      (char const   */* const  */)"fcw",      (char const   */* const  */)"fsw",      (char const   */* const  */)"mxcsr", 
        (char const   */* const  */)"es",      (char const   */* const  */)"cs",      (char const   */* const  */)"ss",      (char const   */* const  */)"ds", 
        (char const   */* const  */)"fs",      (char const   */* const  */)"gs",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)"tr",      (char const   */* const  */)"ldtr",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)"k0",      (char const   */* const  */)"k1",      (char const   */* const  */)"k2", 
        (char const   */* const  */)"k3",      (char const   */* const  */)"k4",      (char const   */* const  */)"k5",      (char const   */* const  */)"k6", 
        (char const   */* const  */)"k7"};
#line 4999 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void init_dwarf_regnames_i386(void) 
{ 


  {
#line 5002
  dwarf_regnames = dwarf_regnames_i386;
#line 5003
  dwarf_regnames_count = (unsigned int )(sizeof(dwarf_regnames_i386) / sizeof(dwarf_regnames_i386[0]));
#line 5004
  return;
}
}
#line 5006 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   * const  dwarf_regnames_x86_64[126]  = 
#line 5006
  {      (char const   */* const  */)"rax",      (char const   */* const  */)"rdx",      (char const   */* const  */)"rcx",      (char const   */* const  */)"rbx", 
        (char const   */* const  */)"rsi",      (char const   */* const  */)"rdi",      (char const   */* const  */)"rbp",      (char const   */* const  */)"rsp", 
        (char const   */* const  */)"r8",      (char const   */* const  */)"r9",      (char const   */* const  */)"r10",      (char const   */* const  */)"r11", 
        (char const   */* const  */)"r12",      (char const   */* const  */)"r13",      (char const   */* const  */)"r14",      (char const   */* const  */)"r15", 
        (char const   */* const  */)"rip",      (char const   */* const  */)"xmm0",      (char const   */* const  */)"xmm1",      (char const   */* const  */)"xmm2", 
        (char const   */* const  */)"xmm3",      (char const   */* const  */)"xmm4",      (char const   */* const  */)"xmm5",      (char const   */* const  */)"xmm6", 
        (char const   */* const  */)"xmm7",      (char const   */* const  */)"xmm8",      (char const   */* const  */)"xmm9",      (char const   */* const  */)"xmm10", 
        (char const   */* const  */)"xmm11",      (char const   */* const  */)"xmm12",      (char const   */* const  */)"xmm13",      (char const   */* const  */)"xmm14", 
        (char const   */* const  */)"xmm15",      (char const   */* const  */)"st0",      (char const   */* const  */)"st1",      (char const   */* const  */)"st2", 
        (char const   */* const  */)"st3",      (char const   */* const  */)"st4",      (char const   */* const  */)"st5",      (char const   */* const  */)"st6", 
        (char const   */* const  */)"st7",      (char const   */* const  */)"mm0",      (char const   */* const  */)"mm1",      (char const   */* const  */)"mm2", 
        (char const   */* const  */)"mm3",      (char const   */* const  */)"mm4",      (char const   */* const  */)"mm5",      (char const   */* const  */)"mm6", 
        (char const   */* const  */)"mm7",      (char const   */* const  */)"rflags",      (char const   */* const  */)"es",      (char const   */* const  */)"cs", 
        (char const   */* const  */)"ss",      (char const   */* const  */)"ds",      (char const   */* const  */)"fs",      (char const   */* const  */)"gs", 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"fs.base",      (char const   */* const  */)"gs.base", 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"tr",      (char const   */* const  */)"ldtr", 
        (char const   */* const  */)"mxcsr",      (char const   */* const  */)"fcw",      (char const   */* const  */)"fsw",      (char const   */* const  */)"xmm16", 
        (char const   */* const  */)"xmm17",      (char const   */* const  */)"xmm18",      (char const   */* const  */)"xmm19",      (char const   */* const  */)"xmm20", 
        (char const   */* const  */)"xmm21",      (char const   */* const  */)"xmm22",      (char const   */* const  */)"xmm23",      (char const   */* const  */)"xmm24", 
        (char const   */* const  */)"xmm25",      (char const   */* const  */)"xmm26",      (char const   */* const  */)"xmm27",      (char const   */* const  */)"xmm28", 
        (char const   */* const  */)"xmm29",      (char const   */* const  */)"xmm30",      (char const   */* const  */)"xmm31",      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"k0",      (char const   */* const  */)"k1", 
        (char const   */* const  */)"k2",      (char const   */* const  */)"k3",      (char const   */* const  */)"k4",      (char const   */* const  */)"k5", 
        (char const   */* const  */)"k6",      (char const   */* const  */)"k7"};
#line 5038 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void init_dwarf_regnames_x86_64(void) 
{ 


  {
#line 5041
  dwarf_regnames = dwarf_regnames_x86_64;
#line 5042
  dwarf_regnames_count = (unsigned int )(sizeof(dwarf_regnames_x86_64) / sizeof(dwarf_regnames_x86_64[0]));
#line 5043
  return;
}
}
#line 5045 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void init_dwarf_regnames(unsigned int e_machine ) 
{ 


  {
  {
#line 5051
  if (e_machine == 6U) {
#line 5051
    goto case_6;
  }
#line 5051
  if (e_machine == 3U) {
#line 5051
    goto case_6;
  }
#line 5057
  if (e_machine == 181U) {
#line 5057
    goto case_181;
  }
#line 5057
  if (e_machine == 180U) {
#line 5057
    goto case_181;
  }
#line 5057
  if (e_machine == 62U) {
#line 5057
    goto case_181;
  }
#line 5061
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 5052
  init_dwarf_regnames_i386();
  }
#line 5053
  goto switch_break;
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  {
#line 5058
  init_dwarf_regnames_x86_64();
  }
#line 5059
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5062
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5064
  return;
}
}
#line 5069 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char reg[64]  ;
#line 5066 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *regname(unsigned int regno , int row ) 
{ 


  {
#line 5070
  if (dwarf_regnames) {
#line 5070
    if (regno < dwarf_regnames_count) {
#line 5070
      if ((unsigned long )*(dwarf_regnames + regno) != (unsigned long )((void *)0)) {
#line 5074
        if (row) {
#line 5075
          return ((char const   *)*(dwarf_regnames + regno));
        }
        {
#line 5076
        snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d (%s)",
                 regno, *(dwarf_regnames + regno));
        }
      } else {
        {
#line 5080
        snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
                 regno);
        }
      }
    } else {
      {
#line 5080
      snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
               regno);
      }
    }
  } else {
    {
#line 5080
    snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
             regno);
    }
  }
#line 5081
  return ((char const   *)(reg));
}
}
#line 5095
static void frame_display_row(Frame_Chunk *fc , int *need_col_headers , int *max_regs ) ;
#line 5095 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *sloc  =    "   LOC";
#line 5084 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void frame_display_row(Frame_Chunk *fc , int *need_col_headers , int *max_regs ) 
{ 
  int r ;
  char tmp___0[100] ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 5090
  if (*max_regs < fc->ncols) {
#line 5091
    *max_regs = fc->ncols;
  }
#line 5093
  if (*need_col_headers) {
    {
#line 5097
    *need_col_headers = 0;
#line 5099
    printf((char const   */* __restrict  */)"%-*s CFA      ", eh_addr_size * 2, sloc);
#line 5101
    r = 0;
    }
    {
#line 5101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5101
      if (! (r < *max_regs)) {
#line 5101
        goto while_break;
      }
#line 5102
      if ((int )*(fc->col_type + r) != -1) {
#line 5104
        if (r == fc->ra) {
          {
#line 5105
          printf((char const   */* __restrict  */)"ra      ");
          }
        } else {
          {
#line 5107
          tmp___1 = regname((unsigned int )r, 1);
#line 5107
          printf((char const   */* __restrict  */)"%-5s ", tmp___1);
          }
        }
      }
#line 5101
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5110
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 5113
  print_dwarf_vma(fc->pc_begin, (unsigned int )eh_addr_size);
  }
#line 5114
  if (fc->cfa_exp) {
    {
#line 5115
    strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"exp");
    }
  } else {
    {
#line 5117
    tmp___2 = regname((unsigned int )fc->cfa_reg, 1);
#line 5117
    sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"%s%+d",
            tmp___2, fc->cfa_offset);
    }
  }
  {
#line 5118
  printf((char const   */* __restrict  */)"%-8s ", tmp___0);
#line 5120
  r = 0;
  }
  {
#line 5120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5120
    if (! (r < fc->ncols)) {
#line 5120
      goto while_break___0;
    }
#line 5122
    if ((int )*(fc->col_type + r) != -1) {
      {
#line 5126
      if ((int )*(fc->col_type + r) == 7) {
#line 5126
        goto case_7;
      }
#line 5129
      if ((int )*(fc->col_type + r) == 8) {
#line 5129
        goto case_8;
      }
#line 5132
      if ((int )*(fc->col_type + r) == 128) {
#line 5132
        goto case_128;
      }
#line 5135
      if ((int )*(fc->col_type + r) == 20) {
#line 5135
        goto case_20;
      }
#line 5138
      if ((int )*(fc->col_type + r) == 9) {
#line 5138
        goto case_9;
      }
#line 5141
      if ((int )*(fc->col_type + r) == 16) {
#line 5141
        goto case_16;
      }
#line 5144
      if ((int )*(fc->col_type + r) == 22) {
#line 5144
        goto case_22;
      }
#line 5147
      goto switch_default;
      case_7: /* CIL Label */ 
      {
#line 5127
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"u");
      }
#line 5128
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 5130
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"s");
      }
#line 5131
      goto switch_break;
      case_128: /* CIL Label */ 
      {
#line 5133
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"c%+d",
              *(fc->col_offset + r));
      }
#line 5134
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 5136
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"v%+d",
              *(fc->col_offset + r));
      }
#line 5137
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 5139
      tmp___3 = regname((unsigned int )*(fc->col_offset + r), 0);
#line 5139
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"%s",
              tmp___3);
      }
#line 5140
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 5142
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"exp");
      }
#line 5143
      goto switch_break;
      case_22: /* CIL Label */ 
      {
#line 5145
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"vexp");
      }
#line 5146
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 5148
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"n/a");
      }
#line 5149
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 5151
      printf((char const   */* __restrict  */)"%-5s ", tmp___0);
      }
    }
#line 5120
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5154
  printf((char const   */* __restrict  */)"\n");
  }
#line 5155
  return;
}
}
#line 5345 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static Frame_Chunk fde_fc  ;
#line 5161 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_frames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *section_start ;
  Frame_Chunk *chunks ;
  Frame_Chunk *remembered_state ;
  Frame_Chunk *rs ;
  int is_eh ;
  int tmp___0 ;
  unsigned int length_return ;
  int max_regs ;
  char const   *bad_reg ;
  char *tmp___1 ;
  int saved_eh_addr_size ;
  char *tmp___2 ;
  unsigned char *saved_start ;
  unsigned char *block_end ;
  dwarf_vma length ;
  dwarf_vma cie_id ;
  Frame_Chunk *fc ;
  Frame_Chunk *cie ;
  int need_col_headers ;
  unsigned char *augmentation_data ;
  unsigned long augmentation_data_len ;
  unsigned int encoded_ptr_size ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int amount ;
  unsigned int amount___0 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int *dummy___1  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___1 ;
  void *tmp___5 ;
  unsigned int amount___1 ;
  int version ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  unsigned char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  unsigned int amount___2 ;
  elf_vma tmp___12 ;
  unsigned int amount___3 ;
  elf_vma tmp___13 ;
  dwarf_vma tmp___14 ;
  dwarf_signed_vma tmp___15 ;
  unsigned int amount___4 ;
  elf_vma tmp___16 ;
  dwarf_vma tmp___17 ;
  dwarf_vma tmp___18 ;
  unsigned long i ;
  unsigned char *p ;
  unsigned char *q ;
  int tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *look_for ;
  unsigned long segment_selector ;
  char const   *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int *dummy___5  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___5 ;
  void *tmp___29 ;
  unsigned int amount___5 ;
  elf_vma tmp___30 ;
  int tmp___31 ;
  int *dummy___6  __attribute__((__unused__)) ;
  unsigned long __lengthofdummy___6 ;
  void *tmp___32 ;
  unsigned int amount___6 ;
  dwarf_vma tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  unsigned long i___0 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned int op ;
  unsigned int opa ;
  unsigned long reg___0 ;
  unsigned long temp ;
  unsigned char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  dwarf_vma tmp___44 ;
  int tmp___45 ;
  dwarf_vma tmp___46 ;
  int tmp___47 ;
  dwarf_vma tmp___48 ;
  int tmp___49 ;
  dwarf_vma tmp___50 ;
  int tmp___51 ;
  dwarf_vma tmp___52 ;
  int tmp___53 ;
  dwarf_vma tmp___54 ;
  dwarf_vma tmp___55 ;
  dwarf_vma tmp___56 ;
  int tmp___57 ;
  dwarf_vma tmp___58 ;
  int tmp___59 ;
  dwarf_vma tmp___60 ;
  int tmp___61 ;
  unsigned int op___0 ;
  unsigned int opa___0 ;
  unsigned long ul ;
  unsigned long reg___1 ;
  unsigned long roffs ;
  long l ;
  dwarf_vma ofs ;
  dwarf_vma vma ;
  char const   *reg_prefix ;
  unsigned char *tmp___62 ;
  char const   *tmp___63 ;
  dwarf_vma tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  char const   *tmp___67 ;
  unsigned int amount___7 ;
  char const   *tmp___68 ;
  unsigned int amount___8 ;
  char const   *tmp___69 ;
  unsigned int amount___9 ;
  char const   *tmp___70 ;
  dwarf_vma tmp___71 ;
  dwarf_vma tmp___72 ;
  char const   *tmp___73 ;
  dwarf_vma tmp___74 ;
  dwarf_vma tmp___75 ;
  char const   *tmp___76 ;
  dwarf_vma tmp___77 ;
  char const   *tmp___78 ;
  dwarf_vma tmp___79 ;
  char const   *tmp___80 ;
  dwarf_vma tmp___81 ;
  char const   *tmp___82 ;
  dwarf_vma tmp___83 ;
  dwarf_vma tmp___84 ;
  char const   *tmp___85 ;
  char const   *tmp___86 ;
  void *tmp___87 ;
  void *tmp___88 ;
  void *tmp___89 ;
  dwarf_vma tmp___90 ;
  dwarf_vma tmp___91 ;
  char const   *tmp___92 ;
  dwarf_vma tmp___93 ;
  char const   *tmp___94 ;
  dwarf_vma tmp___95 ;
  dwarf_vma tmp___96 ;
  dwarf_vma tmp___97 ;
  dwarf_vma tmp___98 ;
  char const   *tmp___99 ;
  dwarf_vma tmp___100 ;
  dwarf_vma tmp___101 ;
  char const   *tmp___102 ;
  dwarf_vma tmp___103 ;
  dwarf_signed_vma tmp___104 ;
  int tmp___105 ;
  char const   *tmp___106 ;
  dwarf_vma tmp___107 ;
  dwarf_signed_vma tmp___108 ;
  int tmp___109 ;
  char const   *tmp___110 ;
  dwarf_vma tmp___111 ;
  dwarf_signed_vma tmp___112 ;
  char const   *tmp___113 ;
  dwarf_signed_vma tmp___114 ;
  unsigned int amount___10 ;
  char const   *tmp___115 ;
  dwarf_vma tmp___116 ;
  dwarf_vma tmp___117 ;
  dwarf_vma tmp___118 ;
  int tmp___119 ;
  char const   *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;

  {
  {
#line 5165
  start = section->start;
#line 5166
  end = start + section->size;
#line 5167
  section_start = start;
#line 5168
  chunks = (Frame_Chunk *)0;
#line 5169
  remembered_state = (Frame_Chunk *)0;
#line 5171
  tmp___0 = strcmp(section->name, ".eh_frame");
#line 5171
  is_eh = tmp___0 == 0;
#line 5173
  max_regs = 0;
#line 5174
  tmp___1 = gettext("bad register: ");
#line 5174
  bad_reg = (char const   *)tmp___1;
#line 5175
  saved_eh_addr_size = eh_addr_size;
#line 5177
  tmp___2 = gettext("Contents of the %s section:\n");
#line 5177
  printf((char const   */* __restrict  */)tmp___2, section->name);
  }
  {
#line 5179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5179
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 5179
      goto while_break;
    }
#line 5187
    need_col_headers = 1;
#line 5188
    augmentation_data = (unsigned char *)((void *)0);
#line 5189
    augmentation_data_len = 0UL;
#line 5190
    encoded_ptr_size = (unsigned int )saved_eh_addr_size;
#line 5194
    saved_start = start;
    {
#line 5196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 5196
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5196
        amount = 4U;
#line 5196
        if ((unsigned long )(start + amount) >= (unsigned long )end) {
#line 5196
          if ((unsigned long )start < (unsigned long )end) {
#line 5196
            amount = (unsigned int )(end - start);
          } else {
#line 5196
            amount = 0U;
          }
        }
#line 5196
        if (amount) {
          {
#line 5196
          length = (*byte_get)(start, (int )amount);
          }
        } else {
#line 5196
          length = (dwarf_vma )0;
        }
#line 5196
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5196
      start += 4;
#line 5196
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5197
    if (length == 0ULL) {
      {
#line 5199
      printf((char const   */* __restrict  */)"\n%08lx ZERO terminator\n\n", (unsigned long )(saved_start - section_start));
      }
#line 5201
      goto while_continue;
    }
#line 5204
    if (length == 4294967295ULL) {
      {
#line 5206
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 5206
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 5206
          amount___0 = 8U;
#line 5206
          if ((unsigned long )(start + amount___0) >= (unsigned long )end) {
#line 5206
            if ((unsigned long )start < (unsigned long )end) {
#line 5206
              amount___0 = (unsigned int )(end - start);
            } else {
#line 5206
              amount___0 = 0U;
            }
          }
#line 5206
          if (amount___0) {
            {
#line 5206
            length = (*byte_get)(start, (int )amount___0);
            }
          } else {
#line 5206
            length = (dwarf_vma )0;
          }
#line 5206
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 5206
        start += 8;
#line 5206
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5207
      offset_size = 8U;
#line 5208
      initial_length_size = 12U;
    } else {
#line 5212
      offset_size = 4U;
#line 5213
      initial_length_size = 4U;
    }
#line 5216
    block_end = (saved_start + length) + initial_length_size;
#line 5217
    if ((unsigned long )block_end > (unsigned long )end) {
      {
#line 5219
      tmp___3 = dwarf_vmatoa_1((char const   *)((void *)0), length, offset_size);
#line 5219
      warn("Invalid length 0x%s in FDE at %#08lx\n", tmp___3, (unsigned long )(saved_start - section_start));
#line 5222
      block_end = end;
      }
    }
    {
#line 5225
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 5225
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 5225
        if (8UL < (unsigned long )offset_size) {
#line 5225
          tmp___4 = -1;
        } else {
#line 5225
          tmp___4 = 1;
        }
        {
#line 5225
        __lengthofdummy___1 = (unsigned long )tmp___4;
#line 5225
        tmp___5 = __builtin_alloca(sizeof(*dummy___1) * __lengthofdummy___1);
#line 5225
        dummy___1 = (int *)tmp___5;
#line 5225
        amount___1 = offset_size;
        }
#line 5225
        if ((unsigned long )(start + amount___1) >= (unsigned long )end) {
#line 5225
          if ((unsigned long )start < (unsigned long )end) {
#line 5225
            amount___1 = (unsigned int )(end - start);
          } else {
#line 5225
            amount___1 = 0U;
          }
        }
#line 5225
        if (amount___1) {
          {
#line 5225
          cie_id = (*byte_get)(start, (int )amount___1);
          }
        } else {
#line 5225
          cie_id = (dwarf_vma )0;
        }
#line 5225
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 5225
      start += offset_size;
#line 5225
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5227
    if (is_eh) {
#line 5227
      tmp___39 = cie_id == 0ULL;
    } else {
#line 5227
      if (offset_size == 4U) {
#line 5227
        if (cie_id == 4294967295ULL) {
#line 5227
          tmp___38 = 1;
        } else {
#line 5227
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 5227
      if (offset_size == 8U) {
#line 5227
        if (cie_id == 0xffffffffffffffffULL) {
#line 5227
          tmp___38 = 1;
        } else {
#line 5227
          tmp___38 = 0;
        }
      } else {
#line 5227
        tmp___38 = 0;
      }
#line 5227
      tmp___39 = tmp___38;
    }
#line 5227
    if (tmp___39) {
      {
#line 5232
      tmp___6 = xmalloc(sizeof(Frame_Chunk ));
#line 5232
      fc = (Frame_Chunk *)tmp___6;
#line 5233
      memset((void *)fc, 0, sizeof(Frame_Chunk ));
#line 5235
      fc->next = chunks;
#line 5236
      chunks = fc;
#line 5237
      fc->chunk_start = saved_start;
#line 5238
      fc->ncols = 0;
#line 5239
      tmp___7 = xmalloc(sizeof(short ));
#line 5239
      fc->col_type = (short *)tmp___7;
#line 5240
      tmp___8 = xmalloc(sizeof(int ));
#line 5240
      fc->col_offset = (int *)tmp___8;
#line 5241
      frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 5243
      tmp___9 = start;
#line 5243
      start ++;
#line 5243
      version = (int )*tmp___9;
#line 5245
      fc->augmentation = (char *)start;
#line 5246
      tmp___10 = strchr((char const   *)((char *)start), '\000');
#line 5246
      start = (unsigned char *)tmp___10 + 1;
#line 5248
      tmp___11 = strcmp((char const   *)fc->augmentation, "eh");
      }
#line 5248
      if (tmp___11 == 0) {
#line 5249
        start += eh_addr_size;
      }
#line 5251
      if (version >= 4) {
        {
#line 5253
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 5253
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 5253
            amount___2 = 1U;
#line 5253
            if ((unsigned long )(start + amount___2) >= (unsigned long )end) {
#line 5253
              if ((unsigned long )start < (unsigned long )end) {
#line 5253
                amount___2 = (unsigned int )(end - start);
              } else {
#line 5253
                amount___2 = 0U;
              }
            }
#line 5253
            if (amount___2) {
              {
#line 5253
              tmp___12 = (*byte_get)(start, (int )amount___2);
#line 5253
              fc->ptr_size = (unsigned char )tmp___12;
              }
            } else {
#line 5253
              fc->ptr_size = (unsigned char)0;
            }
#line 5253
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 5253
          start ++;
#line 5253
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 5254
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 5254
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 5254
            amount___3 = 1U;
#line 5254
            if ((unsigned long )(start + amount___3) >= (unsigned long )end) {
#line 5254
              if ((unsigned long )start < (unsigned long )end) {
#line 5254
                amount___3 = (unsigned int )(end - start);
              } else {
#line 5254
                amount___3 = 0U;
              }
            }
#line 5254
            if (amount___3) {
              {
#line 5254
              tmp___13 = (*byte_get)(start, (int )amount___3);
#line 5254
              fc->segment_size = (unsigned char )tmp___13;
              }
            } else {
#line 5254
              fc->segment_size = (unsigned char)0;
            }
#line 5254
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 5254
          start ++;
#line 5254
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 5255
        eh_addr_size = (int )fc->ptr_size;
      } else {
#line 5259
        fc->ptr_size = (unsigned char )eh_addr_size;
#line 5260
        fc->segment_size = (unsigned char)0;
      }
      {
#line 5262
      tmp___14 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5262
      fc->code_factor = (unsigned int )tmp___14;
#line 5262
      start += length_return;
#line 5263
      tmp___15 = read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5263
      fc->data_factor = (int )tmp___15;
#line 5263
      start += length_return;
      }
#line 5264
      if (version == 1) {
        {
#line 5266
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 5266
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 5266
            amount___4 = 1U;
#line 5266
            if ((unsigned long )(start + amount___4) >= (unsigned long )end) {
#line 5266
              if ((unsigned long )start < (unsigned long )end) {
#line 5266
                amount___4 = (unsigned int )(end - start);
              } else {
#line 5266
                amount___4 = 0U;
              }
            }
#line 5266
            if (amount___4) {
              {
#line 5266
              tmp___16 = (*byte_get)(start, (int )amount___4);
#line 5266
              fc->ra = (int )tmp___16;
              }
            } else {
#line 5266
              fc->ra = 0;
            }
#line 5266
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 5266
          start ++;
#line 5266
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else {
        {
#line 5270
        tmp___17 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5270
        fc->ra = (int )tmp___17;
#line 5270
        start += length_return;
        }
      }
#line 5273
      if ((int )*(fc->augmentation + 0) == 122) {
        {
#line 5275
        tmp___18 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5275
        augmentation_data_len = (unsigned long )tmp___18;
#line 5275
        start += length_return;
#line 5276
        augmentation_data = start;
#line 5277
        start += augmentation_data_len;
        }
      }
      {
#line 5279
      cie = fc;
#line 5281
      printf((char const   */* __restrict  */)"\n%08lx ", (unsigned long )(saved_start - section_start));
#line 5282
      print_dwarf_vma(length, (unsigned int )fc->ptr_size);
#line 5283
      print_dwarf_vma(cie_id, offset_size);
      }
#line 5285
      if (do_debug_frames_interp) {
        {
#line 5287
        printf((char const   */* __restrict  */)"CIE \"%s\" cf=%d df=%d ra=%d\n",
               fc->augmentation, fc->code_factor, fc->data_factor, fc->ra);
        }
      } else {
        {
#line 5292
        printf((char const   */* __restrict  */)"CIE\n");
#line 5293
        printf((char const   */* __restrict  */)"  Version:               %d\n", version);
#line 5294
        printf((char const   */* __restrict  */)"  Augmentation:          \"%s\"\n",
               fc->augmentation);
        }
#line 5295
        if (version >= 4) {
          {
#line 5297
          printf((char const   */* __restrict  */)"  Pointer Size:          %u\n",
                 (int )fc->ptr_size);
#line 5298
          printf((char const   */* __restrict  */)"  Segment Size:          %u\n",
                 (int )fc->segment_size);
          }
        }
        {
#line 5300
        printf((char const   */* __restrict  */)"  Code alignment factor: %u\n", fc->code_factor);
#line 5301
        printf((char const   */* __restrict  */)"  Data alignment factor: %d\n", fc->data_factor);
#line 5302
        printf((char const   */* __restrict  */)"  Return address column: %d\n", fc->ra);
        }
#line 5304
        if (augmentation_data_len) {
          {
#line 5307
          printf((char const   */* __restrict  */)"  Augmentation data:    ");
#line 5308
          i = 0UL;
          }
          {
#line 5308
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 5308
            if (! (i < augmentation_data_len)) {
#line 5308
              goto while_break___12;
            }
            {
#line 5309
            printf((char const   */* __restrict  */)" %02x", (int )*(augmentation_data + i));
#line 5308
            i ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 5310
          putchar('\n');
          }
        }
        {
#line 5312
        putchar('\n');
        }
      }
#line 5315
      if (augmentation_data_len) {
#line 5318
        p = (unsigned char *)fc->augmentation + 1;
#line 5319
        q = augmentation_data;
        {
#line 5321
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 5323
          if ((int )*p == 76) {
#line 5324
            q ++;
          } else
#line 5325
          if ((int )*p == 80) {
            {
#line 5326
            tmp___19 = size_of_encoded_value((int )*q);
#line 5326
            q += 1 + tmp___19;
            }
          } else
#line 5327
          if ((int )*p == 82) {
#line 5328
            tmp___20 = q;
#line 5328
            q ++;
#line 5328
            fc->fde_encoding = *tmp___20;
          } else
#line 5329
          if (! ((int )*p == 83)) {
#line 5332
            goto while_break___13;
          }
#line 5333
          p ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 5336
        if (fc->fde_encoding) {
          {
#line 5337
          tmp___21 = size_of_encoded_value((int )fc->fde_encoding);
#line 5337
          encoded_ptr_size = (unsigned int )tmp___21;
          }
        }
      }
      {
#line 5340
      frame_need_space(fc, (unsigned int )fc->ra);
      }
    } else {
      {
#line 5348
      fc = & fde_fc;
#line 5349
      memset((void *)fc, 0, sizeof(Frame_Chunk ));
      }
#line 5351
      if (is_eh) {
#line 5351
        look_for = (start - 4) - cie_id;
      } else {
#line 5351
        look_for = section_start + cie_id;
      }
#line 5353
      cie = chunks;
      {
#line 5353
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 5353
        if (! cie) {
#line 5353
          goto while_break___14;
        }
#line 5354
        if ((unsigned long )cie->chunk_start == (unsigned long )look_for) {
#line 5355
          goto while_break___14;
        }
#line 5353
        cie = cie->next;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 5357
      if (! cie) {
        {
#line 5359
        tmp___22 = dwarf_vmatoa_1((char const   *)((void *)0), cie_id, offset_size);
#line 5359
        warn("Invalid CIE pointer 0x%s in FDE at %#08lx\n", tmp___22, (unsigned long )(saved_start - section_start));
#line 5362
        fc->ncols = 0;
#line 5363
        tmp___23 = xmalloc(sizeof(short ));
#line 5363
        fc->col_type = (short *)tmp___23;
#line 5364
        tmp___24 = xmalloc(sizeof(int ));
#line 5364
        fc->col_offset = (int *)tmp___24;
#line 5365
        frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 5366
        cie = fc;
#line 5367
        fc->augmentation = (char *)"";
#line 5368
        fc->fde_encoding = (unsigned char)0;
#line 5369
        fc->ptr_size = (unsigned char )eh_addr_size;
#line 5370
        fc->segment_size = (unsigned char)0;
        }
      } else {
        {
#line 5374
        fc->ncols = cie->ncols;
#line 5375
        tmp___25 = xcmalloc((size_t )fc->ncols, sizeof(short ));
#line 5375
        fc->col_type = (short *)tmp___25;
#line 5376
        tmp___26 = xcmalloc((size_t )fc->ncols, sizeof(int ));
#line 5376
        fc->col_offset = (int *)tmp___26;
#line 5377
        memcpy((void */* __restrict  */)fc->col_type, (void const   */* __restrict  */)cie->col_type,
               (unsigned long )fc->ncols * sizeof(short ));
#line 5378
        memcpy((void */* __restrict  */)fc->col_offset, (void const   */* __restrict  */)cie->col_offset,
               (unsigned long )fc->ncols * sizeof(int ));
#line 5379
        fc->augmentation = cie->augmentation;
#line 5380
        fc->ptr_size = cie->ptr_size;
#line 5381
        eh_addr_size = (int )cie->ptr_size;
#line 5382
        fc->segment_size = cie->segment_size;
#line 5383
        fc->code_factor = cie->code_factor;
#line 5384
        fc->data_factor = cie->data_factor;
#line 5385
        fc->cfa_reg = cie->cfa_reg;
#line 5386
        fc->cfa_offset = cie->cfa_offset;
#line 5387
        fc->ra = cie->ra;
#line 5388
        frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 5389
        fc->fde_encoding = cie->fde_encoding;
        }
      }
#line 5392
      if (fc->fde_encoding) {
        {
#line 5393
        tmp___27 = size_of_encoded_value((int )fc->fde_encoding);
#line 5393
        encoded_ptr_size = (unsigned int )tmp___27;
        }
      }
#line 5395
      segment_selector = 0UL;
#line 5396
      if (fc->segment_size) {
        {
#line 5398
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 5398
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 5398
            if (8UL < (unsigned long )fc->segment_size) {
#line 5398
              tmp___28 = -1;
            } else {
#line 5398
              tmp___28 = 1;
            }
            {
#line 5398
            __lengthofdummy___5 = (unsigned long )tmp___28;
#line 5398
            tmp___29 = __builtin_alloca(sizeof(*dummy___5) * __lengthofdummy___5);
#line 5398
            dummy___5 = (int *)tmp___29;
#line 5398
            amount___5 = (unsigned int )fc->segment_size;
            }
#line 5398
            if ((unsigned long )(start + amount___5) >= (unsigned long )end) {
#line 5398
              if ((unsigned long )start < (unsigned long )end) {
#line 5398
                amount___5 = (unsigned int )(end - start);
              } else {
#line 5398
                amount___5 = 0U;
              }
            }
#line 5398
            if (amount___5) {
              {
#line 5398
              tmp___30 = (*byte_get)(start, (int )amount___5);
#line 5398
              segment_selector = (unsigned long )tmp___30;
              }
            } else {
#line 5398
              segment_selector = 0UL;
            }
#line 5398
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 5398
          start += (int )fc->segment_size;
#line 5398
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 5400
      fc->pc_begin = get_encoded_value(start, (int )fc->fde_encoding, section);
#line 5401
      start += encoded_ptr_size;
      }
      {
#line 5407
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 5407
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 5407
          if (8UL < (unsigned long )encoded_ptr_size) {
#line 5407
            tmp___31 = -1;
          } else {
#line 5407
            tmp___31 = 1;
          }
          {
#line 5407
          __lengthofdummy___6 = (unsigned long )tmp___31;
#line 5407
          tmp___32 = __builtin_alloca(sizeof(*dummy___6) * __lengthofdummy___6);
#line 5407
          dummy___6 = (int *)tmp___32;
#line 5407
          amount___6 = encoded_ptr_size;
          }
#line 5407
          if ((unsigned long )(start + amount___6) >= (unsigned long )end) {
#line 5407
            if ((unsigned long )start < (unsigned long )end) {
#line 5407
              amount___6 = (unsigned int )(end - start);
            } else {
#line 5407
              amount___6 = 0U;
            }
          }
#line 5407
          if (amount___6) {
            {
#line 5407
            fc->pc_range = (*byte_get)(start, (int )amount___6);
            }
          } else {
#line 5407
            fc->pc_range = (dwarf_vma )0;
          }
#line 5407
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 5407
        start += encoded_ptr_size;
#line 5407
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 5409
      if ((int )*(cie->augmentation + 0) == 122) {
        {
#line 5411
        tmp___33 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5411
        augmentation_data_len = (unsigned long )tmp___33;
#line 5411
        start += length_return;
#line 5412
        augmentation_data = start;
#line 5413
        start += augmentation_data_len;
        }
      }
      {
#line 5416
      tmp___34 = dwarf_vmatoa_1((char const   *)((void *)0), cie_id, offset_size);
#line 5416
      tmp___35 = dwarf_vmatoa_1((char const   *)((void *)0), length, (unsigned int )fc->ptr_size);
#line 5416
      printf((char const   */* __restrict  */)"\n%08lx %s %s FDE cie=%08lx pc=", (unsigned long )(saved_start - section_start),
             tmp___35, tmp___34, (unsigned long )(cie->chunk_start - section_start));
      }
#line 5422
      if (fc->segment_size) {
        {
#line 5423
        printf((char const   */* __restrict  */)"%04lx:", segment_selector);
        }
      }
      {
#line 5425
      tmp___36 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + fc->pc_range,
                                (unsigned int )fc->ptr_size);
#line 5425
      tmp___37 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin, (unsigned int )fc->ptr_size);
#line 5425
      printf((char const   */* __restrict  */)"%s..%s\n", tmp___37, tmp___36);
      }
#line 5429
      if (! do_debug_frames_interp) {
#line 5429
        if (augmentation_data_len) {
          {
#line 5433
          printf((char const   */* __restrict  */)"  Augmentation data:    ");
#line 5434
          i___0 = 0UL;
          }
          {
#line 5434
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 5434
            if (! (i___0 < augmentation_data_len)) {
#line 5434
              goto while_break___19;
            }
            {
#line 5435
            printf((char const   */* __restrict  */)" %02x", (int )*(augmentation_data + i___0));
#line 5434
            i___0 ++;
            }
          }
          while_break___19: /* CIL Label */ ;
          }
          {
#line 5436
          putchar('\n');
#line 5437
          putchar('\n');
          }
        }
      }
    }
#line 5452
    tmp___40 = start;
    {
#line 5454
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 5454
      if (! ((unsigned long )start < (unsigned long )block_end)) {
#line 5454
        goto while_break___20;
      }
#line 5459
      tmp___41 = start;
#line 5459
      start ++;
#line 5459
      op = (unsigned int )*tmp___41;
#line 5460
      opa = op & 63U;
#line 5461
      if (op & 192U) {
#line 5462
        op &= 192U;
      }
      {
#line 5468
      if (op == 64U) {
#line 5468
        goto case_64;
      }
#line 5470
      if (op == 128U) {
#line 5470
        goto case_128;
      }
#line 5475
      if (op == 192U) {
#line 5475
        goto case_192;
      }
#line 5479
      if (op == 1U) {
#line 5479
        goto case_1;
      }
#line 5482
      if (op == 2U) {
#line 5482
        goto case_2;
      }
#line 5485
      if (op == 3U) {
#line 5485
        goto case_3;
      }
#line 5488
      if (op == 4U) {
#line 5488
        goto case_4;
      }
#line 5492
      if (op == 20U) {
#line 5492
        goto case_20;
      }
#line 5492
      if (op == 5U) {
#line 5492
        goto case_20;
      }
#line 5497
      if (op == 6U) {
#line 5497
        goto case_6;
      }
#line 5503
      if (op == 7U) {
#line 5503
        goto case_7;
      }
#line 5508
      if (op == 8U) {
#line 5508
        goto case_8;
      }
#line 5513
      if (op == 9U) {
#line 5513
        goto case_9;
      }
#line 5518
      if (op == 12U) {
#line 5518
        goto case_12;
      }
#line 5521
      if (op == 13U) {
#line 5521
        goto case_13;
      }
#line 5524
      if (op == 14U) {
#line 5524
        goto case_14;
      }
#line 5527
      if (op == 15U) {
#line 5527
        goto case_15;
      }
#line 5532
      if (op == 22U) {
#line 5532
        goto case_22;
      }
#line 5532
      if (op == 16U) {
#line 5532
        goto case_22;
      }
#line 5540
      if (op == 21U) {
#line 5540
        goto case_21;
      }
#line 5540
      if (op == 17U) {
#line 5540
        goto case_21;
      }
#line 5545
      if (op == 18U) {
#line 5545
        goto case_18;
      }
#line 5548
      if (op == 19U) {
#line 5548
        goto case_19;
      }
#line 5551
      if (op == 29U) {
#line 5551
        goto case_29;
      }
#line 5554
      if (op == 46U) {
#line 5554
        goto case_46;
      }
#line 5557
      if (op == 47U) {
#line 5557
        goto case_47;
      }
#line 5562
      goto switch_default;
      case_64: /* CIL Label */ 
#line 5469
      goto switch_break;
      case_128: /* CIL Label */ 
      {
#line 5471
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5471
      start += length_return;
#line 5472
      tmp___42 = frame_need_space(fc, opa);
      }
#line 5472
      if (tmp___42 >= 0) {
#line 5473
        *(fc->col_type + opa) = (short)7;
      }
#line 5474
      goto switch_break;
      case_192: /* CIL Label */ 
      {
#line 5476
      tmp___43 = frame_need_space(fc, opa);
      }
#line 5476
      if (tmp___43 >= 0) {
#line 5477
        *(fc->col_type + opa) = (short)7;
      }
#line 5478
      goto switch_break;
      case_1: /* CIL Label */ 
#line 5480
      start += encoded_ptr_size;
#line 5481
      goto switch_break;
      case_2: /* CIL Label */ 
#line 5483
      start ++;
#line 5484
      goto switch_break;
      case_3: /* CIL Label */ 
#line 5486
      start += 2;
#line 5487
      goto switch_break;
      case_4: /* CIL Label */ 
#line 5489
      start += 4;
#line 5490
      goto switch_break;
      case_20: /* CIL Label */ 
      case_5: /* CIL Label */ 
      {
#line 5493
      tmp___44 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5493
      reg___0 = (unsigned long )tmp___44;
#line 5493
      start += length_return;
#line 5493
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5493
      start += length_return;
#line 5494
      tmp___45 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5494
      if (tmp___45 >= 0) {
#line 5495
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5496
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 5498
      tmp___46 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5498
      reg___0 = (unsigned long )tmp___46;
#line 5498
      start += length_return;
#line 5499
      frame_need_space(fc, (unsigned int )reg___0);
#line 5500
      tmp___47 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5500
      if (tmp___47 >= 0) {
#line 5501
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5502
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 5504
      tmp___48 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5504
      reg___0 = (unsigned long )tmp___48;
#line 5504
      start += length_return;
#line 5505
      tmp___49 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5505
      if (tmp___49 >= 0) {
#line 5506
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5507
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 5509
      tmp___50 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5509
      reg___0 = (unsigned long )tmp___50;
#line 5509
      start += length_return;
#line 5510
      tmp___51 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5510
      if (tmp___51 >= 0) {
#line 5511
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5512
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 5514
      tmp___52 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5514
      reg___0 = (unsigned long )tmp___52;
#line 5514
      start += length_return;
#line 5514
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5514
      start += length_return;
#line 5515
      tmp___53 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5515
      if (tmp___53 >= 0) {
#line 5516
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5517
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 5519
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5519
      start += length_return;
#line 5519
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5519
      start += length_return;
      }
#line 5520
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 5522
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5522
      start += length_return;
      }
#line 5523
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 5525
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5525
      start += length_return;
      }
#line 5526
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 5528
      tmp___54 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5528
      temp = (unsigned long )tmp___54;
#line 5528
      start += length_return;
#line 5529
      start += temp;
      }
#line 5530
      goto switch_break;
      case_22: /* CIL Label */ 
      case_16: /* CIL Label */ 
      {
#line 5533
      tmp___55 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5533
      reg___0 = (unsigned long )tmp___55;
#line 5533
      start += length_return;
#line 5534
      tmp___56 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5534
      temp = (unsigned long )tmp___56;
#line 5534
      start += length_return;
#line 5535
      start += temp;
#line 5536
      tmp___57 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5536
      if (tmp___57 >= 0) {
#line 5537
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5538
      goto switch_break;
      case_21: /* CIL Label */ 
      case_17: /* CIL Label */ 
      {
#line 5541
      tmp___58 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5541
      reg___0 = (unsigned long )tmp___58;
#line 5541
      start += length_return;
#line 5541
      read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5541
      start += length_return;
#line 5542
      tmp___59 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5542
      if (tmp___59 >= 0) {
#line 5543
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5544
      goto switch_break;
      case_18: /* CIL Label */ 
      {
#line 5546
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5546
      start += length_return;
#line 5546
      read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5546
      start += length_return;
      }
#line 5547
      goto switch_break;
      case_19: /* CIL Label */ 
      {
#line 5549
      read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5549
      start += length_return;
      }
#line 5550
      goto switch_break;
      case_29: /* CIL Label */ 
#line 5552
      start += 8;
#line 5553
      goto switch_break;
      case_46: /* CIL Label */ 
      {
#line 5555
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5555
      start += length_return;
      }
#line 5556
      goto switch_break;
      case_47: /* CIL Label */ 
      {
#line 5558
      tmp___60 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5558
      reg___0 = (unsigned long )tmp___60;
#line 5558
      start += length_return;
#line 5558
      read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5558
      start += length_return;
#line 5559
      tmp___61 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5559
      if (tmp___61 >= 0) {
#line 5560
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5561
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 5563
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
#line 5566
    start = tmp___40;
    {
#line 5572
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 5572
      if (! ((unsigned long )start < (unsigned long )block_end)) {
#line 5572
        goto while_break___21;
      }
#line 5579
      reg_prefix = "";
#line 5581
      tmp___62 = start;
#line 5581
      start ++;
#line 5581
      op___0 = (unsigned int )*tmp___62;
#line 5582
      opa___0 = op___0 & 63U;
#line 5583
      if (op___0 & 192U) {
#line 5584
        op___0 &= 192U;
      }
      {
#line 5590
      if (op___0 == 64U) {
#line 5590
        goto case_64___0;
      }
#line 5602
      if (op___0 == 128U) {
#line 5602
        goto case_128___0;
      }
#line 5617
      if (op___0 == 192U) {
#line 5617
        goto case_192___0;
      }
#line 5634
      if (op___0 == 1U) {
#line 5634
        goto case_1___0;
      }
#line 5645
      if (op___0 == 2U) {
#line 5645
        goto case_2___0;
      }
#line 5658
      if (op___0 == 3U) {
#line 5658
        goto case_3___0;
      }
#line 5671
      if (op___0 == 4U) {
#line 5671
        goto case_4___0;
      }
#line 5684
      if (op___0 == 5U) {
#line 5684
        goto case_5___0;
      }
#line 5700
      if (op___0 == 20U) {
#line 5700
        goto case_20___0;
      }
#line 5716
      if (op___0 == 6U) {
#line 5716
        goto case_6___0;
      }
#line 5731
      if (op___0 == 7U) {
#line 5731
        goto case_7___0;
      }
#line 5745
      if (op___0 == 8U) {
#line 5745
        goto case_8___0;
      }
#line 5759
      if (op___0 == 9U) {
#line 5759
        goto case_9___0;
      }
#line 5777
      if (op___0 == 10U) {
#line 5777
        goto case_10;
      }
#line 5791
      if (op___0 == 11U) {
#line 5791
        goto case_11;
      }
#line 5810
      if (op___0 == 12U) {
#line 5810
        goto case_12___0;
      }
#line 5819
      if (op___0 == 13U) {
#line 5819
        goto case_13___0;
      }
#line 5827
      if (op___0 == 14U) {
#line 5827
        goto case_14___0;
      }
#line 5833
      if (op___0 == 0U) {
#line 5833
        goto case_0;
      }
#line 5838
      if (op___0 == 15U) {
#line 5838
        goto case_15___0;
      }
#line 5851
      if (op___0 == 16U) {
#line 5851
        goto case_16___0;
      }
#line 5869
      if (op___0 == 22U) {
#line 5869
        goto case_22___0;
      }
#line 5887
      if (op___0 == 17U) {
#line 5887
        goto case_17___0;
      }
#line 5903
      if (op___0 == 21U) {
#line 5903
        goto case_21___0;
      }
#line 5919
      if (op___0 == 18U) {
#line 5919
        goto case_18___0;
      }
#line 5929
      if (op___0 == 19U) {
#line 5929
        goto case_19___0;
      }
#line 5936
      if (op___0 == 29U) {
#line 5936
        goto case_29___0;
      }
#line 5949
      if (op___0 == 45U) {
#line 5949
        goto case_45;
      }
#line 5954
      if (op___0 == 46U) {
#line 5954
        goto case_46___0;
      }
#line 5960
      if (op___0 == 47U) {
#line 5960
        goto case_47___0;
      }
#line 5976
      goto switch_default___0;
      case_64___0: /* CIL Label */ 
#line 5591
      if (do_debug_frames_interp) {
        {
#line 5592
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5594
        tmp___63 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + (dwarf_vma )(opa___0 * fc->code_factor),
                                  (unsigned int )fc->ptr_size);
#line 5594
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc: %d to %s\n",
               opa___0 * fc->code_factor, tmp___63);
        }
      }
#line 5599
      fc->pc_begin += (dwarf_vma )(opa___0 * fc->code_factor);
#line 5600
      goto switch_break___0;
      case_128___0: /* CIL Label */ 
      {
#line 5603
      tmp___64 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5603
      roffs = (unsigned long )tmp___64;
#line 5603
      start += length_return;
      }
#line 5604
      if (opa___0 >= (unsigned int )fc->ncols) {
#line 5605
        reg_prefix = bad_reg;
      }
#line 5606
      if (! do_debug_frames_interp) {
        {
#line 5607
        tmp___65 = regname(opa___0, 0);
#line 5607
        printf((char const   */* __restrict  */)"  DW_CFA_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___65, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5606
      if ((int const   )*reg_prefix != 0) {
        {
#line 5607
        tmp___65 = regname(opa___0, 0);
#line 5607
        printf((char const   */* __restrict  */)"  DW_CFA_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___65, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5610
      if ((int const   )*reg_prefix == 0) {
#line 5612
        *(fc->col_type + opa___0) = (short)128;
#line 5613
        *(fc->col_offset + opa___0) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5615
      goto switch_break___0;
      case_192___0: /* CIL Label */ 
#line 5618
      if (opa___0 >= (unsigned int )cie->ncols) {
#line 5620
        reg_prefix = bad_reg;
      } else
#line 5618
      if (opa___0 >= (unsigned int )fc->ncols) {
#line 5620
        reg_prefix = bad_reg;
      }
#line 5621
      if (! do_debug_frames_interp) {
        {
#line 5622
        tmp___66 = regname(opa___0, 0);
#line 5622
        printf((char const   */* __restrict  */)"  DW_CFA_restore: %s%s\n", reg_prefix,
               tmp___66);
        }
      } else
#line 5621
      if ((int const   )*reg_prefix != 0) {
        {
#line 5622
        tmp___66 = regname(opa___0, 0);
#line 5622
        printf((char const   */* __restrict  */)"  DW_CFA_restore: %s%s\n", reg_prefix,
               tmp___66);
        }
      }
#line 5624
      if ((int const   )*reg_prefix == 0) {
#line 5626
        *(fc->col_type + opa___0) = *(cie->col_type + opa___0);
#line 5627
        *(fc->col_offset + opa___0) = *(cie->col_offset + opa___0);
#line 5628
        if (do_debug_frames_interp) {
#line 5628
          if ((int )*(fc->col_type + opa___0) == -1) {
#line 5630
            *(fc->col_type + opa___0) = (short)7;
          }
        }
      }
#line 5632
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 5635
      vma = get_encoded_value(start, (int )fc->fde_encoding, section);
#line 5636
      start += encoded_ptr_size;
      }
#line 5637
      if (do_debug_frames_interp) {
        {
#line 5638
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5640
        tmp___67 = dwarf_vmatoa_1((char const   *)((void *)0), vma, (unsigned int )fc->ptr_size);
#line 5640
        printf((char const   */* __restrict  */)"  DW_CFA_set_loc: %s\n", tmp___67);
        }
      }
#line 5642
      fc->pc_begin = vma;
#line 5643
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 5646
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 5646
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 5646
          amount___7 = 1U;
#line 5646
          if ((unsigned long )(start + amount___7) >= (unsigned long )end) {
#line 5646
            if ((unsigned long )start < (unsigned long )end) {
#line 5646
              amount___7 = (unsigned int )(end - start);
            } else {
#line 5646
              amount___7 = 0U;
            }
          }
#line 5646
          if (amount___7) {
            {
#line 5646
            ofs = (*byte_get)(start, (int )amount___7);
            }
          } else {
#line 5646
            ofs = (dwarf_vma )0;
          }
#line 5646
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
#line 5646
        start ++;
#line 5646
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 5647
      if (do_debug_frames_interp) {
        {
#line 5648
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5650
        tmp___68 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + ofs * (dwarf_vma )fc->code_factor,
                                  (unsigned int )fc->ptr_size);
#line 5650
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc1: %ld to %s\n",
               (unsigned long )(ofs * (dwarf_vma )fc->code_factor), tmp___68);
        }
      }
#line 5655
      fc->pc_begin += ofs * (dwarf_vma )fc->code_factor;
#line 5656
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      {
#line 5659
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 5659
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 5659
          amount___8 = 2U;
#line 5659
          if ((unsigned long )(start + amount___8) >= (unsigned long )end) {
#line 5659
            if ((unsigned long )start < (unsigned long )end) {
#line 5659
              amount___8 = (unsigned int )(end - start);
            } else {
#line 5659
              amount___8 = 0U;
            }
          }
#line 5659
          if (amount___8) {
            {
#line 5659
            ofs = (*byte_get)(start, (int )amount___8);
            }
          } else {
#line 5659
            ofs = (dwarf_vma )0;
          }
#line 5659
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 5659
        start += 2;
#line 5659
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 5660
      if (do_debug_frames_interp) {
        {
#line 5661
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5663
        tmp___69 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + ofs * (dwarf_vma )fc->code_factor,
                                  (unsigned int )fc->ptr_size);
#line 5663
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc2: %ld to %s\n",
               (unsigned long )(ofs * (dwarf_vma )fc->code_factor), tmp___69);
        }
      }
#line 5668
      fc->pc_begin += ofs * (dwarf_vma )fc->code_factor;
#line 5669
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 5672
      while (1) {
        while_continue___26: /* CIL Label */ ;
        {
#line 5672
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 5672
          amount___9 = 4U;
#line 5672
          if ((unsigned long )(start + amount___9) >= (unsigned long )end) {
#line 5672
            if ((unsigned long )start < (unsigned long )end) {
#line 5672
              amount___9 = (unsigned int )(end - start);
            } else {
#line 5672
              amount___9 = 0U;
            }
          }
#line 5672
          if (amount___9) {
            {
#line 5672
            ofs = (*byte_get)(start, (int )amount___9);
            }
          } else {
#line 5672
            ofs = (dwarf_vma )0;
          }
#line 5672
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 5672
        start += 4;
#line 5672
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 5673
      if (do_debug_frames_interp) {
        {
#line 5674
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5676
        tmp___70 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + ofs * (dwarf_vma )fc->code_factor,
                                  (unsigned int )fc->ptr_size);
#line 5676
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc4: %ld to %s\n",
               (unsigned long )(ofs * (dwarf_vma )fc->code_factor), tmp___70);
        }
      }
#line 5681
      fc->pc_begin += ofs * (dwarf_vma )fc->code_factor;
#line 5682
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 5685
      tmp___71 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5685
      reg___1 = (unsigned long )tmp___71;
#line 5685
      start += length_return;
#line 5686
      tmp___72 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5686
      roffs = (unsigned long )tmp___72;
#line 5686
      start += length_return;
      }
#line 5687
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5688
        reg_prefix = bad_reg;
      }
#line 5689
      if (! do_debug_frames_interp) {
        {
#line 5690
        tmp___73 = regname((unsigned int )reg___1, 0);
#line 5690
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___73, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5689
      if ((int const   )*reg_prefix != 0) {
        {
#line 5690
        tmp___73 = regname((unsigned int )reg___1, 0);
#line 5690
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___73, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5693
      if ((int const   )*reg_prefix == 0) {
#line 5695
        *(fc->col_type + reg___1) = (short)128;
#line 5696
        *(fc->col_offset + reg___1) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5698
      goto switch_break___0;
      case_20___0: /* CIL Label */ 
      {
#line 5701
      tmp___74 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5701
      reg___1 = (unsigned long )tmp___74;
#line 5701
      start += length_return;
#line 5702
      tmp___75 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5702
      roffs = (unsigned long )tmp___75;
#line 5702
      start += length_return;
      }
#line 5703
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5704
        reg_prefix = bad_reg;
      }
#line 5705
      if (! do_debug_frames_interp) {
        {
#line 5706
        tmp___76 = regname((unsigned int )reg___1, 0);
#line 5706
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___76, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5705
      if ((int const   )*reg_prefix != 0) {
        {
#line 5706
        tmp___76 = regname((unsigned int )reg___1, 0);
#line 5706
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___76, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5709
      if ((int const   )*reg_prefix == 0) {
#line 5711
        *(fc->col_type + reg___1) = (short)20;
#line 5712
        *(fc->col_offset + reg___1) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5714
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      {
#line 5717
      tmp___77 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5717
      reg___1 = (unsigned long )tmp___77;
#line 5717
      start += length_return;
      }
#line 5718
      if (reg___1 >= (unsigned long )((unsigned int )cie->ncols)) {
#line 5720
        reg_prefix = bad_reg;
      } else
#line 5718
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5720
        reg_prefix = bad_reg;
      }
#line 5721
      if (! do_debug_frames_interp) {
        {
#line 5722
        tmp___78 = regname((unsigned int )reg___1, 0);
#line 5722
        printf((char const   */* __restrict  */)"  DW_CFA_restore_extended: %s%s\n",
               reg_prefix, tmp___78);
        }
      } else
#line 5721
      if ((int const   )*reg_prefix != 0) {
        {
#line 5722
        tmp___78 = regname((unsigned int )reg___1, 0);
#line 5722
        printf((char const   */* __restrict  */)"  DW_CFA_restore_extended: %s%s\n",
               reg_prefix, tmp___78);
        }
      }
#line 5724
      if ((int const   )*reg_prefix == 0) {
#line 5726
        *(fc->col_type + reg___1) = *(cie->col_type + reg___1);
#line 5727
        *(fc->col_offset + reg___1) = *(cie->col_offset + reg___1);
      }
#line 5729
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 5732
      tmp___79 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5732
      reg___1 = (unsigned long )tmp___79;
#line 5732
      start += length_return;
      }
#line 5733
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5734
        reg_prefix = bad_reg;
      }
#line 5735
      if (! do_debug_frames_interp) {
        {
#line 5736
        tmp___80 = regname((unsigned int )reg___1, 0);
#line 5736
        printf((char const   */* __restrict  */)"  DW_CFA_undefined: %s%s\n", reg_prefix,
               tmp___80);
        }
      } else
#line 5735
      if ((int const   )*reg_prefix != 0) {
        {
#line 5736
        tmp___80 = regname((unsigned int )reg___1, 0);
#line 5736
        printf((char const   */* __restrict  */)"  DW_CFA_undefined: %s%s\n", reg_prefix,
               tmp___80);
        }
      }
#line 5738
      if ((int const   )*reg_prefix == 0) {
#line 5740
        *(fc->col_type + reg___1) = (short)7;
#line 5741
        *(fc->col_offset + reg___1) = 0;
      }
#line 5743
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 5746
      tmp___81 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5746
      reg___1 = (unsigned long )tmp___81;
#line 5746
      start += length_return;
      }
#line 5747
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5748
        reg_prefix = bad_reg;
      }
#line 5749
      if (! do_debug_frames_interp) {
        {
#line 5750
        tmp___82 = regname((unsigned int )reg___1, 0);
#line 5750
        printf((char const   */* __restrict  */)"  DW_CFA_same_value: %s%s\n", reg_prefix,
               tmp___82);
        }
      } else
#line 5749
      if ((int const   )*reg_prefix != 0) {
        {
#line 5750
        tmp___82 = regname((unsigned int )reg___1, 0);
#line 5750
        printf((char const   */* __restrict  */)"  DW_CFA_same_value: %s%s\n", reg_prefix,
               tmp___82);
        }
      }
#line 5752
      if ((int const   )*reg_prefix == 0) {
#line 5754
        *(fc->col_type + reg___1) = (short)8;
#line 5755
        *(fc->col_offset + reg___1) = 0;
      }
#line 5757
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 5760
      tmp___83 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5760
      reg___1 = (unsigned long )tmp___83;
#line 5760
      start += length_return;
#line 5761
      tmp___84 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5761
      roffs = (unsigned long )tmp___84;
#line 5761
      start += length_return;
      }
#line 5762
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5763
        reg_prefix = bad_reg;
      }
#line 5764
      if (! do_debug_frames_interp) {
        {
#line 5766
        tmp___85 = regname((unsigned int )reg___1, 0);
#line 5766
        printf((char const   */* __restrict  */)"  DW_CFA_register: %s%s in ", reg_prefix,
               tmp___85);
#line 5768
        tmp___86 = regname((unsigned int )roffs, 0);
#line 5768
        puts(tmp___86);
        }
      } else
#line 5764
      if ((int const   )*reg_prefix != 0) {
        {
#line 5766
        tmp___85 = regname((unsigned int )reg___1, 0);
#line 5766
        printf((char const   */* __restrict  */)"  DW_CFA_register: %s%s in ", reg_prefix,
               tmp___85);
#line 5768
        tmp___86 = regname((unsigned int )roffs, 0);
#line 5768
        puts(tmp___86);
        }
      }
#line 5770
      if ((int const   )*reg_prefix == 0) {
#line 5772
        *(fc->col_type + reg___1) = (short)9;
#line 5773
        *(fc->col_offset + reg___1) = (int )roffs;
      }
#line 5775
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 5778
      if (! do_debug_frames_interp) {
        {
#line 5779
        printf((char const   */* __restrict  */)"  DW_CFA_remember_state\n");
        }
      }
      {
#line 5780
      tmp___87 = xmalloc(sizeof(Frame_Chunk ));
#line 5780
      rs = (Frame_Chunk *)tmp___87;
#line 5781
      rs->ncols = fc->ncols;
#line 5782
      tmp___88 = xcmalloc((size_t )rs->ncols, sizeof(short ));
#line 5782
      rs->col_type = (short *)tmp___88;
#line 5784
      tmp___89 = xcmalloc((size_t )rs->ncols, sizeof(int ));
#line 5784
      rs->col_offset = (int *)tmp___89;
#line 5785
      memcpy((void */* __restrict  */)rs->col_type, (void const   */* __restrict  */)fc->col_type,
             (size_t )rs->ncols);
#line 5786
      memcpy((void */* __restrict  */)rs->col_offset, (void const   */* __restrict  */)fc->col_offset,
             (unsigned long )rs->ncols * sizeof(int ));
#line 5787
      rs->next = remembered_state;
#line 5788
      remembered_state = rs;
      }
#line 5789
      goto switch_break___0;
      case_11: /* CIL Label */ 
#line 5792
      if (! do_debug_frames_interp) {
        {
#line 5793
        printf((char const   */* __restrict  */)"  DW_CFA_restore_state\n");
        }
      }
#line 5794
      rs = remembered_state;
#line 5795
      if (rs) {
        {
#line 5797
        remembered_state = rs->next;
#line 5798
        frame_need_space(fc, (unsigned int )(rs->ncols - 1));
#line 5799
        memcpy((void */* __restrict  */)fc->col_type, (void const   */* __restrict  */)rs->col_type,
               (size_t )rs->ncols);
#line 5800
        memcpy((void */* __restrict  */)fc->col_offset, (void const   */* __restrict  */)rs->col_offset,
               (unsigned long )rs->ncols * sizeof(int ));
#line 5802
        free((void *)rs->col_type);
#line 5803
        free((void *)rs->col_offset);
#line 5804
        free((void *)rs);
        }
      } else
#line 5806
      if (do_debug_frames_interp) {
        {
#line 5807
        printf((char const   */* __restrict  */)"Mismatched DW_CFA_restore_state\n");
        }
      }
#line 5808
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
      {
#line 5811
      tmp___90 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5811
      fc->cfa_reg = (int )tmp___90;
#line 5811
      start += length_return;
#line 5812
      tmp___91 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5812
      fc->cfa_offset = (int )tmp___91;
#line 5812
      start += length_return;
#line 5813
      fc->cfa_exp = (unsigned char)0;
      }
#line 5814
      if (! do_debug_frames_interp) {
        {
#line 5815
        tmp___92 = regname((unsigned int )fc->cfa_reg, 0);
#line 5815
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa: %s ofs %d\n", tmp___92,
               fc->cfa_offset);
        }
      }
#line 5817
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      {
#line 5820
      tmp___93 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5820
      fc->cfa_reg = (int )tmp___93;
#line 5820
      start += length_return;
#line 5821
      fc->cfa_exp = (unsigned char)0;
      }
#line 5822
      if (! do_debug_frames_interp) {
        {
#line 5823
        tmp___94 = regname((unsigned int )fc->cfa_reg, 0);
#line 5823
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_register: %s\n",
               tmp___94);
        }
      }
#line 5825
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
      {
#line 5828
      tmp___95 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5828
      fc->cfa_offset = (int )tmp___95;
#line 5828
      start += length_return;
      }
#line 5829
      if (! do_debug_frames_interp) {
        {
#line 5830
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
        }
      }
#line 5831
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 5834
      if (! do_debug_frames_interp) {
        {
#line 5835
        printf((char const   */* __restrict  */)"  DW_CFA_nop\n");
        }
      }
#line 5836
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 5839
      tmp___96 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5839
      ul = (unsigned long )tmp___96;
#line 5839
      start += length_return;
      }
#line 5840
      if (! do_debug_frames_interp) {
        {
#line 5842
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_expression (");
#line 5843
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5845
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5847
      fc->cfa_exp = (unsigned char)1;
#line 5848
      start += ul;
#line 5849
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
      {
#line 5852
      tmp___97 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5852
      reg___1 = (unsigned long )tmp___97;
#line 5852
      start += length_return;
#line 5853
      tmp___98 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5853
      ul = (unsigned long )tmp___98;
#line 5853
      start += length_return;
      }
#line 5854
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5855
        reg_prefix = bad_reg;
      }
#line 5856
      if (! do_debug_frames_interp) {
        {
#line 5858
        tmp___99 = regname((unsigned int )reg___1, 0);
#line 5858
        printf((char const   */* __restrict  */)"  DW_CFA_expression: %s%s (", reg_prefix,
               tmp___99);
#line 5860
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5862
        printf((char const   */* __restrict  */)")\n");
        }
      } else
#line 5856
      if ((int const   )*reg_prefix != 0) {
        {
#line 5858
        tmp___99 = regname((unsigned int )reg___1, 0);
#line 5858
        printf((char const   */* __restrict  */)"  DW_CFA_expression: %s%s (", reg_prefix,
               tmp___99);
#line 5860
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5862
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5864
      if ((int const   )*reg_prefix == 0) {
#line 5865
        *(fc->col_type + reg___1) = (short)16;
      }
#line 5866
      start += ul;
#line 5867
      goto switch_break___0;
      case_22___0: /* CIL Label */ 
      {
#line 5870
      tmp___100 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5870
      reg___1 = (unsigned long )tmp___100;
#line 5870
      start += length_return;
#line 5871
      tmp___101 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5871
      ul = (unsigned long )tmp___101;
#line 5871
      start += length_return;
      }
#line 5872
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5873
        reg_prefix = bad_reg;
      }
#line 5874
      if (! do_debug_frames_interp) {
        {
#line 5876
        tmp___102 = regname((unsigned int )reg___1, 0);
#line 5876
        printf((char const   */* __restrict  */)"  DW_CFA_val_expression: %s%s (",
               reg_prefix, tmp___102);
#line 5878
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5880
        printf((char const   */* __restrict  */)")\n");
        }
      } else
#line 5874
      if ((int const   )*reg_prefix != 0) {
        {
#line 5876
        tmp___102 = regname((unsigned int )reg___1, 0);
#line 5876
        printf((char const   */* __restrict  */)"  DW_CFA_val_expression: %s%s (",
               reg_prefix, tmp___102);
#line 5878
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5880
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5882
      if ((int const   )*reg_prefix == 0) {
#line 5883
        *(fc->col_type + reg___1) = (short)22;
      }
#line 5884
      start += ul;
#line 5885
      goto switch_break___0;
      case_17___0: /* CIL Label */ 
      {
#line 5888
      tmp___103 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5888
      reg___1 = (unsigned long )tmp___103;
#line 5888
      start += length_return;
#line 5889
      tmp___104 = read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5889
      l = (long )tmp___104;
#line 5889
      start += length_return;
#line 5890
      tmp___105 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5890
      if (tmp___105 < 0) {
#line 5891
        reg_prefix = bad_reg;
      }
#line 5892
      if (! do_debug_frames_interp) {
        {
#line 5893
        tmp___106 = regname((unsigned int )reg___1, 0);
#line 5893
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___106, l * (long )fc->data_factor);
        }
      } else
#line 5892
      if ((int const   )*reg_prefix != 0) {
        {
#line 5893
        tmp___106 = regname((unsigned int )reg___1, 0);
#line 5893
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___106, l * (long )fc->data_factor);
        }
      }
#line 5896
      if ((int const   )*reg_prefix == 0) {
#line 5898
        *(fc->col_type + reg___1) = (short)128;
#line 5899
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5901
      goto switch_break___0;
      case_21___0: /* CIL Label */ 
      {
#line 5904
      tmp___107 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5904
      reg___1 = (unsigned long )tmp___107;
#line 5904
      start += length_return;
#line 5905
      tmp___108 = read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5905
      l = (long )tmp___108;
#line 5905
      start += length_return;
#line 5906
      tmp___109 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5906
      if (tmp___109 < 0) {
#line 5907
        reg_prefix = bad_reg;
      }
#line 5908
      if (! do_debug_frames_interp) {
        {
#line 5909
        tmp___110 = regname((unsigned int )reg___1, 0);
#line 5909
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___110, l * (long )fc->data_factor);
        }
      } else
#line 5908
      if ((int const   )*reg_prefix != 0) {
        {
#line 5909
        tmp___110 = regname((unsigned int )reg___1, 0);
#line 5909
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___110, l * (long )fc->data_factor);
        }
      }
#line 5912
      if ((int const   )*reg_prefix == 0) {
#line 5914
        *(fc->col_type + reg___1) = (short)20;
#line 5915
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5917
      goto switch_break___0;
      case_18___0: /* CIL Label */ 
      {
#line 5920
      tmp___111 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5920
      fc->cfa_reg = (int )tmp___111;
#line 5920
      start += length_return;
#line 5921
      tmp___112 = read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5921
      fc->cfa_offset = (int )tmp___112;
#line 5921
      start += length_return;
#line 5922
      fc->cfa_offset *= fc->data_factor;
#line 5923
      fc->cfa_exp = (unsigned char)0;
      }
#line 5924
      if (! do_debug_frames_interp) {
        {
#line 5925
        tmp___113 = regname((unsigned int )fc->cfa_reg, 0);
#line 5925
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_sf: %s ofs %d\n",
               tmp___113, fc->cfa_offset);
        }
      }
#line 5927
      goto switch_break___0;
      case_19___0: /* CIL Label */ 
      {
#line 5930
      tmp___114 = read_sleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5930
      fc->cfa_offset = (int )tmp___114;
#line 5930
      start += length_return;
#line 5931
      fc->cfa_offset *= fc->data_factor;
      }
#line 5932
      if (! do_debug_frames_interp) {
        {
#line 5933
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_offset_sf: %d\n",
               fc->cfa_offset);
        }
      }
#line 5934
      goto switch_break___0;
      case_29___0: /* CIL Label */ 
      {
#line 5937
      while (1) {
        while_continue___28: /* CIL Label */ ;
        {
#line 5937
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 5937
          amount___10 = 8U;
#line 5937
          if ((unsigned long )(start + amount___10) >= (unsigned long )end) {
#line 5937
            if ((unsigned long )start < (unsigned long )end) {
#line 5937
              amount___10 = (unsigned int )(end - start);
            } else {
#line 5937
              amount___10 = 0U;
            }
          }
#line 5937
          if (amount___10) {
            {
#line 5937
            ofs = (*byte_get)(start, (int )amount___10);
            }
          } else {
#line 5937
            ofs = (dwarf_vma )0;
          }
#line 5937
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 5937
        start += 8;
#line 5937
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 5938
      if (do_debug_frames_interp) {
        {
#line 5939
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5941
        tmp___115 = dwarf_vmatoa_1((char const   *)((void *)0), fc->pc_begin + ofs * (dwarf_vma )fc->code_factor,
                                   (unsigned int )fc->ptr_size);
#line 5941
        printf((char const   */* __restrict  */)"  DW_CFA_MIPS_advance_loc8: %ld to %s\n",
               (unsigned long )(ofs * (dwarf_vma )fc->code_factor), tmp___115);
        }
      }
#line 5946
      fc->pc_begin += ofs * (dwarf_vma )fc->code_factor;
#line 5947
      goto switch_break___0;
      case_45: /* CIL Label */ 
#line 5950
      if (! do_debug_frames_interp) {
        {
#line 5951
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_window_save\n");
        }
      }
#line 5952
      goto switch_break___0;
      case_46___0: /* CIL Label */ 
      {
#line 5955
      tmp___116 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5955
      ul = (unsigned long )tmp___116;
#line 5955
      start += length_return;
      }
#line 5956
      if (! do_debug_frames_interp) {
        {
#line 5957
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_args_size: %ld\n", ul);
        }
      }
#line 5958
      goto switch_break___0;
      case_47___0: /* CIL Label */ 
      {
#line 5961
      tmp___117 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5961
      reg___1 = (unsigned long )tmp___117;
#line 5961
      start += length_return;
#line 5962
      tmp___118 = read_uleb128(start, & length_return, (unsigned char const   */* const  */)end);
#line 5962
      l = (long )(- tmp___118);
#line 5962
      start += length_return;
#line 5963
      tmp___119 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5963
      if (tmp___119 < 0) {
#line 5964
        reg_prefix = bad_reg;
      }
#line 5965
      if (! do_debug_frames_interp) {
        {
#line 5966
        tmp___120 = regname((unsigned int )reg___1, 0);
#line 5966
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___120, l * (long )fc->data_factor);
        }
      } else
#line 5965
      if ((int const   )*reg_prefix != 0) {
        {
#line 5966
        tmp___120 = regname((unsigned int )reg___1, 0);
#line 5966
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___120, l * (long )fc->data_factor);
        }
      }
#line 5969
      if ((int const   )*reg_prefix == 0) {
#line 5971
        *(fc->col_type + reg___1) = (short)128;
#line 5972
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5974
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 5977
      if (op___0 >= 28U) {
#line 5977
        if (op___0 <= 63U) {
          {
#line 5978
          tmp___121 = gettext("  DW_CFA_??? (User defined call frame op: %#x)\n");
#line 5978
          printf((char const   */* __restrict  */)tmp___121, op___0);
          }
        } else {
          {
#line 5980
          tmp___122 = gettext("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n");
#line 5980
          warn((char const   *)tmp___122, op___0);
          }
        }
      } else {
        {
#line 5980
        tmp___122 = gettext("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n");
#line 5980
        warn((char const   *)tmp___122, op___0);
        }
      }
#line 5981
      start = block_end;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
#line 5985
    if (do_debug_frames_interp) {
      {
#line 5986
      frame_display_row(fc, & need_col_headers, & max_regs);
      }
    }
#line 5988
    start = block_end;
#line 5989
    eh_addr_size = saved_eh_addr_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5992
  printf((char const   */* __restrict  */)"\n");
  }
#line 5994
  return (1);
}
}
#line 6001 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_gdb_index(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  uint32_t version ;
  uint32_t cu_list_offset ;
  uint32_t tu_list_offset ;
  uint32_t address_table_offset ;
  uint32_t symbol_table_offset ;
  uint32_t constant_pool_offset ;
  unsigned int cu_list_elements ;
  unsigned int tu_list_elements ;
  unsigned int address_table_size ;
  unsigned int symbol_table_slots ;
  unsigned char *cu_list ;
  unsigned char *tu_list ;
  unsigned char *address_table ;
  unsigned char *symbol_table ;
  unsigned char *constant_pool ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  uint64_t cu_offset ;
  elf_vma tmp___16 ;
  uint64_t cu_length ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  uint64_t tu_offset ;
  elf_vma tmp___20 ;
  uint64_t type_offset ;
  elf_vma tmp___21 ;
  uint64_t signature ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  uint64_t low ;
  elf_vma tmp___25 ;
  uint64_t high ;
  elf_vma tmp___26 ;
  uint32_t cu_index ;
  elf_vma tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  uint32_t name_offset ;
  elf_vma tmp___30 ;
  uint32_t cu_vector_offset ;
  elf_vma tmp___31 ;
  uint32_t num_cus ;
  uint32_t cu ;
  unsigned int j ;
  elf_vma tmp___32 ;
  int is_static ;
  gdb_index_symbol_kind kind ;
  elf_vma tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;

  {
  {
#line 6005
  start = section->start;
#line 6017
  tmp___0 = gettext("Contents of the %s section:\n");
#line 6017
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
#line 6019
  if (section->size < (dwarf_size_type )(6UL * sizeof(uint32_t ))) {
    {
#line 6021
    tmp___1 = gettext("Truncated header in the %s section.\n");
#line 6021
    warn((char const   *)tmp___1, section->name);
    }
#line 6022
    return (0);
  }
  {
#line 6025
  tmp___2 = byte_get_little_endian(start, 4);
#line 6025
  version = (uint32_t )tmp___2;
#line 6026
  tmp___3 = gettext("Version %ld\n");
#line 6026
  printf((char const   */* __restrict  */)tmp___3, (long )version);
  }
#line 6030
  if (version < 3U) {
    {
#line 6032
    tmp___4 = gettext("Unsupported version %lu.\n");
#line 6032
    warn((char const   *)tmp___4, (unsigned long )version);
    }
#line 6033
    return (0);
  } else
#line 6030
  if (version > 8U) {
    {
#line 6032
    tmp___4 = gettext("Unsupported version %lu.\n");
#line 6032
    warn((char const   *)tmp___4, (unsigned long )version);
    }
#line 6033
    return (0);
  }
#line 6035
  if (version < 4U) {
    {
#line 6036
    tmp___5 = gettext("The address table data in version 3 may be wrong.\n");
#line 6036
    warn((char const   *)tmp___5);
    }
  }
#line 6037
  if (version < 5U) {
    {
#line 6038
    tmp___6 = gettext("Version 4 does not support case insensitive lookups.\n");
#line 6038
    warn((char const   *)tmp___6);
    }
  }
#line 6039
  if (version < 6U) {
    {
#line 6040
    tmp___7 = gettext("Version 5 does not include inlined functions.\n");
#line 6040
    warn((char const   *)tmp___7);
    }
  }
#line 6041
  if (version < 7U) {
    {
#line 6042
    tmp___8 = gettext("Version 6 does not include symbol attributes.\n");
#line 6042
    warn((char const   *)tmp___8);
    }
  }
  {
#line 6048
  tmp___9 = byte_get_little_endian(start + 4, 4);
#line 6048
  cu_list_offset = (uint32_t )tmp___9;
#line 6049
  tmp___10 = byte_get_little_endian(start + 8, 4);
#line 6049
  tu_list_offset = (uint32_t )tmp___10;
#line 6050
  tmp___11 = byte_get_little_endian(start + 12, 4);
#line 6050
  address_table_offset = (uint32_t )tmp___11;
#line 6051
  tmp___12 = byte_get_little_endian(start + 16, 4);
#line 6051
  symbol_table_offset = (uint32_t )tmp___12;
#line 6052
  tmp___13 = byte_get_little_endian(start + 20, 4);
#line 6052
  constant_pool_offset = (uint32_t )tmp___13;
  }
#line 6054
  if ((dwarf_size_type )cu_list_offset > section->size) {
    {
#line 6060
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 6060
    warn((char const   *)tmp___14, section->name);
    }
#line 6061
    return (0);
  } else
#line 6054
  if ((dwarf_size_type )tu_list_offset > section->size) {
    {
#line 6060
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 6060
    warn((char const   *)tmp___14, section->name);
    }
#line 6061
    return (0);
  } else
#line 6054
  if ((dwarf_size_type )address_table_offset > section->size) {
    {
#line 6060
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 6060
    warn((char const   *)tmp___14, section->name);
    }
#line 6061
    return (0);
  } else
#line 6054
  if ((dwarf_size_type )symbol_table_offset > section->size) {
    {
#line 6060
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 6060
    warn((char const   *)tmp___14, section->name);
    }
#line 6061
    return (0);
  } else
#line 6054
  if ((dwarf_size_type )constant_pool_offset > section->size) {
    {
#line 6060
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 6060
    warn((char const   *)tmp___14, section->name);
    }
#line 6061
    return (0);
  }
  {
#line 6064
  cu_list_elements = (tu_list_offset - cu_list_offset) / 8U;
#line 6065
  tu_list_elements = (address_table_offset - tu_list_offset) / 8U;
#line 6066
  address_table_size = symbol_table_offset - address_table_offset;
#line 6067
  symbol_table_slots = (constant_pool_offset - symbol_table_offset) / 8U;
#line 6069
  cu_list = start + cu_list_offset;
#line 6070
  tu_list = start + tu_list_offset;
#line 6071
  address_table = start + address_table_offset;
#line 6072
  symbol_table = start + symbol_table_offset;
#line 6073
  constant_pool = start + constant_pool_offset;
#line 6075
  tmp___15 = gettext("\nCU table:\n");
#line 6075
  printf((char const   */* __restrict  */)tmp___15);
#line 6076
  i = 0U;
  }
  {
#line 6076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6076
    if (! (i < cu_list_elements)) {
#line 6076
      goto while_break;
    }
    {
#line 6078
    tmp___16 = byte_get_little_endian(cu_list + i * 8U, 8);
#line 6078
    cu_offset = (uint64_t )tmp___16;
#line 6079
    tmp___17 = byte_get_little_endian((cu_list + i * 8U) + 8, 8);
#line 6079
    cu_length = (uint64_t )tmp___17;
#line 6081
    tmp___18 = gettext("[%3u] 0x%lx - 0x%lx\n");
#line 6081
    printf((char const   */* __restrict  */)tmp___18, i / 2U, cu_offset, (cu_offset + cu_length) - 1UL);
#line 6076
    i += 2U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6086
  tmp___19 = gettext("\nTU table:\n");
#line 6086
  printf((char const   */* __restrict  */)tmp___19);
#line 6087
  i = 0U;
  }
  {
#line 6087
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6087
    if (! (i < tu_list_elements)) {
#line 6087
      goto while_break___0;
    }
    {
#line 6089
    tmp___20 = byte_get_little_endian(tu_list + i * 8U, 8);
#line 6089
    tu_offset = (uint64_t )tmp___20;
#line 6090
    tmp___21 = byte_get_little_endian((tu_list + i * 8U) + 8, 8);
#line 6090
    type_offset = (uint64_t )tmp___21;
#line 6091
    tmp___22 = byte_get_little_endian((tu_list + i * 8U) + 16, 8);
#line 6091
    signature = (uint64_t )tmp___22;
#line 6093
    tmp___23 = gettext("[%3u] 0x%lx 0x%lx ");
#line 6093
    printf((char const   */* __restrict  */)tmp___23, i / 3U, tu_offset, type_offset);
#line 6096
    print_dwarf_vma((dwarf_vma )signature, 8U);
#line 6097
    printf((char const   */* __restrict  */)"\n");
#line 6087
    i += 3U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6100
  tmp___24 = gettext("\nAddress table:\n");
#line 6100
  printf((char const   */* __restrict  */)tmp___24);
#line 6101
  i = 0U;
  }
  {
#line 6101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6101
    if (! (i < address_table_size)) {
#line 6101
      goto while_break___1;
    }
    {
#line 6103
    tmp___25 = byte_get_little_endian(address_table + i, 8);
#line 6103
    low = (uint64_t )tmp___25;
#line 6104
    tmp___26 = byte_get_little_endian((address_table + i) + 8, 8);
#line 6104
    high = (uint64_t )tmp___26;
#line 6105
    tmp___27 = byte_get_little_endian((address_table + i) + 16, 4);
#line 6105
    cu_index = (uint32_t )tmp___27;
#line 6107
    print_dwarf_vma((dwarf_vma )low, 8U);
#line 6108
    print_dwarf_vma((dwarf_vma )high, 8U);
#line 6109
    tmp___28 = gettext("%lu\n");
#line 6109
    printf((char const   */* __restrict  */)tmp___28, (unsigned long )cu_index);
#line 6101
    i += 20U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 6112
  tmp___29 = gettext("\nSymbol table:\n");
#line 6112
  printf((char const   */* __restrict  */)tmp___29);
#line 6113
  i = 0U;
  }
  {
#line 6113
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 6113
    if (! (i < symbol_table_slots)) {
#line 6113
      goto while_break___2;
    }
    {
#line 6115
    tmp___30 = byte_get_little_endian(symbol_table + i * 8U, 4);
#line 6115
    name_offset = (uint32_t )tmp___30;
#line 6116
    tmp___31 = byte_get_little_endian((symbol_table + i * 8U) + 4, 4);
#line 6116
    cu_vector_offset = (uint32_t )tmp___31;
    }
#line 6119
    if (name_offset != 0U) {
#line 6119
      goto _L;
    } else
#line 6119
    if (cu_vector_offset != 0U) {
      _L: /* CIL Label */ 
      {
#line 6124
      printf((char const   */* __restrict  */)"[%3u] %s:", i, constant_pool + name_offset);
#line 6125
      tmp___32 = byte_get_little_endian(constant_pool + cu_vector_offset, 4);
#line 6125
      num_cus = (uint32_t )tmp___32;
      }
#line 6126
      if (num_cus > 1U) {
        {
#line 6127
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 6128
      j = 0U;
      {
#line 6128
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6128
        if (! (j < num_cus)) {
#line 6128
          goto while_break___3;
        }
        {
#line 6133
        tmp___33 = byte_get_little_endian(((constant_pool + cu_vector_offset) + 4) + j * 4U,
                                          4);
#line 6133
        cu = (uint32_t )tmp___33;
#line 6134
        is_static = (int )((cu >> 31) & 1U);
#line 6135
        kind = (gdb_index_symbol_kind )((cu >> 28) & 7U);
#line 6136
        cu &= (unsigned int )((1 << 24) - 1);
        }
#line 6138
        if (cu >= cu_list_elements / 2U) {
#line 6139
          if (num_cus > 1U) {
#line 6139
            tmp___34 = '\t';
          } else {
#line 6139
            tmp___34 = ' ';
          }
          {
#line 6139
          printf((char const   */* __restrict  */)"%cT%lu", tmp___34, (unsigned long )(cu - cu_list_elements / 2U));
          }
        } else {
#line 6142
          if (num_cus > 1U) {
#line 6142
            tmp___35 = '\t';
          } else {
#line 6142
            tmp___35 = ' ';
          }
          {
#line 6142
          printf((char const   */* __restrict  */)"%c%lu", tmp___35, (unsigned long )cu);
          }
        }
        {
#line 6146
        if ((unsigned int )kind == 0U) {
#line 6146
          goto case_0;
        }
#line 6149
        if ((unsigned int )kind == 1U) {
#line 6149
          goto case_1;
        }
#line 6154
        if ((unsigned int )kind == 2U) {
#line 6154
          goto case_2;
        }
#line 6159
        if ((unsigned int )kind == 3U) {
#line 6159
          goto case_3;
        }
#line 6164
        if ((unsigned int )kind == 4U) {
#line 6164
          goto case_4;
        }
#line 6169
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 6147
        tmp___36 = gettext(" [no symbol information]");
#line 6147
        printf((char const   */* __restrict  */)tmp___36);
        }
#line 6148
        goto switch_break;
        case_1: /* CIL Label */ 
#line 6150
        if (is_static) {
          {
#line 6150
          tmp___37 = gettext(" [static type]");
#line 6150
          tmp___39 = tmp___37;
          }
        } else {
          {
#line 6150
          tmp___38 = gettext(" [global type]");
#line 6150
          tmp___39 = tmp___38;
          }
        }
        {
#line 6150
        printf((char const   */* __restrict  */)tmp___39);
        }
#line 6153
        goto switch_break;
        case_2: /* CIL Label */ 
#line 6155
        if (is_static) {
          {
#line 6155
          tmp___40 = gettext(" [static variable]");
#line 6155
          tmp___42 = tmp___40;
          }
        } else {
          {
#line 6155
          tmp___41 = gettext(" [global variable]");
#line 6155
          tmp___42 = tmp___41;
          }
        }
        {
#line 6155
        printf((char const   */* __restrict  */)tmp___42);
        }
#line 6158
        goto switch_break;
        case_3: /* CIL Label */ 
#line 6160
        if (is_static) {
          {
#line 6160
          tmp___43 = gettext(" [static function]");
#line 6160
          tmp___45 = tmp___43;
          }
        } else {
          {
#line 6160
          tmp___44 = gettext(" [global function]");
#line 6160
          tmp___45 = tmp___44;
          }
        }
        {
#line 6160
        printf((char const   */* __restrict  */)tmp___45);
        }
#line 6163
        goto switch_break;
        case_4: /* CIL Label */ 
#line 6165
        if (is_static) {
          {
#line 6165
          tmp___46 = gettext(" [static other]");
#line 6165
          tmp___48 = tmp___46;
          }
        } else {
          {
#line 6165
          tmp___47 = gettext(" [global other]");
#line 6165
          tmp___48 = tmp___47;
          }
        }
        {
#line 6165
        printf((char const   */* __restrict  */)tmp___48);
        }
#line 6168
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 6170
        if (is_static) {
          {
#line 6170
          tmp___49 = gettext(" [static unknown: %d]");
#line 6170
          tmp___51 = tmp___49;
          }
        } else {
          {
#line 6170
          tmp___50 = gettext(" [global unknown: %d]");
#line 6170
          tmp___51 = tmp___50;
          }
        }
        {
#line 6170
        printf((char const   */* __restrict  */)tmp___51, (unsigned int )kind);
        }
#line 6174
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 6176
        if (num_cus > 1U) {
          {
#line 6177
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 6128
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6179
      if (num_cus <= 1U) {
        {
#line 6180
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 6113
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 6184
  return (1);
}
}
#line 6189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void prealloc_cu_tu_list(unsigned int nshndx ) 
{ 
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6192
  if ((unsigned long )shndx_pool == (unsigned long )((void *)0)) {
    {
#line 6194
    shndx_pool_size = nshndx;
#line 6195
    shndx_pool_used = 0U;
#line 6196
    tmp___0 = xcmalloc((size_t )shndx_pool_size, sizeof(unsigned int ));
#line 6196
    shndx_pool = (unsigned int *)tmp___0;
    }
  } else {
    {
#line 6201
    shndx_pool_size = shndx_pool_used + nshndx;
#line 6202
    tmp___1 = xcrealloc((void *)shndx_pool, (size_t )shndx_pool_size, sizeof(unsigned int ));
#line 6202
    shndx_pool = (unsigned int *)tmp___1;
    }
  }
#line 6205
  return;
}
}
#line 6207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void add_shndx_to_cu_tu_entry(unsigned int shndx ) 
{ 
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 6210
  if (shndx_pool_used >= shndx_pool_size) {
    {
#line 6212
    tmp___0 = gettext("Internal error: out of space in the shndx pool.\n");
#line 6212
    error((char const   *)tmp___0);
    }
#line 6213
    return;
  }
#line 6215
  tmp___1 = shndx_pool_used;
#line 6215
  shndx_pool_used ++;
#line 6215
  *(shndx_pool + tmp___1) = shndx;
#line 6216
  return;
}
}
#line 6218 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void end_cu_tu_entry(void) 
{ 
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 6221
  if (shndx_pool_used >= shndx_pool_size) {
    {
#line 6223
    tmp___0 = gettext("Internal error: out of space in the shndx pool.\n");
#line 6223
    error((char const   *)tmp___0);
    }
#line 6224
    return;
  }
#line 6226
  tmp___1 = shndx_pool_used;
#line 6226
  shndx_pool_used ++;
#line 6226
  *(shndx_pool + tmp___1) = 0U;
#line 6227
  return;
}
}
#line 6234 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char buf___4[16]  ;
#line 6231 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static char const   *get_DW_SECT_short_name(unsigned int dw_sect ) 
{ 


  {
  {
#line 6238
  if (dw_sect == 1U) {
#line 6238
    goto case_1;
  }
#line 6240
  if (dw_sect == 2U) {
#line 6240
    goto case_2;
  }
#line 6242
  if (dw_sect == 3U) {
#line 6242
    goto case_3;
  }
#line 6244
  if (dw_sect == 4U) {
#line 6244
    goto case_4;
  }
#line 6246
  if (dw_sect == 5U) {
#line 6246
    goto case_5;
  }
#line 6248
  if (dw_sect == 6U) {
#line 6248
    goto case_6;
  }
#line 6250
  if (dw_sect == 7U) {
#line 6250
    goto case_7;
  }
#line 6252
  if (dw_sect == 8U) {
#line 6252
    goto case_8;
  }
#line 6254
  goto switch_default;
  case_1: /* CIL Label */ 
#line 6239
  return ("info");
  case_2: /* CIL Label */ 
#line 6241
  return ("types");
  case_3: /* CIL Label */ 
#line 6243
  return ("abbrev");
  case_4: /* CIL Label */ 
#line 6245
  return ("line");
  case_5: /* CIL Label */ 
#line 6247
  return ("loc");
  case_6: /* CIL Label */ 
#line 6249
  return ("str_off");
  case_7: /* CIL Label */ 
#line 6251
  return ("macinfo");
  case_8: /* CIL Label */ 
#line 6253
  return ("macro");
  switch_default: /* CIL Label */ 
#line 6255
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 6258
  snprintf((char */* __restrict  */)(buf___4), sizeof(buf___4), (char const   */* __restrict  */)"%d",
           dw_sect);
  }
#line 6259
  return ((char const   *)(buf___4));
}
}
#line 6266 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int process_cu_tu_index(struct dwarf_section *section , int do_display ) 
{ 
  unsigned char *phdr ;
  unsigned char *limit ;
  unsigned char *phash ;
  unsigned char *pindex ;
  unsigned char *ppool ;
  unsigned int version ;
  unsigned int ncols ;
  unsigned int nused ;
  unsigned int nslots ;
  unsigned int i ;
  unsigned int j ;
  dwarf_vma signature_high ;
  dwarf_vma signature_low ;
  char buf___7[64] ;
  elf_vma tmp___0 ;
  elf_vma tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned char *shndx_list ;
  unsigned int shndx ;
  elf_vma tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  elf_vma tmp___14 ;
  unsigned int val ;
  unsigned int dw_sect ;
  unsigned char *ph ;
  unsigned char *pi ;
  unsigned char *poffsets ;
  unsigned char *psizes ;
  unsigned char *pend ;
  bfd_boolean is_tu_index ;
  struct cu_tu_set *this_set ;
  unsigned int row ;
  unsigned char *prow ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  elf_vma tmp___23 ;
  char const   *tmp___24 ;
  elf_vma tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  elf_vma tmp___28 ;
  elf_vma tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  elf_vma tmp___34 ;
  char const   *tmp___35 ;
  elf_vma tmp___36 ;
  char const   *tmp___37 ;
  char *tmp___38 ;
  elf_vma tmp___39 ;
  elf_vma tmp___40 ;
  char *tmp___41 ;

  {
  {
#line 6269
  phdr = section->start;
#line 6270
  limit = phdr + section->size;
#line 6275
  ncols = 0U;
#line 6284
  tmp___0 = (*byte_get)(phdr, 4);
#line 6284
  version = (unsigned int )tmp___0;
  }
#line 6285
  if (version >= 2U) {
    {
#line 6286
    tmp___1 = (*byte_get)(phdr + 4, 4);
#line 6286
    ncols = (unsigned int )tmp___1;
    }
  }
  {
#line 6287
  tmp___2 = (*byte_get)(phdr + 8, 4);
#line 6287
  nused = (unsigned int )tmp___2;
#line 6288
  tmp___3 = (*byte_get)(phdr + 12, 4);
#line 6288
  nslots = (unsigned int )tmp___3;
#line 6289
  phash = phdr + 16;
#line 6290
  pindex = phash + nslots * 8U;
#line 6291
  ppool = pindex + nslots * 4U;
  }
#line 6293
  if (do_display) {
    {
#line 6295
    tmp___4 = gettext("Contents of the %s section:\n\n");
#line 6295
    printf((char const   */* __restrict  */)tmp___4, section->name);
#line 6296
    tmp___5 = gettext("  Version:                 %d\n");
#line 6296
    printf((char const   */* __restrict  */)tmp___5, version);
    }
#line 6297
    if (version >= 2U) {
      {
#line 6298
      tmp___6 = gettext("  Number of columns:       %d\n");
#line 6298
      printf((char const   */* __restrict  */)tmp___6, ncols);
      }
    }
    {
#line 6299
    tmp___7 = gettext("  Number of used entries:  %d\n");
#line 6299
    printf((char const   */* __restrict  */)tmp___7, nused);
#line 6300
    tmp___8 = gettext("  Number of slots:         %d\n\n");
#line 6300
    printf((char const   */* __restrict  */)tmp___8, nslots);
    }
  }
#line 6303
  if ((unsigned long )ppool > (unsigned long )limit) {
    {
#line 6305
    tmp___9 = gettext("Section %s too small for %d hash table entries\n");
#line 6305
    warn((char const   *)tmp___9, section->name, nslots);
    }
#line 6307
    return (0);
  }
#line 6310
  if (version == 1U) {
#line 6312
    if (! do_display) {
      {
#line 6313
      prealloc_cu_tu_list((unsigned int )((limit - ppool) / 4L));
      }
    }
#line 6314
    i = 0U;
    {
#line 6314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6314
      if (! (i < nslots)) {
#line 6314
        goto while_break;
      }
      {
#line 6319
      byte_get_64(phash, & signature_high, & signature_low);
      }
#line 6320
      if (signature_high != 0ULL) {
#line 6320
        goto _L;
      } else
#line 6320
      if (signature_low != 0ULL) {
        _L: /* CIL Label */ 
        {
#line 6322
        tmp___10 = (*byte_get)(pindex, 4);
#line 6322
        j = (unsigned int )tmp___10;
#line 6323
        shndx_list = ppool + j * 4U;
        }
#line 6324
        if (do_display) {
          {
#line 6325
          tmp___11 = dwarf_vmatoa64(signature_high, signature_low, buf___7, (unsigned int )sizeof(buf___7));
#line 6325
          tmp___12 = gettext("  [%3d] Signature:  0x%s  Sections: ");
#line 6325
          printf((char const   */* __restrict  */)tmp___12, i, tmp___11);
          }
        }
        {
#line 6328
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6330
          if ((unsigned long )shndx_list >= (unsigned long )limit) {
            {
#line 6332
            tmp___13 = gettext("Section %s too small for shndx pool\n");
#line 6332
            warn((char const   *)tmp___13, section->name);
            }
#line 6334
            return (0);
          }
          {
#line 6336
          tmp___14 = (*byte_get)(shndx_list, 4);
#line 6336
          shndx = (unsigned int )tmp___14;
          }
#line 6337
          if (shndx == 0U) {
#line 6338
            goto while_break___0;
          }
#line 6339
          if (do_display) {
            {
#line 6340
            printf((char const   */* __restrict  */)" %d", shndx);
            }
          } else {
            {
#line 6342
            add_shndx_to_cu_tu_entry(shndx);
            }
          }
#line 6343
          shndx_list += 4;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 6345
        if (do_display) {
          {
#line 6346
          printf((char const   */* __restrict  */)"\n");
          }
        } else {
          {
#line 6348
          end_cu_tu_entry();
          }
        }
      }
#line 6350
      phash += 8;
#line 6351
      pindex += 4;
#line 6314
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 6354
  if (version == 2U) {
    {
#line 6358
    ph = phash;
#line 6359
    pi = pindex;
#line 6360
    poffsets = ppool + ncols * 4U;
#line 6361
    psizes = poffsets + (nused * ncols) * 4U;
#line 6362
    pend = psizes + (nused * ncols) * 4U;
#line 6364
    this_set = (struct cu_tu_set *)((void *)0);
#line 6368
    tmp___15 = strcmp(section->name, ".debug_tu_index");
#line 6368
    is_tu_index = tmp___15 == 0;
    }
#line 6370
    if ((unsigned long )pend > (unsigned long )limit) {
      {
#line 6372
      tmp___16 = gettext("Section %s too small for offset and size tables\n");
#line 6372
      warn((char const   *)tmp___16, section->name);
      }
#line 6374
      return (0);
    }
#line 6377
    if (do_display) {
      {
#line 6379
      tmp___17 = gettext("  Offset table\n");
#line 6379
      printf((char const   */* __restrict  */)tmp___17);
      }
#line 6380
      if (is_tu_index) {
        {
#line 6380
        tmp___18 = gettext("signature");
#line 6380
        tmp___20 = tmp___18;
        }
      } else {
        {
#line 6380
        tmp___19 = gettext("dwo_id");
#line 6380
        tmp___20 = tmp___19;
        }
      }
      {
#line 6380
      printf((char const   */* __restrict  */)"  slot  %-16s  ", tmp___20);
      }
    } else
#line 6385
    if (is_tu_index) {
      {
#line 6387
      tu_count = (int )nused;
#line 6388
      tmp___21 = xcmalloc((size_t )nused, sizeof(struct cu_tu_set ));
#line 6388
      tu_sets = (struct cu_tu_set *)tmp___21;
#line 6389
      this_set = tu_sets;
      }
    } else {
      {
#line 6393
      cu_count = (int )nused;
#line 6394
      tmp___22 = xcmalloc((size_t )nused, sizeof(struct cu_tu_set ));
#line 6394
      cu_sets = (struct cu_tu_set *)tmp___22;
#line 6395
      this_set = cu_sets;
      }
    }
#line 6398
    if (do_display) {
#line 6400
      j = 0U;
      {
#line 6400
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6400
        if (! (j < ncols)) {
#line 6400
          goto while_break___1;
        }
        {
#line 6402
        tmp___23 = (*byte_get)(ppool + j * 4U, 4);
#line 6402
        dw_sect = (unsigned int )tmp___23;
#line 6403
        tmp___24 = get_DW_SECT_short_name(dw_sect);
#line 6403
        printf((char const   */* __restrict  */)" %8s", tmp___24);
#line 6400
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 6405
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 6407
    i = 0U;
    {
#line 6407
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6407
      if (! (i < nslots)) {
#line 6407
        goto while_break___2;
      }
      {
#line 6409
      byte_get_64(ph, & signature_high, & signature_low);
#line 6410
      tmp___25 = (*byte_get)(pi, 4);
#line 6410
      row = (unsigned int )tmp___25;
      }
#line 6411
      if (row != 0U) {
#line 6413
        if (! do_display) {
          {
#line 6414
          memcpy((void */* __restrict  */)(& (this_set + (row - 1U))->signature),
                 (void const   */* __restrict  */)ph, sizeof(uint64_t ));
          }
        }
#line 6415
        prow = poffsets + ((row - 1U) * ncols) * 4U;
#line 6416
        if (do_display) {
          {
#line 6417
          tmp___26 = dwarf_vmatoa64(signature_high, signature_low, buf___7, (unsigned int )sizeof(buf___7));
#line 6417
          tmp___27 = gettext("  [%3d] 0x%s");
#line 6417
          printf((char const   */* __restrict  */)tmp___27, i, tmp___26);
          }
        }
#line 6420
        j = 0U;
        {
#line 6420
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 6420
          if (! (j < ncols)) {
#line 6420
            goto while_break___3;
          }
          {
#line 6422
          tmp___28 = (*byte_get)(prow + j * 4U, 4);
#line 6422
          val = (unsigned int )tmp___28;
          }
#line 6423
          if (do_display) {
            {
#line 6424
            printf((char const   */* __restrict  */)" %8d", val);
            }
          } else {
            {
#line 6427
            tmp___29 = (*byte_get)(ppool + j * 4U, 4);
#line 6427
            dw_sect = (unsigned int )tmp___29;
#line 6428
            (this_set + (row - 1U))->section_offsets[dw_sect] = (dwarf_vma )val;
            }
          }
#line 6420
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 6431
        if (do_display) {
          {
#line 6432
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 6434
      ph += 8;
#line 6435
      pi += 4;
#line 6407
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 6438
    ph = phash;
#line 6439
    pi = pindex;
#line 6440
    if (do_display) {
      {
#line 6442
      printf((char const   */* __restrict  */)"\n");
#line 6443
      tmp___30 = gettext("  Size table\n");
#line 6443
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 6444
      if (is_tu_index) {
        {
#line 6444
        tmp___31 = gettext("signature");
#line 6444
        tmp___33 = tmp___31;
        }
      } else {
        {
#line 6444
        tmp___32 = gettext("dwo_id");
#line 6444
        tmp___33 = tmp___32;
        }
      }
      {
#line 6444
      printf((char const   */* __restrict  */)"  slot  %-16s  ", tmp___33);
      }
    }
#line 6447
    j = 0U;
    {
#line 6447
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6447
      if (! (j < ncols)) {
#line 6447
        goto while_break___4;
      }
      {
#line 6449
      tmp___34 = (*byte_get)(ppool + j * 4U, 4);
#line 6449
      val = (unsigned int )tmp___34;
      }
#line 6450
      if (do_display) {
        {
#line 6451
        tmp___35 = get_DW_SECT_short_name(val);
#line 6451
        printf((char const   */* __restrict  */)" %8s", tmp___35);
        }
      }
#line 6447
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 6453
    if (do_display) {
      {
#line 6454
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 6455
    i = 0U;
    {
#line 6455
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 6455
      if (! (i < nslots)) {
#line 6455
        goto while_break___5;
      }
      {
#line 6457
      byte_get_64(ph, & signature_high, & signature_low);
#line 6458
      tmp___36 = (*byte_get)(pi, 4);
#line 6458
      row = (unsigned int )tmp___36;
      }
#line 6459
      if (row != 0U) {
#line 6461
        prow = psizes + ((row - 1U) * ncols) * 4U;
#line 6462
        if (do_display) {
          {
#line 6463
          tmp___37 = dwarf_vmatoa64(signature_high, signature_low, buf___7, (unsigned int )sizeof(buf___7));
#line 6463
          tmp___38 = gettext("  [%3d] 0x%s");
#line 6463
          printf((char const   */* __restrict  */)tmp___38, i, tmp___37);
          }
        }
#line 6466
        j = 0U;
        {
#line 6466
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 6466
          if (! (j < ncols)) {
#line 6466
            goto while_break___6;
          }
          {
#line 6468
          tmp___39 = (*byte_get)(prow + j * 4U, 4);
#line 6468
          val = (unsigned int )tmp___39;
          }
#line 6469
          if (do_display) {
            {
#line 6470
            printf((char const   */* __restrict  */)" %8d", val);
            }
          } else {
            {
#line 6473
            tmp___40 = (*byte_get)(ppool + j * 4U, 4);
#line 6473
            dw_sect = (unsigned int )tmp___40;
#line 6474
            (this_set + (row - 1U))->section_sizes[dw_sect] = (size_t )val;
            }
          }
#line 6466
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 6477
        if (do_display) {
          {
#line 6478
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 6480
      ph += 8;
#line 6481
      pi += 4;
#line 6455
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 6484
  if (do_display) {
    {
#line 6485
    tmp___41 = gettext("  Unsupported version\n");
#line 6485
    printf((char const   */* __restrict  */)tmp___41);
    }
  }
#line 6487
  if (do_display) {
    {
#line 6488
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 6490
  return (1);
}
}
#line 6497 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static void load_cu_tu_indexes(void *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6502
  if (cu_tu_indexes_read) {
#line 6503
    return;
  }
  {
#line 6505
  tmp___0 = load_debug_section((enum dwarf_section_display_enum )32, file);
  }
#line 6505
  if (tmp___0) {
    {
#line 6506
    process_cu_tu_index(& debug_displays[32].section, 0);
    }
  }
  {
#line 6508
  tmp___1 = load_debug_section((enum dwarf_section_display_enum )33, file);
  }
#line 6508
  if (tmp___1) {
    {
#line 6509
    process_cu_tu_index(& debug_displays[33].section, 0);
    }
  }
#line 6511
  cu_tu_indexes_read = 1;
#line 6512
  return;
}
}
#line 6516 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
unsigned int *find_cu_tu_set(void *file , unsigned int shndx ) 
{ 
  unsigned int i ;

  {
  {
#line 6521
  load_cu_tu_indexes(file);
#line 6524
  i = 0U;
  }
  {
#line 6524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6524
    if (! (i < shndx_pool_used)) {
#line 6524
      goto while_break;
    }
#line 6525
    if (*(shndx_pool + i) == shndx) {
#line 6526
      goto while_break;
    }
#line 6524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6528
  if (i >= shndx_pool_used) {
#line 6529
    return ((unsigned int *)((void *)0));
  }
  {
#line 6532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6532
    if (i > 0U) {
#line 6532
      if (! (*(shndx_pool + (i - 1U)) != 0U)) {
#line 6532
        goto while_break___0;
      }
    } else {
#line 6532
      goto while_break___0;
    }
#line 6533
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6535
  return (shndx_pool + i);
}
}
#line 6540 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_cu_index(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 6543
  tmp___0 = process_cu_tu_index(section, 1);
  }
#line 6543
  return (tmp___0);
}
}
#line 6546 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static int display_debug_not_supported(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  char *tmp___0 ;

  {
  {
#line 6550
  tmp___0 = gettext("Displaying the debug contents of section %s is not yet supported.\n");
#line 6550
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
#line 6553
  return (1);
}
}
#line 6556 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void *cmalloc(size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 6560
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 6561
    return ((void *)0);
  } else {
    {
#line 6563
    tmp___0 = malloc(nmemb * size);
    }
#line 6563
    return (tmp___0);
  }
}
}
#line 6566 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void *xcmalloc(size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 6570
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 6571
    return ((void *)0);
  } else {
    {
#line 6573
    tmp___0 = xmalloc(nmemb * size);
    }
#line 6573
    return (tmp___0);
  }
}
}
#line 6576 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void *xcrealloc(void *ptr , size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 6580
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 6581
    return ((void *)0);
  } else {
    {
#line 6583
    tmp___0 = xrealloc(ptr, nmemb * size);
    }
#line 6583
    return (tmp___0);
  }
}
}
#line 6586 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void free_debug_memory(void) 
{ 
  unsigned int i ;

  {
  {
#line 6591
  free_abbrevs();
#line 6593
  i = 0U;
  }
  {
#line 6593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6593
    if (! (i < 34U)) {
#line 6593
      goto while_break;
    }
    {
#line 6594
    free_debug_section((enum dwarf_section_display_enum )i);
#line 6593
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6596
  if ((unsigned long )debug_information != (unsigned long )((void *)0)) {
#line 6598
    if (num_debug_info_entries != 4294967295U) {
#line 6600
      i = 0U;
      {
#line 6600
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6600
        if (! (i < num_debug_info_entries)) {
#line 6600
          goto while_break___0;
        }
#line 6602
        if (! (debug_information + i)->max_loc_offsets) {
          {
#line 6604
          free((void *)(debug_information + i)->loc_offsets);
#line 6605
          free((void *)(debug_information + i)->have_frame_base);
          }
        }
#line 6607
        if (! (debug_information + i)->max_range_lists) {
          {
#line 6608
          free((void *)(debug_information + i)->range_lists);
          }
        }
#line 6600
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 6612
    free((void *)debug_information);
#line 6613
    debug_information = (debug_info *)((void *)0);
#line 6614
    num_debug_info_entries = 0U;
    }
  }
#line 6616
  return;
}
}
#line 6629 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
static debug_dump_long_opts const   opts_table[22]  = 
#line 6629
  {      {"Ranges", & do_debug_ranges, 1}, 
        {"abbrev", & do_debug_abbrevs, 1}, 
        {"addr", & do_debug_addr, 1}, 
        {"aranges", & do_debug_aranges, 1}, 
        {"cu_index", & do_debug_cu_index, 1}, 
        {"decodedline", & do_debug_lines, 2}, 
        {"frames", & do_debug_frames, 1}, 
        {"frames-interp", & do_debug_frames_interp, 1}, 
        {"gdb_index", & do_gdb_index, 1}, 
        {"info", & do_debug_info, 1}, 
        {"line", & do_debug_lines, 1}, 
        {"loc", & do_debug_loc, 1}, 
        {"macro", & do_debug_macinfo, 1}, 
        {"pubnames", & do_debug_pubnames, 1}, 
        {"pubtypes", & do_debug_pubtypes, 1}, 
        {"ranges", & do_debug_aranges, 1}, 
        {"rawline", & do_debug_lines, 1}, 
        {"str", & do_debug_str, 1}, 
        {"trace_abbrev", & do_trace_abbrevs, 1}, 
        {"trace_aranges", & do_trace_aranges, 1}, 
        {"trace_info", & do_trace_info, 1}, 
        {(char const   *)((void *)0), (int *)((void *)0), 0}};
#line 6618 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void dwarf_select_sections_by_names(char const   *names ) 
{ 
  char const   *p ;
  debug_dump_long_opts const   *entry ;
  size_t len ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 6662
  p = names;
  {
#line 6663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6663
    if (! *p) {
#line 6663
      goto while_break;
    }
#line 6667
    entry = opts_table;
    {
#line 6667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6667
      if (! entry->option) {
#line 6667
        goto while_break___0;
      }
      {
#line 6669
      tmp___0 = strlen((char const   *)entry->option);
#line 6669
      len = tmp___0;
#line 6671
      tmp___1 = strncmp(p, (char const   *)entry->option, len);
      }
#line 6671
      if (tmp___1 == 0) {
#line 6671
        if ((int const   )*(p + len) == 44) {
#line 6671
          goto _L;
        } else
#line 6671
        if ((int const   )*(p + len) == 0) {
          _L: /* CIL Label */ 
#line 6674
          *(entry->variable) |= (int )entry->val;
#line 6678
          if (do_debug_frames_interp) {
#line 6679
            do_debug_frames = 1;
          }
#line 6681
          p += len;
#line 6682
          goto while_break___0;
        }
      }
#line 6667
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6686
    if ((unsigned long )entry->option == (unsigned long )((void *)0)) {
      {
#line 6688
      tmp___2 = gettext("Unrecognized debug option \'%s\'\n");
#line 6688
      warn((char const   *)tmp___2, p);
#line 6689
      tmp___3 = strchr(p, ',');
#line 6689
      p = (char const   *)tmp___3;
      }
#line 6690
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 6691
        goto while_break;
      }
    }
#line 6694
    if ((int const   )*p == 44) {
#line 6695
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6697
  return;
}
}
#line 6699 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void dwarf_select_sections_by_letters(char const   *letters ) 
{ 
  unsigned int lindex ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 6702
  lindex = 0U;
  {
#line 6704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6704
    if (! *(letters + lindex)) {
#line 6704
      goto while_break;
    }
#line 6705
    tmp___0 = lindex;
#line 6705
    lindex ++;
    {
#line 6707
    if ((int const   )*(letters + tmp___0) == 105) {
#line 6707
      goto case_105;
    }
#line 6711
    if ((int const   )*(letters + tmp___0) == 97) {
#line 6711
      goto case_97;
    }
#line 6715
    if ((int const   )*(letters + tmp___0) == 108) {
#line 6715
      goto case_108;
    }
#line 6719
    if ((int const   )*(letters + tmp___0) == 76) {
#line 6719
      goto case_76;
    }
#line 6723
    if ((int const   )*(letters + tmp___0) == 112) {
#line 6723
      goto case_112;
    }
#line 6727
    if ((int const   )*(letters + tmp___0) == 116) {
#line 6727
      goto case_116;
    }
#line 6731
    if ((int const   )*(letters + tmp___0) == 114) {
#line 6731
      goto case_114;
    }
#line 6735
    if ((int const   )*(letters + tmp___0) == 82) {
#line 6735
      goto case_82;
    }
#line 6739
    if ((int const   )*(letters + tmp___0) == 70) {
#line 6739
      goto case_70;
    }
#line 6741
    if ((int const   )*(letters + tmp___0) == 102) {
#line 6741
      goto case_102;
    }
#line 6745
    if ((int const   )*(letters + tmp___0) == 109) {
#line 6745
      goto case_109;
    }
#line 6749
    if ((int const   )*(letters + tmp___0) == 115) {
#line 6749
      goto case_115;
    }
#line 6753
    if ((int const   )*(letters + tmp___0) == 111) {
#line 6753
      goto case_111;
    }
#line 6757
    goto switch_default;
    case_105: /* CIL Label */ 
#line 6708
    do_debug_info = 1;
#line 6709
    goto switch_break;
    case_97: /* CIL Label */ 
#line 6712
    do_debug_abbrevs = 1;
#line 6713
    goto switch_break;
    case_108: /* CIL Label */ 
#line 6716
    do_debug_lines |= 1;
#line 6717
    goto switch_break;
    case_76: /* CIL Label */ 
#line 6720
    do_debug_lines |= 2;
#line 6721
    goto switch_break;
    case_112: /* CIL Label */ 
#line 6724
    do_debug_pubnames = 1;
#line 6725
    goto switch_break;
    case_116: /* CIL Label */ 
#line 6728
    do_debug_pubtypes = 1;
#line 6729
    goto switch_break;
    case_114: /* CIL Label */ 
#line 6732
    do_debug_aranges = 1;
#line 6733
    goto switch_break;
    case_82: /* CIL Label */ 
#line 6736
    do_debug_ranges = 1;
#line 6737
    goto switch_break;
    case_70: /* CIL Label */ 
#line 6740
    do_debug_frames_interp = 1;
    case_102: /* CIL Label */ 
#line 6742
    do_debug_frames = 1;
#line 6743
    goto switch_break;
    case_109: /* CIL Label */ 
#line 6746
    do_debug_macinfo = 1;
#line 6747
    goto switch_break;
    case_115: /* CIL Label */ 
#line 6750
    do_debug_str = 1;
#line 6751
    goto switch_break;
    case_111: /* CIL Label */ 
#line 6754
    do_debug_loc = 1;
#line 6755
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 6758
    tmp___1 = gettext("Unrecognized debug option \'%s\'\n");
#line 6758
    warn((char const   *)tmp___1, optarg);
    }
#line 6759
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6761
  return;
}
}
#line 6763 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
void dwarf_select_sections_all(void) 
{ 


  {
#line 6766
  do_debug_info = 1;
#line 6767
  do_debug_abbrevs = 1;
#line 6768
  do_debug_lines = 1;
#line 6769
  do_debug_pubnames = 1;
#line 6770
  do_debug_pubtypes = 1;
#line 6771
  do_debug_aranges = 1;
#line 6772
  do_debug_ranges = 1;
#line 6773
  do_debug_frames = 1;
#line 6774
  do_debug_macinfo = 1;
#line 6775
  do_debug_str = 1;
#line 6776
  do_debug_loc = 1;
#line 6777
  do_gdb_index = 1;
#line 6778
  do_trace_info = 1;
#line 6779
  do_trace_abbrevs = 1;
#line 6780
  do_trace_aranges = 1;
#line 6781
  do_debug_addr = 1;
#line 6782
  do_debug_cu_index = 1;
#line 6783
  return;
}
}
#line 6785 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/dwarf.c"
struct dwarf_section_display debug_displays[34]  = 
#line 6785
  {      {{".debug_abbrev", ".zdebug_abbrev", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_abbrev,
      & do_debug_abbrevs, 0U}, 
        {{".debug_aranges", ".zdebug_aranges", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_aranges,
      & do_debug_aranges, 1U}, 
        {{".debug_frame", ".zdebug_frame", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_frames,
      & do_debug_frames, 1U}, 
        {{".debug_info", ".zdebug_info", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_info,
      & do_debug_info, 1U}, 
        {{".debug_line", ".zdebug_line", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_lines,
      & do_debug_lines, 1U}, 
        {{".debug_pubnames", ".zdebug_pubnames", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_pubnames,
      & do_debug_pubnames, 0U}, 
        {{".eh_frame", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_frames,
      & do_debug_frames, 1U}, 
        {{".debug_macinfo", ".zdebug_macinfo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macinfo,
      & do_debug_macinfo, 0U}, 
        {{".debug_macro", ".zdebug_macro", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macro,
      & do_debug_macinfo, 1U}, 
        {{".debug_str", ".zdebug_str", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_str,
      & do_debug_str, 0U}, 
        {{".debug_loc", ".zdebug_loc", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_loc,
      & do_debug_loc, 1U}, 
        {{".debug_pubtypes", ".zdebug_pubtypes", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_pubnames,
      & do_debug_pubtypes, 0U}, 
        {{".debug_ranges", ".zdebug_ranges", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_ranges,
      & do_debug_ranges, 1U}, 
        {{".debug_static_func", ".zdebug_static_func", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".debug_static_vars", ".zdebug_static_vars", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".debug_types", ".zdebug_types", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_types,
      & do_debug_info, 1U}, 
        {{".debug_weaknames", ".zdebug_weaknames", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".gdb_index", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_gdb_index,
      & do_gdb_index, 0U}, 
        {{".trace_info", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )19},
      & display_trace_info, & do_trace_info, 1U}, 
        {{".trace_abbrev", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_abbrev,
      & do_trace_abbrevs, 0U}, 
        {{".trace_aranges", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_aranges,
      & do_trace_aranges, 0U}, 
        {{".debug_info.dwo", ".zdebug_info.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_info, & do_debug_info, 1U}, 
        {{".debug_abbrev.dwo", ".zdebug_abbrev.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_abbrev,
      & do_debug_abbrevs, 0U}, 
        {{".debug_types.dwo", ".zdebug_types.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_types, & do_debug_info, 1U}, 
        {{".debug_line.dwo", ".zdebug_line.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_lines,
      & do_debug_lines, 1U}, 
        {{".debug_loc.dwo", ".zdebug_loc.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_loc,
      & do_debug_loc, 1U}, 
        {{".debug_macro.dwo", ".zdebug_macro.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macro,
      & do_debug_macinfo, 1U}, 
        {{".debug_macinfo.dwo", ".zdebug_macinfo.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macinfo,
      & do_debug_macinfo, 0U}, 
        {{".debug_str.dwo", ".zdebug_str.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_str,
      & do_debug_str, 1U}, 
        {{".debug_str_offsets", ".zdebug_str_offsets", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_str_offsets,
      (int *)((void *)0), 0U}, 
        {{".debug_str_offsets.dwo", ".zdebug_str_offsets.dwo", (char const   *)((void *)0),
       (unsigned char *)((void *)0), (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0},
      & display_debug_str_offsets, (int *)((void *)0), 0U}, 
        {{".debug_addr", ".zdebug_addr", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_addr,
      & do_debug_addr, 1U}, 
        {{".debug_cu_index", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_cu_index,
      & do_debug_cu_index, 0U}, 
        {{".debug_tu_index", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_cu_index,
      & do_debug_cu_index, 0U}};
#line 32 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.h"
unsigned char const   *unw_decode(unsigned char const   *dp , int inside_body , void *ptr_inside_body ) ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static bfd_vma unw_rlen  =    (bfd_vma )0;
#line 40
static void unw_print_brmask(char *cp , unsigned int mask ) ;
#line 41
static void unw_print_grmask(char *cp , unsigned int mask ) ;
#line 42
static void unw_print_frmask(char *cp , unsigned int mask ) ;
#line 43
static void unw_print_abreg(char *cp , unsigned int abreg ) ;
#line 44
static void unw_print_xyreg(char *cp , unsigned int x , unsigned int ytreg ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static void unw_print_brmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 49
  sep = 0;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (mask) {
#line 52
      if (! (i < 5)) {
#line 52
        goto while_break;
      }
    } else {
#line 52
      goto while_break;
    }
#line 54
    if (mask & 1U) {
#line 56
      if (sep) {
#line 57
        tmp___0 = cp;
#line 57
        cp ++;
#line 57
        *tmp___0 = (char )',';
      }
#line 58
      tmp___1 = cp;
#line 58
      cp ++;
#line 58
      *tmp___1 = (char )'b';
#line 59
      tmp___2 = cp;
#line 59
      cp ++;
#line 59
      *tmp___2 = (char )((i + 1) + 48);
#line 60
      sep = 1;
    }
#line 62
    mask >>= 1;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  *cp = (char )'\000';
#line 65
  return;
}
}
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static void unw_print_grmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 70
  sep = 0;
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 4)) {
#line 73
      goto while_break;
    }
#line 75
    if (mask & 1U) {
#line 77
      if (sep) {
#line 78
        tmp___0 = cp;
#line 78
        cp ++;
#line 78
        *tmp___0 = (char )',';
      }
#line 79
      tmp___1 = cp;
#line 79
      cp ++;
#line 79
      *tmp___1 = (char )'r';
#line 80
      tmp___2 = cp;
#line 80
      cp ++;
#line 80
      *tmp___2 = (char )((i + 4) + 48);
#line 81
      sep = 1;
    }
#line 83
    mask >>= 1;
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *cp = (char )'\000';
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static void unw_print_frmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 91
  sep = 0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < 20)) {
#line 94
      goto while_break;
    }
#line 96
    if (mask & 1U) {
#line 98
      if (sep) {
#line 99
        tmp___0 = cp;
#line 99
        cp ++;
#line 99
        *tmp___0 = (char )',';
      }
#line 100
      tmp___1 = cp;
#line 100
      cp ++;
#line 100
      *tmp___1 = (char )'f';
#line 101
      if (i < 4) {
#line 102
        tmp___2 = cp;
#line 102
        cp ++;
#line 102
        *tmp___2 = (char )((i + 2) + 48);
      } else {
#line 105
        tmp___3 = cp;
#line 105
        cp ++;
#line 105
        *tmp___3 = (char )(((i + 2) / 10 + 1) + 48);
#line 106
        tmp___4 = cp;
#line 106
        cp ++;
#line 106
        *tmp___4 = (char )((i + 2) % 10 + 48);
      }
#line 108
      sep = 1;
    }
#line 110
    mask >>= 1;
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  *cp = (char )'\000';
#line 113
  return;
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static char const   * const  special_reg[16]  = 
#line 118
  {      (char const   */* const  */)"pr",      (char const   */* const  */)"psp",      (char const   */* const  */)"@priunat",      (char const   */* const  */)"rp", 
        (char const   */* const  */)"ar.bsp",      (char const   */* const  */)"ar.bspstore",      (char const   */* const  */)"ar.rnat",      (char const   */* const  */)"ar.unat", 
        (char const   */* const  */)"ar.fpsr",      (char const   */* const  */)"ar.pfs",      (char const   */* const  */)"ar.lc",      (char const   */* const  */)"Unknown11", 
        (char const   */* const  */)"Unknown12",      (char const   */* const  */)"Unknown13",      (char const   */* const  */)"Unknown14",      (char const   */* const  */)"Unknown15"};
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static void unw_print_abreg(char *cp , unsigned int abreg ) 
{ 


  {
  {
#line 127
  if (((abreg >> 5) & 3U) == 0U) {
#line 127
    goto case_0;
  }
#line 131
  if (((abreg >> 5) & 3U) == 1U) {
#line 131
    goto case_1;
  }
#line 135
  if (((abreg >> 5) & 3U) == 2U) {
#line 135
    goto case_2;
  }
#line 139
  if (((abreg >> 5) & 3U) == 3U) {
#line 139
    goto case_3;
  }
#line 125
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 128
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"r%u", abreg & 31U);
  }
#line 129
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 132
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"f%u", abreg & 31U);
  }
#line 133
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 136
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"b%u", abreg & 31U);
  }
#line 137
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 140
  strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)special_reg[abreg & 15U]);
  }
#line 141
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static void unw_print_xyreg(char *cp , unsigned int x , unsigned int ytreg ) 
{ 


  {
  {
#line 150
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 0U) {
#line 150
    goto case_0;
  }
#line 154
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 1U) {
#line 154
    goto case_1;
  }
#line 158
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 2U) {
#line 158
    goto case_2;
  }
#line 148
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 151
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"r%u", ytreg & 31U);
  }
#line 152
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 155
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"f%u", ytreg & 31U);
  }
#line 156
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 159
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"b%u", ytreg & 31U);
  }
#line 160
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 537
static unw_word unw_decode_uleb128(unsigned char const   **dpp ) ;
#line 538
static unsigned char const   *unw_decode_x1(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 540
static unsigned char const   *unw_decode_x2(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 542
static unsigned char const   *unw_decode_x3(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 544
static unsigned char const   *unw_decode_x4(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 546
static unsigned char const   *unw_decode_r1(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 548
static unsigned char const   *unw_decode_r2(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 550
static unsigned char const   *unw_decode_r3(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 552
static unsigned char const   *unw_decode_p1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 554
static unsigned char const   *unw_decode_p2_p5(unsigned char const   *dp , unsigned int code ,
                                               void *arg  __attribute__((__unused__)) ) ;
#line 556
static unsigned char const   *unw_decode_p6(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 558
static unsigned char const   *unw_decode_p7_p10(unsigned char const   *dp , unsigned int code ,
                                                void *arg ) ;
#line 560
static unsigned char const   *unw_decode_b1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 562
static unsigned char const   *unw_decode_b2(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 564
static unsigned char const   *unw_decode_b3_x4(unsigned char const   *dp , unsigned int code ,
                                               void *arg ) ;
#line 567 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unw_word unw_decode_uleb128(unsigned char const   **dpp ) 
{ 
  unsigned int shift ;
  unw_word byte ;
  unw_word result ;
  unsigned char const   *bp ;
  unsigned char const   *tmp___0 ;

  {
#line 570
  shift = 0U;
#line 571
  result = (unw_word )0;
#line 572
  bp = *dpp;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    tmp___0 = bp;
#line 576
    bp ++;
#line 576
    byte = (unw_word )*tmp___0;
#line 577
    result |= (byte & 127UL) << shift;
#line 579
    if ((byte & 128UL) == 0UL) {
#line 580
      goto while_break;
    }
#line 582
    shift += 7U;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  *dpp = bp;
#line 587
  return (result);
}
}
#line 590 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x1(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char abreg ;
  unw_word t ;
  unw_word off ;
  unsigned char const   *tmp___0 ;
  char regname___0[20] ;
  char regname___1[20] ;

  {
  {
#line 597
  tmp___0 = dp;
#line 597
  dp ++;
#line 597
  byte1 = (unsigned char )*tmp___0;
#line 598
  t = unw_decode_uleb128(& dp);
#line 599
  off = unw_decode_uleb128(& dp);
#line 600
  abreg = (unsigned char )((int )byte1 & 127);
  }
#line 601
  if ((int )byte1 & 128) {
    {
#line 602
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 602
      unw_print_abreg(regname___0, (unsigned int )abreg);
#line 602
      printf((char const   */* __restrict  */)"\t%s:spill_sprel(reg=%s,t=%lu,spoff=0x%lx)\n",
             "X1", regname___0, t, 4UL * off);
      }
#line 602
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 604
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 604
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 604
      printf((char const   */* __restrict  */)"\t%s:spill_psprel(reg=%s,t=%lu,pspoff=0x10-0x%lx)\n",
             "X1", regname___1, t, 4UL * off);
      }
#line 604
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 605
  return (dp);
}
}
#line 608 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x2(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char abreg ;
  unsigned char x ;
  unsigned char ytreg ;
  unw_word t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char regname___0[20] ;
  char abregname[20] ;
  char tregname[20] ;

  {
  {
#line 615
  tmp___0 = dp;
#line 615
  dp ++;
#line 615
  byte1 = (unsigned char )*tmp___0;
#line 616
  tmp___1 = dp;
#line 616
  dp ++;
#line 616
  byte2 = (unsigned char )*tmp___1;
#line 617
  t = unw_decode_uleb128(& dp);
#line 618
  abreg = (unsigned char )((int )byte1 & 127);
#line 619
  ytreg = byte2;
#line 620
  x = (unsigned char )(((int )byte1 >> 7) & 1);
  }
#line 621
  if (((int )byte1 & 128) == 0) {
#line 621
    if ((int )ytreg == 0) {
      {
#line 622
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 622
        unw_print_abreg(regname___0, (unsigned int )abreg);
#line 622
        printf((char const   */* __restrict  */)"\t%s:restore(t=%lu,reg=%s)\n", "X2",
               t, regname___0);
        }
#line 622
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 621
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 624
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 624
      unw_print_abreg(abregname, (unsigned int )abreg);
#line 624
      unw_print_xyreg(tregname, (unsigned int )x, (unsigned int )ytreg);
#line 624
      printf((char const   */* __restrict  */)"\t%s:spill_reg(t=%lu,reg=%s,treg=%s)\n",
             "X2", t, abregname, tregname);
      }
#line 624
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 625
  return (dp);
}
}
#line 628 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x3(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char abreg ;
  unsigned char qp ;
  unw_word t ;
  unw_word off ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char regname___0[20] ;
  char regname___1[20] ;

  {
  {
#line 635
  tmp___0 = dp;
#line 635
  dp ++;
#line 635
  byte1 = (unsigned char )*tmp___0;
#line 636
  tmp___1 = dp;
#line 636
  dp ++;
#line 636
  byte2 = (unsigned char )*tmp___1;
#line 637
  t = unw_decode_uleb128(& dp);
#line 638
  off = unw_decode_uleb128(& dp);
#line 640
  qp = (unsigned char )((int )byte1 & 63);
#line 641
  abreg = (unsigned char )((int )byte2 & 127);
  }
#line 643
  if ((int )byte1 & 128) {
    {
#line 644
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 644
      unw_print_abreg(regname___0, (unsigned int )abreg);
#line 644
      printf((char const   */* __restrict  */)"\t%s:spill_sprel_p(qp=p%u,t=%lu,reg=%s,spoff=0x%lx)\n",
             "X3", (int )qp, t, regname___0, 4UL * off);
      }
#line 644
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 646
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 646
      printf((char const   */* __restrict  */)"\t%s:spill_psprel_p(qp=p%u,t=%lu,reg=%s,pspoff=0x10-0x%lx)\n",
             "X3", (int )qp, t, regname___1, 4UL * off);
      }
#line 646
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 647
  return (dp);
}
}
#line 650 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x4(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char byte3 ;
  unsigned char qp ;
  unsigned char abreg ;
  unsigned char x ;
  unsigned char ytreg ;
  unw_word t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  char regname___0[20] ;
  char regname___1[20] ;
  char tregname[20] ;

  {
  {
#line 657
  tmp___0 = dp;
#line 657
  dp ++;
#line 657
  byte1 = (unsigned char )*tmp___0;
#line 658
  tmp___1 = dp;
#line 658
  dp ++;
#line 658
  byte2 = (unsigned char )*tmp___1;
#line 659
  tmp___2 = dp;
#line 659
  dp ++;
#line 659
  byte3 = (unsigned char )*tmp___2;
#line 660
  t = unw_decode_uleb128(& dp);
#line 662
  qp = (unsigned char )((int )byte1 & 63);
#line 663
  abreg = (unsigned char )((int )byte2 & 127);
#line 664
  x = (unsigned char )(((int )byte2 >> 7) & 1);
#line 665
  ytreg = byte3;
  }
#line 667
  if (((int )byte2 & 128) == 0) {
#line 667
    if ((int )byte3 == 0) {
      {
#line 668
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 668
        unw_print_abreg(regname___0, (unsigned int )abreg);
#line 668
        printf((char const   */* __restrict  */)"\t%s:restore_p(qp=p%u,t=%lu,reg=%s)\n",
               "X4", (int )qp, t, regname___0);
        }
#line 668
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 667
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 670
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 670
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 670
      unw_print_xyreg(tregname, (unsigned int )x, (unsigned int )ytreg);
#line 670
      printf((char const   */* __restrict  */)"\t%s:spill_reg_p(qp=p%u,t=%lu,reg=%s,treg=%s)\n",
             "X4", (int )qp, t, regname___1, tregname);
      }
#line 670
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 671
  return (dp);
}
}
#line 674 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r1(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  int body ;
  unw_word rlen ;
  char const   *tmp___0 ;

  {
#line 677
  body = (code & 32U) != 0U;
#line 680
  rlen = (unw_word )(code & 31U);
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    unw_rlen = rlen;
#line 681
    *((int *)arg) = body;
#line 681
    if (body) {
#line 681
      tmp___0 = "body";
    } else {
#line 681
      tmp___0 = "prologue";
    }
    {
#line 681
    printf((char const   */* __restrict  */)"    %s:%s(rlen=%lu)\n", "R1", tmp___0,
           rlen);
    }
#line 681
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (dp);
}
}
#line 685 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r2(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  unsigned char byte1 ;
  unsigned char mask ;
  unsigned char grsave ;
  unw_word rlen ;
  unsigned char const   *tmp___0 ;
  char regname___0[16] ;
  char maskstr[64] ;
  char *sep ;

  {
  {
#line 691
  tmp___0 = dp;
#line 691
  dp ++;
#line 691
  byte1 = (unsigned char )*tmp___0;
#line 693
  mask = (unsigned char )(((code & 7U) << 1) | (unsigned int )(((int )byte1 >> 7) & 1));
#line 694
  grsave = (unsigned char )((int )byte1 & 127);
#line 695
  rlen = unw_decode_uleb128(& dp);
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    unw_rlen = rlen;
#line 696
    *((int *)arg) = 0;
#line 696
    maskstr[0] = (char )'\000';
#line 696
    sep = (char *)"";
#line 696
    if ((int )mask & 8) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"rp");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 4) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"ar.pfs");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 2) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"psp");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 1) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"pr");
      }
    }
    {
#line 696
    sprintf((char */* __restrict  */)(regname___0), (char const   */* __restrict  */)"r%u",
            (int )grsave);
#line 696
    printf((char const   */* __restrict  */)"    %s:prologue_gr(mask=[%s],grsave=%s,rlen=%lu)\n",
           "R2", maskstr, regname___0, rlen);
    }
#line 696
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return (dp);
}
}
#line 700 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r3(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  unw_word rlen ;
  char const   *tmp___0 ;

  {
  {
#line 705
  rlen = unw_decode_uleb128(& dp);
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    unw_rlen = rlen;
#line 706
    *((int *)arg) = (code & 3U) == 1U;
#line 706
    if ((code & 3U) == 1U) {
#line 706
      tmp___0 = "body";
    } else {
#line 706
      tmp___0 = "prologue";
    }
    {
#line 706
    printf((char const   */* __restrict  */)"    %s:%s(rlen=%lu)\n", "R3", tmp___0,
           rlen);
    }
#line 706
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  return (dp);
}
}
#line 710 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char brmask ;
  char brstr[20] ;

  {
#line 714
  brmask = (unsigned char )(code & 31U);
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 716
    unw_print_brmask(brstr, (unsigned int )brmask);
#line 716
    printf((char const   */* __restrict  */)"\t%s:br_mem(brmask=[%s])\n", "P1", brstr);
    }
#line 716
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return (dp);
}
}
#line 781 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static char const   *spill_type  =    "-frb";
#line 720 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p2_p5(unsigned char const   *dp , unsigned int code ,
                                               void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char const   *tmp___0 ;
  char brstr[20] ;
  unsigned char byte1___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char r ;
  unsigned char dst ;
  unsigned char const   *imaskp ;
  unsigned char mask ;
  bfd_vma insn ;
  unsigned char const   *tmp___2 ;
  unw_word grmask ;
  unw_word frmask ;
  unw_word byte1___1 ;
  unw_word byte2 ;
  unw_word byte3 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  char frstr[200] ;
  char grstr[20] ;

  {
#line 724
  if ((code & 16U) == 0U) {
#line 726
    tmp___0 = dp;
#line 726
    dp ++;
#line 726
    byte1 = (unsigned char )*tmp___0;
    {
#line 728
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 728
      unw_print_brmask(brstr, ((code & 15U) << 1) | (unsigned int )(((int )byte1 >> 7) & 1));
#line 728
      printf((char const   */* __restrict  */)"\t%s:br_gr(brmask=[%s],gr=r%u)\n",
             "P2", brstr, (int )byte1 & 127);
      }
#line 728
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 731
  if ((code & 8U) == 0U) {
#line 733
    tmp___1 = dp;
#line 733
    dp ++;
#line 733
    byte1___0 = (unsigned char )*tmp___1;
#line 735
    r = (unsigned char )(((code & 7U) << 1) | (unsigned int )(((int )byte1___0 >> 7) & 1));
#line 736
    dst = (unsigned char )((int )byte1___0 & 127);
    {
#line 739
    if ((int )r == 0) {
#line 739
      goto case_0;
    }
#line 742
    if ((int )r == 1) {
#line 742
      goto case_1;
    }
#line 745
    if ((int )r == 2) {
#line 745
      goto case_2;
    }
#line 748
    if ((int )r == 3) {
#line 748
      goto case_3;
    }
#line 751
    if ((int )r == 4) {
#line 751
      goto case_4;
    }
#line 754
    if ((int )r == 5) {
#line 754
      goto case_5;
    }
#line 757
    if ((int )r == 6) {
#line 757
      goto case_6;
    }
#line 760
    if ((int )r == 7) {
#line 760
      goto case_7;
    }
#line 763
    if ((int )r == 8) {
#line 763
      goto case_8;
    }
#line 766
    if ((int )r == 9) {
#line 766
      goto case_9;
    }
#line 769
    if ((int )r == 10) {
#line 769
      goto case_10;
    }
#line 772
    if ((int )r == 11) {
#line 772
      goto case_11;
    }
#line 775
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 740
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "psp",
           (int )dst);
    }
#line 741
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 743
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "rp", (int )dst);
    }
#line 744
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 746
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "pfs",
           (int )dst);
    }
#line 747
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 749
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "pr", (int )dst);
    }
#line 750
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 752
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "unat",
           (int )dst);
    }
#line 753
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 755
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "lc", (int )dst);
    }
#line 756
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 758
    printf((char const   */* __restrict  */)"\t%s:rp_br(reg=b%u)\n", "P3", (int )dst);
    }
#line 759
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 761
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "rnat",
           (int )dst);
    }
#line 762
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 764
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "bsp",
           (int )dst);
    }
#line 765
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 767
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "bspstore",
           (int )dst);
    }
#line 768
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 770
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "fpsr",
           (int )dst);
    }
#line 771
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 773
    printf((char const   */* __restrict  */)"\t%s:priunat_gr(reg=r%u)\n", "P3", (int )dst);
    }
#line 774
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 776
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 777
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 780
  if ((code & 7U) == 0U) {
    {
#line 781
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 781
      imaskp = dp;
#line 781
      mask = (unsigned char)0;
#line 781
      insn = (bfd_vma )0;
#line 781
      printf((char const   */* __restrict  */)"\t%s:spill_mask(imask=[", "P4");
#line 781
      insn = (bfd_vma )0;
      }
      {
#line 781
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 781
        if (! (insn < unw_rlen)) {
#line 781
          goto while_break___1;
        }
#line 781
        if (insn % 4UL == 0UL) {
#line 781
          tmp___2 = imaskp;
#line 781
          imaskp ++;
#line 781
          mask = (unsigned char )*tmp___2;
        }
#line 781
        if (insn > 0UL) {
#line 781
          if (insn % 3UL == 0UL) {
            {
#line 781
            putchar(',');
            }
          }
        }
        {
#line 781
        putchar((int )*(spill_type + (((int )mask >> 2UL * (3UL - (insn & 3UL))) & 3)));
#line 781
        insn ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 781
      printf((char const   */* __restrict  */)"])\n");
#line 781
      dp = imaskp;
      }
#line 781
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 782
  if ((code & 7U) == 1U) {
#line 786
    tmp___3 = dp;
#line 786
    dp ++;
#line 786
    byte1___1 = (unw_word )*tmp___3;
#line 787
    tmp___4 = dp;
#line 787
    dp ++;
#line 787
    byte2 = (unw_word )*tmp___4;
#line 788
    tmp___5 = dp;
#line 788
    dp ++;
#line 788
    byte3 = (unw_word )*tmp___5;
#line 789
    grmask = (byte1___1 >> 4) & 15UL;
#line 790
    frmask = (((byte1___1 & 15UL) << 16) | (byte2 << 8)) | byte3;
    {
#line 791
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 791
      unw_print_grmask(grstr, (unsigned int )grmask);
#line 791
      unw_print_frmask(frstr, (unsigned int )frmask);
#line 791
      printf((char const   */* __restrict  */)"\t%s:frgr_mem(grmask=[%s],frmask=[%s])\n",
             "P5", grstr, frstr);
      }
#line 791
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 794
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
  }
#line 796
  return (dp);
}
}
#line 799 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p6(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  int gregs ;
  unsigned char mask ;
  char grstr[200] ;
  char frstr[200] ;

  {
#line 803
  gregs = (code & 16U) != 0U;
#line 804
  mask = (unsigned char )(code & 15U);
#line 806
  if (gregs) {
    {
#line 807
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 807
      unw_print_grmask(grstr, (unsigned int )mask);
#line 807
      printf((char const   */* __restrict  */)"\t%s:gr_mem(grmask=[%s])\n", "P6",
             grstr);
      }
#line 807
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 809
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 809
      unw_print_frmask(frstr, (unsigned int )mask);
#line 809
      printf((char const   */* __restrict  */)"\t%s:fr_mem(frmask=[%s])\n", "P6",
             frstr);
      }
#line 809
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 810
  return (dp);
}
}
#line 963 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static char const   * const  abiname[3]  = {      (char const   */* const  */)"@svr4",      (char const   */* const  */)"@hpux",      (char const   */* const  */)"@nt"};
#line 813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p7_p10(unsigned char const   *dp , unsigned int code ,
                                                void *arg ) 
{ 
  unsigned char r ;
  unsigned char byte1 ;
  unsigned char byte2 ;
  unw_word t ;
  unw_word size ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  char grstr[20] ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  char buf___7[20] ;
  char const   *abistr ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;

  {
#line 819
  if ((code & 16U) == 0U) {
    {
#line 821
    r = (unsigned char )(code & 15U);
#line 822
    t = unw_decode_uleb128(& dp);
    }
    {
#line 825
    if ((int )r == 0) {
#line 825
      goto case_0;
    }
#line 830
    if ((int )r == 1) {
#line 830
      goto case_1;
    }
#line 833
    if ((int )r == 2) {
#line 833
      goto case_2;
    }
#line 836
    if ((int )r == 3) {
#line 836
      goto case_3;
    }
#line 839
    if ((int )r == 4) {
#line 839
      goto case_4;
    }
#line 842
    if ((int )r == 5) {
#line 842
      goto case_5;
    }
#line 845
    if ((int )r == 6) {
#line 845
      goto case_6;
    }
#line 848
    if ((int )r == 7) {
#line 848
      goto case_7;
    }
#line 851
    if ((int )r == 8) {
#line 851
      goto case_8;
    }
#line 854
    if ((int )r == 9) {
#line 854
      goto case_9;
    }
#line 857
    if ((int )r == 10) {
#line 857
      goto case_10;
    }
#line 860
    if ((int )r == 11) {
#line 860
      goto case_11;
    }
#line 863
    if ((int )r == 12) {
#line 863
      goto case_12;
    }
#line 866
    if ((int )r == 13) {
#line 866
      goto case_13;
    }
#line 869
    if ((int )r == 14) {
#line 869
      goto case_14;
    }
#line 872
    if ((int )r == 15) {
#line 872
      goto case_15;
    }
#line 875
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 826
    size = unw_decode_uleb128(& dp);
#line 827
    printf((char const   */* __restrict  */)"\t%s:mem_stack_f(t=%lu,size=%lu)\n",
           "P7", t, 16UL * size);
    }
#line 828
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 831
    printf((char const   */* __restrict  */)"\t%s:mem_stack_v(t=%lu)\n", "P7", t);
    }
#line 832
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 834
    printf((char const   */* __restrict  */)"\t%s:spill_base(pspoff=0x10-0x%lx)\n",
           "P7", 4UL * t);
    }
#line 835
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 837
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P7",
           "psp", 4UL * t);
    }
#line 838
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 840
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "rp", t);
    }
#line 841
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 843
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "rp", 4UL * t);
    }
#line 844
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 846
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "pfs",
           t);
    }
#line 847
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 849
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "pfs", 4UL * t);
    }
#line 850
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 852
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "pr", t);
    }
#line 853
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 855
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "pr", 4UL * t);
    }
#line 856
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 858
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "lc", t);
    }
#line 859
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 861
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "lc", 4UL * t);
    }
#line 862
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 864
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "unat",
           t);
    }
#line 865
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 867
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "unat", 4UL * t);
    }
#line 868
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 870
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "fpsr",
           t);
    }
#line 871
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 873
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "fpsr", 4UL * t);
    }
#line 874
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 876
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 877
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 884
    if ((code & 15U) == 0U) {
#line 884
      goto case_0___0;
    }
#line 954
    if ((code & 15U) == 1U) {
#line 954
      goto case_1___1;
    }
#line 960
    if ((code & 15U) == 15U) {
#line 960
      goto case_15___1;
    }
#line 966
    if ((code & 15U) == 9U) {
#line 966
      goto case_9___1;
    }
#line 969
    if ((code & 15U) == 10U) {
#line 969
      goto case_10___1;
    }
#line 972
    if ((code & 15U) == 11U) {
#line 972
      goto case_11___1;
    }
#line 975
    if ((code & 15U) == 12U) {
#line 975
      goto case_12___1;
    }
#line 978
    goto switch_default___1;
    case_0___0: /* CIL Label */ 
    {
#line 886
    tmp___0 = dp;
#line 886
    dp ++;
#line 886
    r = (unsigned char )*tmp___0;
#line 887
    t = unw_decode_uleb128(& dp);
    }
    {
#line 890
    if ((int )r == 1) {
#line 890
      goto case_1___0;
    }
#line 893
    if ((int )r == 2) {
#line 893
      goto case_2___0;
    }
#line 896
    if ((int )r == 3) {
#line 896
      goto case_3___0;
    }
#line 899
    if ((int )r == 4) {
#line 899
      goto case_4___0;
    }
#line 902
    if ((int )r == 5) {
#line 902
      goto case_5___0;
    }
#line 905
    if ((int )r == 6) {
#line 905
      goto case_6___0;
    }
#line 908
    if ((int )r == 7) {
#line 908
      goto case_7___0;
    }
#line 911
    if ((int )r == 8) {
#line 911
      goto case_8___0;
    }
#line 914
    if ((int )r == 9) {
#line 914
      goto case_9___0;
    }
#line 917
    if ((int )r == 10) {
#line 917
      goto case_10___0;
    }
#line 920
    if ((int )r == 11) {
#line 920
      goto case_11___0;
    }
#line 923
    if ((int )r == 12) {
#line 923
      goto case_12___0;
    }
#line 926
    if ((int )r == 13) {
#line 926
      goto case_13___0;
    }
#line 929
    if ((int )r == 14) {
#line 929
      goto case_14___0;
    }
#line 932
    if ((int )r == 15) {
#line 932
      goto case_15___0;
    }
#line 935
    if ((int )r == 16) {
#line 935
      goto case_16;
    }
#line 938
    if ((int )r == 17) {
#line 938
      goto case_17;
    }
#line 941
    if ((int )r == 18) {
#line 941
      goto case_18;
    }
#line 944
    if ((int )r == 19) {
#line 944
      goto case_19;
    }
#line 947
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 891
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "rp", 4UL * t);
    }
#line 892
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 894
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "pfs", 4UL * t);
    }
#line 895
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
#line 897
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "pr", 4UL * t);
    }
#line 898
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 900
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "lc", 4UL * t);
    }
#line 901
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
    {
#line 903
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "unat", 4UL * t);
    }
#line 904
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
    {
#line 906
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "fpsr", 4UL * t);
    }
#line 907
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
    {
#line 909
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "bsp",
           t);
    }
#line 910
    goto switch_break___1;
    case_8___0: /* CIL Label */ 
    {
#line 912
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "bsp", 4UL * t);
    }
#line 913
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
    {
#line 915
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "bsp", 4UL * t);
    }
#line 916
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
    {
#line 918
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "bspstore",
           t);
    }
#line 919
    goto switch_break___1;
    case_11___0: /* CIL Label */ 
    {
#line 921
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "bspstore", 4UL * t);
    }
#line 922
    goto switch_break___1;
    case_12___0: /* CIL Label */ 
    {
#line 924
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "bspstore", 4UL * t);
    }
#line 925
    goto switch_break___1;
    case_13___0: /* CIL Label */ 
    {
#line 927
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "rnat",
           t);
    }
#line 928
    goto switch_break___1;
    case_14___0: /* CIL Label */ 
    {
#line 930
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "rnat", 4UL * t);
    }
#line 931
    goto switch_break___1;
    case_15___0: /* CIL Label */ 
    {
#line 933
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "rnat", 4UL * t);
    }
#line 934
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 936
    printf((char const   */* __restrict  */)"\t%s:priunat_when_gr(t=%lu)\n", "P8",
           t);
    }
#line 937
    goto switch_break___1;
    case_17: /* CIL Label */ 
    {
#line 939
    printf((char const   */* __restrict  */)"\t%s:priunat_psprel(pspoff=0x10-0x%lx)\n",
           "P8", 4UL * t);
    }
#line 940
    goto switch_break___1;
    case_18: /* CIL Label */ 
    {
#line 942
    printf((char const   */* __restrict  */)"\t%s:priunat_sprel(spoff=0x%lx)\n", "P8",
           4UL * t);
    }
#line 943
    goto switch_break___1;
    case_19: /* CIL Label */ 
    {
#line 945
    printf((char const   */* __restrict  */)"\t%s:priunat_when_mem(t=%lu)\n", "P8",
           t);
    }
#line 946
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 948
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 949
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 952
    goto switch_break___0;
    case_1___1: /* CIL Label */ 
#line 955
    tmp___1 = dp;
#line 955
    dp ++;
#line 955
    byte1 = (unsigned char )*tmp___1;
#line 956
    tmp___2 = dp;
#line 956
    dp ++;
#line 956
    byte2 = (unsigned char )*tmp___2;
    {
#line 957
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 957
      unw_print_grmask(grstr, (unsigned int )((int )byte1 & 15));
#line 957
      printf((char const   */* __restrict  */)"\t%s:gr_gr(grmask=[%s],r%u)\n", "P9",
             grstr, (int )byte2 & 127);
      }
#line 957
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 958
    goto switch_break___0;
    case_15___1: /* CIL Label */ 
#line 961
    tmp___3 = dp;
#line 961
    dp ++;
#line 961
    byte1 = (unsigned char )*tmp___3;
#line 962
    tmp___4 = dp;
#line 962
    dp ++;
#line 962
    byte2 = (unsigned char )*tmp___4;
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 963
      abistr = (char const   *)(buf___7);
#line 963
      if ((int )byte1 < 3) {
#line 963
        abistr = (char const   *)abiname[byte1];
      } else {
        {
#line 963
        sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"0x%x",
                (int )byte1);
        }
      }
      {
#line 963
      printf((char const   */* __restrict  */)"\t%s:unwabi(abi=%s,context=0x%02x)\n",
             "P10", abistr, (int )byte2);
      }
#line 963
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 964
    goto switch_break___0;
    case_9___1: /* CIL Label */ 
    {
#line 967
    tmp___5 = unw_decode_x1(dp, code, arg);
    }
#line 967
    return (tmp___5);
    case_10___1: /* CIL Label */ 
    {
#line 970
    tmp___6 = unw_decode_x2(dp, code, arg);
    }
#line 970
    return (tmp___6);
    case_11___1: /* CIL Label */ 
    {
#line 973
    tmp___7 = unw_decode_x3(dp, code, arg);
    }
#line 973
    return (tmp___7);
    case_12___1: /* CIL Label */ 
    {
#line 976
    tmp___8 = unw_decode_x4(dp, code, arg);
    }
#line 976
    return (tmp___8);
    switch_default___1: /* CIL Label */ 
    {
#line 979
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
#line 980
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 983
  return (dp);
}
}
#line 986 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unw_word label ;

  {
#line 990
  label = (unw_word )(code & 31U);
#line 992
  if ((code & 32U) != 0U) {
    {
#line 993
    printf((char const   */* __restrict  */)"\t%s:copy_state(label=%lu)\n", "B1",
           label);
    }
  } else {
    {
#line 995
    printf((char const   */* __restrict  */)"\t%s:label_state(label=%lu)\n", "B1",
           label);
    }
  }
#line 996
  return (dp);
}
}
#line 999 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b2(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unw_word t ;

  {
  {
#line 1005
  t = unw_decode_uleb128(& dp);
#line 1006
  printf((char const   */* __restrict  */)"\t%s:epilogue(t=%lu,ecount=%lu)\n", "B2",
         t, (unsigned long )(code & 31U));
  }
#line 1007
  return (dp);
}
}
#line 1010 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b3_x4(unsigned char const   *dp , unsigned int code ,
                                               void *arg ) 
{ 
  unw_word t ;
  unw_word ecount ;
  unw_word label ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;

  {
#line 1015
  if ((code & 16U) == 0U) {
    {
#line 1017
    t = unw_decode_uleb128(& dp);
#line 1018
    ecount = unw_decode_uleb128(& dp);
#line 1019
    printf((char const   */* __restrict  */)"\t%s:epilogue(t=%lu,ecount=%lu)\n", "B3",
           t, ecount);
    }
  } else
#line 1021
  if ((code & 7U) == 0U) {
    {
#line 1023
    label = unw_decode_uleb128(& dp);
    }
#line 1024
    if ((code & 8U) != 0U) {
      {
#line 1025
      printf((char const   */* __restrict  */)"\t%s:copy_state(label=%lu)\n", "B4",
             label);
      }
    } else {
      {
#line 1027
      printf((char const   */* __restrict  */)"\t%s:label_state(label=%lu)\n", "B4",
             label);
      }
    }
  } else {
    {
#line 1032
    if ((code & 7U) == 1U) {
#line 1032
      goto case_1;
    }
#line 1034
    if ((code & 7U) == 2U) {
#line 1034
      goto case_2;
    }
#line 1036
    if ((code & 7U) == 3U) {
#line 1036
      goto case_3;
    }
#line 1038
    if ((code & 7U) == 4U) {
#line 1038
      goto case_4;
    }
#line 1040
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1033
    tmp___0 = unw_decode_x1(dp, code, arg);
    }
#line 1033
    return (tmp___0);
    case_2: /* CIL Label */ 
    {
#line 1035
    tmp___1 = unw_decode_x2(dp, code, arg);
    }
#line 1035
    return (tmp___1);
    case_3: /* CIL Label */ 
    {
#line 1037
    tmp___2 = unw_decode_x3(dp, code, arg);
    }
#line 1037
    return (tmp___2);
    case_4: /* CIL Label */ 
    {
#line 1039
    tmp___3 = unw_decode_x4(dp, code, arg);
    }
#line 1039
    return (tmp___3);
    switch_default: /* CIL Label */ 
    {
#line 1041
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
#line 1042
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1044
  return (dp);
}
}
#line 1050 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
static unw_decoder const   unw_decode_table[2][8]  = { {        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r2),        (unw_decoder const   )(& unw_decode_r3), 
            (unw_decoder const   )(& unw_decode_p1),        (unw_decoder const   )(& unw_decode_p2_p5),        (unw_decoder const   )(& unw_decode_p6),        (unw_decoder const   )(& unw_decode_p7_p10)}, 
   {        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r2),        (unw_decoder const   )(& unw_decode_r3), 
            (unw_decoder const   )(& unw_decode_b1),        (unw_decoder const   )(& unw_decode_b1),        (unw_decoder const   )(& unw_decode_b2),        (unw_decoder const   )(& unw_decode_b3_x4)}};
#line 1076 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/unwind-ia64.c"
unsigned char const   *unw_decode(unsigned char const   *dp , int inside_body , void *ptr_inside_body ) 
{ 
  unsigned char const   *(*decoder)(unsigned char const   * , unsigned int  , void * ) ;
  unsigned char code ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
  {
#line 1083
  tmp___0 = dp;
#line 1083
  dp ++;
#line 1083
  code = (unsigned char )*tmp___0;
#line 1084
  decoder = (unsigned char const   *(*)(unsigned char const   * , unsigned int  ,
                                        void * ))unw_decode_table[inside_body][(int )code >> 5];
#line 1085
  tmp___1 = (*decoder)(dp, (unsigned int )code, ptr_inside_body);
  }
#line 1085
  return (tmp___1);
}
}
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/bucomm.h"
void print_version(char const   *name___0 ) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/version.c"
void print_version(char const   *name___0 ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 35
  printf((char const   */* __restrict  */)"GNU %s %s\n", name___0, "(GNU Binutils) 2.24");
#line 36
  tmp___0 = gettext("Copyright 2013 Free Software Foundation, Inc.\n");
#line 36
  printf((char const   */* __restrict  */)tmp___0);
#line 37
  tmp___1 = gettext("This program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n");
#line 37
  printf((char const   */* __restrict  */)tmp___1);
#line 41
  exit(0);
  }
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 377 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 451 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 119 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 400 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 957
extern int inflateReset(z_streamp strm ) ;
#line 1766
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 41 "./../include/elf/aarch64.h"
static char const   *elf_aarch64_reloc_type(unsigned long rtype ) ;
#line 41 "./../include/elf/aarch64.h"
static char const   *elf_aarch64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 44
  if (rtype == 0UL) {
#line 44
    goto case_0;
  }
#line 49
  if (rtype == 1UL) {
#line 49
    goto case_1;
  }
#line 52
  if (rtype == 2UL) {
#line 52
    goto case_2;
  }
#line 55
  if (rtype == 3UL) {
#line 55
    goto case_3;
  }
#line 58
  if (rtype == 4UL) {
#line 58
    goto case_4;
  }
#line 64
  if (rtype == 5UL) {
#line 64
    goto case_5;
  }
#line 67
  if (rtype == 6UL) {
#line 67
    goto case_6;
  }
#line 70
  if (rtype == 7UL) {
#line 70
    goto case_7;
  }
#line 77
  if (rtype == 8UL) {
#line 77
    goto case_8;
  }
#line 83
  if (rtype == 9UL) {
#line 83
    goto case_9;
  }
#line 86
  if (rtype == 10UL) {
#line 86
    goto case_10;
  }
#line 89
  if (rtype == 11UL) {
#line 89
    goto case_11;
  }
#line 92
  if (rtype == 12UL) {
#line 92
    goto case_12;
  }
#line 95
  if (rtype == 13UL) {
#line 95
    goto case_13;
  }
#line 98
  if (rtype == 14UL) {
#line 98
    goto case_14;
  }
#line 101
  if (rtype == 15UL) {
#line 101
    goto case_15;
  }
#line 104
  if (rtype == 16UL) {
#line 104
    goto case_16;
  }
#line 107
  if (rtype == 17UL) {
#line 107
    goto case_17;
  }
#line 112
  if (rtype == 18UL) {
#line 112
    goto case_18;
  }
#line 115
  if (rtype == 19UL) {
#line 115
    goto case_19;
  }
#line 118
  if (rtype == 20UL) {
#line 118
    goto case_20;
  }
#line 121
  if (rtype == 21UL) {
#line 121
    goto case_21;
  }
#line 124
  if (rtype == 25UL) {
#line 124
    goto case_25;
  }
#line 125
  if (rtype == 26UL) {
#line 125
    goto case_26;
  }
#line 126
  if (rtype == 27UL) {
#line 126
    goto case_27;
  }
#line 129
  if (rtype == 81UL) {
#line 129
    goto case_81;
  }
#line 130
  if (rtype == 82UL) {
#line 130
    goto case_82;
  }
#line 131
  if (rtype == 103UL) {
#line 131
    goto case_103;
  }
#line 132
  if (rtype == 104UL) {
#line 132
    goto case_104;
  }
#line 133
  if (rtype == 105UL) {
#line 133
    goto case_105;
  }
#line 134
  if (rtype == 106UL) {
#line 134
    goto case_106;
  }
#line 135
  if (rtype == 107UL) {
#line 135
    goto case_107;
  }
#line 136
  if (rtype == 108UL) {
#line 136
    goto case_108;
  }
#line 137
  if (rtype == 109UL) {
#line 137
    goto case_109;
  }
#line 138
  if (rtype == 110UL) {
#line 138
    goto case_110;
  }
#line 139
  if (rtype == 111UL) {
#line 139
    goto case_111;
  }
#line 141
  if (rtype == 122UL) {
#line 141
    goto case_122;
  }
#line 142
  if (rtype == 123UL) {
#line 142
    goto case_123;
  }
#line 143
  if (rtype == 124UL) {
#line 143
    goto case_124;
  }
#line 144
  if (rtype == 125UL) {
#line 144
    goto case_125;
  }
#line 145
  if (rtype == 126UL) {
#line 145
    goto case_126;
  }
#line 146
  if (rtype == 127UL) {
#line 146
    goto case_127;
  }
#line 151
  if (rtype == 180UL) {
#line 151
    goto case_180;
  }
#line 154
  if (rtype == 181UL) {
#line 154
    goto case_181;
  }
#line 157
  if (rtype == 182UL) {
#line 157
    goto case_182;
  }
#line 160
  if (rtype == 183UL) {
#line 160
    goto case_183;
  }
#line 161
  if (rtype == 184UL) {
#line 161
    goto case_184;
  }
#line 162
  if (rtype == 185UL) {
#line 162
    goto case_185;
  }
#line 163
  if (rtype == 186UL) {
#line 163
    goto case_186;
  }
#line 164
  if (rtype == 187UL) {
#line 164
    goto case_187;
  }
#line 165
  if (rtype == 188UL) {
#line 165
    goto case_188;
  }
#line 167
  if (rtype == 256UL) {
#line 167
    goto case_256;
  }
#line 172
  if (rtype == 257UL) {
#line 172
    goto case_257;
  }
#line 175
  if (rtype == 258UL) {
#line 175
    goto case_258;
  }
#line 178
  if (rtype == 259UL) {
#line 178
    goto case_259;
  }
#line 181
  if (rtype == 260UL) {
#line 181
    goto case_260;
  }
#line 184
  if (rtype == 261UL) {
#line 184
    goto case_261;
  }
#line 187
  if (rtype == 262UL) {
#line 187
    goto case_262;
  }
#line 193
  if (rtype == 263UL) {
#line 193
    goto case_263;
  }
#line 196
  if (rtype == 264UL) {
#line 196
    goto case_264;
  }
#line 199
  if (rtype == 265UL) {
#line 199
    goto case_265;
  }
#line 202
  if (rtype == 266UL) {
#line 202
    goto case_266;
  }
#line 205
  if (rtype == 267UL) {
#line 205
    goto case_267;
  }
#line 208
  if (rtype == 268UL) {
#line 208
    goto case_268;
  }
#line 211
  if (rtype == 269UL) {
#line 211
    goto case_269;
  }
#line 218
  if (rtype == 270UL) {
#line 218
    goto case_270;
  }
#line 221
  if (rtype == 271UL) {
#line 221
    goto case_271;
  }
#line 224
  if (rtype == 272UL) {
#line 224
    goto case_272;
  }
#line 230
  if (rtype == 273UL) {
#line 230
    goto case_273;
  }
#line 233
  if (rtype == 274UL) {
#line 233
    goto case_274;
  }
#line 236
  if (rtype == 275UL) {
#line 236
    goto case_275;
  }
#line 239
  if (rtype == 276UL) {
#line 239
    goto case_276;
  }
#line 242
  if (rtype == 277UL) {
#line 242
    goto case_277;
  }
#line 245
  if (rtype == 278UL) {
#line 245
    goto case_278;
  }
#line 250
  if (rtype == 279UL) {
#line 250
    goto case_279;
  }
#line 253
  if (rtype == 280UL) {
#line 253
    goto case_280;
  }
#line 258
  if (rtype == 282UL) {
#line 258
    goto case_282;
  }
#line 261
  if (rtype == 283UL) {
#line 261
    goto case_283;
  }
#line 264
  if (rtype == 284UL) {
#line 264
    goto case_284;
  }
#line 267
  if (rtype == 285UL) {
#line 267
    goto case_285;
  }
#line 270
  if (rtype == 286UL) {
#line 270
    goto case_286;
  }
#line 273
  if (rtype == 299UL) {
#line 273
    goto case_299;
  }
#line 275
  if (rtype == 309UL) {
#line 275
    goto case_309;
  }
#line 276
  if (rtype == 311UL) {
#line 276
    goto case_311;
  }
#line 277
  if (rtype == 312UL) {
#line 277
    goto case_312;
  }
#line 279
  if (rtype == 513UL) {
#line 279
    goto case_513;
  }
#line 280
  if (rtype == 514UL) {
#line 280
    goto case_514;
  }
#line 281
  if (rtype == 539UL) {
#line 281
    goto case_539;
  }
#line 282
  if (rtype == 540UL) {
#line 282
    goto case_540;
  }
#line 283
  if (rtype == 541UL) {
#line 283
    goto case_541;
  }
#line 284
  if (rtype == 542UL) {
#line 284
    goto case_542;
  }
#line 285
  if (rtype == 543UL) {
#line 285
    goto case_543;
  }
#line 286
  if (rtype == 544UL) {
#line 286
    goto case_544;
  }
#line 287
  if (rtype == 545UL) {
#line 287
    goto case_545;
  }
#line 288
  if (rtype == 546UL) {
#line 288
    goto case_546;
  }
#line 289
  if (rtype == 547UL) {
#line 289
    goto case_547;
  }
#line 290
  if (rtype == 548UL) {
#line 290
    goto case_548;
  }
#line 291
  if (rtype == 549UL) {
#line 291
    goto case_549;
  }
#line 292
  if (rtype == 550UL) {
#line 292
    goto case_550;
  }
#line 293
  if (rtype == 551UL) {
#line 293
    goto case_551;
  }
#line 295
  if (rtype == 560UL) {
#line 295
    goto case_560;
  }
#line 296
  if (rtype == 561UL) {
#line 296
    goto case_561;
  }
#line 297
  if (rtype == 562UL) {
#line 297
    goto case_562;
  }
#line 298
  if (rtype == 563UL) {
#line 298
    goto case_563;
  }
#line 299
  if (rtype == 564UL) {
#line 299
    goto case_564;
  }
#line 300
  if (rtype == 565UL) {
#line 300
    goto case_565;
  }
#line 301
  if (rtype == 566UL) {
#line 301
    goto case_566;
  }
#line 302
  if (rtype == 567UL) {
#line 302
    goto case_567;
  }
#line 303
  if (rtype == 568UL) {
#line 303
    goto case_568;
  }
#line 304
  if (rtype == 569UL) {
#line 304
    goto case_569;
  }
#line 309
  if (rtype == 1024UL) {
#line 309
    goto case_1024;
  }
#line 312
  if (rtype == 1025UL) {
#line 312
    goto case_1025;
  }
#line 315
  if (rtype == 1026UL) {
#line 315
    goto case_1026;
  }
#line 318
  if (rtype == 1027UL) {
#line 318
    goto case_1027;
  }
#line 319
  if (rtype == 1028UL) {
#line 319
    goto case_1028;
  }
#line 320
  if (rtype == 1029UL) {
#line 320
    goto case_1029;
  }
#line 321
  if (rtype == 1030UL) {
#line 321
    goto case_1030;
  }
#line 330
  if (rtype == 1031UL) {
#line 330
    goto case_1031;
  }
#line 331
  if (rtype == 1032UL) {
#line 331
    goto case_1032;
  }
#line 333
  goto switch_default;
  case_0: /* CIL Label */ 
#line 44
  return ("R_AARCH64_NONE");
  case_1: /* CIL Label */ 
#line 49
  return ("R_AARCH64_P32_ABS32");
  case_2: /* CIL Label */ 
#line 52
  return ("R_AARCH64_P32_ABS16");
  case_3: /* CIL Label */ 
#line 55
  return ("R_AARCH64_P32_PREL32");
  case_4: /* CIL Label */ 
#line 58
  return ("R_AARCH64_P32_PREL16");
  case_5: /* CIL Label */ 
#line 64
  return ("R_AARCH64_P32_MOVW_UABS_G0");
  case_6: /* CIL Label */ 
#line 67
  return ("R_AARCH64_P32_MOVW_UABS_G0_NC");
  case_7: /* CIL Label */ 
#line 70
  return ("R_AARCH64_P32_MOVW_UABS_G1");
  case_8: /* CIL Label */ 
#line 77
  return ("R_AARCH64_P32_MOVW_SABS_G0");
  case_9: /* CIL Label */ 
#line 83
  return ("R_AARCH64_P32_LD_PREL_LO19");
  case_10: /* CIL Label */ 
#line 86
  return ("R_AARCH64_P32_ADR_PREL_LO21");
  case_11: /* CIL Label */ 
#line 89
  return ("R_AARCH64_P32_ADR_PREL_PG_HI21");
  case_12: /* CIL Label */ 
#line 92
  return ("R_AARCH64_P32_ADD_ABS_LO12_NC");
  case_13: /* CIL Label */ 
#line 95
  return ("R_AARCH64_P32_LDST8_ABS_LO12_NC");
  case_14: /* CIL Label */ 
#line 98
  return ("R_AARCH64_P32_LDST16_ABS_LO12_NC");
  case_15: /* CIL Label */ 
#line 101
  return ("R_AARCH64_P32_LDST32_ABS_LO12_NC");
  case_16: /* CIL Label */ 
#line 104
  return ("R_AARCH64_P32_LDST64_ABS_LO12_NC");
  case_17: /* CIL Label */ 
#line 107
  return ("R_AARCH64_P32_LDST128_ABS_LO12_NC");
  case_18: /* CIL Label */ 
#line 112
  return ("R_AARCH64_P32_TSTBR14");
  case_19: /* CIL Label */ 
#line 115
  return ("R_AARCH64_P32_CONDBR19");
  case_20: /* CIL Label */ 
#line 118
  return ("R_AARCH64_P32_JUMP26");
  case_21: /* CIL Label */ 
#line 121
  return ("R_AARCH64_P32_CALL26");
  case_25: /* CIL Label */ 
#line 124
  return ("R_AARCH64_P32_GOT_LD_PREL19");
  case_26: /* CIL Label */ 
#line 125
  return ("R_AARCH64_P32_ADR_GOT_PAGE");
  case_27: /* CIL Label */ 
#line 126
  return ("R_AARCH64_P32_LD32_GOT_LO12_NC");
  case_81: /* CIL Label */ 
#line 129
  return ("R_AARCH64_P32_TLSGD_ADR_PAGE21");
  case_82: /* CIL Label */ 
#line 130
  return ("R_AARCH64_P32_TLSGD_ADD_LO12_NC");
  case_103: /* CIL Label */ 
#line 131
  return ("R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21");
  case_104: /* CIL Label */ 
#line 132
  return ("R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC");
  case_105: /* CIL Label */ 
#line 133
  return ("R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19");
  case_106: /* CIL Label */ 
#line 134
  return ("R_AARCH64_P32_TLSLE_MOVW_TPREL_G1");
  case_107: /* CIL Label */ 
#line 135
  return ("R_AARCH64_P32_TLSLE_MOVW_TPREL_G0");
  case_108: /* CIL Label */ 
#line 136
  return ("R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC");
  case_109: /* CIL Label */ 
#line 137
  return ("R_AARCH64_P32_TLSLE_ADD_TPREL_HI12");
  case_110: /* CIL Label */ 
#line 138
  return ("R_AARCH64_P32_TLSLE_ADD_TPREL_LO12");
  case_111: /* CIL Label */ 
#line 139
  return ("R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC");
  case_122: /* CIL Label */ 
#line 141
  return ("R_AARCH64_P32_TLSDESC_LD_PREL19");
  case_123: /* CIL Label */ 
#line 142
  return ("R_AARCH64_P32_TLSDESC_ADR_PREL21");
  case_124: /* CIL Label */ 
#line 143
  return ("R_AARCH64_P32_TLSDESC_ADR_PAGE21");
  case_125: /* CIL Label */ 
#line 144
  return ("R_AARCH64_P32_TLSDESC_LD32_LO12_NC");
  case_126: /* CIL Label */ 
#line 145
  return ("R_AARCH64_P32_TLSDESC_ADD_LO12_NC");
  case_127: /* CIL Label */ 
#line 146
  return ("R_AARCH64_P32_TLSDESC_CALL");
  case_180: /* CIL Label */ 
#line 151
  return ("R_AARCH64_P32_COPY");
  case_181: /* CIL Label */ 
#line 154
  return ("R_AARCH64_P32_GLOB_DAT");
  case_182: /* CIL Label */ 
#line 157
  return ("R_AARCH64_P32_JUMP_SLOT");
  case_183: /* CIL Label */ 
#line 160
  return ("R_AARCH64_P32_RELATIVE");
  case_184: /* CIL Label */ 
#line 161
  return ("R_AARCH64_P32_TLS_DTPMOD");
  case_185: /* CIL Label */ 
#line 162
  return ("R_AARCH64_P32_TLS_DTPREL");
  case_186: /* CIL Label */ 
#line 163
  return ("R_AARCH64_P32_TLS_TPREL");
  case_187: /* CIL Label */ 
#line 164
  return ("R_AARCH64_P32_TLSDESC");
  case_188: /* CIL Label */ 
#line 165
  return ("R_AARCH64_P32_IRELATIVE");
  case_256: /* CIL Label */ 
#line 167
  return ("R_AARCH64_NULL");
  case_257: /* CIL Label */ 
#line 172
  return ("R_AARCH64_ABS64");
  case_258: /* CIL Label */ 
#line 175
  return ("R_AARCH64_ABS32");
  case_259: /* CIL Label */ 
#line 178
  return ("R_AARCH64_ABS16");
  case_260: /* CIL Label */ 
#line 181
  return ("R_AARCH64_PREL64");
  case_261: /* CIL Label */ 
#line 184
  return ("R_AARCH64_PREL32");
  case_262: /* CIL Label */ 
#line 187
  return ("R_AARCH64_PREL16");
  case_263: /* CIL Label */ 
#line 193
  return ("R_AARCH64_MOVW_UABS_G0");
  case_264: /* CIL Label */ 
#line 196
  return ("R_AARCH64_MOVW_UABS_G0_NC");
  case_265: /* CIL Label */ 
#line 199
  return ("R_AARCH64_MOVW_UABS_G1");
  case_266: /* CIL Label */ 
#line 202
  return ("R_AARCH64_MOVW_UABS_G1_NC");
  case_267: /* CIL Label */ 
#line 205
  return ("R_AARCH64_MOVW_UABS_G2");
  case_268: /* CIL Label */ 
#line 208
  return ("R_AARCH64_MOVW_UABS_G2_NC");
  case_269: /* CIL Label */ 
#line 211
  return ("R_AARCH64_MOVW_UABS_G3");
  case_270: /* CIL Label */ 
#line 218
  return ("R_AARCH64_MOVW_SABS_G0");
  case_271: /* CIL Label */ 
#line 221
  return ("R_AARCH64_MOVW_SABS_G1");
  case_272: /* CIL Label */ 
#line 224
  return ("R_AARCH64_MOVW_SABS_G2");
  case_273: /* CIL Label */ 
#line 230
  return ("R_AARCH64_LD_PREL_LO19");
  case_274: /* CIL Label */ 
#line 233
  return ("R_AARCH64_ADR_PREL_LO21");
  case_275: /* CIL Label */ 
#line 236
  return ("R_AARCH64_ADR_PREL_PG_HI21");
  case_276: /* CIL Label */ 
#line 239
  return ("R_AARCH64_ADR_PREL_PG_HI21_NC");
  case_277: /* CIL Label */ 
#line 242
  return ("R_AARCH64_ADD_ABS_LO12_NC");
  case_278: /* CIL Label */ 
#line 245
  return ("R_AARCH64_LDST8_ABS_LO12_NC");
  case_279: /* CIL Label */ 
#line 250
  return ("R_AARCH64_TSTBR14");
  case_280: /* CIL Label */ 
#line 253
  return ("R_AARCH64_CONDBR19");
  case_282: /* CIL Label */ 
#line 258
  return ("R_AARCH64_JUMP26");
  case_283: /* CIL Label */ 
#line 261
  return ("R_AARCH64_CALL26");
  case_284: /* CIL Label */ 
#line 264
  return ("R_AARCH64_LDST16_ABS_LO12_NC");
  case_285: /* CIL Label */ 
#line 267
  return ("R_AARCH64_LDST32_ABS_LO12_NC");
  case_286: /* CIL Label */ 
#line 270
  return ("R_AARCH64_LDST64_ABS_LO12_NC");
  case_299: /* CIL Label */ 
#line 273
  return ("R_AARCH64_LDST128_ABS_LO12_NC");
  case_309: /* CIL Label */ 
#line 275
  return ("R_AARCH64_GOT_LD_PREL19");
  case_311: /* CIL Label */ 
#line 276
  return ("R_AARCH64_ADR_GOT_PAGE");
  case_312: /* CIL Label */ 
#line 277
  return ("R_AARCH64_LD64_GOT_LO12_NC");
  case_513: /* CIL Label */ 
#line 279
  return ("R_AARCH64_TLSGD_ADR_PAGE21");
  case_514: /* CIL Label */ 
#line 280
  return ("R_AARCH64_TLSGD_ADD_LO12_NC");
  case_539: /* CIL Label */ 
#line 281
  return ("R_AARCH64_TLSIE_MOVW_GOTTPREL_G1");
  case_540: /* CIL Label */ 
#line 282
  return ("R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC");
  case_541: /* CIL Label */ 
#line 283
  return ("R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21");
  case_542: /* CIL Label */ 
#line 284
  return ("R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC");
  case_543: /* CIL Label */ 
#line 285
  return ("R_AARCH64_TLSIE_LD_GOTTPREL_PREL19");
  case_544: /* CIL Label */ 
#line 286
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G2");
  case_545: /* CIL Label */ 
#line 287
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G1");
  case_546: /* CIL Label */ 
#line 288
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G1_NC");
  case_547: /* CIL Label */ 
#line 289
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G0");
  case_548: /* CIL Label */ 
#line 290
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G0_NC");
  case_549: /* CIL Label */ 
#line 291
  return ("R_AARCH64_TLSLE_ADD_TPREL_HI12");
  case_550: /* CIL Label */ 
#line 292
  return ("R_AARCH64_TLSLE_ADD_TPREL_LO12");
  case_551: /* CIL Label */ 
#line 293
  return ("R_AARCH64_TLSLE_ADD_TPREL_LO12_NC");
  case_560: /* CIL Label */ 
#line 295
  return ("R_AARCH64_TLSDESC_LD_PREL19");
  case_561: /* CIL Label */ 
#line 296
  return ("R_AARCH64_TLSDESC_ADR_PREL21");
  case_562: /* CIL Label */ 
#line 297
  return ("R_AARCH64_TLSDESC_ADR_PAGE21");
  case_563: /* CIL Label */ 
#line 298
  return ("R_AARCH64_TLSDESC_LD64_LO12_NC");
  case_564: /* CIL Label */ 
#line 299
  return ("R_AARCH64_TLSDESC_ADD_LO12_NC");
  case_565: /* CIL Label */ 
#line 300
  return ("R_AARCH64_TLSDESC_OFF_G1");
  case_566: /* CIL Label */ 
#line 301
  return ("R_AARCH64_TLSDESC_OFF_G0_NC");
  case_567: /* CIL Label */ 
#line 302
  return ("R_AARCH64_TLSDESC_LDR");
  case_568: /* CIL Label */ 
#line 303
  return ("R_AARCH64_TLSDESC_ADD");
  case_569: /* CIL Label */ 
#line 304
  return ("R_AARCH64_TLSDESC_CALL");
  case_1024: /* CIL Label */ 
#line 309
  return ("R_AARCH64_COPY");
  case_1025: /* CIL Label */ 
#line 312
  return ("R_AARCH64_GLOB_DAT");
  case_1026: /* CIL Label */ 
#line 315
  return ("R_AARCH64_JUMP_SLOT");
  case_1027: /* CIL Label */ 
#line 318
  return ("R_AARCH64_RELATIVE");
  case_1028: /* CIL Label */ 
#line 319
  return ("R_AARCH64_TLS_DTPMOD64");
  case_1029: /* CIL Label */ 
#line 320
  return ("R_AARCH64_TLS_DTPREL64");
  case_1030: /* CIL Label */ 
#line 321
  return ("R_AARCH64_TLS_TPREL64");
  case_1031: /* CIL Label */ 
#line 330
  return ("R_AARCH64_TLSDESC");
  case_1032: /* CIL Label */ 
#line 331
  return ("R_AARCH64_IRELATIVE");
  switch_default: /* CIL Label */ 
#line 333
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 73 "./../include/elf/alpha.h"
static char const   *elf_alpha_reloc_type(unsigned long rtype ) ;
#line 73 "./../include/elf/alpha.h"
static char const   *elf_alpha_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 74
  if (rtype == 0UL) {
#line 74
    goto case_0;
  }
#line 75
  if (rtype == 1UL) {
#line 75
    goto case_1;
  }
#line 76
  if (rtype == 2UL) {
#line 76
    goto case_2;
  }
#line 77
  if (rtype == 3UL) {
#line 77
    goto case_3;
  }
#line 78
  if (rtype == 4UL) {
#line 78
    goto case_4;
  }
#line 79
  if (rtype == 5UL) {
#line 79
    goto case_5;
  }
#line 80
  if (rtype == 6UL) {
#line 80
    goto case_6;
  }
#line 81
  if (rtype == 7UL) {
#line 81
    goto case_7;
  }
#line 82
  if (rtype == 8UL) {
#line 82
    goto case_8;
  }
#line 83
  if (rtype == 9UL) {
#line 83
    goto case_9;
  }
#line 84
  if (rtype == 10UL) {
#line 84
    goto case_10;
  }
#line 85
  if (rtype == 11UL) {
#line 85
    goto case_11;
  }
#line 89
  if (rtype == 17UL) {
#line 89
    goto case_17;
  }
#line 90
  if (rtype == 18UL) {
#line 90
    goto case_18;
  }
#line 91
  if (rtype == 19UL) {
#line 91
    goto case_19;
  }
#line 96
  if (rtype == 24UL) {
#line 96
    goto case_24;
  }
#line 97
  if (rtype == 25UL) {
#line 97
    goto case_25;
  }
#line 98
  if (rtype == 26UL) {
#line 98
    goto case_26;
  }
#line 99
  if (rtype == 27UL) {
#line 99
    goto case_27;
  }
#line 104
  if (rtype == 28UL) {
#line 104
    goto case_28;
  }
#line 107
  if (rtype == 29UL) {
#line 107
    goto case_29;
  }
#line 108
  if (rtype == 30UL) {
#line 108
    goto case_30;
  }
#line 109
  if (rtype == 31UL) {
#line 109
    goto case_31;
  }
#line 110
  if (rtype == 32UL) {
#line 110
    goto case_32;
  }
#line 111
  if (rtype == 33UL) {
#line 111
    goto case_33;
  }
#line 112
  if (rtype == 34UL) {
#line 112
    goto case_34;
  }
#line 113
  if (rtype == 35UL) {
#line 113
    goto case_35;
  }
#line 114
  if (rtype == 36UL) {
#line 114
    goto case_36;
  }
#line 115
  if (rtype == 37UL) {
#line 115
    goto case_37;
  }
#line 116
  if (rtype == 38UL) {
#line 116
    goto case_38;
  }
#line 117
  if (rtype == 39UL) {
#line 117
    goto case_39;
  }
#line 118
  if (rtype == 40UL) {
#line 118
    goto case_40;
  }
#line 119
  if (rtype == 41UL) {
#line 119
    goto case_41;
  }
#line 121
  goto switch_default;
  case_0: /* CIL Label */ 
#line 74
  return ("R_ALPHA_NONE");
  case_1: /* CIL Label */ 
#line 75
  return ("R_ALPHA_REFLONG");
  case_2: /* CIL Label */ 
#line 76
  return ("R_ALPHA_REFQUAD");
  case_3: /* CIL Label */ 
#line 77
  return ("R_ALPHA_GPREL32");
  case_4: /* CIL Label */ 
#line 78
  return ("R_ALPHA_LITERAL");
  case_5: /* CIL Label */ 
#line 79
  return ("R_ALPHA_LITUSE");
  case_6: /* CIL Label */ 
#line 80
  return ("R_ALPHA_GPDISP");
  case_7: /* CIL Label */ 
#line 81
  return ("R_ALPHA_BRADDR");
  case_8: /* CIL Label */ 
#line 82
  return ("R_ALPHA_HINT");
  case_9: /* CIL Label */ 
#line 83
  return ("R_ALPHA_SREL16");
  case_10: /* CIL Label */ 
#line 84
  return ("R_ALPHA_SREL32");
  case_11: /* CIL Label */ 
#line 85
  return ("R_ALPHA_SREL64");
  case_17: /* CIL Label */ 
#line 89
  return ("R_ALPHA_GPRELHIGH");
  case_18: /* CIL Label */ 
#line 90
  return ("R_ALPHA_GPRELLOW");
  case_19: /* CIL Label */ 
#line 91
  return ("R_ALPHA_GPREL16");
  case_24: /* CIL Label */ 
#line 96
  return ("R_ALPHA_COPY");
  case_25: /* CIL Label */ 
#line 97
  return ("R_ALPHA_GLOB_DAT");
  case_26: /* CIL Label */ 
#line 98
  return ("R_ALPHA_JMP_SLOT");
  case_27: /* CIL Label */ 
#line 99
  return ("R_ALPHA_RELATIVE");
  case_28: /* CIL Label */ 
#line 104
  return ("R_ALPHA_BRSGP");
  case_29: /* CIL Label */ 
#line 107
  return ("R_ALPHA_TLSGD");
  case_30: /* CIL Label */ 
#line 108
  return ("R_ALPHA_TLSLDM");
  case_31: /* CIL Label */ 
#line 109
  return ("R_ALPHA_DTPMOD64");
  case_32: /* CIL Label */ 
#line 110
  return ("R_ALPHA_GOTDTPREL");
  case_33: /* CIL Label */ 
#line 111
  return ("R_ALPHA_DTPREL64");
  case_34: /* CIL Label */ 
#line 112
  return ("R_ALPHA_DTPRELHI");
  case_35: /* CIL Label */ 
#line 113
  return ("R_ALPHA_DTPRELLO");
  case_36: /* CIL Label */ 
#line 114
  return ("R_ALPHA_DTPREL16");
  case_37: /* CIL Label */ 
#line 115
  return ("R_ALPHA_GOTTPREL");
  case_38: /* CIL Label */ 
#line 116
  return ("R_ALPHA_TPREL64");
  case_39: /* CIL Label */ 
#line 117
  return ("R_ALPHA_TPRELHI");
  case_40: /* CIL Label */ 
#line 118
  return ("R_ALPHA_TPRELLO");
  case_41: /* CIL Label */ 
#line 119
  return ("R_ALPHA_TPREL16");
  switch_default: /* CIL Label */ 
#line 121
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "./../include/elf/arc.h"
static char const   *elf_arc_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/arc.h"
static char const   *elf_arc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 32
  if (rtype == 0UL) {
#line 32
    goto case_0;
  }
#line 33
  if (rtype == 1UL) {
#line 33
    goto case_1;
  }
#line 34
  if (rtype == 2UL) {
#line 34
    goto case_2;
  }
#line 35
  if (rtype == 3UL) {
#line 35
    goto case_3;
  }
#line 36
  goto switch_default;
  case_0: /* CIL Label */ 
#line 32
  return ("R_ARC_NONE");
  case_1: /* CIL Label */ 
#line 33
  return ("R_ARC_32");
  case_2: /* CIL Label */ 
#line 34
  return ("R_ARC_B26");
  case_3: /* CIL Label */ 
#line 35
  return ("R_ARC_B22_PCREL");
  switch_default: /* CIL Label */ 
#line 36
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 117 "./../include/elf/arm.h"
static char const   *elf_arm_reloc_type(unsigned long rtype ) ;
#line 117 "./../include/elf/arm.h"
static char const   *elf_arm_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 119
  if (rtype == 0UL) {
#line 119
    goto case_0;
  }
#line 120
  if (rtype == 1UL) {
#line 120
    goto case_1;
  }
#line 121
  if (rtype == 2UL) {
#line 121
    goto case_2;
  }
#line 122
  if (rtype == 3UL) {
#line 122
    goto case_3;
  }
#line 123
  if (rtype == 4UL) {
#line 123
    goto case_4;
  }
#line 124
  if (rtype == 5UL) {
#line 124
    goto case_5;
  }
#line 125
  if (rtype == 6UL) {
#line 125
    goto case_6;
  }
#line 126
  if (rtype == 7UL) {
#line 126
    goto case_7;
  }
#line 127
  if (rtype == 8UL) {
#line 127
    goto case_8;
  }
#line 128
  if (rtype == 9UL) {
#line 128
    goto case_9;
  }
#line 129
  if (rtype == 10UL) {
#line 129
    goto case_10;
  }
#line 130
  if (rtype == 11UL) {
#line 130
    goto case_11;
  }
#line 131
  if (rtype == 12UL) {
#line 131
    goto case_12;
  }
#line 132
  if (rtype == 13UL) {
#line 132
    goto case_13;
  }
#line 133
  if (rtype == 14UL) {
#line 133
    goto case_14;
  }
#line 134
  if (rtype == 15UL) {
#line 134
    goto case_15;
  }
#line 135
  if (rtype == 16UL) {
#line 135
    goto case_16;
  }
#line 136
  if (rtype == 17UL) {
#line 136
    goto case_17;
  }
#line 137
  if (rtype == 18UL) {
#line 137
    goto case_18;
  }
#line 138
  if (rtype == 19UL) {
#line 138
    goto case_19;
  }
#line 139
  if (rtype == 20UL) {
#line 139
    goto case_20;
  }
#line 140
  if (rtype == 21UL) {
#line 140
    goto case_21;
  }
#line 141
  if (rtype == 22UL) {
#line 141
    goto case_22;
  }
#line 142
  if (rtype == 23UL) {
#line 142
    goto case_23;
  }
#line 143
  if (rtype == 24UL) {
#line 143
    goto case_24;
  }
#line 144
  if (rtype == 25UL) {
#line 144
    goto case_25;
  }
#line 145
  if (rtype == 26UL) {
#line 145
    goto case_26;
  }
#line 146
  if (rtype == 27UL) {
#line 146
    goto case_27;
  }
#line 147
  if (rtype == 28UL) {
#line 147
    goto case_28;
  }
#line 148
  if (rtype == 29UL) {
#line 148
    goto case_29;
  }
#line 149
  if (rtype == 30UL) {
#line 149
    goto case_30;
  }
#line 150
  if (rtype == 31UL) {
#line 150
    goto case_31;
  }
#line 151
  if (rtype == 32UL) {
#line 151
    goto case_32;
  }
#line 152
  if (rtype == 33UL) {
#line 152
    goto case_33;
  }
#line 153
  if (rtype == 34UL) {
#line 153
    goto case_34;
  }
#line 154
  if (rtype == 35UL) {
#line 154
    goto case_35;
  }
#line 155
  if (rtype == 36UL) {
#line 155
    goto case_36;
  }
#line 156
  if (rtype == 37UL) {
#line 156
    goto case_37;
  }
#line 157
  if (rtype == 38UL) {
#line 157
    goto case_38;
  }
#line 158
  if (rtype == 39UL) {
#line 158
    goto case_39;
  }
#line 159
  if (rtype == 40UL) {
#line 159
    goto case_40;
  }
#line 160
  if (rtype == 41UL) {
#line 160
    goto case_41;
  }
#line 161
  if (rtype == 42UL) {
#line 161
    goto case_42;
  }
#line 162
  if (rtype == 43UL) {
#line 162
    goto case_43;
  }
#line 163
  if (rtype == 44UL) {
#line 163
    goto case_44;
  }
#line 164
  if (rtype == 45UL) {
#line 164
    goto case_45;
  }
#line 165
  if (rtype == 46UL) {
#line 165
    goto case_46;
  }
#line 166
  if (rtype == 47UL) {
#line 166
    goto case_47;
  }
#line 167
  if (rtype == 48UL) {
#line 167
    goto case_48;
  }
#line 168
  if (rtype == 49UL) {
#line 168
    goto case_49;
  }
#line 169
  if (rtype == 50UL) {
#line 169
    goto case_50;
  }
#line 170
  if (rtype == 51UL) {
#line 170
    goto case_51;
  }
#line 171
  if (rtype == 52UL) {
#line 171
    goto case_52;
  }
#line 172
  if (rtype == 53UL) {
#line 172
    goto case_53;
  }
#line 173
  if (rtype == 54UL) {
#line 173
    goto case_54;
  }
#line 174
  if (rtype == 55UL) {
#line 174
    goto case_55;
  }
#line 175
  if (rtype == 56UL) {
#line 175
    goto case_56;
  }
#line 176
  if (rtype == 57UL) {
#line 176
    goto case_57;
  }
#line 177
  if (rtype == 58UL) {
#line 177
    goto case_58;
  }
#line 178
  if (rtype == 59UL) {
#line 178
    goto case_59;
  }
#line 179
  if (rtype == 60UL) {
#line 179
    goto case_60;
  }
#line 180
  if (rtype == 61UL) {
#line 180
    goto case_61;
  }
#line 181
  if (rtype == 62UL) {
#line 181
    goto case_62;
  }
#line 182
  if (rtype == 63UL) {
#line 182
    goto case_63;
  }
#line 183
  if (rtype == 64UL) {
#line 183
    goto case_64;
  }
#line 184
  if (rtype == 65UL) {
#line 184
    goto case_65;
  }
#line 185
  if (rtype == 66UL) {
#line 185
    goto case_66;
  }
#line 186
  if (rtype == 67UL) {
#line 186
    goto case_67;
  }
#line 187
  if (rtype == 68UL) {
#line 187
    goto case_68;
  }
#line 188
  if (rtype == 69UL) {
#line 188
    goto case_69;
  }
#line 189
  if (rtype == 70UL) {
#line 189
    goto case_70;
  }
#line 190
  if (rtype == 71UL) {
#line 190
    goto case_71;
  }
#line 191
  if (rtype == 72UL) {
#line 191
    goto case_72;
  }
#line 192
  if (rtype == 73UL) {
#line 192
    goto case_73;
  }
#line 193
  if (rtype == 74UL) {
#line 193
    goto case_74;
  }
#line 194
  if (rtype == 75UL) {
#line 194
    goto case_75;
  }
#line 195
  if (rtype == 76UL) {
#line 195
    goto case_76;
  }
#line 196
  if (rtype == 77UL) {
#line 196
    goto case_77;
  }
#line 197
  if (rtype == 78UL) {
#line 197
    goto case_78;
  }
#line 198
  if (rtype == 79UL) {
#line 198
    goto case_79;
  }
#line 199
  if (rtype == 80UL) {
#line 199
    goto case_80;
  }
#line 200
  if (rtype == 81UL) {
#line 200
    goto case_81;
  }
#line 201
  if (rtype == 82UL) {
#line 201
    goto case_82;
  }
#line 202
  if (rtype == 83UL) {
#line 202
    goto case_83;
  }
#line 203
  if (rtype == 84UL) {
#line 203
    goto case_84;
  }
#line 204
  if (rtype == 85UL) {
#line 204
    goto case_85;
  }
#line 205
  if (rtype == 86UL) {
#line 205
    goto case_86;
  }
#line 206
  if (rtype == 87UL) {
#line 206
    goto case_87;
  }
#line 207
  if (rtype == 88UL) {
#line 207
    goto case_88;
  }
#line 208
  if (rtype == 89UL) {
#line 208
    goto case_89;
  }
#line 209
  if (rtype == 90UL) {
#line 209
    goto case_90;
  }
#line 210
  if (rtype == 91UL) {
#line 210
    goto case_91;
  }
#line 211
  if (rtype == 92UL) {
#line 211
    goto case_92;
  }
#line 212
  if (rtype == 93UL) {
#line 212
    goto case_93;
  }
#line 213
  if (rtype == 94UL) {
#line 213
    goto case_94;
  }
#line 214
  if (rtype == 95UL) {
#line 214
    goto case_95;
  }
#line 215
  if (rtype == 96UL) {
#line 215
    goto case_96;
  }
#line 216
  if (rtype == 97UL) {
#line 216
    goto case_97;
  }
#line 217
  if (rtype == 98UL) {
#line 217
    goto case_98;
  }
#line 218
  if (rtype == 99UL) {
#line 218
    goto case_99;
  }
#line 219
  if (rtype == 100UL) {
#line 219
    goto case_100;
  }
#line 220
  if (rtype == 101UL) {
#line 220
    goto case_101;
  }
#line 221
  if (rtype == 102UL) {
#line 221
    goto case_102;
  }
#line 222
  if (rtype == 103UL) {
#line 222
    goto case_103;
  }
#line 223
  if (rtype == 104UL) {
#line 223
    goto case_104;
  }
#line 224
  if (rtype == 105UL) {
#line 224
    goto case_105;
  }
#line 225
  if (rtype == 106UL) {
#line 225
    goto case_106;
  }
#line 226
  if (rtype == 107UL) {
#line 226
    goto case_107;
  }
#line 227
  if (rtype == 108UL) {
#line 227
    goto case_108;
  }
#line 228
  if (rtype == 109UL) {
#line 228
    goto case_109;
  }
#line 229
  if (rtype == 110UL) {
#line 229
    goto case_110;
  }
#line 230
  if (rtype == 111UL) {
#line 230
    goto case_111;
  }
#line 232
  if (rtype == 128UL) {
#line 232
    goto case_128;
  }
#line 233
  if (rtype == 129UL) {
#line 233
    goto case_129;
  }
#line 235
  if (rtype == 160UL) {
#line 235
    goto case_160;
  }
#line 238
  if (rtype == 249UL) {
#line 238
    goto case_249;
  }
#line 239
  if (rtype == 250UL) {
#line 239
    goto case_250;
  }
#line 240
  if (rtype == 251UL) {
#line 240
    goto case_251;
  }
#line 241
  if (rtype == 252UL) {
#line 241
    goto case_252;
  }
#line 242
  if (rtype == 253UL) {
#line 242
    goto case_253;
  }
#line 243
  if (rtype == 254UL) {
#line 243
    goto case_254;
  }
#line 244
  if (rtype == 255UL) {
#line 244
    goto case_255;
  }
#line 259
  goto switch_default;
  case_0: /* CIL Label */ 
#line 119
  return ("R_ARM_NONE");
  case_1: /* CIL Label */ 
#line 120
  return ("R_ARM_PC24");
  case_2: /* CIL Label */ 
#line 121
  return ("R_ARM_ABS32");
  case_3: /* CIL Label */ 
#line 122
  return ("R_ARM_REL32");
  case_4: /* CIL Label */ 
#line 123
  return ("R_ARM_LDR_PC_G0");
  case_5: /* CIL Label */ 
#line 124
  return ("R_ARM_ABS16");
  case_6: /* CIL Label */ 
#line 125
  return ("R_ARM_ABS12");
  case_7: /* CIL Label */ 
#line 126
  return ("R_ARM_THM_ABS5");
  case_8: /* CIL Label */ 
#line 127
  return ("R_ARM_ABS8");
  case_9: /* CIL Label */ 
#line 128
  return ("R_ARM_SBREL32");
  case_10: /* CIL Label */ 
#line 129
  return ("R_ARM_THM_CALL");
  case_11: /* CIL Label */ 
#line 130
  return ("R_ARM_THM_PC8");
  case_12: /* CIL Label */ 
#line 131
  return ("R_ARM_BREL_ADJ");
  case_13: /* CIL Label */ 
#line 132
  return ("R_ARM_TLS_DESC");
  case_14: /* CIL Label */ 
#line 133
  return ("R_ARM_THM_SWI8");
  case_15: /* CIL Label */ 
#line 134
  return ("R_ARM_XPC25");
  case_16: /* CIL Label */ 
#line 135
  return ("R_ARM_THM_XPC22");
  case_17: /* CIL Label */ 
#line 136
  return ("R_ARM_TLS_DTPMOD32");
  case_18: /* CIL Label */ 
#line 137
  return ("R_ARM_TLS_DTPOFF32");
  case_19: /* CIL Label */ 
#line 138
  return ("R_ARM_TLS_TPOFF32");
  case_20: /* CIL Label */ 
#line 139
  return ("R_ARM_COPY");
  case_21: /* CIL Label */ 
#line 140
  return ("R_ARM_GLOB_DAT");
  case_22: /* CIL Label */ 
#line 141
  return ("R_ARM_JUMP_SLOT");
  case_23: /* CIL Label */ 
#line 142
  return ("R_ARM_RELATIVE");
  case_24: /* CIL Label */ 
#line 143
  return ("R_ARM_GOTOFF32");
  case_25: /* CIL Label */ 
#line 144
  return ("R_ARM_BASE_PREL");
  case_26: /* CIL Label */ 
#line 145
  return ("R_ARM_GOT_BREL");
  case_27: /* CIL Label */ 
#line 146
  return ("R_ARM_PLT32");
  case_28: /* CIL Label */ 
#line 147
  return ("R_ARM_CALL");
  case_29: /* CIL Label */ 
#line 148
  return ("R_ARM_JUMP24");
  case_30: /* CIL Label */ 
#line 149
  return ("R_ARM_THM_JUMP24");
  case_31: /* CIL Label */ 
#line 150
  return ("R_ARM_BASE_ABS");
  case_32: /* CIL Label */ 
#line 151
  return ("R_ARM_ALU_PCREL7_0");
  case_33: /* CIL Label */ 
#line 152
  return ("R_ARM_ALU_PCREL15_8");
  case_34: /* CIL Label */ 
#line 153
  return ("R_ARM_ALU_PCREL23_15");
  case_35: /* CIL Label */ 
#line 154
  return ("R_ARM_LDR_SBREL_11_0");
  case_36: /* CIL Label */ 
#line 155
  return ("R_ARM_ALU_SBREL_19_12");
  case_37: /* CIL Label */ 
#line 156
  return ("R_ARM_ALU_SBREL_27_20");
  case_38: /* CIL Label */ 
#line 157
  return ("R_ARM_TARGET1");
  case_39: /* CIL Label */ 
#line 158
  return ("R_ARM_SBREL31");
  case_40: /* CIL Label */ 
#line 159
  return ("R_ARM_V4BX");
  case_41: /* CIL Label */ 
#line 160
  return ("R_ARM_TARGET2");
  case_42: /* CIL Label */ 
#line 161
  return ("R_ARM_PREL31");
  case_43: /* CIL Label */ 
#line 162
  return ("R_ARM_MOVW_ABS_NC");
  case_44: /* CIL Label */ 
#line 163
  return ("R_ARM_MOVT_ABS");
  case_45: /* CIL Label */ 
#line 164
  return ("R_ARM_MOVW_PREL_NC");
  case_46: /* CIL Label */ 
#line 165
  return ("R_ARM_MOVT_PREL");
  case_47: /* CIL Label */ 
#line 166
  return ("R_ARM_THM_MOVW_ABS_NC");
  case_48: /* CIL Label */ 
#line 167
  return ("R_ARM_THM_MOVT_ABS");
  case_49: /* CIL Label */ 
#line 168
  return ("R_ARM_THM_MOVW_PREL_NC");
  case_50: /* CIL Label */ 
#line 169
  return ("R_ARM_THM_MOVT_PREL");
  case_51: /* CIL Label */ 
#line 170
  return ("R_ARM_THM_JUMP19");
  case_52: /* CIL Label */ 
#line 171
  return ("R_ARM_THM_JUMP6");
  case_53: /* CIL Label */ 
#line 172
  return ("R_ARM_THM_ALU_PREL_11_0");
  case_54: /* CIL Label */ 
#line 173
  return ("R_ARM_THM_PC12");
  case_55: /* CIL Label */ 
#line 174
  return ("R_ARM_ABS32_NOI");
  case_56: /* CIL Label */ 
#line 175
  return ("R_ARM_REL32_NOI");
  case_57: /* CIL Label */ 
#line 176
  return ("R_ARM_ALU_PC_G0_NC");
  case_58: /* CIL Label */ 
#line 177
  return ("R_ARM_ALU_PC_G0");
  case_59: /* CIL Label */ 
#line 178
  return ("R_ARM_ALU_PC_G1_NC");
  case_60: /* CIL Label */ 
#line 179
  return ("R_ARM_ALU_PC_G1");
  case_61: /* CIL Label */ 
#line 180
  return ("R_ARM_ALU_PC_G2");
  case_62: /* CIL Label */ 
#line 181
  return ("R_ARM_LDR_PC_G1");
  case_63: /* CIL Label */ 
#line 182
  return ("R_ARM_LDR_PC_G2");
  case_64: /* CIL Label */ 
#line 183
  return ("R_ARM_LDRS_PC_G0");
  case_65: /* CIL Label */ 
#line 184
  return ("R_ARM_LDRS_PC_G1");
  case_66: /* CIL Label */ 
#line 185
  return ("R_ARM_LDRS_PC_G2");
  case_67: /* CIL Label */ 
#line 186
  return ("R_ARM_LDC_PC_G0");
  case_68: /* CIL Label */ 
#line 187
  return ("R_ARM_LDC_PC_G1");
  case_69: /* CIL Label */ 
#line 188
  return ("R_ARM_LDC_PC_G2");
  case_70: /* CIL Label */ 
#line 189
  return ("R_ARM_ALU_SB_G0_NC");
  case_71: /* CIL Label */ 
#line 190
  return ("R_ARM_ALU_SB_G0");
  case_72: /* CIL Label */ 
#line 191
  return ("R_ARM_ALU_SB_G1_NC");
  case_73: /* CIL Label */ 
#line 192
  return ("R_ARM_ALU_SB_G1");
  case_74: /* CIL Label */ 
#line 193
  return ("R_ARM_ALU_SB_G2");
  case_75: /* CIL Label */ 
#line 194
  return ("R_ARM_LDR_SB_G0");
  case_76: /* CIL Label */ 
#line 195
  return ("R_ARM_LDR_SB_G1");
  case_77: /* CIL Label */ 
#line 196
  return ("R_ARM_LDR_SB_G2");
  case_78: /* CIL Label */ 
#line 197
  return ("R_ARM_LDRS_SB_G0");
  case_79: /* CIL Label */ 
#line 198
  return ("R_ARM_LDRS_SB_G1");
  case_80: /* CIL Label */ 
#line 199
  return ("R_ARM_LDRS_SB_G2");
  case_81: /* CIL Label */ 
#line 200
  return ("R_ARM_LDC_SB_G0");
  case_82: /* CIL Label */ 
#line 201
  return ("R_ARM_LDC_SB_G1");
  case_83: /* CIL Label */ 
#line 202
  return ("R_ARM_LDC_SB_G2");
  case_84: /* CIL Label */ 
#line 203
  return ("R_ARM_MOVW_BREL_NC");
  case_85: /* CIL Label */ 
#line 204
  return ("R_ARM_MOVT_BREL");
  case_86: /* CIL Label */ 
#line 205
  return ("R_ARM_MOVW_BREL");
  case_87: /* CIL Label */ 
#line 206
  return ("R_ARM_THM_MOVW_BREL_NC");
  case_88: /* CIL Label */ 
#line 207
  return ("R_ARM_THM_MOVT_BREL");
  case_89: /* CIL Label */ 
#line 208
  return ("R_ARM_THM_MOVW_BREL");
  case_90: /* CIL Label */ 
#line 209
  return ("R_ARM_TLS_GOTDESC");
  case_91: /* CIL Label */ 
#line 210
  return ("R_ARM_TLS_CALL");
  case_92: /* CIL Label */ 
#line 211
  return ("R_ARM_TLS_DESCSEQ");
  case_93: /* CIL Label */ 
#line 212
  return ("R_ARM_THM_TLS_CALL");
  case_94: /* CIL Label */ 
#line 213
  return ("R_ARM_PLT32_ABS");
  case_95: /* CIL Label */ 
#line 214
  return ("R_ARM_GOT_ABS");
  case_96: /* CIL Label */ 
#line 215
  return ("R_ARM_GOT_PREL");
  case_97: /* CIL Label */ 
#line 216
  return ("R_ARM_GOT_BREL12");
  case_98: /* CIL Label */ 
#line 217
  return ("R_ARM_GOTOFF12");
  case_99: /* CIL Label */ 
#line 218
  return ("R_ARM_GOTRELAX");
  case_100: /* CIL Label */ 
#line 219
  return ("R_ARM_GNU_VTENTRY");
  case_101: /* CIL Label */ 
#line 220
  return ("R_ARM_GNU_VTINHERIT");
  case_102: /* CIL Label */ 
#line 221
  return ("R_ARM_THM_JUMP11");
  case_103: /* CIL Label */ 
#line 222
  return ("R_ARM_THM_JUMP8");
  case_104: /* CIL Label */ 
#line 223
  return ("R_ARM_TLS_GD32");
  case_105: /* CIL Label */ 
#line 224
  return ("R_ARM_TLS_LDM32");
  case_106: /* CIL Label */ 
#line 225
  return ("R_ARM_TLS_LDO32");
  case_107: /* CIL Label */ 
#line 226
  return ("R_ARM_TLS_IE32");
  case_108: /* CIL Label */ 
#line 227
  return ("R_ARM_TLS_LE32");
  case_109: /* CIL Label */ 
#line 228
  return ("R_ARM_TLS_LDO12");
  case_110: /* CIL Label */ 
#line 229
  return ("R_ARM_TLS_LE12");
  case_111: /* CIL Label */ 
#line 230
  return ("R_ARM_TLS_IE12GP");
  case_128: /* CIL Label */ 
#line 232
  return ("R_ARM_ME_TOO");
  case_129: /* CIL Label */ 
#line 233
  return ("R_ARM_THM_TLS_DESCSEQ");
  case_160: /* CIL Label */ 
#line 235
  return ("R_ARM_IRELATIVE");
  case_249: /* CIL Label */ 
#line 238
  return ("R_ARM_RXPC25");
  case_250: /* CIL Label */ 
#line 239
  return ("R_ARM_RSBREL32");
  case_251: /* CIL Label */ 
#line 240
  return ("R_ARM_THM_RPC22");
  case_252: /* CIL Label */ 
#line 241
  return ("R_ARM_RREL32");
  case_253: /* CIL Label */ 
#line 242
  return ("R_ARM_RABS32");
  case_254: /* CIL Label */ 
#line 243
  return ("R_ARM_RPC24");
  case_255: /* CIL Label */ 
#line 244
  return ("R_ARM_RBASE");
  switch_default: /* CIL Label */ 
#line 259
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 53 "./../include/elf/avr.h"
static char const   *elf_avr_reloc_type(unsigned long rtype ) ;
#line 53 "./../include/elf/avr.h"
static char const   *elf_avr_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 54
  if (rtype == 0UL) {
#line 54
    goto case_0;
  }
#line 55
  if (rtype == 1UL) {
#line 55
    goto case_1;
  }
#line 56
  if (rtype == 2UL) {
#line 56
    goto case_2;
  }
#line 57
  if (rtype == 3UL) {
#line 57
    goto case_3;
  }
#line 58
  if (rtype == 4UL) {
#line 58
    goto case_4;
  }
#line 59
  if (rtype == 5UL) {
#line 59
    goto case_5;
  }
#line 60
  if (rtype == 6UL) {
#line 60
    goto case_6;
  }
#line 61
  if (rtype == 7UL) {
#line 61
    goto case_7;
  }
#line 62
  if (rtype == 8UL) {
#line 62
    goto case_8;
  }
#line 63
  if (rtype == 9UL) {
#line 63
    goto case_9;
  }
#line 64
  if (rtype == 10UL) {
#line 64
    goto case_10;
  }
#line 65
  if (rtype == 11UL) {
#line 65
    goto case_11;
  }
#line 66
  if (rtype == 12UL) {
#line 66
    goto case_12;
  }
#line 67
  if (rtype == 13UL) {
#line 67
    goto case_13;
  }
#line 68
  if (rtype == 14UL) {
#line 68
    goto case_14;
  }
#line 69
  if (rtype == 15UL) {
#line 69
    goto case_15;
  }
#line 70
  if (rtype == 16UL) {
#line 70
    goto case_16;
  }
#line 71
  if (rtype == 17UL) {
#line 71
    goto case_17;
  }
#line 72
  if (rtype == 18UL) {
#line 72
    goto case_18;
  }
#line 73
  if (rtype == 19UL) {
#line 73
    goto case_19;
  }
#line 74
  if (rtype == 20UL) {
#line 74
    goto case_20;
  }
#line 75
  if (rtype == 21UL) {
#line 75
    goto case_21;
  }
#line 76
  if (rtype == 22UL) {
#line 76
    goto case_22;
  }
#line 77
  if (rtype == 23UL) {
#line 77
    goto case_23;
  }
#line 78
  if (rtype == 24UL) {
#line 78
    goto case_24;
  }
#line 79
  if (rtype == 25UL) {
#line 79
    goto case_25;
  }
#line 80
  if (rtype == 26UL) {
#line 80
    goto case_26;
  }
#line 81
  if (rtype == 27UL) {
#line 81
    goto case_27;
  }
#line 82
  if (rtype == 28UL) {
#line 82
    goto case_28;
  }
#line 83
  if (rtype == 29UL) {
#line 83
    goto case_29;
  }
#line 84
  goto switch_default;
  case_0: /* CIL Label */ 
#line 54
  return ("R_AVR_NONE");
  case_1: /* CIL Label */ 
#line 55
  return ("R_AVR_32");
  case_2: /* CIL Label */ 
#line 56
  return ("R_AVR_7_PCREL");
  case_3: /* CIL Label */ 
#line 57
  return ("R_AVR_13_PCREL");
  case_4: /* CIL Label */ 
#line 58
  return ("R_AVR_16");
  case_5: /* CIL Label */ 
#line 59
  return ("R_AVR_16_PM");
  case_6: /* CIL Label */ 
#line 60
  return ("R_AVR_LO8_LDI");
  case_7: /* CIL Label */ 
#line 61
  return ("R_AVR_HI8_LDI");
  case_8: /* CIL Label */ 
#line 62
  return ("R_AVR_HH8_LDI");
  case_9: /* CIL Label */ 
#line 63
  return ("R_AVR_LO8_LDI_NEG");
  case_10: /* CIL Label */ 
#line 64
  return ("R_AVR_HI8_LDI_NEG");
  case_11: /* CIL Label */ 
#line 65
  return ("R_AVR_HH8_LDI_NEG");
  case_12: /* CIL Label */ 
#line 66
  return ("R_AVR_LO8_LDI_PM");
  case_13: /* CIL Label */ 
#line 67
  return ("R_AVR_HI8_LDI_PM");
  case_14: /* CIL Label */ 
#line 68
  return ("R_AVR_HH8_LDI_PM");
  case_15: /* CIL Label */ 
#line 69
  return ("R_AVR_LO8_LDI_PM_NEG");
  case_16: /* CIL Label */ 
#line 70
  return ("R_AVR_HI8_LDI_PM_NEG");
  case_17: /* CIL Label */ 
#line 71
  return ("R_AVR_HH8_LDI_PM_NEG");
  case_18: /* CIL Label */ 
#line 72
  return ("R_AVR_CALL");
  case_19: /* CIL Label */ 
#line 73
  return ("R_AVR_LDI");
  case_20: /* CIL Label */ 
#line 74
  return ("R_AVR_6");
  case_21: /* CIL Label */ 
#line 75
  return ("R_AVR_6_ADIW");
  case_22: /* CIL Label */ 
#line 76
  return ("R_AVR_MS8_LDI");
  case_23: /* CIL Label */ 
#line 77
  return ("R_AVR_MS8_LDI_NEG");
  case_24: /* CIL Label */ 
#line 78
  return ("R_AVR_LO8_LDI_GS");
  case_25: /* CIL Label */ 
#line 79
  return ("R_AVR_HI8_LDI_GS");
  case_26: /* CIL Label */ 
#line 80
  return ("R_AVR_8");
  case_27: /* CIL Label */ 
#line 81
  return ("R_AVR_8_LO8");
  case_28: /* CIL Label */ 
#line 82
  return ("R_AVR_8_HI8");
  case_29: /* CIL Label */ 
#line 83
  return ("R_AVR_8_HLO8");
  switch_default: /* CIL Label */ 
#line 84
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 25 "./../include/elf/bfin.h"
static char const   *elf_bfin_reloc_type(unsigned long rtype ) ;
#line 25 "./../include/elf/bfin.h"
static char const   *elf_bfin_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 26
  if (rtype == 0UL) {
#line 26
    goto case_0;
  }
#line 27
  if (rtype == 1UL) {
#line 27
    goto case_1;
  }
#line 28
  if (rtype == 2UL) {
#line 28
    goto case_2;
  }
#line 29
  if (rtype == 3UL) {
#line 29
    goto case_3;
  }
#line 30
  if (rtype == 4UL) {
#line 30
    goto case_4;
  }
#line 31
  if (rtype == 5UL) {
#line 31
    goto case_5;
  }
#line 32
  if (rtype == 6UL) {
#line 32
    goto case_6;
  }
#line 33
  if (rtype == 7UL) {
#line 33
    goto case_7;
  }
#line 34
  if (rtype == 8UL) {
#line 34
    goto case_8;
  }
#line 35
  if (rtype == 9UL) {
#line 35
    goto case_9;
  }
#line 36
  if (rtype == 10UL) {
#line 36
    goto case_10;
  }
#line 37
  if (rtype == 11UL) {
#line 37
    goto case_11;
  }
#line 38
  if (rtype == 12UL) {
#line 38
    goto case_12;
  }
#line 39
  if (rtype == 13UL) {
#line 39
    goto case_13;
  }
#line 40
  if (rtype == 14UL) {
#line 40
    goto case_14;
  }
#line 41
  if (rtype == 15UL) {
#line 41
    goto case_15;
  }
#line 42
  if (rtype == 16UL) {
#line 42
    goto case_16;
  }
#line 43
  if (rtype == 17UL) {
#line 43
    goto case_17;
  }
#line 44
  if (rtype == 18UL) {
#line 44
    goto case_18;
  }
#line 45
  if (rtype == 19UL) {
#line 45
    goto case_19;
  }
#line 46
  if (rtype == 20UL) {
#line 46
    goto case_20;
  }
#line 47
  if (rtype == 21UL) {
#line 47
    goto case_21;
  }
#line 48
  if (rtype == 22UL) {
#line 48
    goto case_22;
  }
#line 49
  if (rtype == 23UL) {
#line 49
    goto case_23;
  }
#line 50
  if (rtype == 24UL) {
#line 50
    goto case_24;
  }
#line 51
  if (rtype == 25UL) {
#line 51
    goto case_25;
  }
#line 52
  if (rtype == 26UL) {
#line 52
    goto case_26;
  }
#line 53
  if (rtype == 27UL) {
#line 53
    goto case_27;
  }
#line 54
  if (rtype == 28UL) {
#line 54
    goto case_28;
  }
#line 55
  if (rtype == 29UL) {
#line 55
    goto case_29;
  }
#line 56
  if (rtype == 30UL) {
#line 56
    goto case_30;
  }
#line 57
  if (rtype == 31UL) {
#line 57
    goto case_31;
  }
#line 58
  if (rtype == 32UL) {
#line 58
    goto case_32;
  }
#line 59
  if (rtype == 33UL) {
#line 59
    goto case_33;
  }
#line 61
  if (rtype == 224UL) {
#line 61
    goto case_224;
  }
#line 62
  if (rtype == 225UL) {
#line 62
    goto case_225;
  }
#line 63
  if (rtype == 226UL) {
#line 63
    goto case_226;
  }
#line 64
  if (rtype == 227UL) {
#line 64
    goto case_227;
  }
#line 65
  if (rtype == 228UL) {
#line 65
    goto case_228;
  }
#line 66
  if (rtype == 229UL) {
#line 66
    goto case_229;
  }
#line 67
  if (rtype == 230UL) {
#line 67
    goto case_230;
  }
#line 68
  if (rtype == 231UL) {
#line 68
    goto case_231;
  }
#line 69
  if (rtype == 232UL) {
#line 69
    goto case_232;
  }
#line 70
  if (rtype == 233UL) {
#line 70
    goto case_233;
  }
#line 71
  if (rtype == 234UL) {
#line 71
    goto case_234;
  }
#line 72
  if (rtype == 235UL) {
#line 72
    goto case_235;
  }
#line 73
  if (rtype == 236UL) {
#line 73
    goto case_236;
  }
#line 74
  if (rtype == 237UL) {
#line 74
    goto case_237;
  }
#line 75
  if (rtype == 238UL) {
#line 75
    goto case_238;
  }
#line 76
  if (rtype == 239UL) {
#line 76
    goto case_239;
  }
#line 77
  if (rtype == 240UL) {
#line 77
    goto case_240;
  }
#line 78
  if (rtype == 241UL) {
#line 78
    goto case_241;
  }
#line 79
  if (rtype == 242UL) {
#line 79
    goto case_242;
  }
#line 80
  if (rtype == 243UL) {
#line 80
    goto case_243;
  }
#line 81
  if (rtype == 64UL) {
#line 81
    goto case_64;
  }
#line 82
  if (rtype == 65UL) {
#line 82
    goto case_65;
  }
#line 83
  if (rtype == 66UL) {
#line 83
    goto case_66;
  }
#line 84
  if (rtype == 67UL) {
#line 84
    goto case_67;
  }
#line 85
  goto switch_default;
  case_0: /* CIL Label */ 
#line 26
  return ("R_BFIN_UNUSED0");
  case_1: /* CIL Label */ 
#line 27
  return ("R_BFIN_PCREL5M2");
  case_2: /* CIL Label */ 
#line 28
  return ("R_BFIN_UNUSED1");
  case_3: /* CIL Label */ 
#line 29
  return ("R_BFIN_PCREL10");
  case_4: /* CIL Label */ 
#line 30
  return ("R_BFIN_PCREL12_JUMP");
  case_5: /* CIL Label */ 
#line 31
  return ("R_BFIN_RIMM16");
  case_6: /* CIL Label */ 
#line 32
  return ("R_BFIN_LUIMM16");
  case_7: /* CIL Label */ 
#line 33
  return ("R_BFIN_HUIMM16");
  case_8: /* CIL Label */ 
#line 34
  return ("R_BFIN_PCREL12_JUMP_S");
  case_9: /* CIL Label */ 
#line 35
  return ("R_BFIN_PCREL24_JUMP_X");
  case_10: /* CIL Label */ 
#line 36
  return ("R_BFIN_PCREL24");
  case_11: /* CIL Label */ 
#line 37
  return ("R_BFIN_UNUSEDB");
  case_12: /* CIL Label */ 
#line 38
  return ("R_BFIN_UNUSEDC");
  case_13: /* CIL Label */ 
#line 39
  return ("R_BFIN_PCREL24_JUMP_L");
  case_14: /* CIL Label */ 
#line 40
  return ("R_BFIN_PCREL24_CALL_X");
  case_15: /* CIL Label */ 
#line 41
  return ("R_BFIN_VAR_EQ_SYMB");
  case_16: /* CIL Label */ 
#line 42
  return ("R_BFIN_BYTE_DATA");
  case_17: /* CIL Label */ 
#line 43
  return ("R_BFIN_BYTE2_DATA");
  case_18: /* CIL Label */ 
#line 44
  return ("R_BFIN_BYTE4_DATA");
  case_19: /* CIL Label */ 
#line 45
  return ("R_BFIN_PCREL11");
  case_20: /* CIL Label */ 
#line 46
  return ("R_BFIN_GOT17M4");
  case_21: /* CIL Label */ 
#line 47
  return ("R_BFIN_GOTHI");
  case_22: /* CIL Label */ 
#line 48
  return ("R_BFIN_GOTLO");
  case_23: /* CIL Label */ 
#line 49
  return ("R_BFIN_FUNCDESC");
  case_24: /* CIL Label */ 
#line 50
  return ("R_BFIN_FUNCDESC_GOT17M4");
  case_25: /* CIL Label */ 
#line 51
  return ("R_BFIN_FUNCDESC_GOTHI");
  case_26: /* CIL Label */ 
#line 52
  return ("R_BFIN_FUNCDESC_GOTLO");
  case_27: /* CIL Label */ 
#line 53
  return ("R_BFIN_FUNCDESC_VALUE");
  case_28: /* CIL Label */ 
#line 54
  return ("R_BFIN_FUNCDESC_GOTOFF17M4");
  case_29: /* CIL Label */ 
#line 55
  return ("R_BFIN_FUNCDESC_GOTOFFHI");
  case_30: /* CIL Label */ 
#line 56
  return ("R_BFIN_FUNCDESC_GOTOFFLO");
  case_31: /* CIL Label */ 
#line 57
  return ("R_BFIN_GOTOFF17M4");
  case_32: /* CIL Label */ 
#line 58
  return ("R_BFIN_GOTOFFHI");
  case_33: /* CIL Label */ 
#line 59
  return ("R_BFIN_GOTOFFLO");
  case_224: /* CIL Label */ 
#line 61
  return ("R_BFIN_PUSH");
  case_225: /* CIL Label */ 
#line 62
  return ("R_BFIN_CONST");
  case_226: /* CIL Label */ 
#line 63
  return ("R_BFIN_ADD");
  case_227: /* CIL Label */ 
#line 64
  return ("R_BFIN_SUB");
  case_228: /* CIL Label */ 
#line 65
  return ("R_BFIN_MULT");
  case_229: /* CIL Label */ 
#line 66
  return ("R_BFIN_DIV");
  case_230: /* CIL Label */ 
#line 67
  return ("R_BFIN_MOD");
  case_231: /* CIL Label */ 
#line 68
  return ("R_BFIN_LSHIFT");
  case_232: /* CIL Label */ 
#line 69
  return ("R_BFIN_RSHIFT");
  case_233: /* CIL Label */ 
#line 70
  return ("R_BFIN_AND");
  case_234: /* CIL Label */ 
#line 71
  return ("R_BFIN_OR");
  case_235: /* CIL Label */ 
#line 72
  return ("R_BFIN_XOR");
  case_236: /* CIL Label */ 
#line 73
  return ("R_BFIN_LAND");
  case_237: /* CIL Label */ 
#line 74
  return ("R_BFIN_LOR");
  case_238: /* CIL Label */ 
#line 75
  return ("R_BFIN_LEN");
  case_239: /* CIL Label */ 
#line 76
  return ("R_BFIN_NEG");
  case_240: /* CIL Label */ 
#line 77
  return ("R_BFIN_COMP");
  case_241: /* CIL Label */ 
#line 78
  return ("R_BFIN_PAGE");
  case_242: /* CIL Label */ 
#line 79
  return ("R_BFIN_HWPAGE");
  case_243: /* CIL Label */ 
#line 80
  return ("R_BFIN_ADDR");
  case_64: /* CIL Label */ 
#line 81
  return ("R_BFIN_PLTPC");
  case_65: /* CIL Label */ 
#line 82
  return ("R_BFIN_GOT");
  case_66: /* CIL Label */ 
#line 83
  return ("R_BFIN_GNU_VTINHERIT");
  case_67: /* CIL Label */ 
#line 84
  return ("R_BFIN_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 85
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/cr16.h"
static char const   *elf_cr16_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/cr16.h"
static char const   *elf_cr16_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  if (rtype == 18UL) {
#line 46
    goto case_18;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 51
  if (rtype == 23UL) {
#line 51
    goto case_23;
  }
#line 52
  if (rtype == 24UL) {
#line 52
    goto case_24;
  }
#line 53
  if (rtype == 25UL) {
#line 53
    goto case_25;
  }
#line 54
  if (rtype == 26UL) {
#line 54
    goto case_26;
  }
#line 55
  if (rtype == 27UL) {
#line 55
    goto case_27;
  }
#line 56
  if (rtype == 28UL) {
#line 56
    goto case_28;
  }
#line 57
  if (rtype == 29UL) {
#line 57
    goto case_29;
  }
#line 58
  if (rtype == 30UL) {
#line 58
    goto case_30;
  }
#line 59
  if (rtype == 31UL) {
#line 59
    goto case_31;
  }
#line 60
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_CR16_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_CR16_NUM8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_CR16_NUM16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_CR16_NUM32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_CR16_NUM32a");
  case_5: /* CIL Label */ 
#line 33
  return ("R_CR16_REGREL4");
  case_6: /* CIL Label */ 
#line 34
  return ("R_CR16_REGREL4a");
  case_7: /* CIL Label */ 
#line 35
  return ("R_CR16_REGREL14");
  case_8: /* CIL Label */ 
#line 36
  return ("R_CR16_REGREL14a");
  case_9: /* CIL Label */ 
#line 37
  return ("R_CR16_REGREL16");
  case_10: /* CIL Label */ 
#line 38
  return ("R_CR16_REGREL20");
  case_11: /* CIL Label */ 
#line 39
  return ("R_CR16_REGREL20a");
  case_12: /* CIL Label */ 
#line 40
  return ("R_CR16_ABS20");
  case_13: /* CIL Label */ 
#line 41
  return ("R_CR16_ABS24");
  case_14: /* CIL Label */ 
#line 42
  return ("R_CR16_IMM4");
  case_15: /* CIL Label */ 
#line 43
  return ("R_CR16_IMM8");
  case_16: /* CIL Label */ 
#line 44
  return ("R_CR16_IMM16");
  case_17: /* CIL Label */ 
#line 45
  return ("R_CR16_IMM20");
  case_18: /* CIL Label */ 
#line 46
  return ("R_CR16_IMM24");
  case_19: /* CIL Label */ 
#line 47
  return ("R_CR16_IMM32");
  case_20: /* CIL Label */ 
#line 48
  return ("R_CR16_IMM32a");
  case_21: /* CIL Label */ 
#line 49
  return ("R_CR16_DISP4");
  case_22: /* CIL Label */ 
#line 50
  return ("R_CR16_DISP8");
  case_23: /* CIL Label */ 
#line 51
  return ("R_CR16_DISP16");
  case_24: /* CIL Label */ 
#line 52
  return ("R_CR16_DISP24");
  case_25: /* CIL Label */ 
#line 53
  return ("R_CR16_DISP24a");
  case_26: /* CIL Label */ 
#line 54
  return ("R_CR16_SWITCH8");
  case_27: /* CIL Label */ 
#line 55
  return ("R_CR16_SWITCH16");
  case_28: /* CIL Label */ 
#line 56
  return ("R_CR16_SWITCH32");
  case_29: /* CIL Label */ 
#line 57
  return ("R_CR16_GOT_REGREL20");
  case_30: /* CIL Label */ 
#line 58
  return ("R_CR16_GOTC_REGREL20");
  case_31: /* CIL Label */ 
#line 59
  return ("R_CR16_GLOB_DAT");
  switch_default: /* CIL Label */ 
#line 60
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/cris.h"
static char const   *elf_cris_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/cris.h"
static char const   *elf_cris_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 39
  if (rtype == 7UL) {
#line 39
    goto case_7;
  }
#line 40
  if (rtype == 8UL) {
#line 40
    goto case_8;
  }
#line 44
  if (rtype == 9UL) {
#line 44
    goto case_9;
  }
#line 48
  if (rtype == 10UL) {
#line 48
    goto case_10;
  }
#line 52
  if (rtype == 11UL) {
#line 52
    goto case_11;
  }
#line 56
  if (rtype == 12UL) {
#line 56
    goto case_12;
  }
#line 61
  if (rtype == 13UL) {
#line 61
    goto case_13;
  }
#line 66
  if (rtype == 14UL) {
#line 66
    goto case_14;
  }
#line 71
  if (rtype == 15UL) {
#line 71
    goto case_15;
  }
#line 76
  if (rtype == 16UL) {
#line 76
    goto case_16;
  }
#line 81
  if (rtype == 17UL) {
#line 81
    goto case_17;
  }
#line 86
  if (rtype == 18UL) {
#line 86
    goto case_18;
  }
#line 92
  if (rtype == 19UL) {
#line 92
    goto case_19;
  }
#line 99
  if (rtype == 20UL) {
#line 99
    goto case_20;
  }
#line 107
  if (rtype == 21UL) {
#line 107
    goto case_21;
  }
#line 112
  if (rtype == 22UL) {
#line 112
    goto case_22;
  }
#line 118
  if (rtype == 23UL) {
#line 118
    goto case_23;
  }
#line 127
  if (rtype == 24UL) {
#line 127
    goto case_24;
  }
#line 134
  if (rtype == 25UL) {
#line 134
    goto case_25;
  }
#line 141
  if (rtype == 26UL) {
#line 141
    goto case_26;
  }
#line 146
  if (rtype == 27UL) {
#line 146
    goto case_27;
  }
#line 153
  if (rtype == 28UL) {
#line 153
    goto case_28;
  }
#line 162
  if (rtype == 29UL) {
#line 162
    goto case_29;
  }
#line 167
  if (rtype == 30UL) {
#line 167
    goto case_30;
  }
#line 172
  if (rtype == 31UL) {
#line 172
    goto case_31;
  }
#line 176
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_CRIS_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_CRIS_8");
  case_2: /* CIL Label */ 
#line 31
  return ("R_CRIS_16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_CRIS_32");
  case_4: /* CIL Label */ 
#line 35
  return ("R_CRIS_8_PCREL");
  case_5: /* CIL Label */ 
#line 36
  return ("R_CRIS_16_PCREL");
  case_6: /* CIL Label */ 
#line 37
  return ("R_CRIS_32_PCREL");
  case_7: /* CIL Label */ 
#line 39
  return ("R_CRIS_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 40
  return ("R_CRIS_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 44
  return ("R_CRIS_COPY");
  case_10: /* CIL Label */ 
#line 48
  return ("R_CRIS_GLOB_DAT");
  case_11: /* CIL Label */ 
#line 52
  return ("R_CRIS_JUMP_SLOT");
  case_12: /* CIL Label */ 
#line 56
  return ("R_CRIS_RELATIVE");
  case_13: /* CIL Label */ 
#line 61
  return ("R_CRIS_16_GOT");
  case_14: /* CIL Label */ 
#line 66
  return ("R_CRIS_32_GOT");
  case_15: /* CIL Label */ 
#line 71
  return ("R_CRIS_16_GOTPLT");
  case_16: /* CIL Label */ 
#line 76
  return ("R_CRIS_32_GOTPLT");
  case_17: /* CIL Label */ 
#line 81
  return ("R_CRIS_32_GOTREL");
  case_18: /* CIL Label */ 
#line 86
  return ("R_CRIS_32_PLT_GOTREL");
  case_19: /* CIL Label */ 
#line 92
  return ("R_CRIS_32_PLT_PCREL");
  case_20: /* CIL Label */ 
#line 99
  return ("R_CRIS_32_GOT_GD");
  case_21: /* CIL Label */ 
#line 107
  return ("R_CRIS_16_GOT_GD");
  case_22: /* CIL Label */ 
#line 112
  return ("R_CRIS_32_GD");
  case_23: /* CIL Label */ 
#line 118
  return ("R_CRIS_DTP");
  case_24: /* CIL Label */ 
#line 127
  return ("R_CRIS_32_DTPREL");
  case_25: /* CIL Label */ 
#line 134
  return ("R_CRIS_16_DTPREL");
  case_26: /* CIL Label */ 
#line 141
  return ("R_CRIS_32_GOT_TPREL");
  case_27: /* CIL Label */ 
#line 146
  return ("R_CRIS_16_GOT_TPREL");
  case_28: /* CIL Label */ 
#line 153
  return ("R_CRIS_32_TPREL");
  case_29: /* CIL Label */ 
#line 162
  return ("R_CRIS_16_TPREL");
  case_30: /* CIL Label */ 
#line 167
  return ("R_CRIS_DTPMOD");
  case_31: /* CIL Label */ 
#line 172
  return ("R_CRIS_32_IE");
  switch_default: /* CIL Label */ 
#line 176
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/crx.h"
static char const   *elf_crx_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/crx.h"
static char const   *elf_crx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 44
  if (rtype == 14UL) {
#line 44
    goto case_14;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 50
  if (rtype == 20UL) {
#line 50
    goto case_20;
  }
#line 51
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_CRX_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_CRX_REL4");
  case_2: /* CIL Label */ 
#line 32
  return ("R_CRX_REL8");
  case_3: /* CIL Label */ 
#line 33
  return ("R_CRX_REL8_CMP");
  case_4: /* CIL Label */ 
#line 34
  return ("R_CRX_REL16");
  case_5: /* CIL Label */ 
#line 35
  return ("R_CRX_REL24");
  case_6: /* CIL Label */ 
#line 36
  return ("R_CRX_REL32");
  case_7: /* CIL Label */ 
#line 37
  return ("R_CRX_REGREL12");
  case_8: /* CIL Label */ 
#line 38
  return ("R_CRX_REGREL22");
  case_9: /* CIL Label */ 
#line 39
  return ("R_CRX_REGREL28");
  case_10: /* CIL Label */ 
#line 40
  return ("R_CRX_REGREL32");
  case_11: /* CIL Label */ 
#line 41
  return ("R_CRX_ABS16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_CRX_ABS32");
  case_13: /* CIL Label */ 
#line 43
  return ("R_CRX_NUM8");
  case_14: /* CIL Label */ 
#line 44
  return ("R_CRX_NUM16");
  case_15: /* CIL Label */ 
#line 45
  return ("R_CRX_NUM32");
  case_16: /* CIL Label */ 
#line 46
  return ("R_CRX_IMM16");
  case_17: /* CIL Label */ 
#line 47
  return ("R_CRX_IMM32");
  case_18: /* CIL Label */ 
#line 48
  return ("R_CRX_SWITCH8");
  case_19: /* CIL Label */ 
#line 49
  return ("R_CRX_SWITCH16");
  case_20: /* CIL Label */ 
#line 50
  return ("R_CRX_SWITCH32");
  switch_default: /* CIL Label */ 
#line 51
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/d10v.h"
static char const   *elf_d10v_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/d10v.h"
static char const   *elf_d10v_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_D10V_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_D10V_10_PCREL_R");
  case_2: /* CIL Label */ 
#line 29
  return ("R_D10V_10_PCREL_L");
  case_3: /* CIL Label */ 
#line 30
  return ("R_D10V_16");
  case_4: /* CIL Label */ 
#line 31
  return ("R_D10V_18");
  case_5: /* CIL Label */ 
#line 32
  return ("R_D10V_18_PCREL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_D10V_32");
  case_7: /* CIL Label */ 
#line 34
  return ("R_D10V_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 35
  return ("R_D10V_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 36
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/d30v.h"
static char const   *elf_d30v_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/d30v.h"
static char const   *elf_d30v_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_D30V_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_D30V_6");
  case_2: /* CIL Label */ 
#line 29
  return ("R_D30V_9_PCREL");
  case_3: /* CIL Label */ 
#line 30
  return ("R_D30V_9_PCREL_R");
  case_4: /* CIL Label */ 
#line 31
  return ("R_D30V_15");
  case_5: /* CIL Label */ 
#line 32
  return ("R_D30V_15_PCREL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_D30V_15_PCREL_R");
  case_7: /* CIL Label */ 
#line 34
  return ("R_D30V_21");
  case_8: /* CIL Label */ 
#line 35
  return ("R_D30V_21_PCREL");
  case_9: /* CIL Label */ 
#line 36
  return ("R_D30V_21_PCREL_R");
  case_10: /* CIL Label */ 
#line 37
  return ("R_D30V_32");
  case_11: /* CIL Label */ 
#line 38
  return ("R_D30V_32_PCREL");
  case_12: /* CIL Label */ 
#line 39
  return ("R_D30V_32_NORMAL");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 39 "./../include/elf/dlx.h"
static char const   *elf_dlx_reloc_type(unsigned long rtype ) ;
#line 39 "./../include/elf/dlx.h"
static char const   *elf_dlx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 40
  if (rtype == 0UL) {
#line 40
    goto case_0;
  }
#line 41
  if (rtype == 1UL) {
#line 41
    goto case_1;
  }
#line 42
  if (rtype == 2UL) {
#line 42
    goto case_2;
  }
#line 43
  if (rtype == 3UL) {
#line 43
    goto case_3;
  }
#line 44
  if (rtype == 4UL) {
#line 44
    goto case_4;
  }
#line 45
  if (rtype == 5UL) {
#line 45
    goto case_5;
  }
#line 46
  if (rtype == 6UL) {
#line 46
    goto case_6;
  }
#line 47
  if (rtype == 7UL) {
#line 47
    goto case_7;
  }
#line 48
  if (rtype == 8UL) {
#line 48
    goto case_8;
  }
#line 49
  if (rtype == 9UL) {
#line 49
    goto case_9;
  }
#line 50
  goto switch_default;
  case_0: /* CIL Label */ 
#line 40
  return ("R_DLX_NONE");
  case_1: /* CIL Label */ 
#line 41
  return ("R_DLX_RELOC_8");
  case_2: /* CIL Label */ 
#line 42
  return ("R_DLX_RELOC_16");
  case_3: /* CIL Label */ 
#line 43
  return ("R_DLX_RELOC_32");
  case_4: /* CIL Label */ 
#line 44
  return ("R_DLX_GNU_VTINHERIT");
  case_5: /* CIL Label */ 
#line 45
  return ("R_DLX_GNU_VTENTRY");
  case_6: /* CIL Label */ 
#line 46
  return ("R_DLX_RELOC_16_HI");
  case_7: /* CIL Label */ 
#line 47
  return ("R_DLX_RELOC_16_LO");
  case_8: /* CIL Label */ 
#line 48
  return ("R_DLX_RELOC_16_PCREL");
  case_9: /* CIL Label */ 
#line 49
  return ("R_DLX_RELOC_26_PCREL");
  switch_default: /* CIL Label */ 
#line 50
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/epiphany.h"
static char const   *elf_epiphany_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/epiphany.h"
static char const   *elf_epiphany_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 36
  if (rtype == 4UL) {
#line 36
    goto case_4;
  }
#line 37
  if (rtype == 5UL) {
#line 37
    goto case_5;
  }
#line 38
  if (rtype == 6UL) {
#line 38
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 50
  if (rtype == 11UL) {
#line 50
    goto case_11;
  }
#line 52
  if (rtype == 12UL) {
#line 52
    goto case_12;
  }
#line 55
  if (rtype == 13UL) {
#line 55
    goto case_13;
  }
#line 57
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_EPIPHANY_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_EPIPHANY_8");
  case_2: /* CIL Label */ 
#line 32
  return ("R_EPIPHANY_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_EPIPHANY_32");
  case_4: /* CIL Label */ 
#line 36
  return ("R_EPIPHANY_8_PCREL");
  case_5: /* CIL Label */ 
#line 37
  return ("R_EPIPHANY_16_PCREL");
  case_6: /* CIL Label */ 
#line 38
  return ("R_EPIPHANY_32_PCREL");
  case_7: /* CIL Label */ 
#line 41
  return ("R_EPIPHANY_SIMM8");
  case_8: /* CIL Label */ 
#line 42
  return ("R_EPIPHANY_SIMM24");
  case_9: /* CIL Label */ 
#line 46
  return ("R_EPIPHANY_HIGH");
  case_10: /* CIL Label */ 
#line 47
  return ("R_EPIPHANY_LOW");
  case_11: /* CIL Label */ 
#line 50
  return ("R_EPIPHANY_SIMM11");
  case_12: /* CIL Label */ 
#line 52
  return ("R_EPIPHANY_IMM11");
  case_13: /* CIL Label */ 
#line 55
  return ("R_EPIPHANY_IMM8");
  switch_default: /* CIL Label */ 
#line 57
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/fr30.h"
static char const   *elf_fr30_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/fr30.h"
static char const   *elf_fr30_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_FR30_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_FR30_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_FR30_20");
  case_3: /* CIL Label */ 
#line 30
  return ("R_FR30_32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_FR30_48");
  case_5: /* CIL Label */ 
#line 32
  return ("R_FR30_6_IN_4");
  case_6: /* CIL Label */ 
#line 33
  return ("R_FR30_8_IN_8");
  case_7: /* CIL Label */ 
#line 34
  return ("R_FR30_9_IN_8");
  case_8: /* CIL Label */ 
#line 35
  return ("R_FR30_10_IN_8");
  case_9: /* CIL Label */ 
#line 36
  return ("R_FR30_9_PCREL");
  case_10: /* CIL Label */ 
#line 37
  return ("R_FR30_12_PCREL");
  case_11: /* CIL Label */ 
#line 38
  return ("R_FR30_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 39
  return ("R_FR30_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/frv.h"
static char const   *elf_frv_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/frv.h"
static char const   *elf_frv_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 65
  if (rtype == 38UL) {
#line 65
    goto case_38;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 200UL) {
#line 68
    goto case_200;
  }
#line 69
  if (rtype == 201UL) {
#line 69
    goto case_201;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_FRV_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_FRV_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_FRV_LABEL16");
  case_3: /* CIL Label */ 
#line 30
  return ("R_FRV_LABEL24");
  case_4: /* CIL Label */ 
#line 31
  return ("R_FRV_LO16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_FRV_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_FRV_GPREL12");
  case_7: /* CIL Label */ 
#line 34
  return ("R_FRV_GPRELU12");
  case_8: /* CIL Label */ 
#line 35
  return ("R_FRV_GPREL32");
  case_9: /* CIL Label */ 
#line 36
  return ("R_FRV_GPRELHI");
  case_10: /* CIL Label */ 
#line 37
  return ("R_FRV_GPRELLO");
  case_11: /* CIL Label */ 
#line 38
  return ("R_FRV_GOT12");
  case_12: /* CIL Label */ 
#line 39
  return ("R_FRV_GOTHI");
  case_13: /* CIL Label */ 
#line 40
  return ("R_FRV_GOTLO");
  case_14: /* CIL Label */ 
#line 41
  return ("R_FRV_FUNCDESC");
  case_15: /* CIL Label */ 
#line 42
  return ("R_FRV_FUNCDESC_GOT12");
  case_16: /* CIL Label */ 
#line 43
  return ("R_FRV_FUNCDESC_GOTHI");
  case_17: /* CIL Label */ 
#line 44
  return ("R_FRV_FUNCDESC_GOTLO");
  case_18: /* CIL Label */ 
#line 45
  return ("R_FRV_FUNCDESC_VALUE");
  case_19: /* CIL Label */ 
#line 46
  return ("R_FRV_FUNCDESC_GOTOFF12");
  case_20: /* CIL Label */ 
#line 47
  return ("R_FRV_FUNCDESC_GOTOFFHI");
  case_21: /* CIL Label */ 
#line 48
  return ("R_FRV_FUNCDESC_GOTOFFLO");
  case_22: /* CIL Label */ 
#line 49
  return ("R_FRV_GOTOFF12");
  case_23: /* CIL Label */ 
#line 50
  return ("R_FRV_GOTOFFHI");
  case_24: /* CIL Label */ 
#line 51
  return ("R_FRV_GOTOFFLO");
  case_25: /* CIL Label */ 
#line 52
  return ("R_FRV_GETTLSOFF");
  case_26: /* CIL Label */ 
#line 53
  return ("R_FRV_TLSDESC_VALUE");
  case_27: /* CIL Label */ 
#line 54
  return ("R_FRV_GOTTLSDESC12");
  case_28: /* CIL Label */ 
#line 55
  return ("R_FRV_GOTTLSDESCHI");
  case_29: /* CIL Label */ 
#line 56
  return ("R_FRV_GOTTLSDESCLO");
  case_30: /* CIL Label */ 
#line 57
  return ("R_FRV_TLSMOFF12");
  case_31: /* CIL Label */ 
#line 58
  return ("R_FRV_TLSMOFFHI");
  case_32: /* CIL Label */ 
#line 59
  return ("R_FRV_TLSMOFFLO");
  case_33: /* CIL Label */ 
#line 60
  return ("R_FRV_GOTTLSOFF12");
  case_34: /* CIL Label */ 
#line 61
  return ("R_FRV_GOTTLSOFFHI");
  case_35: /* CIL Label */ 
#line 62
  return ("R_FRV_GOTTLSOFFLO");
  case_36: /* CIL Label */ 
#line 63
  return ("R_FRV_TLSOFF");
  case_37: /* CIL Label */ 
#line 64
  return ("R_FRV_TLSDESC_RELAX");
  case_38: /* CIL Label */ 
#line 65
  return ("R_FRV_GETTLSOFF_RELAX");
  case_39: /* CIL Label */ 
#line 66
  return ("R_FRV_TLSOFF_RELAX");
  case_40: /* CIL Label */ 
#line 67
  return ("R_FRV_TLSMOFF");
  case_200: /* CIL Label */ 
#line 68
  return ("R_FRV_GNU_VTINHERIT");
  case_201: /* CIL Label */ 
#line 69
  return ("R_FRV_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 70
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/h8.h"
static char const   *elf_h8_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/h8.h"
static char const   *elf_h8_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 63
  if (rtype == 59UL) {
#line 63
    goto case_59;
  }
#line 64
  if (rtype == 60UL) {
#line 64
    goto case_60;
  }
#line 65
  if (rtype == 61UL) {
#line 65
    goto case_61;
  }
#line 66
  if (rtype == 62UL) {
#line 66
    goto case_62;
  }
#line 67
  if (rtype == 63UL) {
#line 67
    goto case_63;
  }
#line 68
  if (rtype == 64UL) {
#line 68
    goto case_64;
  }
#line 69
  if (rtype == 65UL) {
#line 69
    goto case_65;
  }
#line 70
  if (rtype == 127UL) {
#line 70
    goto case_127;
  }
#line 71
  if (rtype == 128UL) {
#line 71
    goto case_128;
  }
#line 72
  if (rtype == 129UL) {
#line 72
    goto case_129;
  }
#line 73
  if (rtype == 130UL) {
#line 73
    goto case_130;
  }
#line 74
  if (rtype == 131UL) {
#line 74
    goto case_131;
  }
#line 75
  if (rtype == 132UL) {
#line 75
    goto case_132;
  }
#line 76
  if (rtype == 133UL) {
#line 76
    goto case_133;
  }
#line 77
  if (rtype == 134UL) {
#line 77
    goto case_134;
  }
#line 78
  if (rtype == 135UL) {
#line 78
    goto case_135;
  }
#line 79
  if (rtype == 136UL) {
#line 79
    goto case_136;
  }
#line 80
  if (rtype == 137UL) {
#line 80
    goto case_137;
  }
#line 81
  if (rtype == 138UL) {
#line 81
    goto case_138;
  }
#line 82
  if (rtype == 139UL) {
#line 82
    goto case_139;
  }
#line 83
  if (rtype == 140UL) {
#line 83
    goto case_140;
  }
#line 84
  if (rtype == 141UL) {
#line 84
    goto case_141;
  }
#line 85
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_H8_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_H8_DIR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_H8_DIR32_28");
  case_3: /* CIL Label */ 
#line 31
  return ("R_H8_DIR32_24");
  case_4: /* CIL Label */ 
#line 32
  return ("R_H8_DIR32_16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_H8_DIR32U");
  case_7: /* CIL Label */ 
#line 34
  return ("R_H8_DIR32U_28");
  case_8: /* CIL Label */ 
#line 35
  return ("R_H8_DIR32U_24");
  case_9: /* CIL Label */ 
#line 36
  return ("R_H8_DIR32U_20");
  case_10: /* CIL Label */ 
#line 37
  return ("R_H8_DIR32U_16");
  case_11: /* CIL Label */ 
#line 38
  return ("R_H8_DIR24");
  case_12: /* CIL Label */ 
#line 39
  return ("R_H8_DIR24_20");
  case_13: /* CIL Label */ 
#line 40
  return ("R_H8_DIR24_16");
  case_14: /* CIL Label */ 
#line 41
  return ("R_H8_DIR24U");
  case_15: /* CIL Label */ 
#line 42
  return ("R_H8_DIR24U_20");
  case_16: /* CIL Label */ 
#line 43
  return ("R_H8_DIR24U_16");
  case_17: /* CIL Label */ 
#line 44
  return ("R_H8_DIR16");
  case_18: /* CIL Label */ 
#line 45
  return ("R_H8_DIR16U");
  case_19: /* CIL Label */ 
#line 46
  return ("R_H8_DIR16S_32");
  case_20: /* CIL Label */ 
#line 47
  return ("R_H8_DIR16S_28");
  case_21: /* CIL Label */ 
#line 48
  return ("R_H8_DIR16S_24");
  case_22: /* CIL Label */ 
#line 49
  return ("R_H8_DIR16S_20");
  case_23: /* CIL Label */ 
#line 50
  return ("R_H8_DIR16S");
  case_24: /* CIL Label */ 
#line 51
  return ("R_H8_DIR8");
  case_25: /* CIL Label */ 
#line 52
  return ("R_H8_DIR8U");
  case_26: /* CIL Label */ 
#line 53
  return ("R_H8_DIR8Z_32");
  case_27: /* CIL Label */ 
#line 54
  return ("R_H8_DIR8Z_28");
  case_28: /* CIL Label */ 
#line 55
  return ("R_H8_DIR8Z_24");
  case_29: /* CIL Label */ 
#line 56
  return ("R_H8_DIR8Z_20");
  case_30: /* CIL Label */ 
#line 57
  return ("R_H8_DIR8Z_16");
  case_31: /* CIL Label */ 
#line 58
  return ("R_H8_PCREL16");
  case_32: /* CIL Label */ 
#line 59
  return ("R_H8_PCREL8");
  case_33: /* CIL Label */ 
#line 60
  return ("R_H8_BPOS");
  case_59: /* CIL Label */ 
#line 63
  return ("R_H8_DIR16A8");
  case_60: /* CIL Label */ 
#line 64
  return ("R_H8_DIR16R8");
  case_61: /* CIL Label */ 
#line 65
  return ("R_H8_DIR24A8");
  case_62: /* CIL Label */ 
#line 66
  return ("R_H8_DIR24R8");
  case_63: /* CIL Label */ 
#line 67
  return ("R_H8_DIR32A16");
  case_64: /* CIL Label */ 
#line 68
  return ("R_H8_DISP32A16");
  case_65: /* CIL Label */ 
#line 69
  return ("R_H8_ABS32");
  case_127: /* CIL Label */ 
#line 70
  return ("R_H8_ABS32A16");
  case_128: /* CIL Label */ 
#line 71
  return ("R_H8_SYM");
  case_129: /* CIL Label */ 
#line 72
  return ("R_H8_OPneg");
  case_130: /* CIL Label */ 
#line 73
  return ("R_H8_OPadd");
  case_131: /* CIL Label */ 
#line 74
  return ("R_H8_OPsub");
  case_132: /* CIL Label */ 
#line 75
  return ("R_H8_OPmul");
  case_133: /* CIL Label */ 
#line 76
  return ("R_H8_OPdiv");
  case_134: /* CIL Label */ 
#line 77
  return ("R_H8_OPshla");
  case_135: /* CIL Label */ 
#line 78
  return ("R_H8_OPshra");
  case_136: /* CIL Label */ 
#line 79
  return ("R_H8_OPsctsize");
  case_137: /* CIL Label */ 
#line 80
  return ("R_H8_OPhword");
  case_138: /* CIL Label */ 
#line 81
  return ("R_H8_OPlword");
  case_139: /* CIL Label */ 
#line 82
  return ("R_H8_OPhigh");
  case_140: /* CIL Label */ 
#line 83
  return ("R_H8_OPlow");
  case_141: /* CIL Label */ 
#line 84
  return ("R_H8_OPscttop");
  switch_default: /* CIL Label */ 
#line 85
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 111 "./../include/elf/hppa.h"
static char const   *elf_hppa_reloc_type(unsigned long rtype ) ;
#line 111 "./../include/elf/hppa.h"
static char const   *elf_hppa_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 112
  if (rtype == 0UL) {
#line 112
    goto case_0;
  }
#line 116
  if (rtype == 1UL) {
#line 116
    goto case_1;
  }
#line 119
  if (rtype == 2UL) {
#line 119
    goto case_2;
  }
#line 122
  if (rtype == 3UL) {
#line 122
    goto case_3;
  }
#line 125
  if (rtype == 4UL) {
#line 125
    goto case_4;
  }
#line 128
  if (rtype == 6UL) {
#line 128
    goto case_6;
  }
#line 131
  if (rtype == 7UL) {
#line 131
    goto case_7;
  }
#line 148
  if (rtype == 8UL) {
#line 148
    goto case_8;
  }
#line 151
  if (rtype == 9UL) {
#line 151
    goto case_9;
  }
#line 154
  if (rtype == 10UL) {
#line 154
    goto case_10;
  }
#line 157
  if (rtype == 11UL) {
#line 157
    goto case_11;
  }
#line 160
  if (rtype == 12UL) {
#line 160
    goto case_12;
  }
#line 163
  if (rtype == 13UL) {
#line 163
    goto case_13;
  }
#line 166
  if (rtype == 14UL) {
#line 166
    goto case_14;
  }
#line 169
  if (rtype == 15UL) {
#line 169
    goto case_15;
  }
#line 174
  if (rtype == 18UL) {
#line 174
    goto case_18;
  }
#line 177
  if (rtype == 19UL) {
#line 177
    goto case_19;
  }
#line 180
  if (rtype == 20UL) {
#line 180
    goto case_20;
  }
#line 183
  if (rtype == 22UL) {
#line 183
    goto case_22;
  }
#line 186
  if (rtype == 23UL) {
#line 186
    goto case_23;
  }
#line 196
  if (rtype == 26UL) {
#line 196
    goto case_26;
  }
#line 199
  if (rtype == 30UL) {
#line 199
    goto case_30;
  }
#line 202
  if (rtype == 31UL) {
#line 202
    goto case_31;
  }
#line 207
  if (rtype == 34UL) {
#line 207
    goto case_34;
  }
#line 210
  if (rtype == 38UL) {
#line 210
    goto case_38;
  }
#line 213
  if (rtype == 39UL) {
#line 213
    goto case_39;
  }
#line 218
  if (rtype == 40UL) {
#line 218
    goto case_40;
  }
#line 221
  if (rtype == 41UL) {
#line 221
    goto case_41;
  }
#line 224
  if (rtype == 42UL) {
#line 224
    goto case_42;
  }
#line 227
  if (rtype == 43UL) {
#line 227
    goto case_43;
  }
#line 230
  if (rtype == 44UL) {
#line 230
    goto case_44;
  }
#line 233
  if (rtype == 46UL) {
#line 233
    goto case_46;
  }
#line 236
  if (rtype == 47UL) {
#line 236
    goto case_47;
  }
#line 241
  if (rtype == 48UL) {
#line 241
    goto case_48;
  }
#line 244
  if (rtype == 49UL) {
#line 244
    goto case_49;
  }
#line 249
  if (rtype == 50UL) {
#line 249
    goto case_50;
  }
#line 252
  if (rtype == 54UL) {
#line 252
    goto case_54;
  }
#line 255
  if (rtype == 55UL) {
#line 255
    goto case_55;
  }
#line 259
  if (rtype == 57UL) {
#line 259
    goto case_57;
  }
#line 262
  if (rtype == 58UL) {
#line 262
    goto case_58;
  }
#line 265
  if (rtype == 62UL) {
#line 265
    goto case_62;
  }
#line 269
  if (rtype == 64UL) {
#line 269
    goto case_64;
  }
#line 274
  if (rtype == 65UL) {
#line 274
    goto case_65;
  }
#line 277
  if (rtype == 66UL) {
#line 277
    goto case_66;
  }
#line 280
  if (rtype == 70UL) {
#line 280
    goto case_70;
  }
#line 285
  if (rtype == 72UL) {
#line 285
    goto case_72;
  }
#line 288
  if (rtype == 73UL) {
#line 288
    goto case_73;
  }
#line 291
  if (rtype == 74UL) {
#line 291
    goto case_74;
  }
#line 294
  if (rtype == 75UL) {
#line 294
    goto case_75;
  }
#line 297
  if (rtype == 76UL) {
#line 297
    goto case_76;
  }
#line 300
  if (rtype == 77UL) {
#line 300
    goto case_77;
  }
#line 303
  if (rtype == 78UL) {
#line 303
    goto case_78;
  }
#line 306
  if (rtype == 79UL) {
#line 306
    goto case_79;
  }
#line 310
  if (rtype == 80UL) {
#line 310
    goto case_80;
  }
#line 313
  if (rtype == 83UL) {
#line 313
    goto case_83;
  }
#line 316
  if (rtype == 84UL) {
#line 316
    goto case_84;
  }
#line 319
  if (rtype == 85UL) {
#line 319
    goto case_85;
  }
#line 322
  if (rtype == 86UL) {
#line 322
    goto case_86;
  }
#line 325
  if (rtype == 87UL) {
#line 325
    goto case_87;
  }
#line 328
  if (rtype == 88UL) {
#line 328
    goto case_88;
  }
#line 331
  if (rtype == 91UL) {
#line 331
    goto case_91;
  }
#line 334
  if (rtype == 92UL) {
#line 334
    goto case_92;
  }
#line 337
  if (rtype == 93UL) {
#line 337
    goto case_93;
  }
#line 340
  if (rtype == 94UL) {
#line 340
    goto case_94;
  }
#line 343
  if (rtype == 95UL) {
#line 343
    goto case_95;
  }
#line 347
  if (rtype == 96UL) {
#line 347
    goto case_96;
  }
#line 350
  if (rtype == 99UL) {
#line 350
    goto case_99;
  }
#line 353
  if (rtype == 100UL) {
#line 353
    goto case_100;
  }
#line 356
  if (rtype == 101UL) {
#line 356
    goto case_101;
  }
#line 359
  if (rtype == 102UL) {
#line 359
    goto case_102;
  }
#line 362
  if (rtype == 103UL) {
#line 362
    goto case_103;
  }
#line 366
  if (rtype == 104UL) {
#line 366
    goto case_104;
  }
#line 369
  if (rtype == 107UL) {
#line 369
    goto case_107;
  }
#line 372
  if (rtype == 108UL) {
#line 372
    goto case_108;
  }
#line 376
  if (rtype == 112UL) {
#line 376
    goto case_112;
  }
#line 379
  if (rtype == 115UL) {
#line 379
    goto case_115;
  }
#line 382
  if (rtype == 116UL) {
#line 382
    goto case_116;
  }
#line 385
  if (rtype == 117UL) {
#line 385
    goto case_117;
  }
#line 388
  if (rtype == 118UL) {
#line 388
    goto case_118;
  }
#line 391
  if (rtype == 119UL) {
#line 391
    goto case_119;
  }
#line 395
  if (rtype == 120UL) {
#line 395
    goto case_120;
  }
#line 398
  if (rtype == 123UL) {
#line 398
    goto case_123;
  }
#line 401
  if (rtype == 124UL) {
#line 401
    goto case_124;
  }
#line 404
  if (rtype == 125UL) {
#line 404
    goto case_125;
  }
#line 407
  if (rtype == 126UL) {
#line 407
    goto case_126;
  }
#line 410
  if (rtype == 127UL) {
#line 410
    goto case_127;
  }
#line 414
  if (rtype == 128UL) {
#line 414
    goto case_128;
  }
#line 417
  if (rtype == 129UL) {
#line 417
    goto case_129;
  }
#line 420
  if (rtype == 130UL) {
#line 420
    goto case_130;
  }
#line 424
  if (rtype == 153UL) {
#line 424
    goto case_153;
  }
#line 427
  if (rtype == 154UL) {
#line 427
    goto case_154;
  }
#line 430
  if (rtype == 158UL) {
#line 430
    goto case_158;
  }
#line 434
  if (rtype == 162UL) {
#line 434
    goto case_162;
  }
#line 437
  if (rtype == 166UL) {
#line 437
    goto case_166;
  }
#line 440
  if (rtype == 167UL) {
#line 440
    goto case_167;
  }
#line 444
  if (rtype == 216UL) {
#line 444
    goto case_216;
  }
#line 447
  if (rtype == 219UL) {
#line 447
    goto case_219;
  }
#line 450
  if (rtype == 220UL) {
#line 450
    goto case_220;
  }
#line 453
  if (rtype == 221UL) {
#line 453
    goto case_221;
  }
#line 456
  if (rtype == 222UL) {
#line 456
    goto case_222;
  }
#line 459
  if (rtype == 223UL) {
#line 459
    goto case_223;
  }
#line 463
  if (rtype == 224UL) {
#line 463
    goto case_224;
  }
#line 466
  if (rtype == 227UL) {
#line 466
    goto case_227;
  }
#line 469
  if (rtype == 228UL) {
#line 469
    goto case_228;
  }
#line 472
  if (rtype == 229UL) {
#line 472
    goto case_229;
  }
#line 475
  if (rtype == 230UL) {
#line 475
    goto case_230;
  }
#line 478
  if (rtype == 231UL) {
#line 478
    goto case_231;
  }
#line 481
  if (rtype == 232UL) {
#line 481
    goto case_232;
  }
#line 482
  if (rtype == 233UL) {
#line 482
    goto case_233;
  }
#line 484
  if (rtype == 234UL) {
#line 484
    goto case_234;
  }
#line 485
  if (rtype == 235UL) {
#line 485
    goto case_235;
  }
#line 486
  if (rtype == 236UL) {
#line 486
    goto case_236;
  }
#line 487
  if (rtype == 237UL) {
#line 487
    goto case_237;
  }
#line 488
  if (rtype == 238UL) {
#line 488
    goto case_238;
  }
#line 489
  if (rtype == 239UL) {
#line 489
    goto case_239;
  }
#line 490
  if (rtype == 240UL) {
#line 490
    goto case_240;
  }
#line 491
  if (rtype == 241UL) {
#line 491
    goto case_241;
  }
#line 492
  if (rtype == 242UL) {
#line 492
    goto case_242;
  }
#line 493
  if (rtype == 243UL) {
#line 493
    goto case_243;
  }
#line 494
  if (rtype == 244UL) {
#line 494
    goto case_244;
  }
#line 495
  if (rtype == 245UL) {
#line 495
    goto case_245;
  }
#line 497
  goto switch_default;
  case_0: /* CIL Label */ 
#line 112
  return ("R_PARISC_NONE");
  case_1: /* CIL Label */ 
#line 116
  return ("R_PARISC_DIR32");
  case_2: /* CIL Label */ 
#line 119
  return ("R_PARISC_DIR21L");
  case_3: /* CIL Label */ 
#line 122
  return ("R_PARISC_DIR17R");
  case_4: /* CIL Label */ 
#line 125
  return ("R_PARISC_DIR17F");
  case_6: /* CIL Label */ 
#line 128
  return ("R_PARISC_DIR14R");
  case_7: /* CIL Label */ 
#line 131
  return ("R_PARISC_DIR14F");
  case_8: /* CIL Label */ 
#line 148
  return ("R_PARISC_PCREL12F");
  case_9: /* CIL Label */ 
#line 151
  return ("R_PARISC_PCREL32");
  case_10: /* CIL Label */ 
#line 154
  return ("R_PARISC_PCREL21L");
  case_11: /* CIL Label */ 
#line 157
  return ("R_PARISC_PCREL17R");
  case_12: /* CIL Label */ 
#line 160
  return ("R_PARISC_PCREL17F");
  case_13: /* CIL Label */ 
#line 163
  return ("R_PARISC_PCREL17C");
  case_14: /* CIL Label */ 
#line 166
  return ("R_PARISC_PCREL14R");
  case_15: /* CIL Label */ 
#line 169
  return ("R_PARISC_PCREL14F");
  case_18: /* CIL Label */ 
#line 174
  return ("R_PARISC_DPREL21L");
  case_19: /* CIL Label */ 
#line 177
  return ("R_PARISC_DPREL14WR");
  case_20: /* CIL Label */ 
#line 180
  return ("R_PARISC_DPREL14DR");
  case_22: /* CIL Label */ 
#line 183
  return ("R_PARISC_DPREL14R");
  case_23: /* CIL Label */ 
#line 186
  return ("R_PARISC_DPREL14F");
  case_26: /* CIL Label */ 
#line 196
  return ("R_PARISC_DLTREL21L");
  case_30: /* CIL Label */ 
#line 199
  return ("R_PARISC_DLTREL14R");
  case_31: /* CIL Label */ 
#line 202
  return ("R_PARISC_DLTREL14F");
  case_34: /* CIL Label */ 
#line 207
  return ("R_PARISC_DLTIND21L");
  case_38: /* CIL Label */ 
#line 210
  return ("R_PARISC_DLTIND14R");
  case_39: /* CIL Label */ 
#line 213
  return ("R_PARISC_DLTIND14F");
  case_40: /* CIL Label */ 
#line 218
  return ("R_PARISC_SETBASE");
  case_41: /* CIL Label */ 
#line 221
  return ("R_PARISC_SECREL32");
  case_42: /* CIL Label */ 
#line 224
  return ("R_PARISC_BASEREL21L");
  case_43: /* CIL Label */ 
#line 227
  return ("R_PARISC_BASEREL17R");
  case_44: /* CIL Label */ 
#line 230
  return ("R_PARISC_BASEREL17F");
  case_46: /* CIL Label */ 
#line 233
  return ("R_PARISC_BASEREL14R");
  case_47: /* CIL Label */ 
#line 236
  return ("R_PARISC_BASEREL14F");
  case_48: /* CIL Label */ 
#line 241
  return ("R_PARISC_SEGBASE");
  case_49: /* CIL Label */ 
#line 244
  return ("R_PARISC_SEGREL32");
  case_50: /* CIL Label */ 
#line 249
  return ("R_PARISC_PLTOFF21L");
  case_54: /* CIL Label */ 
#line 252
  return ("R_PARISC_PLTOFF14R");
  case_55: /* CIL Label */ 
#line 255
  return ("R_PARISC_PLTOFF14F");
  case_57: /* CIL Label */ 
#line 259
  return ("R_PARISC_LTOFF_FPTR32");
  case_58: /* CIL Label */ 
#line 262
  return ("R_PARISC_LTOFF_FPTR21L");
  case_62: /* CIL Label */ 
#line 265
  return ("R_PARISC_LTOFF_FPTR14R");
  case_64: /* CIL Label */ 
#line 269
  return ("R_PARISC_FPTR64");
  case_65: /* CIL Label */ 
#line 274
  return ("R_PARISC_PLABEL32");
  case_66: /* CIL Label */ 
#line 277
  return ("R_PARISC_PLABEL21L");
  case_70: /* CIL Label */ 
#line 280
  return ("R_PARISC_PLABEL14R");
  case_72: /* CIL Label */ 
#line 285
  return ("R_PARISC_PCREL64");
  case_73: /* CIL Label */ 
#line 288
  return ("R_PARISC_PCREL22C");
  case_74: /* CIL Label */ 
#line 291
  return ("R_PARISC_PCREL22F");
  case_75: /* CIL Label */ 
#line 294
  return ("R_PARISC_PCREL14WR");
  case_76: /* CIL Label */ 
#line 297
  return ("R_PARISC_PCREL14DR");
  case_77: /* CIL Label */ 
#line 300
  return ("R_PARISC_PCREL16F");
  case_78: /* CIL Label */ 
#line 303
  return ("R_PARISC_PCREL16WF");
  case_79: /* CIL Label */ 
#line 306
  return ("R_PARISC_PCREL16DF");
  case_80: /* CIL Label */ 
#line 310
  return ("R_PARISC_DIR64");
  case_83: /* CIL Label */ 
#line 313
  return ("R_PARISC_DIR14WR");
  case_84: /* CIL Label */ 
#line 316
  return ("R_PARISC_DIR14DR");
  case_85: /* CIL Label */ 
#line 319
  return ("R_PARISC_DIR16F");
  case_86: /* CIL Label */ 
#line 322
  return ("R_PARISC_DIR16WF");
  case_87: /* CIL Label */ 
#line 325
  return ("R_PARISC_DIR16DF");
  case_88: /* CIL Label */ 
#line 328
  return ("R_PARISC_GPREL64");
  case_91: /* CIL Label */ 
#line 331
  return ("R_PARISC_DLTREL14WR");
  case_92: /* CIL Label */ 
#line 334
  return ("R_PARISC_DLTREL14DR");
  case_93: /* CIL Label */ 
#line 337
  return ("R_PARISC_GPREL16F");
  case_94: /* CIL Label */ 
#line 340
  return ("R_PARISC_GPREL16WF");
  case_95: /* CIL Label */ 
#line 343
  return ("R_PARISC_GPREL16DF");
  case_96: /* CIL Label */ 
#line 347
  return ("R_PARISC_LTOFF64");
  case_99: /* CIL Label */ 
#line 350
  return ("R_PARISC_DLTIND14WR");
  case_100: /* CIL Label */ 
#line 353
  return ("R_PARISC_DLTIND14DR");
  case_101: /* CIL Label */ 
#line 356
  return ("R_PARISC_LTOFF16F");
  case_102: /* CIL Label */ 
#line 359
  return ("R_PARISC_LTOFF16WF");
  case_103: /* CIL Label */ 
#line 362
  return ("R_PARISC_LTOFF16DF");
  case_104: /* CIL Label */ 
#line 366
  return ("R_PARISC_SECREL64");
  case_107: /* CIL Label */ 
#line 369
  return ("R_PARISC_BASEREL14WR");
  case_108: /* CIL Label */ 
#line 372
  return ("R_PARISC_BASEREL14DR");
  case_112: /* CIL Label */ 
#line 376
  return ("R_PARISC_SEGREL64");
  case_115: /* CIL Label */ 
#line 379
  return ("R_PARISC_PLTOFF14WR");
  case_116: /* CIL Label */ 
#line 382
  return ("R_PARISC_PLTOFF14DR");
  case_117: /* CIL Label */ 
#line 385
  return ("R_PARISC_PLTOFF16F");
  case_118: /* CIL Label */ 
#line 388
  return ("R_PARISC_PLTOFF16WF");
  case_119: /* CIL Label */ 
#line 391
  return ("R_PARISC_PLTOFF16DF");
  case_120: /* CIL Label */ 
#line 395
  return ("R_PARISC_LTOFF_FPTR64");
  case_123: /* CIL Label */ 
#line 398
  return ("R_PARISC_LTOFF_FPTR14WR");
  case_124: /* CIL Label */ 
#line 401
  return ("R_PARISC_LTOFF_FPTR14DR");
  case_125: /* CIL Label */ 
#line 404
  return ("R_PARISC_LTOFF_FPTR16F");
  case_126: /* CIL Label */ 
#line 407
  return ("R_PARISC_LTOFF_FPTR16WF");
  case_127: /* CIL Label */ 
#line 410
  return ("R_PARISC_LTOFF_FPTR16DF");
  case_128: /* CIL Label */ 
#line 414
  return ("R_PARISC_COPY");
  case_129: /* CIL Label */ 
#line 417
  return ("R_PARISC_IPLT");
  case_130: /* CIL Label */ 
#line 420
  return ("R_PARISC_EPLT");
  case_153: /* CIL Label */ 
#line 424
  return ("R_PARISC_TPREL32");
  case_154: /* CIL Label */ 
#line 427
  return ("R_PARISC_TPREL21L");
  case_158: /* CIL Label */ 
#line 430
  return ("R_PARISC_TPREL14R");
  case_162: /* CIL Label */ 
#line 434
  return ("R_PARISC_LTOFF_TP21L");
  case_166: /* CIL Label */ 
#line 437
  return ("R_PARISC_LTOFF_TP14R");
  case_167: /* CIL Label */ 
#line 440
  return ("R_PARISC_LTOFF_TP14F");
  case_216: /* CIL Label */ 
#line 444
  return ("R_PARISC_TPREL64");
  case_219: /* CIL Label */ 
#line 447
  return ("R_PARISC_TPREL14WR");
  case_220: /* CIL Label */ 
#line 450
  return ("R_PARISC_TPREL14DR");
  case_221: /* CIL Label */ 
#line 453
  return ("R_PARISC_TPREL16F");
  case_222: /* CIL Label */ 
#line 456
  return ("R_PARISC_TPREL16WF");
  case_223: /* CIL Label */ 
#line 459
  return ("R_PARISC_TPREL16DF");
  case_224: /* CIL Label */ 
#line 463
  return ("R_PARISC_LTOFF_TP64");
  case_227: /* CIL Label */ 
#line 466
  return ("R_PARISC_LTOFF_TP14WR");
  case_228: /* CIL Label */ 
#line 469
  return ("R_PARISC_LTOFF_TP14DR");
  case_229: /* CIL Label */ 
#line 472
  return ("R_PARISC_LTOFF_TP16F");
  case_230: /* CIL Label */ 
#line 475
  return ("R_PARISC_LTOFF_TP16WF");
  case_231: /* CIL Label */ 
#line 478
  return ("R_PARISC_LTOFF_TP16DF");
  case_232: /* CIL Label */ 
#line 481
  return ("R_PARISC_GNU_VTENTRY");
  case_233: /* CIL Label */ 
#line 482
  return ("R_PARISC_GNU_VTINHERIT");
  case_234: /* CIL Label */ 
#line 484
  return ("R_PARISC_TLS_GD21L");
  case_235: /* CIL Label */ 
#line 485
  return ("R_PARISC_TLS_GD14R");
  case_236: /* CIL Label */ 
#line 486
  return ("R_PARISC_TLS_GDCALL");
  case_237: /* CIL Label */ 
#line 487
  return ("R_PARISC_TLS_LDM21L");
  case_238: /* CIL Label */ 
#line 488
  return ("R_PARISC_TLS_LDM14R");
  case_239: /* CIL Label */ 
#line 489
  return ("R_PARISC_TLS_LDMCALL");
  case_240: /* CIL Label */ 
#line 490
  return ("R_PARISC_TLS_LDO21L");
  case_241: /* CIL Label */ 
#line 491
  return ("R_PARISC_TLS_LDO14R");
  case_242: /* CIL Label */ 
#line 492
  return ("R_PARISC_TLS_DTPMOD32");
  case_243: /* CIL Label */ 
#line 493
  return ("R_PARISC_TLS_DTPMOD64");
  case_244: /* CIL Label */ 
#line 494
  return ("R_PARISC_TLS_DTPOFF32");
  case_245: /* CIL Label */ 
#line 495
  return ("R_PARISC_TLS_DTPOFF64");
  switch_default: /* CIL Label */ 
#line 497
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/i386.h"
static char const   *elf_i386_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/i386.h"
static char const   *elf_i386_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 65
  if (rtype == 38UL) {
#line 65
    goto case_38;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 41UL) {
#line 68
    goto case_41;
  }
#line 69
  if (rtype == 42UL) {
#line 69
    goto case_42;
  }
#line 72
  if (rtype == 200UL) {
#line 72
    goto case_200;
  }
#line 75
  if (rtype == 250UL) {
#line 75
    goto case_250;
  }
#line 76
  if (rtype == 251UL) {
#line 76
    goto case_251;
  }
#line 77
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_386_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_386_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_386_PC32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_386_GOT32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_386_PLT32");
  case_5: /* CIL Label */ 
#line 32
  return ("R_386_COPY");
  case_6: /* CIL Label */ 
#line 33
  return ("R_386_GLOB_DAT");
  case_7: /* CIL Label */ 
#line 34
  return ("R_386_JUMP_SLOT");
  case_8: /* CIL Label */ 
#line 35
  return ("R_386_RELATIVE");
  case_9: /* CIL Label */ 
#line 36
  return ("R_386_GOTOFF");
  case_10: /* CIL Label */ 
#line 37
  return ("R_386_GOTPC");
  case_11: /* CIL Label */ 
#line 38
  return ("R_386_32PLT");
  case_14: /* CIL Label */ 
#line 41
  return ("R_386_TLS_TPOFF");
  case_15: /* CIL Label */ 
#line 42
  return ("R_386_TLS_IE");
  case_16: /* CIL Label */ 
#line 43
  return ("R_386_TLS_GOTIE");
  case_17: /* CIL Label */ 
#line 44
  return ("R_386_TLS_LE");
  case_18: /* CIL Label */ 
#line 45
  return ("R_386_TLS_GD");
  case_19: /* CIL Label */ 
#line 46
  return ("R_386_TLS_LDM");
  case_20: /* CIL Label */ 
#line 47
  return ("R_386_16");
  case_21: /* CIL Label */ 
#line 48
  return ("R_386_PC16");
  case_22: /* CIL Label */ 
#line 49
  return ("R_386_8");
  case_23: /* CIL Label */ 
#line 50
  return ("R_386_PC8");
  case_24: /* CIL Label */ 
#line 51
  return ("R_386_TLS_GD_32");
  case_25: /* CIL Label */ 
#line 52
  return ("R_386_TLS_GD_PUSH");
  case_26: /* CIL Label */ 
#line 53
  return ("R_386_TLS_GD_CALL");
  case_27: /* CIL Label */ 
#line 54
  return ("R_386_TLS_GD_POP");
  case_28: /* CIL Label */ 
#line 55
  return ("R_386_TLS_LDM_32");
  case_29: /* CIL Label */ 
#line 56
  return ("R_386_TLS_LDM_PUSH");
  case_30: /* CIL Label */ 
#line 57
  return ("R_386_TLS_LDM_CALL");
  case_31: /* CIL Label */ 
#line 58
  return ("R_386_TLS_LDM_POP");
  case_32: /* CIL Label */ 
#line 59
  return ("R_386_TLS_LDO_32");
  case_33: /* CIL Label */ 
#line 60
  return ("R_386_TLS_IE_32");
  case_34: /* CIL Label */ 
#line 61
  return ("R_386_TLS_LE_32");
  case_35: /* CIL Label */ 
#line 62
  return ("R_386_TLS_DTPMOD32");
  case_36: /* CIL Label */ 
#line 63
  return ("R_386_TLS_DTPOFF32");
  case_37: /* CIL Label */ 
#line 64
  return ("R_386_TLS_TPOFF32");
  case_38: /* CIL Label */ 
#line 65
  return ("R_386_SIZE32");
  case_39: /* CIL Label */ 
#line 66
  return ("R_386_TLS_GOTDESC");
  case_40: /* CIL Label */ 
#line 67
  return ("R_386_TLS_DESC_CALL");
  case_41: /* CIL Label */ 
#line 68
  return ("R_386_TLS_DESC");
  case_42: /* CIL Label */ 
#line 69
  return ("R_386_IRELATIVE");
  case_200: /* CIL Label */ 
#line 72
  return ("R_386_USED_BY_INTEL_200");
  case_250: /* CIL Label */ 
#line 75
  return ("R_386_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 76
  return ("R_386_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 77
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 46 "./../include/elf/i370.h"
static char const   *i370_reloc_type(unsigned long rtype ) ;
#line 46 "./../include/elf/i370.h"
static char const   *i370_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 47
  if (rtype == 0UL) {
#line 47
    goto case_0;
  }
#line 48
  if (rtype == 1UL) {
#line 48
    goto case_1;
  }
#line 49
  if (rtype == 2UL) {
#line 49
    goto case_2;
  }
#line 50
  if (rtype == 3UL) {
#line 50
    goto case_3;
  }
#line 51
  if (rtype == 4UL) {
#line 51
    goto case_4;
  }
#line 52
  if (rtype == 5UL) {
#line 52
    goto case_5;
  }
#line 53
  if (rtype == 6UL) {
#line 53
    goto case_6;
  }
#line 54
  if (rtype == 7UL) {
#line 54
    goto case_7;
  }
#line 55
  if (rtype == 8UL) {
#line 55
    goto case_8;
  }
#line 56
  if (rtype == 9UL) {
#line 56
    goto case_9;
  }
#line 57
  if (rtype == 10UL) {
#line 57
    goto case_10;
  }
#line 58
  if (rtype == 11UL) {
#line 58
    goto case_11;
  }
#line 59
  goto switch_default;
  case_0: /* CIL Label */ 
#line 47
  return ("R_I370_NONE");
  case_1: /* CIL Label */ 
#line 48
  return ("R_I370_ADDR31");
  case_2: /* CIL Label */ 
#line 49
  return ("R_I370_ADDR32");
  case_3: /* CIL Label */ 
#line 50
  return ("R_I370_ADDR16");
  case_4: /* CIL Label */ 
#line 51
  return ("R_I370_REL31");
  case_5: /* CIL Label */ 
#line 52
  return ("R_I370_REL32");
  case_6: /* CIL Label */ 
#line 53
  return ("R_I370_ADDR12");
  case_7: /* CIL Label */ 
#line 54
  return ("R_I370_REL12");
  case_8: /* CIL Label */ 
#line 55
  return ("R_I370_ADDR8");
  case_9: /* CIL Label */ 
#line 56
  return ("R_I370_REL8");
  case_10: /* CIL Label */ 
#line 57
  return ("R_I370_COPY");
  case_11: /* CIL Label */ 
#line 58
  return ("R_I370_RELATIVE");
  switch_default: /* CIL Label */ 
#line 59
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/i860.h"
static char const   *elf_i860_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/i860.h"
static char const   *elf_i860_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 48UL) {
#line 36
    goto case_48;
  }
#line 37
  if (rtype == 49UL) {
#line 37
    goto case_49;
  }
#line 38
  if (rtype == 50UL) {
#line 38
    goto case_50;
  }
#line 39
  if (rtype == 64UL) {
#line 39
    goto case_64;
  }
#line 40
  if (rtype == 66UL) {
#line 40
    goto case_66;
  }
#line 41
  if (rtype == 68UL) {
#line 41
    goto case_68;
  }
#line 42
  if (rtype == 70UL) {
#line 42
    goto case_70;
  }
#line 43
  if (rtype == 72UL) {
#line 43
    goto case_72;
  }
#line 44
  if (rtype == 74UL) {
#line 44
    goto case_74;
  }
#line 45
  if (rtype == 76UL) {
#line 45
    goto case_76;
  }
#line 46
  if (rtype == 80UL) {
#line 46
    goto case_80;
  }
#line 47
  if (rtype == 82UL) {
#line 47
    goto case_82;
  }
#line 48
  if (rtype == 84UL) {
#line 48
    goto case_84;
  }
#line 49
  if (rtype == 86UL) {
#line 49
    goto case_86;
  }
#line 50
  if (rtype == 96UL) {
#line 50
    goto case_96;
  }
#line 51
  if (rtype == 98UL) {
#line 51
    goto case_98;
  }
#line 52
  if (rtype == 100UL) {
#line 52
    goto case_100;
  }
#line 53
  if (rtype == 102UL) {
#line 53
    goto case_102;
  }
#line 54
  if (rtype == 104UL) {
#line 54
    goto case_104;
  }
#line 55
  if (rtype == 108UL) {
#line 55
    goto case_108;
  }
#line 56
  if (rtype == 112UL) {
#line 56
    goto case_112;
  }
#line 57
  if (rtype == 128UL) {
#line 57
    goto case_128;
  }
#line 58
  if (rtype == 144UL) {
#line 58
    goto case_144;
  }
#line 59
  if (rtype == 160UL) {
#line 59
    goto case_160;
  }
#line 60
  if (rtype == 176UL) {
#line 60
    goto case_176;
  }
#line 61
  if (rtype == 192UL) {
#line 61
    goto case_192;
  }
#line 62
  if (rtype == 208UL) {
#line 62
    goto case_208;
  }
#line 63
  if (rtype == 224UL) {
#line 63
    goto case_224;
  }
#line 64
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_860_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_860_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_860_COPY");
  case_3: /* CIL Label */ 
#line 33
  return ("R_860_GLOB_DAT");
  case_4: /* CIL Label */ 
#line 34
  return ("R_860_JUMP_SLOT");
  case_5: /* CIL Label */ 
#line 35
  return ("R_860_RELATIVE");
  case_48: /* CIL Label */ 
#line 36
  return ("R_860_PC26");
  case_49: /* CIL Label */ 
#line 37
  return ("R_860_PLT26");
  case_50: /* CIL Label */ 
#line 38
  return ("R_860_PC16");
  case_64: /* CIL Label */ 
#line 39
  return ("R_860_LOW0");
  case_66: /* CIL Label */ 
#line 40
  return ("R_860_SPLIT0");
  case_68: /* CIL Label */ 
#line 41
  return ("R_860_LOW1");
  case_70: /* CIL Label */ 
#line 42
  return ("R_860_SPLIT1");
  case_72: /* CIL Label */ 
#line 43
  return ("R_860_LOW2");
  case_74: /* CIL Label */ 
#line 44
  return ("R_860_SPLIT2");
  case_76: /* CIL Label */ 
#line 45
  return ("R_860_LOW3");
  case_80: /* CIL Label */ 
#line 46
  return ("R_860_LOGOT0");
  case_82: /* CIL Label */ 
#line 47
  return ("R_860_SPGOT0");
  case_84: /* CIL Label */ 
#line 48
  return ("R_860_LOGOT1");
  case_86: /* CIL Label */ 
#line 49
  return ("R_860_SPGOT1");
  case_96: /* CIL Label */ 
#line 50
  return ("R_860_LOGOTOFF0");
  case_98: /* CIL Label */ 
#line 51
  return ("R_860_SPGOTOFF0");
  case_100: /* CIL Label */ 
#line 52
  return ("R_860_LOGOTOFF1");
  case_102: /* CIL Label */ 
#line 53
  return ("R_860_SPGOTOFF1");
  case_104: /* CIL Label */ 
#line 54
  return ("R_860_LOGOTOFF2");
  case_108: /* CIL Label */ 
#line 55
  return ("R_860_LOGOTOFF3");
  case_112: /* CIL Label */ 
#line 56
  return ("R_860_LOPC");
  case_128: /* CIL Label */ 
#line 57
  return ("R_860_HIGHADJ");
  case_144: /* CIL Label */ 
#line 58
  return ("R_860_HAGOT");
  case_160: /* CIL Label */ 
#line 59
  return ("R_860_HAGOTOFF");
  case_176: /* CIL Label */ 
#line 60
  return ("R_860_HAPC");
  case_192: /* CIL Label */ 
#line 61
  return ("R_860_HIGH");
  case_208: /* CIL Label */ 
#line 62
  return ("R_860_HIGOT");
  case_224: /* CIL Label */ 
#line 63
  return ("R_860_HIGOTOFF");
  switch_default: /* CIL Label */ 
#line 64
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/i960.h"
static char const   *elf_i960_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/i960.h"
static char const   *elf_i960_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_960_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_960_12");
  case_2: /* CIL Label */ 
#line 29
  return ("R_960_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_960_IP24");
  case_4: /* CIL Label */ 
#line 31
  return ("R_960_SUB");
  case_5: /* CIL Label */ 
#line 32
  return ("R_960_OPTCALL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_960_OPTCALLX");
  case_7: /* CIL Label */ 
#line 34
  return ("R_960_OPTCALLXA");
  switch_default: /* CIL Label */ 
#line 35
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 288 "./../include/elf/ia64.h"
static char const   *elf_ia64_reloc_type(unsigned long rtype ) ;
#line 288 "./../include/elf/ia64.h"
static char const   *elf_ia64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 289
  if (rtype == 0UL) {
#line 289
    goto case_0;
  }
#line 291
  if (rtype == 33UL) {
#line 291
    goto case_33;
  }
#line 292
  if (rtype == 34UL) {
#line 292
    goto case_34;
  }
#line 293
  if (rtype == 35UL) {
#line 293
    goto case_35;
  }
#line 294
  if (rtype == 36UL) {
#line 294
    goto case_36;
  }
#line 295
  if (rtype == 37UL) {
#line 295
    goto case_37;
  }
#line 296
  if (rtype == 38UL) {
#line 296
    goto case_38;
  }
#line 297
  if (rtype == 39UL) {
#line 297
    goto case_39;
  }
#line 299
  if (rtype == 42UL) {
#line 299
    goto case_42;
  }
#line 300
  if (rtype == 43UL) {
#line 300
    goto case_43;
  }
#line 301
  if (rtype == 44UL) {
#line 301
    goto case_44;
  }
#line 302
  if (rtype == 45UL) {
#line 302
    goto case_45;
  }
#line 303
  if (rtype == 46UL) {
#line 303
    goto case_46;
  }
#line 304
  if (rtype == 47UL) {
#line 304
    goto case_47;
  }
#line 306
  if (rtype == 50UL) {
#line 306
    goto case_50;
  }
#line 307
  if (rtype == 51UL) {
#line 307
    goto case_51;
  }
#line 309
  if (rtype == 58UL) {
#line 309
    goto case_58;
  }
#line 310
  if (rtype == 59UL) {
#line 310
    goto case_59;
  }
#line 311
  if (rtype == 62UL) {
#line 311
    goto case_62;
  }
#line 312
  if (rtype == 63UL) {
#line 312
    goto case_63;
  }
#line 314
  if (rtype == 67UL) {
#line 314
    goto case_67;
  }
#line 315
  if (rtype == 68UL) {
#line 315
    goto case_68;
  }
#line 316
  if (rtype == 69UL) {
#line 316
    goto case_69;
  }
#line 317
  if (rtype == 70UL) {
#line 317
    goto case_70;
  }
#line 318
  if (rtype == 71UL) {
#line 318
    goto case_71;
  }
#line 320
  if (rtype == 72UL) {
#line 320
    goto case_72;
  }
#line 321
  if (rtype == 73UL) {
#line 321
    goto case_73;
  }
#line 322
  if (rtype == 74UL) {
#line 322
    goto case_74;
  }
#line 323
  if (rtype == 75UL) {
#line 323
    goto case_75;
  }
#line 324
  if (rtype == 76UL) {
#line 324
    goto case_76;
  }
#line 325
  if (rtype == 77UL) {
#line 325
    goto case_77;
  }
#line 326
  if (rtype == 78UL) {
#line 326
    goto case_78;
  }
#line 327
  if (rtype == 79UL) {
#line 327
    goto case_79;
  }
#line 329
  if (rtype == 82UL) {
#line 329
    goto case_82;
  }
#line 330
  if (rtype == 83UL) {
#line 330
    goto case_83;
  }
#line 331
  if (rtype == 84UL) {
#line 331
    goto case_84;
  }
#line 332
  if (rtype == 85UL) {
#line 332
    goto case_85;
  }
#line 333
  if (rtype == 86UL) {
#line 333
    goto case_86;
  }
#line 334
  if (rtype == 87UL) {
#line 334
    goto case_87;
  }
#line 336
  if (rtype == 92UL) {
#line 336
    goto case_92;
  }
#line 337
  if (rtype == 93UL) {
#line 337
    goto case_93;
  }
#line 338
  if (rtype == 94UL) {
#line 338
    goto case_94;
  }
#line 339
  if (rtype == 95UL) {
#line 339
    goto case_95;
  }
#line 341
  if (rtype == 100UL) {
#line 341
    goto case_100;
  }
#line 342
  if (rtype == 101UL) {
#line 342
    goto case_101;
  }
#line 343
  if (rtype == 102UL) {
#line 343
    goto case_102;
  }
#line 344
  if (rtype == 103UL) {
#line 344
    goto case_103;
  }
#line 346
  if (rtype == 108UL) {
#line 346
    goto case_108;
  }
#line 347
  if (rtype == 109UL) {
#line 347
    goto case_109;
  }
#line 348
  if (rtype == 110UL) {
#line 348
    goto case_110;
  }
#line 349
  if (rtype == 111UL) {
#line 349
    goto case_111;
  }
#line 351
  if (rtype == 116UL) {
#line 351
    goto case_116;
  }
#line 352
  if (rtype == 117UL) {
#line 352
    goto case_117;
  }
#line 353
  if (rtype == 118UL) {
#line 353
    goto case_118;
  }
#line 354
  if (rtype == 119UL) {
#line 354
    goto case_119;
  }
#line 356
  if (rtype == 121UL) {
#line 356
    goto case_121;
  }
#line 357
  if (rtype == 122UL) {
#line 357
    goto case_122;
  }
#line 358
  if (rtype == 123UL) {
#line 358
    goto case_123;
  }
#line 360
  if (rtype == 128UL) {
#line 360
    goto case_128;
  }
#line 361
  if (rtype == 129UL) {
#line 361
    goto case_129;
  }
#line 362
  if (rtype == 132UL) {
#line 362
    goto case_132;
  }
#line 363
  if (rtype == 134UL) {
#line 363
    goto case_134;
  }
#line 364
  if (rtype == 135UL) {
#line 364
    goto case_135;
  }
#line 366
  if (rtype == 145UL) {
#line 366
    goto case_145;
  }
#line 367
  if (rtype == 146UL) {
#line 367
    goto case_146;
  }
#line 368
  if (rtype == 147UL) {
#line 368
    goto case_147;
  }
#line 369
  if (rtype == 150UL) {
#line 369
    goto case_150;
  }
#line 370
  if (rtype == 151UL) {
#line 370
    goto case_151;
  }
#line 372
  if (rtype == 154UL) {
#line 372
    goto case_154;
  }
#line 374
  if (rtype == 166UL) {
#line 374
    goto case_166;
  }
#line 375
  if (rtype == 167UL) {
#line 375
    goto case_167;
  }
#line 376
  if (rtype == 170UL) {
#line 376
    goto case_170;
  }
#line 378
  if (rtype == 177UL) {
#line 378
    goto case_177;
  }
#line 379
  if (rtype == 178UL) {
#line 379
    goto case_178;
  }
#line 380
  if (rtype == 179UL) {
#line 380
    goto case_179;
  }
#line 381
  if (rtype == 180UL) {
#line 381
    goto case_180;
  }
#line 382
  if (rtype == 181UL) {
#line 382
    goto case_181;
  }
#line 383
  if (rtype == 182UL) {
#line 383
    goto case_182;
  }
#line 384
  if (rtype == 183UL) {
#line 384
    goto case_183;
  }
#line 386
  if (rtype == 186UL) {
#line 386
    goto case_186;
  }
#line 391
  if (rtype == 1879048192UL) {
#line 391
    goto case_1879048192;
  }
#line 392
  if (rtype == 1879048193UL) {
#line 392
    goto case_1879048193;
  }
#line 393
  if (rtype == 1879048194UL) {
#line 393
    goto case_1879048194;
  }
#line 394
  if (rtype == 1879048195UL) {
#line 394
    goto case_1879048195;
  }
#line 395
  if (rtype == 1879048196UL) {
#line 395
    goto case_1879048196;
  }
#line 396
  if (rtype == 1879048197UL) {
#line 396
    goto case_1879048197;
  }
#line 397
  if (rtype == 1879048198UL) {
#line 397
    goto case_1879048198;
  }
#line 398
  if (rtype == 1879048199UL) {
#line 398
    goto case_1879048199;
  }
#line 399
  if (rtype == 1879048200UL) {
#line 399
    goto case_1879048200;
  }
#line 400
  if (rtype == 1879048201UL) {
#line 400
    goto case_1879048201;
  }
#line 401
  if (rtype == 1879048202UL) {
#line 401
    goto case_1879048202;
  }
#line 402
  if (rtype == 1879048203UL) {
#line 402
    goto case_1879048203;
  }
#line 403
  if (rtype == 1879048204UL) {
#line 403
    goto case_1879048204;
  }
#line 404
  if (rtype == 1879048205UL) {
#line 404
    goto case_1879048205;
  }
#line 405
  if (rtype == 1879048206UL) {
#line 405
    goto case_1879048206;
  }
#line 406
  if (rtype == 1879048207UL) {
#line 406
    goto case_1879048207;
  }
#line 407
  if (rtype == 1879048208UL) {
#line 407
    goto case_1879048208;
  }
#line 408
  if (rtype == 1879048209UL) {
#line 408
    goto case_1879048209;
  }
#line 409
  if (rtype == 1879048210UL) {
#line 409
    goto case_1879048210;
  }
#line 410
  if (rtype == 1879048212UL) {
#line 410
    goto case_1879048212;
  }
#line 411
  if (rtype == 1879048213UL) {
#line 411
    goto case_1879048213;
  }
#line 412
  if (rtype == 1879048214UL) {
#line 412
    goto case_1879048214;
  }
#line 413
  if (rtype == 1879048215UL) {
#line 413
    goto case_1879048215;
  }
#line 414
  goto switch_default;
  case_0: /* CIL Label */ 
#line 289
  return ("R_IA64_NONE");
  case_33: /* CIL Label */ 
#line 291
  return ("R_IA64_IMM14");
  case_34: /* CIL Label */ 
#line 292
  return ("R_IA64_IMM22");
  case_35: /* CIL Label */ 
#line 293
  return ("R_IA64_IMM64");
  case_36: /* CIL Label */ 
#line 294
  return ("R_IA64_DIR32MSB");
  case_37: /* CIL Label */ 
#line 295
  return ("R_IA64_DIR32LSB");
  case_38: /* CIL Label */ 
#line 296
  return ("R_IA64_DIR64MSB");
  case_39: /* CIL Label */ 
#line 297
  return ("R_IA64_DIR64LSB");
  case_42: /* CIL Label */ 
#line 299
  return ("R_IA64_GPREL22");
  case_43: /* CIL Label */ 
#line 300
  return ("R_IA64_GPREL64I");
  case_44: /* CIL Label */ 
#line 301
  return ("R_IA64_GPREL32MSB");
  case_45: /* CIL Label */ 
#line 302
  return ("R_IA64_GPREL32LSB");
  case_46: /* CIL Label */ 
#line 303
  return ("R_IA64_GPREL64MSB");
  case_47: /* CIL Label */ 
#line 304
  return ("R_IA64_GPREL64LSB");
  case_50: /* CIL Label */ 
#line 306
  return ("R_IA64_LTOFF22");
  case_51: /* CIL Label */ 
#line 307
  return ("R_IA64_LTOFF64I");
  case_58: /* CIL Label */ 
#line 309
  return ("R_IA64_PLTOFF22");
  case_59: /* CIL Label */ 
#line 310
  return ("R_IA64_PLTOFF64I");
  case_62: /* CIL Label */ 
#line 311
  return ("R_IA64_PLTOFF64MSB");
  case_63: /* CIL Label */ 
#line 312
  return ("R_IA64_PLTOFF64LSB");
  case_67: /* CIL Label */ 
#line 314
  return ("R_IA64_FPTR64I");
  case_68: /* CIL Label */ 
#line 315
  return ("R_IA64_FPTR32MSB");
  case_69: /* CIL Label */ 
#line 316
  return ("R_IA64_FPTR32LSB");
  case_70: /* CIL Label */ 
#line 317
  return ("R_IA64_FPTR64MSB");
  case_71: /* CIL Label */ 
#line 318
  return ("R_IA64_FPTR64LSB");
  case_72: /* CIL Label */ 
#line 320
  return ("R_IA64_PCREL60B");
  case_73: /* CIL Label */ 
#line 321
  return ("R_IA64_PCREL21B");
  case_74: /* CIL Label */ 
#line 322
  return ("R_IA64_PCREL21M");
  case_75: /* CIL Label */ 
#line 323
  return ("R_IA64_PCREL21F");
  case_76: /* CIL Label */ 
#line 324
  return ("R_IA64_PCREL32MSB");
  case_77: /* CIL Label */ 
#line 325
  return ("R_IA64_PCREL32LSB");
  case_78: /* CIL Label */ 
#line 326
  return ("R_IA64_PCREL64MSB");
  case_79: /* CIL Label */ 
#line 327
  return ("R_IA64_PCREL64LSB");
  case_82: /* CIL Label */ 
#line 329
  return ("R_IA64_LTOFF_FPTR22");
  case_83: /* CIL Label */ 
#line 330
  return ("R_IA64_LTOFF_FPTR64I");
  case_84: /* CIL Label */ 
#line 331
  return ("R_IA64_LTOFF_FPTR32MSB");
  case_85: /* CIL Label */ 
#line 332
  return ("R_IA64_LTOFF_FPTR32LSB");
  case_86: /* CIL Label */ 
#line 333
  return ("R_IA64_LTOFF_FPTR64MSB");
  case_87: /* CIL Label */ 
#line 334
  return ("R_IA64_LTOFF_FPTR64LSB");
  case_92: /* CIL Label */ 
#line 336
  return ("R_IA64_SEGREL32MSB");
  case_93: /* CIL Label */ 
#line 337
  return ("R_IA64_SEGREL32LSB");
  case_94: /* CIL Label */ 
#line 338
  return ("R_IA64_SEGREL64MSB");
  case_95: /* CIL Label */ 
#line 339
  return ("R_IA64_SEGREL64LSB");
  case_100: /* CIL Label */ 
#line 341
  return ("R_IA64_SECREL32MSB");
  case_101: /* CIL Label */ 
#line 342
  return ("R_IA64_SECREL32LSB");
  case_102: /* CIL Label */ 
#line 343
  return ("R_IA64_SECREL64MSB");
  case_103: /* CIL Label */ 
#line 344
  return ("R_IA64_SECREL64LSB");
  case_108: /* CIL Label */ 
#line 346
  return ("R_IA64_REL32MSB");
  case_109: /* CIL Label */ 
#line 347
  return ("R_IA64_REL32LSB");
  case_110: /* CIL Label */ 
#line 348
  return ("R_IA64_REL64MSB");
  case_111: /* CIL Label */ 
#line 349
  return ("R_IA64_REL64LSB");
  case_116: /* CIL Label */ 
#line 351
  return ("R_IA64_LTV32MSB");
  case_117: /* CIL Label */ 
#line 352
  return ("R_IA64_LTV32LSB");
  case_118: /* CIL Label */ 
#line 353
  return ("R_IA64_LTV64MSB");
  case_119: /* CIL Label */ 
#line 354
  return ("R_IA64_LTV64LSB");
  case_121: /* CIL Label */ 
#line 356
  return ("R_IA64_PCREL21BI");
  case_122: /* CIL Label */ 
#line 357
  return ("R_IA64_PCREL22");
  case_123: /* CIL Label */ 
#line 358
  return ("R_IA64_PCREL64I");
  case_128: /* CIL Label */ 
#line 360
  return ("R_IA64_IPLTMSB");
  case_129: /* CIL Label */ 
#line 361
  return ("R_IA64_IPLTLSB");
  case_132: /* CIL Label */ 
#line 362
  return ("R_IA64_COPY");
  case_134: /* CIL Label */ 
#line 363
  return ("R_IA64_LTOFF22X");
  case_135: /* CIL Label */ 
#line 364
  return ("R_IA64_LDXMOV");
  case_145: /* CIL Label */ 
#line 366
  return ("R_IA64_TPREL14");
  case_146: /* CIL Label */ 
#line 367
  return ("R_IA64_TPREL22");
  case_147: /* CIL Label */ 
#line 368
  return ("R_IA64_TPREL64I");
  case_150: /* CIL Label */ 
#line 369
  return ("R_IA64_TPREL64MSB");
  case_151: /* CIL Label */ 
#line 370
  return ("R_IA64_TPREL64LSB");
  case_154: /* CIL Label */ 
#line 372
  return ("R_IA64_LTOFF_TPREL22");
  case_166: /* CIL Label */ 
#line 374
  return ("R_IA64_DTPMOD64MSB");
  case_167: /* CIL Label */ 
#line 375
  return ("R_IA64_DTPMOD64LSB");
  case_170: /* CIL Label */ 
#line 376
  return ("R_IA64_LTOFF_DTPMOD22");
  case_177: /* CIL Label */ 
#line 378
  return ("R_IA64_DTPREL14");
  case_178: /* CIL Label */ 
#line 379
  return ("R_IA64_DTPREL22");
  case_179: /* CIL Label */ 
#line 380
  return ("R_IA64_DTPREL64I");
  case_180: /* CIL Label */ 
#line 381
  return ("R_IA64_DTPREL32MSB");
  case_181: /* CIL Label */ 
#line 382
  return ("R_IA64_DTPREL32LSB");
  case_182: /* CIL Label */ 
#line 383
  return ("R_IA64_DTPREL64MSB");
  case_183: /* CIL Label */ 
#line 384
  return ("R_IA64_DTPREL64LSB");
  case_186: /* CIL Label */ 
#line 386
  return ("R_IA64_LTOFF_DTPREL22");
  case_1879048192: /* CIL Label */ 
#line 391
  return ("R_IA64_VMS_DIR8");
  case_1879048193: /* CIL Label */ 
#line 392
  return ("R_IA64_VMS_DIR16LSB");
  case_1879048194: /* CIL Label */ 
#line 393
  return ("R_IA64_VMS_CALL_SIGNATURE");
  case_1879048195: /* CIL Label */ 
#line 394
  return ("R_IA64_VMS_EXECLET_FUNC");
  case_1879048196: /* CIL Label */ 
#line 395
  return ("R_IA64_VMS_EXECLET_DATA");
  case_1879048197: /* CIL Label */ 
#line 396
  return ("R_IA64_VMS_FIX8");
  case_1879048198: /* CIL Label */ 
#line 397
  return ("R_IA64_VMS_FIX16");
  case_1879048199: /* CIL Label */ 
#line 398
  return ("R_IA64_VMS_FIX32");
  case_1879048200: /* CIL Label */ 
#line 399
  return ("R_IA64_VMS_FIX64");
  case_1879048201: /* CIL Label */ 
#line 400
  return ("R_IA64_VMS_FIXFD");
  case_1879048202: /* CIL Label */ 
#line 401
  return ("R_IA64_VMS_ACC_LOAD");
  case_1879048203: /* CIL Label */ 
#line 402
  return ("R_IA64_VMS_ACC_ADD");
  case_1879048204: /* CIL Label */ 
#line 403
  return ("R_IA64_VMS_ACC_SUB");
  case_1879048205: /* CIL Label */ 
#line 404
  return ("R_IA64_VMS_ACC_MUL");
  case_1879048206: /* CIL Label */ 
#line 405
  return ("R_IA64_VMS_ACC_DIV");
  case_1879048207: /* CIL Label */ 
#line 406
  return ("R_IA64_VMS_ACC_AND");
  case_1879048208: /* CIL Label */ 
#line 407
  return ("R_IA64_VMS_ACC_IOR");
  case_1879048209: /* CIL Label */ 
#line 408
  return ("R_IA64_VMS_ACC_EOR");
  case_1879048210: /* CIL Label */ 
#line 409
  return ("R_IA64_VMS_ACC_ASH");
  case_1879048212: /* CIL Label */ 
#line 410
  return ("R_IA64_VMS_ACC_STO8");
  case_1879048213: /* CIL Label */ 
#line 411
  return ("R_IA64_VMS_ACC_STO16LSH");
  case_1879048214: /* CIL Label */ 
#line 412
  return ("R_IA64_VMS_ACC_STO32LSH");
  case_1879048215: /* CIL Label */ 
#line 413
  return ("R_IA64_VMS_ACC_STO64LSH");
  switch_default: /* CIL Label */ 
#line 414
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/ip2k.h"
static char const   *elf_ip2k_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/ip2k.h"
static char const   *elf_ip2k_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_IP2K_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_IP2K_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_IP2K_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_IP2K_FR9");
  case_4: /* CIL Label */ 
#line 31
  return ("R_IP2K_BANK");
  case_5: /* CIL Label */ 
#line 32
  return ("R_IP2K_ADDR16CJP");
  case_6: /* CIL Label */ 
#line 33
  return ("R_IP2K_PAGE3");
  case_7: /* CIL Label */ 
#line 34
  return ("R_IP2K_LO8DATA");
  case_8: /* CIL Label */ 
#line 35
  return ("R_IP2K_HI8DATA");
  case_9: /* CIL Label */ 
#line 36
  return ("R_IP2K_LO8INSN");
  case_10: /* CIL Label */ 
#line 37
  return ("R_IP2K_HI8INSN");
  case_11: /* CIL Label */ 
#line 38
  return ("R_IP2K_PC_SKIP");
  case_12: /* CIL Label */ 
#line 39
  return ("R_IP2K_TEXT");
  case_13: /* CIL Label */ 
#line 40
  return ("R_IP2K_FR_OFFSET");
  case_14: /* CIL Label */ 
#line 41
  return ("R_IP2K_EX8DATA");
  switch_default: /* CIL Label */ 
#line 42
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/lm32.h"
static char const   *elf_lm32_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/lm32.h"
static char const   *elf_lm32_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_LM32_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_LM32_8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_LM32_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_LM32_32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_LM32_HI16");
  case_5: /* CIL Label */ 
#line 33
  return ("R_LM32_LO16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_LM32_GPREL16");
  case_7: /* CIL Label */ 
#line 35
  return ("R_LM32_CALL");
  case_8: /* CIL Label */ 
#line 36
  return ("R_LM32_BRANCH");
  case_9: /* CIL Label */ 
#line 37
  return ("R_LM32_GNU_VTINHERIT");
  case_10: /* CIL Label */ 
#line 38
  return ("R_LM32_GNU_VTENTRY");
  case_11: /* CIL Label */ 
#line 39
  return ("R_LM32_16_GOT");
  case_12: /* CIL Label */ 
#line 40
  return ("R_LM32_GOTOFF_HI16");
  case_13: /* CIL Label */ 
#line 41
  return ("R_LM32_GOTOFF_LO16");
  case_14: /* CIL Label */ 
#line 42
  return ("R_LM32_COPY");
  case_15: /* CIL Label */ 
#line 43
  return ("R_LM32_GLOB_DAT");
  case_16: /* CIL Label */ 
#line 44
  return ("R_LM32_JMP_SLOT");
  case_17: /* CIL Label */ 
#line 45
  return ("R_LM32_RELATIVE");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/iq2000.h"
static char const   *elf_iq2000_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/iq2000.h"
static char const   *elf_iq2000_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 200UL) {
#line 38
    goto case_200;
  }
#line 39
  if (rtype == 201UL) {
#line 39
    goto case_201;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_IQ2000_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_IQ2000_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_IQ2000_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_IQ2000_26");
  case_4: /* CIL Label */ 
#line 31
  return ("R_IQ2000_PC16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_IQ2000_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_IQ2000_LO16");
  case_7: /* CIL Label */ 
#line 34
  return ("R_IQ2000_OFFSET_16");
  case_8: /* CIL Label */ 
#line 35
  return ("R_IQ2000_OFFSET_21");
  case_9: /* CIL Label */ 
#line 36
  return ("R_IQ2000_UHI16");
  case_10: /* CIL Label */ 
#line 37
  return ("R_IQ2000_32_DEBUG");
  case_200: /* CIL Label */ 
#line 38
  return ("R_IQ2000_GNU_VTINHERIT");
  case_201: /* CIL Label */ 
#line 39
  return ("R_IQ2000_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/m32c.h"
static char const   *elf_m32c_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/m32c.h"
static char const   *elf_m32c_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 41
  if (rtype == 9UL) {
#line 41
    goto case_9;
  }
#line 45
  if (rtype == 10UL) {
#line 45
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 51
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_M32C_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_M32C_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_M32C_24");
  case_3: /* CIL Label */ 
#line 30
  return ("R_M32C_32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_M32C_8_PCREL");
  case_5: /* CIL Label */ 
#line 32
  return ("R_M32C_16_PCREL");
  case_6: /* CIL Label */ 
#line 35
  return ("R_M32C_8");
  case_7: /* CIL Label */ 
#line 37
  return ("R_M32C_LO16");
  case_8: /* CIL Label */ 
#line 39
  return ("R_M32C_HI8");
  case_9: /* CIL Label */ 
#line 41
  return ("R_M32C_HI16");
  case_10: /* CIL Label */ 
#line 45
  return ("R_M32C_RL_JUMP");
  case_11: /* CIL Label */ 
#line 47
  return ("R_M32C_RL_1ADDR");
  case_12: /* CIL Label */ 
#line 49
  return ("R_M32C_RL_2ADDR");
  switch_default: /* CIL Label */ 
#line 51
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/m32r.h"
static char const   *elf_m32r_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/m32r.h"
static char const   *elf_m32r_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 44
  if (rtype == 33UL) {
#line 44
    goto case_33;
  }
#line 45
  if (rtype == 34UL) {
#line 45
    goto case_34;
  }
#line 46
  if (rtype == 35UL) {
#line 46
    goto case_35;
  }
#line 47
  if (rtype == 36UL) {
#line 47
    goto case_36;
  }
#line 48
  if (rtype == 37UL) {
#line 48
    goto case_37;
  }
#line 49
  if (rtype == 38UL) {
#line 49
    goto case_38;
  }
#line 50
  if (rtype == 39UL) {
#line 50
    goto case_39;
  }
#line 51
  if (rtype == 40UL) {
#line 51
    goto case_40;
  }
#line 52
  if (rtype == 41UL) {
#line 52
    goto case_41;
  }
#line 53
  if (rtype == 42UL) {
#line 53
    goto case_42;
  }
#line 54
  if (rtype == 43UL) {
#line 54
    goto case_43;
  }
#line 55
  if (rtype == 44UL) {
#line 55
    goto case_44;
  }
#line 57
  if (rtype == 45UL) {
#line 57
    goto case_45;
  }
#line 59
  if (rtype == 48UL) {
#line 59
    goto case_48;
  }
#line 60
  if (rtype == 49UL) {
#line 60
    goto case_49;
  }
#line 61
  if (rtype == 50UL) {
#line 61
    goto case_50;
  }
#line 62
  if (rtype == 51UL) {
#line 62
    goto case_51;
  }
#line 63
  if (rtype == 52UL) {
#line 63
    goto case_52;
  }
#line 64
  if (rtype == 53UL) {
#line 64
    goto case_53;
  }
#line 65
  if (rtype == 54UL) {
#line 65
    goto case_54;
  }
#line 66
  if (rtype == 55UL) {
#line 66
    goto case_55;
  }
#line 67
  if (rtype == 56UL) {
#line 67
    goto case_56;
  }
#line 68
  if (rtype == 57UL) {
#line 68
    goto case_57;
  }
#line 69
  if (rtype == 58UL) {
#line 69
    goto case_58;
  }
#line 70
  if (rtype == 59UL) {
#line 70
    goto case_59;
  }
#line 71
  if (rtype == 60UL) {
#line 71
    goto case_60;
  }
#line 72
  if (rtype == 61UL) {
#line 72
    goto case_61;
  }
#line 73
  if (rtype == 62UL) {
#line 73
    goto case_62;
  }
#line 74
  if (rtype == 63UL) {
#line 74
    goto case_63;
  }
#line 75
  if (rtype == 64UL) {
#line 75
    goto case_64;
  }
#line 77
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_M32R_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_M32R_16");
  case_2: /* CIL Label */ 
#line 31
  return ("R_M32R_32");
  case_3: /* CIL Label */ 
#line 32
  return ("R_M32R_24");
  case_4: /* CIL Label */ 
#line 33
  return ("R_M32R_10_PCREL");
  case_5: /* CIL Label */ 
#line 34
  return ("R_M32R_18_PCREL");
  case_6: /* CIL Label */ 
#line 35
  return ("R_M32R_26_PCREL");
  case_7: /* CIL Label */ 
#line 36
  return ("R_M32R_HI16_ULO");
  case_8: /* CIL Label */ 
#line 37
  return ("R_M32R_HI16_SLO");
  case_9: /* CIL Label */ 
#line 38
  return ("R_M32R_LO16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_M32R_SDA16");
  case_11: /* CIL Label */ 
#line 40
  return ("R_M32R_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 41
  return ("R_M32R_GNU_VTENTRY");
  case_33: /* CIL Label */ 
#line 44
  return ("R_M32R_16_RELA");
  case_34: /* CIL Label */ 
#line 45
  return ("R_M32R_32_RELA");
  case_35: /* CIL Label */ 
#line 46
  return ("R_M32R_24_RELA");
  case_36: /* CIL Label */ 
#line 47
  return ("R_M32R_10_PCREL_RELA");
  case_37: /* CIL Label */ 
#line 48
  return ("R_M32R_18_PCREL_RELA");
  case_38: /* CIL Label */ 
#line 49
  return ("R_M32R_26_PCREL_RELA");
  case_39: /* CIL Label */ 
#line 50
  return ("R_M32R_HI16_ULO_RELA");
  case_40: /* CIL Label */ 
#line 51
  return ("R_M32R_HI16_SLO_RELA");
  case_41: /* CIL Label */ 
#line 52
  return ("R_M32R_LO16_RELA");
  case_42: /* CIL Label */ 
#line 53
  return ("R_M32R_SDA16_RELA");
  case_43: /* CIL Label */ 
#line 54
  return ("R_M32R_RELA_GNU_VTINHERIT");
  case_44: /* CIL Label */ 
#line 55
  return ("R_M32R_RELA_GNU_VTENTRY");
  case_45: /* CIL Label */ 
#line 57
  return ("R_M32R_REL32");
  case_48: /* CIL Label */ 
#line 59
  return ("R_M32R_GOT24");
  case_49: /* CIL Label */ 
#line 60
  return ("R_M32R_26_PLTREL");
  case_50: /* CIL Label */ 
#line 61
  return ("R_M32R_COPY");
  case_51: /* CIL Label */ 
#line 62
  return ("R_M32R_GLOB_DAT");
  case_52: /* CIL Label */ 
#line 63
  return ("R_M32R_JMP_SLOT");
  case_53: /* CIL Label */ 
#line 64
  return ("R_M32R_RELATIVE");
  case_54: /* CIL Label */ 
#line 65
  return ("R_M32R_GOTOFF");
  case_55: /* CIL Label */ 
#line 66
  return ("R_M32R_GOTPC24");
  case_56: /* CIL Label */ 
#line 67
  return ("R_M32R_GOT16_HI_ULO");
  case_57: /* CIL Label */ 
#line 68
  return ("R_M32R_GOT16_HI_SLO");
  case_58: /* CIL Label */ 
#line 69
  return ("R_M32R_GOT16_LO");
  case_59: /* CIL Label */ 
#line 70
  return ("R_M32R_GOTPC_HI_ULO");
  case_60: /* CIL Label */ 
#line 71
  return ("R_M32R_GOTPC_HI_SLO");
  case_61: /* CIL Label */ 
#line 72
  return ("R_M32R_GOTPC_LO");
  case_62: /* CIL Label */ 
#line 73
  return ("R_M32R_GOTOFF_HI_ULO");
  case_63: /* CIL Label */ 
#line 74
  return ("R_M32R_GOTOFF_HI_SLO");
  case_64: /* CIL Label */ 
#line 75
  return ("R_M32R_GOTOFF_LO");
  switch_default: /* CIL Label */ 
#line 77
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/m68k.h"
static char const   *elf_m68k_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/m68k.h"
static char const   *elf_m68k_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  if (rtype == 18UL) {
#line 46
    goto case_18;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 55
  if (rtype == 25UL) {
#line 55
    goto case_25;
  }
#line 56
  if (rtype == 26UL) {
#line 56
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 59
  if (rtype == 29UL) {
#line 59
    goto case_29;
  }
#line 60
  if (rtype == 30UL) {
#line 60
    goto case_30;
  }
#line 61
  if (rtype == 31UL) {
#line 61
    goto case_31;
  }
#line 62
  if (rtype == 32UL) {
#line 62
    goto case_32;
  }
#line 63
  if (rtype == 33UL) {
#line 63
    goto case_33;
  }
#line 64
  if (rtype == 34UL) {
#line 64
    goto case_34;
  }
#line 65
  if (rtype == 35UL) {
#line 65
    goto case_35;
  }
#line 66
  if (rtype == 36UL) {
#line 66
    goto case_36;
  }
#line 67
  if (rtype == 37UL) {
#line 67
    goto case_37;
  }
#line 68
  if (rtype == 38UL) {
#line 68
    goto case_38;
  }
#line 69
  if (rtype == 39UL) {
#line 69
    goto case_39;
  }
#line 70
  if (rtype == 40UL) {
#line 70
    goto case_40;
  }
#line 71
  if (rtype == 41UL) {
#line 71
    goto case_41;
  }
#line 72
  if (rtype == 42UL) {
#line 72
    goto case_42;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_68K_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_68K_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_68K_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_68K_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_68K_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_68K_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_68K_PC8");
  case_7: /* CIL Label */ 
#line 35
  return ("R_68K_GOT32");
  case_8: /* CIL Label */ 
#line 36
  return ("R_68K_GOT16");
  case_9: /* CIL Label */ 
#line 37
  return ("R_68K_GOT8");
  case_10: /* CIL Label */ 
#line 38
  return ("R_68K_GOT32O");
  case_11: /* CIL Label */ 
#line 39
  return ("R_68K_GOT16O");
  case_12: /* CIL Label */ 
#line 40
  return ("R_68K_GOT8O");
  case_13: /* CIL Label */ 
#line 41
  return ("R_68K_PLT32");
  case_14: /* CIL Label */ 
#line 42
  return ("R_68K_PLT16");
  case_15: /* CIL Label */ 
#line 43
  return ("R_68K_PLT8");
  case_16: /* CIL Label */ 
#line 44
  return ("R_68K_PLT32O");
  case_17: /* CIL Label */ 
#line 45
  return ("R_68K_PLT16O");
  case_18: /* CIL Label */ 
#line 46
  return ("R_68K_PLT8O");
  case_19: /* CIL Label */ 
#line 47
  return ("R_68K_COPY");
  case_20: /* CIL Label */ 
#line 48
  return ("R_68K_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 49
  return ("R_68K_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 50
  return ("R_68K_RELATIVE");
  case_23: /* CIL Label */ 
#line 52
  return ("R_68K_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 53
  return ("R_68K_GNU_VTENTRY");
  case_25: /* CIL Label */ 
#line 55
  return ("R_68K_TLS_GD32");
  case_26: /* CIL Label */ 
#line 56
  return ("R_68K_TLS_GD16");
  case_27: /* CIL Label */ 
#line 57
  return ("R_68K_TLS_GD8");
  case_28: /* CIL Label */ 
#line 58
  return ("R_68K_TLS_LDM32");
  case_29: /* CIL Label */ 
#line 59
  return ("R_68K_TLS_LDM16");
  case_30: /* CIL Label */ 
#line 60
  return ("R_68K_TLS_LDM8");
  case_31: /* CIL Label */ 
#line 61
  return ("R_68K_TLS_LDO32");
  case_32: /* CIL Label */ 
#line 62
  return ("R_68K_TLS_LDO16");
  case_33: /* CIL Label */ 
#line 63
  return ("R_68K_TLS_LDO8");
  case_34: /* CIL Label */ 
#line 64
  return ("R_68K_TLS_IE32");
  case_35: /* CIL Label */ 
#line 65
  return ("R_68K_TLS_IE16");
  case_36: /* CIL Label */ 
#line 66
  return ("R_68K_TLS_IE8");
  case_37: /* CIL Label */ 
#line 67
  return ("R_68K_TLS_LE32");
  case_38: /* CIL Label */ 
#line 68
  return ("R_68K_TLS_LE16");
  case_39: /* CIL Label */ 
#line 69
  return ("R_68K_TLS_LE8");
  case_40: /* CIL Label */ 
#line 70
  return ("R_68K_TLS_DTPMOD32");
  case_41: /* CIL Label */ 
#line 71
  return ("R_68K_TLS_DTPREL32");
  case_42: /* CIL Label */ 
#line 72
  return ("R_68K_TLS_TPREL32");
  switch_default: /* CIL Label */ 
#line 73
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/m68hc11.h"
static char const   *elf_m68hc11_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/m68hc11.h"
static char const   *elf_m68hc11_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 53
  if (rtype == 20UL) {
#line 53
    goto case_20;
  }
#line 56
  if (rtype == 21UL) {
#line 56
    goto case_21;
  }
#line 57
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_M68HC11_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_M68HC11_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_M68HC11_HI8");
  case_3: /* CIL Label */ 
#line 30
  return ("R_M68HC11_LO8");
  case_4: /* CIL Label */ 
#line 31
  return ("R_M68HC11_PCREL_8");
  case_5: /* CIL Label */ 
#line 32
  return ("R_M68HC11_16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_M68HC11_32");
  case_7: /* CIL Label */ 
#line 34
  return ("R_M68HC11_3B");
  case_8: /* CIL Label */ 
#line 35
  return ("R_M68HC11_PCREL_16");
  case_9: /* CIL Label */ 
#line 38
  return ("R_M68HC11_GNU_VTINHERIT");
  case_10: /* CIL Label */ 
#line 39
  return ("R_M68HC11_GNU_VTENTRY");
  case_11: /* CIL Label */ 
#line 41
  return ("R_M68HC11_24");
  case_12: /* CIL Label */ 
#line 42
  return ("R_M68HC11_LO16");
  case_13: /* CIL Label */ 
#line 43
  return ("R_M68HC11_PAGE");
  case_15: /* CIL Label */ 
#line 45
  return ("R_M68HC12_16B");
  case_16: /* CIL Label */ 
#line 46
  return ("R_M68HC12_PCREL_9");
  case_17: /* CIL Label */ 
#line 47
  return ("R_M68HC12_PCREL_10");
  case_18: /* CIL Label */ 
#line 48
  return ("R_M68HC12_HI8XG");
  case_19: /* CIL Label */ 
#line 49
  return ("R_M68HC12_LO8XG");
  case_20: /* CIL Label */ 
#line 53
  return ("R_M68HC11_RL_JUMP");
  case_21: /* CIL Label */ 
#line 56
  return ("R_M68HC11_RL_GROUP");
  switch_default: /* CIL Label */ 
#line 57
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/mcore.h"
static char const   *elf_mcore_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/mcore.h"
static char const   *elf_mcore_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_MCORE_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_MCORE_ADDR32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_MCORE_PCRELIMM8BY4");
  case_3: /* CIL Label */ 
#line 32
  return ("R_MCORE_PCRELIMM11BY2");
  case_4: /* CIL Label */ 
#line 33
  return ("R_MCORE_PCRELIMM4BY2");
  case_5: /* CIL Label */ 
#line 34
  return ("R_MCORE_PCREL32");
  case_6: /* CIL Label */ 
#line 35
  return ("R_MCORE_PCRELJSR_IMM11BY2");
  case_7: /* CIL Label */ 
#line 36
  return ("R_MCORE_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 37
  return ("R_MCORE_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 38
  return ("R_MCORE_RELATIVE");
  case_10: /* CIL Label */ 
#line 39
  return ("R_MCORE_COPY");
  case_11: /* CIL Label */ 
#line 40
  return ("R_MCORE_GLOB_DAT");
  case_12: /* CIL Label */ 
#line 41
  return ("R_MCORE_JUMP_SLOT");
  switch_default: /* CIL Label */ 
#line 42
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 38 "./../include/elf/mep.h"
static char const   *elf_mep_reloc_type(unsigned long rtype ) ;
#line 38 "./../include/elf/mep.h"
static char const   *elf_mep_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 41
  if (rtype == 0UL) {
#line 41
    goto case_0;
  }
#line 42
  if (rtype == 1UL) {
#line 42
    goto case_1;
  }
#line 44
  if (rtype == 2UL) {
#line 44
    goto case_2;
  }
#line 45
  if (rtype == 3UL) {
#line 45
    goto case_3;
  }
#line 46
  if (rtype == 4UL) {
#line 46
    goto case_4;
  }
#line 48
  if (rtype == 5UL) {
#line 48
    goto case_5;
  }
#line 49
  if (rtype == 6UL) {
#line 49
    goto case_6;
  }
#line 50
  if (rtype == 7UL) {
#line 50
    goto case_7;
  }
#line 51
  if (rtype == 8UL) {
#line 51
    goto case_8;
  }
#line 52
  if (rtype == 9UL) {
#line 52
    goto case_9;
  }
#line 54
  if (rtype == 10UL) {
#line 54
    goto case_10;
  }
#line 55
  if (rtype == 11UL) {
#line 55
    goto case_11;
  }
#line 56
  if (rtype == 12UL) {
#line 56
    goto case_12;
  }
#line 57
  if (rtype == 13UL) {
#line 57
    goto case_13;
  }
#line 58
  if (rtype == 14UL) {
#line 58
    goto case_14;
  }
#line 60
  if (rtype == 15UL) {
#line 60
    goto case_15;
  }
#line 61
  if (rtype == 16UL) {
#line 61
    goto case_16;
  }
#line 62
  if (rtype == 17UL) {
#line 62
    goto case_17;
  }
#line 64
  if (rtype == 18UL) {
#line 64
    goto case_18;
  }
#line 65
  if (rtype == 19UL) {
#line 65
    goto case_19;
  }
#line 67
  if (rtype == 20UL) {
#line 67
    goto case_20;
  }
#line 68
  if (rtype == 21UL) {
#line 68
    goto case_21;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 41
  return ("R_MEP_NONE");
  case_1: /* CIL Label */ 
#line 42
  return ("R_RELC");
  case_2: /* CIL Label */ 
#line 44
  return ("R_MEP_8");
  case_3: /* CIL Label */ 
#line 45
  return ("R_MEP_16");
  case_4: /* CIL Label */ 
#line 46
  return ("R_MEP_32");
  case_5: /* CIL Label */ 
#line 48
  return ("R_MEP_PCREL8A2");
  case_6: /* CIL Label */ 
#line 49
  return ("R_MEP_PCREL12A2");
  case_7: /* CIL Label */ 
#line 50
  return ("R_MEP_PCREL17A2");
  case_8: /* CIL Label */ 
#line 51
  return ("R_MEP_PCREL24A2");
  case_9: /* CIL Label */ 
#line 52
  return ("R_MEP_PCABS24A2");
  case_10: /* CIL Label */ 
#line 54
  return ("R_MEP_LOW16");
  case_11: /* CIL Label */ 
#line 55
  return ("R_MEP_HI16U");
  case_12: /* CIL Label */ 
#line 56
  return ("R_MEP_HI16S");
  case_13: /* CIL Label */ 
#line 57
  return ("R_MEP_GPREL");
  case_14: /* CIL Label */ 
#line 58
  return ("R_MEP_TPREL");
  case_15: /* CIL Label */ 
#line 60
  return ("R_MEP_TPREL7");
  case_16: /* CIL Label */ 
#line 61
  return ("R_MEP_TPREL7A2");
  case_17: /* CIL Label */ 
#line 62
  return ("R_MEP_TPREL7A4");
  case_18: /* CIL Label */ 
#line 64
  return ("R_MEP_UIMM24");
  case_19: /* CIL Label */ 
#line 65
  return ("R_MEP_ADDR24A4");
  case_20: /* CIL Label */ 
#line 67
  return ("R_MEP_GNU_VTINHERIT");
  case_21: /* CIL Label */ 
#line 68
  return ("R_MEP_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 70
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/metag.h"
static char const   *elf_metag_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/metag.h"
static char const   *elf_metag_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 38
  if (rtype == 7UL) {
#line 38
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 40
  if (rtype == 9UL) {
#line 40
    goto case_9;
  }
#line 41
  if (rtype == 10UL) {
#line 41
    goto case_10;
  }
#line 42
  if (rtype == 11UL) {
#line 42
    goto case_11;
  }
#line 43
  if (rtype == 12UL) {
#line 43
    goto case_12;
  }
#line 45
  if (rtype == 13UL) {
#line 45
    goto case_13;
  }
#line 46
  if (rtype == 14UL) {
#line 46
    goto case_14;
  }
#line 48
  if (rtype == 15UL) {
#line 48
    goto case_15;
  }
#line 49
  if (rtype == 16UL) {
#line 49
    goto case_16;
  }
#line 52
  if (rtype == 30UL) {
#line 52
    goto case_30;
  }
#line 53
  if (rtype == 31UL) {
#line 53
    goto case_31;
  }
#line 56
  if (rtype == 32UL) {
#line 56
    goto case_32;
  }
#line 57
  if (rtype == 33UL) {
#line 57
    goto case_33;
  }
#line 58
  if (rtype == 34UL) {
#line 58
    goto case_34;
  }
#line 59
  if (rtype == 35UL) {
#line 59
    goto case_35;
  }
#line 60
  if (rtype == 36UL) {
#line 60
    goto case_36;
  }
#line 61
  if (rtype == 37UL) {
#line 61
    goto case_37;
  }
#line 62
  if (rtype == 38UL) {
#line 62
    goto case_38;
  }
#line 63
  if (rtype == 39UL) {
#line 63
    goto case_39;
  }
#line 64
  if (rtype == 40UL) {
#line 64
    goto case_40;
  }
#line 65
  if (rtype == 41UL) {
#line 65
    goto case_41;
  }
#line 66
  if (rtype == 42UL) {
#line 66
    goto case_42;
  }
#line 67
  if (rtype == 43UL) {
#line 67
    goto case_43;
  }
#line 68
  if (rtype == 44UL) {
#line 68
    goto case_44;
  }
#line 69
  if (rtype == 45UL) {
#line 69
    goto case_45;
  }
#line 70
  if (rtype == 46UL) {
#line 70
    goto case_46;
  }
#line 73
  if (rtype == 47UL) {
#line 73
    goto case_47;
  }
#line 74
  if (rtype == 48UL) {
#line 74
    goto case_48;
  }
#line 75
  if (rtype == 49UL) {
#line 75
    goto case_49;
  }
#line 76
  if (rtype == 50UL) {
#line 76
    goto case_50;
  }
#line 77
  if (rtype == 51UL) {
#line 77
    goto case_51;
  }
#line 78
  if (rtype == 52UL) {
#line 78
    goto case_52;
  }
#line 79
  if (rtype == 53UL) {
#line 79
    goto case_53;
  }
#line 80
  if (rtype == 54UL) {
#line 80
    goto case_54;
  }
#line 81
  if (rtype == 55UL) {
#line 81
    goto case_55;
  }
#line 82
  if (rtype == 56UL) {
#line 82
    goto case_56;
  }
#line 83
  if (rtype == 57UL) {
#line 83
    goto case_57;
  }
#line 84
  if (rtype == 58UL) {
#line 84
    goto case_58;
  }
#line 85
  if (rtype == 59UL) {
#line 85
    goto case_59;
  }
#line 86
  if (rtype == 60UL) {
#line 86
    goto case_60;
  }
#line 87
  if (rtype == 61UL) {
#line 87
    goto case_61;
  }
#line 89
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_METAG_HIADDR16");
  case_1: /* CIL Label */ 
#line 30
  return ("R_METAG_LOADDR16");
  case_2: /* CIL Label */ 
#line 31
  return ("R_METAG_ADDR32");
  case_3: /* CIL Label */ 
#line 32
  return ("R_METAG_NONE");
  case_4: /* CIL Label */ 
#line 33
  return ("R_METAG_RELBRANCH");
  case_5: /* CIL Label */ 
#line 34
  return ("R_METAG_GETSETOFF");
  case_6: /* CIL Label */ 
#line 37
  return ("R_METAG_REG32OP1");
  case_7: /* CIL Label */ 
#line 38
  return ("R_METAG_REG32OP2");
  case_8: /* CIL Label */ 
#line 39
  return ("R_METAG_REG32OP3");
  case_9: /* CIL Label */ 
#line 40
  return ("R_METAG_REG16OP1");
  case_10: /* CIL Label */ 
#line 41
  return ("R_METAG_REG16OP2");
  case_11: /* CIL Label */ 
#line 42
  return ("R_METAG_REG16OP3");
  case_12: /* CIL Label */ 
#line 43
  return ("R_METAG_REG32OP4");
  case_13: /* CIL Label */ 
#line 45
  return ("R_METAG_HIOG");
  case_14: /* CIL Label */ 
#line 46
  return ("R_METAG_LOOG");
  case_15: /* CIL Label */ 
#line 48
  return ("R_METAG_REL8");
  case_16: /* CIL Label */ 
#line 49
  return ("R_METAG_REL16");
  case_30: /* CIL Label */ 
#line 52
  return ("R_METAG_GNU_VTINHERIT");
  case_31: /* CIL Label */ 
#line 53
  return ("R_METAG_GNU_VTENTRY");
  case_32: /* CIL Label */ 
#line 56
  return ("R_METAG_HI16_GOTOFF");
  case_33: /* CIL Label */ 
#line 57
  return ("R_METAG_LO16_GOTOFF");
  case_34: /* CIL Label */ 
#line 58
  return ("R_METAG_GETSET_GOTOFF");
  case_35: /* CIL Label */ 
#line 59
  return ("R_METAG_GETSET_GOT");
  case_36: /* CIL Label */ 
#line 60
  return ("R_METAG_HI16_GOTPC");
  case_37: /* CIL Label */ 
#line 61
  return ("R_METAG_LO16_GOTPC");
  case_38: /* CIL Label */ 
#line 62
  return ("R_METAG_HI16_PLT");
  case_39: /* CIL Label */ 
#line 63
  return ("R_METAG_LO16_PLT");
  case_40: /* CIL Label */ 
#line 64
  return ("R_METAG_RELBRANCH_PLT");
  case_41: /* CIL Label */ 
#line 65
  return ("R_METAG_GOTOFF");
  case_42: /* CIL Label */ 
#line 66
  return ("R_METAG_PLT");
  case_43: /* CIL Label */ 
#line 67
  return ("R_METAG_COPY");
  case_44: /* CIL Label */ 
#line 68
  return ("R_METAG_JMP_SLOT");
  case_45: /* CIL Label */ 
#line 69
  return ("R_METAG_RELATIVE");
  case_46: /* CIL Label */ 
#line 70
  return ("R_METAG_GLOB_DAT");
  case_47: /* CIL Label */ 
#line 73
  return ("R_METAG_TLS_GD");
  case_48: /* CIL Label */ 
#line 74
  return ("R_METAG_TLS_LDM");
  case_49: /* CIL Label */ 
#line 75
  return ("R_METAG_TLS_LDO_HI16");
  case_50: /* CIL Label */ 
#line 76
  return ("R_METAG_TLS_LDO_LO16");
  case_51: /* CIL Label */ 
#line 77
  return ("R_METAG_TLS_LDO");
  case_52: /* CIL Label */ 
#line 78
  return ("R_METAG_TLS_IE");
  case_53: /* CIL Label */ 
#line 79
  return ("R_METAG_TLS_IENONPIC");
  case_54: /* CIL Label */ 
#line 80
  return ("R_METAG_TLS_IENONPIC_HI16");
  case_55: /* CIL Label */ 
#line 81
  return ("R_METAG_TLS_IENONPIC_LO16");
  case_56: /* CIL Label */ 
#line 82
  return ("R_METAG_TLS_TPOFF");
  case_57: /* CIL Label */ 
#line 83
  return ("R_METAG_TLS_DTPMOD");
  case_58: /* CIL Label */ 
#line 84
  return ("R_METAG_TLS_DTPOFF");
  case_59: /* CIL Label */ 
#line 85
  return ("R_METAG_TLS_LE");
  case_60: /* CIL Label */ 
#line 86
  return ("R_METAG_TLS_LE_HI16");
  case_61: /* CIL Label */ 
#line 87
  return ("R_METAG_TLS_LE_LO16");
  switch_default: /* CIL Label */ 
#line 89
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 30 "./../include/elf/microblaze.h"
static char const   *elf_microblaze_reloc_type(unsigned long rtype ) ;
#line 30 "./../include/elf/microblaze.h"
static char const   *elf_microblaze_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 31
  if (rtype == 0UL) {
#line 31
    goto case_0;
  }
#line 32
  if (rtype == 1UL) {
#line 32
    goto case_1;
  }
#line 33
  if (rtype == 2UL) {
#line 33
    goto case_2;
  }
#line 34
  if (rtype == 3UL) {
#line 34
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 38
  if (rtype == 7UL) {
#line 38
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 40
  if (rtype == 9UL) {
#line 40
    goto case_9;
  }
#line 41
  if (rtype == 10UL) {
#line 41
    goto case_10;
  }
#line 42
  if (rtype == 11UL) {
#line 42
    goto case_11;
  }
#line 43
  if (rtype == 12UL) {
#line 43
    goto case_12;
  }
#line 44
  if (rtype == 13UL) {
#line 44
    goto case_13;
  }
#line 45
  if (rtype == 14UL) {
#line 45
    goto case_14;
  }
#line 46
  if (rtype == 15UL) {
#line 46
    goto case_15;
  }
#line 47
  if (rtype == 16UL) {
#line 47
    goto case_16;
  }
#line 48
  if (rtype == 17UL) {
#line 48
    goto case_17;
  }
#line 49
  if (rtype == 18UL) {
#line 49
    goto case_18;
  }
#line 50
  if (rtype == 19UL) {
#line 50
    goto case_19;
  }
#line 51
  if (rtype == 20UL) {
#line 51
    goto case_20;
  }
#line 52
  if (rtype == 21UL) {
#line 52
    goto case_21;
  }
#line 53
  if (rtype == 22UL) {
#line 53
    goto case_22;
  }
#line 54
  if (rtype == 23UL) {
#line 54
    goto case_23;
  }
#line 55
  if (rtype == 24UL) {
#line 55
    goto case_24;
  }
#line 56
  if (rtype == 25UL) {
#line 56
    goto case_25;
  }
#line 57
  if (rtype == 26UL) {
#line 57
    goto case_26;
  }
#line 58
  if (rtype == 27UL) {
#line 58
    goto case_27;
  }
#line 59
  if (rtype == 28UL) {
#line 59
    goto case_28;
  }
#line 60
  if (rtype == 29UL) {
#line 60
    goto case_29;
  }
#line 62
  goto switch_default;
  case_0: /* CIL Label */ 
#line 31
  return ("R_MICROBLAZE_NONE");
  case_1: /* CIL Label */ 
#line 32
  return ("R_MICROBLAZE_32");
  case_2: /* CIL Label */ 
#line 33
  return ("R_MICROBLAZE_32_PCREL");
  case_3: /* CIL Label */ 
#line 34
  return ("R_MICROBLAZE_64_PCREL");
  case_4: /* CIL Label */ 
#line 35
  return ("R_MICROBLAZE_32_PCREL_LO");
  case_5: /* CIL Label */ 
#line 36
  return ("R_MICROBLAZE_64");
  case_6: /* CIL Label */ 
#line 37
  return ("R_MICROBLAZE_32_LO");
  case_7: /* CIL Label */ 
#line 38
  return ("R_MICROBLAZE_SRO32");
  case_8: /* CIL Label */ 
#line 39
  return ("R_MICROBLAZE_SRW32");
  case_9: /* CIL Label */ 
#line 40
  return ("R_MICROBLAZE_64_NONE");
  case_10: /* CIL Label */ 
#line 41
  return ("R_MICROBLAZE_32_SYM_OP_SYM");
  case_11: /* CIL Label */ 
#line 42
  return ("R_MICROBLAZE_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 43
  return ("R_MICROBLAZE_GNU_VTENTRY");
  case_13: /* CIL Label */ 
#line 44
  return ("R_MICROBLAZE_GOTPC_64");
  case_14: /* CIL Label */ 
#line 45
  return ("R_MICROBLAZE_GOT_64");
  case_15: /* CIL Label */ 
#line 46
  return ("R_MICROBLAZE_PLT_64");
  case_16: /* CIL Label */ 
#line 47
  return ("R_MICROBLAZE_REL");
  case_17: /* CIL Label */ 
#line 48
  return ("R_MICROBLAZE_JUMP_SLOT");
  case_18: /* CIL Label */ 
#line 49
  return ("R_MICROBLAZE_GLOB_DAT");
  case_19: /* CIL Label */ 
#line 50
  return ("R_MICROBLAZE_GOTOFF_64");
  case_20: /* CIL Label */ 
#line 51
  return ("R_MICROBLAZE_GOTOFF_32");
  case_21: /* CIL Label */ 
#line 52
  return ("R_MICROBLAZE_COPY");
  case_22: /* CIL Label */ 
#line 53
  return ("R_MICROBLAZE_TLS");
  case_23: /* CIL Label */ 
#line 54
  return ("R_MICROBLAZE_TLSGD");
  case_24: /* CIL Label */ 
#line 55
  return ("R_MICROBLAZE_TLSLD");
  case_25: /* CIL Label */ 
#line 56
  return ("R_MICROBLAZE_TLSDTPMOD32");
  case_26: /* CIL Label */ 
#line 57
  return ("R_MICROBLAZE_TLSDTPREL32");
  case_27: /* CIL Label */ 
#line 58
  return ("R_MICROBLAZE_TLSDTPREL64");
  case_28: /* CIL Label */ 
#line 59
  return ("R_MICROBLAZE_TLSGOTTPREL32");
  case_29: /* CIL Label */ 
#line 60
  return ("R_MICROBLAZE_TLSTPREL32");
  switch_default: /* CIL Label */ 
#line 62
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "./../include/elf/mips.h"
static char const   *elf_mips_reloc_type(unsigned long rtype ) ;
#line 36 "./../include/elf/mips.h"
static char const   *elf_mips_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 37
  if (rtype == 0UL) {
#line 37
    goto case_0;
  }
#line 38
  if (rtype == 1UL) {
#line 38
    goto case_1;
  }
#line 39
  if (rtype == 2UL) {
#line 39
    goto case_2;
  }
#line 40
  if (rtype == 3UL) {
#line 40
    goto case_3;
  }
#line 41
  if (rtype == 4UL) {
#line 41
    goto case_4;
  }
#line 42
  if (rtype == 5UL) {
#line 42
    goto case_5;
  }
#line 43
  if (rtype == 6UL) {
#line 43
    goto case_6;
  }
#line 44
  if (rtype == 7UL) {
#line 44
    goto case_7;
  }
#line 45
  if (rtype == 8UL) {
#line 45
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 48
  if (rtype == 11UL) {
#line 48
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 52
  if (rtype == 13UL) {
#line 52
    goto case_13;
  }
#line 53
  if (rtype == 14UL) {
#line 53
    goto case_14;
  }
#line 54
  if (rtype == 15UL) {
#line 54
    goto case_15;
  }
#line 55
  if (rtype == 16UL) {
#line 55
    goto case_16;
  }
#line 56
  if (rtype == 17UL) {
#line 56
    goto case_17;
  }
#line 57
  if (rtype == 18UL) {
#line 57
    goto case_18;
  }
#line 58
  if (rtype == 19UL) {
#line 58
    goto case_19;
  }
#line 59
  if (rtype == 20UL) {
#line 59
    goto case_20;
  }
#line 60
  if (rtype == 21UL) {
#line 60
    goto case_21;
  }
#line 61
  if (rtype == 22UL) {
#line 61
    goto case_22;
  }
#line 62
  if (rtype == 23UL) {
#line 62
    goto case_23;
  }
#line 63
  if (rtype == 24UL) {
#line 63
    goto case_24;
  }
#line 64
  if (rtype == 25UL) {
#line 64
    goto case_25;
  }
#line 65
  if (rtype == 26UL) {
#line 65
    goto case_26;
  }
#line 66
  if (rtype == 27UL) {
#line 66
    goto case_27;
  }
#line 67
  if (rtype == 28UL) {
#line 67
    goto case_28;
  }
#line 68
  if (rtype == 29UL) {
#line 68
    goto case_29;
  }
#line 69
  if (rtype == 30UL) {
#line 69
    goto case_30;
  }
#line 70
  if (rtype == 31UL) {
#line 70
    goto case_31;
  }
#line 71
  if (rtype == 32UL) {
#line 71
    goto case_32;
  }
#line 72
  if (rtype == 33UL) {
#line 72
    goto case_33;
  }
#line 73
  if (rtype == 34UL) {
#line 73
    goto case_34;
  }
#line 74
  if (rtype == 35UL) {
#line 74
    goto case_35;
  }
#line 75
  if (rtype == 36UL) {
#line 75
    goto case_36;
  }
#line 76
  if (rtype == 37UL) {
#line 76
    goto case_37;
  }
#line 78
  if (rtype == 38UL) {
#line 78
    goto case_38;
  }
#line 79
  if (rtype == 39UL) {
#line 79
    goto case_39;
  }
#line 80
  if (rtype == 40UL) {
#line 80
    goto case_40;
  }
#line 81
  if (rtype == 41UL) {
#line 81
    goto case_41;
  }
#line 82
  if (rtype == 42UL) {
#line 82
    goto case_42;
  }
#line 83
  if (rtype == 43UL) {
#line 83
    goto case_43;
  }
#line 84
  if (rtype == 44UL) {
#line 84
    goto case_44;
  }
#line 85
  if (rtype == 45UL) {
#line 85
    goto case_45;
  }
#line 86
  if (rtype == 46UL) {
#line 86
    goto case_46;
  }
#line 87
  if (rtype == 47UL) {
#line 87
    goto case_47;
  }
#line 88
  if (rtype == 48UL) {
#line 88
    goto case_48;
  }
#line 89
  if (rtype == 49UL) {
#line 89
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 91
  if (rtype == 51UL) {
#line 91
    goto case_51;
  }
#line 95
  if (rtype == 100UL) {
#line 95
    goto case_100;
  }
#line 96
  if (rtype == 101UL) {
#line 96
    goto case_101;
  }
#line 97
  if (rtype == 102UL) {
#line 97
    goto case_102;
  }
#line 98
  if (rtype == 103UL) {
#line 98
    goto case_103;
  }
#line 99
  if (rtype == 104UL) {
#line 99
    goto case_104;
  }
#line 100
  if (rtype == 105UL) {
#line 100
    goto case_105;
  }
#line 101
  if (rtype == 106UL) {
#line 101
    goto case_106;
  }
#line 102
  if (rtype == 107UL) {
#line 102
    goto case_107;
  }
#line 103
  if (rtype == 108UL) {
#line 103
    goto case_108;
  }
#line 104
  if (rtype == 109UL) {
#line 104
    goto case_109;
  }
#line 105
  if (rtype == 110UL) {
#line 105
    goto case_110;
  }
#line 106
  if (rtype == 111UL) {
#line 106
    goto case_111;
  }
#line 107
  if (rtype == 112UL) {
#line 107
    goto case_112;
  }
#line 110
  if (rtype == 126UL) {
#line 110
    goto case_126;
  }
#line 111
  if (rtype == 127UL) {
#line 111
    goto case_127;
  }
#line 115
  if (rtype == 133UL) {
#line 115
    goto case_133;
  }
#line 116
  if (rtype == 134UL) {
#line 116
    goto case_134;
  }
#line 117
  if (rtype == 135UL) {
#line 117
    goto case_135;
  }
#line 118
  if (rtype == 136UL) {
#line 118
    goto case_136;
  }
#line 120
  if (rtype == 137UL) {
#line 120
    goto case_137;
  }
#line 121
  if (rtype == 138UL) {
#line 121
    goto case_138;
  }
#line 123
  if (rtype == 139UL) {
#line 123
    goto case_139;
  }
#line 124
  if (rtype == 140UL) {
#line 124
    goto case_140;
  }
#line 125
  if (rtype == 141UL) {
#line 125
    goto case_141;
  }
#line 126
  if (rtype == 142UL) {
#line 126
    goto case_142;
  }
#line 128
  if (rtype == 145UL) {
#line 128
    goto case_145;
  }
#line 129
  if (rtype == 146UL) {
#line 129
    goto case_146;
  }
#line 130
  if (rtype == 147UL) {
#line 130
    goto case_147;
  }
#line 131
  if (rtype == 148UL) {
#line 131
    goto case_148;
  }
#line 132
  if (rtype == 149UL) {
#line 132
    goto case_149;
  }
#line 133
  if (rtype == 150UL) {
#line 133
    goto case_150;
  }
#line 134
  if (rtype == 151UL) {
#line 134
    goto case_151;
  }
#line 135
  if (rtype == 152UL) {
#line 135
    goto case_152;
  }
#line 136
  if (rtype == 153UL) {
#line 136
    goto case_153;
  }
#line 137
  if (rtype == 154UL) {
#line 137
    goto case_154;
  }
#line 138
  if (rtype == 155UL) {
#line 138
    goto case_155;
  }
#line 139
  if (rtype == 156UL) {
#line 139
    goto case_156;
  }
#line 140
  if (rtype == 157UL) {
#line 140
    goto case_157;
  }
#line 142
  if (rtype == 162UL) {
#line 142
    goto case_162;
  }
#line 143
  if (rtype == 163UL) {
#line 143
    goto case_163;
  }
#line 144
  if (rtype == 164UL) {
#line 144
    goto case_164;
  }
#line 145
  if (rtype == 165UL) {
#line 145
    goto case_165;
  }
#line 146
  if (rtype == 166UL) {
#line 146
    goto case_166;
  }
#line 147
  if (rtype == 169UL) {
#line 147
    goto case_169;
  }
#line 148
  if (rtype == 170UL) {
#line 148
    goto case_170;
  }
#line 150
  if (rtype == 172UL) {
#line 150
    goto case_172;
  }
#line 151
  if (rtype == 173UL) {
#line 151
    goto case_173;
  }
#line 157
  if (rtype == 248UL) {
#line 157
    goto case_248;
  }
#line 158
  if (rtype == 249UL) {
#line 158
    goto case_249;
  }
#line 160
  if (rtype == 250UL) {
#line 160
    goto case_250;
  }
#line 162
  if (rtype == 253UL) {
#line 162
    goto case_253;
  }
#line 163
  if (rtype == 254UL) {
#line 163
    goto case_254;
  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
#line 37
  return ("R_MIPS_NONE");
  case_1: /* CIL Label */ 
#line 38
  return ("R_MIPS_16");
  case_2: /* CIL Label */ 
#line 39
  return ("R_MIPS_32");
  case_3: /* CIL Label */ 
#line 40
  return ("R_MIPS_REL32");
  case_4: /* CIL Label */ 
#line 41
  return ("R_MIPS_26");
  case_5: /* CIL Label */ 
#line 42
  return ("R_MIPS_HI16");
  case_6: /* CIL Label */ 
#line 43
  return ("R_MIPS_LO16");
  case_7: /* CIL Label */ 
#line 44
  return ("R_MIPS_GPREL16");
  case_8: /* CIL Label */ 
#line 45
  return ("R_MIPS_LITERAL");
  case_9: /* CIL Label */ 
#line 46
  return ("R_MIPS_GOT16");
  case_10: /* CIL Label */ 
#line 47
  return ("R_MIPS_PC16");
  case_11: /* CIL Label */ 
#line 48
  return ("R_MIPS_CALL16");
  case_12: /* CIL Label */ 
#line 49
  return ("R_MIPS_GPREL32");
  case_13: /* CIL Label */ 
#line 52
  return ("R_MIPS_UNUSED1");
  case_14: /* CIL Label */ 
#line 53
  return ("R_MIPS_UNUSED2");
  case_15: /* CIL Label */ 
#line 54
  return ("R_MIPS_UNUSED3");
  case_16: /* CIL Label */ 
#line 55
  return ("R_MIPS_SHIFT5");
  case_17: /* CIL Label */ 
#line 56
  return ("R_MIPS_SHIFT6");
  case_18: /* CIL Label */ 
#line 57
  return ("R_MIPS_64");
  case_19: /* CIL Label */ 
#line 58
  return ("R_MIPS_GOT_DISP");
  case_20: /* CIL Label */ 
#line 59
  return ("R_MIPS_GOT_PAGE");
  case_21: /* CIL Label */ 
#line 60
  return ("R_MIPS_GOT_OFST");
  case_22: /* CIL Label */ 
#line 61
  return ("R_MIPS_GOT_HI16");
  case_23: /* CIL Label */ 
#line 62
  return ("R_MIPS_GOT_LO16");
  case_24: /* CIL Label */ 
#line 63
  return ("R_MIPS_SUB");
  case_25: /* CIL Label */ 
#line 64
  return ("R_MIPS_INSERT_A");
  case_26: /* CIL Label */ 
#line 65
  return ("R_MIPS_INSERT_B");
  case_27: /* CIL Label */ 
#line 66
  return ("R_MIPS_DELETE");
  case_28: /* CIL Label */ 
#line 67
  return ("R_MIPS_HIGHER");
  case_29: /* CIL Label */ 
#line 68
  return ("R_MIPS_HIGHEST");
  case_30: /* CIL Label */ 
#line 69
  return ("R_MIPS_CALL_HI16");
  case_31: /* CIL Label */ 
#line 70
  return ("R_MIPS_CALL_LO16");
  case_32: /* CIL Label */ 
#line 71
  return ("R_MIPS_SCN_DISP");
  case_33: /* CIL Label */ 
#line 72
  return ("R_MIPS_REL16");
  case_34: /* CIL Label */ 
#line 73
  return ("R_MIPS_ADD_IMMEDIATE");
  case_35: /* CIL Label */ 
#line 74
  return ("R_MIPS_PJUMP");
  case_36: /* CIL Label */ 
#line 75
  return ("R_MIPS_RELGOT");
  case_37: /* CIL Label */ 
#line 76
  return ("R_MIPS_JALR");
  case_38: /* CIL Label */ 
#line 78
  return ("R_MIPS_TLS_DTPMOD32");
  case_39: /* CIL Label */ 
#line 79
  return ("R_MIPS_TLS_DTPREL32");
  case_40: /* CIL Label */ 
#line 80
  return ("R_MIPS_TLS_DTPMOD64");
  case_41: /* CIL Label */ 
#line 81
  return ("R_MIPS_TLS_DTPREL64");
  case_42: /* CIL Label */ 
#line 82
  return ("R_MIPS_TLS_GD");
  case_43: /* CIL Label */ 
#line 83
  return ("R_MIPS_TLS_LDM");
  case_44: /* CIL Label */ 
#line 84
  return ("R_MIPS_TLS_DTPREL_HI16");
  case_45: /* CIL Label */ 
#line 85
  return ("R_MIPS_TLS_DTPREL_LO16");
  case_46: /* CIL Label */ 
#line 86
  return ("R_MIPS_TLS_GOTTPREL");
  case_47: /* CIL Label */ 
#line 87
  return ("R_MIPS_TLS_TPREL32");
  case_48: /* CIL Label */ 
#line 88
  return ("R_MIPS_TLS_TPREL64");
  case_49: /* CIL Label */ 
#line 89
  return ("R_MIPS_TLS_TPREL_HI16");
  case_50: /* CIL Label */ 
#line 90
  return ("R_MIPS_TLS_TPREL_LO16");
  case_51: /* CIL Label */ 
#line 91
  return ("R_MIPS_GLOB_DAT");
  case_100: /* CIL Label */ 
#line 95
  return ("R_MIPS16_26");
  case_101: /* CIL Label */ 
#line 96
  return ("R_MIPS16_GPREL");
  case_102: /* CIL Label */ 
#line 97
  return ("R_MIPS16_GOT16");
  case_103: /* CIL Label */ 
#line 98
  return ("R_MIPS16_CALL16");
  case_104: /* CIL Label */ 
#line 99
  return ("R_MIPS16_HI16");
  case_105: /* CIL Label */ 
#line 100
  return ("R_MIPS16_LO16");
  case_106: /* CIL Label */ 
#line 101
  return ("R_MIPS16_TLS_GD");
  case_107: /* CIL Label */ 
#line 102
  return ("R_MIPS16_TLS_LDM");
  case_108: /* CIL Label */ 
#line 103
  return ("R_MIPS16_TLS_DTPREL_HI16");
  case_109: /* CIL Label */ 
#line 104
  return ("R_MIPS16_TLS_DTPREL_LO16");
  case_110: /* CIL Label */ 
#line 105
  return ("R_MIPS16_TLS_GOTTPREL");
  case_111: /* CIL Label */ 
#line 106
  return ("R_MIPS16_TLS_TPREL_HI16");
  case_112: /* CIL Label */ 
#line 107
  return ("R_MIPS16_TLS_TPREL_LO16");
  case_126: /* CIL Label */ 
#line 110
  return ("R_MIPS_COPY");
  case_127: /* CIL Label */ 
#line 111
  return ("R_MIPS_JUMP_SLOT");
  case_133: /* CIL Label */ 
#line 115
  return ("R_MICROMIPS_26_S1");
  case_134: /* CIL Label */ 
#line 116
  return ("R_MICROMIPS_HI16");
  case_135: /* CIL Label */ 
#line 117
  return ("R_MICROMIPS_LO16");
  case_136: /* CIL Label */ 
#line 118
  return ("R_MICROMIPS_GPREL16");
  case_137: /* CIL Label */ 
#line 120
  return ("R_MICROMIPS_LITERAL");
  case_138: /* CIL Label */ 
#line 121
  return ("R_MICROMIPS_GOT16");
  case_139: /* CIL Label */ 
#line 123
  return ("R_MICROMIPS_PC7_S1");
  case_140: /* CIL Label */ 
#line 124
  return ("R_MICROMIPS_PC10_S1");
  case_141: /* CIL Label */ 
#line 125
  return ("R_MICROMIPS_PC16_S1");
  case_142: /* CIL Label */ 
#line 126
  return ("R_MICROMIPS_CALL16");
  case_145: /* CIL Label */ 
#line 128
  return ("R_MICROMIPS_GOT_DISP");
  case_146: /* CIL Label */ 
#line 129
  return ("R_MICROMIPS_GOT_PAGE");
  case_147: /* CIL Label */ 
#line 130
  return ("R_MICROMIPS_GOT_OFST");
  case_148: /* CIL Label */ 
#line 131
  return ("R_MICROMIPS_GOT_HI16");
  case_149: /* CIL Label */ 
#line 132
  return ("R_MICROMIPS_GOT_LO16");
  case_150: /* CIL Label */ 
#line 133
  return ("R_MICROMIPS_SUB");
  case_151: /* CIL Label */ 
#line 134
  return ("R_MICROMIPS_HIGHER");
  case_152: /* CIL Label */ 
#line 135
  return ("R_MICROMIPS_HIGHEST");
  case_153: /* CIL Label */ 
#line 136
  return ("R_MICROMIPS_CALL_HI16");
  case_154: /* CIL Label */ 
#line 137
  return ("R_MICROMIPS_CALL_LO16");
  case_155: /* CIL Label */ 
#line 138
  return ("R_MICROMIPS_SCN_DISP");
  case_156: /* CIL Label */ 
#line 139
  return ("R_MICROMIPS_JALR");
  case_157: /* CIL Label */ 
#line 140
  return ("R_MICROMIPS_HI0_LO16");
  case_162: /* CIL Label */ 
#line 142
  return ("R_MICROMIPS_TLS_GD");
  case_163: /* CIL Label */ 
#line 143
  return ("R_MICROMIPS_TLS_LDM");
  case_164: /* CIL Label */ 
#line 144
  return ("R_MICROMIPS_TLS_DTPREL_HI16");
  case_165: /* CIL Label */ 
#line 145
  return ("R_MICROMIPS_TLS_DTPREL_LO16");
  case_166: /* CIL Label */ 
#line 146
  return ("R_MICROMIPS_TLS_GOTTPREL");
  case_169: /* CIL Label */ 
#line 147
  return ("R_MICROMIPS_TLS_TPREL_HI16");
  case_170: /* CIL Label */ 
#line 148
  return ("R_MICROMIPS_TLS_TPREL_LO16");
  case_172: /* CIL Label */ 
#line 150
  return ("R_MICROMIPS_GPREL7_S2");
  case_173: /* CIL Label */ 
#line 151
  return ("R_MICROMIPS_PC23_S2");
  case_248: /* CIL Label */ 
#line 157
  return ("R_MIPS_PC32");
  case_249: /* CIL Label */ 
#line 158
  return ("R_MIPS_EH");
  case_250: /* CIL Label */ 
#line 160
  return ("R_MIPS_GNU_REL16_S2");
  case_253: /* CIL Label */ 
#line 162
  return ("R_MIPS_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 163
  return ("R_MIPS_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 164
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mmix.h"
static char const   *elf_mmix_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mmix.h"
static char const   *elf_mmix_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 33
  if (rtype == 1UL) {
#line 33
    goto case_1;
  }
#line 34
  if (rtype == 2UL) {
#line 34
    goto case_2;
  }
#line 35
  if (rtype == 3UL) {
#line 35
    goto case_3;
  }
#line 36
  if (rtype == 4UL) {
#line 36
    goto case_4;
  }
#line 37
  if (rtype == 5UL) {
#line 37
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 43
  if (rtype == 9UL) {
#line 43
    goto case_9;
  }
#line 44
  if (rtype == 10UL) {
#line 44
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 48
  if (rtype == 12UL) {
#line 48
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 57
  if (rtype == 17UL) {
#line 57
    goto case_17;
  }
#line 58
  if (rtype == 18UL) {
#line 58
    goto case_18;
  }
#line 59
  if (rtype == 19UL) {
#line 59
    goto case_19;
  }
#line 60
  if (rtype == 20UL) {
#line 60
    goto case_20;
  }
#line 61
  if (rtype == 21UL) {
#line 61
    goto case_21;
  }
#line 64
  if (rtype == 22UL) {
#line 64
    goto case_22;
  }
#line 65
  if (rtype == 23UL) {
#line 65
    goto case_23;
  }
#line 66
  if (rtype == 24UL) {
#line 66
    goto case_24;
  }
#line 67
  if (rtype == 25UL) {
#line 67
    goto case_25;
  }
#line 70
  if (rtype == 26UL) {
#line 70
    goto case_26;
  }
#line 71
  if (rtype == 27UL) {
#line 71
    goto case_27;
  }
#line 72
  if (rtype == 28UL) {
#line 72
    goto case_28;
  }
#line 73
  if (rtype == 29UL) {
#line 73
    goto case_29;
  }
#line 76
  if (rtype == 30UL) {
#line 76
    goto case_30;
  }
#line 79
  if (rtype == 31UL) {
#line 79
    goto case_31;
  }
#line 82
  if (rtype == 32UL) {
#line 82
    goto case_32;
  }
#line 85
  if (rtype == 33UL) {
#line 85
    goto case_33;
  }
#line 91
  if (rtype == 34UL) {
#line 91
    goto case_34;
  }
#line 94
  if (rtype == 35UL) {
#line 94
    goto case_35;
  }
#line 97
  if (rtype == 36UL) {
#line 97
    goto case_36;
  }
#line 98
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MMIX_NONE");
  case_1: /* CIL Label */ 
#line 33
  return ("R_MMIX_8");
  case_2: /* CIL Label */ 
#line 34
  return ("R_MMIX_16");
  case_3: /* CIL Label */ 
#line 35
  return ("R_MMIX_24");
  case_4: /* CIL Label */ 
#line 36
  return ("R_MMIX_32");
  case_5: /* CIL Label */ 
#line 37
  return ("R_MMIX_64");
  case_6: /* CIL Label */ 
#line 40
  return ("R_MMIX_PC_8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_MMIX_PC_16");
  case_8: /* CIL Label */ 
#line 42
  return ("R_MMIX_PC_24");
  case_9: /* CIL Label */ 
#line 43
  return ("R_MMIX_PC_32");
  case_10: /* CIL Label */ 
#line 44
  return ("R_MMIX_PC_64");
  case_11: /* CIL Label */ 
#line 47
  return ("R_MMIX_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 48
  return ("R_MMIX_GNU_VTENTRY");
  case_13: /* CIL Label */ 
#line 51
  return ("R_MMIX_GETA");
  case_14: /* CIL Label */ 
#line 52
  return ("R_MMIX_GETA_1");
  case_15: /* CIL Label */ 
#line 53
  return ("R_MMIX_GETA_2");
  case_16: /* CIL Label */ 
#line 54
  return ("R_MMIX_GETA_3");
  case_17: /* CIL Label */ 
#line 57
  return ("R_MMIX_CBRANCH");
  case_18: /* CIL Label */ 
#line 58
  return ("R_MMIX_CBRANCH_J");
  case_19: /* CIL Label */ 
#line 59
  return ("R_MMIX_CBRANCH_1");
  case_20: /* CIL Label */ 
#line 60
  return ("R_MMIX_CBRANCH_2");
  case_21: /* CIL Label */ 
#line 61
  return ("R_MMIX_CBRANCH_3");
  case_22: /* CIL Label */ 
#line 64
  return ("R_MMIX_PUSHJ");
  case_23: /* CIL Label */ 
#line 65
  return ("R_MMIX_PUSHJ_1");
  case_24: /* CIL Label */ 
#line 66
  return ("R_MMIX_PUSHJ_2");
  case_25: /* CIL Label */ 
#line 67
  return ("R_MMIX_PUSHJ_3");
  case_26: /* CIL Label */ 
#line 70
  return ("R_MMIX_JMP");
  case_27: /* CIL Label */ 
#line 71
  return ("R_MMIX_JMP_1");
  case_28: /* CIL Label */ 
#line 72
  return ("R_MMIX_JMP_2");
  case_29: /* CIL Label */ 
#line 73
  return ("R_MMIX_JMP_3");
  case_30: /* CIL Label */ 
#line 76
  return ("R_MMIX_ADDR19");
  case_31: /* CIL Label */ 
#line 79
  return ("R_MMIX_ADDR27");
  case_32: /* CIL Label */ 
#line 82
  return ("R_MMIX_REG_OR_BYTE");
  case_33: /* CIL Label */ 
#line 85
  return ("R_MMIX_REG");
  case_34: /* CIL Label */ 
#line 91
  return ("R_MMIX_BASE_PLUS_OFFSET");
  case_35: /* CIL Label */ 
#line 94
  return ("R_MMIX_LOCAL");
  case_36: /* CIL Label */ 
#line 97
  return ("R_MMIX_PUSHJ_STUBBABLE");
  switch_default: /* CIL Label */ 
#line 98
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mn10200.h"
static char const   *elf_mn10200_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mn10200.h"
static char const   *elf_mn10200_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MN10200_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_MN10200_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_MN10200_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_MN10200_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_MN10200_24");
  case_5: /* CIL Label */ 
#line 35
  return ("R_MN10200_PCREL8");
  case_6: /* CIL Label */ 
#line 36
  return ("R_MN10200_PCREL16");
  case_7: /* CIL Label */ 
#line 37
  return ("R_MN10200_PCREL24");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mn10300.h"
static char const   *elf_mn10300_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mn10300.h"
static char const   *elf_mn10300_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 44
  if (rtype == 14UL) {
#line 44
    goto case_14;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 50
  if (rtype == 20UL) {
#line 50
    goto case_20;
  }
#line 51
  if (rtype == 21UL) {
#line 51
    goto case_21;
  }
#line 52
  if (rtype == 22UL) {
#line 52
    goto case_22;
  }
#line 53
  if (rtype == 23UL) {
#line 53
    goto case_23;
  }
#line 54
  if (rtype == 24UL) {
#line 54
    goto case_24;
  }
#line 55
  if (rtype == 25UL) {
#line 55
    goto case_25;
  }
#line 56
  if (rtype == 26UL) {
#line 56
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 59
  if (rtype == 29UL) {
#line 59
    goto case_29;
  }
#line 60
  if (rtype == 30UL) {
#line 60
    goto case_30;
  }
#line 61
  if (rtype == 31UL) {
#line 61
    goto case_31;
  }
#line 62
  if (rtype == 32UL) {
#line 62
    goto case_32;
  }
#line 63
  if (rtype == 33UL) {
#line 63
    goto case_33;
  }
#line 64
  if (rtype == 34UL) {
#line 64
    goto case_34;
  }
#line 65
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MN10300_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_MN10300_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_MN10300_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_MN10300_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_MN10300_PCREL32");
  case_5: /* CIL Label */ 
#line 35
  return ("R_MN10300_PCREL16");
  case_6: /* CIL Label */ 
#line 36
  return ("R_MN10300_PCREL8");
  case_7: /* CIL Label */ 
#line 37
  return ("R_MN10300_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 38
  return ("R_MN10300_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 39
  return ("R_MN10300_24");
  case_10: /* CIL Label */ 
#line 40
  return ("R_MN10300_GOTPC32");
  case_11: /* CIL Label */ 
#line 41
  return ("R_MN10300_GOTPC16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_MN10300_GOTOFF32");
  case_13: /* CIL Label */ 
#line 43
  return ("R_MN10300_GOTOFF24");
  case_14: /* CIL Label */ 
#line 44
  return ("R_MN10300_GOTOFF16");
  case_15: /* CIL Label */ 
#line 45
  return ("R_MN10300_PLT32");
  case_16: /* CIL Label */ 
#line 46
  return ("R_MN10300_PLT16");
  case_17: /* CIL Label */ 
#line 47
  return ("R_MN10300_GOT32");
  case_18: /* CIL Label */ 
#line 48
  return ("R_MN10300_GOT24");
  case_19: /* CIL Label */ 
#line 49
  return ("R_MN10300_GOT16");
  case_20: /* CIL Label */ 
#line 50
  return ("R_MN10300_COPY");
  case_21: /* CIL Label */ 
#line 51
  return ("R_MN10300_GLOB_DAT");
  case_22: /* CIL Label */ 
#line 52
  return ("R_MN10300_JMP_SLOT");
  case_23: /* CIL Label */ 
#line 53
  return ("R_MN10300_RELATIVE");
  case_24: /* CIL Label */ 
#line 54
  return ("R_MN10300_TLS_GD");
  case_25: /* CIL Label */ 
#line 55
  return ("R_MN10300_TLS_LD");
  case_26: /* CIL Label */ 
#line 56
  return ("R_MN10300_TLS_LDO");
  case_27: /* CIL Label */ 
#line 57
  return ("R_MN10300_TLS_GOTIE");
  case_28: /* CIL Label */ 
#line 58
  return ("R_MN10300_TLS_IE");
  case_29: /* CIL Label */ 
#line 59
  return ("R_MN10300_TLS_LE");
  case_30: /* CIL Label */ 
#line 60
  return ("R_MN10300_TLS_DTPMOD");
  case_31: /* CIL Label */ 
#line 61
  return ("R_MN10300_TLS_DTPOFF");
  case_32: /* CIL Label */ 
#line 62
  return ("R_MN10300_TLS_TPOFF");
  case_33: /* CIL Label */ 
#line 63
  return ("R_MN10300_SYM_DIFF");
  case_34: /* CIL Label */ 
#line 64
  return ("R_MN10300_ALIGN");
  switch_default: /* CIL Label */ 
#line 65
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/moxie.h"
static char const   *elf_moxie_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/moxie.h"
static char const   *elf_moxie_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_MOXIE_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_MOXIE_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_MOXIE_PCREL10");
  switch_default: /* CIL Label */ 
#line 30
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/mt.h"
static char const   *elf_mt_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/mt.h"
static char const   *elf_mt_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_MT_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_MT_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_MT_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_MT_32_PCREL");
  case_4: /* CIL Label */ 
#line 31
  return ("R_MT_PC16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_MT_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_MT_LO16");
  switch_default: /* CIL Label */ 
#line 34
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 63 "./../include/elf/msp430.h"
static char const   *elf_msp430_reloc_type(unsigned long rtype ) ;
#line 63 "./../include/elf/msp430.h"
static char const   *elf_msp430_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 64
  if (rtype == 0UL) {
#line 64
    goto case_0;
  }
#line 65
  if (rtype == 1UL) {
#line 65
    goto case_1;
  }
#line 66
  if (rtype == 2UL) {
#line 66
    goto case_2;
  }
#line 67
  if (rtype == 3UL) {
#line 67
    goto case_3;
  }
#line 68
  if (rtype == 4UL) {
#line 68
    goto case_4;
  }
#line 69
  if (rtype == 5UL) {
#line 69
    goto case_5;
  }
#line 70
  if (rtype == 6UL) {
#line 70
    goto case_6;
  }
#line 71
  if (rtype == 7UL) {
#line 71
    goto case_7;
  }
#line 72
  if (rtype == 8UL) {
#line 72
    goto case_8;
  }
#line 73
  if (rtype == 9UL) {
#line 73
    goto case_9;
  }
#line 74
  if (rtype == 10UL) {
#line 74
    goto case_10;
  }
#line 75
  goto switch_default;
  case_0: /* CIL Label */ 
#line 64
  return ("R_MSP430_NONE");
  case_1: /* CIL Label */ 
#line 65
  return ("R_MSP430_32");
  case_2: /* CIL Label */ 
#line 66
  return ("R_MSP430_10_PCREL");
  case_3: /* CIL Label */ 
#line 67
  return ("R_MSP430_16");
  case_4: /* CIL Label */ 
#line 68
  return ("R_MSP430_16_PCREL");
  case_5: /* CIL Label */ 
#line 69
  return ("R_MSP430_16_BYTE");
  case_6: /* CIL Label */ 
#line 70
  return ("R_MSP430_16_PCREL_BYTE");
  case_7: /* CIL Label */ 
#line 71
  return ("R_MSP430_2X_PCREL");
  case_8: /* CIL Label */ 
#line 72
  return ("R_MSP430_RL_PCREL");
  case_9: /* CIL Label */ 
#line 73
  return ("R_MSP430_8");
  case_10: /* CIL Label */ 
#line 74
  return ("R_MSP430_SYM_DIFF");
  switch_default: /* CIL Label */ 
#line 75
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 77
static char const   *elf_msp430x_reloc_type(unsigned long rtype ) ;
#line 77 "./../include/elf/msp430.h"
static char const   *elf_msp430x_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 78
  if (rtype == 1UL) {
#line 78
    goto case_1;
  }
#line 79
  if (rtype == 2UL) {
#line 79
    goto case_2;
  }
#line 80
  if (rtype == 3UL) {
#line 80
    goto case_3;
  }
#line 81
  if (rtype == 4UL) {
#line 81
    goto case_4;
  }
#line 82
  if (rtype == 5UL) {
#line 82
    goto case_5;
  }
#line 83
  if (rtype == 6UL) {
#line 83
    goto case_6;
  }
#line 84
  if (rtype == 7UL) {
#line 84
    goto case_7;
  }
#line 85
  if (rtype == 8UL) {
#line 85
    goto case_8;
  }
#line 86
  if (rtype == 9UL) {
#line 86
    goto case_9;
  }
#line 87
  if (rtype == 10UL) {
#line 87
    goto case_10;
  }
#line 88
  if (rtype == 11UL) {
#line 88
    goto case_11;
  }
#line 89
  if (rtype == 12UL) {
#line 89
    goto case_12;
  }
#line 90
  if (rtype == 13UL) {
#line 90
    goto case_13;
  }
#line 91
  if (rtype == 14UL) {
#line 91
    goto case_14;
  }
#line 92
  if (rtype == 15UL) {
#line 92
    goto case_15;
  }
#line 93
  if (rtype == 16UL) {
#line 93
    goto case_16;
  }
#line 94
  if (rtype == 17UL) {
#line 94
    goto case_17;
  }
#line 95
  if (rtype == 18UL) {
#line 95
    goto case_18;
  }
#line 96
  if (rtype == 19UL) {
#line 96
    goto case_19;
  }
#line 97
  if (rtype == 20UL) {
#line 97
    goto case_20;
  }
#line 98
  if (rtype == 21UL) {
#line 98
    goto case_21;
  }
#line 99
  goto switch_default;
  case_1: /* CIL Label */ 
#line 78
  return ("R_MSP430_ABS32");
  case_2: /* CIL Label */ 
#line 79
  return ("R_MSP430_ABS16");
  case_3: /* CIL Label */ 
#line 80
  return ("R_MSP430_ABS8");
  case_4: /* CIL Label */ 
#line 81
  return ("R_MSP430_PCR16");
  case_5: /* CIL Label */ 
#line 82
  return ("R_MSP430X_PCR20_EXT_SRC");
  case_6: /* CIL Label */ 
#line 83
  return ("R_MSP430X_PCR20_EXT_DST");
  case_7: /* CIL Label */ 
#line 84
  return ("R_MSP430X_PCR20_EXT_ODST");
  case_8: /* CIL Label */ 
#line 85
  return ("R_MSP430X_ABS20_EXT_SRC");
  case_9: /* CIL Label */ 
#line 86
  return ("R_MSP430X_ABS20_EXT_DST");
  case_10: /* CIL Label */ 
#line 87
  return ("R_MSP430X_ABS20_EXT_ODST");
  case_11: /* CIL Label */ 
#line 88
  return ("R_MSP430X_ABS20_ADR_SRC");
  case_12: /* CIL Label */ 
#line 89
  return ("R_MSP430X_ABS20_ADR_DST");
  case_13: /* CIL Label */ 
#line 90
  return ("R_MSP430X_PCR16");
  case_14: /* CIL Label */ 
#line 91
  return ("R_MSP430X_PCR20_CALL");
  case_15: /* CIL Label */ 
#line 92
  return ("R_MSP430X_ABS16");
  case_16: /* CIL Label */ 
#line 93
  return ("R_MSP430_ABS_HI16");
  case_17: /* CIL Label */ 
#line 94
  return ("R_MSP430_PREL31");
  case_18: /* CIL Label */ 
#line 95
  return ("R_MSP430_EHTYPE");
  case_19: /* CIL Label */ 
#line 96
  return ("R_MSP430X_10_PCREL");
  case_20: /* CIL Label */ 
#line 97
  return ("R_MSP430X_2X_PCREL");
  case_21: /* CIL Label */ 
#line 98
  return ("R_MSP430X_SYM_DIFF");
  switch_default: /* CIL Label */ 
#line 99
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "./../include/elf/nios2.h"
static char const   *elf_nios2_reloc_type(unsigned long rtype ) ;
#line 36 "./../include/elf/nios2.h"
static char const   *elf_nios2_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 37
  if (rtype == 0UL) {
#line 37
    goto case_0;
  }
#line 38
  if (rtype == 1UL) {
#line 38
    goto case_1;
  }
#line 39
  if (rtype == 2UL) {
#line 39
    goto case_2;
  }
#line 40
  if (rtype == 3UL) {
#line 40
    goto case_3;
  }
#line 41
  if (rtype == 4UL) {
#line 41
    goto case_4;
  }
#line 42
  if (rtype == 5UL) {
#line 42
    goto case_5;
  }
#line 43
  if (rtype == 6UL) {
#line 43
    goto case_6;
  }
#line 44
  if (rtype == 7UL) {
#line 44
    goto case_7;
  }
#line 45
  if (rtype == 8UL) {
#line 45
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 48
  if (rtype == 11UL) {
#line 48
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 50
  if (rtype == 13UL) {
#line 50
    goto case_13;
  }
#line 51
  if (rtype == 14UL) {
#line 51
    goto case_14;
  }
#line 52
  if (rtype == 15UL) {
#line 52
    goto case_15;
  }
#line 53
  if (rtype == 16UL) {
#line 53
    goto case_16;
  }
#line 54
  if (rtype == 17UL) {
#line 54
    goto case_17;
  }
#line 55
  if (rtype == 18UL) {
#line 55
    goto case_18;
  }
#line 56
  if (rtype == 19UL) {
#line 56
    goto case_19;
  }
#line 57
  if (rtype == 20UL) {
#line 57
    goto case_20;
  }
#line 58
  if (rtype == 21UL) {
#line 58
    goto case_21;
  }
#line 59
  if (rtype == 22UL) {
#line 59
    goto case_22;
  }
#line 60
  if (rtype == 23UL) {
#line 60
    goto case_23;
  }
#line 61
  if (rtype == 24UL) {
#line 61
    goto case_24;
  }
#line 62
  if (rtype == 25UL) {
#line 62
    goto case_25;
  }
#line 63
  if (rtype == 26UL) {
#line 63
    goto case_26;
  }
#line 64
  if (rtype == 27UL) {
#line 64
    goto case_27;
  }
#line 65
  if (rtype == 28UL) {
#line 65
    goto case_28;
  }
#line 66
  if (rtype == 29UL) {
#line 66
    goto case_29;
  }
#line 67
  if (rtype == 30UL) {
#line 67
    goto case_30;
  }
#line 68
  if (rtype == 31UL) {
#line 68
    goto case_31;
  }
#line 69
  if (rtype == 32UL) {
#line 69
    goto case_32;
  }
#line 70
  if (rtype == 33UL) {
#line 70
    goto case_33;
  }
#line 71
  if (rtype == 34UL) {
#line 71
    goto case_34;
  }
#line 72
  if (rtype == 35UL) {
#line 72
    goto case_35;
  }
#line 73
  if (rtype == 36UL) {
#line 73
    goto case_36;
  }
#line 74
  if (rtype == 37UL) {
#line 74
    goto case_37;
  }
#line 75
  if (rtype == 38UL) {
#line 75
    goto case_38;
  }
#line 76
  if (rtype == 39UL) {
#line 76
    goto case_39;
  }
#line 77
  if (rtype == 40UL) {
#line 77
    goto case_40;
  }
#line 78
  if (rtype == 41UL) {
#line 78
    goto case_41;
  }
#line 79
  goto switch_default;
  case_0: /* CIL Label */ 
#line 37
  return ("R_NIOS2_NONE");
  case_1: /* CIL Label */ 
#line 38
  return ("R_NIOS2_S16");
  case_2: /* CIL Label */ 
#line 39
  return ("R_NIOS2_U16");
  case_3: /* CIL Label */ 
#line 40
  return ("R_NIOS2_PCREL16");
  case_4: /* CIL Label */ 
#line 41
  return ("R_NIOS2_CALL26");
  case_5: /* CIL Label */ 
#line 42
  return ("R_NIOS2_IMM5");
  case_6: /* CIL Label */ 
#line 43
  return ("R_NIOS2_CACHE_OPX");
  case_7: /* CIL Label */ 
#line 44
  return ("R_NIOS2_IMM6");
  case_8: /* CIL Label */ 
#line 45
  return ("R_NIOS2_IMM8");
  case_9: /* CIL Label */ 
#line 46
  return ("R_NIOS2_HI16");
  case_10: /* CIL Label */ 
#line 47
  return ("R_NIOS2_LO16");
  case_11: /* CIL Label */ 
#line 48
  return ("R_NIOS2_HIADJ16");
  case_12: /* CIL Label */ 
#line 49
  return ("R_NIOS2_BFD_RELOC_32");
  case_13: /* CIL Label */ 
#line 50
  return ("R_NIOS2_BFD_RELOC_16");
  case_14: /* CIL Label */ 
#line 51
  return ("R_NIOS2_BFD_RELOC_8");
  case_15: /* CIL Label */ 
#line 52
  return ("R_NIOS2_GPREL");
  case_16: /* CIL Label */ 
#line 53
  return ("R_NIOS2_GNU_VTINHERIT");
  case_17: /* CIL Label */ 
#line 54
  return ("R_NIOS2_GNU_VTENTRY");
  case_18: /* CIL Label */ 
#line 55
  return ("R_NIOS2_UJMP");
  case_19: /* CIL Label */ 
#line 56
  return ("R_NIOS2_CJMP");
  case_20: /* CIL Label */ 
#line 57
  return ("R_NIOS2_CALLR");
  case_21: /* CIL Label */ 
#line 58
  return ("R_NIOS2_ALIGN");
  case_22: /* CIL Label */ 
#line 59
  return ("R_NIOS2_GOT16");
  case_23: /* CIL Label */ 
#line 60
  return ("R_NIOS2_CALL16");
  case_24: /* CIL Label */ 
#line 61
  return ("R_NIOS2_GOTOFF_LO");
  case_25: /* CIL Label */ 
#line 62
  return ("R_NIOS2_GOTOFF_HA");
  case_26: /* CIL Label */ 
#line 63
  return ("R_NIOS2_PCREL_LO");
  case_27: /* CIL Label */ 
#line 64
  return ("R_NIOS2_PCREL_HA");
  case_28: /* CIL Label */ 
#line 65
  return ("R_NIOS2_TLS_GD16");
  case_29: /* CIL Label */ 
#line 66
  return ("R_NIOS2_TLS_LDM16");
  case_30: /* CIL Label */ 
#line 67
  return ("R_NIOS2_TLS_LDO16");
  case_31: /* CIL Label */ 
#line 68
  return ("R_NIOS2_TLS_IE16");
  case_32: /* CIL Label */ 
#line 69
  return ("R_NIOS2_TLS_LE16");
  case_33: /* CIL Label */ 
#line 70
  return ("R_NIOS2_TLS_DTPMOD");
  case_34: /* CIL Label */ 
#line 71
  return ("R_NIOS2_TLS_DTPREL");
  case_35: /* CIL Label */ 
#line 72
  return ("R_NIOS2_TLS_TPREL");
  case_36: /* CIL Label */ 
#line 73
  return ("R_NIOS2_COPY");
  case_37: /* CIL Label */ 
#line 74
  return ("R_NIOS2_GLOB_DAT");
  case_38: /* CIL Label */ 
#line 75
  return ("R_NIOS2_JUMP_SLOT");
  case_39: /* CIL Label */ 
#line 76
  return ("R_NIOS2_RELATIVE");
  case_40: /* CIL Label */ 
#line 77
  return ("R_NIOS2_GOTOFF");
  case_41: /* CIL Label */ 
#line 78
  return ("R_NIOS2_ILLEGAL");
  switch_default: /* CIL Label */ 
#line 79
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/or32.h"
static char const   *elf_or32_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/or32.h"
static char const   *elf_or32_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_OR32_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_OR32_32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_OR32_16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_OR32_8");
  case_4: /* CIL Label */ 
#line 33
  return ("R_OR32_CONST");
  case_5: /* CIL Label */ 
#line 34
  return ("R_OR32_CONSTH");
  case_6: /* CIL Label */ 
#line 35
  return ("R_OR32_JUMPTARG");
  case_7: /* CIL Label */ 
#line 36
  return ("R_OR32_GNU_VTENTRY");
  case_8: /* CIL Label */ 
#line 37
  return ("R_OR32_GNU_VTINHERIT");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/pj.h"
static char const   *elf_pj_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/pj.h"
static char const   *elf_pj_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 6UL) {
#line 32
    goto case_6;
  }
#line 33
  if (rtype == 7UL) {
#line 33
    goto case_7;
  }
#line 34
  if (rtype == 13UL) {
#line 34
    goto case_13;
  }
#line 35
  if (rtype == 14UL) {
#line 35
    goto case_14;
  }
#line 36
  if (rtype == 15UL) {
#line 36
    goto case_15;
  }
#line 37
  if (rtype == 16UL) {
#line 37
    goto case_16;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_PJ_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_PJ_DATA_DIR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_PJ_CODE_REL32");
  case_3: /* CIL Label */ 
#line 31
  return ("R_PJ_CODE_REL16");
  case_6: /* CIL Label */ 
#line 32
  return ("R_PJ_CODE_DIR32");
  case_7: /* CIL Label */ 
#line 33
  return ("R_PJ_CODE_DIR16");
  case_13: /* CIL Label */ 
#line 34
  return ("R_PJ_CODE_LO16");
  case_14: /* CIL Label */ 
#line 35
  return ("R_PJ_CODE_HI16");
  case_15: /* CIL Label */ 
#line 36
  return ("R_PJ_GNU_VTINHERIT");
  case_16: /* CIL Label */ 
#line 37
  return ("R_PJ_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "./../include/elf/ppc.h"
static char const   *elf_ppc_reloc_type(unsigned long rtype ) ;
#line 36 "./../include/elf/ppc.h"
static char const   *elf_ppc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 37
  if (rtype == 0UL) {
#line 37
    goto case_0;
  }
#line 38
  if (rtype == 1UL) {
#line 38
    goto case_1;
  }
#line 39
  if (rtype == 2UL) {
#line 39
    goto case_2;
  }
#line 40
  if (rtype == 3UL) {
#line 40
    goto case_3;
  }
#line 41
  if (rtype == 4UL) {
#line 41
    goto case_4;
  }
#line 42
  if (rtype == 5UL) {
#line 42
    goto case_5;
  }
#line 43
  if (rtype == 6UL) {
#line 43
    goto case_6;
  }
#line 44
  if (rtype == 7UL) {
#line 44
    goto case_7;
  }
#line 45
  if (rtype == 8UL) {
#line 45
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 48
  if (rtype == 11UL) {
#line 48
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 50
  if (rtype == 13UL) {
#line 50
    goto case_13;
  }
#line 51
  if (rtype == 14UL) {
#line 51
    goto case_14;
  }
#line 52
  if (rtype == 15UL) {
#line 52
    goto case_15;
  }
#line 53
  if (rtype == 16UL) {
#line 53
    goto case_16;
  }
#line 54
  if (rtype == 17UL) {
#line 54
    goto case_17;
  }
#line 55
  if (rtype == 18UL) {
#line 55
    goto case_18;
  }
#line 56
  if (rtype == 19UL) {
#line 56
    goto case_19;
  }
#line 57
  if (rtype == 20UL) {
#line 57
    goto case_20;
  }
#line 58
  if (rtype == 21UL) {
#line 58
    goto case_21;
  }
#line 59
  if (rtype == 22UL) {
#line 59
    goto case_22;
  }
#line 60
  if (rtype == 23UL) {
#line 60
    goto case_23;
  }
#line 61
  if (rtype == 24UL) {
#line 61
    goto case_24;
  }
#line 62
  if (rtype == 25UL) {
#line 62
    goto case_25;
  }
#line 63
  if (rtype == 26UL) {
#line 63
    goto case_26;
  }
#line 64
  if (rtype == 27UL) {
#line 64
    goto case_27;
  }
#line 65
  if (rtype == 28UL) {
#line 65
    goto case_28;
  }
#line 66
  if (rtype == 29UL) {
#line 66
    goto case_29;
  }
#line 67
  if (rtype == 30UL) {
#line 67
    goto case_30;
  }
#line 68
  if (rtype == 31UL) {
#line 68
    goto case_31;
  }
#line 69
  if (rtype == 32UL) {
#line 69
    goto case_32;
  }
#line 70
  if (rtype == 33UL) {
#line 70
    goto case_33;
  }
#line 71
  if (rtype == 34UL) {
#line 71
    goto case_34;
  }
#line 72
  if (rtype == 35UL) {
#line 72
    goto case_35;
  }
#line 73
  if (rtype == 36UL) {
#line 73
    goto case_36;
  }
#line 74
  if (rtype == 37UL) {
#line 74
    goto case_37;
  }
#line 84
  if (rtype == 67UL) {
#line 84
    goto case_67;
  }
#line 85
  if (rtype == 68UL) {
#line 85
    goto case_68;
  }
#line 86
  if (rtype == 69UL) {
#line 86
    goto case_69;
  }
#line 87
  if (rtype == 70UL) {
#line 87
    goto case_70;
  }
#line 88
  if (rtype == 71UL) {
#line 88
    goto case_71;
  }
#line 89
  if (rtype == 72UL) {
#line 89
    goto case_72;
  }
#line 90
  if (rtype == 73UL) {
#line 90
    goto case_73;
  }
#line 91
  if (rtype == 74UL) {
#line 91
    goto case_74;
  }
#line 92
  if (rtype == 75UL) {
#line 92
    goto case_75;
  }
#line 93
  if (rtype == 76UL) {
#line 93
    goto case_76;
  }
#line 94
  if (rtype == 77UL) {
#line 94
    goto case_77;
  }
#line 95
  if (rtype == 78UL) {
#line 95
    goto case_78;
  }
#line 96
  if (rtype == 79UL) {
#line 96
    goto case_79;
  }
#line 97
  if (rtype == 80UL) {
#line 97
    goto case_80;
  }
#line 98
  if (rtype == 81UL) {
#line 98
    goto case_81;
  }
#line 99
  if (rtype == 82UL) {
#line 99
    goto case_82;
  }
#line 100
  if (rtype == 83UL) {
#line 100
    goto case_83;
  }
#line 101
  if (rtype == 84UL) {
#line 101
    goto case_84;
  }
#line 102
  if (rtype == 85UL) {
#line 102
    goto case_85;
  }
#line 103
  if (rtype == 86UL) {
#line 103
    goto case_86;
  }
#line 104
  if (rtype == 87UL) {
#line 104
    goto case_87;
  }
#line 105
  if (rtype == 88UL) {
#line 105
    goto case_88;
  }
#line 106
  if (rtype == 89UL) {
#line 106
    goto case_89;
  }
#line 107
  if (rtype == 90UL) {
#line 107
    goto case_90;
  }
#line 108
  if (rtype == 91UL) {
#line 108
    goto case_91;
  }
#line 109
  if (rtype == 92UL) {
#line 109
    goto case_92;
  }
#line 110
  if (rtype == 93UL) {
#line 110
    goto case_93;
  }
#line 111
  if (rtype == 94UL) {
#line 111
    goto case_94;
  }
#line 112
  if (rtype == 95UL) {
#line 112
    goto case_95;
  }
#line 113
  if (rtype == 96UL) {
#line 113
    goto case_96;
  }
#line 117
  if (rtype == 101UL) {
#line 117
    goto case_101;
  }
#line 118
  if (rtype == 102UL) {
#line 118
    goto case_102;
  }
#line 119
  if (rtype == 103UL) {
#line 119
    goto case_103;
  }
#line 120
  if (rtype == 104UL) {
#line 120
    goto case_104;
  }
#line 121
  if (rtype == 105UL) {
#line 121
    goto case_105;
  }
#line 122
  if (rtype == 106UL) {
#line 122
    goto case_106;
  }
#line 123
  if (rtype == 107UL) {
#line 123
    goto case_107;
  }
#line 124
  if (rtype == 108UL) {
#line 124
    goto case_108;
  }
#line 125
  if (rtype == 109UL) {
#line 125
    goto case_109;
  }
#line 126
  if (rtype == 110UL) {
#line 126
    goto case_110;
  }
#line 127
  if (rtype == 111UL) {
#line 127
    goto case_111;
  }
#line 128
  if (rtype == 112UL) {
#line 128
    goto case_112;
  }
#line 129
  if (rtype == 113UL) {
#line 129
    goto case_113;
  }
#line 130
  if (rtype == 114UL) {
#line 130
    goto case_114;
  }
#line 131
  if (rtype == 115UL) {
#line 131
    goto case_115;
  }
#line 132
  if (rtype == 116UL) {
#line 132
    goto case_116;
  }
#line 135
  if (rtype == 216UL) {
#line 135
    goto case_216;
  }
#line 136
  if (rtype == 217UL) {
#line 136
    goto case_217;
  }
#line 137
  if (rtype == 218UL) {
#line 137
    goto case_218;
  }
#line 138
  if (rtype == 219UL) {
#line 138
    goto case_219;
  }
#line 139
  if (rtype == 220UL) {
#line 139
    goto case_220;
  }
#line 140
  if (rtype == 221UL) {
#line 140
    goto case_221;
  }
#line 141
  if (rtype == 222UL) {
#line 141
    goto case_222;
  }
#line 142
  if (rtype == 223UL) {
#line 142
    goto case_223;
  }
#line 143
  if (rtype == 224UL) {
#line 143
    goto case_224;
  }
#line 144
  if (rtype == 225UL) {
#line 144
    goto case_225;
  }
#line 145
  if (rtype == 226UL) {
#line 145
    goto case_226;
  }
#line 146
  if (rtype == 227UL) {
#line 146
    goto case_227;
  }
#line 147
  if (rtype == 228UL) {
#line 147
    goto case_228;
  }
#line 148
  if (rtype == 229UL) {
#line 148
    goto case_229;
  }
#line 149
  if (rtype == 230UL) {
#line 149
    goto case_230;
  }
#line 150
  if (rtype == 231UL) {
#line 150
    goto case_231;
  }
#line 151
  if (rtype == 232UL) {
#line 151
    goto case_232;
  }
#line 154
  if (rtype == 248UL) {
#line 154
    goto case_248;
  }
#line 157
  if (rtype == 249UL) {
#line 157
    goto case_249;
  }
#line 158
  if (rtype == 250UL) {
#line 158
    goto case_250;
  }
#line 159
  if (rtype == 251UL) {
#line 159
    goto case_251;
  }
#line 160
  if (rtype == 252UL) {
#line 160
    goto case_252;
  }
#line 163
  if (rtype == 253UL) {
#line 163
    goto case_253;
  }
#line 164
  if (rtype == 254UL) {
#line 164
    goto case_254;
  }
#line 168
  if (rtype == 255UL) {
#line 168
    goto case_255;
  }
#line 170
  goto switch_default;
  case_0: /* CIL Label */ 
#line 37
  return ("R_PPC_NONE");
  case_1: /* CIL Label */ 
#line 38
  return ("R_PPC_ADDR32");
  case_2: /* CIL Label */ 
#line 39
  return ("R_PPC_ADDR24");
  case_3: /* CIL Label */ 
#line 40
  return ("R_PPC_ADDR16");
  case_4: /* CIL Label */ 
#line 41
  return ("R_PPC_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 42
  return ("R_PPC_ADDR16_HI");
  case_6: /* CIL Label */ 
#line 43
  return ("R_PPC_ADDR16_HA");
  case_7: /* CIL Label */ 
#line 44
  return ("R_PPC_ADDR14");
  case_8: /* CIL Label */ 
#line 45
  return ("R_PPC_ADDR14_BRTAKEN");
  case_9: /* CIL Label */ 
#line 46
  return ("R_PPC_ADDR14_BRNTAKEN");
  case_10: /* CIL Label */ 
#line 47
  return ("R_PPC_REL24");
  case_11: /* CIL Label */ 
#line 48
  return ("R_PPC_REL14");
  case_12: /* CIL Label */ 
#line 49
  return ("R_PPC_REL14_BRTAKEN");
  case_13: /* CIL Label */ 
#line 50
  return ("R_PPC_REL14_BRNTAKEN");
  case_14: /* CIL Label */ 
#line 51
  return ("R_PPC_GOT16");
  case_15: /* CIL Label */ 
#line 52
  return ("R_PPC_GOT16_LO");
  case_16: /* CIL Label */ 
#line 53
  return ("R_PPC_GOT16_HI");
  case_17: /* CIL Label */ 
#line 54
  return ("R_PPC_GOT16_HA");
  case_18: /* CIL Label */ 
#line 55
  return ("R_PPC_PLTREL24");
  case_19: /* CIL Label */ 
#line 56
  return ("R_PPC_COPY");
  case_20: /* CIL Label */ 
#line 57
  return ("R_PPC_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 58
  return ("R_PPC_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 59
  return ("R_PPC_RELATIVE");
  case_23: /* CIL Label */ 
#line 60
  return ("R_PPC_LOCAL24PC");
  case_24: /* CIL Label */ 
#line 61
  return ("R_PPC_UADDR32");
  case_25: /* CIL Label */ 
#line 62
  return ("R_PPC_UADDR16");
  case_26: /* CIL Label */ 
#line 63
  return ("R_PPC_REL32");
  case_27: /* CIL Label */ 
#line 64
  return ("R_PPC_PLT32");
  case_28: /* CIL Label */ 
#line 65
  return ("R_PPC_PLTREL32");
  case_29: /* CIL Label */ 
#line 66
  return ("R_PPC_PLT16_LO");
  case_30: /* CIL Label */ 
#line 67
  return ("R_PPC_PLT16_HI");
  case_31: /* CIL Label */ 
#line 68
  return ("R_PPC_PLT16_HA");
  case_32: /* CIL Label */ 
#line 69
  return ("R_PPC_SDAREL16");
  case_33: /* CIL Label */ 
#line 70
  return ("R_PPC_SECTOFF");
  case_34: /* CIL Label */ 
#line 71
  return ("R_PPC_SECTOFF_LO");
  case_35: /* CIL Label */ 
#line 72
  return ("R_PPC_SECTOFF_HI");
  case_36: /* CIL Label */ 
#line 73
  return ("R_PPC_SECTOFF_HA");
  case_37: /* CIL Label */ 
#line 74
  return ("R_PPC_ADDR30");
  case_67: /* CIL Label */ 
#line 84
  return ("R_PPC_TLS");
  case_68: /* CIL Label */ 
#line 85
  return ("R_PPC_DTPMOD32");
  case_69: /* CIL Label */ 
#line 86
  return ("R_PPC_TPREL16");
  case_70: /* CIL Label */ 
#line 87
  return ("R_PPC_TPREL16_LO");
  case_71: /* CIL Label */ 
#line 88
  return ("R_PPC_TPREL16_HI");
  case_72: /* CIL Label */ 
#line 89
  return ("R_PPC_TPREL16_HA");
  case_73: /* CIL Label */ 
#line 90
  return ("R_PPC_TPREL32");
  case_74: /* CIL Label */ 
#line 91
  return ("R_PPC_DTPREL16");
  case_75: /* CIL Label */ 
#line 92
  return ("R_PPC_DTPREL16_LO");
  case_76: /* CIL Label */ 
#line 93
  return ("R_PPC_DTPREL16_HI");
  case_77: /* CIL Label */ 
#line 94
  return ("R_PPC_DTPREL16_HA");
  case_78: /* CIL Label */ 
#line 95
  return ("R_PPC_DTPREL32");
  case_79: /* CIL Label */ 
#line 96
  return ("R_PPC_GOT_TLSGD16");
  case_80: /* CIL Label */ 
#line 97
  return ("R_PPC_GOT_TLSGD16_LO");
  case_81: /* CIL Label */ 
#line 98
  return ("R_PPC_GOT_TLSGD16_HI");
  case_82: /* CIL Label */ 
#line 99
  return ("R_PPC_GOT_TLSGD16_HA");
  case_83: /* CIL Label */ 
#line 100
  return ("R_PPC_GOT_TLSLD16");
  case_84: /* CIL Label */ 
#line 101
  return ("R_PPC_GOT_TLSLD16_LO");
  case_85: /* CIL Label */ 
#line 102
  return ("R_PPC_GOT_TLSLD16_HI");
  case_86: /* CIL Label */ 
#line 103
  return ("R_PPC_GOT_TLSLD16_HA");
  case_87: /* CIL Label */ 
#line 104
  return ("R_PPC_GOT_TPREL16");
  case_88: /* CIL Label */ 
#line 105
  return ("R_PPC_GOT_TPREL16_LO");
  case_89: /* CIL Label */ 
#line 106
  return ("R_PPC_GOT_TPREL16_HI");
  case_90: /* CIL Label */ 
#line 107
  return ("R_PPC_GOT_TPREL16_HA");
  case_91: /* CIL Label */ 
#line 108
  return ("R_PPC_GOT_DTPREL16");
  case_92: /* CIL Label */ 
#line 109
  return ("R_PPC_GOT_DTPREL16_LO");
  case_93: /* CIL Label */ 
#line 110
  return ("R_PPC_GOT_DTPREL16_HI");
  case_94: /* CIL Label */ 
#line 111
  return ("R_PPC_GOT_DTPREL16_HA");
  case_95: /* CIL Label */ 
#line 112
  return ("R_PPC_TLSGD");
  case_96: /* CIL Label */ 
#line 113
  return ("R_PPC_TLSLD");
  case_101: /* CIL Label */ 
#line 117
  return ("R_PPC_EMB_NADDR32");
  case_102: /* CIL Label */ 
#line 118
  return ("R_PPC_EMB_NADDR16");
  case_103: /* CIL Label */ 
#line 119
  return ("R_PPC_EMB_NADDR16_LO");
  case_104: /* CIL Label */ 
#line 120
  return ("R_PPC_EMB_NADDR16_HI");
  case_105: /* CIL Label */ 
#line 121
  return ("R_PPC_EMB_NADDR16_HA");
  case_106: /* CIL Label */ 
#line 122
  return ("R_PPC_EMB_SDAI16");
  case_107: /* CIL Label */ 
#line 123
  return ("R_PPC_EMB_SDA2I16");
  case_108: /* CIL Label */ 
#line 124
  return ("R_PPC_EMB_SDA2REL");
  case_109: /* CIL Label */ 
#line 125
  return ("R_PPC_EMB_SDA21");
  case_110: /* CIL Label */ 
#line 126
  return ("R_PPC_EMB_MRKREF");
  case_111: /* CIL Label */ 
#line 127
  return ("R_PPC_EMB_RELSEC16");
  case_112: /* CIL Label */ 
#line 128
  return ("R_PPC_EMB_RELST_LO");
  case_113: /* CIL Label */ 
#line 129
  return ("R_PPC_EMB_RELST_HI");
  case_114: /* CIL Label */ 
#line 130
  return ("R_PPC_EMB_RELST_HA");
  case_115: /* CIL Label */ 
#line 131
  return ("R_PPC_EMB_BIT_FLD");
  case_116: /* CIL Label */ 
#line 132
  return ("R_PPC_EMB_RELSDA");
  case_216: /* CIL Label */ 
#line 135
  return ("R_PPC_VLE_REL8");
  case_217: /* CIL Label */ 
#line 136
  return ("R_PPC_VLE_REL15");
  case_218: /* CIL Label */ 
#line 137
  return ("R_PPC_VLE_REL24");
  case_219: /* CIL Label */ 
#line 138
  return ("R_PPC_VLE_LO16A");
  case_220: /* CIL Label */ 
#line 139
  return ("R_PPC_VLE_LO16D");
  case_221: /* CIL Label */ 
#line 140
  return ("R_PPC_VLE_HI16A");
  case_222: /* CIL Label */ 
#line 141
  return ("R_PPC_VLE_HI16D");
  case_223: /* CIL Label */ 
#line 142
  return ("R_PPC_VLE_HA16A");
  case_224: /* CIL Label */ 
#line 143
  return ("R_PPC_VLE_HA16D");
  case_225: /* CIL Label */ 
#line 144
  return ("R_PPC_VLE_SDA21");
  case_226: /* CIL Label */ 
#line 145
  return ("R_PPC_VLE_SDA21_LO");
  case_227: /* CIL Label */ 
#line 146
  return ("R_PPC_VLE_SDAREL_LO16A");
  case_228: /* CIL Label */ 
#line 147
  return ("R_PPC_VLE_SDAREL_LO16D");
  case_229: /* CIL Label */ 
#line 148
  return ("R_PPC_VLE_SDAREL_HI16A");
  case_230: /* CIL Label */ 
#line 149
  return ("R_PPC_VLE_SDAREL_HI16D");
  case_231: /* CIL Label */ 
#line 150
  return ("R_PPC_VLE_SDAREL_HA16A");
  case_232: /* CIL Label */ 
#line 151
  return ("R_PPC_VLE_SDAREL_HA16D");
  case_248: /* CIL Label */ 
#line 154
  return ("R_PPC_IRELATIVE");
  case_249: /* CIL Label */ 
#line 157
  return ("R_PPC_REL16");
  case_250: /* CIL Label */ 
#line 158
  return ("R_PPC_REL16_LO");
  case_251: /* CIL Label */ 
#line 159
  return ("R_PPC_REL16_HI");
  case_252: /* CIL Label */ 
#line 160
  return ("R_PPC_REL16_HA");
  case_253: /* CIL Label */ 
#line 163
  return ("R_PPC_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 164
  return ("R_PPC_GNU_VTENTRY");
  case_255: /* CIL Label */ 
#line 168
  return ("R_PPC_TOC16");
  switch_default: /* CIL Label */ 
#line 170
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/ppc64.h"
static char const   *elf_ppc64_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/ppc64.h"
static char const   *elf_ppc64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 52
  if (rtype == 24UL) {
#line 52
    goto case_24;
  }
#line 53
  if (rtype == 25UL) {
#line 53
    goto case_25;
  }
#line 54
  if (rtype == 26UL) {
#line 54
    goto case_26;
  }
#line 55
  if (rtype == 27UL) {
#line 55
    goto case_27;
  }
#line 56
  if (rtype == 28UL) {
#line 56
    goto case_28;
  }
#line 57
  if (rtype == 29UL) {
#line 57
    goto case_29;
  }
#line 58
  if (rtype == 30UL) {
#line 58
    goto case_30;
  }
#line 59
  if (rtype == 31UL) {
#line 59
    goto case_31;
  }
#line 61
  if (rtype == 33UL) {
#line 61
    goto case_33;
  }
#line 62
  if (rtype == 34UL) {
#line 62
    goto case_34;
  }
#line 63
  if (rtype == 35UL) {
#line 63
    goto case_35;
  }
#line 64
  if (rtype == 36UL) {
#line 64
    goto case_36;
  }
#line 65
  if (rtype == 37UL) {
#line 65
    goto case_37;
  }
#line 66
  if (rtype == 38UL) {
#line 66
    goto case_38;
  }
#line 67
  if (rtype == 39UL) {
#line 67
    goto case_39;
  }
#line 68
  if (rtype == 40UL) {
#line 68
    goto case_40;
  }
#line 69
  if (rtype == 41UL) {
#line 69
    goto case_41;
  }
#line 70
  if (rtype == 42UL) {
#line 70
    goto case_42;
  }
#line 71
  if (rtype == 43UL) {
#line 71
    goto case_43;
  }
#line 72
  if (rtype == 44UL) {
#line 72
    goto case_44;
  }
#line 73
  if (rtype == 45UL) {
#line 73
    goto case_45;
  }
#line 74
  if (rtype == 46UL) {
#line 74
    goto case_46;
  }
#line 75
  if (rtype == 47UL) {
#line 75
    goto case_47;
  }
#line 76
  if (rtype == 48UL) {
#line 76
    goto case_48;
  }
#line 77
  if (rtype == 49UL) {
#line 77
    goto case_49;
  }
#line 78
  if (rtype == 50UL) {
#line 78
    goto case_50;
  }
#line 79
  if (rtype == 51UL) {
#line 79
    goto case_51;
  }
#line 80
  if (rtype == 52UL) {
#line 80
    goto case_52;
  }
#line 81
  if (rtype == 53UL) {
#line 81
    goto case_53;
  }
#line 82
  if (rtype == 54UL) {
#line 82
    goto case_54;
  }
#line 83
  if (rtype == 55UL) {
#line 83
    goto case_55;
  }
#line 87
  if (rtype == 56UL) {
#line 87
    goto case_56;
  }
#line 88
  if (rtype == 57UL) {
#line 88
    goto case_57;
  }
#line 89
  if (rtype == 58UL) {
#line 89
    goto case_58;
  }
#line 90
  if (rtype == 59UL) {
#line 90
    goto case_59;
  }
#line 91
  if (rtype == 60UL) {
#line 91
    goto case_60;
  }
#line 92
  if (rtype == 61UL) {
#line 92
    goto case_61;
  }
#line 93
  if (rtype == 62UL) {
#line 93
    goto case_62;
  }
#line 94
  if (rtype == 63UL) {
#line 94
    goto case_63;
  }
#line 95
  if (rtype == 64UL) {
#line 95
    goto case_64;
  }
#line 96
  if (rtype == 65UL) {
#line 96
    goto case_65;
  }
#line 97
  if (rtype == 66UL) {
#line 97
    goto case_66;
  }
#line 100
  if (rtype == 67UL) {
#line 100
    goto case_67;
  }
#line 101
  if (rtype == 68UL) {
#line 101
    goto case_68;
  }
#line 102
  if (rtype == 69UL) {
#line 102
    goto case_69;
  }
#line 103
  if (rtype == 70UL) {
#line 103
    goto case_70;
  }
#line 104
  if (rtype == 71UL) {
#line 104
    goto case_71;
  }
#line 105
  if (rtype == 72UL) {
#line 105
    goto case_72;
  }
#line 106
  if (rtype == 73UL) {
#line 106
    goto case_73;
  }
#line 107
  if (rtype == 74UL) {
#line 107
    goto case_74;
  }
#line 108
  if (rtype == 75UL) {
#line 108
    goto case_75;
  }
#line 109
  if (rtype == 76UL) {
#line 109
    goto case_76;
  }
#line 110
  if (rtype == 77UL) {
#line 110
    goto case_77;
  }
#line 111
  if (rtype == 78UL) {
#line 111
    goto case_78;
  }
#line 112
  if (rtype == 79UL) {
#line 112
    goto case_79;
  }
#line 113
  if (rtype == 80UL) {
#line 113
    goto case_80;
  }
#line 114
  if (rtype == 81UL) {
#line 114
    goto case_81;
  }
#line 115
  if (rtype == 82UL) {
#line 115
    goto case_82;
  }
#line 116
  if (rtype == 83UL) {
#line 116
    goto case_83;
  }
#line 117
  if (rtype == 84UL) {
#line 117
    goto case_84;
  }
#line 118
  if (rtype == 85UL) {
#line 118
    goto case_85;
  }
#line 119
  if (rtype == 86UL) {
#line 119
    goto case_86;
  }
#line 120
  if (rtype == 87UL) {
#line 120
    goto case_87;
  }
#line 121
  if (rtype == 88UL) {
#line 121
    goto case_88;
  }
#line 122
  if (rtype == 89UL) {
#line 122
    goto case_89;
  }
#line 123
  if (rtype == 90UL) {
#line 123
    goto case_90;
  }
#line 124
  if (rtype == 91UL) {
#line 124
    goto case_91;
  }
#line 125
  if (rtype == 92UL) {
#line 125
    goto case_92;
  }
#line 126
  if (rtype == 93UL) {
#line 126
    goto case_93;
  }
#line 127
  if (rtype == 94UL) {
#line 127
    goto case_94;
  }
#line 128
  if (rtype == 95UL) {
#line 128
    goto case_95;
  }
#line 129
  if (rtype == 96UL) {
#line 129
    goto case_96;
  }
#line 130
  if (rtype == 97UL) {
#line 130
    goto case_97;
  }
#line 131
  if (rtype == 98UL) {
#line 131
    goto case_98;
  }
#line 132
  if (rtype == 99UL) {
#line 132
    goto case_99;
  }
#line 133
  if (rtype == 100UL) {
#line 133
    goto case_100;
  }
#line 134
  if (rtype == 101UL) {
#line 134
    goto case_101;
  }
#line 135
  if (rtype == 102UL) {
#line 135
    goto case_102;
  }
#line 136
  if (rtype == 103UL) {
#line 136
    goto case_103;
  }
#line 137
  if (rtype == 104UL) {
#line 137
    goto case_104;
  }
#line 138
  if (rtype == 105UL) {
#line 138
    goto case_105;
  }
#line 139
  if (rtype == 106UL) {
#line 139
    goto case_106;
  }
#line 140
  if (rtype == 107UL) {
#line 140
    goto case_107;
  }
#line 141
  if (rtype == 108UL) {
#line 141
    goto case_108;
  }
#line 142
  if (rtype == 109UL) {
#line 142
    goto case_109;
  }
#line 145
  if (rtype == 110UL) {
#line 145
    goto case_110;
  }
#line 146
  if (rtype == 111UL) {
#line 146
    goto case_111;
  }
#line 147
  if (rtype == 112UL) {
#line 147
    goto case_112;
  }
#line 148
  if (rtype == 113UL) {
#line 148
    goto case_113;
  }
#line 149
  if (rtype == 114UL) {
#line 149
    goto case_114;
  }
#line 150
  if (rtype == 115UL) {
#line 150
    goto case_115;
  }
#line 157
  if (rtype == 247UL) {
#line 157
    goto case_247;
  }
#line 158
  if (rtype == 248UL) {
#line 158
    goto case_248;
  }
#line 161
  if (rtype == 249UL) {
#line 161
    goto case_249;
  }
#line 162
  if (rtype == 250UL) {
#line 162
    goto case_250;
  }
#line 163
  if (rtype == 251UL) {
#line 163
    goto case_251;
  }
#line 164
  if (rtype == 252UL) {
#line 164
    goto case_252;
  }
#line 167
  if (rtype == 253UL) {
#line 167
    goto case_253;
  }
#line 168
  if (rtype == 254UL) {
#line 168
    goto case_254;
  }
#line 170
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_PPC64_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_PPC64_ADDR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_PPC64_ADDR24");
  case_3: /* CIL Label */ 
#line 31
  return ("R_PPC64_ADDR16");
  case_4: /* CIL Label */ 
#line 32
  return ("R_PPC64_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 33
  return ("R_PPC64_ADDR16_HI");
  case_6: /* CIL Label */ 
#line 34
  return ("R_PPC64_ADDR16_HA");
  case_7: /* CIL Label */ 
#line 35
  return ("R_PPC64_ADDR14");
  case_8: /* CIL Label */ 
#line 36
  return ("R_PPC64_ADDR14_BRTAKEN");
  case_9: /* CIL Label */ 
#line 37
  return ("R_PPC64_ADDR14_BRNTAKEN");
  case_10: /* CIL Label */ 
#line 38
  return ("R_PPC64_REL24");
  case_11: /* CIL Label */ 
#line 39
  return ("R_PPC64_REL14");
  case_12: /* CIL Label */ 
#line 40
  return ("R_PPC64_REL14_BRTAKEN");
  case_13: /* CIL Label */ 
#line 41
  return ("R_PPC64_REL14_BRNTAKEN");
  case_14: /* CIL Label */ 
#line 42
  return ("R_PPC64_GOT16");
  case_15: /* CIL Label */ 
#line 43
  return ("R_PPC64_GOT16_LO");
  case_16: /* CIL Label */ 
#line 44
  return ("R_PPC64_GOT16_HI");
  case_17: /* CIL Label */ 
#line 45
  return ("R_PPC64_GOT16_HA");
  case_19: /* CIL Label */ 
#line 47
  return ("R_PPC64_COPY");
  case_20: /* CIL Label */ 
#line 48
  return ("R_PPC64_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 49
  return ("R_PPC64_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 50
  return ("R_PPC64_RELATIVE");
  case_24: /* CIL Label */ 
#line 52
  return ("R_PPC64_UADDR32");
  case_25: /* CIL Label */ 
#line 53
  return ("R_PPC64_UADDR16");
  case_26: /* CIL Label */ 
#line 54
  return ("R_PPC64_REL32");
  case_27: /* CIL Label */ 
#line 55
  return ("R_PPC64_PLT32");
  case_28: /* CIL Label */ 
#line 56
  return ("R_PPC64_PLTREL32");
  case_29: /* CIL Label */ 
#line 57
  return ("R_PPC64_PLT16_LO");
  case_30: /* CIL Label */ 
#line 58
  return ("R_PPC64_PLT16_HI");
  case_31: /* CIL Label */ 
#line 59
  return ("R_PPC64_PLT16_HA");
  case_33: /* CIL Label */ 
#line 61
  return ("R_PPC64_SECTOFF");
  case_34: /* CIL Label */ 
#line 62
  return ("R_PPC64_SECTOFF_LO");
  case_35: /* CIL Label */ 
#line 63
  return ("R_PPC64_SECTOFF_HI");
  case_36: /* CIL Label */ 
#line 64
  return ("R_PPC64_SECTOFF_HA");
  case_37: /* CIL Label */ 
#line 65
  return ("R_PPC64_REL30");
  case_38: /* CIL Label */ 
#line 66
  return ("R_PPC64_ADDR64");
  case_39: /* CIL Label */ 
#line 67
  return ("R_PPC64_ADDR16_HIGHER");
  case_40: /* CIL Label */ 
#line 68
  return ("R_PPC64_ADDR16_HIGHERA");
  case_41: /* CIL Label */ 
#line 69
  return ("R_PPC64_ADDR16_HIGHEST");
  case_42: /* CIL Label */ 
#line 70
  return ("R_PPC64_ADDR16_HIGHESTA");
  case_43: /* CIL Label */ 
#line 71
  return ("R_PPC64_UADDR64");
  case_44: /* CIL Label */ 
#line 72
  return ("R_PPC64_REL64");
  case_45: /* CIL Label */ 
#line 73
  return ("R_PPC64_PLT64");
  case_46: /* CIL Label */ 
#line 74
  return ("R_PPC64_PLTREL64");
  case_47: /* CIL Label */ 
#line 75
  return ("R_PPC64_TOC16");
  case_48: /* CIL Label */ 
#line 76
  return ("R_PPC64_TOC16_LO");
  case_49: /* CIL Label */ 
#line 77
  return ("R_PPC64_TOC16_HI");
  case_50: /* CIL Label */ 
#line 78
  return ("R_PPC64_TOC16_HA");
  case_51: /* CIL Label */ 
#line 79
  return ("R_PPC64_TOC");
  case_52: /* CIL Label */ 
#line 80
  return ("R_PPC64_PLTGOT16");
  case_53: /* CIL Label */ 
#line 81
  return ("R_PPC64_PLTGOT16_LO");
  case_54: /* CIL Label */ 
#line 82
  return ("R_PPC64_PLTGOT16_HI");
  case_55: /* CIL Label */ 
#line 83
  return ("R_PPC64_PLTGOT16_HA");
  case_56: /* CIL Label */ 
#line 87
  return ("R_PPC64_ADDR16_DS");
  case_57: /* CIL Label */ 
#line 88
  return ("R_PPC64_ADDR16_LO_DS");
  case_58: /* CIL Label */ 
#line 89
  return ("R_PPC64_GOT16_DS");
  case_59: /* CIL Label */ 
#line 90
  return ("R_PPC64_GOT16_LO_DS");
  case_60: /* CIL Label */ 
#line 91
  return ("R_PPC64_PLT16_LO_DS");
  case_61: /* CIL Label */ 
#line 92
  return ("R_PPC64_SECTOFF_DS");
  case_62: /* CIL Label */ 
#line 93
  return ("R_PPC64_SECTOFF_LO_DS");
  case_63: /* CIL Label */ 
#line 94
  return ("R_PPC64_TOC16_DS");
  case_64: /* CIL Label */ 
#line 95
  return ("R_PPC64_TOC16_LO_DS");
  case_65: /* CIL Label */ 
#line 96
  return ("R_PPC64_PLTGOT16_DS");
  case_66: /* CIL Label */ 
#line 97
  return ("R_PPC64_PLTGOT16_LO_DS");
  case_67: /* CIL Label */ 
#line 100
  return ("R_PPC64_TLS");
  case_68: /* CIL Label */ 
#line 101
  return ("R_PPC64_DTPMOD64");
  case_69: /* CIL Label */ 
#line 102
  return ("R_PPC64_TPREL16");
  case_70: /* CIL Label */ 
#line 103
  return ("R_PPC64_TPREL16_LO");
  case_71: /* CIL Label */ 
#line 104
  return ("R_PPC64_TPREL16_HI");
  case_72: /* CIL Label */ 
#line 105
  return ("R_PPC64_TPREL16_HA");
  case_73: /* CIL Label */ 
#line 106
  return ("R_PPC64_TPREL64");
  case_74: /* CIL Label */ 
#line 107
  return ("R_PPC64_DTPREL16");
  case_75: /* CIL Label */ 
#line 108
  return ("R_PPC64_DTPREL16_LO");
  case_76: /* CIL Label */ 
#line 109
  return ("R_PPC64_DTPREL16_HI");
  case_77: /* CIL Label */ 
#line 110
  return ("R_PPC64_DTPREL16_HA");
  case_78: /* CIL Label */ 
#line 111
  return ("R_PPC64_DTPREL64");
  case_79: /* CIL Label */ 
#line 112
  return ("R_PPC64_GOT_TLSGD16");
  case_80: /* CIL Label */ 
#line 113
  return ("R_PPC64_GOT_TLSGD16_LO");
  case_81: /* CIL Label */ 
#line 114
  return ("R_PPC64_GOT_TLSGD16_HI");
  case_82: /* CIL Label */ 
#line 115
  return ("R_PPC64_GOT_TLSGD16_HA");
  case_83: /* CIL Label */ 
#line 116
  return ("R_PPC64_GOT_TLSLD16");
  case_84: /* CIL Label */ 
#line 117
  return ("R_PPC64_GOT_TLSLD16_LO");
  case_85: /* CIL Label */ 
#line 118
  return ("R_PPC64_GOT_TLSLD16_HI");
  case_86: /* CIL Label */ 
#line 119
  return ("R_PPC64_GOT_TLSLD16_HA");
  case_87: /* CIL Label */ 
#line 120
  return ("R_PPC64_GOT_TPREL16_DS");
  case_88: /* CIL Label */ 
#line 121
  return ("R_PPC64_GOT_TPREL16_LO_DS");
  case_89: /* CIL Label */ 
#line 122
  return ("R_PPC64_GOT_TPREL16_HI");
  case_90: /* CIL Label */ 
#line 123
  return ("R_PPC64_GOT_TPREL16_HA");
  case_91: /* CIL Label */ 
#line 124
  return ("R_PPC64_GOT_DTPREL16_DS");
  case_92: /* CIL Label */ 
#line 125
  return ("R_PPC64_GOT_DTPREL16_LO_DS");
  case_93: /* CIL Label */ 
#line 126
  return ("R_PPC64_GOT_DTPREL16_HI");
  case_94: /* CIL Label */ 
#line 127
  return ("R_PPC64_GOT_DTPREL16_HA");
  case_95: /* CIL Label */ 
#line 128
  return ("R_PPC64_TPREL16_DS");
  case_96: /* CIL Label */ 
#line 129
  return ("R_PPC64_TPREL16_LO_DS");
  case_97: /* CIL Label */ 
#line 130
  return ("R_PPC64_TPREL16_HIGHER");
  case_98: /* CIL Label */ 
#line 131
  return ("R_PPC64_TPREL16_HIGHERA");
  case_99: /* CIL Label */ 
#line 132
  return ("R_PPC64_TPREL16_HIGHEST");
  case_100: /* CIL Label */ 
#line 133
  return ("R_PPC64_TPREL16_HIGHESTA");
  case_101: /* CIL Label */ 
#line 134
  return ("R_PPC64_DTPREL16_DS");
  case_102: /* CIL Label */ 
#line 135
  return ("R_PPC64_DTPREL16_LO_DS");
  case_103: /* CIL Label */ 
#line 136
  return ("R_PPC64_DTPREL16_HIGHER");
  case_104: /* CIL Label */ 
#line 137
  return ("R_PPC64_DTPREL16_HIGHERA");
  case_105: /* CIL Label */ 
#line 138
  return ("R_PPC64_DTPREL16_HIGHEST");
  case_106: /* CIL Label */ 
#line 139
  return ("R_PPC64_DTPREL16_HIGHESTA");
  case_107: /* CIL Label */ 
#line 140
  return ("R_PPC64_TLSGD");
  case_108: /* CIL Label */ 
#line 141
  return ("R_PPC64_TLSLD");
  case_109: /* CIL Label */ 
#line 142
  return ("R_PPC64_TOCSAVE");
  case_110: /* CIL Label */ 
#line 145
  return ("R_PPC64_ADDR16_HIGH");
  case_111: /* CIL Label */ 
#line 146
  return ("R_PPC64_ADDR16_HIGHA");
  case_112: /* CIL Label */ 
#line 147
  return ("R_PPC64_TPREL16_HIGH");
  case_113: /* CIL Label */ 
#line 148
  return ("R_PPC64_TPREL16_HIGHA");
  case_114: /* CIL Label */ 
#line 149
  return ("R_PPC64_DTPREL16_HIGH");
  case_115: /* CIL Label */ 
#line 150
  return ("R_PPC64_DTPREL16_HIGHA");
  case_247: /* CIL Label */ 
#line 157
  return ("R_PPC64_JMP_IREL");
  case_248: /* CIL Label */ 
#line 158
  return ("R_PPC64_IRELATIVE");
  case_249: /* CIL Label */ 
#line 161
  return ("R_PPC64_REL16");
  case_250: /* CIL Label */ 
#line 162
  return ("R_PPC64_REL16_LO");
  case_251: /* CIL Label */ 
#line 163
  return ("R_PPC64_REL16_HI");
  case_252: /* CIL Label */ 
#line 164
  return ("R_PPC64_REL16_HA");
  case_253: /* CIL Label */ 
#line 167
  return ("R_PPC64_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 168
  return ("R_PPC64_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 170
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 203 "./../include/elf/ppc64.h"
__inline static unsigned int ppc64_decode_local_entry(unsigned int other ) 
{ 


  {
#line 206
  return ((unsigned int )(((1 << other) >> 2) << 2));
}
}
#line 31 "./../include/elf/rl78.h"
static char const   *elf_rl78_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/rl78.h"
static char const   *elf_rl78_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 33
  if (rtype == 0UL) {
#line 33
    goto case_0;
  }
#line 35
  if (rtype == 1UL) {
#line 35
    goto case_1;
  }
#line 36
  if (rtype == 2UL) {
#line 36
    goto case_2;
  }
#line 37
  if (rtype == 3UL) {
#line 37
    goto case_3;
  }
#line 38
  if (rtype == 4UL) {
#line 38
    goto case_4;
  }
#line 39
  if (rtype == 5UL) {
#line 39
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 45
  if (rtype == 9UL) {
#line 45
    goto case_9;
  }
#line 46
  if (rtype == 10UL) {
#line 46
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 50
  if (rtype == 12UL) {
#line 50
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 55
  if (rtype == 17UL) {
#line 55
    goto case_17;
  }
#line 56
  if (rtype == 18UL) {
#line 56
    goto case_18;
  }
#line 59
  if (rtype == 45UL) {
#line 59
    goto case_45;
  }
#line 60
  if (rtype == 46UL) {
#line 60
    goto case_46;
  }
#line 61
  if (rtype == 47UL) {
#line 61
    goto case_47;
  }
#line 64
  if (rtype == 65UL) {
#line 64
    goto case_65;
  }
#line 65
  if (rtype == 66UL) {
#line 65
    goto case_66;
  }
#line 66
  if (rtype == 67UL) {
#line 66
    goto case_67;
  }
#line 67
  if (rtype == 68UL) {
#line 67
    goto case_68;
  }
#line 68
  if (rtype == 69UL) {
#line 68
    goto case_69;
  }
#line 69
  if (rtype == 70UL) {
#line 69
    goto case_70;
  }
#line 70
  if (rtype == 71UL) {
#line 70
    goto case_71;
  }
#line 71
  if (rtype == 72UL) {
#line 71
    goto case_72;
  }
#line 72
  if (rtype == 73UL) {
#line 72
    goto case_73;
  }
#line 73
  if (rtype == 74UL) {
#line 73
    goto case_74;
  }
#line 74
  if (rtype == 75UL) {
#line 74
    goto case_75;
  }
#line 75
  if (rtype == 76UL) {
#line 75
    goto case_76;
  }
#line 76
  if (rtype == 77UL) {
#line 76
    goto case_77;
  }
#line 77
  if (rtype == 78UL) {
#line 77
    goto case_78;
  }
#line 78
  if (rtype == 79UL) {
#line 78
    goto case_79;
  }
#line 79
  if (rtype == 80UL) {
#line 79
    goto case_80;
  }
#line 80
  if (rtype == 81UL) {
#line 80
    goto case_81;
  }
#line 82
  if (rtype == 128UL) {
#line 82
    goto case_128;
  }
#line 83
  if (rtype == 129UL) {
#line 83
    goto case_129;
  }
#line 84
  if (rtype == 130UL) {
#line 84
    goto case_130;
  }
#line 85
  if (rtype == 131UL) {
#line 85
    goto case_131;
  }
#line 86
  if (rtype == 132UL) {
#line 86
    goto case_132;
  }
#line 87
  if (rtype == 133UL) {
#line 87
    goto case_133;
  }
#line 88
  if (rtype == 134UL) {
#line 88
    goto case_134;
  }
#line 89
  if (rtype == 135UL) {
#line 89
    goto case_135;
  }
#line 90
  if (rtype == 136UL) {
#line 90
    goto case_136;
  }
#line 91
  if (rtype == 141UL) {
#line 91
    goto case_141;
  }
#line 92
  if (rtype == 144UL) {
#line 92
    goto case_144;
  }
#line 93
  if (rtype == 145UL) {
#line 93
    goto case_145;
  }
#line 94
  if (rtype == 146UL) {
#line 94
    goto case_146;
  }
#line 95
  if (rtype == 147UL) {
#line 95
    goto case_147;
  }
#line 96
  if (rtype == 148UL) {
#line 96
    goto case_148;
  }
#line 97
  if (rtype == 149UL) {
#line 97
    goto case_149;
  }
#line 98
  if (rtype == 150UL) {
#line 98
    goto case_150;
  }
#line 100
  goto switch_default;
  case_0: /* CIL Label */ 
#line 33
  return ("R_RL78_NONE");
  case_1: /* CIL Label */ 
#line 35
  return ("R_RL78_DIR32");
  case_2: /* CIL Label */ 
#line 36
  return ("R_RL78_DIR24S");
  case_3: /* CIL Label */ 
#line 37
  return ("R_RL78_DIR16");
  case_4: /* CIL Label */ 
#line 38
  return ("R_RL78_DIR16U");
  case_5: /* CIL Label */ 
#line 39
  return ("R_RL78_DIR16S");
  case_6: /* CIL Label */ 
#line 40
  return ("R_RL78_DIR8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_RL78_DIR8U");
  case_8: /* CIL Label */ 
#line 42
  return ("R_RL78_DIR8S");
  case_9: /* CIL Label */ 
#line 45
  return ("R_RL78_DIR24S_PCREL");
  case_10: /* CIL Label */ 
#line 46
  return ("R_RL78_DIR16S_PCREL");
  case_11: /* CIL Label */ 
#line 47
  return ("R_RL78_DIR8S_PCREL");
  case_12: /* CIL Label */ 
#line 50
  return ("R_RL78_DIR16UL");
  case_13: /* CIL Label */ 
#line 51
  return ("R_RL78_DIR16UW");
  case_14: /* CIL Label */ 
#line 52
  return ("R_RL78_DIR8UL");
  case_15: /* CIL Label */ 
#line 53
  return ("R_RL78_DIR8UW");
  case_16: /* CIL Label */ 
#line 54
  return ("R_RL78_DIR32_REV");
  case_17: /* CIL Label */ 
#line 55
  return ("R_RL78_DIR16_REV");
  case_18: /* CIL Label */ 
#line 56
  return ("R_RL78_DIR3U_PCREL");
  case_45: /* CIL Label */ 
#line 59
  return ("R_RL78_RH_RELAX");
  case_46: /* CIL Label */ 
#line 60
  return ("R_RL78_RH_SFR");
  case_47: /* CIL Label */ 
#line 61
  return ("R_RL78_RH_SADDR");
  case_65: /* CIL Label */ 
#line 64
  return ("R_RL78_ABS32");
  case_66: /* CIL Label */ 
#line 65
  return ("R_RL78_ABS24S");
  case_67: /* CIL Label */ 
#line 66
  return ("R_RL78_ABS16");
  case_68: /* CIL Label */ 
#line 67
  return ("R_RL78_ABS16U");
  case_69: /* CIL Label */ 
#line 68
  return ("R_RL78_ABS16S");
  case_70: /* CIL Label */ 
#line 69
  return ("R_RL78_ABS8");
  case_71: /* CIL Label */ 
#line 70
  return ("R_RL78_ABS8U");
  case_72: /* CIL Label */ 
#line 71
  return ("R_RL78_ABS8S");
  case_73: /* CIL Label */ 
#line 72
  return ("R_RL78_ABS24S_PCREL");
  case_74: /* CIL Label */ 
#line 73
  return ("R_RL78_ABS16S_PCREL");
  case_75: /* CIL Label */ 
#line 74
  return ("R_RL78_ABS8S_PCREL");
  case_76: /* CIL Label */ 
#line 75
  return ("R_RL78_ABS16UL");
  case_77: /* CIL Label */ 
#line 76
  return ("R_RL78_ABS16UW");
  case_78: /* CIL Label */ 
#line 77
  return ("R_RL78_ABS8UL");
  case_79: /* CIL Label */ 
#line 78
  return ("R_RL78_ABS8UW");
  case_80: /* CIL Label */ 
#line 79
  return ("R_RL78_ABS32_REV");
  case_81: /* CIL Label */ 
#line 80
  return ("R_RL78_ABS16_REV");
  case_128: /* CIL Label */ 
#line 82
  return ("R_RL78_SYM");
  case_129: /* CIL Label */ 
#line 83
  return ("R_RL78_OPneg");
  case_130: /* CIL Label */ 
#line 84
  return ("R_RL78_OPadd");
  case_131: /* CIL Label */ 
#line 85
  return ("R_RL78_OPsub");
  case_132: /* CIL Label */ 
#line 86
  return ("R_RL78_OPmul");
  case_133: /* CIL Label */ 
#line 87
  return ("R_RL78_OPdiv");
  case_134: /* CIL Label */ 
#line 88
  return ("R_RL78_OPshla");
  case_135: /* CIL Label */ 
#line 89
  return ("R_RL78_OPshra");
  case_136: /* CIL Label */ 
#line 90
  return ("R_RL78_OPsctsize");
  case_141: /* CIL Label */ 
#line 91
  return ("R_RL78_OPscttop");
  case_144: /* CIL Label */ 
#line 92
  return ("R_RL78_OPand");
  case_145: /* CIL Label */ 
#line 93
  return ("R_RL78_OPor");
  case_146: /* CIL Label */ 
#line 94
  return ("R_RL78_OPxor");
  case_147: /* CIL Label */ 
#line 95
  return ("R_RL78_OPnot");
  case_148: /* CIL Label */ 
#line 96
  return ("R_RL78_OPmod");
  case_149: /* CIL Label */ 
#line 97
  return ("R_RL78_OPromtop");
  case_150: /* CIL Label */ 
#line 98
  return ("R_RL78_OPramtop");
  switch_default: /* CIL Label */ 
#line 100
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "./../include/elf/rx.h"
static char const   *elf_rx_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/rx.h"
static char const   *elf_rx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 33
  if (rtype == 0UL) {
#line 33
    goto case_0;
  }
#line 35
  if (rtype == 1UL) {
#line 35
    goto case_1;
  }
#line 36
  if (rtype == 2UL) {
#line 36
    goto case_2;
  }
#line 37
  if (rtype == 3UL) {
#line 37
    goto case_3;
  }
#line 38
  if (rtype == 4UL) {
#line 38
    goto case_4;
  }
#line 39
  if (rtype == 5UL) {
#line 39
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 45
  if (rtype == 9UL) {
#line 45
    goto case_9;
  }
#line 46
  if (rtype == 10UL) {
#line 46
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 50
  if (rtype == 12UL) {
#line 50
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 55
  if (rtype == 17UL) {
#line 55
    goto case_17;
  }
#line 56
  if (rtype == 18UL) {
#line 56
    goto case_18;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 65
  if (rtype == 38UL) {
#line 65
    goto case_38;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 41UL) {
#line 68
    goto case_41;
  }
#line 69
  if (rtype == 42UL) {
#line 69
    goto case_42;
  }
#line 70
  if (rtype == 43UL) {
#line 70
    goto case_43;
  }
#line 71
  if (rtype == 44UL) {
#line 71
    goto case_44;
  }
#line 72
  if (rtype == 45UL) {
#line 72
    goto case_45;
  }
#line 75
  if (rtype == 65UL) {
#line 75
    goto case_65;
  }
#line 76
  if (rtype == 66UL) {
#line 76
    goto case_66;
  }
#line 77
  if (rtype == 67UL) {
#line 77
    goto case_67;
  }
#line 78
  if (rtype == 68UL) {
#line 78
    goto case_68;
  }
#line 79
  if (rtype == 69UL) {
#line 79
    goto case_69;
  }
#line 80
  if (rtype == 70UL) {
#line 80
    goto case_70;
  }
#line 81
  if (rtype == 71UL) {
#line 81
    goto case_71;
  }
#line 82
  if (rtype == 72UL) {
#line 82
    goto case_72;
  }
#line 83
  if (rtype == 73UL) {
#line 83
    goto case_73;
  }
#line 84
  if (rtype == 74UL) {
#line 84
    goto case_74;
  }
#line 85
  if (rtype == 75UL) {
#line 85
    goto case_75;
  }
#line 86
  if (rtype == 76UL) {
#line 86
    goto case_76;
  }
#line 87
  if (rtype == 77UL) {
#line 87
    goto case_77;
  }
#line 88
  if (rtype == 78UL) {
#line 88
    goto case_78;
  }
#line 89
  if (rtype == 79UL) {
#line 89
    goto case_79;
  }
#line 90
  if (rtype == 80UL) {
#line 90
    goto case_80;
  }
#line 91
  if (rtype == 81UL) {
#line 91
    goto case_81;
  }
#line 93
  if (rtype == 128UL) {
#line 93
    goto case_128;
  }
#line 94
  if (rtype == 129UL) {
#line 94
    goto case_129;
  }
#line 95
  if (rtype == 130UL) {
#line 95
    goto case_130;
  }
#line 96
  if (rtype == 131UL) {
#line 96
    goto case_131;
  }
#line 97
  if (rtype == 132UL) {
#line 97
    goto case_132;
  }
#line 98
  if (rtype == 133UL) {
#line 98
    goto case_133;
  }
#line 99
  if (rtype == 134UL) {
#line 99
    goto case_134;
  }
#line 100
  if (rtype == 135UL) {
#line 100
    goto case_135;
  }
#line 101
  if (rtype == 136UL) {
#line 101
    goto case_136;
  }
#line 102
  if (rtype == 141UL) {
#line 102
    goto case_141;
  }
#line 103
  if (rtype == 144UL) {
#line 103
    goto case_144;
  }
#line 104
  if (rtype == 145UL) {
#line 104
    goto case_145;
  }
#line 105
  if (rtype == 146UL) {
#line 105
    goto case_146;
  }
#line 106
  if (rtype == 147UL) {
#line 106
    goto case_147;
  }
#line 107
  if (rtype == 148UL) {
#line 107
    goto case_148;
  }
#line 108
  if (rtype == 149UL) {
#line 108
    goto case_149;
  }
#line 109
  if (rtype == 150UL) {
#line 109
    goto case_150;
  }
#line 111
  goto switch_default;
  case_0: /* CIL Label */ 
#line 33
  return ("R_RX_NONE");
  case_1: /* CIL Label */ 
#line 35
  return ("R_RX_DIR32");
  case_2: /* CIL Label */ 
#line 36
  return ("R_RX_DIR24S");
  case_3: /* CIL Label */ 
#line 37
  return ("R_RX_DIR16");
  case_4: /* CIL Label */ 
#line 38
  return ("R_RX_DIR16U");
  case_5: /* CIL Label */ 
#line 39
  return ("R_RX_DIR16S");
  case_6: /* CIL Label */ 
#line 40
  return ("R_RX_DIR8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_RX_DIR8U");
  case_8: /* CIL Label */ 
#line 42
  return ("R_RX_DIR8S");
  case_9: /* CIL Label */ 
#line 45
  return ("R_RX_DIR24S_PCREL");
  case_10: /* CIL Label */ 
#line 46
  return ("R_RX_DIR16S_PCREL");
  case_11: /* CIL Label */ 
#line 47
  return ("R_RX_DIR8S_PCREL");
  case_12: /* CIL Label */ 
#line 50
  return ("R_RX_DIR16UL");
  case_13: /* CIL Label */ 
#line 51
  return ("R_RX_DIR16UW");
  case_14: /* CIL Label */ 
#line 52
  return ("R_RX_DIR8UL");
  case_15: /* CIL Label */ 
#line 53
  return ("R_RX_DIR8UW");
  case_16: /* CIL Label */ 
#line 54
  return ("R_RX_DIR32_REV");
  case_17: /* CIL Label */ 
#line 55
  return ("R_RX_DIR16_REV");
  case_18: /* CIL Label */ 
#line 56
  return ("R_RX_DIR3U_PCREL");
  case_32: /* CIL Label */ 
#line 59
  return ("R_RX_RH_3_PCREL");
  case_33: /* CIL Label */ 
#line 60
  return ("R_RX_RH_16_OP");
  case_34: /* CIL Label */ 
#line 61
  return ("R_RX_RH_24_OP");
  case_35: /* CIL Label */ 
#line 62
  return ("R_RX_RH_32_OP");
  case_36: /* CIL Label */ 
#line 63
  return ("R_RX_RH_24_UNS");
  case_37: /* CIL Label */ 
#line 64
  return ("R_RX_RH_8_NEG");
  case_38: /* CIL Label */ 
#line 65
  return ("R_RX_RH_16_NEG");
  case_39: /* CIL Label */ 
#line 66
  return ("R_RX_RH_24_NEG");
  case_40: /* CIL Label */ 
#line 67
  return ("R_RX_RH_32_NEG");
  case_41: /* CIL Label */ 
#line 68
  return ("R_RX_RH_DIFF");
  case_42: /* CIL Label */ 
#line 69
  return ("R_RX_RH_GPRELB");
  case_43: /* CIL Label */ 
#line 70
  return ("R_RX_RH_GPRELW");
  case_44: /* CIL Label */ 
#line 71
  return ("R_RX_RH_GPRELL");
  case_45: /* CIL Label */ 
#line 72
  return ("R_RX_RH_RELAX");
  case_65: /* CIL Label */ 
#line 75
  return ("R_RX_ABS32");
  case_66: /* CIL Label */ 
#line 76
  return ("R_RX_ABS24S");
  case_67: /* CIL Label */ 
#line 77
  return ("R_RX_ABS16");
  case_68: /* CIL Label */ 
#line 78
  return ("R_RX_ABS16U");
  case_69: /* CIL Label */ 
#line 79
  return ("R_RX_ABS16S");
  case_70: /* CIL Label */ 
#line 80
  return ("R_RX_ABS8");
  case_71: /* CIL Label */ 
#line 81
  return ("R_RX_ABS8U");
  case_72: /* CIL Label */ 
#line 82
  return ("R_RX_ABS8S");
  case_73: /* CIL Label */ 
#line 83
  return ("R_RX_ABS24S_PCREL");
  case_74: /* CIL Label */ 
#line 84
  return ("R_RX_ABS16S_PCREL");
  case_75: /* CIL Label */ 
#line 85
  return ("R_RX_ABS8S_PCREL");
  case_76: /* CIL Label */ 
#line 86
  return ("R_RX_ABS16UL");
  case_77: /* CIL Label */ 
#line 87
  return ("R_RX_ABS16UW");
  case_78: /* CIL Label */ 
#line 88
  return ("R_RX_ABS8UL");
  case_79: /* CIL Label */ 
#line 89
  return ("R_RX_ABS8UW");
  case_80: /* CIL Label */ 
#line 90
  return ("R_RX_ABS32_REV");
  case_81: /* CIL Label */ 
#line 91
  return ("R_RX_ABS16_REV");
  case_128: /* CIL Label */ 
#line 93
  return ("R_RX_SYM");
  case_129: /* CIL Label */ 
#line 94
  return ("R_RX_OPneg");
  case_130: /* CIL Label */ 
#line 95
  return ("R_RX_OPadd");
  case_131: /* CIL Label */ 
#line 96
  return ("R_RX_OPsub");
  case_132: /* CIL Label */ 
#line 97
  return ("R_RX_OPmul");
  case_133: /* CIL Label */ 
#line 98
  return ("R_RX_OPdiv");
  case_134: /* CIL Label */ 
#line 99
  return ("R_RX_OPshla");
  case_135: /* CIL Label */ 
#line 100
  return ("R_RX_OPshra");
  case_136: /* CIL Label */ 
#line 101
  return ("R_RX_OPsctsize");
  case_141: /* CIL Label */ 
#line 102
  return ("R_RX_OPscttop");
  case_144: /* CIL Label */ 
#line 103
  return ("R_RX_OPand");
  case_145: /* CIL Label */ 
#line 104
  return ("R_RX_OPor");
  case_146: /* CIL Label */ 
#line 105
  return ("R_RX_OPxor");
  case_147: /* CIL Label */ 
#line 106
  return ("R_RX_OPnot");
  case_148: /* CIL Label */ 
#line 107
  return ("R_RX_OPmod");
  case_149: /* CIL Label */ 
#line 108
  return ("R_RX_OPromtop");
  case_150: /* CIL Label */ 
#line 109
  return ("R_RX_OPramtop");
  switch_default: /* CIL Label */ 
#line 111
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 42 "./../include/elf/s390.h"
static char const   *elf_s390_reloc_type(unsigned long rtype ) ;
#line 42 "./../include/elf/s390.h"
static char const   *elf_s390_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 43
  if (rtype == 0UL) {
#line 43
    goto case_0;
  }
#line 44
  if (rtype == 1UL) {
#line 44
    goto case_1;
  }
#line 45
  if (rtype == 2UL) {
#line 45
    goto case_2;
  }
#line 46
  if (rtype == 3UL) {
#line 46
    goto case_3;
  }
#line 47
  if (rtype == 4UL) {
#line 47
    goto case_4;
  }
#line 48
  if (rtype == 5UL) {
#line 48
    goto case_5;
  }
#line 49
  if (rtype == 6UL) {
#line 49
    goto case_6;
  }
#line 50
  if (rtype == 7UL) {
#line 50
    goto case_7;
  }
#line 51
  if (rtype == 8UL) {
#line 51
    goto case_8;
  }
#line 52
  if (rtype == 9UL) {
#line 52
    goto case_9;
  }
#line 53
  if (rtype == 10UL) {
#line 53
    goto case_10;
  }
#line 54
  if (rtype == 11UL) {
#line 54
    goto case_11;
  }
#line 55
  if (rtype == 12UL) {
#line 55
    goto case_12;
  }
#line 56
  if (rtype == 13UL) {
#line 56
    goto case_13;
  }
#line 57
  if (rtype == 14UL) {
#line 57
    goto case_14;
  }
#line 58
  if (rtype == 15UL) {
#line 58
    goto case_15;
  }
#line 59
  if (rtype == 16UL) {
#line 59
    goto case_16;
  }
#line 60
  if (rtype == 62UL) {
#line 60
    goto case_62;
  }
#line 61
  if (rtype == 63UL) {
#line 61
    goto case_63;
  }
#line 62
  if (rtype == 17UL) {
#line 62
    goto case_17;
  }
#line 63
  if (rtype == 18UL) {
#line 63
    goto case_18;
  }
#line 64
  if (rtype == 64UL) {
#line 64
    goto case_64;
  }
#line 65
  if (rtype == 65UL) {
#line 65
    goto case_65;
  }
#line 66
  if (rtype == 19UL) {
#line 66
    goto case_19;
  }
#line 67
  if (rtype == 20UL) {
#line 67
    goto case_20;
  }
#line 68
  if (rtype == 21UL) {
#line 68
    goto case_21;
  }
#line 69
  if (rtype == 22UL) {
#line 69
    goto case_22;
  }
#line 70
  if (rtype == 23UL) {
#line 70
    goto case_23;
  }
#line 71
  if (rtype == 24UL) {
#line 71
    goto case_24;
  }
#line 72
  if (rtype == 25UL) {
#line 72
    goto case_25;
  }
#line 73
  if (rtype == 26UL) {
#line 73
    goto case_26;
  }
#line 74
  if (rtype == 27UL) {
#line 74
    goto case_27;
  }
#line 75
  if (rtype == 28UL) {
#line 75
    goto case_28;
  }
#line 76
  if (rtype == 29UL) {
#line 76
    goto case_29;
  }
#line 77
  if (rtype == 30UL) {
#line 77
    goto case_30;
  }
#line 78
  if (rtype == 31UL) {
#line 78
    goto case_31;
  }
#line 79
  if (rtype == 32UL) {
#line 79
    goto case_32;
  }
#line 80
  if (rtype == 33UL) {
#line 80
    goto case_33;
  }
#line 81
  if (rtype == 34UL) {
#line 81
    goto case_34;
  }
#line 82
  if (rtype == 35UL) {
#line 82
    goto case_35;
  }
#line 83
  if (rtype == 36UL) {
#line 83
    goto case_36;
  }
#line 84
  if (rtype == 37UL) {
#line 84
    goto case_37;
  }
#line 85
  if (rtype == 38UL) {
#line 85
    goto case_38;
  }
#line 87
  if (rtype == 39UL) {
#line 87
    goto case_39;
  }
#line 89
  if (rtype == 40UL) {
#line 89
    goto case_40;
  }
#line 91
  if (rtype == 41UL) {
#line 91
    goto case_41;
  }
#line 93
  if (rtype == 42UL) {
#line 93
    goto case_42;
  }
#line 95
  if (rtype == 43UL) {
#line 95
    goto case_43;
  }
#line 97
  if (rtype == 44UL) {
#line 97
    goto case_44;
  }
#line 99
  if (rtype == 45UL) {
#line 99
    goto case_45;
  }
#line 101
  if (rtype == 46UL) {
#line 101
    goto case_46;
  }
#line 103
  if (rtype == 47UL) {
#line 103
    goto case_47;
  }
#line 105
  if (rtype == 48UL) {
#line 105
    goto case_48;
  }
#line 107
  if (rtype == 49UL) {
#line 107
    goto case_49;
  }
#line 109
  if (rtype == 50UL) {
#line 109
    goto case_50;
  }
#line 111
  if (rtype == 51UL) {
#line 111
    goto case_51;
  }
#line 113
  if (rtype == 52UL) {
#line 113
    goto case_52;
  }
#line 115
  if (rtype == 53UL) {
#line 115
    goto case_53;
  }
#line 117
  if (rtype == 54UL) {
#line 117
    goto case_54;
  }
#line 118
  if (rtype == 55UL) {
#line 118
    goto case_55;
  }
#line 119
  if (rtype == 56UL) {
#line 119
    goto case_56;
  }
#line 121
  if (rtype == 57UL) {
#line 121
    goto case_57;
  }
#line 122
  if (rtype == 58UL) {
#line 122
    goto case_58;
  }
#line 123
  if (rtype == 59UL) {
#line 123
    goto case_59;
  }
#line 124
  if (rtype == 60UL) {
#line 124
    goto case_60;
  }
#line 126
  if (rtype == 61UL) {
#line 126
    goto case_61;
  }
#line 128
  if (rtype == 250UL) {
#line 128
    goto case_250;
  }
#line 129
  if (rtype == 251UL) {
#line 129
    goto case_251;
  }
#line 130
  goto switch_default;
  case_0: /* CIL Label */ 
#line 43
  return ("R_390_NONE");
  case_1: /* CIL Label */ 
#line 44
  return ("R_390_8");
  case_2: /* CIL Label */ 
#line 45
  return ("R_390_12");
  case_3: /* CIL Label */ 
#line 46
  return ("R_390_16");
  case_4: /* CIL Label */ 
#line 47
  return ("R_390_32");
  case_5: /* CIL Label */ 
#line 48
  return ("R_390_PC32");
  case_6: /* CIL Label */ 
#line 49
  return ("R_390_GOT12");
  case_7: /* CIL Label */ 
#line 50
  return ("R_390_GOT32");
  case_8: /* CIL Label */ 
#line 51
  return ("R_390_PLT32");
  case_9: /* CIL Label */ 
#line 52
  return ("R_390_COPY");
  case_10: /* CIL Label */ 
#line 53
  return ("R_390_GLOB_DAT");
  case_11: /* CIL Label */ 
#line 54
  return ("R_390_JMP_SLOT");
  case_12: /* CIL Label */ 
#line 55
  return ("R_390_RELATIVE");
  case_13: /* CIL Label */ 
#line 56
  return ("R_390_GOTOFF32");
  case_14: /* CIL Label */ 
#line 57
  return ("R_390_GOTPC");
  case_15: /* CIL Label */ 
#line 58
  return ("R_390_GOT16");
  case_16: /* CIL Label */ 
#line 59
  return ("R_390_PC16");
  case_62: /* CIL Label */ 
#line 60
  return ("R_390_PC12DBL");
  case_63: /* CIL Label */ 
#line 61
  return ("R_390_PLT12DBL");
  case_17: /* CIL Label */ 
#line 62
  return ("R_390_PC16DBL");
  case_18: /* CIL Label */ 
#line 63
  return ("R_390_PLT16DBL");
  case_64: /* CIL Label */ 
#line 64
  return ("R_390_PC24DBL");
  case_65: /* CIL Label */ 
#line 65
  return ("R_390_PLT24DBL");
  case_19: /* CIL Label */ 
#line 66
  return ("R_390_PC32DBL");
  case_20: /* CIL Label */ 
#line 67
  return ("R_390_PLT32DBL");
  case_21: /* CIL Label */ 
#line 68
  return ("R_390_GOTPCDBL");
  case_22: /* CIL Label */ 
#line 69
  return ("R_390_64");
  case_23: /* CIL Label */ 
#line 70
  return ("R_390_PC64");
  case_24: /* CIL Label */ 
#line 71
  return ("R_390_GOT64");
  case_25: /* CIL Label */ 
#line 72
  return ("R_390_PLT64");
  case_26: /* CIL Label */ 
#line 73
  return ("R_390_GOTENT");
  case_27: /* CIL Label */ 
#line 74
  return ("R_390_GOTOFF16");
  case_28: /* CIL Label */ 
#line 75
  return ("R_390_GOTOFF64");
  case_29: /* CIL Label */ 
#line 76
  return ("R_390_GOTPLT12");
  case_30: /* CIL Label */ 
#line 77
  return ("R_390_GOTPLT16");
  case_31: /* CIL Label */ 
#line 78
  return ("R_390_GOTPLT32");
  case_32: /* CIL Label */ 
#line 79
  return ("R_390_GOTPLT64");
  case_33: /* CIL Label */ 
#line 80
  return ("R_390_GOTPLTENT");
  case_34: /* CIL Label */ 
#line 81
  return ("R_390_PLTOFF16");
  case_35: /* CIL Label */ 
#line 82
  return ("R_390_PLTOFF32");
  case_36: /* CIL Label */ 
#line 83
  return ("R_390_PLTOFF64");
  case_37: /* CIL Label */ 
#line 84
  return ("R_390_TLS_LOAD");
  case_38: /* CIL Label */ 
#line 85
  return ("R_390_TLS_GDCALL");
  case_39: /* CIL Label */ 
#line 87
  return ("R_390_TLS_LDCALL");
  case_40: /* CIL Label */ 
#line 89
  return ("R_390_TLS_GD32");
  case_41: /* CIL Label */ 
#line 91
  return ("R_390_TLS_GD64");
  case_42: /* CIL Label */ 
#line 93
  return ("R_390_TLS_GOTIE12");
  case_43: /* CIL Label */ 
#line 95
  return ("R_390_TLS_GOTIE32");
  case_44: /* CIL Label */ 
#line 97
  return ("R_390_TLS_GOTIE64");
  case_45: /* CIL Label */ 
#line 99
  return ("R_390_TLS_LDM32");
  case_46: /* CIL Label */ 
#line 101
  return ("R_390_TLS_LDM64");
  case_47: /* CIL Label */ 
#line 103
  return ("R_390_TLS_IE32");
  case_48: /* CIL Label */ 
#line 105
  return ("R_390_TLS_IE64");
  case_49: /* CIL Label */ 
#line 107
  return ("R_390_TLS_IEENT");
  case_50: /* CIL Label */ 
#line 109
  return ("R_390_TLS_LE32");
  case_51: /* CIL Label */ 
#line 111
  return ("R_390_TLS_LE64");
  case_52: /* CIL Label */ 
#line 113
  return ("R_390_TLS_LDO32");
  case_53: /* CIL Label */ 
#line 115
  return ("R_390_TLS_LDO64");
  case_54: /* CIL Label */ 
#line 117
  return ("R_390_TLS_DTPMOD");
  case_55: /* CIL Label */ 
#line 118
  return ("R_390_TLS_DTPOFF");
  case_56: /* CIL Label */ 
#line 119
  return ("R_390_TLS_TPOFF");
  case_57: /* CIL Label */ 
#line 121
  return ("R_390_20");
  case_58: /* CIL Label */ 
#line 122
  return ("R_390_GOT20");
  case_59: /* CIL Label */ 
#line 123
  return ("R_390_GOTPLT20");
  case_60: /* CIL Label */ 
#line 124
  return ("R_390_TLS_GOTIE20");
  case_61: /* CIL Label */ 
#line 126
  return ("R_390_IRELATIVE");
  case_250: /* CIL Label */ 
#line 128
  return ("R_390_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 129
  return ("R_390_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 130
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 105 "./../include/elf/score.h"
static char const   *elf_score_reloc_type(unsigned long rtype ) ;
#line 105 "./../include/elf/score.h"
static char const   *elf_score_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 106
  if (rtype == 0UL) {
#line 106
    goto case_0;
  }
#line 107
  if (rtype == 1UL) {
#line 107
    goto case_1;
  }
#line 108
  if (rtype == 2UL) {
#line 108
    goto case_2;
  }
#line 109
  if (rtype == 3UL) {
#line 109
    goto case_3;
  }
#line 110
  if (rtype == 4UL) {
#line 110
    goto case_4;
  }
#line 111
  if (rtype == 5UL) {
#line 111
    goto case_5;
  }
#line 112
  if (rtype == 6UL) {
#line 112
    goto case_6;
  }
#line 113
  if (rtype == 7UL) {
#line 113
    goto case_7;
  }
#line 114
  if (rtype == 8UL) {
#line 114
    goto case_8;
  }
#line 115
  if (rtype == 9UL) {
#line 115
    goto case_9;
  }
#line 116
  if (rtype == 10UL) {
#line 116
    goto case_10;
  }
#line 117
  if (rtype == 11UL) {
#line 117
    goto case_11;
  }
#line 118
  if (rtype == 12UL) {
#line 118
    goto case_12;
  }
#line 119
  if (rtype == 13UL) {
#line 119
    goto case_13;
  }
#line 120
  if (rtype == 14UL) {
#line 120
    goto case_14;
  }
#line 121
  if (rtype == 15UL) {
#line 121
    goto case_15;
  }
#line 122
  if (rtype == 16UL) {
#line 122
    goto case_16;
  }
#line 123
  if (rtype == 17UL) {
#line 123
    goto case_17;
  }
#line 124
  if (rtype == 18UL) {
#line 124
    goto case_18;
  }
#line 125
  if (rtype == 19UL) {
#line 125
    goto case_19;
  }
#line 126
  if (rtype == 20UL) {
#line 126
    goto case_20;
  }
#line 127
  if (rtype == 21UL) {
#line 127
    goto case_21;
  }
#line 128
  goto switch_default;
  case_0: /* CIL Label */ 
#line 106
  return ("R_SCORE_NONE");
  case_1: /* CIL Label */ 
#line 107
  return ("R_SCORE_HI16");
  case_2: /* CIL Label */ 
#line 108
  return ("R_SCORE_LO16");
  case_3: /* CIL Label */ 
#line 109
  return ("R_SCORE_BCMP");
  case_4: /* CIL Label */ 
#line 110
  return ("R_SCORE_24");
  case_5: /* CIL Label */ 
#line 111
  return ("R_SCORE_PC19");
  case_6: /* CIL Label */ 
#line 112
  return ("R_SCORE16_11");
  case_7: /* CIL Label */ 
#line 113
  return ("R_SCORE16_PC8");
  case_8: /* CIL Label */ 
#line 114
  return ("R_SCORE_ABS32");
  case_9: /* CIL Label */ 
#line 115
  return ("R_SCORE_ABS16");
  case_10: /* CIL Label */ 
#line 116
  return ("R_SCORE_DUMMY2");
  case_11: /* CIL Label */ 
#line 117
  return ("R_SCORE_GP15");
  case_12: /* CIL Label */ 
#line 118
  return ("R_SCORE_GNU_VTINHERIT");
  case_13: /* CIL Label */ 
#line 119
  return ("R_SCORE_GNU_VTENTRY");
  case_14: /* CIL Label */ 
#line 120
  return ("R_SCORE_GOT15");
  case_15: /* CIL Label */ 
#line 121
  return ("R_SCORE_GOT_LO16");
  case_16: /* CIL Label */ 
#line 122
  return ("R_SCORE_CALL15");
  case_17: /* CIL Label */ 
#line 123
  return ("R_SCORE_GPREL32");
  case_18: /* CIL Label */ 
#line 124
  return ("R_SCORE_REL32");
  case_19: /* CIL Label */ 
#line 125
  return ("R_SCORE_DUMMY_HI16");
  case_20: /* CIL Label */ 
#line 126
  return ("R_SCORE_IMM30");
  case_21: /* CIL Label */ 
#line 127
  return ("R_SCORE_IMM32");
  switch_default: /* CIL Label */ 
#line 128
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 121 "./../include/elf/sh.h"
static char const   *elf_sh_reloc_type(unsigned long rtype ) ;
#line 121 "./../include/elf/sh.h"
static char const   *elf_sh_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 122
  if (rtype == 0UL) {
#line 122
    goto case_0;
  }
#line 123
  if (rtype == 1UL) {
#line 123
    goto case_1;
  }
#line 124
  if (rtype == 2UL) {
#line 124
    goto case_2;
  }
#line 125
  if (rtype == 3UL) {
#line 125
    goto case_3;
  }
#line 126
  if (rtype == 4UL) {
#line 126
    goto case_4;
  }
#line 127
  if (rtype == 5UL) {
#line 127
    goto case_5;
  }
#line 128
  if (rtype == 6UL) {
#line 128
    goto case_6;
  }
#line 129
  if (rtype == 7UL) {
#line 129
    goto case_7;
  }
#line 130
  if (rtype == 8UL) {
#line 130
    goto case_8;
  }
#line 131
  if (rtype == 9UL) {
#line 131
    goto case_9;
  }
#line 133
  if (rtype == 10UL) {
#line 133
    goto case_10;
  }
#line 134
  if (rtype == 11UL) {
#line 134
    goto case_11;
  }
#line 139
  if (rtype == 22UL) {
#line 139
    goto case_22;
  }
#line 140
  if (rtype == 23UL) {
#line 140
    goto case_23;
  }
#line 141
  if (rtype == 24UL) {
#line 141
    goto case_24;
  }
#line 142
  if (rtype == 25UL) {
#line 142
    goto case_25;
  }
#line 143
  if (rtype == 26UL) {
#line 143
    goto case_26;
  }
#line 144
  if (rtype == 27UL) {
#line 144
    goto case_27;
  }
#line 145
  if (rtype == 28UL) {
#line 145
    goto case_28;
  }
#line 146
  if (rtype == 29UL) {
#line 146
    goto case_29;
  }
#line 147
  if (rtype == 30UL) {
#line 147
    goto case_30;
  }
#line 148
  if (rtype == 31UL) {
#line 148
    goto case_31;
  }
#line 149
  if (rtype == 32UL) {
#line 149
    goto case_32;
  }
#line 151
  if (rtype == 33UL) {
#line 151
    goto case_33;
  }
#line 152
  if (rtype == 34UL) {
#line 152
    goto case_34;
  }
#line 153
  if (rtype == 35UL) {
#line 153
    goto case_35;
  }
#line 154
  if (rtype == 36UL) {
#line 154
    goto case_36;
  }
#line 155
  if (rtype == 37UL) {
#line 155
    goto case_37;
  }
#line 156
  if (rtype == 38UL) {
#line 156
    goto case_38;
  }
#line 157
  if (rtype == 39UL) {
#line 157
    goto case_39;
  }
#line 158
  if (rtype == 40UL) {
#line 158
    goto case_40;
  }
#line 159
  if (rtype == 41UL) {
#line 159
    goto case_41;
  }
#line 160
  if (rtype == 42UL) {
#line 160
    goto case_42;
  }
#line 161
  if (rtype == 43UL) {
#line 161
    goto case_43;
  }
#line 162
  if (rtype == 44UL) {
#line 162
    goto case_44;
  }
#line 163
  if (rtype == 45UL) {
#line 163
    goto case_45;
  }
#line 164
  if (rtype == 46UL) {
#line 164
    goto case_46;
  }
#line 165
  if (rtype == 47UL) {
#line 165
    goto case_47;
  }
#line 166
  if (rtype == 48UL) {
#line 166
    goto case_48;
  }
#line 167
  if (rtype == 49UL) {
#line 167
    goto case_49;
  }
#line 168
  if (rtype == 50UL) {
#line 168
    goto case_50;
  }
#line 169
  if (rtype == 51UL) {
#line 169
    goto case_51;
  }
#line 172
  if (rtype == 53UL) {
#line 172
    goto case_53;
  }
#line 175
  if (rtype == 144UL) {
#line 175
    goto case_144;
  }
#line 176
  if (rtype == 145UL) {
#line 176
    goto case_145;
  }
#line 177
  if (rtype == 146UL) {
#line 177
    goto case_146;
  }
#line 178
  if (rtype == 147UL) {
#line 178
    goto case_147;
  }
#line 179
  if (rtype == 148UL) {
#line 179
    goto case_148;
  }
#line 180
  if (rtype == 149UL) {
#line 180
    goto case_149;
  }
#line 181
  if (rtype == 150UL) {
#line 181
    goto case_150;
  }
#line 182
  if (rtype == 151UL) {
#line 182
    goto case_151;
  }
#line 185
  if (rtype == 160UL) {
#line 185
    goto case_160;
  }
#line 186
  if (rtype == 161UL) {
#line 186
    goto case_161;
  }
#line 187
  if (rtype == 162UL) {
#line 187
    goto case_162;
  }
#line 188
  if (rtype == 163UL) {
#line 188
    goto case_163;
  }
#line 189
  if (rtype == 164UL) {
#line 189
    goto case_164;
  }
#line 190
  if (rtype == 165UL) {
#line 190
    goto case_165;
  }
#line 191
  if (rtype == 166UL) {
#line 191
    goto case_166;
  }
#line 192
  if (rtype == 167UL) {
#line 192
    goto case_167;
  }
#line 193
  if (rtype == 168UL) {
#line 193
    goto case_168;
  }
#line 194
  if (rtype == 169UL) {
#line 194
    goto case_169;
  }
#line 195
  if (rtype == 170UL) {
#line 195
    goto case_170;
  }
#line 196
  if (rtype == 171UL) {
#line 196
    goto case_171;
  }
#line 197
  if (rtype == 172UL) {
#line 197
    goto case_172;
  }
#line 198
  if (rtype == 173UL) {
#line 198
    goto case_173;
  }
#line 199
  if (rtype == 174UL) {
#line 199
    goto case_174;
  }
#line 200
  if (rtype == 175UL) {
#line 200
    goto case_175;
  }
#line 201
  if (rtype == 176UL) {
#line 201
    goto case_176;
  }
#line 202
  if (rtype == 177UL) {
#line 202
    goto case_177;
  }
#line 203
  if (rtype == 178UL) {
#line 203
    goto case_178;
  }
#line 204
  if (rtype == 179UL) {
#line 204
    goto case_179;
  }
#line 205
  if (rtype == 180UL) {
#line 205
    goto case_180;
  }
#line 206
  if (rtype == 181UL) {
#line 206
    goto case_181;
  }
#line 207
  if (rtype == 182UL) {
#line 207
    goto case_182;
  }
#line 208
  if (rtype == 183UL) {
#line 208
    goto case_183;
  }
#line 209
  if (rtype == 184UL) {
#line 209
    goto case_184;
  }
#line 210
  if (rtype == 185UL) {
#line 210
    goto case_185;
  }
#line 211
  if (rtype == 186UL) {
#line 211
    goto case_186;
  }
#line 212
  if (rtype == 187UL) {
#line 212
    goto case_187;
  }
#line 213
  if (rtype == 188UL) {
#line 213
    goto case_188;
  }
#line 214
  if (rtype == 189UL) {
#line 214
    goto case_189;
  }
#line 215
  if (rtype == 190UL) {
#line 215
    goto case_190;
  }
#line 216
  if (rtype == 191UL) {
#line 216
    goto case_191;
  }
#line 217
  if (rtype == 192UL) {
#line 217
    goto case_192;
  }
#line 218
  if (rtype == 193UL) {
#line 218
    goto case_193;
  }
#line 219
  if (rtype == 194UL) {
#line 219
    goto case_194;
  }
#line 220
  if (rtype == 195UL) {
#line 220
    goto case_195;
  }
#line 221
  if (rtype == 196UL) {
#line 221
    goto case_196;
  }
#line 224
  if (rtype == 201UL) {
#line 224
    goto case_201;
  }
#line 225
  if (rtype == 202UL) {
#line 225
    goto case_202;
  }
#line 226
  if (rtype == 203UL) {
#line 226
    goto case_203;
  }
#line 227
  if (rtype == 204UL) {
#line 227
    goto case_204;
  }
#line 228
  if (rtype == 205UL) {
#line 228
    goto case_205;
  }
#line 229
  if (rtype == 206UL) {
#line 229
    goto case_206;
  }
#line 230
  if (rtype == 207UL) {
#line 230
    goto case_207;
  }
#line 231
  if (rtype == 208UL) {
#line 231
    goto case_208;
  }
#line 234
  if (rtype == 242UL) {
#line 234
    goto case_242;
  }
#line 235
  if (rtype == 243UL) {
#line 235
    goto case_243;
  }
#line 236
  if (rtype == 244UL) {
#line 236
    goto case_244;
  }
#line 237
  if (rtype == 245UL) {
#line 237
    goto case_245;
  }
#line 238
  if (rtype == 246UL) {
#line 238
    goto case_246;
  }
#line 239
  if (rtype == 247UL) {
#line 239
    goto case_247;
  }
#line 240
  if (rtype == 248UL) {
#line 240
    goto case_248;
  }
#line 241
  if (rtype == 249UL) {
#line 241
    goto case_249;
  }
#line 242
  if (rtype == 250UL) {
#line 242
    goto case_250;
  }
#line 243
  if (rtype == 251UL) {
#line 243
    goto case_251;
  }
#line 244
  if (rtype == 252UL) {
#line 244
    goto case_252;
  }
#line 245
  if (rtype == 253UL) {
#line 245
    goto case_253;
  }
#line 246
  if (rtype == 254UL) {
#line 246
    goto case_254;
  }
#line 247
  if (rtype == 255UL) {
#line 247
    goto case_255;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
#line 122
  return ("R_SH_NONE");
  case_1: /* CIL Label */ 
#line 123
  return ("R_SH_DIR32");
  case_2: /* CIL Label */ 
#line 124
  return ("R_SH_REL32");
  case_3: /* CIL Label */ 
#line 125
  return ("R_SH_DIR8WPN");
  case_4: /* CIL Label */ 
#line 126
  return ("R_SH_IND12W");
  case_5: /* CIL Label */ 
#line 127
  return ("R_SH_DIR8WPL");
  case_6: /* CIL Label */ 
#line 128
  return ("R_SH_DIR8WPZ");
  case_7: /* CIL Label */ 
#line 129
  return ("R_SH_DIR8BP");
  case_8: /* CIL Label */ 
#line 130
  return ("R_SH_DIR8W");
  case_9: /* CIL Label */ 
#line 131
  return ("R_SH_DIR8L");
  case_10: /* CIL Label */ 
#line 133
  return ("R_SH_LOOP_START");
  case_11: /* CIL Label */ 
#line 134
  return ("R_SH_LOOP_END");
  case_22: /* CIL Label */ 
#line 139
  return ("R_SH_GNU_VTINHERIT");
  case_23: /* CIL Label */ 
#line 140
  return ("R_SH_GNU_VTENTRY");
  case_24: /* CIL Label */ 
#line 141
  return ("R_SH_SWITCH8");
  case_25: /* CIL Label */ 
#line 142
  return ("R_SH_SWITCH16");
  case_26: /* CIL Label */ 
#line 143
  return ("R_SH_SWITCH32");
  case_27: /* CIL Label */ 
#line 144
  return ("R_SH_USES");
  case_28: /* CIL Label */ 
#line 145
  return ("R_SH_COUNT");
  case_29: /* CIL Label */ 
#line 146
  return ("R_SH_ALIGN");
  case_30: /* CIL Label */ 
#line 147
  return ("R_SH_CODE");
  case_31: /* CIL Label */ 
#line 148
  return ("R_SH_DATA");
  case_32: /* CIL Label */ 
#line 149
  return ("R_SH_LABEL");
  case_33: /* CIL Label */ 
#line 151
  return ("R_SH_DIR16");
  case_34: /* CIL Label */ 
#line 152
  return ("R_SH_DIR8");
  case_35: /* CIL Label */ 
#line 153
  return ("R_SH_DIR8UL");
  case_36: /* CIL Label */ 
#line 154
  return ("R_SH_DIR8UW");
  case_37: /* CIL Label */ 
#line 155
  return ("R_SH_DIR8U");
  case_38: /* CIL Label */ 
#line 156
  return ("R_SH_DIR8SW");
  case_39: /* CIL Label */ 
#line 157
  return ("R_SH_DIR8S");
  case_40: /* CIL Label */ 
#line 158
  return ("R_SH_DIR4UL");
  case_41: /* CIL Label */ 
#line 159
  return ("R_SH_DIR4UW");
  case_42: /* CIL Label */ 
#line 160
  return ("R_SH_DIR4U");
  case_43: /* CIL Label */ 
#line 161
  return ("R_SH_PSHA");
  case_44: /* CIL Label */ 
#line 162
  return ("R_SH_PSHL");
  case_45: /* CIL Label */ 
#line 163
  return ("R_SH_DIR5U");
  case_46: /* CIL Label */ 
#line 164
  return ("R_SH_DIR6U");
  case_47: /* CIL Label */ 
#line 165
  return ("R_SH_DIR6S");
  case_48: /* CIL Label */ 
#line 166
  return ("R_SH_DIR10S");
  case_49: /* CIL Label */ 
#line 167
  return ("R_SH_DIR10SW");
  case_50: /* CIL Label */ 
#line 168
  return ("R_SH_DIR10SL");
  case_51: /* CIL Label */ 
#line 169
  return ("R_SH_DIR10SQ");
  case_53: /* CIL Label */ 
#line 172
  return ("R_SH_DIR16S");
  case_144: /* CIL Label */ 
#line 175
  return ("R_SH_TLS_GD_32");
  case_145: /* CIL Label */ 
#line 176
  return ("R_SH_TLS_LD_32");
  case_146: /* CIL Label */ 
#line 177
  return ("R_SH_TLS_LDO_32");
  case_147: /* CIL Label */ 
#line 178
  return ("R_SH_TLS_IE_32");
  case_148: /* CIL Label */ 
#line 179
  return ("R_SH_TLS_LE_32");
  case_149: /* CIL Label */ 
#line 180
  return ("R_SH_TLS_DTPMOD32");
  case_150: /* CIL Label */ 
#line 181
  return ("R_SH_TLS_DTPOFF32");
  case_151: /* CIL Label */ 
#line 182
  return ("R_SH_TLS_TPOFF32");
  case_160: /* CIL Label */ 
#line 185
  return ("R_SH_GOT32");
  case_161: /* CIL Label */ 
#line 186
  return ("R_SH_PLT32");
  case_162: /* CIL Label */ 
#line 187
  return ("R_SH_COPY");
  case_163: /* CIL Label */ 
#line 188
  return ("R_SH_GLOB_DAT");
  case_164: /* CIL Label */ 
#line 189
  return ("R_SH_JMP_SLOT");
  case_165: /* CIL Label */ 
#line 190
  return ("R_SH_RELATIVE");
  case_166: /* CIL Label */ 
#line 191
  return ("R_SH_GOTOFF");
  case_167: /* CIL Label */ 
#line 192
  return ("R_SH_GOTPC");
  case_168: /* CIL Label */ 
#line 193
  return ("R_SH_GOTPLT32");
  case_169: /* CIL Label */ 
#line 194
  return ("R_SH_GOT_LOW16");
  case_170: /* CIL Label */ 
#line 195
  return ("R_SH_GOT_MEDLOW16");
  case_171: /* CIL Label */ 
#line 196
  return ("R_SH_GOT_MEDHI16");
  case_172: /* CIL Label */ 
#line 197
  return ("R_SH_GOT_HI16");
  case_173: /* CIL Label */ 
#line 198
  return ("R_SH_GOTPLT_LOW16");
  case_174: /* CIL Label */ 
#line 199
  return ("R_SH_GOTPLT_MEDLOW16");
  case_175: /* CIL Label */ 
#line 200
  return ("R_SH_GOTPLT_MEDHI16");
  case_176: /* CIL Label */ 
#line 201
  return ("R_SH_GOTPLT_HI16");
  case_177: /* CIL Label */ 
#line 202
  return ("R_SH_PLT_LOW16");
  case_178: /* CIL Label */ 
#line 203
  return ("R_SH_PLT_MEDLOW16");
  case_179: /* CIL Label */ 
#line 204
  return ("R_SH_PLT_MEDHI16");
  case_180: /* CIL Label */ 
#line 205
  return ("R_SH_PLT_HI16");
  case_181: /* CIL Label */ 
#line 206
  return ("R_SH_GOTOFF_LOW16");
  case_182: /* CIL Label */ 
#line 207
  return ("R_SH_GOTOFF_MEDLOW16");
  case_183: /* CIL Label */ 
#line 208
  return ("R_SH_GOTOFF_MEDHI16");
  case_184: /* CIL Label */ 
#line 209
  return ("R_SH_GOTOFF_HI16");
  case_185: /* CIL Label */ 
#line 210
  return ("R_SH_GOTPC_LOW16");
  case_186: /* CIL Label */ 
#line 211
  return ("R_SH_GOTPC_MEDLOW16");
  case_187: /* CIL Label */ 
#line 212
  return ("R_SH_GOTPC_MEDHI16");
  case_188: /* CIL Label */ 
#line 213
  return ("R_SH_GOTPC_HI16");
  case_189: /* CIL Label */ 
#line 214
  return ("R_SH_GOT10BY4");
  case_190: /* CIL Label */ 
#line 215
  return ("R_SH_GOTPLT10BY4");
  case_191: /* CIL Label */ 
#line 216
  return ("R_SH_GOT10BY8");
  case_192: /* CIL Label */ 
#line 217
  return ("R_SH_GOTPLT10BY8");
  case_193: /* CIL Label */ 
#line 218
  return ("R_SH_COPY64");
  case_194: /* CIL Label */ 
#line 219
  return ("R_SH_GLOB_DAT64");
  case_195: /* CIL Label */ 
#line 220
  return ("R_SH_JMP_SLOT64");
  case_196: /* CIL Label */ 
#line 221
  return ("R_SH_RELATIVE64");
  case_201: /* CIL Label */ 
#line 224
  return ("R_SH_GOT20");
  case_202: /* CIL Label */ 
#line 225
  return ("R_SH_GOTOFF20");
  case_203: /* CIL Label */ 
#line 226
  return ("R_SH_GOTFUNCDESC");
  case_204: /* CIL Label */ 
#line 227
  return ("R_SH_GOTFUNCDESC20");
  case_205: /* CIL Label */ 
#line 228
  return ("R_SH_GOTOFFFUNCDESC");
  case_206: /* CIL Label */ 
#line 229
  return ("R_SH_GOTOFFFUNCDESC20");
  case_207: /* CIL Label */ 
#line 230
  return ("R_SH_FUNCDESC");
  case_208: /* CIL Label */ 
#line 231
  return ("R_SH_FUNCDESC_VALUE");
  case_242: /* CIL Label */ 
#line 234
  return ("R_SH_SHMEDIA_CODE");
  case_243: /* CIL Label */ 
#line 235
  return ("R_SH_PT_16");
  case_244: /* CIL Label */ 
#line 236
  return ("R_SH_IMMS16");
  case_245: /* CIL Label */ 
#line 237
  return ("R_SH_IMMU16");
  case_246: /* CIL Label */ 
#line 238
  return ("R_SH_IMM_LOW16");
  case_247: /* CIL Label */ 
#line 239
  return ("R_SH_IMM_LOW16_PCREL");
  case_248: /* CIL Label */ 
#line 240
  return ("R_SH_IMM_MEDLOW16");
  case_249: /* CIL Label */ 
#line 241
  return ("R_SH_IMM_MEDLOW16_PCREL");
  case_250: /* CIL Label */ 
#line 242
  return ("R_SH_IMM_MEDHI16");
  case_251: /* CIL Label */ 
#line 243
  return ("R_SH_IMM_MEDHI16_PCREL");
  case_252: /* CIL Label */ 
#line 244
  return ("R_SH_IMM_HI16");
  case_253: /* CIL Label */ 
#line 245
  return ("R_SH_IMM_HI16_PCREL");
  case_254: /* CIL Label */ 
#line 246
  return ("R_SH_64");
  case_255: /* CIL Label */ 
#line 247
  return ("R_SH_64_PCREL");
  switch_default: /* CIL Label */ 
#line 248
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 64 "./../include/elf/sparc.h"
static char const   *elf_sparc_reloc_type(unsigned long rtype ) ;
#line 64 "./../include/elf/sparc.h"
static char const   *elf_sparc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 65
  if (rtype == 0UL) {
#line 65
    goto case_0;
  }
#line 66
  if (rtype == 1UL) {
#line 66
    goto case_1;
  }
#line 67
  if (rtype == 2UL) {
#line 67
    goto case_2;
  }
#line 68
  if (rtype == 3UL) {
#line 68
    goto case_3;
  }
#line 69
  if (rtype == 4UL) {
#line 69
    goto case_4;
  }
#line 70
  if (rtype == 5UL) {
#line 70
    goto case_5;
  }
#line 71
  if (rtype == 6UL) {
#line 71
    goto case_6;
  }
#line 72
  if (rtype == 7UL) {
#line 72
    goto case_7;
  }
#line 73
  if (rtype == 8UL) {
#line 73
    goto case_8;
  }
#line 74
  if (rtype == 9UL) {
#line 74
    goto case_9;
  }
#line 75
  if (rtype == 10UL) {
#line 75
    goto case_10;
  }
#line 76
  if (rtype == 11UL) {
#line 76
    goto case_11;
  }
#line 77
  if (rtype == 12UL) {
#line 77
    goto case_12;
  }
#line 78
  if (rtype == 13UL) {
#line 78
    goto case_13;
  }
#line 79
  if (rtype == 14UL) {
#line 79
    goto case_14;
  }
#line 80
  if (rtype == 15UL) {
#line 80
    goto case_15;
  }
#line 81
  if (rtype == 16UL) {
#line 81
    goto case_16;
  }
#line 82
  if (rtype == 17UL) {
#line 82
    goto case_17;
  }
#line 83
  if (rtype == 18UL) {
#line 83
    goto case_18;
  }
#line 84
  if (rtype == 19UL) {
#line 84
    goto case_19;
  }
#line 85
  if (rtype == 20UL) {
#line 85
    goto case_20;
  }
#line 86
  if (rtype == 21UL) {
#line 86
    goto case_21;
  }
#line 87
  if (rtype == 22UL) {
#line 87
    goto case_22;
  }
#line 88
  if (rtype == 23UL) {
#line 88
    goto case_23;
  }
#line 95
  if (rtype == 24UL) {
#line 95
    goto case_24;
  }
#line 96
  if (rtype == 25UL) {
#line 96
    goto case_25;
  }
#line 97
  if (rtype == 26UL) {
#line 97
    goto case_26;
  }
#line 98
  if (rtype == 27UL) {
#line 98
    goto case_27;
  }
#line 99
  if (rtype == 28UL) {
#line 99
    goto case_28;
  }
#line 100
  if (rtype == 29UL) {
#line 100
    goto case_29;
  }
#line 104
  if (rtype == 30UL) {
#line 104
    goto case_30;
  }
#line 105
  if (rtype == 31UL) {
#line 105
    goto case_31;
  }
#line 106
  if (rtype == 32UL) {
#line 106
    goto case_32;
  }
#line 107
  if (rtype == 33UL) {
#line 107
    goto case_33;
  }
#line 108
  if (rtype == 34UL) {
#line 108
    goto case_34;
  }
#line 109
  if (rtype == 35UL) {
#line 109
    goto case_35;
  }
#line 110
  if (rtype == 36UL) {
#line 110
    goto case_36;
  }
#line 111
  if (rtype == 37UL) {
#line 111
    goto case_37;
  }
#line 112
  if (rtype == 38UL) {
#line 112
    goto case_38;
  }
#line 113
  if (rtype == 39UL) {
#line 113
    goto case_39;
  }
#line 114
  if (rtype == 40UL) {
#line 114
    goto case_40;
  }
#line 115
  if (rtype == 41UL) {
#line 115
    goto case_41;
  }
#line 116
  if (rtype == 42UL) {
#line 116
    goto case_42;
  }
#line 117
  if (rtype == 43UL) {
#line 117
    goto case_43;
  }
#line 118
  if (rtype == 44UL) {
#line 118
    goto case_44;
  }
#line 119
  if (rtype == 45UL) {
#line 119
    goto case_45;
  }
#line 120
  if (rtype == 46UL) {
#line 120
    goto case_46;
  }
#line 121
  if (rtype == 47UL) {
#line 121
    goto case_47;
  }
#line 122
  if (rtype == 48UL) {
#line 122
    goto case_48;
  }
#line 123
  if (rtype == 49UL) {
#line 123
    goto case_49;
  }
#line 124
  if (rtype == 50UL) {
#line 124
    goto case_50;
  }
#line 125
  if (rtype == 51UL) {
#line 125
    goto case_51;
  }
#line 126
  if (rtype == 52UL) {
#line 126
    goto case_52;
  }
#line 127
  if (rtype == 53UL) {
#line 127
    goto case_53;
  }
#line 128
  if (rtype == 54UL) {
#line 128
    goto case_54;
  }
#line 129
  if (rtype == 55UL) {
#line 129
    goto case_55;
  }
#line 131
  if (rtype == 56UL) {
#line 131
    goto case_56;
  }
#line 132
  if (rtype == 57UL) {
#line 132
    goto case_57;
  }
#line 133
  if (rtype == 58UL) {
#line 133
    goto case_58;
  }
#line 134
  if (rtype == 59UL) {
#line 134
    goto case_59;
  }
#line 135
  if (rtype == 60UL) {
#line 135
    goto case_60;
  }
#line 136
  if (rtype == 61UL) {
#line 136
    goto case_61;
  }
#line 137
  if (rtype == 62UL) {
#line 137
    goto case_62;
  }
#line 138
  if (rtype == 63UL) {
#line 138
    goto case_63;
  }
#line 139
  if (rtype == 64UL) {
#line 139
    goto case_64;
  }
#line 140
  if (rtype == 65UL) {
#line 140
    goto case_65;
  }
#line 141
  if (rtype == 66UL) {
#line 141
    goto case_66;
  }
#line 142
  if (rtype == 67UL) {
#line 142
    goto case_67;
  }
#line 143
  if (rtype == 68UL) {
#line 143
    goto case_68;
  }
#line 144
  if (rtype == 69UL) {
#line 144
    goto case_69;
  }
#line 145
  if (rtype == 70UL) {
#line 145
    goto case_70;
  }
#line 146
  if (rtype == 71UL) {
#line 146
    goto case_71;
  }
#line 147
  if (rtype == 72UL) {
#line 147
    goto case_72;
  }
#line 148
  if (rtype == 73UL) {
#line 148
    goto case_73;
  }
#line 149
  if (rtype == 74UL) {
#line 149
    goto case_74;
  }
#line 150
  if (rtype == 75UL) {
#line 150
    goto case_75;
  }
#line 151
  if (rtype == 76UL) {
#line 151
    goto case_76;
  }
#line 152
  if (rtype == 77UL) {
#line 152
    goto case_77;
  }
#line 153
  if (rtype == 78UL) {
#line 153
    goto case_78;
  }
#line 154
  if (rtype == 79UL) {
#line 154
    goto case_79;
  }
#line 156
  if (rtype == 80UL) {
#line 156
    goto case_80;
  }
#line 157
  if (rtype == 81UL) {
#line 157
    goto case_81;
  }
#line 158
  if (rtype == 82UL) {
#line 158
    goto case_82;
  }
#line 159
  if (rtype == 83UL) {
#line 159
    goto case_83;
  }
#line 160
  if (rtype == 84UL) {
#line 160
    goto case_84;
  }
#line 162
  if (rtype == 85UL) {
#line 162
    goto case_85;
  }
#line 163
  if (rtype == 86UL) {
#line 163
    goto case_86;
  }
#line 164
  if (rtype == 87UL) {
#line 164
    goto case_87;
  }
#line 165
  if (rtype == 88UL) {
#line 165
    goto case_88;
  }
#line 169
  if (rtype == 248UL) {
#line 169
    goto case_248;
  }
#line 170
  if (rtype == 249UL) {
#line 170
    goto case_249;
  }
#line 171
  if (rtype == 250UL) {
#line 171
    goto case_250;
  }
#line 172
  if (rtype == 251UL) {
#line 172
    goto case_251;
  }
#line 173
  if (rtype == 252UL) {
#line 173
    goto case_252;
  }
#line 175
  goto switch_default;
  case_0: /* CIL Label */ 
#line 65
  return ("R_SPARC_NONE");
  case_1: /* CIL Label */ 
#line 66
  return ("R_SPARC_8");
  case_2: /* CIL Label */ 
#line 67
  return ("R_SPARC_16");
  case_3: /* CIL Label */ 
#line 68
  return ("R_SPARC_32");
  case_4: /* CIL Label */ 
#line 69
  return ("R_SPARC_DISP8");
  case_5: /* CIL Label */ 
#line 70
  return ("R_SPARC_DISP16");
  case_6: /* CIL Label */ 
#line 71
  return ("R_SPARC_DISP32");
  case_7: /* CIL Label */ 
#line 72
  return ("R_SPARC_WDISP30");
  case_8: /* CIL Label */ 
#line 73
  return ("R_SPARC_WDISP22");
  case_9: /* CIL Label */ 
#line 74
  return ("R_SPARC_HI22");
  case_10: /* CIL Label */ 
#line 75
  return ("R_SPARC_22");
  case_11: /* CIL Label */ 
#line 76
  return ("R_SPARC_13");
  case_12: /* CIL Label */ 
#line 77
  return ("R_SPARC_LO10");
  case_13: /* CIL Label */ 
#line 78
  return ("R_SPARC_GOT10");
  case_14: /* CIL Label */ 
#line 79
  return ("R_SPARC_GOT13");
  case_15: /* CIL Label */ 
#line 80
  return ("R_SPARC_GOT22");
  case_16: /* CIL Label */ 
#line 81
  return ("R_SPARC_PC10");
  case_17: /* CIL Label */ 
#line 82
  return ("R_SPARC_PC22");
  case_18: /* CIL Label */ 
#line 83
  return ("R_SPARC_WPLT30");
  case_19: /* CIL Label */ 
#line 84
  return ("R_SPARC_COPY");
  case_20: /* CIL Label */ 
#line 85
  return ("R_SPARC_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 86
  return ("R_SPARC_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 87
  return ("R_SPARC_RELATIVE");
  case_23: /* CIL Label */ 
#line 88
  return ("R_SPARC_UA32");
  case_24: /* CIL Label */ 
#line 95
  return ("R_SPARC_PLT32");
  case_25: /* CIL Label */ 
#line 96
  return ("R_SPARC_HIPLT22");
  case_26: /* CIL Label */ 
#line 97
  return ("R_SPARC_LOPLT10");
  case_27: /* CIL Label */ 
#line 98
  return ("R_SPARC_PCPLT32");
  case_28: /* CIL Label */ 
#line 99
  return ("R_SPARC_PCPLT22");
  case_29: /* CIL Label */ 
#line 100
  return ("R_SPARC_PCPLT10");
  case_30: /* CIL Label */ 
#line 104
  return ("R_SPARC_10");
  case_31: /* CIL Label */ 
#line 105
  return ("R_SPARC_11");
  case_32: /* CIL Label */ 
#line 106
  return ("R_SPARC_64");
  case_33: /* CIL Label */ 
#line 107
  return ("R_SPARC_OLO10");
  case_34: /* CIL Label */ 
#line 108
  return ("R_SPARC_HH22");
  case_35: /* CIL Label */ 
#line 109
  return ("R_SPARC_HM10");
  case_36: /* CIL Label */ 
#line 110
  return ("R_SPARC_LM22");
  case_37: /* CIL Label */ 
#line 111
  return ("R_SPARC_PC_HH22");
  case_38: /* CIL Label */ 
#line 112
  return ("R_SPARC_PC_HM10");
  case_39: /* CIL Label */ 
#line 113
  return ("R_SPARC_PC_LM22");
  case_40: /* CIL Label */ 
#line 114
  return ("R_SPARC_WDISP16");
  case_41: /* CIL Label */ 
#line 115
  return ("R_SPARC_WDISP19");
  case_42: /* CIL Label */ 
#line 116
  return ("R_SPARC_UNUSED_42");
  case_43: /* CIL Label */ 
#line 117
  return ("R_SPARC_7");
  case_44: /* CIL Label */ 
#line 118
  return ("R_SPARC_5");
  case_45: /* CIL Label */ 
#line 119
  return ("R_SPARC_6");
  case_46: /* CIL Label */ 
#line 120
  return ("R_SPARC_DISP64");
  case_47: /* CIL Label */ 
#line 121
  return ("R_SPARC_PLT64");
  case_48: /* CIL Label */ 
#line 122
  return ("R_SPARC_HIX22");
  case_49: /* CIL Label */ 
#line 123
  return ("R_SPARC_LOX10");
  case_50: /* CIL Label */ 
#line 124
  return ("R_SPARC_H44");
  case_51: /* CIL Label */ 
#line 125
  return ("R_SPARC_M44");
  case_52: /* CIL Label */ 
#line 126
  return ("R_SPARC_L44");
  case_53: /* CIL Label */ 
#line 127
  return ("R_SPARC_REGISTER");
  case_54: /* CIL Label */ 
#line 128
  return ("R_SPARC_UA64");
  case_55: /* CIL Label */ 
#line 129
  return ("R_SPARC_UA16");
  case_56: /* CIL Label */ 
#line 131
  return ("R_SPARC_TLS_GD_HI22");
  case_57: /* CIL Label */ 
#line 132
  return ("R_SPARC_TLS_GD_LO10");
  case_58: /* CIL Label */ 
#line 133
  return ("R_SPARC_TLS_GD_ADD");
  case_59: /* CIL Label */ 
#line 134
  return ("R_SPARC_TLS_GD_CALL");
  case_60: /* CIL Label */ 
#line 135
  return ("R_SPARC_TLS_LDM_HI22");
  case_61: /* CIL Label */ 
#line 136
  return ("R_SPARC_TLS_LDM_LO10");
  case_62: /* CIL Label */ 
#line 137
  return ("R_SPARC_TLS_LDM_ADD");
  case_63: /* CIL Label */ 
#line 138
  return ("R_SPARC_TLS_LDM_CALL");
  case_64: /* CIL Label */ 
#line 139
  return ("R_SPARC_TLS_LDO_HIX22");
  case_65: /* CIL Label */ 
#line 140
  return ("R_SPARC_TLS_LDO_LOX10");
  case_66: /* CIL Label */ 
#line 141
  return ("R_SPARC_TLS_LDO_ADD");
  case_67: /* CIL Label */ 
#line 142
  return ("R_SPARC_TLS_IE_HI22");
  case_68: /* CIL Label */ 
#line 143
  return ("R_SPARC_TLS_IE_LO10");
  case_69: /* CIL Label */ 
#line 144
  return ("R_SPARC_TLS_IE_LD");
  case_70: /* CIL Label */ 
#line 145
  return ("R_SPARC_TLS_IE_LDX");
  case_71: /* CIL Label */ 
#line 146
  return ("R_SPARC_TLS_IE_ADD");
  case_72: /* CIL Label */ 
#line 147
  return ("R_SPARC_TLS_LE_HIX22");
  case_73: /* CIL Label */ 
#line 148
  return ("R_SPARC_TLS_LE_LOX10");
  case_74: /* CIL Label */ 
#line 149
  return ("R_SPARC_TLS_DTPMOD32");
  case_75: /* CIL Label */ 
#line 150
  return ("R_SPARC_TLS_DTPMOD64");
  case_76: /* CIL Label */ 
#line 151
  return ("R_SPARC_TLS_DTPOFF32");
  case_77: /* CIL Label */ 
#line 152
  return ("R_SPARC_TLS_DTPOFF64");
  case_78: /* CIL Label */ 
#line 153
  return ("R_SPARC_TLS_TPOFF32");
  case_79: /* CIL Label */ 
#line 154
  return ("R_SPARC_TLS_TPOFF64");
  case_80: /* CIL Label */ 
#line 156
  return ("R_SPARC_GOTDATA_HIX22");
  case_81: /* CIL Label */ 
#line 157
  return ("R_SPARC_GOTDATA_LOX10");
  case_82: /* CIL Label */ 
#line 158
  return ("R_SPARC_GOTDATA_OP_HIX22");
  case_83: /* CIL Label */ 
#line 159
  return ("R_SPARC_GOTDATA_OP_LOX10");
  case_84: /* CIL Label */ 
#line 160
  return ("R_SPARC_GOTDATA_OP");
  case_85: /* CIL Label */ 
#line 162
  return ("R_SPARC_H34");
  case_86: /* CIL Label */ 
#line 163
  return ("R_SPARC_SIZE32");
  case_87: /* CIL Label */ 
#line 164
  return ("R_SPARC_SIZE64");
  case_88: /* CIL Label */ 
#line 165
  return ("R_SPARC_WDISP10");
  case_248: /* CIL Label */ 
#line 169
  return ("R_SPARC_JMP_IREL");
  case_249: /* CIL Label */ 
#line 170
  return ("R_SPARC_IRELATIVE");
  case_250: /* CIL Label */ 
#line 171
  return ("R_SPARC_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 172
  return ("R_SPARC_GNU_VTENTRY");
  case_252: /* CIL Label */ 
#line 173
  return ("R_SPARC_REV32");
  switch_default: /* CIL Label */ 
#line 175
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/spu.h"
static char const   *elf_spu_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/spu.h"
static char const   *elf_spu_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_SPU_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_SPU_ADDR10");
  case_2: /* CIL Label */ 
#line 30
  return ("R_SPU_ADDR16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_SPU_ADDR16_HI");
  case_4: /* CIL Label */ 
#line 32
  return ("R_SPU_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 33
  return ("R_SPU_ADDR18");
  case_6: /* CIL Label */ 
#line 34
  return ("R_SPU_ADDR32");
  case_7: /* CIL Label */ 
#line 35
  return ("R_SPU_REL16");
  case_8: /* CIL Label */ 
#line 36
  return ("R_SPU_ADDR7");
  case_9: /* CIL Label */ 
#line 37
  return ("R_SPU_REL9");
  case_10: /* CIL Label */ 
#line 38
  return ("R_SPU_REL9I");
  case_11: /* CIL Label */ 
#line 39
  return ("R_SPU_ADDR10I");
  case_12: /* CIL Label */ 
#line 40
  return ("R_SPU_ADDR16I");
  case_13: /* CIL Label */ 
#line 41
  return ("R_SPU_REL32");
  case_14: /* CIL Label */ 
#line 42
  return ("R_SPU_ADDR16X");
  case_15: /* CIL Label */ 
#line 43
  return ("R_SPU_PPU32");
  case_16: /* CIL Label */ 
#line 44
  return ("R_SPU_PPU64");
  case_17: /* CIL Label */ 
#line 45
  return ("R_SPU_ADD_PIC");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/tic6x.h"
static char const   *elf_tic6x_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/tic6x.h"
static char const   *elf_tic6x_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 56
  if (rtype == 27UL) {
#line 56
    goto case_27;
  }
#line 57
  if (rtype == 28UL) {
#line 57
    goto case_28;
  }
#line 58
  if (rtype == 29UL) {
#line 58
    goto case_29;
  }
#line 59
  if (rtype == 30UL) {
#line 59
    goto case_30;
  }
#line 60
  if (rtype == 253UL) {
#line 60
    goto case_253;
  }
#line 61
  if (rtype == 254UL) {
#line 61
    goto case_254;
  }
#line 62
  if (rtype == 255UL) {
#line 62
    goto case_255;
  }
#line 63
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_C6000_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_C6000_ABS32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_C6000_ABS16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_C6000_ABS8");
  case_4: /* CIL Label */ 
#line 33
  return ("R_C6000_PCR_S21");
  case_5: /* CIL Label */ 
#line 34
  return ("R_C6000_PCR_S12");
  case_6: /* CIL Label */ 
#line 35
  return ("R_C6000_PCR_S10");
  case_7: /* CIL Label */ 
#line 36
  return ("R_C6000_PCR_S7");
  case_8: /* CIL Label */ 
#line 37
  return ("R_C6000_ABS_S16");
  case_9: /* CIL Label */ 
#line 38
  return ("R_C6000_ABS_L16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_C6000_ABS_H16");
  case_11: /* CIL Label */ 
#line 40
  return ("R_C6000_SBR_U15_B");
  case_12: /* CIL Label */ 
#line 41
  return ("R_C6000_SBR_U15_H");
  case_13: /* CIL Label */ 
#line 42
  return ("R_C6000_SBR_U15_W");
  case_14: /* CIL Label */ 
#line 43
  return ("R_C6000_SBR_S16");
  case_15: /* CIL Label */ 
#line 44
  return ("R_C6000_SBR_L16_B");
  case_16: /* CIL Label */ 
#line 45
  return ("R_C6000_SBR_L16_H");
  case_17: /* CIL Label */ 
#line 46
  return ("R_C6000_SBR_L16_W");
  case_18: /* CIL Label */ 
#line 47
  return ("R_C6000_SBR_H16_B");
  case_19: /* CIL Label */ 
#line 48
  return ("R_C6000_SBR_H16_H");
  case_20: /* CIL Label */ 
#line 49
  return ("R_C6000_SBR_H16_W");
  case_21: /* CIL Label */ 
#line 50
  return ("R_C6000_SBR_GOT_U15_W");
  case_22: /* CIL Label */ 
#line 51
  return ("R_C6000_SBR_GOT_L16_W");
  case_23: /* CIL Label */ 
#line 52
  return ("R_C6000_SBR_GOT_H16_W");
  case_24: /* CIL Label */ 
#line 53
  return ("R_C6000_DSBT_INDEX");
  case_25: /* CIL Label */ 
#line 54
  return ("R_C6000_PREL31");
  case_26: /* CIL Label */ 
#line 55
  return ("R_C6000_COPY");
  case_27: /* CIL Label */ 
#line 56
  return ("R_C6000_JUMP_SLOT");
  case_28: /* CIL Label */ 
#line 57
  return ("R_C6000_EHTYPE");
  case_29: /* CIL Label */ 
#line 58
  return ("R_C6000_PCR_H16");
  case_30: /* CIL Label */ 
#line 59
  return ("R_C6000_PCR_L16");
  case_253: /* CIL Label */ 
#line 60
  return ("R_C6000_ALIGN");
  case_254: /* CIL Label */ 
#line 61
  return ("R_C6000_FPHEAD");
  case_255: /* CIL Label */ 
#line 62
  return ("R_C6000_NOCMP");
  switch_default: /* CIL Label */ 
#line 63
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/tilegx.h"
static char const   *elf_tilegx_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/tilegx.h"
static char const   *elf_tilegx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 42
  if (rtype == 9UL) {
#line 42
    goto case_9;
  }
#line 43
  if (rtype == 10UL) {
#line 43
    goto case_10;
  }
#line 44
  if (rtype == 11UL) {
#line 44
    goto case_11;
  }
#line 45
  if (rtype == 12UL) {
#line 45
    goto case_12;
  }
#line 46
  if (rtype == 13UL) {
#line 46
    goto case_13;
  }
#line 47
  if (rtype == 14UL) {
#line 47
    goto case_14;
  }
#line 48
  if (rtype == 15UL) {
#line 48
    goto case_15;
  }
#line 50
  if (rtype == 16UL) {
#line 50
    goto case_16;
  }
#line 51
  if (rtype == 17UL) {
#line 51
    goto case_17;
  }
#line 52
  if (rtype == 18UL) {
#line 52
    goto case_18;
  }
#line 53
  if (rtype == 19UL) {
#line 53
    goto case_19;
  }
#line 56
  if (rtype == 20UL) {
#line 56
    goto case_20;
  }
#line 57
  if (rtype == 21UL) {
#line 57
    goto case_21;
  }
#line 58
  if (rtype == 22UL) {
#line 58
    goto case_22;
  }
#line 61
  if (rtype == 23UL) {
#line 61
    goto case_23;
  }
#line 62
  if (rtype == 24UL) {
#line 62
    goto case_24;
  }
#line 63
  if (rtype == 25UL) {
#line 63
    goto case_25;
  }
#line 64
  if (rtype == 26UL) {
#line 64
    goto case_26;
  }
#line 65
  if (rtype == 27UL) {
#line 65
    goto case_27;
  }
#line 66
  if (rtype == 28UL) {
#line 66
    goto case_28;
  }
#line 67
  if (rtype == 29UL) {
#line 67
    goto case_29;
  }
#line 68
  if (rtype == 30UL) {
#line 68
    goto case_30;
  }
#line 69
  if (rtype == 31UL) {
#line 69
    goto case_31;
  }
#line 70
  if (rtype == 32UL) {
#line 70
    goto case_32;
  }
#line 71
  if (rtype == 33UL) {
#line 71
    goto case_33;
  }
#line 72
  if (rtype == 34UL) {
#line 72
    goto case_34;
  }
#line 73
  if (rtype == 35UL) {
#line 73
    goto case_35;
  }
#line 75
  if (rtype == 36UL) {
#line 75
    goto case_36;
  }
#line 76
  if (rtype == 37UL) {
#line 76
    goto case_37;
  }
#line 77
  if (rtype == 38UL) {
#line 77
    goto case_38;
  }
#line 78
  if (rtype == 39UL) {
#line 78
    goto case_39;
  }
#line 79
  if (rtype == 40UL) {
#line 79
    goto case_40;
  }
#line 80
  if (rtype == 41UL) {
#line 80
    goto case_41;
  }
#line 81
  if (rtype == 42UL) {
#line 81
    goto case_42;
  }
#line 82
  if (rtype == 43UL) {
#line 82
    goto case_43;
  }
#line 83
  if (rtype == 44UL) {
#line 83
    goto case_44;
  }
#line 84
  if (rtype == 45UL) {
#line 84
    goto case_45;
  }
#line 85
  if (rtype == 46UL) {
#line 85
    goto case_46;
  }
#line 86
  if (rtype == 47UL) {
#line 86
    goto case_47;
  }
#line 87
  if (rtype == 48UL) {
#line 87
    goto case_48;
  }
#line 88
  if (rtype == 49UL) {
#line 88
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 91
  if (rtype == 51UL) {
#line 91
    goto case_51;
  }
#line 92
  if (rtype == 52UL) {
#line 92
    goto case_52;
  }
#line 93
  if (rtype == 53UL) {
#line 93
    goto case_53;
  }
#line 94
  if (rtype == 54UL) {
#line 94
    goto case_54;
  }
#line 95
  if (rtype == 55UL) {
#line 95
    goto case_55;
  }
#line 96
  if (rtype == 56UL) {
#line 96
    goto case_56;
  }
#line 97
  if (rtype == 57UL) {
#line 97
    goto case_57;
  }
#line 98
  if (rtype == 58UL) {
#line 98
    goto case_58;
  }
#line 99
  if (rtype == 59UL) {
#line 99
    goto case_59;
  }
#line 100
  if (rtype == 60UL) {
#line 100
    goto case_60;
  }
#line 101
  if (rtype == 61UL) {
#line 101
    goto case_61;
  }
#line 102
  if (rtype == 62UL) {
#line 102
    goto case_62;
  }
#line 103
  if (rtype == 63UL) {
#line 103
    goto case_63;
  }
#line 105
  if (rtype == 64UL) {
#line 105
    goto case_64;
  }
#line 106
  if (rtype == 65UL) {
#line 106
    goto case_65;
  }
#line 108
  if (rtype == 66UL) {
#line 108
    goto case_66;
  }
#line 109
  if (rtype == 67UL) {
#line 109
    goto case_67;
  }
#line 110
  if (rtype == 68UL) {
#line 110
    goto case_68;
  }
#line 111
  if (rtype == 69UL) {
#line 111
    goto case_69;
  }
#line 112
  if (rtype == 70UL) {
#line 112
    goto case_70;
  }
#line 113
  if (rtype == 71UL) {
#line 113
    goto case_71;
  }
#line 115
  if (rtype == 72UL) {
#line 115
    goto case_72;
  }
#line 116
  if (rtype == 73UL) {
#line 116
    goto case_73;
  }
#line 117
  if (rtype == 74UL) {
#line 117
    goto case_74;
  }
#line 118
  if (rtype == 75UL) {
#line 118
    goto case_75;
  }
#line 120
  if (rtype == 76UL) {
#line 120
    goto case_76;
  }
#line 121
  if (rtype == 77UL) {
#line 121
    goto case_77;
  }
#line 123
  if (rtype == 78UL) {
#line 123
    goto case_78;
  }
#line 124
  if (rtype == 79UL) {
#line 124
    goto case_79;
  }
#line 125
  if (rtype == 80UL) {
#line 125
    goto case_80;
  }
#line 126
  if (rtype == 81UL) {
#line 126
    goto case_81;
  }
#line 127
  if (rtype == 82UL) {
#line 127
    goto case_82;
  }
#line 128
  if (rtype == 83UL) {
#line 128
    goto case_83;
  }
#line 129
  if (rtype == 84UL) {
#line 129
    goto case_84;
  }
#line 130
  if (rtype == 85UL) {
#line 130
    goto case_85;
  }
#line 131
  if (rtype == 86UL) {
#line 131
    goto case_86;
  }
#line 132
  if (rtype == 87UL) {
#line 132
    goto case_87;
  }
#line 133
  if (rtype == 88UL) {
#line 133
    goto case_88;
  }
#line 134
  if (rtype == 89UL) {
#line 134
    goto case_89;
  }
#line 137
  if (rtype == 92UL) {
#line 137
    goto case_92;
  }
#line 138
  if (rtype == 93UL) {
#line 138
    goto case_93;
  }
#line 140
  if (rtype == 94UL) {
#line 140
    goto case_94;
  }
#line 141
  if (rtype == 95UL) {
#line 141
    goto case_95;
  }
#line 142
  if (rtype == 96UL) {
#line 142
    goto case_96;
  }
#line 143
  if (rtype == 97UL) {
#line 143
    goto case_97;
  }
#line 144
  if (rtype == 98UL) {
#line 144
    goto case_98;
  }
#line 145
  if (rtype == 99UL) {
#line 145
    goto case_99;
  }
#line 147
  if (rtype == 100UL) {
#line 147
    goto case_100;
  }
#line 148
  if (rtype == 101UL) {
#line 148
    goto case_101;
  }
#line 149
  if (rtype == 102UL) {
#line 149
    goto case_102;
  }
#line 150
  if (rtype == 103UL) {
#line 150
    goto case_103;
  }
#line 153
  if (rtype == 106UL) {
#line 153
    goto case_106;
  }
#line 154
  if (rtype == 107UL) {
#line 154
    goto case_107;
  }
#line 155
  if (rtype == 108UL) {
#line 155
    goto case_108;
  }
#line 156
  if (rtype == 109UL) {
#line 156
    goto case_109;
  }
#line 157
  if (rtype == 110UL) {
#line 157
    goto case_110;
  }
#line 158
  if (rtype == 111UL) {
#line 158
    goto case_111;
  }
#line 160
  if (rtype == 112UL) {
#line 160
    goto case_112;
  }
#line 161
  if (rtype == 113UL) {
#line 161
    goto case_113;
  }
#line 162
  if (rtype == 114UL) {
#line 162
    goto case_114;
  }
#line 163
  if (rtype == 115UL) {
#line 163
    goto case_115;
  }
#line 164
  if (rtype == 116UL) {
#line 164
    goto case_116;
  }
#line 165
  if (rtype == 117UL) {
#line 165
    goto case_117;
  }
#line 166
  if (rtype == 118UL) {
#line 166
    goto case_118;
  }
#line 167
  if (rtype == 119UL) {
#line 167
    goto case_119;
  }
#line 168
  if (rtype == 120UL) {
#line 168
    goto case_120;
  }
#line 169
  if (rtype == 121UL) {
#line 169
    goto case_121;
  }
#line 172
  if (rtype == 128UL) {
#line 172
    goto case_128;
  }
#line 173
  if (rtype == 129UL) {
#line 173
    goto case_129;
  }
#line 174
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_TILEGX_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_TILEGX_64");
  case_2: /* CIL Label */ 
#line 32
  return ("R_TILEGX_32");
  case_3: /* CIL Label */ 
#line 33
  return ("R_TILEGX_16");
  case_4: /* CIL Label */ 
#line 34
  return ("R_TILEGX_8");
  case_5: /* CIL Label */ 
#line 35
  return ("R_TILEGX_64_PCREL");
  case_6: /* CIL Label */ 
#line 36
  return ("R_TILEGX_32_PCREL");
  case_7: /* CIL Label */ 
#line 37
  return ("R_TILEGX_16_PCREL");
  case_8: /* CIL Label */ 
#line 38
  return ("R_TILEGX_8_PCREL");
  case_9: /* CIL Label */ 
#line 42
  return ("R_TILEGX_HW0");
  case_10: /* CIL Label */ 
#line 43
  return ("R_TILEGX_HW1");
  case_11: /* CIL Label */ 
#line 44
  return ("R_TILEGX_HW2");
  case_12: /* CIL Label */ 
#line 45
  return ("R_TILEGX_HW3");
  case_13: /* CIL Label */ 
#line 46
  return ("R_TILEGX_HW0_LAST");
  case_14: /* CIL Label */ 
#line 47
  return ("R_TILEGX_HW1_LAST");
  case_15: /* CIL Label */ 
#line 48
  return ("R_TILEGX_HW2_LAST");
  case_16: /* CIL Label */ 
#line 50
  return ("R_TILEGX_COPY");
  case_17: /* CIL Label */ 
#line 51
  return ("R_TILEGX_GLOB_DAT");
  case_18: /* CIL Label */ 
#line 52
  return ("R_TILEGX_JMP_SLOT");
  case_19: /* CIL Label */ 
#line 53
  return ("R_TILEGX_RELATIVE");
  case_20: /* CIL Label */ 
#line 56
  return ("R_TILEGX_BROFF_X1");
  case_21: /* CIL Label */ 
#line 57
  return ("R_TILEGX_JUMPOFF_X1");
  case_22: /* CIL Label */ 
#line 58
  return ("R_TILEGX_JUMPOFF_X1_PLT");
  case_23: /* CIL Label */ 
#line 61
  return ("R_TILEGX_IMM8_X0");
  case_24: /* CIL Label */ 
#line 62
  return ("R_TILEGX_IMM8_Y0");
  case_25: /* CIL Label */ 
#line 63
  return ("R_TILEGX_IMM8_X1");
  case_26: /* CIL Label */ 
#line 64
  return ("R_TILEGX_IMM8_Y1");
  case_27: /* CIL Label */ 
#line 65
  return ("R_TILEGX_DEST_IMM8_X1");
  case_28: /* CIL Label */ 
#line 66
  return ("R_TILEGX_MT_IMM14_X1");
  case_29: /* CIL Label */ 
#line 67
  return ("R_TILEGX_MF_IMM14_X1");
  case_30: /* CIL Label */ 
#line 68
  return ("R_TILEGX_MMSTART_X0");
  case_31: /* CIL Label */ 
#line 69
  return ("R_TILEGX_MMEND_X0");
  case_32: /* CIL Label */ 
#line 70
  return ("R_TILEGX_SHAMT_X0");
  case_33: /* CIL Label */ 
#line 71
  return ("R_TILEGX_SHAMT_X1");
  case_34: /* CIL Label */ 
#line 72
  return ("R_TILEGX_SHAMT_Y0");
  case_35: /* CIL Label */ 
#line 73
  return ("R_TILEGX_SHAMT_Y1");
  case_36: /* CIL Label */ 
#line 75
  return ("R_TILEGX_IMM16_X0_HW0");
  case_37: /* CIL Label */ 
#line 76
  return ("R_TILEGX_IMM16_X1_HW0");
  case_38: /* CIL Label */ 
#line 77
  return ("R_TILEGX_IMM16_X0_HW1");
  case_39: /* CIL Label */ 
#line 78
  return ("R_TILEGX_IMM16_X1_HW1");
  case_40: /* CIL Label */ 
#line 79
  return ("R_TILEGX_IMM16_X0_HW2");
  case_41: /* CIL Label */ 
#line 80
  return ("R_TILEGX_IMM16_X1_HW2");
  case_42: /* CIL Label */ 
#line 81
  return ("R_TILEGX_IMM16_X0_HW3");
  case_43: /* CIL Label */ 
#line 82
  return ("R_TILEGX_IMM16_X1_HW3");
  case_44: /* CIL Label */ 
#line 83
  return ("R_TILEGX_IMM16_X0_HW0_LAST");
  case_45: /* CIL Label */ 
#line 84
  return ("R_TILEGX_IMM16_X1_HW0_LAST");
  case_46: /* CIL Label */ 
#line 85
  return ("R_TILEGX_IMM16_X0_HW1_LAST");
  case_47: /* CIL Label */ 
#line 86
  return ("R_TILEGX_IMM16_X1_HW1_LAST");
  case_48: /* CIL Label */ 
#line 87
  return ("R_TILEGX_IMM16_X0_HW2_LAST");
  case_49: /* CIL Label */ 
#line 88
  return ("R_TILEGX_IMM16_X1_HW2_LAST");
  case_50: /* CIL Label */ 
#line 90
  return ("R_TILEGX_IMM16_X0_HW0_PCREL");
  case_51: /* CIL Label */ 
#line 91
  return ("R_TILEGX_IMM16_X1_HW0_PCREL");
  case_52: /* CIL Label */ 
#line 92
  return ("R_TILEGX_IMM16_X0_HW1_PCREL");
  case_53: /* CIL Label */ 
#line 93
  return ("R_TILEGX_IMM16_X1_HW1_PCREL");
  case_54: /* CIL Label */ 
#line 94
  return ("R_TILEGX_IMM16_X0_HW2_PCREL");
  case_55: /* CIL Label */ 
#line 95
  return ("R_TILEGX_IMM16_X1_HW2_PCREL");
  case_56: /* CIL Label */ 
#line 96
  return ("R_TILEGX_IMM16_X0_HW3_PCREL");
  case_57: /* CIL Label */ 
#line 97
  return ("R_TILEGX_IMM16_X1_HW3_PCREL");
  case_58: /* CIL Label */ 
#line 98
  return ("R_TILEGX_IMM16_X0_HW0_LAST_PCREL");
  case_59: /* CIL Label */ 
#line 99
  return ("R_TILEGX_IMM16_X1_HW0_LAST_PCREL");
  case_60: /* CIL Label */ 
#line 100
  return ("R_TILEGX_IMM16_X0_HW1_LAST_PCREL");
  case_61: /* CIL Label */ 
#line 101
  return ("R_TILEGX_IMM16_X1_HW1_LAST_PCREL");
  case_62: /* CIL Label */ 
#line 102
  return ("R_TILEGX_IMM16_X0_HW2_LAST_PCREL");
  case_63: /* CIL Label */ 
#line 103
  return ("R_TILEGX_IMM16_X1_HW2_LAST_PCREL");
  case_64: /* CIL Label */ 
#line 105
  return ("R_TILEGX_IMM16_X0_HW0_GOT");
  case_65: /* CIL Label */ 
#line 106
  return ("R_TILEGX_IMM16_X1_HW0_GOT");
  case_66: /* CIL Label */ 
#line 108
  return ("R_TILEGX_IMM16_X0_HW0_PLT_PCREL");
  case_67: /* CIL Label */ 
#line 109
  return ("R_TILEGX_IMM16_X1_HW0_PLT_PCREL");
  case_68: /* CIL Label */ 
#line 110
  return ("R_TILEGX_IMM16_X0_HW1_PLT_PCREL");
  case_69: /* CIL Label */ 
#line 111
  return ("R_TILEGX_IMM16_X1_HW1_PLT_PCREL");
  case_70: /* CIL Label */ 
#line 112
  return ("R_TILEGX_IMM16_X0_HW2_PLT_PCREL");
  case_71: /* CIL Label */ 
#line 113
  return ("R_TILEGX_IMM16_X1_HW2_PLT_PCREL");
  case_72: /* CIL Label */ 
#line 115
  return ("R_TILEGX_IMM16_X0_HW0_LAST_GOT");
  case_73: /* CIL Label */ 
#line 116
  return ("R_TILEGX_IMM16_X1_HW0_LAST_GOT");
  case_74: /* CIL Label */ 
#line 117
  return ("R_TILEGX_IMM16_X0_HW1_LAST_GOT");
  case_75: /* CIL Label */ 
#line 118
  return ("R_TILEGX_IMM16_X1_HW1_LAST_GOT");
  case_76: /* CIL Label */ 
#line 120
  return ("R_TILEGX_IMM16_X0_HW3_PLT_PCREL");
  case_77: /* CIL Label */ 
#line 121
  return ("R_TILEGX_IMM16_X1_HW3_PLT_PCREL");
  case_78: /* CIL Label */ 
#line 123
  return ("R_TILEGX_IMM16_X0_HW0_TLS_GD");
  case_79: /* CIL Label */ 
#line 124
  return ("R_TILEGX_IMM16_X1_HW0_TLS_GD");
  case_80: /* CIL Label */ 
#line 125
  return ("R_TILEGX_IMM16_X0_HW0_TLS_LE");
  case_81: /* CIL Label */ 
#line 126
  return ("R_TILEGX_IMM16_X1_HW0_TLS_LE");
  case_82: /* CIL Label */ 
#line 127
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE");
  case_83: /* CIL Label */ 
#line 128
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE");
  case_84: /* CIL Label */ 
#line 129
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE");
  case_85: /* CIL Label */ 
#line 130
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE");
  case_86: /* CIL Label */ 
#line 131
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD");
  case_87: /* CIL Label */ 
#line 132
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD");
  case_88: /* CIL Label */ 
#line 133
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD");
  case_89: /* CIL Label */ 
#line 134
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD");
  case_92: /* CIL Label */ 
#line 137
  return ("R_TILEGX_IMM16_X0_HW0_TLS_IE");
  case_93: /* CIL Label */ 
#line 138
  return ("R_TILEGX_IMM16_X1_HW0_TLS_IE");
  case_94: /* CIL Label */ 
#line 140
  return ("R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL");
  case_95: /* CIL Label */ 
#line 141
  return ("R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL");
  case_96: /* CIL Label */ 
#line 142
  return ("R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL");
  case_97: /* CIL Label */ 
#line 143
  return ("R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL");
  case_98: /* CIL Label */ 
#line 144
  return ("R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL");
  case_99: /* CIL Label */ 
#line 145
  return ("R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL");
  case_100: /* CIL Label */ 
#line 147
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE");
  case_101: /* CIL Label */ 
#line 148
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE");
  case_102: /* CIL Label */ 
#line 149
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE");
  case_103: /* CIL Label */ 
#line 150
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE");
  case_106: /* CIL Label */ 
#line 153
  return ("R_TILEGX_TLS_DTPMOD64");
  case_107: /* CIL Label */ 
#line 154
  return ("R_TILEGX_TLS_DTPOFF64");
  case_108: /* CIL Label */ 
#line 155
  return ("R_TILEGX_TLS_TPOFF64");
  case_109: /* CIL Label */ 
#line 156
  return ("R_TILEGX_TLS_DTPMOD32");
  case_110: /* CIL Label */ 
#line 157
  return ("R_TILEGX_TLS_DTPOFF32");
  case_111: /* CIL Label */ 
#line 158
  return ("R_TILEGX_TLS_TPOFF32");
  case_112: /* CIL Label */ 
#line 160
  return ("R_TILEGX_TLS_GD_CALL");
  case_113: /* CIL Label */ 
#line 161
  return ("R_TILEGX_IMM8_X0_TLS_GD_ADD");
  case_114: /* CIL Label */ 
#line 162
  return ("R_TILEGX_IMM8_X1_TLS_GD_ADD");
  case_115: /* CIL Label */ 
#line 163
  return ("R_TILEGX_IMM8_Y0_TLS_GD_ADD");
  case_116: /* CIL Label */ 
#line 164
  return ("R_TILEGX_IMM8_Y1_TLS_GD_ADD");
  case_117: /* CIL Label */ 
#line 165
  return ("R_TILEGX_TLS_IE_LOAD");
  case_118: /* CIL Label */ 
#line 166
  return ("R_TILEGX_IMM8_X0_TLS_ADD");
  case_119: /* CIL Label */ 
#line 167
  return ("R_TILEGX_IMM8_X1_TLS_ADD");
  case_120: /* CIL Label */ 
#line 168
  return ("R_TILEGX_IMM8_Y0_TLS_ADD");
  case_121: /* CIL Label */ 
#line 169
  return ("R_TILEGX_IMM8_Y1_TLS_ADD");
  case_128: /* CIL Label */ 
#line 172
  return ("R_TILEGX_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 173
  return ("R_TILEGX_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 174
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/tilepro.h"
static char const   *elf_tilepro_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/tilepro.h"
static char const   *elf_tilepro_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 38
  if (rtype == 7UL) {
#line 38
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 40
  if (rtype == 9UL) {
#line 40
    goto case_9;
  }
#line 42
  if (rtype == 10UL) {
#line 42
    goto case_10;
  }
#line 43
  if (rtype == 11UL) {
#line 43
    goto case_11;
  }
#line 44
  if (rtype == 12UL) {
#line 44
    goto case_12;
  }
#line 45
  if (rtype == 13UL) {
#line 45
    goto case_13;
  }
#line 48
  if (rtype == 14UL) {
#line 48
    goto case_14;
  }
#line 49
  if (rtype == 15UL) {
#line 49
    goto case_15;
  }
#line 50
  if (rtype == 16UL) {
#line 50
    goto case_16;
  }
#line 53
  if (rtype == 17UL) {
#line 53
    goto case_17;
  }
#line 54
  if (rtype == 18UL) {
#line 54
    goto case_18;
  }
#line 55
  if (rtype == 19UL) {
#line 55
    goto case_19;
  }
#line 56
  if (rtype == 20UL) {
#line 56
    goto case_20;
  }
#line 57
  if (rtype == 21UL) {
#line 57
    goto case_21;
  }
#line 58
  if (rtype == 22UL) {
#line 58
    goto case_22;
  }
#line 60
  if (rtype == 23UL) {
#line 60
    goto case_23;
  }
#line 61
  if (rtype == 24UL) {
#line 61
    goto case_24;
  }
#line 62
  if (rtype == 25UL) {
#line 62
    goto case_25;
  }
#line 63
  if (rtype == 26UL) {
#line 63
    goto case_26;
  }
#line 64
  if (rtype == 27UL) {
#line 64
    goto case_27;
  }
#line 65
  if (rtype == 28UL) {
#line 65
    goto case_28;
  }
#line 66
  if (rtype == 29UL) {
#line 66
    goto case_29;
  }
#line 67
  if (rtype == 30UL) {
#line 67
    goto case_30;
  }
#line 69
  if (rtype == 31UL) {
#line 69
    goto case_31;
  }
#line 70
  if (rtype == 32UL) {
#line 70
    goto case_32;
  }
#line 71
  if (rtype == 33UL) {
#line 71
    goto case_33;
  }
#line 72
  if (rtype == 34UL) {
#line 72
    goto case_34;
  }
#line 73
  if (rtype == 35UL) {
#line 73
    goto case_35;
  }
#line 74
  if (rtype == 36UL) {
#line 74
    goto case_36;
  }
#line 75
  if (rtype == 37UL) {
#line 75
    goto case_37;
  }
#line 76
  if (rtype == 38UL) {
#line 76
    goto case_38;
  }
#line 78
  if (rtype == 39UL) {
#line 78
    goto case_39;
  }
#line 79
  if (rtype == 40UL) {
#line 79
    goto case_40;
  }
#line 80
  if (rtype == 41UL) {
#line 80
    goto case_41;
  }
#line 81
  if (rtype == 42UL) {
#line 81
    goto case_42;
  }
#line 82
  if (rtype == 43UL) {
#line 82
    goto case_43;
  }
#line 83
  if (rtype == 44UL) {
#line 83
    goto case_44;
  }
#line 84
  if (rtype == 45UL) {
#line 84
    goto case_45;
  }
#line 85
  if (rtype == 46UL) {
#line 85
    goto case_46;
  }
#line 87
  if (rtype == 47UL) {
#line 87
    goto case_47;
  }
#line 88
  if (rtype == 48UL) {
#line 88
    goto case_48;
  }
#line 89
  if (rtype == 49UL) {
#line 89
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 92
  if (rtype == 51UL) {
#line 92
    goto case_51;
  }
#line 93
  if (rtype == 52UL) {
#line 93
    goto case_52;
  }
#line 94
  if (rtype == 53UL) {
#line 94
    goto case_53;
  }
#line 95
  if (rtype == 54UL) {
#line 95
    goto case_54;
  }
#line 97
  if (rtype == 55UL) {
#line 97
    goto case_55;
  }
#line 101
  if (rtype == 60UL) {
#line 101
    goto case_60;
  }
#line 102
  if (rtype == 61UL) {
#line 102
    goto case_61;
  }
#line 103
  if (rtype == 62UL) {
#line 103
    goto case_62;
  }
#line 104
  if (rtype == 63UL) {
#line 104
    goto case_63;
  }
#line 105
  if (rtype == 64UL) {
#line 105
    goto case_64;
  }
#line 106
  if (rtype == 65UL) {
#line 106
    goto case_65;
  }
#line 108
  if (rtype == 66UL) {
#line 108
    goto case_66;
  }
#line 109
  if (rtype == 67UL) {
#line 109
    goto case_67;
  }
#line 110
  if (rtype == 68UL) {
#line 110
    goto case_68;
  }
#line 111
  if (rtype == 69UL) {
#line 111
    goto case_69;
  }
#line 112
  if (rtype == 70UL) {
#line 112
    goto case_70;
  }
#line 113
  if (rtype == 71UL) {
#line 113
    goto case_71;
  }
#line 114
  if (rtype == 72UL) {
#line 114
    goto case_72;
  }
#line 115
  if (rtype == 73UL) {
#line 115
    goto case_73;
  }
#line 117
  if (rtype == 74UL) {
#line 117
    goto case_74;
  }
#line 118
  if (rtype == 75UL) {
#line 118
    goto case_75;
  }
#line 119
  if (rtype == 76UL) {
#line 119
    goto case_76;
  }
#line 120
  if (rtype == 77UL) {
#line 120
    goto case_77;
  }
#line 121
  if (rtype == 78UL) {
#line 121
    goto case_78;
  }
#line 122
  if (rtype == 79UL) {
#line 122
    goto case_79;
  }
#line 123
  if (rtype == 80UL) {
#line 123
    goto case_80;
  }
#line 124
  if (rtype == 81UL) {
#line 124
    goto case_81;
  }
#line 126
  if (rtype == 82UL) {
#line 126
    goto case_82;
  }
#line 127
  if (rtype == 83UL) {
#line 127
    goto case_83;
  }
#line 128
  if (rtype == 84UL) {
#line 128
    goto case_84;
  }
#line 130
  if (rtype == 85UL) {
#line 130
    goto case_85;
  }
#line 131
  if (rtype == 86UL) {
#line 131
    goto case_86;
  }
#line 132
  if (rtype == 87UL) {
#line 132
    goto case_87;
  }
#line 133
  if (rtype == 88UL) {
#line 133
    goto case_88;
  }
#line 134
  if (rtype == 89UL) {
#line 134
    goto case_89;
  }
#line 135
  if (rtype == 90UL) {
#line 135
    goto case_90;
  }
#line 136
  if (rtype == 91UL) {
#line 136
    goto case_91;
  }
#line 137
  if (rtype == 92UL) {
#line 137
    goto case_92;
  }
#line 140
  if (rtype == 128UL) {
#line 140
    goto case_128;
  }
#line 141
  if (rtype == 129UL) {
#line 141
    goto case_129;
  }
#line 142
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_TILEPRO_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_TILEPRO_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_TILEPRO_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_TILEPRO_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_TILEPRO_32_PCREL");
  case_5: /* CIL Label */ 
#line 35
  return ("R_TILEPRO_16_PCREL");
  case_6: /* CIL Label */ 
#line 36
  return ("R_TILEPRO_8_PCREL");
  case_7: /* CIL Label */ 
#line 38
  return ("R_TILEPRO_LO16");
  case_8: /* CIL Label */ 
#line 39
  return ("R_TILEPRO_HI16");
  case_9: /* CIL Label */ 
#line 40
  return ("R_TILEPRO_HA16");
  case_10: /* CIL Label */ 
#line 42
  return ("R_TILEPRO_COPY");
  case_11: /* CIL Label */ 
#line 43
  return ("R_TILEPRO_GLOB_DAT");
  case_12: /* CIL Label */ 
#line 44
  return ("R_TILEPRO_JMP_SLOT");
  case_13: /* CIL Label */ 
#line 45
  return ("R_TILEPRO_RELATIVE");
  case_14: /* CIL Label */ 
#line 48
  return ("R_TILEPRO_BROFF_X1");
  case_15: /* CIL Label */ 
#line 49
  return ("R_TILEPRO_JOFFLONG_X1");
  case_16: /* CIL Label */ 
#line 50
  return ("R_TILEPRO_JOFFLONG_X1_PLT");
  case_17: /* CIL Label */ 
#line 53
  return ("R_TILEPRO_IMM8_X0");
  case_18: /* CIL Label */ 
#line 54
  return ("R_TILEPRO_IMM8_Y0");
  case_19: /* CIL Label */ 
#line 55
  return ("R_TILEPRO_IMM8_X1");
  case_20: /* CIL Label */ 
#line 56
  return ("R_TILEPRO_IMM8_Y1");
  case_21: /* CIL Label */ 
#line 57
  return ("R_TILEPRO_MT_IMM15_X1");
  case_22: /* CIL Label */ 
#line 58
  return ("R_TILEPRO_MF_IMM15_X1");
  case_23: /* CIL Label */ 
#line 60
  return ("R_TILEPRO_IMM16_X0");
  case_24: /* CIL Label */ 
#line 61
  return ("R_TILEPRO_IMM16_X1");
  case_25: /* CIL Label */ 
#line 62
  return ("R_TILEPRO_IMM16_X0_LO");
  case_26: /* CIL Label */ 
#line 63
  return ("R_TILEPRO_IMM16_X1_LO");
  case_27: /* CIL Label */ 
#line 64
  return ("R_TILEPRO_IMM16_X0_HI");
  case_28: /* CIL Label */ 
#line 65
  return ("R_TILEPRO_IMM16_X1_HI");
  case_29: /* CIL Label */ 
#line 66
  return ("R_TILEPRO_IMM16_X0_HA");
  case_30: /* CIL Label */ 
#line 67
  return ("R_TILEPRO_IMM16_X1_HA");
  case_31: /* CIL Label */ 
#line 69
  return ("R_TILEPRO_IMM16_X0_PCREL");
  case_32: /* CIL Label */ 
#line 70
  return ("R_TILEPRO_IMM16_X1_PCREL");
  case_33: /* CIL Label */ 
#line 71
  return ("R_TILEPRO_IMM16_X0_LO_PCREL");
  case_34: /* CIL Label */ 
#line 72
  return ("R_TILEPRO_IMM16_X1_LO_PCREL");
  case_35: /* CIL Label */ 
#line 73
  return ("R_TILEPRO_IMM16_X0_HI_PCREL");
  case_36: /* CIL Label */ 
#line 74
  return ("R_TILEPRO_IMM16_X1_HI_PCREL");
  case_37: /* CIL Label */ 
#line 75
  return ("R_TILEPRO_IMM16_X0_HA_PCREL");
  case_38: /* CIL Label */ 
#line 76
  return ("R_TILEPRO_IMM16_X1_HA_PCREL");
  case_39: /* CIL Label */ 
#line 78
  return ("R_TILEPRO_IMM16_X0_GOT");
  case_40: /* CIL Label */ 
#line 79
  return ("R_TILEPRO_IMM16_X1_GOT");
  case_41: /* CIL Label */ 
#line 80
  return ("R_TILEPRO_IMM16_X0_GOT_LO");
  case_42: /* CIL Label */ 
#line 81
  return ("R_TILEPRO_IMM16_X1_GOT_LO");
  case_43: /* CIL Label */ 
#line 82
  return ("R_TILEPRO_IMM16_X0_GOT_HI");
  case_44: /* CIL Label */ 
#line 83
  return ("R_TILEPRO_IMM16_X1_GOT_HI");
  case_45: /* CIL Label */ 
#line 84
  return ("R_TILEPRO_IMM16_X0_GOT_HA");
  case_46: /* CIL Label */ 
#line 85
  return ("R_TILEPRO_IMM16_X1_GOT_HA");
  case_47: /* CIL Label */ 
#line 87
  return ("R_TILEPRO_MMSTART_X0");
  case_48: /* CIL Label */ 
#line 88
  return ("R_TILEPRO_MMEND_X0");
  case_49: /* CIL Label */ 
#line 89
  return ("R_TILEPRO_MMSTART_X1");
  case_50: /* CIL Label */ 
#line 90
  return ("R_TILEPRO_MMEND_X1");
  case_51: /* CIL Label */ 
#line 92
  return ("R_TILEPRO_SHAMT_X0");
  case_52: /* CIL Label */ 
#line 93
  return ("R_TILEPRO_SHAMT_X1");
  case_53: /* CIL Label */ 
#line 94
  return ("R_TILEPRO_SHAMT_Y0");
  case_54: /* CIL Label */ 
#line 95
  return ("R_TILEPRO_SHAMT_Y1");
  case_55: /* CIL Label */ 
#line 97
  return ("R_TILEPRO_DEST_IMM8_X1");
  case_60: /* CIL Label */ 
#line 101
  return ("R_TILEPRO_TLS_GD_CALL");
  case_61: /* CIL Label */ 
#line 102
  return ("R_TILEPRO_IMM8_X0_TLS_GD_ADD");
  case_62: /* CIL Label */ 
#line 103
  return ("R_TILEPRO_IMM8_X1_TLS_GD_ADD");
  case_63: /* CIL Label */ 
#line 104
  return ("R_TILEPRO_IMM8_Y0_TLS_GD_ADD");
  case_64: /* CIL Label */ 
#line 105
  return ("R_TILEPRO_IMM8_Y1_TLS_GD_ADD");
  case_65: /* CIL Label */ 
#line 106
  return ("R_TILEPRO_TLS_IE_LOAD");
  case_66: /* CIL Label */ 
#line 108
  return ("R_TILEPRO_IMM16_X0_TLS_GD");
  case_67: /* CIL Label */ 
#line 109
  return ("R_TILEPRO_IMM16_X1_TLS_GD");
  case_68: /* CIL Label */ 
#line 110
  return ("R_TILEPRO_IMM16_X0_TLS_GD_LO");
  case_69: /* CIL Label */ 
#line 111
  return ("R_TILEPRO_IMM16_X1_TLS_GD_LO");
  case_70: /* CIL Label */ 
#line 112
  return ("R_TILEPRO_IMM16_X0_TLS_GD_HI");
  case_71: /* CIL Label */ 
#line 113
  return ("R_TILEPRO_IMM16_X1_TLS_GD_HI");
  case_72: /* CIL Label */ 
#line 114
  return ("R_TILEPRO_IMM16_X0_TLS_GD_HA");
  case_73: /* CIL Label */ 
#line 115
  return ("R_TILEPRO_IMM16_X1_TLS_GD_HA");
  case_74: /* CIL Label */ 
#line 117
  return ("R_TILEPRO_IMM16_X0_TLS_IE");
  case_75: /* CIL Label */ 
#line 118
  return ("R_TILEPRO_IMM16_X1_TLS_IE");
  case_76: /* CIL Label */ 
#line 119
  return ("R_TILEPRO_IMM16_X0_TLS_IE_LO");
  case_77: /* CIL Label */ 
#line 120
  return ("R_TILEPRO_IMM16_X1_TLS_IE_LO");
  case_78: /* CIL Label */ 
#line 121
  return ("R_TILEPRO_IMM16_X0_TLS_IE_HI");
  case_79: /* CIL Label */ 
#line 122
  return ("R_TILEPRO_IMM16_X1_TLS_IE_HI");
  case_80: /* CIL Label */ 
#line 123
  return ("R_TILEPRO_IMM16_X0_TLS_IE_HA");
  case_81: /* CIL Label */ 
#line 124
  return ("R_TILEPRO_IMM16_X1_TLS_IE_HA");
  case_82: /* CIL Label */ 
#line 126
  return ("R_TILEPRO_TLS_DTPMOD32");
  case_83: /* CIL Label */ 
#line 127
  return ("R_TILEPRO_TLS_DTPOFF32");
  case_84: /* CIL Label */ 
#line 128
  return ("R_TILEPRO_TLS_TPOFF32");
  case_85: /* CIL Label */ 
#line 130
  return ("R_TILEPRO_IMM16_X0_TLS_LE");
  case_86: /* CIL Label */ 
#line 131
  return ("R_TILEPRO_IMM16_X1_TLS_LE");
  case_87: /* CIL Label */ 
#line 132
  return ("R_TILEPRO_IMM16_X0_TLS_LE_LO");
  case_88: /* CIL Label */ 
#line 133
  return ("R_TILEPRO_IMM16_X1_TLS_LE_LO");
  case_89: /* CIL Label */ 
#line 134
  return ("R_TILEPRO_IMM16_X0_TLS_LE_HI");
  case_90: /* CIL Label */ 
#line 135
  return ("R_TILEPRO_IMM16_X1_TLS_LE_HI");
  case_91: /* CIL Label */ 
#line 136
  return ("R_TILEPRO_IMM16_X0_TLS_LE_HA");
  case_92: /* CIL Label */ 
#line 137
  return ("R_TILEPRO_IMM16_X1_TLS_LE_HA");
  case_128: /* CIL Label */ 
#line 140
  return ("R_TILEPRO_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 141
  return ("R_TILEPRO_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 142
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 60 "./../include/elf/v850.h"
static char const   *v850_reloc_type(unsigned long rtype ) ;
#line 60 "./../include/elf/v850.h"
static char const   *v850_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 61
  if (rtype == 0UL) {
#line 61
    goto case_0;
  }
#line 62
  if (rtype == 1UL) {
#line 62
    goto case_1;
  }
#line 63
  if (rtype == 2UL) {
#line 63
    goto case_2;
  }
#line 64
  if (rtype == 3UL) {
#line 64
    goto case_3;
  }
#line 65
  if (rtype == 4UL) {
#line 65
    goto case_4;
  }
#line 66
  if (rtype == 5UL) {
#line 66
    goto case_5;
  }
#line 67
  if (rtype == 6UL) {
#line 67
    goto case_6;
  }
#line 68
  if (rtype == 7UL) {
#line 68
    goto case_7;
  }
#line 69
  if (rtype == 8UL) {
#line 69
    goto case_8;
  }
#line 70
  if (rtype == 9UL) {
#line 70
    goto case_9;
  }
#line 71
  if (rtype == 10UL) {
#line 71
    goto case_10;
  }
#line 72
  if (rtype == 11UL) {
#line 72
    goto case_11;
  }
#line 73
  if (rtype == 12UL) {
#line 73
    goto case_12;
  }
#line 74
  if (rtype == 13UL) {
#line 74
    goto case_13;
  }
#line 75
  if (rtype == 14UL) {
#line 75
    goto case_14;
  }
#line 76
  if (rtype == 15UL) {
#line 76
    goto case_15;
  }
#line 77
  if (rtype == 16UL) {
#line 77
    goto case_16;
  }
#line 78
  if (rtype == 17UL) {
#line 78
    goto case_17;
  }
#line 79
  if (rtype == 18UL) {
#line 79
    goto case_18;
  }
#line 80
  if (rtype == 19UL) {
#line 80
    goto case_19;
  }
#line 81
  if (rtype == 20UL) {
#line 81
    goto case_20;
  }
#line 82
  if (rtype == 21UL) {
#line 82
    goto case_21;
  }
#line 83
  if (rtype == 22UL) {
#line 83
    goto case_22;
  }
#line 84
  if (rtype == 23UL) {
#line 84
    goto case_23;
  }
#line 85
  if (rtype == 24UL) {
#line 85
    goto case_24;
  }
#line 86
  if (rtype == 25UL) {
#line 86
    goto case_25;
  }
#line 87
  if (rtype == 26UL) {
#line 87
    goto case_26;
  }
#line 88
  if (rtype == 27UL) {
#line 88
    goto case_27;
  }
#line 89
  if (rtype == 28UL) {
#line 89
    goto case_28;
  }
#line 90
  if (rtype == 29UL) {
#line 90
    goto case_29;
  }
#line 91
  if (rtype == 30UL) {
#line 91
    goto case_30;
  }
#line 92
  if (rtype == 31UL) {
#line 92
    goto case_31;
  }
#line 93
  if (rtype == 32UL) {
#line 93
    goto case_32;
  }
#line 94
  if (rtype == 33UL) {
#line 94
    goto case_33;
  }
#line 95
  if (rtype == 34UL) {
#line 95
    goto case_34;
  }
#line 96
  if (rtype == 35UL) {
#line 96
    goto case_35;
  }
#line 97
  if (rtype == 36UL) {
#line 97
    goto case_36;
  }
#line 98
  if (rtype == 37UL) {
#line 98
    goto case_37;
  }
#line 99
  if (rtype == 38UL) {
#line 99
    goto case_38;
  }
#line 100
  if (rtype == 39UL) {
#line 100
    goto case_39;
  }
#line 101
  if (rtype == 40UL) {
#line 101
    goto case_40;
  }
#line 102
  if (rtype == 41UL) {
#line 102
    goto case_41;
  }
#line 103
  if (rtype == 42UL) {
#line 103
    goto case_42;
  }
#line 104
  if (rtype == 43UL) {
#line 104
    goto case_43;
  }
#line 105
  if (rtype == 44UL) {
#line 105
    goto case_44;
  }
#line 106
  if (rtype == 45UL) {
#line 106
    goto case_45;
  }
#line 107
  if (rtype == 46UL) {
#line 107
    goto case_46;
  }
#line 108
  if (rtype == 47UL) {
#line 108
    goto case_47;
  }
#line 109
  if (rtype == 48UL) {
#line 109
    goto case_48;
  }
#line 110
  if (rtype == 49UL) {
#line 110
    goto case_49;
  }
#line 111
  if (rtype == 50UL) {
#line 111
    goto case_50;
  }
#line 112
  if (rtype == 51UL) {
#line 112
    goto case_51;
  }
#line 114
  goto switch_default;
  case_0: /* CIL Label */ 
#line 61
  return ("R_V850_NONE");
  case_1: /* CIL Label */ 
#line 62
  return ("R_V850_9_PCREL");
  case_2: /* CIL Label */ 
#line 63
  return ("R_V850_22_PCREL");
  case_3: /* CIL Label */ 
#line 64
  return ("R_V850_HI16_S");
  case_4: /* CIL Label */ 
#line 65
  return ("R_V850_HI16");
  case_5: /* CIL Label */ 
#line 66
  return ("R_V850_LO16");
  case_6: /* CIL Label */ 
#line 67
  return ("R_V850_ABS32");
  case_7: /* CIL Label */ 
#line 68
  return ("R_V850_16");
  case_8: /* CIL Label */ 
#line 69
  return ("R_V850_8");
  case_9: /* CIL Label */ 
#line 70
  return ("R_V850_SDA_16_16_OFFSET");
  case_10: /* CIL Label */ 
#line 71
  return ("R_V850_SDA_15_16_OFFSET");
  case_11: /* CIL Label */ 
#line 72
  return ("R_V850_ZDA_16_16_OFFSET");
  case_12: /* CIL Label */ 
#line 73
  return ("R_V850_ZDA_15_16_OFFSET");
  case_13: /* CIL Label */ 
#line 74
  return ("R_V850_TDA_6_8_OFFSET");
  case_14: /* CIL Label */ 
#line 75
  return ("R_V850_TDA_7_8_OFFSET");
  case_15: /* CIL Label */ 
#line 76
  return ("R_V850_TDA_7_7_OFFSET");
  case_16: /* CIL Label */ 
#line 77
  return ("R_V850_TDA_16_16_OFFSET");
  case_17: /* CIL Label */ 
#line 78
  return ("R_V850_TDA_4_5_OFFSET");
  case_18: /* CIL Label */ 
#line 79
  return ("R_V850_TDA_4_4_OFFSET");
  case_19: /* CIL Label */ 
#line 80
  return ("R_V850_SDA_16_16_SPLIT_OFFSET");
  case_20: /* CIL Label */ 
#line 81
  return ("R_V850_ZDA_16_16_SPLIT_OFFSET");
  case_21: /* CIL Label */ 
#line 82
  return ("R_V850_CALLT_6_7_OFFSET");
  case_22: /* CIL Label */ 
#line 83
  return ("R_V850_CALLT_16_16_OFFSET");
  case_23: /* CIL Label */ 
#line 84
  return ("R_V850_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 85
  return ("R_V850_GNU_VTENTRY");
  case_25: /* CIL Label */ 
#line 86
  return ("R_V850_LONGCALL");
  case_26: /* CIL Label */ 
#line 87
  return ("R_V850_LONGJUMP");
  case_27: /* CIL Label */ 
#line 88
  return ("R_V850_ALIGN");
  case_28: /* CIL Label */ 
#line 89
  return ("R_V850_REL32");
  case_29: /* CIL Label */ 
#line 90
  return ("R_V850_LO16_SPLIT_OFFSET");
  case_30: /* CIL Label */ 
#line 91
  return ("R_V850_16_PCREL");
  case_31: /* CIL Label */ 
#line 92
  return ("R_V850_17_PCREL");
  case_32: /* CIL Label */ 
#line 93
  return ("R_V850_23");
  case_33: /* CIL Label */ 
#line 94
  return ("R_V850_32_PCREL");
  case_34: /* CIL Label */ 
#line 95
  return ("R_V850_32_ABS");
  case_35: /* CIL Label */ 
#line 96
  return ("R_V850_16_SPLIT_OFFSET");
  case_36: /* CIL Label */ 
#line 97
  return ("R_V850_16_S1");
  case_37: /* CIL Label */ 
#line 98
  return ("R_V850_LO16_S1");
  case_38: /* CIL Label */ 
#line 99
  return ("R_V850_CALLT_15_16_OFFSET");
  case_39: /* CIL Label */ 
#line 100
  return ("R_V850_32_GOTPCREL");
  case_40: /* CIL Label */ 
#line 101
  return ("R_V850_16_GOT");
  case_41: /* CIL Label */ 
#line 102
  return ("R_V850_32_GOT");
  case_42: /* CIL Label */ 
#line 103
  return ("R_V850_22_PLT");
  case_43: /* CIL Label */ 
#line 104
  return ("R_V850_32_PLT");
  case_44: /* CIL Label */ 
#line 105
  return ("R_V850_COPY");
  case_45: /* CIL Label */ 
#line 106
  return ("R_V850_GLOB_DAT");
  case_46: /* CIL Label */ 
#line 107
  return ("R_V850_JMP_SLOT");
  case_47: /* CIL Label */ 
#line 108
  return ("R_V850_RELATIVE");
  case_48: /* CIL Label */ 
#line 109
  return ("R_V850_16_GOTOFF");
  case_49: /* CIL Label */ 
#line 110
  return ("R_V850_32_GOTOFF");
  case_50: /* CIL Label */ 
#line 111
  return ("R_V850_CODE");
  case_51: /* CIL Label */ 
#line 112
  return ("R_V850_DATA");
  switch_default: /* CIL Label */ 
#line 114
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 183
static char const   *v800_reloc_type(unsigned long rtype ) ;
#line 183 "./../include/elf/v850.h"
static char const   *v800_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 185
  if (rtype == 0UL) {
#line 185
    goto case_0;
  }
#line 186
  if (rtype == 48UL) {
#line 186
    goto case_48;
  }
#line 187
  if (rtype == 49UL) {
#line 187
    goto case_49;
  }
#line 188
  if (rtype == 50UL) {
#line 188
    goto case_50;
  }
#line 189
  if (rtype == 51UL) {
#line 189
    goto case_51;
  }
#line 190
  if (rtype == 52UL) {
#line 190
    goto case_52;
  }
#line 191
  if (rtype == 53UL) {
#line 191
    goto case_53;
  }
#line 192
  if (rtype == 54UL) {
#line 192
    goto case_54;
  }
#line 193
  if (rtype == 55UL) {
#line 193
    goto case_55;
  }
#line 194
  if (rtype == 56UL) {
#line 194
    goto case_56;
  }
#line 195
  if (rtype == 57UL) {
#line 195
    goto case_57;
  }
#line 196
  if (rtype == 58UL) {
#line 196
    goto case_58;
  }
#line 197
  if (rtype == 59UL) {
#line 197
    goto case_59;
  }
#line 198
  if (rtype == 60UL) {
#line 198
    goto case_60;
  }
#line 199
  if (rtype == 61UL) {
#line 199
    goto case_61;
  }
#line 201
  if (rtype == 63UL) {
#line 201
    goto case_63;
  }
#line 202
  if (rtype == 64UL) {
#line 202
    goto case_64;
  }
#line 203
  if (rtype == 65UL) {
#line 203
    goto case_65;
  }
#line 204
  if (rtype == 66UL) {
#line 204
    goto case_66;
  }
#line 206
  if (rtype == 68UL) {
#line 206
    goto case_68;
  }
#line 208
  if (rtype == 70UL) {
#line 208
    goto case_70;
  }
#line 209
  if (rtype == 71UL) {
#line 209
    goto case_71;
  }
#line 210
  if (rtype == 72UL) {
#line 210
    goto case_72;
  }
#line 211
  if (rtype == 73UL) {
#line 211
    goto case_73;
  }
#line 212
  if (rtype == 74UL) {
#line 212
    goto case_74;
  }
#line 213
  if (rtype == 75UL) {
#line 213
    goto case_75;
  }
#line 214
  if (rtype == 76UL) {
#line 214
    goto case_76;
  }
#line 215
  if (rtype == 77UL) {
#line 215
    goto case_77;
  }
#line 216
  if (rtype == 78UL) {
#line 216
    goto case_78;
  }
#line 217
  if (rtype == 79UL) {
#line 217
    goto case_79;
  }
#line 219
  if (rtype == 81UL) {
#line 219
    goto case_81;
  }
#line 220
  if (rtype == 82UL) {
#line 220
    goto case_82;
  }
#line 222
  if (rtype == 84UL) {
#line 222
    goto case_84;
  }
#line 223
  if (rtype == 85UL) {
#line 223
    goto case_85;
  }
#line 225
  if (rtype == 87UL) {
#line 225
    goto case_87;
  }
#line 226
  if (rtype == 88UL) {
#line 226
    goto case_88;
  }
#line 227
  if (rtype == 89UL) {
#line 227
    goto case_89;
  }
#line 228
  if (rtype == 90UL) {
#line 228
    goto case_90;
  }
#line 229
  if (rtype == 91UL) {
#line 229
    goto case_91;
  }
#line 230
  if (rtype == 92UL) {
#line 230
    goto case_92;
  }
#line 231
  if (rtype == 93UL) {
#line 231
    goto case_93;
  }
#line 232
  if (rtype == 94UL) {
#line 232
    goto case_94;
  }
#line 233
  if (rtype == 95UL) {
#line 233
    goto case_95;
  }
#line 234
  if (rtype == 96UL) {
#line 234
    goto case_96;
  }
#line 235
  if (rtype == 97UL) {
#line 235
    goto case_97;
  }
#line 236
  if (rtype == 98UL) {
#line 236
    goto case_98;
  }
#line 237
  if (rtype == 99UL) {
#line 237
    goto case_99;
  }
#line 238
  if (rtype == 100UL) {
#line 238
    goto case_100;
  }
#line 239
  if (rtype == 101UL) {
#line 239
    goto case_101;
  }
#line 240
  if (rtype == 102UL) {
#line 240
    goto case_102;
  }
#line 241
  if (rtype == 103UL) {
#line 241
    goto case_103;
  }
#line 242
  if (rtype == 104UL) {
#line 242
    goto case_104;
  }
#line 243
  if (rtype == 105UL) {
#line 243
    goto case_105;
  }
#line 244
  if (rtype == 106UL) {
#line 244
    goto case_106;
  }
#line 245
  if (rtype == 107UL) {
#line 245
    goto case_107;
  }
#line 246
  if (rtype == 108UL) {
#line 246
    goto case_108;
  }
#line 247
  if (rtype == 109UL) {
#line 247
    goto case_109;
  }
#line 248
  if (rtype == 110UL) {
#line 248
    goto case_110;
  }
#line 249
  if (rtype == 111UL) {
#line 249
    goto case_111;
  }
#line 250
  if (rtype == 112UL) {
#line 250
    goto case_112;
  }
#line 251
  if (rtype == 113UL) {
#line 251
    goto case_113;
  }
#line 252
  if (rtype == 114UL) {
#line 252
    goto case_114;
  }
#line 253
  if (rtype == 115UL) {
#line 253
    goto case_115;
  }
#line 254
  if (rtype == 116UL) {
#line 254
    goto case_116;
  }
#line 255
  if (rtype == 117UL) {
#line 255
    goto case_117;
  }
#line 256
  if (rtype == 118UL) {
#line 256
    goto case_118;
  }
#line 257
  if (rtype == 119UL) {
#line 257
    goto case_119;
  }
#line 258
  if (rtype == 120UL) {
#line 258
    goto case_120;
  }
#line 259
  if (rtype == 121UL) {
#line 259
    goto case_121;
  }
#line 260
  if (rtype == 122UL) {
#line 260
    goto case_122;
  }
#line 261
  if (rtype == 123UL) {
#line 261
    goto case_123;
  }
#line 262
  if (rtype == 124UL) {
#line 262
    goto case_124;
  }
#line 263
  if (rtype == 125UL) {
#line 263
    goto case_125;
  }
#line 264
  if (rtype == 126UL) {
#line 264
    goto case_126;
  }
#line 265
  if (rtype == 127UL) {
#line 265
    goto case_127;
  }
#line 266
  if (rtype == 128UL) {
#line 266
    goto case_128;
  }
#line 267
  if (rtype == 129UL) {
#line 267
    goto case_129;
  }
#line 268
  if (rtype == 130UL) {
#line 268
    goto case_130;
  }
#line 269
  if (rtype == 131UL) {
#line 269
    goto case_131;
  }
#line 270
  if (rtype == 132UL) {
#line 270
    goto case_132;
  }
#line 271
  if (rtype == 133UL) {
#line 271
    goto case_133;
  }
#line 274
  if (rtype == 160UL) {
#line 274
    goto case_160;
  }
#line 275
  if (rtype == 224UL) {
#line 275
    goto case_224;
  }
#line 276
  if (rtype == 225UL) {
#line 276
    goto case_225;
  }
#line 277
  if (rtype == 226UL) {
#line 277
    goto case_226;
  }
#line 278
  if (rtype == 227UL) {
#line 278
    goto case_227;
  }
#line 279
  if (rtype == 228UL) {
#line 279
    goto case_228;
  }
#line 281
  goto switch_default;
  case_0: /* CIL Label */ 
#line 185
  return ("R_V800_NONE");
  case_48: /* CIL Label */ 
#line 186
  return ("R_V810_NONE");
  case_49: /* CIL Label */ 
#line 187
  return ("R_V810_BYTE");
  case_50: /* CIL Label */ 
#line 188
  return ("R_V810_HWORD");
  case_51: /* CIL Label */ 
#line 189
  return ("R_V810_WORD");
  case_52: /* CIL Label */ 
#line 190
  return ("R_V810_WLO");
  case_53: /* CIL Label */ 
#line 191
  return ("R_V810_WHI");
  case_54: /* CIL Label */ 
#line 192
  return ("R_V810_WHI1");
  case_55: /* CIL Label */ 
#line 193
  return ("R_V810_GPBYTE");
  case_56: /* CIL Label */ 
#line 194
  return ("R_V810_GPHWORD");
  case_57: /* CIL Label */ 
#line 195
  return ("R_V810_GPWORD");
  case_58: /* CIL Label */ 
#line 196
  return ("R_V810_GPWLO");
  case_59: /* CIL Label */ 
#line 197
  return ("R_V810_GPWHI");
  case_60: /* CIL Label */ 
#line 198
  return ("R_V810_GPWHI1");
  case_61: /* CIL Label */ 
#line 199
  return ("R_V850_HWLO");
  case_63: /* CIL Label */ 
#line 201
  return ("R_V850_EP7BIT");
  case_64: /* CIL Label */ 
#line 202
  return ("R_V850_EPHBYTE");
  case_65: /* CIL Label */ 
#line 203
  return ("R_V850_EPWBYTE");
  case_66: /* CIL Label */ 
#line 204
  return ("R_V850_REGHWLO");
  case_68: /* CIL Label */ 
#line 206
  return ("R_V850_GPHWLO");
  case_70: /* CIL Label */ 
#line 208
  return ("R_V850_PCR22");
  case_71: /* CIL Label */ 
#line 209
  return ("R_V850_BLO");
  case_72: /* CIL Label */ 
#line 210
  return ("R_V850_EP4BIT");
  case_73: /* CIL Label */ 
#line 211
  return ("R_V850_EP5BIT");
  case_74: /* CIL Label */ 
#line 212
  return ("R_V850_REGBLO");
  case_75: /* CIL Label */ 
#line 213
  return ("R_V850_GPBLO");
  case_76: /* CIL Label */ 
#line 214
  return ("R_V810_WLO_1");
  case_77: /* CIL Label */ 
#line 215
  return ("R_V810_GPWLO_1");
  case_78: /* CIL Label */ 
#line 216
  return ("R_V850_BLO_1");
  case_79: /* CIL Label */ 
#line 217
  return ("R_V850_HWLO_1");
  case_81: /* CIL Label */ 
#line 219
  return ("R_V850_GPBLO_1");
  case_82: /* CIL Label */ 
#line 220
  return ("R_V850_GPHWLO_1");
  case_84: /* CIL Label */ 
#line 222
  return ("R_V850_EPBLO");
  case_85: /* CIL Label */ 
#line 223
  return ("R_V850_EPHWLO");
  case_87: /* CIL Label */ 
#line 225
  return ("R_V850_EPWLO_N");
  case_88: /* CIL Label */ 
#line 226
  return ("R_V850_PC32");
  case_89: /* CIL Label */ 
#line 227
  return ("R_V850_W23BIT");
  case_90: /* CIL Label */ 
#line 228
  return ("R_V850_GPW23BIT");
  case_91: /* CIL Label */ 
#line 229
  return ("R_V850_EPW23BIT");
  case_92: /* CIL Label */ 
#line 230
  return ("R_V850_B23BIT");
  case_93: /* CIL Label */ 
#line 231
  return ("R_V850_GPB23BIT");
  case_94: /* CIL Label */ 
#line 232
  return ("R_V850_EPB23BIT");
  case_95: /* CIL Label */ 
#line 233
  return ("R_V850_PC16U");
  case_96: /* CIL Label */ 
#line 234
  return ("R_V850_PC17");
  case_97: /* CIL Label */ 
#line 235
  return ("R_V850_DW8");
  case_98: /* CIL Label */ 
#line 236
  return ("R_V850_GPDW8");
  case_99: /* CIL Label */ 
#line 237
  return ("R_V850_EPDW8");
  case_100: /* CIL Label */ 
#line 238
  return ("R_V850_PC9");
  case_101: /* CIL Label */ 
#line 239
  return ("R_V810_REGBYTE");
  case_102: /* CIL Label */ 
#line 240
  return ("R_V810_REGHWORD");
  case_103: /* CIL Label */ 
#line 241
  return ("R_V810_REGWORD");
  case_104: /* CIL Label */ 
#line 242
  return ("R_V810_REGWLO");
  case_105: /* CIL Label */ 
#line 243
  return ("R_V810_REGWHI");
  case_106: /* CIL Label */ 
#line 244
  return ("R_V810_REGWHI1");
  case_107: /* CIL Label */ 
#line 245
  return ("R_V850_REGW23BIT");
  case_108: /* CIL Label */ 
#line 246
  return ("R_V850_REGB23BIT");
  case_109: /* CIL Label */ 
#line 247
  return ("R_V850_REGDW8");
  case_110: /* CIL Label */ 
#line 248
  return ("R_V810_EPBYTE");
  case_111: /* CIL Label */ 
#line 249
  return ("R_V810_EPHWORD");
  case_112: /* CIL Label */ 
#line 250
  return ("R_V810_EPWORD");
  case_113: /* CIL Label */ 
#line 251
  return ("R_V850_WLO23");
  case_114: /* CIL Label */ 
#line 252
  return ("R_V850_WORD_E");
  case_115: /* CIL Label */ 
#line 253
  return ("R_V850_REGWORD_E");
  case_116: /* CIL Label */ 
#line 254
  return ("R_V850_WORD");
  case_117: /* CIL Label */ 
#line 255
  return ("R_V850_GPWORD");
  case_118: /* CIL Label */ 
#line 256
  return ("R_V850_REGWORD");
  case_119: /* CIL Label */ 
#line 257
  return ("R_V850_EPWORD");
  case_120: /* CIL Label */ 
#line 258
  return ("R_V810_TPBYTE");
  case_121: /* CIL Label */ 
#line 259
  return ("R_V810_TPHWORD");
  case_122: /* CIL Label */ 
#line 260
  return ("R_V810_TPWORD");
  case_123: /* CIL Label */ 
#line 261
  return ("R_V810_TPWLO");
  case_124: /* CIL Label */ 
#line 262
  return ("R_V810_TPWHI");
  case_125: /* CIL Label */ 
#line 263
  return ("R_V810_TPWHI1");
  case_126: /* CIL Label */ 
#line 264
  return ("R_V850_TPHWLO");
  case_127: /* CIL Label */ 
#line 265
  return ("R_V850_TPBLO");
  case_128: /* CIL Label */ 
#line 266
  return ("R_V810_TPWLO_1");
  case_129: /* CIL Label */ 
#line 267
  return ("R_V850_TPBLO_1");
  case_130: /* CIL Label */ 
#line 268
  return ("R_V850_TPHWLO_1");
  case_131: /* CIL Label */ 
#line 269
  return ("R_V850_TP23BIT");
  case_132: /* CIL Label */ 
#line 270
  return ("R_V850_TPW23BIT");
  case_133: /* CIL Label */ 
#line 271
  return ("R_V850_TPDW8");
  case_160: /* CIL Label */ 
#line 274
  return ("R_V810_ABS32");
  case_224: /* CIL Label */ 
#line 275
  return ("R_V850_SYM");
  case_225: /* CIL Label */ 
#line 276
  return ("R_V850_OPadd");
  case_226: /* CIL Label */ 
#line 277
  return ("R_V850_OPsub");
  case_227: /* CIL Label */ 
#line 278
  return ("R_V850_OPsctsize");
  case_228: /* CIL Label */ 
#line 279
  return ("R_V850_OPscttop");
  switch_default: /* CIL Label */ 
#line 281
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/vax.h"
static char const   *elf_vax_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/vax.h"
static char const   *elf_vax_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 13UL) {
#line 36
    goto case_13;
  }
#line 37
  if (rtype == 19UL) {
#line 37
    goto case_19;
  }
#line 38
  if (rtype == 20UL) {
#line 38
    goto case_20;
  }
#line 39
  if (rtype == 21UL) {
#line 39
    goto case_21;
  }
#line 40
  if (rtype == 22UL) {
#line 40
    goto case_22;
  }
#line 42
  if (rtype == 23UL) {
#line 42
    goto case_23;
  }
#line 43
  if (rtype == 24UL) {
#line 43
    goto case_24;
  }
#line 44
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_VAX_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_VAX_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_VAX_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_VAX_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_VAX_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_VAX_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_VAX_PC8");
  case_7: /* CIL Label */ 
#line 35
  return ("R_VAX_GOT32");
  case_13: /* CIL Label */ 
#line 36
  return ("R_VAX_PLT32");
  case_19: /* CIL Label */ 
#line 37
  return ("R_VAX_COPY");
  case_20: /* CIL Label */ 
#line 38
  return ("R_VAX_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 39
  return ("R_VAX_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 40
  return ("R_VAX_RELATIVE");
  case_23: /* CIL Label */ 
#line 42
  return ("R_VAX_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 43
  return ("R_VAX_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 44
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/x86-64.h"
static char const   *elf_x86_64_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/x86-64.h"
static char const   *elf_x86_64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 60
  if (rtype == 29UL) {
#line 60
    goto case_29;
  }
#line 62
  if (rtype == 30UL) {
#line 62
    goto case_30;
  }
#line 64
  if (rtype == 31UL) {
#line 64
    goto case_31;
  }
#line 66
  if (rtype == 32UL) {
#line 66
    goto case_32;
  }
#line 67
  if (rtype == 33UL) {
#line 67
    goto case_33;
  }
#line 68
  if (rtype == 34UL) {
#line 68
    goto case_34;
  }
#line 72
  if (rtype == 35UL) {
#line 72
    goto case_35;
  }
#line 74
  if (rtype == 36UL) {
#line 74
    goto case_36;
  }
#line 75
  if (rtype == 37UL) {
#line 75
    goto case_37;
  }
#line 76
  if (rtype == 38UL) {
#line 76
    goto case_38;
  }
#line 77
  if (rtype == 39UL) {
#line 77
    goto case_39;
  }
#line 79
  if (rtype == 40UL) {
#line 79
    goto case_40;
  }
#line 81
  if (rtype == 250UL) {
#line 81
    goto case_250;
  }
#line 82
  if (rtype == 251UL) {
#line 82
    goto case_251;
  }
#line 83
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_X86_64_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_X86_64_64");
  case_2: /* CIL Label */ 
#line 30
  return ("R_X86_64_PC32");
  case_3: /* CIL Label */ 
#line 31
  return ("R_X86_64_GOT32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_X86_64_PLT32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_X86_64_COPY");
  case_6: /* CIL Label */ 
#line 34
  return ("R_X86_64_GLOB_DAT");
  case_7: /* CIL Label */ 
#line 35
  return ("R_X86_64_JUMP_SLOT");
  case_8: /* CIL Label */ 
#line 36
  return ("R_X86_64_RELATIVE");
  case_9: /* CIL Label */ 
#line 37
  return ("R_X86_64_GOTPCREL");
  case_10: /* CIL Label */ 
#line 39
  return ("R_X86_64_32");
  case_11: /* CIL Label */ 
#line 40
  return ("R_X86_64_32S");
  case_12: /* CIL Label */ 
#line 41
  return ("R_X86_64_16");
  case_13: /* CIL Label */ 
#line 42
  return ("R_X86_64_PC16");
  case_14: /* CIL Label */ 
#line 43
  return ("R_X86_64_8");
  case_15: /* CIL Label */ 
#line 44
  return ("R_X86_64_PC8");
  case_16: /* CIL Label */ 
#line 45
  return ("R_X86_64_DTPMOD64");
  case_17: /* CIL Label */ 
#line 46
  return ("R_X86_64_DTPOFF64");
  case_18: /* CIL Label */ 
#line 47
  return ("R_X86_64_TPOFF64");
  case_19: /* CIL Label */ 
#line 48
  return ("R_X86_64_TLSGD");
  case_20: /* CIL Label */ 
#line 49
  return ("R_X86_64_TLSLD");
  case_21: /* CIL Label */ 
#line 50
  return ("R_X86_64_DTPOFF32");
  case_22: /* CIL Label */ 
#line 51
  return ("R_X86_64_GOTTPOFF");
  case_23: /* CIL Label */ 
#line 52
  return ("R_X86_64_TPOFF32");
  case_24: /* CIL Label */ 
#line 53
  return ("R_X86_64_PC64");
  case_25: /* CIL Label */ 
#line 54
  return ("R_X86_64_GOTOFF64");
  case_26: /* CIL Label */ 
#line 55
  return ("R_X86_64_GOTPC32");
  case_27: /* CIL Label */ 
#line 57
  return ("R_X86_64_GOT64");
  case_28: /* CIL Label */ 
#line 58
  return ("R_X86_64_GOTPCREL64");
  case_29: /* CIL Label */ 
#line 60
  return ("R_X86_64_GOTPC64");
  case_30: /* CIL Label */ 
#line 62
  return ("R_X86_64_GOTPLT64");
  case_31: /* CIL Label */ 
#line 64
  return ("R_X86_64_PLTOFF64");
  case_32: /* CIL Label */ 
#line 66
  return ("R_X86_64_SIZE32");
  case_33: /* CIL Label */ 
#line 67
  return ("R_X86_64_SIZE64");
  case_34: /* CIL Label */ 
#line 68
  return ("R_X86_64_GOTPC32_TLSDESC");
  case_35: /* CIL Label */ 
#line 72
  return ("R_X86_64_TLSDESC_CALL");
  case_36: /* CIL Label */ 
#line 74
  return ("R_X86_64_TLSDESC");
  case_37: /* CIL Label */ 
#line 75
  return ("R_X86_64_IRELATIVE");
  case_38: /* CIL Label */ 
#line 76
  return ("R_X86_64_RELATIVE64");
  case_39: /* CIL Label */ 
#line 77
  return ("R_X86_64_PC32_BND");
  case_40: /* CIL Label */ 
#line 79
  return ("R_X86_64_PLT32_BND");
  case_250: /* CIL Label */ 
#line 81
  return ("R_X86_64_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 82
  return ("R_X86_64_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 83
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/xc16x.h"
static char const   *elf_xc16x_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/xc16x.h"
static char const   *elf_xc16x_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_XC16X_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_XC16X_ABS_8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_XC16X_ABS_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_XC16X_ABS_32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_XC16X_8_PCREL");
  case_5: /* CIL Label */ 
#line 33
  return ("R_XC16X_PAG");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XC16X_POF");
  case_7: /* CIL Label */ 
#line 35
  return ("R_XC16X_SEG");
  case_8: /* CIL Label */ 
#line 36
  return ("R_XC16X_SOF");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/xgate.h"
static char const   *elf_xgate_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/xgate.h"
static char const   *elf_xgate_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 50
  if (rtype == 18UL) {
#line 50
    goto case_18;
  }
#line 53
  if (rtype == 19UL) {
#line 53
    goto case_19;
  }
#line 54
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_XGATE_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_XGATE_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_XGATE_PCREL_8");
  case_3: /* CIL Label */ 
#line 30
  return ("R_XGATE_16");
  case_4: /* CIL Label */ 
#line 31
  return ("R_XGATE_32");
  case_5: /* CIL Label */ 
#line 32
  return ("R_XGATE_PCREL_16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XGATE_GNU_VTINHERIT");
  case_7: /* CIL Label */ 
#line 35
  return ("R_XGATE_GNU_VTENTRY");
  case_8: /* CIL Label */ 
#line 37
  return ("R_XGATE_24");
  case_9: /* CIL Label */ 
#line 38
  return ("R_XGATE_LO16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_XGATE_GPAGE");
  case_11: /* CIL Label */ 
#line 40
  return ("R_XGATE_PCREL_9");
  case_12: /* CIL Label */ 
#line 41
  return ("R_XGATE_PCREL_10");
  case_13: /* CIL Label */ 
#line 42
  return ("R_XGATE_IMM8_LO");
  case_14: /* CIL Label */ 
#line 43
  return ("R_XGATE_IMM8_HI");
  case_15: /* CIL Label */ 
#line 44
  return ("R_XGATE_IMM3");
  case_16: /* CIL Label */ 
#line 45
  return ("R_XGATE_IMM4");
  case_17: /* CIL Label */ 
#line 46
  return ("R_XGATE_IMM5");
  case_18: /* CIL Label */ 
#line 50
  return ("R_XGATE_RL_JUMP");
  case_19: /* CIL Label */ 
#line 53
  return ("R_XGATE_RL_GROUP");
  switch_default: /* CIL Label */ 
#line 54
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/xstormy16.h"
static char const   *elf_xstormy16_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/xstormy16.h"
static char const   *elf_xstormy16_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 44
  if (rtype == 128UL) {
#line 44
    goto case_128;
  }
#line 45
  if (rtype == 129UL) {
#line 45
    goto case_129;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_XSTORMY16_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_XSTORMY16_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_XSTORMY16_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_XSTORMY16_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_XSTORMY16_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_XSTORMY16_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XSTORMY16_PC8");
  case_7: /* CIL Label */ 
#line 36
  return ("R_XSTORMY16_REL_12");
  case_8: /* CIL Label */ 
#line 37
  return ("R_XSTORMY16_24");
  case_9: /* CIL Label */ 
#line 38
  return ("R_XSTORMY16_FPTR16");
  case_10: /* CIL Label */ 
#line 40
  return ("R_XSTORMY16_LO16");
  case_11: /* CIL Label */ 
#line 41
  return ("R_XSTORMY16_HI16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_XSTORMY16_12");
  case_128: /* CIL Label */ 
#line 44
  return ("R_XSTORMY16_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 45
  return ("R_XSTORMY16_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 30 "./../include/elf/xtensa.h"
static char const   *elf_xtensa_reloc_type(unsigned long rtype ) ;
#line 30 "./../include/elf/xtensa.h"
static char const   *elf_xtensa_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 31
  if (rtype == 0UL) {
#line 31
    goto case_0;
  }
#line 32
  if (rtype == 1UL) {
#line 32
    goto case_1;
  }
#line 33
  if (rtype == 2UL) {
#line 33
    goto case_2;
  }
#line 34
  if (rtype == 3UL) {
#line 34
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 56
  if (rtype == 27UL) {
#line 56
    goto case_27;
  }
#line 57
  if (rtype == 28UL) {
#line 57
    goto case_28;
  }
#line 58
  if (rtype == 29UL) {
#line 58
    goto case_29;
  }
#line 59
  if (rtype == 30UL) {
#line 59
    goto case_30;
  }
#line 60
  if (rtype == 31UL) {
#line 60
    goto case_31;
  }
#line 61
  if (rtype == 32UL) {
#line 61
    goto case_32;
  }
#line 62
  if (rtype == 33UL) {
#line 62
    goto case_33;
  }
#line 63
  if (rtype == 34UL) {
#line 63
    goto case_34;
  }
#line 64
  if (rtype == 35UL) {
#line 64
    goto case_35;
  }
#line 65
  if (rtype == 36UL) {
#line 65
    goto case_36;
  }
#line 66
  if (rtype == 37UL) {
#line 66
    goto case_37;
  }
#line 67
  if (rtype == 38UL) {
#line 67
    goto case_38;
  }
#line 68
  if (rtype == 39UL) {
#line 68
    goto case_39;
  }
#line 69
  if (rtype == 40UL) {
#line 69
    goto case_40;
  }
#line 70
  if (rtype == 41UL) {
#line 70
    goto case_41;
  }
#line 71
  if (rtype == 42UL) {
#line 71
    goto case_42;
  }
#line 72
  if (rtype == 43UL) {
#line 72
    goto case_43;
  }
#line 73
  if (rtype == 44UL) {
#line 73
    goto case_44;
  }
#line 74
  if (rtype == 45UL) {
#line 74
    goto case_45;
  }
#line 75
  if (rtype == 46UL) {
#line 75
    goto case_46;
  }
#line 76
  if (rtype == 47UL) {
#line 76
    goto case_47;
  }
#line 77
  if (rtype == 48UL) {
#line 77
    goto case_48;
  }
#line 78
  if (rtype == 49UL) {
#line 78
    goto case_49;
  }
#line 79
  if (rtype == 50UL) {
#line 79
    goto case_50;
  }
#line 80
  if (rtype == 51UL) {
#line 80
    goto case_51;
  }
#line 81
  if (rtype == 52UL) {
#line 81
    goto case_52;
  }
#line 82
  if (rtype == 53UL) {
#line 82
    goto case_53;
  }
#line 83
  if (rtype == 54UL) {
#line 83
    goto case_54;
  }
#line 84
  if (rtype == 55UL) {
#line 84
    goto case_55;
  }
#line 85
  if (rtype == 56UL) {
#line 85
    goto case_56;
  }
#line 86
  goto switch_default;
  case_0: /* CIL Label */ 
#line 31
  return ("R_XTENSA_NONE");
  case_1: /* CIL Label */ 
#line 32
  return ("R_XTENSA_32");
  case_2: /* CIL Label */ 
#line 33
  return ("R_XTENSA_RTLD");
  case_3: /* CIL Label */ 
#line 34
  return ("R_XTENSA_GLOB_DAT");
  case_4: /* CIL Label */ 
#line 35
  return ("R_XTENSA_JMP_SLOT");
  case_5: /* CIL Label */ 
#line 36
  return ("R_XTENSA_RELATIVE");
  case_6: /* CIL Label */ 
#line 37
  return ("R_XTENSA_PLT");
  case_8: /* CIL Label */ 
#line 38
  return ("R_XTENSA_OP0");
  case_9: /* CIL Label */ 
#line 39
  return ("R_XTENSA_OP1");
  case_10: /* CIL Label */ 
#line 40
  return ("R_XTENSA_OP2");
  case_11: /* CIL Label */ 
#line 41
  return ("R_XTENSA_ASM_EXPAND");
  case_12: /* CIL Label */ 
#line 42
  return ("R_XTENSA_ASM_SIMPLIFY");
  case_14: /* CIL Label */ 
#line 43
  return ("R_XTENSA_32_PCREL");
  case_15: /* CIL Label */ 
#line 44
  return ("R_XTENSA_GNU_VTINHERIT");
  case_16: /* CIL Label */ 
#line 45
  return ("R_XTENSA_GNU_VTENTRY");
  case_17: /* CIL Label */ 
#line 46
  return ("R_XTENSA_DIFF8");
  case_18: /* CIL Label */ 
#line 47
  return ("R_XTENSA_DIFF16");
  case_19: /* CIL Label */ 
#line 48
  return ("R_XTENSA_DIFF32");
  case_20: /* CIL Label */ 
#line 49
  return ("R_XTENSA_SLOT0_OP");
  case_21: /* CIL Label */ 
#line 50
  return ("R_XTENSA_SLOT1_OP");
  case_22: /* CIL Label */ 
#line 51
  return ("R_XTENSA_SLOT2_OP");
  case_23: /* CIL Label */ 
#line 52
  return ("R_XTENSA_SLOT3_OP");
  case_24: /* CIL Label */ 
#line 53
  return ("R_XTENSA_SLOT4_OP");
  case_25: /* CIL Label */ 
#line 54
  return ("R_XTENSA_SLOT5_OP");
  case_26: /* CIL Label */ 
#line 55
  return ("R_XTENSA_SLOT6_OP");
  case_27: /* CIL Label */ 
#line 56
  return ("R_XTENSA_SLOT7_OP");
  case_28: /* CIL Label */ 
#line 57
  return ("R_XTENSA_SLOT8_OP");
  case_29: /* CIL Label */ 
#line 58
  return ("R_XTENSA_SLOT9_OP");
  case_30: /* CIL Label */ 
#line 59
  return ("R_XTENSA_SLOT10_OP");
  case_31: /* CIL Label */ 
#line 60
  return ("R_XTENSA_SLOT11_OP");
  case_32: /* CIL Label */ 
#line 61
  return ("R_XTENSA_SLOT12_OP");
  case_33: /* CIL Label */ 
#line 62
  return ("R_XTENSA_SLOT13_OP");
  case_34: /* CIL Label */ 
#line 63
  return ("R_XTENSA_SLOT14_OP");
  case_35: /* CIL Label */ 
#line 64
  return ("R_XTENSA_SLOT0_ALT");
  case_36: /* CIL Label */ 
#line 65
  return ("R_XTENSA_SLOT1_ALT");
  case_37: /* CIL Label */ 
#line 66
  return ("R_XTENSA_SLOT2_ALT");
  case_38: /* CIL Label */ 
#line 67
  return ("R_XTENSA_SLOT3_ALT");
  case_39: /* CIL Label */ 
#line 68
  return ("R_XTENSA_SLOT4_ALT");
  case_40: /* CIL Label */ 
#line 69
  return ("R_XTENSA_SLOT5_ALT");
  case_41: /* CIL Label */ 
#line 70
  return ("R_XTENSA_SLOT6_ALT");
  case_42: /* CIL Label */ 
#line 71
  return ("R_XTENSA_SLOT7_ALT");
  case_43: /* CIL Label */ 
#line 72
  return ("R_XTENSA_SLOT8_ALT");
  case_44: /* CIL Label */ 
#line 73
  return ("R_XTENSA_SLOT9_ALT");
  case_45: /* CIL Label */ 
#line 74
  return ("R_XTENSA_SLOT10_ALT");
  case_46: /* CIL Label */ 
#line 75
  return ("R_XTENSA_SLOT11_ALT");
  case_47: /* CIL Label */ 
#line 76
  return ("R_XTENSA_SLOT12_ALT");
  case_48: /* CIL Label */ 
#line 77
  return ("R_XTENSA_SLOT13_ALT");
  case_49: /* CIL Label */ 
#line 78
  return ("R_XTENSA_SLOT14_ALT");
  case_50: /* CIL Label */ 
#line 79
  return ("R_XTENSA_TLSDESC_FN");
  case_51: /* CIL Label */ 
#line 80
  return ("R_XTENSA_TLSDESC_ARG");
  case_52: /* CIL Label */ 
#line 81
  return ("R_XTENSA_TLS_DTPOFF");
  case_53: /* CIL Label */ 
#line 82
  return ("R_XTENSA_TLS_TPOFF");
  case_54: /* CIL Label */ 
#line 83
  return ("R_XTENSA_TLS_FUNC");
  case_55: /* CIL Label */ 
#line 84
  return ("R_XTENSA_TLS_ARG");
  case_56: /* CIL Label */ 
#line 85
  return ("R_XTENSA_TLS_CALL");
  switch_default: /* CIL Label */ 
#line 86
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 121 "./../include/getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 166 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
char *program_name  =    (char *)"readelf";
#line 167 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static long archive_file_offset  ;
#line 168 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long archive_file_size  ;
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long dynamic_addr  ;
#line 170 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_size_type dynamic_size  ;
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int dynamic_nent  ;
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *dynamic_strings  ;
#line 173 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long dynamic_strings_length  ;
#line 174 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *string_table  ;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long string_table_length  ;
#line 176 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long num_dynamic_syms  ;
#line 177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Sym *dynamic_symbols  ;
#line 178 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Syminfo *dynamic_syminfo  ;
#line 179 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned long dynamic_syminfo_offset  ;
#line 180 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int dynamic_syminfo_nent  ;
#line 181 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char program_interpreter[4096]  ;
#line 182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma dynamic_info[32]  ;
#line 183 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma dynamic_info_DT_GNU_HASH  ;
#line 184 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma version_info[16]  ;
#line 185 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Ehdr elf_header  ;
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Shdr *section_headers  ;
#line 187 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Phdr *program_headers  ;
#line 188 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Dyn *dynamic_section  ;
#line 189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Shdr *symtab_shndx_hdr  ;
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int show_name  ;
#line 191 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_dynamic  ;
#line 192 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_syms  ;
#line 193 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_dyn_syms  ;
#line 194 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_reloc  ;
#line 195 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_sections  ;
#line 196 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_section_groups  ;
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_section_details  ;
#line 198 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_segments  ;
#line 199 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_unwind  ;
#line 200 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_using_dynamic  ;
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_header  ;
#line 202 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_dump  ;
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_version  ;
#line 204 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_histogram  ;
#line 205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_debugging  ;
#line 206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_arch  ;
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_notes  ;
#line 208 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int do_archive_index  ;
#line 209 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int is_32bit_elf  ;
#line 223 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static size_t group_count  ;
#line 224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct group *section_groups  ;
#line 225 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct group **section_headers_groups  ;
#line 244 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct dump_list_entry *dump_sects_byname  ;
#line 248 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static dump_type *cmdline_dump_sects  =    (dump_type *)((void *)0);
#line 249 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int num_cmdline_dump_sects  =    0U;
#line 256 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static dump_type *dump_sects  =    (dump_type *)((void *)0);
#line 257 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int num_dump_sects  =    0U;
#line 306 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void *get_data(void *var , FILE *file , long offset , size_t size , size_t nmemb ,
                      char const   *reason ) 
{ 
  void *mvar ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 312
  if (size == 0UL) {
#line 313
    return ((void *)0);
  } else
#line 312
  if (nmemb == 0UL) {
#line 313
    return ((void *)0);
  }
  {
#line 315
  tmp___1 = fseek(file, archive_file_offset + offset, 0);
  }
#line 315
  if (tmp___1) {
    {
#line 317
    tmp___0 = gettext("Unable to seek to 0x%lx for %s\n");
#line 317
    error((char const   *)tmp___0, (unsigned long )archive_file_offset + (unsigned long )offset,
          reason);
    }
#line 319
    return ((void *)0);
  }
#line 322
  mvar = var;
#line 323
  if ((unsigned long )mvar == (unsigned long )((void *)0)) {
#line 326
    if (nmemb < 0xfffffffffffffffeUL / size) {
      {
#line 328
      mvar = malloc(size * nmemb + 1UL);
      }
    }
#line 330
    if ((unsigned long )mvar == (unsigned long )((void *)0)) {
      {
#line 332
      tmp___2 = gettext("Out of memory allocating 0x%lx bytes for %s\n");
#line 332
      error((char const   *)tmp___2, size * nmemb, reason);
      }
#line 334
      return ((void *)0);
    }
#line 337
    *((char *)mvar + size * nmemb) = (char )'\000';
  }
  {
#line 340
  tmp___4 = fread((void */* __restrict  */)mvar, size, nmemb, (FILE */* __restrict  */)file);
  }
#line 340
  if (tmp___4 != nmemb) {
    {
#line 342
    tmp___3 = gettext("Unable to read in 0x%lx bytes of %s\n");
#line 342
    error((char const   *)tmp___3, size * nmemb, reason);
    }
#line 344
    if ((unsigned long )mvar != (unsigned long )var) {
      {
#line 345
      free(mvar);
      }
    }
#line 346
    return ((void *)0);
  }
#line 349
  return (mvar);
}
}
#line 354 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int print_vma(bfd_vma vma , print_mode mode ) 
{ 
  int nc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 357
  nc = 0;
  {
#line 361
  if ((unsigned int )mode == 5U) {
#line 361
    goto case_5;
  }
#line 365
  if ((unsigned int )mode == 6U) {
#line 365
    goto case_6;
  }
#line 373
  if ((unsigned int )mode == 2U) {
#line 373
    goto case_2;
  }
#line 378
  if ((unsigned int )mode == 4U) {
#line 378
    goto case_4;
  }
#line 382
  if ((unsigned int )mode == 0U) {
#line 382
    goto case_0;
  }
#line 385
  if ((unsigned int )mode == 1U) {
#line 385
    goto case_1;
  }
#line 388
  if ((unsigned int )mode == 3U) {
#line 388
    goto case_3;
  }
#line 359
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 362
  nc = printf((char const   */* __restrict  */)"0x");
  }
  case_6: /* CIL Label */ 
#line 367
  if (is_32bit_elf) {
    {
#line 368
    tmp___0 = printf((char const   */* __restrict  */)"%8.8lx", vma);
    }
#line 368
    return (nc + tmp___0);
  }
  {
#line 370
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
          vma);
  }
#line 371
  return (nc + 16);
  case_2: /* CIL Label */ 
#line 374
  if (vma <= 99999UL) {
    {
#line 375
    tmp___1 = printf((char const   */* __restrict  */)"%5ld", vma);
    }
#line 375
    return (tmp___1);
  }
  case_4: /* CIL Label */ 
  {
#line 379
  nc = printf((char const   */* __restrict  */)"0x");
  }
  case_0: /* CIL Label */ 
  {
#line 383
  tmp___2 = printf((char const   */* __restrict  */)"%lx", vma);
  }
#line 383
  return (nc + tmp___2);
  case_1: /* CIL Label */ 
  {
#line 386
  tmp___3 = printf((char const   */* __restrict  */)"%ld", vma);
  }
#line 386
  return (tmp___3);
  case_3: /* CIL Label */ 
  {
#line 389
  tmp___4 = printf((char const   */* __restrict  */)"%lu", vma);
  }
#line 389
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 391
  return (0);
}
}
#line 404 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int print_symbol(int width , char const   *symbol ) 
{ 
  bfd_boolean extra_padding ;
  int num_printed ;
  mbstate_t state ;
  int width_remaining ;
  size_t n ;
  char c ;
  char const   *tmp___0 ;
  wchar_t w ;
  size_t tmp___1 ;

  {
#line 407
  extra_padding = 0;
#line 408
  num_printed = 0;
#line 414
  if (width < 0) {
#line 417
    width = - width;
#line 418
    extra_padding = 1;
  }
#line 421
  if (do_wide) {
#line 424
    width_remaining = 2147483647;
  } else {
#line 426
    width_remaining = width;
  }
  {
#line 430
  memset((void *)(& state), 0, sizeof(state));
  }
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! width_remaining) {
#line 433
      goto while_break;
    }
#line 436
    tmp___0 = symbol;
#line 436
    symbol ++;
#line 436
    c = (char )*tmp___0;
#line 438
    if ((int )c == 0) {
#line 439
      goto while_break;
    }
#line 444
    if ((int const   )_sch_istable[(int )c & 255] & 2) {
#line 446
      if (width_remaining < 2) {
#line 447
        goto while_break;
      }
      {
#line 449
      printf((char const   */* __restrict  */)"^%c", (int )c + 64);
#line 450
      width_remaining -= 2;
#line 451
      num_printed += 2;
      }
    } else
#line 453
    if ((int const   )_sch_istable[(int )c & 255] & 16) {
      {
#line 455
      putchar((int )c);
#line 456
      width_remaining --;
#line 457
      num_printed ++;
      }
    } else {
      {
#line 465
      printf((char const   */* __restrict  */)"%.1s", symbol - 1);
#line 466
      width_remaining --;
#line 467
      num_printed ++;
#line 473
      tmp___1 = __ctype_get_mb_cur_max();
#line 473
      n = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(symbol - 1),
                  tmp___1, (mbstate_t */* __restrict  */)(& state));
      }
#line 477
      if (n != 0xffffffffffffffffUL) {
#line 477
        if (n != 0xfffffffffffffffeUL) {
#line 477
          if (n > 0UL) {
#line 478
            symbol += n - 1UL;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  if (extra_padding) {
#line 482
    if (num_printed < width) {
      {
#line 485
      printf((char const   */* __restrict  */)"%-*s", width - num_printed, " ");
#line 486
      num_printed = width;
      }
    }
  }
#line 489
  return ((unsigned int )num_printed);
}
}
#line 494 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Shdr *find_section(char const   *name___0 ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 499
  i = 0U;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < elf_header.e_shnum)) {
#line 499
      goto while_break;
    }
#line 500
    if ((unsigned long )(section_headers + i) == (unsigned long )((void *)0)) {
      {
#line 500
      tmp___0 = gettext("<none>");
#line 500
      tmp___5 = tmp___0;
      }
    } else {
#line 500
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 500
        tmp___1 = gettext("<no-name>");
#line 500
        tmp___4 = tmp___1;
        }
      } else {
#line 500
        if ((unsigned long )(section_headers + i)->sh_name >= string_table_length) {
          {
#line 500
          tmp___2 = gettext("<corrupt>");
#line 500
          tmp___3 = tmp___2;
          }
        } else {
#line 500
          tmp___3 = string_table + (section_headers + i)->sh_name;
        }
#line 500
        tmp___4 = tmp___3;
      }
#line 500
      tmp___5 = tmp___4;
    }
    {
#line 500
    tmp___6 = strcmp((char const   *)tmp___5, name___0);
    }
#line 500
    if (tmp___6 == 0) {
#line 501
      return (section_headers + i);
    }
#line 499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return ((Elf_Internal_Shdr *)((void *)0));
}
}
#line 509 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Shdr *find_section_by_address(bfd_vma addr ) 
{ 
  unsigned int i ;
  Elf_Internal_Shdr *sec ;

  {
#line 514
  i = 0U;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (i < elf_header.e_shnum)) {
#line 514
      goto while_break;
    }
#line 516
    sec = section_headers + i;
#line 517
    if (addr >= sec->sh_addr) {
#line 517
      if (addr < sec->sh_addr + sec->sh_size) {
#line 518
        return (sec);
      }
    }
#line 514
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return ((Elf_Internal_Shdr *)((void *)0));
}
}
#line 527 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Shdr *find_section_in_set(char const   *name___0 , unsigned int *set ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned int *tmp___7 ;
  Elf_Internal_Shdr *tmp___8 ;

  {
#line 532
  if ((unsigned long )set != (unsigned long )((void *)0)) {
    {
#line 534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 534
      tmp___7 = set;
#line 534
      set ++;
#line 534
      i = *tmp___7;
#line 534
      if (! (i > 0U)) {
#line 534
        goto while_break;
      }
#line 535
      if ((unsigned long )(section_headers + i) == (unsigned long )((void *)0)) {
        {
#line 535
        tmp___0 = gettext("<none>");
#line 535
        tmp___5 = tmp___0;
        }
      } else {
#line 535
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 535
          tmp___1 = gettext("<no-name>");
#line 535
          tmp___4 = tmp___1;
          }
        } else {
#line 535
          if ((unsigned long )(section_headers + i)->sh_name >= string_table_length) {
            {
#line 535
            tmp___2 = gettext("<corrupt>");
#line 535
            tmp___3 = tmp___2;
            }
          } else {
#line 535
            tmp___3 = string_table + (section_headers + i)->sh_name;
          }
#line 535
          tmp___4 = tmp___3;
        }
#line 535
        tmp___5 = tmp___4;
      }
      {
#line 535
      tmp___6 = strcmp((char const   *)tmp___5, name___0);
      }
#line 535
      if (tmp___6 == 0) {
#line 536
        return (section_headers + i);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 539
  tmp___8 = find_section(name___0);
  }
#line 539
  return (tmp___8);
}
}
#line 545 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
__inline static unsigned long read_uleb128___0(unsigned char *data , unsigned int *length_return ,
                                               unsigned char const   * const  end ) 
{ 
  dwarf_vma tmp___0 ;

  {
  {
#line 550
  tmp___0 = read_leb128(data, length_return, 0, end);
  }
#line 550
  return ((unsigned long )tmp___0);
}
}
#line 557 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
__inline static int is_ia64_vms(void) 
{ 
  int tmp___0 ;

  {
#line 560
  if ((int )elf_header.e_machine == 50) {
#line 560
    if ((int )elf_header.e_ident[7] == 13) {
#line 560
      tmp___0 = 1;
    } else {
#line 560
      tmp___0 = 0;
    }
  } else {
#line 560
    tmp___0 = 0;
  }
#line 560
  return (tmp___0);
}
}
#line 566 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int guess_is_rela(unsigned int e_machine ) 
{ 
  char *tmp___0 ;

  {
  {
#line 585
  if (e_machine == 115U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 135U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 33906U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 92U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 36929U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 10U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 8U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 23205U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 30288U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 85U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 40U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 19U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 6U) {
#line 585
    goto case_115;
  }
#line 585
  if (e_machine == 3U) {
#line 585
    goto case_115;
  }
#line 655
  if (e_machine == 47787U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 189U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 43975U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 94U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 44357U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 181U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 180U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 62U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 75U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 36992U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 87U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 36U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 188U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 191U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 140U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 23U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 43U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 18U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 2U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 42U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 41872U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 22U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 173U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 197U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 20U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 21U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 65211U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 9520U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 4185U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 105U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 65261U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 48879U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 89U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 57005U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 90U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 80U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 174U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 61453U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 39U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 88U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 120U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 65200U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 138U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 65210U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 33303U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 101U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 50U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 47U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 46U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 48U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 21569U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 13104U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 84U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 30326U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 86U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 114U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 76U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 177U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 106U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 4183U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 83U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 113U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 36902U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 4643U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 183U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 7U) {
#line 655
    goto case_47787;
  }
#line 655
  if (e_machine == 4U) {
#line 655
    goto case_47787;
  }
#line 675
  goto switch_default;
  case_115: /* CIL Label */ 
  case_135: /* CIL Label */ 
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_36929: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_23205: /* CIL Label */ 
  case_30288: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 586
  return (0);
  case_47787: /* CIL Label */ 
  case_189: /* CIL Label */ 
  case_43975: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_44357: /* CIL Label */ 
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_36992: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_188: /* CIL Label */ 
  case_191: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41872: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_173: /* CIL Label */ 
  case_197: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_65211: /* CIL Label */ 
  case_9520: /* CIL Label */ 
  case_4185: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_65261: /* CIL Label */ 
  case_48879: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_57005: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_174: /* CIL Label */ 
  case_61453: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
  case_138: /* CIL Label */ 
  case_65210: /* CIL Label */ 
  case_33303: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_21569: /* CIL Label */ 
  case_13104: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_30326: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_177: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_4183: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_4643: /* CIL Label */ 
  case_183: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 656
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 676
  tmp___0 = gettext("Don\'t know about relocations on this machine architecture\n");
#line 676
  warn((char const   *)tmp___0);
  }
#line 677
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 681 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int slurp_rela_relocs(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                             Elf_Internal_Rela **relasp , unsigned long *nrelasp ) 
{ 
  Elf_Internal_Rela *relas ;
  unsigned long nrelas ;
  unsigned int i ;
  Elf32_External_Rela *erelas ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  Elf64_External_Rela *erelas___0 ;
  char *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  bfd_vma inf ;

  {
#line 692
  if (is_32bit_elf) {
    {
#line 696
    tmp___0 = gettext("32-bit relocation data");
#line 696
    tmp___1 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___0);
#line 696
    erelas = (Elf32_External_Rela *)tmp___1;
    }
#line 698
    if (! erelas) {
#line 699
      return (0);
    }
    {
#line 701
    nrelas = rel_size / sizeof(Elf32_External_Rela );
#line 703
    tmp___2 = cmalloc(nrelas, sizeof(Elf_Internal_Rela ));
#line 703
    relas = (Elf_Internal_Rela *)tmp___2;
    }
#line 706
    if ((unsigned long )relas == (unsigned long )((void *)0)) {
      {
#line 708
      free((void *)erelas);
#line 709
      tmp___3 = gettext("out of memory parsing relocs\n");
#line 709
      error((char const   *)tmp___3);
      }
#line 710
      return (0);
    }
#line 713
    i = 0U;
    {
#line 713
    while (1) {
      while_continue: /* CIL Label */ ;
#line 713
      if (! ((unsigned long )i < nrelas)) {
#line 713
        goto while_break;
      }
      {
#line 715
      tmp___4 = (*byte_get)((erelas + i)->r_offset, (int )sizeof((erelas + i)->r_offset));
#line 715
      (relas + i)->r_offset = (bfd_vma )tmp___4;
#line 716
      tmp___5 = (*byte_get)((erelas + i)->r_info, (int )sizeof((erelas + i)->r_info));
#line 716
      (relas + i)->r_info = (bfd_vma )tmp___5;
#line 717
      tmp___6 = byte_get_signed((erelas + i)->r_addend, (int )sizeof((erelas + i)->r_addend));
#line 717
      (relas + i)->r_addend = (bfd_vma )tmp___6;
#line 713
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 720
    free((void *)erelas);
    }
  } else {
    {
#line 726
    tmp___7 = gettext("64-bit relocation data");
#line 726
    tmp___8 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___7);
#line 726
    erelas___0 = (Elf64_External_Rela *)tmp___8;
    }
#line 728
    if (! erelas___0) {
#line 729
      return (0);
    }
    {
#line 731
    nrelas = rel_size / sizeof(Elf64_External_Rela );
#line 733
    tmp___9 = cmalloc(nrelas, sizeof(Elf_Internal_Rela ));
#line 733
    relas = (Elf_Internal_Rela *)tmp___9;
    }
#line 736
    if ((unsigned long )relas == (unsigned long )((void *)0)) {
      {
#line 738
      free((void *)erelas___0);
#line 739
      tmp___10 = gettext("out of memory parsing relocs\n");
#line 739
      error((char const   *)tmp___10);
      }
#line 740
      return (0);
    }
#line 743
    i = 0U;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )i < nrelas)) {
#line 743
        goto while_break___0;
      }
      {
#line 745
      tmp___11 = (*byte_get)((erelas___0 + i)->r_offset, (int )sizeof((erelas___0 + i)->r_offset));
#line 745
      (relas + i)->r_offset = (bfd_vma )tmp___11;
#line 746
      tmp___12 = (*byte_get)((erelas___0 + i)->r_info, (int )sizeof((erelas___0 + i)->r_info));
#line 746
      (relas + i)->r_info = (bfd_vma )tmp___12;
#line 747
      tmp___13 = byte_get_signed((erelas___0 + i)->r_addend, (int )sizeof((erelas___0 + i)->r_addend));
#line 747
      (relas + i)->r_addend = (bfd_vma )tmp___13;
      }
#line 753
      if ((int )elf_header.e_machine == 8) {
#line 753
        if ((int )elf_header.e_ident[5] != 2) {
#line 761
          inf = (relas + i)->r_info;
#line 762
          inf = (((((inf & 4294967295UL) << 32) | ((inf >> 56) & 255UL)) | ((inf >> 40) & 65280UL)) | ((inf >> 24) & 16711680UL)) | ((inf >> 8) & 4278190080UL);
#line 767
          (relas + i)->r_info = inf;
        }
      }
#line 743
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 772
    free((void *)erelas___0);
    }
  }
#line 774
  *relasp = relas;
#line 775
  *nrelasp = nrelas;
#line 776
  return (1);
}
}
#line 779 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int slurp_rel_relocs(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                            Elf_Internal_Rela **relsp , unsigned long *nrelsp ) 
{ 
  Elf_Internal_Rela *rels ;
  unsigned long nrels ;
  unsigned int i ;
  Elf32_External_Rel *erels ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  Elf64_External_Rel *erels___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  bfd_vma inf ;

  {
#line 790
  if (is_32bit_elf) {
    {
#line 794
    tmp___0 = gettext("32-bit relocation data");
#line 794
    tmp___1 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___0);
#line 794
    erels = (Elf32_External_Rel *)tmp___1;
    }
#line 796
    if (! erels) {
#line 797
      return (0);
    }
    {
#line 799
    nrels = rel_size / sizeof(Elf32_External_Rel );
#line 801
    tmp___2 = cmalloc(nrels, sizeof(Elf_Internal_Rela ));
#line 801
    rels = (Elf_Internal_Rela *)tmp___2;
    }
#line 803
    if ((unsigned long )rels == (unsigned long )((void *)0)) {
      {
#line 805
      free((void *)erels);
#line 806
      tmp___3 = gettext("out of memory parsing relocs\n");
#line 806
      error((char const   *)tmp___3);
      }
#line 807
      return (0);
    }
#line 810
    i = 0U;
    {
#line 810
    while (1) {
      while_continue: /* CIL Label */ ;
#line 810
      if (! ((unsigned long )i < nrels)) {
#line 810
        goto while_break;
      }
      {
#line 812
      tmp___4 = (*byte_get)((erels + i)->r_offset, (int )sizeof((erels + i)->r_offset));
#line 812
      (rels + i)->r_offset = (bfd_vma )tmp___4;
#line 813
      tmp___5 = (*byte_get)((erels + i)->r_info, (int )sizeof((erels + i)->r_info));
#line 813
      (rels + i)->r_info = (bfd_vma )tmp___5;
#line 814
      (rels + i)->r_addend = (bfd_vma )0;
#line 810
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 817
    free((void *)erels);
    }
  } else {
    {
#line 823
    tmp___6 = gettext("64-bit relocation data");
#line 823
    tmp___7 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___6);
#line 823
    erels___0 = (Elf64_External_Rel *)tmp___7;
    }
#line 825
    if (! erels___0) {
#line 826
      return (0);
    }
    {
#line 828
    nrels = rel_size / sizeof(Elf64_External_Rel );
#line 830
    tmp___8 = cmalloc(nrels, sizeof(Elf_Internal_Rela ));
#line 830
    rels = (Elf_Internal_Rela *)tmp___8;
    }
#line 832
    if ((unsigned long )rels == (unsigned long )((void *)0)) {
      {
#line 834
      free((void *)erels___0);
#line 835
      tmp___9 = gettext("out of memory parsing relocs\n");
#line 835
      error((char const   *)tmp___9);
      }
#line 836
      return (0);
    }
#line 839
    i = 0U;
    {
#line 839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 839
      if (! ((unsigned long )i < nrels)) {
#line 839
        goto while_break___0;
      }
      {
#line 841
      tmp___10 = (*byte_get)((erels___0 + i)->r_offset, (int )sizeof((erels___0 + i)->r_offset));
#line 841
      (rels + i)->r_offset = (bfd_vma )tmp___10;
#line 842
      tmp___11 = (*byte_get)((erels___0 + i)->r_info, (int )sizeof((erels___0 + i)->r_info));
#line 842
      (rels + i)->r_info = (bfd_vma )tmp___11;
#line 843
      (rels + i)->r_addend = (bfd_vma )0;
      }
#line 849
      if ((int )elf_header.e_machine == 8) {
#line 849
        if ((int )elf_header.e_ident[5] != 2) {
#line 857
          inf = (rels + i)->r_info;
#line 858
          inf = (((((inf & 4294967295UL) << 32) | ((inf >> 56) & 255UL)) | ((inf >> 40) & 65280UL)) | ((inf >> 24) & 16711680UL)) | ((inf >> 8) & 4278190080UL);
#line 863
          (rels + i)->r_info = inf;
        }
      }
#line 839
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 868
    free((void *)erels___0);
    }
  }
#line 870
  *relsp = rels;
#line 871
  *nrelsp = nrels;
#line 872
  return (1);
}
}
#line 877 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned int get_reloc_type(bfd_vma reloc_info ) 
{ 


  {
#line 880
  if (is_32bit_elf) {
#line 881
    return ((unsigned int )(reloc_info & 255UL));
  }
  {
#line 885
  if ((int )elf_header.e_machine == 8) {
#line 885
    goto case_8;
  }
#line 889
  if ((int )elf_header.e_machine == 43) {
#line 889
    goto case_43;
  }
#line 892
  goto switch_default;
  case_8: /* CIL Label */ 
#line 887
  return ((unsigned int )(reloc_info & 255UL));
  case_43: /* CIL Label */ 
#line 890
  return ((unsigned int )(reloc_info & 255UL));
  switch_default: /* CIL Label */ 
#line 893
  return ((unsigned int )(reloc_info & 4294967295UL));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 899 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma get_reloc_symindex(bfd_vma reloc_info ) 
{ 
  bfd_vma tmp___0 ;

  {
#line 902
  if (is_32bit_elf) {
#line 902
    tmp___0 = reloc_info >> 8;
  } else {
#line 902
    tmp___0 = reloc_info >> 32;
  }
#line 902
  return (tmp___0);
}
}
#line 905 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
__inline static bfd_boolean uses_msp430x_relocs(void) 
{ 
  int tmp___0 ;

  {
#line 908
  if ((int )elf_header.e_machine == 105) {
#line 908
    if ((elf_header.e_flags & 255UL) == 45UL) {
#line 908
      tmp___0 = 1;
    } else
#line 908
    if ((int )elf_header.e_ident[7] == 0) {
#line 908
      tmp___0 = 1;
    } else {
#line 908
      tmp___0 = 0;
    }
  } else {
#line 908
    tmp___0 = 0;
  }
#line 908
  return (tmp___0);
}
}
#line 919 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_relocations(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                             Elf_Internal_Sym *symtab , unsigned long nsyms , char *strtab ,
                             unsigned long strtablen , int is_rela ) 
{ 
  unsigned int i ;
  Elf_Internal_Rela *rels ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char const   *rtype ;
  bfd_vma offset ;
  bfd_vma inf ;
  bfd_vma symtab_index ;
  bfd_vma type ;
  unsigned int tmp___10 ;
  char const   *tmp___11 ;
  bfd_boolean tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  Elf_Internal_Sym *psym ;
  char const   *name___0 ;
  unsigned int len ;
  unsigned int width ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  char const   *tmp___19 ;
  char const   *sec_name ;
  char name_buf[40] ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  bfd_signed_vma off ;
  bfd_signed_vma off___0 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  bfd_vma type2 ;
  bfd_vma type3 ;
  char const   *rtype2 ;
  char const   *tmp___31 ;
  char const   *rtype3 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
#line 932
  if (is_rela == -1) {
    {
#line 933
    is_rela = guess_is_rela((unsigned int )elf_header.e_machine);
    }
  }
#line 935
  if (is_rela) {
    {
#line 937
    tmp___0 = slurp_rela_relocs(file, rel_offset, rel_size, & rels, & rel_size);
    }
#line 937
    if (! tmp___0) {
#line 938
      return;
    }
  } else {
    {
#line 942
    tmp___1 = slurp_rel_relocs(file, rel_offset, rel_size, & rels, & rel_size);
    }
#line 942
    if (! tmp___1) {
#line 943
      return;
    }
  }
#line 946
  if (is_32bit_elf) {
#line 948
    if (is_rela) {
#line 950
      if (do_wide) {
        {
#line 951
        tmp___2 = gettext(" Offset     Info    Type                Sym. Value  Symbol\'s Name + Addend\n");
#line 951
        printf((char const   */* __restrict  */)tmp___2);
        }
      } else {
        {
#line 953
        tmp___3 = gettext(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n");
#line 953
        printf((char const   */* __restrict  */)tmp___3);
        }
      }
    } else
#line 957
    if (do_wide) {
      {
#line 958
      tmp___4 = gettext(" Offset     Info    Type                Sym. Value  Symbol\'s Name\n");
#line 958
      printf((char const   */* __restrict  */)tmp___4);
      }
    } else {
      {
#line 960
      tmp___5 = gettext(" Offset     Info    Type            Sym.Value  Sym. Name\n");
#line 960
      printf((char const   */* __restrict  */)tmp___5);
      }
    }
  } else
#line 965
  if (is_rela) {
#line 967
    if (do_wide) {
      {
#line 968
      tmp___6 = gettext("    Offset             Info             Type               Symbol\'s Value  Symbol\'s Name + Addend\n");
#line 968
      printf((char const   */* __restrict  */)tmp___6);
      }
    } else {
      {
#line 970
      tmp___7 = gettext("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n");
#line 970
      printf((char const   */* __restrict  */)tmp___7);
      }
    }
  } else
#line 974
  if (do_wide) {
    {
#line 975
    tmp___8 = gettext("    Offset             Info             Type               Symbol\'s Value  Symbol\'s Name\n");
#line 975
    printf((char const   */* __restrict  */)tmp___8);
    }
  } else {
    {
#line 977
    tmp___9 = gettext("  Offset          Info           Type           Sym. Value    Sym. Name\n");
#line 977
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
#line 981
  i = 0U;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! ((unsigned long )i < rel_size)) {
#line 981
      goto while_break;
    }
    {
#line 989
    offset = (rels + i)->r_offset;
#line 990
    inf = (rels + i)->r_info;
#line 992
    tmp___10 = get_reloc_type(inf);
#line 992
    type = (bfd_vma )tmp___10;
#line 993
    symtab_index = get_reloc_symindex(inf);
    }
#line 995
    if (is_32bit_elf) {
      {
#line 997
      printf((char const   */* __restrict  */)"%8.8lx  %8.8lx ", offset & 4294967295UL,
             inf & 4294967295UL);
      }
    } else {
#line 1004
      if (do_wide) {
#line 1004
        tmp___11 = "%16.16lx  %16.16lx ";
      } else {
#line 1004
        tmp___11 = "%12.12lx  %12.12lx ";
      }
      {
#line 1004
      printf((char const   */* __restrict  */)tmp___11, offset, inf);
      }
    }
    {
#line 1037
    if ((int )elf_header.e_machine == 183) {
#line 1037
      goto case_183;
    }
#line 1042
    if ((int )elf_header.e_machine == 36929) {
#line 1042
      goto case_36929;
    }
#line 1042
    if ((int )elf_header.e_machine == 88) {
#line 1042
      goto case_36929;
    }
#line 1047
    if ((int )elf_header.e_machine == 6) {
#line 1047
      goto case_6;
    }
#line 1047
    if ((int )elf_header.e_machine == 3) {
#line 1047
      goto case_6;
    }
#line 1052
    if ((int )elf_header.e_machine == 53) {
#line 1052
      goto case_53;
    }
#line 1052
    if ((int )elf_header.e_machine == 70) {
#line 1052
      goto case_53;
    }
#line 1056
    if ((int )elf_header.e_machine == 4) {
#line 1056
      goto case_4;
    }
#line 1060
    if ((int )elf_header.e_machine == 19) {
#line 1060
      goto case_19;
    }
#line 1065
    if ((int )elf_header.e_machine == 4183) {
#line 1065
      goto case_4183;
    }
#line 1065
    if ((int )elf_header.e_machine == 83) {
#line 1065
      goto case_4183;
    }
#line 1072
    if ((int )elf_header.e_machine == 2) {
#line 1072
      goto case_2;
    }
#line 1072
    if ((int )elf_header.e_machine == 43) {
#line 1072
      goto case_2;
    }
#line 1072
    if ((int )elf_header.e_machine == 18) {
#line 1072
      goto case_2;
    }
#line 1072
    if ((int )elf_header.e_machine == 11) {
#line 1072
      goto case_2;
    }
#line 1076
    if ((int )elf_header.e_machine == 23) {
#line 1076
      goto case_23;
    }
#line 1080
    if ((int )elf_header.e_machine == 36) {
#line 1080
      goto case_36;
    }
#line 1084
    if ((int )elf_header.e_machine == 36992) {
#line 1084
      goto case_36992;
    }
#line 1084
    if ((int )elf_header.e_machine == 87) {
#line 1084
      goto case_36992;
    }
#line 1089
    if ((int )elf_header.e_machine == 30288) {
#line 1089
      goto case_30288;
    }
#line 1089
    if ((int )elf_header.e_machine == 85) {
#line 1089
      goto case_30288;
    }
#line 1094
    if ((int )elf_header.e_machine == 30326) {
#line 1094
      goto case_30326;
    }
#line 1094
    if ((int )elf_header.e_machine == 86) {
#line 1094
      goto case_30326;
    }
#line 1098
    if ((int )elf_header.e_machine == 23205) {
#line 1098
      goto case_23205;
    }
#line 1102
    if ((int )elf_header.e_machine == 42) {
#line 1102
      goto case_42;
    }
#line 1107
    if ((int )elf_header.e_machine == 48879) {
#line 1107
      goto case_48879;
    }
#line 1107
    if ((int )elf_header.e_machine == 89) {
#line 1107
      goto case_48879;
    }
#line 1112
    if ((int )elf_header.e_machine == 57005) {
#line 1112
      goto case_57005;
    }
#line 1112
    if ((int )elf_header.e_machine == 90) {
#line 1112
      goto case_57005;
    }
#line 1117
    if ((int )elf_header.e_machine == 13104) {
#line 1117
      goto case_13104;
    }
#line 1117
    if ((int )elf_header.e_machine == 84) {
#line 1117
      goto case_13104;
    }
#line 1121
    if ((int )elf_header.e_machine == 21569) {
#line 1121
      goto case_21569;
    }
#line 1125
    if ((int )elf_header.e_machine == 39) {
#line 1125
      goto case_39;
    }
#line 1129
    if ((int )elf_header.e_machine == 80) {
#line 1129
      goto case_80;
    }
#line 1133
    if ((int )elf_header.e_machine == 65261) {
#line 1133
      goto case_65261;
    }
#line 1137
    if ((int )elf_header.e_machine == 105) {
#line 1137
      goto case_105;
    }
#line 1143
    if ((int )elf_header.e_machine == 4185) {
#line 1143
      goto case_4185;
    }
#line 1147
    if ((int )elf_header.e_machine == 20) {
#line 1147
      goto case_20;
    }
#line 1151
    if ((int )elf_header.e_machine == 21) {
#line 1151
      goto case_21;
    }
#line 1156
    if ((int )elf_header.e_machine == 10) {
#line 1156
      goto case_10;
    }
#line 1156
    if ((int )elf_header.e_machine == 8) {
#line 1156
      goto case_10;
    }
#line 1160
    if ((int )elf_header.e_machine == 36902) {
#line 1160
      goto case_36902;
    }
#line 1164
    if ((int )elf_header.e_machine == 40) {
#line 1164
      goto case_40;
    }
#line 1168
    if ((int )elf_header.e_machine == 45) {
#line 1168
      goto case_45;
    }
#line 1172
    if ((int )elf_header.e_machine == 15) {
#line 1172
      goto case_15;
    }
#line 1178
    if ((int )elf_header.e_machine == 48) {
#line 1178
      goto case_48;
    }
#line 1178
    if ((int )elf_header.e_machine == 47) {
#line 1178
      goto case_48;
    }
#line 1178
    if ((int )elf_header.e_machine == 46) {
#line 1178
      goto case_48;
    }
#line 1183
    if ((int )elf_header.e_machine == 33906) {
#line 1183
      goto case_33906;
    }
#line 1183
    if ((int )elf_header.e_machine == 92) {
#line 1183
      goto case_33906;
    }
#line 1188
    if ((int )elf_header.e_machine == 99) {
#line 1188
      goto case_99;
    }
#line 1188
    if ((int )elf_header.e_machine == 91) {
#line 1188
      goto case_99;
    }
#line 1191
    if ((int )elf_header.e_machine == 50) {
#line 1191
      goto case_50;
    }
#line 1195
    if ((int )elf_header.e_machine == 76) {
#line 1195
      goto case_76;
    }
#line 1199
    if ((int )elf_header.e_machine == 7) {
#line 1199
      goto case_7;
    }
#line 1205
    if ((int )elf_header.e_machine == 181) {
#line 1205
      goto case_181;
    }
#line 1205
    if ((int )elf_header.e_machine == 180) {
#line 1205
      goto case_181;
    }
#line 1205
    if ((int )elf_header.e_machine == 62) {
#line 1205
      goto case_181;
    }
#line 1209
    if ((int )elf_header.e_machine == 9) {
#line 1209
      goto case_9;
    }
#line 1214
    if ((int )elf_header.e_machine == 22) {
#line 1214
      goto case_22;
    }
#line 1214
    if ((int )elf_header.e_machine == 41872) {
#line 1214
      goto case_22;
    }
#line 1218
    if ((int )elf_header.e_machine == 135) {
#line 1218
      goto case_135;
    }
#line 1222
    if ((int )elf_header.e_machine == 44357) {
#line 1222
      goto case_44357;
    }
#line 1226
    if ((int )elf_header.e_machine == 114) {
#line 1226
      goto case_114;
    }
#line 1230
    if ((int )elf_header.e_machine == 75) {
#line 1230
      goto case_75;
    }
#line 1234
    if ((int )elf_header.e_machine == 4643) {
#line 1234
      goto case_4643;
    }
#line 1239
    if ((int )elf_header.e_machine == 33303) {
#line 1239
      goto case_33303;
    }
#line 1239
    if ((int )elf_header.e_machine == 101) {
#line 1239
      goto case_33303;
    }
#line 1243
    if ((int )elf_header.e_machine == 65210) {
#line 1243
      goto case_65210;
    }
#line 1248
    if ((int )elf_header.e_machine == 94) {
#line 1248
      goto case_94;
    }
#line 1248
    if ((int )elf_header.e_machine == 43975) {
#line 1248
      goto case_94;
    }
#line 1252
    if ((int )elf_header.e_machine == 138) {
#line 1252
      goto case_138;
    }
#line 1257
    if ((int )elf_header.e_machine == 120) {
#line 1257
      goto case_120;
    }
#line 1257
    if ((int )elf_header.e_machine == 65200) {
#line 1257
      goto case_120;
    }
#line 1261
    if ((int )elf_header.e_machine == 9520) {
#line 1261
      goto case_9520;
    }
#line 1265
    if ((int )elf_header.e_machine == 106) {
#line 1265
      goto case_106;
    }
#line 1269
    if ((int )elf_header.e_machine == 61453) {
#line 1269
      goto case_61453;
    }
#line 1273
    if ((int )elf_header.e_machine == 177) {
#line 1273
      goto case_177;
    }
#line 1278
    if ((int )elf_header.e_machine == 47787) {
#line 1278
      goto case_47787;
    }
#line 1278
    if ((int )elf_header.e_machine == 189) {
#line 1278
      goto case_47787;
    }
#line 1282
    if ((int )elf_header.e_machine == 197) {
#line 1282
      goto case_197;
    }
#line 1286
    if ((int )elf_header.e_machine == 173) {
#line 1286
      goto case_173;
    }
#line 1290
    if ((int )elf_header.e_machine == 174) {
#line 1290
      goto case_174;
    }
#line 1295
    if ((int )elf_header.e_machine == 116) {
#line 1295
      goto case_116;
    }
#line 1295
    if ((int )elf_header.e_machine == 18056) {
#line 1295
      goto case_116;
    }
#line 1299
    if ((int )elf_header.e_machine == 140) {
#line 1299
      goto case_140;
    }
#line 1303
    if ((int )elf_header.e_machine == 191) {
#line 1303
      goto case_191;
    }
#line 1307
    if ((int )elf_header.e_machine == 188) {
#line 1307
      goto case_188;
    }
#line 1311
    if ((int )elf_header.e_machine == 115) {
#line 1311
      goto case_115;
    }
#line 1315
    if ((int )elf_header.e_machine == 113) {
#line 1315
      goto case_113;
    }
#line 1033
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1034
    rtype = (char const   *)((void *)0);
#line 1035
    goto switch_break;
    case_183: /* CIL Label */ 
    {
#line 1038
    rtype = elf_aarch64_reloc_type(type);
    }
#line 1039
    goto switch_break;
    case_36929: /* CIL Label */ 
    case_88: /* CIL Label */ 
    {
#line 1043
    rtype = elf_m32r_reloc_type(type);
    }
#line 1044
    goto switch_break;
    case_6: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 1048
    rtype = elf_i386_reloc_type(type);
    }
#line 1049
    goto switch_break;
    case_53: /* CIL Label */ 
    case_70: /* CIL Label */ 
    {
#line 1053
    rtype = elf_m68hc11_reloc_type(type);
    }
#line 1054
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1057
    rtype = elf_m68k_reloc_type(type);
    }
#line 1058
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1061
    rtype = elf_i960_reloc_type(type);
    }
#line 1062
    goto switch_break;
    case_4183: /* CIL Label */ 
    case_83: /* CIL Label */ 
    {
#line 1066
    rtype = elf_avr_reloc_type(type);
    }
#line 1067
    goto switch_break;
    case_2: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_11: /* CIL Label */ 
    {
#line 1073
    rtype = elf_sparc_reloc_type(type);
    }
#line 1074
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1077
    rtype = elf_spu_reloc_type(type);
    }
#line 1078
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 1081
    rtype = v800_reloc_type(type);
    }
#line 1082
    goto switch_break;
    case_36992: /* CIL Label */ 
    case_87: /* CIL Label */ 
    {
#line 1085
    rtype = v850_reloc_type(type);
    }
#line 1086
    goto switch_break;
    case_30288: /* CIL Label */ 
    case_85: /* CIL Label */ 
    {
#line 1090
    rtype = elf_d10v_reloc_type(type);
    }
#line 1091
    goto switch_break;
    case_30326: /* CIL Label */ 
    case_86: /* CIL Label */ 
    {
#line 1095
    rtype = elf_d30v_reloc_type(type);
    }
#line 1096
    goto switch_break;
    case_23205: /* CIL Label */ 
    {
#line 1099
    rtype = elf_dlx_reloc_type(type);
    }
#line 1100
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 1103
    rtype = elf_sh_reloc_type(type);
    }
#line 1104
    goto switch_break;
    case_48879: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
#line 1108
    rtype = elf_mn10300_reloc_type(type);
    }
#line 1109
    goto switch_break;
    case_57005: /* CIL Label */ 
    case_90: /* CIL Label */ 
    {
#line 1113
    rtype = elf_mn10200_reloc_type(type);
    }
#line 1114
    goto switch_break;
    case_13104: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 1118
    rtype = elf_fr30_reloc_type(type);
    }
#line 1119
    goto switch_break;
    case_21569: /* CIL Label */ 
    {
#line 1122
    rtype = elf_frv_reloc_type(type);
    }
#line 1123
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 1126
    rtype = elf_mcore_reloc_type(type);
    }
#line 1127
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 1130
    rtype = elf_mmix_reloc_type(type);
    }
#line 1131
    goto switch_break;
    case_65261: /* CIL Label */ 
    {
#line 1134
    rtype = elf_moxie_reloc_type(type);
    }
#line 1135
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 1138
    tmp___12 = uses_msp430x_relocs();
    }
#line 1138
    if (tmp___12) {
      {
#line 1140
      rtype = elf_msp430x_reloc_type(type);
      }
#line 1141
      goto switch_break;
    }
    case_4185: /* CIL Label */ 
    {
#line 1144
    rtype = elf_msp430_reloc_type(type);
    }
#line 1145
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 1148
    rtype = elf_ppc_reloc_type(type);
    }
#line 1149
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 1152
    rtype = elf_ppc64_reloc_type(type);
    }
#line 1153
    goto switch_break;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 1157
    rtype = elf_mips_reloc_type(type);
    }
#line 1158
    goto switch_break;
    case_36902: /* CIL Label */ 
    {
#line 1161
    rtype = elf_alpha_reloc_type(type);
    }
#line 1162
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 1165
    rtype = elf_arm_reloc_type(type);
    }
#line 1166
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 1169
    rtype = elf_arc_reloc_type(type);
    }
#line 1170
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1173
    rtype = elf_hppa_reloc_type(type);
    }
#line 1174
    goto switch_break;
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    {
#line 1179
    rtype = elf_h8_reloc_type(type);
    }
#line 1180
    goto switch_break;
    case_33906: /* CIL Label */ 
    case_92: /* CIL Label */ 
    {
#line 1184
    rtype = elf_or32_reloc_type(type);
    }
#line 1185
    goto switch_break;
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
    {
#line 1189
    rtype = elf_pj_reloc_type(type);
    }
#line 1190
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 1192
    rtype = elf_ia64_reloc_type(type);
    }
#line 1193
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1196
    rtype = elf_cris_reloc_type(type);
    }
#line 1197
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1200
    rtype = elf_i860_reloc_type(type);
    }
#line 1201
    goto switch_break;
    case_181: /* CIL Label */ 
    case_180: /* CIL Label */ 
    case_62: /* CIL Label */ 
    {
#line 1206
    rtype = elf_x86_64_reloc_type(type);
    }
#line 1207
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1210
    rtype = i370_reloc_type(type);
    }
#line 1211
    goto switch_break;
    case_22: /* CIL Label */ 
    case_41872: /* CIL Label */ 
    {
#line 1215
    rtype = elf_s390_reloc_type(type);
    }
#line 1216
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 1219
    rtype = elf_score_reloc_type(type);
    }
#line 1220
    goto switch_break;
    case_44357: /* CIL Label */ 
    {
#line 1223
    rtype = elf_xstormy16_reloc_type(type);
    }
#line 1224
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1227
    rtype = elf_crx_reloc_type(type);
    }
#line 1228
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1231
    rtype = elf_vax_reloc_type(type);
    }
#line 1232
    goto switch_break;
    case_4643: /* CIL Label */ 
    {
#line 1235
    rtype = elf_epiphany_reloc_type(type);
    }
#line 1236
    goto switch_break;
    case_33303: /* CIL Label */ 
    case_101: /* CIL Label */ 
    {
#line 1240
    rtype = elf_ip2k_reloc_type(type);
    }
#line 1241
    goto switch_break;
    case_65210: /* CIL Label */ 
    {
#line 1244
    rtype = elf_iq2000_reloc_type(type);
    }
#line 1245
    goto switch_break;
    case_94: /* CIL Label */ 
    case_43975: /* CIL Label */ 
    {
#line 1249
    rtype = elf_xtensa_reloc_type(type);
    }
#line 1250
    goto switch_break;
    case_138: /* CIL Label */ 
    {
#line 1253
    rtype = elf_lm32_reloc_type(type);
    }
#line 1254
    goto switch_break;
    case_120: /* CIL Label */ 
    case_65200: /* CIL Label */ 
    {
#line 1258
    rtype = elf_m32c_reloc_type(type);
    }
#line 1259
    goto switch_break;
    case_9520: /* CIL Label */ 
    {
#line 1262
    rtype = elf_mt_reloc_type(type);
    }
#line 1263
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 1266
    rtype = elf_bfin_reloc_type(type);
    }
#line 1267
    goto switch_break;
    case_61453: /* CIL Label */ 
    {
#line 1270
    rtype = elf_mep_reloc_type(type);
    }
#line 1271
    goto switch_break;
    case_177: /* CIL Label */ 
    {
#line 1274
    rtype = elf_cr16_reloc_type(type);
    }
#line 1275
    goto switch_break;
    case_47787: /* CIL Label */ 
    case_189: /* CIL Label */ 
    {
#line 1279
    rtype = elf_microblaze_reloc_type(type);
    }
#line 1280
    goto switch_break;
    case_197: /* CIL Label */ 
    {
#line 1283
    rtype = elf_rl78_reloc_type(type);
    }
#line 1284
    goto switch_break;
    case_173: /* CIL Label */ 
    {
#line 1287
    rtype = elf_rx_reloc_type(type);
    }
#line 1288
    goto switch_break;
    case_174: /* CIL Label */ 
    {
#line 1291
    rtype = elf_metag_reloc_type(type);
    }
#line 1292
    goto switch_break;
    case_116: /* CIL Label */ 
    case_18056: /* CIL Label */ 
    {
#line 1296
    rtype = elf_xc16x_reloc_type(type);
    }
#line 1297
    goto switch_break;
    case_140: /* CIL Label */ 
    {
#line 1300
    rtype = elf_tic6x_reloc_type(type);
    }
#line 1301
    goto switch_break;
    case_191: /* CIL Label */ 
    {
#line 1304
    rtype = elf_tilegx_reloc_type(type);
    }
#line 1305
    goto switch_break;
    case_188: /* CIL Label */ 
    {
#line 1308
    rtype = elf_tilepro_reloc_type(type);
    }
#line 1309
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1312
    rtype = elf_xgate_reloc_type(type);
    }
#line 1313
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 1316
    rtype = elf_nios2_reloc_type(type);
    }
#line 1317
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1320
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 1321
      tmp___13 = gettext("unrecognized: %-7lx");
#line 1321
      printf((char const   */* __restrict  */)tmp___13, type & 4294967295UL);
      }
    } else {
#line 1323
      if (do_wide) {
#line 1323
        tmp___14 = "%-22.22s";
      } else {
#line 1323
        tmp___14 = "%-17.17s";
      }
      {
#line 1323
      printf((char const   */* __restrict  */)tmp___14, rtype);
      }
    }
#line 1325
    if ((int )elf_header.e_machine == 36902) {
#line 1325
      if ((unsigned long )rtype != (unsigned long )((void *)0)) {
        {
#line 1325
        tmp___29 = strcmp(rtype, "R_ALPHA_LITUSE");
        }
#line 1325
        if (tmp___29 == 0) {
#line 1325
          if (is_rela) {
            {
#line 1332
            if ((rels + i)->r_addend == 0UL) {
#line 1332
              goto case_0;
            }
#line 1333
            if ((rels + i)->r_addend == 1UL) {
#line 1333
              goto case_1;
            }
#line 1334
            if ((rels + i)->r_addend == 2UL) {
#line 1334
              goto case_2___0;
            }
#line 1335
            if ((rels + i)->r_addend == 3UL) {
#line 1335
              goto case_3___0;
            }
#line 1336
            if ((rels + i)->r_addend == 4UL) {
#line 1336
              goto case_4___0;
            }
#line 1337
            if ((rels + i)->r_addend == 5UL) {
#line 1337
              goto case_5;
            }
#line 1338
            if ((rels + i)->r_addend == 6UL) {
#line 1338
              goto case_6___0;
            }
#line 1339
            goto switch_default___0;
            case_0: /* CIL Label */ 
#line 1332
            rtype = "ADDR";
#line 1332
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 1333
            rtype = "BASE";
#line 1333
            goto switch_break___0;
            case_2___0: /* CIL Label */ 
#line 1334
            rtype = "BYTOFF";
#line 1334
            goto switch_break___0;
            case_3___0: /* CIL Label */ 
#line 1335
            rtype = "JSR";
#line 1335
            goto switch_break___0;
            case_4___0: /* CIL Label */ 
#line 1336
            rtype = "TLSGD";
#line 1336
            goto switch_break___0;
            case_5: /* CIL Label */ 
#line 1337
            rtype = "TLSLDM";
#line 1337
            goto switch_break___0;
            case_6___0: /* CIL Label */ 
#line 1338
            rtype = "JSRDIRECT";
#line 1338
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 1339
            rtype = (char const   *)((void *)0);
            switch_break___0: /* CIL Label */ ;
            }
#line 1341
            if (rtype) {
              {
#line 1342
              printf((char const   */* __restrict  */)" (%s)", rtype);
              }
            } else {
              {
#line 1345
              putchar(' ');
#line 1346
              tmp___15 = gettext("<unknown addend: %lx>");
#line 1346
              printf((char const   */* __restrict  */)tmp___15, (rels + i)->r_addend);
              }
            }
          } else {
#line 1325
            goto _L___8;
          }
        } else {
#line 1325
          goto _L___8;
        }
      } else {
#line 1325
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 1350
    if (symtab_index) {
#line 1352
      if ((unsigned long )symtab == (unsigned long )((void *)0)) {
        {
#line 1353
        tmp___16 = gettext(" bad symbol index: %08lx");
#line 1353
        printf((char const   */* __restrict  */)tmp___16, symtab_index);
        }
      } else
#line 1352
      if (symtab_index >= nsyms) {
        {
#line 1353
        tmp___16 = gettext(" bad symbol index: %08lx");
#line 1353
        printf((char const   */* __restrict  */)tmp___16, symtab_index);
        }
      } else {
        {
#line 1358
        psym = symtab + symtab_index;
#line 1360
        printf((char const   */* __restrict  */)" ");
        }
#line 1362
        if (((int )psym->st_info & 15) == 10) {
#line 1366
          if (is_32bit_elf) {
#line 1366
            tmp___17 = 8;
          } else {
#line 1366
            tmp___17 = 14;
          }
#line 1366
          width = (unsigned int )tmp___17;
#line 1378
          if ((unsigned long )strtab == (unsigned long )((void *)0)) {
#line 1381
            name___0 = "??";
          } else
#line 1378
          if (psym->st_name == 0UL) {
#line 1381
            name___0 = "??";
          } else
#line 1378
          if (psym->st_name >= strtablen) {
#line 1381
            name___0 = "??";
          } else {
#line 1383
            name___0 = (char const   *)(strtab + psym->st_name);
          }
          {
#line 1385
          len = print_symbol((int )width, name___0);
          }
#line 1386
          if (len <= width) {
#line 1386
            tmp___18 = (width + 1U) - len;
          } else {
#line 1386
            tmp___18 = 1U;
          }
          {
#line 1386
          printf((char const   */* __restrict  */)"()%-*s", tmp___18, " ");
          }
        } else {
          {
#line 1390
          print_vma(psym->st_value, (print_mode )6);
          }
#line 1392
          if (is_32bit_elf) {
#line 1392
            tmp___19 = "   ";
          } else {
#line 1392
            tmp___19 = " ";
          }
          {
#line 1392
          printf((char const   */* __restrict  */)tmp___19);
          }
        }
#line 1395
        if (psym->st_name == 0UL) {
#line 1397
          sec_name = "<null>";
#line 1400
          if (((int )psym->st_info & 15) == 3) {
#line 1402
            if (psym->st_shndx < elf_header.e_shnum) {
#line 1403
              if ((unsigned long )(section_headers + psym->st_shndx) == (unsigned long )((void *)0)) {
                {
#line 1403
                tmp___20 = gettext("<none>");
#line 1403
                sec_name = (char const   *)tmp___20;
                }
              } else {
#line 1403
                if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                  {
#line 1403
                  tmp___21 = gettext("<no-name>");
#line 1403
                  tmp___24 = tmp___21;
                  }
                } else {
#line 1403
                  if ((unsigned long )(section_headers + psym->st_shndx)->sh_name >= string_table_length) {
                    {
#line 1403
                    tmp___22 = gettext("<corrupt>");
#line 1403
                    tmp___23 = tmp___22;
                    }
                  } else {
#line 1403
                    tmp___23 = string_table + (section_headers + psym->st_shndx)->sh_name;
                  }
#line 1403
                  tmp___24 = tmp___23;
                }
#line 1403
                sec_name = (char const   *)tmp___24;
              }
            } else
#line 1405
            if (psym->st_shndx == 4294967281U) {
#line 1406
              sec_name = "ABS";
            } else
#line 1407
            if (psym->st_shndx == 4294967282U) {
#line 1408
              sec_name = "COMMON";
            } else
#line 1409
            if ((int )elf_header.e_machine == 8) {
#line 1409
              if (psym->st_shndx == 4294967043U) {
#line 1413
                sec_name = "SCOMMON";
              } else {
#line 1409
                goto _L___5;
              }
            } else
            _L___5: /* CIL Label */ 
#line 1409
            if ((int )elf_header.e_machine == 140) {
#line 1409
              if (psym->st_shndx == 4294967040U) {
#line 1413
                sec_name = "SCOMMON";
              } else {
#line 1409
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 1414
            if ((int )elf_header.e_machine == 8) {
#line 1414
              if (psym->st_shndx == 4294967044U) {
#line 1416
                sec_name = "SUNDEF";
              } else {
#line 1414
                goto _L___3;
              }
            } else
            _L___3: /* CIL Label */ 
#line 1417
            if ((int )elf_header.e_machine == 62) {
#line 1417
              goto _L___2;
            } else
#line 1417
            if ((int )elf_header.e_machine == 180) {
#line 1417
              goto _L___2;
            } else
#line 1417
            if ((int )elf_header.e_machine == 181) {
              _L___2: /* CIL Label */ 
#line 1417
              if (psym->st_shndx == 4294967042U) {
#line 1421
                sec_name = "LARGE_COMMON";
              } else {
#line 1417
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 1422
            if ((int )elf_header.e_machine == 50) {
#line 1422
              if ((int )elf_header.e_ident[7] == 1) {
#line 1422
                if (psym->st_shndx == 4294967040U) {
#line 1425
                  sec_name = "ANSI_COM";
                } else {
#line 1422
                  goto _L___0;
                }
              } else {
#line 1422
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 1426
              tmp___25 = is_ia64_vms();
              }
#line 1426
              if (tmp___25) {
#line 1426
                if (psym->st_shndx == 4294967072U) {
#line 1428
                  sec_name = "VMS_SYMVEC";
                } else {
                  {
#line 1431
                  sprintf((char */* __restrict  */)(name_buf), (char const   */* __restrict  */)"<section 0x%x>",
                          psym->st_shndx);
#line 1433
                  sec_name = (char const   *)(name_buf);
                  }
                }
              } else {
                {
#line 1431
                sprintf((char */* __restrict  */)(name_buf), (char const   */* __restrict  */)"<section 0x%x>",
                        psym->st_shndx);
#line 1433
                sec_name = (char const   *)(name_buf);
                }
              }
            }
          }
          {
#line 1436
          print_symbol(22, sec_name);
          }
        } else
#line 1438
        if ((unsigned long )strtab == (unsigned long )((void *)0)) {
          {
#line 1439
          tmp___26 = gettext("<string table index: %3ld>");
#line 1439
          printf((char const   */* __restrict  */)tmp___26, psym->st_name);
          }
        } else
#line 1440
        if (psym->st_name >= strtablen) {
          {
#line 1441
          tmp___27 = gettext("<corrupt string table index: %3ld>");
#line 1441
          printf((char const   */* __restrict  */)tmp___27, psym->st_name);
          }
        } else {
          {
#line 1443
          print_symbol(22, (char const   *)(strtab + psym->st_name));
          }
        }
#line 1445
        if (is_rela) {
#line 1447
          off = (bfd_signed_vma )(rels + i)->r_addend;
#line 1449
          if (off < 0L) {
            {
#line 1450
            printf((char const   */* __restrict  */)" - %lx", - off);
            }
          } else {
            {
#line 1452
            printf((char const   */* __restrict  */)" + %lx", off);
            }
          }
        }
      }
    } else
#line 1456
    if (is_rela) {
#line 1458
      off___0 = (bfd_signed_vma )(rels + i)->r_addend;
#line 1460
      if (is_32bit_elf) {
#line 1460
        tmp___28 = 12;
      } else {
#line 1460
        tmp___28 = 20;
      }
      {
#line 1460
      printf((char const   */* __restrict  */)"%*c", tmp___28, ' ');
      }
#line 1461
      if (off___0 < 0L) {
        {
#line 1462
        printf((char const   */* __restrict  */)"-%lx", - off___0);
        }
      } else {
        {
#line 1464
        printf((char const   */* __restrict  */)"%lx", off___0);
        }
      }
    }
#line 1467
    if ((int )elf_header.e_machine == 43) {
#line 1467
      if ((unsigned long )rtype != (unsigned long )((void *)0)) {
        {
#line 1467
        tmp___30 = strcmp(rtype, "R_SPARC_OLO10");
        }
#line 1467
        if (tmp___30 == 0) {
          {
#line 1470
          printf((char const   */* __restrict  */)" + %lx", (unsigned long )(((bfd_signed_vma )((inf & 4294967295UL) >> 8) ^ 8388608L) - 8388608L));
          }
        }
      }
    }
    {
#line 1472
    putchar('\n');
    }
#line 1475
    if (! is_32bit_elf) {
#line 1475
      if ((int )elf_header.e_machine == 8) {
        {
#line 1477
        type2 = (inf >> 8) & 255UL;
#line 1478
        type3 = (inf >> 16) & 255UL;
#line 1479
        tmp___31 = elf_mips_reloc_type(type2);
#line 1479
        rtype2 = tmp___31;
#line 1480
        tmp___32 = elf_mips_reloc_type(type3);
#line 1480
        rtype3 = tmp___32;
#line 1482
        printf((char const   */* __restrict  */)"                    Type2: ");
        }
#line 1484
        if ((unsigned long )rtype2 == (unsigned long )((void *)0)) {
          {
#line 1485
          tmp___33 = gettext("unrecognized: %-7lx");
#line 1485
          printf((char const   */* __restrict  */)tmp___33, type2 & 4294967295UL);
          }
        } else {
          {
#line 1488
          printf((char const   */* __restrict  */)"%-17.17s", rtype2);
          }
        }
        {
#line 1490
        printf((char const   */* __restrict  */)"\n                    Type3: ");
        }
#line 1492
        if ((unsigned long )rtype3 == (unsigned long )((void *)0)) {
          {
#line 1493
          tmp___34 = gettext("unrecognized: %-7lx");
#line 1493
          printf((char const   */* __restrict  */)tmp___34, type3 & 4294967295UL);
          }
        } else {
          {
#line 1496
          printf((char const   */* __restrict  */)"%-17.17s", rtype3);
          }
        }
        {
#line 1498
        putchar('\n');
        }
      }
    }
#line 981
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1503
  free((void *)rels);
  }
#line 1504
  return;
}
}
#line 1506 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_mips_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1511
  if (type == 1879048193UL) {
#line 1511
    goto case_1879048193;
  }
#line 1512
  if (type == 1879048194UL) {
#line 1512
    goto case_1879048194;
  }
#line 1513
  if (type == 1879048195UL) {
#line 1513
    goto case_1879048195;
  }
#line 1514
  if (type == 1879048196UL) {
#line 1514
    goto case_1879048196;
  }
#line 1515
  if (type == 1879048197UL) {
#line 1515
    goto case_1879048197;
  }
#line 1516
  if (type == 1879048198UL) {
#line 1516
    goto case_1879048198;
  }
#line 1517
  if (type == 1879048199UL) {
#line 1517
    goto case_1879048199;
  }
#line 1518
  if (type == 1879048200UL) {
#line 1518
    goto case_1879048200;
  }
#line 1519
  if (type == 1879048201UL) {
#line 1519
    goto case_1879048201;
  }
#line 1520
  if (type == 1879048202UL) {
#line 1520
    goto case_1879048202;
  }
#line 1521
  if (type == 1879048203UL) {
#line 1521
    goto case_1879048203;
  }
#line 1522
  if (type == 1879048208UL) {
#line 1522
    goto case_1879048208;
  }
#line 1523
  if (type == 1879048209UL) {
#line 1523
    goto case_1879048209;
  }
#line 1524
  if (type == 1879048210UL) {
#line 1524
    goto case_1879048210;
  }
#line 1525
  if (type == 1879048211UL) {
#line 1525
    goto case_1879048211;
  }
#line 1526
  if (type == 1879048212UL) {
#line 1526
    goto case_1879048212;
  }
#line 1527
  if (type == 1879048214UL) {
#line 1527
    goto case_1879048214;
  }
#line 1528
  if (type == 1879048215UL) {
#line 1528
    goto case_1879048215;
  }
#line 1529
  if (type == 1879048216UL) {
#line 1529
    goto case_1879048216;
  }
#line 1530
  if (type == 1879048217UL) {
#line 1530
    goto case_1879048217;
  }
#line 1531
  if (type == 1879048218UL) {
#line 1531
    goto case_1879048218;
  }
#line 1532
  if (type == 1879048219UL) {
#line 1532
    goto case_1879048219;
  }
#line 1533
  if (type == 1879048220UL) {
#line 1533
    goto case_1879048220;
  }
#line 1534
  if (type == 1879048221UL) {
#line 1534
    goto case_1879048221;
  }
#line 1535
  if (type == 1879048222UL) {
#line 1535
    goto case_1879048222;
  }
#line 1536
  if (type == 1879048224UL) {
#line 1536
    goto case_1879048224;
  }
#line 1537
  if (type == 1879048225UL) {
#line 1537
    goto case_1879048225;
  }
#line 1538
  if (type == 1879048226UL) {
#line 1538
    goto case_1879048226;
  }
#line 1539
  if (type == 1879048227UL) {
#line 1539
    goto case_1879048227;
  }
#line 1540
  if (type == 1879048228UL) {
#line 1540
    goto case_1879048228;
  }
#line 1541
  if (type == 1879048229UL) {
#line 1541
    goto case_1879048229;
  }
#line 1542
  if (type == 1879048230UL) {
#line 1542
    goto case_1879048230;
  }
#line 1543
  if (type == 1879048231UL) {
#line 1543
    goto case_1879048231;
  }
#line 1544
  if (type == 1879048232UL) {
#line 1544
    goto case_1879048232;
  }
#line 1545
  if (type == 1879048233UL) {
#line 1545
    goto case_1879048233;
  }
#line 1546
  if (type == 1879048234UL) {
#line 1546
    goto case_1879048234;
  }
#line 1547
  if (type == 1879048235UL) {
#line 1547
    goto case_1879048235;
  }
#line 1548
  if (type == 1879048236UL) {
#line 1548
    goto case_1879048236;
  }
#line 1549
  if (type == 1879048237UL) {
#line 1549
    goto case_1879048237;
  }
#line 1550
  if (type == 1879048238UL) {
#line 1550
    goto case_1879048238;
  }
#line 1551
  if (type == 1879048239UL) {
#line 1551
    goto case_1879048239;
  }
#line 1552
  if (type == 1879048240UL) {
#line 1552
    goto case_1879048240;
  }
#line 1553
  if (type == 1879048241UL) {
#line 1553
    goto case_1879048241;
  }
#line 1554
  if (type == 1879048242UL) {
#line 1554
    goto case_1879048242;
  }
#line 1555
  if (type == 1879048244UL) {
#line 1555
    goto case_1879048244;
  }
#line 1556
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1511
  return ("MIPS_RLD_VERSION");
  case_1879048194: /* CIL Label */ 
#line 1512
  return ("MIPS_TIME_STAMP");
  case_1879048195: /* CIL Label */ 
#line 1513
  return ("MIPS_ICHECKSUM");
  case_1879048196: /* CIL Label */ 
#line 1514
  return ("MIPS_IVERSION");
  case_1879048197: /* CIL Label */ 
#line 1515
  return ("MIPS_FLAGS");
  case_1879048198: /* CIL Label */ 
#line 1516
  return ("MIPS_BASE_ADDRESS");
  case_1879048199: /* CIL Label */ 
#line 1517
  return ("MIPS_MSYM");
  case_1879048200: /* CIL Label */ 
#line 1518
  return ("MIPS_CONFLICT");
  case_1879048201: /* CIL Label */ 
#line 1519
  return ("MIPS_LIBLIST");
  case_1879048202: /* CIL Label */ 
#line 1520
  return ("MIPS_LOCAL_GOTNO");
  case_1879048203: /* CIL Label */ 
#line 1521
  return ("MIPS_CONFLICTNO");
  case_1879048208: /* CIL Label */ 
#line 1522
  return ("MIPS_LIBLISTNO");
  case_1879048209: /* CIL Label */ 
#line 1523
  return ("MIPS_SYMTABNO");
  case_1879048210: /* CIL Label */ 
#line 1524
  return ("MIPS_UNREFEXTNO");
  case_1879048211: /* CIL Label */ 
#line 1525
  return ("MIPS_GOTSYM");
  case_1879048212: /* CIL Label */ 
#line 1526
  return ("MIPS_HIPAGENO");
  case_1879048214: /* CIL Label */ 
#line 1527
  return ("MIPS_RLD_MAP");
  case_1879048215: /* CIL Label */ 
#line 1528
  return ("MIPS_DELTA_CLASS");
  case_1879048216: /* CIL Label */ 
#line 1529
  return ("MIPS_DELTA_CLASS_NO");
  case_1879048217: /* CIL Label */ 
#line 1530
  return ("MIPS_DELTA_INSTANCE");
  case_1879048218: /* CIL Label */ 
#line 1531
  return ("MIPS_DELTA_INSTANCE_NO");
  case_1879048219: /* CIL Label */ 
#line 1532
  return ("MIPS_DELTA_RELOC");
  case_1879048220: /* CIL Label */ 
#line 1533
  return ("MIPS_DELTA_RELOC_NO");
  case_1879048221: /* CIL Label */ 
#line 1534
  return ("MIPS_DELTA_SYM");
  case_1879048222: /* CIL Label */ 
#line 1535
  return ("MIPS_DELTA_SYM_NO");
  case_1879048224: /* CIL Label */ 
#line 1536
  return ("MIPS_DELTA_CLASSSYM");
  case_1879048225: /* CIL Label */ 
#line 1537
  return ("MIPS_DELTA_CLASSSYM_NO");
  case_1879048226: /* CIL Label */ 
#line 1538
  return ("MIPS_CXX_FLAGS");
  case_1879048227: /* CIL Label */ 
#line 1539
  return ("MIPS_PIXIE_INIT");
  case_1879048228: /* CIL Label */ 
#line 1540
  return ("MIPS_SYMBOL_LIB");
  case_1879048229: /* CIL Label */ 
#line 1541
  return ("MIPS_LOCALPAGE_GOTIDX");
  case_1879048230: /* CIL Label */ 
#line 1542
  return ("MIPS_LOCAL_GOTIDX");
  case_1879048231: /* CIL Label */ 
#line 1543
  return ("MIPS_HIDDEN_GOTIDX");
  case_1879048232: /* CIL Label */ 
#line 1544
  return ("MIPS_PROTECTED_GOTIDX");
  case_1879048233: /* CIL Label */ 
#line 1545
  return ("MIPS_OPTIONS");
  case_1879048234: /* CIL Label */ 
#line 1546
  return ("MIPS_INTERFACE");
  case_1879048235: /* CIL Label */ 
#line 1547
  return ("MIPS_DYNSTR_ALIGN");
  case_1879048236: /* CIL Label */ 
#line 1548
  return ("MIPS_INTERFACE_SIZE");
  case_1879048237: /* CIL Label */ 
#line 1549
  return ("MIPS_RLD_TEXT_RESOLVE_ADDR");
  case_1879048238: /* CIL Label */ 
#line 1550
  return ("MIPS_PERF_SUFFIX");
  case_1879048239: /* CIL Label */ 
#line 1551
  return ("MIPS_COMPACT_SIZE");
  case_1879048240: /* CIL Label */ 
#line 1552
  return ("MIPS_GP_VALUE");
  case_1879048241: /* CIL Label */ 
#line 1553
  return ("MIPS_AUX_DYNAMIC");
  case_1879048242: /* CIL Label */ 
#line 1554
  return ("MIPS_PLTGOT");
  case_1879048244: /* CIL Label */ 
#line 1555
  return ("MIPS_RWPLT");
  switch_default: /* CIL Label */ 
#line 1557
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1561 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_sparc64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1566
  if (type == 1879048193UL) {
#line 1566
    goto case_1879048193;
  }
#line 1567
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1566
  return ("SPARC_REGISTER");
  switch_default: /* CIL Label */ 
#line 1568
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1572 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ppc_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1577
  if (type == 1879048192UL) {
#line 1577
    goto case_1879048192;
  }
#line 1578
  if (type == 1879048193UL) {
#line 1578
    goto case_1879048193;
  }
#line 1579
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1577
  return ("PPC_GOT");
  case_1879048193: /* CIL Label */ 
#line 1578
  return ("PPC_OPT");
  switch_default: /* CIL Label */ 
#line 1580
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ppc64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1589
  if (type == 1879048192UL) {
#line 1589
    goto case_1879048192;
  }
#line 1590
  if (type == 1879048193UL) {
#line 1590
    goto case_1879048193;
  }
#line 1591
  if (type == 1879048194UL) {
#line 1591
    goto case_1879048194;
  }
#line 1592
  if (type == 1879048195UL) {
#line 1592
    goto case_1879048195;
  }
#line 1593
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1589
  return ("PPC64_GLINK");
  case_1879048193: /* CIL Label */ 
#line 1590
  return ("PPC64_OPD");
  case_1879048194: /* CIL Label */ 
#line 1591
  return ("PPC64_OPDSZ");
  case_1879048195: /* CIL Label */ 
#line 1592
  return ("PPC64_OPT");
  switch_default: /* CIL Label */ 
#line 1594
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1598 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_parisc_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1603
  if (type == 1610612736UL) {
#line 1603
    goto case_1610612736;
  }
#line 1604
  if (type == 1610612737UL) {
#line 1604
    goto case_1610612737;
  }
#line 1605
  if (type == 1610612738UL) {
#line 1605
    goto case_1610612738;
  }
#line 1606
  if (type == 1610612739UL) {
#line 1606
    goto case_1610612739;
  }
#line 1607
  if (type == 1610612740UL) {
#line 1607
    goto case_1610612740;
  }
#line 1608
  if (type == 1610612741UL) {
#line 1608
    goto case_1610612741;
  }
#line 1609
  if (type == 1610612742UL) {
#line 1609
    goto case_1610612742;
  }
#line 1610
  if (type == 1610612743UL) {
#line 1610
    goto case_1610612743;
  }
#line 1611
  if (type == 1610612744UL) {
#line 1611
    goto case_1610612744;
  }
#line 1612
  if (type == 1610612745UL) {
#line 1612
    goto case_1610612745;
  }
#line 1613
  if (type == 1610612746UL) {
#line 1613
    goto case_1610612746;
  }
#line 1614
  if (type == 1610612747UL) {
#line 1614
    goto case_1610612747;
  }
#line 1615
  if (type == 1610612748UL) {
#line 1615
    goto case_1610612748;
  }
#line 1616
  if (type == 1610612749UL) {
#line 1616
    goto case_1610612749;
  }
#line 1617
  if (type == 1610612750UL) {
#line 1617
    goto case_1610612750;
  }
#line 1618
  if (type == 1610612751UL) {
#line 1618
    goto case_1610612751;
  }
#line 1619
  if (type == 1610612752UL) {
#line 1619
    goto case_1610612752;
  }
#line 1620
  if (type == 1610612753UL) {
#line 1620
    goto case_1610612753;
  }
#line 1621
  if (type == 1610612754UL) {
#line 1621
    goto case_1610612754;
  }
#line 1622
  if (type == 1610612755UL) {
#line 1622
    goto case_1610612755;
  }
#line 1623
  if (type == 1610612756UL) {
#line 1623
    goto case_1610612756;
  }
#line 1624
  if (type == 1610612757UL) {
#line 1624
    goto case_1610612757;
  }
#line 1625
  if (type == 1610612758UL) {
#line 1625
    goto case_1610612758;
  }
#line 1626
  if (type == 1610612759UL) {
#line 1626
    goto case_1610612759;
  }
#line 1627
  goto switch_default;
  case_1610612736: /* CIL Label */ 
#line 1603
  return ("HP_LOAD_MAP");
  case_1610612737: /* CIL Label */ 
#line 1604
  return ("HP_DLD_FLAGS");
  case_1610612738: /* CIL Label */ 
#line 1605
  return ("HP_DLD_HOOK");
  case_1610612739: /* CIL Label */ 
#line 1606
  return ("HP_UX10_INIT");
  case_1610612740: /* CIL Label */ 
#line 1607
  return ("HP_UX10_INITSZ");
  case_1610612741: /* CIL Label */ 
#line 1608
  return ("HP_PREINIT");
  case_1610612742: /* CIL Label */ 
#line 1609
  return ("HP_PREINITSZ");
  case_1610612743: /* CIL Label */ 
#line 1610
  return ("HP_NEEDED");
  case_1610612744: /* CIL Label */ 
#line 1611
  return ("HP_TIME_STAMP");
  case_1610612745: /* CIL Label */ 
#line 1612
  return ("HP_CHECKSUM");
  case_1610612746: /* CIL Label */ 
#line 1613
  return ("HP_GST_SIZE");
  case_1610612747: /* CIL Label */ 
#line 1614
  return ("HP_GST_VERSION");
  case_1610612748: /* CIL Label */ 
#line 1615
  return ("HP_GST_HASHVAL");
  case_1610612749: /* CIL Label */ 
#line 1616
  return ("HP_GST_EPLTREL");
  case_1610612750: /* CIL Label */ 
#line 1617
  return ("HP_GST_EPLTRELSZ");
  case_1610612751: /* CIL Label */ 
#line 1618
  return ("HP_FILTERED");
  case_1610612752: /* CIL Label */ 
#line 1619
  return ("HP_FILTER_TLS");
  case_1610612753: /* CIL Label */ 
#line 1620
  return ("HP_COMPAT_FILTERED");
  case_1610612754: /* CIL Label */ 
#line 1621
  return ("HP_LAZYLOAD");
  case_1610612755: /* CIL Label */ 
#line 1622
  return ("HP_BIND_NOW_COUNT");
  case_1610612756: /* CIL Label */ 
#line 1623
  return ("PLT");
  case_1610612757: /* CIL Label */ 
#line 1624
  return ("PLT_SIZE");
  case_1610612758: /* CIL Label */ 
#line 1625
  return ("DLT");
  case_1610612759: /* CIL Label */ 
#line 1626
  return ("DLT_SIZE");
  switch_default: /* CIL Label */ 
#line 1628
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1632 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ia64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1637
  if (type == 1879048192UL) {
#line 1637
    goto case_1879048192;
  }
#line 1638
  if (type == 1610612749UL) {
#line 1638
    goto case_1610612749;
  }
#line 1639
  if (type == 1610612751UL) {
#line 1639
    goto case_1610612751;
  }
#line 1640
  if (type == 1610612757UL) {
#line 1640
    goto case_1610612757;
  }
#line 1641
  if (type == 1610612759UL) {
#line 1641
    goto case_1610612759;
  }
#line 1642
  if (type == 1610612761UL) {
#line 1642
    goto case_1610612761;
  }
#line 1643
  if (type == 1610612765UL) {
#line 1643
    goto case_1610612765;
  }
#line 1644
  if (type == 1610612767UL) {
#line 1644
    goto case_1610612767;
  }
#line 1645
  if (type == 1610612769UL) {
#line 1645
    goto case_1610612769;
  }
#line 1646
  if (type == 1610612771UL) {
#line 1646
    goto case_1610612771;
  }
#line 1647
  if (type == 1610612773UL) {
#line 1647
    goto case_1610612773;
  }
#line 1648
  if (type == 1610612775UL) {
#line 1648
    goto case_1610612775;
  }
#line 1649
  if (type == 1610612779UL) {
#line 1649
    goto case_1610612779;
  }
#line 1650
  if (type == 1610612781UL) {
#line 1650
    goto case_1610612781;
  }
#line 1651
  if (type == 1610612783UL) {
#line 1651
    goto case_1610612783;
  }
#line 1652
  if (type == 1610612785UL) {
#line 1652
    goto case_1610612785;
  }
#line 1653
  if (type == 1610612787UL) {
#line 1653
    goto case_1610612787;
  }
#line 1654
  if (type == 1610612789UL) {
#line 1654
    goto case_1610612789;
  }
#line 1655
  if (type == 1610612791UL) {
#line 1655
    goto case_1610612791;
  }
#line 1656
  if (type == 1610612793UL) {
#line 1656
    goto case_1610612793;
  }
#line 1657
  if (type == 1610612795UL) {
#line 1657
    goto case_1610612795;
  }
#line 1658
  if (type == 1610612797UL) {
#line 1658
    goto case_1610612797;
  }
#line 1659
  if (type == 1610612799UL) {
#line 1659
    goto case_1610612799;
  }
#line 1660
  if (type == 1610612801UL) {
#line 1660
    goto case_1610612801;
  }
#line 1661
  if (type == 1610612803UL) {
#line 1661
    goto case_1610612803;
  }
#line 1662
  if (type == 1610612805UL) {
#line 1662
    goto case_1610612805;
  }
#line 1663
  if (type == 1610612807UL) {
#line 1663
    goto case_1610612807;
  }
#line 1664
  if (type == 1610612809UL) {
#line 1664
    goto case_1610612809;
  }
#line 1665
  if (type == 1610612811UL) {
#line 1665
    goto case_1610612811;
  }
#line 1666
  if (type == 1610612813UL) {
#line 1666
    goto case_1610612813;
  }
#line 1667
  if (type == 1610612815UL) {
#line 1667
    goto case_1610612815;
  }
#line 1668
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1637
  return ("IA_64_PLT_RESERVE");
  case_1610612749: /* CIL Label */ 
#line 1638
  return ("VMS_SUBTYPE");
  case_1610612751: /* CIL Label */ 
#line 1639
  return ("VMS_IMGIOCNT");
  case_1610612757: /* CIL Label */ 
#line 1640
  return ("VMS_LNKFLAGS");
  case_1610612759: /* CIL Label */ 
#line 1641
  return ("VMS_VIR_MEM_BLK_SIZ");
  case_1610612761: /* CIL Label */ 
#line 1642
  return ("VMS_IDENT");
  case_1610612765: /* CIL Label */ 
#line 1643
  return ("VMS_NEEDED_IDENT");
  case_1610612767: /* CIL Label */ 
#line 1644
  return ("VMS_IMG_RELA_CNT");
  case_1610612769: /* CIL Label */ 
#line 1645
  return ("VMS_SEG_RELA_CNT");
  case_1610612771: /* CIL Label */ 
#line 1646
  return ("VMS_FIXUP_RELA_CNT");
  case_1610612773: /* CIL Label */ 
#line 1647
  return ("VMS_FIXUP_NEEDED");
  case_1610612775: /* CIL Label */ 
#line 1648
  return ("VMS_SYMVEC_CNT");
  case_1610612779: /* CIL Label */ 
#line 1649
  return ("VMS_XLATED");
  case_1610612781: /* CIL Label */ 
#line 1650
  return ("VMS_STACKSIZE");
  case_1610612783: /* CIL Label */ 
#line 1651
  return ("VMS_UNWINDSZ");
  case_1610612785: /* CIL Label */ 
#line 1652
  return ("VMS_UNWIND_CODSEG");
  case_1610612787: /* CIL Label */ 
#line 1653
  return ("VMS_UNWIND_INFOSEG");
  case_1610612789: /* CIL Label */ 
#line 1654
  return ("VMS_LINKTIME");
  case_1610612791: /* CIL Label */ 
#line 1655
  return ("VMS_SEG_NO");
  case_1610612793: /* CIL Label */ 
#line 1656
  return ("VMS_SYMVEC_OFFSET");
  case_1610612795: /* CIL Label */ 
#line 1657
  return ("VMS_SYMVEC_SEG");
  case_1610612797: /* CIL Label */ 
#line 1658
  return ("VMS_UNWIND_OFFSET");
  case_1610612799: /* CIL Label */ 
#line 1659
  return ("VMS_UNWIND_SEG");
  case_1610612801: /* CIL Label */ 
#line 1660
  return ("VMS_STRTAB_OFFSET");
  case_1610612803: /* CIL Label */ 
#line 1661
  return ("VMS_SYSVER_OFFSET");
  case_1610612805: /* CIL Label */ 
#line 1662
  return ("VMS_IMG_RELA_OFF");
  case_1610612807: /* CIL Label */ 
#line 1663
  return ("VMS_SEG_RELA_OFF");
  case_1610612809: /* CIL Label */ 
#line 1664
  return ("VMS_FIXUP_RELA_OFF");
  case_1610612811: /* CIL Label */ 
#line 1665
  return ("VMS_PLTGOT_OFFSET");
  case_1610612813: /* CIL Label */ 
#line 1666
  return ("VMS_PLTGOT_SEG");
  case_1610612815: /* CIL Label */ 
#line 1667
  return ("VMS_FPMODE");
  switch_default: /* CIL Label */ 
#line 1669
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1673 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_alpha_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1678
  if (type == 1879048192UL) {
#line 1678
    goto case_1879048192;
  }
#line 1679
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1678
  return ("ALPHA_PLTRO");
  switch_default: /* CIL Label */ 
#line 1680
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1684 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_score_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1689
  if (type == 1879048193UL) {
#line 1689
    goto case_1879048193;
  }
#line 1690
  if (type == 1879048194UL) {
#line 1690
    goto case_1879048194;
  }
#line 1691
  if (type == 1879048195UL) {
#line 1691
    goto case_1879048195;
  }
#line 1692
  if (type == 1879048196UL) {
#line 1692
    goto case_1879048196;
  }
#line 1693
  if (type == 1879048197UL) {
#line 1693
    goto case_1879048197;
  }
#line 1694
  if (type == 1879048198UL) {
#line 1694
    goto case_1879048198;
  }
#line 1695
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1689
  return ("SCORE_BASE_ADDRESS");
  case_1879048194: /* CIL Label */ 
#line 1690
  return ("SCORE_LOCAL_GOTNO");
  case_1879048195: /* CIL Label */ 
#line 1691
  return ("SCORE_SYMTABNO");
  case_1879048196: /* CIL Label */ 
#line 1692
  return ("SCORE_GOTSYM");
  case_1879048197: /* CIL Label */ 
#line 1693
  return ("SCORE_UNREFEXTNO");
  case_1879048198: /* CIL Label */ 
#line 1694
  return ("SCORE_HIPAGENO");
  switch_default: /* CIL Label */ 
#line 1696
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1700 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_tic6x_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1705
  if (type == 1610612749UL) {
#line 1705
    goto case_1610612749;
  }
#line 1706
  if (type == 1610612751UL) {
#line 1706
    goto case_1610612751;
  }
#line 1707
  if (type == 1879048192UL) {
#line 1707
    goto case_1879048192;
  }
#line 1708
  if (type == 1879048193UL) {
#line 1708
    goto case_1879048193;
  }
#line 1709
  if (type == 1879048194UL) {
#line 1709
    goto case_1879048194;
  }
#line 1710
  if (type == 1879048195UL) {
#line 1710
    goto case_1879048195;
  }
#line 1711
  goto switch_default;
  case_1610612749: /* CIL Label */ 
#line 1705
  return ("C6000_GSYM_OFFSET");
  case_1610612751: /* CIL Label */ 
#line 1706
  return ("C6000_GSTR_OFFSET");
  case_1879048192: /* CIL Label */ 
#line 1707
  return ("C6000_DSBT_BASE");
  case_1879048193: /* CIL Label */ 
#line 1708
  return ("C6000_DSBT_SIZE");
  case_1879048194: /* CIL Label */ 
#line 1709
  return ("C6000_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 1710
  return ("C6000_DSBT_INDEX");
  switch_default: /* CIL Label */ 
#line 1712
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_nios2_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1721
  if (type == 1879048194UL) {
#line 1721
    goto case_1879048194;
  }
#line 1722
  goto switch_default;
  case_1879048194: /* CIL Label */ 
#line 1721
  return ("NIOS2_GP");
  switch_default: /* CIL Label */ 
#line 1723
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1730 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff[64]  ;
#line 1727 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_dynamic_type(unsigned long type ) 
{ 
  char const   *result ;
  char *tmp___0 ;
  char const   *result___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1734
  if (type == 0UL) {
#line 1734
    goto case_0;
  }
#line 1735
  if (type == 1UL) {
#line 1735
    goto case_1;
  }
#line 1736
  if (type == 2UL) {
#line 1736
    goto case_2;
  }
#line 1737
  if (type == 3UL) {
#line 1737
    goto case_3;
  }
#line 1738
  if (type == 4UL) {
#line 1738
    goto case_4;
  }
#line 1739
  if (type == 5UL) {
#line 1739
    goto case_5;
  }
#line 1740
  if (type == 6UL) {
#line 1740
    goto case_6;
  }
#line 1741
  if (type == 7UL) {
#line 1741
    goto case_7;
  }
#line 1742
  if (type == 8UL) {
#line 1742
    goto case_8;
  }
#line 1743
  if (type == 9UL) {
#line 1743
    goto case_9;
  }
#line 1744
  if (type == 10UL) {
#line 1744
    goto case_10;
  }
#line 1745
  if (type == 11UL) {
#line 1745
    goto case_11;
  }
#line 1746
  if (type == 12UL) {
#line 1746
    goto case_12;
  }
#line 1747
  if (type == 13UL) {
#line 1747
    goto case_13;
  }
#line 1748
  if (type == 14UL) {
#line 1748
    goto case_14;
  }
#line 1749
  if (type == 15UL) {
#line 1749
    goto case_15;
  }
#line 1750
  if (type == 16UL) {
#line 1750
    goto case_16;
  }
#line 1751
  if (type == 17UL) {
#line 1751
    goto case_17;
  }
#line 1752
  if (type == 18UL) {
#line 1752
    goto case_18;
  }
#line 1753
  if (type == 19UL) {
#line 1753
    goto case_19;
  }
#line 1754
  if (type == 20UL) {
#line 1754
    goto case_20;
  }
#line 1755
  if (type == 21UL) {
#line 1755
    goto case_21;
  }
#line 1756
  if (type == 22UL) {
#line 1756
    goto case_22;
  }
#line 1757
  if (type == 23UL) {
#line 1757
    goto case_23;
  }
#line 1758
  if (type == 24UL) {
#line 1758
    goto case_24;
  }
#line 1759
  if (type == 25UL) {
#line 1759
    goto case_25;
  }
#line 1760
  if (type == 26UL) {
#line 1760
    goto case_26;
  }
#line 1761
  if (type == 27UL) {
#line 1761
    goto case_27;
  }
#line 1762
  if (type == 28UL) {
#line 1762
    goto case_28;
  }
#line 1763
  if (type == 29UL) {
#line 1763
    goto case_29;
  }
#line 1764
  if (type == 30UL) {
#line 1764
    goto case_30;
  }
#line 1766
  if (type == 32UL) {
#line 1766
    goto case_32;
  }
#line 1767
  if (type == 33UL) {
#line 1767
    goto case_33;
  }
#line 1769
  if (type == 1879047672UL) {
#line 1769
    goto case_1879047672;
  }
#line 1770
  if (type == 1879047673UL) {
#line 1770
    goto case_1879047673;
  }
#line 1771
  if (type == 1879047674UL) {
#line 1771
    goto case_1879047674;
  }
#line 1772
  if (type == 1879047675UL) {
#line 1772
    goto case_1879047675;
  }
#line 1773
  if (type == 1879047676UL) {
#line 1773
    goto case_1879047676;
  }
#line 1774
  if (type == 1879047677UL) {
#line 1774
    goto case_1879047677;
  }
#line 1775
  if (type == 1879047678UL) {
#line 1775
    goto case_1879047678;
  }
#line 1776
  if (type == 1879047679UL) {
#line 1776
    goto case_1879047679;
  }
#line 1778
  if (type == 1879047680UL) {
#line 1778
    goto case_1879047680;
  }
#line 1779
  if (type == 1879047930UL) {
#line 1779
    goto case_1879047930;
  }
#line 1780
  if (type == 1879047931UL) {
#line 1780
    goto case_1879047931;
  }
#line 1781
  if (type == 1879047932UL) {
#line 1781
    goto case_1879047932;
  }
#line 1782
  if (type == 1879047933UL) {
#line 1782
    goto case_1879047933;
  }
#line 1783
  if (type == 1879047934UL) {
#line 1783
    goto case_1879047934;
  }
#line 1784
  if (type == 1879047935UL) {
#line 1784
    goto case_1879047935;
  }
#line 1786
  if (type == 1879048176UL) {
#line 1786
    goto case_1879048176;
  }
#line 1788
  if (type == 1879047927UL) {
#line 1788
    goto case_1879047927;
  }
#line 1789
  if (type == 1879047926UL) {
#line 1789
    goto case_1879047926;
  }
#line 1790
  if (type == 1879048185UL) {
#line 1790
    goto case_1879048185;
  }
#line 1791
  if (type == 1879048186UL) {
#line 1791
    goto case_1879048186;
  }
#line 1792
  if (type == 1879048187UL) {
#line 1792
    goto case_1879048187;
  }
#line 1793
  if (type == 1879048188UL) {
#line 1793
    goto case_1879048188;
  }
#line 1794
  if (type == 1879048189UL) {
#line 1794
    goto case_1879048189;
  }
#line 1795
  if (type == 1879048190UL) {
#line 1795
    goto case_1879048190;
  }
#line 1796
  if (type == 1879048191UL) {
#line 1796
    goto case_1879048191;
  }
#line 1798
  if (type == 2147483645UL) {
#line 1798
    goto case_2147483645;
  }
#line 1799
  if (type == 2147483646UL) {
#line 1799
    goto case_2147483646;
  }
#line 1800
  if (type == 2147483647UL) {
#line 1800
    goto case_2147483647;
  }
#line 1802
  if (type == 1879047669UL) {
#line 1802
    goto case_1879047669;
  }
#line 1803
  if (type == 1879047928UL) {
#line 1803
    goto case_1879047928;
  }
#line 1804
  if (type == 1879047670UL) {
#line 1804
    goto case_1879047670;
  }
#line 1805
  if (type == 1879047929UL) {
#line 1805
    goto case_1879047929;
  }
#line 1806
  if (type == 1879047671UL) {
#line 1806
    goto case_1879047671;
  }
#line 1807
  if (type == 1879047925UL) {
#line 1807
    goto case_1879047925;
  }
#line 1809
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1734
  return ("NULL");
  case_1: /* CIL Label */ 
#line 1735
  return ("NEEDED");
  case_2: /* CIL Label */ 
#line 1736
  return ("PLTRELSZ");
  case_3: /* CIL Label */ 
#line 1737
  return ("PLTGOT");
  case_4: /* CIL Label */ 
#line 1738
  return ("HASH");
  case_5: /* CIL Label */ 
#line 1739
  return ("STRTAB");
  case_6: /* CIL Label */ 
#line 1740
  return ("SYMTAB");
  case_7: /* CIL Label */ 
#line 1741
  return ("RELA");
  case_8: /* CIL Label */ 
#line 1742
  return ("RELASZ");
  case_9: /* CIL Label */ 
#line 1743
  return ("RELAENT");
  case_10: /* CIL Label */ 
#line 1744
  return ("STRSZ");
  case_11: /* CIL Label */ 
#line 1745
  return ("SYMENT");
  case_12: /* CIL Label */ 
#line 1746
  return ("INIT");
  case_13: /* CIL Label */ 
#line 1747
  return ("FINI");
  case_14: /* CIL Label */ 
#line 1748
  return ("SONAME");
  case_15: /* CIL Label */ 
#line 1749
  return ("RPATH");
  case_16: /* CIL Label */ 
#line 1750
  return ("SYMBOLIC");
  case_17: /* CIL Label */ 
#line 1751
  return ("REL");
  case_18: /* CIL Label */ 
#line 1752
  return ("RELSZ");
  case_19: /* CIL Label */ 
#line 1753
  return ("RELENT");
  case_20: /* CIL Label */ 
#line 1754
  return ("PLTREL");
  case_21: /* CIL Label */ 
#line 1755
  return ("DEBUG");
  case_22: /* CIL Label */ 
#line 1756
  return ("TEXTREL");
  case_23: /* CIL Label */ 
#line 1757
  return ("JMPREL");
  case_24: /* CIL Label */ 
#line 1758
  return ("BIND_NOW");
  case_25: /* CIL Label */ 
#line 1759
  return ("INIT_ARRAY");
  case_26: /* CIL Label */ 
#line 1760
  return ("FINI_ARRAY");
  case_27: /* CIL Label */ 
#line 1761
  return ("INIT_ARRAYSZ");
  case_28: /* CIL Label */ 
#line 1762
  return ("FINI_ARRAYSZ");
  case_29: /* CIL Label */ 
#line 1763
  return ("RUNPATH");
  case_30: /* CIL Label */ 
#line 1764
  return ("FLAGS");
  case_32: /* CIL Label */ 
#line 1766
  return ("PREINIT_ARRAY");
  case_33: /* CIL Label */ 
#line 1767
  return ("PREINIT_ARRAYSZ");
  case_1879047672: /* CIL Label */ 
#line 1769
  return ("CHECKSUM");
  case_1879047673: /* CIL Label */ 
#line 1770
  return ("PLTPADSZ");
  case_1879047674: /* CIL Label */ 
#line 1771
  return ("MOVEENT");
  case_1879047675: /* CIL Label */ 
#line 1772
  return ("MOVESZ");
  case_1879047676: /* CIL Label */ 
#line 1773
  return ("FEATURE");
  case_1879047677: /* CIL Label */ 
#line 1774
  return ("POSFLAG_1");
  case_1879047678: /* CIL Label */ 
#line 1775
  return ("SYMINSZ");
  case_1879047679: /* CIL Label */ 
#line 1776
  return ("SYMINENT");
  case_1879047680: /* CIL Label */ 
#line 1778
  return ("ADDRRNGLO");
  case_1879047930: /* CIL Label */ 
#line 1779
  return ("CONFIG");
  case_1879047931: /* CIL Label */ 
#line 1780
  return ("DEPAUDIT");
  case_1879047932: /* CIL Label */ 
#line 1781
  return ("AUDIT");
  case_1879047933: /* CIL Label */ 
#line 1782
  return ("PLTPAD");
  case_1879047934: /* CIL Label */ 
#line 1783
  return ("MOVETAB");
  case_1879047935: /* CIL Label */ 
#line 1784
  return ("SYMINFO");
  case_1879048176: /* CIL Label */ 
#line 1786
  return ("VERSYM");
  case_1879047927: /* CIL Label */ 
#line 1788
  return ("TLSDESC_GOT");
  case_1879047926: /* CIL Label */ 
#line 1789
  return ("TLSDESC_PLT");
  case_1879048185: /* CIL Label */ 
#line 1790
  return ("RELACOUNT");
  case_1879048186: /* CIL Label */ 
#line 1791
  return ("RELCOUNT");
  case_1879048187: /* CIL Label */ 
#line 1792
  return ("FLAGS_1");
  case_1879048188: /* CIL Label */ 
#line 1793
  return ("VERDEF");
  case_1879048189: /* CIL Label */ 
#line 1794
  return ("VERDEFNUM");
  case_1879048190: /* CIL Label */ 
#line 1795
  return ("VERNEED");
  case_1879048191: /* CIL Label */ 
#line 1796
  return ("VERNEEDNUM");
  case_2147483645: /* CIL Label */ 
#line 1798
  return ("AUXILIARY");
  case_2147483646: /* CIL Label */ 
#line 1799
  return ("USED");
  case_2147483647: /* CIL Label */ 
#line 1800
  return ("FILTER");
  case_1879047669: /* CIL Label */ 
#line 1802
  return ("GNU_PRELINKED");
  case_1879047928: /* CIL Label */ 
#line 1803
  return ("GNU_CONFLICT");
  case_1879047670: /* CIL Label */ 
#line 1804
  return ("GNU_CONFLICTSZ");
  case_1879047929: /* CIL Label */ 
#line 1805
  return ("GNU_LIBLIST");
  case_1879047671: /* CIL Label */ 
#line 1806
  return ("GNU_LIBLISTSZ");
  case_1879047925: /* CIL Label */ 
#line 1807
  return ("GNU_HASH");
  switch_default: /* CIL Label */ 
#line 1810
  if (type >= 1879048192UL) {
#line 1810
    if (type <= 2147483647UL) {
      {
#line 1817
      if ((int )elf_header.e_machine == 10) {
#line 1817
        goto case_10___0;
      }
#line 1817
      if ((int )elf_header.e_machine == 8) {
#line 1817
        goto case_10___0;
      }
#line 1820
      if ((int )elf_header.e_machine == 43) {
#line 1820
        goto case_43;
      }
#line 1823
      if ((int )elf_header.e_machine == 20) {
#line 1823
        goto case_20___0;
      }
#line 1826
      if ((int )elf_header.e_machine == 21) {
#line 1826
        goto case_21___0;
      }
#line 1829
      if ((int )elf_header.e_machine == 50) {
#line 1829
        goto case_50;
      }
#line 1832
      if ((int )elf_header.e_machine == 36902) {
#line 1832
        goto case_36902;
      }
#line 1835
      if ((int )elf_header.e_machine == 135) {
#line 1835
        goto case_135;
      }
#line 1838
      if ((int )elf_header.e_machine == 140) {
#line 1838
        goto case_140;
      }
#line 1841
      if ((int )elf_header.e_machine == 113) {
#line 1841
        goto case_113;
      }
#line 1844
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 1818
      result = get_mips_dynamic_type(type);
      }
#line 1819
      goto switch_break___0;
      case_43: /* CIL Label */ 
      {
#line 1821
      result = get_sparc64_dynamic_type(type);
      }
#line 1822
      goto switch_break___0;
      case_20___0: /* CIL Label */ 
      {
#line 1824
      result = get_ppc_dynamic_type(type);
      }
#line 1825
      goto switch_break___0;
      case_21___0: /* CIL Label */ 
      {
#line 1827
      result = get_ppc64_dynamic_type(type);
      }
#line 1828
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 1830
      result = get_ia64_dynamic_type(type);
      }
#line 1831
      goto switch_break___0;
      case_36902: /* CIL Label */ 
      {
#line 1833
      result = get_alpha_dynamic_type(type);
      }
#line 1834
      goto switch_break___0;
      case_135: /* CIL Label */ 
      {
#line 1836
      result = get_score_dynamic_type(type);
      }
#line 1837
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 1839
      result = get_tic6x_dynamic_type(type);
      }
#line 1840
      goto switch_break___0;
      case_113: /* CIL Label */ 
      {
#line 1842
      result = get_nios2_dynamic_type(type);
      }
#line 1843
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1845
      result = (char const   *)((void *)0);
#line 1846
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1849
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 1850
        return (result);
      }
      {
#line 1852
      tmp___0 = gettext("Processor Specific: %lx");
#line 1852
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)tmp___0,
               type);
      }
    } else {
#line 1810
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1854
  if (type >= 1610612749UL) {
#line 1854
    if (type <= 1879044096UL) {
#line 1854
      goto _L;
    } else {
#line 1854
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1854
  if ((int )elf_header.e_machine == 15) {
#line 1854
    if (type >= 1610612736UL) {
#line 1854
      if (type <= 1879048191UL) {
        _L: /* CIL Label */ 
        {
#line 1862
        if ((int )elf_header.e_machine == 15) {
#line 1862
          goto case_15___0;
        }
#line 1865
        if ((int )elf_header.e_machine == 50) {
#line 1865
          goto case_50___0;
        }
#line 1868
        goto switch_default___1;
        case_15___0: /* CIL Label */ 
        {
#line 1863
        result___0 = get_parisc_dynamic_type(type);
        }
#line 1864
        goto switch_break___1;
        case_50___0: /* CIL Label */ 
        {
#line 1866
        result___0 = get_ia64_dynamic_type(type);
        }
#line 1867
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 1869
        result___0 = (char const   *)((void *)0);
#line 1870
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1873
        if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 1874
          return (result___0);
        }
        {
#line 1876
        tmp___1 = gettext("Operating System specific: %lx");
#line 1876
        snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)tmp___1,
                 type);
        }
      } else {
        {
#line 1880
        tmp___2 = gettext("<unknown>: %lx");
#line 1880
        snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)tmp___2,
                 type);
        }
      }
    } else {
      {
#line 1880
      tmp___2 = gettext("<unknown>: %lx");
#line 1880
      snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)tmp___2,
               type);
      }
    }
  } else {
    {
#line 1880
    tmp___2 = gettext("<unknown>: %lx");
#line 1880
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)tmp___2,
             type);
    }
  }
#line 1882
  return ((char const   *)(buff));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1889 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___0[32]  ;
#line 1886 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *get_file_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1893
  if (e_type == 0U) {
#line 1893
    goto case_0;
  }
#line 1894
  if (e_type == 1U) {
#line 1894
    goto case_1;
  }
#line 1895
  if (e_type == 2U) {
#line 1895
    goto case_2;
  }
#line 1896
  if (e_type == 3U) {
#line 1896
    goto case_3;
  }
#line 1897
  if (e_type == 4U) {
#line 1897
    goto case_4;
  }
#line 1899
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1893
  tmp___0 = gettext("NONE (None)");
  }
#line 1893
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 1894
  tmp___1 = gettext("REL (Relocatable file)");
  }
#line 1894
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 1895
  tmp___2 = gettext("EXEC (Executable file)");
  }
#line 1895
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 1896
  tmp___3 = gettext("DYN (Shared object file)");
  }
#line 1896
  return (tmp___3);
  case_4: /* CIL Label */ 
  {
#line 1897
  tmp___4 = gettext("CORE (Core file)");
  }
#line 1897
  return (tmp___4);
  switch_default: /* CIL Label */ 
#line 1900
  if (e_type >= 65280U) {
#line 1900
    if (e_type <= 65535U) {
      {
#line 1901
      tmp___5 = gettext("Processor Specific: (%x)");
#line 1901
      snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___5,
               e_type);
      }
    } else {
#line 1900
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1902
  if (e_type >= 65024U) {
#line 1902
    if (e_type <= 65279U) {
      {
#line 1903
      tmp___6 = gettext("OS Specific: (%x)");
#line 1903
      snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___6,
               e_type);
      }
    } else {
      {
#line 1905
      tmp___7 = gettext("<unknown>: %x");
#line 1905
      snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___7,
               e_type);
      }
    }
  } else {
    {
#line 1905
    tmp___7 = gettext("<unknown>: %x");
#line 1905
    snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___7,
             e_type);
    }
  }
#line 1906
  return (buff___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1913 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___1[64]  ;
#line 1910 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *get_machine_name(unsigned int e_machine ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1917
  if (e_machine == 0U) {
#line 1917
    goto case_0;
  }
#line 1918
  if (e_machine == 183U) {
#line 1918
    goto case_183;
  }
#line 1919
  if (e_machine == 1U) {
#line 1919
    goto case_1;
  }
#line 1920
  if (e_machine == 2U) {
#line 1920
    goto case_2;
  }
#line 1921
  if (e_machine == 23U) {
#line 1921
    goto case_23;
  }
#line 1922
  if (e_machine == 3U) {
#line 1922
    goto case_3;
  }
#line 1923
  if (e_machine == 4U) {
#line 1923
    goto case_4;
  }
#line 1924
  if (e_machine == 5U) {
#line 1924
    goto case_5;
  }
#line 1925
  if (e_machine == 6U) {
#line 1925
    goto case_6;
  }
#line 1926
  if (e_machine == 7U) {
#line 1926
    goto case_7;
  }
#line 1927
  if (e_machine == 8U) {
#line 1927
    goto case_8;
  }
#line 1928
  if (e_machine == 9U) {
#line 1928
    goto case_9;
  }
#line 1929
  if (e_machine == 10U) {
#line 1929
    goto case_10;
  }
#line 1930
  if (e_machine == 11U) {
#line 1930
    goto case_11;
  }
#line 1931
  if (e_machine == 15U) {
#line 1931
    goto case_15;
  }
#line 1932
  if (e_machine == 17U) {
#line 1932
    goto case_17;
  }
#line 1933
  if (e_machine == 18U) {
#line 1933
    goto case_18;
  }
#line 1934
  if (e_machine == 19U) {
#line 1934
    goto case_19;
  }
#line 1935
  if (e_machine == 20U) {
#line 1935
    goto case_20;
  }
#line 1936
  if (e_machine == 21U) {
#line 1936
    goto case_21;
  }
#line 1937
  if (e_machine == 37U) {
#line 1937
    goto case_37;
  }
#line 1938
  if (e_machine == 38U) {
#line 1938
    goto case_38;
  }
#line 1939
  if (e_machine == 39U) {
#line 1939
    goto case_39;
  }
#line 1940
  if (e_machine == 40U) {
#line 1940
    goto case_40;
  }
#line 1941
  if (e_machine == 41U) {
#line 1941
    goto case_41;
  }
#line 1942
  if (e_machine == 42U) {
#line 1942
    goto case_42;
  }
#line 1943
  if (e_machine == 43U) {
#line 1943
    goto case_43;
  }
#line 1944
  if (e_machine == 44U) {
#line 1944
    goto case_44;
  }
#line 1945
  if (e_machine == 45U) {
#line 1945
    goto case_45;
  }
#line 1946
  if (e_machine == 46U) {
#line 1946
    goto case_46;
  }
#line 1947
  if (e_machine == 47U) {
#line 1947
    goto case_47;
  }
#line 1948
  if (e_machine == 48U) {
#line 1948
    goto case_48;
  }
#line 1949
  if (e_machine == 49U) {
#line 1949
    goto case_49;
  }
#line 1950
  if (e_machine == 50U) {
#line 1950
    goto case_50;
  }
#line 1951
  if (e_machine == 51U) {
#line 1951
    goto case_51;
  }
#line 1952
  if (e_machine == 52U) {
#line 1952
    goto case_52;
  }
#line 1953
  if (e_machine == 36902U) {
#line 1953
    goto case_36902;
  }
#line 1955
  if (e_machine == 85U) {
#line 1955
    goto case_85;
  }
#line 1955
  if (e_machine == 30288U) {
#line 1955
    goto case_85;
  }
#line 1957
  if (e_machine == 86U) {
#line 1957
    goto case_86;
  }
#line 1957
  if (e_machine == 30326U) {
#line 1957
    goto case_86;
  }
#line 1959
  if (e_machine == 88U) {
#line 1959
    goto case_88;
  }
#line 1959
  if (e_machine == 36929U) {
#line 1959
    goto case_88;
  }
#line 1961
  if (e_machine == 36U) {
#line 1961
    goto case_36;
  }
#line 1961
  if (e_machine == 36992U) {
#line 1961
    goto case_36;
  }
#line 1962
  if (e_machine == 87U) {
#line 1962
    goto case_87;
  }
#line 1964
  if (e_machine == 89U) {
#line 1964
    goto case_89;
  }
#line 1964
  if (e_machine == 48879U) {
#line 1964
    goto case_89;
  }
#line 1966
  if (e_machine == 90U) {
#line 1966
    goto case_90;
  }
#line 1966
  if (e_machine == 57005U) {
#line 1966
    goto case_90;
  }
#line 1967
  if (e_machine == 65261U) {
#line 1967
    goto case_65261;
  }
#line 1969
  if (e_machine == 84U) {
#line 1969
    goto case_84;
  }
#line 1969
  if (e_machine == 13104U) {
#line 1969
    goto case_84;
  }
#line 1970
  if (e_machine == 21569U) {
#line 1970
    goto case_21569;
  }
#line 1972
  if (e_machine == 91U) {
#line 1972
    goto case_91;
  }
#line 1972
  if (e_machine == 99U) {
#line 1972
    goto case_91;
  }
#line 1973
  if (e_machine == 54U) {
#line 1973
    goto case_54;
  }
#line 1974
  if (e_machine == 55U) {
#line 1974
    goto case_55;
  }
#line 1975
  if (e_machine == 56U) {
#line 1975
    goto case_56;
  }
#line 1976
  if (e_machine == 57U) {
#line 1976
    goto case_57;
  }
#line 1977
  if (e_machine == 58U) {
#line 1977
    goto case_58;
  }
#line 1978
  if (e_machine == 59U) {
#line 1978
    goto case_59;
  }
#line 1979
  if (e_machine == 60U) {
#line 1979
    goto case_60;
  }
#line 1980
  if (e_machine == 61U) {
#line 1980
    goto case_61;
  }
#line 1981
  if (e_machine == 63U) {
#line 1981
    goto case_63;
  }
#line 1982
  if (e_machine == 64U) {
#line 1982
    goto case_64;
  }
#line 1983
  if (e_machine == 65U) {
#line 1983
    goto case_65;
  }
#line 1984
  if (e_machine == 66U) {
#line 1984
    goto case_66;
  }
#line 1985
  if (e_machine == 67U) {
#line 1985
    goto case_67;
  }
#line 1986
  if (e_machine == 68U) {
#line 1986
    goto case_68;
  }
#line 1987
  if (e_machine == 69U) {
#line 1987
    goto case_69;
  }
#line 1988
  if (e_machine == 53U) {
#line 1988
    goto case_53;
  }
#line 1989
  if (e_machine == 70U) {
#line 1989
    goto case_70;
  }
#line 1990
  if (e_machine == 71U) {
#line 1990
    goto case_71;
  }
#line 1991
  if (e_machine == 72U) {
#line 1991
    goto case_72;
  }
#line 1992
  if (e_machine == 73U) {
#line 1992
    goto case_73;
  }
#line 1993
  if (e_machine == 74U) {
#line 1993
    goto case_74;
  }
#line 1994
  if (e_machine == 75U) {
#line 1994
    goto case_75;
  }
#line 1996
  if (e_machine == 83U) {
#line 1996
    goto case_83;
  }
#line 1996
  if (e_machine == 4183U) {
#line 1996
    goto case_83;
  }
#line 1997
  if (e_machine == 76U) {
#line 1997
    goto case_76;
  }
#line 1998
  if (e_machine == 77U) {
#line 1998
    goto case_77;
  }
#line 1999
  if (e_machine == 78U) {
#line 1999
    goto case_78;
  }
#line 2000
  if (e_machine == 79U) {
#line 2000
    goto case_79;
  }
#line 2001
  if (e_machine == 80U) {
#line 2001
    goto case_80;
  }
#line 2002
  if (e_machine == 81U) {
#line 2002
    goto case_81;
  }
#line 2003
  if (e_machine == 82U) {
#line 2003
    goto case_82;
  }
#line 2004
  if (e_machine == 62U) {
#line 2004
    goto case_62;
  }
#line 2005
  if (e_machine == 180U) {
#line 2005
    goto case_180;
  }
#line 2006
  if (e_machine == 181U) {
#line 2006
    goto case_181;
  }
#line 2008
  if (e_machine == 22U) {
#line 2008
    goto case_22;
  }
#line 2008
  if (e_machine == 41872U) {
#line 2008
    goto case_22;
  }
#line 2009
  if (e_machine == 135U) {
#line 2009
    goto case_135;
  }
#line 2010
  if (e_machine == 44357U) {
#line 2010
    goto case_44357;
  }
#line 2012
  if (e_machine == 33906U) {
#line 2012
    goto case_33906;
  }
#line 2012
  if (e_machine == 92U) {
#line 2012
    goto case_33906;
  }
#line 2013
  if (e_machine == 93U) {
#line 2013
    goto case_93;
  }
#line 2014
  if (e_machine == 114U) {
#line 2014
    goto case_114;
  }
#line 2015
  if (e_machine == 4643U) {
#line 2015
    goto case_4643;
  }
#line 2016
  if (e_machine == 23205U) {
#line 2016
    goto case_23205;
  }
#line 2018
  if (e_machine == 101U) {
#line 2018
    goto case_101;
  }
#line 2018
  if (e_machine == 33303U) {
#line 2018
    goto case_101;
  }
#line 2019
  if (e_machine == 65210U) {
#line 2019
    goto case_65210;
  }
#line 2021
  if (e_machine == 94U) {
#line 2021
    goto case_94;
  }
#line 2021
  if (e_machine == 43975U) {
#line 2021
    goto case_94;
  }
#line 2022
  if (e_machine == 95U) {
#line 2022
    goto case_95;
  }
#line 2023
  if (e_machine == 96U) {
#line 2023
    goto case_96;
  }
#line 2024
  if (e_machine == 97U) {
#line 2024
    goto case_97;
  }
#line 2025
  if (e_machine == 98U) {
#line 2025
    goto case_98;
  }
#line 2026
  if (e_machine == 100U) {
#line 2026
    goto case_100;
  }
#line 2027
  if (e_machine == 102U) {
#line 2027
    goto case_102;
  }
#line 2028
  if (e_machine == 103U) {
#line 2028
    goto case_103;
  }
#line 2029
  if (e_machine == 104U) {
#line 2029
    goto case_104;
  }
#line 2030
  if (e_machine == 105U) {
#line 2030
    goto case_105;
  }
#line 2031
  if (e_machine == 138U) {
#line 2031
    goto case_138;
  }
#line 2033
  if (e_machine == 120U) {
#line 2033
    goto case_120;
  }
#line 2033
  if (e_machine == 65200U) {
#line 2033
    goto case_120;
  }
#line 2034
  if (e_machine == 9520U) {
#line 2034
    goto case_9520;
  }
#line 2035
  if (e_machine == 106U) {
#line 2035
    goto case_106;
  }
#line 2036
  if (e_machine == 107U) {
#line 2036
    goto case_107;
  }
#line 2037
  if (e_machine == 108U) {
#line 2037
    goto case_108;
  }
#line 2038
  if (e_machine == 109U) {
#line 2038
    goto case_109;
  }
#line 2039
  if (e_machine == 110U) {
#line 2039
    goto case_110;
  }
#line 2040
  if (e_machine == 111U) {
#line 2040
    goto case_111;
  }
#line 2041
  if (e_machine == 112U) {
#line 2041
    goto case_112;
  }
#line 2042
  if (e_machine == 65211U) {
#line 2042
    goto case_65211;
  }
#line 2043
  if (e_machine == 113U) {
#line 2043
    goto case_113;
  }
#line 2045
  if (e_machine == 18056U) {
#line 2045
    goto case_18056;
  }
#line 2045
  if (e_machine == 116U) {
#line 2045
    goto case_18056;
  }
#line 2046
  if (e_machine == 117U) {
#line 2046
    goto case_117;
  }
#line 2047
  if (e_machine == 118U) {
#line 2047
    goto case_118;
  }
#line 2048
  if (e_machine == 119U) {
#line 2048
    goto case_119;
  }
#line 2049
  if (e_machine == 131U) {
#line 2049
    goto case_131;
  }
#line 2050
  if (e_machine == 132U) {
#line 2050
    goto case_132;
  }
#line 2051
  if (e_machine == 134U) {
#line 2051
    goto case_134;
  }
#line 2052
  if (e_machine == 136U) {
#line 2052
    goto case_136;
  }
#line 2053
  if (e_machine == 137U) {
#line 2053
    goto case_137;
  }
#line 2054
  if (e_machine == 139U) {
#line 2054
    goto case_139;
  }
#line 2055
  if (e_machine == 140U) {
#line 2055
    goto case_140;
  }
#line 2056
  if (e_machine == 141U) {
#line 2056
    goto case_141;
  }
#line 2057
  if (e_machine == 142U) {
#line 2057
    goto case_142;
  }
#line 2058
  if (e_machine == 160U) {
#line 2058
    goto case_160;
  }
#line 2059
  if (e_machine == 161U) {
#line 2059
    goto case_161;
  }
#line 2060
  if (e_machine == 162U) {
#line 2060
    goto case_162;
  }
#line 2061
  if (e_machine == 163U) {
#line 2061
    goto case_163;
  }
#line 2062
  if (e_machine == 164U) {
#line 2062
    goto case_164;
  }
#line 2063
  if (e_machine == 165U) {
#line 2063
    goto case_165;
  }
#line 2064
  if (e_machine == 166U) {
#line 2064
    goto case_166;
  }
#line 2065
  if (e_machine == 167U) {
#line 2065
    goto case_167;
  }
#line 2066
  if (e_machine == 168U) {
#line 2066
    goto case_168;
  }
#line 2067
  if (e_machine == 169U) {
#line 2067
    goto case_169;
  }
#line 2068
  if (e_machine == 170U) {
#line 2068
    goto case_170;
  }
#line 2069
  if (e_machine == 171U) {
#line 2069
    goto case_171;
  }
#line 2070
  if (e_machine == 172U) {
#line 2070
    goto case_172;
  }
#line 2071
  if (e_machine == 61453U) {
#line 2071
    goto case_61453;
  }
#line 2074
  if (e_machine == 47787U) {
#line 2074
    goto case_47787;
  }
#line 2074
  if (e_machine == 189U) {
#line 2074
    goto case_47787;
  }
#line 2074
  if (e_machine == 177U) {
#line 2074
    goto case_47787;
  }
#line 2075
  if (e_machine == 197U) {
#line 2075
    goto case_197;
  }
#line 2076
  if (e_machine == 173U) {
#line 2076
    goto case_173;
  }
#line 2077
  if (e_machine == 174U) {
#line 2077
    goto case_174;
  }
#line 2078
  if (e_machine == 175U) {
#line 2078
    goto case_175;
  }
#line 2079
  if (e_machine == 176U) {
#line 2079
    goto case_176;
  }
#line 2080
  if (e_machine == 178U) {
#line 2080
    goto case_178;
  }
#line 2081
  if (e_machine == 179U) {
#line 2081
    goto case_179;
  }
#line 2082
  if (e_machine == 185U) {
#line 2082
    goto case_185;
  }
#line 2083
  if (e_machine == 186U) {
#line 2083
    goto case_186;
  }
#line 2084
  if (e_machine == 187U) {
#line 2084
    goto case_187;
  }
#line 2085
  if (e_machine == 188U) {
#line 2085
    goto case_188;
  }
#line 2086
  if (e_machine == 191U) {
#line 2086
    goto case_191;
  }
#line 2087
  if (e_machine == 190U) {
#line 2087
    goto case_190;
  }
#line 2088
  if (e_machine == 115U) {
#line 2088
    goto case_115;
  }
#line 2089
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1917
  tmp___0 = gettext("None");
  }
#line 1917
  return (tmp___0);
  case_183: /* CIL Label */ 
#line 1918
  return ((char *)"AArch64");
  case_1: /* CIL Label */ 
#line 1919
  return ((char *)"WE32100");
  case_2: /* CIL Label */ 
#line 1920
  return ((char *)"Sparc");
  case_23: /* CIL Label */ 
#line 1921
  return ((char *)"SPU");
  case_3: /* CIL Label */ 
#line 1922
  return ((char *)"Intel 80386");
  case_4: /* CIL Label */ 
#line 1923
  return ((char *)"MC68000");
  case_5: /* CIL Label */ 
#line 1924
  return ((char *)"MC88000");
  case_6: /* CIL Label */ 
#line 1925
  return ((char *)"Intel 80486");
  case_7: /* CIL Label */ 
#line 1926
  return ((char *)"Intel 80860");
  case_8: /* CIL Label */ 
#line 1927
  return ((char *)"MIPS R3000");
  case_9: /* CIL Label */ 
#line 1928
  return ((char *)"IBM System/370");
  case_10: /* CIL Label */ 
#line 1929
  return ((char *)"MIPS R4000 big-endian");
  case_11: /* CIL Label */ 
#line 1930
  return ((char *)"Sparc v9 (old)");
  case_15: /* CIL Label */ 
#line 1931
  return ((char *)"HPPA");
  case_17: /* CIL Label */ 
#line 1932
  return ((char *)"Power PC (old)");
  case_18: /* CIL Label */ 
#line 1933
  return ((char *)"Sparc v8+");
  case_19: /* CIL Label */ 
#line 1934
  return ((char *)"Intel 90860");
  case_20: /* CIL Label */ 
#line 1935
  return ((char *)"PowerPC");
  case_21: /* CIL Label */ 
#line 1936
  return ((char *)"PowerPC64");
  case_37: /* CIL Label */ 
#line 1937
  return ((char *)"Fujitsu FR20");
  case_38: /* CIL Label */ 
#line 1938
  return ((char *)"TRW RH32");
  case_39: /* CIL Label */ 
#line 1939
  return ((char *)"MCORE");
  case_40: /* CIL Label */ 
#line 1940
  return ((char *)"ARM");
  case_41: /* CIL Label */ 
#line 1941
  return ((char *)"Digital Alpha (old)");
  case_42: /* CIL Label */ 
#line 1942
  return ((char *)"Renesas / SuperH SH");
  case_43: /* CIL Label */ 
#line 1943
  return ((char *)"Sparc v9");
  case_44: /* CIL Label */ 
#line 1944
  return ((char *)"Siemens Tricore");
  case_45: /* CIL Label */ 
#line 1945
  return ((char *)"ARC");
  case_46: /* CIL Label */ 
#line 1946
  return ((char *)"Renesas H8/300");
  case_47: /* CIL Label */ 
#line 1947
  return ((char *)"Renesas H8/300H");
  case_48: /* CIL Label */ 
#line 1948
  return ((char *)"Renesas H8S");
  case_49: /* CIL Label */ 
#line 1949
  return ((char *)"Renesas H8/500");
  case_50: /* CIL Label */ 
#line 1950
  return ((char *)"Intel IA-64");
  case_51: /* CIL Label */ 
#line 1951
  return ((char *)"Stanford MIPS-X");
  case_52: /* CIL Label */ 
#line 1952
  return ((char *)"Motorola Coldfire");
  case_36902: /* CIL Label */ 
#line 1953
  return ((char *)"Alpha");
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 1955
  return ((char *)"d10v");
  case_86: /* CIL Label */ 
  case_30326: /* CIL Label */ 
#line 1957
  return ((char *)"d30v");
  case_88: /* CIL Label */ 
  case_36929: /* CIL Label */ 
#line 1959
  return ((char *)"Renesas M32R (formerly Mitsubishi M32r)");
  case_36: /* CIL Label */ 
  case_36992: /* CIL Label */ 
#line 1961
  return ((char *)"Renesas V850 (using RH850 ABI)");
  case_87: /* CIL Label */ 
#line 1962
  return ((char *)"Renesas V850");
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 1964
  return ((char *)"mn10300");
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 1966
  return ((char *)"mn10200");
  case_65261: /* CIL Label */ 
#line 1967
  return ((char *)"Moxie");
  case_84: /* CIL Label */ 
  case_13104: /* CIL Label */ 
#line 1969
  return ((char *)"Fujitsu FR30");
  case_21569: /* CIL Label */ 
#line 1970
  return ((char *)"Fujitsu FR-V");
  case_91: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 1972
  return ((char *)"picoJava");
  case_54: /* CIL Label */ 
#line 1973
  return ((char *)"Fujitsu Multimedia Accelerator");
  case_55: /* CIL Label */ 
#line 1974
  return ((char *)"Siemens PCP");
  case_56: /* CIL Label */ 
#line 1975
  return ((char *)"Sony nCPU embedded RISC processor");
  case_57: /* CIL Label */ 
#line 1976
  return ((char *)"Denso NDR1 microprocesspr");
  case_58: /* CIL Label */ 
#line 1977
  return ((char *)"Motorola Star*Core processor");
  case_59: /* CIL Label */ 
#line 1978
  return ((char *)"Toyota ME16 processor");
  case_60: /* CIL Label */ 
#line 1979
  return ((char *)"STMicroelectronics ST100 processor");
  case_61: /* CIL Label */ 
#line 1980
  return ((char *)"Advanced Logic Corp. TinyJ embedded processor");
  case_63: /* CIL Label */ 
#line 1981
  return ((char *)"Sony DSP processor");
  case_64: /* CIL Label */ 
#line 1982
  return ((char *)"Digital Equipment Corp. PDP-10");
  case_65: /* CIL Label */ 
#line 1983
  return ((char *)"Digital Equipment Corp. PDP-11");
  case_66: /* CIL Label */ 
#line 1984
  return ((char *)"Siemens FX66 microcontroller");
  case_67: /* CIL Label */ 
#line 1985
  return ((char *)"STMicroelectronics ST9+ 8/16 bit microcontroller");
  case_68: /* CIL Label */ 
#line 1986
  return ((char *)"STMicroelectronics ST7 8-bit microcontroller");
  case_69: /* CIL Label */ 
#line 1987
  return ((char *)"Motorola MC68HC16 Microcontroller");
  case_53: /* CIL Label */ 
#line 1988
  return ((char *)"Motorola MC68HC12 Microcontroller");
  case_70: /* CIL Label */ 
#line 1989
  return ((char *)"Motorola MC68HC11 Microcontroller");
  case_71: /* CIL Label */ 
#line 1990
  return ((char *)"Motorola MC68HC08 Microcontroller");
  case_72: /* CIL Label */ 
#line 1991
  return ((char *)"Motorola MC68HC05 Microcontroller");
  case_73: /* CIL Label */ 
#line 1992
  return ((char *)"Silicon Graphics SVx");
  case_74: /* CIL Label */ 
#line 1993
  return ((char *)"STMicroelectronics ST19 8-bit microcontroller");
  case_75: /* CIL Label */ 
#line 1994
  return ((char *)"Digital VAX");
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 1996
  return ((char *)"Atmel AVR 8-bit microcontroller");
  case_76: /* CIL Label */ 
#line 1997
  return ((char *)"Axis Communications 32-bit embedded processor");
  case_77: /* CIL Label */ 
#line 1998
  return ((char *)"Infineon Technologies 32-bit embedded cpu");
  case_78: /* CIL Label */ 
#line 1999
  return ((char *)"Element 14 64-bit DSP processor");
  case_79: /* CIL Label */ 
#line 2000
  return ((char *)"LSI Logic\'s 16-bit DSP processor");
  case_80: /* CIL Label */ 
#line 2001
  return ((char *)"Donald Knuth\'s educational 64-bit processor");
  case_81: /* CIL Label */ 
#line 2002
  return ((char *)"Harvard Universitys\'s machine-independent object format");
  case_82: /* CIL Label */ 
#line 2003
  return ((char *)"Vitesse Prism");
  case_62: /* CIL Label */ 
#line 2004
  return ((char *)"Advanced Micro Devices X86-64");
  case_180: /* CIL Label */ 
#line 2005
  return ((char *)"Intel L1OM");
  case_181: /* CIL Label */ 
#line 2006
  return ((char *)"Intel K1OM");
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 2008
  return ((char *)"IBM S/390");
  case_135: /* CIL Label */ 
#line 2009
  return ((char *)"SUNPLUS S+Core");
  case_44357: /* CIL Label */ 
#line 2010
  return ((char *)"Sanyo XStormy16 CPU core");
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 2012
  return ((char *)"OpenRISC");
  case_93: /* CIL Label */ 
#line 2013
  return ((char *)"ARC International ARCompact processor");
  case_114: /* CIL Label */ 
#line 2014
  return ((char *)"National Semiconductor CRX microprocessor");
  case_4643: /* CIL Label */ 
#line 2015
  return ((char *)"Adapteva EPIPHANY");
  case_23205: /* CIL Label */ 
#line 2016
  return ((char *)"OpenDLX");
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 2018
  return ((char *)"Ubicom IP2xxx 8-bit microcontrollers");
  case_65210: /* CIL Label */ 
#line 2019
  return ((char *)"Vitesse IQ2000");
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 2021
  return ((char *)"Tensilica Xtensa Processor");
  case_95: /* CIL Label */ 
#line 2022
  return ((char *)"Alphamosaic VideoCore processor");
  case_96: /* CIL Label */ 
#line 2023
  return ((char *)"Thompson Multimedia General Purpose Processor");
  case_97: /* CIL Label */ 
#line 2024
  return ((char *)"National Semiconductor 32000 series");
  case_98: /* CIL Label */ 
#line 2025
  return ((char *)"Tenor Network TPC processor");
  case_100: /* CIL Label */ 
#line 2026
  return ((char *)"STMicroelectronics ST200 microcontroller");
  case_102: /* CIL Label */ 
#line 2027
  return ((char *)"MAX Processor");
  case_103: /* CIL Label */ 
#line 2028
  return ((char *)"National Semiconductor CompactRISC");
  case_104: /* CIL Label */ 
#line 2029
  return ((char *)"Fujitsu F2MC16");
  case_105: /* CIL Label */ 
#line 2030
  return ((char *)"Texas Instruments msp430 microcontroller");
  case_138: /* CIL Label */ 
#line 2031
  return ((char *)"Lattice Mico32");
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 2033
  return ((char *)"Renesas M32c");
  case_9520: /* CIL Label */ 
#line 2034
  return ((char *)"Morpho Techologies MT processor");
  case_106: /* CIL Label */ 
#line 2035
  return ((char *)"Analog Devices Blackfin");
  case_107: /* CIL Label */ 
#line 2036
  return ((char *)"S1C33 Family of Seiko Epson processors");
  case_108: /* CIL Label */ 
#line 2037
  return ((char *)"Sharp embedded microprocessor");
  case_109: /* CIL Label */ 
#line 2038
  return ((char *)"Arca RISC microprocessor");
  case_110: /* CIL Label */ 
#line 2039
  return ((char *)"Unicore");
  case_111: /* CIL Label */ 
#line 2040
  return ((char *)"eXcess 16/32/64-bit configurable embedded CPU");
  case_112: /* CIL Label */ 
#line 2041
  return ((char *)"Icera Semiconductor Inc. Deep Execution Processor");
  case_65211: /* CIL Label */ 
#line 2042
  return ((char *)"Altera Nios");
  case_113: /* CIL Label */ 
#line 2043
  return ((char *)"Altera Nios II");
  case_18056: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 2045
  return ((char *)"Infineon Technologies xc16x");
  case_117: /* CIL Label */ 
#line 2046
  return ((char *)"Renesas M16C series microprocessors");
  case_118: /* CIL Label */ 
#line 2047
  return ((char *)"Microchip Technology dsPIC30F Digital Signal Controller");
  case_119: /* CIL Label */ 
#line 2048
  return ((char *)"Freescale Communication Engine RISC core");
  case_131: /* CIL Label */ 
#line 2049
  return ((char *)"Altium TSK3000 core");
  case_132: /* CIL Label */ 
#line 2050
  return ((char *)"Freescale RS08 embedded processor");
  case_134: /* CIL Label */ 
#line 2051
  return ((char *)"Cyan Technology eCOG2 microprocessor");
  case_136: /* CIL Label */ 
#line 2052
  return ((char *)"New Japan Radio (NJR) 24-bit DSP Processor");
  case_137: /* CIL Label */ 
#line 2053
  return ((char *)"Broadcom VideoCore III processor");
  case_139: /* CIL Label */ 
#line 2054
  return ((char *)"Seiko Epson C17 family");
  case_140: /* CIL Label */ 
#line 2055
  return ((char *)"Texas Instruments TMS320C6000 DSP family");
  case_141: /* CIL Label */ 
#line 2056
  return ((char *)"Texas Instruments TMS320C2000 DSP family");
  case_142: /* CIL Label */ 
#line 2057
  return ((char *)"Texas Instruments TMS320C55x DSP family");
  case_160: /* CIL Label */ 
#line 2058
  return ((char *)"STMicroelectronics 64bit VLIW Data Signal Processor");
  case_161: /* CIL Label */ 
#line 2059
  return ((char *)"Cypress M8C microprocessor");
  case_162: /* CIL Label */ 
#line 2060
  return ((char *)"Renesas R32C series microprocessors");
  case_163: /* CIL Label */ 
#line 2061
  return ((char *)"NXP Semiconductors TriMedia architecture family");
  case_164: /* CIL Label */ 
#line 2062
  return ((char *)"QUALCOMM DSP6 Processor");
  case_165: /* CIL Label */ 
#line 2063
  return ((char *)"Intel 8051 and variants");
  case_166: /* CIL Label */ 
#line 2064
  return ((char *)"STMicroelectronics STxP7x family");
  case_167: /* CIL Label */ 
#line 2065
  return ((char *)"Andes Technology compact code size embedded RISC processor family");
  case_168: /* CIL Label */ 
#line 2066
  return ((char *)"Cyan Technology eCOG1X family");
  case_169: /* CIL Label */ 
#line 2067
  return ((char *)"Dallas Semiconductor MAXQ30 Core microcontrollers");
  case_170: /* CIL Label */ 
#line 2068
  return ((char *)"New Japan Radio (NJR) 16-bit DSP Processor");
  case_171: /* CIL Label */ 
#line 2069
  return ((char *)"M2000 Reconfigurable RISC Microprocessor");
  case_172: /* CIL Label */ 
#line 2070
  return ((char *)"Cray Inc. NV2 vector architecture");
  case_61453: /* CIL Label */ 
#line 2071
  return ((char *)"Toshiba MeP Media Engine");
  case_47787: /* CIL Label */ 
  case_189: /* CIL Label */ 
  case_177: /* CIL Label */ 
#line 2074
  return ((char *)"Xilinx MicroBlaze");
  case_197: /* CIL Label */ 
#line 2075
  return ((char *)"Renesas RL78");
  case_173: /* CIL Label */ 
#line 2076
  return ((char *)"Renesas RX");
  case_174: /* CIL Label */ 
#line 2077
  return ((char *)"Imagination Technologies Meta processor architecture");
  case_175: /* CIL Label */ 
#line 2078
  return ((char *)"MCST Elbrus general purpose hardware architecture");
  case_176: /* CIL Label */ 
#line 2079
  return ((char *)"Cyan Technology eCOG16 family");
  case_178: /* CIL Label */ 
#line 2080
  return ((char *)"Freescale Extended Time Processing Unit");
  case_179: /* CIL Label */ 
#line 2081
  return ((char *)"Infineon Technologies SLE9X core");
  case_185: /* CIL Label */ 
#line 2082
  return ((char *)"Atmel Corporation 32-bit microprocessor family");
  case_186: /* CIL Label */ 
#line 2083
  return ((char *)"STMicroeletronics STM8 8-bit microcontroller");
  case_187: /* CIL Label */ 
#line 2084
  return ((char *)"Tilera TILE64 multicore architecture family");
  case_188: /* CIL Label */ 
#line 2085
  return ((char *)"Tilera TILEPro multicore architecture family");
  case_191: /* CIL Label */ 
#line 2086
  return ((char *)"Tilera TILE-Gx multicore architecture family");
  case_190: /* CIL Label */ 
#line 2087
  return ((char *)"NVIDIA CUDA architecture");
  case_115: /* CIL Label */ 
#line 2088
  return ((char *)"Motorola XGATE embedded processor");
  switch_default: /* CIL Label */ 
  {
#line 2090
  tmp___1 = gettext("<unknown>: 0x%x");
#line 2090
  snprintf((char */* __restrict  */)(buff___1), sizeof(buff___1), (char const   */* __restrict  */)tmp___1,
           e_machine);
  }
#line 2091
  return (buff___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2095 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void decode_ARM_machine_flags(unsigned int e_flags , char *buf___7 ) 
{ 
  unsigned int eabi ;
  int unknown ;
  unsigned int flag ;
  unsigned int flag___0 ;
  unsigned int flag___1 ;
  unsigned int flag___2 ;
  unsigned int flag___3 ;
  char *tmp___0 ;

  {
#line 2099
  unknown = 0;
#line 2101
  eabi = e_flags & 4278190080U;
#line 2102
  e_flags &= 16777215U;
#line 2105
  if (e_flags & 1U) {
    {
#line 2107
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", relocatable executable");
#line 2108
    e_flags &= 4294967294U;
    }
  }
#line 2111
  if (e_flags & 2U) {
    {
#line 2113
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", has entry point");
#line 2114
    e_flags &= 4294967293U;
    }
  }
  {
#line 2126
  if (eabi == 16777216U) {
#line 2126
    goto case_16777216;
  }
#line 2149
  if (eabi == 33554432U) {
#line 2149
    goto case_33554432;
  }
#line 2180
  if (eabi == 50331648U) {
#line 2180
    goto case_50331648;
  }
#line 2184
  if (eabi == 67108864U) {
#line 2184
    goto case_67108864;
  }
#line 2212
  if (eabi == 83886080U) {
#line 2212
    goto case_83886080;
  }
#line 2247
  if (eabi == 0U) {
#line 2247
    goto case_0;
  }
#line 2120
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 2121
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", <unrecognized EABI>");
  }
#line 2122
  if (e_flags) {
#line 2123
    unknown = 1;
  }
#line 2124
  goto switch_break;
  case_16777216: /* CIL Label */ 
  {
#line 2127
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Version1 EABI");
  }
  {
#line 2128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2128
    if (! e_flags) {
#line 2128
      goto while_break;
    }
#line 2133
    flag = e_flags & - e_flags;
#line 2134
    e_flags &= ~ flag;
    {
#line 2138
    if (flag == 4U) {
#line 2138
      goto case_4;
    }
#line 2142
    goto switch_default___0;
    case_4: /* CIL Label */ 
    {
#line 2139
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", sorted symbol tables");
    }
#line 2140
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 2143
    unknown = 1;
#line 2144
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  goto switch_break;
  case_33554432: /* CIL Label */ 
  {
#line 2150
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Version2 EABI");
  }
  {
#line 2151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2151
    if (! e_flags) {
#line 2151
      goto while_break___0;
    }
#line 2156
    flag___0 = e_flags & - e_flags;
#line 2157
    e_flags &= ~ flag___0;
    {
#line 2161
    if (flag___0 == 4U) {
#line 2161
      goto case_4___0;
    }
#line 2165
    if (flag___0 == 8U) {
#line 2165
      goto case_8;
    }
#line 2169
    if (flag___0 == 16U) {
#line 2169
      goto case_16;
    }
#line 2173
    goto switch_default___1;
    case_4___0: /* CIL Label */ 
    {
#line 2162
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", sorted symbol tables");
    }
#line 2163
    goto switch_break___1;
    case_8: /* CIL Label */ 
    {
#line 2166
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", dynamic symbols use segment index");
    }
#line 2167
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 2170
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", mapping symbols precede others");
    }
#line 2171
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 2174
    unknown = 1;
#line 2175
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2178
  goto switch_break;
  case_50331648: /* CIL Label */ 
  {
#line 2181
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Version3 EABI");
  }
#line 2182
  goto switch_break;
  case_67108864: /* CIL Label */ 
  {
#line 2185
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Version4 EABI");
  }
  {
#line 2186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2186
    if (! e_flags) {
#line 2186
      goto while_break___1;
    }
#line 2191
    flag___1 = e_flags & - e_flags;
#line 2192
    e_flags &= ~ flag___1;
    {
#line 2196
    if (flag___1 == 8388608U) {
#line 2196
      goto case_8388608;
    }
#line 2200
    if (flag___1 == 4194304U) {
#line 2200
      goto case_4194304;
    }
#line 2204
    goto switch_default___2;
    case_8388608: /* CIL Label */ 
    {
#line 2197
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", BE8");
    }
#line 2198
    goto switch_break___2;
    case_4194304: /* CIL Label */ 
    {
#line 2201
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", LE8");
    }
#line 2202
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2205
    unknown = 1;
#line 2206
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 2208
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2210
  goto switch_break;
  case_83886080: /* CIL Label */ 
  {
#line 2213
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Version5 EABI");
  }
  {
#line 2214
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2214
    if (! e_flags) {
#line 2214
      goto while_break___2;
    }
#line 2219
    flag___2 = e_flags & - e_flags;
#line 2220
    e_flags &= ~ flag___2;
    {
#line 2224
    if (flag___2 == 8388608U) {
#line 2224
      goto case_8388608___0;
    }
#line 2228
    if (flag___2 == 4194304U) {
#line 2228
      goto case_4194304___0;
    }
#line 2232
    if (flag___2 == 512U) {
#line 2232
      goto case_512;
    }
#line 2236
    if (flag___2 == 1024U) {
#line 2236
      goto case_1024;
    }
#line 2240
    goto switch_default___3;
    case_8388608___0: /* CIL Label */ 
    {
#line 2225
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", BE8");
    }
#line 2226
    goto switch_break___3;
    case_4194304___0: /* CIL Label */ 
    {
#line 2229
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", LE8");
    }
#line 2230
    goto switch_break___3;
    case_512: /* CIL Label */ 
    {
#line 2233
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", soft-float ABI");
    }
#line 2234
    goto switch_break___3;
    case_1024: /* CIL Label */ 
    {
#line 2237
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", hard-float ABI");
    }
#line 2238
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 2241
    unknown = 1;
#line 2242
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2245
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2248
  strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", GNU EABI");
  }
  {
#line 2249
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2249
    if (! e_flags) {
#line 2249
      goto while_break___3;
    }
#line 2254
    flag___3 = e_flags & - e_flags;
#line 2255
    e_flags &= ~ flag___3;
    {
#line 2259
    if (flag___3 == 4U) {
#line 2259
      goto case_4___1;
    }
#line 2263
    if (flag___3 == 8U) {
#line 2263
      goto case_8___0;
    }
#line 2267
    if (flag___3 == 16U) {
#line 2267
      goto case_16___0;
    }
#line 2271
    if (flag___3 == 32U) {
#line 2271
      goto case_32;
    }
#line 2275
    if (flag___3 == 64U) {
#line 2275
      goto case_64;
    }
#line 2279
    if (flag___3 == 128U) {
#line 2279
      goto case_128;
    }
#line 2283
    if (flag___3 == 256U) {
#line 2283
      goto case_256;
    }
#line 2287
    if (flag___3 == 512U) {
#line 2287
      goto case_512___0;
    }
#line 2291
    if (flag___3 == 1024U) {
#line 2291
      goto case_1024___0;
    }
#line 2295
    if (flag___3 == 2048U) {
#line 2295
      goto case_2048;
    }
#line 2299
    goto switch_default___4;
    case_4___1: /* CIL Label */ 
    {
#line 2260
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", interworking enabled");
    }
#line 2261
    goto switch_break___4;
    case_8___0: /* CIL Label */ 
    {
#line 2264
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", uses APCS/26");
    }
#line 2265
    goto switch_break___4;
    case_16___0: /* CIL Label */ 
    {
#line 2268
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", uses APCS/float");
    }
#line 2269
    goto switch_break___4;
    case_32: /* CIL Label */ 
    {
#line 2272
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", position independent");
    }
#line 2273
    goto switch_break___4;
    case_64: /* CIL Label */ 
    {
#line 2276
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", 8 bit structure alignment");
    }
#line 2277
    goto switch_break___4;
    case_128: /* CIL Label */ 
    {
#line 2280
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", uses new ABI");
    }
#line 2281
    goto switch_break___4;
    case_256: /* CIL Label */ 
    {
#line 2284
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", uses old ABI");
    }
#line 2285
    goto switch_break___4;
    case_512___0: /* CIL Label */ 
    {
#line 2288
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", software FP");
    }
#line 2289
    goto switch_break___4;
    case_1024___0: /* CIL Label */ 
    {
#line 2292
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", VFP");
    }
#line 2293
    goto switch_break___4;
    case_2048: /* CIL Label */ 
    {
#line 2296
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)", Maverick FP");
    }
#line 2297
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 2300
    unknown = 1;
#line 2301
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 2306
  if (unknown) {
    {
#line 2307
    tmp___0 = gettext(", <unknown>");
#line 2307
    strcat((char */* __restrict  */)buf___7, (char const   */* __restrict  */)tmp___0);
    }
  }
#line 2308
  return;
}
}
#line 2313 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buf___5[1024]  ;
#line 2310 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *get_machine_flags(unsigned int e_flags , unsigned int e_machine ) 
{ 
  char const   *isa ;
  char *tmp___0 ;
  char const   *mac ;
  char *tmp___1 ;
  char const   *additional ;
  char *tmp___2 ;
  char *tmp___3 ;
  char abi[8] ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 2315
  buf___5[0] = (char )'\000';
#line 2317
  if (e_flags) {
    {
#line 2324
    if (e_machine == 40U) {
#line 2324
      goto case_40;
    }
#line 2328
    if (e_machine == 106U) {
#line 2328
      goto case_106;
    }
#line 2343
    if (e_machine == 21569U) {
#line 2343
      goto case_21569;
    }
#line 2384
    if (e_machine == 4U) {
#line 2384
      goto case_4;
    }
#line 2453
    if (e_machine == 20U) {
#line 2453
      goto case_20;
    }
#line 2464
    if (e_machine == 21U) {
#line 2464
      goto case_21;
    }
#line 2474
    if (e_machine == 36U) {
#line 2474
      goto case_36;
    }
#line 2525
    if (e_machine == 36992U) {
#line 2525
      goto case_36992;
    }
#line 2525
    if (e_machine == 87U) {
#line 2525
      goto case_36992;
    }
#line 2553
    if (e_machine == 36929U) {
#line 2553
      goto case_36929;
    }
#line 2553
    if (e_machine == 88U) {
#line 2553
      goto case_36929;
    }
#line 2559
    if (e_machine == 10U) {
#line 2559
      goto case_10;
    }
#line 2559
    if (e_machine == 8U) {
#line 2559
      goto case_10;
    }
#line 2652
    if (e_machine == 42U) {
#line 2652
      goto case_42;
    }
#line 2686
    if (e_machine == 43U) {
#line 2686
      goto case_43;
    }
#line 2712
    if (e_machine == 15U) {
#line 2712
      goto case_15;
    }
#line 2742
    if (e_machine == 99U) {
#line 2742
      goto case_99;
    }
#line 2742
    if (e_machine == 91U) {
#line 2742
      goto case_99;
    }
#line 2750
    if (e_machine == 50U) {
#line 2750
      goto case_50;
    }
#line 2786
    if (e_machine == 75U) {
#line 2786
      goto case_75;
    }
#line 2795
    if (e_machine == 197U) {
#line 2795
      goto case_197;
    }
#line 2800
    if (e_machine == 173U) {
#line 2800
      goto case_173;
    }
#line 2811
    if (e_machine == 22U) {
#line 2811
      goto case_22___0;
    }
#line 2816
    if (e_machine == 140U) {
#line 2816
      goto case_140;
    }
#line 2821
    if (e_machine == 105U) {
#line 2821
      goto case_105;
    }
#line 2321
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 2322
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 2325
    decode_ARM_machine_flags(e_flags, buf___5);
    }
#line 2326
    goto switch_break;
    case_106: /* CIL Label */ 
#line 2329
    if (e_flags & 1U) {
      {
#line 2330
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", PIC");
      }
    }
#line 2332
    if (e_flags & 2U) {
      {
#line 2333
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", FDPIC");
      }
    }
#line 2335
    if (e_flags & 16U) {
      {
#line 2336
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", code in L1");
      }
    }
#line 2338
    if (e_flags & 32U) {
      {
#line 2339
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", data in L1");
      }
    }
#line 2341
    goto switch_break;
    case_21569: /* CIL Label */ 
    {
#line 2346
    if ((e_flags & 4278190080U) == 0U) {
#line 2346
      goto case_0;
    }
#line 2353
    if ((e_flags & 4278190080U) == 33554432U) {
#line 2353
      goto case_33554432;
    }
#line 2357
    if ((e_flags & 4278190080U) == 83886080U) {
#line 2357
      goto case_83886080;
    }
#line 2360
    if ((e_flags & 4278190080U) == 117440512U) {
#line 2360
      goto case_117440512;
    }
#line 2364
    if ((e_flags & 4278190080U) == 134217728U) {
#line 2364
      goto case_134217728;
    }
#line 2368
    if ((e_flags & 4278190080U) == 16777216U) {
#line 2368
      goto case_16777216;
    }
#line 2371
    if ((e_flags & 4278190080U) == 100663296U) {
#line 2371
      goto case_100663296;
    }
#line 2375
    if ((e_flags & 4278190080U) == 50331648U) {
#line 2375
      goto case_50331648;
    }
#line 2378
    if ((e_flags & 4278190080U) == 67108864U) {
#line 2378
      goto case_67108864;
    }
#line 2349
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 2347
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2350
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr???");
    }
#line 2351
    goto switch_break___0;
    case_33554432: /* CIL Label */ 
    {
#line 2354
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr300");
    }
#line 2355
    goto switch_break___0;
    case_83886080: /* CIL Label */ 
    {
#line 2358
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr400");
    }
#line 2359
    goto switch_break___0;
    case_117440512: /* CIL Label */ 
    {
#line 2361
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr405");
    }
#line 2362
    goto switch_break___0;
    case_134217728: /* CIL Label */ 
    {
#line 2365
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr450");
    }
#line 2366
    goto switch_break___0;
    case_16777216: /* CIL Label */ 
    {
#line 2369
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr500");
    }
#line 2370
    goto switch_break___0;
    case_100663296: /* CIL Label */ 
    {
#line 2372
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fr550");
    }
#line 2373
    goto switch_break___0;
    case_50331648: /* CIL Label */ 
    {
#line 2376
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", simple");
    }
#line 2377
    goto switch_break___0;
    case_67108864: /* CIL Label */ 
    {
#line 2379
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", tomcat");
    }
#line 2380
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2382
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2385
    if ((e_flags & 58818560U) == 16777216U) {
      {
#line 2386
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", m68000");
      }
    } else
#line 2387
    if ((e_flags & 58818560U) == 8454144U) {
      {
#line 2388
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", cpu32");
      }
    } else
#line 2389
    if ((e_flags & 58818560U) == 33554432U) {
      {
#line 2390
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fido_a");
      }
    } else {
      {
#line 2393
      tmp___0 = gettext("unknown");
#line 2393
      isa = (char const   *)tmp___0;
#line 2394
      tmp___1 = gettext("unknown mac");
#line 2394
      mac = (char const   *)tmp___1;
#line 2395
      additional = (char const   *)((void *)0);
      }
      {
#line 2399
      if ((e_flags & 15U) == 1U) {
#line 2399
        goto case_1;
      }
#line 2403
      if ((e_flags & 15U) == 2U) {
#line 2403
        goto case_2;
      }
#line 2406
      if ((e_flags & 15U) == 3U) {
#line 2406
        goto case_3;
      }
#line 2409
      if ((e_flags & 15U) == 4U) {
#line 2409
        goto case_4___0;
      }
#line 2413
      if ((e_flags & 15U) == 5U) {
#line 2413
        goto case_5;
      }
#line 2416
      if ((e_flags & 15U) == 6U) {
#line 2416
        goto case_6;
      }
#line 2419
      if ((e_flags & 15U) == 7U) {
#line 2419
        goto case_7;
      }
#line 2397
      goto switch_break___1;
      case_1: /* CIL Label */ 
#line 2400
      isa = "A";
#line 2401
      additional = ", nodiv";
#line 2402
      goto switch_break___1;
      case_2: /* CIL Label */ 
#line 2404
      isa = "A";
#line 2405
      goto switch_break___1;
      case_3: /* CIL Label */ 
#line 2407
      isa = "A+";
#line 2408
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 2410
      isa = "B";
#line 2411
      additional = ", nousp";
#line 2412
      goto switch_break___1;
      case_5: /* CIL Label */ 
#line 2414
      isa = "B";
#line 2415
      goto switch_break___1;
      case_6: /* CIL Label */ 
#line 2417
      isa = "C";
#line 2418
      goto switch_break___1;
      case_7: /* CIL Label */ 
#line 2420
      isa = "C";
#line 2421
      additional = ", nodiv";
#line 2422
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 2424
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", cf, isa ");
#line 2425
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)isa);
      }
#line 2426
      if (additional) {
        {
#line 2427
        strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)additional);
        }
      }
#line 2428
      if (e_flags & 64U) {
        {
#line 2429
        strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", float");
        }
      }
      {
#line 2432
      if ((e_flags & 48U) == 0U) {
#line 2432
        goto case_0___0;
      }
#line 2435
      if ((e_flags & 48U) == 16U) {
#line 2435
        goto case_16;
      }
#line 2438
      if ((e_flags & 48U) == 32U) {
#line 2438
        goto case_32;
      }
#line 2441
      if ((e_flags & 48U) == 48U) {
#line 2441
        goto case_48;
      }
#line 2430
      goto switch_break___2;
      case_0___0: /* CIL Label */ 
#line 2433
      mac = (char const   *)((void *)0);
#line 2434
      goto switch_break___2;
      case_16: /* CIL Label */ 
#line 2436
      mac = "mac";
#line 2437
      goto switch_break___2;
      case_32: /* CIL Label */ 
#line 2439
      mac = "emac";
#line 2440
      goto switch_break___2;
      case_48: /* CIL Label */ 
#line 2442
      mac = "emac_b";
#line 2443
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 2445
      if (mac) {
        {
#line 2447
        strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ");
#line 2448
        strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)mac);
        }
      }
    }
#line 2451
    goto switch_break;
    case_20: /* CIL Label */ 
#line 2454
    if (e_flags & 2147483648U) {
      {
#line 2455
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", emb");
      }
    }
#line 2457
    if (e_flags & 65536U) {
      {
#line 2458
      tmp___2 = gettext(", relocatable");
#line 2458
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___2);
      }
    }
#line 2460
    if (e_flags & 32768U) {
      {
#line 2461
      tmp___3 = gettext(", relocatable-lib");
#line 2461
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___3);
      }
    }
#line 2462
    goto switch_break;
    case_21: /* CIL Label */ 
#line 2465
    if (e_flags & 3U) {
      {
#line 2467
      abi[0] = (char )',';
#line 2467
      abi[1] = (char )' ';
#line 2467
      abi[2] = (char )'a';
#line 2467
      abi[3] = (char )'b';
#line 2467
      abi[4] = (char )'i';
#line 2467
      abi[5] = (char )'v';
#line 2467
      abi[6] = (char )'0';
#line 2467
      abi[7] = (char )'\000';
#line 2469
      abi[6] = (char )((unsigned int )abi[6] + (e_flags & 3U));
#line 2470
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)(abi));
      }
    }
#line 2472
    goto switch_break;
    case_36: /* CIL Label */ 
#line 2475
    if ((e_flags & 4026531840U) == 4026531840U) {
      {
#line 2476
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", RH850 ABI");
      }
    }
#line 2478
    if (e_flags & 1048576U) {
      {
#line 2479
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", V3 architecture");
      }
    }
#line 2481
    if ((e_flags & 3U) == 0U) {
      {
#line 2482
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", FPU not used");
      }
    }
#line 2484
    if ((e_flags & 96U) == 0U) {
      {
#line 2485
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", regmode: COMMON");
      }
    }
#line 2487
    if ((e_flags & 768U) == 0U) {
      {
#line 2488
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r4 not used");
      }
    }
#line 2490
    if ((e_flags & 3072U) == 0U) {
      {
#line 2491
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r30 not used");
      }
    }
#line 2493
    if ((e_flags & 12288U) == 0U) {
      {
#line 2494
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r5 not used");
      }
    }
#line 2496
    if ((e_flags & 49152U) == 0U) {
      {
#line 2497
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r2 not used");
      }
    }
#line 2499
    e_flags &= 65535U;
    {
#line 2499
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2499
      if (! e_flags) {
#line 2499
        goto while_break;
      }
      {
#line 2503
      if ((e_flags & - e_flags) == 1U) {
#line 2503
        goto case_1___0;
      }
#line 2504
      if ((e_flags & - e_flags) == 2U) {
#line 2504
        goto case_2___0;
      }
#line 2505
      if ((e_flags & - e_flags) == 4U) {
#line 2505
        goto case_4___1;
      }
#line 2506
      if ((e_flags & - e_flags) == 8U) {
#line 2506
        goto case_8;
      }
#line 2507
      if ((e_flags & - e_flags) == 16U) {
#line 2507
        goto case_16___0;
      }
#line 2508
      if ((e_flags & - e_flags) == 32U) {
#line 2508
        goto case_32___0;
      }
#line 2509
      if ((e_flags & - e_flags) == 64U) {
#line 2509
        goto case_64;
      }
#line 2510
      if ((e_flags & - e_flags) == 128U) {
#line 2510
        goto case_128;
      }
#line 2511
      if ((e_flags & - e_flags) == 256U) {
#line 2511
        goto case_256;
      }
#line 2512
      if ((e_flags & - e_flags) == 512U) {
#line 2512
        goto case_512;
      }
#line 2513
      if ((e_flags & - e_flags) == 1024U) {
#line 2513
        goto case_1024;
      }
#line 2514
      if ((e_flags & - e_flags) == 2048U) {
#line 2514
        goto case_2048;
      }
#line 2515
      if ((e_flags & - e_flags) == 4096U) {
#line 2515
        goto case_4096;
      }
#line 2516
      if ((e_flags & - e_flags) == 8192U) {
#line 2516
        goto case_8192;
      }
#line 2517
      if ((e_flags & - e_flags) == 16384U) {
#line 2517
        goto case_16384;
      }
#line 2518
      if ((e_flags & - e_flags) == 32768U) {
#line 2518
        goto case_32768;
      }
#line 2519
      goto switch_default___1;
      case_1___0: /* CIL Label */ 
      {
#line 2503
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", double precision FPU");
      }
#line 2503
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 2504
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", single precision FPU");
      }
#line 2504
      goto switch_break___3;
      case_4___1: /* CIL Label */ 
      {
#line 2505
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", SIMD");
      }
#line 2505
      goto switch_break___3;
      case_8: /* CIL Label */ 
      {
#line 2506
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", CACHE");
      }
#line 2506
      goto switch_break___3;
      case_16___0: /* CIL Label */ 
      {
#line 2507
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", MMU");
      }
#line 2507
      goto switch_break___3;
      case_32___0: /* CIL Label */ 
      {
#line 2508
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", regmode:22");
      }
#line 2508
      goto switch_break___3;
      case_64: /* CIL Label */ 
      {
#line 2509
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", regmode:23");
      }
#line 2509
      goto switch_break___3;
      case_128: /* CIL Label */ 
      {
#line 2510
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 8-byte alignment");
      }
#line 2510
      goto switch_break___3;
      case_256: /* CIL Label */ 
      {
#line 2511
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r4 fixed");
      }
#line 2511
      goto switch_break___3;
      case_512: /* CIL Label */ 
      {
#line 2512
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r4 free");
      }
#line 2512
      goto switch_break___3;
      case_1024: /* CIL Label */ 
      {
#line 2513
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r30 fixed");
      }
#line 2513
      goto switch_break___3;
      case_2048: /* CIL Label */ 
      {
#line 2514
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r30 free");
      }
#line 2514
      goto switch_break___3;
      case_4096: /* CIL Label */ 
      {
#line 2515
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r5 fixed");
      }
#line 2515
      goto switch_break___3;
      case_8192: /* CIL Label */ 
      {
#line 2516
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r5 free");
      }
#line 2516
      goto switch_break___3;
      case_16384: /* CIL Label */ 
      {
#line 2517
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r2 fixed");
      }
#line 2517
      goto switch_break___3;
      case_32768: /* CIL Label */ 
      {
#line 2518
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", r2 free");
      }
#line 2518
      goto switch_break___3;
      switch_default___1: /* CIL Label */ 
#line 2519
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 2499
      e_flags &= ~ (e_flags & - e_flags);
    }
    while_break: /* CIL Label */ ;
    }
#line 2522
    goto switch_break;
    case_36992: /* CIL Label */ 
    case_87: /* CIL Label */ 
    {
#line 2528
    if ((e_flags & 4026531840U) == 1610612736U) {
#line 2528
      goto case_1610612736;
    }
#line 2531
    if ((e_flags & 4026531840U) == 1073741824U) {
#line 2531
      goto case_1073741824;
    }
#line 2534
    if ((e_flags & 4026531840U) == 805306368U) {
#line 2534
      goto case_805306368;
    }
#line 2537
    if ((e_flags & 4026531840U) == 536870912U) {
#line 2537
      goto case_536870912;
    }
#line 2540
    if ((e_flags & 4026531840U) == 268435456U) {
#line 2540
      goto case_268435456;
    }
#line 2543
    if ((e_flags & 4026531840U) == 0U) {
#line 2543
      goto case_0___1;
    }
#line 2546
    goto switch_default___2;
    case_1610612736: /* CIL Label */ 
    {
#line 2529
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850e3v5");
    }
#line 2530
    goto switch_break___4;
    case_1073741824: /* CIL Label */ 
    {
#line 2532
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850e2v3");
    }
#line 2533
    goto switch_break___4;
    case_805306368: /* CIL Label */ 
    {
#line 2535
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850e2");
    }
#line 2536
    goto switch_break___4;
    case_536870912: /* CIL Label */ 
    {
#line 2538
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850e1");
    }
#line 2539
    goto switch_break___4;
    case_268435456: /* CIL Label */ 
    {
#line 2541
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850e");
    }
#line 2542
    goto switch_break___4;
    case_0___1: /* CIL Label */ 
    {
#line 2544
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v850");
    }
#line 2545
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
    {
#line 2547
    tmp___4 = gettext(", unknown v850 architecture variant");
#line 2547
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___4);
    }
#line 2548
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 2550
    goto switch_break;
    case_36929: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 2554
    if ((e_flags & 805306368U) == 0U) {
      {
#line 2555
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", m32r");
      }
    }
#line 2556
    goto switch_break;
    case_10: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
#line 2560
    if (e_flags & 1U) {
      {
#line 2561
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", noreorder");
      }
    }
#line 2563
    if (e_flags & 2U) {
      {
#line 2564
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", pic");
      }
    }
#line 2566
    if (e_flags & 4U) {
      {
#line 2567
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", cpic");
      }
    }
#line 2569
    if (e_flags & 16U) {
      {
#line 2570
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ugen_reserved");
      }
    }
#line 2572
    if (e_flags & 32U) {
      {
#line 2573
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", abi2");
      }
    }
#line 2575
    if (e_flags & 128U) {
      {
#line 2576
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", odk first");
      }
    }
#line 2578
    if (e_flags & 256U) {
      {
#line 2579
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 32bitmode");
      }
    }
#line 2581
    if (e_flags & 1024U) {
      {
#line 2582
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", nan2008");
      }
    }
#line 2584
    if (e_flags & 512U) {
      {
#line 2585
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fp64");
      }
    }
    {
#line 2589
    if ((e_flags & 16711680U) == 8454144U) {
#line 2589
      goto case_8454144;
    }
#line 2590
    if ((e_flags & 16711680U) == 8519680U) {
#line 2590
      goto case_8519680;
    }
#line 2591
    if ((e_flags & 16711680U) == 8585216U) {
#line 2591
      goto case_8585216;
    }
#line 2592
    if ((e_flags & 16711680U) == 8912896U) {
#line 2592
      goto case_8912896;
    }
#line 2593
    if ((e_flags & 16711680U) == 8847360U) {
#line 2593
      goto case_8847360;
    }
#line 2594
    if ((e_flags & 16711680U) == 8716288U) {
#line 2594
      goto case_8716288;
    }
#line 2595
    if ((e_flags & 16711680U) == 9502720U) {
#line 2595
      goto case_9502720;
    }
#line 2596
    if ((e_flags & 16711680U) == 9961472U) {
#line 2596
      goto case_9961472;
    }
#line 2597
    if ((e_flags & 16711680U) == 9043968U) {
#line 2597
      goto case_9043968;
    }
#line 2598
    if ((e_flags & 16711680U) == 10027008U) {
#line 2598
      goto case_10027008;
    }
#line 2599
    if ((e_flags & 16711680U) == 10485760U) {
#line 2599
      goto case_10485760;
    }
#line 2600
    if ((e_flags & 16711680U) == 10551296U) {
#line 2600
      goto case_10551296;
    }
#line 2601
    if ((e_flags & 16711680U) == 10616832U) {
#line 2601
      goto case_10616832;
    }
#line 2602
    if ((e_flags & 16711680U) == 9109504U) {
#line 2602
      goto case_9109504;
    }
#line 2603
    if ((e_flags & 16711680U) == 9240576U) {
#line 2603
      goto case_9240576;
    }
#line 2604
    if ((e_flags & 16711680U) == 9175040U) {
#line 2604
      goto case_9175040;
    }
#line 2605
    if ((e_flags & 16711680U) == 0U) {
#line 2605
      goto case_0___2;
    }
#line 2610
    goto switch_default___3;
    case_8454144: /* CIL Label */ 
    {
#line 2589
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 3900");
    }
#line 2589
    goto switch_break___5;
    case_8519680: /* CIL Label */ 
    {
#line 2590
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 4010");
    }
#line 2590
    goto switch_break___5;
    case_8585216: /* CIL Label */ 
    {
#line 2591
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 4100");
    }
#line 2591
    goto switch_break___5;
    case_8912896: /* CIL Label */ 
    {
#line 2592
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 4111");
    }
#line 2592
    goto switch_break___5;
    case_8847360: /* CIL Label */ 
    {
#line 2593
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 4120");
    }
#line 2593
    goto switch_break___5;
    case_8716288: /* CIL Label */ 
    {
#line 2594
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 4650");
    }
#line 2594
    goto switch_break___5;
    case_9502720: /* CIL Label */ 
    {
#line 2595
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 5400");
    }
#line 2595
    goto switch_break___5;
    case_9961472: /* CIL Label */ 
    {
#line 2596
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 5500");
    }
#line 2596
    goto switch_break___5;
    case_9043968: /* CIL Label */ 
    {
#line 2597
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sb1");
    }
#line 2597
    goto switch_break___5;
    case_10027008: /* CIL Label */ 
    {
#line 2598
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 9000");
    }
#line 2598
    goto switch_break___5;
    case_10485760: /* CIL Label */ 
    {
#line 2599
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", loongson-2e");
    }
#line 2599
    goto switch_break___5;
    case_10551296: /* CIL Label */ 
    {
#line 2600
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", loongson-2f");
    }
#line 2600
    goto switch_break___5;
    case_10616832: /* CIL Label */ 
    {
#line 2601
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", loongson-3a");
    }
#line 2601
    goto switch_break___5;
    case_9109504: /* CIL Label */ 
    {
#line 2602
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", octeon");
    }
#line 2602
    goto switch_break___5;
    case_9240576: /* CIL Label */ 
    {
#line 2603
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", octeon2");
    }
#line 2603
    goto switch_break___5;
    case_9175040: /* CIL Label */ 
    {
#line 2604
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", xlr");
    }
#line 2604
    goto switch_break___5;
    case_0___2: /* CIL Label */ 
#line 2609
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
    {
#line 2610
    tmp___5 = gettext(", unknown CPU");
#line 2610
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___5);
    }
#line 2610
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
    {
#line 2615
    if ((e_flags & 61440U) == 4096U) {
#line 2615
      goto case_4096___0;
    }
#line 2616
    if ((e_flags & 61440U) == 8192U) {
#line 2616
      goto case_8192___0;
    }
#line 2617
    if ((e_flags & 61440U) == 12288U) {
#line 2617
      goto case_12288;
    }
#line 2618
    if ((e_flags & 61440U) == 16384U) {
#line 2618
      goto case_16384___0;
    }
#line 2619
    if ((e_flags & 61440U) == 0U) {
#line 2619
      goto case_0___3;
    }
#line 2625
    goto switch_default___4;
    case_4096___0: /* CIL Label */ 
    {
#line 2615
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", o32");
    }
#line 2615
    goto switch_break___6;
    case_8192___0: /* CIL Label */ 
    {
#line 2616
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", o64");
    }
#line 2616
    goto switch_break___6;
    case_12288: /* CIL Label */ 
    {
#line 2617
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", eabi32");
    }
#line 2617
    goto switch_break___6;
    case_16384___0: /* CIL Label */ 
    {
#line 2618
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", eabi64");
    }
#line 2618
    goto switch_break___6;
    case_0___3: /* CIL Label */ 
#line 2624
    goto switch_break___6;
    switch_default___4: /* CIL Label */ 
    {
#line 2625
    tmp___6 = gettext(", unknown ABI");
#line 2625
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___6);
    }
#line 2625
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 2628
    if (e_flags & 134217728U) {
      {
#line 2629
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mdmx");
      }
    }
#line 2631
    if (e_flags & 67108864U) {
      {
#line 2632
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips16");
      }
    }
#line 2634
    if (e_flags & 33554432U) {
      {
#line 2635
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", micromips");
      }
    }
    {
#line 2639
    if ((e_flags & 4026531840U) == 0U) {
#line 2639
      goto case_0___4;
    }
#line 2640
    if ((e_flags & 4026531840U) == 268435456U) {
#line 2640
      goto case_268435456___0;
    }
#line 2641
    if ((e_flags & 4026531840U) == 536870912U) {
#line 2641
      goto case_536870912___0;
    }
#line 2642
    if ((e_flags & 4026531840U) == 805306368U) {
#line 2642
      goto case_805306368___0;
    }
#line 2643
    if ((e_flags & 4026531840U) == 1073741824U) {
#line 2643
      goto case_1073741824___0;
    }
#line 2644
    if ((e_flags & 4026531840U) == 1342177280U) {
#line 2644
      goto case_1342177280;
    }
#line 2645
    if ((e_flags & 4026531840U) == 1879048192U) {
#line 2645
      goto case_1879048192;
    }
#line 2646
    if ((e_flags & 4026531840U) == 1610612736U) {
#line 2646
      goto case_1610612736___0;
    }
#line 2647
    if ((e_flags & 4026531840U) == 2147483648U) {
#line 2647
      goto case_2147483648;
    }
#line 2648
    goto switch_default___5;
    case_0___4: /* CIL Label */ 
    {
#line 2639
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips1");
    }
#line 2639
    goto switch_break___7;
    case_268435456___0: /* CIL Label */ 
    {
#line 2640
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips2");
    }
#line 2640
    goto switch_break___7;
    case_536870912___0: /* CIL Label */ 
    {
#line 2641
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips3");
    }
#line 2641
    goto switch_break___7;
    case_805306368___0: /* CIL Label */ 
    {
#line 2642
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips4");
    }
#line 2642
    goto switch_break___7;
    case_1073741824___0: /* CIL Label */ 
    {
#line 2643
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips5");
    }
#line 2643
    goto switch_break___7;
    case_1342177280: /* CIL Label */ 
    {
#line 2644
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips32");
    }
#line 2644
    goto switch_break___7;
    case_1879048192: /* CIL Label */ 
    {
#line 2645
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips32r2");
    }
#line 2645
    goto switch_break___7;
    case_1610612736___0: /* CIL Label */ 
    {
#line 2646
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips64");
    }
#line 2646
    goto switch_break___7;
    case_2147483648: /* CIL Label */ 
    {
#line 2647
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", mips64r2");
    }
#line 2647
    goto switch_break___7;
    switch_default___5: /* CIL Label */ 
    {
#line 2648
    tmp___7 = gettext(", unknown ISA");
#line 2648
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___7);
    }
#line 2648
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
#line 2650
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 2655
    if ((e_flags & 31U) == 1U) {
#line 2655
      goto case_1___1;
    }
#line 2656
    if ((e_flags & 31U) == 2U) {
#line 2656
      goto case_2___1;
    }
#line 2657
    if ((e_flags & 31U) == 3U) {
#line 2657
      goto case_3___0;
    }
#line 2658
    if ((e_flags & 31U) == 4U) {
#line 2658
      goto case_4___2;
    }
#line 2659
    if ((e_flags & 31U) == 5U) {
#line 2659
      goto case_5___0;
    }
#line 2660
    if ((e_flags & 31U) == 6U) {
#line 2660
      goto case_6___0;
    }
#line 2661
    if ((e_flags & 31U) == 8U) {
#line 2661
      goto case_8___1;
    }
#line 2662
    if ((e_flags & 31U) == 9U) {
#line 2662
      goto case_9;
    }
#line 2663
    if ((e_flags & 31U) == 10U) {
#line 2663
      goto case_10___0;
    }
#line 2664
    if ((e_flags & 31U) == 11U) {
#line 2664
      goto case_11;
    }
#line 2665
    if ((e_flags & 31U) == 12U) {
#line 2665
      goto case_12;
    }
#line 2666
    if ((e_flags & 31U) == 13U) {
#line 2666
      goto case_13;
    }
#line 2667
    if ((e_flags & 31U) == 16U) {
#line 2667
      goto case_16___1;
    }
#line 2668
    if ((e_flags & 31U) == 17U) {
#line 2668
      goto case_17;
    }
#line 2669
    if ((e_flags & 31U) == 19U) {
#line 2669
      goto case_19;
    }
#line 2670
    if ((e_flags & 31U) == 20U) {
#line 2670
      goto case_20___0;
    }
#line 2671
    if ((e_flags & 31U) == 18U) {
#line 2671
      goto case_18;
    }
#line 2672
    if ((e_flags & 31U) == 21U) {
#line 2672
      goto case_21___0;
    }
#line 2673
    if ((e_flags & 31U) == 22U) {
#line 2673
      goto case_22;
    }
#line 2674
    if ((e_flags & 31U) == 23U) {
#line 2674
      goto case_23;
    }
#line 2675
    if ((e_flags & 31U) == 24U) {
#line 2675
      goto case_24;
    }
#line 2676
    goto switch_default___6;
    case_1___1: /* CIL Label */ 
    {
#line 2655
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh1");
    }
#line 2655
    goto switch_break___8;
    case_2___1: /* CIL Label */ 
    {
#line 2656
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2");
    }
#line 2656
    goto switch_break___8;
    case_3___0: /* CIL Label */ 
    {
#line 2657
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh3");
    }
#line 2657
    goto switch_break___8;
    case_4___2: /* CIL Label */ 
    {
#line 2658
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh-dsp");
    }
#line 2658
    goto switch_break___8;
    case_5___0: /* CIL Label */ 
    {
#line 2659
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh3-dsp");
    }
#line 2659
    goto switch_break___8;
    case_6___0: /* CIL Label */ 
    {
#line 2660
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4al-dsp");
    }
#line 2660
    goto switch_break___8;
    case_8___1: /* CIL Label */ 
    {
#line 2661
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh3e");
    }
#line 2661
    goto switch_break___8;
    case_9: /* CIL Label */ 
    {
#line 2662
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4");
    }
#line 2662
    goto switch_break___8;
    case_10___0: /* CIL Label */ 
    {
#line 2663
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh5");
    }
#line 2663
    goto switch_break___8;
    case_11: /* CIL Label */ 
    {
#line 2664
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2e");
    }
#line 2664
    goto switch_break___8;
    case_12: /* CIL Label */ 
    {
#line 2665
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4a");
    }
#line 2665
    goto switch_break___8;
    case_13: /* CIL Label */ 
    {
#line 2666
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a");
    }
#line 2666
    goto switch_break___8;
    case_16___1: /* CIL Label */ 
    {
#line 2667
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4-nofpu");
    }
#line 2667
    goto switch_break___8;
    case_17: /* CIL Label */ 
    {
#line 2668
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4a-nofpu");
    }
#line 2668
    goto switch_break___8;
    case_19: /* CIL Label */ 
    {
#line 2669
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a-nofpu");
    }
#line 2669
    goto switch_break___8;
    case_20___0: /* CIL Label */ 
    {
#line 2670
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh3-nommu");
    }
#line 2670
    goto switch_break___8;
    case_18: /* CIL Label */ 
    {
#line 2671
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh4-nommu-nofpu");
    }
#line 2671
    goto switch_break___8;
    case_21___0: /* CIL Label */ 
    {
#line 2672
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a-nofpu-or-sh4-nommu-nofpu");
    }
#line 2672
    goto switch_break___8;
    case_22: /* CIL Label */ 
    {
#line 2673
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a-nofpu-or-sh3-nommu");
    }
#line 2673
    goto switch_break___8;
    case_23: /* CIL Label */ 
    {
#line 2674
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a-or-sh4");
    }
#line 2674
    goto switch_break___8;
    case_24: /* CIL Label */ 
    {
#line 2675
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", sh2a-or-sh3e");
    }
#line 2675
    goto switch_break___8;
    switch_default___6: /* CIL Label */ 
    {
#line 2676
    tmp___8 = gettext(", unknown ISA");
#line 2676
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___8);
    }
#line 2676
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 2679
    if (e_flags & 256U) {
      {
#line 2680
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", pic");
      }
    }
#line 2682
    if (e_flags & 32768U) {
      {
#line 2683
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", fdpic");
      }
    }
#line 2684
    goto switch_break;
    case_43: /* CIL Label */ 
#line 2687
    if (e_flags & 256U) {
      {
#line 2688
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", v8+");
      }
    }
#line 2690
    if (e_flags & 512U) {
      {
#line 2691
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ultrasparcI");
      }
    }
#line 2693
    if (e_flags & 2048U) {
      {
#line 2694
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ultrasparcIII");
      }
    }
#line 2696
    if (e_flags & 1024U) {
      {
#line 2697
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", halr1");
      }
    }
#line 2699
    if (e_flags & 8388608U) {
      {
#line 2700
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ledata");
      }
    }
#line 2702
    if ((e_flags & 3U) == 0U) {
      {
#line 2703
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", tso");
      }
    }
#line 2705
    if ((e_flags & 3U) == 1U) {
      {
#line 2706
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", pso");
      }
    }
#line 2708
    if ((e_flags & 3U) == 2U) {
      {
#line 2709
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", rmo");
      }
    }
#line 2710
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 2715
    if ((e_flags & 65535U) == 523U) {
#line 2715
      goto case_523;
    }
#line 2718
    if ((e_flags & 65535U) == 528U) {
#line 2718
      goto case_528;
    }
#line 2721
    if ((e_flags & 65535U) == 532U) {
#line 2721
      goto case_532;
    }
#line 2724
    goto switch_default___7;
    case_523: /* CIL Label */ 
    {
#line 2716
    strcpy((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", PA-RISC 1.0");
    }
#line 2717
    goto switch_break___9;
    case_528: /* CIL Label */ 
    {
#line 2719
    strcpy((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", PA-RISC 1.1");
    }
#line 2720
    goto switch_break___9;
    case_532: /* CIL Label */ 
    {
#line 2722
    strcpy((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", PA-RISC 2.0");
    }
#line 2723
    goto switch_break___9;
    switch_default___7: /* CIL Label */ 
#line 2725
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 2727
    if (e_flags & 65536U) {
      {
#line 2728
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", trapnil");
      }
    }
#line 2729
    if (e_flags & 131072U) {
      {
#line 2730
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", ext");
      }
    }
#line 2731
    if (e_flags & 262144U) {
      {
#line 2732
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", lsb");
      }
    }
#line 2733
    if (e_flags & 524288U) {
      {
#line 2734
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", wide");
      }
    }
#line 2735
    if (e_flags & 1048576U) {
      {
#line 2736
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", no kabp");
      }
    }
#line 2737
    if (e_flags & 4194304U) {
      {
#line 2738
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", lazyswap");
      }
    }
#line 2739
    goto switch_break;
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 2743
    if ((e_flags & 16U) == 16U) {
      {
#line 2744
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", new calling convention");
      }
    }
#line 2746
    if ((e_flags & 32U) == 32U) {
      {
#line 2747
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", gnu calling convention");
      }
    }
#line 2748
    goto switch_break;
    case_50: /* CIL Label */ 
#line 2751
    if (e_flags & (unsigned int )(1 << 4)) {
      {
#line 2752
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 64-bit");
      }
    } else {
      {
#line 2754
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 32-bit");
      }
    }
#line 2755
    if (e_flags & (unsigned int )(1 << 5)) {
      {
#line 2756
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", reduced fp model");
      }
    }
#line 2757
    if (e_flags & (unsigned int )(1 << 7)) {
      {
#line 2758
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", no function descriptors, constant gp");
      }
    } else
#line 2759
    if (e_flags & (unsigned int )(1 << 6)) {
      {
#line 2760
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", constant gp");
      }
    }
#line 2761
    if (e_flags & (unsigned int )(1 << 8)) {
      {
#line 2762
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", absolute");
      }
    }
#line 2763
    if ((int )elf_header.e_ident[7] == 13) {
#line 2765
      if (e_flags & 4U) {
        {
#line 2766
        strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", vms_linkages");
        }
      }
      {
#line 2769
      if ((e_flags & 3U) == 0U) {
#line 2769
        goto case_0___5;
      }
#line 2771
      if ((e_flags & 3U) == 1U) {
#line 2771
        goto case_1___2;
      }
#line 2774
      if ((e_flags & 3U) == 2U) {
#line 2774
        goto case_2___2;
      }
#line 2777
      if ((e_flags & 3U) == 3U) {
#line 2777
        goto case_3___1;
      }
#line 2780
      goto switch_default___8;
      case_0___5: /* CIL Label */ 
#line 2770
      goto switch_break___10;
      case_1___2: /* CIL Label */ 
      {
#line 2772
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", warning");
      }
#line 2773
      goto switch_break___10;
      case_2___2: /* CIL Label */ 
      {
#line 2775
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", error");
      }
#line 2776
      goto switch_break___10;
      case_3___1: /* CIL Label */ 
      {
#line 2778
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", abort");
      }
#line 2779
      goto switch_break___10;
      switch_default___8: /* CIL Label */ 
      {
#line 2781
      abort();
      }
      switch_break___10: /* CIL Label */ ;
      }
    }
#line 2784
    goto switch_break;
    case_75: /* CIL Label */ 
#line 2787
    if (e_flags & 1U) {
      {
#line 2788
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", non-PIC");
      }
    }
#line 2789
    if (e_flags & 256U) {
      {
#line 2790
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", D-Float");
      }
    }
#line 2791
    if (e_flags & 512U) {
      {
#line 2792
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", G-Float");
      }
    }
#line 2793
    goto switch_break;
    case_197: /* CIL Label */ 
#line 2796
    if (e_flags & (unsigned int )(1 << 2)) {
      {
#line 2797
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", G10");
      }
    }
#line 2798
    goto switch_break;
    case_173: /* CIL Label */ 
#line 2801
    if (e_flags & 1U) {
      {
#line 2802
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", 64-bit doubles");
      }
    }
#line 2803
    if (e_flags & (unsigned int )(1 << 1)) {
      {
#line 2804
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", dsp");
      }
    }
#line 2805
    if (e_flags & (unsigned int )(1 << 2)) {
      {
#line 2806
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", pid");
      }
    }
#line 2807
    if (e_flags & (unsigned int )(1 << 3)) {
      {
#line 2808
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", RX ABI");
      }
    }
#line 2809
    goto switch_break;
    case_22___0: /* CIL Label */ 
#line 2812
    if (e_flags & 1U) {
      {
#line 2813
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", highgprs");
      }
    }
#line 2814
    goto switch_break;
    case_140: /* CIL Label */ 
#line 2817
    if (e_flags & 1U) {
      {
#line 2818
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)", relocatable module");
      }
    }
#line 2819
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 2822
    tmp___9 = gettext(": architecture variant: ");
#line 2822
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___9);
    }
    {
#line 2825
    if ((e_flags & 255U) == 11U) {
#line 2825
      goto case_11___0;
    }
#line 2826
    if ((e_flags & 255U) == 110U) {
#line 2826
      goto case_110;
    }
#line 2827
    if ((e_flags & 255U) == 12U) {
#line 2827
      goto case_12___0;
    }
#line 2828
    if ((e_flags & 255U) == 13U) {
#line 2828
      goto case_13___0;
    }
#line 2829
    if ((e_flags & 255U) == 14U) {
#line 2829
      goto case_14;
    }
#line 2830
    if ((e_flags & 255U) == 15U) {
#line 2830
      goto case_15___0;
    }
#line 2831
    if ((e_flags & 255U) == 16U) {
#line 2831
      goto case_16___2;
    }
#line 2832
    if ((e_flags & 255U) == 31U) {
#line 2832
      goto case_31;
    }
#line 2833
    if ((e_flags & 255U) == 32U) {
#line 2833
      goto case_32___1;
    }
#line 2834
    if ((e_flags & 255U) == 33U) {
#line 2834
      goto case_33;
    }
#line 2835
    if ((e_flags & 255U) == 41U) {
#line 2835
      goto case_41;
    }
#line 2836
    if ((e_flags & 255U) == 42U) {
#line 2836
      goto case_42___0;
    }
#line 2837
    if ((e_flags & 255U) == 43U) {
#line 2837
      goto case_43___0;
    }
#line 2838
    if ((e_flags & 255U) == 44U) {
#line 2838
      goto case_44;
    }
#line 2839
    if ((e_flags & 255U) == 45U) {
#line 2839
      goto case_45;
    }
#line 2840
    goto switch_default___9;
    case_11___0: /* CIL Label */ 
    {
#line 2825
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x11");
    }
#line 2825
    goto switch_break___11;
    case_110: /* CIL Label */ 
    {
#line 2826
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x11x1 ");
    }
#line 2826
    goto switch_break___11;
    case_12___0: /* CIL Label */ 
    {
#line 2827
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x12");
    }
#line 2827
    goto switch_break___11;
    case_13___0: /* CIL Label */ 
    {
#line 2828
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x13");
    }
#line 2828
    goto switch_break___11;
    case_14: /* CIL Label */ 
    {
#line 2829
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x14");
    }
#line 2829
    goto switch_break___11;
    case_15___0: /* CIL Label */ 
    {
#line 2830
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x15");
    }
#line 2830
    goto switch_break___11;
    case_16___2: /* CIL Label */ 
    {
#line 2831
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x16");
    }
#line 2831
    goto switch_break___11;
    case_31: /* CIL Label */ 
    {
#line 2832
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x31");
    }
#line 2832
    goto switch_break___11;
    case_32___1: /* CIL Label */ 
    {
#line 2833
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x32");
    }
#line 2833
    goto switch_break___11;
    case_33: /* CIL Label */ 
    {
#line 2834
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x33");
    }
#line 2834
    goto switch_break___11;
    case_41: /* CIL Label */ 
    {
#line 2835
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x41");
    }
#line 2835
    goto switch_break___11;
    case_42___0: /* CIL Label */ 
    {
#line 2836
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x42");
    }
#line 2836
    goto switch_break___11;
    case_43___0: /* CIL Label */ 
    {
#line 2837
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x43");
    }
#line 2837
    goto switch_break___11;
    case_44: /* CIL Label */ 
    {
#line 2838
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430x44");
    }
#line 2838
    goto switch_break___11;
    case_45: /* CIL Label */ 
    {
#line 2839
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"MSP430X");
    }
#line 2839
    goto switch_break___11;
    switch_default___9: /* CIL Label */ 
    {
#line 2841
    tmp___10 = gettext(": unknown");
#line 2841
    strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___10);
    }
#line 2841
    goto switch_break___11;
    switch_break___11: /* CIL Label */ ;
    }
#line 2844
    if (e_flags & 4294967040U) {
      {
#line 2845
      tmp___11 = gettext(": unknown extra flag bits also present");
#line 2845
      strcat((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)tmp___11);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 2849
  return (buf___5);
}
}
#line 2855 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___2[32]  ;
#line 2852 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_osabi_name(unsigned int osabi ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2859
  if (osabi == 0U) {
#line 2859
    goto case_0;
  }
#line 2860
  if (osabi == 1U) {
#line 2860
    goto case_1;
  }
#line 2861
  if (osabi == 2U) {
#line 2861
    goto case_2;
  }
#line 2862
  if (osabi == 3U) {
#line 2862
    goto case_3;
  }
#line 2863
  if (osabi == 6U) {
#line 2863
    goto case_6;
  }
#line 2864
  if (osabi == 7U) {
#line 2864
    goto case_7;
  }
#line 2865
  if (osabi == 8U) {
#line 2865
    goto case_8;
  }
#line 2866
  if (osabi == 9U) {
#line 2866
    goto case_9;
  }
#line 2867
  if (osabi == 10U) {
#line 2867
    goto case_10;
  }
#line 2868
  if (osabi == 11U) {
#line 2868
    goto case_11;
  }
#line 2869
  if (osabi == 12U) {
#line 2869
    goto case_12;
  }
#line 2870
  if (osabi == 13U) {
#line 2870
    goto case_13;
  }
#line 2871
  if (osabi == 14U) {
#line 2871
    goto case_14;
  }
#line 2872
  if (osabi == 15U) {
#line 2872
    goto case_15;
  }
#line 2873
  if (osabi == 16U) {
#line 2873
    goto case_16;
  }
#line 2874
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2859
  return ("UNIX - System V");
  case_1: /* CIL Label */ 
#line 2860
  return ("UNIX - HP-UX");
  case_2: /* CIL Label */ 
#line 2861
  return ("UNIX - NetBSD");
  case_3: /* CIL Label */ 
#line 2862
  return ("UNIX - GNU");
  case_6: /* CIL Label */ 
#line 2863
  return ("UNIX - Solaris");
  case_7: /* CIL Label */ 
#line 2864
  return ("UNIX - AIX");
  case_8: /* CIL Label */ 
#line 2865
  return ("UNIX - IRIX");
  case_9: /* CIL Label */ 
#line 2866
  return ("UNIX - FreeBSD");
  case_10: /* CIL Label */ 
#line 2867
  return ("UNIX - TRU64");
  case_11: /* CIL Label */ 
#line 2868
  return ("Novell - Modesto");
  case_12: /* CIL Label */ 
#line 2869
  return ("UNIX - OpenBSD");
  case_13: /* CIL Label */ 
#line 2870
  return ("VMS - OpenVMS");
  case_14: /* CIL Label */ 
#line 2871
  return ("HP - Non-Stop Kernel");
  case_15: /* CIL Label */ 
#line 2872
  return ("AROS");
  case_16: /* CIL Label */ 
#line 2873
  return ("FenixOS");
  switch_default: /* CIL Label */ 
#line 2875
  if (osabi >= 64U) {
    {
#line 2878
    if ((int )elf_header.e_machine == 40) {
#line 2878
      goto case_40;
    }
#line 2888
    if ((int )elf_header.e_machine == 4185) {
#line 2888
      goto case_4185;
    }
#line 2888
    if ((int )elf_header.e_machine == 105) {
#line 2888
      goto case_4185;
    }
#line 2897
    if ((int )elf_header.e_machine == 140) {
#line 2897
      goto case_140;
    }
#line 2907
    goto switch_default___3;
    case_40: /* CIL Label */ 
    {
#line 2881
    if (osabi == 97U) {
#line 2881
      goto case_97;
    }
#line 2882
    goto switch_default___0;
    case_97: /* CIL Label */ 
#line 2881
    return ("ARM");
    switch_default___0: /* CIL Label */ 
#line 2883
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 2885
    goto switch_break___0;
    case_4185: /* CIL Label */ 
    case_105: /* CIL Label */ 
    {
#line 2891
    if (osabi == 255U) {
#line 2891
      goto case_255;
    }
#line 2892
    goto switch_default___1;
    case_255: /* CIL Label */ 
    {
#line 2891
    tmp___0 = gettext("Standalone App");
    }
#line 2891
    return ((char const   *)tmp___0);
    switch_default___1: /* CIL Label */ 
#line 2893
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 2895
    goto switch_break___0;
    case_140: /* CIL Label */ 
    {
#line 2900
    if (osabi == 64U) {
#line 2900
      goto case_64;
    }
#line 2901
    if (osabi == 65U) {
#line 2901
      goto case_65;
    }
#line 2902
    goto switch_default___2;
    case_64: /* CIL Label */ 
    {
#line 2900
    tmp___1 = gettext("Bare-metal C6000");
    }
#line 2900
    return ((char const   *)tmp___1);
    case_65: /* CIL Label */ 
#line 2901
    return ("Linux C6000");
    switch_default___2: /* CIL Label */ 
#line 2903
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 2905
    goto switch_break___0;
    switch_default___3: /* CIL Label */ 
#line 2908
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2910
  tmp___2 = gettext("<unknown: %x>");
#line 2910
  snprintf((char */* __restrict  */)(buff___2), sizeof(buff___2), (char const   */* __restrict  */)tmp___2,
           osabi);
  }
#line 2911
  return ((char const   *)(buff___2));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2915 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_aarch64_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2920
  if (type == 1879048192UL) {
#line 2920
    goto case_1879048192;
  }
#line 2922
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2921
  return ("AARCH64_ARCHEXT");
  switch_default: /* CIL Label */ 
#line 2923
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2926
  return ((char const   *)((void *)0));
}
}
#line 2929 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_arm_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2934
  if (type == 1879048193UL) {
#line 2934
    goto case_1879048193;
  }
#line 2936
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 2935
  return ("EXIDX");
  switch_default: /* CIL Label */ 
#line 2937
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2940
  return ((char const   *)((void *)0));
}
}
#line 2943 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_mips_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2948
  if (type == 1879048192UL) {
#line 2948
    goto case_1879048192;
  }
#line 2950
  if (type == 1879048193UL) {
#line 2950
    goto case_1879048193;
  }
#line 2952
  if (type == 1879048194UL) {
#line 2952
    goto case_1879048194;
  }
#line 2954
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2949
  return ("REGINFO");
  case_1879048193: /* CIL Label */ 
#line 2951
  return ("RTPROC");
  case_1879048194: /* CIL Label */ 
#line 2953
  return ("OPTIONS");
  switch_default: /* CIL Label */ 
#line 2955
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2958
  return ((char const   *)((void *)0));
}
}
#line 2961 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_parisc_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2966
  if (type == 1610612736UL) {
#line 2966
    goto case_1610612736;
  }
#line 2967
  if (type == 1610612737UL) {
#line 2967
    goto case_1610612737;
  }
#line 2968
  if (type == 1610612738UL) {
#line 2968
    goto case_1610612738;
  }
#line 2969
  if (type == 1610612739UL) {
#line 2969
    goto case_1610612739;
  }
#line 2970
  if (type == 1610612740UL) {
#line 2970
    goto case_1610612740;
  }
#line 2971
  if (type == 1610612741UL) {
#line 2971
    goto case_1610612741;
  }
#line 2972
  if (type == 1610612742UL) {
#line 2972
    goto case_1610612742;
  }
#line 2973
  if (type == 1610612743UL) {
#line 2973
    goto case_1610612743;
  }
#line 2974
  if (type == 1610612744UL) {
#line 2974
    goto case_1610612744;
  }
#line 2975
  if (type == 1610612745UL) {
#line 2975
    goto case_1610612745;
  }
#line 2976
  if (type == 1610612752UL) {
#line 2976
    goto case_1610612752;
  }
#line 2977
  if (type == 1610612753UL) {
#line 2977
    goto case_1610612753;
  }
#line 2978
  if (type == 1610612754UL) {
#line 2978
    goto case_1610612754;
  }
#line 2979
  if (type == 1610612755UL) {
#line 2979
    goto case_1610612755;
  }
#line 2980
  if (type == 1610612756UL) {
#line 2980
    goto case_1610612756;
  }
#line 2981
  if (type == 1610612757UL) {
#line 2981
    goto case_1610612757;
  }
#line 2982
  if (type == 1879048192UL) {
#line 2982
    goto case_1879048192;
  }
#line 2983
  if (type == 1879048193UL) {
#line 2983
    goto case_1879048193;
  }
#line 2984
  if (type == 1879048194UL) {
#line 2984
    goto case_1879048194;
  }
#line 2985
  goto switch_default;
  case_1610612736: /* CIL Label */ 
#line 2966
  return ("HP_TLS");
  case_1610612737: /* CIL Label */ 
#line 2967
  return ("HP_CORE_NONE");
  case_1610612738: /* CIL Label */ 
#line 2968
  return ("HP_CORE_VERSION");
  case_1610612739: /* CIL Label */ 
#line 2969
  return ("HP_CORE_KERNEL");
  case_1610612740: /* CIL Label */ 
#line 2970
  return ("HP_CORE_COMM");
  case_1610612741: /* CIL Label */ 
#line 2971
  return ("HP_CORE_PROC");
  case_1610612742: /* CIL Label */ 
#line 2972
  return ("HP_CORE_LOADABLE");
  case_1610612743: /* CIL Label */ 
#line 2973
  return ("HP_CORE_STACK");
  case_1610612744: /* CIL Label */ 
#line 2974
  return ("HP_CORE_SHM");
  case_1610612745: /* CIL Label */ 
#line 2975
  return ("HP_CORE_MMF");
  case_1610612752: /* CIL Label */ 
#line 2976
  return ("HP_PARALLEL");
  case_1610612753: /* CIL Label */ 
#line 2977
  return ("HP_FASTBIND");
  case_1610612754: /* CIL Label */ 
#line 2978
  return ("HP_OPT_ANNOT");
  case_1610612755: /* CIL Label */ 
#line 2979
  return ("HP_HSL_ANNOT");
  case_1610612756: /* CIL Label */ 
#line 2980
  return ("HP_STACK");
  case_1610612757: /* CIL Label */ 
#line 2981
  return ("HP_CORE_UTSNAME");
  case_1879048192: /* CIL Label */ 
#line 2982
  return ("PARISC_ARCHEXT");
  case_1879048193: /* CIL Label */ 
#line 2983
  return ("PARISC_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 2984
  return ("PARISC_WEAKORDER");
  switch_default: /* CIL Label */ 
#line 2986
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2989
  return ((char const   *)((void *)0));
}
}
#line 2992 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ia64_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2997
  if (type == 1879048192UL) {
#line 2997
    goto case_1879048192;
  }
#line 2998
  if (type == 1879048193UL) {
#line 2998
    goto case_1879048193;
  }
#line 2999
  if (type == 1610612736UL) {
#line 2999
    goto case_1610612736;
  }
#line 3000
  if (type == 1610612754UL) {
#line 3000
    goto case_1610612754;
  }
#line 3001
  if (type == 1610612755UL) {
#line 3001
    goto case_1610612755;
  }
#line 3002
  if (type == 1610612756UL) {
#line 3002
    goto case_1610612756;
  }
#line 3003
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2997
  return ("IA_64_ARCHEXT");
  case_1879048193: /* CIL Label */ 
#line 2998
  return ("IA_64_UNWIND");
  case_1610612736: /* CIL Label */ 
#line 2999
  return ("HP_TLS");
  case_1610612754: /* CIL Label */ 
#line 3000
  return ("HP_OPT_ANNOT");
  case_1610612755: /* CIL Label */ 
#line 3001
  return ("HP_HSL_ANNOT");
  case_1610612756: /* CIL Label */ 
#line 3002
  return ("HP_STACK");
  switch_default: /* CIL Label */ 
#line 3004
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3007
  return ((char const   *)((void *)0));
}
}
#line 3010 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_tic6x_segment_type(unsigned long type ) 
{ 


  {
  {
#line 3015
  if (type == 1879048192UL) {
#line 3015
    goto case_1879048192;
  }
#line 3016
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 3015
  return ("C6000_PHATTR");
  switch_default: /* CIL Label */ 
#line 3017
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3020
  return ((char const   *)((void *)0));
}
}
#line 3026 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___3[32]  ;
#line 3023 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_segment_type(unsigned long p_type ) 
{ 
  char const   *result ;
  char const   *result___0 ;
  char *tmp___0 ;

  {
  {
#line 3030
  if (p_type == 0UL) {
#line 3030
    goto case_0;
  }
#line 3031
  if (p_type == 1UL) {
#line 3031
    goto case_1;
  }
#line 3032
  if (p_type == 2UL) {
#line 3032
    goto case_2;
  }
#line 3033
  if (p_type == 3UL) {
#line 3033
    goto case_3;
  }
#line 3034
  if (p_type == 4UL) {
#line 3034
    goto case_4;
  }
#line 3035
  if (p_type == 5UL) {
#line 3035
    goto case_5;
  }
#line 3036
  if (p_type == 6UL) {
#line 3036
    goto case_6;
  }
#line 3037
  if (p_type == 7UL) {
#line 3037
    goto case_7;
  }
#line 3039
  if (p_type == 1685382480UL) {
#line 3039
    goto case_1685382480;
  }
#line 3041
  if (p_type == 1685382481UL) {
#line 3041
    goto case_1685382481;
  }
#line 3042
  if (p_type == 1685382482UL) {
#line 3042
    goto case_1685382482;
  }
#line 3044
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3030
  return ("NULL");
  case_1: /* CIL Label */ 
#line 3031
  return ("LOAD");
  case_2: /* CIL Label */ 
#line 3032
  return ("DYNAMIC");
  case_3: /* CIL Label */ 
#line 3033
  return ("INTERP");
  case_4: /* CIL Label */ 
#line 3034
  return ("NOTE");
  case_5: /* CIL Label */ 
#line 3035
  return ("SHLIB");
  case_6: /* CIL Label */ 
#line 3036
  return ("PHDR");
  case_7: /* CIL Label */ 
#line 3037
  return ("TLS");
  case_1685382480: /* CIL Label */ 
#line 3040
  return ("GNU_EH_FRAME");
  case_1685382481: /* CIL Label */ 
#line 3041
  return ("GNU_STACK");
  case_1685382482: /* CIL Label */ 
#line 3042
  return ("GNU_RELRO");
  switch_default: /* CIL Label */ 
#line 3045
  if (p_type >= 1879048192UL) {
#line 3045
    if (p_type <= 2147483647UL) {
      {
#line 3051
      if ((int )elf_header.e_machine == 183) {
#line 3051
        goto case_183;
      }
#line 3054
      if ((int )elf_header.e_machine == 40) {
#line 3054
        goto case_40;
      }
#line 3058
      if ((int )elf_header.e_machine == 10) {
#line 3058
        goto case_10;
      }
#line 3058
      if ((int )elf_header.e_machine == 8) {
#line 3058
        goto case_10;
      }
#line 3061
      if ((int )elf_header.e_machine == 15) {
#line 3061
        goto case_15;
      }
#line 3064
      if ((int )elf_header.e_machine == 50) {
#line 3064
        goto case_50;
      }
#line 3067
      if ((int )elf_header.e_machine == 140) {
#line 3067
        goto case_140;
      }
#line 3070
      goto switch_default___0;
      case_183: /* CIL Label */ 
      {
#line 3052
      result = get_aarch64_segment_type(p_type);
      }
#line 3053
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 3055
      result = get_arm_segment_type(p_type);
      }
#line 3056
      goto switch_break___0;
      case_10: /* CIL Label */ 
      case_8: /* CIL Label */ 
      {
#line 3059
      result = get_mips_segment_type(p_type);
      }
#line 3060
      goto switch_break___0;
      case_15: /* CIL Label */ 
      {
#line 3062
      result = get_parisc_segment_type(p_type);
      }
#line 3063
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 3065
      result = get_ia64_segment_type(p_type);
      }
#line 3066
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 3068
      result = get_tic6x_segment_type(p_type);
      }
#line 3069
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3071
      result = (char const   *)((void *)0);
#line 3072
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3075
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 3076
        return (result);
      }
      {
#line 3078
      sprintf((char */* __restrict  */)(buff___3), (char const   */* __restrict  */)"LOPROC+%lx",
              p_type - 1879048192UL);
      }
    } else {
#line 3045
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3080
  if (p_type >= 1610612736UL) {
#line 3080
    if (p_type <= 1879048191UL) {
      {
#line 3086
      if ((int )elf_header.e_machine == 15) {
#line 3086
        goto case_15___0;
      }
#line 3089
      if ((int )elf_header.e_machine == 50) {
#line 3089
        goto case_50___0;
      }
#line 3092
      goto switch_default___1;
      case_15___0: /* CIL Label */ 
      {
#line 3087
      result___0 = get_parisc_segment_type(p_type);
      }
#line 3088
      goto switch_break___1;
      case_50___0: /* CIL Label */ 
      {
#line 3090
      result___0 = get_ia64_segment_type(p_type);
      }
#line 3091
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 3093
      result___0 = (char const   *)((void *)0);
#line 3094
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 3097
      if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 3098
        return (result___0);
      }
      {
#line 3100
      sprintf((char */* __restrict  */)(buff___3), (char const   */* __restrict  */)"LOOS+%lx",
              p_type - 1610612736UL);
      }
    } else {
      {
#line 3103
      tmp___0 = gettext("<unknown>: %lx");
#line 3103
      snprintf((char */* __restrict  */)(buff___3), sizeof(buff___3), (char const   */* __restrict  */)tmp___0,
               p_type);
      }
    }
  } else {
    {
#line 3103
    tmp___0 = gettext("<unknown>: %lx");
#line 3103
    snprintf((char */* __restrict  */)(buff___3), sizeof(buff___3), (char const   */* __restrict  */)tmp___0,
             p_type);
    }
  }
#line 3105
  return ((char const   *)(buff___3));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3109 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_mips_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3114
  if (sh_type == 1879048192U) {
#line 3114
    goto case_1879048192;
  }
#line 3115
  if (sh_type == 1879048193U) {
#line 3115
    goto case_1879048193;
  }
#line 3116
  if (sh_type == 1879048194U) {
#line 3116
    goto case_1879048194;
  }
#line 3117
  if (sh_type == 1879048195U) {
#line 3117
    goto case_1879048195;
  }
#line 3118
  if (sh_type == 1879048196U) {
#line 3118
    goto case_1879048196;
  }
#line 3119
  if (sh_type == 1879048197U) {
#line 3119
    goto case_1879048197;
  }
#line 3120
  if (sh_type == 1879048198U) {
#line 3120
    goto case_1879048198;
  }
#line 3121
  if (sh_type == 1879048199U) {
#line 3121
    goto case_1879048199;
  }
#line 3122
  if (sh_type == 1879048200U) {
#line 3122
    goto case_1879048200;
  }
#line 3123
  if (sh_type == 1879048201U) {
#line 3123
    goto case_1879048201;
  }
#line 3124
  if (sh_type == 1879048203U) {
#line 3124
    goto case_1879048203;
  }
#line 3125
  if (sh_type == 1879048204U) {
#line 3125
    goto case_1879048204;
  }
#line 3126
  if (sh_type == 1879048205U) {
#line 3126
    goto case_1879048205;
  }
#line 3127
  if (sh_type == 1879048208U) {
#line 3127
    goto case_1879048208;
  }
#line 3128
  if (sh_type == 1879048209U) {
#line 3128
    goto case_1879048209;
  }
#line 3129
  if (sh_type == 1879048210U) {
#line 3129
    goto case_1879048210;
  }
#line 3130
  if (sh_type == 1879048211U) {
#line 3130
    goto case_1879048211;
  }
#line 3131
  if (sh_type == 1879048212U) {
#line 3131
    goto case_1879048212;
  }
#line 3132
  if (sh_type == 1879048213U) {
#line 3132
    goto case_1879048213;
  }
#line 3133
  if (sh_type == 1879048214U) {
#line 3133
    goto case_1879048214;
  }
#line 3134
  if (sh_type == 1879048215U) {
#line 3134
    goto case_1879048215;
  }
#line 3135
  if (sh_type == 1879048216U) {
#line 3135
    goto case_1879048216;
  }
#line 3136
  if (sh_type == 1879048217U) {
#line 3136
    goto case_1879048217;
  }
#line 3137
  if (sh_type == 1879048218U) {
#line 3137
    goto case_1879048218;
  }
#line 3138
  if (sh_type == 1879048219U) {
#line 3138
    goto case_1879048219;
  }
#line 3139
  if (sh_type == 1879048220U) {
#line 3139
    goto case_1879048220;
  }
#line 3140
  if (sh_type == 1879048221U) {
#line 3140
    goto case_1879048221;
  }
#line 3141
  if (sh_type == 1879048222U) {
#line 3141
    goto case_1879048222;
  }
#line 3142
  if (sh_type == 1879048223U) {
#line 3142
    goto case_1879048223;
  }
#line 3143
  if (sh_type == 1879048224U) {
#line 3143
    goto case_1879048224;
  }
#line 3144
  if (sh_type == 1879048225U) {
#line 3144
    goto case_1879048225;
  }
#line 3145
  if (sh_type == 1879048226U) {
#line 3145
    goto case_1879048226;
  }
#line 3146
  if (sh_type == 1879048227U) {
#line 3146
    goto case_1879048227;
  }
#line 3147
  if (sh_type == 1879048228U) {
#line 3147
    goto case_1879048228;
  }
#line 3148
  if (sh_type == 1879048229U) {
#line 3148
    goto case_1879048229;
  }
#line 3149
  if (sh_type == 1879048230U) {
#line 3149
    goto case_1879048230;
  }
#line 3150
  if (sh_type == 1879048231U) {
#line 3150
    goto case_1879048231;
  }
#line 3151
  if (sh_type == 1879048232U) {
#line 3151
    goto case_1879048232;
  }
#line 3152
  if (sh_type == 1879048233U) {
#line 3152
    goto case_1879048233;
  }
#line 3153
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 3114
  return ("MIPS_LIBLIST");
  case_1879048193: /* CIL Label */ 
#line 3115
  return ("MIPS_MSYM");
  case_1879048194: /* CIL Label */ 
#line 3116
  return ("MIPS_CONFLICT");
  case_1879048195: /* CIL Label */ 
#line 3117
  return ("MIPS_GPTAB");
  case_1879048196: /* CIL Label */ 
#line 3118
  return ("MIPS_UCODE");
  case_1879048197: /* CIL Label */ 
#line 3119
  return ("MIPS_DEBUG");
  case_1879048198: /* CIL Label */ 
#line 3120
  return ("MIPS_REGINFO");
  case_1879048199: /* CIL Label */ 
#line 3121
  return ("MIPS_PACKAGE");
  case_1879048200: /* CIL Label */ 
#line 3122
  return ("MIPS_PACKSYM");
  case_1879048201: /* CIL Label */ 
#line 3123
  return ("MIPS_RELD");
  case_1879048203: /* CIL Label */ 
#line 3124
  return ("MIPS_IFACE");
  case_1879048204: /* CIL Label */ 
#line 3125
  return ("MIPS_CONTENT");
  case_1879048205: /* CIL Label */ 
#line 3126
  return ("MIPS_OPTIONS");
  case_1879048208: /* CIL Label */ 
#line 3127
  return ("MIPS_SHDR");
  case_1879048209: /* CIL Label */ 
#line 3128
  return ("MIPS_FDESC");
  case_1879048210: /* CIL Label */ 
#line 3129
  return ("MIPS_EXTSYM");
  case_1879048211: /* CIL Label */ 
#line 3130
  return ("MIPS_DENSE");
  case_1879048212: /* CIL Label */ 
#line 3131
  return ("MIPS_PDESC");
  case_1879048213: /* CIL Label */ 
#line 3132
  return ("MIPS_LOCSYM");
  case_1879048214: /* CIL Label */ 
#line 3133
  return ("MIPS_AUXSYM");
  case_1879048215: /* CIL Label */ 
#line 3134
  return ("MIPS_OPTSYM");
  case_1879048216: /* CIL Label */ 
#line 3135
  return ("MIPS_LOCSTR");
  case_1879048217: /* CIL Label */ 
#line 3136
  return ("MIPS_LINE");
  case_1879048218: /* CIL Label */ 
#line 3137
  return ("MIPS_RFDESC");
  case_1879048219: /* CIL Label */ 
#line 3138
  return ("MIPS_DELTASYM");
  case_1879048220: /* CIL Label */ 
#line 3139
  return ("MIPS_DELTAINST");
  case_1879048221: /* CIL Label */ 
#line 3140
  return ("MIPS_DELTACLASS");
  case_1879048222: /* CIL Label */ 
#line 3141
  return ("MIPS_DWARF");
  case_1879048223: /* CIL Label */ 
#line 3142
  return ("MIPS_DELTADECL");
  case_1879048224: /* CIL Label */ 
#line 3143
  return ("MIPS_SYMBOL_LIB");
  case_1879048225: /* CIL Label */ 
#line 3144
  return ("MIPS_EVENTS");
  case_1879048226: /* CIL Label */ 
#line 3145
  return ("MIPS_TRANSLATE");
  case_1879048227: /* CIL Label */ 
#line 3146
  return ("MIPS_PIXIE");
  case_1879048228: /* CIL Label */ 
#line 3147
  return ("MIPS_XLATE");
  case_1879048229: /* CIL Label */ 
#line 3148
  return ("MIPS_XLATE_DEBUG");
  case_1879048230: /* CIL Label */ 
#line 3149
  return ("MIPS_WHIRL");
  case_1879048231: /* CIL Label */ 
#line 3150
  return ("MIPS_EH_REGION");
  case_1879048232: /* CIL Label */ 
#line 3151
  return ("MIPS_XLATE_OLD");
  case_1879048233: /* CIL Label */ 
#line 3152
  return ("MIPS_PDR_EXCEPTION");
  switch_default: /* CIL Label */ 
#line 3154
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3156
  return ((char const   *)((void *)0));
}
}
#line 3159 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_parisc_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3164
  if (sh_type == 1879048192U) {
#line 3164
    goto case_1879048192;
  }
#line 3165
  if (sh_type == 1879048193U) {
#line 3165
    goto case_1879048193;
  }
#line 3166
  if (sh_type == 1879048194U) {
#line 3166
    goto case_1879048194;
  }
#line 3167
  if (sh_type == 1879048195U) {
#line 3167
    goto case_1879048195;
  }
#line 3168
  if (sh_type == 1879048200U) {
#line 3168
    goto case_1879048200;
  }
#line 3169
  if (sh_type == 1879048201U) {
#line 3169
    goto case_1879048201;
  }
#line 3170
  if (sh_type == 1879048196U) {
#line 3170
    goto case_1879048196;
  }
#line 3171
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 3164
  return ("PARISC_EXT");
  case_1879048193: /* CIL Label */ 
#line 3165
  return ("PARISC_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 3166
  return ("PARISC_DOC");
  case_1879048195: /* CIL Label */ 
#line 3167
  return ("PARISC_ANNOT");
  case_1879048200: /* CIL Label */ 
#line 3168
  return ("PARISC_SYMEXTN");
  case_1879048201: /* CIL Label */ 
#line 3169
  return ("PARISC_STUBS");
  case_1879048196: /* CIL Label */ 
#line 3170
  return ("PARISC_DLKM");
  switch_default: /* CIL Label */ 
#line 3172
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3174
  return ((char const   *)((void *)0));
}
}
#line 3177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ia64_section_type_name(unsigned int sh_type ) 
{ 
  char const   *tmp___0 ;

  {
#line 3181
  if ((sh_type & 4278190080U) == 2013265920U) {
    {
#line 3182
    tmp___0 = get_osabi_name((sh_type & 16711680U) >> 16);
    }
#line 3182
    return (tmp___0);
  }
  {
#line 3186
  if (sh_type == 1879048192U) {
#line 3186
    goto case_1879048192;
  }
#line 3187
  if (sh_type == 1879048193U) {
#line 3187
    goto case_1879048193;
  }
#line 3188
  if (sh_type == 2030043136U) {
#line 3188
    goto case_2030043136;
  }
#line 3189
  if (sh_type == 1610612736U) {
#line 3189
    goto case_1610612736;
  }
#line 3190
  if (sh_type == 1610612737U) {
#line 3190
    goto case_1610612737;
  }
#line 3191
  if (sh_type == 1610612738U) {
#line 3191
    goto case_1610612738;
  }
#line 3192
  if (sh_type == 1610612739U) {
#line 3192
    goto case_1610612739;
  }
#line 3193
  if (sh_type == 1610612740U) {
#line 3193
    goto case_1610612740;
  }
#line 3194
  if (sh_type == 1610612741U) {
#line 3194
    goto case_1610612741;
  }
#line 3195
  if (sh_type == 1610612742U) {
#line 3195
    goto case_1610612742;
  }
#line 3196
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 3186
  return ("IA_64_EXT");
  case_1879048193: /* CIL Label */ 
#line 3187
  return ("IA_64_UNWIND");
  case_2030043136: /* CIL Label */ 
#line 3188
  return ("IA_64_PRIORITY_INIT");
  case_1610612736: /* CIL Label */ 
#line 3189
  return ("VMS_TRACE");
  case_1610612737: /* CIL Label */ 
#line 3190
  return ("VMS_TIE_SIGNATURES");
  case_1610612738: /* CIL Label */ 
#line 3191
  return ("VMS_DEBUG");
  case_1610612739: /* CIL Label */ 
#line 3192
  return ("VMS_DEBUG_STR");
  case_1610612740: /* CIL Label */ 
#line 3193
  return ("VMS_LINKAGES");
  case_1610612741: /* CIL Label */ 
#line 3194
  return ("VMS_SYMBOL_VECTOR");
  case_1610612742: /* CIL Label */ 
#line 3195
  return ("VMS_FIXUP");
  switch_default: /* CIL Label */ 
#line 3197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3199
  return ((char const   *)((void *)0));
}
}
#line 3202 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_x86_64_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3207
  if (sh_type == 1879048193U) {
#line 3207
    goto case_1879048193;
  }
#line 3208
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3207
  return ("X86_64_UNWIND");
  switch_default: /* CIL Label */ 
#line 3209
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3211
  return ((char const   *)((void *)0));
}
}
#line 3214 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_aarch64_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3219
  if (sh_type == 1879048195U) {
#line 3219
    goto case_1879048195;
  }
#line 3221
  goto switch_default;
  case_1879048195: /* CIL Label */ 
#line 3220
  return ("AARCH64_ATTRIBUTES");
  switch_default: /* CIL Label */ 
#line 3222
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3224
  return ((char const   *)((void *)0));
}
}
#line 3227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_arm_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3232
  if (sh_type == 1879048193U) {
#line 3232
    goto case_1879048193;
  }
#line 3233
  if (sh_type == 1879048194U) {
#line 3233
    goto case_1879048194;
  }
#line 3234
  if (sh_type == 1879048195U) {
#line 3234
    goto case_1879048195;
  }
#line 3235
  if (sh_type == 1879048196U) {
#line 3235
    goto case_1879048196;
  }
#line 3236
  if (sh_type == 1879048197U) {
#line 3236
    goto case_1879048197;
  }
#line 3237
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3232
  return ("ARM_EXIDX");
  case_1879048194: /* CIL Label */ 
#line 3233
  return ("ARM_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 3234
  return ("ARM_ATTRIBUTES");
  case_1879048196: /* CIL Label */ 
#line 3235
  return ("ARM_DEBUGOVERLAY");
  case_1879048197: /* CIL Label */ 
#line 3236
  return ("ARM_OVERLAYSECTION");
  switch_default: /* CIL Label */ 
#line 3238
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3240
  return ((char const   *)((void *)0));
}
}
#line 3243 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_tic6x_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3248
  if (sh_type == 1879048193U) {
#line 3248
    goto case_1879048193;
  }
#line 3250
  if (sh_type == 1879048194U) {
#line 3250
    goto case_1879048194;
  }
#line 3252
  if (sh_type == 1879048195U) {
#line 3252
    goto case_1879048195;
  }
#line 3254
  if (sh_type == 2130706432U) {
#line 3254
    goto case_2130706432;
  }
#line 3256
  if (sh_type == 2130706433U) {
#line 3256
    goto case_2130706433;
  }
#line 3258
  if (sh_type == 2130706434U) {
#line 3258
    goto case_2130706434;
  }
#line 3260
  if (sh_type == 2130706435U) {
#line 3260
    goto case_2130706435;
  }
#line 3262
  if (sh_type == 2130706436U) {
#line 3262
    goto case_2130706436;
  }
#line 3264
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3249
  return ("C6000_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 3251
  return ("C6000_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 3253
  return ("C6000_ATTRIBUTES");
  case_2130706432: /* CIL Label */ 
#line 3255
  return ("TI_ICODE");
  case_2130706433: /* CIL Label */ 
#line 3257
  return ("TI_XREF");
  case_2130706434: /* CIL Label */ 
#line 3259
  return ("TI_HANDLER");
  case_2130706435: /* CIL Label */ 
#line 3261
  return ("TI_INITINFO");
  case_2130706436: /* CIL Label */ 
#line 3263
  return ("TI_PHATTRS");
  switch_default: /* CIL Label */ 
#line 3265
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3267
  return ((char const   *)((void *)0));
}
}
#line 3270 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_msp430x_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3275
  if (sh_type == 2130706437U) {
#line 3275
    goto case_2130706437;
  }
#line 3276
  if (sh_type == 2130706438U) {
#line 3276
    goto case_2130706438;
  }
#line 3277
  if (sh_type == 1879048195U) {
#line 3277
    goto case_1879048195;
  }
#line 3278
  goto switch_default;
  case_2130706437: /* CIL Label */ 
#line 3275
  return ("MSP430_SEC_FLAGS");
  case_2130706438: /* CIL Label */ 
#line 3276
  return ("MSP430_SYM_ALIASES");
  case_1879048195: /* CIL Label */ 
#line 3277
  return ("MSP430_ATTRIBUTES");
  switch_default: /* CIL Label */ 
#line 3278
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3285 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___4[32]  ;
#line 3282 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_section_type_name(unsigned int sh_type ) 
{ 
  char const   *result ;
  char const   *result___0 ;
  char *tmp___0 ;

  {
  {
#line 3289
  if (sh_type == 0U) {
#line 3289
    goto case_0;
  }
#line 3290
  if (sh_type == 1U) {
#line 3290
    goto case_1;
  }
#line 3291
  if (sh_type == 2U) {
#line 3291
    goto case_2;
  }
#line 3292
  if (sh_type == 3U) {
#line 3292
    goto case_3;
  }
#line 3293
  if (sh_type == 4U) {
#line 3293
    goto case_4;
  }
#line 3294
  if (sh_type == 5U) {
#line 3294
    goto case_5;
  }
#line 3295
  if (sh_type == 6U) {
#line 3295
    goto case_6;
  }
#line 3296
  if (sh_type == 7U) {
#line 3296
    goto case_7;
  }
#line 3297
  if (sh_type == 8U) {
#line 3297
    goto case_8;
  }
#line 3298
  if (sh_type == 9U) {
#line 3298
    goto case_9;
  }
#line 3299
  if (sh_type == 10U) {
#line 3299
    goto case_10;
  }
#line 3300
  if (sh_type == 11U) {
#line 3300
    goto case_11;
  }
#line 3301
  if (sh_type == 14U) {
#line 3301
    goto case_14;
  }
#line 3302
  if (sh_type == 15U) {
#line 3302
    goto case_15;
  }
#line 3303
  if (sh_type == 16U) {
#line 3303
    goto case_16;
  }
#line 3304
  if (sh_type == 1879048182U) {
#line 3304
    goto case_1879048182;
  }
#line 3305
  if (sh_type == 17U) {
#line 3305
    goto case_17;
  }
#line 3306
  if (sh_type == 18U) {
#line 3306
    goto case_18;
  }
#line 3307
  if (sh_type == 1879048189U) {
#line 3307
    goto case_1879048189;
  }
#line 3308
  if (sh_type == 1879048190U) {
#line 3308
    goto case_1879048190;
  }
#line 3309
  if (sh_type == 1879048191U) {
#line 3309
    goto case_1879048191;
  }
#line 3310
  if (sh_type == 1879048176U) {
#line 3310
    goto case_1879048176;
  }
#line 3311
  if (sh_type == 1879048188U) {
#line 3311
    goto case_1879048188;
  }
#line 3312
  if (sh_type == 2147483645U) {
#line 3312
    goto case_2147483645;
  }
#line 3313
  if (sh_type == 2147483647U) {
#line 3313
    goto case_2147483647;
  }
#line 3314
  if (sh_type == 1879048183U) {
#line 3314
    goto case_1879048183;
  }
#line 3316
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3289
  return ("NULL");
  case_1: /* CIL Label */ 
#line 3290
  return ("PROGBITS");
  case_2: /* CIL Label */ 
#line 3291
  return ("SYMTAB");
  case_3: /* CIL Label */ 
#line 3292
  return ("STRTAB");
  case_4: /* CIL Label */ 
#line 3293
  return ("RELA");
  case_5: /* CIL Label */ 
#line 3294
  return ("HASH");
  case_6: /* CIL Label */ 
#line 3295
  return ("DYNAMIC");
  case_7: /* CIL Label */ 
#line 3296
  return ("NOTE");
  case_8: /* CIL Label */ 
#line 3297
  return ("NOBITS");
  case_9: /* CIL Label */ 
#line 3298
  return ("REL");
  case_10: /* CIL Label */ 
#line 3299
  return ("SHLIB");
  case_11: /* CIL Label */ 
#line 3300
  return ("DYNSYM");
  case_14: /* CIL Label */ 
#line 3301
  return ("INIT_ARRAY");
  case_15: /* CIL Label */ 
#line 3302
  return ("FINI_ARRAY");
  case_16: /* CIL Label */ 
#line 3303
  return ("PREINIT_ARRAY");
  case_1879048182: /* CIL Label */ 
#line 3304
  return ("GNU_HASH");
  case_17: /* CIL Label */ 
#line 3305
  return ("GROUP");
  case_18: /* CIL Label */ 
#line 3306
  return ("SYMTAB SECTION INDICIES");
  case_1879048189: /* CIL Label */ 
#line 3307
  return ("VERDEF");
  case_1879048190: /* CIL Label */ 
#line 3308
  return ("VERNEED");
  case_1879048191: /* CIL Label */ 
#line 3309
  return ("VERSYM");
  case_1879048176: /* CIL Label */ 
#line 3310
  return ("VERSYM");
  case_1879048188: /* CIL Label */ 
#line 3311
  return ("VERDEF");
  case_2147483645: /* CIL Label */ 
#line 3312
  return ("AUXILIARY");
  case_2147483647: /* CIL Label */ 
#line 3313
  return ("FILTER");
  case_1879048183: /* CIL Label */ 
#line 3314
  return ("GNU_LIBLIST");
  switch_default: /* CIL Label */ 
#line 3317
  if (sh_type >= 1879048192U) {
#line 3317
    if (sh_type <= 2147483647U) {
      {
#line 3324
      if ((int )elf_header.e_machine == 10) {
#line 3324
        goto case_10___0;
      }
#line 3324
      if ((int )elf_header.e_machine == 8) {
#line 3324
        goto case_10___0;
      }
#line 3327
      if ((int )elf_header.e_machine == 15) {
#line 3327
        goto case_15___0;
      }
#line 3330
      if ((int )elf_header.e_machine == 50) {
#line 3330
        goto case_50;
      }
#line 3335
      if ((int )elf_header.e_machine == 181) {
#line 3335
        goto case_181;
      }
#line 3335
      if ((int )elf_header.e_machine == 180) {
#line 3335
        goto case_181;
      }
#line 3335
      if ((int )elf_header.e_machine == 62) {
#line 3335
        goto case_181;
      }
#line 3338
      if ((int )elf_header.e_machine == 183) {
#line 3338
        goto case_183;
      }
#line 3341
      if ((int )elf_header.e_machine == 40) {
#line 3341
        goto case_40;
      }
#line 3344
      if ((int )elf_header.e_machine == 140) {
#line 3344
        goto case_140;
      }
#line 3347
      if ((int )elf_header.e_machine == 105) {
#line 3347
        goto case_105;
      }
#line 3350
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 3325
      result = get_mips_section_type_name(sh_type);
      }
#line 3326
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 3328
      result = get_parisc_section_type_name(sh_type);
      }
#line 3329
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 3331
      result = get_ia64_section_type_name(sh_type);
      }
#line 3332
      goto switch_break___0;
      case_181: /* CIL Label */ 
      case_180: /* CIL Label */ 
      case_62: /* CIL Label */ 
      {
#line 3336
      result = get_x86_64_section_type_name(sh_type);
      }
#line 3337
      goto switch_break___0;
      case_183: /* CIL Label */ 
      {
#line 3339
      result = get_aarch64_section_type_name(sh_type);
      }
#line 3340
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 3342
      result = get_arm_section_type_name(sh_type);
      }
#line 3343
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 3345
      result = get_tic6x_section_type_name(sh_type);
      }
#line 3346
      goto switch_break___0;
      case_105: /* CIL Label */ 
      {
#line 3348
      result = get_msp430x_section_type_name(sh_type);
      }
#line 3349
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3351
      result = (char const   *)((void *)0);
#line 3352
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3355
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 3356
        return (result);
      }
      {
#line 3358
      sprintf((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)"LOPROC+%x",
              sh_type - 1879048192U);
      }
    } else {
#line 3317
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3360
  if (sh_type >= 1610612736U) {
#line 3360
    if (sh_type <= 1879048191U) {
      {
#line 3366
      if ((int )elf_header.e_machine == 50) {
#line 3366
        goto case_50___0;
      }
#line 3369
      goto switch_default___1;
      case_50___0: /* CIL Label */ 
      {
#line 3367
      result___0 = get_ia64_section_type_name(sh_type);
      }
#line 3368
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 3370
      result___0 = (char const   *)((void *)0);
#line 3371
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 3374
      if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 3375
        return (result___0);
      }
      {
#line 3377
      sprintf((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)"LOOS+%x",
              sh_type - 1610612736U);
      }
    } else {
#line 3360
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3379
  if (sh_type >= 2147483648U) {
#line 3379
    if (sh_type <= 4294967295U) {
      {
#line 3380
      sprintf((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)"LOUSER+%x",
              sh_type - 2147483648U);
      }
    } else {
      {
#line 3384
      tmp___0 = gettext("%08x: <unknown>");
#line 3384
      snprintf((char */* __restrict  */)(buff___4), sizeof(buff___4), (char const   */* __restrict  */)tmp___0,
               sh_type);
      }
    }
  } else {
    {
#line 3384
    tmp___0 = gettext("%08x: <unknown>");
#line 3384
    snprintf((char */* __restrict  */)(buff___4), sizeof(buff___4), (char const   */* __restrict  */)tmp___0,
             sh_type);
    }
  }
#line 3386
  return ((char const   *)(buff___4));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3396 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct option options[33]  = 
#line 3396
  {      {"all", 0, (int *)0, 'a'}, 
        {"file-header", 0, (int *)0, 'h'}, 
        {"program-headers", 0, (int *)0, 'l'}, 
        {"headers", 0, (int *)0, 'e'}, 
        {"histogram", 0, (int *)0, 'I'}, 
        {"segments", 0, (int *)0, 'l'}, 
        {"sections", 0, (int *)0, 'S'}, 
        {"section-headers", 0, (int *)0, 'S'}, 
        {"section-groups", 0, (int *)0, 'g'}, 
        {"section-details", 0, (int *)0, 't'}, 
        {"full-section-name", 0, (int *)0, 'N'}, 
        {"symbols", 0, (int *)0, 's'}, 
        {"syms", 0, (int *)0, 's'}, 
        {"dyn-syms", 0, (int *)0, 513}, 
        {"relocs", 0, (int *)0, 'r'}, 
        {"notes", 0, (int *)0, 'n'}, 
        {"dynamic", 0, (int *)0, 'd'}, 
        {"arch-specific", 0, (int *)0, 'A'}, 
        {"version-info", 0, (int *)0, 'V'}, 
        {"use-dynamic", 0, (int *)0, 'D'}, 
        {"unwind", 0, (int *)0, 'u'}, 
        {"archive-index", 0, (int *)0, 'c'}, 
        {"hex-dump", 1, (int *)0, 'x'}, 
        {"relocated-dump", 1, (int *)0, 'R'}, 
        {"string-dump", 1, (int *)0, 'p'}, 
        {"debug-dump", 2, (int *)0, 512}, 
        {"dwarf-depth", 1, (int *)0, 514}, 
        {"dwarf-start", 1, (int *)0, 515}, 
        {"dwarf-check", 0, (int *)0, 516}, 
        {"version", 0, (int *)0, 'v'}, 
        {"wide", 0, (int *)0, 'W'}, 
        {"help", 0, (int *)0, 'H'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 3438 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void usage(FILE *stream ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3441
  tmp___0 = gettext("Usage: readelf <option(s)> elf-file(s)\n");
#line 3441
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___0);
#line 3442
  tmp___1 = gettext(" Display information about the contents of ELF format files\n");
#line 3442
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1);
#line 3443
  tmp___2 = gettext(" Options are:\n  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n  -h --file-header       Display the ELF file header\n  -l --program-headers   Display the program headers\n     --segments          An alias for --program-headers\n  -S --section-headers   Display the sections\' header\n     --sections          An alias for --section-headers\n  -g --section-groups    Display the section groups\n  -t --section-details   Display the section details\n  -e --headers           Equivalent to: -h -l -S\n  -s --syms              Display the symbol table\n     --symbols           An alias for --syms\n  --dyn-syms             Display the dynamic symbol table\n  -n --notes             Display the core notes (if present)\n  -r --relocs            Display the relocations (if present)\n  -u --unwind            Display the unwind info (if present)\n  -d --dynamic           Display the dynamic section (if present)\n  -V --version-info      Display the version sections (if present)\n  -A --arch-specific     Display architecture specific information (if any)\n  -c --archive-index     Display the symbol/file index in an archive\n  -D --use-dynamic       Use the dynamic section info when displaying symbols\n  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n  -R --relocated-dump=<number|name>\n                         Dump the contents of section <number|name> as relocated bytes\n  -w[lLiaprmfFsoRt] or\n  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n               =addr,=cu_index]\n                         Display the contents of DWARF2 debug sections\n");
#line 3443
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2);
#line 3476
  tmp___3 = gettext("  --dwarf-depth=N        Do not display DIEs at depth N or greater\n  --dwarf-start=N        Display DIEs starting with N, at the same depth\n                         or deeper\n");
#line 3476
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3);
#line 3485
  tmp___4 = gettext("  -I --histogram         Display histogram of bucket list lengths\n  -W --wide              Allow output width to exceed 80 characters\n  @<file>                Read options from <file>\n  -H --help              Display this information\n  -v --version           Display the version number of readelf\n");
#line 3485
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4);
  }
#line 3492
  if (*("<http://www.sourceware.org/bugzilla/>" + 0)) {
#line 3492
    if ((unsigned long )stream == (unsigned long )stdout) {
      {
#line 3493
      tmp___5 = gettext("Report bugs to %s\n");
#line 3493
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___5,
              "<http://www.sourceware.org/bugzilla/>");
      }
    }
  }
#line 3495
  if ((unsigned long )stream == (unsigned long )stdout) {
#line 3495
    tmp___6 = 0;
  } else {
#line 3495
    tmp___6 = 1;
  }
  {
#line 3495
  exit(tmp___6);
  }
}
}
#line 3503 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void request_dump_bynumber(unsigned int section , dump_type type ) 
{ 
  dump_type *new_dump_sects ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 3506
  if (section >= num_dump_sects) {
    {
#line 3510
    tmp___0 = calloc((size_t )(section + 1U), sizeof(*dump_sects));
#line 3510
    new_dump_sects = (dump_type *)tmp___0;
    }
#line 3513
    if ((unsigned long )new_dump_sects == (unsigned long )((void *)0)) {
      {
#line 3514
      tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 3514
      error((char const   *)tmp___1);
      }
    } else {
      {
#line 3518
      memcpy((void */* __restrict  */)new_dump_sects, (void const   */* __restrict  */)dump_sects,
             (unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 3520
      free((void *)dump_sects);
#line 3522
      dump_sects = new_dump_sects;
#line 3523
      num_dump_sects = section + 1U;
      }
    }
  }
#line 3527
  if (dump_sects) {
#line 3528
    *(dump_sects + section) = (dump_type )((int )*(dump_sects + section) | (int )type);
  }
#line 3530
  return;
}
}
#line 3535 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void request_dump_byname(char const   *section , dump_type type ) 
{ 
  struct dump_list_entry *new_request ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 3540
  tmp___0 = malloc(sizeof(struct dump_list_entry ));
#line 3540
  new_request = (struct dump_list_entry *)tmp___0;
  }
#line 3542
  if (! new_request) {
    {
#line 3543
    tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 3543
    error((char const   *)tmp___1);
    }
  }
  {
#line 3545
  new_request->name = strdup(section);
  }
#line 3546
  if (! new_request->name) {
    {
#line 3547
    tmp___2 = gettext("Out of memory allocating dump request table.\n");
#line 3547
    error((char const   *)tmp___2);
    }
  }
#line 3549
  new_request->type = type;
#line 3551
  new_request->next = dump_sects_byname;
#line 3552
  dump_sects_byname = new_request;
#line 3553
  return;
}
}
#line 3555 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
__inline static void request_dump(dump_type type ) 
{ 
  int section ;
  char *cp ;
  unsigned long tmp___0 ;

  {
  {
#line 3561
  do_dump ++;
#line 3562
  tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp),
                    0);
#line 3562
  section = (int )tmp___0;
  }
#line 3564
  if (! *cp) {
#line 3564
    if (section >= 0) {
      {
#line 3565
      request_dump_bynumber((unsigned int )section, type);
      }
    } else {
      {
#line 3567
      request_dump_byname((char const   *)optarg, type);
      }
    }
  } else {
    {
#line 3567
    request_dump_byname((char const   *)optarg, type);
    }
  }
#line 3568
  return;
}
}
#line 3571 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void parse_args(int argc , char **argv ) 
{ 
  int c ;
  char *cp ;
  unsigned long tmp___0 ;
  char *cp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3576
  if (argc < 2) {
    {
#line 3577
    usage(stderr);
    }
  }
  {
#line 3579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3579
    c = getopt_long(argc, (char * const  *)argv, "ADHINR:SVWacdeghi:lnp:rstuvw::x:",
                    (struct option  const  *)(options), (int *)((void *)0));
    }
#line 3579
    if (! (c != -1)) {
#line 3579
      goto while_break;
    }
    {
#line 3584
    if (c == 0) {
#line 3584
      goto case_0;
    }
#line 3587
    if (c == 72) {
#line 3587
      goto case_72;
    }
#line 3591
    if (c == 97) {
#line 3591
      goto case_97;
    }
#line 3605
    if (c == 103) {
#line 3605
      goto case_103;
    }
#line 3609
    if (c == 78) {
#line 3609
      goto case_78;
    }
#line 3609
    if (c == 116) {
#line 3609
      goto case_78;
    }
#line 3613
    if (c == 101) {
#line 3613
      goto case_101;
    }
#line 3618
    if (c == 65) {
#line 3618
      goto case_65;
    }
#line 3621
    if (c == 68) {
#line 3621
      goto case_68;
    }
#line 3624
    if (c == 114) {
#line 3624
      goto case_114;
    }
#line 3627
    if (c == 117) {
#line 3627
      goto case_117;
    }
#line 3630
    if (c == 104) {
#line 3630
      goto case_104;
    }
#line 3633
    if (c == 108) {
#line 3633
      goto case_108;
    }
#line 3636
    if (c == 115) {
#line 3636
      goto case_115;
    }
#line 3639
    if (c == 83) {
#line 3639
      goto case_83;
    }
#line 3642
    if (c == 100) {
#line 3642
      goto case_100;
    }
#line 3645
    if (c == 73) {
#line 3645
      goto case_73;
    }
#line 3648
    if (c == 110) {
#line 3648
      goto case_110;
    }
#line 3651
    if (c == 99) {
#line 3651
      goto case_99;
    }
#line 3654
    if (c == 120) {
#line 3654
      goto case_120;
    }
#line 3657
    if (c == 112) {
#line 3657
      goto case_112;
    }
#line 3660
    if (c == 82) {
#line 3660
      goto case_82;
    }
#line 3663
    if (c == 119) {
#line 3663
      goto case_119;
    }
#line 3676
    if (c == 512) {
#line 3676
      goto case_512;
    }
#line 3686
    if (c == 514) {
#line 3686
      goto case_514;
    }
#line 3693
    if (c == 515) {
#line 3693
      goto case_515;
    }
#line 3700
    if (c == 516) {
#line 3700
      goto case_516;
    }
#line 3703
    if (c == 513) {
#line 3703
      goto case_513;
    }
#line 3711
    if (c == 118) {
#line 3711
      goto case_118;
    }
#line 3714
    if (c == 86) {
#line 3714
      goto case_86;
    }
#line 3717
    if (c == 87) {
#line 3717
      goto case_87;
    }
#line 3724
    if (c == 63) {
#line 3724
      goto case_63;
    }
#line 3720
    goto switch_default;
    case_0: /* CIL Label */ 
#line 3586
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 3588
    usage(stdout);
    }
#line 3589
    goto switch_break;
    case_97: /* CIL Label */ 
#line 3592
    do_syms ++;
#line 3593
    do_reloc ++;
#line 3594
    do_unwind ++;
#line 3595
    do_dynamic ++;
#line 3596
    do_header ++;
#line 3597
    do_sections ++;
#line 3598
    do_section_groups ++;
#line 3599
    do_segments ++;
#line 3600
    do_version ++;
#line 3601
    do_histogram ++;
#line 3602
    do_arch ++;
#line 3603
    do_notes ++;
#line 3604
    goto switch_break;
    case_103: /* CIL Label */ 
#line 3606
    do_section_groups ++;
#line 3607
    goto switch_break;
    case_78: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 3610
    do_sections ++;
#line 3611
    do_section_details ++;
#line 3612
    goto switch_break;
    case_101: /* CIL Label */ 
#line 3614
    do_header ++;
#line 3615
    do_sections ++;
#line 3616
    do_segments ++;
#line 3617
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3619
    do_arch ++;
#line 3620
    goto switch_break;
    case_68: /* CIL Label */ 
#line 3622
    do_using_dynamic ++;
#line 3623
    goto switch_break;
    case_114: /* CIL Label */ 
#line 3625
    do_reloc ++;
#line 3626
    goto switch_break;
    case_117: /* CIL Label */ 
#line 3628
    do_unwind ++;
#line 3629
    goto switch_break;
    case_104: /* CIL Label */ 
#line 3631
    do_header ++;
#line 3632
    goto switch_break;
    case_108: /* CIL Label */ 
#line 3634
    do_segments ++;
#line 3635
    goto switch_break;
    case_115: /* CIL Label */ 
#line 3637
    do_syms ++;
#line 3638
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3640
    do_sections ++;
#line 3641
    goto switch_break;
    case_100: /* CIL Label */ 
#line 3643
    do_dynamic ++;
#line 3644
    goto switch_break;
    case_73: /* CIL Label */ 
#line 3646
    do_histogram ++;
#line 3647
    goto switch_break;
    case_110: /* CIL Label */ 
#line 3649
    do_notes ++;
#line 3650
    goto switch_break;
    case_99: /* CIL Label */ 
#line 3652
    do_archive_index ++;
#line 3653
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 3655
    request_dump((dump_type )1);
    }
#line 3656
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 3658
    request_dump((dump_type )(1 << 3));
    }
#line 3659
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 3661
    request_dump((dump_type )(1 << 4));
    }
#line 3662
    goto switch_break;
    case_119: /* CIL Label */ 
#line 3664
    do_dump ++;
#line 3665
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
      {
#line 3667
      do_debugging = 1;
#line 3668
      dwarf_select_sections_all();
      }
    } else {
      {
#line 3672
      do_debugging = 0;
#line 3673
      dwarf_select_sections_by_letters((char const   *)optarg);
      }
    }
#line 3675
    goto switch_break;
    case_512: /* CIL Label */ 
#line 3677
    do_dump ++;
#line 3678
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 3679
      do_debugging = 1;
    } else {
      {
#line 3682
      do_debugging = 0;
#line 3683
      dwarf_select_sections_by_names((char const   *)optarg);
      }
    }
#line 3685
    goto switch_break;
    case_514: /* CIL Label */ 
    {
#line 3690
    tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp),
                      0);
#line 3690
    dwarf_cutoff_level = (int )tmp___0;
    }
#line 3692
    goto switch_break;
    case_515: /* CIL Label */ 
    {
#line 3697
    dwarf_start_die = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp___0),
                              0);
    }
#line 3699
    goto switch_break;
    case_516: /* CIL Label */ 
#line 3701
    dwarf_check = 1;
#line 3702
    goto switch_break;
    case_513: /* CIL Label */ 
#line 3704
    do_dyn_syms ++;
#line 3705
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 3712
    print_version((char const   *)program_name);
    }
#line 3713
    goto switch_break;
    case_86: /* CIL Label */ 
#line 3715
    do_version ++;
#line 3716
    goto switch_break;
    case_87: /* CIL Label */ 
#line 3718
    do_wide ++;
#line 3719
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3722
    tmp___1 = gettext("Invalid option \'-%c\'\n");
#line 3722
    error((char const   *)tmp___1, c);
    }
    case_63: /* CIL Label */ 
    {
#line 3725
    usage(stderr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3729
  if (! do_dynamic) {
#line 3729
    if (! do_syms) {
#line 3729
      if (! do_reloc) {
#line 3729
        if (! do_unwind) {
#line 3729
          if (! do_sections) {
#line 3729
            if (! do_segments) {
#line 3729
              if (! do_header) {
#line 3729
                if (! do_dump) {
#line 3729
                  if (! do_version) {
#line 3729
                    if (! do_histogram) {
#line 3729
                      if (! do_debugging) {
#line 3729
                        if (! do_arch) {
#line 3729
                          if (! do_notes) {
#line 3729
                            if (! do_section_groups) {
#line 3729
                              if (! do_archive_index) {
#line 3729
                                if (! do_dyn_syms) {
                                  {
#line 3734
                                  usage(stderr);
                                  }
                                } else {
#line 3729
                                  goto _L___13;
                                }
                              } else {
#line 3729
                                goto _L___13;
                              }
                            } else {
#line 3729
                              goto _L___13;
                            }
                          } else {
#line 3729
                            goto _L___13;
                          }
                        } else {
#line 3729
                          goto _L___13;
                        }
                      } else {
#line 3729
                        goto _L___13;
                      }
                    } else {
#line 3729
                      goto _L___13;
                    }
                  } else {
#line 3729
                    goto _L___13;
                  }
                } else {
#line 3729
                  goto _L___13;
                }
              } else {
#line 3729
                goto _L___13;
              }
            } else {
#line 3729
              goto _L___13;
            }
          } else {
#line 3729
            goto _L___13;
          }
        } else {
#line 3729
          goto _L___13;
        }
      } else {
#line 3729
        goto _L___13;
      }
    } else {
#line 3729
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 3735
  if (argc < 3) {
    {
#line 3737
    tmp___2 = gettext("Nothing to do.\n");
#line 3737
    warn((char const   *)tmp___2);
#line 3738
    usage(stderr);
    }
  }
#line 3740
  return;
}
}
#line 3745 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___5[32]  ;
#line 3742 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_elf_class(unsigned int elf_class ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 3749
  if (elf_class == 0U) {
#line 3749
    goto case_0;
  }
#line 3750
  if (elf_class == 1U) {
#line 3750
    goto case_1;
  }
#line 3751
  if (elf_class == 2U) {
#line 3751
    goto case_2;
  }
#line 3752
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 3749
  tmp___0 = gettext("none");
  }
#line 3749
  return ((char const   *)tmp___0);
  case_1: /* CIL Label */ 
#line 3750
  return ("ELF32");
  case_2: /* CIL Label */ 
#line 3751
  return ("ELF64");
  switch_default: /* CIL Label */ 
  {
#line 3753
  tmp___1 = gettext("<unknown: %x>");
#line 3753
  snprintf((char */* __restrict  */)(buff___5), sizeof(buff___5), (char const   */* __restrict  */)tmp___1,
           elf_class);
  }
#line 3754
  return ((char const   *)(buff___5));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3761 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___6[32]  ;
#line 3758 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_data_encoding(unsigned int encoding ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 3765
  if (encoding == 0U) {
#line 3765
    goto case_0;
  }
#line 3766
  if (encoding == 1U) {
#line 3766
    goto case_1;
  }
#line 3767
  if (encoding == 2U) {
#line 3767
    goto case_2;
  }
#line 3768
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 3765
  tmp___0 = gettext("none");
  }
#line 3765
  return ((char const   *)tmp___0);
  case_1: /* CIL Label */ 
  {
#line 3766
  tmp___1 = gettext("2\'s complement, little endian");
  }
#line 3766
  return ((char const   *)tmp___1);
  case_2: /* CIL Label */ 
  {
#line 3767
  tmp___2 = gettext("2\'s complement, big endian");
  }
#line 3767
  return ((char const   *)tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 3769
  tmp___3 = gettext("<unknown: %x>");
#line 3769
  snprintf((char */* __restrict  */)(buff___6), sizeof(buff___6), (char const   */* __restrict  */)tmp___3,
           encoding);
  }
#line 3770
  return ((char const   *)(buff___6));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3776 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_file_header(void) 
{ 
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 3779
  if ((int )elf_header.e_ident[0] != 127) {
    {
#line 3784
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3784
    error((char const   *)tmp___0);
    }
#line 3786
    return (0);
  } else
#line 3779
  if ((int )elf_header.e_ident[1] != 69) {
    {
#line 3784
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3784
    error((char const   *)tmp___0);
    }
#line 3786
    return (0);
  } else
#line 3779
  if ((int )elf_header.e_ident[2] != 76) {
    {
#line 3784
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3784
    error((char const   *)tmp___0);
    }
#line 3786
    return (0);
  } else
#line 3779
  if ((int )elf_header.e_ident[3] != 70) {
    {
#line 3784
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3784
    error((char const   *)tmp___0);
    }
#line 3786
    return (0);
  }
  {
#line 3789
  init_dwarf_regnames((unsigned int )elf_header.e_machine);
  }
#line 3791
  if (do_header) {
    {
#line 3795
    tmp___1 = gettext("ELF Header:\n");
#line 3795
    printf((char const   */* __restrict  */)tmp___1);
#line 3796
    tmp___2 = gettext("  Magic:   ");
#line 3796
    printf((char const   */* __restrict  */)tmp___2);
#line 3797
    i = 0;
    }
    {
#line 3797
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3797
      if (! (i < 16)) {
#line 3797
        goto while_break;
      }
      {
#line 3798
      printf((char const   */* __restrict  */)"%2.2x ", (int )elf_header.e_ident[i]);
#line 3797
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3799
    printf((char const   */* __restrict  */)"\n");
#line 3800
    tmp___3 = get_elf_class((unsigned int )elf_header.e_ident[4]);
#line 3800
    tmp___4 = gettext("  Class:                             %s\n");
#line 3800
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 3802
    tmp___5 = get_data_encoding((unsigned int )elf_header.e_ident[5]);
#line 3802
    tmp___6 = gettext("  Data:                              %s\n");
#line 3802
    printf((char const   */* __restrict  */)tmp___6, tmp___5);
    }
#line 3804
    if ((int )elf_header.e_ident[6] == 1) {
#line 3804
      tmp___9 = "(current)";
    } else {
#line 3804
      if ((int )elf_header.e_ident[6] != 0) {
        {
#line 3804
        tmp___7 = gettext("<unknown: %lx>");
#line 3804
        tmp___8 = (char const   *)tmp___7;
        }
      } else {
#line 3804
        tmp___8 = "";
      }
#line 3804
      tmp___9 = tmp___8;
    }
    {
#line 3804
    tmp___10 = gettext("  Version:                           %d %s\n");
#line 3804
    printf((char const   */* __restrict  */)tmp___10, (int )elf_header.e_ident[6],
           tmp___9);
#line 3811
    tmp___11 = get_osabi_name((unsigned int )elf_header.e_ident[7]);
#line 3811
    tmp___12 = gettext("  OS/ABI:                            %s\n");
#line 3811
    printf((char const   */* __restrict  */)tmp___12, tmp___11);
#line 3813
    tmp___13 = gettext("  ABI Version:                       %d\n");
#line 3813
    printf((char const   */* __restrict  */)tmp___13, (int )elf_header.e_ident[8]);
#line 3815
    tmp___14 = get_file_type((unsigned int )elf_header.e_type);
#line 3815
    tmp___15 = gettext("  Type:                              %s\n");
#line 3815
    printf((char const   */* __restrict  */)tmp___15, tmp___14);
#line 3817
    tmp___16 = get_machine_name((unsigned int )elf_header.e_machine);
#line 3817
    tmp___17 = gettext("  Machine:                           %s\n");
#line 3817
    printf((char const   */* __restrict  */)tmp___17, tmp___16);
#line 3819
    tmp___18 = gettext("  Version:                           0x%lx\n");
#line 3819
    printf((char const   */* __restrict  */)tmp___18, elf_header.e_version);
#line 3822
    tmp___19 = gettext("  Entry point address:               ");
#line 3822
    printf((char const   */* __restrict  */)tmp___19);
#line 3823
    print_vma(elf_header.e_entry, (print_mode )4);
#line 3824
    tmp___20 = gettext("\n  Start of program headers:          ");
#line 3824
    printf((char const   */* __restrict  */)tmp___20);
#line 3825
    print_vma(elf_header.e_phoff, (print_mode )1);
#line 3826
    tmp___21 = gettext(" (bytes into file)\n  Start of section headers:          ");
#line 3826
    printf((char const   */* __restrict  */)tmp___21);
#line 3827
    print_vma(elf_header.e_shoff, (print_mode )1);
#line 3828
    tmp___22 = gettext(" (bytes into file)\n");
#line 3828
    printf((char const   */* __restrict  */)tmp___22);
#line 3830
    tmp___23 = get_machine_flags((unsigned int )elf_header.e_flags, (unsigned int )elf_header.e_machine);
#line 3830
    tmp___24 = gettext("  Flags:                             0x%lx%s\n");
#line 3830
    printf((char const   */* __restrict  */)tmp___24, elf_header.e_flags, tmp___23);
#line 3833
    tmp___25 = gettext("  Size of this header:               %ld (bytes)\n");
#line 3833
    printf((char const   */* __restrict  */)tmp___25, (long )elf_header.e_ehsize);
#line 3835
    tmp___26 = gettext("  Size of program headers:           %ld (bytes)\n");
#line 3835
    printf((char const   */* __restrict  */)tmp___26, (long )elf_header.e_phentsize);
#line 3837
    tmp___27 = gettext("  Number of program headers:         %ld");
#line 3837
    printf((char const   */* __restrict  */)tmp___27, (long )elf_header.e_phnum);
    }
#line 3839
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3839
      if (elf_header.e_phnum == 65535U) {
#line 3839
        if ((section_headers + 0)->sh_info != 0U) {
          {
#line 3842
          printf((char const   */* __restrict  */)" (%ld)", (long )(section_headers + 0)->sh_info);
          }
        }
      }
    }
    {
#line 3843
    _IO_putc('\n', stdout);
#line 3844
    tmp___28 = gettext("  Size of section headers:           %ld (bytes)\n");
#line 3844
    printf((char const   */* __restrict  */)tmp___28, (long )elf_header.e_shentsize);
#line 3846
    tmp___29 = gettext("  Number of section headers:         %ld");
#line 3846
    printf((char const   */* __restrict  */)tmp___29, (long )elf_header.e_shnum);
    }
#line 3848
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3848
      if (elf_header.e_shnum == 0U) {
        {
#line 3849
        printf((char const   */* __restrict  */)" (%ld)", (long )(section_headers + 0)->sh_size);
        }
      }
    }
    {
#line 3850
    _IO_putc('\n', stdout);
#line 3851
    tmp___30 = gettext("  Section header string table index: %ld");
#line 3851
    printf((char const   */* __restrict  */)tmp___30, (long )elf_header.e_shstrndx);
    }
#line 3853
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3853
      if (elf_header.e_shstrndx == 65535U) {
        {
#line 3855
        printf((char const   */* __restrict  */)" (%u)", (section_headers + 0)->sh_link);
        }
      } else {
#line 3853
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3856
    if (elf_header.e_shstrndx != 0U) {
#line 3856
      if (elf_header.e_shstrndx >= elf_header.e_shnum) {
        {
#line 3858
        tmp___31 = gettext(" <corrupt: out of range>");
#line 3858
        printf((char const   */* __restrict  */)tmp___31);
        }
      }
    }
    {
#line 3859
    _IO_putc('\n', stdout);
    }
  }
#line 3862
  if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3864
    if (elf_header.e_phnum == 65535U) {
#line 3864
      if ((section_headers + 0)->sh_info != 0U) {
#line 3866
        elf_header.e_phnum = (section_headers + 0)->sh_info;
      }
    }
#line 3867
    if (elf_header.e_shnum == 0U) {
#line 3868
      elf_header.e_shnum = (unsigned int )(section_headers + 0)->sh_size;
    }
#line 3869
    if (elf_header.e_shstrndx == 65535U) {
#line 3870
      elf_header.e_shstrndx = (section_headers + 0)->sh_link;
    } else
#line 3871
    if (elf_header.e_shstrndx >= elf_header.e_shnum) {
#line 3872
      elf_header.e_shstrndx = 0U;
    }
    {
#line 3873
    free((void *)section_headers);
#line 3874
    section_headers = (Elf_Internal_Shdr *)((void *)0);
    }
  }
#line 3877
  return (1);
}
}
#line 3881 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_32bit_program_headers(FILE *file , Elf_Internal_Phdr *pheaders ) 
{ 
  Elf32_External_Phdr *phdrs ;
  Elf32_External_Phdr *external ;
  Elf_Internal_Phdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 3889
  tmp___0 = gettext("program headers");
#line 3889
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_phoff, (size_t )elf_header.e_phentsize,
                     (size_t )elf_header.e_phnum, (char const   *)tmp___0);
#line 3889
  phdrs = (Elf32_External_Phdr *)tmp___1;
  }
#line 3893
  if (! phdrs) {
#line 3894
    return (0);
  }
#line 3896
  i = 0U;
#line 3896
  internal = pheaders;
#line 3896
  external = phdrs;
  {
#line 3896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3896
    if (! (i < elf_header.e_phnum)) {
#line 3896
      goto while_break;
    }
    {
#line 3900
    tmp___2 = (*byte_get)(external->p_type, (int )sizeof(external->p_type));
#line 3900
    internal->p_type = (unsigned long )tmp___2;
#line 3901
    tmp___3 = (*byte_get)(external->p_offset, (int )sizeof(external->p_offset));
#line 3901
    internal->p_offset = (bfd_vma )tmp___3;
#line 3902
    tmp___4 = (*byte_get)(external->p_vaddr, (int )sizeof(external->p_vaddr));
#line 3902
    internal->p_vaddr = (bfd_vma )tmp___4;
#line 3903
    tmp___5 = (*byte_get)(external->p_paddr, (int )sizeof(external->p_paddr));
#line 3903
    internal->p_paddr = (bfd_vma )tmp___5;
#line 3904
    tmp___6 = (*byte_get)(external->p_filesz, (int )sizeof(external->p_filesz));
#line 3904
    internal->p_filesz = (bfd_vma )tmp___6;
#line 3905
    tmp___7 = (*byte_get)(external->p_memsz, (int )sizeof(external->p_memsz));
#line 3905
    internal->p_memsz = (bfd_vma )tmp___7;
#line 3906
    tmp___8 = (*byte_get)(external->p_flags, (int )sizeof(external->p_flags));
#line 3906
    internal->p_flags = (unsigned long )tmp___8;
#line 3907
    tmp___9 = (*byte_get)(external->p_align, (int )sizeof(external->p_align));
#line 3907
    internal->p_align = (bfd_vma )tmp___9;
#line 3896
    i ++;
#line 3896
    internal ++;
#line 3896
    external ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3910
  free((void *)phdrs);
  }
#line 3912
  return (1);
}
}
#line 3915 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_64bit_program_headers(FILE *file , Elf_Internal_Phdr *pheaders ) 
{ 
  Elf64_External_Phdr *phdrs ;
  Elf64_External_Phdr *external ;
  Elf_Internal_Phdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 3923
  tmp___0 = gettext("program headers");
#line 3923
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_phoff, (size_t )elf_header.e_phentsize,
                     (size_t )elf_header.e_phnum, (char const   *)tmp___0);
#line 3923
  phdrs = (Elf64_External_Phdr *)tmp___1;
  }
#line 3927
  if (! phdrs) {
#line 3928
    return (0);
  }
#line 3930
  i = 0U;
#line 3930
  internal = pheaders;
#line 3930
  external = phdrs;
  {
#line 3930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3930
    if (! (i < elf_header.e_phnum)) {
#line 3930
      goto while_break;
    }
    {
#line 3934
    tmp___2 = (*byte_get)(external->p_type, (int )sizeof(external->p_type));
#line 3934
    internal->p_type = (unsigned long )tmp___2;
#line 3935
    tmp___3 = (*byte_get)(external->p_flags, (int )sizeof(external->p_flags));
#line 3935
    internal->p_flags = (unsigned long )tmp___3;
#line 3936
    tmp___4 = (*byte_get)(external->p_offset, (int )sizeof(external->p_offset));
#line 3936
    internal->p_offset = (bfd_vma )tmp___4;
#line 3937
    tmp___5 = (*byte_get)(external->p_vaddr, (int )sizeof(external->p_vaddr));
#line 3937
    internal->p_vaddr = (bfd_vma )tmp___5;
#line 3938
    tmp___6 = (*byte_get)(external->p_paddr, (int )sizeof(external->p_paddr));
#line 3938
    internal->p_paddr = (bfd_vma )tmp___6;
#line 3939
    tmp___7 = (*byte_get)(external->p_filesz, (int )sizeof(external->p_filesz));
#line 3939
    internal->p_filesz = (bfd_vma )tmp___7;
#line 3940
    tmp___8 = (*byte_get)(external->p_memsz, (int )sizeof(external->p_memsz));
#line 3940
    internal->p_memsz = (bfd_vma )tmp___8;
#line 3941
    tmp___9 = (*byte_get)(external->p_align, (int )sizeof(external->p_align));
#line 3941
    internal->p_align = (bfd_vma )tmp___9;
#line 3930
    i ++;
#line 3930
    internal ++;
#line 3930
    external ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3944
  free((void *)phdrs);
  }
#line 3946
  return (1);
}
}
#line 3951 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_program_headers(FILE *file ) 
{ 
  Elf_Internal_Phdr *phdrs ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3957
  if ((unsigned long )program_headers != (unsigned long )((void *)0)) {
#line 3958
    return (1);
  }
  {
#line 3960
  tmp___0 = cmalloc((size_t )elf_header.e_phnum, sizeof(Elf_Internal_Phdr ));
#line 3960
  phdrs = (Elf_Internal_Phdr *)tmp___0;
  }
#line 3963
  if ((unsigned long )phdrs == (unsigned long )((void *)0)) {
    {
#line 3965
    tmp___1 = gettext("Out of memory\n");
#line 3965
    error((char const   *)tmp___1);
    }
#line 3966
    return (0);
  }
#line 3969
  if (is_32bit_elf) {
    {
#line 3969
    tmp___2 = get_32bit_program_headers(file, phdrs);
#line 3969
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 3969
    tmp___3 = get_64bit_program_headers(file, phdrs);
#line 3969
    tmp___4 = tmp___3;
    }
  }
#line 3969
  if (tmp___4) {
#line 3973
    program_headers = phdrs;
#line 3974
    return (1);
  }
  {
#line 3977
  free((void *)phdrs);
  }
#line 3978
  return (0);
}
}
#line 3983 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_program_headers(FILE *file ) 
{ 
  Elf_Internal_Phdr *segment ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  Elf_Internal_Shdr *sec ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char fmt[32] ;
  int ret ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  unsigned int j ;
  Elf_Internal_Shdr *section ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  bfd_size_type tmp___43 ;
  bfd_size_type tmp___44 ;

  {
#line 3989
  if (elf_header.e_phnum == 0U) {
#line 3992
    if (elf_header.e_phoff != 0UL) {
      {
#line 3993
      tmp___0 = gettext("possibly corrupt ELF header - it has a non-zero program header offset, but no program headers");
#line 3993
      warn((char const   *)tmp___0);
      }
    } else
#line 3995
    if (do_segments) {
      {
#line 3996
      tmp___1 = gettext("\nThere are no program headers in this file.\n");
#line 3996
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 3997
    return (0);
  }
#line 4000
  if (do_segments) {
#line 4000
    if (! do_header) {
      {
#line 4002
      tmp___2 = get_file_type((unsigned int )elf_header.e_type);
#line 4002
      tmp___3 = gettext("\nElf file type is %s\n");
#line 4002
      printf((char const   */* __restrict  */)tmp___3, tmp___2);
#line 4003
      tmp___4 = gettext("Entry point ");
#line 4003
      printf((char const   */* __restrict  */)tmp___4);
#line 4004
      print_vma(elf_header.e_entry, (print_mode )4);
#line 4005
      tmp___5 = gettext("\nThere are %d program headers, starting at offset ");
#line 4005
      printf((char const   */* __restrict  */)tmp___5, elf_header.e_phnum);
#line 4007
      print_vma(elf_header.e_phoff, (print_mode )1);
#line 4008
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 4011
  tmp___6 = get_program_headers(file);
  }
#line 4011
  if (! tmp___6) {
#line 4012
    return (0);
  }
#line 4014
  if (do_segments) {
#line 4016
    if (elf_header.e_phnum > 1U) {
      {
#line 4017
      tmp___7 = gettext("\nProgram Headers:\n");
#line 4017
      printf((char const   */* __restrict  */)tmp___7);
      }
    } else {
      {
#line 4019
      tmp___8 = gettext("\nProgram Headers:\n");
#line 4019
      printf((char const   */* __restrict  */)tmp___8);
      }
    }
#line 4021
    if (is_32bit_elf) {
      {
#line 4022
      tmp___9 = gettext("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n");
#line 4022
      printf((char const   */* __restrict  */)tmp___9);
      }
    } else
#line 4024
    if (do_wide) {
      {
#line 4025
      tmp___10 = gettext("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n");
#line 4025
      printf((char const   */* __restrict  */)tmp___10);
      }
    } else {
      {
#line 4029
      tmp___11 = gettext("  Type           Offset             VirtAddr           PhysAddr\n");
#line 4029
      printf((char const   */* __restrict  */)tmp___11);
#line 4031
      tmp___12 = gettext("                 FileSiz            MemSiz              Flags  Align\n");
#line 4031
      printf((char const   */* __restrict  */)tmp___12);
      }
    }
  }
#line 4036
  dynamic_addr = 0UL;
#line 4037
  dynamic_size = (bfd_size_type )0;
#line 4039
  i = 0U;
#line 4039
  segment = program_headers;
  {
#line 4039
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4039
    if (! (i < elf_header.e_phnum)) {
#line 4039
      goto while_break;
    }
#line 4043
    if (do_segments) {
      {
#line 4045
      tmp___13 = get_segment_type(segment->p_type);
#line 4045
      printf((char const   */* __restrict  */)"  %-14.14s ", tmp___13);
      }
#line 4047
      if (is_32bit_elf) {
        {
#line 4049
        printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_offset);
#line 4050
        printf((char const   */* __restrict  */)"0x%8.8lx ", segment->p_vaddr);
#line 4051
        printf((char const   */* __restrict  */)"0x%8.8lx ", segment->p_paddr);
#line 4052
        printf((char const   */* __restrict  */)"0x%5.5lx ", segment->p_filesz);
#line 4053
        printf((char const   */* __restrict  */)"0x%5.5lx ", segment->p_memsz);
        }
#line 4054
        if (segment->p_flags & 1UL) {
#line 4054
          tmp___14 = 'E';
        } else {
#line 4054
          tmp___14 = ' ';
        }
#line 4054
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 4054
          tmp___15 = 'W';
        } else {
#line 4054
          tmp___15 = ' ';
        }
#line 4054
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 4054
          tmp___16 = 'R';
        } else {
#line 4054
          tmp___16 = ' ';
        }
        {
#line 4054
        printf((char const   */* __restrict  */)"%c%c%c ", tmp___16, tmp___15, tmp___14);
#line 4058
        printf((char const   */* __restrict  */)"%#lx", segment->p_align);
        }
      } else
#line 4060
      if (do_wide) {
#line 4062
        if (segment->p_offset == segment->p_offset) {
          {
#line 4063
          printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_offset);
          }
        } else {
          {
#line 4066
          print_vma(segment->p_offset, (print_mode )5);
#line 4067
          putchar(' ');
          }
        }
        {
#line 4070
        print_vma(segment->p_vaddr, (print_mode )5);
#line 4071
        putchar(' ');
#line 4072
        print_vma(segment->p_paddr, (print_mode )5);
#line 4073
        putchar(' ');
        }
#line 4075
        if (segment->p_filesz == segment->p_filesz) {
          {
#line 4076
          printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_filesz);
          }
        } else {
          {
#line 4079
          print_vma(segment->p_filesz, (print_mode )5);
#line 4080
          putchar(' ');
          }
        }
#line 4083
        if (segment->p_memsz == segment->p_memsz) {
          {
#line 4084
          printf((char const   */* __restrict  */)"0x%6.6lx", segment->p_memsz);
          }
        } else {
          {
#line 4087
          print_vma(segment->p_memsz, (print_mode )5);
          }
        }
#line 4090
        if (segment->p_flags & 1UL) {
#line 4090
          tmp___17 = 'E';
        } else {
#line 4090
          tmp___17 = ' ';
        }
#line 4090
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 4090
          tmp___18 = 'W';
        } else {
#line 4090
          tmp___18 = ' ';
        }
#line 4090
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 4090
          tmp___19 = 'R';
        } else {
#line 4090
          tmp___19 = ' ';
        }
        {
#line 4090
        printf((char const   */* __restrict  */)" %c%c%c ", tmp___19, tmp___18, tmp___17);
        }
#line 4095
        if (segment->p_align == segment->p_align) {
          {
#line 4096
          printf((char const   */* __restrict  */)"%#lx", segment->p_align);
          }
        } else {
          {
#line 4099
          print_vma(segment->p_align, (print_mode )4);
          }
        }
      } else {
        {
#line 4104
        print_vma(segment->p_offset, (print_mode )5);
#line 4105
        putchar(' ');
#line 4106
        print_vma(segment->p_vaddr, (print_mode )5);
#line 4107
        putchar(' ');
#line 4108
        print_vma(segment->p_paddr, (print_mode )5);
#line 4109
        printf((char const   */* __restrict  */)"\n                 ");
#line 4110
        print_vma(segment->p_filesz, (print_mode )5);
#line 4111
        putchar(' ');
#line 4112
        print_vma(segment->p_memsz, (print_mode )5);
        }
#line 4113
        if (segment->p_flags & 1UL) {
#line 4113
          tmp___20 = 'E';
        } else {
#line 4113
          tmp___20 = ' ';
        }
#line 4113
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 4113
          tmp___21 = 'W';
        } else {
#line 4113
          tmp___21 = ' ';
        }
#line 4113
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 4113
          tmp___22 = 'R';
        } else {
#line 4113
          tmp___22 = ' ';
        }
        {
#line 4113
        printf((char const   */* __restrict  */)"  %c%c%c    ", tmp___22, tmp___21,
               tmp___20);
#line 4117
        print_vma(segment->p_align, (print_mode )0);
        }
      }
    }
    {
#line 4123
    if (segment->p_type == 2UL) {
#line 4123
      goto case_2;
    }
#line 4167
    if (segment->p_type == 3UL) {
#line 4167
      goto case_3;
    }
#line 4121
    goto switch_break;
    case_2: /* CIL Label */ 
#line 4124
    if (dynamic_addr) {
      {
#line 4125
      tmp___23 = gettext("more than one dynamic segment\n");
#line 4125
      error((char const   *)tmp___23);
      }
    }
#line 4129
    dynamic_addr = segment->p_offset;
#line 4130
    dynamic_size = segment->p_filesz;
#line 4134
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
      {
#line 4138
      sec = find_section(".dynamic");
      }
#line 4139
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
#line 4139
        goto _L;
      } else
#line 4139
      if (sec->sh_size == 0UL) {
        _L: /* CIL Label */ 
        {
#line 4143
        tmp___25 = is_ia64_vms();
        }
#line 4143
        if (! tmp___25) {
          {
#line 4144
          tmp___24 = gettext("no .dynamic section in the dynamic segment\n");
#line 4144
          error((char const   *)tmp___24);
          }
        }
#line 4145
        goto switch_break;
      }
#line 4148
      if (sec->sh_type == 8U) {
#line 4150
        dynamic_size = (bfd_size_type )0;
#line 4151
        goto switch_break;
      }
#line 4154
      dynamic_addr = (unsigned long )sec->sh_offset;
#line 4155
      dynamic_size = sec->sh_size;
#line 4157
      if (dynamic_addr < segment->p_offset) {
        {
#line 4159
        tmp___26 = gettext("the .dynamic section is not contained within the dynamic segment\n");
#line 4159
        warn((char const   *)tmp___26);
        }
      } else
#line 4157
      if (dynamic_addr > segment->p_offset + segment->p_filesz) {
        {
#line 4159
        tmp___26 = gettext("the .dynamic section is not contained within the dynamic segment\n");
#line 4159
        warn((char const   *)tmp___26);
        }
      } else
#line 4161
      if (dynamic_addr > segment->p_offset) {
        {
#line 4162
        tmp___27 = gettext("the .dynamic section is not the first section in the dynamic segment.\n");
#line 4162
        warn((char const   *)tmp___27);
        }
      }
    }
#line 4165
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 4168
    tmp___34 = fseek(file, archive_file_offset + (long )segment->p_offset, 0);
    }
#line 4168
    if (tmp___34) {
      {
#line 4170
      tmp___28 = gettext("Unable to find program interpreter name\n");
#line 4170
      error((char const   *)tmp___28);
      }
    } else {
      {
#line 4174
      tmp___29 = snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%%%ds",
                          4096);
#line 4174
      ret = tmp___29;
      }
#line 4176
      if (ret >= (int )sizeof(fmt)) {
        {
#line 4177
        tmp___30 = gettext("Internal error: failed to create format string to display program interpreter\n");
#line 4177
        error((char const   *)tmp___30);
        }
      } else
#line 4176
      if (ret < 0) {
        {
#line 4177
        tmp___30 = gettext("Internal error: failed to create format string to display program interpreter\n");
#line 4177
        error((char const   *)tmp___30);
        }
      }
      {
#line 4179
      program_interpreter[0] = (char)0;
#line 4180
      tmp___32 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(fmt),
                        program_interpreter);
      }
#line 4180
      if (tmp___32 <= 0) {
        {
#line 4181
        tmp___31 = gettext("Unable to read program interpreter name\n");
#line 4181
        error((char const   *)tmp___31);
        }
      }
#line 4183
      if (do_segments) {
        {
#line 4184
        tmp___33 = gettext("\n      [Requesting program interpreter: %s]");
#line 4184
        printf((char const   */* __restrict  */)tmp___33, program_interpreter);
        }
      }
    }
#line 4187
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4190
    if (do_segments) {
      {
#line 4191
      _IO_putc('\n', stdout);
      }
    }
#line 4039
    i ++;
#line 4039
    segment ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4194
  if (do_segments) {
#line 4194
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 4194
      if ((unsigned long )string_table != (unsigned long )((void *)0)) {
        {
#line 4196
        tmp___35 = gettext("\n Section to Segment mapping:\n");
#line 4196
        printf((char const   */* __restrict  */)tmp___35);
#line 4197
        tmp___36 = gettext("  Segment Sections...\n");
#line 4197
        printf((char const   */* __restrict  */)tmp___36);
#line 4199
        i = 0U;
        }
        {
#line 4199
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4199
          if (! (i < elf_header.e_phnum)) {
#line 4199
            goto while_break___0;
          }
          {
#line 4204
          segment = program_headers + i;
#line 4205
          section = section_headers + 1;
#line 4207
          printf((char const   */* __restrict  */)"   %2.2d     ", i);
#line 4209
          j = 1U;
          }
          {
#line 4209
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 4209
            if (! (j < elf_header.e_shnum)) {
#line 4209
              goto while_break___1;
            }
#line 4211
            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 4211
              if (section->sh_type == 8U) {
#line 4211
                if (! (segment->p_type != 7UL)) {
#line 4211
                  goto _L___8;
                }
              } else {
#line 4211
                goto _L___8;
              }
            } else
            _L___8: /* CIL Label */ 
#line 4211
            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 4211
              if (segment->p_type == 7UL) {
#line 4211
                goto _L___5;
              } else
#line 4211
              if (segment->p_type == 1685382482UL) {
#line 4211
                goto _L___5;
              } else
#line 4211
              if (segment->p_type == 1UL) {
#line 4211
                goto _L___5;
              } else {
#line 4211
                goto _L___6;
              }
            } else
            _L___6: /* CIL Label */ 
#line 4211
            if ((section->sh_flags & (unsigned long )(1 << 10)) == 0UL) {
#line 4211
              if (segment->p_type != 7UL) {
#line 4211
                if (segment->p_type != 6UL) {
                  _L___5: /* CIL Label */ 
#line 4211
                  if (section->sh_type == 8U) {
#line 4211
                    goto _L___4;
                  } else
#line 4211
                  if ((bfd_vma )section->sh_offset >= segment->p_offset) {
#line 4211
                    if ((bfd_vma )section->sh_offset - segment->p_offset <= segment->p_filesz - 1UL) {
#line 4211
                      if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 4211
                        if (section->sh_type == 8U) {
#line 4211
                          if (segment->p_type != 7UL) {
#line 4211
                            tmp___43 = (bfd_size_type )0;
                          } else {
#line 4211
                            tmp___43 = section->sh_size;
                          }
                        } else {
#line 4211
                          tmp___43 = section->sh_size;
                        }
                      } else {
#line 4211
                        tmp___43 = section->sh_size;
                      }
#line 4211
                      if (((bfd_vma )section->sh_offset - segment->p_offset) + tmp___43 <= segment->p_filesz) {
                        _L___4: /* CIL Label */ 
#line 4211
                        if ((section->sh_flags & (unsigned long )(1 << 1)) == 0UL) {
#line 4211
                          goto _L___3;
                        } else
#line 4211
                        if (section->sh_addr >= segment->p_vaddr) {
#line 4211
                          if (section->sh_addr - segment->p_vaddr <= segment->p_memsz - 1UL) {
#line 4211
                            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 4211
                              if (section->sh_type == 8U) {
#line 4211
                                if (segment->p_type != 7UL) {
#line 4211
                                  tmp___44 = (bfd_size_type )0;
                                } else {
#line 4211
                                  tmp___44 = section->sh_size;
                                }
                              } else {
#line 4211
                                tmp___44 = section->sh_size;
                              }
                            } else {
#line 4211
                              tmp___44 = section->sh_size;
                            }
#line 4211
                            if ((section->sh_addr - segment->p_vaddr) + tmp___44 <= segment->p_memsz) {
                              _L___3: /* CIL Label */ 
#line 4211
                              if (segment->p_type != 2UL) {
#line 4211
                                goto _L___1;
                              } else
#line 4211
                              if (section->sh_size != 0UL) {
#line 4211
                                goto _L___1;
                              } else
#line 4211
                              if (segment->p_memsz == 0UL) {
#line 4211
                                goto _L___1;
                              } else
#line 4211
                              if (section->sh_type == 8U) {
#line 4211
                                goto _L___2;
                              } else
#line 4211
                              if ((bfd_vma )section->sh_offset > segment->p_offset) {
#line 4211
                                if ((bfd_vma )section->sh_offset - segment->p_offset < segment->p_filesz) {
                                  _L___2: /* CIL Label */ 
#line 4211
                                  if ((section->sh_flags & (unsigned long )(1 << 1)) == 0UL) {
#line 4211
                                    goto _L___1;
                                  } else
#line 4211
                                  if (section->sh_addr > segment->p_vaddr) {
#line 4211
                                    if (section->sh_addr - segment->p_vaddr < segment->p_memsz) {
                                      _L___1: /* CIL Label */ 
#line 4213
                                      if ((unsigned long )section == (unsigned long )((void *)0)) {
                                        {
#line 4213
                                        tmp___37 = gettext("<none>");
#line 4213
                                        tmp___42 = tmp___37;
                                        }
                                      } else {
#line 4213
                                        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                                          {
#line 4213
                                          tmp___38 = gettext("<no-name>");
#line 4213
                                          tmp___41 = tmp___38;
                                          }
                                        } else {
#line 4213
                                          if ((unsigned long )section->sh_name >= string_table_length) {
                                            {
#line 4213
                                            tmp___39 = gettext("<corrupt>");
#line 4213
                                            tmp___40 = tmp___39;
                                            }
                                          } else {
#line 4213
                                            tmp___40 = string_table + section->sh_name;
                                          }
#line 4213
                                          tmp___41 = tmp___40;
                                        }
#line 4213
                                        tmp___42 = tmp___41;
                                      }
                                      {
#line 4213
                                      printf((char const   */* __restrict  */)"%s ",
                                             tmp___42);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 4209
            j ++;
#line 4209
            section ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 4216
          _IO_putc('\n', stdout);
#line 4199
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 4220
  return (1);
}
}
#line 4226 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static long offset_from_vma(FILE *file , bfd_vma vma , bfd_size_type size ) 
{ 
  Elf_Internal_Phdr *seg ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 4231
  tmp___1 = get_program_headers(file);
  }
#line 4231
  if (! tmp___1) {
    {
#line 4233
    tmp___0 = gettext("Cannot interpret virtual addresses without program headers.\n");
#line 4233
    warn((char const   *)tmp___0);
    }
#line 4234
    return ((long )vma);
  }
#line 4237
  seg = program_headers;
  {
#line 4237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4237
    if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 4237
      goto while_break;
    }
#line 4241
    if (seg->p_type != 1UL) {
#line 4242
      goto __Cont;
    }
#line 4244
    if (vma >= (seg->p_vaddr & - seg->p_align)) {
#line 4244
      if (vma + size <= seg->p_vaddr + seg->p_filesz) {
#line 4246
        return ((long )((vma - seg->p_vaddr) + seg->p_offset));
      }
    }
    __Cont: /* CIL Label */ 
#line 4237
    seg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4249
  tmp___2 = gettext("Virtual address 0x%lx not located in any PT_LOAD segment.\n");
#line 4249
  warn((char const   *)tmp___2, vma);
  }
#line 4251
  return ((long )vma);
}
}
#line 4255 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_32bit_section_headers(FILE *file , unsigned int num ) 
{ 
  Elf32_External_Shdr *shdrs ;
  Elf_Internal_Shdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;

  {
  {
#line 4262
  tmp___0 = gettext("section headers");
#line 4262
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_shoff, (size_t )elf_header.e_shentsize,
                     (size_t )num, (char const   *)tmp___0);
#line 4262
  shdrs = (Elf32_External_Shdr *)tmp___1;
  }
#line 4265
  if (! shdrs) {
#line 4266
    return (0);
  }
  {
#line 4268
  tmp___2 = cmalloc((size_t )num, sizeof(Elf_Internal_Shdr ));
#line 4268
  section_headers = (Elf_Internal_Shdr *)tmp___2;
  }
#line 4271
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 4273
    tmp___3 = gettext("Out of memory\n");
#line 4273
    error((char const   *)tmp___3);
    }
#line 4274
    return (0);
  }
#line 4277
  i = 0U;
#line 4277
  internal = section_headers;
  {
#line 4277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4277
    if (! (i < num)) {
#line 4277
      goto while_break;
    }
    {
#line 4281
    tmp___4 = (*byte_get)((shdrs + i)->sh_name, (int )sizeof((shdrs + i)->sh_name));
#line 4281
    internal->sh_name = (unsigned int )tmp___4;
#line 4282
    tmp___5 = (*byte_get)((shdrs + i)->sh_type, (int )sizeof((shdrs + i)->sh_type));
#line 4282
    internal->sh_type = (unsigned int )tmp___5;
#line 4283
    tmp___6 = (*byte_get)((shdrs + i)->sh_flags, (int )sizeof((shdrs + i)->sh_flags));
#line 4283
    internal->sh_flags = (bfd_vma )tmp___6;
#line 4284
    tmp___7 = (*byte_get)((shdrs + i)->sh_addr, (int )sizeof((shdrs + i)->sh_addr));
#line 4284
    internal->sh_addr = (bfd_vma )tmp___7;
#line 4285
    tmp___8 = (*byte_get)((shdrs + i)->sh_offset, (int )sizeof((shdrs + i)->sh_offset));
#line 4285
    internal->sh_offset = (file_ptr )tmp___8;
#line 4286
    tmp___9 = (*byte_get)((shdrs + i)->sh_size, (int )sizeof((shdrs + i)->sh_size));
#line 4286
    internal->sh_size = (bfd_size_type )tmp___9;
#line 4287
    tmp___10 = (*byte_get)((shdrs + i)->sh_link, (int )sizeof((shdrs + i)->sh_link));
#line 4287
    internal->sh_link = (unsigned int )tmp___10;
#line 4288
    tmp___11 = (*byte_get)((shdrs + i)->sh_info, (int )sizeof((shdrs + i)->sh_info));
#line 4288
    internal->sh_info = (unsigned int )tmp___11;
#line 4289
    tmp___12 = (*byte_get)((shdrs + i)->sh_addralign, (int )sizeof((shdrs + i)->sh_addralign));
#line 4289
    internal->sh_addralign = (bfd_vma )tmp___12;
#line 4290
    tmp___13 = (*byte_get)((shdrs + i)->sh_entsize, (int )sizeof((shdrs + i)->sh_entsize));
#line 4290
    internal->sh_entsize = (bfd_size_type )tmp___13;
#line 4277
    i ++;
#line 4277
    internal ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4293
  free((void *)shdrs);
  }
#line 4295
  return (1);
}
}
#line 4298 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_64bit_section_headers(FILE *file , unsigned int num ) 
{ 
  Elf64_External_Shdr *shdrs ;
  Elf_Internal_Shdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;

  {
  {
#line 4305
  tmp___0 = gettext("section headers");
#line 4305
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_shoff, (size_t )elf_header.e_shentsize,
                     (size_t )num, (char const   *)tmp___0);
#line 4305
  shdrs = (Elf64_External_Shdr *)tmp___1;
  }
#line 4308
  if (! shdrs) {
#line 4309
    return (0);
  }
  {
#line 4311
  tmp___2 = cmalloc((size_t )num, sizeof(Elf_Internal_Shdr ));
#line 4311
  section_headers = (Elf_Internal_Shdr *)tmp___2;
  }
#line 4314
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 4316
    tmp___3 = gettext("Out of memory\n");
#line 4316
    error((char const   *)tmp___3);
    }
#line 4317
    return (0);
  }
#line 4320
  i = 0U;
#line 4320
  internal = section_headers;
  {
#line 4320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4320
    if (! (i < num)) {
#line 4320
      goto while_break;
    }
    {
#line 4324
    tmp___4 = (*byte_get)((shdrs + i)->sh_name, (int )sizeof((shdrs + i)->sh_name));
#line 4324
    internal->sh_name = (unsigned int )tmp___4;
#line 4325
    tmp___5 = (*byte_get)((shdrs + i)->sh_type, (int )sizeof((shdrs + i)->sh_type));
#line 4325
    internal->sh_type = (unsigned int )tmp___5;
#line 4326
    tmp___6 = (*byte_get)((shdrs + i)->sh_flags, (int )sizeof((shdrs + i)->sh_flags));
#line 4326
    internal->sh_flags = (bfd_vma )tmp___6;
#line 4327
    tmp___7 = (*byte_get)((shdrs + i)->sh_addr, (int )sizeof((shdrs + i)->sh_addr));
#line 4327
    internal->sh_addr = (bfd_vma )tmp___7;
#line 4328
    tmp___8 = (*byte_get)((shdrs + i)->sh_size, (int )sizeof((shdrs + i)->sh_size));
#line 4328
    internal->sh_size = (bfd_size_type )tmp___8;
#line 4329
    tmp___9 = (*byte_get)((shdrs + i)->sh_entsize, (int )sizeof((shdrs + i)->sh_entsize));
#line 4329
    internal->sh_entsize = (bfd_size_type )tmp___9;
#line 4330
    tmp___10 = (*byte_get)((shdrs + i)->sh_link, (int )sizeof((shdrs + i)->sh_link));
#line 4330
    internal->sh_link = (unsigned int )tmp___10;
#line 4331
    tmp___11 = (*byte_get)((shdrs + i)->sh_info, (int )sizeof((shdrs + i)->sh_info));
#line 4331
    internal->sh_info = (unsigned int )tmp___11;
#line 4332
    tmp___12 = (*byte_get)((shdrs + i)->sh_offset, (int )sizeof((shdrs + i)->sh_offset));
#line 4332
    internal->sh_offset = (file_ptr )tmp___12;
#line 4333
    tmp___13 = (*byte_get)((shdrs + i)->sh_addralign, (int )sizeof((shdrs + i)->sh_addralign));
#line 4333
    internal->sh_addralign = (bfd_vma )tmp___13;
#line 4320
    i ++;
#line 4320
    internal ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4336
  free((void *)shdrs);
  }
#line 4338
  return (1);
}
}
#line 4341 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Sym *get_32bit_elf_symbols(FILE *file , Elf_Internal_Shdr *section ,
                                               unsigned long *num_syms_return ) 
{ 
  unsigned long number ;
  Elf32_External_Sym *esyms ;
  Elf_External_Sym_Shndx *shndx ;
  Elf_Internal_Sym *isyms ;
  Elf_Internal_Sym *psym ;
  unsigned int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;

  {
#line 4346
  number = 0UL;
#line 4347
  esyms = (Elf32_External_Sym *)((void *)0);
#line 4348
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4349
  isyms = (Elf_Internal_Sym *)((void *)0);
#line 4354
  if (section->sh_entsize == 0UL) {
    {
#line 4356
    tmp___0 = gettext("sh_entsize is zero\n");
#line 4356
    error((char const   *)tmp___0);
    }
#line 4357
    goto exit_point;
  }
#line 4360
  number = section->sh_size / section->sh_entsize;
#line 4362
  if (number * sizeof(Elf32_External_Sym ) > section->sh_size + 1UL) {
    {
#line 4364
    tmp___1 = gettext("Invalid sh_entsize\n");
#line 4364
    error((char const   *)tmp___1);
    }
#line 4365
    goto exit_point;
  }
  {
#line 4368
  tmp___2 = gettext("symbols");
#line 4368
  tmp___3 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                     (char const   *)tmp___2);
#line 4368
  esyms = (Elf32_External_Sym *)tmp___3;
  }
#line 4370
  if ((unsigned long )esyms == (unsigned long )((void *)0)) {
#line 4371
    goto exit_point;
  }
#line 4373
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4374
  if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
#line 4374
    if ((unsigned long )symtab_shndx_hdr->sh_link == (unsigned long )(section - section_headers)) {
      {
#line 4378
      tmp___4 = gettext("symbol table section indicies");
#line 4378
      tmp___5 = get_data((void *)0, file, symtab_shndx_hdr->sh_offset, (size_t )1,
                         symtab_shndx_hdr->sh_size, (char const   *)tmp___4);
#line 4378
      shndx = (Elf_External_Sym_Shndx *)tmp___5;
      }
#line 4382
      if ((unsigned long )shndx == (unsigned long )((void *)0)) {
#line 4383
        goto exit_point;
      }
    }
  }
  {
#line 4386
  tmp___6 = cmalloc(number, sizeof(Elf_Internal_Sym ));
#line 4386
  isyms = (Elf_Internal_Sym *)tmp___6;
  }
#line 4388
  if ((unsigned long )isyms == (unsigned long )((void *)0)) {
    {
#line 4390
    tmp___7 = gettext("Out of memory\n");
#line 4390
    error((char const   *)tmp___7);
    }
#line 4391
    goto exit_point;
  }
#line 4394
  j = 0U;
#line 4394
  psym = isyms;
  {
#line 4394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4394
    if (! ((unsigned long )j < number)) {
#line 4394
      goto while_break;
    }
    {
#line 4396
    tmp___8 = (*byte_get)((esyms + j)->st_name, (int )sizeof((esyms + j)->st_name));
#line 4396
    psym->st_name = (unsigned long )tmp___8;
#line 4397
    tmp___9 = (*byte_get)((esyms + j)->st_value, (int )sizeof((esyms + j)->st_value));
#line 4397
    psym->st_value = (bfd_vma )tmp___9;
#line 4398
    tmp___10 = (*byte_get)((esyms + j)->st_size, (int )sizeof((esyms + j)->st_size));
#line 4398
    psym->st_size = (bfd_vma )tmp___10;
#line 4399
    tmp___11 = (*byte_get)((esyms + j)->st_shndx, (int )sizeof((esyms + j)->st_shndx));
#line 4399
    psym->st_shndx = (unsigned int )tmp___11;
    }
#line 4400
    if (psym->st_shndx == 65535U) {
#line 4400
      if ((unsigned long )shndx != (unsigned long )((void *)0)) {
        {
#line 4401
        tmp___12 = (*byte_get)((unsigned char *)(shndx + j), (int )sizeof(*(shndx + j)));
#line 4401
        psym->st_shndx = (unsigned int )tmp___12;
        }
      } else {
#line 4400
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4403
    if (psym->st_shndx >= 65280U) {
#line 4404
      psym->st_shndx += 4294901760U;
    }
    {
#line 4405
    tmp___13 = (*byte_get)((esyms + j)->st_info, (int )sizeof((esyms + j)->st_info));
#line 4405
    psym->st_info = (unsigned char )tmp___13;
#line 4406
    tmp___14 = (*byte_get)((esyms + j)->st_other, (int )sizeof((esyms + j)->st_other));
#line 4406
    psym->st_other = (unsigned char )tmp___14;
#line 4394
    j ++;
#line 4394
    psym ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit_point: 
#line 4410
  if ((unsigned long )shndx != (unsigned long )((void *)0)) {
    {
#line 4411
    free((void *)shndx);
    }
  }
#line 4412
  if ((unsigned long )esyms != (unsigned long )((void *)0)) {
    {
#line 4413
    free((void *)esyms);
    }
  }
#line 4415
  if ((unsigned long )num_syms_return != (unsigned long )((void *)0)) {
#line 4416
    if ((unsigned long )isyms == (unsigned long )((void *)0)) {
#line 4416
      *num_syms_return = 0UL;
    } else {
#line 4416
      *num_syms_return = number;
    }
  }
#line 4418
  return (isyms);
}
}
#line 4421 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Sym *get_64bit_elf_symbols(FILE *file , Elf_Internal_Shdr *section ,
                                               unsigned long *num_syms_return ) 
{ 
  unsigned long number ;
  Elf64_External_Sym *esyms ;
  Elf_External_Sym_Shndx *shndx ;
  Elf_Internal_Sym *isyms ;
  Elf_Internal_Sym *psym ;
  unsigned int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;

  {
#line 4426
  number = 0UL;
#line 4427
  esyms = (Elf64_External_Sym *)((void *)0);
#line 4428
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4429
  isyms = (Elf_Internal_Sym *)((void *)0);
#line 4434
  if (section->sh_entsize == 0UL) {
    {
#line 4436
    tmp___0 = gettext("sh_entsize is zero\n");
#line 4436
    error((char const   *)tmp___0);
    }
#line 4437
    goto exit_point;
  }
#line 4440
  number = section->sh_size / section->sh_entsize;
#line 4442
  if (number * sizeof(Elf64_External_Sym ) > section->sh_size + 1UL) {
    {
#line 4444
    tmp___1 = gettext("Invalid sh_entsize\n");
#line 4444
    error((char const   *)tmp___1);
    }
#line 4445
    goto exit_point;
  }
  {
#line 4448
  tmp___2 = gettext("symbols");
#line 4448
  tmp___3 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                     (char const   *)tmp___2);
#line 4448
  esyms = (Elf64_External_Sym *)tmp___3;
  }
#line 4450
  if (! esyms) {
#line 4451
    goto exit_point;
  }
#line 4453
  if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
#line 4453
    if ((unsigned long )symtab_shndx_hdr->sh_link == (unsigned long )(section - section_headers)) {
      {
#line 4457
      tmp___4 = gettext("symbol table section indicies");
#line 4457
      tmp___5 = get_data((void *)0, file, symtab_shndx_hdr->sh_offset, (size_t )1,
                         symtab_shndx_hdr->sh_size, (char const   *)tmp___4);
#line 4457
      shndx = (Elf_External_Sym_Shndx *)tmp___5;
      }
#line 4461
      if ((unsigned long )shndx == (unsigned long )((void *)0)) {
#line 4462
        goto exit_point;
      }
    }
  }
  {
#line 4465
  tmp___6 = cmalloc(number, sizeof(Elf_Internal_Sym ));
#line 4465
  isyms = (Elf_Internal_Sym *)tmp___6;
  }
#line 4467
  if ((unsigned long )isyms == (unsigned long )((void *)0)) {
    {
#line 4469
    tmp___7 = gettext("Out of memory\n");
#line 4469
    error((char const   *)tmp___7);
    }
#line 4470
    goto exit_point;
  }
#line 4473
  j = 0U;
#line 4473
  psym = isyms;
  {
#line 4473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4473
    if (! ((unsigned long )j < number)) {
#line 4473
      goto while_break;
    }
    {
#line 4475
    tmp___8 = (*byte_get)((esyms + j)->st_name, (int )sizeof((esyms + j)->st_name));
#line 4475
    psym->st_name = (unsigned long )tmp___8;
#line 4476
    tmp___9 = (*byte_get)((esyms + j)->st_info, (int )sizeof((esyms + j)->st_info));
#line 4476
    psym->st_info = (unsigned char )tmp___9;
#line 4477
    tmp___10 = (*byte_get)((esyms + j)->st_other, (int )sizeof((esyms + j)->st_other));
#line 4477
    psym->st_other = (unsigned char )tmp___10;
#line 4478
    tmp___11 = (*byte_get)((esyms + j)->st_shndx, (int )sizeof((esyms + j)->st_shndx));
#line 4478
    psym->st_shndx = (unsigned int )tmp___11;
    }
#line 4480
    if (psym->st_shndx == 65535U) {
#line 4480
      if ((unsigned long )shndx != (unsigned long )((void *)0)) {
        {
#line 4481
        tmp___12 = (*byte_get)((unsigned char *)(shndx + j), (int )sizeof(*(shndx + j)));
#line 4481
        psym->st_shndx = (unsigned int )tmp___12;
        }
      } else {
#line 4480
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4483
    if (psym->st_shndx >= 65280U) {
#line 4484
      psym->st_shndx += 4294901760U;
    }
    {
#line 4486
    tmp___13 = (*byte_get)((esyms + j)->st_value, (int )sizeof((esyms + j)->st_value));
#line 4486
    psym->st_value = (bfd_vma )tmp___13;
#line 4487
    tmp___14 = (*byte_get)((esyms + j)->st_size, (int )sizeof((esyms + j)->st_size));
#line 4487
    psym->st_size = (bfd_vma )tmp___14;
#line 4473
    j ++;
#line 4473
    psym ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit_point: 
#line 4491
  if ((unsigned long )shndx != (unsigned long )((void *)0)) {
    {
#line 4492
    free((void *)shndx);
    }
  }
#line 4493
  if ((unsigned long )esyms != (unsigned long )((void *)0)) {
    {
#line 4494
    free((void *)esyms);
    }
  }
#line 4496
  if ((unsigned long )num_syms_return != (unsigned long )((void *)0)) {
#line 4497
    if ((unsigned long )isyms == (unsigned long )((void *)0)) {
#line 4497
      *num_syms_return = 0UL;
    } else {
#line 4497
      *num_syms_return = number;
    }
  }
#line 4499
  return (isyms);
}
}
#line 4505 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___7[1024]  ;
#line 4513
static char const   *get_elf_section_flags(bfd_vma sh_flags ) ;
#line 4513 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct __anonstruct_flags_713894858  const  flags[20]  = 
#line 4513
  {      {"WRITE", (int )(sizeof("WRITE") - 1UL)}, 
        {"ALLOC", (int )(sizeof("ALLOC") - 1UL)}, 
        {"EXEC", (int )(sizeof("EXEC") - 1UL)}, 
        {"MERGE", (int )(sizeof("MERGE") - 1UL)}, 
        {"STRINGS", (int )(sizeof("STRINGS") - 1UL)}, 
        {"INFO LINK", (int )(sizeof("INFO LINK") - 1UL)}, 
        {"LINK ORDER", (int )(sizeof("LINK ORDER") - 1UL)}, 
        {"OS NONCONF", (int )(sizeof("OS NONCONF") - 1UL)}, 
        {"GROUP", (int )(sizeof("GROUP") - 1UL)}, 
        {"TLS", (int )(sizeof("TLS") - 1UL)}, 
        {"SHORT", (int )(sizeof("SHORT") - 1UL)}, 
        {"NORECOV", (int )(sizeof("NORECOV") - 1UL)}, 
        {"VMS_GLOBAL", (int )(sizeof("VMS_GLOBAL") - 1UL)}, 
        {"VMS_OVERLAID", (int )(sizeof("VMS_OVERLAID") - 1UL)}, 
        {"VMS_SHARED", (int )(sizeof("VMS_SHARED") - 1UL)}, 
        {"VMS_VECTOR", (int )(sizeof("VMS_VECTOR") - 1UL)}, 
        {"VMS_ALLOC_64BIT", (int )(sizeof("VMS_ALLOC_64BIT") - 1UL)}, 
        {"VMS_PROTECTED", (int )(sizeof("VMS_PROTECTED") - 1UL)}, 
        {"EXCLUDE", (int )(sizeof("EXCLUDE") - 1UL)}, 
        {"ORDERED", (int )(sizeof("ORDERED") - 1UL)}};
#line 4502 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_elf_section_flags(bfd_vma sh_flags ) 
{ 
  char *p ;
  int field_size ;
  int tmp___0 ;
  int sindex ;
  int size ;
  bfd_vma os_flags ;
  bfd_vma proc_flags ;
  bfd_vma unknown_flags ;
  bfd_vma flag ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 4506
  p = buff___7;
#line 4507
  if (is_32bit_elf) {
#line 4507
    tmp___0 = 8;
  } else {
#line 4507
    tmp___0 = 16;
  }
#line 4507
  field_size = tmp___0;
#line 4509
  size = (int )(sizeof(buff___7) - (unsigned long )((field_size + 4) + 1));
#line 4510
  os_flags = (bfd_vma )0;
#line 4511
  proc_flags = (bfd_vma )0;
#line 4512
  unknown_flags = (bfd_vma )0;
#line 4546
  if (do_section_details) {
    {
#line 4548
    sprintf((char */* __restrict  */)(buff___7), (char const   */* __restrict  */)"[%*.*lx]: ",
            field_size, field_size, sh_flags);
#line 4550
    p += field_size + 4;
    }
  }
  {
#line 4553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4553
    if (! sh_flags) {
#line 4553
      goto while_break;
    }
#line 4557
    flag = sh_flags & - sh_flags;
#line 4558
    sh_flags &= ~ flag;
#line 4560
    if (do_section_details) {
      {
#line 4564
      if (flag == 1UL) {
#line 4564
        goto case_1;
      }
#line 4565
      if (flag == (bfd_vma )(1 << 1)) {
#line 4565
        goto case_exp;
      }
#line 4566
      if (flag == (bfd_vma )(1 << 2)) {
#line 4566
        goto case_exp___0;
      }
#line 4567
      if (flag == (bfd_vma )(1 << 4)) {
#line 4567
        goto case_exp___1;
      }
#line 4568
      if (flag == (bfd_vma )(1 << 5)) {
#line 4568
        goto case_exp___2;
      }
#line 4569
      if (flag == (bfd_vma )(1 << 6)) {
#line 4569
        goto case_exp___3;
      }
#line 4570
      if (flag == (bfd_vma )(1 << 7)) {
#line 4570
        goto case_exp___4;
      }
#line 4571
      if (flag == (bfd_vma )(1 << 8)) {
#line 4571
        goto case_exp___5;
      }
#line 4572
      if (flag == (bfd_vma )(1 << 9)) {
#line 4572
        goto case_exp___6;
      }
#line 4573
      if (flag == (bfd_vma )(1 << 10)) {
#line 4573
        goto case_exp___7;
      }
#line 4574
      if (flag == 2147483648UL) {
#line 4574
        goto case_2147483648;
      }
#line 4576
      goto switch_default;
      case_1: /* CIL Label */ 
#line 4564
      sindex = 0;
#line 4564
      goto switch_break;
      case_exp: /* CIL Label */ 
#line 4565
      sindex = 1;
#line 4565
      goto switch_break;
      case_exp___0: /* CIL Label */ 
#line 4566
      sindex = 2;
#line 4566
      goto switch_break;
      case_exp___1: /* CIL Label */ 
#line 4567
      sindex = 3;
#line 4567
      goto switch_break;
      case_exp___2: /* CIL Label */ 
#line 4568
      sindex = 4;
#line 4568
      goto switch_break;
      case_exp___3: /* CIL Label */ 
#line 4569
      sindex = 5;
#line 4569
      goto switch_break;
      case_exp___4: /* CIL Label */ 
#line 4570
      sindex = 6;
#line 4570
      goto switch_break;
      case_exp___5: /* CIL Label */ 
#line 4571
      sindex = 7;
#line 4571
      goto switch_break;
      case_exp___6: /* CIL Label */ 
#line 4572
      sindex = 8;
#line 4572
      goto switch_break;
      case_exp___7: /* CIL Label */ 
#line 4573
      sindex = 9;
#line 4573
      goto switch_break;
      case_2147483648: /* CIL Label */ 
#line 4574
      sindex = 18;
#line 4574
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4577
      sindex = -1;
      {
#line 4580
      if ((int )elf_header.e_machine == 50) {
#line 4580
        goto case_50;
      }
#line 4608
      if ((int )elf_header.e_machine == 2) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 43) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 18) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 11) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 181) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 180) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 62) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 6) {
#line 4608
        goto case_2;
      }
#line 4608
      if ((int )elf_header.e_machine == 3) {
#line 4608
        goto case_2;
      }
#line 4612
      goto switch_default___1;
      case_50: /* CIL Label */ 
#line 4581
      if (flag == 268435456UL) {
#line 4582
        sindex = 10;
      } else
#line 4583
      if (flag == 536870912UL) {
#line 4584
        sindex = 11;
      } else
#line 4586
      if ((int )elf_header.e_ident[7] == 13) {
        {
#line 4589
        if (flag == 4294967296UL) {
#line 4589
          goto case_4294967296;
        }
#line 4590
        if (flag == 8589934592UL) {
#line 4590
          goto case_8589934592;
        }
#line 4591
        if (flag == 17179869184UL) {
#line 4591
          goto case_17179869184;
        }
#line 4592
        if (flag == 34359738368UL) {
#line 4592
          goto case_34359738368;
        }
#line 4593
        if (flag == 68719476736UL) {
#line 4593
          goto case_68719476736;
        }
#line 4594
        if (flag == 137438953472UL) {
#line 4594
          goto case_137438953472;
        }
#line 4595
        goto switch_default___0;
        case_4294967296: /* CIL Label */ 
#line 4589
        sindex = 12;
#line 4589
        goto switch_break___1;
        case_8589934592: /* CIL Label */ 
#line 4590
        sindex = 13;
#line 4590
        goto switch_break___1;
        case_17179869184: /* CIL Label */ 
#line 4591
        sindex = 14;
#line 4591
        goto switch_break___1;
        case_34359738368: /* CIL Label */ 
#line 4592
        sindex = 15;
#line 4592
        goto switch_break___1;
        case_68719476736: /* CIL Label */ 
#line 4593
        sindex = 16;
#line 4593
        goto switch_break___1;
        case_137438953472: /* CIL Label */ 
#line 4594
        sindex = 17;
#line 4594
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 4595
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 4598
      goto switch_break___0;
      case_2: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_18: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_181: /* CIL Label */ 
      case_180: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 4609
      if (flag == 1073741824UL) {
#line 4610
        sindex = 19;
      }
#line 4611
      goto switch_break___0;
      switch_default___1: /* CIL Label */ 
#line 4613
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 4617
      if (sindex != -1) {
#line 4619
        if ((unsigned long )p != (unsigned long )((buff___7 + field_size) + 4)) {
#line 4621
          if (size < 12) {
            {
#line 4622
            abort();
            }
          }
#line 4623
          size -= 2;
#line 4624
          tmp___1 = p;
#line 4624
          p ++;
#line 4624
          *tmp___1 = (char )',';
#line 4625
          tmp___2 = p;
#line 4625
          p ++;
#line 4625
          *tmp___2 = (char )' ';
        }
        {
#line 4628
        size -= (int )flags[sindex].len;
#line 4629
        p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)flags[sindex].str);
        }
      } else
#line 4631
      if (flag & 267386880UL) {
#line 4632
        os_flags |= flag;
      } else
#line 4633
      if (flag & 4026531840UL) {
#line 4634
        proc_flags |= flag;
      } else {
#line 4636
        unknown_flags |= flag;
      }
    } else {
      {
#line 4642
      if (flag == 1UL) {
#line 4642
        goto case_1___0;
      }
#line 4643
      if (flag == (bfd_vma )(1 << 1)) {
#line 4643
        goto case_exp___8;
      }
#line 4644
      if (flag == (bfd_vma )(1 << 2)) {
#line 4644
        goto case_exp___9;
      }
#line 4645
      if (flag == (bfd_vma )(1 << 4)) {
#line 4645
        goto case_exp___10;
      }
#line 4646
      if (flag == (bfd_vma )(1 << 5)) {
#line 4646
        goto case_exp___11;
      }
#line 4647
      if (flag == (bfd_vma )(1 << 6)) {
#line 4647
        goto case_exp___12;
      }
#line 4648
      if (flag == (bfd_vma )(1 << 7)) {
#line 4648
        goto case_exp___13;
      }
#line 4649
      if (flag == (bfd_vma )(1 << 8)) {
#line 4649
        goto case_exp___14;
      }
#line 4650
      if (flag == (bfd_vma )(1 << 9)) {
#line 4650
        goto case_exp___15;
      }
#line 4651
      if (flag == (bfd_vma )(1 << 10)) {
#line 4651
        goto case_exp___16;
      }
#line 4652
      if (flag == 2147483648UL) {
#line 4652
        goto case_2147483648___0;
      }
#line 4654
      goto switch_default___2;
      case_1___0: /* CIL Label */ 
#line 4642
      *p = (char )'W';
#line 4642
      goto switch_break___2;
      case_exp___8: /* CIL Label */ 
#line 4643
      *p = (char )'A';
#line 4643
      goto switch_break___2;
      case_exp___9: /* CIL Label */ 
#line 4644
      *p = (char )'X';
#line 4644
      goto switch_break___2;
      case_exp___10: /* CIL Label */ 
#line 4645
      *p = (char )'M';
#line 4645
      goto switch_break___2;
      case_exp___11: /* CIL Label */ 
#line 4646
      *p = (char )'S';
#line 4646
      goto switch_break___2;
      case_exp___12: /* CIL Label */ 
#line 4647
      *p = (char )'I';
#line 4647
      goto switch_break___2;
      case_exp___13: /* CIL Label */ 
#line 4648
      *p = (char )'L';
#line 4648
      goto switch_break___2;
      case_exp___14: /* CIL Label */ 
#line 4649
      *p = (char )'O';
#line 4649
      goto switch_break___2;
      case_exp___15: /* CIL Label */ 
#line 4650
      *p = (char )'G';
#line 4650
      goto switch_break___2;
      case_exp___16: /* CIL Label */ 
#line 4651
      *p = (char )'T';
#line 4651
      goto switch_break___2;
      case_2147483648___0: /* CIL Label */ 
#line 4652
      *p = (char )'E';
#line 4652
      goto switch_break___2;
      switch_default___2: /* CIL Label */ 
#line 4655
      if ((int )elf_header.e_machine == 62) {
#line 4655
        goto _L___0;
      } else
#line 4655
      if ((int )elf_header.e_machine == 180) {
#line 4655
        goto _L___0;
      } else
#line 4655
      if ((int )elf_header.e_machine == 181) {
        _L___0: /* CIL Label */ 
#line 4655
        if (flag == 268435456UL) {
#line 4659
          *p = (char )'l';
        } else {
#line 4655
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 4660
      if (flag & 267386880UL) {
#line 4662
        *p = (char )'o';
#line 4663
        sh_flags &= 0xfffffffff00fffffUL;
      } else
#line 4665
      if (flag & 4026531840UL) {
#line 4667
        *p = (char )'p';
#line 4668
        sh_flags &= 268435455UL;
      } else {
#line 4671
        *p = (char )'x';
      }
#line 4672
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 4674
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4678
  if (do_section_details) {
#line 4680
    if (os_flags) {
#line 4682
      size -= 5 + field_size;
#line 4683
      if ((unsigned long )p != (unsigned long )((buff___7 + field_size) + 4)) {
#line 4685
        if (size < 3) {
          {
#line 4686
          abort();
          }
        }
#line 4687
        size -= 2;
#line 4688
        tmp___3 = p;
#line 4688
        p ++;
#line 4688
        *tmp___3 = (char )',';
#line 4689
        tmp___4 = p;
#line 4689
        p ++;
#line 4689
        *tmp___4 = (char )' ';
      }
      {
#line 4691
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"OS (%*.*lx)",
              field_size, field_size, os_flags);
#line 4693
      p += 5 + field_size;
      }
    }
#line 4695
    if (proc_flags) {
#line 4697
      size -= 7 + field_size;
#line 4698
      if ((unsigned long )p != (unsigned long )((buff___7 + field_size) + 4)) {
#line 4700
        if (size < 3) {
          {
#line 4701
          abort();
          }
        }
#line 4702
        size -= 2;
#line 4703
        tmp___5 = p;
#line 4703
        p ++;
#line 4703
        *tmp___5 = (char )',';
#line 4704
        tmp___6 = p;
#line 4704
        p ++;
#line 4704
        *tmp___6 = (char )' ';
      }
      {
#line 4706
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"PROC (%*.*lx)",
              field_size, field_size, proc_flags);
#line 4708
      p += 7 + field_size;
      }
    }
#line 4710
    if (unknown_flags) {
#line 4712
      size -= 10 + field_size;
#line 4713
      if ((unsigned long )p != (unsigned long )((buff___7 + field_size) + 4)) {
#line 4715
        if (size < 3) {
          {
#line 4716
          abort();
          }
        }
#line 4717
        size -= 2;
#line 4718
        tmp___7 = p;
#line 4718
        p ++;
#line 4718
        *tmp___7 = (char )',';
#line 4719
        tmp___8 = p;
#line 4719
        p ++;
#line 4719
        *tmp___8 = (char )' ';
      }
      {
#line 4721
      tmp___9 = gettext("UNKNOWN (%*.*lx)");
#line 4721
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___9,
              field_size, field_size, unknown_flags);
#line 4723
      p += 10 + field_size;
      }
    }
  }
#line 4727
  *p = (char )'\000';
#line 4728
  return ((char const   *)(buff___7));
}
}
#line 4731 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_section_headers(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  Elf_Internal_Shdr *tmp___7 ;
  char *name___0 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  bfd_size_type expected_entsize ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  Elf_Internal_Sym *tmp___18 ;
  Elf_Internal_Sym *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *tmp___22 ;
  char *tmp___23 ;
  bfd_size_type expected_entsize___0 ;
  unsigned long tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  bfd_size_type expected_entsize___1 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  bfd_size_type expected_entsize___2 ;
  unsigned long tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  bfd_size_type expected_entsize___3 ;
  unsigned long tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char const   *tmp___89 ;
  char const   *tmp___90 ;
  char const   *link_too_big ;
  char const   *tmp___91 ;
  char *tmp___92 ;
  char const   *tmp___93 ;
  char const   *tmp___94 ;
  char const   *tmp___95 ;
  char const   *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;

  {
#line 4737
  section_headers = (Elf_Internal_Shdr *)((void *)0);
#line 4739
  if (elf_header.e_shnum == 0U) {
#line 4742
    if (elf_header.e_shoff != 0UL) {
      {
#line 4743
      tmp___0 = gettext("possibly corrupt ELF file header - it has a non-zero section header offset, but no section headers\n");
#line 4743
      warn((char const   *)tmp___0);
      }
    } else
#line 4745
    if (do_sections) {
      {
#line 4746
      tmp___1 = gettext("\nThere are no sections in this file.\n");
#line 4746
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 4748
    return (1);
  }
#line 4751
  if (do_sections) {
#line 4751
    if (! do_header) {
      {
#line 4752
      tmp___2 = gettext("There are %d section headers, starting at offset 0x%lx:\n");
#line 4752
      printf((char const   */* __restrict  */)tmp___2, elf_header.e_shnum, elf_header.e_shoff);
      }
    }
  }
#line 4755
  if (is_32bit_elf) {
    {
#line 4757
    tmp___3 = get_32bit_section_headers(file, elf_header.e_shnum);
    }
#line 4757
    if (! tmp___3) {
#line 4758
      return (0);
    }
  } else {
    {
#line 4760
    tmp___4 = get_64bit_section_headers(file, elf_header.e_shnum);
    }
#line 4760
    if (! tmp___4) {
#line 4761
      return (0);
    }
  }
#line 4764
  if (elf_header.e_shstrndx != 0U) {
#line 4764
    if (elf_header.e_shstrndx < elf_header.e_shnum) {
#line 4767
      section = section_headers + elf_header.e_shstrndx;
#line 4769
      if (section->sh_size != 0UL) {
        {
#line 4771
        tmp___5 = gettext("string table");
#line 4771
        tmp___6 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                           (char const   *)tmp___5);
#line 4771
        string_table = (char *)tmp___6;
        }
#line 4775
        if ((unsigned long )string_table != (unsigned long )((void *)0)) {
#line 4775
          string_table_length = section->sh_size;
        } else {
#line 4775
          string_table_length = 0UL;
        }
      }
    }
  }
#line 4781
  dynamic_symbols = (Elf_Internal_Sym *)((void *)0);
#line 4782
  dynamic_strings = (char *)((void *)0);
#line 4783
  dynamic_syminfo = (Elf_Internal_Syminfo *)((void *)0);
#line 4784
  symtab_shndx_hdr = (Elf_Internal_Shdr *)((void *)0);
#line 4786
  if (is_32bit_elf) {
#line 4786
    eh_addr_size = 4;
  } else {
#line 4786
    eh_addr_size = 8;
  }
  {
#line 4790
  if ((int )elf_header.e_machine == 10) {
#line 4790
    goto case_10;
  }
#line 4790
  if ((int )elf_header.e_machine == 8) {
#line 4790
    goto case_10;
  }
#line 4806
  if ((int )elf_header.e_machine == 47) {
#line 4806
    goto case_47;
  }
#line 4806
  if ((int )elf_header.e_machine == 46) {
#line 4806
    goto case_47;
  }
#line 4824
  if ((int )elf_header.e_machine == 120) {
#line 4824
    goto case_120;
  }
#line 4824
  if ((int )elf_header.e_machine == 65200) {
#line 4824
    goto case_120;
  }
#line 4787
  goto switch_break;
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 4800
  if ((elf_header.e_flags & 61440UL) == 16384UL) {
    {
#line 4800
    tmp___7 = find_section(".gcc_compiled_long32");
    }
#line 4800
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 4802
      eh_addr_size = 8;
    }
  }
#line 4803
  goto switch_break;
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  {
#line 4812
  if ((elf_header.e_flags & 16711680UL) == 8781824UL) {
#line 4812
    goto case_8781824;
  }
#line 4812
  if ((elf_header.e_flags & 16711680UL) == 8650752UL) {
#line 4812
    goto case_8781824;
  }
#line 4812
  if ((elf_header.e_flags & 16711680UL) == 8585216UL) {
#line 4812
    goto case_8781824;
  }
#line 4812
  if ((elf_header.e_flags & 16711680UL) == 8388608UL) {
#line 4812
    goto case_8781824;
  }
#line 4817
  if ((elf_header.e_flags & 16711680UL) == 8716288UL) {
#line 4817
    goto case_8716288;
  }
#line 4817
  if ((elf_header.e_flags & 16711680UL) == 8519680UL) {
#line 4817
    goto case_8716288;
  }
#line 4817
  if ((elf_header.e_flags & 16711680UL) == 8454144UL) {
#line 4817
    goto case_8716288;
  }
#line 4807
  goto switch_break___0;
  case_8781824: /* CIL Label */ 
  case_8650752: /* CIL Label */ 
  case_8585216: /* CIL Label */ 
  case_8388608: /* CIL Label */ 
#line 4813
  eh_addr_size = 2;
#line 4814
  goto switch_break___0;
  case_8716288: /* CIL Label */ 
  case_8519680: /* CIL Label */ 
  case_8454144: /* CIL Label */ 
#line 4818
  eh_addr_size = 4;
#line 4819
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 4821
  goto switch_break;
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
  {
#line 4827
  if ((elf_header.e_flags & 127UL) == 117UL) {
#line 4827
    goto case_117;
  }
#line 4825
  goto switch_break___1;
  case_117: /* CIL Label */ 
#line 4828
  eh_addr_size = 2;
#line 4829
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 4831
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4853
  i = 0U;
#line 4853
  section = section_headers;
  {
#line 4853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4853
    if (! (i < elf_header.e_shnum)) {
#line 4853
      goto while_break;
    }
#line 4857
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 4857
      tmp___8 = gettext("<none>");
#line 4857
      tmp___13 = tmp___8;
      }
    } else {
#line 4857
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 4857
        tmp___9 = gettext("<no-name>");
#line 4857
        tmp___12 = tmp___9;
        }
      } else {
#line 4857
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 4857
          tmp___10 = gettext("<corrupt>");
#line 4857
          tmp___11 = tmp___10;
          }
        } else {
#line 4857
          tmp___11 = string_table + section->sh_name;
        }
#line 4857
        tmp___12 = tmp___11;
      }
#line 4857
      tmp___13 = tmp___12;
    }
#line 4857
    name___0 = tmp___13;
#line 4859
    if (section->sh_type == 11U) {
#line 4861
      if ((unsigned long )dynamic_symbols != (unsigned long )((void *)0)) {
        {
#line 4863
        tmp___14 = gettext("File contains multiple dynamic symbol tables\n");
#line 4863
        error((char const   *)tmp___14);
        }
#line 4864
        goto __Cont;
      }
      {
#line 4867
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4867
        if (is_32bit_elf) {
#line 4867
          tmp___15 = sizeof(Elf32_External_Sym );
        } else {
#line 4867
          tmp___15 = sizeof(Elf64_External_Sym );
        }
#line 4867
        expected_entsize = tmp___15;
#line 4867
        if (section->sh_entsize != expected_entsize) {
          {
#line 4867
          tmp___16 = gettext("Section %d has invalid sh_entsize of %lx\n");
#line 4867
          error((char const   *)tmp___16, i, section->sh_entsize);
#line 4867
          tmp___17 = gettext("(Using the expected size of %d for the rest of this dump)\n");
#line 4867
          error((char const   *)tmp___17, (int )expected_entsize);
#line 4867
          section->sh_entsize = expected_entsize;
          }
        }
#line 4867
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4868
      if (is_32bit_elf) {
        {
#line 4868
        tmp___18 = get_32bit_elf_symbols(file, section, & num_dynamic_syms);
#line 4868
        dynamic_symbols = tmp___18;
        }
      } else {
        {
#line 4868
        tmp___19 = get_64bit_elf_symbols(file, section, & num_dynamic_syms);
#line 4868
        dynamic_symbols = tmp___19;
        }
      }
    } else
#line 4870
    if (section->sh_type == 3U) {
      {
#line 4870
      tmp___62 = strcmp((char const   *)name___0, ".dynstr");
      }
#line 4870
      if (tmp___62 == 0) {
#line 4873
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          {
#line 4875
          tmp___20 = gettext("File contains multiple dynamic string tables\n");
#line 4875
          error((char const   *)tmp___20);
          }
#line 4876
          goto __Cont;
        }
        {
#line 4879
        tmp___21 = gettext("dynamic strings");
#line 4879
        tmp___22 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                            (char const   *)tmp___21);
#line 4879
        dynamic_strings = (char *)tmp___22;
        }
#line 4882
        if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 4882
          dynamic_strings_length = 0UL;
        } else {
#line 4882
          dynamic_strings_length = section->sh_size;
        }
      } else {
#line 4870
        goto _L___25;
      }
    } else
    _L___25: /* CIL Label */ 
#line 4884
    if (section->sh_type == 18U) {
#line 4886
      if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
        {
#line 4888
        tmp___23 = gettext("File contains multiple symtab shndx tables\n");
#line 4888
        error((char const   *)tmp___23);
        }
#line 4889
        goto __Cont;
      }
#line 4891
      symtab_shndx_hdr = section;
    } else
#line 4893
    if (section->sh_type == 2U) {
      {
#line 4894
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4894
        if (is_32bit_elf) {
#line 4894
          tmp___24 = sizeof(Elf32_External_Sym );
        } else {
#line 4894
          tmp___24 = sizeof(Elf64_External_Sym );
        }
#line 4894
        expected_entsize___0 = tmp___24;
#line 4894
        if (section->sh_entsize != expected_entsize___0) {
          {
#line 4894
          tmp___25 = gettext("Section %d has invalid sh_entsize of %lx\n");
#line 4894
          error((char const   *)tmp___25, i, section->sh_entsize);
#line 4894
          tmp___26 = gettext("(Using the expected size of %d for the rest of this dump)\n");
#line 4894
          error((char const   *)tmp___26, (int )expected_entsize___0);
#line 4894
          section->sh_entsize = expected_entsize___0;
          }
        }
#line 4894
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 4895
    if (section->sh_type == 17U) {
      {
#line 4896
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4896
        if (is_32bit_elf) {
#line 4896
          tmp___27 = 4;
        } else {
#line 4896
          tmp___27 = 4;
        }
#line 4896
        expected_entsize___1 = (bfd_size_type )tmp___27;
#line 4896
        if (section->sh_entsize != expected_entsize___1) {
          {
#line 4896
          tmp___28 = gettext("Section %d has invalid sh_entsize of %lx\n");
#line 4896
          error((char const   *)tmp___28, i, section->sh_entsize);
#line 4896
          tmp___29 = gettext("(Using the expected size of %d for the rest of this dump)\n");
#line 4896
          error((char const   *)tmp___29, (int )expected_entsize___1);
#line 4896
          section->sh_entsize = expected_entsize___1;
          }
        }
#line 4896
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 4897
    if (section->sh_type == 9U) {
      {
#line 4898
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4898
        if (is_32bit_elf) {
#line 4898
          tmp___30 = sizeof(Elf32_External_Rel );
        } else {
#line 4898
          tmp___30 = sizeof(Elf64_External_Rel );
        }
#line 4898
        expected_entsize___2 = tmp___30;
#line 4898
        if (section->sh_entsize != expected_entsize___2) {
          {
#line 4898
          tmp___31 = gettext("Section %d has invalid sh_entsize of %lx\n");
#line 4898
          error((char const   *)tmp___31, i, section->sh_entsize);
#line 4898
          tmp___32 = gettext("(Using the expected size of %d for the rest of this dump)\n");
#line 4898
          error((char const   *)tmp___32, (int )expected_entsize___2);
#line 4898
          section->sh_entsize = expected_entsize___2;
          }
        }
#line 4898
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 4899
    if (section->sh_type == 4U) {
      {
#line 4900
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4900
        if (is_32bit_elf) {
#line 4900
          tmp___33 = sizeof(Elf32_External_Rela );
        } else {
#line 4900
          tmp___33 = sizeof(Elf64_External_Rela );
        }
#line 4900
        expected_entsize___3 = tmp___33;
#line 4900
        if (section->sh_entsize != expected_entsize___3) {
          {
#line 4900
          tmp___34 = gettext("Section %d has invalid sh_entsize of %lx\n");
#line 4900
          error((char const   *)tmp___34, i, section->sh_entsize);
#line 4900
          tmp___35 = gettext("(Using the expected size of %d for the rest of this dump)\n");
#line 4900
          error((char const   *)tmp___35, (int )expected_entsize___3);
#line 4900
          section->sh_entsize = expected_entsize___3;
          }
        }
#line 4900
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 4901
    if (do_debugging) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_info) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_abbrevs) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_lines) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_pubnames) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_pubtypes) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_aranges) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_frames) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_macinfo) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_str) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_loc) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_ranges) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_addr) {
#line 4901
      goto _L___24;
    } else
#line 4901
    if (do_debug_cu_index) {
      _L___24: /* CIL Label */ 
      {
#line 4901
      tmp___60 = strncmp((char const   *)name___0, ".debug_", sizeof(".debug_") - 1UL);
      }
#line 4901
      if (tmp___60 == 0) {
#line 4901
        goto _L___23;
      } else {
        {
#line 4901
        tmp___61 = strncmp((char const   *)name___0, ".zdebug_", sizeof(".zdebug_") - 1UL);
        }
#line 4901
        if (tmp___61 == 0) {
          _L___23: /* CIL Label */ 
#line 4909
          if ((int )*(name___0 + 1) == 122) {
#line 4910
            name___0 += sizeof(".zdebug_") - 1UL;
          } else {
#line 4912
            name___0 += sizeof(".debug_") - 1UL;
          }
#line 4914
          if (do_debugging) {
            {
#line 4933
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else
#line 4914
          if (do_debug_info) {
            {
#line 4914
            tmp___36 = strncmp((char const   *)name___0, "info", sizeof("info") - 1UL);
            }
#line 4914
            if (tmp___36 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___14;
            }
          } else
          _L___14: /* CIL Label */ 
#line 4914
          if (do_debug_info) {
            {
#line 4914
            tmp___37 = strncmp((char const   *)name___0, "types", sizeof("types") - 1UL);
            }
#line 4914
            if (tmp___37 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___13;
            }
          } else
          _L___13: /* CIL Label */ 
#line 4914
          if (do_debug_abbrevs) {
            {
#line 4914
            tmp___38 = strncmp((char const   *)name___0, "abbrev", sizeof("abbrev") - 1UL);
            }
#line 4914
            if (tmp___38 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___12;
            }
          } else
          _L___12: /* CIL Label */ 
#line 4914
          if (do_debug_lines) {
            {
#line 4914
            tmp___39 = strcmp((char const   *)name___0, "line");
            }
#line 4914
            if (tmp___39 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 4914
          if (do_debug_lines) {
            {
#line 4914
            tmp___40 = strncmp((char const   *)name___0, "line.", sizeof("line.") - 1UL);
            }
#line 4914
            if (tmp___40 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___10;
            }
          } else
          _L___10: /* CIL Label */ 
#line 4914
          if (do_debug_pubnames) {
            {
#line 4914
            tmp___41 = strncmp((char const   *)name___0, "pubnames", sizeof("pubnames") - 1UL);
            }
#line 4914
            if (tmp___41 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
#line 4914
          if (do_debug_pubtypes) {
            {
#line 4914
            tmp___42 = strncmp((char const   *)name___0, "pubtypes", sizeof("pubtypes") - 1UL);
            }
#line 4914
            if (tmp___42 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___8;
            }
          } else
          _L___8: /* CIL Label */ 
#line 4914
          if (do_debug_aranges) {
            {
#line 4914
            tmp___43 = strncmp((char const   *)name___0, "aranges", sizeof("aranges") - 1UL);
            }
#line 4914
            if (tmp___43 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 4914
          if (do_debug_ranges) {
            {
#line 4914
            tmp___44 = strncmp((char const   *)name___0, "ranges", sizeof("ranges") - 1UL);
            }
#line 4914
            if (tmp___44 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
#line 4914
          if (do_debug_frames) {
            {
#line 4914
            tmp___45 = strncmp((char const   *)name___0, "frame", sizeof("frame") - 1UL);
            }
#line 4914
            if (tmp___45 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 4914
          if (do_debug_macinfo) {
            {
#line 4914
            tmp___46 = strncmp((char const   *)name___0, "macinfo", sizeof("macinfo") - 1UL);
            }
#line 4914
            if (tmp___46 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 4914
          if (do_debug_macinfo) {
            {
#line 4914
            tmp___47 = strncmp((char const   *)name___0, "macro", sizeof("macro") - 1UL);
            }
#line 4914
            if (tmp___47 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 4914
          if (do_debug_str) {
            {
#line 4914
            tmp___48 = strncmp((char const   *)name___0, "str", sizeof("str") - 1UL);
            }
#line 4914
            if (tmp___48 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 4914
          if (do_debug_loc) {
            {
#line 4914
            tmp___49 = strncmp((char const   *)name___0, "loc", sizeof("loc") - 1UL);
            }
#line 4914
            if (tmp___49 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 4914
          if (do_debug_addr) {
            {
#line 4914
            tmp___50 = strncmp((char const   *)name___0, "addr", sizeof("addr") - 1UL);
            }
#line 4914
            if (tmp___50 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 4914
          if (do_debug_cu_index) {
            {
#line 4914
            tmp___51 = strncmp((char const   *)name___0, "cu_index", sizeof("cu_index") - 1UL);
            }
#line 4914
            if (tmp___51 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4914
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 4914
          if (do_debug_cu_index) {
            {
#line 4914
            tmp___52 = strncmp((char const   *)name___0, "tu_index", sizeof("tu_index") - 1UL);
            }
#line 4914
            if (tmp___52 == 0) {
              {
#line 4933
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            }
          }
        } else {
#line 4901
          goto _L___22;
        }
      }
    } else
    _L___22: /* CIL Label */ 
#line 4936
    if (do_debugging) {
#line 4936
      goto _L___21;
    } else
#line 4936
    if (do_debug_info) {
      _L___21: /* CIL Label */ 
      {
#line 4936
      tmp___59 = strncmp((char const   *)name___0, ".gnu.linkonce.wi.", sizeof(".gnu.linkonce.wi.") - 1UL);
      }
#line 4936
      if (tmp___59 == 0) {
        {
#line 4938
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4936
        goto _L___20;
      }
    } else
    _L___20: /* CIL Label */ 
#line 4939
    if (do_debug_frames) {
      {
#line 4939
      tmp___58 = strcmp((char const   *)name___0, ".eh_frame");
      }
#line 4939
      if (tmp___58 == 0) {
        {
#line 4940
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4939
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 4941
    if (do_gdb_index) {
      {
#line 4941
      tmp___57 = strcmp((char const   *)name___0, ".gdb_index");
      }
#line 4941
      if (tmp___57 == 0) {
        {
#line 4942
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4941
        goto _L___18;
      }
    } else
    _L___18: /* CIL Label */ 
#line 4944
    if (do_debugging) {
#line 4944
      goto _L___17;
    } else
#line 4944
    if (do_trace_info) {
#line 4944
      goto _L___17;
    } else
#line 4944
    if (do_trace_abbrevs) {
#line 4944
      goto _L___17;
    } else
#line 4944
    if (do_trace_aranges) {
      _L___17: /* CIL Label */ 
      {
#line 4944
      tmp___56 = strncmp((char const   *)name___0, ".trace_", sizeof(".trace_") - 1UL);
      }
#line 4944
      if (tmp___56 == 0) {
#line 4948
        name___0 += sizeof(".trace_") - 1UL;
#line 4950
        if (do_debugging) {
          {
#line 4955
          request_dump_bynumber(i, (dump_type )(1 << 2));
          }
        } else
#line 4950
        if (do_trace_info) {
          {
#line 4950
          tmp___53 = strcmp((char const   *)name___0, "info");
          }
#line 4950
          if (tmp___53 == 0) {
            {
#line 4955
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else {
#line 4950
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 4950
        if (do_trace_abbrevs) {
          {
#line 4950
          tmp___54 = strcmp((char const   *)name___0, "abbrev");
          }
#line 4950
          if (tmp___54 == 0) {
            {
#line 4955
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else {
#line 4950
            goto _L___15;
          }
        } else
        _L___15: /* CIL Label */ 
#line 4950
        if (do_trace_aranges) {
          {
#line 4950
          tmp___55 = strcmp((char const   *)name___0, "aranges");
          }
#line 4950
          if (tmp___55 == 0) {
            {
#line 4955
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 4853
    i ++;
#line 4853
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4960
  if (! do_sections) {
#line 4961
    return (1);
  }
#line 4963
  if (elf_header.e_shnum > 1U) {
    {
#line 4964
    tmp___63 = gettext("\nSection Headers:\n");
#line 4964
    printf((char const   */* __restrict  */)tmp___63);
    }
  } else {
    {
#line 4966
    tmp___64 = gettext("\nSection Header:\n");
#line 4966
    printf((char const   */* __restrict  */)tmp___64);
    }
  }
#line 4968
  if (is_32bit_elf) {
#line 4970
    if (do_section_details) {
      {
#line 4972
      tmp___65 = gettext("  [Nr] Name\n");
#line 4972
      printf((char const   */* __restrict  */)tmp___65);
#line 4973
      tmp___66 = gettext("       Type            Addr     Off    Size   ES   Lk Inf Al\n");
#line 4973
      printf((char const   */* __restrict  */)tmp___66);
      }
    } else {
      {
#line 4976
      tmp___67 = gettext("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n");
#line 4976
      printf((char const   */* __restrict  */)tmp___67);
      }
    }
  } else
#line 4979
  if (do_wide) {
#line 4981
    if (do_section_details) {
      {
#line 4983
      tmp___68 = gettext("  [Nr] Name\n");
#line 4983
      printf((char const   */* __restrict  */)tmp___68);
#line 4984
      tmp___69 = gettext("       Type            Address          Off    Size   ES   Lk Inf Al\n");
#line 4984
      printf((char const   */* __restrict  */)tmp___69);
      }
    } else {
      {
#line 4987
      tmp___70 = gettext("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n");
#line 4987
      printf((char const   */* __restrict  */)tmp___70);
      }
    }
  } else
#line 4992
  if (do_section_details) {
    {
#line 4994
    tmp___71 = gettext("  [Nr] Name\n");
#line 4994
    printf((char const   */* __restrict  */)tmp___71);
#line 4995
    tmp___72 = gettext("       Type              Address          Offset            Link\n");
#line 4995
    printf((char const   */* __restrict  */)tmp___72);
#line 4996
    tmp___73 = gettext("       Size              EntSize          Info              Align\n");
#line 4996
    printf((char const   */* __restrict  */)tmp___73);
    }
  } else {
    {
#line 5000
    tmp___74 = gettext("  [Nr] Name              Type             Address           Offset\n");
#line 5000
    printf((char const   */* __restrict  */)tmp___74);
#line 5001
    tmp___75 = gettext("       Size              EntSize          Flags  Link  Info  Align\n");
#line 5001
    printf((char const   */* __restrict  */)tmp___75);
    }
  }
#line 5005
  if (do_section_details) {
    {
#line 5006
    tmp___76 = gettext("       Flags\n");
#line 5006
    printf((char const   */* __restrict  */)tmp___76);
    }
  }
#line 5008
  i = 0U;
#line 5008
  section = section_headers;
  {
#line 5008
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5008
    if (! (i < elf_header.e_shnum)) {
#line 5008
      goto while_break___5;
    }
    {
#line 5012
    printf((char const   */* __restrict  */)"  [%2u] ", i);
    }
#line 5013
    if (do_section_details) {
#line 5015
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 5015
        tmp___77 = gettext("<none>");
#line 5015
        tmp___82 = tmp___77;
        }
      } else {
#line 5015
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5015
          tmp___78 = gettext("<no-name>");
#line 5015
          tmp___81 = tmp___78;
          }
        } else {
#line 5015
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 5015
            tmp___79 = gettext("<corrupt>");
#line 5015
            tmp___80 = tmp___79;
            }
          } else {
#line 5015
            tmp___80 = string_table + section->sh_name;
          }
#line 5015
          tmp___81 = tmp___80;
        }
#line 5015
        tmp___82 = tmp___81;
      }
      {
#line 5015
      print_symbol(2147483647, (char const   *)tmp___82);
#line 5016
      printf((char const   */* __restrict  */)"\n      ");
      }
    } else {
#line 5020
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 5020
        tmp___83 = gettext("<none>");
#line 5020
        tmp___88 = tmp___83;
        }
      } else {
#line 5020
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5020
          tmp___84 = gettext("<no-name>");
#line 5020
          tmp___87 = tmp___84;
          }
        } else {
#line 5020
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 5020
            tmp___85 = gettext("<corrupt>");
#line 5020
            tmp___86 = tmp___85;
            }
          } else {
#line 5020
            tmp___86 = string_table + section->sh_name;
          }
#line 5020
          tmp___87 = tmp___86;
        }
#line 5020
        tmp___88 = tmp___87;
      }
      {
#line 5020
      print_symbol(-17, (char const   *)tmp___88);
      }
    }
    {
#line 5023
    tmp___89 = get_section_type_name(section->sh_type);
    }
#line 5023
    if (do_wide) {
#line 5023
      tmp___90 = " %-15s ";
    } else {
#line 5023
      tmp___90 = " %-15.15s ";
    }
    {
#line 5023
    printf((char const   */* __restrict  */)tmp___90, tmp___89);
    }
#line 5026
    if (is_32bit_elf) {
      {
#line 5028
      link_too_big = (char const   *)((void *)0);
#line 5030
      print_vma(section->sh_addr, (print_mode )6);
#line 5032
      printf((char const   */* __restrict  */)" %6.6lx %6.6lx %2.2lx", (unsigned long )section->sh_offset,
             section->sh_size, section->sh_entsize);
      }
#line 5037
      if (do_section_details) {
        {
#line 5038
        fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 5040
        tmp___91 = get_elf_section_flags(section->sh_flags);
#line 5040
        printf((char const   */* __restrict  */)" %3s ", tmp___91);
        }
      }
#line 5042
      if (section->sh_link >= elf_header.e_shnum) {
#line 5044
        link_too_big = "";
        {
#line 5057
        if ((int )elf_header.e_machine == 2) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 43) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 18) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 11) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 181) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 180) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 62) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 6) {
#line 5057
          goto case_2;
        }
#line 5057
        if ((int )elf_header.e_machine == 3) {
#line 5057
          goto case_2;
        }
#line 5063
        goto switch_default;
        case_2: /* CIL Label */ 
        case_43: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_11: /* CIL Label */ 
        case_181: /* CIL Label */ 
        case_180: /* CIL Label */ 
        case_62: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 5058
        if (section->sh_link == 65280U) {
#line 5059
          link_too_big = "BEFORE";
        } else
#line 5060
        if (section->sh_link == 65281U) {
#line 5061
          link_too_big = "AFTER";
        }
#line 5062
        goto switch_break___2;
        switch_default: /* CIL Label */ 
#line 5064
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
#line 5068
      if (do_section_details) {
#line 5070
        if ((unsigned long )link_too_big != (unsigned long )((void *)0)) {
#line 5070
          if (*link_too_big) {
            {
#line 5071
            printf((char const   */* __restrict  */)"<%s> ", link_too_big);
            }
          } else {
            {
#line 5073
            printf((char const   */* __restrict  */)"%2u ", section->sh_link);
            }
          }
        } else {
          {
#line 5073
          printf((char const   */* __restrict  */)"%2u ", section->sh_link);
          }
        }
        {
#line 5074
        printf((char const   */* __restrict  */)"%3u %2lu\n", section->sh_info, section->sh_addralign);
        }
      } else {
        {
#line 5078
        printf((char const   */* __restrict  */)"%2u %3u %2lu\n", section->sh_link,
               section->sh_info, section->sh_addralign);
        }
      }
#line 5083
      if (link_too_big) {
#line 5083
        if (! *link_too_big) {
          {
#line 5084
          tmp___92 = gettext("section %u: sh_link value of %u is larger than the number of sections\n");
#line 5084
          warn((char const   *)tmp___92, i, section->sh_link);
          }
        }
      }
    } else
#line 5087
    if (do_wide) {
      {
#line 5089
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 5091
      if (section->sh_offset == section->sh_offset) {
        {
#line 5092
        printf((char const   */* __restrict  */)" %6.6lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 5095
        putchar(' ');
#line 5096
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
#line 5099
      if (section->sh_size == section->sh_size) {
        {
#line 5100
        printf((char const   */* __restrict  */)" %6.6lx", section->sh_size);
        }
      } else {
        {
#line 5103
        putchar(' ');
#line 5104
        print_vma(section->sh_size, (print_mode )6);
        }
      }
#line 5107
      if (section->sh_entsize == section->sh_entsize) {
        {
#line 5108
        printf((char const   */* __restrict  */)" %2.2lx", section->sh_entsize);
        }
      } else {
        {
#line 5111
        putchar(' ');
#line 5112
        print_vma(section->sh_entsize, (print_mode )6);
        }
      }
#line 5115
      if (do_section_details) {
        {
#line 5116
        fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 5118
        tmp___93 = get_elf_section_flags(section->sh_flags);
#line 5118
        printf((char const   */* __restrict  */)" %3s ", tmp___93);
        }
      }
      {
#line 5120
      printf((char const   */* __restrict  */)"%2u %3u ", section->sh_link, section->sh_info);
      }
#line 5122
      if (section->sh_addralign == section->sh_addralign) {
        {
#line 5123
        printf((char const   */* __restrict  */)"%2lu\n", section->sh_addralign);
        }
      } else {
        {
#line 5126
        print_vma(section->sh_addralign, (print_mode )1);
#line 5127
        putchar('\n');
        }
      }
    } else
#line 5130
    if (do_section_details) {
      {
#line 5132
      tmp___94 = get_section_type_name(section->sh_type);
#line 5132
      printf((char const   */* __restrict  */)"       %-15.15s  ", tmp___94);
#line 5134
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 5135
      if (section->sh_offset == section->sh_offset) {
        {
#line 5136
        printf((char const   */* __restrict  */)"  %16.16lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 5139
        printf((char const   */* __restrict  */)"  ");
#line 5140
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
      {
#line 5142
      printf((char const   */* __restrict  */)"  %u\n       ", section->sh_link);
#line 5143
      print_vma(section->sh_size, (print_mode )6);
#line 5144
      putchar(' ');
#line 5145
      print_vma(section->sh_entsize, (print_mode )6);
#line 5147
      printf((char const   */* __restrict  */)"  %-16u  %lu\n", section->sh_info,
             section->sh_addralign);
      }
    } else {
      {
#line 5153
      putchar(' ');
#line 5154
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 5155
      if (section->sh_offset == section->sh_offset) {
        {
#line 5156
        printf((char const   */* __restrict  */)"  %8.8lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 5159
        printf((char const   */* __restrict  */)"  ");
#line 5160
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
      {
#line 5162
      printf((char const   */* __restrict  */)"\n       ");
#line 5163
      print_vma(section->sh_size, (print_mode )6);
#line 5164
      printf((char const   */* __restrict  */)"  ");
#line 5165
      print_vma(section->sh_entsize, (print_mode )6);
#line 5167
      tmp___95 = get_elf_section_flags(section->sh_flags);
#line 5167
      printf((char const   */* __restrict  */)" %3s ", tmp___95);
#line 5169
      printf((char const   */* __restrict  */)"     %2u   %3u     %lu\n", section->sh_link,
             section->sh_info, section->sh_addralign);
      }
    }
#line 5175
    if (do_section_details) {
      {
#line 5176
      tmp___96 = get_elf_section_flags(section->sh_flags);
#line 5176
      printf((char const   */* __restrict  */)"       %s\n", tmp___96);
      }
    }
#line 5008
    i ++;
#line 5008
    section ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 5179
  if (! do_section_details) {
#line 5181
    if ((int )elf_header.e_machine == 62) {
      {
#line 5184
      tmp___97 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 5184
      printf((char const   */* __restrict  */)tmp___97);
      }
    } else
#line 5181
    if ((int )elf_header.e_machine == 180) {
      {
#line 5184
      tmp___97 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 5184
      printf((char const   */* __restrict  */)tmp___97);
      }
    } else
#line 5181
    if ((int )elf_header.e_machine == 181) {
      {
#line 5184
      tmp___97 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 5184
      printf((char const   */* __restrict  */)tmp___97);
      }
    } else {
      {
#line 5189
      tmp___98 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 5189
      printf((char const   */* __restrict  */)tmp___98);
      }
    }
  }
#line 5195
  return (1);
}
}
#line 5201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___8[32]  ;
#line 5198 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_group_flags(unsigned int flags___1 ) 
{ 
  char *tmp___0 ;

  {
  {
#line 5204
  if (flags___1 == 0U) {
#line 5204
    goto case_0;
  }
#line 5207
  if (flags___1 == 1U) {
#line 5207
    goto case_1;
  }
#line 5210
  goto switch_default;
  case_0: /* CIL Label */ 
#line 5205
  return ("");
  case_1: /* CIL Label */ 
#line 5208
  return ("COMDAT ");
  switch_default: /* CIL Label */ 
  {
#line 5211
  tmp___0 = gettext("[<unknown>: 0x%x] ");
#line 5211
  snprintf((char */* __restrict  */)(buff___8), sizeof(buff___8), (char const   */* __restrict  */)tmp___0,
           flags___1);
  }
#line 5212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5214
  return ((char const   *)(buff___8));
}
}
#line 5424
static int process_section_groups(FILE *file ) ;
#line 5424 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int warned___0  =    0;
#line 5217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_section_groups(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  struct group *group ;
  Elf_Internal_Shdr *symtab_sec ;
  Elf_Internal_Shdr *strtab_sec ;
  Elf_Internal_Sym *symtab ;
  unsigned long num_syms ;
  char *strtab ;
  size_t strtab_size ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *name___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *group_name ;
  unsigned char *start ;
  unsigned char *indices ;
  unsigned int entry ;
  unsigned int j ;
  unsigned int size ;
  Elf_Internal_Shdr *sec ;
  Elf_Internal_Sym *sym ;
  char *tmp___13 ;
  Elf_Internal_Sym *tmp___14 ;
  Elf_Internal_Sym *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  elf_vma tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  struct group_list *g ;
  elf_vma tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  void *tmp___43 ;

  {
#line 5231
  if (! do_unwind) {
#line 5231
    if (! do_section_groups) {
#line 5232
      return (1);
    }
  }
#line 5234
  if (elf_header.e_shnum == 0U) {
#line 5236
    if (do_section_groups) {
      {
#line 5237
      tmp___0 = gettext("\nThere are no sections to group in this file.\n");
#line 5237
      printf((char const   */* __restrict  */)tmp___0);
      }
    }
#line 5239
    return (1);
  }
#line 5242
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 5244
    tmp___1 = gettext("Section headers are not available!\n");
#line 5244
    error((char const   *)tmp___1);
    }
#line 5246
    return (0);
  }
  {
#line 5249
  tmp___2 = calloc((size_t )elf_header.e_shnum, sizeof(struct group *));
#line 5249
  section_headers_groups = (struct group **)tmp___2;
  }
#line 5252
  if ((unsigned long )section_headers_groups == (unsigned long )((void *)0)) {
    {
#line 5254
    tmp___3 = gettext("Out of memory\n");
#line 5254
    error((char const   *)tmp___3);
    }
#line 5255
    return (0);
  }
#line 5259
  group_count = (size_t )0;
#line 5260
  i = 0U;
#line 5260
  section = section_headers;
  {
#line 5260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5260
    if (! (i < elf_header.e_shnum)) {
#line 5260
      goto while_break;
    }
#line 5263
    if (section->sh_type == 17U) {
#line 5264
      group_count ++;
    }
#line 5260
    i ++;
#line 5260
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5266
  if (group_count == 0UL) {
#line 5268
    if (do_section_groups) {
      {
#line 5269
      tmp___4 = gettext("\nThere are no section groups in this file.\n");
#line 5269
      printf((char const   */* __restrict  */)tmp___4);
      }
    }
#line 5271
    return (1);
  }
  {
#line 5274
  tmp___5 = calloc(group_count, sizeof(struct group ));
#line 5274
  section_groups = (struct group *)tmp___5;
  }
#line 5276
  if ((unsigned long )section_groups == (unsigned long )((void *)0)) {
    {
#line 5278
    tmp___6 = gettext("Out of memory\n");
#line 5278
    error((char const   *)tmp___6);
    }
#line 5279
    return (0);
  }
#line 5282
  symtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5283
  strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5284
  symtab = (Elf_Internal_Sym *)((void *)0);
#line 5285
  num_syms = 0UL;
#line 5286
  strtab = (char *)((void *)0);
#line 5287
  strtab_size = (size_t )0;
#line 5288
  i = 0U;
#line 5288
  section = section_headers;
#line 5288
  group = section_groups;
  {
#line 5288
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5288
    if (! (i < elf_header.e_shnum)) {
#line 5288
      goto while_break___0;
    }
#line 5292
    if (section->sh_type == 17U) {
#line 5294
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 5294
        tmp___7 = gettext("<none>");
#line 5294
        tmp___12 = tmp___7;
        }
      } else {
#line 5294
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5294
          tmp___8 = gettext("<no-name>");
#line 5294
          tmp___11 = tmp___8;
          }
        } else {
#line 5294
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 5294
            tmp___9 = gettext("<corrupt>");
#line 5294
            tmp___10 = tmp___9;
            }
          } else {
#line 5294
            tmp___10 = string_table + section->sh_name;
          }
#line 5294
          tmp___11 = tmp___10;
        }
#line 5294
        tmp___12 = tmp___11;
      }
#line 5294
      name___0 = tmp___12;
#line 5303
      if (section->sh_link >= elf_header.e_shnum) {
        {
#line 5307
        tmp___13 = gettext("Bad sh_link in group section `%s\'\n");
#line 5307
        error((char const   *)tmp___13, name___0);
        }
#line 5308
        goto __Cont;
      } else {
#line 5303
        sec = section_headers + section->sh_link;
#line 5303
        if (sec->sh_type != 2U) {
          {
#line 5307
          tmp___13 = gettext("Bad sh_link in group section `%s\'\n");
#line 5307
          error((char const   *)tmp___13, name___0);
          }
#line 5308
          goto __Cont;
        }
      }
#line 5311
      if ((unsigned long )symtab_sec != (unsigned long )sec) {
#line 5313
        symtab_sec = sec;
#line 5314
        if (symtab) {
          {
#line 5315
          free((void *)symtab);
          }
        }
#line 5316
        if (is_32bit_elf) {
          {
#line 5316
          tmp___14 = get_32bit_elf_symbols(file, symtab_sec, & num_syms);
#line 5316
          symtab = tmp___14;
          }
        } else {
          {
#line 5316
          tmp___15 = get_64bit_elf_symbols(file, symtab_sec, & num_syms);
#line 5316
          symtab = tmp___15;
          }
        }
      }
#line 5319
      if ((unsigned long )symtab == (unsigned long )((void *)0)) {
        {
#line 5321
        tmp___16 = gettext("Corrupt header in group section `%s\'\n");
#line 5321
        error((char const   *)tmp___16, name___0);
        }
#line 5322
        goto __Cont;
      }
#line 5325
      if ((unsigned long )section->sh_info >= num_syms) {
        {
#line 5327
        tmp___17 = gettext("Bad sh_info in group section `%s\'\n");
#line 5327
        error((char const   *)tmp___17, name___0);
        }
#line 5328
        goto __Cont;
      }
#line 5331
      sym = symtab + section->sh_info;
#line 5333
      if (((int )sym->st_info & 15) == 3) {
#line 5335
        if (sym->st_shndx == 0U) {
          {
#line 5338
          tmp___18 = gettext("Bad sh_info in group section `%s\'\n");
#line 5338
          error((char const   *)tmp___18, name___0);
          }
#line 5339
          goto __Cont;
        } else
#line 5335
        if (sym->st_shndx >= elf_header.e_shnum) {
          {
#line 5338
          tmp___18 = gettext("Bad sh_info in group section `%s\'\n");
#line 5338
          error((char const   *)tmp___18, name___0);
          }
#line 5339
          goto __Cont;
        }
#line 5342
        if ((unsigned long )(section_headers + sym->st_shndx) == (unsigned long )((void *)0)) {
          {
#line 5342
          tmp___19 = gettext("<none>");
#line 5342
          group_name = tmp___19;
          }
        } else {
#line 5342
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5342
            tmp___20 = gettext("<no-name>");
#line 5342
            tmp___23 = tmp___20;
            }
          } else {
#line 5342
            if ((unsigned long )(section_headers + sym->st_shndx)->sh_name >= string_table_length) {
              {
#line 5342
              tmp___21 = gettext("<corrupt>");
#line 5342
              tmp___22 = tmp___21;
              }
            } else {
#line 5342
              tmp___22 = string_table + (section_headers + sym->st_shndx)->sh_name;
            }
#line 5342
            tmp___23 = tmp___22;
          }
#line 5342
          group_name = tmp___23;
        }
#line 5343
        strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5344
        if (strtab) {
          {
#line 5345
          free((void *)strtab);
          }
        }
#line 5346
        strtab = (char *)((void *)0);
#line 5347
        strtab_size = (size_t )0;
      } else {
#line 5352
        if (symtab_sec->sh_link >= elf_header.e_shnum) {
#line 5354
          strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5355
          if (strtab) {
            {
#line 5356
            free((void *)strtab);
            }
          }
#line 5357
          strtab = (char *)((void *)0);
#line 5358
          strtab_size = (size_t )0;
        } else {
#line 5360
          sec = section_headers + symtab_sec->sh_link;
#line 5360
          if ((unsigned long )strtab_sec != (unsigned long )sec) {
#line 5363
            strtab_sec = sec;
#line 5364
            if (strtab) {
              {
#line 5365
              free((void *)strtab);
              }
            }
            {
#line 5366
            tmp___24 = gettext("string table");
#line 5366
            tmp___25 = get_data((void *)0, file, strtab_sec->sh_offset, (size_t )1,
                                strtab_sec->sh_size, (char const   *)tmp___24);
#line 5366
            strtab = (char *)tmp___25;
            }
#line 5369
            if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 5369
              strtab_size = strtab_sec->sh_size;
            } else {
#line 5369
              strtab_size = (size_t )0;
            }
          }
        }
#line 5371
        if (sym->st_name < strtab_size) {
#line 5371
          group_name = strtab + sym->st_name;
        } else {
          {
#line 5371
          tmp___26 = gettext("<corrupt>");
#line 5371
          group_name = tmp___26;
          }
        }
      }
      {
#line 5375
      tmp___27 = gettext("section data");
#line 5375
      tmp___28 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                          (char const   *)tmp___27);
#line 5375
      start = (unsigned char *)tmp___28;
      }
#line 5378
      if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 5379
        goto __Cont;
      }
      {
#line 5381
      indices = start;
#line 5382
      size = (unsigned int )(section->sh_size / section->sh_entsize - 1UL);
#line 5383
      tmp___29 = (*byte_get)(indices, 4);
#line 5383
      entry = (unsigned int )tmp___29;
#line 5384
      indices += 4;
      }
#line 5386
      if (do_section_groups) {
        {
#line 5388
        tmp___30 = get_group_flags(entry);
#line 5388
        tmp___31 = gettext("\n%sgroup section [%5u] `%s\' [%s] contains %u sections:\n");
#line 5388
        printf((char const   */* __restrict  */)tmp___31, tmp___30, i, name___0, group_name,
               size);
#line 5391
        tmp___32 = gettext("   [Index]    Name\n");
#line 5391
        printf((char const   */* __restrict  */)tmp___32);
        }
      }
#line 5394
      group->group_index = i;
#line 5396
      j = 0U;
      {
#line 5396
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5396
        if (! (j < size)) {
#line 5396
          goto while_break___1;
        }
        {
#line 5400
        tmp___33 = (*byte_get)(indices, 4);
#line 5400
        entry = (unsigned int )tmp___33;
#line 5401
        indices += 4;
        }
#line 5403
        if (entry >= elf_header.e_shnum) {
          {
#line 5405
          tmp___34 = gettext("section [%5u] in group section [%5u] > maximum section [%5u]\n");
#line 5405
          error((char const   *)tmp___34, entry, i, elf_header.e_shnum - 1U);
          }
#line 5407
          goto __Cont___0;
        }
#line 5410
        if ((unsigned long )*(section_headers_groups + entry) != (unsigned long )((void *)0)) {
#line 5412
          if (entry) {
            {
#line 5414
            tmp___35 = gettext("section [%5u] in group section [%5u] already in group section [%5u]\n");
#line 5414
            error((char const   *)tmp___35, entry, i, (*(section_headers_groups + entry))->group_index);
            }
#line 5417
            goto __Cont___0;
          } else
#line 5425
          if (! warned___0) {
            {
#line 5427
            tmp___36 = gettext("section 0 in group section [%5u]\n");
#line 5427
            error((char const   *)tmp___36, (*(section_headers_groups + entry))->group_index);
#line 5429
            warned___0 ++;
            }
          }
        }
#line 5434
        *(section_headers_groups + entry) = group;
#line 5436
        if (do_section_groups) {
#line 5438
          sec = section_headers + entry;
#line 5439
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 5439
            tmp___37 = gettext("<none>");
#line 5439
            tmp___42 = tmp___37;
            }
          } else {
#line 5439
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5439
              tmp___38 = gettext("<no-name>");
#line 5439
              tmp___41 = tmp___38;
              }
            } else {
#line 5439
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 5439
                tmp___39 = gettext("<corrupt>");
#line 5439
                tmp___40 = tmp___39;
                }
              } else {
#line 5439
                tmp___40 = string_table + sec->sh_name;
              }
#line 5439
              tmp___41 = tmp___40;
            }
#line 5439
            tmp___42 = tmp___41;
          }
          {
#line 5439
          printf((char const   */* __restrict  */)"   [%5u]   %s\n", entry, tmp___42);
          }
        }
        {
#line 5442
        tmp___43 = xmalloc(sizeof(struct group_list ));
#line 5442
        g = (struct group_list *)tmp___43;
#line 5443
        g->section_index = entry;
#line 5444
        g->next = group->root;
#line 5445
        group->root = g;
        }
        __Cont___0: /* CIL Label */ 
#line 5396
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5448
      if (start) {
        {
#line 5449
        free((void *)start);
        }
      }
#line 5451
      group ++;
    }
    __Cont: /* CIL Label */ 
#line 5288
    i ++;
#line 5288
    section ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5455
  if (symtab) {
    {
#line 5456
    free((void *)symtab);
    }
  }
#line 5457
  if (strtab) {
    {
#line 5458
    free((void *)strtab);
    }
  }
#line 5459
  return (1);
}
}
#line 5484 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_ia64_vms_dynamic_fixups(FILE *file , struct ia64_vms_dynfixup *fixup ,
                                         char const   *strtab , unsigned int strtab_sz ) 
{ 
  Elf64_External_VMS_IMAGE_FIXUP *imfs ;
  long i ;
  char const   *lib_name ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int type ;
  char const   *rtype ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;

  {
  {
#line 5492
  tmp___0 = gettext("dynamic section image fixups");
#line 5492
  tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + fixup->fixup_rela_off),
                     (size_t )1, fixup->fixup_rela_cnt * sizeof(*imfs), (char const   *)tmp___0);
#line 5492
  imfs = (Elf64_External_VMS_IMAGE_FIXUP *)tmp___1;
  }
#line 5495
  if (! imfs) {
#line 5496
    return;
  }
#line 5498
  if (fixup->needed < (bfd_vma )strtab_sz) {
#line 5499
    lib_name = strtab + fixup->needed;
  } else {
    {
#line 5502
    warn("corrupt library name index of 0x%lx found in dynamic entry", fixup->needed);
#line 5504
    lib_name = "???";
    }
  }
  {
#line 5506
  tmp___2 = gettext("\nImage fixups for needed library #%d: %s - ident: %lx\n");
#line 5506
  printf((char const   */* __restrict  */)tmp___2, (int )fixup->fixup_needed, lib_name,
         (long )fixup->needed_ident);
#line 5508
  tmp___3 = gettext("Seg Offset           Type                             SymVec DataType\n");
#line 5508
  printf((char const   */* __restrict  */)tmp___3);
#line 5511
  i = 0L;
  }
  {
#line 5511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5511
    if (! (i < (long )fixup->fixup_rela_cnt)) {
#line 5511
      goto while_break;
    }
    {
#line 5516
    tmp___4 = (*byte_get)((imfs + i)->fixup_seg, (int )sizeof((imfs + i)->fixup_seg));
#line 5516
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___4);
#line 5517
    tmp___5 = (*byte_get)((imfs + i)->fixup_offset, (int )sizeof((imfs + i)->fixup_offset));
#line 5517
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            (bfd_vma )tmp___5);
#line 5518
    tmp___6 = (*byte_get)((imfs + i)->type, (int )sizeof((imfs + i)->type));
#line 5518
    type = (unsigned int )tmp___6;
#line 5519
    rtype = elf_ia64_reloc_type((unsigned long )type);
    }
#line 5520
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 5521
      printf((char const   */* __restrict  */)" 0x%08x                       ", type);
      }
    } else {
      {
#line 5523
      printf((char const   */* __restrict  */)" %-32s ", rtype);
      }
    }
    {
#line 5524
    tmp___7 = (*byte_get)((imfs + i)->symvec_index, (int )sizeof((imfs + i)->symvec_index));
#line 5524
    printf((char const   */* __restrict  */)"%6u ", (unsigned int )tmp___7);
#line 5525
    tmp___8 = (*byte_get)((imfs + i)->data_type, (int )sizeof((imfs + i)->data_type));
#line 5525
    printf((char const   */* __restrict  */)"0x%08x\n", (unsigned int )tmp___8);
#line 5511
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5528
  free((void *)imfs);
  }
#line 5529
  return;
}
}
#line 5533 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_ia64_vms_dynamic_relocs(FILE *file , struct ia64_vms_dynimgrela *imgrela ) 
{ 
  Elf64_External_VMS_IMAGE_RELA *imrs ;
  long i ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int type ;
  char const   *rtype ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 5539
  tmp___0 = gettext("dynamic section image relocations");
#line 5539
  tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + imgrela->img_rela_off),
                     (size_t )1, imgrela->img_rela_cnt * sizeof(*imrs), (char const   *)tmp___0);
#line 5539
  imrs = (Elf64_External_VMS_IMAGE_RELA *)tmp___1;
  }
#line 5542
  if (! imrs) {
#line 5543
    return;
  }
  {
#line 5545
  tmp___2 = gettext("\nImage relocs\n");
#line 5545
  printf((char const   */* __restrict  */)tmp___2);
#line 5546
  tmp___3 = gettext("Seg Offset   Type                            Addend            Seg Sym Off\n");
#line 5546
  printf((char const   */* __restrict  */)tmp___3);
#line 5549
  i = 0L;
  }
  {
#line 5549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5549
    if (! (i < (long )imgrela->img_rela_cnt)) {
#line 5549
      goto while_break;
    }
    {
#line 5554
    tmp___4 = (*byte_get)((imrs + i)->rela_seg, (int )sizeof((imrs + i)->rela_seg));
#line 5554
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___4);
#line 5555
    tmp___5 = (*byte_get)((imrs + i)->rela_offset, (int )sizeof((imrs + i)->rela_offset));
#line 5555
    printf((char const   */* __restrict  */)"%08lx ", (bfd_vma )tmp___5);
#line 5557
    tmp___6 = (*byte_get)((imrs + i)->type, (int )sizeof((imrs + i)->type));
#line 5557
    type = (unsigned int )tmp___6;
#line 5558
    rtype = elf_ia64_reloc_type((unsigned long )type);
    }
#line 5559
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 5560
      printf((char const   */* __restrict  */)"0x%08x                      ", type);
      }
    } else {
      {
#line 5562
      printf((char const   */* __restrict  */)"%-31s ", rtype);
      }
    }
    {
#line 5563
    tmp___7 = (*byte_get)((imrs + i)->addend, (int )sizeof((imrs + i)->addend));
#line 5563
    print_vma((bfd_vma )tmp___7, (print_mode )5);
#line 5564
    tmp___8 = (*byte_get)((imrs + i)->sym_seg, (int )sizeof((imrs + i)->sym_seg));
#line 5564
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___8);
#line 5565
    tmp___9 = (*byte_get)((imrs + i)->sym_offset, (int )sizeof((imrs + i)->sym_offset));
#line 5565
    printf((char const   */* __restrict  */)"%08lx\n", (bfd_vma )tmp___9);
#line 5549
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5569
  free((void *)imrs);
  }
#line 5570
  return;
}
}
#line 5574 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_ia64_vms_dynamic_relocs(FILE *file ) 
{ 
  struct ia64_vms_dynfixup fixup ;
  struct ia64_vms_dynimgrela imgrela ;
  Elf_Internal_Dyn *entry ;
  int res___0 ;
  bfd_vma strtab_off ;
  bfd_vma strtab_sz ;
  char *strtab ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 5580
  res___0 = 0;
#line 5581
  strtab_off = (bfd_vma )0;
#line 5582
  strtab_sz = (bfd_vma )0;
#line 5583
  strtab = (char *)((void *)0);
#line 5585
  memset((void *)(& fixup), 0, sizeof(fixup));
#line 5586
  memset((void *)(& imgrela), 0, sizeof(imgrela));
#line 5589
  entry = dynamic_section;
  }
  {
#line 5589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5589
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 5589
      goto while_break;
    }
    {
#line 5595
    if (entry->d_tag == 1610612801UL) {
#line 5595
      goto case_1610612801;
    }
#line 5598
    if (entry->d_tag == 10UL) {
#line 5598
      goto case_10;
    }
#line 5605
    if (entry->d_tag == 1610612765UL) {
#line 5605
      goto case_1610612765;
    }
#line 5608
    if (entry->d_tag == 1UL) {
#line 5608
      goto case_1;
    }
#line 5611
    if (entry->d_tag == 1610612773UL) {
#line 5611
      goto case_1610612773;
    }
#line 5614
    if (entry->d_tag == 1610612771UL) {
#line 5614
      goto case_1610612771;
    }
#line 5617
    if (entry->d_tag == 1610612809UL) {
#line 5617
      goto case_1610612809;
    }
#line 5623
    if (entry->d_tag == 1610612767UL) {
#line 5623
      goto case_1610612767;
    }
#line 5626
    if (entry->d_tag == 1610612805UL) {
#line 5626
      goto case_1610612805;
    }
#line 5632
    goto switch_default;
    case_1610612801: /* CIL Label */ 
#line 5596
    strtab_off = entry->d_un.d_val;
#line 5597
    goto switch_break;
    case_10: /* CIL Label */ 
#line 5599
    strtab_sz = entry->d_un.d_val;
#line 5600
    if ((unsigned long )strtab == (unsigned long )((void *)0)) {
      {
#line 5601
      tmp___0 = gettext("dynamic string section");
#line 5601
      tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + strtab_off), (size_t )1,
                         strtab_sz, (char const   *)tmp___0);
#line 5601
      strtab = (char *)tmp___1;
      }
    }
#line 5603
    goto switch_break;
    case_1610612765: /* CIL Label */ 
#line 5606
    fixup.needed_ident = entry->d_un.d_val;
#line 5607
    goto switch_break;
    case_1: /* CIL Label */ 
#line 5609
    fixup.needed = entry->d_un.d_val;
#line 5610
    goto switch_break;
    case_1610612773: /* CIL Label */ 
#line 5612
    fixup.fixup_needed = entry->d_un.d_val;
#line 5613
    goto switch_break;
    case_1610612771: /* CIL Label */ 
#line 5615
    fixup.fixup_rela_cnt = entry->d_un.d_val;
#line 5616
    goto switch_break;
    case_1610612809: /* CIL Label */ 
    {
#line 5618
    fixup.fixup_rela_off = entry->d_un.d_val;
#line 5619
    res___0 ++;
#line 5620
    dump_ia64_vms_dynamic_fixups(file, & fixup, (char const   *)strtab, (unsigned int )strtab_sz);
    }
#line 5621
    goto switch_break;
    case_1610612767: /* CIL Label */ 
#line 5624
    imgrela.img_rela_cnt = entry->d_un.d_val;
#line 5625
    goto switch_break;
    case_1610612805: /* CIL Label */ 
    {
#line 5627
    imgrela.img_rela_off = entry->d_un.d_val;
#line 5628
    res___0 ++;
#line 5629
    dump_ia64_vms_dynamic_relocs(file, & imgrela);
    }
#line 5630
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5633
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5589
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5637
  if ((unsigned long )strtab != (unsigned long )((void *)0)) {
    {
#line 5638
    free((void *)strtab);
    }
  }
#line 5640
  return (res___0);
}
}
#line 5643 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct __anonstruct_dynamic_relocations_602783530 dynamic_relocations[3]  = {      {"REL",
      17, 18, 0}, 
        {"RELA", 7, 8, 1}, 
        {"PLT", 23, 2, -1}};
#line 5658 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_relocs(FILE *file ) 
{ 
  unsigned long rel_size ;
  unsigned long rel_offset ;
  int is_rela ;
  char const   *name___0 ;
  int has_dynamic_reloc ;
  unsigned int i ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  Elf_Internal_Shdr *section ;
  unsigned long i___0 ;
  int found ;
  Elf_Internal_Shdr *strsec ;
  int is_rela___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  Elf_Internal_Shdr *symsec ;
  Elf_Internal_Sym *symtab ;
  unsigned long nsyms ;
  unsigned long strtablen ;
  char *strtab ;
  Elf_Internal_Sym *tmp___13 ;
  Elf_Internal_Sym *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;

  {
#line 5665
  if (! do_reloc) {
#line 5666
    return (1);
  }
#line 5668
  if (do_using_dynamic) {
#line 5675
    has_dynamic_reloc = 0;
#line 5677
    i = 0U;
    {
#line 5677
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5677
      if (! ((unsigned long )i < sizeof(dynamic_relocations) / sizeof(dynamic_relocations[0]))) {
#line 5677
        goto while_break;
      }
#line 5679
      is_rela = dynamic_relocations[i].rela;
#line 5680
      name___0 = dynamic_relocations[i].name;
#line 5681
      rel_size = dynamic_info[dynamic_relocations[i].size];
#line 5682
      rel_offset = dynamic_info[dynamic_relocations[i].reloc];
#line 5684
      has_dynamic_reloc = (int )((unsigned long )has_dynamic_reloc | rel_size);
#line 5686
      if (is_rela == -1) {
#line 5688
        if (dynamic_relocations[i].reloc == 23) {
          {
#line 5691
          if (dynamic_info[20] == 17UL) {
#line 5691
            goto case_17;
          }
#line 5694
          if (dynamic_info[20] == 7UL) {
#line 5694
            goto case_7;
          }
#line 5689
          goto switch_break;
          case_17: /* CIL Label */ 
#line 5692
          is_rela = 0;
#line 5693
          goto switch_break;
          case_7: /* CIL Label */ 
#line 5695
          is_rela = 1;
#line 5696
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
#line 5700
      if (rel_size) {
        {
#line 5702
        tmp___0 = gettext("\n\'%s\' relocation section at offset 0x%lx contains %ld bytes:\n");
#line 5702
        printf((char const   */* __restrict  */)tmp___0, name___0, rel_offset, rel_size);
#line 5706
        tmp___1 = offset_from_vma(file, rel_offset, rel_size);
#line 5706
        dump_relocations(file, (unsigned long )tmp___1, rel_size, dynamic_symbols,
                         num_dynamic_syms, dynamic_strings, dynamic_strings_length,
                         is_rela);
        }
      }
#line 5677
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5714
    tmp___3 = is_ia64_vms();
    }
#line 5714
    if (tmp___3) {
      {
#line 5715
      tmp___2 = process_ia64_vms_dynamic_relocs(file);
#line 5715
      has_dynamic_reloc |= tmp___2;
      }
    }
#line 5717
    if (! has_dynamic_reloc) {
      {
#line 5718
      tmp___4 = gettext("\nThere are no dynamic relocations in this file.\n");
#line 5718
      printf((char const   */* __restrict  */)tmp___4);
      }
    }
  } else {
#line 5724
    found = 0;
#line 5726
    i___0 = 0UL;
#line 5726
    section = section_headers;
    {
#line 5726
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5726
      if (! (i___0 < (unsigned long )elf_header.e_shnum)) {
#line 5726
        goto while_break___0;
      }
#line 5730
      if (section->sh_type != 4U) {
#line 5730
        if (section->sh_type != 9U) {
#line 5732
          goto __Cont;
        }
      }
#line 5734
      rel_offset = (unsigned long )section->sh_offset;
#line 5735
      rel_size = section->sh_size;
#line 5737
      if (rel_size) {
        {
#line 5742
        tmp___5 = gettext("\nRelocation section ");
#line 5742
        printf((char const   */* __restrict  */)tmp___5);
        }
#line 5744
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5745
          printf((char const   */* __restrict  */)"%d", section->sh_name);
          }
        } else {
#line 5747
          if ((unsigned long )section == (unsigned long )((void *)0)) {
            {
#line 5747
            tmp___6 = gettext("<none>");
#line 5747
            tmp___11 = tmp___6;
            }
          } else {
#line 5747
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5747
              tmp___7 = gettext("<no-name>");
#line 5747
              tmp___10 = tmp___7;
              }
            } else {
#line 5747
              if ((unsigned long )section->sh_name >= string_table_length) {
                {
#line 5747
                tmp___8 = gettext("<corrupt>");
#line 5747
                tmp___9 = tmp___8;
                }
              } else {
#line 5747
                tmp___9 = string_table + section->sh_name;
              }
#line 5747
              tmp___10 = tmp___9;
            }
#line 5747
            tmp___11 = tmp___10;
          }
          {
#line 5747
          printf((char const   */* __restrict  */)"\'%s\'", tmp___11);
          }
        }
        {
#line 5749
        tmp___12 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 5749
        printf((char const   */* __restrict  */)tmp___12, rel_offset, rel_size / section->sh_entsize);
#line 5752
        is_rela___0 = section->sh_type == 4U;
        }
#line 5754
        if (section->sh_link != 0U) {
#line 5754
          if (section->sh_link < elf_header.e_shnum) {
#line 5760
            strtablen = 0UL;
#line 5761
            strtab = (char *)((void *)0);
#line 5763
            symsec = section_headers + section->sh_link;
#line 5764
            if (symsec->sh_type != 2U) {
#line 5764
              if (symsec->sh_type != 11U) {
#line 5766
                goto __Cont;
              }
            }
#line 5768
            if (is_32bit_elf) {
              {
#line 5768
              tmp___13 = get_32bit_elf_symbols(file, symsec, & nsyms);
#line 5768
              symtab = tmp___13;
              }
            } else {
              {
#line 5768
              tmp___14 = get_64bit_elf_symbols(file, symsec, & nsyms);
#line 5768
              symtab = tmp___14;
              }
            }
#line 5770
            if ((unsigned long )symtab == (unsigned long )((void *)0)) {
#line 5771
              goto __Cont;
            }
#line 5773
            if (symsec->sh_link != 0U) {
#line 5773
              if (symsec->sh_link < elf_header.e_shnum) {
                {
#line 5776
                strsec = section_headers + symsec->sh_link;
#line 5778
                tmp___15 = gettext("string table");
#line 5778
                tmp___16 = get_data((void *)0, file, strsec->sh_offset, (size_t )1,
                                    strsec->sh_size, (char const   *)tmp___15);
#line 5778
                strtab = (char *)tmp___16;
                }
#line 5781
                if ((unsigned long )strtab == (unsigned long )((void *)0)) {
#line 5781
                  strtablen = 0UL;
                } else {
#line 5781
                  strtablen = strsec->sh_size;
                }
              }
            }
            {
#line 5784
            dump_relocations(file, rel_offset, rel_size, symtab, nsyms, strtab, strtablen,
                             is_rela___0);
            }
#line 5786
            if (strtab) {
              {
#line 5787
              free((void *)strtab);
              }
            }
            {
#line 5788
            free((void *)symtab);
            }
          } else {
            {
#line 5791
            dump_relocations(file, rel_offset, rel_size, (Elf_Internal_Sym *)((void *)0),
                             0UL, (char *)((void *)0), 0UL, is_rela___0);
            }
          }
        } else {
          {
#line 5791
          dump_relocations(file, rel_offset, rel_size, (Elf_Internal_Sym *)((void *)0),
                           0UL, (char *)((void *)0), 0UL, is_rela___0);
          }
        }
#line 5794
        found = 1;
      }
      __Cont: /* CIL Label */ 
#line 5726
      i___0 ++;
#line 5726
      section ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5798
    if (! found) {
      {
#line 5799
      tmp___17 = gettext("\nThere are no relocations in this file.\n");
#line 5799
      printf((char const   */* __restrict  */)tmp___17);
      }
    }
  }
#line 5802
  return (1);
}
}
#line 5846 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void find_symbol_for_address(Elf_Internal_Sym *symtab , unsigned long nsyms ,
                                    char const   *strtab , unsigned long strtab_size ,
                                    struct absaddr addr , char const   **symname ,
                                    bfd_vma *offset ) 
{ 
  bfd_vma dist ;
  Elf_Internal_Sym *sym ;
  Elf_Internal_Sym *best ;
  unsigned long i ;
  bfd_vma value ;
  char *tmp___0 ;

  {
#line 5855
  dist = (bfd_vma )1048576;
#line 5857
  best = (Elf_Internal_Sym *)((void *)0);
  {
#line 5860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5860
    if ((int )elf_header.e_machine == 40) {
#line 5860
      addr.offset &= 0xfffffffffffffffeUL;
    }
#line 5860
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5862
  i = 0UL;
#line 5862
  sym = symtab;
  {
#line 5862
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5862
    if (! (i < nsyms)) {
#line 5862
      goto while_break___0;
    }
#line 5864
    value = sym->st_value;
    {
#line 5866
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5866
      if ((int )elf_header.e_machine == 40) {
#line 5866
        value &= 0xfffffffffffffffeUL;
      }
#line 5866
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5868
    if (((int )sym->st_info & 15) == 2) {
#line 5868
      if (sym->st_name != 0UL) {
#line 5868
        if ((int )addr.section == 0) {
#line 5868
          goto _L;
        } else
#line 5868
        if ((unsigned int )addr.section == sym->st_shndx) {
          _L: /* CIL Label */ 
#line 5868
          if (addr.offset >= value) {
#line 5868
            if (addr.offset - value < dist) {
#line 5874
              best = sym;
#line 5875
              dist = addr.offset - value;
#line 5876
              if (! dist) {
#line 5877
                goto while_break___0;
              }
            }
          }
        }
      }
    }
#line 5862
    i ++;
#line 5862
    sym ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5881
  if (best) {
#line 5883
    if (best->st_name >= strtab_size) {
      {
#line 5883
      tmp___0 = gettext("<corrupt>");
#line 5883
      *symname = (char const   *)tmp___0;
      }
    } else {
#line 5883
      *symname = strtab + best->st_name;
    }
#line 5885
    *offset = dist;
#line 5886
    return;
  }
#line 5889
  *symname = (char const   *)((void *)0);
#line 5890
  *offset = addr.offset;
#line 5891
  return;
}
}
#line 5893 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_ia64_unwind(struct ia64_unw_aux_info *aux ) 
{ 
  struct ia64_unw_table_entry *tp ;
  int in_body ;
  bfd_vma stamp ;
  bfd_vma offset ;
  unsigned char const   *dp ;
  unsigned char const   *head ;
  char const   *procname ;
  bfd_vma tmp___0 ;
  elf_vma tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 5899
  tp = aux->table;
  {
#line 5899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5899
    if (! ((unsigned long )tp < (unsigned long )(aux->table + aux->table_len))) {
#line 5899
      goto while_break;
    }
    {
#line 5907
    find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab,
                            aux->strtab_size, tp->start, & procname, & offset);
#line 5910
    fputs((char const   */* __restrict  */)"\n<", (FILE */* __restrict  */)stdout);
    }
#line 5912
    if (procname) {
      {
#line 5914
      fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
      }
#line 5916
      if (offset) {
        {
#line 5917
        printf((char const   */* __restrict  */)"+%lx", offset);
        }
      }
    }
    {
#line 5920
    fputs((char const   */* __restrict  */)">: [", (FILE */* __restrict  */)stdout);
#line 5921
    print_vma(tp->start.offset, (print_mode )4);
#line 5922
    fputc('-', stdout);
#line 5923
    print_vma(tp->end.offset, (print_mode )4);
#line 5924
    printf((char const   */* __restrict  */)"], info at +0x%lx\n", tp->info.offset - aux->seg_base);
    }
#line 5927
    if (tp->info.section) {
#line 5927
      tmp___0 = (section_headers + tp->info.section)->sh_addr + tp->info.offset;
    } else {
#line 5927
      tmp___0 = tp->info.offset;
    }
    {
#line 5927
    head = (unsigned char const   *)(aux->info + (tmp___0 - aux->info_addr));
#line 5928
    tmp___1 = (*byte_get)((unsigned char *)head, (int )sizeof(stamp));
#line 5928
    stamp = (bfd_vma )tmp___1;
    }
#line 5930
    if ((unsigned long long )stamp & 8589934592ULL) {
#line 5930
      tmp___2 = " uhandler";
    } else {
#line 5930
      tmp___2 = "";
    }
#line 5930
    if ((unsigned long long )stamp & 4294967296ULL) {
#line 5930
      tmp___3 = " ehandler";
    } else {
#line 5930
      tmp___3 = "";
    }
    {
#line 5930
    printf((char const   */* __restrict  */)"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
           (unsigned int )(stamp >> 48), (unsigned long )(((unsigned long long )stamp & 281470681743360ULL) >> 32),
           tmp___3, tmp___2, (unsigned long )((unsigned long long )eh_addr_size * ((unsigned long long )stamp & 4294967295ULL)));
    }
#line 5937
    if (stamp >> 48 != 1UL) {
      {
#line 5939
      tmp___4 = gettext("\tUnknown version.\n");
#line 5939
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 5940
      goto __Cont;
    }
#line 5943
    in_body = 0;
#line 5944
    dp = head + 8;
    {
#line 5944
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5944
      if (! ((unsigned long )dp < (unsigned long )((head + 8) + (unsigned long long )eh_addr_size * ((unsigned long long )stamp & 4294967295ULL)))) {
#line 5944
        goto while_break___0;
      }
      {
#line 5945
      dp = unw_decode(dp, in_body, (void *)(& in_body));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 5899
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5947
  return;
}
}
#line 5949 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int slurp_ia64_unwind_table(FILE *file , struct ia64_unw_aux_info *aux , Elf_Internal_Shdr *sec ) 
{ 
  unsigned long size ;
  unsigned long nrelas ;
  unsigned long i ;
  Elf_Internal_Phdr *seg ;
  struct ia64_unw_table_entry *tep ;
  Elf_Internal_Shdr *relsec ;
  Elf_Internal_Rela *rela ;
  Elf_Internal_Rela *rp ;
  unsigned char *table ;
  unsigned char *tp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  bfd_vma tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 5968
  if (elf_header.e_phnum) {
    {
#line 5970
    tmp___0 = get_program_headers(file);
    }
#line 5970
    if (! tmp___0) {
#line 5971
      return (0);
    }
#line 5973
    seg = program_headers;
    {
#line 5973
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5973
      if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 5973
        goto while_break;
      }
#line 5977
      if (seg->p_type != 1UL) {
#line 5978
        goto __Cont;
      }
#line 5980
      if (sec->sh_addr >= seg->p_vaddr) {
#line 5980
        if (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz) {
#line 5983
          aux->seg_base = seg->p_vaddr;
#line 5984
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 5973
      seg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 5990
  size = sec->sh_size;
#line 5991
  tmp___1 = gettext("unwind table");
#line 5991
  tmp___2 = get_data((void *)0, file, sec->sh_offset, (size_t )1, size, (char const   *)tmp___1);
#line 5991
  table = (unsigned char *)tmp___2;
  }
#line 5993
  if (! table) {
#line 5994
    return (0);
  }
  {
#line 5996
  tmp___3 = xcmalloc(size / (unsigned long )(3 * eh_addr_size), sizeof(*(aux->table + 0)));
#line 5996
  aux->table = (struct ia64_unw_table_entry *)tmp___3;
#line 5998
  tep = aux->table;
#line 5999
  tp = table;
  }
  {
#line 5999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5999
    if (! ((unsigned long )tp < (unsigned long )(table + size))) {
#line 5999
      goto while_break___0;
    }
    {
#line 6001
    tep->start.section = (unsigned short)0;
#line 6002
    tep->end.section = (unsigned short)0;
#line 6003
    tep->info.section = (unsigned short)0;
#line 6004
    tmp___4 = (*byte_get)(tp, eh_addr_size);
#line 6004
    tep->start.offset = (bfd_vma )tmp___4;
#line 6004
    tp += eh_addr_size;
#line 6005
    tmp___5 = (*byte_get)(tp, eh_addr_size);
#line 6005
    tep->end.offset = (bfd_vma )tmp___5;
#line 6005
    tp += eh_addr_size;
#line 6006
    tmp___6 = (*byte_get)(tp, eh_addr_size);
#line 6006
    tep->info.offset = (bfd_vma )tmp___6;
#line 6006
    tp += eh_addr_size;
#line 6007
    tep->start.offset += aux->seg_base;
#line 6008
    tep->end.offset += aux->seg_base;
#line 6009
    tep->info.offset += aux->seg_base;
#line 5999
    tep ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6011
  free((void *)table);
#line 6014
  relsec = section_headers;
  }
  {
#line 6014
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6014
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 6014
      goto while_break___1;
    }
#line 6018
    if (relsec->sh_type != 4U) {
#line 6021
      goto __Cont___0;
    } else
#line 6018
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 6021
      goto __Cont___0;
    } else
#line 6018
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 6021
      goto __Cont___0;
    }
    {
#line 6023
    tmp___7 = slurp_rela_relocs(file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                & rela, & nrelas);
    }
#line 6023
    if (! tmp___7) {
#line 6025
      return (0);
    }
#line 6027
    rp = rela;
    {
#line 6027
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6027
      if (! ((unsigned long )rp < (unsigned long )(rela + nrelas))) {
#line 6027
        goto while_break___2;
      }
      {
#line 6029
      tmp___8 = get_reloc_type(rp->r_info);
#line 6029
      relname = elf_ia64_reloc_type((unsigned long )tmp___8);
#line 6030
      tmp___9 = get_reloc_symindex(rp->r_info);
#line 6030
      sym = aux->symtab + tmp___9;
#line 6032
      tmp___11 = strncmp(relname, "R_IA64_SEGREL", sizeof("R_IA64_SEGREL") - 1UL);
      }
#line 6032
      if (! (tmp___11 == 0)) {
        {
#line 6034
        tmp___10 = gettext("Skipping unexpected relocation type %s\n");
#line 6034
        warn((char const   *)tmp___10, relname);
        }
#line 6035
        goto __Cont___1;
      }
#line 6038
      i = rp->r_offset / (bfd_vma )(3 * eh_addr_size);
      {
#line 6042
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 0UL) {
#line 6042
        goto case_0;
      }
#line 6046
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 1UL) {
#line 6046
        goto case_1;
      }
#line 6050
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 2UL) {
#line 6050
        goto case_2;
      }
#line 6054
      goto switch_default;
      case_0: /* CIL Label */ 
#line 6043
      (aux->table + i)->start.section = (unsigned short )sym->st_shndx;
#line 6044
      (aux->table + i)->start.offset = rp->r_addend + sym->st_value;
#line 6045
      goto switch_break;
      case_1: /* CIL Label */ 
#line 6047
      (aux->table + i)->end.section = (unsigned short )sym->st_shndx;
#line 6048
      (aux->table + i)->end.offset = rp->r_addend + sym->st_value;
#line 6049
      goto switch_break;
      case_2: /* CIL Label */ 
#line 6051
      (aux->table + i)->info.section = (unsigned short )sym->st_shndx;
#line 6052
      (aux->table + i)->info.offset = rp->r_addend + sym->st_value;
#line 6053
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 6055
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 6027
      rp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6059
    free((void *)rela);
    }
    __Cont___0: /* CIL Label */ 
#line 6014
    relsec ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6062
  aux->table_len = size / (unsigned long )(3 * eh_addr_size);
#line 6063
  return (1);
}
}
#line 6066 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void ia64_process_unwind(FILE *file ) 
{ 
  Elf_Internal_Shdr *sec ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  unsigned long i ;
  unsigned long unwcount ;
  unsigned long unwstart ;
  struct ia64_unw_aux_info aux ;
  Elf_Internal_Sym *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *suffix ;
  size_t len ;
  size_t len2 ;
  struct group_list *g ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  void *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  unsigned long tmp___85 ;

  {
  {
#line 6070
  unwsec = (Elf_Internal_Shdr *)((void *)0);
#line 6072
  unwcount = 0UL;
#line 6072
  unwstart = 0UL;
#line 6075
  memset((void *)(& aux), 0, sizeof(aux));
#line 6077
  i = 0UL;
#line 6077
  sec = section_headers;
  }
  {
#line 6077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6077
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6077
      goto while_break;
    }
#line 6079
    if (sec->sh_type == 2U) {
#line 6079
      if (sec->sh_link < elf_header.e_shnum) {
#line 6082
        if (is_32bit_elf) {
          {
#line 6082
          tmp___0 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 6082
          aux.symtab = tmp___0;
          }
        } else {
          {
#line 6082
          tmp___1 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 6082
          aux.symtab = tmp___1;
          }
        }
#line 6084
        strsec = section_headers + sec->sh_link;
#line 6085
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 6085
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                        6085U, "ia64_process_unwind");
          }
        }
        {
#line 6086
        tmp___2 = gettext("string table");
#line 6086
        tmp___3 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___2);
#line 6086
        aux.strtab = (char *)tmp___3;
        }
#line 6089
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 6089
          aux.strtab_size = strsec->sh_size;
        } else {
#line 6089
          aux.strtab_size = 0UL;
        }
      } else {
#line 6079
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 6091
    if (sec->sh_type == 1879048193U) {
#line 6092
      unwcount ++;
    }
#line 6077
    i ++;
#line 6077
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6095
  if (! unwcount) {
    {
#line 6096
    tmp___4 = gettext("\nThere are no unwind sections in this file.\n");
#line 6096
    printf((char const   */* __restrict  */)tmp___4);
    }
  }
  {
#line 6098
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6098
    tmp___85 = unwcount;
#line 6098
    unwcount --;
#line 6098
    if (! (tmp___85 > 0UL)) {
#line 6098
      goto while_break___0;
    }
#line 6103
    i = unwstart;
#line 6103
    sec = section_headers + unwstart;
    {
#line 6103
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6103
      if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6103
        goto while_break___1;
      }
#line 6105
      if (sec->sh_type == 1879048193U) {
#line 6107
        unwsec = sec;
#line 6108
        goto while_break___1;
      }
#line 6103
      i ++;
#line 6103
      sec ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6111
    unwstart = i + 1UL;
#line 6112
    len = sizeof(".gnu.linkonce.ia64unw.") - 1UL;
#line 6114
    if ((unwsec->sh_flags & (unsigned long )(1 << 9)) != 0UL) {
#line 6117
      g = (*(section_headers_groups + i))->root;
      {
#line 6119
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6119
        if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 6119
          goto while_break___2;
        }
#line 6121
        sec = section_headers + g->section_index;
#line 6123
        if ((unsigned long )sec == (unsigned long )((void *)0)) {
          {
#line 6123
          tmp___5 = gettext("<none>");
#line 6123
          tmp___10 = tmp___5;
          }
        } else {
#line 6123
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 6123
            tmp___6 = gettext("<no-name>");
#line 6123
            tmp___9 = tmp___6;
            }
          } else {
#line 6123
            if ((unsigned long )sec->sh_name >= string_table_length) {
              {
#line 6123
              tmp___7 = gettext("<corrupt>");
#line 6123
              tmp___8 = tmp___7;
              }
            } else {
#line 6123
              tmp___8 = string_table + sec->sh_name;
            }
#line 6123
            tmp___9 = tmp___8;
          }
#line 6123
          tmp___10 = tmp___9;
        }
        {
#line 6123
        tmp___11 = strcmp((char const   *)tmp___10, ".IA_64.unwind_info");
        }
#line 6123
        if (tmp___11 == 0) {
#line 6124
          goto while_break___2;
        }
#line 6119
        g = g->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 6127
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 6128
        i = (unsigned long )elf_header.e_shnum;
      }
    } else {
#line 6130
      if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
        {
#line 6130
        tmp___59 = gettext("<none>");
#line 6130
        tmp___64 = tmp___59;
        }
      } else {
#line 6130
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 6130
          tmp___60 = gettext("<no-name>");
#line 6130
          tmp___63 = tmp___60;
          }
        } else {
#line 6130
          if ((unsigned long )unwsec->sh_name >= string_table_length) {
            {
#line 6130
            tmp___61 = gettext("<corrupt>");
#line 6130
            tmp___62 = tmp___61;
            }
          } else {
#line 6130
            tmp___62 = string_table + unwsec->sh_name;
          }
#line 6130
          tmp___63 = tmp___62;
        }
#line 6130
        tmp___64 = tmp___63;
      }
      {
#line 6130
      tmp___65 = strncmp((char const   *)tmp___64, ".gnu.linkonce.ia64unw.", len);
      }
#line 6130
      if (tmp___65 == 0) {
#line 6133
        len2 = sizeof(".gnu.linkonce.ia64unwi.") - 1UL;
#line 6134
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 6134
          tmp___12 = gettext("<none>");
#line 6134
          tmp___17 = tmp___12;
          }
        } else {
#line 6134
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 6134
            tmp___13 = gettext("<no-name>");
#line 6134
            tmp___16 = tmp___13;
            }
          } else {
#line 6134
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 6134
              tmp___14 = gettext("<corrupt>");
#line 6134
              tmp___15 = tmp___14;
              }
            } else {
#line 6134
              tmp___15 = string_table + unwsec->sh_name;
            }
#line 6134
            tmp___16 = tmp___15;
          }
#line 6134
          tmp___17 = tmp___16;
        }
#line 6134
        suffix = tmp___17 + len;
#line 6135
        i = 0UL;
#line 6135
        sec = section_headers;
        {
#line 6135
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 6135
          if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6135
            goto while_break___3;
          }
#line 6137
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 6137
            tmp___18 = gettext("<none>");
#line 6137
            tmp___23 = tmp___18;
            }
          } else {
#line 6137
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 6137
              tmp___19 = gettext("<no-name>");
#line 6137
              tmp___22 = tmp___19;
              }
            } else {
#line 6137
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 6137
                tmp___20 = gettext("<corrupt>");
#line 6137
                tmp___21 = tmp___20;
                }
              } else {
#line 6137
                tmp___21 = string_table + sec->sh_name;
              }
#line 6137
              tmp___22 = tmp___21;
            }
#line 6137
            tmp___23 = tmp___22;
          }
          {
#line 6137
          tmp___24 = strncmp((char const   *)tmp___23, ".gnu.linkonce.ia64unwi.",
                             len2);
          }
#line 6137
          if (tmp___24 == 0) {
#line 6137
            if ((unsigned long )sec == (unsigned long )((void *)0)) {
              {
#line 6137
              tmp___25 = gettext("<none>");
#line 6137
              tmp___30 = tmp___25;
              }
            } else {
#line 6137
              if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                {
#line 6137
                tmp___26 = gettext("<no-name>");
#line 6137
                tmp___29 = tmp___26;
                }
              } else {
#line 6137
                if ((unsigned long )sec->sh_name >= string_table_length) {
                  {
#line 6137
                  tmp___27 = gettext("<corrupt>");
#line 6137
                  tmp___28 = tmp___27;
                  }
                } else {
#line 6137
                  tmp___28 = string_table + sec->sh_name;
                }
#line 6137
                tmp___29 = tmp___28;
              }
#line 6137
              tmp___30 = tmp___29;
            }
            {
#line 6137
            tmp___31 = strcmp((char const   *)(tmp___30 + len2), (char const   *)suffix);
            }
#line 6137
            if (tmp___31 == 0) {
#line 6139
              goto while_break___3;
            }
          }
#line 6135
          i ++;
#line 6135
          sec ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 6145
        len = sizeof(".IA_64.unwind") - 1UL;
#line 6146
        len2 = sizeof(".IA_64.unwind_info") - 1UL;
#line 6147
        suffix = (char *)"";
#line 6148
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 6148
          tmp___38 = gettext("<none>");
#line 6148
          tmp___43 = tmp___38;
          }
        } else {
#line 6148
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 6148
            tmp___39 = gettext("<no-name>");
#line 6148
            tmp___42 = tmp___39;
            }
          } else {
#line 6148
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 6148
              tmp___40 = gettext("<corrupt>");
#line 6148
              tmp___41 = tmp___40;
              }
            } else {
#line 6148
              tmp___41 = string_table + unwsec->sh_name;
            }
#line 6148
            tmp___42 = tmp___41;
          }
#line 6148
          tmp___43 = tmp___42;
        }
        {
#line 6148
        tmp___44 = strncmp((char const   *)tmp___43, ".IA_64.unwind", len);
        }
#line 6148
        if (tmp___44 == 0) {
#line 6149
          if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
            {
#line 6149
            tmp___32 = gettext("<none>");
#line 6149
            tmp___37 = tmp___32;
            }
          } else {
#line 6149
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 6149
              tmp___33 = gettext("<no-name>");
#line 6149
              tmp___36 = tmp___33;
              }
            } else {
#line 6149
              if ((unsigned long )unwsec->sh_name >= string_table_length) {
                {
#line 6149
                tmp___34 = gettext("<corrupt>");
#line 6149
                tmp___35 = tmp___34;
                }
              } else {
#line 6149
                tmp___35 = string_table + unwsec->sh_name;
              }
#line 6149
              tmp___36 = tmp___35;
            }
#line 6149
            tmp___37 = tmp___36;
          }
#line 6149
          suffix = tmp___37 + len;
        }
#line 6150
        i = 0UL;
#line 6150
        sec = section_headers;
        {
#line 6150
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 6150
          if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6150
            goto while_break___4;
          }
#line 6152
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 6152
            tmp___45 = gettext("<none>");
#line 6152
            tmp___50 = tmp___45;
            }
          } else {
#line 6152
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 6152
              tmp___46 = gettext("<no-name>");
#line 6152
              tmp___49 = tmp___46;
              }
            } else {
#line 6152
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 6152
                tmp___47 = gettext("<corrupt>");
#line 6152
                tmp___48 = tmp___47;
                }
              } else {
#line 6152
                tmp___48 = string_table + sec->sh_name;
              }
#line 6152
              tmp___49 = tmp___48;
            }
#line 6152
            tmp___50 = tmp___49;
          }
          {
#line 6152
          tmp___51 = strncmp((char const   *)tmp___50, ".IA_64.unwind_info", len2);
          }
#line 6152
          if (tmp___51 == 0) {
#line 6152
            if ((unsigned long )sec == (unsigned long )((void *)0)) {
              {
#line 6152
              tmp___52 = gettext("<none>");
#line 6152
              tmp___57 = tmp___52;
              }
            } else {
#line 6152
              if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                {
#line 6152
                tmp___53 = gettext("<no-name>");
#line 6152
                tmp___56 = tmp___53;
                }
              } else {
#line 6152
                if ((unsigned long )sec->sh_name >= string_table_length) {
                  {
#line 6152
                  tmp___54 = gettext("<corrupt>");
#line 6152
                  tmp___55 = tmp___54;
                  }
                } else {
#line 6152
                  tmp___55 = string_table + sec->sh_name;
                }
#line 6152
                tmp___56 = tmp___55;
              }
#line 6152
              tmp___57 = tmp___56;
            }
            {
#line 6152
            tmp___58 = strcmp((char const   *)(tmp___57 + len2), (char const   *)suffix);
            }
#line 6152
            if (tmp___58 == 0) {
#line 6154
              goto while_break___4;
            }
          }
#line 6150
          i ++;
#line 6150
          sec ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 6157
    if (i == (unsigned long )elf_header.e_shnum) {
      {
#line 6159
      tmp___66 = gettext("\nCould not find unwind info section for ");
#line 6159
      printf((char const   */* __restrict  */)tmp___66);
      }
#line 6161
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 6162
        printf((char const   */* __restrict  */)"%d", unwsec->sh_name);
        }
      } else {
#line 6164
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 6164
          tmp___67 = gettext("<none>");
#line 6164
          tmp___72 = tmp___67;
          }
        } else {
#line 6164
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 6164
            tmp___68 = gettext("<no-name>");
#line 6164
            tmp___71 = tmp___68;
            }
          } else {
#line 6164
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 6164
              tmp___69 = gettext("<corrupt>");
#line 6164
              tmp___70 = tmp___69;
              }
            } else {
#line 6164
              tmp___70 = string_table + unwsec->sh_name;
            }
#line 6164
            tmp___71 = tmp___70;
          }
#line 6164
          tmp___72 = tmp___71;
        }
        {
#line 6164
        tmp___73 = gettext("\'%s\'");
#line 6164
        printf((char const   */* __restrict  */)tmp___73, tmp___72);
        }
      }
    } else {
      {
#line 6168
      aux.info_addr = sec->sh_addr;
#line 6169
      tmp___74 = gettext("unwind info");
#line 6169
      tmp___75 = get_data((void *)0, file, sec->sh_offset, (size_t )1, sec->sh_size,
                          (char const   *)tmp___74);
#line 6169
      aux.info = (unsigned char *)tmp___75;
      }
#line 6172
      if ((unsigned long )aux.info == (unsigned long )((void *)0)) {
#line 6172
        aux.info_size = 0UL;
      } else {
#line 6172
        aux.info_size = sec->sh_size;
      }
      {
#line 6174
      tmp___76 = gettext("\nUnwind section ");
#line 6174
      printf((char const   */* __restrict  */)tmp___76);
      }
#line 6176
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 6177
        printf((char const   */* __restrict  */)"%d", unwsec->sh_name);
        }
      } else {
#line 6179
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 6179
          tmp___77 = gettext("<none>");
#line 6179
          tmp___82 = tmp___77;
          }
        } else {
#line 6179
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 6179
            tmp___78 = gettext("<no-name>");
#line 6179
            tmp___81 = tmp___78;
            }
          } else {
#line 6179
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 6179
              tmp___79 = gettext("<corrupt>");
#line 6179
              tmp___80 = tmp___79;
              }
            } else {
#line 6179
              tmp___80 = string_table + unwsec->sh_name;
            }
#line 6179
            tmp___81 = tmp___80;
          }
#line 6179
          tmp___82 = tmp___81;
        }
        {
#line 6179
        tmp___83 = gettext("\'%s\'");
#line 6179
        printf((char const   */* __restrict  */)tmp___83, tmp___82);
        }
      }
      {
#line 6181
      tmp___84 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 6181
      printf((char const   */* __restrict  */)tmp___84, (unsigned long )unwsec->sh_offset,
             unwsec->sh_size / (bfd_size_type )(3 * eh_addr_size));
#line 6185
      slurp_ia64_unwind_table(file, & aux, unwsec);
      }
#line 6187
      if (aux.table_len > 0UL) {
        {
#line 6188
        dump_ia64_unwind(& aux);
        }
      }
#line 6190
      if (aux.table) {
        {
#line 6191
        free((void *)((char *)aux.table));
        }
      }
#line 6192
      if (aux.info) {
        {
#line 6193
        free((void *)((char *)aux.info));
        }
      }
#line 6194
      aux.table = (struct ia64_unw_table_entry *)((void *)0);
#line 6195
      aux.info = (unsigned char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6199
  if (aux.symtab) {
    {
#line 6200
    free((void *)aux.symtab);
    }
  }
#line 6201
  if (aux.strtab) {
    {
#line 6202
    free((void *)aux.strtab);
    }
  }
#line 6203
  return;
}
}
#line 6253 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_hppa_unwind(struct hppa_unw_aux_info *aux ) 
{ 
  struct hppa_unw_table_entry *tp ;
  bfd_vma offset ;
  char const   *procname ;

  {
#line 6258
  tp = aux->table;
  {
#line 6258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6258
    if (! ((unsigned long )tp < (unsigned long )(aux->table + aux->table_len))) {
#line 6258
      goto while_break;
    }
    {
#line 6263
    find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab,
                            aux->strtab_size, tp->start, & procname, & offset);
#line 6267
    fputs((char const   */* __restrict  */)"\n<", (FILE */* __restrict  */)stdout);
    }
#line 6269
    if (procname) {
      {
#line 6271
      fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
      }
#line 6273
      if (offset) {
        {
#line 6274
        printf((char const   */* __restrict  */)"+%lx", offset);
        }
      }
    }
    {
#line 6277
    fputs((char const   */* __restrict  */)">: [", (FILE */* __restrict  */)stdout);
#line 6278
    print_vma(tp->start.offset, (print_mode )4);
#line 6279
    fputc('-', stdout);
#line 6280
    print_vma(tp->end.offset, (print_mode )4);
#line 6281
    printf((char const   */* __restrict  */)"]\n\t");
    }
#line 6285
    if (tp->Cannot_unwind) {
      {
#line 6285
      printf((char const   */* __restrict  */)"Cannot_unwind ");
      }
    }
#line 6286
    if (tp->Millicode) {
      {
#line 6286
      printf((char const   */* __restrict  */)"Millicode ");
      }
    }
#line 6287
    if (tp->Millicode_save_sr0) {
      {
#line 6287
      printf((char const   */* __restrict  */)"Millicode_save_sr0 ");
      }
    }
#line 6289
    if (tp->Entry_SR) {
      {
#line 6289
      printf((char const   */* __restrict  */)"Entry_SR ");
      }
    }
#line 6290
    if (tp->Entry_FR) {
      {
#line 6290
      printf((char const   */* __restrict  */)"Entry_FR=%d ", tp->Entry_FR);
      }
    }
#line 6291
    if (tp->Entry_GR) {
      {
#line 6291
      printf((char const   */* __restrict  */)"Entry_GR=%d ", tp->Entry_GR);
      }
    }
#line 6292
    if (tp->Args_stored) {
      {
#line 6292
      printf((char const   */* __restrict  */)"Args_stored ");
      }
    }
#line 6293
    if (tp->Variable_Frame) {
      {
#line 6293
      printf((char const   */* __restrict  */)"Variable_Frame ");
      }
    }
#line 6294
    if (tp->Separate_Package_Body) {
      {
#line 6294
      printf((char const   */* __restrict  */)"Separate_Package_Body ");
      }
    }
#line 6295
    if (tp->Frame_Extension_Millicode) {
      {
#line 6295
      printf((char const   */* __restrict  */)"Frame_Extension_Millicode ");
      }
    }
#line 6296
    if (tp->Stack_Overflow_Check) {
      {
#line 6296
      printf((char const   */* __restrict  */)"Stack_Overflow_Check ");
      }
    }
#line 6297
    if (tp->Two_Instruction_SP_Increment) {
      {
#line 6297
      printf((char const   */* __restrict  */)"Two_Instruction_SP_Increment ");
      }
    }
#line 6298
    if (tp->Ada_Region) {
      {
#line 6298
      printf((char const   */* __restrict  */)"Ada_Region ");
      }
    }
#line 6299
    if (tp->cxx_info) {
      {
#line 6299
      printf((char const   */* __restrict  */)"cxx_info ");
      }
    }
#line 6300
    if (tp->cxx_try_catch) {
      {
#line 6300
      printf((char const   */* __restrict  */)"cxx_try_catch ");
      }
    }
#line 6301
    if (tp->sched_entry_seq) {
      {
#line 6301
      printf((char const   */* __restrict  */)"sched_entry_seq ");
      }
    }
#line 6302
    if (tp->Save_SP) {
      {
#line 6302
      printf((char const   */* __restrict  */)"Save_SP ");
      }
    }
#line 6303
    if (tp->Save_RP) {
      {
#line 6303
      printf((char const   */* __restrict  */)"Save_RP ");
      }
    }
#line 6304
    if (tp->Save_MRP_in_frame) {
      {
#line 6304
      printf((char const   */* __restrict  */)"Save_MRP_in_frame ");
      }
    }
#line 6305
    if (tp->extn_ptr_defined) {
      {
#line 6305
      printf((char const   */* __restrict  */)"extn_ptr_defined ");
      }
    }
#line 6306
    if (tp->Cleanup_defined) {
      {
#line 6306
      printf((char const   */* __restrict  */)"Cleanup_defined ");
      }
    }
#line 6307
    if (tp->MPE_XL_interrupt_marker) {
      {
#line 6307
      printf((char const   */* __restrict  */)"MPE_XL_interrupt_marker ");
      }
    }
#line 6308
    if (tp->HP_UX_interrupt_marker) {
      {
#line 6308
      printf((char const   */* __restrict  */)"HP_UX_interrupt_marker ");
      }
    }
#line 6309
    if (tp->Large_frame) {
      {
#line 6309
      printf((char const   */* __restrict  */)"Large_frame ");
      }
    }
#line 6310
    if (tp->Pseudo_SP_Set) {
      {
#line 6310
      printf((char const   */* __restrict  */)"Pseudo_SP_Set ");
      }
    }
#line 6311
    if (tp->Total_frame_size) {
      {
#line 6311
      printf((char const   */* __restrict  */)"Total_frame_size=%d ", tp->Total_frame_size);
      }
    }
#line 6258
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6316
  printf((char const   */* __restrict  */)"\n");
  }
#line 6317
  return;
}
}
#line 6319 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int slurp_hppa_unwind_table(FILE *file , struct hppa_unw_aux_info *aux , Elf_Internal_Shdr *sec ) 
{ 
  unsigned long size ;
  unsigned long unw_ent_size ;
  unsigned long nentries ;
  unsigned long nrelas ;
  unsigned long i ;
  Elf_Internal_Phdr *seg ;
  struct hppa_unw_table_entry *tep ;
  Elf_Internal_Shdr *relsec ;
  Elf_Internal_Rela *rela ;
  Elf_Internal_Rela *rp ;
  unsigned char *table ;
  unsigned char *tp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  struct hppa_unw_table_entry *tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp1 ;
  unsigned int tmp2 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  bfd_vma tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 6338
  if (elf_header.e_phnum) {
    {
#line 6340
    tmp___0 = get_program_headers(file);
    }
#line 6340
    if (! tmp___0) {
#line 6341
      return (0);
    }
#line 6343
    seg = program_headers;
    {
#line 6343
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6343
      if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 6343
        goto while_break;
      }
#line 6347
      if (seg->p_type != 1UL) {
#line 6348
        goto __Cont;
      }
#line 6350
      if (sec->sh_addr >= seg->p_vaddr) {
#line 6350
        if (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz) {
#line 6353
          aux->seg_base = seg->p_vaddr;
#line 6354
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 6343
      seg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 6361
  size = sec->sh_size;
#line 6362
  tmp___1 = gettext("unwind table");
#line 6362
  tmp___2 = get_data((void *)0, file, sec->sh_offset, (size_t )1, size, (char const   *)tmp___1);
#line 6362
  table = (unsigned char *)tmp___2;
  }
#line 6364
  if (! table) {
#line 6365
    return (0);
  }
  {
#line 6367
  unw_ent_size = 16UL;
#line 6368
  nentries = size / unw_ent_size;
#line 6369
  size = unw_ent_size * nentries;
#line 6371
  tmp___4 = xcmalloc(nentries, sizeof(*(aux->table + 0)));
#line 6371
  tmp___3 = (struct hppa_unw_table_entry *)tmp___4;
#line 6371
  aux->table = tmp___3;
#line 6371
  tep = tmp___3;
#line 6374
  tp = table;
  }
  {
#line 6374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6374
    if (! ((unsigned long )tp < (unsigned long )(table + size))) {
#line 6374
      goto while_break___0;
    }
    {
#line 6378
    tep->start.section = (unsigned short)0;
#line 6379
    tep->end.section = (unsigned short)0;
#line 6381
    tmp___5 = (*byte_get)(tp + 0, 4);
#line 6381
    tep->start.offset = (bfd_vma )tmp___5;
#line 6382
    tmp___6 = (*byte_get)(tp + 4, 4);
#line 6382
    tep->end.offset = (bfd_vma )tmp___6;
#line 6383
    tmp___7 = (*byte_get)(tp + 8, 4);
#line 6383
    tmp1 = (unsigned int )tmp___7;
#line 6384
    tmp___8 = (*byte_get)(tp + 12, 4);
#line 6384
    tmp2 = (unsigned int )tmp___8;
#line 6386
    tep->start.offset += aux->seg_base;
#line 6387
    tep->end.offset += aux->seg_base;
#line 6389
    tep->Cannot_unwind = (tmp1 >> 31) & 1U;
#line 6390
    tep->Millicode = (tmp1 >> 30) & 1U;
#line 6391
    tep->Millicode_save_sr0 = (tmp1 >> 29) & 1U;
#line 6392
    tep->Region_description = (tmp1 >> 27) & 3U;
#line 6393
    tep->reserved1 = (tmp1 >> 26) & 1U;
#line 6394
    tep->Entry_SR = (tmp1 >> 25) & 1U;
#line 6395
    tep->Entry_FR = (tmp1 >> 21) & 15U;
#line 6396
    tep->Entry_GR = (tmp1 >> 16) & 31U;
#line 6397
    tep->Args_stored = (tmp1 >> 15) & 1U;
#line 6398
    tep->Variable_Frame = (tmp1 >> 14) & 1U;
#line 6399
    tep->Separate_Package_Body = (tmp1 >> 13) & 1U;
#line 6400
    tep->Frame_Extension_Millicode = (tmp1 >> 12) & 1U;
#line 6401
    tep->Stack_Overflow_Check = (tmp1 >> 11) & 1U;
#line 6402
    tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 1U;
#line 6403
    tep->Ada_Region = (tmp1 >> 9) & 1U;
#line 6404
    tep->cxx_info = (tmp1 >> 8) & 1U;
#line 6405
    tep->cxx_try_catch = (tmp1 >> 7) & 1U;
#line 6406
    tep->sched_entry_seq = (tmp1 >> 6) & 1U;
#line 6407
    tep->reserved2 = (tmp1 >> 5) & 1U;
#line 6408
    tep->Save_SP = (tmp1 >> 4) & 1U;
#line 6409
    tep->Save_RP = (tmp1 >> 3) & 1U;
#line 6410
    tep->Save_MRP_in_frame = (tmp1 >> 2) & 1U;
#line 6411
    tep->extn_ptr_defined = (tmp1 >> 1) & 1U;
#line 6412
    tep->Cleanup_defined = tmp1 & 1U;
#line 6414
    tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 1U;
#line 6415
    tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 1U;
#line 6416
    tep->Large_frame = (tmp2 >> 29) & 1U;
#line 6417
    tep->Pseudo_SP_Set = (tmp2 >> 28) & 1U;
#line 6418
    tep->reserved4 = (tmp2 >> 27) & 1U;
#line 6419
    tep->Total_frame_size = tmp2 & 134217727U;
#line 6374
    tp += unw_ent_size;
#line 6374
    tep ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6421
  free((void *)table);
#line 6424
  relsec = section_headers;
  }
  {
#line 6424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6424
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 6424
      goto while_break___1;
    }
#line 6428
    if (relsec->sh_type != 4U) {
#line 6431
      goto __Cont___0;
    } else
#line 6428
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 6431
      goto __Cont___0;
    } else
#line 6428
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 6431
      goto __Cont___0;
    }
    {
#line 6433
    tmp___9 = slurp_rela_relocs(file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                & rela, & nrelas);
    }
#line 6433
    if (! tmp___9) {
#line 6435
      return (0);
    }
#line 6437
    rp = rela;
    {
#line 6437
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6437
      if (! ((unsigned long )rp < (unsigned long )(rela + nrelas))) {
#line 6437
        goto while_break___2;
      }
      {
#line 6439
      tmp___10 = get_reloc_type(rp->r_info);
#line 6439
      relname = elf_hppa_reloc_type((unsigned long )tmp___10);
#line 6440
      tmp___11 = get_reloc_symindex(rp->r_info);
#line 6440
      sym = aux->symtab + tmp___11;
#line 6443
      tmp___13 = strncmp(relname, "R_PARISC_SEGREL", sizeof("R_PARISC_SEGREL") - 1UL);
      }
#line 6443
      if (! (tmp___13 == 0)) {
        {
#line 6445
        tmp___12 = gettext("Skipping unexpected relocation type %s\n");
#line 6445
        warn((char const   *)tmp___12, relname);
        }
#line 6446
        goto __Cont___1;
      }
#line 6449
      i = rp->r_offset / unw_ent_size;
      {
#line 6453
      if ((rp->r_offset % unw_ent_size) / (unsigned long )eh_addr_size == 0UL) {
#line 6453
        goto case_0;
      }
#line 6457
      if ((rp->r_offset % unw_ent_size) / (unsigned long )eh_addr_size == 1UL) {
#line 6457
        goto case_1;
      }
#line 6461
      goto switch_default;
      case_0: /* CIL Label */ 
#line 6454
      (aux->table + i)->start.section = (unsigned short )sym->st_shndx;
#line 6455
      (aux->table + i)->start.offset = sym->st_value + rp->r_addend;
#line 6456
      goto switch_break;
      case_1: /* CIL Label */ 
#line 6458
      (aux->table + i)->end.section = (unsigned short )sym->st_shndx;
#line 6459
      (aux->table + i)->end.offset = sym->st_value + rp->r_addend;
#line 6460
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 6462
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 6437
      rp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6466
    free((void *)rela);
    }
    __Cont___0: /* CIL Label */ 
#line 6424
    relsec ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6469
  aux->table_len = nentries;
#line 6471
  return (1);
}
}
#line 6474 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void hppa_process_unwind(FILE *file ) 
{ 
  struct hppa_unw_aux_info aux ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  Elf_Internal_Shdr *sec ;
  unsigned long i ;
  Elf_Internal_Sym *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;

  {
#line 6478
  unwsec = (Elf_Internal_Shdr *)((void *)0);
#line 6483
  if ((unsigned long )string_table == (unsigned long )((void *)0)) {
#line 6484
    return;
  }
  {
#line 6486
  memset((void *)(& aux), 0, sizeof(aux));
#line 6488
  i = 0UL;
#line 6488
  sec = section_headers;
  }
  {
#line 6488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6488
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6488
      goto while_break;
    }
#line 6490
    if (sec->sh_type == 2U) {
#line 6490
      if (sec->sh_link < elf_header.e_shnum) {
#line 6493
        if (is_32bit_elf) {
          {
#line 6493
          tmp___0 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 6493
          aux.symtab = tmp___0;
          }
        } else {
          {
#line 6493
          tmp___1 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 6493
          aux.symtab = tmp___1;
          }
        }
#line 6495
        strsec = section_headers + sec->sh_link;
#line 6496
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 6496
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                        6496U, "hppa_process_unwind");
          }
        }
        {
#line 6497
        tmp___2 = gettext("string table");
#line 6497
        tmp___3 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___2);
#line 6497
        aux.strtab = (char *)tmp___3;
        }
#line 6500
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 6500
          aux.strtab_size = strsec->sh_size;
        } else {
#line 6500
          aux.strtab_size = 0UL;
        }
      } else {
#line 6490
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 6502
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
        {
#line 6502
        tmp___4 = gettext("<none>");
#line 6502
        tmp___9 = tmp___4;
        }
      } else {
#line 6502
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 6502
          tmp___5 = gettext("<no-name>");
#line 6502
          tmp___8 = tmp___5;
          }
        } else {
#line 6502
          if ((unsigned long )sec->sh_name >= string_table_length) {
            {
#line 6502
            tmp___6 = gettext("<corrupt>");
#line 6502
            tmp___7 = tmp___6;
            }
          } else {
#line 6502
            tmp___7 = string_table + sec->sh_name;
          }
#line 6502
          tmp___8 = tmp___7;
        }
#line 6502
        tmp___9 = tmp___8;
      }
      {
#line 6502
      tmp___10 = strcmp((char const   *)tmp___9, ".PARISC.unwind");
      }
#line 6502
      if (tmp___10 == 0) {
#line 6503
        unwsec = sec;
      }
    }
#line 6488
    i ++;
#line 6488
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6506
  if (! unwsec) {
    {
#line 6507
    tmp___11 = gettext("\nThere are no unwind sections in this file.\n");
#line 6507
    printf((char const   */* __restrict  */)tmp___11);
    }
  }
#line 6509
  i = 0UL;
#line 6509
  sec = section_headers;
  {
#line 6509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6509
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6509
      goto while_break___0;
    }
#line 6511
    if ((unsigned long )sec == (unsigned long )((void *)0)) {
      {
#line 6511
      tmp___21 = gettext("<none>");
#line 6511
      tmp___26 = tmp___21;
      }
    } else {
#line 6511
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 6511
        tmp___22 = gettext("<no-name>");
#line 6511
        tmp___25 = tmp___22;
        }
      } else {
#line 6511
        if ((unsigned long )sec->sh_name >= string_table_length) {
          {
#line 6511
          tmp___23 = gettext("<corrupt>");
#line 6511
          tmp___24 = tmp___23;
          }
        } else {
#line 6511
          tmp___24 = string_table + sec->sh_name;
        }
#line 6511
        tmp___25 = tmp___24;
      }
#line 6511
      tmp___26 = tmp___25;
    }
    {
#line 6511
    tmp___27 = strcmp((char const   *)tmp___26, ".PARISC.unwind");
    }
#line 6511
    if (tmp___27 == 0) {
      {
#line 6513
      tmp___12 = gettext("\nUnwind section ");
#line 6513
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 6514
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
        {
#line 6514
        tmp___13 = gettext("<none>");
#line 6514
        tmp___18 = tmp___13;
        }
      } else {
#line 6514
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 6514
          tmp___14 = gettext("<no-name>");
#line 6514
          tmp___17 = tmp___14;
          }
        } else {
#line 6514
          if ((unsigned long )sec->sh_name >= string_table_length) {
            {
#line 6514
            tmp___15 = gettext("<corrupt>");
#line 6514
            tmp___16 = tmp___15;
            }
          } else {
#line 6514
            tmp___16 = string_table + sec->sh_name;
          }
#line 6514
          tmp___17 = tmp___16;
        }
#line 6514
        tmp___18 = tmp___17;
      }
      {
#line 6514
      tmp___19 = gettext("\'%s\'");
#line 6514
      printf((char const   */* __restrict  */)tmp___19, tmp___18);
#line 6516
      tmp___20 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 6516
      printf((char const   */* __restrict  */)tmp___20, (unsigned long )sec->sh_offset,
             sec->sh_size / (bfd_size_type )(2 * eh_addr_size + 8));
#line 6520
      slurp_hppa_unwind_table(file, & aux, sec);
      }
#line 6521
      if (aux.table_len > 0UL) {
        {
#line 6522
        dump_hppa_unwind(& aux);
        }
      }
#line 6524
      if (aux.table) {
        {
#line 6525
        free((void *)((char *)aux.table));
        }
      }
#line 6526
      aux.table = (struct hppa_unw_table_entry *)((void *)0);
    }
#line 6509
    i ++;
#line 6509
    sec ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6530
  if (aux.symtab) {
    {
#line 6531
    free((void *)aux.symtab);
    }
  }
#line 6532
  if (aux.strtab) {
    {
#line 6533
    free((void *)aux.strtab);
    }
  }
#line 6534
  return;
}
}
#line 6555 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_print_vma_and_name(struct arm_unw_aux_info *aux , bfd_vma fn ,
                                            struct absaddr addr ) 
{ 
  char const   *procname ;
  bfd_vma sym_offset ;

  {
#line 6562
  if ((int )addr.section == 0) {
#line 6563
    addr.offset = fn;
  }
  {
#line 6565
  find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab, aux->strtab_size,
                          addr, & procname, & sym_offset);
#line 6569
  print_vma(fn, (print_mode )4);
  }
#line 6571
  if (procname) {
    {
#line 6573
    fputs((char const   */* __restrict  */)" <", (FILE */* __restrict  */)stdout);
#line 6574
    fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
    }
#line 6576
    if (sym_offset) {
      {
#line 6577
      printf((char const   */* __restrict  */)"+0x%lx", sym_offset);
      }
    }
    {
#line 6578
    fputc('>', stdout);
    }
  }
#line 6581
  return (procname);
}
}
#line 6584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void arm_free_section(struct arm_section *arm_sec ) 
{ 


  {
#line 6587
  if ((unsigned long )arm_sec->data != (unsigned long )((void *)0)) {
    {
#line 6588
    free((void *)arm_sec->data);
    }
  }
#line 6590
  if ((unsigned long )arm_sec->rela != (unsigned long )((void *)0)) {
    {
#line 6591
    free((void *)arm_sec->rela);
    }
  }
#line 6592
  return;
}
}
#line 6605 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean get_unwind_section_word(struct arm_unw_aux_info *aux , struct arm_section *arm_sec ,
                                           Elf_Internal_Shdr *sec , bfd_vma word_offset ,
                                           unsigned int *wordp , struct absaddr *addr ,
                                           bfd_vma *sym_name ) 
{ 
  Elf_Internal_Rela *rp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  unsigned int word ;
  bfd_boolean wrapped ;
  Elf_Internal_Shdr *relsec ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  elf_vma tmp___4 ;
  bfd_vma prelval ;
  bfd_vma offset ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 6620
  addr->section = (unsigned short)0;
#line 6621
  addr->offset = (bfd_vma )0;
#line 6623
  if ((unsigned long )sym_name != (unsigned long )((void *)0)) {
#line 6624
    *sym_name = (bfd_vma )-1;
  }
#line 6627
  if ((unsigned long )sec != (unsigned long )arm_sec->sec) {
    {
#line 6631
    arm_free_section(arm_sec);
#line 6633
    arm_sec->sec = sec;
#line 6634
    tmp___0 = gettext("unwind data");
#line 6634
    tmp___1 = get_data((void *)0, aux->file, sec->sh_offset, (size_t )1, sec->sh_size,
                       (char const   *)tmp___0);
#line 6634
    arm_sec->data = (unsigned char *)tmp___1;
#line 6636
    arm_sec->rela = (Elf_Internal_Rela *)((void *)0);
#line 6637
    arm_sec->nrelas = 0UL;
#line 6639
    relsec = section_headers;
    }
    {
#line 6639
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6639
      if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 6639
        goto while_break;
      }
#line 6643
      if (relsec->sh_info >= elf_header.e_shnum) {
#line 6648
        goto __Cont;
      } else
#line 6643
      if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 6648
        goto __Cont;
      } else
#line 6643
      if (relsec->sh_type != 9U) {
#line 6643
        if (relsec->sh_type != 4U) {
#line 6648
          goto __Cont;
        }
      }
#line 6650
      arm_sec->rel_type = relsec->sh_type;
#line 6651
      if (relsec->sh_type == 9U) {
        {
#line 6653
        tmp___2 = slurp_rel_relocs(aux->file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                   & arm_sec->rela, & arm_sec->nrelas);
        }
#line 6653
        if (! tmp___2) {
#line 6656
          return (0);
        }
      } else {
        {
#line 6660
        tmp___3 = slurp_rela_relocs(aux->file, (unsigned long )relsec->sh_offset,
                                    relsec->sh_size, & arm_sec->rela, & arm_sec->nrelas);
        }
#line 6660
        if (! tmp___3) {
#line 6663
          return (0);
        }
      }
#line 6665
      goto while_break;
      __Cont: /* CIL Label */ 
#line 6639
      relsec ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6668
    arm_sec->next_rela = arm_sec->rela;
  }
#line 6672
  if ((unsigned long )arm_sec->data == (unsigned long )((void *)0)) {
#line 6673
    return (0);
  }
  {
#line 6676
  tmp___4 = (*byte_get)(arm_sec->data + word_offset, 4);
#line 6676
  word = (unsigned int )tmp___4;
#line 6679
  wrapped = 0;
#line 6680
  rp = arm_sec->next_rela;
  }
  {
#line 6680
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6680
    if (! ((unsigned long )rp != (unsigned long )(arm_sec->rela + arm_sec->nrelas))) {
#line 6680
      goto while_break___0;
    }
#line 6684
    if (rp->r_offset > word_offset) {
#line 6684
      if (! wrapped) {
#line 6686
        rp = arm_sec->rela;
#line 6687
        wrapped = 1;
      }
    }
#line 6689
    if (rp->r_offset > word_offset) {
#line 6690
      goto while_break___0;
    }
#line 6692
    if (rp->r_offset & 3UL) {
      {
#line 6694
      tmp___5 = gettext("Skipping unexpected relocation at offset 0x%lx\n");
#line 6694
      warn((char const   *)tmp___5, rp->r_offset);
      }
#line 6696
      goto __Cont___0;
    }
#line 6699
    if (rp->r_offset < word_offset) {
#line 6700
      goto __Cont___0;
    }
#line 6702
    sym = aux->symtab + (rp->r_info >> 8);
#line 6704
    if (arm_sec->rel_type == 9U) {
#line 6706
      offset = (bfd_vma )(word & 2147483647U);
#line 6707
      if (offset & 1073741824UL) {
#line 6708
        offset |= 0xffffffff80000000UL;
      }
    } else
#line 6710
    if (arm_sec->rel_type == 4U) {
#line 6711
      offset = rp->r_addend;
    } else {
      {
#line 6713
      abort();
      }
    }
#line 6715
    offset += sym->st_value;
#line 6716
    prelval = offset - ((arm_sec->sec)->sh_addr + rp->r_offset);
#line 6719
    if ((int )elf_header.e_machine == 40) {
      {
#line 6721
      relname = elf_arm_reloc_type(rp->r_info & 255UL);
#line 6723
      tmp___6 = strcmp(relname, "R_ARM_NONE");
      }
#line 6723
      if (tmp___6 == 0) {
#line 6724
        goto __Cont___0;
      }
      {
#line 6726
      tmp___8 = strcmp(relname, "R_ARM_PREL31");
      }
#line 6726
      if (! (tmp___8 == 0)) {
        {
#line 6728
        tmp___7 = gettext("Skipping unexpected relocation type %s\n");
#line 6728
        warn((char const   *)tmp___7, relname);
        }
#line 6729
        goto __Cont___0;
      }
    } else
#line 6732
    if ((int )elf_header.e_machine == 140) {
      {
#line 6734
      relname = elf_tic6x_reloc_type(rp->r_info & 255UL);
#line 6736
      tmp___9 = strcmp(relname, "R_C6000_NONE");
      }
#line 6736
      if (tmp___9 == 0) {
#line 6737
        goto __Cont___0;
      }
      {
#line 6739
      tmp___11 = strcmp(relname, "R_C6000_PREL31");
      }
#line 6739
      if (! (tmp___11 == 0)) {
        {
#line 6741
        tmp___10 = gettext("Skipping unexpected relocation type %s\n");
#line 6741
        warn((char const   *)tmp___10, relname);
        }
#line 6742
        goto __Cont___0;
      }
#line 6745
      prelval >>= 1;
    } else {
      {
#line 6749
      abort();
      }
    }
#line 6751
    word = (unsigned int )(((unsigned long )word & 0xffffffff80000000UL) | (prelval & 2147483647UL));
#line 6752
    addr->section = (unsigned short )sym->st_shndx;
#line 6753
    addr->offset = offset;
#line 6754
    if (sym_name) {
#line 6755
      *sym_name = sym->st_name;
    }
#line 6756
    goto while_break___0;
    __Cont___0: /* CIL Label */ 
#line 6680
    rp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6759
  *wordp = word;
#line 6760
  arm_sec->next_rela = rp;
#line 6762
  return (1);
}
}
#line 6765 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *tic6x_unwind_regnames[16]  = 
#line 6765
  {      "A15",      "B15",      "B14",      "B13", 
        "B12",      "B11",      "B10",      "B3", 
        "A14",      "A13",      "A12",      "A11", 
        "A10",      "[invalid reg 13]",      "[invalid reg 14]",      "[invalid reg 15]"};
#line 6772 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void decode_tic6x_unwind_regmask(unsigned int mask ) 
{ 
  int i ;

  {
#line 6777
  i = 12;
  {
#line 6777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6777
    if (! mask) {
#line 6777
      goto while_break;
    }
#line 6779
    if (mask & 1U) {
      {
#line 6781
      fputs((char const   */* __restrict  */)tic6x_unwind_regnames[i], (FILE */* __restrict  */)stdout);
      }
#line 6782
      if (mask > 1U) {
        {
#line 6783
        fputs((char const   */* __restrict  */)", ", (FILE */* __restrict  */)stdout);
        }
      }
    }
#line 6777
    mask >>= 1;
#line 6777
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 6786
  return;
}
}
#line 6814 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void decode_arm_unwind_bytecode(struct arm_unw_aux_info *aux , unsigned int word ,
                                       unsigned int remaining , unsigned int more_words ,
                                       bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                                       struct arm_section *data_arm_sec ) 
{ 
  struct absaddr addr ;
  unsigned int op ;
  unsigned int op2 ;
  bfd_boolean tmp___0 ;
  int offset ;
  int offset___0 ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int mask ;
  int first ;
  int i ;
  char *tmp___4 ;
  int end ;
  int first___0 ;
  int i___0 ;
  char *tmp___5 ;
  bfd_boolean tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned int mask___0 ;
  int first___1 ;
  int i___1 ;
  unsigned char buf___7[9] ;
  unsigned int i___2 ;
  unsigned int len ;
  unsigned long offset___1 ;
  bfd_boolean tmp___9 ;
  char *tmp___10 ;
  unsigned int first___2 ;
  unsigned int last ;
  bfd_boolean tmp___12 ;
  char *tmp___13 ;
  unsigned int count ;
  unsigned int count___0 ;
  unsigned int first___3 ;
  unsigned int last___0 ;
  bfd_boolean tmp___14 ;
  char *tmp___15 ;
  bfd_boolean tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  unsigned int mask___1 ;
  int first___4 ;
  int i___3 ;
  char *tmp___19 ;

  {
  {
#line 6824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6828
    if (remaining == 0U) {
#line 6828
      if (more_words) {
        {
#line 6828
        data_offset += 4UL;
#line 6828
        tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                          & word, & addr, (bfd_vma *)((void *)0));
        }
#line 6828
        if (! tmp___0) {
#line 6828
          return;
        }
#line 6828
        remaining = 4U;
#line 6828
        more_words --;
      }
    }
#line 6829
    if (remaining == 0U) {
#line 6830
      goto while_break;
    }
    {
#line 6831
    remaining --;
#line 6832
    op = word >> 24;
#line 6833
    word <<= 8;
#line 6835
    printf((char const   */* __restrict  */)"  0x%02x ", op);
    }
#line 6837
    if ((op & 192U) == 0U) {
      {
#line 6839
      offset = (int )(((op & 63U) << 2) + 4U);
#line 6841
      printf((char const   */* __restrict  */)"     vsp = vsp + %d", offset);
      }
    } else
#line 6843
    if ((op & 192U) == 64U) {
      {
#line 6845
      offset___0 = (int )(((op & 63U) << 2) + 4U);
#line 6847
      printf((char const   */* __restrict  */)"     vsp = vsp - %d", offset___0);
      }
    } else
#line 6849
    if ((op & 240U) == 128U) {
#line 6851
      if (remaining == 0U) {
#line 6851
        if (more_words) {
          {
#line 6851
          data_offset += 4UL;
#line 6851
          tmp___1 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6851
          if (! tmp___1) {
#line 6851
            return;
          }
#line 6851
          remaining = 4U;
#line 6851
          more_words --;
        }
      }
#line 6851
      if (remaining) {
#line 6851
        remaining --;
#line 6851
        op2 = word >> 24;
#line 6851
        word <<= 8;
      } else {
        {
#line 6851
        tmp___2 = gettext("[Truncated opcode]\n");
#line 6851
        printf((char const   */* __restrict  */)tmp___2);
        }
#line 6851
        return;
      }
      {
#line 6851
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6852
      if (op == 128U) {
#line 6852
        if (op2 == 0U) {
          {
#line 6853
          tmp___3 = gettext("Refuse to unwind");
#line 6853
          printf((char const   */* __restrict  */)tmp___3);
          }
        } else {
#line 6852
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 6856
        mask = ((op & 15U) << 8) | op2;
#line 6857
        first = 1;
#line 6860
        printf((char const   */* __restrict  */)"pop {");
#line 6861
        i = 0;
        }
        {
#line 6861
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6861
          if (! (i < 12)) {
#line 6861
            goto while_break___0;
          }
#line 6862
          if (mask & (unsigned int )(1 << i)) {
#line 6864
            if (first) {
#line 6865
              first = 0;
            } else {
              {
#line 6867
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 6868
            printf((char const   */* __restrict  */)"r%d", 4 + i);
            }
          }
#line 6861
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 6870
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 6873
    if ((op & 240U) == 144U) {
#line 6875
      if (op == 157U) {
        {
#line 6876
        tmp___4 = gettext("     [Reserved]");
#line 6876
        printf((char const   */* __restrict  */)tmp___4);
        }
      } else
#line 6875
      if (op == 159U) {
        {
#line 6876
        tmp___4 = gettext("     [Reserved]");
#line 6876
        printf((char const   */* __restrict  */)tmp___4);
        }
      } else {
        {
#line 6878
        printf((char const   */* __restrict  */)"     vsp = r%d", op & 15U);
        }
      }
    } else
#line 6880
    if ((op & 240U) == 160U) {
      {
#line 6882
      end = (int )(4U + (op & 7U));
#line 6883
      first___0 = 1;
#line 6886
      printf((char const   */* __restrict  */)"     pop {");
#line 6887
      i___0 = 4;
      }
      {
#line 6887
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6887
        if (! (i___0 <= end)) {
#line 6887
          goto while_break___1;
        }
#line 6889
        if (first___0) {
#line 6890
          first___0 = 0;
        } else {
          {
#line 6892
          printf((char const   */* __restrict  */)", ");
          }
        }
        {
#line 6893
        printf((char const   */* __restrict  */)"r%d", i___0);
#line 6887
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 6895
      if (op & 8U) {
#line 6897
        if (! first___0) {
          {
#line 6898
          printf((char const   */* __restrict  */)", ");
          }
        }
        {
#line 6899
        printf((char const   */* __restrict  */)"r14");
        }
      }
      {
#line 6901
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6903
    if (op == 176U) {
      {
#line 6904
      tmp___5 = gettext("     finish");
#line 6904
      printf((char const   */* __restrict  */)tmp___5);
      }
    } else
#line 6905
    if (op == 177U) {
#line 6907
      if (remaining == 0U) {
#line 6907
        if (more_words) {
          {
#line 6907
          data_offset += 4UL;
#line 6907
          tmp___6 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6907
          if (! tmp___6) {
#line 6907
            return;
          }
#line 6907
          remaining = 4U;
#line 6907
          more_words --;
        }
      }
#line 6907
      if (remaining) {
#line 6907
        remaining --;
#line 6907
        op2 = word >> 24;
#line 6907
        word <<= 8;
      } else {
        {
#line 6907
        tmp___7 = gettext("[Truncated opcode]\n");
#line 6907
        printf((char const   */* __restrict  */)tmp___7);
        }
#line 6907
        return;
      }
      {
#line 6907
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6908
      if (op2 == 0U) {
        {
#line 6909
        tmp___8 = gettext("[Spare]");
#line 6909
        printf((char const   */* __restrict  */)tmp___8);
        }
      } else
#line 6908
      if ((op2 & 240U) != 0U) {
        {
#line 6909
        tmp___8 = gettext("[Spare]");
#line 6909
        printf((char const   */* __restrict  */)tmp___8);
        }
      } else {
        {
#line 6912
        mask___0 = op2 & 15U;
#line 6913
        first___1 = 1;
#line 6916
        printf((char const   */* __restrict  */)"pop {");
#line 6917
        i___1 = 0;
        }
        {
#line 6917
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 6917
          if (! (i___1 < 12)) {
#line 6917
            goto while_break___2;
          }
#line 6918
          if (mask___0 & (unsigned int )(1 << i___1)) {
#line 6920
            if (first___1) {
#line 6921
              first___1 = 0;
            } else {
              {
#line 6923
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 6924
            printf((char const   */* __restrict  */)"r%d", i___1);
            }
          }
#line 6917
          i___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 6926
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 6929
    if (op == 178U) {
#line 6935
      i___2 = 0U;
      {
#line 6935
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6935
        if (! ((unsigned long )i___2 < sizeof(buf___7))) {
#line 6935
          goto while_break___3;
        }
#line 6937
        if (remaining == 0U) {
#line 6937
          if (more_words) {
            {
#line 6937
            data_offset += 4UL;
#line 6937
            tmp___9 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 6937
            if (! tmp___9) {
#line 6937
              return;
            }
#line 6937
            remaining = 4U;
#line 6937
            more_words --;
          }
        }
#line 6937
        if (remaining) {
#line 6937
          remaining --;
#line 6937
          buf___7[i___2] = (unsigned char )(word >> 24);
#line 6937
          word <<= 8;
        } else {
          {
#line 6937
          tmp___10 = gettext("[Truncated opcode]\n");
#line 6937
          printf((char const   */* __restrict  */)tmp___10);
          }
#line 6937
          return;
        }
        {
#line 6937
        printf((char const   */* __restrict  */)"0x%02x ", (int )buf___7[i___2]);
        }
#line 6938
        if (((int )buf___7[i___2] & 128) == 0) {
#line 6939
          goto while_break___3;
        }
#line 6935
        i___2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6941
      if (! ((unsigned long )i___2 < sizeof(buf___7))) {
        {
#line 6941
        __assert_fail("i < sizeof (buf)", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                      6941U, "decode_arm_unwind_bytecode");
        }
      }
      {
#line 6942
      offset___1 = read_uleb128___0(buf___7, & len, (unsigned char const   */* const  */)((buf___7 + i___2) + 1));
      }
#line 6943
      if (! (len == i___2 + 1U)) {
        {
#line 6943
        __assert_fail("len == i + 1", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                      6943U, "decode_arm_unwind_bytecode");
        }
      }
      {
#line 6944
      offset___1 = offset___1 * 4UL + 516UL;
#line 6945
      printf((char const   */* __restrict  */)"vsp = vsp + %ld", offset___1);
      }
    } else
#line 6947
    if (op == 179U) {
#line 6947
      goto _L___2;
    } else
#line 6947
    if (op == 200U) {
#line 6947
      goto _L___2;
    } else
#line 6947
    if (op == 201U) {
      _L___2: /* CIL Label */ 
#line 6951
      if (remaining == 0U) {
#line 6951
        if (more_words) {
          {
#line 6951
          data_offset += 4UL;
#line 6951
          tmp___12 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6951
          if (! tmp___12) {
#line 6951
            return;
          }
#line 6951
          remaining = 4U;
#line 6951
          more_words --;
        }
      }
#line 6951
      if (remaining) {
#line 6951
        remaining --;
#line 6951
        op2 = word >> 24;
#line 6951
        word <<= 8;
      } else {
        {
#line 6951
        tmp___13 = gettext("[Truncated opcode]\n");
#line 6951
        printf((char const   */* __restrict  */)tmp___13);
        }
#line 6951
        return;
      }
      {
#line 6951
      printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 6952
      first___2 = op2 >> 4;
#line 6953
      last = op2 & 15U;
      }
#line 6954
      if (op == 200U) {
#line 6955
        first___2 += 16U;
      }
      {
#line 6956
      printf((char const   */* __restrict  */)"pop {D%d", first___2);
      }
#line 6957
      if (last) {
        {
#line 6958
        printf((char const   */* __restrict  */)"-D%d", first___2 + last);
        }
      }
      {
#line 6959
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6961
    if ((op & 248U) == 184U) {
#line 6961
      goto _L___1;
    } else
#line 6961
    if ((op & 248U) == 208U) {
      _L___1: /* CIL Label */ 
      {
#line 6963
      count = op & 7U;
#line 6965
      printf((char const   */* __restrict  */)"pop {D8");
      }
#line 6966
      if (count) {
        {
#line 6967
        printf((char const   */* __restrict  */)"-D%d", 8U + count);
        }
      }
      {
#line 6968
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6970
    if (op >= 192U) {
#line 6970
      if (op <= 197U) {
        {
#line 6972
        count___0 = op & 7U;
#line 6974
        printf((char const   */* __restrict  */)"     pop {wR10");
        }
#line 6975
        if (count___0) {
          {
#line 6976
          printf((char const   */* __restrict  */)"-wR%d", 10U + count___0);
          }
        }
        {
#line 6977
        printf((char const   */* __restrict  */)"}");
        }
      } else {
#line 6970
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 6979
    if (op == 198U) {
#line 6983
      if (remaining == 0U) {
#line 6983
        if (more_words) {
          {
#line 6983
          data_offset += 4UL;
#line 6983
          tmp___14 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6983
          if (! tmp___14) {
#line 6983
            return;
          }
#line 6983
          remaining = 4U;
#line 6983
          more_words --;
        }
      }
#line 6983
      if (remaining) {
#line 6983
        remaining --;
#line 6983
        op2 = word >> 24;
#line 6983
        word <<= 8;
      } else {
        {
#line 6983
        tmp___15 = gettext("[Truncated opcode]\n");
#line 6983
        printf((char const   */* __restrict  */)tmp___15);
        }
#line 6983
        return;
      }
      {
#line 6983
      printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 6984
      first___3 = op2 >> 4;
#line 6985
      last___0 = op2 & 15U;
#line 6986
      printf((char const   */* __restrict  */)"pop {wR%d", first___3);
      }
#line 6987
      if (last___0) {
        {
#line 6988
        printf((char const   */* __restrict  */)"-wR%d", first___3 + last___0);
        }
      }
      {
#line 6989
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6991
    if (op == 199U) {
#line 6993
      if (remaining == 0U) {
#line 6993
        if (more_words) {
          {
#line 6993
          data_offset += 4UL;
#line 6993
          tmp___16 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6993
          if (! tmp___16) {
#line 6993
            return;
          }
#line 6993
          remaining = 4U;
#line 6993
          more_words --;
        }
      }
#line 6993
      if (remaining) {
#line 6993
        remaining --;
#line 6993
        op2 = word >> 24;
#line 6993
        word <<= 8;
      } else {
        {
#line 6993
        tmp___17 = gettext("[Truncated opcode]\n");
#line 6993
        printf((char const   */* __restrict  */)tmp___17);
        }
#line 6993
        return;
      }
      {
#line 6993
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6994
      if (op2 == 0U) {
        {
#line 6995
        tmp___18 = gettext("[Spare]");
#line 6995
        printf((char const   */* __restrict  */)tmp___18);
        }
      } else
#line 6994
      if ((op2 & 240U) != 0U) {
        {
#line 6995
        tmp___18 = gettext("[Spare]");
#line 6995
        printf((char const   */* __restrict  */)tmp___18);
        }
      } else {
        {
#line 6998
        mask___1 = op2 & 15U;
#line 6999
        first___4 = 1;
#line 7002
        printf((char const   */* __restrict  */)"pop {");
#line 7003
        i___3 = 0;
        }
        {
#line 7003
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 7003
          if (! (i___3 < 4)) {
#line 7003
            goto while_break___4;
          }
#line 7004
          if (mask___1 & (unsigned int )(1 << i___3)) {
#line 7006
            if (first___4) {
#line 7007
              first___4 = 0;
            } else {
              {
#line 7009
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 7010
            printf((char const   */* __restrict  */)"wCGR%d", i___3);
            }
          }
#line 7003
          i___3 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 7012
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else {
      {
#line 7016
      tmp___19 = gettext("     [unsupported opcode]");
#line 7016
      printf((char const   */* __restrict  */)tmp___19);
      }
    }
    {
#line 7017
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7019
  return;
}
}
#line 7021 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void decode_tic6x_unwind_bytecode(struct arm_unw_aux_info *aux , unsigned int word ,
                                         unsigned int remaining , unsigned int more_words ,
                                         bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                                         struct arm_section *data_arm_sec ) 
{ 
  struct absaddr addr ;
  unsigned int op ;
  unsigned int op2 ;
  bfd_boolean tmp___0 ;
  int offset ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int mask ;
  unsigned int reg___0 ;
  unsigned int nregs ;
  unsigned int i ;
  char const   *name___0 ;
  struct __anonstruct_regpos_973678109 regpos[16] ;
  bfd_boolean tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned char buf___7[9] ;
  unsigned int i___0 ;
  unsigned int len ;
  unsigned long offset___0 ;
  bfd_boolean tmp___8 ;
  char *tmp___9 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 7031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7035
    if (remaining == 0U) {
#line 7035
      if (more_words) {
        {
#line 7035
        data_offset += 4UL;
#line 7035
        tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                          & word, & addr, (bfd_vma *)((void *)0));
        }
#line 7035
        if (! tmp___0) {
#line 7035
          return;
        }
#line 7035
        remaining = 4U;
#line 7035
        more_words --;
      }
    }
#line 7036
    if (remaining == 0U) {
#line 7037
      goto while_break;
    }
    {
#line 7038
    remaining --;
#line 7039
    op = word >> 24;
#line 7040
    word <<= 8;
#line 7042
    printf((char const   */* __restrict  */)"  0x%02x ", op);
    }
#line 7044
    if ((op & 192U) == 0U) {
      {
#line 7046
      offset = (int )(((op & 63U) << 3) + 8U);
#line 7047
      printf((char const   */* __restrict  */)"     sp = sp + %d", offset);
      }
    } else
#line 7049
    if ((op & 192U) == 128U) {
#line 7051
      if (remaining == 0U) {
#line 7051
        if (more_words) {
          {
#line 7051
          data_offset += 4UL;
#line 7051
          tmp___1 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 7051
          if (! tmp___1) {
#line 7051
            return;
          }
#line 7051
          remaining = 4U;
#line 7051
          more_words --;
        }
      }
#line 7051
      if (remaining) {
#line 7051
        remaining --;
#line 7051
        op2 = word >> 24;
#line 7051
        word <<= 8;
      } else {
        {
#line 7051
        tmp___2 = gettext("[Truncated opcode]\n");
#line 7051
        printf((char const   */* __restrict  */)tmp___2);
        }
#line 7051
        return;
      }
      {
#line 7051
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 7052
      if (op == 128U) {
#line 7052
        if (op2 == 0U) {
          {
#line 7053
          tmp___3 = gettext("Refuse to unwind");
#line 7053
          printf((char const   */* __restrict  */)tmp___3);
          }
        } else {
#line 7052
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 7056
        mask = ((op & 31U) << 8) | op2;
#line 7057
        if (op & 32U) {
          {
#line 7058
          printf((char const   */* __restrict  */)"pop compact {");
          }
        } else {
          {
#line 7060
          printf((char const   */* __restrict  */)"pop {");
          }
        }
        {
#line 7062
        decode_tic6x_unwind_regmask(mask);
#line 7063
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 7066
    if ((op & 240U) == 192U) {
#line 7080
      nregs = 0U;
#line 7081
      i = 0U;
      {
#line 7081
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 7081
        if (! (nregs < (op & 15U))) {
#line 7081
          goto while_break___0;
        }
#line 7083
        if (remaining == 0U) {
#line 7083
          if (more_words) {
            {
#line 7083
            data_offset += 4UL;
#line 7083
            tmp___4 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 7083
            if (! tmp___4) {
#line 7083
              return;
            }
#line 7083
            remaining = 4U;
#line 7083
            more_words --;
          }
        }
#line 7083
        if (remaining) {
#line 7083
          remaining --;
#line 7083
          op2 = word >> 24;
#line 7083
          word <<= 8;
        } else {
          {
#line 7083
          tmp___5 = gettext("[Truncated opcode]\n");
#line 7083
          printf((char const   */* __restrict  */)tmp___5);
          }
#line 7083
          return;
        }
        {
#line 7083
        printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 7084
        reg___0 = op2 >> 4;
        }
#line 7085
        if (reg___0 != 15U) {
#line 7087
          regpos[nregs].offset = i * 2U;
#line 7088
          regpos[nregs].reg = reg___0;
#line 7089
          nregs ++;
        }
#line 7092
        reg___0 = op2 & 15U;
#line 7093
        if (reg___0 != 15U) {
#line 7095
          regpos[nregs].offset = i * 2U + 1U;
#line 7096
          regpos[nregs].reg = reg___0;
#line 7097
          nregs ++;
        }
#line 7081
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 7101
      tmp___6 = gettext("pop frame {");
#line 7101
      printf((char const   */* __restrict  */)tmp___6);
#line 7102
      reg___0 = nregs - 1U;
#line 7103
      i *= 2U;
      }
      {
#line 7103
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7103
        if (! (i > 0U)) {
#line 7103
          goto while_break___1;
        }
#line 7105
        if (regpos[reg___0].offset == i - 1U) {
#line 7107
          name___0 = tic6x_unwind_regnames[regpos[reg___0].reg];
#line 7108
          if (reg___0 > 0U) {
#line 7109
            reg___0 --;
          }
        } else {
          {
#line 7112
          tmp___7 = gettext("[pad]");
#line 7112
          name___0 = (char const   *)tmp___7;
          }
        }
        {
#line 7114
        fputs((char const   */* __restrict  */)name___0, (FILE */* __restrict  */)stdout);
        }
#line 7115
        if (i > 1U) {
          {
#line 7116
          printf((char const   */* __restrict  */)", ");
          }
        }
#line 7103
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 7119
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 7121
    if (op == 208U) {
      {
#line 7122
      printf((char const   */* __restrict  */)"     MOV FP, SP");
      }
    } else
#line 7123
    if (op == 209U) {
      {
#line 7124
      printf((char const   */* __restrict  */)"     __c6xabi_pop_rts");
      }
    } else
#line 7125
    if (op == 210U) {
#line 7131
      i___0 = 0U;
      {
#line 7131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 7131
        if (! ((unsigned long )i___0 < sizeof(buf___7))) {
#line 7131
          goto while_break___2;
        }
#line 7133
        if (remaining == 0U) {
#line 7133
          if (more_words) {
            {
#line 7133
            data_offset += 4UL;
#line 7133
            tmp___8 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 7133
            if (! tmp___8) {
#line 7133
              return;
            }
#line 7133
            remaining = 4U;
#line 7133
            more_words --;
          }
        }
#line 7133
        if (remaining) {
#line 7133
          remaining --;
#line 7133
          buf___7[i___0] = (unsigned char )(word >> 24);
#line 7133
          word <<= 8;
        } else {
          {
#line 7133
          tmp___9 = gettext("[Truncated opcode]\n");
#line 7133
          printf((char const   */* __restrict  */)tmp___9);
          }
#line 7133
          return;
        }
        {
#line 7133
        printf((char const   */* __restrict  */)"0x%02x ", (int )buf___7[i___0]);
        }
#line 7134
        if (((int )buf___7[i___0] & 128) == 0) {
#line 7135
          goto while_break___2;
        }
#line 7131
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 7137
      if (! ((unsigned long )i___0 < sizeof(buf___7))) {
        {
#line 7137
        __assert_fail("i < sizeof (buf)", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                      7137U, "decode_tic6x_unwind_bytecode");
        }
      }
      {
#line 7138
      offset___0 = read_uleb128___0(buf___7, & len, (unsigned char const   */* const  */)((buf___7 + i___0) + 1));
      }
#line 7139
      if (! (len == i___0 + 1U)) {
        {
#line 7139
        __assert_fail("len == i + 1", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                      7139U, "decode_tic6x_unwind_bytecode");
        }
      }
      {
#line 7140
      offset___0 = offset___0 * 8UL + 1032UL;
#line 7141
      tmp___11 = gettext("sp = sp + %ld");
#line 7141
      printf((char const   */* __restrict  */)tmp___11, offset___0);
      }
    } else
#line 7143
    if ((op & 240U) == 224U) {
#line 7145
      if ((op & 15U) == 7U) {
        {
#line 7146
        printf((char const   */* __restrict  */)"     RETURN");
        }
      } else {
        {
#line 7148
        printf((char const   */* __restrict  */)"     MV %s, B3", tic6x_unwind_regnames[op & 15U]);
        }
      }
    } else {
      {
#line 7152
      tmp___12 = gettext("     [unsupported opcode]");
#line 7152
      printf((char const   */* __restrict  */)tmp___12);
      }
    }
    {
#line 7154
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7156
  return;
}
}
#line 7158 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma arm_expand_prel31(bfd_vma word , bfd_vma where ) 
{ 
  bfd_vma offset ;

  {
#line 7163
  offset = word & 2147483647UL;
#line 7164
  if (offset & 1073741824UL) {
#line 7165
    offset |= 0xffffffff80000000UL;
  }
#line 7167
  if ((int )elf_header.e_machine == 140) {
#line 7168
    offset <<= 1;
  }
#line 7170
  return (offset + where);
}
}
#line 7173 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void decode_arm_unwind(struct arm_unw_aux_info *aux , unsigned int word , unsigned int remaining ,
                              bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                              struct arm_section *data_arm_sec ) 
{ 
  int per_index ;
  unsigned int more_words ;
  struct absaddr addr ;
  bfd_vma sym_name ;
  bfd_boolean tmp___0 ;
  bfd_vma fn ;
  char const   *procname ;
  char *tmp___1 ;
  bfd_boolean tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 7182
  more_words = 0U;
#line 7184
  sym_name = (bfd_vma )-1;
#line 7186
  if (remaining == 0U) {
    {
#line 7193
    tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset, & word,
                                      & addr, & sym_name);
    }
#line 7193
    if (! tmp___0) {
#line 7195
      return;
    }
#line 7197
    remaining = 4U;
  }
#line 7200
  if ((word & 2147483648U) == 0U) {
    {
#line 7206
    fn = arm_expand_prel31((bfd_vma )word, data_sec->sh_addr + data_offset);
#line 7207
    tmp___1 = gettext("  Personality routine: ");
#line 7207
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 7208
    if (fn == 0UL) {
#line 7208
      if ((int )addr.section == 0) {
#line 7208
        if (addr.offset == 0UL) {
#line 7208
          if (sym_name != 0xffffffffffffffffUL) {
#line 7208
            if (sym_name < aux->strtab_size) {
              {
#line 7212
              procname = (char const   *)(aux->strtab + sym_name);
#line 7213
              print_vma(fn, (print_mode )4);
              }
#line 7214
              if (procname) {
                {
#line 7216
                fputs((char const   */* __restrict  */)" <", (FILE */* __restrict  */)stdout);
#line 7217
                fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
#line 7218
                fputc('>', stdout);
                }
              }
            } else {
              {
#line 7222
              procname = arm_print_vma_and_name(aux, fn, addr);
              }
            }
          } else {
            {
#line 7222
            procname = arm_print_vma_and_name(aux, fn, addr);
            }
          }
        } else {
          {
#line 7222
          procname = arm_print_vma_and_name(aux, fn, addr);
          }
        }
      } else {
        {
#line 7222
        procname = arm_print_vma_and_name(aux, fn, addr);
        }
      }
    } else {
      {
#line 7222
      procname = arm_print_vma_and_name(aux, fn, addr);
      }
    }
    {
#line 7223
    fputc('\n', stdout);
    }
#line 7228
    if ((unsigned long )procname != (unsigned long )((void *)0)) {
      {
#line 7228
      tmp___4 = strncmp(procname, "__gcc_personality_v0", sizeof("__gcc_personality_v0") - 1UL);
      }
#line 7228
      if (tmp___4 == 0) {
#line 7228
        goto _L;
      } else {
        {
#line 7228
        tmp___5 = strncmp(procname, "__gxx_personality_v0", sizeof("__gxx_personality_v0") - 1UL);
        }
#line 7228
        if (tmp___5 == 0) {
#line 7228
          goto _L;
        } else {
          {
#line 7228
          tmp___6 = strncmp(procname, "__gcj_personality_v0", sizeof("__gcj_personality_v0") - 1UL);
          }
#line 7228
          if (tmp___6 == 0) {
#line 7228
            goto _L;
          } else {
            {
#line 7228
            tmp___7 = strncmp(procname, "__gnu_objc_personality_v0", sizeof("__gnu_objc_personality_v0") - 1UL);
            }
#line 7228
            if (tmp___7 == 0) {
              _L: /* CIL Label */ 
#line 7234
              remaining = 0U;
#line 7235
              more_words = 1U;
#line 7236
              if (remaining == 0U) {
#line 7236
                if (more_words) {
                  {
#line 7236
                  data_offset += 4UL;
#line 7236
                  tmp___2 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                                    & word, & addr, (bfd_vma *)((void *)0));
                  }
#line 7236
                  if (! tmp___2) {
#line 7236
                    return;
                  }
#line 7236
                  remaining = 4U;
#line 7236
                  more_words --;
                }
              }
#line 7237
              if (! remaining) {
                {
#line 7239
                tmp___3 = gettext("  [Truncated data]\n");
#line 7239
                printf((char const   */* __restrict  */)tmp___3);
                }
#line 7240
                return;
              }
#line 7242
              more_words = word >> 24;
#line 7243
              word <<= 8;
#line 7244
              remaining --;
#line 7245
              per_index = -1;
            } else {
#line 7248
              return;
            }
          }
        }
      }
    } else {
#line 7248
      return;
    }
  } else {
#line 7260
    if ((int )elf_header.e_machine == 40) {
#line 7260
      if (word & 1879048192U) {
        {
#line 7262
        tmp___8 = gettext("Corrupt ARM compact model table entry: %x \n");
#line 7262
        warn((char const   *)tmp___8, word);
        }
      }
    }
    {
#line 7264
    per_index = (int )((word >> 24) & 127U);
#line 7265
    tmp___9 = gettext("  Compact model index: %d\n");
#line 7265
    printf((char const   */* __restrict  */)tmp___9, per_index);
    }
#line 7266
    if (per_index == 0) {
#line 7268
      more_words = 0U;
#line 7269
      word <<= 8;
#line 7270
      remaining --;
    } else
#line 7272
    if (per_index < 3) {
#line 7274
      more_words = (word >> 16) & 255U;
#line 7275
      word <<= 16;
#line 7276
      remaining -= 2U;
    }
  }
  {
#line 7282
  if ((int )elf_header.e_machine == 40) {
#line 7282
    goto case_40;
  }
#line 7295
  if ((int )elf_header.e_machine == 140) {
#line 7295
    goto case_140;
  }
#line 7319
  goto switch_default;
  case_40: /* CIL Label */ 
#line 7283
  if (per_index < 3) {
    {
#line 7285
    decode_arm_unwind_bytecode(aux, word, remaining, more_words, data_offset, data_sec,
                               data_arm_sec);
    }
  } else {
    {
#line 7290
    tmp___10 = gettext("Unknown ARM compact model index encountered\n");
#line 7290
    warn((char const   *)tmp___10);
#line 7291
    tmp___11 = gettext("  [reserved]\n");
#line 7291
    printf((char const   */* __restrict  */)tmp___11);
    }
  }
#line 7293
  goto switch_break;
  case_140: /* CIL Label */ 
#line 7296
  if (per_index < 3) {
    {
#line 7298
    decode_tic6x_unwind_bytecode(aux, word, remaining, more_words, data_offset, data_sec,
                                 data_arm_sec);
    }
  } else
#line 7301
  if (per_index < 5) {
#line 7303
    if (((word >> 17) & 127U) == 127U) {
      {
#line 7304
      tmp___12 = gettext("  Restore stack from frame pointer\n");
#line 7304
      printf((char const   */* __restrict  */)tmp___12);
      }
    } else {
      {
#line 7306
      tmp___13 = gettext("  Stack increment %d\n");
#line 7306
      printf((char const   */* __restrict  */)tmp___13, (word >> 14) & 508U);
      }
    }
    {
#line 7307
    tmp___14 = gettext("  Registers restored: ");
#line 7307
    printf((char const   */* __restrict  */)tmp___14);
    }
#line 7308
    if (per_index == 4) {
      {
#line 7309
      printf((char const   */* __restrict  */)" (compact) ");
      }
    }
    {
#line 7310
    decode_tic6x_unwind_regmask((word >> 4) & 8191U);
#line 7311
    putchar('\n');
#line 7312
    tmp___15 = gettext("  Return register: %s\n");
#line 7312
    printf((char const   */* __restrict  */)tmp___15, tic6x_unwind_regnames[word & 15U]);
    }
  } else {
    {
#line 7316
    tmp___16 = gettext("  [reserved (%d)]\n");
#line 7316
    printf((char const   */* __restrict  */)tmp___16, per_index);
    }
  }
#line 7317
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7320
  tmp___17 = gettext("Unsupported architecture type %d encountered when decoding unwind table");
#line 7320
  error((char const   *)tmp___17, (int )elf_header.e_machine);
  }
  switch_break: /* CIL Label */ ;
  }
#line 7325
  return;
}
}
#line 7327 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_arm_unwind(struct arm_unw_aux_info *aux , Elf_Internal_Shdr *exidx_sec ) 
{ 
  struct arm_section exidx_arm_sec ;
  struct arm_section extab_arm_sec ;
  unsigned int i ;
  unsigned int exidx_len ;
  unsigned int exidx_fn ;
  unsigned int exidx_entry ;
  struct absaddr fn_addr ;
  struct absaddr entry_addr ;
  bfd_vma fn ;
  bfd_boolean tmp___0 ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  bfd_vma table ;
  bfd_vma table_offset ;
  Elf_Internal_Shdr *table_sec ;
  char *tmp___3 ;

  {
  {
#line 7333
  memset((void *)(& exidx_arm_sec), 0, sizeof(exidx_arm_sec));
#line 7334
  memset((void *)(& extab_arm_sec), 0, sizeof(extab_arm_sec));
#line 7335
  exidx_len = (unsigned int )(exidx_sec->sh_size / 8UL);
#line 7337
  i = 0U;
  }
  {
#line 7337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7337
    if (! (i < exidx_len)) {
#line 7337
      goto while_break;
    }
    {
#line 7343
    fputc('\n', stdout);
#line 7345
    tmp___0 = get_unwind_section_word(aux, & exidx_arm_sec, exidx_sec, (bfd_vma )(8U * i),
                                      & exidx_fn, & fn_addr, (bfd_vma *)((void *)0));
    }
#line 7345
    if (tmp___0) {
      {
#line 7345
      tmp___1 = get_unwind_section_word(aux, & exidx_arm_sec, exidx_sec, (bfd_vma )(8U * i + 4U),
                                        & exidx_entry, & entry_addr, (bfd_vma *)((void *)0));
      }
#line 7345
      if (! tmp___1) {
        {
#line 7350
        arm_free_section(& exidx_arm_sec);
#line 7351
        arm_free_section(& extab_arm_sec);
        }
#line 7352
        return;
      }
    } else {
      {
#line 7350
      arm_free_section(& exidx_arm_sec);
#line 7351
      arm_free_section(& extab_arm_sec);
      }
#line 7352
      return;
    }
#line 7358
    if (exidx_fn & 2147483648U) {
      {
#line 7359
      tmp___2 = gettext("corrupt index table entry: %x\n");
#line 7359
      warn((char const   *)tmp___2, exidx_fn);
      }
    }
    {
#line 7361
    fn = arm_expand_prel31((bfd_vma )exidx_fn, exidx_sec->sh_addr + (bfd_vma )(8U * i));
#line 7363
    arm_print_vma_and_name(aux, fn, fn_addr);
#line 7364
    fputs((char const   */* __restrict  */)": ", (FILE */* __restrict  */)stdout);
    }
#line 7366
    if (exidx_entry == 1U) {
      {
#line 7368
      print_vma((bfd_vma )exidx_entry, (print_mode )4);
#line 7369
      fputs((char const   */* __restrict  */)" [cantunwind]\n", (FILE */* __restrict  */)stdout);
      }
    } else
#line 7371
    if (exidx_entry & 2147483648U) {
      {
#line 7373
      print_vma((bfd_vma )exidx_entry, (print_mode )4);
#line 7374
      fputc('\n', stdout);
#line 7375
      decode_arm_unwind(aux, exidx_entry, 4U, (bfd_vma )0, (Elf_Internal_Shdr *)((void *)0),
                        (struct arm_section *)((void *)0));
      }
    } else {
      {
#line 7379
      table_offset = (bfd_vma )0;
#line 7382
      fputs((char const   */* __restrict  */)"@", (FILE */* __restrict  */)stdout);
#line 7383
      table = arm_expand_prel31((bfd_vma )exidx_entry, (exidx_sec->sh_addr + (bfd_vma )(8U * i)) + 4UL);
#line 7384
      print_vma(table, (print_mode )4);
#line 7385
      printf((char const   */* __restrict  */)"\n");
      }
#line 7388
      if ((int )entry_addr.section != 0) {
#line 7388
        if ((unsigned int )entry_addr.section < elf_header.e_shnum) {
#line 7391
          table_sec = section_headers + (int )entry_addr.section;
#line 7392
          table_offset = entry_addr.offset;
        } else {
#line 7388
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 7396
        table_sec = find_section_by_address(table);
        }
#line 7397
        if ((unsigned long )table_sec != (unsigned long )((void *)0)) {
#line 7398
          table_offset = table - table_sec->sh_addr;
        }
      }
#line 7400
      if ((unsigned long )table_sec == (unsigned long )((void *)0)) {
        {
#line 7402
        tmp___3 = gettext("Could not locate .ARM.extab section containing 0x%lx.\n");
#line 7402
        warn((char const   *)tmp___3, table);
        }
#line 7404
        goto __Cont;
      }
      {
#line 7406
      decode_arm_unwind(aux, 0U, 0U, table_offset, table_sec, & extab_arm_sec);
      }
    }
    __Cont: /* CIL Label */ 
#line 7337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7411
  printf((char const   */* __restrict  */)"\n");
#line 7413
  arm_free_section(& exidx_arm_sec);
#line 7414
  arm_free_section(& extab_arm_sec);
  }
#line 7415
  return;
}
}
#line 7419 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void arm_process_unwind(FILE *file ) 
{ 
  struct arm_unw_aux_info aux ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  Elf_Internal_Shdr *sec ;
  unsigned long i ;
  unsigned int sec_type ;
  char *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  Elf_Internal_Sym *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 7423
  unwsec = (Elf_Internal_Shdr *)((void *)0);
  {
#line 7431
  if ((int )elf_header.e_machine == 40) {
#line 7431
    goto case_40;
  }
#line 7435
  if ((int )elf_header.e_machine == 140) {
#line 7435
    goto case_140;
  }
#line 7439
  goto switch_default;
  case_40: /* CIL Label */ 
#line 7432
  sec_type = 1879048193U;
#line 7433
  goto switch_break;
  case_140: /* CIL Label */ 
#line 7436
  sec_type = 1879048193U;
#line 7437
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7440
  tmp___0 = gettext("Unsupported architecture type %d encountered when processing unwind table");
#line 7440
  error((char const   *)tmp___0, (int )elf_header.e_machine);
  }
#line 7442
  return;
  switch_break: /* CIL Label */ ;
  }
#line 7445
  if ((unsigned long )string_table == (unsigned long )((void *)0)) {
#line 7446
    return;
  }
  {
#line 7448
  memset((void *)(& aux), 0, sizeof(aux));
#line 7449
  aux.file = file;
#line 7451
  i = 0UL;
#line 7451
  sec = section_headers;
  }
  {
#line 7451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7451
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 7451
      goto while_break;
    }
#line 7453
    if (sec->sh_type == 2U) {
#line 7453
      if (sec->sh_link < elf_header.e_shnum) {
#line 7455
        if (is_32bit_elf) {
          {
#line 7455
          tmp___1 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 7455
          aux.symtab = tmp___1;
          }
        } else {
          {
#line 7455
          tmp___2 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 7455
          aux.symtab = tmp___2;
          }
        }
#line 7457
        strsec = section_headers + sec->sh_link;
#line 7458
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 7458
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                        7458U, "arm_process_unwind");
          }
        }
        {
#line 7459
        tmp___3 = gettext("string table");
#line 7459
        tmp___4 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___3);
#line 7459
        aux.strtab = (char *)tmp___4;
        }
#line 7461
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 7461
          aux.strtab_size = strsec->sh_size;
        } else {
#line 7461
          aux.strtab_size = 0UL;
        }
      } else {
#line 7453
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 7463
    if (sec->sh_type == sec_type) {
#line 7464
      unwsec = sec;
    }
#line 7451
    i ++;
#line 7451
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7467
  if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
    {
#line 7468
    tmp___5 = gettext("\nThere are no unwind sections in this file.\n");
#line 7468
    printf((char const   */* __restrict  */)tmp___5);
    }
  } else {
#line 7470
    i = 0UL;
#line 7470
    sec = section_headers;
    {
#line 7470
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7470
      if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 7470
        goto while_break___0;
      }
#line 7472
      if (sec->sh_type == sec_type) {
#line 7474
        if ((unsigned long )sec == (unsigned long )((void *)0)) {
          {
#line 7474
          tmp___6 = gettext("<none>");
#line 7474
          tmp___11 = tmp___6;
          }
        } else {
#line 7474
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 7474
            tmp___7 = gettext("<no-name>");
#line 7474
            tmp___10 = tmp___7;
            }
          } else {
#line 7474
            if ((unsigned long )sec->sh_name >= string_table_length) {
              {
#line 7474
              tmp___8 = gettext("<corrupt>");
#line 7474
              tmp___9 = tmp___8;
              }
            } else {
#line 7474
              tmp___9 = string_table + sec->sh_name;
            }
#line 7474
            tmp___10 = tmp___9;
          }
#line 7474
          tmp___11 = tmp___10;
        }
        {
#line 7474
        tmp___12 = gettext("\nUnwind table index \'%s\' at offset 0x%lx contains %lu entries:\n");
#line 7474
        printf((char const   */* __restrict  */)tmp___12, tmp___11, (unsigned long )sec->sh_offset,
               sec->sh_size / (bfd_size_type )(2 * eh_addr_size));
#line 7479
        dump_arm_unwind(& aux, sec);
        }
      }
#line 7470
      i ++;
#line 7470
      sec ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7483
  if (aux.symtab) {
    {
#line 7484
    free((void *)aux.symtab);
    }
  }
#line 7485
  if (aux.strtab) {
    {
#line 7486
    free((void *)aux.strtab);
    }
  }
#line 7487
  return;
}
}
#line 7489 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void process_unwind(FILE *file ) 
{ 
  struct unwind_handler handlers[5] ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 7492
  handlers[0].machtype = 40;
#line 7492
  handlers[0].handler = & arm_process_unwind;
#line 7492
  handlers[1].machtype = 50;
#line 7492
  handlers[1].handler = & ia64_process_unwind;
#line 7492
  handlers[2].machtype = 15;
#line 7492
  handlers[2].handler = & hppa_process_unwind;
#line 7492
  handlers[3].machtype = 140;
#line 7492
  handlers[3].handler = & arm_process_unwind;
#line 7492
  handlers[4].machtype = 0;
#line 7492
  handlers[4].handler = (void (*)(FILE * ))0;
#line 7506
  if (! do_unwind) {
#line 7507
    return;
  }
#line 7509
  i = 0;
  {
#line 7509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7509
    if (! ((unsigned long )handlers[i].handler != (unsigned long )((void *)0))) {
#line 7509
      goto while_break;
    }
#line 7510
    if ((int )elf_header.e_machine == handlers[i].machtype) {
      {
#line 7512
      (*(handlers[i].handler))(file);
      }
#line 7513
      return;
    }
#line 7509
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7516
  tmp___0 = get_machine_name((unsigned int )elf_header.e_machine);
#line 7516
  tmp___1 = gettext("\nThe decoding of unwind sections for machine type %s is not currently supported.\n");
#line 7516
  printf((char const   */* __restrict  */)tmp___1, tmp___0);
  }
#line 7518
  return;
}
}
#line 7530
static void dynamic_section_mips_val(Elf_Internal_Dyn *entry ) ;
#line 7530 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *opts[15]  = 
#line 7530
  {      "QUICKSTART",      "NOTPOT",      "NO_LIBRARY_REPLACEMENT",      "NO_MOVE", 
        "SGI_ONLY",      "GUARANTEE_INIT",      "DELTA_C_PLUS_PLUS",      "GUARANTEE_START_INIT", 
        "PIXIE",      "DEFAULT_DELAY_LOAD",      "REQUICKSTART",      "REQUICKSTARTED", 
        "CORD",      "NO_UNRES_UNDEF",      "RLD_ORDER_SAFE"};
#line 7520 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dynamic_section_mips_val(Elf_Internal_Dyn *entry ) 
{ 
  char *tmp___0 ;
  unsigned int cnt ;
  int first ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char timebuf[20] ;
  struct tm *tmp___4 ;
  time_t atime ;
  char *tmp___5 ;

  {
  {
#line 7525
  if (entry->d_tag == 1879048197UL) {
#line 7525
    goto case_1879048197;
  }
#line 7550
  if (entry->d_tag == 1879048196UL) {
#line 7550
    goto case_1879048196;
  }
#line 7557
  if (entry->d_tag == 1879048194UL) {
#line 7557
    goto case_1879048194;
  }
#line 7583
  if (entry->d_tag == 1879048239UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048225UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048222UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048220UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048218UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048216UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048212UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048210UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048209UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048208UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048203UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048202UL) {
#line 7583
    goto case_1879048239;
  }
#line 7583
  if (entry->d_tag == 1879048193UL) {
#line 7583
    goto case_1879048239;
  }
#line 7587
  goto switch_default;
  case_1879048197: /* CIL Label */ 
#line 7526
  if (entry->d_un.d_val == 0UL) {
    {
#line 7527
    tmp___0 = gettext("NONE");
#line 7527
    printf((char const   */* __restrict  */)tmp___0);
    }
  } else {
#line 7539
    first = 1;
#line 7541
    cnt = 0U;
    {
#line 7541
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7541
      if (! ((unsigned long )cnt < sizeof(opts) / sizeof(opts[0]))) {
#line 7541
        goto while_break;
      }
#line 7542
      if (entry->d_un.d_val & (unsigned long )(1 << cnt)) {
#line 7544
        if (first) {
#line 7544
          tmp___1 = "";
        } else {
#line 7544
          tmp___1 = " ";
        }
        {
#line 7544
        printf((char const   */* __restrict  */)"%s%s", tmp___1, opts[cnt]);
#line 7545
        first = 0;
        }
      }
#line 7541
      cnt ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 7548
  goto switch_break;
  case_1879048196: /* CIL Label */ 
#line 7551
  if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 7551
    if (entry->d_un.d_val < dynamic_strings_length) {
      {
#line 7552
      tmp___2 = gettext("Interface Version: %s");
#line 7552
      printf((char const   */* __restrict  */)tmp___2, dynamic_strings + entry->d_un.d_val);
      }
    } else {
      {
#line 7554
      tmp___3 = gettext("<corrupt: %ld>");
#line 7554
      printf((char const   */* __restrict  */)tmp___3, entry->d_un.d_ptr);
      }
    }
  } else {
    {
#line 7554
    tmp___3 = gettext("<corrupt: %ld>");
#line 7554
    printf((char const   */* __restrict  */)tmp___3, entry->d_un.d_ptr);
    }
  }
#line 7555
  goto switch_break;
  case_1879048194: /* CIL Label */ 
  {
#line 7562
  atime = (time_t )entry->d_un.d_val;
#line 7563
  tmp___4 = gmtime((time_t const   *)(& atime));
#line 7564
  snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
           tmp___4->tm_year + 1900, tmp___4->tm_mon + 1, tmp___4->tm_mday, tmp___4->tm_hour,
           tmp___4->tm_min, tmp___4->tm_sec);
#line 7567
  tmp___5 = gettext("Time Stamp: %s");
#line 7567
  printf((char const   */* __restrict  */)tmp___5, timebuf);
  }
#line 7569
  goto switch_break;
  case_1879048239: /* CIL Label */ 
  case_1879048225: /* CIL Label */ 
  case_1879048222: /* CIL Label */ 
  case_1879048220: /* CIL Label */ 
  case_1879048218: /* CIL Label */ 
  case_1879048216: /* CIL Label */ 
  case_1879048212: /* CIL Label */ 
  case_1879048210: /* CIL Label */ 
  case_1879048209: /* CIL Label */ 
  case_1879048208: /* CIL Label */ 
  case_1879048203: /* CIL Label */ 
  case_1879048202: /* CIL Label */ 
  case_1879048193: /* CIL Label */ 
  {
#line 7584
  print_vma(entry->d_un.d_ptr, (print_mode )1);
  }
#line 7585
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7588
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 7590
  putchar('\n');
  }
#line 7591
  return;
}
}
#line 7600
static void dynamic_section_parisc_val(Elf_Internal_Dyn *entry ) ;
#line 7600 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct __anonstruct_flags_85572036 flags___0[17]  = 
#line 7600
  {      {1L, "HP_DEBUG_PRIVATE"}, 
        {2L, "HP_DEBUG_CALLBACK"}, 
        {4L, "HP_DEBUG_CALLBACK_BOR"}, 
        {8L, "HP_NO_ENVVAR"}, 
        {16L, "HP_BIND_NOW"}, 
        {32L, "HP_BIND_NONFATAL"}, 
        {64L, "HP_BIND_VERBOSE"}, 
        {128L, "HP_BIND_RESTRICTED"}, 
        {256L, "HP_BIND_SYMBOLIC"}, 
        {512L, "HP_RPATH_FIRST"}, 
        {1024L, "HP_BIND_DEPTH_FIRST"}, 
        {2048L, "HP_GST"}, 
        {4096L, "HP_SHLIB_FIXED"}, 
        {8192L, "HP_MERGE_SHLIB_SEG"}, 
        {16384L, "HP_NODELETE"}, 
        {32768L, "HP_GROUP"}, 
        {65536L, "HP_PROTECT_LINKAGE_TABLE"}};
#line 7593 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dynamic_section_parisc_val(Elf_Internal_Dyn *entry ) 
{ 
  int first ;
  size_t cnt ;
  bfd_vma val ;

  {
  {
#line 7598
  if (entry->d_tag == 1610612737UL) {
#line 7598
    goto case_1610612737;
  }
#line 7648
  goto switch_default;
  case_1610612737: /* CIL Label */ 
#line 7625
  first = 1;
#line 7627
  val = entry->d_un.d_val;
#line 7629
  cnt = (size_t )0;
  {
#line 7629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7629
    if (! (cnt < sizeof(flags___0) / sizeof(flags___0[0]))) {
#line 7629
      goto while_break;
    }
#line 7630
    if (val & (unsigned long )flags___0[cnt].bit) {
#line 7632
      if (! first) {
        {
#line 7633
        putchar(' ');
        }
      }
      {
#line 7634
      fputs((char const   */* __restrict  */)flags___0[cnt].str, (FILE */* __restrict  */)stdout);
#line 7635
      first = 0;
#line 7636
      val ^= (unsigned long )flags___0[cnt].bit;
      }
    }
#line 7629
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7639
  if (val != 0UL) {
#line 7639
    goto _L;
  } else
#line 7639
  if (first) {
    _L: /* CIL Label */ 
#line 7641
    if (! first) {
      {
#line 7642
      putchar(' ');
      }
    }
    {
#line 7643
    print_vma(val, (print_mode )0);
    }
  }
#line 7646
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7649
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7650
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 7652
  putchar('\n');
  }
#line 7653
  return;
}
}
#line 7664 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void print_vms_time(bfd_int64_t vmstime ) 
{ 
  struct tm *tm ;
  time_t unxtime ;

  {
  {
#line 7670
  unxtime = (time_t )(((long long )vmstime - 35067168000000000LL) / 10000000LL);
#line 7671
  tm = gmtime((time_t const   *)(& unxtime));
#line 7672
  printf((char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u", tm->tm_year + 1900,
         tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
  }
#line 7675
  return;
}
}
#line 7678 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dynamic_section_ia64_val(Elf_Internal_Dyn *entry ) 
{ 


  {
  {
#line 7683
  if (entry->d_tag == 1879048192UL) {
#line 7683
    goto case_1879048192;
  }
#line 7690
  if (entry->d_tag == 1610612789UL) {
#line 7690
    goto case_1610612789;
  }
#line 7696
  if (entry->d_tag == 1610612757UL) {
#line 7696
    goto case_1610612757;
  }
#line 7730
  goto switch_default;
  case_1879048192: /* CIL Label */ 
  {
#line 7685
  print_vma(entry->d_un.d_ptr, (print_mode )4);
#line 7686
  printf((char const   */* __restrict  */)" -- ");
#line 7687
  print_vma(entry->d_un.d_ptr + 24UL, (print_mode )4);
  }
#line 7688
  goto switch_break;
  case_1610612789: /* CIL Label */ 
  {
#line 7692
  print_vms_time((bfd_int64_t )entry->d_un.d_val);
  }
#line 7694
  goto switch_break;
  case_1610612757: /* CIL Label */ 
  {
#line 7697
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7698
  if (entry->d_un.d_val & 1UL) {
    {
#line 7699
    printf((char const   */* __restrict  */)" CALL_DEBUG");
    }
  }
#line 7700
  if (entry->d_un.d_val & 2UL) {
    {
#line 7701
    printf((char const   */* __restrict  */)" NOP0BUFS");
    }
  }
#line 7702
  if (entry->d_un.d_val & 4UL) {
    {
#line 7703
    printf((char const   */* __restrict  */)" P0IMAGE");
    }
  }
#line 7704
  if (entry->d_un.d_val & 8UL) {
    {
#line 7705
    printf((char const   */* __restrict  */)" MKTHREADS");
    }
  }
#line 7706
  if (entry->d_un.d_val & 16UL) {
    {
#line 7707
    printf((char const   */* __restrict  */)" UPCALLS");
    }
  }
#line 7708
  if (entry->d_un.d_val & 32UL) {
    {
#line 7709
    printf((char const   */* __restrict  */)" IMGSTA");
    }
  }
#line 7710
  if (entry->d_un.d_val & 64UL) {
    {
#line 7711
    printf((char const   */* __restrict  */)" INITIALIZE");
    }
  }
#line 7712
  if (entry->d_un.d_val & 128UL) {
    {
#line 7713
    printf((char const   */* __restrict  */)" MAIN");
    }
  }
#line 7714
  if (entry->d_un.d_val & 512UL) {
    {
#line 7715
    printf((char const   */* __restrict  */)" EXE_INIT");
    }
  }
#line 7716
  if (entry->d_un.d_val & 1024UL) {
    {
#line 7717
    printf((char const   */* __restrict  */)" TBK_IN_IMG");
    }
  }
#line 7718
  if (entry->d_un.d_val & 2048UL) {
    {
#line 7719
    printf((char const   */* __restrict  */)" DBG_IN_IMG");
    }
  }
#line 7720
  if (entry->d_un.d_val & 4096UL) {
    {
#line 7721
    printf((char const   */* __restrict  */)" TBK_IN_DSF");
    }
  }
#line 7722
  if (entry->d_un.d_val & 8192UL) {
    {
#line 7723
    printf((char const   */* __restrict  */)" DBG_IN_DSF");
    }
  }
#line 7724
  if (entry->d_un.d_val & 16384UL) {
    {
#line 7725
    printf((char const   */* __restrict  */)" SIGNATURES");
    }
  }
#line 7726
  if (entry->d_un.d_val & 32768UL) {
    {
#line 7727
    printf((char const   */* __restrict  */)" REL_SEG_OFF");
    }
  }
#line 7728
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7731
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7732
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 7734
  putchar('\n');
  }
#line 7735
  return;
}
}
#line 7737 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_32bit_dynamic_section(FILE *file ) 
{ 
  Elf32_External_Dyn *edyn ;
  Elf32_External_Dyn *ext ;
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;

  {
  {
#line 7744
  tmp___0 = gettext("dynamic section");
#line 7744
  tmp___1 = get_data((void *)0, file, (long )dynamic_addr, (size_t )1, dynamic_size,
                     (char const   *)tmp___0);
#line 7744
  edyn = (Elf32_External_Dyn *)tmp___1;
  }
#line 7746
  if (! edyn) {
#line 7747
    return (0);
  }
#line 7752
  ext = edyn;
#line 7752
  dynamic_nent = 0U;
  {
#line 7752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7752
    if (! ((unsigned long )((char *)ext) < (unsigned long )((char *)edyn + dynamic_size))) {
#line 7752
      goto while_break;
    }
    {
#line 7756
    dynamic_nent ++;
#line 7757
    tmp___2 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
    }
#line 7757
    if (tmp___2 == 0ULL) {
#line 7758
      goto while_break;
    }
#line 7752
    ext ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7761
  tmp___3 = cmalloc((size_t )dynamic_nent, sizeof(*entry));
#line 7761
  dynamic_section = (Elf_Internal_Dyn *)tmp___3;
  }
#line 7763
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
    {
#line 7765
    tmp___4 = gettext("Out of memory\n");
#line 7765
    error((char const   *)tmp___4);
#line 7766
    free((void *)edyn);
    }
#line 7767
    return (0);
  }
#line 7770
  ext = edyn;
#line 7770
  entry = dynamic_section;
  {
#line 7770
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7770
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7770
      goto while_break___0;
    }
    {
#line 7774
    tmp___5 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
#line 7774
    entry->d_tag = (bfd_vma )tmp___5;
#line 7775
    tmp___6 = (*byte_get)(ext->d_un.d_val, (int )sizeof(ext->d_un.d_val));
#line 7775
    entry->d_un.d_val = (bfd_vma )tmp___6;
#line 7770
    ext ++;
#line 7770
    entry ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7778
  free((void *)edyn);
  }
#line 7780
  return (1);
}
}
#line 7783 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_64bit_dynamic_section(FILE *file ) 
{ 
  Elf64_External_Dyn *edyn ;
  Elf64_External_Dyn *ext ;
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;

  {
  {
#line 7790
  tmp___0 = gettext("dynamic section");
#line 7790
  tmp___1 = get_data((void *)0, file, (long )dynamic_addr, (size_t )1, dynamic_size,
                     (char const   *)tmp___0);
#line 7790
  edyn = (Elf64_External_Dyn *)tmp___1;
  }
#line 7792
  if (! edyn) {
#line 7793
    return (0);
  }
#line 7798
  ext = edyn;
#line 7798
  dynamic_nent = 0U;
  {
#line 7798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7798
    if (! ((unsigned long )((char *)ext) < (unsigned long )((char *)edyn + dynamic_size))) {
#line 7798
      goto while_break;
    }
    {
#line 7802
    dynamic_nent ++;
#line 7803
    tmp___2 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
    }
#line 7803
    if (tmp___2 == 0ULL) {
#line 7804
      goto while_break;
    }
#line 7798
    ext ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7807
  tmp___3 = cmalloc((size_t )dynamic_nent, sizeof(*entry));
#line 7807
  dynamic_section = (Elf_Internal_Dyn *)tmp___3;
  }
#line 7809
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
    {
#line 7811
    tmp___4 = gettext("Out of memory\n");
#line 7811
    error((char const   *)tmp___4);
#line 7812
    free((void *)edyn);
    }
#line 7813
    return (0);
  }
#line 7816
  ext = edyn;
#line 7816
  entry = dynamic_section;
  {
#line 7816
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7816
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7816
      goto while_break___0;
    }
    {
#line 7820
    tmp___5 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
#line 7820
    entry->d_tag = (bfd_vma )tmp___5;
#line 7821
    tmp___6 = (*byte_get)(ext->d_un.d_val, (int )sizeof(ext->d_un.d_val));
#line 7821
    entry->d_un.d_val = (bfd_vma )tmp___6;
#line 7816
    ext ++;
#line 7816
    entry ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7824
  free((void *)edyn);
  }
#line 7826
  return (1);
}
}
#line 7829 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void print_dynamic_flags(bfd_vma flags___1 ) 
{ 
  int first ;
  bfd_vma flag ;
  char *tmp___0 ;

  {
#line 7832
  first = 1;
  {
#line 7834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7834
    if (! flags___1) {
#line 7834
      goto while_break;
    }
#line 7838
    flag = flags___1 & - flags___1;
#line 7839
    flags___1 &= ~ flag;
#line 7841
    if (first) {
#line 7842
      first = 0;
    } else {
      {
#line 7844
      _IO_putc(' ', stdout);
      }
    }
    {
#line 7848
    if (flag == 1UL) {
#line 7848
      goto case_1;
    }
#line 7849
    if (flag == (bfd_vma )(1 << 1)) {
#line 7849
      goto case_exp;
    }
#line 7850
    if (flag == (bfd_vma )(1 << 2)) {
#line 7850
      goto case_exp___0;
    }
#line 7851
    if (flag == (bfd_vma )(1 << 3)) {
#line 7851
      goto case_exp___1;
    }
#line 7852
    if (flag == (bfd_vma )(1 << 4)) {
#line 7852
      goto case_exp___2;
    }
#line 7853
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 7848
    fputs((char const   */* __restrict  */)"ORIGIN", (FILE */* __restrict  */)stdout);
    }
#line 7848
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 7849
    fputs((char const   */* __restrict  */)"SYMBOLIC", (FILE */* __restrict  */)stdout);
    }
#line 7849
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 7850
    fputs((char const   */* __restrict  */)"TEXTREL", (FILE */* __restrict  */)stdout);
    }
#line 7850
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 7851
    fputs((char const   */* __restrict  */)"BIND_NOW", (FILE */* __restrict  */)stdout);
    }
#line 7851
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 7852
    fputs((char const   */* __restrict  */)"STATIC_TLS", (FILE */* __restrict  */)stdout);
    }
#line 7852
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 7853
    tmp___0 = gettext("unknown");
#line 7853
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
    }
#line 7853
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7856
  puts("");
  }
#line 7857
  return;
}
}
#line 7861 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_dynamic_section(FILE *file ) 
{ 
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Elf_Internal_Shdr section ;
  char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  Elf_Internal_Sym *tmp___6 ;
  Elf_Internal_Sym *tmp___7 ;
  char *tmp___8 ;
  unsigned long offset ;
  long str_tab_len ;
  long tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  unsigned long syminsz ;
  long tmp___16 ;
  Elf_External_Syminfo *extsyminfo ;
  Elf_External_Syminfo *extsym ;
  Elf_Internal_Syminfo *syminfo ;
  char *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char const   *dtype ;
  int tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned long val ;
  char *tmp___34 ;
  char *tmp___35 ;
  unsigned long val___0 ;
  char *tmp___36 ;
  char *tmp___37 ;
  unsigned long val___1 ;
  char const   *tmp___38 ;
  char *name___0 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *name___1 ;
  char *tmp___46 ;
  struct tm *tmp___47 ;
  time_t atime ;

  {
#line 7866
  if (dynamic_size == 0UL) {
#line 7868
    if (do_dynamic) {
      {
#line 7869
      tmp___0 = gettext("\nThere is no dynamic section in this file.\n");
#line 7869
      printf((char const   */* __restrict  */)tmp___0);
      }
    }
#line 7871
    return (1);
  }
#line 7874
  if (is_32bit_elf) {
    {
#line 7876
    tmp___1 = get_32bit_dynamic_section(file);
    }
#line 7876
    if (! tmp___1) {
#line 7877
      return (0);
    }
  } else {
    {
#line 7879
    tmp___2 = get_64bit_dynamic_section(file);
    }
#line 7879
    if (! tmp___2) {
#line 7880
      return (0);
    }
  }
#line 7883
  if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
#line 7885
    entry = dynamic_section;
    {
#line 7885
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7885
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7885
        goto while_break;
      }
#line 7891
      if (entry->d_tag != 6UL) {
#line 7892
        goto __Cont;
      }
      {
#line 7894
      dynamic_info[6] = entry->d_un.d_val;
#line 7900
      section.sh_offset = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
      }
#line 7902
      if (archive_file_offset != 0L) {
#line 7903
        section.sh_size = archive_file_size - (unsigned long )section.sh_offset;
      } else {
        {
#line 7906
        tmp___4 = fseek(file, 0L, 2);
        }
#line 7906
        if (tmp___4) {
          {
#line 7907
          tmp___3 = gettext("Unable to seek to end of file!\n");
#line 7907
          error((char const   *)tmp___3);
          }
        }
        {
#line 7909
        tmp___5 = ftell(file);
#line 7909
        section.sh_size = (bfd_size_type )(tmp___5 - section.sh_offset);
        }
      }
#line 7912
      if (is_32bit_elf) {
#line 7913
        section.sh_entsize = sizeof(Elf32_External_Sym );
      } else {
#line 7915
        section.sh_entsize = sizeof(Elf64_External_Sym );
      }
#line 7917
      if (is_32bit_elf) {
        {
#line 7917
        tmp___6 = get_32bit_elf_symbols(file, & section, & num_dynamic_syms);
#line 7917
        dynamic_symbols = tmp___6;
        }
      } else {
        {
#line 7917
        tmp___7 = get_64bit_elf_symbols(file, & section, & num_dynamic_syms);
#line 7917
        dynamic_symbols = tmp___7;
        }
      }
#line 7918
      if (num_dynamic_syms < 1UL) {
        {
#line 7920
        tmp___8 = gettext("Unable to determine the number of symbols to load\n");
#line 7920
        error((char const   *)tmp___8);
        }
#line 7921
        goto __Cont;
      }
      __Cont: /* CIL Label */ 
#line 7885
      entry ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 7927
  if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 7929
    entry = dynamic_section;
    {
#line 7929
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7929
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7929
        goto while_break___0;
      }
#line 7936
      if (entry->d_tag != 5UL) {
#line 7937
        goto __Cont___0;
      }
      {
#line 7939
      dynamic_info[5] = entry->d_un.d_val;
#line 7946
      tmp___9 = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
#line 7946
      offset = (unsigned long )tmp___9;
      }
#line 7948
      if (archive_file_offset != 0L) {
#line 7949
        str_tab_len = (long )(archive_file_size - offset);
      } else {
        {
#line 7952
        tmp___11 = fseek(file, 0L, 2);
        }
#line 7952
        if (tmp___11) {
          {
#line 7953
          tmp___10 = gettext("Unable to seek to end of file\n");
#line 7953
          error((char const   *)tmp___10);
          }
        }
        {
#line 7954
        tmp___12 = ftell(file);
#line 7954
        str_tab_len = (long )((unsigned long )tmp___12 - offset);
        }
      }
#line 7957
      if (str_tab_len < 1L) {
        {
#line 7959
        tmp___13 = gettext("Unable to determine the length of the dynamic string table\n");
#line 7959
        error((char const   *)tmp___13);
        }
#line 7961
        goto __Cont___0;
      }
      {
#line 7964
      tmp___14 = gettext("dynamic string table");
#line 7964
      tmp___15 = get_data((void *)0, file, (long )offset, (size_t )1, (size_t )str_tab_len,
                          (char const   *)tmp___14);
#line 7964
      dynamic_strings = (char *)tmp___15;
      }
#line 7967
      if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 7967
        dynamic_strings_length = 0UL;
      } else {
#line 7967
        dynamic_strings_length = (unsigned long )str_tab_len;
      }
#line 7968
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 7929
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7973
  if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
#line 7975
    syminsz = 0UL;
#line 7977
    entry = dynamic_section;
    {
#line 7977
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7977
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7977
        goto while_break___1;
      }
#line 7981
      if (entry->d_tag == 1879047679UL) {
#line 7985
        if (! (sizeof(Elf_External_Syminfo ) == entry->d_un.d_val)) {
          {
#line 7985
          __assert_fail("sizeof (Elf_External_Syminfo) == entry->d_un.d_val", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                        7985U, "process_dynamic_section");
          }
        }
      } else
#line 7987
      if (entry->d_tag == 1879047678UL) {
#line 7988
        syminsz = entry->d_un.d_val;
      } else
#line 7989
      if (entry->d_tag == 1879047935UL) {
        {
#line 7990
        tmp___16 = offset_from_vma(file, entry->d_un.d_val, syminsz);
#line 7990
        dynamic_syminfo_offset = (unsigned long )tmp___16;
        }
      }
#line 7977
      entry ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7994
    if (dynamic_syminfo_offset != 0UL) {
#line 7994
      if (syminsz != 0UL) {
        {
#line 8001
        tmp___17 = gettext("symbol information");
#line 8001
        tmp___18 = get_data((void *)0, file, (long )dynamic_syminfo_offset, (size_t )1,
                            syminsz, (char const   *)tmp___17);
#line 8001
        extsyminfo = (Elf_External_Syminfo *)tmp___18;
        }
#line 8004
        if (! extsyminfo) {
#line 8005
          return (0);
        }
        {
#line 8007
        tmp___19 = malloc(syminsz);
#line 8007
        dynamic_syminfo = (Elf_Internal_Syminfo *)tmp___19;
        }
#line 8008
        if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
          {
#line 8010
          tmp___20 = gettext("Out of memory\n");
#line 8010
          error((char const   *)tmp___20);
          }
#line 8011
          return (0);
        }
#line 8014
        dynamic_syminfo_nent = (unsigned int )(syminsz / sizeof(Elf_External_Syminfo ));
#line 8015
        syminfo = dynamic_syminfo;
#line 8015
        extsym = extsyminfo;
        {
#line 8015
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 8015
          if (! ((unsigned long )syminfo < (unsigned long )(dynamic_syminfo + dynamic_syminfo_nent))) {
#line 8015
            goto while_break___2;
          }
          {
#line 8019
          tmp___21 = (*byte_get)(extsym->si_boundto, (int )sizeof(extsym->si_boundto));
#line 8019
          syminfo->si_boundto = (unsigned short )tmp___21;
#line 8020
          tmp___22 = (*byte_get)(extsym->si_flags, (int )sizeof(extsym->si_flags));
#line 8020
          syminfo->si_flags = (unsigned short )tmp___22;
#line 8015
          syminfo ++;
#line 8015
          extsym ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 8023
        free((void *)extsyminfo);
        }
      }
    }
  }
#line 8027
  if (do_dynamic) {
#line 8027
    if (dynamic_addr) {
      {
#line 8028
      tmp___23 = gettext("\nDynamic section at offset 0x%lx contains %u entries:\n");
#line 8028
      printf((char const   */* __restrict  */)tmp___23, dynamic_addr, dynamic_nent);
      }
    }
  }
#line 8030
  if (do_dynamic) {
    {
#line 8031
    tmp___24 = gettext("  Tag        Type                         Name/Value\n");
#line 8031
    printf((char const   */* __restrict  */)tmp___24);
    }
  }
#line 8033
  entry = dynamic_section;
  {
#line 8033
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 8033
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 8033
      goto while_break___3;
    }
#line 8037
    if (do_dynamic) {
      {
#line 8041
      putchar(' ');
#line 8042
      print_vma(entry->d_tag, (print_mode )5);
#line 8043
      dtype = get_dynamic_type(entry->d_tag);
      }
#line 8044
      if (is_32bit_elf) {
#line 8044
        tmp___25 = 27;
      } else {
#line 8044
        tmp___25 = 19;
      }
      {
#line 8044
      tmp___26 = strlen(dtype);
#line 8044
      printf((char const   */* __restrict  */)" (%s)%*s", dtype, tmp___25 - (int )tmp___26,
             " ");
      }
    }
    {
#line 8052
    if (entry->d_tag == 30UL) {
#line 8052
      goto case_30;
    }
#line 8061
    if (entry->d_tag == 1879047932UL) {
#line 8061
      goto case_1879047932;
    }
#line 8061
    if (entry->d_tag == 1879047931UL) {
#line 8061
      goto case_1879047932;
    }
#line 8061
    if (entry->d_tag == 1879047930UL) {
#line 8061
      goto case_1879047932;
    }
#line 8061
    if (entry->d_tag == 2147483647UL) {
#line 8061
      goto case_1879047932;
    }
#line 8061
    if (entry->d_tag == 2147483645UL) {
#line 8061
      goto case_1879047932;
    }
#line 8098
    if (entry->d_tag == 1879047676UL) {
#line 8098
      goto case_1879047676;
    }
#line 8126
    if (entry->d_tag == 1879047677UL) {
#line 8126
      goto case_1879047677;
    }
#line 8154
    if (entry->d_tag == 1879048187UL) {
#line 8154
      goto case_1879048187;
    }
#line 8301
    if (entry->d_tag == 20UL) {
#line 8301
      goto case_20;
    }
#line 8323
    if (entry->d_tag == 29UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 23UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 22UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 21UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 17UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 16UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 15UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 14UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 13UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 12UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 7UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 6UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 5UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 4UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 3UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 1UL) {
#line 8323
      goto case_29;
    }
#line 8323
    if (entry->d_tag == 0UL) {
#line 8323
      goto case_29;
    }
#line 8376
    if (entry->d_tag == 19UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 11UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 9UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 18UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 10UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 8UL) {
#line 8376
      goto case_19;
    }
#line 8376
    if (entry->d_tag == 2UL) {
#line 8376
      goto case_19;
    }
#line 8384
    if (entry->d_tag == 1879047671UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 1879047670UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 28UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 27UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 1879047675UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 1879047674UL) {
#line 8384
      goto case_1879047671;
    }
#line 8384
    if (entry->d_tag == 1879047673UL) {
#line 8384
      goto case_1879047671;
    }
#line 8395
    if (entry->d_tag == 1879048186UL) {
#line 8395
      goto case_1879048186;
    }
#line 8395
    if (entry->d_tag == 1879048185UL) {
#line 8395
      goto case_1879048186;
    }
#line 8395
    if (entry->d_tag == 1879048191UL) {
#line 8395
      goto case_1879048186;
    }
#line 8395
    if (entry->d_tag == 1879048189UL) {
#line 8395
      goto case_1879048186;
    }
#line 8408
    if (entry->d_tag == 26UL) {
#line 8408
      goto case_26;
    }
#line 8408
    if (entry->d_tag == 25UL) {
#line 8408
      goto case_26;
    }
#line 8408
    if (entry->d_tag == 2147483646UL) {
#line 8408
      goto case_26;
    }
#line 8408
    if (entry->d_tag == 1879047935UL) {
#line 8408
      goto case_26;
    }
#line 8408
    if (entry->d_tag == 1879047679UL) {
#line 8408
      goto case_26;
    }
#line 8408
    if (entry->d_tag == 1879047678UL) {
#line 8408
      goto case_26;
    }
#line 8428
    if (entry->d_tag == 24UL) {
#line 8428
      goto case_24;
    }
#line 8434
    if (entry->d_tag == 1879047669UL) {
#line 8434
      goto case_1879047669;
    }
#line 8448
    if (entry->d_tag == 1879047925UL) {
#line 8448
      goto case_1879047925;
    }
#line 8457
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 8053
    if (do_dynamic) {
      {
#line 8054
      print_dynamic_flags(entry->d_un.d_val);
      }
    }
#line 8055
    goto switch_break;
    case_1879047932: /* CIL Label */ 
    case_1879047931: /* CIL Label */ 
    case_1879047930: /* CIL Label */ 
    case_2147483647: /* CIL Label */ 
    case_2147483645: /* CIL Label */ 
#line 8062
    if (do_dynamic) {
      {
#line 8066
      if (entry->d_tag == 2147483645UL) {
#line 8066
        goto case_2147483645___0;
      }
#line 8070
      if (entry->d_tag == 2147483647UL) {
#line 8070
        goto case_2147483647___0;
      }
#line 8074
      if (entry->d_tag == 1879047930UL) {
#line 8074
        goto case_1879047930___0;
      }
#line 8078
      if (entry->d_tag == 1879047931UL) {
#line 8078
        goto case_1879047931___0;
      }
#line 8082
      if (entry->d_tag == 1879047932UL) {
#line 8082
        goto case_1879047932___0;
      }
#line 8064
      goto switch_break___0;
      case_2147483645___0: /* CIL Label */ 
      {
#line 8067
      tmp___27 = gettext("Auxiliary library");
#line 8067
      printf((char const   */* __restrict  */)tmp___27);
      }
#line 8068
      goto switch_break___0;
      case_2147483647___0: /* CIL Label */ 
      {
#line 8071
      tmp___28 = gettext("Filter library");
#line 8071
      printf((char const   */* __restrict  */)tmp___28);
      }
#line 8072
      goto switch_break___0;
      case_1879047930___0: /* CIL Label */ 
      {
#line 8075
      tmp___29 = gettext("Configuration file");
#line 8075
      printf((char const   */* __restrict  */)tmp___29);
      }
#line 8076
      goto switch_break___0;
      case_1879047931___0: /* CIL Label */ 
      {
#line 8079
      tmp___30 = gettext("Dependency audit library");
#line 8079
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 8080
      goto switch_break___0;
      case_1879047932___0: /* CIL Label */ 
      {
#line 8083
      tmp___31 = gettext("Audit library");
#line 8083
      printf((char const   */* __restrict  */)tmp___31);
      }
#line 8084
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 8087
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8087
        if (entry->d_un.d_val < dynamic_strings_length) {
          {
#line 8088
          printf((char const   */* __restrict  */)": [%s]\n", dynamic_strings + entry->d_un.d_val);
          }
        } else {
          {
#line 8091
          printf((char const   */* __restrict  */)": ");
#line 8092
          print_vma(entry->d_un.d_val, (print_mode )4);
#line 8093
          putchar('\n');
          }
        }
      } else {
        {
#line 8091
        printf((char const   */* __restrict  */)": ");
#line 8092
        print_vma(entry->d_un.d_val, (print_mode )4);
#line 8093
        putchar('\n');
        }
      }
    }
#line 8096
    goto switch_break;
    case_1879047676: /* CIL Label */ 
#line 8099
    if (do_dynamic) {
      {
#line 8101
      tmp___32 = gettext("Flags:");
#line 8101
      printf((char const   */* __restrict  */)tmp___32);
      }
#line 8103
      if (entry->d_un.d_val == 0UL) {
        {
#line 8104
        tmp___33 = gettext(" None\n");
#line 8104
        printf((char const   */* __restrict  */)tmp___33);
        }
      } else {
#line 8107
        val = entry->d_un.d_val;
#line 8109
        if (val & 1UL) {
          {
#line 8111
          printf((char const   */* __restrict  */)" PARINIT");
#line 8112
          val ^= 1UL;
          }
        }
#line 8114
        if (val & 2UL) {
          {
#line 8116
          printf((char const   */* __restrict  */)" CONFEXP");
#line 8117
          val ^= 2UL;
          }
        }
#line 8119
        if (val != 0UL) {
          {
#line 8120
          printf((char const   */* __restrict  */)" %lx", val);
          }
        }
        {
#line 8121
        puts("");
        }
      }
    }
#line 8124
    goto switch_break;
    case_1879047677: /* CIL Label */ 
#line 8127
    if (do_dynamic) {
      {
#line 8129
      tmp___34 = gettext("Flags:");
#line 8129
      printf((char const   */* __restrict  */)tmp___34);
      }
#line 8131
      if (entry->d_un.d_val == 0UL) {
        {
#line 8132
        tmp___35 = gettext(" None\n");
#line 8132
        printf((char const   */* __restrict  */)tmp___35);
        }
      } else {
#line 8135
        val___0 = entry->d_un.d_val;
#line 8137
        if (val___0 & 1UL) {
          {
#line 8139
          printf((char const   */* __restrict  */)" LAZYLOAD");
#line 8140
          val___0 ^= 1UL;
          }
        }
#line 8142
        if (val___0 & 2UL) {
          {
#line 8144
          printf((char const   */* __restrict  */)" GROUPPERM");
#line 8145
          val___0 ^= 2UL;
          }
        }
#line 8147
        if (val___0 != 0UL) {
          {
#line 8148
          printf((char const   */* __restrict  */)" %lx", val___0);
          }
        }
        {
#line 8149
        puts("");
        }
      }
    }
#line 8152
    goto switch_break;
    case_1879048187: /* CIL Label */ 
#line 8155
    if (do_dynamic) {
      {
#line 8157
      tmp___36 = gettext("Flags:");
#line 8157
      printf((char const   */* __restrict  */)tmp___36);
      }
#line 8158
      if (entry->d_un.d_val == 0UL) {
        {
#line 8159
        tmp___37 = gettext(" None\n");
#line 8159
        printf((char const   */* __restrict  */)tmp___37);
        }
      } else {
#line 8162
        val___1 = entry->d_un.d_val;
#line 8164
        if (val___1 & 1UL) {
          {
#line 8166
          printf((char const   */* __restrict  */)" NOW");
#line 8167
          val___1 ^= 1UL;
          }
        }
#line 8169
        if (val___1 & 2UL) {
          {
#line 8171
          printf((char const   */* __restrict  */)" GLOBAL");
#line 8172
          val___1 ^= 2UL;
          }
        }
#line 8174
        if (val___1 & 4UL) {
          {
#line 8176
          printf((char const   */* __restrict  */)" GROUP");
#line 8177
          val___1 ^= 4UL;
          }
        }
#line 8179
        if (val___1 & 8UL) {
          {
#line 8181
          printf((char const   */* __restrict  */)" NODELETE");
#line 8182
          val___1 ^= 8UL;
          }
        }
#line 8184
        if (val___1 & 16UL) {
          {
#line 8186
          printf((char const   */* __restrict  */)" LOADFLTR");
#line 8187
          val___1 ^= 16UL;
          }
        }
#line 8189
        if (val___1 & 32UL) {
          {
#line 8191
          printf((char const   */* __restrict  */)" INITFIRST");
#line 8192
          val___1 ^= 32UL;
          }
        }
#line 8194
        if (val___1 & 64UL) {
          {
#line 8196
          printf((char const   */* __restrict  */)" NOOPEN");
#line 8197
          val___1 ^= 64UL;
          }
        }
#line 8199
        if (val___1 & 128UL) {
          {
#line 8201
          printf((char const   */* __restrict  */)" ORIGIN");
#line 8202
          val___1 ^= 128UL;
          }
        }
#line 8204
        if (val___1 & 256UL) {
          {
#line 8206
          printf((char const   */* __restrict  */)" DIRECT");
#line 8207
          val___1 ^= 256UL;
          }
        }
#line 8209
        if (val___1 & 512UL) {
          {
#line 8211
          printf((char const   */* __restrict  */)" TRANS");
#line 8212
          val___1 ^= 512UL;
          }
        }
#line 8214
        if (val___1 & 1024UL) {
          {
#line 8216
          printf((char const   */* __restrict  */)" INTERPOSE");
#line 8217
          val___1 ^= 1024UL;
          }
        }
#line 8219
        if (val___1 & 2048UL) {
          {
#line 8221
          printf((char const   */* __restrict  */)" NODEFLIB");
#line 8222
          val___1 ^= 2048UL;
          }
        }
#line 8224
        if (val___1 & 4096UL) {
          {
#line 8226
          printf((char const   */* __restrict  */)" NODUMP");
#line 8227
          val___1 ^= 4096UL;
          }
        }
#line 8229
        if (val___1 & 8192UL) {
          {
#line 8231
          printf((char const   */* __restrict  */)" CONFALT");
#line 8232
          val___1 ^= 8192UL;
          }
        }
#line 8234
        if (val___1 & 16384UL) {
          {
#line 8236
          printf((char const   */* __restrict  */)" ENDFILTEE");
#line 8237
          val___1 ^= 16384UL;
          }
        }
#line 8239
        if (val___1 & 32768UL) {
          {
#line 8241
          printf((char const   */* __restrict  */)" DISPRELDNE");
#line 8242
          val___1 ^= 32768UL;
          }
        }
#line 8244
        if (val___1 & 65536UL) {
          {
#line 8246
          printf((char const   */* __restrict  */)" DISPRELPND");
#line 8247
          val___1 ^= 65536UL;
          }
        }
#line 8249
        if (val___1 & 131072UL) {
          {
#line 8251
          printf((char const   */* __restrict  */)" NODIRECT");
#line 8252
          val___1 ^= 131072UL;
          }
        }
#line 8254
        if (val___1 & 262144UL) {
          {
#line 8256
          printf((char const   */* __restrict  */)" IGNMULDEF");
#line 8257
          val___1 ^= 262144UL;
          }
        }
#line 8259
        if (val___1 & 524288UL) {
          {
#line 8261
          printf((char const   */* __restrict  */)" NOKSYMS");
#line 8262
          val___1 ^= 524288UL;
          }
        }
#line 8264
        if (val___1 & 1048576UL) {
          {
#line 8266
          printf((char const   */* __restrict  */)" NOHDR");
#line 8267
          val___1 ^= 1048576UL;
          }
        }
#line 8269
        if (val___1 & 2097152UL) {
          {
#line 8271
          printf((char const   */* __restrict  */)" EDITED");
#line 8272
          val___1 ^= 2097152UL;
          }
        }
#line 8274
        if (val___1 & 4194304UL) {
          {
#line 8276
          printf((char const   */* __restrict  */)" NORELOC");
#line 8277
          val___1 ^= 4194304UL;
          }
        }
#line 8279
        if (val___1 & 8388608UL) {
          {
#line 8281
          printf((char const   */* __restrict  */)" SYMINTPOSE");
#line 8282
          val___1 ^= 8388608UL;
          }
        }
#line 8284
        if (val___1 & 16777216UL) {
          {
#line 8286
          printf((char const   */* __restrict  */)" GLOBAUDIT");
#line 8287
          val___1 ^= 16777216UL;
          }
        }
#line 8289
        if (val___1 & 33554432UL) {
          {
#line 8291
          printf((char const   */* __restrict  */)" SINGLETON");
#line 8292
          val___1 ^= 33554432UL;
          }
        }
#line 8294
        if (val___1 != 0UL) {
          {
#line 8295
          printf((char const   */* __restrict  */)" %lx", val___1);
          }
        }
        {
#line 8296
        puts("");
        }
      }
    }
#line 8299
    goto switch_break;
    case_20: /* CIL Label */ 
#line 8302
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
#line 8303
    if (do_dynamic) {
      {
#line 8304
      tmp___38 = get_dynamic_type(entry->d_un.d_val);
#line 8304
      puts(tmp___38);
      }
    }
#line 8305
    goto switch_break;
    case_29: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 8324
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
#line 8326
    if (do_dynamic) {
#line 8330
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8330
        if (entry->d_un.d_val < dynamic_strings_length) {
#line 8331
          name___0 = dynamic_strings + entry->d_un.d_val;
        } else {
#line 8333
          name___0 = (char *)((void *)0);
        }
      } else {
#line 8333
        name___0 = (char *)((void *)0);
      }
#line 8335
      if (name___0) {
        {
#line 8339
        if (entry->d_tag == 1UL) {
#line 8339
          goto case_1___0;
        }
#line 8346
        if (entry->d_tag == 14UL) {
#line 8346
          goto case_14___0;
        }
#line 8350
        if (entry->d_tag == 15UL) {
#line 8350
          goto case_15___0;
        }
#line 8354
        if (entry->d_tag == 29UL) {
#line 8354
          goto case_29___0;
        }
#line 8358
        goto switch_default;
        case_1___0: /* CIL Label */ 
        {
#line 8340
        tmp___39 = gettext("Shared library: [%s]");
#line 8340
        printf((char const   */* __restrict  */)tmp___39, name___0);
#line 8342
        tmp___41 = strcmp((char const   *)name___0, (char const   *)(program_interpreter));
        }
#line 8342
        if (tmp___41 == 0) {
          {
#line 8343
          tmp___40 = gettext(" program interpreter");
#line 8343
          printf((char const   */* __restrict  */)tmp___40);
          }
        }
#line 8344
        goto switch_break___1;
        case_14___0: /* CIL Label */ 
        {
#line 8347
        tmp___42 = gettext("Library soname: [%s]");
#line 8347
        printf((char const   */* __restrict  */)tmp___42, name___0);
        }
#line 8348
        goto switch_break___1;
        case_15___0: /* CIL Label */ 
        {
#line 8351
        tmp___43 = gettext("Library rpath: [%s]");
#line 8351
        printf((char const   */* __restrict  */)tmp___43, name___0);
        }
#line 8352
        goto switch_break___1;
        case_29___0: /* CIL Label */ 
        {
#line 8355
        tmp___44 = gettext("Library runpath: [%s]");
#line 8355
        printf((char const   */* __restrict  */)tmp___44, name___0);
        }
#line 8356
        goto switch_break___1;
        switch_default: /* CIL Label */ 
        {
#line 8359
        print_vma(entry->d_un.d_val, (print_mode )4);
        }
#line 8360
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 8364
        print_vma(entry->d_un.d_val, (print_mode )4);
        }
      }
      {
#line 8366
      putchar('\n');
      }
    }
#line 8368
    goto switch_break;
    case_19: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 8377
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
    case_1879047671: /* CIL Label */ 
    case_1879047670: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_1879047675: /* CIL Label */ 
    case_1879047674: /* CIL Label */ 
    case_1879047673: /* CIL Label */ 
#line 8385
    if (do_dynamic) {
      {
#line 8387
      print_vma(entry->d_un.d_val, (print_mode )3);
#line 8388
      tmp___45 = gettext(" (bytes)\n");
#line 8388
      printf((char const   */* __restrict  */)tmp___45);
      }
    }
#line 8390
    goto switch_break;
    case_1879048186: /* CIL Label */ 
    case_1879048185: /* CIL Label */ 
    case_1879048191: /* CIL Label */ 
    case_1879048189: /* CIL Label */ 
#line 8396
    if (do_dynamic) {
      {
#line 8398
      print_vma(entry->d_un.d_val, (print_mode )3);
#line 8399
      putchar('\n');
      }
    }
#line 8401
    goto switch_break;
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_2147483646: /* CIL Label */ 
    case_1879047935: /* CIL Label */ 
    case_1879047679: /* CIL Label */ 
    case_1879047678: /* CIL Label */ 
#line 8409
    if (do_dynamic) {
#line 8411
      if (entry->d_tag == 2147483646UL) {
#line 8411
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8411
          if (entry->d_un.d_val < dynamic_strings_length) {
#line 8414
            name___1 = dynamic_strings + entry->d_un.d_val;
#line 8416
            if (*name___1) {
              {
#line 8418
              tmp___46 = gettext("Not needed object: [%s]\n");
#line 8418
              printf((char const   */* __restrict  */)tmp___46, name___1);
              }
#line 8419
              goto switch_break;
            }
          }
        }
      }
      {
#line 8423
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8424
      putchar('\n');
      }
    }
#line 8426
    goto switch_break;
    case_24: /* CIL Label */ 
#line 8430
    if (do_dynamic) {
      {
#line 8431
      putchar('\n');
      }
    }
#line 8432
    goto switch_break;
    case_1879047669: /* CIL Label */ 
#line 8435
    if (do_dynamic) {
      {
#line 8438
      atime = (time_t )entry->d_un.d_val;
#line 8440
      tmp___47 = gmtime((time_t const   *)(& atime));
#line 8441
      printf((char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u\n", tmp___47->tm_year + 1900,
             tmp___47->tm_mon + 1, tmp___47->tm_mday, tmp___47->tm_hour, tmp___47->tm_min,
             tmp___47->tm_sec);
      }
    }
#line 8446
    goto switch_break;
    case_1879047925: /* CIL Label */ 
#line 8449
    dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
#line 8450
    if (do_dynamic) {
      {
#line 8452
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8453
      putchar('\n');
      }
    }
#line 8455
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 8458
    if (entry->d_tag >= 1879048176UL) {
#line 8458
      if (entry->d_tag <= 1879048191UL) {
#line 8459
        version_info[1879048191UL - entry->d_tag] = entry->d_un.d_val;
      }
    }
#line 8462
    if (do_dynamic) {
      {
#line 8467
      if ((int )elf_header.e_machine == 10) {
#line 8467
        goto case_10___0;
      }
#line 8467
      if ((int )elf_header.e_machine == 8) {
#line 8467
        goto case_10___0;
      }
#line 8470
      if ((int )elf_header.e_machine == 15) {
#line 8470
        goto case_15___1;
      }
#line 8473
      if ((int )elf_header.e_machine == 50) {
#line 8473
        goto case_50;
      }
#line 8476
      goto switch_default___1;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 8468
      dynamic_section_mips_val(entry);
      }
#line 8469
      goto switch_break___2;
      case_15___1: /* CIL Label */ 
      {
#line 8471
      dynamic_section_parisc_val(entry);
      }
#line 8472
      goto switch_break___2;
      case_50: /* CIL Label */ 
      {
#line 8474
      dynamic_section_ia64_val(entry);
      }
#line 8475
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 8477
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8478
      putchar('\n');
      }
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 8481
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 8033
    entry ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 8485
  return (1);
}
}
#line 8491 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___9[32]  ;
#line 8488 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *get_ver_flags(unsigned int flags___1 ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 8493
  buff___9[0] = (char)0;
#line 8495
  if (flags___1 == 0U) {
    {
#line 8496
    tmp___0 = gettext("none");
    }
#line 8496
    return (tmp___0);
  }
#line 8498
  if (flags___1 & 1U) {
    {
#line 8499
    strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)"BASE ");
    }
  }
#line 8501
  if (flags___1 & 2U) {
#line 8503
    if (flags___1 & 1U) {
      {
#line 8504
      strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)"| ");
      }
    }
    {
#line 8506
    strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)"WEAK ");
    }
  }
#line 8509
  if (flags___1 & 4U) {
#line 8511
    if (flags___1 & 3U) {
      {
#line 8512
      strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)"| ");
      }
    }
    {
#line 8514
    strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)"INFO ");
    }
  }
#line 8517
  if (flags___1 & 4294967288U) {
    {
#line 8518
    tmp___1 = gettext("| <unknown>");
#line 8518
    strcat((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)tmp___1);
    }
  }
#line 8520
  return (buff___9);
}
}
#line 8525 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_version_sections(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  int found ;
  Elf_External_Verdef *edefs ;
  unsigned int idx___0 ;
  unsigned int cnt ;
  char *endbuf ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  char *vstart ;
  Elf_External_Verdef *edef ;
  Elf_Internal_Verdef ent ;
  Elf_External_Verdaux *eaux ;
  Elf_Internal_Verdaux aux ;
  int j ;
  int isum ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  elf_vma tmp___23 ;
  elf_vma tmp___24 ;
  elf_vma tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  elf_vma tmp___29 ;
  elf_vma tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  elf_vma tmp___33 ;
  elf_vma tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  Elf_External_Verneed *eneed ;
  unsigned int idx___1 ;
  unsigned int cnt___0 ;
  char *endbuf___0 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  void *tmp___57 ;
  Elf_External_Verneed *entry ;
  Elf_Internal_Verneed ent___0 ;
  int j___0 ;
  int isum___0 ;
  char *vstart___0 ;
  elf_vma tmp___58 ;
  elf_vma tmp___59 ;
  elf_vma tmp___60 ;
  elf_vma tmp___61 ;
  elf_vma tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  Elf_External_Vernaux *eaux___0 ;
  Elf_Internal_Vernaux aux___0 ;
  elf_vma tmp___67 ;
  elf_vma tmp___68 ;
  elf_vma tmp___69 ;
  elf_vma tmp___70 ;
  elf_vma tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  Elf_Internal_Shdr *link_section ;
  int total ;
  int cnt___1 ;
  unsigned char *edata ;
  unsigned short *data ;
  char *strtab ;
  Elf_Internal_Sym *symbols ;
  Elf_Internal_Shdr *string_sec ;
  unsigned long num_syms ;
  long off ;
  Elf_Internal_Sym *tmp___78 ;
  Elf_Internal_Sym *tmp___79 ;
  char *tmp___80 ;
  void *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  void *tmp___98 ;
  void *tmp___99 ;
  elf_vma tmp___100 ;
  int tmp___101 ;
  int j___1 ;
  int nn ;
  int check_def ;
  int check_need ;
  char *name___0 ;
  char *tmp___102 ;
  char *tmp___103 ;
  int tmp___104 ;
  char *tmp___105 ;
  Elf_Internal_Verneed ivn ;
  unsigned long offset ;
  long tmp___106 ;
  Elf_Internal_Vernaux ivna ;
  Elf_External_Verneed evn ;
  Elf_External_Vernaux evna ;
  unsigned long a_off ;
  char *tmp___107 ;
  void *tmp___108 ;
  elf_vma tmp___109 ;
  elf_vma tmp___110 ;
  elf_vma tmp___111 ;
  elf_vma tmp___112 ;
  char *tmp___113 ;
  void *tmp___114 ;
  elf_vma tmp___115 ;
  size_t tmp___116 ;
  int tmp___117 ;
  Elf_Internal_Verdef ivd ;
  Elf_External_Verdef evd ;
  unsigned long offset___0 ;
  long tmp___118 ;
  elf_vma tmp___119 ;
  elf_vma tmp___120 ;
  char *tmp___121 ;
  void *tmp___122 ;
  Elf_External_Verdaux evda ;
  Elf_Internal_Verdaux ivda ;
  elf_vma tmp___123 ;
  char *tmp___124 ;
  void *tmp___125 ;
  elf_vma tmp___126 ;
  size_t tmp___127 ;
  int tmp___128 ;
  char *tmp___129 ;

  {
#line 8530
  found = 0;
#line 8532
  if (! do_version) {
#line 8533
    return (1);
  }
#line 8535
  i = 0U;
#line 8535
  section = section_headers;
  {
#line 8535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8535
    if (! (i < elf_header.e_shnum)) {
#line 8535
      goto while_break;
    }
    {
#line 8541
    if (section->sh_type == 1879048189U) {
#line 8541
      goto case_1879048189;
    }
#line 8658
    if (section->sh_type == 1879048190U) {
#line 8658
      goto case_1879048190;
    }
#line 8770
    if (section->sh_type == 1879048191U) {
#line 8770
      goto case_1879048191;
    }
#line 9017
    goto switch_default___0;
    case_1879048189: /* CIL Label */ 
#line 8548
    found = 1;
#line 8550
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8550
      tmp___0 = gettext("<none>");
#line 8550
      tmp___5 = tmp___0;
      }
    } else {
#line 8550
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8550
        tmp___1 = gettext("<no-name>");
#line 8550
        tmp___4 = tmp___1;
        }
      } else {
#line 8550
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8550
          tmp___2 = gettext("<corrupt>");
#line 8550
          tmp___3 = tmp___2;
          }
        } else {
#line 8550
          tmp___3 = string_table + section->sh_name;
        }
#line 8550
        tmp___4 = tmp___3;
      }
#line 8550
      tmp___5 = tmp___4;
    }
    {
#line 8550
    tmp___6 = gettext("\nVersion definition section \'%s\' contains %u entries:\n");
#line 8550
    printf((char const   */* __restrict  */)tmp___6, tmp___5, section->sh_info);
#line 8554
    tmp___7 = gettext("  Addr: 0x");
#line 8554
    printf((char const   */* __restrict  */)tmp___7);
#line 8555
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8556
    if (section->sh_link < elf_header.e_shnum) {
#line 8556
      if ((unsigned long )(section_headers + section->sh_link) == (unsigned long )((void *)0)) {
        {
#line 8556
        tmp___8 = gettext("<none>");
#line 8556
        tmp___13 = tmp___8;
        }
      } else {
#line 8556
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 8556
          tmp___9 = gettext("<no-name>");
#line 8556
          tmp___12 = tmp___9;
          }
        } else {
#line 8556
          if ((unsigned long )(section_headers + section->sh_link)->sh_name >= string_table_length) {
            {
#line 8556
            tmp___10 = gettext("<corrupt>");
#line 8556
            tmp___11 = tmp___10;
            }
          } else {
#line 8556
            tmp___11 = string_table + (section_headers + section->sh_link)->sh_name;
          }
#line 8556
          tmp___12 = tmp___11;
        }
#line 8556
        tmp___13 = tmp___12;
      }
#line 8556
      tmp___15 = tmp___13;
    } else {
      {
#line 8556
      tmp___14 = gettext("<corrupt>");
#line 8556
      tmp___15 = tmp___14;
      }
    }
    {
#line 8556
    tmp___16 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8556
    printf((char const   */* __restrict  */)tmp___16, (unsigned long )section->sh_offset,
           section->sh_link, tmp___15);
#line 8562
    tmp___17 = gettext("version definition section");
#line 8562
    tmp___18 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                        (char const   *)tmp___17);
#line 8562
    edefs = (Elf_External_Verdef *)tmp___18;
    }
#line 8565
    if (! edefs) {
#line 8566
      goto switch_break;
    }
#line 8567
    endbuf = (char *)edefs + section->sh_size;
#line 8569
    cnt = 0U;
#line 8569
    idx___0 = cnt;
    {
#line 8569
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8569
      if (! (cnt < section->sh_info)) {
#line 8569
        goto while_break___0;
      }
#line 8580
      if ((size_t )idx___0 > (size_t )(endbuf - (char *)edefs)) {
#line 8581
        goto while_break___0;
      }
#line 8583
      vstart = (char *)edefs + idx___0;
#line 8584
      if ((unsigned long )(vstart + sizeof(*edef)) > (unsigned long )endbuf) {
#line 8585
        goto while_break___0;
      }
      {
#line 8587
      edef = (Elf_External_Verdef *)vstart;
#line 8589
      tmp___19 = (*byte_get)(edef->vd_version, (int )sizeof(edef->vd_version));
#line 8589
      ent.vd_version = (unsigned short )tmp___19;
#line 8590
      tmp___20 = (*byte_get)(edef->vd_flags, (int )sizeof(edef->vd_flags));
#line 8590
      ent.vd_flags = (unsigned short )tmp___20;
#line 8591
      tmp___21 = (*byte_get)(edef->vd_ndx, (int )sizeof(edef->vd_ndx));
#line 8591
      ent.vd_ndx = (unsigned short )tmp___21;
#line 8592
      tmp___22 = (*byte_get)(edef->vd_cnt, (int )sizeof(edef->vd_cnt));
#line 8592
      ent.vd_cnt = (unsigned short )tmp___22;
#line 8593
      tmp___23 = (*byte_get)(edef->vd_hash, (int )sizeof(edef->vd_hash));
#line 8593
      ent.vd_hash = (unsigned long )tmp___23;
#line 8594
      tmp___24 = (*byte_get)(edef->vd_aux, (int )sizeof(edef->vd_aux));
#line 8594
      ent.vd_aux = (unsigned long )tmp___24;
#line 8595
      tmp___25 = (*byte_get)(edef->vd_next, (int )sizeof(edef->vd_next));
#line 8595
      ent.vd_next = (unsigned long )tmp___25;
#line 8597
      tmp___26 = get_ver_flags((unsigned int )ent.vd_flags);
#line 8597
      tmp___27 = gettext("  %#06x: Rev: %d  Flags: %s");
#line 8597
      printf((char const   */* __restrict  */)tmp___27, idx___0, (int )ent.vd_version,
             tmp___26);
#line 8600
      tmp___28 = gettext("  Index: %d  Cnt: %d  ");
#line 8600
      printf((char const   */* __restrict  */)tmp___28, (int )ent.vd_ndx, (int )ent.vd_cnt);
      }
#line 8604
      if (ent.vd_aux > (size_t )(endbuf - vstart)) {
#line 8605
        goto while_break___0;
      }
      {
#line 8607
      vstart += ent.vd_aux;
#line 8609
      eaux = (Elf_External_Verdaux *)vstart;
#line 8611
      tmp___29 = (*byte_get)(eaux->vda_name, (int )sizeof(eaux->vda_name));
#line 8611
      aux.vda_name = (unsigned long )tmp___29;
#line 8612
      tmp___30 = (*byte_get)(eaux->vda_next, (int )sizeof(eaux->vda_next));
#line 8612
      aux.vda_next = (unsigned long )tmp___30;
      }
#line 8614
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8614
        if (aux.vda_name < dynamic_strings_length) {
          {
#line 8615
          tmp___31 = gettext("Name: %s\n");
#line 8615
          printf((char const   */* __restrict  */)tmp___31, dynamic_strings + aux.vda_name);
          }
        } else {
          {
#line 8617
          tmp___32 = gettext("Name index: %ld\n");
#line 8617
          printf((char const   */* __restrict  */)tmp___32, aux.vda_name);
          }
        }
      } else {
        {
#line 8617
        tmp___32 = gettext("Name index: %ld\n");
#line 8617
        printf((char const   */* __restrict  */)tmp___32, aux.vda_name);
        }
      }
#line 8619
      isum = (int )((unsigned long )idx___0 + ent.vd_aux);
#line 8621
      j = 1;
      {
#line 8621
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 8621
        if (! (j < (int )ent.vd_cnt)) {
#line 8621
          goto while_break___1;
        }
#line 8624
        if (aux.vda_next > (size_t )(endbuf - vstart)) {
#line 8625
          goto while_break___1;
        }
#line 8627
        isum = (int )((unsigned long )isum + aux.vda_next);
#line 8628
        vstart += aux.vda_next;
#line 8630
        eaux = (Elf_External_Verdaux *)vstart;
#line 8631
        if ((unsigned long )(vstart + sizeof(*eaux)) > (unsigned long )endbuf) {
#line 8632
          goto while_break___1;
        }
        {
#line 8634
        tmp___33 = (*byte_get)(eaux->vda_name, (int )sizeof(eaux->vda_name));
#line 8634
        aux.vda_name = (unsigned long )tmp___33;
#line 8635
        tmp___34 = (*byte_get)(eaux->vda_next, (int )sizeof(eaux->vda_next));
#line 8635
        aux.vda_next = (unsigned long )tmp___34;
        }
#line 8637
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8637
          if (aux.vda_name < dynamic_strings_length) {
            {
#line 8638
            tmp___35 = gettext("  %#06x: Parent %d: %s\n");
#line 8638
            printf((char const   */* __restrict  */)tmp___35, isum, j, dynamic_strings + aux.vda_name);
            }
          } else {
            {
#line 8641
            tmp___36 = gettext("  %#06x: Parent %d, name index: %ld\n");
#line 8641
            printf((char const   */* __restrict  */)tmp___36, isum, j, aux.vda_name);
            }
          }
        } else {
          {
#line 8641
          tmp___36 = gettext("  %#06x: Parent %d, name index: %ld\n");
#line 8641
          printf((char const   */* __restrict  */)tmp___36, isum, j, aux.vda_name);
          }
        }
#line 8621
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 8645
      if (j < (int )ent.vd_cnt) {
        {
#line 8646
        tmp___37 = gettext("  Version def aux past end of section\n");
#line 8646
        printf((char const   */* __restrict  */)tmp___37);
        }
      }
#line 8648
      idx___0 = (unsigned int )((unsigned long )idx___0 + ent.vd_next);
#line 8569
      cnt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 8651
    if (cnt < section->sh_info) {
      {
#line 8652
      tmp___38 = gettext("  Version definition past end of section\n");
#line 8652
      printf((char const   */* __restrict  */)tmp___38);
      }
    }
    {
#line 8654
    free((void *)edefs);
    }
#line 8656
    goto switch_break;
    case_1879048190: /* CIL Label */ 
#line 8665
    found = 1;
#line 8667
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8667
      tmp___39 = gettext("<none>");
#line 8667
      tmp___44 = tmp___39;
      }
    } else {
#line 8667
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8667
        tmp___40 = gettext("<no-name>");
#line 8667
        tmp___43 = tmp___40;
        }
      } else {
#line 8667
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8667
          tmp___41 = gettext("<corrupt>");
#line 8667
          tmp___42 = tmp___41;
          }
        } else {
#line 8667
          tmp___42 = string_table + section->sh_name;
        }
#line 8667
        tmp___43 = tmp___42;
      }
#line 8667
      tmp___44 = tmp___43;
    }
    {
#line 8667
    tmp___45 = gettext("\nVersion needs section \'%s\' contains %u entries:\n");
#line 8667
    printf((char const   */* __restrict  */)tmp___45, tmp___44, section->sh_info);
#line 8670
    tmp___46 = gettext(" Addr: 0x");
#line 8670
    printf((char const   */* __restrict  */)tmp___46);
#line 8671
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8672
    if (section->sh_link < elf_header.e_shnum) {
#line 8672
      if ((unsigned long )(section_headers + section->sh_link) == (unsigned long )((void *)0)) {
        {
#line 8672
        tmp___47 = gettext("<none>");
#line 8672
        tmp___52 = tmp___47;
        }
      } else {
#line 8672
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 8672
          tmp___48 = gettext("<no-name>");
#line 8672
          tmp___51 = tmp___48;
          }
        } else {
#line 8672
          if ((unsigned long )(section_headers + section->sh_link)->sh_name >= string_table_length) {
            {
#line 8672
            tmp___49 = gettext("<corrupt>");
#line 8672
            tmp___50 = tmp___49;
            }
          } else {
#line 8672
            tmp___50 = string_table + (section_headers + section->sh_link)->sh_name;
          }
#line 8672
          tmp___51 = tmp___50;
        }
#line 8672
        tmp___52 = tmp___51;
      }
#line 8672
      tmp___54 = tmp___52;
    } else {
      {
#line 8672
      tmp___53 = gettext("<corrupt>");
#line 8672
      tmp___54 = tmp___53;
      }
    }
    {
#line 8672
    tmp___55 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8672
    printf((char const   */* __restrict  */)tmp___55, (unsigned long )section->sh_offset,
           section->sh_link, tmp___54);
#line 8678
    tmp___56 = gettext("Version Needs section");
#line 8678
    tmp___57 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                        (char const   *)tmp___56);
#line 8678
    eneed = (Elf_External_Verneed *)tmp___57;
    }
#line 8682
    if (! eneed) {
#line 8683
      goto switch_break;
    }
#line 8684
    endbuf___0 = (char *)eneed + section->sh_size;
#line 8686
    cnt___0 = 0U;
#line 8686
    idx___1 = cnt___0;
    {
#line 8686
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 8686
      if (! (cnt___0 < section->sh_info)) {
#line 8686
        goto while_break___2;
      }
#line 8694
      if ((size_t )idx___1 > (size_t )(endbuf___0 - (char *)eneed)) {
#line 8695
        goto while_break___2;
      }
#line 8697
      vstart___0 = (char *)eneed + idx___1;
#line 8698
      if ((unsigned long )(vstart___0 + sizeof(*entry)) > (unsigned long )endbuf___0) {
#line 8699
        goto while_break___2;
      }
      {
#line 8701
      entry = (Elf_External_Verneed *)vstart___0;
#line 8703
      tmp___58 = (*byte_get)(entry->vn_version, (int )sizeof(entry->vn_version));
#line 8703
      ent___0.vn_version = (unsigned short )tmp___58;
#line 8704
      tmp___59 = (*byte_get)(entry->vn_cnt, (int )sizeof(entry->vn_cnt));
#line 8704
      ent___0.vn_cnt = (unsigned short )tmp___59;
#line 8705
      tmp___60 = (*byte_get)(entry->vn_file, (int )sizeof(entry->vn_file));
#line 8705
      ent___0.vn_file = (unsigned long )tmp___60;
#line 8706
      tmp___61 = (*byte_get)(entry->vn_aux, (int )sizeof(entry->vn_aux));
#line 8706
      ent___0.vn_aux = (unsigned long )tmp___61;
#line 8707
      tmp___62 = (*byte_get)(entry->vn_next, (int )sizeof(entry->vn_next));
#line 8707
      ent___0.vn_next = (unsigned long )tmp___62;
#line 8709
      tmp___63 = gettext("  %#06x: Version: %d");
#line 8709
      printf((char const   */* __restrict  */)tmp___63, idx___1, (int )ent___0.vn_version);
      }
#line 8711
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8711
        if (ent___0.vn_file < dynamic_strings_length) {
          {
#line 8712
          tmp___64 = gettext("  File: %s");
#line 8712
          printf((char const   */* __restrict  */)tmp___64, dynamic_strings + ent___0.vn_file);
          }
        } else {
          {
#line 8714
          tmp___65 = gettext("  File: %lx");
#line 8714
          printf((char const   */* __restrict  */)tmp___65, ent___0.vn_file);
          }
        }
      } else {
        {
#line 8714
        tmp___65 = gettext("  File: %lx");
#line 8714
        printf((char const   */* __restrict  */)tmp___65, ent___0.vn_file);
        }
      }
      {
#line 8716
      tmp___66 = gettext("  Cnt: %d\n");
#line 8716
      printf((char const   */* __restrict  */)tmp___66, (int )ent___0.vn_cnt);
      }
#line 8719
      if (ent___0.vn_aux > (size_t )(endbuf___0 - vstart___0)) {
#line 8720
        goto while_break___2;
      }
#line 8722
      vstart___0 += ent___0.vn_aux;
#line 8724
      j___0 = 0;
#line 8724
      isum___0 = (int )((unsigned long )idx___1 + ent___0.vn_aux);
      {
#line 8724
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 8724
        if (! (j___0 < (int )ent___0.vn_cnt)) {
#line 8724
          goto while_break___3;
        }
#line 8729
        if ((unsigned long )(vstart___0 + sizeof(*eaux___0)) > (unsigned long )endbuf___0) {
#line 8730
          goto while_break___3;
        }
        {
#line 8731
        eaux___0 = (Elf_External_Vernaux *)vstart___0;
#line 8733
        tmp___67 = (*byte_get)(eaux___0->vna_hash, (int )sizeof(eaux___0->vna_hash));
#line 8733
        aux___0.vna_hash = (unsigned long )tmp___67;
#line 8734
        tmp___68 = (*byte_get)(eaux___0->vna_flags, (int )sizeof(eaux___0->vna_flags));
#line 8734
        aux___0.vna_flags = (unsigned short )tmp___68;
#line 8735
        tmp___69 = (*byte_get)(eaux___0->vna_other, (int )sizeof(eaux___0->vna_other));
#line 8735
        aux___0.vna_other = (unsigned short )tmp___69;
#line 8736
        tmp___70 = (*byte_get)(eaux___0->vna_name, (int )sizeof(eaux___0->vna_name));
#line 8736
        aux___0.vna_name = (unsigned long )tmp___70;
#line 8737
        tmp___71 = (*byte_get)(eaux___0->vna_next, (int )sizeof(eaux___0->vna_next));
#line 8737
        aux___0.vna_next = (unsigned long )tmp___71;
        }
#line 8739
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8739
          if (aux___0.vna_name < dynamic_strings_length) {
            {
#line 8740
            tmp___72 = gettext("  %#06x:   Name: %s");
#line 8740
            printf((char const   */* __restrict  */)tmp___72, isum___0, dynamic_strings + aux___0.vna_name);
            }
          } else {
            {
#line 8743
            tmp___73 = gettext("  %#06x:   Name index: %lx");
#line 8743
            printf((char const   */* __restrict  */)tmp___73, isum___0, aux___0.vna_name);
            }
          }
        } else {
          {
#line 8743
          tmp___73 = gettext("  %#06x:   Name index: %lx");
#line 8743
          printf((char const   */* __restrict  */)tmp___73, isum___0, aux___0.vna_name);
          }
        }
        {
#line 8746
        tmp___74 = get_ver_flags((unsigned int )aux___0.vna_flags);
#line 8746
        tmp___75 = gettext("  Flags: %s  Version: %d\n");
#line 8746
        printf((char const   */* __restrict  */)tmp___75, tmp___74, (int )aux___0.vna_other);
        }
#line 8750
        if (aux___0.vna_next > (size_t )(endbuf___0 - vstart___0)) {
#line 8751
          goto while_break___3;
        }
#line 8753
        isum___0 = (int )((unsigned long )isum___0 + aux___0.vna_next);
#line 8754
        vstart___0 += aux___0.vna_next;
#line 8724
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 8757
      if (j___0 < (int )ent___0.vn_cnt) {
        {
#line 8758
        tmp___76 = gettext("Missing Version Needs auxillary information\n");
#line 8758
        warn((char const   *)tmp___76);
        }
      }
#line 8760
      idx___1 = (unsigned int )((unsigned long )idx___1 + ent___0.vn_next);
#line 8686
      cnt___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 8763
    if (cnt___0 < section->sh_info) {
      {
#line 8764
      tmp___77 = gettext("Missing Version Needs information\n");
#line 8764
      warn((char const   *)tmp___77);
      }
    }
    {
#line 8766
    free((void *)eneed);
    }
#line 8768
    goto switch_break;
    case_1879048191: /* CIL Label */ 
#line 8783
    if (section->sh_link >= elf_header.e_shnum) {
#line 8784
      goto switch_break;
    }
#line 8786
    link_section = section_headers + section->sh_link;
#line 8787
    total = (int )(section->sh_size / sizeof(Elf_External_Versym ));
#line 8789
    if (link_section->sh_link >= elf_header.e_shnum) {
#line 8790
      goto switch_break;
    }
#line 8792
    found = 1;
#line 8794
    if (is_32bit_elf) {
      {
#line 8794
      tmp___78 = get_32bit_elf_symbols(file, link_section, & num_syms);
#line 8794
      symbols = tmp___78;
      }
    } else {
      {
#line 8794
      tmp___79 = get_64bit_elf_symbols(file, link_section, & num_syms);
#line 8794
      symbols = tmp___79;
      }
    }
#line 8795
    if ((unsigned long )symbols == (unsigned long )((void *)0)) {
#line 8796
      goto switch_break;
    }
    {
#line 8798
    string_sec = section_headers + link_section->sh_link;
#line 8800
    tmp___80 = gettext("version string table");
#line 8800
    tmp___81 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1, string_sec->sh_size,
                        (char const   *)tmp___80);
#line 8800
    strtab = (char *)tmp___81;
    }
#line 8803
    if (! strtab) {
      {
#line 8805
      free((void *)symbols);
      }
#line 8806
      goto switch_break;
    }
#line 8809
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8809
      tmp___82 = gettext("<none>");
#line 8809
      tmp___87 = tmp___82;
      }
    } else {
#line 8809
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8809
        tmp___83 = gettext("<no-name>");
#line 8809
        tmp___86 = tmp___83;
        }
      } else {
#line 8809
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8809
          tmp___84 = gettext("<corrupt>");
#line 8809
          tmp___85 = tmp___84;
          }
        } else {
#line 8809
          tmp___85 = string_table + section->sh_name;
        }
#line 8809
        tmp___86 = tmp___85;
      }
#line 8809
      tmp___87 = tmp___86;
    }
    {
#line 8809
    tmp___88 = gettext("\nVersion symbols section \'%s\' contains %d entries:\n");
#line 8809
    printf((char const   */* __restrict  */)tmp___88, tmp___87, total);
#line 8812
    tmp___89 = gettext(" Addr: ");
#line 8812
    printf((char const   */* __restrict  */)tmp___89);
#line 8813
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8814
    if ((unsigned long )link_section == (unsigned long )((void *)0)) {
      {
#line 8814
      tmp___90 = gettext("<none>");
#line 8814
      tmp___95 = tmp___90;
      }
    } else {
#line 8814
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8814
        tmp___91 = gettext("<no-name>");
#line 8814
        tmp___94 = tmp___91;
        }
      } else {
#line 8814
        if ((unsigned long )link_section->sh_name >= string_table_length) {
          {
#line 8814
          tmp___92 = gettext("<corrupt>");
#line 8814
          tmp___93 = tmp___92;
          }
        } else {
#line 8814
          tmp___93 = string_table + link_section->sh_name;
        }
#line 8814
        tmp___94 = tmp___93;
      }
#line 8814
      tmp___95 = tmp___94;
    }
    {
#line 8814
    tmp___96 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8814
    printf((char const   */* __restrict  */)tmp___96, (unsigned long )section->sh_offset,
           section->sh_link, tmp___95);
#line 8818
    off = offset_from_vma(file, version_info[15], (unsigned long )total * sizeof(short ));
#line 8821
    tmp___97 = gettext("version symbol data");
#line 8821
    tmp___98 = get_data((void *)0, file, off, (size_t )total, sizeof(short ), (char const   *)tmp___97);
#line 8821
    edata = (unsigned char *)tmp___98;
    }
#line 8824
    if (! edata) {
      {
#line 8826
      free((void *)strtab);
#line 8827
      free((void *)symbols);
      }
#line 8828
      goto switch_break;
    }
    {
#line 8831
    tmp___99 = cmalloc((size_t )total, sizeof(short ));
#line 8831
    data = (unsigned short *)tmp___99;
#line 8833
    cnt___1 = total;
    }
    {
#line 8833
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 8833
      tmp___101 = cnt___1;
#line 8833
      cnt___1 --;
#line 8833
      if (! tmp___101) {
#line 8833
        goto while_break___4;
      }
      {
#line 8834
      tmp___100 = (*byte_get)(edata + (unsigned long )cnt___1 * sizeof(short ), (int )sizeof(short ));
#line 8834
      *(data + cnt___1) = (unsigned short )tmp___100;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 8837
    free((void *)edata);
#line 8839
    cnt___1 = 0;
    }
    {
#line 8839
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 8839
      if (! (cnt___1 < total)) {
#line 8839
        goto while_break___5;
      }
      {
#line 8845
      printf((char const   */* __restrict  */)"  %03x:", cnt___1);
#line 8847
      j___1 = 0;
      }
      {
#line 8847
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 8847
        if (j___1 < 4) {
#line 8847
          if (! (cnt___1 + j___1 < total)) {
#line 8847
            goto while_break___6;
          }
        } else {
#line 8847
          goto while_break___6;
        }
        {
#line 8850
        if ((int )*(data + (cnt___1 + j___1)) == 0) {
#line 8850
          goto case_0;
        }
#line 8854
        if ((int )*(data + (cnt___1 + j___1)) == 1) {
#line 8854
          goto case_1;
        }
#line 8858
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 8851
        tmp___102 = gettext("   0 (*local*)    ");
#line 8851
        fputs((char const   */* __restrict  */)tmp___102, (FILE */* __restrict  */)stdout);
        }
#line 8852
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 8855
        tmp___103 = gettext("   1 (*global*)   ");
#line 8855
        fputs((char const   */* __restrict  */)tmp___103, (FILE */* __restrict  */)stdout);
        }
#line 8856
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 8859
        if ((int )*(data + (cnt___1 + j___1)) & 32768) {
#line 8859
          tmp___104 = 'h';
        } else {
#line 8859
          tmp___104 = ' ';
        }
        {
#line 8859
        nn = printf((char const   */* __restrict  */)"%4x%c", (int )*(data + (cnt___1 + j___1)) & 32767,
                    tmp___104);
        }
#line 8864
        if ((unsigned long )(cnt___1 + j___1) >= num_syms) {
          {
#line 8866
          tmp___105 = gettext("invalid index into symbol array\n");
#line 8866
          warn((char const   *)tmp___105);
          }
#line 8867
          goto switch_break___0;
        }
#line 8870
        check_def = 1;
#line 8871
        check_need = 1;
#line 8872
        if ((symbols + (cnt___1 + j___1))->st_shndx >= elf_header.e_shnum) {
#line 8872
          goto _L;
        } else
#line 8872
        if ((section_headers + (symbols + (cnt___1 + j___1))->st_shndx)->sh_type != 8U) {
          _L: /* CIL Label */ 
#line 8876
          if ((symbols + (cnt___1 + j___1))->st_shndx == 0U) {
#line 8877
            check_def = 0;
          } else {
#line 8879
            check_need = 0;
          }
        }
#line 8882
        if (check_need) {
#line 8882
          if (version_info[1]) {
            {
#line 8888
            tmp___106 = offset_from_vma(file, version_info[1], sizeof(Elf_External_Verneed ));
#line 8888
            offset = (unsigned long )tmp___106;
            }
            {
#line 8892
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 8899
              tmp___107 = gettext("version need");
#line 8899
              tmp___108 = get_data((void *)(& evn), file, (long )offset, sizeof(evn),
                                   (size_t )1, (char const   *)tmp___107);
              }
#line 8899
              if ((unsigned long )tmp___108 == (unsigned long )((void *)0)) {
#line 8901
                goto while_break___7;
              }
              {
#line 8903
              tmp___109 = (*byte_get)(evn.vn_aux, (int )sizeof(evn.vn_aux));
#line 8903
              ivn.vn_aux = (unsigned long )tmp___109;
#line 8904
              tmp___110 = (*byte_get)(evn.vn_next, (int )sizeof(evn.vn_next));
#line 8904
              ivn.vn_next = (unsigned long )tmp___110;
#line 8906
              a_off = offset + ivn.vn_aux;
              }
              {
#line 8908
              while (1) {
                while_continue___8: /* CIL Label */ ;
                {
#line 8910
                tmp___113 = gettext("version need aux (2)");
#line 8910
                tmp___114 = get_data((void *)(& evna), file, (long )a_off, sizeof(evna),
                                     (size_t )1, (char const   *)tmp___113);
                }
#line 8910
                if ((unsigned long )tmp___114 == (unsigned long )((void *)0)) {
#line 8913
                  ivna.vna_next = 0UL;
#line 8914
                  ivna.vna_other = (unsigned short)0;
                } else {
                  {
#line 8918
                  tmp___111 = (*byte_get)(evna.vna_next, (int )sizeof(evna.vna_next));
#line 8918
                  ivna.vna_next = (unsigned long )tmp___111;
#line 8919
                  tmp___112 = (*byte_get)(evna.vna_other, (int )sizeof(evna.vna_other));
#line 8919
                  ivna.vna_other = (unsigned short )tmp___112;
                  }
                }
#line 8922
                a_off += ivna.vna_next;
#line 8908
                if ((int )ivna.vna_other != (int )*(data + (cnt___1 + j___1))) {
#line 8908
                  if (! (ivna.vna_next != 0UL)) {
#line 8908
                    goto while_break___8;
                  }
                } else {
#line 8908
                  goto while_break___8;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
#line 8927
              if ((int )ivna.vna_other == (int )*(data + (cnt___1 + j___1))) {
                {
#line 8929
                tmp___115 = (*byte_get)(evna.vna_name, (int )sizeof(evna.vna_name));
#line 8929
                ivna.vna_name = (unsigned long )tmp___115;
                }
#line 8931
                if (ivna.vna_name >= string_sec->sh_size) {
                  {
#line 8932
                  name___0 = gettext("*invalid*");
                  }
                } else {
#line 8934
                  name___0 = strtab + ivna.vna_name;
                }
                {
#line 8935
                tmp___116 = strlen((char const   *)name___0);
#line 8935
                tmp___117 = printf((char const   */* __restrict  */)"(%s%-*s", name___0,
                                   12 - (int )tmp___116, ")");
#line 8935
                nn += tmp___117;
#line 8939
                check_def = 0;
                }
#line 8940
                goto while_break___7;
              }
#line 8943
              offset += ivn.vn_next;
#line 8892
              if (! ivn.vn_next) {
#line 8892
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
#line 8948
        if (check_def) {
#line 8948
          if ((int )*(data + (cnt___1 + j___1)) != 32769) {
#line 8948
            if (version_info[3]) {
              {
#line 8955
              tmp___118 = offset_from_vma(file, version_info[3], sizeof(evd));
#line 8955
              offset___0 = (unsigned long )tmp___118;
              }
              {
#line 8959
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 8961
                tmp___121 = gettext("version def");
#line 8961
                tmp___122 = get_data((void *)(& evd), file, (long )offset___0, sizeof(evd),
                                     (size_t )1, (char const   *)tmp___121);
                }
#line 8961
                if ((unsigned long )tmp___122 == (unsigned long )((void *)0)) {
#line 8964
                  ivd.vd_next = 0UL;
#line 8965
                  ivd.vd_ndx = (unsigned short)0;
                } else {
                  {
#line 8969
                  tmp___119 = (*byte_get)(evd.vd_next, (int )sizeof(evd.vd_next));
#line 8969
                  ivd.vd_next = (unsigned long )tmp___119;
#line 8970
                  tmp___120 = (*byte_get)(evd.vd_ndx, (int )sizeof(evd.vd_ndx));
#line 8970
                  ivd.vd_ndx = (unsigned short )tmp___120;
                  }
                }
#line 8973
                offset___0 += ivd.vd_next;
#line 8959
                if ((int )ivd.vd_ndx != ((int )*(data + (cnt___1 + j___1)) & 32767)) {
#line 8959
                  if (! (ivd.vd_next != 0UL)) {
#line 8959
                    goto while_break___9;
                  }
                } else {
#line 8959
                  goto while_break___9;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
#line 8978
              if ((int )ivd.vd_ndx == ((int )*(data + (cnt___1 + j___1)) & 32767)) {
                {
#line 8983
                tmp___123 = (*byte_get)(evd.vd_aux, (int )sizeof(evd.vd_aux));
#line 8983
                ivd.vd_aux = (unsigned long )tmp___123;
#line 8985
                tmp___124 = gettext("version def aux");
#line 8985
                tmp___125 = get_data((void *)(& evda), file, (long )((offset___0 - ivd.vd_next) + ivd.vd_aux),
                                     sizeof(evda), (size_t )1, (char const   *)tmp___124);
                }
#line 8985
                if ((unsigned long )tmp___125 == (unsigned long )((void *)0)) {
#line 8989
                  goto switch_break___0;
                }
                {
#line 8991
                tmp___126 = (*byte_get)(evda.vda_name, (int )sizeof(evda.vda_name));
#line 8991
                ivda.vda_name = (unsigned long )tmp___126;
                }
#line 8993
                if (ivda.vda_name >= string_sec->sh_size) {
                  {
#line 8994
                  name___0 = gettext("*invalid*");
                  }
                } else {
#line 8996
                  name___0 = strtab + ivda.vda_name;
                }
                {
#line 8997
                tmp___127 = strlen((char const   *)name___0);
#line 8997
                tmp___128 = printf((char const   */* __restrict  */)"(%s%-*s", name___0,
                                   12 - (int )tmp___127, ")");
#line 8997
                nn += tmp___128;
                }
              }
            }
          }
        }
#line 9004
        if (nn < 18) {
          {
#line 9005
          printf((char const   */* __restrict  */)"%*c", 18 - nn, ' ');
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 8847
        j___1 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 9008
      putchar('\n');
#line 8839
      cnt___1 += 4;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 9011
    free((void *)data);
#line 9012
    free((void *)strtab);
#line 9013
    free((void *)symbols);
    }
#line 9015
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 9018
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 8535
    i ++;
#line 8535
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9022
  if (! found) {
    {
#line 9023
    tmp___129 = gettext("\nNo version information found in this file.\n");
#line 9023
    printf((char const   */* __restrict  */)tmp___129);
    }
  }
#line 9025
  return (1);
}
}
#line 9031 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___10[32]  ;
#line 9028 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_symbol_binding(unsigned int binding ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 9035
  if (binding == 0U) {
#line 9035
    goto case_0;
  }
#line 9036
  if (binding == 1U) {
#line 9036
    goto case_1;
  }
#line 9037
  if (binding == 2U) {
#line 9037
    goto case_2;
  }
#line 9038
  goto switch_default;
  case_0: /* CIL Label */ 
#line 9035
  return ("LOCAL");
  case_1: /* CIL Label */ 
#line 9036
  return ("GLOBAL");
  case_2: /* CIL Label */ 
#line 9037
  return ("WEAK");
  switch_default: /* CIL Label */ 
#line 9039
  if (binding >= 13U) {
#line 9039
    if (binding <= 15U) {
      {
#line 9040
      tmp___0 = gettext("<processor specific>: %d");
#line 9040
      snprintf((char */* __restrict  */)(buff___10), sizeof(buff___10), (char const   */* __restrict  */)tmp___0,
               binding);
      }
    } else {
#line 9039
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 9042
  if (binding >= 10U) {
#line 9042
    if (binding <= 12U) {
#line 9044
      if (binding == 10U) {
#line 9044
        if ((int )elf_header.e_ident[7] == 3) {
#line 9048
          return ("UNIQUE");
        } else
#line 9044
        if ((int )elf_header.e_ident[7] == 0) {
#line 9048
          return ("UNIQUE");
        }
      }
      {
#line 9049
      tmp___1 = gettext("<OS specific>: %d");
#line 9049
      snprintf((char */* __restrict  */)(buff___10), sizeof(buff___10), (char const   */* __restrict  */)tmp___1,
               binding);
      }
    } else {
      {
#line 9052
      tmp___2 = gettext("<unknown>: %d");
#line 9052
      snprintf((char */* __restrict  */)(buff___10), sizeof(buff___10), (char const   */* __restrict  */)tmp___2,
               binding);
      }
    }
  } else {
    {
#line 9052
    tmp___2 = gettext("<unknown>: %d");
#line 9052
    snprintf((char */* __restrict  */)(buff___10), sizeof(buff___10), (char const   */* __restrict  */)tmp___2,
             binding);
    }
  }
#line 9053
  return ((char const   *)(buff___10));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 9060 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___11[32]  ;
#line 9057 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_symbol_type(unsigned int type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 9064
  if (type == 0U) {
#line 9064
    goto case_0;
  }
#line 9065
  if (type == 1U) {
#line 9065
    goto case_1;
  }
#line 9066
  if (type == 2U) {
#line 9066
    goto case_2;
  }
#line 9067
  if (type == 3U) {
#line 9067
    goto case_3;
  }
#line 9068
  if (type == 4U) {
#line 9068
    goto case_4;
  }
#line 9069
  if (type == 5U) {
#line 9069
    goto case_5;
  }
#line 9070
  if (type == 6U) {
#line 9070
    goto case_6;
  }
#line 9071
  if (type == 8U) {
#line 9071
    goto case_8;
  }
#line 9072
  if (type == 9U) {
#line 9072
    goto case_9;
  }
#line 9073
  goto switch_default;
  case_0: /* CIL Label */ 
#line 9064
  return ("NOTYPE");
  case_1: /* CIL Label */ 
#line 9065
  return ("OBJECT");
  case_2: /* CIL Label */ 
#line 9066
  return ("FUNC");
  case_3: /* CIL Label */ 
#line 9067
  return ("SECTION");
  case_4: /* CIL Label */ 
#line 9068
  return ("FILE");
  case_5: /* CIL Label */ 
#line 9069
  return ("COMMON");
  case_6: /* CIL Label */ 
#line 9070
  return ("TLS");
  case_8: /* CIL Label */ 
#line 9071
  return ("RELC");
  case_9: /* CIL Label */ 
#line 9072
  return ("SRELC");
  switch_default: /* CIL Label */ 
#line 9074
  if (type >= 13U) {
#line 9074
    if (type <= 15U) {
#line 9076
      if ((int )elf_header.e_machine == 40) {
#line 9078
        if (type == 13U) {
#line 9079
          return ("THUMB_FUNC");
        }
#line 9080
        if (type == 15U) {
#line 9081
          return ("THUMB_LABEL");
        }
      }
#line 9084
      if ((int )elf_header.e_machine == 43) {
#line 9084
        if (type == 13U) {
#line 9085
          return ("REGISTER");
        }
      }
#line 9087
      if ((int )elf_header.e_machine == 15) {
#line 9087
        if (type == 13U) {
#line 9088
          return ("PARISC_MILLI");
        }
      }
      {
#line 9090
      tmp___0 = gettext("<processor specific>: %d");
#line 9090
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___0,
               type);
      }
    } else {
#line 9074
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 9092
  if (type >= 10U) {
#line 9092
    if (type <= 12U) {
#line 9094
      if ((int )elf_header.e_machine == 15) {
#line 9096
        if (type == 11U) {
#line 9097
          return ("HP_OPAQUE");
        }
#line 9098
        if (type == 12U) {
#line 9099
          return ("HP_STUB");
        }
      }
#line 9102
      if (type == 10U) {
#line 9102
        if ((int )elf_header.e_ident[7] == 3) {
#line 9107
          return ("IFUNC");
        } else
#line 9102
        if ((int )elf_header.e_ident[7] == 9) {
#line 9107
          return ("IFUNC");
        } else
#line 9102
        if ((int )elf_header.e_ident[7] == 0) {
#line 9107
          return ("IFUNC");
        }
      }
      {
#line 9109
      tmp___1 = gettext("<OS specific>: %d");
#line 9109
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___1,
               type);
      }
    } else {
      {
#line 9112
      tmp___2 = gettext("<unknown>: %d");
#line 9112
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___2,
               type);
      }
    }
  } else {
    {
#line 9112
    tmp___2 = gettext("<unknown>: %d");
#line 9112
    snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___2,
             type);
    }
  }
#line 9113
  return ((char const   *)(buff___11));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 9117 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_symbol_visibility(unsigned int visibility ) 
{ 


  {
  {
#line 9122
  if (visibility == 0U) {
#line 9122
    goto case_0;
  }
#line 9123
  if (visibility == 1U) {
#line 9123
    goto case_1;
  }
#line 9124
  if (visibility == 2U) {
#line 9124
    goto case_2;
  }
#line 9125
  if (visibility == 3U) {
#line 9125
    goto case_3;
  }
#line 9126
  goto switch_default;
  case_0: /* CIL Label */ 
#line 9122
  return ("DEFAULT");
  case_1: /* CIL Label */ 
#line 9123
  return ("INTERNAL");
  case_2: /* CIL Label */ 
#line 9124
  return ("HIDDEN");
  case_3: /* CIL Label */ 
#line 9125
  return ("PROTECTED");
  switch_default: /* CIL Label */ 
  {
#line 9126
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 9130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_mips_symbol_other(unsigned int other ) 
{ 


  {
  {
#line 9135
  if (other == (unsigned int )(1 << 2)) {
#line 9135
    goto case_exp;
  }
#line 9137
  if (other == 8U) {
#line 9137
    goto case_8;
  }
#line 9139
  if (other == 32U) {
#line 9139
    goto case_32;
  }
#line 9141
  if (other == (unsigned int )(2 << 6)) {
#line 9141
    goto case_exp___0;
  }
#line 9143
  if (other == (unsigned int )((2 << 6) | 32)) {
#line 9143
    goto case_exp___1;
  }
#line 9145
  if (other == 240U) {
#line 9145
    goto case_240;
  }
#line 9147
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 9136
  return ("OPTIONAL");
  case_8: /* CIL Label */ 
#line 9138
  return ("MIPS PLT");
  case_32: /* CIL Label */ 
#line 9140
  return ("MIPS PIC");
  case_exp___0: /* CIL Label */ 
#line 9142
  return ("MICROMIPS");
  case_exp___1: /* CIL Label */ 
#line 9144
  return ("MICROMIPS, MIPS PIC");
  case_240: /* CIL Label */ 
#line 9146
  return ("MIPS16");
  switch_default: /* CIL Label */ 
#line 9148
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 9157 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char res[32]  ;
#line 9152 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ia64_symbol_other(unsigned int other ) 
{ 
  int tmp___0 ;

  {
  {
#line 9155
  tmp___0 = is_ia64_vms();
  }
#line 9155
  if (tmp___0) {
#line 9159
    res[0] = (char)0;
    {
#line 9165
    if ((int )elf_header.e_type == 2) {
#line 9165
      goto case_2;
    }
#line 9165
    if ((int )elf_header.e_type == 3) {
#line 9165
      goto case_2;
    }
#line 9184
    goto switch_default___0;
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 9168
    if ((other & 48U) >> 4 == 0U) {
#line 9168
      goto case_0;
    }
#line 9171
    if ((other & 48U) >> 4 == 1U) {
#line 9171
      goto case_1;
    }
#line 9174
    if ((other & 48U) >> 4 == 2U) {
#line 9174
      goto case_2___0;
    }
#line 9177
    if ((other & 48U) >> 4 == 3U) {
#line 9177
      goto case_3___0;
    }
#line 9180
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 9169
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" CA");
    }
#line 9170
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 9172
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" VEC");
    }
#line 9173
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 9175
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" FD");
    }
#line 9176
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 9178
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" RSV");
    }
#line 9179
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 9181
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 9183
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 9185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 9189
    if ((other & 192U) >> 6 == 0U) {
#line 9189
      goto case_0___0;
    }
#line 9192
    if ((other & 192U) >> 6 == 1U) {
#line 9192
      goto case_1___0;
    }
#line 9195
    if ((other & 192U) >> 6 == 2U) {
#line 9195
      goto case_2___1;
    }
#line 9198
    if ((other & 192U) >> 6 == 3U) {
#line 9198
      goto case_3___1;
    }
#line 9201
    goto switch_default___1;
    case_0___0: /* CIL Label */ 
    {
#line 9190
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" IGN");
    }
#line 9191
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
    {
#line 9193
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" RSV");
    }
#line 9194
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 9196
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" STD");
    }
#line 9197
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    {
#line 9199
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" LNK");
    }
#line 9200
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 9202
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 9205
    if ((int )res[0] != 0) {
#line 9206
      return ((char const   *)(res + 1));
    } else {
#line 9208
      return ((char const   *)(res));
    }
  }
#line 9210
  return ((char const   *)((void *)0));
}
}
#line 9218 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buf___6[32]  ;
#line 9213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ppc64_symbol_other(unsigned int other ) 
{ 
  unsigned int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 9216
  tmp___2 = ppc64_decode_local_entry((other & (unsigned int )(7 << 5)) >> 5);
  }
#line 9216
  if (tmp___2 != 0U) {
    {
#line 9219
    tmp___0 = ppc64_decode_local_entry((other & (unsigned int )(7 << 5)) >> 5);
#line 9219
    tmp___1 = gettext("<localentry>: %d");
#line 9219
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)tmp___1,
             tmp___0);
    }
#line 9221
    return ((char const   *)(buf___6));
  }
#line 9223
  return ((char const   *)((void *)0));
}
}
#line 9230 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___12[32]  ;
#line 9226 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_symbol_other(unsigned int other ) 
{ 
  char const   *result ;
  char *tmp___0 ;

  {
#line 9229
  result = (char const   *)((void *)0);
#line 9232
  if (other == 0U) {
#line 9233
    return ("");
  }
  {
#line 9237
  if ((int )elf_header.e_machine == 8) {
#line 9237
    goto case_8;
  }
#line 9240
  if ((int )elf_header.e_machine == 50) {
#line 9240
    goto case_50;
  }
#line 9243
  if ((int )elf_header.e_machine == 21) {
#line 9243
    goto case_21;
  }
#line 9246
  goto switch_default;
  case_8: /* CIL Label */ 
  {
#line 9238
  result = get_mips_symbol_other(other);
  }
#line 9239
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 9241
  result = get_ia64_symbol_other(other);
  }
#line 9242
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 9244
  result = get_ppc64_symbol_other(other);
  }
#line 9245
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 9247
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 9250
  if (result) {
#line 9251
    return (result);
  }
  {
#line 9253
  tmp___0 = gettext("<other>: %x");
#line 9253
  snprintf((char */* __restrict  */)(buff___12), sizeof(buff___12), (char const   */* __restrict  */)tmp___0,
           other);
  }
#line 9254
  return ((char const   *)(buff___12));
}
}
#line 9260 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___13[32]  ;
#line 9257 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_symbol_index_type(unsigned int type ) 
{ 


  {
  {
#line 9264
  if (type == 0U) {
#line 9264
    goto case_0;
  }
#line 9265
  if (type == 4294967281U) {
#line 9265
    goto case_4294967281;
  }
#line 9266
  if (type == 4294967282U) {
#line 9266
    goto case_4294967282;
  }
#line 9267
  goto switch_default;
  case_0: /* CIL Label */ 
#line 9264
  return ("UND");
  case_4294967281: /* CIL Label */ 
#line 9265
  return ("ABS");
  case_4294967282: /* CIL Label */ 
#line 9266
  return ("COM");
  switch_default: /* CIL Label */ 
#line 9268
  if (type == 4294967040U) {
#line 9268
    if ((int )elf_header.e_machine == 50) {
#line 9268
      if ((int )elf_header.e_ident[7] == 1) {
#line 9271
        return ("ANSI_COM");
      } else {
#line 9268
        goto _L___7;
      }
    } else {
#line 9268
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 9272
  if ((int )elf_header.e_machine == 62) {
#line 9272
    goto _L___5;
  } else
#line 9272
  if ((int )elf_header.e_machine == 180) {
#line 9272
    goto _L___5;
  } else
#line 9272
  if ((int )elf_header.e_machine == 181) {
    _L___5: /* CIL Label */ 
#line 9272
    if (type == 4294967042U) {
#line 9276
      return ("LARGE_COM");
    } else {
#line 9272
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 9277
  if (type == 4294967043U) {
#line 9277
    if ((int )elf_header.e_machine == 8) {
#line 9281
      return ("SCOM");
    } else {
#line 9277
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 9277
  if (type == 4294967040U) {
#line 9277
    if ((int )elf_header.e_machine == 140) {
#line 9281
      return ("SCOM");
    } else {
#line 9277
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 9282
  if (type == 4294967044U) {
#line 9282
    if ((int )elf_header.e_machine == 8) {
#line 9284
      return ("SUND");
    } else {
#line 9282
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 9285
  if (type >= 4294967040U) {
#line 9285
    if (type <= 4294967071U) {
      {
#line 9286
      sprintf((char */* __restrict  */)(buff___13), (char const   */* __restrict  */)"PRC[0x%04x]",
              type & 65535U);
      }
    } else {
#line 9285
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 9287
  if (type >= 4294967072U) {
#line 9287
    if (type <= 4294967103U) {
      {
#line 9288
      sprintf((char */* __restrict  */)(buff___13), (char const   */* __restrict  */)"OS [0x%04x]",
              type & 65535U);
      }
    } else {
#line 9287
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 9289
  if (type >= 4294967040U) {
    {
#line 9290
    sprintf((char */* __restrict  */)(buff___13), (char const   */* __restrict  */)"RSV[0x%04x]",
            type & 65535U);
    }
  } else
#line 9291
  if (type >= elf_header.e_shnum) {
    {
#line 9292
    sprintf((char */* __restrict  */)(buff___13), (char const   */* __restrict  */)"bad section index[%3d]",
            type);
    }
  } else {
    {
#line 9294
    sprintf((char */* __restrict  */)(buff___13), (char const   */* __restrict  */)"%3d",
            type);
    }
  }
#line 9295
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 9298
  return ((char const   *)(buff___13));
}
}
#line 9301 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma *get_dynamic_data(FILE *file , unsigned int number , unsigned int ent_size ) 
{ 
  unsigned char *e_data ;
  bfd_vma *i_data ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  elf_vma tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 9307
  tmp___0 = cmalloc((size_t )number, (size_t )ent_size);
#line 9307
  e_data = (unsigned char *)tmp___0;
  }
#line 9309
  if ((unsigned long )e_data == (unsigned long )((void *)0)) {
    {
#line 9311
    tmp___1 = gettext("Out of memory\n");
#line 9311
    error((char const   *)tmp___1);
    }
#line 9312
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9315
  tmp___3 = fread((void */* __restrict  */)e_data, (size_t )ent_size, (size_t )number,
                  (FILE */* __restrict  */)file);
  }
#line 9315
  if (tmp___3 != (size_t )number) {
    {
#line 9317
    tmp___2 = gettext("Unable to read in dynamic data\n");
#line 9317
    error((char const   *)tmp___2);
    }
#line 9318
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9321
  tmp___4 = cmalloc((size_t )number, sizeof(*i_data));
#line 9321
  i_data = (bfd_vma *)tmp___4;
  }
#line 9323
  if ((unsigned long )i_data == (unsigned long )((void *)0)) {
    {
#line 9325
    tmp___5 = gettext("Out of memory\n");
#line 9325
    error((char const   *)tmp___5);
#line 9326
    free((void *)e_data);
    }
#line 9327
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9330
    tmp___7 = number;
#line 9330
    number --;
#line 9330
    if (! tmp___7) {
#line 9330
      goto while_break;
    }
    {
#line 9331
    tmp___6 = (*byte_get)(e_data + number * ent_size, (int )ent_size);
#line 9331
    *(i_data + number) = (bfd_vma )tmp___6;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9333
  free((void *)e_data);
  }
#line 9335
  return (i_data);
}
}
#line 9338 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void print_dynamic_symbol(bfd_vma si , unsigned long hn ) 
{ 
  Elf_Internal_Sym *psym ;
  int n ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 9344
  psym = dynamic_symbols + si;
#line 9346
  n = print_vma(si, (print_mode )2);
  }
#line 9347
  if (n < 5) {
    {
#line 9348
    fputs((char const   */* __restrict  */)("     " + n), (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 9349
  printf((char const   */* __restrict  */)" %3lu: ", hn);
#line 9350
  print_vma(psym->st_value, (print_mode )6);
#line 9351
  putchar(' ');
#line 9352
  print_vma(psym->st_size, (print_mode )2);
#line 9354
  tmp___0 = get_symbol_type((unsigned int )((int )psym->st_info & 15));
#line 9354
  printf((char const   */* __restrict  */)" %-7s", tmp___0);
#line 9355
  tmp___1 = get_symbol_binding((unsigned int )psym->st_info >> 4);
#line 9355
  printf((char const   */* __restrict  */)" %-6s", tmp___1);
#line 9356
  tmp___2 = get_symbol_visibility((unsigned int )((int )psym->st_other & 3));
#line 9356
  printf((char const   */* __restrict  */)" %-7s", tmp___2);
  }
#line 9361
  if ((int )psym->st_other ^ ((int )psym->st_other & 3)) {
    {
#line 9362
    tmp___3 = get_symbol_other((unsigned int )((int )psym->st_other ^ ((int )psym->st_other & 3)));
#line 9362
    printf((char const   */* __restrict  */)" [%s] ", tmp___3);
    }
  }
  {
#line 9363
  tmp___4 = get_symbol_index_type(psym->st_shndx);
#line 9363
  printf((char const   */* __restrict  */)" %3.3s ", tmp___4);
  }
#line 9364
  if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9364
    if (psym->st_name < dynamic_strings_length) {
      {
#line 9365
      print_symbol(25, (char const   *)(dynamic_strings + psym->st_name));
      }
    } else {
      {
#line 9367
      tmp___5 = gettext(" <corrupt: %14ld>");
#line 9367
      printf((char const   */* __restrict  */)tmp___5, psym->st_name);
      }
    }
  } else {
    {
#line 9367
    tmp___5 = gettext(" <corrupt: %14ld>");
#line 9367
    printf((char const   */* __restrict  */)tmp___5, psym->st_name);
    }
  }
  {
#line 9368
  putchar('\n');
  }
#line 9369
  return;
}
}
#line 9372 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_symbol_table(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  bfd_vma nbuckets ;
  bfd_vma nchains ;
  bfd_vma *buckets ;
  bfd_vma *chains ;
  bfd_vma ngnubuckets ;
  bfd_vma *gnubuckets ;
  bfd_vma *gnuchains ;
  bfd_vma gnusymidx ;
  unsigned char nb[8] ;
  unsigned char nc[8] ;
  int hash_ent_size ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  unsigned char nb___0[16] ;
  bfd_vma i ;
  bfd_vma maxchain ;
  bfd_vma bitmaskwords ;
  bfd_vma buckets_vma ;
  char *tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  elf_vma tmp___14 ;
  elf_vma tmp___15 ;
  elf_vma tmp___16 ;
  char *tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  elf_vma tmp___25 ;
  char *tmp___26 ;
  long tmp___27 ;
  int tmp___28 ;
  unsigned long hn ;
  bfd_vma si ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  bfd_vma si___0 ;
  bfd_vma off ;
  bfd_vma tmp___35 ;
  unsigned int i___0 ;
  unsigned int si___1 ;
  char *strtab ;
  unsigned long strtab_size ;
  Elf_Internal_Sym *symtab ;
  Elf_Internal_Sym *psym ;
  unsigned long num_syms ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  Elf_Internal_Sym *tmp___52 ;
  Elf_Internal_Sym *tmp___53 ;
  Elf_Internal_Shdr *string_sec ;
  char *tmp___54 ;
  void *tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  unsigned char data[2] ;
  unsigned short vers_data ;
  unsigned long offset ;
  int is_nobits ;
  int check_def ;
  long tmp___63 ;
  char *tmp___64 ;
  void *tmp___65 ;
  elf_vma tmp___66 ;
  int tmp___67 ;
  Elf_External_Verneed evn ;
  Elf_Internal_Verneed ivn ;
  Elf_Internal_Vernaux ivna ;
  long tmp___68 ;
  unsigned long vna_off ;
  char *tmp___69 ;
  void *tmp___70 ;
  elf_vma tmp___71 ;
  elf_vma tmp___72 ;
  Elf_External_Vernaux evna ;
  elf_vma tmp___73 ;
  elf_vma tmp___74 ;
  elf_vma tmp___75 ;
  char *tmp___76 ;
  void *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  Elf_Internal_Verdef ivd ;
  Elf_Internal_Verdaux ivda ;
  Elf_External_Verdaux evda ;
  unsigned long off___0 ;
  long tmp___81 ;
  Elf_External_Verdef evd ;
  elf_vma tmp___82 ;
  elf_vma tmp___83 ;
  elf_vma tmp___84 ;
  char *tmp___85 ;
  void *tmp___86 ;
  char *tmp___87 ;
  void *tmp___88 ;
  elf_vma tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char const   *tmp___92 ;
  char *tmp___93 ;
  unsigned long *lengths ;
  unsigned long *counts ;
  unsigned long hn___0 ;
  bfd_vma si___2 ;
  unsigned long maxlength ;
  unsigned long nzero_counts ;
  unsigned long nsyms ;
  char *tmp___94 ;
  char *tmp___95 ;
  void *tmp___96 ;
  char *tmp___97 ;
  void *tmp___98 ;
  char *tmp___99 ;
  unsigned long i___1 ;
  unsigned long *lengths___0 ;
  unsigned long *counts___0 ;
  unsigned long hn___1 ;
  unsigned long maxlength___0 ;
  unsigned long nzero_counts___0 ;
  unsigned long nsyms___0 ;
  void *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  bfd_vma off___1 ;
  bfd_vma length ;
  void *tmp___104 ;
  char *tmp___105 ;
  unsigned long j ;

  {
#line 9376
  nbuckets = (bfd_vma )0;
#line 9377
  nchains = (bfd_vma )0;
#line 9378
  buckets = (bfd_vma *)((void *)0);
#line 9379
  chains = (bfd_vma *)((void *)0);
#line 9380
  ngnubuckets = (bfd_vma )0;
#line 9381
  gnubuckets = (bfd_vma *)((void *)0);
#line 9382
  gnuchains = (bfd_vma *)((void *)0);
#line 9383
  gnusymidx = (bfd_vma )0;
#line 9385
  if (! do_syms) {
#line 9385
    if (! do_dyn_syms) {
#line 9385
      if (! do_histogram) {
#line 9386
        return (1);
      }
    }
  }
#line 9388
  if (dynamic_info[4]) {
#line 9388
    if (do_histogram) {
#line 9388
      goto _L___1;
    } else
#line 9388
    if (do_using_dynamic) {
#line 9388
      if (! do_dyn_syms) {
#line 9388
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 9396
          hash_ent_size = 4;
#line 9398
          if ((int )elf_header.e_machine == 36902) {
#line 9398
            goto _L;
          } else
#line 9398
          if ((int )elf_header.e_machine == 22) {
#line 9398
            goto _L;
          } else
#line 9398
          if ((int )elf_header.e_machine == 41872) {
            _L: /* CIL Label */ 
#line 9398
            if ((int )elf_header.e_ident[4] == 2) {
#line 9402
              hash_ent_size = 8;
            }
          }
          {
#line 9404
          tmp___1 = offset_from_vma(file, dynamic_info[4], sizeof(nb) + sizeof(nc));
#line 9404
          tmp___2 = fseek(file, archive_file_offset + tmp___1, 0);
          }
#line 9404
          if (tmp___2) {
            {
#line 9410
            tmp___0 = gettext("Unable to seek to start of dynamic information\n");
#line 9410
            error((char const   *)tmp___0);
            }
#line 9411
            goto no_hash;
          }
          {
#line 9414
          tmp___4 = fread((void */* __restrict  */)(nb), (size_t )hash_ent_size, (size_t )1,
                          (FILE */* __restrict  */)file);
          }
#line 9414
          if (tmp___4 != 1UL) {
            {
#line 9416
            tmp___3 = gettext("Failed to read in number of buckets\n");
#line 9416
            error((char const   *)tmp___3);
            }
#line 9417
            goto no_hash;
          }
          {
#line 9420
          tmp___6 = fread((void */* __restrict  */)(nc), (size_t )hash_ent_size, (size_t )1,
                          (FILE */* __restrict  */)file);
          }
#line 9420
          if (tmp___6 != 1UL) {
            {
#line 9422
            tmp___5 = gettext("Failed to read in number of chains\n");
#line 9422
            error((char const   *)tmp___5);
            }
#line 9423
            goto no_hash;
          }
          {
#line 9426
          tmp___7 = (*byte_get)(nb, hash_ent_size);
#line 9426
          nbuckets = (bfd_vma )tmp___7;
#line 9427
          tmp___8 = (*byte_get)(nc, hash_ent_size);
#line 9427
          nchains = (bfd_vma )tmp___8;
#line 9429
          buckets = get_dynamic_data(file, (unsigned int )nbuckets, (unsigned int )hash_ent_size);
#line 9430
          chains = get_dynamic_data(file, (unsigned int )nchains, (unsigned int )hash_ent_size);
          }
          no_hash: 
#line 9433
          if ((unsigned long )buckets == (unsigned long )((void *)0)) {
#line 9433
            goto _L___0;
          } else
#line 9433
          if ((unsigned long )chains == (unsigned long )((void *)0)) {
            _L___0: /* CIL Label */ 
#line 9435
            if (do_using_dynamic) {
#line 9436
              return (0);
            }
            {
#line 9437
            free((void *)buckets);
#line 9438
            free((void *)chains);
#line 9439
            buckets = (bfd_vma *)((void *)0);
#line 9440
            chains = (bfd_vma *)((void *)0);
#line 9441
            nbuckets = (bfd_vma )0;
#line 9442
            nchains = (bfd_vma )0;
            }
          }
        }
      }
    }
  }
#line 9446
  if (dynamic_info_DT_GNU_HASH) {
#line 9446
    if (do_histogram) {
#line 9446
      goto _L___2;
    } else
#line 9446
    if (do_using_dynamic) {
#line 9446
      if (! do_dyn_syms) {
#line 9446
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          _L___2: /* CIL Label */ 
          {
#line 9453
          maxchain = (bfd_vma )4294967295U;
#line 9456
          tmp___10 = offset_from_vma(file, dynamic_info_DT_GNU_HASH, sizeof(nb___0));
#line 9456
          tmp___11 = fseek(file, archive_file_offset + tmp___10, 0);
          }
#line 9456
          if (tmp___11) {
            {
#line 9462
            tmp___9 = gettext("Unable to seek to start of dynamic information\n");
#line 9462
            error((char const   *)tmp___9);
            }
#line 9463
            goto no_gnu_hash;
          }
          {
#line 9466
          tmp___13 = fread((void */* __restrict  */)(nb___0), (size_t )16, (size_t )1,
                           (FILE */* __restrict  */)file);
          }
#line 9466
          if (tmp___13 != 1UL) {
            {
#line 9468
            tmp___12 = gettext("Failed to read in number of buckets\n");
#line 9468
            error((char const   *)tmp___12);
            }
#line 9469
            goto no_gnu_hash;
          }
          {
#line 9472
          tmp___14 = (*byte_get)(nb___0, 4);
#line 9472
          ngnubuckets = (bfd_vma )tmp___14;
#line 9473
          tmp___15 = (*byte_get)(nb___0 + 4, 4);
#line 9473
          gnusymidx = (bfd_vma )tmp___15;
#line 9474
          tmp___16 = (*byte_get)(nb___0 + 8, 4);
#line 9474
          bitmaskwords = (bfd_vma )tmp___16;
#line 9475
          buckets_vma = dynamic_info_DT_GNU_HASH + 16UL;
          }
#line 9476
          if (is_32bit_elf) {
#line 9477
            buckets_vma += bitmaskwords * 4UL;
          } else {
#line 9479
            buckets_vma += bitmaskwords * 8UL;
          }
          {
#line 9481
          tmp___18 = offset_from_vma(file, buckets_vma, (bfd_size_type )4);
#line 9481
          tmp___19 = fseek(file, archive_file_offset + tmp___18, 0);
          }
#line 9481
          if (tmp___19) {
            {
#line 9486
            tmp___17 = gettext("Unable to seek to start of dynamic information\n");
#line 9486
            error((char const   *)tmp___17);
            }
#line 9487
            goto no_gnu_hash;
          }
          {
#line 9490
          gnubuckets = get_dynamic_data(file, (unsigned int )ngnubuckets, 4U);
          }
#line 9492
          if ((unsigned long )gnubuckets == (unsigned long )((void *)0)) {
#line 9493
            goto no_gnu_hash;
          }
#line 9495
          i = (bfd_vma )0;
          {
#line 9495
          while (1) {
            while_continue: /* CIL Label */ ;
#line 9495
            if (! (i < ngnubuckets)) {
#line 9495
              goto while_break;
            }
#line 9496
            if (*(gnubuckets + i) != 0UL) {
#line 9498
              if (*(gnubuckets + i) < gnusymidx) {
#line 9499
                return (0);
              }
#line 9501
              if (maxchain == 4294967295UL) {
#line 9502
                maxchain = *(gnubuckets + i);
              } else
#line 9501
              if (*(gnubuckets + i) > maxchain) {
#line 9502
                maxchain = *(gnubuckets + i);
              }
            }
#line 9495
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 9505
          if (maxchain == 4294967295UL) {
#line 9506
            goto no_gnu_hash;
          }
          {
#line 9508
          maxchain -= gnusymidx;
#line 9510
          tmp___21 = offset_from_vma(file, buckets_vma + 4UL * (ngnubuckets + maxchain),
                                     (bfd_size_type )4);
#line 9510
          tmp___22 = fseek(file, archive_file_offset + tmp___21, 0);
          }
#line 9510
          if (tmp___22) {
            {
#line 9516
            tmp___20 = gettext("Unable to seek to start of dynamic information\n");
#line 9516
            error((char const   *)tmp___20);
            }
#line 9517
            goto no_gnu_hash;
          }
          {
#line 9520
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 9522
            tmp___24 = fread((void */* __restrict  */)(nb___0), (size_t )4, (size_t )1,
                             (FILE */* __restrict  */)file);
            }
#line 9522
            if (tmp___24 != 1UL) {
              {
#line 9524
              tmp___23 = gettext("Failed to determine last chain length\n");
#line 9524
              error((char const   *)tmp___23);
              }
#line 9525
              goto no_gnu_hash;
            }
#line 9528
            if (maxchain + 1UL == 0UL) {
#line 9529
              goto no_gnu_hash;
            }
            {
#line 9531
            maxchain ++;
#line 9520
            tmp___25 = (*byte_get)(nb___0, 4);
            }
#line 9520
            if (! ((tmp___25 & 1ULL) == 0ULL)) {
#line 9520
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 9535
          tmp___27 = offset_from_vma(file, buckets_vma + 4UL * ngnubuckets, (bfd_size_type )4);
#line 9535
          tmp___28 = fseek(file, archive_file_offset + tmp___27, 0);
          }
#line 9535
          if (tmp___28) {
            {
#line 9540
            tmp___26 = gettext("Unable to seek to start of dynamic information\n");
#line 9540
            error((char const   *)tmp___26);
            }
#line 9541
            goto no_gnu_hash;
          }
          {
#line 9544
          gnuchains = get_dynamic_data(file, (unsigned int )maxchain, 4U);
          }
          no_gnu_hash: 
#line 9547
          if ((unsigned long )gnuchains == (unsigned long )((void *)0)) {
            {
#line 9549
            free((void *)gnubuckets);
#line 9550
            gnubuckets = (bfd_vma *)((void *)0);
#line 9551
            ngnubuckets = (bfd_vma )0;
            }
#line 9552
            if (do_using_dynamic) {
#line 9553
              return (0);
            }
          }
        }
      }
    }
  }
#line 9557
  if (dynamic_info[4]) {
#line 9557
    goto _L___11;
  } else
#line 9557
  if (dynamic_info_DT_GNU_HASH) {
    _L___11: /* CIL Label */ 
#line 9557
    if (do_syms) {
#line 9557
      if (do_using_dynamic) {
#line 9557
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9564
          if (dynamic_info[4]) {
            {
#line 9568
            tmp___29 = gettext("\nSymbol table for image:\n");
#line 9568
            printf((char const   */* __restrict  */)tmp___29);
            }
#line 9569
            if (is_32bit_elf) {
              {
#line 9570
              tmp___30 = gettext("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n");
#line 9570
              printf((char const   */* __restrict  */)tmp___30);
              }
            } else {
              {
#line 9572
              tmp___31 = gettext("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n");
#line 9572
              printf((char const   */* __restrict  */)tmp___31);
              }
            }
#line 9574
            hn = 0UL;
            {
#line 9574
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 9574
              if (! (hn < nbuckets)) {
#line 9574
                goto while_break___1;
              }
#line 9576
              if (! *(buckets + hn)) {
#line 9577
                goto __Cont;
              }
#line 9579
              si = *(buckets + hn);
              {
#line 9579
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 9579
                if (si < nchains) {
#line 9579
                  if (! (si > 0UL)) {
#line 9579
                    goto while_break___2;
                  }
                } else {
#line 9579
                  goto while_break___2;
                }
                {
#line 9580
                print_dynamic_symbol(si, hn);
#line 9579
                si = *(chains + si);
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              __Cont: /* CIL Label */ 
#line 9574
              hn ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 9584
          if (dynamic_info_DT_GNU_HASH) {
            {
#line 9586
            tmp___32 = gettext("\nSymbol table of `.gnu.hash\' for image:\n");
#line 9586
            printf((char const   */* __restrict  */)tmp___32);
            }
#line 9587
            if (is_32bit_elf) {
              {
#line 9588
              tmp___33 = gettext("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n");
#line 9588
              printf((char const   */* __restrict  */)tmp___33);
              }
            } else {
              {
#line 9590
              tmp___34 = gettext("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n");
#line 9590
              printf((char const   */* __restrict  */)tmp___34);
              }
            }
#line 9592
            hn = 0UL;
            {
#line 9592
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 9592
              if (! (hn < ngnubuckets)) {
#line 9592
                goto while_break___3;
              }
#line 9593
              if (*(gnubuckets + hn) != 0UL) {
#line 9595
                si___0 = *(gnubuckets + hn);
#line 9596
                off = si___0 - gnusymidx;
                {
#line 9598
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  {
#line 9600
                  print_dynamic_symbol(si___0, hn);
#line 9601
                  si___0 ++;
#line 9598
                  tmp___35 = off;
#line 9598
                  off ++;
                  }
#line 9598
                  if (! ((*(gnuchains + tmp___35) & 1UL) == 0UL)) {
#line 9598
                    goto while_break___4;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
              }
#line 9592
              hn ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else {
#line 9557
          goto _L___10;
        }
      } else {
#line 9557
        goto _L___10;
      }
    } else {
#line 9557
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 9607
  if (do_dyn_syms) {
#line 9607
    goto _L___6;
  } else
#line 9607
  if (do_syms) {
#line 9607
    if (! do_using_dynamic) {
      _L___6: /* CIL Label */ 
#line 9611
      i___0 = 0U;
#line 9611
      section = section_headers;
      {
#line 9611
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 9611
        if (! (i___0 < elf_header.e_shnum)) {
#line 9611
          goto while_break___5;
        }
#line 9616
        strtab = (char *)((void *)0);
#line 9617
        strtab_size = 0UL;
#line 9622
        if (section->sh_type != 2U) {
#line 9622
          if (section->sh_type != 11U) {
#line 9626
            goto __Cont___0;
          } else {
#line 9622
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 9622
        if (! do_syms) {
#line 9622
          if (section->sh_type == 2U) {
#line 9626
            goto __Cont___0;
          }
        }
#line 9628
        if (section->sh_entsize == 0UL) {
#line 9630
          if ((unsigned long )section == (unsigned long )((void *)0)) {
            {
#line 9630
            tmp___36 = gettext("<none>");
#line 9630
            tmp___41 = tmp___36;
            }
          } else {
#line 9630
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 9630
              tmp___37 = gettext("<no-name>");
#line 9630
              tmp___40 = tmp___37;
              }
            } else {
#line 9630
              if ((unsigned long )section->sh_name >= string_table_length) {
                {
#line 9630
                tmp___38 = gettext("<corrupt>");
#line 9630
                tmp___39 = tmp___38;
                }
              } else {
#line 9630
                tmp___39 = string_table + section->sh_name;
              }
#line 9630
              tmp___40 = tmp___39;
            }
#line 9630
            tmp___41 = tmp___40;
          }
          {
#line 9630
          tmp___42 = gettext("\nSymbol table \'%s\' has a sh_entsize of zero!\n");
#line 9630
          printf((char const   */* __restrict  */)tmp___42, tmp___41);
          }
#line 9632
          goto __Cont___0;
        }
#line 9635
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 9635
          tmp___43 = gettext("<none>");
#line 9635
          tmp___48 = tmp___43;
          }
        } else {
#line 9635
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 9635
            tmp___44 = gettext("<no-name>");
#line 9635
            tmp___47 = tmp___44;
            }
          } else {
#line 9635
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 9635
              tmp___45 = gettext("<corrupt>");
#line 9635
              tmp___46 = tmp___45;
              }
            } else {
#line 9635
              tmp___46 = string_table + section->sh_name;
            }
#line 9635
            tmp___47 = tmp___46;
          }
#line 9635
          tmp___48 = tmp___47;
        }
        {
#line 9635
        tmp___49 = gettext("\nSymbol table \'%s\' contains %lu entries:\n");
#line 9635
        printf((char const   */* __restrict  */)tmp___49, tmp___48, section->sh_size / section->sh_entsize);
        }
#line 9639
        if (is_32bit_elf) {
          {
#line 9640
          tmp___50 = gettext("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n");
#line 9640
          printf((char const   */* __restrict  */)tmp___50);
          }
        } else {
          {
#line 9642
          tmp___51 = gettext("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n");
#line 9642
          printf((char const   */* __restrict  */)tmp___51);
          }
        }
#line 9644
        if (is_32bit_elf) {
          {
#line 9644
          tmp___52 = get_32bit_elf_symbols(file, section, & num_syms);
#line 9644
          symtab = tmp___52;
          }
        } else {
          {
#line 9644
          tmp___53 = get_64bit_elf_symbols(file, section, & num_syms);
#line 9644
          symtab = tmp___53;
          }
        }
#line 9645
        if ((unsigned long )symtab == (unsigned long )((void *)0)) {
#line 9646
          goto __Cont___0;
        }
#line 9648
        if (section->sh_link == elf_header.e_shstrndx) {
#line 9650
          strtab = string_table;
#line 9651
          strtab_size = string_table_length;
        } else
#line 9653
        if (section->sh_link < elf_header.e_shnum) {
          {
#line 9657
          string_sec = section_headers + section->sh_link;
#line 9659
          tmp___54 = gettext("string table");
#line 9659
          tmp___55 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1,
                              string_sec->sh_size, (char const   *)tmp___54);
#line 9659
          strtab = (char *)tmp___55;
          }
#line 9662
          if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 9662
            strtab_size = string_sec->sh_size;
          } else {
#line 9662
            strtab_size = 0UL;
          }
        }
#line 9665
        si___1 = 0U;
#line 9665
        psym = symtab;
        {
#line 9665
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 9665
          if (! ((unsigned long )si___1 < num_syms)) {
#line 9665
            goto while_break___6;
          }
          {
#line 9667
          printf((char const   */* __restrict  */)"%6d: ", si___1);
#line 9668
          print_vma(psym->st_value, (print_mode )6);
#line 9669
          putchar(' ');
#line 9670
          print_vma(psym->st_size, (print_mode )2);
#line 9671
          tmp___56 = get_symbol_type((unsigned int )((int )psym->st_info & 15));
#line 9671
          printf((char const   */* __restrict  */)" %-7s", tmp___56);
#line 9672
          tmp___57 = get_symbol_binding((unsigned int )psym->st_info >> 4);
#line 9672
          printf((char const   */* __restrict  */)" %-6s", tmp___57);
#line 9673
          tmp___58 = get_symbol_visibility((unsigned int )((int )psym->st_other & 3));
#line 9673
          printf((char const   */* __restrict  */)" %-7s", tmp___58);
          }
#line 9677
          if ((int )psym->st_other ^ ((int )psym->st_other & 3)) {
            {
#line 9678
            tmp___59 = get_symbol_other((unsigned int )((int )psym->st_other ^ ((int )psym->st_other & 3)));
#line 9678
            printf((char const   */* __restrict  */)" [%s] ", tmp___59);
            }
          }
          {
#line 9679
          tmp___60 = get_symbol_index_type(psym->st_shndx);
#line 9679
          printf((char const   */* __restrict  */)" %4s ", tmp___60);
          }
#line 9680
          if (psym->st_name < strtab_size) {
#line 9680
            tmp___62 = strtab + psym->st_name;
          } else {
            {
#line 9680
            tmp___61 = gettext("<corrupt>");
#line 9680
            tmp___62 = tmp___61;
            }
          }
          {
#line 9680
          print_symbol(25, (char const   *)tmp___62);
          }
#line 9683
          if (section->sh_type == 11U) {
#line 9683
            if (version_info[15] != 0UL) {
              {
#line 9692
              tmp___63 = offset_from_vma(file, version_info[15], sizeof(data) + (unsigned long )si___1 * sizeof(vers_data));
#line 9692
              offset = (unsigned long )tmp___63;
#line 9696
              tmp___64 = gettext("version data");
#line 9696
              tmp___65 = get_data((void *)(& data), file, (long )(offset + (unsigned long )si___1 * sizeof(vers_data)),
                                  sizeof(data), (size_t )1, (char const   *)tmp___64);
              }
#line 9696
              if ((unsigned long )tmp___65 == (unsigned long )((void *)0)) {
#line 9698
                goto while_break___6;
              }
              {
#line 9700
              tmp___66 = (*byte_get)(data, 2);
#line 9700
              vers_data = (unsigned short )tmp___66;
              }
#line 9702
              if (psym->st_shndx < elf_header.e_shnum) {
#line 9702
                if ((section_headers + psym->st_shndx)->sh_type == 8U) {
#line 9702
                  tmp___67 = 1;
                } else {
#line 9702
                  tmp___67 = 0;
                }
              } else {
#line 9702
                tmp___67 = 0;
              }
#line 9702
              is_nobits = tmp___67;
#line 9706
              check_def = psym->st_shndx != 0U;
#line 9708
              if ((int )vers_data & 32768) {
#line 9708
                goto _L___5;
              } else
#line 9708
              if ((int )vers_data > 1) {
                _L___5: /* CIL Label */ 
#line 9710
                if (version_info[1]) {
#line 9710
                  if (is_nobits) {
#line 9710
                    goto _L___4;
                  } else
#line 9710
                  if (! check_def) {
                    _L___4: /* CIL Label */ 
                    {
#line 9718
                    tmp___68 = offset_from_vma(file, version_info[1], sizeof(evn));
#line 9718
                    offset = (unsigned long )tmp___68;
                    }
                    {
#line 9722
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
                      {
#line 9726
                      tmp___69 = gettext("version need");
#line 9726
                      tmp___70 = get_data((void *)(& evn), file, (long )offset, sizeof(evn),
                                          (size_t )1, (char const   *)tmp___69);
                      }
#line 9726
                      if ((unsigned long )tmp___70 == (unsigned long )((void *)0)) {
#line 9729
                        ivna.vna_next = 0UL;
#line 9730
                        ivna.vna_other = (unsigned short)0;
#line 9731
                        ivna.vna_name = 0UL;
#line 9732
                        goto while_break___7;
                      }
                      {
#line 9735
                      tmp___71 = (*byte_get)(evn.vn_aux, (int )sizeof(evn.vn_aux));
#line 9735
                      ivn.vn_aux = (unsigned long )tmp___71;
#line 9736
                      tmp___72 = (*byte_get)(evn.vn_next, (int )sizeof(evn.vn_next));
#line 9736
                      ivn.vn_next = (unsigned long )tmp___72;
#line 9738
                      vna_off = offset + ivn.vn_aux;
                      }
                      {
#line 9740
                      while (1) {
                        while_continue___8: /* CIL Label */ ;
                        {
#line 9744
                        tmp___76 = gettext("version need aux (3)");
#line 9744
                        tmp___77 = get_data((void *)(& evna), file, (long )vna_off,
                                            sizeof(evna), (size_t )1, (char const   *)tmp___76);
                        }
#line 9744
                        if ((unsigned long )tmp___77 == (unsigned long )((void *)0)) {
#line 9748
                          ivna.vna_next = 0UL;
#line 9749
                          ivna.vna_other = (unsigned short)0;
#line 9750
                          ivna.vna_name = 0UL;
                        } else {
                          {
#line 9754
                          tmp___73 = (*byte_get)(evna.vna_other, (int )sizeof(evna.vna_other));
#line 9754
                          ivna.vna_other = (unsigned short )tmp___73;
#line 9755
                          tmp___74 = (*byte_get)(evna.vna_next, (int )sizeof(evna.vna_next));
#line 9755
                          ivna.vna_next = (unsigned long )tmp___74;
#line 9756
                          tmp___75 = (*byte_get)(evna.vna_name, (int )sizeof(evna.vna_name));
#line 9756
                          ivna.vna_name = (unsigned long )tmp___75;
                          }
                        }
#line 9759
                        vna_off += ivna.vna_next;
#line 9740
                        if ((int )ivna.vna_other != (int )vers_data) {
#line 9740
                          if (! (ivna.vna_next != 0UL)) {
#line 9740
                            goto while_break___8;
                          }
                        } else {
#line 9740
                          goto while_break___8;
                        }
                      }
                      while_break___8: /* CIL Label */ ;
                      }
#line 9764
                      if ((int )ivna.vna_other == (int )vers_data) {
#line 9765
                        goto while_break___7;
                      }
#line 9767
                      offset += ivn.vn_next;
#line 9722
                      if (! (ivn.vn_next != 0UL)) {
#line 9722
                        goto while_break___7;
                      }
                    }
                    while_break___7: /* CIL Label */ ;
                    }
#line 9771
                    if ((int )ivna.vna_other == (int )vers_data) {
#line 9773
                      if (ivna.vna_name < strtab_size) {
#line 9773
                        tmp___79 = strtab + ivna.vna_name;
                      } else {
                        {
#line 9773
                        tmp___78 = gettext("<corrupt>");
#line 9773
                        tmp___79 = tmp___78;
                        }
                      }
                      {
#line 9773
                      printf((char const   */* __restrict  */)"@%s (%d)", tmp___79,
                             (int )ivna.vna_other);
#line 9777
                      check_def = 0;
                      }
                    } else
#line 9779
                    if (! is_nobits) {
                      {
#line 9780
                      tmp___80 = gettext("bad dynamic symbol\n");
#line 9780
                      error((char const   *)tmp___80);
                      }
                    } else {
#line 9782
                      check_def = 1;
                    }
                  }
                }
#line 9785
                if (check_def) {
#line 9787
                  if ((int )vers_data != 32769) {
#line 9787
                    if (version_info[3]) {
                      {
#line 9795
                      tmp___81 = offset_from_vma(file, version_info[3], sizeof(Elf_External_Verdef ));
#line 9795
                      off___0 = (unsigned long )tmp___81;
                      }
                      {
#line 9800
                      while (1) {
                        while_continue___9: /* CIL Label */ ;
                        {
#line 9804
                        tmp___85 = gettext("version def");
#line 9804
                        tmp___86 = get_data((void *)(& evd), file, (long )off___0,
                                            sizeof(evd), (size_t )1, (char const   *)tmp___85);
                        }
#line 9804
                        if ((unsigned long )tmp___86 == (unsigned long )((void *)0)) {
#line 9807
                          ivd.vd_ndx = (unsigned short)0;
#line 9808
                          ivd.vd_aux = 0UL;
#line 9809
                          ivd.vd_next = 0UL;
                        } else {
                          {
#line 9813
                          tmp___82 = (*byte_get)(evd.vd_ndx, (int )sizeof(evd.vd_ndx));
#line 9813
                          ivd.vd_ndx = (unsigned short )tmp___82;
#line 9814
                          tmp___83 = (*byte_get)(evd.vd_aux, (int )sizeof(evd.vd_aux));
#line 9814
                          ivd.vd_aux = (unsigned long )tmp___83;
#line 9815
                          tmp___84 = (*byte_get)(evd.vd_next, (int )sizeof(evd.vd_next));
#line 9815
                          ivd.vd_next = (unsigned long )tmp___84;
                          }
                        }
#line 9818
                        off___0 += ivd.vd_next;
#line 9800
                        if ((int )ivd.vd_ndx != ((int )vers_data & 32767)) {
#line 9800
                          if (! (ivd.vd_next != 0UL)) {
#line 9800
                            goto while_break___9;
                          }
                        } else {
#line 9800
                          goto while_break___9;
                        }
                      }
                      while_break___9: /* CIL Label */ ;
                      }
                      {
#line 9823
                      off___0 -= ivd.vd_next;
#line 9824
                      off___0 += ivd.vd_aux;
#line 9826
                      tmp___87 = gettext("version def aux");
#line 9826
                      tmp___88 = get_data((void *)(& evda), file, (long )off___0,
                                          sizeof(evda), (size_t )1, (char const   *)tmp___87);
                      }
#line 9826
                      if ((unsigned long )tmp___88 == (unsigned long )((void *)0)) {
#line 9828
                        goto while_break___6;
                      }
                      {
#line 9830
                      tmp___89 = (*byte_get)(evda.vda_name, (int )sizeof(evda.vda_name));
#line 9830
                      ivda.vda_name = (unsigned long )tmp___89;
                      }
#line 9832
                      if (psym->st_name != ivda.vda_name) {
#line 9833
                        if (ivda.vda_name < strtab_size) {
#line 9833
                          tmp___91 = strtab + ivda.vda_name;
                        } else {
                          {
#line 9833
                          tmp___90 = gettext("<corrupt>");
#line 9833
                          tmp___91 = tmp___90;
                          }
                        }
#line 9833
                        if ((int )vers_data & 32768) {
#line 9833
                          tmp___92 = "@%s";
                        } else {
#line 9833
                          tmp___92 = "@@%s";
                        }
                        {
#line 9833
                        printf((char const   */* __restrict  */)tmp___92, tmp___91);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          {
#line 9842
          putchar('\n');
#line 9665
          si___1 ++;
#line 9665
          psym ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 9845
        free((void *)symtab);
        }
#line 9846
        if ((unsigned long )strtab != (unsigned long )string_table) {
          {
#line 9847
          free((void *)strtab);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 9611
        i___0 ++;
#line 9611
        section ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 9607
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 9850
  if (do_syms) {
    {
#line 9851
    tmp___93 = gettext("\nDynamic symbol information is not available for displaying symbols.\n");
#line 9851
    printf((char const   */* __restrict  */)tmp___93);
    }
  }
#line 9854
  if (do_histogram) {
#line 9854
    if ((unsigned long )buckets != (unsigned long )((void *)0)) {
      {
#line 9860
      maxlength = 0UL;
#line 9861
      nzero_counts = 0UL;
#line 9862
      nsyms = 0UL;
#line 9864
      tmp___94 = gettext("\nHistogram for bucket list length (total of %lu buckets):\n");
#line 9864
      printf((char const   */* __restrict  */)tmp___94, nbuckets);
#line 9866
      tmp___95 = gettext(" Length  Number     %% of total  Coverage\n");
#line 9866
      printf((char const   */* __restrict  */)tmp___95);
#line 9868
      tmp___96 = calloc(nbuckets, sizeof(*lengths));
#line 9868
      lengths = (unsigned long *)tmp___96;
      }
#line 9869
      if ((unsigned long )lengths == (unsigned long )((void *)0)) {
        {
#line 9871
        tmp___97 = gettext("Out of memory\n");
#line 9871
        error((char const   *)tmp___97);
        }
#line 9872
        return (0);
      }
#line 9874
      hn___0 = 0UL;
      {
#line 9874
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 9874
        if (! (hn___0 < nbuckets)) {
#line 9874
          goto while_break___10;
        }
#line 9876
        si___2 = *(buckets + hn___0);
        {
#line 9876
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 9876
          if (si___2 > 0UL) {
#line 9876
            if (! (si___2 < nchains)) {
#line 9876
              goto while_break___11;
            }
          } else {
#line 9876
            goto while_break___11;
          }
#line 9878
          nsyms ++;
#line 9879
          (*(lengths + hn___0)) ++;
#line 9879
          if (maxlength < *(lengths + hn___0)) {
#line 9880
            maxlength ++;
          }
#line 9876
          si___2 = *(chains + si___2);
        }
        while_break___11: /* CIL Label */ ;
        }
#line 9874
        hn___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 9884
      tmp___98 = calloc(maxlength + 1UL, sizeof(*counts));
#line 9884
      counts = (unsigned long *)tmp___98;
      }
#line 9885
      if ((unsigned long )counts == (unsigned long )((void *)0)) {
        {
#line 9887
        tmp___99 = gettext("Out of memory\n");
#line 9887
        error((char const   *)tmp___99);
        }
#line 9888
        return (0);
      }
#line 9891
      hn___0 = 0UL;
      {
#line 9891
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 9891
        if (! (hn___0 < nbuckets)) {
#line 9891
          goto while_break___12;
        }
#line 9892
        (*(counts + *(lengths + hn___0))) ++;
#line 9891
        hn___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 9894
      if (nbuckets > 0UL) {
        {
#line 9897
        printf((char const   */* __restrict  */)"      0  %-10lu (%5.1f%%)\n", *(counts + 0),
               ((double )*(counts + 0) * 100.0) / (double )nbuckets);
#line 9899
        i___1 = 1UL;
        }
        {
#line 9899
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 9899
          if (! (i___1 <= maxlength)) {
#line 9899
            goto while_break___13;
          }
          {
#line 9901
          nzero_counts += *(counts + i___1) * i___1;
#line 9902
          printf((char const   */* __restrict  */)"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
                 i___1, *(counts + i___1), ((double )*(counts + i___1) * 100.0) / (double )nbuckets,
                 ((double )nzero_counts * 100.0) / (double )nsyms);
#line 9899
          i___1 ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 9908
      free((void *)counts);
#line 9909
      free((void *)lengths);
      }
    }
  }
#line 9912
  if ((unsigned long )buckets != (unsigned long )((void *)0)) {
    {
#line 9914
    free((void *)buckets);
#line 9915
    free((void *)chains);
    }
  }
#line 9918
  if (do_histogram) {
#line 9918
    if ((unsigned long )gnubuckets != (unsigned long )((void *)0)) {
      {
#line 9923
      maxlength___0 = 0UL;
#line 9924
      nzero_counts___0 = 0UL;
#line 9925
      nsyms___0 = 0UL;
#line 9927
      tmp___100 = calloc(ngnubuckets, sizeof(*lengths___0));
#line 9927
      lengths___0 = (unsigned long *)tmp___100;
      }
#line 9928
      if ((unsigned long )lengths___0 == (unsigned long )((void *)0)) {
        {
#line 9930
        tmp___101 = gettext("Out of memory\n");
#line 9930
        error((char const   *)tmp___101);
        }
#line 9931
        return (0);
      }
      {
#line 9934
      tmp___102 = gettext("\nHistogram for `.gnu.hash\' bucket list length (total of %lu buckets):\n");
#line 9934
      printf((char const   */* __restrict  */)tmp___102, ngnubuckets);
#line 9936
      tmp___103 = gettext(" Length  Number     %% of total  Coverage\n");
#line 9936
      printf((char const   */* __restrict  */)tmp___103);
#line 9938
      hn___1 = 0UL;
      }
      {
#line 9938
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 9938
        if (! (hn___1 < ngnubuckets)) {
#line 9938
          goto while_break___14;
        }
#line 9939
        if (*(gnubuckets + hn___1) != 0UL) {
#line 9941
          length = (bfd_vma )1;
#line 9943
          off___1 = *(gnubuckets + hn___1) - gnusymidx;
          {
#line 9943
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 9943
            if (! ((*(gnuchains + off___1) & 1UL) == 0UL)) {
#line 9943
              goto while_break___15;
            }
#line 9945
            length ++;
#line 9943
            off___1 ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 9946
          *(lengths___0 + hn___1) = length;
#line 9947
          if (length > maxlength___0) {
#line 9948
            maxlength___0 = length;
          }
#line 9949
          nsyms___0 += length;
        }
#line 9938
        hn___1 ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 9952
      tmp___104 = calloc(maxlength___0 + 1UL, sizeof(*counts___0));
#line 9952
      counts___0 = (unsigned long *)tmp___104;
      }
#line 9953
      if ((unsigned long )counts___0 == (unsigned long )((void *)0)) {
        {
#line 9955
        tmp___105 = gettext("Out of memory\n");
#line 9955
        error((char const   *)tmp___105);
        }
#line 9956
        return (0);
      }
#line 9959
      hn___1 = 0UL;
      {
#line 9959
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 9959
        if (! (hn___1 < ngnubuckets)) {
#line 9959
          goto while_break___16;
        }
#line 9960
        (*(counts___0 + *(lengths___0 + hn___1))) ++;
#line 9959
        hn___1 ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 9962
      if (ngnubuckets > 0UL) {
        {
#line 9965
        printf((char const   */* __restrict  */)"      0  %-10lu (%5.1f%%)\n", *(counts___0 + 0),
               ((double )*(counts___0 + 0) * 100.0) / (double )ngnubuckets);
#line 9967
        j = 1UL;
        }
        {
#line 9967
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 9967
          if (! (j <= maxlength___0)) {
#line 9967
            goto while_break___17;
          }
          {
#line 9969
          nzero_counts___0 += *(counts___0 + j) * j;
#line 9970
          printf((char const   */* __restrict  */)"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
                 j, *(counts___0 + j), ((double )*(counts___0 + j) * 100.0) / (double )ngnubuckets,
                 ((double )nzero_counts___0 * 100.0) / (double )nsyms___0);
#line 9967
          j ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
      }
      {
#line 9976
      free((void *)counts___0);
#line 9977
      free((void *)lengths___0);
#line 9978
      free((void *)gnubuckets);
#line 9979
      free((void *)gnuchains);
      }
    }
  }
#line 9982
  return (1);
}
}
#line 9985 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_syminfo(FILE *file  __attribute__((__unused__)) ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short flags___1 ;
  char *tmp___2 ;

  {
#line 9990
  if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
#line 9993
    return (1);
  } else
#line 9990
  if (! do_dynamic) {
#line 9993
    return (1);
  }
#line 9996
  if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
#line 9997
    return (0);
  } else
#line 9996
  if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 9997
    return (0);
  }
#line 9999
  if (dynamic_addr) {
    {
#line 10000
    tmp___0 = gettext("\nDynamic info segment at offset 0x%lx contains %d entries:\n");
#line 10000
    printf((char const   */* __restrict  */)tmp___0, dynamic_syminfo_offset, dynamic_syminfo_nent);
    }
  }
  {
#line 10003
  tmp___1 = gettext(" Num: Name                           BoundTo     Flags\n");
#line 10003
  printf((char const   */* __restrict  */)tmp___1);
#line 10004
  i = 0U;
  }
  {
#line 10004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10004
    if (! (i < dynamic_syminfo_nent)) {
#line 10004
      goto while_break;
    }
    {
#line 10006
    flags___1 = (dynamic_syminfo + i)->si_flags;
#line 10008
    printf((char const   */* __restrict  */)"%4d: ", i);
    }
#line 10009
    if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 10009
      if ((dynamic_symbols + i)->st_name < dynamic_strings_length) {
        {
#line 10010
        print_symbol(30, (char const   *)(dynamic_strings + (dynamic_symbols + i)->st_name));
        }
      } else {
        {
#line 10012
        tmp___2 = gettext("<corrupt: %19ld>");
#line 10012
        printf((char const   */* __restrict  */)tmp___2, (dynamic_symbols + i)->st_name);
        }
      }
    } else {
      {
#line 10012
      tmp___2 = gettext("<corrupt: %19ld>");
#line 10012
      printf((char const   */* __restrict  */)tmp___2, (dynamic_symbols + i)->st_name);
      }
    }
    {
#line 10013
    putchar(' ');
    }
    {
#line 10017
    if ((int )(dynamic_syminfo + i)->si_boundto == 65535) {
#line 10017
      goto case_65535;
    }
#line 10020
    if ((int )(dynamic_syminfo + i)->si_boundto == 65534) {
#line 10020
      goto case_65534;
    }
#line 10023
    goto switch_default;
    case_65535: /* CIL Label */ 
    {
#line 10018
    fputs((char const   */* __restrict  */)"SELF       ", (FILE */* __restrict  */)stdout);
    }
#line 10019
    goto switch_break;
    case_65534: /* CIL Label */ 
    {
#line 10021
    fputs((char const   */* __restrict  */)"PARENT     ", (FILE */* __restrict  */)stdout);
    }
#line 10022
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 10024
    if ((int )(dynamic_syminfo + i)->si_boundto > 0) {
#line 10024
      if ((unsigned int )(dynamic_syminfo + i)->si_boundto < dynamic_nent) {
#line 10024
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 10024
          if ((dynamic_section + (dynamic_syminfo + i)->si_boundto)->d_un.d_val < dynamic_strings_length) {
            {
#line 10028
            print_symbol(10, (char const   *)(dynamic_strings + (dynamic_section + (dynamic_syminfo + i)->si_boundto)->d_un.d_val));
#line 10029
            putchar(' ');
            }
          } else {
            {
#line 10032
            printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
            }
          }
        } else {
          {
#line 10032
          printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
          }
        }
      } else {
        {
#line 10032
        printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
        }
      }
    } else {
      {
#line 10032
      printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
      }
    }
#line 10033
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 10036
    if ((int )flags___1 & 1) {
      {
#line 10037
      printf((char const   */* __restrict  */)" DIRECT");
      }
    }
#line 10038
    if ((int )flags___1 & 2) {
      {
#line 10039
      printf((char const   */* __restrict  */)" PASSTHRU");
      }
    }
#line 10040
    if ((int )flags___1 & 4) {
      {
#line 10041
      printf((char const   */* __restrict  */)" COPY");
      }
    }
#line 10042
    if ((int )flags___1 & 8) {
      {
#line 10043
      printf((char const   */* __restrict  */)" LAZYLOAD");
      }
    }
    {
#line 10045
    puts("");
#line 10004
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 10048
  return (1);
}
}
#line 10067
static bfd_boolean target_specific_reloc_handling(Elf_Internal_Rela *reloc , unsigned char *start ,
                                                  Elf_Internal_Sym *symtab ) ;
#line 10067 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Sym *saved_sym  =    (Elf_Internal_Sym *)((void *)0);
#line 10121 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static Elf_Internal_Sym *saved_sym___0  =    (Elf_Internal_Sym *)((void *)0);
#line 10055 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean target_specific_reloc_handling(Elf_Internal_Rela *reloc , unsigned char *start ,
                                                  Elf_Internal_Sym *symtab ) 
{ 
  unsigned int reloc_type ;
  unsigned int tmp___0 ;
  bfd_boolean tmp___1 ;
  bfd_vma tmp___2 ;
  bfd_boolean tmp___3 ;
  bfd_boolean tmp___4 ;
  bfd_vma value ;
  bfd_vma tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  bfd_vma tmp___8 ;
  bfd_vma value___0 ;
  bfd_vma tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 10060
  tmp___0 = get_reloc_type(reloc->r_info);
#line 10060
  reloc_type = tmp___0;
  }
  {
#line 10065
  if ((int )elf_header.e_machine == 4185) {
#line 10065
    goto case_4185;
  }
#line 10065
  if ((int )elf_header.e_machine == 105) {
#line 10065
    goto case_4185;
  }
#line 10119
  if ((int )elf_header.e_machine == 48879) {
#line 10119
    goto case_48879;
  }
#line 10119
  if ((int )elf_header.e_machine == 89) {
#line 10119
    goto case_48879;
  }
#line 10062
  goto switch_break;
  case_4185: /* CIL Label */ 
  case_105: /* CIL Label */ 
  {
#line 10071
  if (reloc_type == 10U) {
#line 10071
    goto case_10;
  }
#line 10074
  if (reloc_type == 21U) {
#line 10074
    goto case_21;
  }
#line 10079
  if (reloc_type == 3U) {
#line 10079
    goto case_3;
  }
#line 10079
  if (reloc_type == 1U) {
#line 10079
    goto case_3;
  }
#line 10083
  if (reloc_type == 9U) {
#line 10083
    goto case_9;
  }
#line 10083
  if (reloc_type == 5U) {
#line 10083
    goto case_9;
  }
#line 10089
  if (reloc_type == 15U) {
#line 10089
    goto case_15;
  }
#line 10089
  if (reloc_type == 2U) {
#line 10089
    goto case_15;
  }
#line 10110
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 10072
  tmp___1 = uses_msp430x_relocs();
  }
#line 10072
  if (tmp___1) {
#line 10073
    goto switch_break___0;
  }
  case_21: /* CIL Label */ 
  {
#line 10075
  tmp___2 = get_reloc_symindex(reloc->r_info);
#line 10075
  saved_sym = symtab + tmp___2;
  }
#line 10076
  return (1);
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 10080
  goto handle_sym_diff;
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 10084
  tmp___3 = uses_msp430x_relocs();
  }
#line 10084
  if (tmp___3) {
#line 10085
    goto switch_break___0;
  }
#line 10086
  goto handle_sym_diff;
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 10090
  tmp___4 = uses_msp430x_relocs();
  }
#line 10090
  if (! tmp___4) {
#line 10091
    goto switch_break___0;
  }
#line 10092
  goto handle_sym_diff;
  handle_sym_diff: 
#line 10095
  if ((unsigned long )saved_sym != (unsigned long )((void *)0)) {
    {
#line 10099
    tmp___5 = get_reloc_symindex(reloc->r_info);
#line 10099
    value = reloc->r_addend + ((symtab + tmp___5)->st_value - saved_sym->st_value);
    }
#line 10103
    if (reloc_type == 1U) {
#line 10103
      tmp___6 = 4;
    } else {
#line 10103
      tmp___6 = 2;
    }
    {
#line 10103
    (*byte_put)(start + reloc->r_offset, (elf_vma )value, tmp___6);
#line 10105
    saved_sym = (Elf_Internal_Sym *)((void *)0);
    }
#line 10106
    return (1);
  }
#line 10108
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 10111
  if ((unsigned long )saved_sym != (unsigned long )((void *)0)) {
    {
#line 10112
    tmp___7 = gettext("Unhandled MSP430 reloc type found after SYM_DIFF reloc");
#line 10112
    error((char const   *)tmp___7);
    }
  }
#line 10113
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 10115
  goto switch_break;
  case_48879: /* CIL Label */ 
  case_89: /* CIL Label */ 
  {
#line 10125
  if (reloc_type == 34U) {
#line 10125
    goto case_34;
  }
#line 10127
  if (reloc_type == 33U) {
#line 10127
    goto case_33;
  }
#line 10131
  if (reloc_type == 2U) {
#line 10131
    goto case_2___0;
  }
#line 10131
  if (reloc_type == 1U) {
#line 10131
    goto case_2___0;
  }
#line 10146
  goto switch_default___0;
  case_34: /* CIL Label */ 
#line 10126
  return (1);
  case_33: /* CIL Label */ 
  {
#line 10128
  tmp___8 = get_reloc_symindex(reloc->r_info);
#line 10128
  saved_sym___0 = symtab + tmp___8;
  }
#line 10129
  return (1);
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 10132
  if ((unsigned long )saved_sym___0 != (unsigned long )((void *)0)) {
    {
#line 10136
    tmp___9 = get_reloc_symindex(reloc->r_info);
#line 10136
    value___0 = reloc->r_addend + ((symtab + tmp___9)->st_value - saved_sym___0->st_value);
    }
#line 10140
    if (reloc_type == 1U) {
#line 10140
      tmp___10 = 4;
    } else {
#line 10140
      tmp___10 = 2;
    }
    {
#line 10140
    (*byte_put)(start + reloc->r_offset, (elf_vma )value___0, tmp___10);
#line 10142
    saved_sym___0 = (Elf_Internal_Sym *)((void *)0);
    }
#line 10143
    return (1);
  }
#line 10145
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 10147
  if ((unsigned long )saved_sym___0 != (unsigned long )((void *)0)) {
    {
#line 10148
    tmp___11 = gettext("Unhandled MN10300 reloc type found after SYM_DIFF reloc");
#line 10148
    error((char const   *)tmp___11);
    }
  }
#line 10149
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 10151
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 10155
  return (0);
}
}
#line 10169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_32bit_abs_reloc(unsigned int reloc_type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 10175
  if ((int )elf_header.e_machine == 6) {
#line 10175
    goto case_6;
  }
#line 10175
  if ((int )elf_header.e_machine == 3) {
#line 10175
    goto case_6;
  }
#line 10177
  if ((int )elf_header.e_machine == 4) {
#line 10177
    goto case_4;
  }
#line 10179
  if ((int )elf_header.e_machine == 7) {
#line 10179
    goto case_7;
  }
#line 10181
  if ((int )elf_header.e_machine == 19) {
#line 10181
    goto case_19;
  }
#line 10183
  if ((int )elf_header.e_machine == 183) {
#line 10183
    goto case_183;
  }
#line 10185
  if ((int )elf_header.e_machine == 36902) {
#line 10185
    goto case_36902;
  }
#line 10187
  if ((int )elf_header.e_machine == 45) {
#line 10187
    goto case_45;
  }
#line 10189
  if ((int )elf_header.e_machine == 40) {
#line 10189
    goto case_40;
  }
#line 10192
  if ((int )elf_header.e_machine == 83) {
#line 10192
    goto case_83;
  }
#line 10192
  if ((int )elf_header.e_machine == 4183) {
#line 10192
    goto case_83;
  }
#line 10194
  if ((int )elf_header.e_machine == 4643) {
#line 10194
    goto case_4643;
  }
#line 10196
  if ((int )elf_header.e_machine == 106) {
#line 10196
    goto case_106;
  }
#line 10198
  if ((int )elf_header.e_machine == 76) {
#line 10198
    goto case_76;
  }
#line 10200
  if ((int )elf_header.e_machine == 177) {
#line 10200
    goto case_177;
  }
#line 10202
  if ((int )elf_header.e_machine == 114) {
#line 10202
    goto case_114;
  }
#line 10204
  if ((int )elf_header.e_machine == 21569) {
#line 10204
    goto case_21569;
  }
#line 10207
  if ((int )elf_header.e_machine == 85) {
#line 10207
    goto case_85;
  }
#line 10207
  if ((int )elf_header.e_machine == 30288) {
#line 10207
    goto case_85;
  }
#line 10210
  if ((int )elf_header.e_machine == 86) {
#line 10210
    goto case_86;
  }
#line 10210
  if ((int )elf_header.e_machine == 30326) {
#line 10210
    goto case_86;
  }
#line 10212
  if ((int )elf_header.e_machine == 23205) {
#line 10212
    goto case_23205;
  }
#line 10215
  if ((int )elf_header.e_machine == 84) {
#line 10215
    goto case_84;
  }
#line 10215
  if ((int )elf_header.e_machine == 13104) {
#line 10215
    goto case_84;
  }
#line 10219
  if ((int )elf_header.e_machine == 47) {
#line 10219
    goto case_47;
  }
#line 10219
  if ((int )elf_header.e_machine == 46) {
#line 10219
    goto case_47;
  }
#line 10219
  if ((int )elf_header.e_machine == 48) {
#line 10219
    goto case_47;
  }
#line 10221
  if ((int )elf_header.e_machine == 50) {
#line 10221
    goto case_50;
  }
#line 10224
  if ((int )elf_header.e_machine == 101) {
#line 10224
    goto case_101;
  }
#line 10224
  if ((int )elf_header.e_machine == 33303) {
#line 10224
    goto case_101;
  }
#line 10226
  if ((int )elf_header.e_machine == 65210) {
#line 10226
    goto case_65210;
  }
#line 10228
  if ((int )elf_header.e_machine == 138) {
#line 10228
    goto case_138;
  }
#line 10231
  if ((int )elf_header.e_machine == 120) {
#line 10231
    goto case_120;
  }
#line 10231
  if ((int )elf_header.e_machine == 65200) {
#line 10231
    goto case_120;
  }
#line 10233
  if ((int )elf_header.e_machine == 88) {
#line 10233
    goto case_88;
  }
#line 10235
  if ((int )elf_header.e_machine == 39) {
#line 10235
    goto case_39;
  }
#line 10237
  if ((int )elf_header.e_machine == 61453) {
#line 10237
    goto case_61453;
  }
#line 10239
  if ((int )elf_header.e_machine == 174) {
#line 10239
    goto case_174;
  }
#line 10241
  if ((int )elf_header.e_machine == 189) {
#line 10241
    goto case_189;
  }
#line 10243
  if ((int )elf_header.e_machine == 8) {
#line 10243
    goto case_8;
  }
#line 10245
  if ((int )elf_header.e_machine == 80) {
#line 10245
    goto case_80;
  }
#line 10248
  if ((int )elf_header.e_machine == 90) {
#line 10248
    goto case_90;
  }
#line 10248
  if ((int )elf_header.e_machine == 57005) {
#line 10248
    goto case_90;
  }
#line 10251
  if ((int )elf_header.e_machine == 89) {
#line 10251
    goto case_89;
  }
#line 10251
  if ((int )elf_header.e_machine == 48879) {
#line 10251
    goto case_89;
  }
#line 10253
  if ((int )elf_header.e_machine == 65261) {
#line 10253
    goto case_65261;
  }
#line 10256
  if ((int )elf_header.e_machine == 105) {
#line 10256
    goto case_105;
  }
#line 10256
  if ((int )elf_header.e_machine == 4185) {
#line 10256
    goto case_105;
  }
#line 10258
  if ((int )elf_header.e_machine == 9520) {
#line 10258
    goto case_9520;
  }
#line 10260
  if ((int )elf_header.e_machine == 113) {
#line 10260
    goto case_113;
  }
#line 10262
  if ((int )elf_header.e_machine == 65211) {
#line 10262
    goto case_65211;
  }
#line 10265
  if ((int )elf_header.e_machine == 33906) {
#line 10265
    goto case_33906;
  }
#line 10265
  if ((int )elf_header.e_machine == 92) {
#line 10265
    goto case_33906;
  }
#line 10267
  if ((int )elf_header.e_machine == 15) {
#line 10267
    goto case_15;
  }
#line 10271
  if ((int )elf_header.e_machine == 99) {
#line 10271
    goto case_99;
  }
#line 10271
  if ((int )elf_header.e_machine == 91) {
#line 10271
    goto case_99;
  }
#line 10273
  if ((int )elf_header.e_machine == 21) {
#line 10273
    goto case_21;
  }
#line 10275
  if ((int )elf_header.e_machine == 20) {
#line 10275
    goto case_20;
  }
#line 10277
  if ((int )elf_header.e_machine == 197) {
#line 10277
    goto case_197;
  }
#line 10279
  if ((int )elf_header.e_machine == 173) {
#line 10279
    goto case_173;
  }
#line 10281
  if ((int )elf_header.e_machine == 9) {
#line 10281
    goto case_9;
  }
#line 10284
  if ((int )elf_header.e_machine == 22) {
#line 10284
    goto case_22;
  }
#line 10284
  if ((int )elf_header.e_machine == 41872) {
#line 10284
    goto case_22;
  }
#line 10286
  if ((int )elf_header.e_machine == 135) {
#line 10286
    goto case_135;
  }
#line 10288
  if ((int )elf_header.e_machine == 42) {
#line 10288
    goto case_42;
  }
#line 10292
  if ((int )elf_header.e_machine == 2) {
#line 10292
    goto case_2;
  }
#line 10292
  if ((int )elf_header.e_machine == 43) {
#line 10292
    goto case_2;
  }
#line 10292
  if ((int )elf_header.e_machine == 18) {
#line 10292
    goto case_2;
  }
#line 10295
  if ((int )elf_header.e_machine == 23) {
#line 10295
    goto case_23;
  }
#line 10297
  if ((int )elf_header.e_machine == 140) {
#line 10297
    goto case_140;
  }
#line 10299
  if ((int )elf_header.e_machine == 191) {
#line 10299
    goto case_191;
  }
#line 10301
  if ((int )elf_header.e_machine == 188) {
#line 10301
    goto case_188;
  }
#line 10304
  if ((int )elf_header.e_machine == 87) {
#line 10304
    goto case_87;
  }
#line 10304
  if ((int )elf_header.e_machine == 36992) {
#line 10304
    goto case_87;
  }
#line 10306
  if ((int )elf_header.e_machine == 36) {
#line 10306
    goto case_36;
  }
#line 10308
  if ((int )elf_header.e_machine == 75) {
#line 10308
    goto case_75;
  }
#line 10312
  if ((int )elf_header.e_machine == 181) {
#line 10312
    goto case_181;
  }
#line 10312
  if ((int )elf_header.e_machine == 180) {
#line 10312
    goto case_181;
  }
#line 10312
  if ((int )elf_header.e_machine == 62) {
#line 10312
    goto case_181;
  }
#line 10315
  if ((int )elf_header.e_machine == 116) {
#line 10315
    goto case_116;
  }
#line 10315
  if ((int )elf_header.e_machine == 18056) {
#line 10315
    goto case_116;
  }
#line 10317
  if ((int )elf_header.e_machine == 115) {
#line 10317
    goto case_115;
  }
#line 10319
  if ((int )elf_header.e_machine == 44357) {
#line 10319
    goto case_44357;
  }
#line 10322
  if ((int )elf_header.e_machine == 94) {
#line 10322
    goto case_94;
  }
#line 10322
  if ((int )elf_header.e_machine == 43975) {
#line 10322
    goto case_94;
  }
#line 10324
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 10176
  return (reloc_type == 1U);
  case_4: /* CIL Label */ 
#line 10178
  return (reloc_type == 1U);
  case_7: /* CIL Label */ 
#line 10180
  return (reloc_type == 1U);
  case_19: /* CIL Label */ 
#line 10182
  return (reloc_type == 2U);
  case_183: /* CIL Label */ 
#line 10184
  return (reloc_type == 258U);
  case_36902: /* CIL Label */ 
#line 10186
  return (reloc_type == 1U);
  case_45: /* CIL Label */ 
#line 10188
  return (reloc_type == 1U);
  case_40: /* CIL Label */ 
#line 10190
  return (reloc_type == 2U);
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 10193
  return (reloc_type == 1U);
  case_4643: /* CIL Label */ 
#line 10195
  return (reloc_type == 3U);
  case_106: /* CIL Label */ 
#line 10197
  return (reloc_type == 18U);
  case_76: /* CIL Label */ 
#line 10199
  return (reloc_type == 3U);
  case_177: /* CIL Label */ 
#line 10201
  return (reloc_type == 3U);
  case_114: /* CIL Label */ 
#line 10203
  return (reloc_type == 15U);
  case_21569: /* CIL Label */ 
#line 10205
  return (reloc_type == 1U);
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 10208
  return (reloc_type == 6U);
  case_86: /* CIL Label */ 
  case_30326: /* CIL Label */ 
#line 10211
  return (reloc_type == 12U);
  case_23205: /* CIL Label */ 
#line 10213
  return (reloc_type == 3U);
  case_84: /* CIL Label */ 
  case_13104: /* CIL Label */ 
#line 10216
  return (reloc_type == 3U);
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 10220
  return (reloc_type == 1U);
  case_50: /* CIL Label */ 
#line 10222
  return (reloc_type == 101U);
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 10225
  return (reloc_type == 2U);
  case_65210: /* CIL Label */ 
#line 10227
  return (reloc_type == 2U);
  case_138: /* CIL Label */ 
#line 10229
  return (reloc_type == 3U);
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 10232
  return (reloc_type == 3U);
  case_88: /* CIL Label */ 
#line 10234
  return (reloc_type == 34U);
  case_39: /* CIL Label */ 
#line 10236
  return (reloc_type == 1U);
  case_61453: /* CIL Label */ 
#line 10238
  return (reloc_type == 4U);
  case_174: /* CIL Label */ 
#line 10240
  return (reloc_type == 2U);
  case_189: /* CIL Label */ 
#line 10242
  return (reloc_type == 1U);
  case_8: /* CIL Label */ 
#line 10244
  return (reloc_type == 2U);
  case_80: /* CIL Label */ 
#line 10246
  return (reloc_type == 4U);
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 10249
  return (reloc_type == 1U);
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 10252
  return (reloc_type == 1U);
  case_65261: /* CIL Label */ 
#line 10254
  return (reloc_type == 1U);
  case_105: /* CIL Label */ 
  case_4185: /* CIL Label */ 
#line 10257
  return (reloc_type == 1U);
  case_9520: /* CIL Label */ 
#line 10259
  return (reloc_type == 2U);
  case_113: /* CIL Label */ 
#line 10261
  return (reloc_type == 12U);
  case_65211: /* CIL Label */ 
#line 10263
  return (reloc_type == 1U);
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 10266
  return (reloc_type == 1U);
  case_15: /* CIL Label */ 
#line 10268
  if (reloc_type == 1U) {
#line 10268
    tmp___0 = 1;
  } else
#line 10268
  if (reloc_type == 41U) {
#line 10268
    tmp___0 = 1;
  } else {
#line 10268
    tmp___0 = 0;
  }
#line 10268
  return (tmp___0);
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
#line 10272
  return (reloc_type == 1U);
  case_21: /* CIL Label */ 
#line 10274
  return (reloc_type == 1U);
  case_20: /* CIL Label */ 
#line 10276
  return (reloc_type == 1U);
  case_197: /* CIL Label */ 
#line 10278
  return (reloc_type == 1U);
  case_173: /* CIL Label */ 
#line 10280
  return (reloc_type == 1U);
  case_9: /* CIL Label */ 
#line 10282
  return (reloc_type == 1U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10285
  return (reloc_type == 4U);
  case_135: /* CIL Label */ 
#line 10287
  return (reloc_type == 8U);
  case_42: /* CIL Label */ 
#line 10289
  return (reloc_type == 1U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10293
  if (reloc_type == 3U) {
#line 10293
    tmp___1 = 1;
  } else
#line 10293
  if (reloc_type == 23U) {
#line 10293
    tmp___1 = 1;
  } else {
#line 10293
    tmp___1 = 0;
  }
#line 10293
  return (tmp___1);
  case_23: /* CIL Label */ 
#line 10296
  return (reloc_type == 6U);
  case_140: /* CIL Label */ 
#line 10298
  return (reloc_type == 1U);
  case_191: /* CIL Label */ 
#line 10300
  return (reloc_type == 2U);
  case_188: /* CIL Label */ 
#line 10302
  return (reloc_type == 1U);
  case_87: /* CIL Label */ 
  case_36992: /* CIL Label */ 
#line 10305
  return (reloc_type == 6U);
  case_36: /* CIL Label */ 
#line 10307
  return (reloc_type == 51U);
  case_75: /* CIL Label */ 
#line 10309
  return (reloc_type == 1U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10313
  return (reloc_type == 10U);
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
#line 10316
  return (reloc_type == 3U);
  case_115: /* CIL Label */ 
#line 10318
  return (reloc_type == 4U);
  case_44357: /* CIL Label */ 
#line 10320
  return (reloc_type == 1U);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 10323
  return (reloc_type == 1U);
  switch_default: /* CIL Label */ 
  {
#line 10325
  tmp___2 = gettext("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n");
#line 10325
  error((char const   *)tmp___2, (int )elf_header.e_machine);
#line 10327
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10334 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_32bit_pcrel_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10340
  if ((int )elf_header.e_machine == 6) {
#line 10340
    goto case_6;
  }
#line 10340
  if ((int )elf_header.e_machine == 3) {
#line 10340
    goto case_6;
  }
#line 10342
  if ((int )elf_header.e_machine == 4) {
#line 10342
    goto case_4;
  }
#line 10344
  if ((int )elf_header.e_machine == 183) {
#line 10344
    goto case_183;
  }
#line 10346
  if ((int )elf_header.e_machine == 4643) {
#line 10346
    goto case_4643;
  }
#line 10348
  if ((int )elf_header.e_machine == 36902) {
#line 10348
    goto case_36902;
  }
#line 10350
  if ((int )elf_header.e_machine == 40) {
#line 10350
    goto case_40;
  }
#line 10352
  if ((int )elf_header.e_machine == 189) {
#line 10352
    goto case_189;
  }
#line 10354
  if ((int )elf_header.e_machine == 15) {
#line 10354
    goto case_15;
  }
#line 10356
  if ((int )elf_header.e_machine == 20) {
#line 10356
    goto case_20;
  }
#line 10358
  if ((int )elf_header.e_machine == 21) {
#line 10358
    goto case_21;
  }
#line 10361
  if ((int )elf_header.e_machine == 22) {
#line 10361
    goto case_22;
  }
#line 10361
  if ((int )elf_header.e_machine == 41872) {
#line 10361
    goto case_22;
  }
#line 10363
  if ((int )elf_header.e_machine == 42) {
#line 10363
    goto case_42;
  }
#line 10367
  if ((int )elf_header.e_machine == 2) {
#line 10367
    goto case_2;
  }
#line 10367
  if ((int )elf_header.e_machine == 43) {
#line 10367
    goto case_2;
  }
#line 10367
  if ((int )elf_header.e_machine == 18) {
#line 10367
    goto case_2;
  }
#line 10369
  if ((int )elf_header.e_machine == 23) {
#line 10369
    goto case_23;
  }
#line 10371
  if ((int )elf_header.e_machine == 191) {
#line 10371
    goto case_191;
  }
#line 10373
  if ((int )elf_header.e_machine == 188) {
#line 10373
    goto case_188;
  }
#line 10377
  if ((int )elf_header.e_machine == 181) {
#line 10377
    goto case_181;
  }
#line 10377
  if ((int )elf_header.e_machine == 180) {
#line 10377
    goto case_181;
  }
#line 10377
  if ((int )elf_header.e_machine == 62) {
#line 10377
    goto case_181;
  }
#line 10380
  if ((int )elf_header.e_machine == 94) {
#line 10380
    goto case_94;
  }
#line 10380
  if ((int )elf_header.e_machine == 43975) {
#line 10380
    goto case_94;
  }
#line 10382
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 10341
  return (reloc_type == 2U);
  case_4: /* CIL Label */ 
#line 10343
  return (reloc_type == 4U);
  case_183: /* CIL Label */ 
#line 10345
  return (reloc_type == 261U);
  case_4643: /* CIL Label */ 
#line 10347
  return (reloc_type == 6U);
  case_36902: /* CIL Label */ 
#line 10349
  return (reloc_type == 10U);
  case_40: /* CIL Label */ 
#line 10351
  return (reloc_type == 3U);
  case_189: /* CIL Label */ 
#line 10353
  return (reloc_type == 2U);
  case_15: /* CIL Label */ 
#line 10355
  return (reloc_type == 9U);
  case_20: /* CIL Label */ 
#line 10357
  return (reloc_type == 26U);
  case_21: /* CIL Label */ 
#line 10359
  return (reloc_type == 26U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10362
  return (reloc_type == 5U);
  case_42: /* CIL Label */ 
#line 10364
  return (reloc_type == 2U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10368
  return (reloc_type == 6U);
  case_23: /* CIL Label */ 
#line 10370
  return (reloc_type == 13U);
  case_191: /* CIL Label */ 
#line 10372
  return (reloc_type == 6U);
  case_188: /* CIL Label */ 
#line 10374
  return (reloc_type == 4U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10378
  return (reloc_type == 2U);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 10381
  return (reloc_type == 14U);
  switch_default: /* CIL Label */ 
#line 10388
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10395 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_64bit_abs_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10400
  if ((int )elf_header.e_machine == 183) {
#line 10400
    goto case_183;
  }
#line 10402
  if ((int )elf_header.e_machine == 36902) {
#line 10402
    goto case_36902;
  }
#line 10404
  if ((int )elf_header.e_machine == 50) {
#line 10404
    goto case_50;
  }
#line 10406
  if ((int )elf_header.e_machine == 15) {
#line 10406
    goto case_15;
  }
#line 10408
  if ((int )elf_header.e_machine == 21) {
#line 10408
    goto case_21;
  }
#line 10412
  if ((int )elf_header.e_machine == 2) {
#line 10412
    goto case_2;
  }
#line 10412
  if ((int )elf_header.e_machine == 43) {
#line 10412
    goto case_2;
  }
#line 10412
  if ((int )elf_header.e_machine == 18) {
#line 10412
    goto case_2;
  }
#line 10416
  if ((int )elf_header.e_machine == 181) {
#line 10416
    goto case_181;
  }
#line 10416
  if ((int )elf_header.e_machine == 180) {
#line 10416
    goto case_181;
  }
#line 10416
  if ((int )elf_header.e_machine == 62) {
#line 10416
    goto case_181;
  }
#line 10419
  if ((int )elf_header.e_machine == 22) {
#line 10419
    goto case_22;
  }
#line 10419
  if ((int )elf_header.e_machine == 41872) {
#line 10419
    goto case_22;
  }
#line 10421
  if ((int )elf_header.e_machine == 191) {
#line 10421
    goto case_191;
  }
#line 10423
  if ((int )elf_header.e_machine == 8) {
#line 10423
    goto case_8;
  }
#line 10425
  goto switch_default;
  case_183: /* CIL Label */ 
#line 10401
  return (reloc_type == 257U);
  case_36902: /* CIL Label */ 
#line 10403
  return (reloc_type == 2U);
  case_50: /* CIL Label */ 
#line 10405
  return (reloc_type == 39U);
  case_15: /* CIL Label */ 
#line 10407
  return (reloc_type == 80U);
  case_21: /* CIL Label */ 
#line 10409
  return (reloc_type == 38U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10413
  return (reloc_type == 54U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10417
  return (reloc_type == 1U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10420
  return (reloc_type == 22U);
  case_191: /* CIL Label */ 
#line 10422
  return (reloc_type == 1U);
  case_8: /* CIL Label */ 
#line 10424
  return (reloc_type == 18U);
  switch_default: /* CIL Label */ 
#line 10426
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10433 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_64bit_pcrel_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10438
  if ((int )elf_header.e_machine == 183) {
#line 10438
    goto case_183;
  }
#line 10440
  if ((int )elf_header.e_machine == 36902) {
#line 10440
    goto case_36902;
  }
#line 10442
  if ((int )elf_header.e_machine == 50) {
#line 10442
    goto case_50;
  }
#line 10444
  if ((int )elf_header.e_machine == 15) {
#line 10444
    goto case_15;
  }
#line 10446
  if ((int )elf_header.e_machine == 21) {
#line 10446
    goto case_21;
  }
#line 10450
  if ((int )elf_header.e_machine == 2) {
#line 10450
    goto case_2;
  }
#line 10450
  if ((int )elf_header.e_machine == 43) {
#line 10450
    goto case_2;
  }
#line 10450
  if ((int )elf_header.e_machine == 18) {
#line 10450
    goto case_2;
  }
#line 10454
  if ((int )elf_header.e_machine == 181) {
#line 10454
    goto case_181;
  }
#line 10454
  if ((int )elf_header.e_machine == 180) {
#line 10454
    goto case_181;
  }
#line 10454
  if ((int )elf_header.e_machine == 62) {
#line 10454
    goto case_181;
  }
#line 10457
  if ((int )elf_header.e_machine == 22) {
#line 10457
    goto case_22;
  }
#line 10457
  if ((int )elf_header.e_machine == 41872) {
#line 10457
    goto case_22;
  }
#line 10459
  if ((int )elf_header.e_machine == 191) {
#line 10459
    goto case_191;
  }
#line 10461
  goto switch_default;
  case_183: /* CIL Label */ 
#line 10439
  return (reloc_type == 260U);
  case_36902: /* CIL Label */ 
#line 10441
  return (reloc_type == 11U);
  case_50: /* CIL Label */ 
#line 10443
  return (reloc_type == 79U);
  case_15: /* CIL Label */ 
#line 10445
  return (reloc_type == 72U);
  case_21: /* CIL Label */ 
#line 10447
  return (reloc_type == 44U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10451
  return (reloc_type == 46U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10455
  return (reloc_type == 24U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10458
  return (reloc_type == 23U);
  case_191: /* CIL Label */ 
#line 10460
  return (reloc_type == 5U);
  switch_default: /* CIL Label */ 
#line 10462
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10469 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_24bit_abs_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10475
  if ((int )elf_header.e_machine == 90) {
#line 10475
    goto case_90;
  }
#line 10475
  if ((int )elf_header.e_machine == 57005) {
#line 10475
    goto case_90;
  }
#line 10477
  goto switch_default;
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 10476
  return (reloc_type == 4U);
  switch_default: /* CIL Label */ 
#line 10478
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10485 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_16bit_abs_reloc(unsigned int reloc_type ) 
{ 
  bfd_boolean tmp___0 ;

  {
  {
#line 10491
  if ((int )elf_header.e_machine == 83) {
#line 10491
    goto case_83;
  }
#line 10491
  if ((int )elf_header.e_machine == 4183) {
#line 10491
    goto case_83;
  }
#line 10493
  if ((int )elf_header.e_machine == 4643) {
#line 10493
    goto case_4643;
  }
#line 10496
  if ((int )elf_header.e_machine == 85) {
#line 10496
    goto case_85;
  }
#line 10496
  if ((int )elf_header.e_machine == 30288) {
#line 10496
    goto case_85;
  }
#line 10500
  if ((int )elf_header.e_machine == 47) {
#line 10500
    goto case_47;
  }
#line 10500
  if ((int )elf_header.e_machine == 46) {
#line 10500
    goto case_47;
  }
#line 10500
  if ((int )elf_header.e_machine == 48) {
#line 10500
    goto case_47;
  }
#line 10503
  if ((int )elf_header.e_machine == 101) {
#line 10503
    goto case_101;
  }
#line 10503
  if ((int )elf_header.e_machine == 33303) {
#line 10503
    goto case_101;
  }
#line 10506
  if ((int )elf_header.e_machine == 120) {
#line 10506
    goto case_120;
  }
#line 10506
  if ((int )elf_header.e_machine == 65200) {
#line 10506
    goto case_120;
  }
#line 10508
  if ((int )elf_header.e_machine == 105) {
#line 10508
    goto case_105;
  }
#line 10511
  if ((int )elf_header.e_machine == 4185) {
#line 10511
    goto case_4185;
  }
#line 10513
  if ((int )elf_header.e_machine == 113) {
#line 10513
    goto case_113;
  }
#line 10515
  if ((int )elf_header.e_machine == 65211) {
#line 10515
    goto case_65211;
  }
#line 10517
  if ((int )elf_header.e_machine == 140) {
#line 10517
    goto case_140;
  }
#line 10520
  if ((int )elf_header.e_machine == 116) {
#line 10520
    goto case_116;
  }
#line 10520
  if ((int )elf_header.e_machine == 18056) {
#line 10520
    goto case_116;
  }
#line 10523
  if ((int )elf_header.e_machine == 90) {
#line 10523
    goto case_90;
  }
#line 10523
  if ((int )elf_header.e_machine == 57005) {
#line 10523
    goto case_90;
  }
#line 10526
  if ((int )elf_header.e_machine == 89) {
#line 10526
    goto case_89;
  }
#line 10526
  if ((int )elf_header.e_machine == 48879) {
#line 10526
    goto case_89;
  }
#line 10528
  if ((int )elf_header.e_machine == 115) {
#line 10528
    goto case_115;
  }
#line 10530
  goto switch_default;
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 10492
  return (reloc_type == 4U);
  case_4643: /* CIL Label */ 
#line 10494
  return (reloc_type == 5U);
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 10497
  return (reloc_type == 3U);
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 10501
  return (reloc_type == 17U);
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 10504
  return (reloc_type == 1U);
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 10507
  return (reloc_type == 1U);
  case_105: /* CIL Label */ 
  {
#line 10509
  tmp___0 = uses_msp430x_relocs();
  }
#line 10509
  if (tmp___0) {
#line 10510
    return (reloc_type == 2U);
  }
  case_4185: /* CIL Label */ 
#line 10512
  return (reloc_type == 5U);
  case_113: /* CIL Label */ 
#line 10514
  return (reloc_type == 13U);
  case_65211: /* CIL Label */ 
#line 10516
  return (reloc_type == 9U);
  case_140: /* CIL Label */ 
#line 10518
  return (reloc_type == 2U);
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
#line 10521
  return (reloc_type == 2U);
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 10524
  return (reloc_type == 2U);
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 10527
  return (reloc_type == 2U);
  case_115: /* CIL Label */ 
#line 10529
  return (reloc_type == 3U);
  switch_default: /* CIL Label */ 
#line 10531
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10538 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_boolean is_none_reloc(unsigned int reloc_type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 10572
  if ((int )elf_header.e_machine == 65211) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 113) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 116) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 18056) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 188) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 191) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 140) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 88) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 65261) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 89) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 181) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 180) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 62) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 76) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 22) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 41872) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 42) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 50) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 40) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 21) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 20) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 4643) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 36902) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 15) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 8) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 2) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 43) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 18) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 3) {
#line 10572
    goto case_65211;
  }
#line 10572
  if ((int )elf_header.e_machine == 4) {
#line 10572
    goto case_65211;
  }
#line 10574
  if ((int )elf_header.e_machine == 183) {
#line 10574
    goto case_183;
  }
#line 10577
  if ((int )elf_header.e_machine == 94) {
#line 10577
    goto case_94;
  }
#line 10577
  if ((int )elf_header.e_machine == 43975) {
#line 10577
    goto case_94;
  }
#line 10582
  if ((int )elf_header.e_machine == 174) {
#line 10582
    goto case_174;
  }
#line 10541
  goto switch_break;
  case_65211: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
  case_188: /* CIL Label */ 
  case_191: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_65261: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_4643: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 10573
  return (reloc_type == 0U);
  case_183: /* CIL Label */ 
#line 10575
  if (reloc_type == 0U) {
#line 10575
    tmp___0 = 1;
  } else
#line 10575
  if (reloc_type == 256U) {
#line 10575
    tmp___0 = 1;
  } else {
#line 10575
    tmp___0 = 0;
  }
#line 10575
  return (tmp___0);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 10578
  if (reloc_type == 0U) {
#line 10578
    tmp___1 = 1;
  } else
#line 10578
  if (reloc_type == 17U) {
#line 10578
    tmp___1 = 1;
  } else
#line 10578
  if (reloc_type == 18U) {
#line 10578
    tmp___1 = 1;
  } else
#line 10578
  if (reloc_type == 19U) {
#line 10578
    tmp___1 = 1;
  } else {
#line 10578
    tmp___1 = 0;
  }
#line 10578
  return (tmp___1);
  case_174: /* CIL Label */ 
#line 10583
  return (reloc_type == 3U);
  switch_break: /* CIL Label */ ;
  }
#line 10585
  return (0);
}
}
#line 10593 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void apply_relocations(void *file , Elf_Internal_Shdr *section , unsigned char *start ) 
{ 
  Elf_Internal_Shdr *relsec ;
  unsigned char *end ;
  bfd_boolean is_rela ;
  unsigned long num_relocs ;
  Elf_Internal_Rela *relocs ;
  Elf_Internal_Rela *rp ;
  Elf_Internal_Shdr *symsec ;
  Elf_Internal_Sym *symtab ;
  unsigned long num_syms ;
  Elf_Internal_Sym *sym ;
  int tmp___0 ;
  int tmp___1 ;
  Elf_Internal_Sym *tmp___2 ;
  Elf_Internal_Sym *tmp___3 ;
  bfd_vma addend ;
  unsigned int reloc_type ;
  unsigned int reloc_size ;
  unsigned char *rloc ;
  unsigned long sym_index ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  bfd_boolean tmp___11 ;
  bfd_boolean tmp___12 ;
  bfd_boolean tmp___13 ;
  bfd_boolean tmp___14 ;
  bfd_boolean tmp___15 ;
  bfd_boolean tmp___16 ;
  bfd_boolean tmp___17 ;
  bfd_boolean tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  bfd_vma tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  elf_vma tmp___42 ;
  bfd_boolean tmp___43 ;
  bfd_boolean tmp___44 ;

  {
#line 10599
  end = start + section->sh_size;
#line 10601
  if ((int )elf_header.e_type != 1) {
#line 10602
    return;
  }
#line 10605
  relsec = section_headers;
  {
#line 10605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10605
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10605
      goto while_break;
    }
#line 10618
    if (relsec->sh_type != 4U) {
#line 10618
      if (relsec->sh_type != 9U) {
#line 10623
        goto __Cont;
      } else {
#line 10618
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 10618
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 10623
      goto __Cont;
    } else
#line 10618
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10623
      goto __Cont;
    } else
#line 10618
    if (relsec->sh_size == 0UL) {
#line 10623
      goto __Cont;
    } else
#line 10618
    if (relsec->sh_link >= elf_header.e_shnum) {
#line 10623
      goto __Cont;
    }
#line 10625
    is_rela = relsec->sh_type == 4U;
#line 10627
    if (is_rela) {
      {
#line 10629
      tmp___0 = slurp_rela_relocs((FILE *)file, (unsigned long )relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs);
      }
#line 10629
      if (! tmp___0) {
#line 10631
        return;
      }
    } else {
      {
#line 10635
      tmp___1 = slurp_rel_relocs((FILE *)file, (unsigned long )relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs);
      }
#line 10635
      if (! tmp___1) {
#line 10637
        return;
      }
    }
#line 10641
    if ((int )elf_header.e_machine == 42) {
#line 10642
      is_rela = 0;
    }
#line 10644
    symsec = section_headers + relsec->sh_link;
#line 10645
    if (is_32bit_elf) {
      {
#line 10645
      tmp___2 = get_32bit_elf_symbols((FILE *)file, symsec, & num_syms);
#line 10645
      symtab = tmp___2;
      }
    } else {
      {
#line 10645
      tmp___3 = get_64bit_elf_symbols((FILE *)file, symsec, & num_syms);
#line 10645
      symtab = tmp___3;
      }
    }
#line 10647
    rp = relocs;
    {
#line 10647
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10647
      if (! ((unsigned long )rp < (unsigned long )(relocs + num_relocs))) {
#line 10647
        goto while_break___0;
      }
      {
#line 10655
      reloc_type = get_reloc_type(rp->r_info);
#line 10657
      tmp___18 = target_specific_reloc_handling(rp, start, symtab);
      }
#line 10657
      if (tmp___18) {
#line 10658
        goto __Cont___0;
      } else {
        {
#line 10659
        tmp___17 = is_none_reloc(reloc_type);
        }
#line 10659
        if (tmp___17) {
#line 10660
          goto __Cont___0;
        } else {
          {
#line 10661
          tmp___15 = is_32bit_abs_reloc(reloc_type);
          }
#line 10661
          if (tmp___15) {
#line 10663
            reloc_size = 4U;
          } else {
            {
#line 10661
            tmp___16 = is_32bit_pcrel_reloc(reloc_type);
            }
#line 10661
            if (tmp___16) {
#line 10663
              reloc_size = 4U;
            } else {
              {
#line 10664
              tmp___13 = is_64bit_abs_reloc(reloc_type);
              }
#line 10664
              if (tmp___13) {
#line 10666
                reloc_size = 8U;
              } else {
                {
#line 10664
                tmp___14 = is_64bit_pcrel_reloc(reloc_type);
                }
#line 10664
                if (tmp___14) {
#line 10666
                  reloc_size = 8U;
                } else {
                  {
#line 10667
                  tmp___12 = is_24bit_abs_reloc(reloc_type);
                  }
#line 10667
                  if (tmp___12) {
#line 10668
                    reloc_size = 3U;
                  } else {
                    {
#line 10669
                    tmp___11 = is_16bit_abs_reloc(reloc_type);
                    }
#line 10669
                    if (tmp___11) {
#line 10670
                      reloc_size = 2U;
                    } else {
#line 10673
                      if ((unsigned long )section == (unsigned long )((void *)0)) {
                        {
#line 10673
                        tmp___4 = gettext("<none>");
#line 10673
                        tmp___9 = tmp___4;
                        }
                      } else {
#line 10673
                        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                          {
#line 10673
                          tmp___5 = gettext("<no-name>");
#line 10673
                          tmp___8 = tmp___5;
                          }
                        } else {
#line 10673
                          if ((unsigned long )section->sh_name >= string_table_length) {
                            {
#line 10673
                            tmp___6 = gettext("<corrupt>");
#line 10673
                            tmp___7 = tmp___6;
                            }
                          } else {
#line 10673
                            tmp___7 = string_table + section->sh_name;
                          }
#line 10673
                          tmp___8 = tmp___7;
                        }
#line 10673
                        tmp___9 = tmp___8;
                      }
                      {
#line 10673
                      tmp___10 = gettext("unable to apply unsupported reloc type %d to section %s\n");
#line 10673
                      warn((char const   *)tmp___10, reloc_type, tmp___9);
                      }
#line 10675
                      goto __Cont___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 10678
      rloc = start + rp->r_offset;
#line 10679
      if ((unsigned long )(rloc + reloc_size) > (unsigned long )end) {
#line 10679
        goto _L___0;
      } else
#line 10679
      if ((unsigned long )rloc < (unsigned long )start) {
        _L___0: /* CIL Label */ 
#line 10681
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 10681
          tmp___19 = gettext("<none>");
#line 10681
          tmp___24 = tmp___19;
          }
        } else {
#line 10681
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 10681
            tmp___20 = gettext("<no-name>");
#line 10681
            tmp___23 = tmp___20;
            }
          } else {
#line 10681
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 10681
              tmp___21 = gettext("<corrupt>");
#line 10681
              tmp___22 = tmp___21;
              }
            } else {
#line 10681
              tmp___22 = string_table + section->sh_name;
            }
#line 10681
            tmp___23 = tmp___22;
          }
#line 10681
          tmp___24 = tmp___23;
        }
        {
#line 10681
        tmp___25 = gettext("skipping invalid relocation offset 0x%lx in section %s\n");
#line 10681
        warn((char const   *)tmp___25, rp->r_offset, tmp___24);
        }
#line 10684
        goto __Cont___0;
      }
      {
#line 10687
      tmp___26 = get_reloc_symindex(rp->r_info);
#line 10687
      sym_index = tmp___26;
      }
#line 10688
      if (sym_index >= num_syms) {
#line 10690
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 10690
          tmp___27 = gettext("<none>");
#line 10690
          tmp___32 = tmp___27;
          }
        } else {
#line 10690
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 10690
            tmp___28 = gettext("<no-name>");
#line 10690
            tmp___31 = tmp___28;
            }
          } else {
#line 10690
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 10690
              tmp___29 = gettext("<corrupt>");
#line 10690
              tmp___30 = tmp___29;
              }
            } else {
#line 10690
              tmp___30 = string_table + section->sh_name;
            }
#line 10690
            tmp___31 = tmp___30;
          }
#line 10690
          tmp___32 = tmp___31;
        }
        {
#line 10690
        tmp___33 = gettext("skipping invalid relocation symbol index 0x%lx in section %s\n");
#line 10690
        warn((char const   *)tmp___33, sym_index, tmp___32);
        }
#line 10692
        goto __Cont___0;
      }
#line 10694
      sym = symtab + sym_index;
#line 10709
      if ((unsigned long )sym != (unsigned long )symtab) {
#line 10709
        if (((int )sym->st_info & 15) > 3) {
#line 10712
          if ((unsigned long )relsec == (unsigned long )((void *)0)) {
            {
#line 10712
            tmp___34 = gettext("<none>");
#line 10712
            tmp___39 = tmp___34;
            }
          } else {
#line 10712
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 10712
              tmp___35 = gettext("<no-name>");
#line 10712
              tmp___38 = tmp___35;
              }
            } else {
#line 10712
              if ((unsigned long )relsec->sh_name >= string_table_length) {
                {
#line 10712
                tmp___36 = gettext("<corrupt>");
#line 10712
                tmp___37 = tmp___36;
                }
              } else {
#line 10712
                tmp___37 = string_table + relsec->sh_name;
              }
#line 10712
              tmp___38 = tmp___37;
            }
#line 10712
            tmp___39 = tmp___38;
          }
          {
#line 10712
          tmp___40 = get_symbol_type((unsigned int )((int )sym->st_info & 15));
#line 10712
          tmp___41 = gettext("skipping unexpected symbol type %s in %ld\'th relocation in section %s\n");
#line 10712
          warn((char const   *)tmp___41, tmp___40, rp - relocs, tmp___39);
          }
#line 10716
          goto __Cont___0;
        }
      }
#line 10719
      addend = (bfd_vma )0;
#line 10720
      if (is_rela) {
#line 10721
        addend += rp->r_addend;
      }
#line 10724
      if (! is_rela) {
        {
#line 10733
        tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10733
        addend = (bfd_vma )((elf_vma )addend + tmp___42);
        }
      } else
#line 10724
      if ((int )elf_header.e_machine == 94) {
#line 10724
        if (reloc_type == 1U) {
          {
#line 10733
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10733
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        } else {
#line 10724
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 10724
      if ((int )elf_header.e_machine == 91) {
#line 10724
        goto _L___3;
      } else
#line 10724
      if ((int )elf_header.e_machine == 99) {
        _L___3: /* CIL Label */ 
#line 10724
        if (reloc_type == 1U) {
          {
#line 10733
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10733
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        } else {
#line 10724
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 10724
      if ((int )elf_header.e_machine == 86) {
#line 10724
        goto _L___1;
      } else
#line 10724
      if ((int )elf_header.e_machine == 30326) {
        _L___1: /* CIL Label */ 
#line 10724
        if (reloc_type == 12U) {
          {
#line 10733
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10733
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        }
      }
      {
#line 10735
      tmp___43 = is_32bit_pcrel_reloc(reloc_type);
      }
#line 10735
      if (tmp___43) {
#line 10735
        goto _L___5;
      } else {
        {
#line 10735
        tmp___44 = is_64bit_pcrel_reloc(reloc_type);
        }
#line 10735
        if (tmp___44) {
          _L___5: /* CIL Label */ 
#line 10739
          if ((int )elf_header.e_machine == 15) {
#line 10740
            addend -= 8UL;
          }
          {
#line 10741
          (*byte_put)(rloc, (elf_vma )((addend + sym->st_value) - rp->r_offset), (int )reloc_size);
          }
        } else {
          {
#line 10745
          (*byte_put)(rloc, (elf_vma )(addend + sym->st_value), (int )reloc_size);
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 10647
      rp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 10748
    free((void *)symtab);
#line 10749
    free((void *)relocs);
    }
#line 10750
    goto while_break;
    __Cont: /* CIL Label */ 
#line 10605
    relsec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10752
  return;
}
}
#line 10770 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char *get_section_contents(Elf_Internal_Shdr *section , FILE *file ) 
{ 
  bfd_size_type num_bytes ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 10775
  num_bytes = section->sh_size;
#line 10777
  if (num_bytes == 0UL) {
#line 10777
    goto _L;
  } else
#line 10777
  if (section->sh_type == 8U) {
    _L: /* CIL Label */ 
#line 10779
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 10779
      tmp___0 = gettext("<none>");
#line 10779
      tmp___5 = tmp___0;
      }
    } else {
#line 10779
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 10779
        tmp___1 = gettext("<no-name>");
#line 10779
        tmp___4 = tmp___1;
        }
      } else {
#line 10779
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 10779
          tmp___2 = gettext("<corrupt>");
#line 10779
          tmp___3 = tmp___2;
          }
        } else {
#line 10779
          tmp___3 = string_table + section->sh_name;
        }
#line 10779
        tmp___4 = tmp___3;
      }
#line 10779
      tmp___5 = tmp___4;
    }
    {
#line 10779
    tmp___6 = gettext("\nSection \'%s\' has no data to dump.\n");
#line 10779
    printf((char const   */* __restrict  */)tmp___6, tmp___5);
    }
#line 10781
    return ((char *)((void *)0));
  }
  {
#line 10784
  tmp___7 = gettext("section contents");
#line 10784
  tmp___8 = get_data((void *)0, file, section->sh_offset, (size_t )1, num_bytes, (char const   *)tmp___7);
  }
#line 10784
  return ((char *)tmp___8);
}
}
#line 10789 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_section_as_strings(Elf_Internal_Shdr *section , FILE *file ) 
{ 
  Elf_Internal_Shdr *relsec ;
  bfd_size_type num_bytes ;
  char *data ;
  char *end ;
  char *start ;
  char *name___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  bfd_boolean some_strings_shown ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;

  {
#line 10797
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 10797
    tmp___0 = gettext("<none>");
#line 10797
    tmp___5 = tmp___0;
    }
  } else {
#line 10797
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 10797
      tmp___1 = gettext("<no-name>");
#line 10797
      tmp___4 = tmp___1;
      }
    } else {
#line 10797
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 10797
        tmp___2 = gettext("<corrupt>");
#line 10797
        tmp___3 = tmp___2;
        }
      } else {
#line 10797
        tmp___3 = string_table + section->sh_name;
      }
#line 10797
      tmp___4 = tmp___3;
    }
#line 10797
    tmp___5 = tmp___4;
  }
  {
#line 10797
  name___0 = tmp___5;
#line 10800
  start = get_section_contents(section, file);
  }
#line 10801
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 10802
    return;
  }
  {
#line 10804
  tmp___6 = gettext("\nString dump of section \'%s\':\n");
#line 10804
  printf((char const   */* __restrict  */)tmp___6, name___0);
#line 10811
  relsec = section_headers;
  }
  {
#line 10811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10811
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10811
      goto while_break;
    }
#line 10815
    if (relsec->sh_type != 4U) {
#line 10815
      if (relsec->sh_type != 9U) {
#line 10820
        goto __Cont;
      } else {
#line 10815
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 10815
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 10820
      goto __Cont;
    } else
#line 10815
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10820
      goto __Cont;
    } else
#line 10815
    if (relsec->sh_size == 0UL) {
#line 10820
      goto __Cont;
    } else
#line 10815
    if (relsec->sh_link >= elf_header.e_shnum) {
#line 10820
      goto __Cont;
    }
    {
#line 10822
    tmp___7 = gettext("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n");
#line 10822
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 10823
    goto while_break;
    __Cont: /* CIL Label */ 
#line 10811
    relsec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10826
  num_bytes = section->sh_size;
#line 10827
  data = start;
#line 10828
  end = start + num_bytes;
#line 10829
  some_strings_shown = 0;
  {
#line 10831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10831
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 10831
      goto while_break___0;
    }
    {
#line 10833
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10833
      if (! (! ((int const   )_sch_istable[(int )*data & 255] & 16))) {
#line 10833
        goto while_break___1;
      }
#line 10834
      data ++;
#line 10834
      if ((unsigned long )data >= (unsigned long )end) {
#line 10835
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 10837
    if ((unsigned long )data < (unsigned long )end) {
      {
#line 10842
      printf((char const   */* __restrict  */)"  [%6tx]  ", data - start);
#line 10843
      printf((char const   */* __restrict  */)"%s\n", data);
#line 10847
      tmp___8 = strlen((char const   *)data);
#line 10847
      data += tmp___8;
#line 10848
      some_strings_shown = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 10852
  if (! some_strings_shown) {
    {
#line 10853
    tmp___9 = gettext("  No strings found in this section.");
#line 10853
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
  {
#line 10855
  free((void *)start);
#line 10857
  putchar('\n');
  }
#line 10858
  return;
}
}
#line 10860 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void dump_section_as_bytes(Elf_Internal_Shdr *section , FILE *file , bfd_boolean relocate ) 
{ 
  Elf_Internal_Shdr *relsec ;
  bfd_size_type bytes ;
  bfd_vma addr ;
  unsigned char *data ;
  unsigned char *start ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int j ;
  int k ;
  int lbytes ;

  {
  {
#line 10871
  tmp___0 = get_section_contents(section, file);
#line 10871
  start = (unsigned char *)tmp___0;
  }
#line 10872
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 10873
    return;
  }
#line 10875
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 10875
    tmp___1 = gettext("<none>");
#line 10875
    tmp___6 = tmp___1;
    }
  } else {
#line 10875
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 10875
      tmp___2 = gettext("<no-name>");
#line 10875
      tmp___5 = tmp___2;
      }
    } else {
#line 10875
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 10875
        tmp___3 = gettext("<corrupt>");
#line 10875
        tmp___4 = tmp___3;
        }
      } else {
#line 10875
        tmp___4 = string_table + section->sh_name;
      }
#line 10875
      tmp___5 = tmp___4;
    }
#line 10875
    tmp___6 = tmp___5;
  }
  {
#line 10875
  tmp___7 = gettext("\nHex dump of section \'%s\':\n");
#line 10875
  printf((char const   */* __restrict  */)tmp___7, tmp___6);
  }
#line 10877
  if (relocate) {
    {
#line 10879
    apply_relocations((void *)file, section, start);
    }
  } else {
#line 10888
    relsec = section_headers;
    {
#line 10888
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10888
      if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10888
        goto while_break;
      }
#line 10892
      if (relsec->sh_type != 4U) {
#line 10892
        if (relsec->sh_type != 9U) {
#line 10897
          goto __Cont;
        } else {
#line 10892
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 10892
      if (relsec->sh_info >= elf_header.e_shnum) {
#line 10897
        goto __Cont;
      } else
#line 10892
      if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10897
        goto __Cont;
      } else
#line 10892
      if (relsec->sh_size == 0UL) {
#line 10897
        goto __Cont;
      } else
#line 10892
      if (relsec->sh_link >= elf_header.e_shnum) {
#line 10897
        goto __Cont;
      }
      {
#line 10899
      tmp___8 = gettext(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n");
#line 10899
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 10900
      goto while_break;
      __Cont: /* CIL Label */ 
#line 10888
      relsec ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 10904
  addr = section->sh_addr;
#line 10905
  bytes = section->sh_size;
#line 10906
  data = start;
  {
#line 10908
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10908
    if (! bytes) {
#line 10908
      goto while_break___0;
    }
#line 10914
    if (bytes > 16UL) {
#line 10914
      lbytes = 16;
    } else {
#line 10914
      lbytes = (int )bytes;
    }
    {
#line 10916
    printf((char const   */* __restrict  */)"  0x%8.8lx ", addr);
#line 10918
    j = 0;
    }
    {
#line 10918
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10918
      if (! (j < 16)) {
#line 10918
        goto while_break___1;
      }
#line 10920
      if (j < lbytes) {
        {
#line 10921
        printf((char const   */* __restrict  */)"%2.2x", (int )*(data + j));
        }
      } else {
        {
#line 10923
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 10925
      if ((j & 3) == 3) {
        {
#line 10926
        printf((char const   */* __restrict  */)" ");
        }
      }
#line 10918
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 10929
    j = 0;
    {
#line 10929
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 10929
      if (! (j < lbytes)) {
#line 10929
        goto while_break___2;
      }
#line 10931
      k = (int )*(data + j);
#line 10932
      if (k >= 32) {
#line 10932
        if (k < 127) {
          {
#line 10933
          printf((char const   */* __restrict  */)"%c", k);
          }
        } else {
          {
#line 10935
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 10935
        printf((char const   */* __restrict  */)".");
        }
      }
#line 10929
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 10938
    putchar('\n');
#line 10940
    data += lbytes;
#line 10941
    addr += (bfd_vma )lbytes;
#line 10942
    bytes -= (bfd_size_type )lbytes;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 10945
  free((void *)start);
#line 10947
  putchar('\n');
  }
#line 10948
  return;
}
}
#line 10952 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int uncompress_section_contents(unsigned char **buffer___2  __attribute__((__unused__)) ,
                                       dwarf_size_type *size  __attribute__((__unused__)) ) 
{ 
  dwarf_size_type compressed_size ;
  unsigned char *compressed_buffer ;
  dwarf_size_type uncompressed_size ;
  unsigned char *uncompressed_buffer ;
  z_stream strm ;
  int rc ;
  dwarf_size_type header_size ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 10959
  compressed_size = *size;
#line 10960
  compressed_buffer = *buffer___2;
#line 10965
  header_size = (dwarf_size_type )12;
#line 10969
  if (compressed_size < header_size) {
#line 10971
    return (0);
  } else {
    {
#line 10969
    tmp___0 = strcmp((char const   *)((char *)compressed_buffer), "ZLIB");
    }
#line 10969
    if (! (tmp___0 == 0)) {
#line 10971
      return (0);
    }
  }
  {
#line 10973
  uncompressed_size = (dwarf_size_type )*(compressed_buffer + 4);
#line 10973
  uncompressed_size <<= 8;
#line 10974
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 5);
#line 10974
  uncompressed_size <<= 8;
#line 10975
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 6);
#line 10975
  uncompressed_size <<= 8;
#line 10976
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 7);
#line 10976
  uncompressed_size <<= 8;
#line 10977
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 8);
#line 10977
  uncompressed_size <<= 8;
#line 10978
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 9);
#line 10978
  uncompressed_size <<= 8;
#line 10979
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 10);
#line 10979
  uncompressed_size <<= 8;
#line 10980
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 11);
#line 10984
  strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))((void *)0);
#line 10985
  strm.zfree = (void (*)(voidpf opaque , voidpf address ))((void *)0);
#line 10986
  strm.opaque = (void *)0;
#line 10987
  strm.avail_in = (uInt )(compressed_size - header_size);
#line 10988
  strm.next_in = compressed_buffer + header_size;
#line 10989
  strm.avail_out = (uInt )uncompressed_size;
#line 10990
  tmp___1 = xmalloc((size_t )uncompressed_size);
#line 10990
  uncompressed_buffer = (unsigned char *)tmp___1;
#line 10992
  rc = inflateInit_(& strm, "1.2.11", (int )sizeof(z_stream ));
  }
  {
#line 10993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10993
    if (! (strm.avail_in > 0U)) {
#line 10993
      goto while_break;
    }
#line 10995
    if (rc != 0) {
#line 10996
      goto fail;
    }
    {
#line 10997
    strm.next_out = uncompressed_buffer + (uncompressed_size - (dwarf_size_type )strm.avail_out);
#line 10999
    rc = inflate(& strm, 4);
    }
#line 11000
    if (rc != 1) {
#line 11001
      goto fail;
    }
    {
#line 11002
    rc = inflateReset(& strm);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 11004
  rc = inflateEnd(& strm);
  }
#line 11005
  if (rc != 0) {
#line 11007
    goto fail;
  } else
#line 11005
  if (strm.avail_out != 0U) {
#line 11007
    goto fail;
  }
  {
#line 11009
  free((void *)compressed_buffer);
#line 11010
  *buffer___2 = uncompressed_buffer;
#line 11011
  *size = uncompressed_size;
  }
#line 11012
  return (1);
  fail: 
  {
#line 11015
  free((void *)uncompressed_buffer);
#line 11017
  *buffer___2 = (unsigned char *)((void *)0);
  }
#line 11018
  return (0);
}
}
#line 11022 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int load_specific_debug_section(enum dwarf_section_display_enum debug , Elf_Internal_Shdr *sec ,
                                       void *file ) 
{ 
  struct dwarf_section *section ;
  char buf___7[64] ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 11026
  section = & debug_displays[debug].section;
#line 11030
  if ((unsigned long )section->start != (unsigned long )((void *)0)) {
#line 11031
    return (1);
  }
  {
#line 11033
  tmp___0 = gettext("%s section data");
#line 11033
  snprintf((char */* __restrict  */)(buf___7), sizeof(buf___7), (char const   */* __restrict  */)tmp___0,
           section->name);
#line 11034
  section->address = (dwarf_vma )sec->sh_addr;
#line 11035
  tmp___1 = get_data((void *)0, (FILE *)file, sec->sh_offset, (size_t )1, sec->sh_size,
                     (char const   *)(buf___7));
#line 11035
  section->start = (unsigned char *)tmp___1;
  }
#line 11038
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 11039
    section->size = (dwarf_size_type )0;
  } else {
    {
#line 11042
    section->size = (dwarf_size_type )sec->sh_size;
#line 11043
    tmp___2 = uncompress_section_contents(& section->start, & section->size);
    }
#line 11043
    if (tmp___2) {
#line 11044
      sec->sh_size = (bfd_size_type )section->size;
    }
  }
#line 11047
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 11048
    return (0);
  }
#line 11050
  if (debug_displays[debug].relocate) {
    {
#line 11051
    apply_relocations((void *)((FILE *)file), sec, section->start);
    }
  }
#line 11053
  return (1);
}
}
#line 11058 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
unsigned int *section_subset  =    (unsigned int *)((void *)0);
#line 11060 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
int load_debug_section(enum dwarf_section_display_enum debug , void *file ) 
{ 
  struct dwarf_section *section ;
  Elf_Internal_Shdr *sec ;
  int tmp___0 ;

  {
  {
#line 11063
  section = & debug_displays[debug].section;
#line 11067
  sec = find_section_in_set(section->uncompressed_name, section_subset);
  }
#line 11068
  if ((unsigned long )sec != (unsigned long )((void *)0)) {
#line 11069
    section->name = section->uncompressed_name;
  } else {
    {
#line 11072
    sec = find_section_in_set(section->compressed_name, section_subset);
    }
#line 11073
    if ((unsigned long )sec != (unsigned long )((void *)0)) {
#line 11074
      section->name = section->compressed_name;
    }
  }
#line 11076
  if ((unsigned long )sec == (unsigned long )((void *)0)) {
#line 11077
    return (0);
  }
#line 11082
  if ((unsigned long )section_subset != (unsigned long )((void *)0)) {
    {
#line 11083
    free_debug_section(debug);
    }
  }
  {
#line 11085
  tmp___0 = load_specific_debug_section(debug, sec, (void *)((FILE *)file));
  }
#line 11085
  return (tmp___0);
}
}
#line 11088 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
void free_debug_section(enum dwarf_section_display_enum debug ) 
{ 
  struct dwarf_section *section ;

  {
#line 11091
  section = & debug_displays[debug].section;
#line 11093
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 11094
    return;
  }
  {
#line 11096
  free((void *)((char *)section->start));
#line 11097
  section->start = (unsigned char *)((void *)0);
#line 11098
  section->address = (dwarf_vma )0;
#line 11099
  section->size = (dwarf_size_type )0;
  }
#line 11100
  return;
}
}
#line 11102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int display_debug_section(int shndx , Elf_Internal_Shdr *section , FILE *file ) 
{ 
  char *name___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  bfd_size_type length ;
  int result ;
  int i ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  struct dwarf_section *sec ;
  int secondary ;
  Elf_Internal_Shdr *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 11105
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 11105
    tmp___0 = gettext("<none>");
#line 11105
    tmp___5 = tmp___0;
    }
  } else {
#line 11105
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 11105
      tmp___1 = gettext("<no-name>");
#line 11105
      tmp___4 = tmp___1;
      }
    } else {
#line 11105
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 11105
        tmp___2 = gettext("<corrupt>");
#line 11105
        tmp___3 = tmp___2;
        }
      } else {
#line 11105
        tmp___3 = string_table + section->sh_name;
      }
#line 11105
      tmp___4 = tmp___3;
    }
#line 11105
    tmp___5 = tmp___4;
  }
#line 11105
  name___0 = tmp___5;
#line 11107
  result = 1;
#line 11110
  length = section->sh_size;
#line 11111
  if (length == 0UL) {
    {
#line 11113
    tmp___6 = gettext("\nSection \'%s\' has no debugging data.\n");
#line 11113
    printf((char const   */* __restrict  */)tmp___6, name___0);
    }
#line 11114
    return (0);
  }
#line 11116
  if (section->sh_type == 8U) {
    {
#line 11122
    tmp___7 = gettext("section \'%s\' has the NOBITS type - its contents are unreliable.\n");
#line 11122
    printf((char const   */* __restrict  */)tmp___7, name___0);
    }
#line 11123
    return (0);
  }
  {
#line 11126
  tmp___8 = strncmp((char const   *)name___0, ".gnu.linkonce.wi.", sizeof(".gnu.linkonce.wi.") - 1UL);
  }
#line 11126
  if (tmp___8 == 0) {
#line 11127
    name___0 = (char *)".debug_info";
  }
#line 11130
  i = 0;
  {
#line 11130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11130
    if (! (i < 34)) {
#line 11130
      goto while_break;
    }
    {
#line 11131
    tmp___14 = strcmp(debug_displays[i].section.uncompressed_name, (char const   *)name___0);
    }
#line 11131
    if (tmp___14 == 0) {
#line 11131
      goto _L___0;
    } else
#line 11131
    if (i == 4) {
      {
#line 11131
      tmp___15 = strncmp((char const   *)name___0, ".debug_line.", sizeof(".debug_line.") - 1UL);
      }
#line 11131
      if (tmp___15 == 0) {
#line 11131
        goto _L___0;
      } else {
#line 11131
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 11131
      tmp___16 = strcmp(debug_displays[i].section.compressed_name, (char const   *)name___0);
      }
#line 11131
      if (tmp___16 == 0) {
        _L___0: /* CIL Label */ 
        {
#line 11135
        sec = & debug_displays[i].section;
#line 11136
        tmp___9 = find_section((char const   *)name___0);
#line 11136
        secondary = (unsigned long )section != (unsigned long )tmp___9;
        }
#line 11138
        if (secondary) {
          {
#line 11139
          free_debug_section((enum dwarf_section_display_enum )i);
          }
        }
#line 11141
        if (i == 4) {
          {
#line 11141
          tmp___11 = strncmp((char const   *)name___0, ".debug_line.", sizeof(".debug_line.") - 1UL);
          }
#line 11141
          if (tmp___11 == 0) {
#line 11142
            sec->name = (char const   *)name___0;
          } else {
#line 11141
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 11143
          tmp___10 = strcmp(sec->uncompressed_name, (char const   *)name___0);
          }
#line 11143
          if (tmp___10 == 0) {
#line 11144
            sec->name = sec->uncompressed_name;
          } else {
#line 11146
            sec->name = sec->compressed_name;
          }
        }
        {
#line 11147
        tmp___13 = load_specific_debug_section((enum dwarf_section_display_enum )i,
                                               section, (void *)file);
        }
#line 11147
        if (tmp___13) {
          {
#line 11152
          section_subset = find_cu_tu_set((void *)file, (unsigned int )shndx);
#line 11154
          tmp___12 = (*(debug_displays[i].display))(sec, (void *)file);
#line 11154
          result &= tmp___12;
#line 11156
          section_subset = (unsigned int *)((void *)0);
          }
#line 11158
          if (secondary) {
            {
#line 11159
            free_debug_section((enum dwarf_section_display_enum )i);
            }
          } else
#line 11158
          if (i != 3) {
#line 11158
            if (i != 0) {
              {
#line 11159
              free_debug_section((enum dwarf_section_display_enum )i);
              }
            }
          }
        }
#line 11162
        goto while_break;
      }
    }
#line 11130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11165
  if (i == 34) {
    {
#line 11167
    tmp___17 = gettext("Unrecognized debug section: %s\n");
#line 11167
    printf((char const   */* __restrict  */)tmp___17, name___0);
#line 11168
    result = 0;
    }
  }
#line 11171
  return (result);
}
}
#line 11177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void initialise_dumps_byname(void) 
{ 
  struct dump_list_entry *cur ;
  unsigned int i ;
  int any ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 11182
  cur = dump_sects_byname;
  {
#line 11182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11182
    if (! cur) {
#line 11182
      goto while_break;
    }
#line 11187
    i = 0U;
#line 11187
    any = 0;
    {
#line 11187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11187
      if (! (i < elf_header.e_shnum)) {
#line 11187
        goto while_break___0;
      }
#line 11188
      if ((unsigned long )(section_headers + i) == (unsigned long )((void *)0)) {
        {
#line 11188
        tmp___0 = gettext("<none>");
#line 11188
        tmp___5 = tmp___0;
        }
      } else {
#line 11188
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 11188
          tmp___1 = gettext("<no-name>");
#line 11188
          tmp___4 = tmp___1;
          }
        } else {
#line 11188
          if ((unsigned long )(section_headers + i)->sh_name >= string_table_length) {
            {
#line 11188
            tmp___2 = gettext("<corrupt>");
#line 11188
            tmp___3 = tmp___2;
            }
          } else {
#line 11188
            tmp___3 = string_table + (section_headers + i)->sh_name;
          }
#line 11188
          tmp___4 = tmp___3;
        }
#line 11188
        tmp___5 = tmp___4;
      }
      {
#line 11188
      tmp___6 = strcmp((char const   *)tmp___5, (char const   *)cur->name);
      }
#line 11188
      if (tmp___6 == 0) {
        {
#line 11190
        request_dump_bynumber(i, cur->type);
#line 11191
        any = 1;
        }
      }
#line 11187
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11194
    if (! any) {
      {
#line 11195
      tmp___7 = gettext("Section \'%s\' was not dumped because it does not exist!\n");
#line 11195
      warn((char const   *)tmp___7, cur->name);
      }
    }
#line 11182
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 11198
  return;
}
}
#line 11200 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void process_section_contents(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 11206
  if (! do_dump) {
#line 11207
    return;
  }
  {
#line 11209
  initialise_dumps_byname();
#line 11211
  i = 0U;
#line 11211
  section = section_headers;
  }
  {
#line 11211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11211
    if (i < elf_header.e_shnum) {
#line 11211
      if (! (i < num_dump_sects)) {
#line 11211
        goto while_break;
      }
    } else {
#line 11211
      goto while_break;
    }
#line 11219
    if ((int )*(dump_sects + i) & 1) {
      {
#line 11220
      dump_section_as_bytes(section, file, 0);
      }
    }
#line 11222
    if ((int )*(dump_sects + i) & (1 << 4)) {
      {
#line 11223
      dump_section_as_bytes(section, file, 1);
      }
    }
#line 11225
    if ((int )*(dump_sects + i) & (1 << 3)) {
      {
#line 11226
      dump_section_as_strings(section, file);
      }
    }
#line 11228
    if ((int )*(dump_sects + i) & (1 << 2)) {
      {
#line 11229
      display_debug_section((int )i, section, file);
      }
    }
#line 11211
    i ++;
#line 11211
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 11234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 11234
    tmp___1 = i;
#line 11234
    i ++;
#line 11234
    if (! (tmp___1 < num_dump_sects)) {
#line 11234
      goto while_break___0;
    }
#line 11235
    if (*(dump_sects + i)) {
      {
#line 11236
      tmp___0 = gettext("Section %d was not dumped because it does not exist!\n");
#line 11236
      warn((char const   *)tmp___0, i);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 11237
  return;
}
}
#line 11239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void process_mips_fpe_exception(int mask ) 
{ 
  int first ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 11242
  if (mask) {
#line 11244
    first = 1;
#line 11245
    if (mask & 1) {
      {
#line 11246
      fputs((char const   */* __restrict  */)"INEX", (FILE */* __restrict  */)stdout);
#line 11246
      first = 0;
      }
    }
#line 11247
    if (mask & 2) {
#line 11248
      if (first) {
#line 11248
        tmp___0 = "";
      } else {
#line 11248
        tmp___0 = "|";
      }
      {
#line 11248
      printf((char const   */* __restrict  */)"%sUFLO", tmp___0);
#line 11248
      first = 0;
      }
    }
#line 11249
    if (mask & 4) {
#line 11250
      if (first) {
#line 11250
        tmp___1 = "";
      } else {
#line 11250
        tmp___1 = "|";
      }
      {
#line 11250
      printf((char const   */* __restrict  */)"%sOFLO", tmp___1);
#line 11250
      first = 0;
      }
    }
#line 11251
    if (mask & 8) {
#line 11252
      if (first) {
#line 11252
        tmp___2 = "";
      } else {
#line 11252
        tmp___2 = "|";
      }
      {
#line 11252
      printf((char const   */* __restrict  */)"%sDIV0", tmp___2);
#line 11252
      first = 0;
      }
    }
#line 11253
    if (mask & 16) {
#line 11254
      if (first) {
#line 11254
        tmp___3 = "";
      } else {
#line 11254
        tmp___3 = "|";
      }
      {
#line 11254
      printf((char const   */* __restrict  */)"%sINVAL", tmp___3);
      }
    }
  } else {
    {
#line 11257
    fputs((char const   */* __restrict  */)"0", (FILE */* __restrict  */)stdout);
    }
  }
#line 11258
  return;
}
}
#line 11274 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_tag_value(int tag , unsigned char *p , unsigned char const   * const  end ) 
{ 
  unsigned long val ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned int len ;

  {
#line 11281
  if (tag > 0) {
    {
#line 11282
    printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
    }
  }
#line 11284
  if ((unsigned long )p >= (unsigned long )end) {
    {
#line 11286
    tmp___0 = gettext("corrupt tag\n");
#line 11286
    warn((char const   *)tmp___0);
    }
  } else
#line 11288
  if (tag & 1) {
    {
#line 11291
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11292
    tmp___1 = strlen((char const   *)((char *)p));
#line 11292
    p += tmp___1 + 1UL;
    }
  } else {
    {
#line 11298
    val = read_uleb128___0(p, & len, end);
#line 11299
    p += len;
#line 11300
    printf((char const   */* __restrict  */)"%ld (0x%lx)\n", val, val);
    }
  }
#line 11303
  return (p);
}
}
#line 11316 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_CPU_arch[15]  = 
#line 11316
  {      "Pre-v4",      "v4",      "v4T",      "v5T", 
        "v5TE",      "v5TEJ",      "v6",      "v6KZ", 
        "v6T2",      "v6K",      "v7",      "v6-M", 
        "v6S-M",      "v7E-M",      "v8"};
#line 11319 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ARM_ISA_use[2]  = {      "No",      "Yes"};
#line 11320 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_THUMB_ISA_use[3]  = {      "No",      "Thumb-1",      "Thumb-2"};
#line 11322 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_FP_arch[8]  = 
#line 11322
  {      "No",      "VFPv1",      "VFPv2",      "VFPv3", 
        "VFPv3-D16",      "VFPv4",      "VFPv4-D16",      "FP for ARMv8"};
#line 11325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_WMMX_arch[3]  = {      "No",      "WMMXv1",      "WMMXv2"};
#line 11326 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_Advanced_SIMD_arch[4]  = {      "No",      "NEONv1",      "NEONv1 with Fused-MAC",      "NEON for ARMv8"};
#line 11328 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_PCS_config[8]  = 
#line 11328
  {      "None",      "Bare platform",      "Linux application",      "Linux DSO", 
        "PalmOS 2004",      "PalmOS (reserved)",      "SymbianOS 2004",      "SymbianOS (reserved)"};
#line 11331 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_R9_use[4]  = {      "V6",      "SB",      "TLS",      "Unused"};
#line 11333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_RW_data[4]  = {      "Absolute",      "PC-relative",      "SB-relative",      "None"};
#line 11335 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_RO_data[3]  = {      "Absolute",      "PC-relative",      "None"};
#line 11337 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_GOT_use[3]  = {      "None",      "direct",      "GOT-indirect"};
#line 11339 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_wchar_t[5]  = {      "None",      "??? 1",      "2",      "??? 3", 
        "4"};
#line 11341 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_rounding[2]  = {      "Unused",      "Needed"};
#line 11342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_denormal[3]  = {      "Unused",      "Needed",      "Sign only"};
#line 11344 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_exceptions[2]  = {      "Unused",      "Needed"};
#line 11345 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_user_exceptions[2]  = {      "Unused",      "Needed"};
#line 11346 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_number_model[4]  = {      "Unused",      "Finite",      "RTABI",      "IEEE 754"};
#line 11348 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_enum_size[4]  = {      "Unused",      "small",      "int",      "forced to int"};
#line 11350 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_HardFP_use[4]  = {      "As Tag_FP_arch",      "SP only",      "DP only",      "SP and DP"};
#line 11352 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_VFP_args[3]  = {      "AAPCS",      "VFP registers",      "custom"};
#line 11354 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_WMMX_args[3]  = {      "AAPCS",      "WMMX registers",      "custom"};
#line 11356 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_optimization_goals[7]  = {      "None",      "Prefer Speed",      "Aggressive Speed",      "Prefer Size", 
        "Aggressive Size",      "Prefer Debug",      "Aggressive Debug"};
#line 11359 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_optimization_goals[7]  = {      "None",      "Prefer Speed",      "Aggressive Speed",      "Prefer Size", 
        "Aggressive Size",      "Prefer Accuracy",      "Aggressive Accuracy"};
#line 11362 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_CPU_unaligned_access[2]  = {      "None",      "v6"};
#line 11363 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_FP_HP_extension[2]  = {      "Not Allowed",      "Allowed"};
#line 11365 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_16bit_format[3]  = {      "None",      "IEEE 754",      "Alternative Format"};
#line 11367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_MPextension_use[2]  = {      "Not Allowed",      "Allowed"};
#line 11369 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_DIV_use[3]  = {      "Allowed in Thumb-ISA, v7-R or v7-M",      "Not allowed",      "Allowed in v7-A with integer division extension"};
#line 11372 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_T2EE_use[2]  = {      "Not Allowed",      "Allowed"};
#line 11373 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_Virtualization_use[4]  = {      "Not Allowed",      "TrustZone",      "Virtualization Extensions",      "TrustZone and Virtualization Extensions"};
#line 11376 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *arm_attr_tag_MPextension_use_legacy[2]  = {      "Not Allowed",      "Allowed"};
#line 11381 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static arm_attr_public_tag arm_attr_public_tags[40]  = 
#line 11381
  {      {4, "CPU_raw_name", 1, (char const   **)((void *)0)}, 
        {5, "CPU_name", 1, (char const   **)((void *)0)}, 
        {6, "CPU_arch", (int )(128UL | sizeof(arm_attr_tag_CPU_arch) / sizeof(arm_attr_tag_CPU_arch[0])),
      arm_attr_tag_CPU_arch}, 
        {7, "CPU_arch_profile", 0, (char const   **)((void *)0)}, 
        {8, "ARM_ISA_use", (int )(128UL | sizeof(arm_attr_tag_ARM_ISA_use) / sizeof(arm_attr_tag_ARM_ISA_use[0])),
      arm_attr_tag_ARM_ISA_use}, 
        {9, "THUMB_ISA_use", (int )(128UL | sizeof(arm_attr_tag_THUMB_ISA_use) / sizeof(arm_attr_tag_THUMB_ISA_use[0])),
      arm_attr_tag_THUMB_ISA_use}, 
        {10, "FP_arch", (int )(128UL | sizeof(arm_attr_tag_FP_arch) / sizeof(arm_attr_tag_FP_arch[0])),
      arm_attr_tag_FP_arch}, 
        {11, "WMMX_arch", (int )(128UL | sizeof(arm_attr_tag_WMMX_arch) / sizeof(arm_attr_tag_WMMX_arch[0])),
      arm_attr_tag_WMMX_arch}, 
        {12, "Advanced_SIMD_arch", (int )(128UL | sizeof(arm_attr_tag_Advanced_SIMD_arch) / sizeof(arm_attr_tag_Advanced_SIMD_arch[0])),
      arm_attr_tag_Advanced_SIMD_arch}, 
        {13, "PCS_config", (int )(128UL | sizeof(arm_attr_tag_PCS_config) / sizeof(arm_attr_tag_PCS_config[0])),
      arm_attr_tag_PCS_config}, 
        {14, "ABI_PCS_R9_use", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_R9_use) / sizeof(arm_attr_tag_ABI_PCS_R9_use[0])),
      arm_attr_tag_ABI_PCS_R9_use}, 
        {15, "ABI_PCS_RW_data", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_RW_data) / sizeof(arm_attr_tag_ABI_PCS_RW_data[0])),
      arm_attr_tag_ABI_PCS_RW_data}, 
        {16, "ABI_PCS_RO_data", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_RO_data) / sizeof(arm_attr_tag_ABI_PCS_RO_data[0])),
      arm_attr_tag_ABI_PCS_RO_data}, 
        {17, "ABI_PCS_GOT_use", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_GOT_use) / sizeof(arm_attr_tag_ABI_PCS_GOT_use[0])),
      arm_attr_tag_ABI_PCS_GOT_use}, 
        {18, "ABI_PCS_wchar_t", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_wchar_t) / sizeof(arm_attr_tag_ABI_PCS_wchar_t[0])),
      arm_attr_tag_ABI_PCS_wchar_t}, 
        {19, "ABI_FP_rounding", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_rounding) / sizeof(arm_attr_tag_ABI_FP_rounding[0])),
      arm_attr_tag_ABI_FP_rounding}, 
        {20, "ABI_FP_denormal", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_denormal) / sizeof(arm_attr_tag_ABI_FP_denormal[0])),
      arm_attr_tag_ABI_FP_denormal}, 
        {21, "ABI_FP_exceptions", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_exceptions) / sizeof(arm_attr_tag_ABI_FP_exceptions[0])),
      arm_attr_tag_ABI_FP_exceptions}, 
        {22, "ABI_FP_user_exceptions", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_user_exceptions) / sizeof(arm_attr_tag_ABI_FP_user_exceptions[0])),
      arm_attr_tag_ABI_FP_user_exceptions}, 
        {23, "ABI_FP_number_model", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_number_model) / sizeof(arm_attr_tag_ABI_FP_number_model[0])),
      arm_attr_tag_ABI_FP_number_model}, 
        {24, "ABI_align_needed", 0, (char const   **)((void *)0)}, 
        {25, "ABI_align_preserved", 0, (char const   **)((void *)0)}, 
        {26, "ABI_enum_size", (int )(128UL | sizeof(arm_attr_tag_ABI_enum_size) / sizeof(arm_attr_tag_ABI_enum_size[0])),
      arm_attr_tag_ABI_enum_size}, 
        {27, "ABI_HardFP_use", (int )(128UL | sizeof(arm_attr_tag_ABI_HardFP_use) / sizeof(arm_attr_tag_ABI_HardFP_use[0])),
      arm_attr_tag_ABI_HardFP_use}, 
        {28, "ABI_VFP_args", (int )(128UL | sizeof(arm_attr_tag_ABI_VFP_args) / sizeof(arm_attr_tag_ABI_VFP_args[0])),
      arm_attr_tag_ABI_VFP_args}, 
        {29, "ABI_WMMX_args", (int )(128UL | sizeof(arm_attr_tag_ABI_WMMX_args) / sizeof(arm_attr_tag_ABI_WMMX_args[0])),
      arm_attr_tag_ABI_WMMX_args}, 
        {30, "ABI_optimization_goals", (int )(128UL | sizeof(arm_attr_tag_ABI_optimization_goals) / sizeof(arm_attr_tag_ABI_optimization_goals[0])),
      arm_attr_tag_ABI_optimization_goals}, 
        {31, "ABI_FP_optimization_goals", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_optimization_goals) / sizeof(arm_attr_tag_ABI_FP_optimization_goals[0])),
      arm_attr_tag_ABI_FP_optimization_goals}, 
        {32, "compatibility", 0, (char const   **)((void *)0)}, 
        {34, "CPU_unaligned_access", (int )(128UL | sizeof(arm_attr_tag_CPU_unaligned_access) / sizeof(arm_attr_tag_CPU_unaligned_access[0])),
      arm_attr_tag_CPU_unaligned_access}, 
        {36, "FP_HP_extension", (int )(128UL | sizeof(arm_attr_tag_FP_HP_extension) / sizeof(arm_attr_tag_FP_HP_extension[0])),
      arm_attr_tag_FP_HP_extension}, 
        {38, "ABI_FP_16bit_format", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_16bit_format) / sizeof(arm_attr_tag_ABI_FP_16bit_format[0])),
      arm_attr_tag_ABI_FP_16bit_format}, 
        {42, "MPextension_use", (int )(128UL | sizeof(arm_attr_tag_MPextension_use) / sizeof(arm_attr_tag_MPextension_use[0])),
      arm_attr_tag_MPextension_use}, 
        {44, "DIV_use", (int )(128UL | sizeof(arm_attr_tag_DIV_use) / sizeof(arm_attr_tag_DIV_use[0])),
      arm_attr_tag_DIV_use}, 
        {64, "nodefaults", 0, (char const   **)((void *)0)}, 
        {65, "also_compatible_with", 0, (char const   **)((void *)0)}, 
        {66, "T2EE_use", (int )(128UL | sizeof(arm_attr_tag_T2EE_use) / sizeof(arm_attr_tag_T2EE_use[0])),
      arm_attr_tag_T2EE_use}, 
        {67, "conformance", 1, (char const   **)((void *)0)}, 
        {68, "Virtualization_use", (int )(128UL | sizeof(arm_attr_tag_Virtualization_use) / sizeof(arm_attr_tag_Virtualization_use[0])),
      arm_attr_tag_Virtualization_use}, 
        {70, "MPextension_use_legacy", (int )(128UL | sizeof(arm_attr_tag_MPextension_use_legacy) / sizeof(arm_attr_tag_MPextension_use_legacy[0])),
      arm_attr_tag_MPextension_use_legacy}};
#line 11426 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_arm_attribute(unsigned char *p , unsigned char const   * const  end ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  arm_attr_public_tag *attr ;
  unsigned int i ;
  int type ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  unsigned long tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  unsigned long tmp___21 ;
  unsigned long tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned long tmp___26 ;
  unsigned char *tmp___27 ;

  {
  {
#line 11437
  tmp___0 = read_uleb128___0(p, & len, end);
#line 11437
  tag = (int )tmp___0;
#line 11438
  p += len;
#line 11439
  attr = (arm_attr_public_tag *)((void *)0);
#line 11440
  i = 0U;
  }
  {
#line 11440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11440
    if (! ((unsigned long )i < sizeof(arm_attr_public_tags) / sizeof(arm_attr_public_tags[0]))) {
#line 11440
      goto while_break;
    }
#line 11442
    if (arm_attr_public_tags[i].tag == tag) {
#line 11444
      attr = & arm_attr_public_tags[i];
#line 11445
      goto while_break;
    }
#line 11440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11449
  if (attr) {
    {
#line 11451
    printf((char const   */* __restrict  */)"  Tag_%s: ", attr->name);
    }
    {
#line 11454
    if (attr->type == 0) {
#line 11454
      goto case_0;
    }
#line 11543
    if (attr->type == 1) {
#line 11543
      goto case_1___1;
    }
#line 11545
    if (attr->type == 2) {
#line 11545
      goto case_2___1;
    }
#line 11548
    goto switch_default___3;
    case_0: /* CIL Label */ 
    {
#line 11457
    if (tag == 7) {
#line 11457
      goto case_7;
    }
#line 11471
    if (tag == 24) {
#line 11471
      goto case_24;
    }
#line 11490
    if (tag == 25) {
#line 11490
      goto case_25;
    }
#line 11509
    if (tag == 32) {
#line 11509
      goto case_32;
    }
#line 11516
    if (tag == 64) {
#line 11516
      goto case_64;
    }
#line 11521
    if (tag == 65) {
#line 11521
      goto case_65___0;
    }
#line 11538
    goto switch_default___2;
    case_7: /* CIL Label */ 
    {
#line 11458
    tmp___1 = read_uleb128___0(p, & len, end);
#line 11458
    val = (int )tmp___1;
#line 11459
    p += len;
    }
    {
#line 11462
    if (val == 0) {
#line 11462
      goto case_0___0;
    }
#line 11463
    if (val == 65) {
#line 11463
      goto case_65;
    }
#line 11464
    if (val == 82) {
#line 11464
      goto case_82;
    }
#line 11465
    if (val == 77) {
#line 11465
      goto case_77;
    }
#line 11466
    if (val == 83) {
#line 11466
      goto case_83;
    }
#line 11467
    goto switch_default;
    case_0___0: /* CIL Label */ 
    {
#line 11462
    tmp___2 = gettext("None\n");
#line 11462
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11462
    goto switch_break___1;
    case_65: /* CIL Label */ 
    {
#line 11463
    tmp___3 = gettext("Application\n");
#line 11463
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11463
    goto switch_break___1;
    case_82: /* CIL Label */ 
    {
#line 11464
    tmp___4 = gettext("Realtime\n");
#line 11464
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11464
    goto switch_break___1;
    case_77: /* CIL Label */ 
    {
#line 11465
    tmp___5 = gettext("Microcontroller\n");
#line 11465
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 11465
    goto switch_break___1;
    case_83: /* CIL Label */ 
    {
#line 11466
    tmp___6 = gettext("Application or Realtime\n");
#line 11466
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 11466
    goto switch_break___1;
    switch_default: /* CIL Label */ 
    {
#line 11467
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11467
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 11469
    goto switch_break___0;
    case_24: /* CIL Label */ 
    {
#line 11472
    tmp___7 = read_uleb128___0(p, & len, end);
#line 11472
    val = (int )tmp___7;
#line 11473
    p += len;
    }
    {
#line 11476
    if (val == 0) {
#line 11476
      goto case_0___1;
    }
#line 11477
    if (val == 1) {
#line 11477
      goto case_1;
    }
#line 11478
    if (val == 2) {
#line 11478
      goto case_2;
    }
#line 11479
    if (val == 3) {
#line 11479
      goto case_3;
    }
#line 11480
    goto switch_default___0;
    case_0___1: /* CIL Label */ 
    {
#line 11476
    tmp___8 = gettext("None\n");
#line 11476
    printf((char const   */* __restrict  */)tmp___8);
    }
#line 11476
    goto switch_break___2;
    case_1: /* CIL Label */ 
    {
#line 11477
    tmp___9 = gettext("8-byte\n");
#line 11477
    printf((char const   */* __restrict  */)tmp___9);
    }
#line 11477
    goto switch_break___2;
    case_2: /* CIL Label */ 
    {
#line 11478
    tmp___10 = gettext("4-byte\n");
#line 11478
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 11478
    goto switch_break___2;
    case_3: /* CIL Label */ 
    {
#line 11479
    printf((char const   */* __restrict  */)"??? 3\n");
    }
#line 11479
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 11481
    if (val <= 12) {
      {
#line 11482
      tmp___11 = gettext("8-byte and up to %d-byte extended\n");
#line 11482
      printf((char const   */* __restrict  */)tmp___11, 1 << val);
      }
    } else {
      {
#line 11485
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    }
#line 11486
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 11488
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 11491
    tmp___12 = read_uleb128___0(p, & len, end);
#line 11491
    val = (int )tmp___12;
#line 11492
    p += len;
    }
    {
#line 11495
    if (val == 0) {
#line 11495
      goto case_0___2;
    }
#line 11496
    if (val == 1) {
#line 11496
      goto case_1___0;
    }
#line 11497
    if (val == 2) {
#line 11497
      goto case_2___0;
    }
#line 11498
    if (val == 3) {
#line 11498
      goto case_3___0;
    }
#line 11499
    goto switch_default___1;
    case_0___2: /* CIL Label */ 
    {
#line 11495
    tmp___13 = gettext("None\n");
#line 11495
    printf((char const   */* __restrict  */)tmp___13);
    }
#line 11495
    goto switch_break___3;
    case_1___0: /* CIL Label */ 
    {
#line 11496
    tmp___14 = gettext("8-byte, except leaf SP\n");
#line 11496
    printf((char const   */* __restrict  */)tmp___14);
    }
#line 11496
    goto switch_break___3;
    case_2___0: /* CIL Label */ 
    {
#line 11497
    tmp___15 = gettext("8-byte\n");
#line 11497
    printf((char const   */* __restrict  */)tmp___15);
    }
#line 11497
    goto switch_break___3;
    case_3___0: /* CIL Label */ 
    {
#line 11498
    printf((char const   */* __restrict  */)"??? 3\n");
    }
#line 11498
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 11500
    if (val <= 12) {
      {
#line 11501
      tmp___16 = gettext("8-byte and up to %d-byte extended\n");
#line 11501
      printf((char const   */* __restrict  */)tmp___16, 1 << val);
      }
    } else {
      {
#line 11504
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    }
#line 11505
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 11507
    goto switch_break___0;
    case_32: /* CIL Label */ 
    {
#line 11510
    tmp___17 = read_uleb128___0(p, & len, end);
#line 11510
    val = (int )tmp___17;
#line 11511
    p += len;
#line 11512
    tmp___18 = gettext("flag = %d, vendor = %s\n");
#line 11512
    printf((char const   */* __restrict  */)tmp___18, val, p);
#line 11513
    tmp___19 = strlen((char const   *)((char *)p));
#line 11513
    p += tmp___19 + 1UL;
    }
#line 11514
    goto switch_break___0;
    case_64: /* CIL Label */ 
    {
#line 11517
    p ++;
#line 11518
    tmp___20 = gettext("True\n");
#line 11518
    printf((char const   */* __restrict  */)tmp___20);
    }
#line 11519
    goto switch_break___0;
    case_65___0: /* CIL Label */ 
    {
#line 11522
    tmp___21 = read_uleb128___0(p, & len, end);
#line 11522
    val = (int )tmp___21;
#line 11523
    p += len;
    }
#line 11524
    if (val == 6) {
      {
#line 11526
      tmp___22 = read_uleb128___0(p, & len, end);
#line 11526
      val = (int )tmp___22;
#line 11527
      p += len;
      }
#line 11528
      if ((unsigned long )((unsigned int )val) >= sizeof(arm_attr_tag_CPU_arch) / sizeof(arm_attr_tag_CPU_arch[0])) {
        {
#line 11529
        printf((char const   */* __restrict  */)"??? (%d)\n", val);
        }
      } else {
        {
#line 11531
        printf((char const   */* __restrict  */)"%s\n", arm_attr_tag_CPU_arch[val]);
        }
      }
    } else {
      {
#line 11534
      printf((char const   */* __restrict  */)"???\n");
      }
    }
    {
#line 11535
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11535
      tmp___23 = p;
#line 11535
      p ++;
#line 11535
      if (! ((int )*tmp___23 != 0)) {
#line 11535
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11536
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
    {
#line 11539
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 11541
    return (p);
    case_1___1: /* CIL Label */ 
    {
#line 11544
    tmp___24 = display_tag_value(-1, p, end);
    }
#line 11544
    return (tmp___24);
    case_2___1: /* CIL Label */ 
    {
#line 11546
    tmp___25 = display_tag_value(0, p, end);
    }
#line 11546
    return (tmp___25);
    switch_default___3: /* CIL Label */ 
#line 11549
    if (! (attr->type & 128)) {
      {
#line 11549
      __assert_fail("attr->type & 0x80", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                    11549U, "display_arm_attribute");
      }
    }
    {
#line 11550
    tmp___26 = read_uleb128___0(p, & len, end);
#line 11550
    val = (int )tmp___26;
#line 11551
    p += len;
#line 11552
    type = attr->type & 127;
    }
#line 11553
    if (val >= type) {
      {
#line 11554
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    } else {
      {
#line 11556
      printf((char const   */* __restrict  */)"%s\n", *(attr->table + val));
      }
    }
#line 11557
    return (p);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 11561
  tmp___27 = display_tag_value(tag, p, end);
  }
#line 11561
  return (tmp___27);
}
}
#line 11564 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_gnu_attribute(unsigned char *p , unsigned char *(*display_proc_gnu_attribute)(unsigned char * ,
                                                                                                            int  ,
                                                                                                            unsigned char const   * const   ) ,
                                            unsigned char const   * const  end ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
  {
#line 11573
  tmp___0 = read_uleb128___0(p, & len, end);
#line 11573
  tag = (int )tmp___0;
#line 11574
  p += len;
  }
#line 11578
  if (tag == 32) {
    {
#line 11580
    tmp___1 = read_uleb128___0(p, & len, end);
#line 11580
    val = (int )tmp___1;
#line 11581
    p += len;
    }
#line 11582
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 11584
      tmp___2 = gettext("flag = %d, vendor = <corrupt>\n");
#line 11584
      printf((char const   */* __restrict  */)tmp___2, val);
#line 11585
      tmp___3 = gettext("corrupt vendor attribute\n");
#line 11585
      warn((char const   *)tmp___3);
      }
    } else {
      {
#line 11589
      tmp___4 = gettext("flag = %d, vendor = %s\n");
#line 11589
      printf((char const   */* __restrict  */)tmp___4, val, p);
#line 11590
      tmp___5 = strlen((char const   *)((char *)p));
#line 11590
      p += tmp___5 + 1UL;
      }
    }
#line 11592
    return (p);
  }
#line 11595
  if ((tag & 2) == 0) {
#line 11595
    if (display_proc_gnu_attribute) {
      {
#line 11596
      tmp___6 = (*display_proc_gnu_attribute)(p, tag, end);
      }
#line 11596
      return (tmp___6);
    }
  }
  {
#line 11598
  tmp___7 = display_tag_value(tag, p, end);
  }
#line 11598
  return (tmp___7);
}
}
#line 11601 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_power_gnu_attribute(unsigned char *p , int tag , unsigned char const   * const  end ) 
{ 
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned char *tmp___12 ;

  {
#line 11609
  if (tag == 4) {
    {
#line 11611
    tmp___0 = read_uleb128___0(p, & len, end);
#line 11611
    val = (int )tmp___0;
#line 11612
    p += len;
#line 11613
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_FP: ");
    }
    {
#line 11617
    if (val == 0) {
#line 11617
      goto case_0;
    }
#line 11620
    if (val == 1) {
#line 11620
      goto case_1;
    }
#line 11623
    if (val == 2) {
#line 11623
      goto case_2;
    }
#line 11626
    if (val == 3) {
#line 11626
      goto case_3;
    }
#line 11629
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 11618
    tmp___1 = gettext("Hard or soft float\n");
#line 11618
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 11619
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 11621
    tmp___2 = gettext("Hard float\n");
#line 11621
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11622
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 11624
    tmp___3 = gettext("Soft float\n");
#line 11624
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11625
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 11627
    tmp___4 = gettext("Single-precision hard float\n");
#line 11627
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11628
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 11630
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11631
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 11633
    return (p);
  }
#line 11636
  if (tag == 8) {
    {
#line 11638
    tmp___5 = read_uleb128___0(p, & len, end);
#line 11638
    val = (int )tmp___5;
#line 11639
    p += len;
#line 11640
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_Vector: ");
    }
    {
#line 11643
    if (val == 0) {
#line 11643
      goto case_0___0;
    }
#line 11646
    if (val == 1) {
#line 11646
      goto case_1___0;
    }
#line 11649
    if (val == 2) {
#line 11649
      goto case_2___0;
    }
#line 11652
    if (val == 3) {
#line 11652
      goto case_3___0;
    }
#line 11655
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 11644
    tmp___6 = gettext("Any\n");
#line 11644
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 11645
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 11647
    tmp___7 = gettext("Generic\n");
#line 11647
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 11648
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 11650
    printf((char const   */* __restrict  */)"AltiVec\n");
    }
#line 11651
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 11653
    printf((char const   */* __restrict  */)"SPE\n");
    }
#line 11654
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 11656
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11657
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 11659
    return (p);
  }
#line 11662
  if (tag == 12) {
#line 11664
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 11666
      tmp___8 = gettext("corrupt Tag_GNU_Power_ABI_Struct_Return");
#line 11666
      warn((char const   *)tmp___8);
      }
#line 11667
      return (p);
    }
    {
#line 11670
    tmp___9 = read_uleb128___0(p, & len, end);
#line 11670
    val = (int )tmp___9;
#line 11671
    p += len;
#line 11672
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_Struct_Return: ");
    }
    {
#line 11675
    if (val == 0) {
#line 11675
      goto case_0___1;
    }
#line 11678
    if (val == 1) {
#line 11678
      goto case_1___1;
    }
#line 11681
    if (val == 2) {
#line 11681
      goto case_2___1;
    }
#line 11684
    goto switch_default___1;
    case_0___1: /* CIL Label */ 
    {
#line 11676
    tmp___10 = gettext("Any\n");
#line 11676
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 11677
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 11679
    printf((char const   */* __restrict  */)"r3/r4\n");
    }
#line 11680
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 11682
    tmp___11 = gettext("Memory\n");
#line 11682
    printf((char const   */* __restrict  */)tmp___11);
    }
#line 11683
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 11685
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11686
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 11688
    return (p);
  }
  {
#line 11691
  tmp___12 = display_tag_value(tag & 1, p, end);
  }
#line 11691
  return (tmp___12);
}
}
#line 11694 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void display_sparc_hwcaps(int mask ) 
{ 
  int first ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
#line 11697
  if (mask) {
#line 11699
    first = 1;
#line 11700
    if (mask & 1) {
      {
#line 11701
      fputs((char const   */* __restrict  */)"mul32", (FILE */* __restrict  */)stdout);
#line 11701
      first = 0;
      }
    }
#line 11702
    if (mask & 2) {
#line 11703
      if (first) {
#line 11703
        tmp___0 = "";
      } else {
#line 11703
        tmp___0 = "|";
      }
      {
#line 11703
      printf((char const   */* __restrict  */)"%sdiv32", tmp___0);
#line 11703
      first = 0;
      }
    }
#line 11704
    if (mask & 4) {
#line 11705
      if (first) {
#line 11705
        tmp___1 = "";
      } else {
#line 11705
        tmp___1 = "|";
      }
      {
#line 11705
      printf((char const   */* __restrict  */)"%sfsmuld", tmp___1);
#line 11705
      first = 0;
      }
    }
#line 11706
    if (mask & 8) {
#line 11707
      if (first) {
#line 11707
        tmp___2 = "";
      } else {
#line 11707
        tmp___2 = "|";
      }
      {
#line 11707
      printf((char const   */* __restrict  */)"%sv8plus", tmp___2);
#line 11707
      first = 0;
      }
    }
#line 11708
    if (mask & 16) {
#line 11709
      if (first) {
#line 11709
        tmp___3 = "";
      } else {
#line 11709
        tmp___3 = "|";
      }
      {
#line 11709
      printf((char const   */* __restrict  */)"%spopc", tmp___3);
#line 11709
      first = 0;
      }
    }
#line 11710
    if (mask & 32) {
#line 11711
      if (first) {
#line 11711
        tmp___4 = "";
      } else {
#line 11711
        tmp___4 = "|";
      }
      {
#line 11711
      printf((char const   */* __restrict  */)"%svis", tmp___4);
#line 11711
      first = 0;
      }
    }
#line 11712
    if (mask & 64) {
#line 11713
      if (first) {
#line 11713
        tmp___5 = "";
      } else {
#line 11713
        tmp___5 = "|";
      }
      {
#line 11713
      printf((char const   */* __restrict  */)"%svis2", tmp___5);
#line 11713
      first = 0;
      }
    }
#line 11714
    if (mask & 128) {
#line 11715
      if (first) {
#line 11715
        tmp___6 = "";
      } else {
#line 11715
        tmp___6 = "|";
      }
      {
#line 11715
      printf((char const   */* __restrict  */)"%sASIBlkInit", tmp___6);
#line 11715
      first = 0;
      }
    }
#line 11716
    if (mask & 256) {
#line 11717
      if (first) {
#line 11717
        tmp___7 = "";
      } else {
#line 11717
        tmp___7 = "|";
      }
      {
#line 11717
      printf((char const   */* __restrict  */)"%sfmaf", tmp___7);
#line 11717
      first = 0;
      }
    }
#line 11718
    if (mask & 1024) {
#line 11719
      if (first) {
#line 11719
        tmp___8 = "";
      } else {
#line 11719
        tmp___8 = "|";
      }
      {
#line 11719
      printf((char const   */* __restrict  */)"%svis3", tmp___8);
#line 11719
      first = 0;
      }
    }
#line 11720
    if (mask & 2048) {
#line 11721
      if (first) {
#line 11721
        tmp___9 = "";
      } else {
#line 11721
        tmp___9 = "|";
      }
      {
#line 11721
      printf((char const   */* __restrict  */)"%shpc", tmp___9);
#line 11721
      first = 0;
      }
    }
#line 11722
    if (mask & 4096) {
#line 11723
      if (first) {
#line 11723
        tmp___10 = "";
      } else {
#line 11723
        tmp___10 = "|";
      }
      {
#line 11723
      printf((char const   */* __restrict  */)"%srandom", tmp___10);
#line 11723
      first = 0;
      }
    }
#line 11724
    if (mask & 8192) {
#line 11725
      if (first) {
#line 11725
        tmp___11 = "";
      } else {
#line 11725
        tmp___11 = "|";
      }
      {
#line 11725
      printf((char const   */* __restrict  */)"%strans", tmp___11);
#line 11725
      first = 0;
      }
    }
#line 11726
    if (mask & 16384) {
#line 11727
      if (first) {
#line 11727
        tmp___12 = "";
      } else {
#line 11727
        tmp___12 = "|";
      }
      {
#line 11727
      printf((char const   */* __restrict  */)"%sfjfmau", tmp___12);
#line 11727
      first = 0;
      }
    }
#line 11728
    if (mask & 32768) {
#line 11729
      if (first) {
#line 11729
        tmp___13 = "";
      } else {
#line 11729
        tmp___13 = "|";
      }
      {
#line 11729
      printf((char const   */* __restrict  */)"%sima", tmp___13);
#line 11729
      first = 0;
      }
    }
#line 11730
    if (mask & 65536) {
#line 11731
      if (first) {
#line 11731
        tmp___14 = "";
      } else {
#line 11731
        tmp___14 = "|";
      }
      {
#line 11731
      printf((char const   */* __restrict  */)"%scspare", tmp___14);
#line 11731
      first = 0;
      }
    }
  } else {
    {
#line 11734
    fputc('0', stdout);
    }
  }
  {
#line 11735
  fputc('\n', stdout);
  }
#line 11736
  return;
}
}
#line 11738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_sparc_gnu_attribute(unsigned char *p , int tag , unsigned char const   * const  end ) 
{ 
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 11743
  if (tag == 4) {
    {
#line 11748
    tmp___0 = read_uleb128___0(p, & len, end);
#line 11748
    val = (int )tmp___0;
#line 11749
    p += len;
#line 11750
    printf((char const   */* __restrict  */)"  Tag_GNU_Sparc_HWCAPS: ");
#line 11751
    display_sparc_hwcaps(val);
    }
#line 11752
    return (p);
  }
  {
#line 11755
  tmp___1 = display_tag_value(tag, p, end);
  }
#line 11755
  return (tmp___1);
}
}
#line 11758 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_mips_gnu_attribute(unsigned char *p , int tag , unsigned char const   * const  end ) 
{ 
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 11763
  if (tag == 4) {
    {
#line 11768
    tmp___0 = read_uleb128___0(p, & len, end);
#line 11768
    val = (int )tmp___0;
#line 11769
    p += len;
#line 11770
    printf((char const   */* __restrict  */)"  Tag_GNU_MIPS_ABI_FP: ");
    }
    {
#line 11774
    if (val == 0) {
#line 11774
      goto case_0;
    }
#line 11777
    if (val == 1) {
#line 11777
      goto case_1;
    }
#line 11780
    if (val == 2) {
#line 11780
      goto case_2;
    }
#line 11783
    if (val == 3) {
#line 11783
      goto case_3;
    }
#line 11786
    if (val == 4) {
#line 11786
      goto case_4;
    }
#line 11789
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 11775
    tmp___1 = gettext("Hard or soft float\n");
#line 11775
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 11776
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 11778
    tmp___2 = gettext("Hard float (double precision)\n");
#line 11778
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11779
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 11781
    tmp___3 = gettext("Hard float (single precision)\n");
#line 11781
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11782
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 11784
    tmp___4 = gettext("Soft float\n");
#line 11784
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11785
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 11787
    tmp___5 = gettext("Hard float (MIPS32r2 64-bit FPU)\n");
#line 11787
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 11788
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 11790
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11791
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 11793
    return (p);
  }
  {
#line 11796
  tmp___6 = display_tag_value(tag & 1, p, end);
  }
#line 11796
  return (tmp___6);
}
}
#line 11799 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_tic6x_attribute(unsigned char *p , unsigned char const   * const  end ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  unsigned long tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned long tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  unsigned long tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned long tmp___31 ;
  char *tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  unsigned char *tmp___35 ;

  {
  {
#line 11807
  tmp___0 = read_uleb128___0(p, & len, end);
#line 11807
  tag = (int )tmp___0;
#line 11808
  p += len;
  }
  {
#line 11812
  if (tag == 4) {
#line 11812
    goto case_4;
  }
#line 11846
  if (tag == 6) {
#line 11846
    goto case_6___0;
  }
#line 11867
  if (tag == 8) {
#line 11867
    goto case_8___0;
  }
#line 11885
  if (tag == 10) {
#line 11885
    goto case_10;
  }
#line 11903
  if (tag == 12) {
#line 11903
    goto case_12;
  }
#line 11921
  if (tag == 14) {
#line 11921
    goto case_14;
  }
#line 11942
  if (tag == 16) {
#line 11942
    goto case_16;
  }
#line 11960
  if (tag == 18) {
#line 11960
    goto case_18;
  }
#line 11981
  if (tag == 20) {
#line 11981
    goto case_20;
  }
#line 12002
  if (tag == 32) {
#line 12002
    goto case_32;
  }
#line 12010
  if (tag == 67) {
#line 12010
    goto case_67;
  }
#line 11810
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 11813
  tmp___1 = read_uleb128___0(p, & len, end);
#line 11813
  val = (int )tmp___1;
#line 11814
  p += len;
#line 11815
  printf((char const   */* __restrict  */)"  Tag_ISA: ");
  }
  {
#line 11819
  if (val == 0) {
#line 11819
    goto case_0;
  }
#line 11822
  if (val == 1) {
#line 11822
    goto case_1;
  }
#line 11825
  if (val == 3) {
#line 11825
    goto case_3;
  }
#line 11828
  if (val == 4) {
#line 11828
    goto case_4___0;
  }
#line 11831
  if (val == 6) {
#line 11831
    goto case_6;
  }
#line 11834
  if (val == 7) {
#line 11834
    goto case_7;
  }
#line 11837
  if (val == 8) {
#line 11837
    goto case_8;
  }
#line 11840
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 11820
  tmp___2 = gettext("None\n");
#line 11820
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 11821
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 11823
  printf((char const   */* __restrict  */)"C62x\n");
  }
#line 11824
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 11826
  printf((char const   */* __restrict  */)"C67x\n");
  }
#line 11827
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 11829
  printf((char const   */* __restrict  */)"C67x+\n");
  }
#line 11830
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 11832
  printf((char const   */* __restrict  */)"C64x\n");
  }
#line 11833
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 11835
  printf((char const   */* __restrict  */)"C64x+\n");
  }
#line 11836
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 11838
  printf((char const   */* __restrict  */)"C674x\n");
  }
#line 11839
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 11841
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11842
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 11844
  return (p);
  case_6___0: /* CIL Label */ 
  {
#line 11847
  tmp___3 = read_uleb128___0(p, & len, end);
#line 11847
  val = (int )tmp___3;
#line 11848
  p += len;
#line 11849
  printf((char const   */* __restrict  */)"  Tag_ABI_wchar_t: ");
  }
  {
#line 11852
  if (val == 0) {
#line 11852
    goto case_0___0;
  }
#line 11855
  if (val == 1) {
#line 11855
    goto case_1___0;
  }
#line 11858
  if (val == 2) {
#line 11858
    goto case_2;
  }
#line 11861
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 11853
  tmp___4 = gettext("Not used\n");
#line 11853
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 11854
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 11856
  tmp___5 = gettext("2 bytes\n");
#line 11856
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 11857
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 11859
  tmp___6 = gettext("4 bytes\n");
#line 11859
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 11860
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 11862
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11863
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 11865
  return (p);
  case_8___0: /* CIL Label */ 
  {
#line 11868
  tmp___7 = read_uleb128___0(p, & len, end);
#line 11868
  val = (int )tmp___7;
#line 11869
  p += len;
#line 11870
  printf((char const   */* __restrict  */)"  Tag_ABI_stack_align_needed: ");
  }
  {
#line 11873
  if (val == 0) {
#line 11873
    goto case_0___1;
  }
#line 11876
  if (val == 1) {
#line 11876
    goto case_1___1;
  }
#line 11879
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
  {
#line 11874
  tmp___8 = gettext("8-byte\n");
#line 11874
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 11875
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
  {
#line 11877
  tmp___9 = gettext("16-byte\n");
#line 11877
  printf((char const   */* __restrict  */)tmp___9);
  }
#line 11878
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 11880
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11881
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 11883
  return (p);
  case_10: /* CIL Label */ 
  {
#line 11886
  tmp___10 = read_uleb128___0(p, & len, end);
#line 11886
  val = (int )tmp___10;
#line 11887
  p += len;
#line 11888
  printf((char const   */* __restrict  */)"  Tag_ABI_stack_align_preserved: ");
  }
  {
#line 11891
  if (val == 0) {
#line 11891
    goto case_0___2;
  }
#line 11894
  if (val == 1) {
#line 11894
    goto case_1___2;
  }
#line 11897
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
  {
#line 11892
  tmp___11 = gettext("8-byte\n");
#line 11892
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 11893
  goto switch_break___3;
  case_1___2: /* CIL Label */ 
  {
#line 11895
  tmp___12 = gettext("16-byte\n");
#line 11895
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 11896
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 11898
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11899
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 11901
  return (p);
  case_12: /* CIL Label */ 
  {
#line 11904
  tmp___13 = read_uleb128___0(p, & len, end);
#line 11904
  val = (int )tmp___13;
#line 11905
  p += len;
#line 11906
  printf((char const   */* __restrict  */)"  Tag_ABI_DSBT: ");
  }
  {
#line 11909
  if (val == 0) {
#line 11909
    goto case_0___3;
  }
#line 11912
  if (val == 1) {
#line 11912
    goto case_1___3;
  }
#line 11915
  goto switch_default___3;
  case_0___3: /* CIL Label */ 
  {
#line 11910
  tmp___14 = gettext("DSBT addressing not used\n");
#line 11910
  printf((char const   */* __restrict  */)tmp___14);
  }
#line 11911
  goto switch_break___4;
  case_1___3: /* CIL Label */ 
  {
#line 11913
  tmp___15 = gettext("DSBT addressing used\n");
#line 11913
  printf((char const   */* __restrict  */)tmp___15);
  }
#line 11914
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 11916
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11917
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 11919
  return (p);
  case_14: /* CIL Label */ 
  {
#line 11922
  tmp___16 = read_uleb128___0(p, & len, end);
#line 11922
  val = (int )tmp___16;
#line 11923
  p += len;
#line 11924
  printf((char const   */* __restrict  */)"  Tag_ABI_PID: ");
  }
  {
#line 11927
  if (val == 0) {
#line 11927
    goto case_0___4;
  }
#line 11930
  if (val == 1) {
#line 11930
    goto case_1___4;
  }
#line 11933
  if (val == 2) {
#line 11933
    goto case_2___0;
  }
#line 11936
  goto switch_default___4;
  case_0___4: /* CIL Label */ 
  {
#line 11928
  tmp___17 = gettext("Data addressing position-dependent\n");
#line 11928
  printf((char const   */* __restrict  */)tmp___17);
  }
#line 11929
  goto switch_break___5;
  case_1___4: /* CIL Label */ 
  {
#line 11931
  tmp___18 = gettext("Data addressing position-independent, GOT near DP\n");
#line 11931
  printf((char const   */* __restrict  */)tmp___18);
  }
#line 11932
  goto switch_break___5;
  case_2___0: /* CIL Label */ 
  {
#line 11934
  tmp___19 = gettext("Data addressing position-independent, GOT far from DP\n");
#line 11934
  printf((char const   */* __restrict  */)tmp___19);
  }
#line 11935
  goto switch_break___5;
  switch_default___4: /* CIL Label */ 
  {
#line 11937
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11938
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 11940
  return (p);
  case_16: /* CIL Label */ 
  {
#line 11943
  tmp___20 = read_uleb128___0(p, & len, end);
#line 11943
  val = (int )tmp___20;
#line 11944
  p += len;
#line 11945
  printf((char const   */* __restrict  */)"  Tag_ABI_PIC: ");
  }
  {
#line 11948
  if (val == 0) {
#line 11948
    goto case_0___5;
  }
#line 11951
  if (val == 1) {
#line 11951
    goto case_1___5;
  }
#line 11954
  goto switch_default___5;
  case_0___5: /* CIL Label */ 
  {
#line 11949
  tmp___21 = gettext("Code addressing position-dependent\n");
#line 11949
  printf((char const   */* __restrict  */)tmp___21);
  }
#line 11950
  goto switch_break___6;
  case_1___5: /* CIL Label */ 
  {
#line 11952
  tmp___22 = gettext("Code addressing position-independent\n");
#line 11952
  printf((char const   */* __restrict  */)tmp___22);
  }
#line 11953
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 11955
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11956
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 11958
  return (p);
  case_18: /* CIL Label */ 
  {
#line 11961
  tmp___23 = read_uleb128___0(p, & len, end);
#line 11961
  val = (int )tmp___23;
#line 11962
  p += len;
#line 11963
  printf((char const   */* __restrict  */)"  Tag_ABI_array_object_alignment: ");
  }
  {
#line 11966
  if (val == 0) {
#line 11966
    goto case_0___6;
  }
#line 11969
  if (val == 1) {
#line 11969
    goto case_1___6;
  }
#line 11972
  if (val == 2) {
#line 11972
    goto case_2___1;
  }
#line 11975
  goto switch_default___6;
  case_0___6: /* CIL Label */ 
  {
#line 11967
  tmp___24 = gettext("8-byte\n");
#line 11967
  printf((char const   */* __restrict  */)tmp___24);
  }
#line 11968
  goto switch_break___7;
  case_1___6: /* CIL Label */ 
  {
#line 11970
  tmp___25 = gettext("4-byte\n");
#line 11970
  printf((char const   */* __restrict  */)tmp___25);
  }
#line 11971
  goto switch_break___7;
  case_2___1: /* CIL Label */ 
  {
#line 11973
  tmp___26 = gettext("16-byte\n");
#line 11973
  printf((char const   */* __restrict  */)tmp___26);
  }
#line 11974
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 11976
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11977
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 11979
  return (p);
  case_20: /* CIL Label */ 
  {
#line 11982
  tmp___27 = read_uleb128___0(p, & len, end);
#line 11982
  val = (int )tmp___27;
#line 11983
  p += len;
#line 11984
  printf((char const   */* __restrict  */)"  Tag_ABI_array_object_align_expected: ");
  }
  {
#line 11987
  if (val == 0) {
#line 11987
    goto case_0___7;
  }
#line 11990
  if (val == 1) {
#line 11990
    goto case_1___7;
  }
#line 11993
  if (val == 2) {
#line 11993
    goto case_2___2;
  }
#line 11996
  goto switch_default___7;
  case_0___7: /* CIL Label */ 
  {
#line 11988
  tmp___28 = gettext("8-byte\n");
#line 11988
  printf((char const   */* __restrict  */)tmp___28);
  }
#line 11989
  goto switch_break___8;
  case_1___7: /* CIL Label */ 
  {
#line 11991
  tmp___29 = gettext("4-byte\n");
#line 11991
  printf((char const   */* __restrict  */)tmp___29);
  }
#line 11992
  goto switch_break___8;
  case_2___2: /* CIL Label */ 
  {
#line 11994
  tmp___30 = gettext("16-byte\n");
#line 11994
  printf((char const   */* __restrict  */)tmp___30);
  }
#line 11995
  goto switch_break___8;
  switch_default___7: /* CIL Label */ 
  {
#line 11997
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11998
  goto switch_break___8;
  switch_break___8: /* CIL Label */ ;
  }
#line 12000
  return (p);
  case_32: /* CIL Label */ 
  {
#line 12003
  tmp___31 = read_uleb128___0(p, & len, end);
#line 12003
  val = (int )tmp___31;
#line 12004
  p += len;
#line 12005
  printf((char const   */* __restrict  */)"  Tag_ABI_compatibility: ");
#line 12006
  tmp___32 = gettext("flag = %d, vendor = %s\n");
#line 12006
  printf((char const   */* __restrict  */)tmp___32, val, p);
#line 12007
  tmp___33 = strlen((char const   *)((char *)p));
#line 12007
  p += tmp___33 + 1UL;
  }
#line 12008
  return (p);
  case_67: /* CIL Label */ 
  {
#line 12011
  printf((char const   */* __restrict  */)"  Tag_ABI_conformance: ");
#line 12012
  printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 12013
  tmp___34 = strlen((char const   *)((char *)p));
#line 12013
  p += tmp___34 + 1UL;
  }
#line 12014
  return (p);
  switch_break: /* CIL Label */ ;
  }
  {
#line 12017
  tmp___35 = display_tag_value(tag, p, end);
  }
#line 12017
  return (tmp___35);
}
}
#line 12020 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static void display_raw_attribute(unsigned char *p , unsigned char *end ) 
{ 
  unsigned long addr ;
  size_t bytes ;
  int j ;
  int k ;
  int lbytes ;
  size_t tmp___0 ;

  {
#line 12023
  addr = 0UL;
#line 12024
  bytes = (size_t )(end - p);
  {
#line 12026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12026
    if (! bytes) {
#line 12026
      goto while_break;
    }
#line 12030
    if (bytes > 16UL) {
#line 12030
      tmp___0 = (size_t )16;
    } else {
#line 12030
      tmp___0 = bytes;
    }
    {
#line 12030
    lbytes = (int )tmp___0;
#line 12032
    printf((char const   */* __restrict  */)"  0x%8.8lx ", addr);
#line 12034
    j = 0;
    }
    {
#line 12034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12034
      if (! (j < 16)) {
#line 12034
        goto while_break___0;
      }
#line 12036
      if (j < lbytes) {
        {
#line 12037
        printf((char const   */* __restrict  */)"%2.2x", (int )*(p + j));
        }
      } else {
        {
#line 12039
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 12041
      if ((j & 3) == 3) {
        {
#line 12042
        printf((char const   */* __restrict  */)" ");
        }
      }
#line 12034
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 12045
    j = 0;
    {
#line 12045
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12045
      if (! (j < lbytes)) {
#line 12045
        goto while_break___1;
      }
#line 12047
      k = (int )*(p + j);
#line 12048
      if (k >= 32) {
#line 12048
        if (k < 127) {
          {
#line 12049
          printf((char const   */* __restrict  */)"%c", k);
          }
        } else {
          {
#line 12051
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 12051
        printf((char const   */* __restrict  */)".");
        }
      }
#line 12045
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 12054
    putchar('\n');
#line 12056
    p += lbytes;
#line 12057
    bytes -= (size_t )lbytes;
#line 12058
    addr += (unsigned long )lbytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12061
  putchar('\n');
  }
#line 12062
  return;
}
}
#line 12064 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static unsigned char *display_msp430x_attribute(unsigned char *p , unsigned char const   * const  end ) 
{ 
  unsigned int len ;
  int val ;
  int tag ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  unsigned long tmp___16 ;

  {
  {
#line 12072
  tmp___0 = read_uleb128___0(p, & len, end);
#line 12072
  tag = (int )tmp___0;
#line 12073
  p += len;
  }
  {
#line 12077
  if (tag == 4) {
#line 12077
    goto case_4;
  }
#line 12090
  if (tag == 6) {
#line 12090
    goto case_6;
  }
#line 12103
  if (tag == 8) {
#line 12103
    goto case_8;
  }
#line 12117
  goto switch_default___2;
  case_4: /* CIL Label */ 
  {
#line 12078
  tmp___1 = read_uleb128___0(p, & len, end);
#line 12078
  val = (int )tmp___1;
#line 12079
  p += len;
#line 12080
  printf((char const   */* __restrict  */)"  Tag_ISA: ");
  }
  {
#line 12083
  if (val == 0) {
#line 12083
    goto case_0;
  }
#line 12084
  if (val == 1) {
#line 12084
    goto case_1;
  }
#line 12085
  if (val == 2) {
#line 12085
    goto case_2;
  }
#line 12086
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 12083
  tmp___2 = gettext("None\n");
#line 12083
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 12083
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 12084
  tmp___3 = gettext("MSP430\n");
#line 12084
  printf((char const   */* __restrict  */)tmp___3);
  }
#line 12084
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 12085
  tmp___4 = gettext("MSP430X\n");
#line 12085
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 12085
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 12086
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 12086
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 12088
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 12091
  tmp___5 = read_uleb128___0(p, & len, end);
#line 12091
  val = (int )tmp___5;
#line 12092
  p += len;
#line 12093
  printf((char const   */* __restrict  */)"  Tag_Code_Model: ");
  }
  {
#line 12096
  if (val == 0) {
#line 12096
    goto case_0___0;
  }
#line 12097
  if (val == 1) {
#line 12097
    goto case_1___0;
  }
#line 12098
  if (val == 2) {
#line 12098
    goto case_2___0;
  }
#line 12099
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 12096
  tmp___6 = gettext("None\n");
#line 12096
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 12096
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 12097
  tmp___7 = gettext("Small\n");
#line 12097
  printf((char const   */* __restrict  */)tmp___7);
  }
#line 12097
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 12098
  tmp___8 = gettext("Large\n");
#line 12098
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 12098
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 12099
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 12099
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 12101
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 12104
  tmp___9 = read_uleb128___0(p, & len, end);
#line 12104
  val = (int )tmp___9;
#line 12105
  p += len;
#line 12106
  printf((char const   */* __restrict  */)"  Tag_Data_Model: ");
  }
  {
#line 12109
  if (val == 0) {
#line 12109
    goto case_0___1;
  }
#line 12110
  if (val == 1) {
#line 12110
    goto case_1___1;
  }
#line 12111
  if (val == 2) {
#line 12111
    goto case_2___1;
  }
#line 12112
  if (val == 3) {
#line 12112
    goto case_3;
  }
#line 12113
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
  {
#line 12109
  tmp___10 = gettext("None\n");
#line 12109
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 12109
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
  {
#line 12110
  tmp___11 = gettext("Small\n");
#line 12110
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 12110
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
  {
#line 12111
  tmp___12 = gettext("Large\n");
#line 12111
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 12111
  goto switch_break___2;
  case_3: /* CIL Label */ 
  {
#line 12112
  tmp___13 = gettext("Restricted Large\n");
#line 12112
  printf((char const   */* __restrict  */)tmp___13);
  }
#line 12112
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 12113
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 12113
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 12115
  goto switch_break;
  switch_default___2: /* CIL Label */ 
  {
#line 12118
  tmp___14 = gettext("  <unknown tag %d>: ");
#line 12118
  printf((char const   */* __restrict  */)tmp___14, tag);
  }
#line 12120
  if (tag & 1) {
    {
#line 12122
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 12123
    tmp___15 = strlen((char const   *)((char *)p));
#line 12123
    p += tmp___15 + 1UL;
    }
  } else {
    {
#line 12127
    tmp___16 = read_uleb128___0(p, & len, end);
#line 12127
    val = (int )tmp___16;
#line 12128
    p += len;
#line 12129
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 12131
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 12134
  return (p);
}
}
#line 12137 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_attributes(FILE *file , char const   *public_name , unsigned int proc_type ,
                              unsigned char *(*display_pub_attribute)(unsigned char * ,
                                                                      unsigned char const   * const   ) ,
                              unsigned char *(*display_proc_gnu_attribute)(unsigned char * ,
                                                                           int  ,
                                                                           unsigned char const   * const   ) ) 
{ 
  Elf_Internal_Shdr *sect ;
  unsigned char *contents ;
  unsigned char *p ;
  unsigned char *end ;
  bfd_vma section_len ;
  bfd_vma len ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  int namelen ;
  bfd_boolean public_section ;
  bfd_boolean gnu_section ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tag ;
  unsigned char *tmp___8 ;
  int val ;
  bfd_vma size ;
  elf_vma tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned int j ;
  unsigned long tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 12153
  i = 0U;
#line 12153
  sect = section_headers;
  {
#line 12153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12153
    if (! (i < elf_header.e_shnum)) {
#line 12153
      goto while_break;
    }
#line 12157
    if (sect->sh_type != proc_type) {
#line 12157
      if (sect->sh_type != 1879048181U) {
#line 12158
        goto __Cont;
      }
    }
    {
#line 12160
    tmp___0 = gettext("attributes");
#line 12160
    tmp___1 = get_data((void *)0, file, sect->sh_offset, (size_t )1, sect->sh_size,
                       (char const   *)tmp___0);
#line 12160
    contents = (unsigned char *)tmp___1;
    }
#line 12162
    if ((unsigned long )contents == (unsigned long )((void *)0)) {
#line 12163
      goto __Cont;
    }
#line 12165
    p = contents;
#line 12166
    if ((int )*p == 65) {
#line 12168
      len = sect->sh_size - 1UL;
#line 12169
      p ++;
      {
#line 12171
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 12171
        if (! (len > 0UL)) {
#line 12171
          goto while_break___0;
        }
        {
#line 12177
        tmp___2 = (*byte_get)(p, 4);
#line 12177
        section_len = (bfd_vma )tmp___2;
#line 12178
        p += 4;
        }
#line 12180
        if (section_len > len) {
          {
#line 12182
          tmp___3 = gettext("ERROR: Bad section length (%d > %d)\n");
#line 12182
          printf((char const   */* __restrict  */)tmp___3, (int )section_len, (int )len);
#line 12184
          section_len = len;
          }
        }
        {
#line 12187
        len -= section_len;
#line 12188
        tmp___4 = gettext("Attribute Section: %s\n");
#line 12188
        printf((char const   */* __restrict  */)tmp___4, p);
        }
#line 12190
        if (public_name) {
          {
#line 12190
          tmp___5 = strcmp((char const   *)((char *)p), public_name);
          }
#line 12190
          if (tmp___5 == 0) {
#line 12191
            public_section = 1;
          } else {
#line 12193
            public_section = 0;
          }
        } else {
#line 12193
          public_section = 0;
        }
        {
#line 12195
        tmp___6 = strcmp((char const   *)((char *)p), "gnu");
        }
#line 12195
        if (tmp___6 == 0) {
#line 12196
          gnu_section = 1;
        } else {
#line 12198
          gnu_section = 0;
        }
        {
#line 12200
        tmp___7 = strlen((char const   *)((char *)p));
#line 12200
        namelen = (int )(tmp___7 + 1UL);
#line 12201
        p += namelen;
#line 12202
        section_len -= (bfd_vma )(namelen + 4);
        }
        {
#line 12204
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 12204
          if (! (section_len > 0UL)) {
#line 12204
            goto while_break___1;
          }
          {
#line 12206
          tmp___8 = p;
#line 12206
          p ++;
#line 12206
          tag = (int )*tmp___8;
#line 12210
          tmp___9 = (*byte_get)(p, 4);
#line 12210
          size = (bfd_vma )tmp___9;
          }
#line 12211
          if (size > section_len) {
            {
#line 12213
            tmp___10 = gettext("ERROR: Bad subsection length (%d > %d)\n");
#line 12213
            printf((char const   */* __restrict  */)tmp___10, (int )size, (int )section_len);
#line 12215
            size = section_len;
            }
          }
#line 12218
          section_len -= size;
#line 12219
          end = (p + size) - 1;
#line 12220
          p += 4;
          {
#line 12224
          if (tag == 1) {
#line 12224
            goto case_1;
          }
#line 12227
          if (tag == 2) {
#line 12227
            goto case_2;
          }
#line 12230
          if (tag == 3) {
#line 12230
            goto case_3;
          }
#line 12245
          goto switch_default;
          case_1: /* CIL Label */ 
          {
#line 12225
          tmp___11 = gettext("File Attributes\n");
#line 12225
          printf((char const   */* __restrict  */)tmp___11);
          }
#line 12226
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 12228
          tmp___12 = gettext("Section Attributes:");
#line 12228
          printf((char const   */* __restrict  */)tmp___12);
          }
#line 12229
          goto do_numlist;
          case_3: /* CIL Label */ 
          {
#line 12231
          tmp___13 = gettext("Symbol Attributes:");
#line 12231
          printf((char const   */* __restrict  */)tmp___13);
          }
          do_numlist: 
          {
#line 12233
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 12237
            tmp___14 = read_uleb128___0(p, & j, (unsigned char const   */* const  */)end);
#line 12237
            val = (int )tmp___14;
#line 12238
            p += j;
            }
#line 12239
            if (val == 0) {
#line 12240
              goto while_break___2;
            }
            {
#line 12241
            printf((char const   */* __restrict  */)" %d", val);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 12243
          printf((char const   */* __restrict  */)"\n");
          }
#line 12244
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 12246
          tmp___15 = gettext("Unknown tag: %d\n");
#line 12246
          printf((char const   */* __restrict  */)tmp___15, tag);
#line 12247
          public_section = 0;
          }
#line 12248
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 12251
          if (public_section) {
            {
#line 12253
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 12253
              if (! ((unsigned long )p < (unsigned long )end)) {
#line 12253
                goto while_break___3;
              }
              {
#line 12254
              p = (*display_pub_attribute)(p, (unsigned char const   */* const  */)end);
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          } else
#line 12256
          if (gnu_section) {
            {
#line 12258
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 12258
              if (! ((unsigned long )p < (unsigned long )end)) {
#line 12258
                goto while_break___4;
              }
              {
#line 12259
              p = display_gnu_attribute(p, display_proc_gnu_attribute, (unsigned char const   */* const  */)end);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
            {
#line 12265
            tmp___16 = gettext("  Unknown section contexts\n");
#line 12265
            printf((char const   */* __restrict  */)tmp___16);
#line 12266
            display_raw_attribute(p, end);
#line 12267
            p = end;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 12273
      tmp___17 = gettext("Unknown format \'%c\'\n");
#line 12273
      printf((char const   */* __restrict  */)tmp___17, (int )*p);
      }
    }
    {
#line 12275
    free((void *)contents);
    }
    __Cont: /* CIL Label */ 
#line 12153
    i ++;
#line 12153
    sect ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12277
  return (1);
}
}
#line 12280 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_arm_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 12283
  tmp___0 = process_attributes(file, "aeabi", 1879048195U, & display_arm_attribute,
                               (unsigned char *(*)(unsigned char * , int  , unsigned char const   * const   ))((void *)0));
  }
#line 12283
  return (tmp___0);
}
}
#line 12287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_power_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 12290
  tmp___0 = process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ,
                                                                                                   unsigned char const   * const   ))((void *)0),
                               & display_power_gnu_attribute);
  }
#line 12290
  return (tmp___0);
}
}
#line 12294 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_sparc_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 12297
  tmp___0 = process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ,
                                                                                                   unsigned char const   * const   ))((void *)0),
                               & display_sparc_gnu_attribute);
  }
#line 12297
  return (tmp___0);
}
}
#line 12301 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_tic6x_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 12304
  tmp___0 = process_attributes(file, "c6xabi", 1879048195U, & display_tic6x_attribute,
                               (unsigned char *(*)(unsigned char * , int  , unsigned char const   * const   ))((void *)0));
  }
#line 12304
  return (tmp___0);
}
}
#line 12308 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_msp430x_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 12311
  tmp___0 = process_attributes(file, "mspabi", 1879048195U, & display_msp430x_attribute,
                               (unsigned char *(*)(unsigned char * , int  , unsigned char const   * const   ))((void *)0));
  }
#line 12311
  return (tmp___0);
}
}
#line 12319 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma print_mips_got_entry(unsigned char *data , bfd_vma pltgot , bfd_vma addr ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  bfd_vma entry ;
  int tmp___2 ;
  elf_vma tmp___3 ;
  int tmp___4 ;

  {
  {
#line 12322
  printf((char const   */* __restrict  */)"  ");
#line 12323
  print_vma(addr, (print_mode )6);
#line 12324
  printf((char const   */* __restrict  */)" ");
  }
#line 12325
  if (addr < pltgot + 65520UL) {
    {
#line 12326
    printf((char const   */* __restrict  */)"%6d(gp)", (int )((addr - pltgot) - 32752UL));
    }
  } else {
    {
#line 12328
    printf((char const   */* __restrict  */)"%10s", "");
    }
  }
  {
#line 12329
  printf((char const   */* __restrict  */)" ");
  }
#line 12330
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 12331
    tmp___0 = gettext("<unknown>");
    }
#line 12331
    if (is_32bit_elf) {
#line 12331
      tmp___1 = 8;
    } else {
#line 12331
      tmp___1 = 16;
    }
    {
#line 12331
    printf((char const   */* __restrict  */)"%*s", tmp___1, tmp___0);
    }
  } else {
#line 12336
    if (is_32bit_elf) {
#line 12336
      tmp___2 = 4;
    } else {
#line 12336
      tmp___2 = 8;
    }
    {
#line 12336
    tmp___3 = (*byte_get)((data + addr) - pltgot, tmp___2);
#line 12336
    entry = (bfd_vma )tmp___3;
#line 12337
    print_vma(entry, (print_mode )6);
    }
  }
#line 12339
  if (is_32bit_elf) {
#line 12339
    tmp___4 = 4;
  } else {
#line 12339
    tmp___4 = 8;
  }
#line 12339
  return (addr + (bfd_vma )tmp___4);
}
}
#line 12346 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static bfd_vma print_mips_pltgot_entry(unsigned char *data , bfd_vma pltgot , bfd_vma addr ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  bfd_vma entry ;
  int tmp___2 ;
  elf_vma tmp___3 ;
  int tmp___4 ;

  {
  {
#line 12349
  printf((char const   */* __restrict  */)"  ");
#line 12350
  print_vma(addr, (print_mode )6);
#line 12351
  printf((char const   */* __restrict  */)" ");
  }
#line 12352
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 12353
    tmp___0 = gettext("<unknown>");
    }
#line 12353
    if (is_32bit_elf) {
#line 12353
      tmp___1 = 8;
    } else {
#line 12353
      tmp___1 = 16;
    }
    {
#line 12353
    printf((char const   */* __restrict  */)"%*s", tmp___1, tmp___0);
    }
  } else {
#line 12358
    if (is_32bit_elf) {
#line 12358
      tmp___2 = 4;
    } else {
#line 12358
      tmp___2 = 8;
    }
    {
#line 12358
    tmp___3 = (*byte_get)((data + addr) - pltgot, tmp___2);
#line 12358
    entry = (bfd_vma )tmp___3;
#line 12359
    print_vma(entry, (print_mode )6);
    }
  }
#line 12361
  if (is_32bit_elf) {
#line 12361
    tmp___4 = 4;
  } else {
#line 12361
    tmp___4 = 8;
  }
#line 12361
  return (addr + (bfd_vma )tmp___4);
}
}
#line 12487
static int process_mips_specific(FILE *file ) ;
#line 12487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static struct __anonstruct_l_flags_vals_973678110  const  l_flags_vals[6]  = {      {" EXACT_MATCH", 1}, 
        {" IGNORE_INT_VER", 2}, 
        {" REQUIRE_MINOR", 4}, 
        {" EXPORTS", 8}, 
        {" DELAY_LOAD", 16}, 
        {" DELTA", 32}};
#line 12364 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_mips_specific(FILE *file ) 
{ 
  Elf_Internal_Dyn *entry ;
  size_t liblist_offset ;
  size_t liblistno ;
  size_t conflictsno ;
  size_t options_offset ;
  size_t conflicts_offset ;
  size_t pltrelsz ;
  size_t pltrel ;
  bfd_vma pltgot ;
  bfd_vma mips_pltgot ;
  bfd_vma jmprel ;
  bfd_vma local_gotno ;
  bfd_vma gotsym ;
  bfd_vma symtabno ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Elf32_External_Lib *elib ;
  size_t cnt ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Elf32_Lib liblist ;
  time_t atime ;
  char timebuf[20] ;
  struct tm *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int flags___1 ;
  size_t fcnt ;
  Elf_External_Options *eopt ;
  Elf_Internal_Shdr *sect ;
  Elf_Internal_Options *iopt ;
  Elf_Internal_Options *option ;
  size_t offset ;
  int cnt___0 ;
  char *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  Elf_External_Options *eoption ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  size_t len ;
  Elf32_External_RegInfo *ereg ;
  Elf32_RegInfo reginfo ;
  elf_vma tmp___30 ;
  elf_vma tmp___31 ;
  elf_vma tmp___32 ;
  elf_vma tmp___33 ;
  elf_vma tmp___34 ;
  elf_vma tmp___35 ;
  Elf64_External_RegInfo *ereg___0 ;
  Elf64_Internal_RegInfo reginfo___0 ;
  elf_vma tmp___36 ;
  elf_vma tmp___37 ;
  elf_vma tmp___38 ;
  elf_vma tmp___39 ;
  elf_vma tmp___40 ;
  elf_vma tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  Elf32_Conflict *iconf ;
  size_t cnt___1 ;
  char *tmp___45 ;
  void *tmp___46 ;
  char *tmp___47 ;
  Elf32_External_Conflict *econf32 ;
  char *tmp___48 ;
  void *tmp___49 ;
  elf_vma tmp___50 ;
  Elf64_External_Conflict *econf64 ;
  char *tmp___51 ;
  void *tmp___52 ;
  elf_vma tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  Elf_Internal_Sym *psym ;
  char *tmp___56 ;
  bfd_vma ent ;
  bfd_vma local_end ;
  bfd_vma global_end ;
  size_t i ;
  size_t offset___0 ;
  unsigned char *data ;
  int addr_size ;
  long tmp___57 ;
  char *tmp___58 ;
  void *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  elf_vma tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  int sym_width ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  int tmp___82 ;
  Elf_Internal_Sym *psym___0 ;
  char const   *tmp___83 ;
  char const   *tmp___84 ;
  char *tmp___85 ;
  bfd_vma ent___0 ;
  bfd_vma end ;
  size_t offset___1 ;
  size_t rel_offset ;
  unsigned long count ;
  unsigned long i___0 ;
  unsigned char *data___0 ;
  int addr_size___0 ;
  int sym_width___0 ;
  Elf_Internal_Rela *rels ;
  long tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  long tmp___89 ;
  char *tmp___90 ;
  void *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  int tmp___105 ;
  Elf_Internal_Sym *psym___1 ;
  bfd_vma tmp___106 ;
  char const   *tmp___107 ;
  char const   *tmp___108 ;
  char *tmp___109 ;

  {
  {
#line 12368
  liblist_offset = (size_t )0;
#line 12369
  liblistno = (size_t )0;
#line 12370
  conflictsno = (size_t )0;
#line 12371
  options_offset = (size_t )0;
#line 12372
  conflicts_offset = (size_t )0;
#line 12373
  pltrelsz = (size_t )0;
#line 12374
  pltrel = (size_t )0;
#line 12375
  pltgot = (bfd_vma )0;
#line 12376
  mips_pltgot = (bfd_vma )0;
#line 12377
  jmprel = (bfd_vma )0;
#line 12378
  local_gotno = (bfd_vma )0;
#line 12379
  gotsym = (bfd_vma )0;
#line 12380
  symtabno = (bfd_vma )0;
#line 12382
  process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ,
                                                                                         unsigned char const   * const   ))((void *)0),
                     & display_mips_gnu_attribute);
  }
#line 12386
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
#line 12388
    return (0);
  }
#line 12390
  entry = dynamic_section;
  {
#line 12390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12390
    if (! (entry->d_tag != 0UL)) {
#line 12390
      goto while_break;
    }
    {
#line 12393
    if (entry->d_tag == 1879048201UL) {
#line 12393
      goto case_1879048201;
    }
#line 12398
    if (entry->d_tag == 1879048208UL) {
#line 12398
      goto case_1879048208;
    }
#line 12401
    if (entry->d_tag == 1879048233UL) {
#line 12401
      goto case_1879048233;
    }
#line 12404
    if (entry->d_tag == 1879048200UL) {
#line 12404
      goto case_1879048200;
    }
#line 12409
    if (entry->d_tag == 1879048203UL) {
#line 12409
      goto case_1879048203;
    }
#line 12412
    if (entry->d_tag == 3UL) {
#line 12412
      goto case_3;
    }
#line 12415
    if (entry->d_tag == 1879048202UL) {
#line 12415
      goto case_1879048202;
    }
#line 12418
    if (entry->d_tag == 1879048211UL) {
#line 12418
      goto case_1879048211;
    }
#line 12421
    if (entry->d_tag == 1879048209UL) {
#line 12421
      goto case_1879048209;
    }
#line 12424
    if (entry->d_tag == 1879048242UL) {
#line 12424
      goto case_1879048242;
    }
#line 12427
    if (entry->d_tag == 20UL) {
#line 12427
      goto case_20;
    }
#line 12430
    if (entry->d_tag == 2UL) {
#line 12430
      goto case_2;
    }
#line 12433
    if (entry->d_tag == 23UL) {
#line 12433
      goto case_23;
    }
#line 12436
    goto switch_default;
    case_1879048201: /* CIL Label */ 
    {
#line 12394
    tmp___0 = offset_from_vma(file, entry->d_un.d_val, liblistno * sizeof(Elf32_External_Lib ));
#line 12394
    liblist_offset = (size_t )tmp___0;
    }
#line 12397
    goto switch_break;
    case_1879048208: /* CIL Label */ 
#line 12399
    liblistno = entry->d_un.d_val;
#line 12400
    goto switch_break;
    case_1879048233: /* CIL Label */ 
    {
#line 12402
    tmp___1 = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
#line 12402
    options_offset = (size_t )tmp___1;
    }
#line 12403
    goto switch_break;
    case_1879048200: /* CIL Label */ 
    {
#line 12405
    tmp___2 = offset_from_vma(file, entry->d_un.d_val, conflictsno * sizeof(Elf32_External_Conflict ));
#line 12405
    conflicts_offset = (size_t )tmp___2;
    }
#line 12408
    goto switch_break;
    case_1879048203: /* CIL Label */ 
#line 12410
    conflictsno = entry->d_un.d_val;
#line 12411
    goto switch_break;
    case_3: /* CIL Label */ 
#line 12413
    pltgot = entry->d_un.d_ptr;
#line 12414
    goto switch_break;
    case_1879048202: /* CIL Label */ 
#line 12416
    local_gotno = entry->d_un.d_val;
#line 12417
    goto switch_break;
    case_1879048211: /* CIL Label */ 
#line 12419
    gotsym = entry->d_un.d_val;
#line 12420
    goto switch_break;
    case_1879048209: /* CIL Label */ 
#line 12422
    symtabno = entry->d_un.d_val;
#line 12423
    goto switch_break;
    case_1879048242: /* CIL Label */ 
#line 12425
    mips_pltgot = entry->d_un.d_ptr;
#line 12426
    goto switch_break;
    case_20: /* CIL Label */ 
#line 12428
    pltrel = entry->d_un.d_val;
#line 12429
    goto switch_break;
    case_2: /* CIL Label */ 
#line 12431
    pltrelsz = entry->d_un.d_val;
#line 12432
    goto switch_break;
    case_23: /* CIL Label */ 
#line 12434
    jmprel = entry->d_un.d_ptr;
#line 12435
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 12437
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 12390
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12440
  if (liblist_offset != 0UL) {
#line 12440
    if (liblistno != 0UL) {
#line 12440
      if (do_dynamic) {
        {
#line 12445
        tmp___3 = gettext("liblist section data");
#line 12445
        tmp___4 = get_data((void *)0, file, (long )liblist_offset, liblistno, sizeof(Elf32_External_Lib ),
                           (char const   *)tmp___3);
#line 12445
        elib = (Elf32_External_Lib *)tmp___4;
        }
#line 12449
        if (elib) {
          {
#line 12451
          tmp___5 = gettext("\nSection \'.liblist\' contains %lu entries:\n");
#line 12451
          printf((char const   */* __restrict  */)tmp___5, liblistno);
#line 12453
          tmp___6 = gettext("     Library              Time Stamp          Checksum   Version Flags\n");
#line 12453
          fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 12456
          cnt = (size_t )0;
          }
          {
#line 12456
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 12456
            if (! (cnt < liblistno)) {
#line 12456
              goto while_break___0;
            }
            {
#line 12463
            tmp___8 = (*byte_get)((elib + cnt)->l_name, (int )sizeof((elib + cnt)->l_name));
#line 12463
            liblist.l_name = (unsigned long )tmp___8;
#line 12464
            tmp___9 = (*byte_get)((elib + cnt)->l_time_stamp, (int )sizeof((elib + cnt)->l_time_stamp));
#line 12464
            atime = (time_t )tmp___9;
#line 12465
            tmp___10 = (*byte_get)((elib + cnt)->l_checksum, (int )sizeof((elib + cnt)->l_checksum));
#line 12465
            liblist.l_checksum = (unsigned long )tmp___10;
#line 12466
            tmp___11 = (*byte_get)((elib + cnt)->l_version, (int )sizeof((elib + cnt)->l_version));
#line 12466
            liblist.l_version = (unsigned long )tmp___11;
#line 12467
            tmp___12 = (*byte_get)((elib + cnt)->l_flags, (int )sizeof((elib + cnt)->l_flags));
#line 12467
            liblist.l_flags = (unsigned long )tmp___12;
#line 12469
            tmp___7 = gmtime((time_t const   *)(& atime));
#line 12470
            snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
                     tmp___7->tm_year + 1900, tmp___7->tm_mon + 1, tmp___7->tm_mday,
                     tmp___7->tm_hour, tmp___7->tm_min, tmp___7->tm_sec);
#line 12475
            printf((char const   */* __restrict  */)"%3lu: ", cnt);
            }
#line 12476
            if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12476
              if (liblist.l_name < dynamic_strings_length) {
                {
#line 12477
                print_symbol(20, (char const   *)(dynamic_strings + liblist.l_name));
                }
              } else {
                {
#line 12479
                tmp___13 = gettext("<corrupt: %9ld>");
#line 12479
                printf((char const   */* __restrict  */)tmp___13, liblist.l_name);
                }
              }
            } else {
              {
#line 12479
              tmp___13 = gettext("<corrupt: %9ld>");
#line 12479
              printf((char const   */* __restrict  */)tmp___13, liblist.l_name);
              }
            }
            {
#line 12480
            printf((char const   */* __restrict  */)" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
                   liblist.l_version);
            }
#line 12483
            if (liblist.l_flags == 0UL) {
              {
#line 12484
              tmp___14 = gettext(" NONE");
#line 12484
              puts((char const   *)tmp___14);
              }
            } else {
#line 12501
              flags___1 = (int )liblist.l_flags;
#line 12504
              fcnt = (size_t )0;
              {
#line 12504
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 12504
                if (! (fcnt < sizeof(l_flags_vals) / sizeof(l_flags_vals[0]))) {
#line 12504
                  goto while_break___1;
                }
#line 12505
                if ((flags___1 & (int )l_flags_vals[fcnt].bit) != 0) {
                  {
#line 12507
                  fputs((char const   */* __restrict  */)l_flags_vals[fcnt].name,
                        (FILE */* __restrict  */)stdout);
#line 12508
                  flags___1 ^= (int )l_flags_vals[fcnt].bit;
                  }
                }
#line 12504
                fcnt ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 12510
              if (flags___1 != 0) {
                {
#line 12511
                printf((char const   */* __restrict  */)" %#x", (unsigned int )flags___1);
                }
              }
              {
#line 12513
              puts("");
              }
            }
#line 12456
            cnt ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 12517
          free((void *)elib);
          }
        }
      }
    }
  }
#line 12521
  if (options_offset != 0UL) {
#line 12524
    sect = section_headers;
    {
#line 12531
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 12531
      if (! (sect->sh_type != 1879048205U)) {
#line 12531
        goto while_break___2;
      }
#line 12532
      sect ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 12534
    tmp___15 = gettext("options");
#line 12534
    tmp___16 = get_data((void *)0, file, (long )options_offset, (size_t )1, sect->sh_size,
                        (char const   *)tmp___15);
#line 12534
    eopt = (Elf_External_Options *)tmp___16;
    }
#line 12536
    if (eopt) {
      {
#line 12538
      tmp___17 = cmalloc(sect->sh_size / sizeof(eopt), sizeof(*iopt));
#line 12538
      iopt = (Elf_Internal_Options *)tmp___17;
      }
#line 12540
      if ((unsigned long )iopt == (unsigned long )((void *)0)) {
        {
#line 12542
        tmp___18 = gettext("Out of memory\n");
#line 12542
        error((char const   *)tmp___18);
        }
#line 12543
        return (0);
      }
#line 12546
      cnt___0 = 0;
#line 12546
      offset = (size_t )cnt___0;
#line 12547
      option = iopt;
      {
#line 12549
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 12549
        if (! (offset < sect->sh_size)) {
#line 12549
          goto while_break___3;
        }
        {
#line 12553
        eoption = (Elf_External_Options *)((char *)eopt + offset);
#line 12555
        tmp___19 = (*byte_get)(eoption->kind, (int )sizeof(eoption->kind));
#line 12555
        option->kind = (unsigned char )tmp___19;
#line 12556
        tmp___20 = (*byte_get)(eoption->size, (int )sizeof(eoption->size));
#line 12556
        option->size = (unsigned char )tmp___20;
#line 12557
        tmp___21 = (*byte_get)(eoption->section, (int )sizeof(eoption->section));
#line 12557
        option->section = (unsigned short )tmp___21;
#line 12558
        tmp___22 = (*byte_get)(eoption->info, (int )sizeof(eoption->info));
#line 12558
        option->info = (unsigned long )tmp___22;
#line 12560
        offset += (size_t )option->size;
#line 12562
        option ++;
#line 12563
        cnt___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 12566
      if ((unsigned long )sect == (unsigned long )((void *)0)) {
        {
#line 12566
        tmp___23 = gettext("<none>");
#line 12566
        tmp___28 = tmp___23;
        }
      } else {
#line 12566
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 12566
          tmp___24 = gettext("<no-name>");
#line 12566
          tmp___27 = tmp___24;
          }
        } else {
#line 12566
          if ((unsigned long )sect->sh_name >= string_table_length) {
            {
#line 12566
            tmp___25 = gettext("<corrupt>");
#line 12566
            tmp___26 = tmp___25;
            }
          } else {
#line 12566
            tmp___26 = string_table + sect->sh_name;
          }
#line 12566
          tmp___27 = tmp___26;
        }
#line 12566
        tmp___28 = tmp___27;
      }
      {
#line 12566
      tmp___29 = gettext("\nSection \'%s\' contains %d entries:\n");
#line 12566
      printf((char const   */* __restrict  */)tmp___29, tmp___28, cnt___0);
#line 12569
      option = iopt;
      }
      {
#line 12571
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 12571
        tmp___44 = cnt___0;
#line 12571
        cnt___0 --;
#line 12571
        if (! (tmp___44 > 0)) {
#line 12571
          goto while_break___4;
        }
        {
#line 12577
        if ((int )option->kind == 0) {
#line 12577
          goto case_0;
        }
#line 12581
        if ((int )option->kind == 1) {
#line 12581
          goto case_1;
        }
#line 12629
        if ((int )option->kind == 2) {
#line 12629
          goto case_2___0;
        }
#line 12645
        if ((int )option->kind == 3) {
#line 12645
          goto case_3___0;
        }
#line 12654
        if ((int )option->kind == 4) {
#line 12654
          goto case_4;
        }
#line 12665
        if ((int )option->kind == 5) {
#line 12665
          goto case_5;
        }
#line 12669
        if ((int )option->kind == 6) {
#line 12669
          goto case_6;
        }
#line 12673
        if ((int )option->kind == 7) {
#line 12673
          goto case_7;
        }
#line 12680
        if ((int )option->kind == 8) {
#line 12680
          goto case_8;
        }
#line 12687
        if ((int )option->kind == 9) {
#line 12687
          goto case_9;
        }
#line 12692
        if ((int )option->kind == 10) {
#line 12692
          goto case_10;
        }
#line 12697
        goto switch_default___0;
        case_0: /* CIL Label */ 
        {
#line 12579
        printf((char const   */* __restrict  */)" NULL       %d %lx", (int )option->section,
               option->info);
        }
#line 12580
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 12582
        printf((char const   */* __restrict  */)" REGINFO    ");
        }
#line 12583
        if ((int )elf_header.e_machine == 8) {
          {
#line 12589
          ereg = (Elf32_External_RegInfo *)(option + 1);
#line 12590
          tmp___30 = (*byte_get)(ereg->ri_gprmask, (int )sizeof(ereg->ri_gprmask));
#line 12590
          reginfo.ri_gprmask = (unsigned long )tmp___30;
#line 12591
          tmp___31 = (*byte_get)(ereg->ri_cprmask[0], (int )sizeof(ereg->ri_cprmask[0]));
#line 12591
          reginfo.ri_cprmask[0] = (unsigned long )tmp___31;
#line 12592
          tmp___32 = (*byte_get)(ereg->ri_cprmask[1], (int )sizeof(ereg->ri_cprmask[1]));
#line 12592
          reginfo.ri_cprmask[1] = (unsigned long )tmp___32;
#line 12593
          tmp___33 = (*byte_get)(ereg->ri_cprmask[2], (int )sizeof(ereg->ri_cprmask[2]));
#line 12593
          reginfo.ri_cprmask[2] = (unsigned long )tmp___33;
#line 12594
          tmp___34 = (*byte_get)(ereg->ri_cprmask[3], (int )sizeof(ereg->ri_cprmask[3]));
#line 12594
          reginfo.ri_cprmask[3] = (unsigned long )tmp___34;
#line 12595
          tmp___35 = (*byte_get)(ereg->ri_gp_value, (int )sizeof(ereg->ri_gp_value));
#line 12595
          reginfo.ri_gp_value = (long )tmp___35;
#line 12597
          printf((char const   */* __restrict  */)"GPR %08lx  GP 0x%lx\n", reginfo.ri_gprmask,
                 (unsigned long )reginfo.ri_gp_value);
#line 12600
          printf((char const   */* __restrict  */)"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
                 reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2],
                 reginfo.ri_cprmask[3]);
          }
        } else {
          {
#line 12610
          ereg___0 = (Elf64_External_RegInfo *)(option + 1);
#line 12611
          tmp___36 = (*byte_get)(ereg___0->ri_gprmask, (int )sizeof(ereg___0->ri_gprmask));
#line 12611
          reginfo___0.ri_gprmask = (unsigned long )tmp___36;
#line 12612
          tmp___37 = (*byte_get)(ereg___0->ri_cprmask[0], (int )sizeof(ereg___0->ri_cprmask[0]));
#line 12612
          reginfo___0.ri_cprmask[0] = (unsigned long )tmp___37;
#line 12613
          tmp___38 = (*byte_get)(ereg___0->ri_cprmask[1], (int )sizeof(ereg___0->ri_cprmask[1]));
#line 12613
          reginfo___0.ri_cprmask[1] = (unsigned long )tmp___38;
#line 12614
          tmp___39 = (*byte_get)(ereg___0->ri_cprmask[2], (int )sizeof(ereg___0->ri_cprmask[2]));
#line 12614
          reginfo___0.ri_cprmask[2] = (unsigned long )tmp___39;
#line 12615
          tmp___40 = (*byte_get)(ereg___0->ri_cprmask[3], (int )sizeof(ereg___0->ri_cprmask[3]));
#line 12615
          reginfo___0.ri_cprmask[3] = (unsigned long )tmp___40;
#line 12616
          tmp___41 = (*byte_get)(ereg___0->ri_gp_value, (int )sizeof(ereg___0->ri_gp_value));
#line 12616
          reginfo___0.ri_gp_value = (bfd_vma )tmp___41;
#line 12618
          printf((char const   */* __restrict  */)"GPR %08lx  GP 0x", reginfo___0.ri_gprmask);
#line 12620
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
                  reginfo___0.ri_gp_value);
#line 12621
          printf((char const   */* __restrict  */)"\n");
#line 12623
          printf((char const   */* __restrict  */)"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
                 reginfo___0.ri_cprmask[0], reginfo___0.ri_cprmask[1], reginfo___0.ri_cprmask[2],
                 reginfo___0.ri_cprmask[3]);
          }
        }
#line 12627
        option ++;
#line 12628
        goto while_continue___4;
        case_2___0: /* CIL Label */ 
        {
#line 12630
        fputs((char const   */* __restrict  */)" EXCEPTIONS fpe_min(", (FILE */* __restrict  */)stdout);
#line 12631
        process_mips_fpe_exception((int )(option->info & 31UL));
#line 12632
        fputs((char const   */* __restrict  */)") fpe_max(", (FILE */* __restrict  */)stdout);
#line 12633
        process_mips_fpe_exception((int )((option->info & 7936UL) >> 8));
#line 12634
        fputs((char const   */* __restrict  */)")", (FILE */* __restrict  */)stdout);
        }
#line 12636
        if (option->info & 65536UL) {
          {
#line 12637
          fputs((char const   */* __restrict  */)" PAGE0", (FILE */* __restrict  */)stdout);
          }
        }
#line 12638
        if (option->info & 131072UL) {
          {
#line 12639
          fputs((char const   */* __restrict  */)" SMM", (FILE */* __restrict  */)stdout);
          }
        }
#line 12640
        if (option->info & 262144UL) {
          {
#line 12641
          fputs((char const   */* __restrict  */)" FPDBUG", (FILE */* __restrict  */)stdout);
          }
        }
#line 12642
        if (option->info & 524288UL) {
          {
#line 12643
          fputs((char const   */* __restrict  */)" DISMISS", (FILE */* __restrict  */)stdout);
          }
        }
#line 12644
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
        {
#line 12646
        fputs((char const   */* __restrict  */)" PAD       ", (FILE */* __restrict  */)stdout);
        }
#line 12647
        if (option->info & 1UL) {
          {
#line 12648
          fputs((char const   */* __restrict  */)" PREFIX", (FILE */* __restrict  */)stdout);
          }
        }
#line 12649
        if (option->info & 2UL) {
          {
#line 12650
          fputs((char const   */* __restrict  */)" POSTFIX", (FILE */* __restrict  */)stdout);
          }
        }
#line 12651
        if (option->info & 4UL) {
          {
#line 12652
          fputs((char const   */* __restrict  */)" SYMBOL", (FILE */* __restrict  */)stdout);
          }
        }
#line 12653
        goto switch_break___0;
        case_4: /* CIL Label */ 
        {
#line 12655
        fputs((char const   */* __restrict  */)" HWPATCH   ", (FILE */* __restrict  */)stdout);
        }
#line 12656
        if (option->info & 1UL) {
          {
#line 12657
          fputs((char const   */* __restrict  */)" R4KEOP", (FILE */* __restrict  */)stdout);
          }
        }
#line 12658
        if (option->info & 2UL) {
          {
#line 12659
          fputs((char const   */* __restrict  */)" R8KPFETCH", (FILE */* __restrict  */)stdout);
          }
        }
#line 12660
        if (option->info & 4UL) {
          {
#line 12661
          fputs((char const   */* __restrict  */)" R5KEOP", (FILE */* __restrict  */)stdout);
          }
        }
#line 12662
        if (option->info & 8UL) {
          {
#line 12663
          fputs((char const   */* __restrict  */)" R5KCVTL", (FILE */* __restrict  */)stdout);
          }
        }
#line 12664
        goto switch_break___0;
        case_5: /* CIL Label */ 
        {
#line 12666
        fputs((char const   */* __restrict  */)" FILL       ", (FILE */* __restrict  */)stdout);
        }
#line 12668
        goto switch_break___0;
        case_6: /* CIL Label */ 
        {
#line 12670
        fputs((char const   */* __restrict  */)" TAGS       ", (FILE */* __restrict  */)stdout);
        }
#line 12672
        goto switch_break___0;
        case_7: /* CIL Label */ 
        {
#line 12674
        fputs((char const   */* __restrict  */)" HWAND     ", (FILE */* __restrict  */)stdout);
        }
#line 12675
        if (option->info & 1UL) {
          {
#line 12676
          fputs((char const   */* __restrict  */)" R4KEOP_CHECKED", (FILE */* __restrict  */)stdout);
          }
        }
#line 12677
        if (option->info & 2UL) {
          {
#line 12678
          fputs((char const   */* __restrict  */)" R4KEOP_CLEAN", (FILE */* __restrict  */)stdout);
          }
        }
#line 12679
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 12681
        fputs((char const   */* __restrict  */)" HWOR      ", (FILE */* __restrict  */)stdout);
        }
#line 12682
        if (option->info & 1UL) {
          {
#line 12683
          fputs((char const   */* __restrict  */)" R4KEOP_CHECKED", (FILE */* __restrict  */)stdout);
          }
        }
#line 12684
        if (option->info & 2UL) {
          {
#line 12685
          fputs((char const   */* __restrict  */)" R4KEOP_CLEAN", (FILE */* __restrict  */)stdout);
          }
        }
#line 12686
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 12688
        printf((char const   */* __restrict  */)" GP_GROUP  %#06lx  self-contained %#06lx",
               option->info & 65535UL, (option->info & 4294901760UL) >> 16);
        }
#line 12691
        goto switch_break___0;
        case_10: /* CIL Label */ 
        {
#line 12693
        printf((char const   */* __restrict  */)" IDENT     %#06lx  self-contained %#06lx",
               option->info & 65535UL, (option->info & 4294901760UL) >> 16);
        }
#line 12696
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 12699
        printf((char const   */* __restrict  */)" %3d ???     %d %lx", (int )option->kind,
               (int )option->section, option->info);
        }
#line 12701
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 12704
        len = sizeof(*eopt);
        {
#line 12705
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 12705
          if (! (len < (size_t )option->size)) {
#line 12705
            goto while_break___5;
          }
#line 12706
          if ((int )*((char *)option + len) >= 32) {
#line 12706
            if ((int )*((char *)option + len) < 127) {
              {
#line 12708
              tmp___42 = len;
#line 12708
              len ++;
#line 12708
              printf((char const   */* __restrict  */)"%c", (int )*((char *)option + tmp___42));
              }
            } else {
              {
#line 12710
              tmp___43 = len;
#line 12710
              len ++;
#line 12710
              printf((char const   */* __restrict  */)"\\%03o", (int )*((char *)option + tmp___43));
              }
            }
          } else {
            {
#line 12710
            tmp___43 = len;
#line 12710
            len ++;
#line 12710
            printf((char const   */* __restrict  */)"\\%03o", (int )*((char *)option + tmp___43));
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 12712
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
#line 12713
        option ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 12716
      free((void *)eopt);
      }
    }
  }
#line 12720
  if (conflicts_offset != 0UL) {
#line 12720
    if (conflictsno != 0UL) {
#line 12725
      if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
        {
#line 12727
        tmp___45 = gettext("conflict list found without a dynamic symbol table\n");
#line 12727
        error((char const   *)tmp___45);
        }
#line 12728
        return (0);
      }
      {
#line 12731
      tmp___46 = cmalloc(conflictsno, sizeof(*iconf));
#line 12731
      iconf = (Elf32_Conflict *)tmp___46;
      }
#line 12732
      if ((unsigned long )iconf == (unsigned long )((void *)0)) {
        {
#line 12734
        tmp___47 = gettext("Out of memory\n");
#line 12734
        error((char const   *)tmp___47);
        }
#line 12735
        return (0);
      }
#line 12738
      if (is_32bit_elf) {
        {
#line 12742
        tmp___48 = gettext("conflict");
#line 12742
        tmp___49 = get_data((void *)0, file, (long )conflicts_offset, conflictsno,
                            sizeof(*econf32), (char const   *)tmp___48);
#line 12742
        econf32 = (Elf32_External_Conflict *)tmp___49;
        }
#line 12745
        if (! econf32) {
#line 12746
          return (0);
        }
#line 12748
        cnt___1 = (size_t )0;
        {
#line 12748
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 12748
          if (! (cnt___1 < conflictsno)) {
#line 12748
            goto while_break___6;
          }
          {
#line 12749
          tmp___50 = (*byte_get)(*(econf32 + cnt___1), (int )sizeof(*(econf32 + cnt___1)));
#line 12749
          *(iconf + cnt___1) = (Elf32_Conflict )tmp___50;
#line 12748
          cnt___1 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 12751
        free((void *)econf32);
        }
      } else {
        {
#line 12757
        tmp___51 = gettext("conflict");
#line 12757
        tmp___52 = get_data((void *)0, file, (long )conflicts_offset, conflictsno,
                            sizeof(*econf64), (char const   *)tmp___51);
#line 12757
        econf64 = (Elf64_External_Conflict *)tmp___52;
        }
#line 12760
        if (! econf64) {
#line 12761
          return (0);
        }
#line 12763
        cnt___1 = (size_t )0;
        {
#line 12763
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 12763
          if (! (cnt___1 < conflictsno)) {
#line 12763
            goto while_break___7;
          }
          {
#line 12764
          tmp___53 = (*byte_get)(*(econf64 + cnt___1), (int )sizeof(*(econf64 + cnt___1)));
#line 12764
          *(iconf + cnt___1) = (Elf32_Conflict )tmp___53;
#line 12763
          cnt___1 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 12766
        free((void *)econf64);
        }
      }
      {
#line 12769
      tmp___54 = gettext("\nSection \'.conflict\' contains %lu entries:\n");
#line 12769
      printf((char const   */* __restrict  */)tmp___54, conflictsno);
#line 12771
      tmp___55 = gettext("  Num:    Index       Value  Name");
#line 12771
      puts((char const   *)tmp___55);
#line 12773
      cnt___1 = (size_t )0;
      }
      {
#line 12773
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 12773
        if (! (cnt___1 < conflictsno)) {
#line 12773
          goto while_break___8;
        }
        {
#line 12775
        psym = dynamic_symbols + *(iconf + cnt___1);
#line 12777
        printf((char const   */* __restrict  */)"%5lu: %8lu  ", cnt___1, *(iconf + cnt___1));
#line 12778
        print_vma(psym->st_value, (print_mode )5);
#line 12779
        putchar(' ');
        }
#line 12780
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12780
          if (psym->st_name < dynamic_strings_length) {
            {
#line 12781
            print_symbol(25, (char const   *)(dynamic_strings + psym->st_name));
            }
          } else {
            {
#line 12783
            tmp___56 = gettext("<corrupt: %14ld>");
#line 12783
            printf((char const   */* __restrict  */)tmp___56, psym->st_name);
            }
          }
        } else {
          {
#line 12783
          tmp___56 = gettext("<corrupt: %14ld>");
#line 12783
          printf((char const   */* __restrict  */)tmp___56, psym->st_name);
          }
        }
        {
#line 12784
        putchar('\n');
#line 12773
        cnt___1 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 12787
      free((void *)iconf);
      }
    }
  }
#line 12790
  if (pltgot != 0UL) {
#line 12790
    if (local_gotno != 0UL) {
#line 12797
      ent = pltgot;
#line 12798
      if (is_32bit_elf) {
#line 12798
        addr_size = 4;
      } else {
#line 12798
        addr_size = 8;
      }
      {
#line 12799
      local_end = pltgot + local_gotno * (bfd_vma )addr_size;
#line 12800
      global_end = local_end + (symtabno - gotsym) * (bfd_vma )addr_size;
#line 12802
      tmp___57 = offset_from_vma(file, pltgot, global_end - pltgot);
#line 12802
      offset___0 = (size_t )tmp___57;
#line 12803
      tmp___58 = gettext("Global Offset Table data");
#line 12803
      tmp___59 = get_data((void *)0, file, (long )offset___0, global_end - pltgot,
                          (size_t )1, (char const   *)tmp___58);
#line 12803
      data = (unsigned char *)tmp___59;
      }
#line 12806
      if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 12807
        return (0);
      }
      {
#line 12809
      tmp___60 = gettext("\nPrimary GOT:\n");
#line 12809
      printf((char const   */* __restrict  */)tmp___60);
#line 12810
      tmp___61 = gettext(" Canonical gp value: ");
#line 12810
      printf((char const   */* __restrict  */)tmp___61);
#line 12811
      print_vma(pltgot + 32752UL, (print_mode )6);
#line 12812
      printf((char const   */* __restrict  */)"\n\n");
#line 12814
      tmp___62 = gettext(" Reserved entries:\n");
#line 12814
      printf((char const   */* __restrict  */)tmp___62);
#line 12815
      tmp___63 = gettext("Initial");
#line 12815
      tmp___64 = gettext("Access");
#line 12815
      tmp___65 = gettext("Address");
#line 12815
      tmp___66 = gettext("  %*s %10s %*s Purpose\n");
#line 12815
      printf((char const   */* __restrict  */)tmp___66, addr_size * 2, tmp___65, tmp___64,
             addr_size * 2, tmp___63);
#line 12818
      ent = print_mips_got_entry(data, pltgot, ent);
#line 12819
      tmp___67 = gettext(" Lazy resolver\n");
#line 12819
      printf((char const   */* __restrict  */)tmp___67);
      }
#line 12820
      if (data) {
        {
#line 12820
        tmp___69 = (*byte_get)((data + ent) - pltgot, addr_size);
        }
#line 12820
        if (tmp___69 >> (addr_size * 8 - 1) != 0ULL) {
          {
#line 12824
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12825
          tmp___68 = gettext(" Module pointer (GNU extension)\n");
#line 12825
          printf((char const   */* __restrict  */)tmp___68);
          }
        }
      }
      {
#line 12827
      printf((char const   */* __restrict  */)"\n");
      }
#line 12829
      if (ent < local_end) {
        {
#line 12831
        tmp___70 = gettext(" Local entries:\n");
#line 12831
        printf((char const   */* __restrict  */)tmp___70);
#line 12832
        tmp___71 = gettext("Initial");
#line 12832
        tmp___72 = gettext("Access");
#line 12832
        tmp___73 = gettext("Address");
#line 12832
        printf((char const   */* __restrict  */)"  %*s %10s %*s\n", addr_size * 2,
               tmp___73, tmp___72, addr_size * 2, tmp___71);
        }
        {
#line 12835
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 12835
          if (! (ent < local_end)) {
#line 12835
            goto while_break___9;
          }
          {
#line 12837
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12838
          printf((char const   */* __restrict  */)"\n");
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 12840
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 12843
      if (gotsym < symtabno) {
        {
#line 12847
        tmp___74 = gettext(" Global entries:\n");
#line 12847
        printf((char const   */* __restrict  */)tmp___74);
#line 12848
        tmp___75 = gettext("Name");
#line 12848
        tmp___76 = gettext("Ndx");
#line 12848
        tmp___77 = gettext("Type");
#line 12848
        tmp___78 = gettext("Sym.Val.");
#line 12848
        tmp___79 = gettext("Initial");
#line 12848
        tmp___80 = gettext("Access");
#line 12848
        tmp___81 = gettext("Address");
#line 12848
        printf((char const   */* __restrict  */)"  %*s %10s %*s %*s %-7s %3s %s\n",
               addr_size * 2, tmp___81, tmp___80, addr_size * 2, tmp___79, addr_size * 2,
               tmp___78, tmp___77, tmp___76, tmp___75);
        }
#line 12857
        if (is_32bit_elf) {
#line 12857
          tmp___82 = 80;
        } else {
#line 12857
          tmp___82 = 160;
        }
#line 12857
        sym_width = ((tmp___82 - 28) - addr_size * 6) - 1;
#line 12858
        i = gotsym;
        {
#line 12858
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 12858
          if (! (i < symtabno)) {
#line 12858
            goto while_break___10;
          }
          {
#line 12862
          psym___0 = dynamic_symbols + i;
#line 12863
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12864
          printf((char const   */* __restrict  */)" ");
#line 12865
          print_vma(psym___0->st_value, (print_mode )6);
#line 12866
          tmp___83 = get_symbol_index_type(psym___0->st_shndx);
#line 12866
          tmp___84 = get_symbol_type((unsigned int )((int )psym___0->st_info & 15));
#line 12866
          printf((char const   */* __restrict  */)" %-7s %3s ", tmp___84, tmp___83);
          }
#line 12869
          if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12869
            if (psym___0->st_name < dynamic_strings_length) {
              {
#line 12870
              print_symbol(sym_width, (char const   *)(dynamic_strings + psym___0->st_name));
              }
            } else {
              {
#line 12872
              tmp___85 = gettext("<corrupt: %14ld>");
#line 12872
              printf((char const   */* __restrict  */)tmp___85, psym___0->st_name);
              }
            }
          } else {
            {
#line 12872
            tmp___85 = gettext("<corrupt: %14ld>");
#line 12872
            printf((char const   */* __restrict  */)tmp___85, psym___0->st_name);
            }
          }
          {
#line 12873
          printf((char const   */* __restrict  */)"\n");
#line 12858
          i ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 12875
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 12878
      if (data) {
        {
#line 12879
        free((void *)data);
        }
      }
    }
  }
#line 12882
  if (mips_pltgot != 0UL) {
#line 12882
    if (jmprel != 0UL) {
#line 12882
      if (pltrel != 0UL) {
#line 12882
        if (pltrelsz != 0UL) {
          {
#line 12891
          tmp___86 = offset_from_vma(file, jmprel, pltrelsz);
#line 12891
          rel_offset = (size_t )tmp___86;
          }
#line 12892
          if (pltrel == 7UL) {
            {
#line 12894
            tmp___87 = slurp_rela_relocs(file, rel_offset, pltrelsz, & rels, & count);
            }
#line 12894
            if (! tmp___87) {
#line 12895
              return (0);
            }
          } else {
            {
#line 12899
            tmp___88 = slurp_rel_relocs(file, rel_offset, pltrelsz, & rels, & count);
            }
#line 12899
            if (! tmp___88) {
#line 12900
              return (0);
            }
          }
#line 12903
          ent___0 = mips_pltgot;
#line 12904
          if (is_32bit_elf) {
#line 12904
            addr_size___0 = 4;
          } else {
#line 12904
            addr_size___0 = 8;
          }
          {
#line 12905
          end = mips_pltgot + (2UL + count) * (unsigned long )addr_size___0;
#line 12907
          tmp___89 = offset_from_vma(file, mips_pltgot, end - mips_pltgot);
#line 12907
          offset___1 = (size_t )tmp___89;
#line 12908
          tmp___90 = gettext("Procedure Linkage Table data");
#line 12908
          tmp___91 = get_data((void *)0, file, (long )offset___1, end - mips_pltgot,
                              (size_t )1, (char const   *)tmp___90);
#line 12908
          data___0 = (unsigned char *)tmp___91;
          }
#line 12910
          if ((unsigned long )data___0 == (unsigned long )((void *)0)) {
#line 12911
            return (0);
          }
          {
#line 12913
          printf((char const   */* __restrict  */)"\nPLT GOT:\n\n");
#line 12914
          tmp___92 = gettext(" Reserved entries:\n");
#line 12914
          printf((char const   */* __restrict  */)tmp___92);
#line 12915
          tmp___93 = gettext("Initial");
#line 12915
          tmp___94 = gettext("Address");
#line 12915
          tmp___95 = gettext("  %*s %*s Purpose\n");
#line 12915
          printf((char const   */* __restrict  */)tmp___95, addr_size___0 * 2, tmp___94,
                 addr_size___0 * 2, tmp___93);
#line 12917
          ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12918
          tmp___96 = gettext(" PLT lazy resolver\n");
#line 12918
          printf((char const   */* __restrict  */)tmp___96);
#line 12919
          ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12920
          tmp___97 = gettext(" Module pointer\n");
#line 12920
          printf((char const   */* __restrict  */)tmp___97);
#line 12921
          printf((char const   */* __restrict  */)"\n");
#line 12923
          tmp___98 = gettext(" Entries:\n");
#line 12923
          printf((char const   */* __restrict  */)tmp___98);
#line 12924
          tmp___99 = gettext("Name");
#line 12924
          tmp___100 = gettext("Ndx");
#line 12924
          tmp___101 = gettext("Type");
#line 12924
          tmp___102 = gettext("Sym.Val.");
#line 12924
          tmp___103 = gettext("Initial");
#line 12924
          tmp___104 = gettext("Address");
#line 12924
          printf((char const   */* __restrict  */)"  %*s %*s %*s %-7s %3s %s\n", addr_size___0 * 2,
                 tmp___104, addr_size___0 * 2, tmp___103, addr_size___0 * 2, tmp___102,
                 tmp___101, tmp___100, tmp___99);
          }
#line 12928
          if (is_32bit_elf) {
#line 12928
            tmp___105 = 80;
          } else {
#line 12928
            tmp___105 = 160;
          }
#line 12928
          sym_width___0 = ((tmp___105 - 17) - addr_size___0 * 6) - 1;
#line 12929
          i___0 = 0UL;
          {
#line 12929
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 12929
            if (! (i___0 < count)) {
#line 12929
              goto while_break___11;
            }
            {
#line 12933
            tmp___106 = get_reloc_symindex((rels + i___0)->r_info);
#line 12933
            psym___1 = dynamic_symbols + tmp___106;
#line 12934
            ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12935
            printf((char const   */* __restrict  */)" ");
#line 12936
            print_vma(psym___1->st_value, (print_mode )6);
#line 12937
            tmp___107 = get_symbol_index_type(psym___1->st_shndx);
#line 12937
            tmp___108 = get_symbol_type((unsigned int )((int )psym___1->st_info & 15));
#line 12937
            printf((char const   */* __restrict  */)" %-7s %3s ", tmp___108, tmp___107);
            }
#line 12940
            if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12940
              if (psym___1->st_name < dynamic_strings_length) {
                {
#line 12941
                print_symbol(sym_width___0, (char const   *)(dynamic_strings + psym___1->st_name));
                }
              } else {
                {
#line 12943
                tmp___109 = gettext("<corrupt: %14ld>");
#line 12943
                printf((char const   */* __restrict  */)tmp___109, psym___1->st_name);
                }
              }
            } else {
              {
#line 12943
              tmp___109 = gettext("<corrupt: %14ld>");
#line 12943
              printf((char const   */* __restrict  */)tmp___109, psym___1->st_name);
              }
            }
            {
#line 12944
            printf((char const   */* __restrict  */)"\n");
#line 12929
            i___0 ++;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 12946
          printf((char const   */* __restrict  */)"\n");
          }
#line 12948
          if (data___0) {
            {
#line 12949
            free((void *)data___0);
            }
          }
          {
#line 12950
          free((void *)rels);
          }
        }
      }
    }
  }
#line 12953
  return (1);
}
}
#line 12956 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_gnu_liblist(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  Elf_Internal_Shdr *string_sec ;
  Elf32_External_Lib *elib ;
  char *strtab ;
  size_t strtab_size ;
  size_t cnt ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  Elf32_Lib liblist ;
  time_t atime ;
  char timebuf[20] ;
  struct tm *tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  elf_vma tmp___15 ;
  elf_vma tmp___16 ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 12967
  if (! do_arch) {
#line 12968
    return (0);
  }
#line 12970
  i = 0U;
#line 12970
  section = section_headers;
  {
#line 12970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12970
    if (! (i < elf_header.e_shnum)) {
#line 12970
      goto while_break;
    }
    {
#line 12976
    if (section->sh_type == 1879048183U) {
#line 12976
      goto case_1879048183;
    }
#line 12974
    goto switch_break;
    case_1879048183: /* CIL Label */ 
#line 12977
    if (section->sh_link >= elf_header.e_shnum) {
#line 12978
      goto switch_break;
    }
    {
#line 12980
    tmp___0 = gettext("liblist section data");
#line 12980
    tmp___1 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                       (char const   *)tmp___0);
#line 12980
    elib = (Elf32_External_Lib *)tmp___1;
    }
#line 12984
    if ((unsigned long )elib == (unsigned long )((void *)0)) {
#line 12985
      goto switch_break;
    }
    {
#line 12986
    string_sec = section_headers + section->sh_link;
#line 12988
    tmp___2 = gettext("liblist string table");
#line 12988
    tmp___3 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1, string_sec->sh_size,
                       (char const   *)tmp___2);
#line 12988
    strtab = (char *)tmp___3;
    }
#line 12991
    if ((unsigned long )strtab == (unsigned long )((void *)0)) {
      {
#line 12994
      free((void *)elib);
#line 12995
      free((void *)strtab);
      }
#line 12996
      goto switch_break;
    } else
#line 12991
    if (section->sh_entsize != sizeof(Elf32_External_Lib )) {
      {
#line 12994
      free((void *)elib);
#line 12995
      free((void *)strtab);
      }
#line 12996
      goto switch_break;
    }
#line 12998
    strtab_size = string_sec->sh_size;
#line 13000
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 13000
      tmp___4 = gettext("<none>");
#line 13000
      tmp___9 = tmp___4;
      }
    } else {
#line 13000
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 13000
        tmp___5 = gettext("<no-name>");
#line 13000
        tmp___8 = tmp___5;
        }
      } else {
#line 13000
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 13000
          tmp___6 = gettext("<corrupt>");
#line 13000
          tmp___7 = tmp___6;
          }
        } else {
#line 13000
          tmp___7 = string_table + section->sh_name;
        }
#line 13000
        tmp___8 = tmp___7;
      }
#line 13000
      tmp___9 = tmp___8;
    }
    {
#line 13000
    tmp___10 = gettext("\nLibrary list section \'%s\' contains %lu entries:\n");
#line 13000
    printf((char const   */* __restrict  */)tmp___10, tmp___9, section->sh_size / sizeof(Elf32_External_Lib ));
#line 13004
    tmp___11 = gettext("     Library              Time Stamp          Checksum   Version Flags");
#line 13004
    puts((char const   *)tmp___11);
#line 13006
    cnt = (size_t )0;
    }
    {
#line 13006
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 13006
      if (! (cnt < section->sh_size / sizeof(Elf32_External_Lib ))) {
#line 13006
        goto while_break___0;
      }
      {
#line 13014
      tmp___13 = (*byte_get)((elib + cnt)->l_name, (int )sizeof((elib + cnt)->l_name));
#line 13014
      liblist.l_name = (unsigned long )tmp___13;
#line 13015
      tmp___14 = (*byte_get)((elib + cnt)->l_time_stamp, (int )sizeof((elib + cnt)->l_time_stamp));
#line 13015
      atime = (time_t )tmp___14;
#line 13016
      tmp___15 = (*byte_get)((elib + cnt)->l_checksum, (int )sizeof((elib + cnt)->l_checksum));
#line 13016
      liblist.l_checksum = (unsigned long )tmp___15;
#line 13017
      tmp___16 = (*byte_get)((elib + cnt)->l_version, (int )sizeof((elib + cnt)->l_version));
#line 13017
      liblist.l_version = (unsigned long )tmp___16;
#line 13018
      tmp___17 = (*byte_get)((elib + cnt)->l_flags, (int )sizeof((elib + cnt)->l_flags));
#line 13018
      liblist.l_flags = (unsigned long )tmp___17;
#line 13020
      tmp___12 = gmtime((time_t const   *)(& atime));
#line 13021
      snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
               tmp___12->tm_year + 1900, tmp___12->tm_mon + 1, tmp___12->tm_mday,
               tmp___12->tm_hour, tmp___12->tm_min, tmp___12->tm_sec);
#line 13026
      printf((char const   */* __restrict  */)"%3lu: ", cnt);
      }
#line 13027
      if (do_wide) {
#line 13028
        if (liblist.l_name < strtab_size) {
#line 13028
          tmp___19 = strtab + liblist.l_name;
        } else {
          {
#line 13028
          tmp___18 = gettext("<corrupt>");
#line 13028
          tmp___19 = tmp___18;
          }
        }
        {
#line 13028
        printf((char const   */* __restrict  */)"%-20s", tmp___19);
        }
      } else {
#line 13031
        if (liblist.l_name < strtab_size) {
#line 13031
          tmp___21 = strtab + liblist.l_name;
        } else {
          {
#line 13031
          tmp___20 = gettext("<corrupt>");
#line 13031
          tmp___21 = tmp___20;
          }
        }
        {
#line 13031
        printf((char const   */* __restrict  */)"%-20.20s", tmp___21);
        }
      }
      {
#line 13033
      printf((char const   */* __restrict  */)" %s %#010lx %-7ld %-7ld\n", timebuf,
             liblist.l_checksum, liblist.l_version, liblist.l_flags);
#line 13006
      cnt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 13037
    free((void *)elib);
#line 13038
    free((void *)strtab);
    }
    switch_break: /* CIL Label */ ;
    }
#line 12970
    i ++;
#line 12970
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13042
  return (1);
}
}
#line 13048 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___14[64]  ;
#line 13045 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
#line 13050
  if ((int )elf_header.e_type == 4) {
    {
#line 13053
    if (e_type == 6U) {
#line 13053
      goto case_6;
    }
#line 13055
    if (e_type == 1U) {
#line 13055
      goto case_1;
    }
#line 13057
    if (e_type == 2U) {
#line 13057
      goto case_2;
    }
#line 13059
    if (e_type == 3U) {
#line 13059
      goto case_3;
    }
#line 13061
    if (e_type == 4U) {
#line 13061
      goto case_4;
    }
#line 13063
    if (e_type == 1189489535U) {
#line 13063
      goto case_1189489535;
    }
#line 13065
    if (e_type == 256U) {
#line 13065
      goto case_256;
    }
#line 13067
    if (e_type == 258U) {
#line 13067
      goto case_258;
    }
#line 13069
    if (e_type == 512U) {
#line 13069
      goto case_512;
    }
#line 13071
    if (e_type == 513U) {
#line 13071
      goto case_513;
    }
#line 13073
    if (e_type == 514U) {
#line 13073
      goto case_514;
    }
#line 13075
    if (e_type == 768U) {
#line 13075
      goto case_768;
    }
#line 13077
    if (e_type == 769U) {
#line 13077
      goto case_769;
    }
#line 13079
    if (e_type == 770U) {
#line 13079
      goto case_770;
    }
#line 13081
    if (e_type == 771U) {
#line 13081
      goto case_771;
    }
#line 13083
    if (e_type == 772U) {
#line 13083
      goto case_772;
    }
#line 13085
    if (e_type == 773U) {
#line 13085
      goto case_773;
    }
#line 13087
    if (e_type == 774U) {
#line 13087
      goto case_774;
    }
#line 13089
    if (e_type == 775U) {
#line 13089
      goto case_775;
    }
#line 13091
    if (e_type == 776U) {
#line 13091
      goto case_776;
    }
#line 13093
    if (e_type == 1024U) {
#line 13093
      goto case_1024;
    }
#line 13095
    if (e_type == 1025U) {
#line 13095
      goto case_1025;
    }
#line 13097
    if (e_type == 1026U) {
#line 13097
      goto case_1026;
    }
#line 13099
    if (e_type == 1027U) {
#line 13099
      goto case_1027;
    }
#line 13101
    if (e_type == 10U) {
#line 13101
      goto case_10;
    }
#line 13103
    if (e_type == 12U) {
#line 13103
      goto case_12;
    }
#line 13105
    if (e_type == 13U) {
#line 13105
      goto case_13;
    }
#line 13107
    if (e_type == 16U) {
#line 13107
      goto case_16;
    }
#line 13109
    if (e_type == 17U) {
#line 13109
      goto case_17;
    }
#line 13111
    if (e_type == 18U) {
#line 13111
      goto case_18;
    }
#line 13113
    if (e_type == 1397311305U) {
#line 13113
      goto case_1397311305;
    }
#line 13115
    if (e_type == 1179208773U) {
#line 13115
      goto case_1179208773;
    }
#line 13117
    goto switch_default;
    case_6: /* CIL Label */ 
    {
#line 13054
    tmp___0 = gettext("NT_AUXV (auxiliary vector)");
    }
#line 13054
    return ((char const   *)tmp___0);
    case_1: /* CIL Label */ 
    {
#line 13056
    tmp___1 = gettext("NT_PRSTATUS (prstatus structure)");
    }
#line 13056
    return ((char const   *)tmp___1);
    case_2: /* CIL Label */ 
    {
#line 13058
    tmp___2 = gettext("NT_FPREGSET (floating point registers)");
    }
#line 13058
    return ((char const   *)tmp___2);
    case_3: /* CIL Label */ 
    {
#line 13060
    tmp___3 = gettext("NT_PRPSINFO (prpsinfo structure)");
    }
#line 13060
    return ((char const   *)tmp___3);
    case_4: /* CIL Label */ 
    {
#line 13062
    tmp___4 = gettext("NT_TASKSTRUCT (task structure)");
    }
#line 13062
    return ((char const   *)tmp___4);
    case_1189489535: /* CIL Label */ 
    {
#line 13064
    tmp___5 = gettext("NT_PRXFPREG (user_xfpregs structure)");
    }
#line 13064
    return ((char const   *)tmp___5);
    case_256: /* CIL Label */ 
    {
#line 13066
    tmp___6 = gettext("NT_PPC_VMX (ppc Altivec registers)");
    }
#line 13066
    return ((char const   *)tmp___6);
    case_258: /* CIL Label */ 
    {
#line 13068
    tmp___7 = gettext("NT_PPC_VSX (ppc VSX registers)");
    }
#line 13068
    return ((char const   *)tmp___7);
    case_512: /* CIL Label */ 
    {
#line 13070
    tmp___8 = gettext("NT_386_TLS (x86 TLS information)");
    }
#line 13070
    return ((char const   *)tmp___8);
    case_513: /* CIL Label */ 
    {
#line 13072
    tmp___9 = gettext("NT_386_IOPERM (x86 I/O permissions)");
    }
#line 13072
    return ((char const   *)tmp___9);
    case_514: /* CIL Label */ 
    {
#line 13074
    tmp___10 = gettext("NT_X86_XSTATE (x86 XSAVE extended state)");
    }
#line 13074
    return ((char const   *)tmp___10);
    case_768: /* CIL Label */ 
    {
#line 13076
    tmp___11 = gettext("NT_S390_HIGH_GPRS (s390 upper register halves)");
    }
#line 13076
    return ((char const   *)tmp___11);
    case_769: /* CIL Label */ 
    {
#line 13078
    tmp___12 = gettext("NT_S390_TIMER (s390 timer register)");
    }
#line 13078
    return ((char const   *)tmp___12);
    case_770: /* CIL Label */ 
    {
#line 13080
    tmp___13 = gettext("NT_S390_TODCMP (s390 TOD comparator register)");
    }
#line 13080
    return ((char const   *)tmp___13);
    case_771: /* CIL Label */ 
    {
#line 13082
    tmp___14 = gettext("NT_S390_TODPREG (s390 TOD programmable register)");
    }
#line 13082
    return ((char const   *)tmp___14);
    case_772: /* CIL Label */ 
    {
#line 13084
    tmp___15 = gettext("NT_S390_CTRS (s390 control registers)");
    }
#line 13084
    return ((char const   *)tmp___15);
    case_773: /* CIL Label */ 
    {
#line 13086
    tmp___16 = gettext("NT_S390_PREFIX (s390 prefix register)");
    }
#line 13086
    return ((char const   *)tmp___16);
    case_774: /* CIL Label */ 
    {
#line 13088
    tmp___17 = gettext("NT_S390_LAST_BREAK (s390 last breaking event address)");
    }
#line 13088
    return ((char const   *)tmp___17);
    case_775: /* CIL Label */ 
    {
#line 13090
    tmp___18 = gettext("NT_S390_SYSTEM_CALL (s390 system call restart data)");
    }
#line 13090
    return ((char const   *)tmp___18);
    case_776: /* CIL Label */ 
    {
#line 13092
    tmp___19 = gettext("NT_S390_TDB (s390 transaction diagnostic block)");
    }
#line 13092
    return ((char const   *)tmp___19);
    case_1024: /* CIL Label */ 
    {
#line 13094
    tmp___20 = gettext("NT_ARM_VFP (arm VFP registers)");
    }
#line 13094
    return ((char const   *)tmp___20);
    case_1025: /* CIL Label */ 
    {
#line 13096
    tmp___21 = gettext("NT_ARM_TLS (AArch TLS registers)");
    }
#line 13096
    return ((char const   *)tmp___21);
    case_1026: /* CIL Label */ 
    {
#line 13098
    tmp___22 = gettext("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
    }
#line 13098
    return ((char const   *)tmp___22);
    case_1027: /* CIL Label */ 
    {
#line 13100
    tmp___23 = gettext("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
    }
#line 13100
    return ((char const   *)tmp___23);
    case_10: /* CIL Label */ 
    {
#line 13102
    tmp___24 = gettext("NT_PSTATUS (pstatus structure)");
    }
#line 13102
    return ((char const   *)tmp___24);
    case_12: /* CIL Label */ 
    {
#line 13104
    tmp___25 = gettext("NT_FPREGS (floating point registers)");
    }
#line 13104
    return ((char const   *)tmp___25);
    case_13: /* CIL Label */ 
    {
#line 13106
    tmp___26 = gettext("NT_PSINFO (psinfo structure)");
    }
#line 13106
    return ((char const   *)tmp___26);
    case_16: /* CIL Label */ 
    {
#line 13108
    tmp___27 = gettext("NT_LWPSTATUS (lwpstatus_t structure)");
    }
#line 13108
    return ((char const   *)tmp___27);
    case_17: /* CIL Label */ 
    {
#line 13110
    tmp___28 = gettext("NT_LWPSINFO (lwpsinfo_t structure)");
    }
#line 13110
    return ((char const   *)tmp___28);
    case_18: /* CIL Label */ 
    {
#line 13112
    tmp___29 = gettext("NT_WIN32PSTATUS (win32_pstatus structure)");
    }
#line 13112
    return ((char const   *)tmp___29);
    case_1397311305: /* CIL Label */ 
    {
#line 13114
    tmp___30 = gettext("NT_SIGINFO (siginfo_t data)");
    }
#line 13114
    return ((char const   *)tmp___30);
    case_1179208773: /* CIL Label */ 
    {
#line 13116
    tmp___31 = gettext("NT_FILE (mapped files)");
    }
#line 13116
    return ((char const   *)tmp___31);
    switch_default: /* CIL Label */ 
#line 13118
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 13123
    if (e_type == 1U) {
#line 13123
      goto case_1___0;
    }
#line 13125
    if (e_type == 2U) {
#line 13125
      goto case_2___0;
    }
#line 13127
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 13124
    tmp___32 = gettext("NT_VERSION (version)");
    }
#line 13124
    return ((char const   *)tmp___32);
    case_2___0: /* CIL Label */ 
    {
#line 13126
    tmp___33 = gettext("NT_ARCH (architecture)");
    }
#line 13126
    return ((char const   *)tmp___33);
    switch_default___0: /* CIL Label */ 
#line 13128
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 13131
  tmp___34 = gettext("Unknown note type: (0x%08x)");
#line 13131
  snprintf((char */* __restrict  */)(buff___14), sizeof(buff___14), (char const   */* __restrict  */)tmp___34,
           e_type);
  }
#line 13132
  return ((char const   *)(buff___14));
}
}
#line 13135 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int print_core_note(Elf_Internal_Note *pnote ) 
{ 
  unsigned int addr_size ;
  int tmp___0 ;
  bfd_vma count ;
  bfd_vma page_size ;
  unsigned char *descdata ;
  unsigned char *filenames ;
  unsigned char *descend ;
  char *tmp___1 ;
  char *tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  bfd_vma start ;
  bfd_vma end ;
  bfd_vma file_ofs ;
  char *tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  size_t tmp___15 ;

  {
#line 13138
  if (is_32bit_elf) {
#line 13138
    tmp___0 = 4;
  } else {
#line 13138
    tmp___0 = 8;
  }
#line 13138
  addr_size = (unsigned int )tmp___0;
#line 13142
  if (pnote->type != 1179208773UL) {
#line 13143
    return (1);
  }
#line 13154
  if (pnote->descsz < (unsigned long )(2U * addr_size)) {
    {
#line 13156
    tmp___1 = gettext("    Malformed note - too short for header\n");
#line 13156
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 13157
    return (0);
  }
#line 13160
  descdata = (unsigned char *)pnote->descdata;
#line 13161
  descend = descdata + pnote->descsz;
#line 13163
  if ((int )*(descdata + (pnote->descsz - 1UL)) != 0) {
    {
#line 13165
    tmp___2 = gettext("    Malformed note - does not end with \\0\n");
#line 13165
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 13166
    return (0);
  }
  {
#line 13169
  tmp___3 = (*byte_get)(descdata, (int )addr_size);
#line 13169
  count = (bfd_vma )tmp___3;
#line 13170
  descdata += addr_size;
#line 13172
  tmp___4 = (*byte_get)(descdata, (int )addr_size);
#line 13172
  page_size = (bfd_vma )tmp___4;
#line 13173
  descdata += addr_size;
  }
#line 13175
  if (pnote->descsz < (bfd_vma )(2U * addr_size) + (count * 3UL) * (bfd_vma )addr_size) {
    {
#line 13177
    tmp___5 = gettext("    Malformed note - too short for supplied file count\n");
#line 13177
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 13178
    return (0);
  }
  {
#line 13181
  tmp___6 = gettext("    Page size: ");
#line 13181
  printf((char const   */* __restrict  */)tmp___6);
#line 13182
  print_vma(page_size, (print_mode )1);
#line 13183
  printf((char const   */* __restrict  */)"\n");
#line 13185
  tmp___7 = gettext("Page Offset");
#line 13185
  tmp___8 = gettext("End");
#line 13185
  tmp___9 = gettext("Start");
#line 13185
  tmp___10 = gettext("    %*s%*s%*s\n");
#line 13185
  printf((char const   */* __restrict  */)tmp___10, (int )(2U + 2U * addr_size), tmp___9,
         (int )(4U + 2U * addr_size), tmp___8, (int )(4U + 2U * addr_size), tmp___7);
#line 13189
  filenames = descdata + (count * 3UL) * (bfd_vma )addr_size;
  }
  {
#line 13190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13190
    count --;
#line 13190
    if (! (count > 0UL)) {
#line 13190
      goto while_break;
    }
#line 13194
    if ((unsigned long )filenames == (unsigned long )descend) {
      {
#line 13196
      tmp___11 = gettext("    Malformed note - filenames end too early\n");
#line 13196
      printf((char const   */* __restrict  */)tmp___11);
      }
#line 13197
      return (0);
    }
    {
#line 13200
    tmp___12 = (*byte_get)(descdata, (int )addr_size);
#line 13200
    start = (bfd_vma )tmp___12;
#line 13201
    descdata += addr_size;
#line 13202
    tmp___13 = (*byte_get)(descdata, (int )addr_size);
#line 13202
    end = (bfd_vma )tmp___13;
#line 13203
    descdata += addr_size;
#line 13204
    tmp___14 = (*byte_get)(descdata, (int )addr_size);
#line 13204
    file_ofs = (bfd_vma )tmp___14;
#line 13205
    descdata += addr_size;
#line 13207
    printf((char const   */* __restrict  */)"    ");
#line 13208
    print_vma(start, (print_mode )5);
#line 13209
    printf((char const   */* __restrict  */)"  ");
#line 13210
    print_vma(end, (print_mode )5);
#line 13211
    printf((char const   */* __restrict  */)"  ");
#line 13212
    print_vma(file_ofs, (print_mode )5);
#line 13213
    printf((char const   */* __restrict  */)"\n        %s\n", filenames);
#line 13215
    tmp___15 = strlen((char const   *)((char *)filenames));
#line 13215
    filenames += 1UL + tmp___15;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 13218
  return (1);
}
}
#line 13224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___15[64]  ;
#line 13221 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_gnu_elf_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 13228
  if (e_type == 1U) {
#line 13228
    goto case_1;
  }
#line 13230
  if (e_type == 2U) {
#line 13230
    goto case_2;
  }
#line 13232
  if (e_type == 3U) {
#line 13232
    goto case_3;
  }
#line 13234
  if (e_type == 4U) {
#line 13234
    goto case_4;
  }
#line 13236
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 13229
  tmp___0 = gettext("NT_GNU_ABI_TAG (ABI version tag)");
  }
#line 13229
  return ((char const   *)tmp___0);
  case_2: /* CIL Label */ 
  {
#line 13231
  tmp___1 = gettext("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
  }
#line 13231
  return ((char const   *)tmp___1);
  case_3: /* CIL Label */ 
  {
#line 13233
  tmp___2 = gettext("NT_GNU_BUILD_ID (unique build ID bitstring)");
  }
#line 13233
  return ((char const   *)tmp___2);
  case_4: /* CIL Label */ 
  {
#line 13235
  tmp___3 = gettext("NT_GNU_GOLD_VERSION (gold version)");
  }
#line 13235
  return ((char const   *)tmp___3);
  switch_default: /* CIL Label */ 
#line 13237
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 13240
  tmp___4 = gettext("Unknown note type: (0x%08x)");
#line 13240
  snprintf((char */* __restrict  */)(buff___15), sizeof(buff___15), (char const   */* __restrict  */)tmp___4,
           e_type);
  }
#line 13241
  return ((char const   *)(buff___15));
}
}
#line 13244 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int print_gnu_note(Elf_Internal_Note *pnote ) 
{ 
  unsigned long i ;
  char *tmp___0 ;
  unsigned long os ;
  unsigned long major ;
  unsigned long minor ;
  unsigned long subminor ;
  char const   *osname ;
  elf_vma tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 13249
  if (pnote->type == 3UL) {
#line 13249
    goto case_3;
  }
#line 13260
  if (pnote->type == 1UL) {
#line 13260
    goto case_1;
  }
#line 13247
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 13253
  tmp___0 = gettext("    Build ID: ");
#line 13253
  printf((char const   */* __restrict  */)tmp___0);
#line 13254
  i = 0UL;
  }
  {
#line 13254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13254
    if (! (i < pnote->descsz)) {
#line 13254
      goto while_break;
    }
    {
#line 13255
    printf((char const   */* __restrict  */)"%02x", (int )*(pnote->descdata + i) & 255);
#line 13254
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 13256
  printf((char const   */* __restrict  */)"\n");
  }
#line 13258
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 13265
  tmp___1 = (*byte_get)((unsigned char *)pnote->descdata, 4);
#line 13265
  os = (unsigned long )tmp___1;
#line 13266
  tmp___2 = (*byte_get)((unsigned char *)pnote->descdata + 4, 4);
#line 13266
  major = (unsigned long )tmp___2;
#line 13267
  tmp___3 = (*byte_get)((unsigned char *)pnote->descdata + 8, 4);
#line 13267
  minor = (unsigned long )tmp___3;
#line 13268
  tmp___4 = (*byte_get)((unsigned char *)pnote->descdata + 12, 4);
#line 13268
  subminor = (unsigned long )tmp___4;
  }
  {
#line 13272
  if (os == 0UL) {
#line 13272
    goto case_0;
  }
#line 13275
  if (os == 1UL) {
#line 13275
    goto case_1___0;
  }
#line 13278
  if (os == 2UL) {
#line 13278
    goto case_2;
  }
#line 13281
  if (os == 3UL) {
#line 13281
    goto case_3___0;
  }
#line 13284
  if (os == 4UL) {
#line 13284
    goto case_4;
  }
#line 13287
  goto switch_default;
  case_0: /* CIL Label */ 
#line 13273
  osname = "Linux";
#line 13274
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 13276
  osname = "Hurd";
#line 13277
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 13279
  osname = "Solaris";
#line 13280
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 13282
  osname = "FreeBSD";
#line 13283
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 13285
  osname = "NetBSD";
#line 13286
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 13288
  osname = "Unknown";
#line 13289
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 13292
  tmp___5 = gettext("    OS: %s, ABI: %ld.%ld.%ld\n");
#line 13292
  printf((char const   */* __restrict  */)tmp___5, osname, major, minor, subminor);
  }
#line 13295
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13298
  return (1);
}
}
#line 13304 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___16[64]  ;
#line 13301 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_netbsd_elfcore_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 13306
  if (e_type == 1U) {
    {
#line 13309
    tmp___0 = gettext("NetBSD procinfo structure");
    }
#line 13309
    return ((char const   *)tmp___0);
  }
#line 13317
  if (e_type < 32U) {
    {
#line 13319
    tmp___1 = gettext("Unknown note type: (0x%08x)");
#line 13319
    snprintf((char */* __restrict  */)(buff___16), sizeof(buff___16), (char const   */* __restrict  */)tmp___1,
             e_type);
    }
#line 13320
    return ((char const   *)(buff___16));
  }
  {
#line 13332
  if ((int )elf_header.e_machine == 43) {
#line 13332
    goto case_43;
  }
#line 13332
  if ((int )elf_header.e_machine == 18) {
#line 13332
    goto case_43;
  }
#line 13332
  if ((int )elf_header.e_machine == 2) {
#line 13332
    goto case_43;
  }
#line 13332
  if ((int )elf_header.e_machine == 36902) {
#line 13332
    goto case_43;
  }
#line 13332
  if ((int )elf_header.e_machine == 41) {
#line 13332
    goto case_43;
  }
#line 13346
  goto switch_default___0;
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_41: /* CIL Label */ 
  {
#line 13335
  if (e_type == 32U) {
#line 13335
    goto case_32;
  }
#line 13337
  if (e_type == 34U) {
#line 13337
    goto case_34;
  }
#line 13339
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 13336
  tmp___2 = gettext("PT_GETREGS (reg structure)");
  }
#line 13336
  return ((char const   *)tmp___2);
  case_34: /* CIL Label */ 
  {
#line 13338
  tmp___3 = gettext("PT_GETFPREGS (fpreg structure)");
  }
#line 13338
  return ((char const   *)tmp___3);
  switch_default: /* CIL Label */ 
#line 13340
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 13342
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 13349
  if (e_type == 33U) {
#line 13349
    goto case_33;
  }
#line 13351
  if (e_type == 35U) {
#line 13351
    goto case_35;
  }
#line 13353
  goto switch_default___1;
  case_33: /* CIL Label */ 
  {
#line 13350
  tmp___4 = gettext("PT_GETREGS (reg structure)");
  }
#line 13350
  return ((char const   *)tmp___4);
  case_35: /* CIL Label */ 
  {
#line 13352
  tmp___5 = gettext("PT_GETFPREGS (fpreg structure)");
  }
#line 13352
  return ((char const   *)tmp___5);
  switch_default___1: /* CIL Label */ 
#line 13354
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 13358
  snprintf((char */* __restrict  */)(buff___16), sizeof(buff___16), (char const   */* __restrict  */)"PT_FIRSTMACH+%d",
           e_type - 32U);
  }
#line 13360
  return ((char const   *)(buff___16));
}
}
#line 13366 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___17[64]  ;
#line 13363 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_stapsdt_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 13370
  if (e_type == 3U) {
#line 13370
    goto case_3;
  }
#line 13373
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 13371
  tmp___0 = gettext("NT_STAPSDT (SystemTap probe descriptors)");
  }
#line 13371
  return ((char const   *)tmp___0);
  switch_default: /* CIL Label */ 
#line 13374
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 13377
  tmp___1 = gettext("Unknown note type: (0x%08x)");
#line 13377
  snprintf((char */* __restrict  */)(buff___17), sizeof(buff___17), (char const   */* __restrict  */)tmp___1,
           e_type);
  }
#line 13378
  return ((char const   *)(buff___17));
}
}
#line 13381 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int print_stapsdt_note(Elf_Internal_Note *pnote ) 
{ 
  int addr_size ;
  int tmp___0 ;
  char *data ;
  char *data_end ;
  bfd_vma pc ;
  bfd_vma base_addr ;
  bfd_vma semaphore ;
  char *provider ;
  char *probe ;
  char *arg_fmt ;
  elf_vma tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 13384
  if (is_32bit_elf) {
#line 13384
    tmp___0 = 4;
  } else {
#line 13384
    tmp___0 = 8;
  }
  {
#line 13384
  addr_size = tmp___0;
#line 13385
  data = pnote->descdata;
#line 13386
  data_end = pnote->descdata + pnote->descsz;
#line 13390
  tmp___1 = (*byte_get)((unsigned char *)data, addr_size);
#line 13390
  pc = (bfd_vma )tmp___1;
#line 13391
  data += addr_size;
#line 13392
  tmp___2 = (*byte_get)((unsigned char *)data, addr_size);
#line 13392
  base_addr = (bfd_vma )tmp___2;
#line 13393
  data += addr_size;
#line 13394
  tmp___3 = (*byte_get)((unsigned char *)data, addr_size);
#line 13394
  semaphore = (bfd_vma )tmp___3;
#line 13395
  data += addr_size;
#line 13397
  provider = data;
#line 13398
  tmp___4 = strlen((char const   *)data);
#line 13398
  data += tmp___4 + 1UL;
#line 13399
  probe = data;
#line 13400
  tmp___5 = strlen((char const   *)data);
#line 13400
  data += tmp___5 + 1UL;
#line 13401
  arg_fmt = data;
#line 13402
  tmp___6 = strlen((char const   *)data);
#line 13402
  data += tmp___6 + 1UL;
#line 13404
  tmp___7 = gettext("    Provider: %s\n");
#line 13404
  printf((char const   */* __restrict  */)tmp___7, provider);
#line 13405
  tmp___8 = gettext("    Name: %s\n");
#line 13405
  printf((char const   */* __restrict  */)tmp___8, probe);
#line 13406
  tmp___9 = gettext("    Location: ");
#line 13406
  printf((char const   */* __restrict  */)tmp___9);
#line 13407
  print_vma(pc, (print_mode )5);
#line 13408
  tmp___10 = gettext(", Base: ");
#line 13408
  printf((char const   */* __restrict  */)tmp___10);
#line 13409
  print_vma(base_addr, (print_mode )5);
#line 13410
  tmp___11 = gettext(", Semaphore: ");
#line 13410
  printf((char const   */* __restrict  */)tmp___11);
#line 13411
  print_vma(semaphore, (print_mode )5);
#line 13412
  printf((char const   */* __restrict  */)"\n");
#line 13413
  tmp___12 = gettext("    Arguments: %s\n");
#line 13413
  printf((char const   */* __restrict  */)tmp___12, arg_fmt);
  }
#line 13415
  return ((unsigned long )data == (unsigned long )data_end);
}
}
#line 13421 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char buff___18[64]  ;
#line 13418 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static char const   *get_ia64_vms_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 13425
  if (e_type == 1U) {
#line 13425
    goto case_1;
  }
#line 13427
  if (e_type == 2U) {
#line 13427
    goto case_2;
  }
#line 13429
  if (e_type == 3U) {
#line 13429
    goto case_3;
  }
#line 13431
  if (e_type == 4U) {
#line 13431
    goto case_4;
  }
#line 13433
  if (e_type == 5U) {
#line 13433
    goto case_5;
  }
#line 13435
  if (e_type == 6U) {
#line 13435
    goto case_6;
  }
#line 13437
  if (e_type == 101U) {
#line 13437
    goto case_101;
  }
#line 13439
  if (e_type == 102U) {
#line 13439
    goto case_102;
  }
#line 13441
  if (e_type == 103U) {
#line 13441
    goto case_103;
  }
#line 13443
  if (e_type == 104U) {
#line 13443
    goto case_104;
  }
#line 13445
  if (e_type == 105U) {
#line 13445
    goto case_105;
  }
#line 13447
  if (e_type == 106U) {
#line 13447
    goto case_106;
  }
#line 13449
  if (e_type == 107U) {
#line 13449
    goto case_107;
  }
#line 13451
  if (e_type == 108U) {
#line 13451
    goto case_108;
  }
#line 13453
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 13426
  tmp___0 = gettext("NT_VMS_MHD (module header)");
  }
#line 13426
  return ((char const   *)tmp___0);
  case_2: /* CIL Label */ 
  {
#line 13428
  tmp___1 = gettext("NT_VMS_LNM (language name)");
  }
#line 13428
  return ((char const   *)tmp___1);
  case_3: /* CIL Label */ 
  {
#line 13430
  tmp___2 = gettext("NT_VMS_SRC (source files)");
  }
#line 13430
  return ((char const   *)tmp___2);
  case_4: /* CIL Label */ 
#line 13432
  return ("NT_VMS_TITLE");
  case_5: /* CIL Label */ 
  {
#line 13434
  tmp___3 = gettext("NT_VMS_EIDC (consistency check)");
  }
#line 13434
  return ((char const   *)tmp___3);
  case_6: /* CIL Label */ 
  {
#line 13436
  tmp___4 = gettext("NT_VMS_FPMODE (FP mode)");
  }
#line 13436
  return ((char const   *)tmp___4);
  case_101: /* CIL Label */ 
#line 13438
  return ("NT_VMS_LINKTIME");
  case_102: /* CIL Label */ 
  {
#line 13440
  tmp___5 = gettext("NT_VMS_IMGNAM (image name)");
  }
#line 13440
  return ((char const   *)tmp___5);
  case_103: /* CIL Label */ 
  {
#line 13442
  tmp___6 = gettext("NT_VMS_IMGID (image id)");
  }
#line 13442
  return ((char const   *)tmp___6);
  case_104: /* CIL Label */ 
  {
#line 13444
  tmp___7 = gettext("NT_VMS_LINKID (link id)");
  }
#line 13444
  return ((char const   *)tmp___7);
  case_105: /* CIL Label */ 
  {
#line 13446
  tmp___8 = gettext("NT_VMS_IMGBID (build id)");
  }
#line 13446
  return ((char const   *)tmp___8);
  case_106: /* CIL Label */ 
  {
#line 13448
  tmp___9 = gettext("NT_VMS_GSTNAM (sym table name)");
  }
#line 13448
  return ((char const   *)tmp___9);
  case_107: /* CIL Label */ 
#line 13450
  return ("NT_VMS_ORIG_DYN");
  case_108: /* CIL Label */ 
#line 13452
  return ("NT_VMS_PATCHTIME");
  switch_default: /* CIL Label */ 
  {
#line 13454
  tmp___10 = gettext("Unknown note type: (0x%08x)");
#line 13454
  snprintf((char */* __restrict  */)(buff___18), sizeof(buff___18), (char const   */* __restrict  */)tmp___10,
           e_type);
  }
#line 13455
  return ((char const   *)(buff___18));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 13459 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int print_ia64_vms_note(Elf_Internal_Note *pnote ) 
{ 
  size_t l ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  char *tmp___9 ;
  elf_vma tmp___10 ;
  char *tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 13464
  if (pnote->type == 1UL) {
#line 13464
    goto case_1;
  }
#line 13476
  if (pnote->type == 2UL) {
#line 13476
    goto case_2;
  }
#line 13480
  if (pnote->type == 6UL) {
#line 13480
    goto case_6;
  }
#line 13485
  if (pnote->type == 101UL) {
#line 13485
    goto case_101;
  }
#line 13491
  if (pnote->type == 108UL) {
#line 13491
    goto case_108;
  }
#line 13497
  if (pnote->type == 107UL) {
#line 13497
    goto case_107;
  }
#line 13512
  if (pnote->type == 102UL) {
#line 13512
    goto case_102;
  }
#line 13515
  if (pnote->type == 106UL) {
#line 13515
    goto case_106;
  }
#line 13518
  if (pnote->type == 103UL) {
#line 13518
    goto case_103;
  }
#line 13521
  if (pnote->type == 104UL) {
#line 13521
    goto case_104;
  }
#line 13524
  goto switch_default;
  case_1: /* CIL Label */ 
#line 13465
  if (pnote->descsz > 36UL) {
    {
#line 13467
    tmp___0 = strlen((char const   *)(pnote->descdata + 34));
#line 13467
    l = tmp___0;
#line 13468
    tmp___1 = gettext("    Creation date  : %.17s\n");
#line 13468
    printf((char const   */* __restrict  */)tmp___1, pnote->descdata);
#line 13469
    tmp___2 = gettext("    Last patch date: %.17s\n");
#line 13469
    printf((char const   */* __restrict  */)tmp___2, pnote->descdata + 17);
#line 13470
    tmp___3 = gettext("    Module name    : %s\n");
#line 13470
    printf((char const   */* __restrict  */)tmp___3, pnote->descdata + 34);
#line 13471
    tmp___4 = gettext("    Module version : %s\n");
#line 13471
    printf((char const   */* __restrict  */)tmp___4, ((pnote->descdata + 34) + l) + 1);
    }
  } else {
    {
#line 13474
    tmp___5 = gettext("    Invalid size\n");
#line 13474
    printf((char const   */* __restrict  */)tmp___5);
    }
  }
#line 13475
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 13477
  tmp___6 = gettext("   Language: %s\n");
#line 13477
  printf((char const   */* __restrict  */)tmp___6, pnote->descdata);
  }
#line 13478
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 13481
  tmp___7 = gettext("   Floating Point mode: ");
#line 13481
  printf((char const   */* __restrict  */)tmp___7);
#line 13482
  tmp___8 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 13482
  printf((char const   */* __restrict  */)"0x%016lx\n", (bfd_vma )tmp___8);
  }
#line 13484
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 13486
  tmp___9 = gettext("   Link time: ");
#line 13486
  printf((char const   */* __restrict  */)tmp___9);
#line 13487
  tmp___10 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 13487
  print_vms_time((bfd_int64_t )tmp___10);
#line 13489
  printf((char const   */* __restrict  */)"\n");
  }
#line 13490
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 13492
  tmp___11 = gettext("   Patch time: ");
#line 13492
  printf((char const   */* __restrict  */)tmp___11);
#line 13493
  tmp___12 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 13493
  print_vms_time((bfd_int64_t )tmp___12);
#line 13495
  printf((char const   */* __restrict  */)"\n");
  }
#line 13496
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 13498
  tmp___13 = (*byte_get)((unsigned char *)pnote->descdata + 4, 4);
#line 13498
  tmp___14 = (*byte_get)((unsigned char *)pnote->descdata, 4);
#line 13498
  tmp___15 = gettext("   Major id: %u,  minor id: %u\n");
#line 13498
  printf((char const   */* __restrict  */)tmp___15, (unsigned int )tmp___14, (unsigned int )tmp___13);
#line 13501
  tmp___16 = gettext("   Last modified  : ");
#line 13501
  printf((char const   */* __restrict  */)tmp___16);
#line 13502
  tmp___17 = (*byte_get)((unsigned char *)pnote->descdata + 8, 8);
#line 13502
  print_vms_time((bfd_int64_t )tmp___17);
#line 13504
  tmp___18 = gettext("\n   Link flags  : ");
#line 13504
  printf((char const   */* __restrict  */)tmp___18);
#line 13505
  tmp___19 = (*byte_get)((unsigned char *)pnote->descdata + 16, 8);
#line 13505
  printf((char const   */* __restrict  */)"0x%016lx\n", (bfd_vma )tmp___19);
#line 13507
  tmp___20 = (*byte_get)((unsigned char *)pnote->descdata + 24, 4);
#line 13507
  tmp___21 = gettext("   Header flags: 0x%08x\n");
#line 13507
  printf((char const   */* __restrict  */)tmp___21, (unsigned int )tmp___20);
#line 13509
  tmp___22 = gettext("   Image id    : %s\n");
#line 13509
  printf((char const   */* __restrict  */)tmp___22, pnote->descdata + 32);
  }
#line 13510
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 13513
  tmp___23 = gettext("    Image name: %s\n");
#line 13513
  printf((char const   */* __restrict  */)tmp___23, pnote->descdata);
  }
#line 13514
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 13516
  tmp___24 = gettext("    Global symbol table name: %s\n");
#line 13516
  printf((char const   */* __restrict  */)tmp___24, pnote->descdata);
  }
#line 13517
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 13519
  tmp___25 = gettext("    Image id: %s\n");
#line 13519
  printf((char const   */* __restrict  */)tmp___25, pnote->descdata);
  }
#line 13520
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 13522
  tmp___26 = gettext("    Linker id: %s\n");
#line 13522
  printf((char const   */* __restrict  */)tmp___26, pnote->descdata);
  }
#line 13523
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 13525
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13527
  return (1);
}
}
#line 13535 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_note(Elf_Internal_Note *pnote ) 
{ 
  char const   *name___0 ;
  char const   *tmp___0 ;
  char const   *nt ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 13538
  if (pnote->namesz) {
#line 13538
    tmp___0 = (char const   *)pnote->namedata;
  } else {
#line 13538
    tmp___0 = "(NONE)";
  }
#line 13538
  name___0 = tmp___0;
#line 13541
  if (pnote->namesz == 0UL) {
    {
#line 13544
    nt = get_note_type((unsigned int )pnote->type);
    }
  } else {
    {
#line 13546
    tmp___5 = strncmp((char const   *)pnote->namedata, "GNU", sizeof("GNU") - 1UL);
    }
#line 13546
    if (tmp___5 == 0) {
      {
#line 13548
      nt = get_gnu_elf_note_type((unsigned int )pnote->type);
      }
    } else {
      {
#line 13550
      tmp___4 = strncmp((char const   *)pnote->namedata, "NetBSD-CORE", sizeof("NetBSD-CORE") - 1UL);
      }
#line 13550
      if (tmp___4 == 0) {
        {
#line 13552
        nt = get_netbsd_elfcore_note_type((unsigned int )pnote->type);
        }
      } else {
        {
#line 13554
        tmp___3 = strncmp((char const   *)pnote->namedata, "SPU/", (size_t )4);
        }
#line 13554
        if (tmp___3 == 0) {
#line 13557
          nt = (char const   *)(pnote->namedata + 4);
#line 13558
          name___0 = "SPU";
        } else {
          {
#line 13561
          tmp___2 = strncmp((char const   *)pnote->namedata, "IPF/VMS", sizeof("IPF/VMS") - 1UL);
          }
#line 13561
          if (tmp___2 == 0) {
            {
#line 13563
            nt = get_ia64_vms_note_type((unsigned int )pnote->type);
            }
          } else {
            {
#line 13565
            tmp___1 = strncmp((char const   *)pnote->namedata, "stapsdt", sizeof("stapsdt") - 1UL);
            }
#line 13565
            if (tmp___1 == 0) {
              {
#line 13566
              nt = get_stapsdt_note_type((unsigned int )pnote->type);
              }
            } else {
              {
#line 13571
              nt = get_note_type((unsigned int )pnote->type);
              }
            }
          }
        }
      }
    }
  }
  {
#line 13573
  printf((char const   */* __restrict  */)"  %-20s 0x%08lx\t%s\n", name___0, pnote->descsz,
         nt);
#line 13575
  tmp___13 = strncmp((char const   *)pnote->namedata, "IPF/VMS", sizeof("IPF/VMS") - 1UL);
  }
#line 13575
  if (tmp___13 == 0) {
    {
#line 13576
    tmp___6 = print_ia64_vms_note(pnote);
    }
#line 13576
    return (tmp___6);
  } else {
    {
#line 13577
    tmp___12 = strncmp((char const   *)pnote->namedata, "GNU", sizeof("GNU") - 1UL);
    }
#line 13577
    if (tmp___12 == 0) {
      {
#line 13578
      tmp___7 = print_gnu_note(pnote);
      }
#line 13578
      return (tmp___7);
    } else {
      {
#line 13579
      tmp___11 = strncmp((char const   *)pnote->namedata, "stapsdt", sizeof("stapsdt") - 1UL);
      }
#line 13579
      if (tmp___11 == 0) {
        {
#line 13580
        tmp___8 = print_stapsdt_note(pnote);
        }
#line 13580
        return (tmp___8);
      } else {
        {
#line 13581
        tmp___10 = strncmp((char const   *)pnote->namedata, "CORE", sizeof("CORE") - 1UL);
        }
#line 13581
        if (tmp___10 == 0) {
          {
#line 13582
          tmp___9 = print_core_note(pnote);
          }
#line 13582
          return (tmp___9);
        } else {
#line 13584
          return (1);
        }
      }
    }
  }
}
}
#line 13588 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_corefile_note_segment(FILE *file , bfd_vma offset , bfd_vma length ) 
{ 
  Elf_External_Note *pnotes ;
  Elf_External_Note *external ;
  int res___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Elf_Internal_Note inote ;
  size_t min_notesz ;
  char *next ;
  char *temp ;
  size_t data_remaining ;
  char *tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  Elf64_External_VMS_Note *vms_external ;
  char *tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 13593
  res___0 = 1;
#line 13595
  if (length <= 0UL) {
#line 13596
    return (0);
  }
  {
#line 13598
  tmp___0 = gettext("notes");
#line 13598
  tmp___1 = get_data((void *)0, file, (long )offset, (size_t )1, length, (char const   *)tmp___0);
#line 13598
  pnotes = (Elf_External_Note *)tmp___1;
  }
#line 13600
  if ((unsigned long )pnotes == (unsigned long )((void *)0)) {
#line 13601
    return (0);
  }
  {
#line 13603
  external = pnotes;
#line 13605
  tmp___2 = gettext("\nDisplaying notes found at file offset 0x%08lx with length 0x%08lx:\n");
#line 13605
  printf((char const   */* __restrict  */)tmp___2, offset, length);
#line 13607
  tmp___3 = gettext("Data size");
#line 13607
  tmp___4 = gettext("Owner");
#line 13607
  tmp___5 = gettext("  %-20s %10s\tDescription\n");
#line 13607
  printf((char const   */* __restrict  */)tmp___5, tmp___4, tmp___3);
  }
  {
#line 13609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13609
    if (! ((unsigned long )((char *)external) < (unsigned long )((char *)pnotes + length))) {
#line 13609
      goto while_break;
    }
    {
#line 13614
    temp = (char *)((void *)0);
#line 13615
    data_remaining = (size_t )(((char *)pnotes + length) - (char *)external);
#line 13617
    tmp___14 = is_ia64_vms();
    }
#line 13617
    if (tmp___14) {
#line 13642
      min_notesz = (unsigned long )(& ((Elf64_External_VMS_Note *)0)->name);
#line 13643
      if (data_remaining < min_notesz) {
        {
#line 13645
        tmp___10 = gettext("Corrupt note: only %d bytes remain, not enough for a full note\n");
#line 13645
        warn((char const   *)tmp___10, (int )data_remaining);
        }
#line 13647
        goto while_break;
      }
      {
#line 13650
      vms_external = (Elf64_External_VMS_Note *)external;
#line 13651
      tmp___11 = (*byte_get)(vms_external->type, (int )sizeof(vms_external->type));
#line 13651
      inote.type = (unsigned long )tmp___11;
#line 13652
      tmp___12 = (*byte_get)(vms_external->namesz, (int )sizeof(vms_external->namesz));
#line 13652
      inote.namesz = (unsigned long )tmp___12;
#line 13653
      inote.namedata = vms_external->name;
#line 13654
      tmp___13 = (*byte_get)(vms_external->descsz, (int )sizeof(vms_external->descsz));
#line 13654
      inote.descsz = (unsigned long )tmp___13;
#line 13655
      inote.descdata = inote.namedata + (((inote.namesz + (1UL << 3)) - 1UL) & (0xffffffffffffffffUL << 3));
#line 13656
      inote.descpos = offset + (bfd_vma )(inote.descdata - (char *)pnotes);
#line 13657
      next = inote.descdata + (((inote.descsz + (1UL << 3)) - 1UL) & (0xffffffffffffffffUL << 3));
      }
    } else {
#line 13621
      min_notesz = (unsigned long )(& ((Elf_External_Note *)0)->name);
#line 13622
      if (data_remaining < min_notesz) {
        {
#line 13624
        tmp___6 = gettext("Corrupt note: only %d bytes remain, not enough for a full note\n");
#line 13624
        warn((char const   *)tmp___6, (int )data_remaining);
        }
#line 13626
        goto while_break;
      }
      {
#line 13628
      tmp___7 = (*byte_get)(external->type, (int )sizeof(external->type));
#line 13628
      inote.type = (unsigned long )tmp___7;
#line 13629
      tmp___8 = (*byte_get)(external->namesz, (int )sizeof(external->namesz));
#line 13629
      inote.namesz = (unsigned long )tmp___8;
#line 13630
      inote.namedata = external->name;
#line 13631
      tmp___9 = (*byte_get)(external->descsz, (int )sizeof(external->descsz));
#line 13631
      inote.descsz = (unsigned long )tmp___9;
#line 13632
      inote.descdata = inote.namedata + (((inote.namesz + (1UL << 2)) - 1UL) & (0xffffffffffffffffUL << 2));
#line 13633
      inote.descpos = offset + (bfd_vma )(inote.descdata - (char *)pnotes);
#line 13634
      next = inote.descdata + (((inote.descsz + (1UL << 2)) - 1UL) & (0xffffffffffffffffUL << 2));
      }
    }
#line 13660
    if ((unsigned long )inote.descdata < (unsigned long )((char *)external + min_notesz)) {
      {
#line 13664
      tmp___15 = gettext("note with invalid namesz and/or descsz found at offset 0x%lx\n");
#line 13664
      warn((char const   *)tmp___15, (unsigned long )((char *)external - (char *)pnotes));
#line 13666
      tmp___16 = gettext(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n");
#line 13666
      warn((char const   *)tmp___16, inote.type, inote.namesz, inote.descsz);
      }
#line 13668
      goto while_break;
    } else
#line 13660
    if ((unsigned long )next < (unsigned long )((char *)external + min_notesz)) {
      {
#line 13664
      tmp___15 = gettext("note with invalid namesz and/or descsz found at offset 0x%lx\n");
#line 13664
      warn((char const   *)tmp___15, (unsigned long )((char *)external - (char *)pnotes));
#line 13666
      tmp___16 = gettext(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n");
#line 13666
      warn((char const   *)tmp___16, inote.type, inote.namesz, inote.descsz);
      }
#line 13668
      goto while_break;
    } else
#line 13660
    if (data_remaining < (size_t )(next - (char *)external)) {
      {
#line 13664
      tmp___15 = gettext("note with invalid namesz and/or descsz found at offset 0x%lx\n");
#line 13664
      warn((char const   *)tmp___15, (unsigned long )((char *)external - (char *)pnotes));
#line 13666
      tmp___16 = gettext(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n");
#line 13666
      warn((char const   *)tmp___16, inote.type, inote.namesz, inote.descsz);
      }
#line 13668
      goto while_break;
    }
#line 13671
    external = (Elf_External_Note *)next;
#line 13677
    if ((int )*(inote.namedata + (inote.namesz - 1UL)) != 0) {
      {
#line 13679
      tmp___17 = malloc(inote.namesz + 1UL);
#line 13679
      temp = (char *)tmp___17;
      }
#line 13681
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 13683
        tmp___18 = gettext("Out of memory\n");
#line 13683
        error((char const   *)tmp___18);
#line 13684
        res___0 = 0;
        }
#line 13685
        goto while_break;
      }
      {
#line 13688
      strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)inote.namedata,
              inote.namesz);
#line 13689
      *(temp + inote.namesz) = (char)0;
#line 13692
      inote.namedata = temp;
      }
    }
    {
#line 13695
    tmp___19 = process_note(& inote);
#line 13695
    res___0 &= tmp___19;
    }
#line 13697
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
      {
#line 13699
      free((void *)temp);
#line 13700
      temp = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 13704
  free((void *)pnotes);
  }
#line 13706
  return (res___0);
}
}
#line 13709 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_corefile_note_segments(FILE *file ) 
{ 
  Elf_Internal_Phdr *segment ;
  unsigned int i ;
  int res___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 13714
  res___0 = 1;
#line 13716
  tmp___0 = get_program_headers(file);
  }
#line 13716
  if (! tmp___0) {
#line 13717
    return (0);
  }
#line 13719
  i = 0U;
#line 13719
  segment = program_headers;
  {
#line 13719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13719
    if (! (i < elf_header.e_phnum)) {
#line 13719
      goto while_break;
    }
#line 13723
    if (segment->p_type == 4UL) {
      {
#line 13724
      tmp___1 = process_corefile_note_segment(file, segment->p_offset, segment->p_filesz);
#line 13724
      res___0 &= tmp___1;
      }
    }
#line 13719
    i ++;
#line 13719
    segment ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13729
  return (res___0);
}
}
#line 13732 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_note_sections(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned long i ;
  int res___0 ;
  int tmp___0 ;

  {
#line 13737
  res___0 = 1;
#line 13739
  i = 0UL;
#line 13739
  section = section_headers;
  {
#line 13739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13739
    if (i < (unsigned long )elf_header.e_shnum) {
#line 13739
      if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 13739
        goto while_break;
      }
    } else {
#line 13739
      goto while_break;
    }
#line 13742
    if (section->sh_type == 7U) {
      {
#line 13743
      tmp___0 = process_corefile_note_segment(file, (bfd_vma )section->sh_offset,
                                              section->sh_size);
#line 13743
      res___0 &= tmp___0;
      }
    }
#line 13739
    i ++;
#line 13739
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13747
  return (res___0);
}
}
#line 13750 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_notes(FILE *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 13754
  if (! do_notes) {
#line 13755
    return (1);
  }
#line 13757
  if ((int )elf_header.e_type != 4) {
    {
#line 13758
    tmp___0 = process_note_sections(file);
    }
#line 13758
    return (tmp___0);
  }
#line 13761
  if (elf_header.e_phnum > 0U) {
    {
#line 13762
    tmp___1 = process_corefile_note_segments(file);
    }
#line 13762
    return (tmp___1);
  }
  {
#line 13764
  tmp___2 = gettext("No note segments present in the core file.\n");
#line 13764
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 13765
  return (1);
}
}
#line 13768 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_arch_specific(FILE *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 13771
  if (! do_arch) {
#line 13772
    return (1);
  }
  {
#line 13776
  if ((int )elf_header.e_machine == 40) {
#line 13776
    goto case_40;
  }
#line 13779
  if ((int )elf_header.e_machine == 10) {
#line 13779
    goto case_10;
  }
#line 13779
  if ((int )elf_header.e_machine == 8) {
#line 13779
    goto case_10;
  }
#line 13782
  if ((int )elf_header.e_machine == 20) {
#line 13782
    goto case_20;
  }
#line 13787
  if ((int )elf_header.e_machine == 43) {
#line 13787
    goto case_43;
  }
#line 13787
  if ((int )elf_header.e_machine == 18) {
#line 13787
    goto case_43;
  }
#line 13787
  if ((int )elf_header.e_machine == 2) {
#line 13787
    goto case_43;
  }
#line 13790
  if ((int )elf_header.e_machine == 140) {
#line 13790
    goto case_140;
  }
#line 13793
  if ((int )elf_header.e_machine == 105) {
#line 13793
    goto case_105;
  }
#line 13795
  goto switch_default;
  case_40: /* CIL Label */ 
  {
#line 13777
  tmp___0 = process_arm_specific(file);
  }
#line 13777
  return (tmp___0);
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 13780
  tmp___1 = process_mips_specific(file);
  }
#line 13780
  return (tmp___1);
#line 13781
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 13783
  tmp___2 = process_power_specific(file);
  }
#line 13783
  return (tmp___2);
#line 13784
  goto switch_break;
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 13788
  tmp___3 = process_sparc_specific(file);
  }
#line 13788
  return (tmp___3);
#line 13789
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 13791
  tmp___4 = process_tic6x_specific(file);
  }
#line 13791
  return (tmp___4);
#line 13792
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 13794
  tmp___5 = process_msp430x_specific(file);
  }
#line 13794
  return (tmp___5);
  switch_default: /* CIL Label */ 
#line 13796
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13798
  return (1);
}
}
#line 13801 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int get_file_header(FILE *file ) 
{ 
  size_t tmp___0 ;
  Elf32_External_Ehdr ehdr32 ;
  size_t tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  Elf64_External_Ehdr ehdr64 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  elf_vma tmp___17 ;
  elf_vma tmp___18 ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  elf_vma tmp___23 ;
  elf_vma tmp___24 ;
  elf_vma tmp___25 ;
  elf_vma tmp___26 ;
  elf_vma tmp___27 ;
  elf_vma tmp___28 ;
  elf_vma tmp___29 ;

  {
  {
#line 13805
  tmp___0 = fread((void */* __restrict  */)(elf_header.e_ident), (size_t )16, (size_t )1,
                  (FILE */* __restrict  */)file);
  }
#line 13805
  if (tmp___0 != 1UL) {
#line 13806
    return (0);
  }
  {
#line 13817
  if ((int )elf_header.e_ident[5] == 2) {
#line 13817
    goto case_2;
  }
#line 13811
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 13814
  byte_get = & byte_get_little_endian;
#line 13815
  byte_put = & byte_put_little_endian;
#line 13816
  goto switch_break;
  case_2: /* CIL Label */ 
#line 13818
  byte_get = & byte_get_big_endian;
#line 13819
  byte_put = & byte_put_big_endian;
#line 13820
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13824
  is_32bit_elf = (int )elf_header.e_ident[4] != 2;
#line 13827
  if (is_32bit_elf) {
    {
#line 13831
    tmp___1 = fread((void */* __restrict  */)(ehdr32.e_type), sizeof(ehdr32) - 16UL,
                    (size_t )1, (FILE */* __restrict  */)file);
    }
#line 13831
    if (tmp___1 != 1UL) {
#line 13832
      return (0);
    }
    {
#line 13834
    tmp___2 = (*byte_get)(ehdr32.e_type, (int )sizeof(ehdr32.e_type));
#line 13834
    elf_header.e_type = (unsigned short )tmp___2;
#line 13835
    tmp___3 = (*byte_get)(ehdr32.e_machine, (int )sizeof(ehdr32.e_machine));
#line 13835
    elf_header.e_machine = (unsigned short )tmp___3;
#line 13836
    tmp___4 = (*byte_get)(ehdr32.e_version, (int )sizeof(ehdr32.e_version));
#line 13836
    elf_header.e_version = (unsigned long )tmp___4;
#line 13837
    tmp___5 = (*byte_get)(ehdr32.e_entry, (int )sizeof(ehdr32.e_entry));
#line 13837
    elf_header.e_entry = (bfd_vma )tmp___5;
#line 13838
    tmp___6 = (*byte_get)(ehdr32.e_phoff, (int )sizeof(ehdr32.e_phoff));
#line 13838
    elf_header.e_phoff = (bfd_size_type )tmp___6;
#line 13839
    tmp___7 = (*byte_get)(ehdr32.e_shoff, (int )sizeof(ehdr32.e_shoff));
#line 13839
    elf_header.e_shoff = (bfd_size_type )tmp___7;
#line 13840
    tmp___8 = (*byte_get)(ehdr32.e_flags, (int )sizeof(ehdr32.e_flags));
#line 13840
    elf_header.e_flags = (unsigned long )tmp___8;
#line 13841
    tmp___9 = (*byte_get)(ehdr32.e_ehsize, (int )sizeof(ehdr32.e_ehsize));
#line 13841
    elf_header.e_ehsize = (unsigned int )tmp___9;
#line 13842
    tmp___10 = (*byte_get)(ehdr32.e_phentsize, (int )sizeof(ehdr32.e_phentsize));
#line 13842
    elf_header.e_phentsize = (unsigned int )tmp___10;
#line 13843
    tmp___11 = (*byte_get)(ehdr32.e_phnum, (int )sizeof(ehdr32.e_phnum));
#line 13843
    elf_header.e_phnum = (unsigned int )tmp___11;
#line 13844
    tmp___12 = (*byte_get)(ehdr32.e_shentsize, (int )sizeof(ehdr32.e_shentsize));
#line 13844
    elf_header.e_shentsize = (unsigned int )tmp___12;
#line 13845
    tmp___13 = (*byte_get)(ehdr32.e_shnum, (int )sizeof(ehdr32.e_shnum));
#line 13845
    elf_header.e_shnum = (unsigned int )tmp___13;
#line 13846
    tmp___14 = (*byte_get)(ehdr32.e_shstrndx, (int )sizeof(ehdr32.e_shstrndx));
#line 13846
    elf_header.e_shstrndx = (unsigned int )tmp___14;
    }
  } else {
#line 13856
    if (sizeof(bfd_vma ) < 8UL) {
      {
#line 13858
      tmp___15 = gettext("This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n");
#line 13858
      error((char const   *)tmp___15);
      }
#line 13860
      return (0);
    }
    {
#line 13863
    tmp___16 = fread((void */* __restrict  */)(ehdr64.e_type), sizeof(ehdr64) - 16UL,
                     (size_t )1, (FILE */* __restrict  */)file);
    }
#line 13863
    if (tmp___16 != 1UL) {
#line 13864
      return (0);
    }
    {
#line 13866
    tmp___17 = (*byte_get)(ehdr64.e_type, (int )sizeof(ehdr64.e_type));
#line 13866
    elf_header.e_type = (unsigned short )tmp___17;
#line 13867
    tmp___18 = (*byte_get)(ehdr64.e_machine, (int )sizeof(ehdr64.e_machine));
#line 13867
    elf_header.e_machine = (unsigned short )tmp___18;
#line 13868
    tmp___19 = (*byte_get)(ehdr64.e_version, (int )sizeof(ehdr64.e_version));
#line 13868
    elf_header.e_version = (unsigned long )tmp___19;
#line 13869
    tmp___20 = (*byte_get)(ehdr64.e_entry, (int )sizeof(ehdr64.e_entry));
#line 13869
    elf_header.e_entry = (bfd_vma )tmp___20;
#line 13870
    tmp___21 = (*byte_get)(ehdr64.e_phoff, (int )sizeof(ehdr64.e_phoff));
#line 13870
    elf_header.e_phoff = (bfd_size_type )tmp___21;
#line 13871
    tmp___22 = (*byte_get)(ehdr64.e_shoff, (int )sizeof(ehdr64.e_shoff));
#line 13871
    elf_header.e_shoff = (bfd_size_type )tmp___22;
#line 13872
    tmp___23 = (*byte_get)(ehdr64.e_flags, (int )sizeof(ehdr64.e_flags));
#line 13872
    elf_header.e_flags = (unsigned long )tmp___23;
#line 13873
    tmp___24 = (*byte_get)(ehdr64.e_ehsize, (int )sizeof(ehdr64.e_ehsize));
#line 13873
    elf_header.e_ehsize = (unsigned int )tmp___24;
#line 13874
    tmp___25 = (*byte_get)(ehdr64.e_phentsize, (int )sizeof(ehdr64.e_phentsize));
#line 13874
    elf_header.e_phentsize = (unsigned int )tmp___25;
#line 13875
    tmp___26 = (*byte_get)(ehdr64.e_phnum, (int )sizeof(ehdr64.e_phnum));
#line 13875
    elf_header.e_phnum = (unsigned int )tmp___26;
#line 13876
    tmp___27 = (*byte_get)(ehdr64.e_shentsize, (int )sizeof(ehdr64.e_shentsize));
#line 13876
    elf_header.e_shentsize = (unsigned int )tmp___27;
#line 13877
    tmp___28 = (*byte_get)(ehdr64.e_shnum, (int )sizeof(ehdr64.e_shnum));
#line 13877
    elf_header.e_shnum = (unsigned int )tmp___28;
#line 13878
    tmp___29 = (*byte_get)(ehdr64.e_shstrndx, (int )sizeof(ehdr64.e_shstrndx));
#line 13878
    elf_header.e_shstrndx = (unsigned int )tmp___29;
    }
  }
#line 13881
  if (elf_header.e_shoff) {
#line 13885
    if (is_32bit_elf) {
      {
#line 13886
      get_32bit_section_headers(file, 1U);
      }
    } else {
      {
#line 13888
      get_64bit_section_headers(file, 1U);
      }
    }
  }
#line 13891
  return (1);
}
}
#line 13898 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_object(char *file_name , FILE *file ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct group_list *g ;
  struct group_list *next ;

  {
  {
#line 13903
  tmp___1 = get_file_header(file);
  }
#line 13903
  if (! tmp___1) {
    {
#line 13905
    tmp___0 = gettext("%s: Failed to read file header\n");
#line 13905
    error((char const   *)tmp___0, file_name);
    }
#line 13906
    return (1);
  }
#line 13910
  i = (unsigned int )(sizeof(version_info) / sizeof(version_info[0]));
  {
#line 13910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13910
    tmp___2 = i;
#line 13910
    i --;
#line 13910
    if (! tmp___2) {
#line 13910
      goto while_break;
    }
#line 13911
    version_info[i] = (bfd_vma )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 13913
  i = (unsigned int )(sizeof(dynamic_info) / sizeof(dynamic_info[0]));
  {
#line 13913
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 13913
    tmp___3 = i;
#line 13913
    i --;
#line 13913
    if (! tmp___3) {
#line 13913
      goto while_break___0;
    }
#line 13914
    dynamic_info[i] = (bfd_vma )0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 13915
  dynamic_info_DT_GNU_HASH = (bfd_vma )0;
#line 13918
  if (show_name) {
    {
#line 13919
    tmp___4 = gettext("\nFile: %s\n");
#line 13919
    printf((char const   */* __restrict  */)tmp___4, file_name);
    }
  }
#line 13925
  if (num_dump_sects > num_cmdline_dump_sects) {
    {
#line 13926
    memset((void *)dump_sects, 0, (unsigned long )num_dump_sects * sizeof(*dump_sects));
    }
  }
#line 13928
  if (num_cmdline_dump_sects > 0U) {
#line 13930
    if (num_dump_sects == 0U) {
      {
#line 13932
      request_dump_bynumber(num_cmdline_dump_sects, (dump_type )0);
      }
    }
#line 13934
    if (! (num_dump_sects >= num_cmdline_dump_sects)) {
      {
#line 13934
      __assert_fail("num_dump_sects >= num_cmdline_dump_sects", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c",
                    13934U, "process_object");
      }
    }
    {
#line 13935
    memcpy((void */* __restrict  */)dump_sects, (void const   */* __restrict  */)cmdline_dump_sects,
           (unsigned long )num_cmdline_dump_sects * sizeof(*dump_sects));
    }
  }
  {
#line 13939
  tmp___5 = process_file_header();
  }
#line 13939
  if (! tmp___5) {
#line 13940
    return (1);
  }
  {
#line 13942
  tmp___6 = process_section_headers(file);
  }
#line 13942
  if (! tmp___6) {
#line 13946
    do_arch = 0;
#line 13946
    do_dump = do_arch;
#line 13946
    do_version = do_dump;
#line 13946
    do_unwind = do_version;
#line 13948
    if (! do_using_dynamic) {
#line 13949
      do_reloc = 0;
#line 13949
      do_dyn_syms = do_reloc;
#line 13949
      do_syms = do_dyn_syms;
    }
  }
  {
#line 13952
  tmp___7 = process_section_groups(file);
  }
#line 13952
  if (! tmp___7) {
#line 13955
    do_unwind = 0;
  }
  {
#line 13958
  tmp___8 = process_program_headers(file);
  }
#line 13958
  if (tmp___8) {
    {
#line 13959
    process_dynamic_section(file);
    }
  }
  {
#line 13961
  process_relocs(file);
#line 13963
  process_unwind(file);
#line 13965
  process_symbol_table(file);
#line 13967
  process_syminfo(file);
#line 13969
  process_version_sections(file);
#line 13971
  process_section_contents(file);
#line 13973
  process_notes(file);
#line 13975
  process_gnu_liblist(file);
#line 13977
  process_arch_specific(file);
  }
#line 13979
  if (program_headers) {
    {
#line 13981
    free((void *)program_headers);
#line 13982
    program_headers = (Elf_Internal_Phdr *)((void *)0);
    }
  }
#line 13985
  if (section_headers) {
    {
#line 13987
    free((void *)section_headers);
#line 13988
    section_headers = (Elf_Internal_Shdr *)((void *)0);
    }
  }
#line 13991
  if (string_table) {
    {
#line 13993
    free((void *)string_table);
#line 13994
    string_table = (char *)((void *)0);
#line 13995
    string_table_length = 0UL;
    }
  }
#line 13998
  if (dynamic_strings) {
    {
#line 14000
    free((void *)dynamic_strings);
#line 14001
    dynamic_strings = (char *)((void *)0);
#line 14002
    dynamic_strings_length = 0UL;
    }
  }
#line 14005
  if (dynamic_symbols) {
    {
#line 14007
    free((void *)dynamic_symbols);
#line 14008
    dynamic_symbols = (Elf_Internal_Sym *)((void *)0);
#line 14009
    num_dynamic_syms = 0UL;
    }
  }
#line 14012
  if (dynamic_syminfo) {
    {
#line 14014
    free((void *)dynamic_syminfo);
#line 14015
    dynamic_syminfo = (Elf_Internal_Syminfo *)((void *)0);
    }
  }
#line 14018
  if (dynamic_section) {
    {
#line 14020
    free((void *)dynamic_section);
#line 14021
    dynamic_section = (Elf_Internal_Dyn *)((void *)0);
    }
  }
#line 14024
  if (section_headers_groups) {
    {
#line 14026
    free((void *)section_headers_groups);
#line 14027
    section_headers_groups = (struct group **)((void *)0);
    }
  }
#line 14030
  if (section_groups) {
#line 14035
    i = 0U;
    {
#line 14035
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 14035
      if (! ((size_t )i < group_count)) {
#line 14035
        goto while_break___1;
      }
#line 14037
      g = (section_groups + i)->root;
      {
#line 14037
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 14037
        if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 14037
          goto while_break___2;
        }
        {
#line 14039
        next = g->next;
#line 14040
        free((void *)g);
#line 14037
        g = next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 14035
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 14044
    free((void *)section_groups);
#line 14045
    section_groups = (struct group *)((void *)0);
    }
  }
  {
#line 14048
  free_debug_memory();
  }
#line 14050
  return (0);
}
}
#line 14056 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_archive(char *file_name , FILE *file , bfd_boolean is_thin_archive ) 
{ 
  struct archive_info arch ;
  struct archive_info nested_arch ;
  size_t got ;
  int ret ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int i ;
  unsigned int l ;
  unsigned long current_pos ;
  char *tmp___2 ;
  long tmp___3 ;
  char *member_name ;
  char *qualified_name ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *name___0 ;
  size_t namelen ;
  char *qualified_name___0 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  FILE *member_file ;
  char *member_file_name ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
#line 14064
  show_name = 1;
#line 14067
  arch.file_name = (char *)((void *)0);
#line 14068
  arch.file = (FILE *)((void *)0);
#line 14069
  arch.index_array = (elf_vma *)((void *)0);
#line 14070
  arch.sym_table = (char *)((void *)0);
#line 14071
  arch.longnames = (char *)((void *)0);
#line 14076
  nested_arch.file_name = (char *)((void *)0);
#line 14077
  nested_arch.file = (FILE *)((void *)0);
#line 14078
  nested_arch.index_array = (elf_vma *)((void *)0);
#line 14079
  nested_arch.sym_table = (char *)((void *)0);
#line 14080
  nested_arch.longnames = (char *)((void *)0);
#line 14082
  tmp___0 = setup_archive(& arch, (char const   *)file_name, file, is_thin_archive,
                          do_archive_index);
  }
#line 14082
  if (tmp___0 != 0) {
#line 14084
    ret = 1;
#line 14085
    goto out;
  }
#line 14088
  if (do_archive_index) {
#line 14090
    if ((unsigned long )arch.sym_table == (unsigned long )((void *)0)) {
      {
#line 14091
      tmp___1 = gettext("%s: unable to dump the index as none was found\n");
#line 14091
      error((char const   *)tmp___1, file_name);
      }
    } else {
      {
#line 14097
      tmp___2 = gettext("Index of archive %s: (%ld entries, 0x%lx bytes in the symbol table)\n");
#line 14097
      printf((char const   */* __restrict  */)tmp___2, file_name, (long )arch.index_num,
             arch.sym_size);
#line 14099
      tmp___3 = ftell(file);
#line 14099
      current_pos = (unsigned long )tmp___3;
#line 14101
      l = 0U;
#line 14101
      i = l;
      }
      {
#line 14101
      while (1) {
        while_continue: /* CIL Label */ ;
#line 14101
        if (! ((elf_vma )i < arch.index_num)) {
#line 14101
          goto while_break;
        }
#line 14103
        if (i == 0U) {
#line 14103
          goto _L;
        } else
#line 14103
        if (i > 0U) {
#line 14103
          if (*(arch.index_array + i) != *(arch.index_array + (i - 1U))) {
            _L: /* CIL Label */ 
            {
#line 14107
            member_name = get_archive_member_name_at(& arch, (unsigned long )*(arch.index_array + i),
                                                     & nested_arch);
            }
#line 14109
            if ((unsigned long )member_name != (unsigned long )((void *)0)) {
              {
#line 14111
              tmp___4 = make_qualified_name(& arch, & nested_arch, (char const   *)member_name);
#line 14111
              qualified_name = tmp___4;
              }
#line 14113
              if ((unsigned long )qualified_name != (unsigned long )((void *)0)) {
                {
#line 14115
                tmp___5 = gettext("Contents of binary %s at offset ");
#line 14115
                printf((char const   */* __restrict  */)tmp___5, qualified_name);
#line 14116
                print_vma((bfd_vma )*(arch.index_array + i), (print_mode )4);
#line 14117
                putchar('\n');
#line 14118
                free((void *)qualified_name);
                }
              }
            }
          }
        }
#line 14123
        if ((unsigned long )l >= arch.sym_size) {
          {
#line 14125
          tmp___6 = gettext("%s: end of the symbol table reached before the end of the index\n");
#line 14125
          error((char const   *)tmp___6, file_name);
          }
#line 14127
          goto while_break;
        }
        {
#line 14129
        printf((char const   */* __restrict  */)"\t%s\n", arch.sym_table + l);
#line 14130
        tmp___7 = strlen((char const   *)(arch.sym_table + l));
#line 14130
        l = (unsigned int )((size_t )l + (tmp___7 + 1UL));
#line 14101
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 14133
      if (arch.uses_64bit_indicies) {
#line 14134
        l = (l + 7U) & 4294967288U;
      } else {
#line 14136
        l += l & 1U;
      }
#line 14138
      if ((unsigned long )l < arch.sym_size) {
        {
#line 14139
        tmp___8 = gettext("%s: %ld bytes remain in the symbol table, but without corresponding entries in the index table\n");
#line 14139
        error((char const   *)tmp___8, file_name, arch.sym_size - (unsigned long )l);
        }
      }
      {
#line 14142
      tmp___10 = fseek(file, (long )current_pos, 0);
      }
#line 14142
      if (tmp___10 != 0) {
        {
#line 14144
        tmp___9 = gettext("%s: failed to seek back to start of object files in the archive\n");
#line 14144
        error((char const   *)tmp___9, file_name);
#line 14145
        ret = 1;
        }
#line 14146
        goto out;
      }
    }
#line 14150
    if (! do_dynamic) {
#line 14150
      if (! do_syms) {
#line 14150
        if (! do_reloc) {
#line 14150
          if (! do_unwind) {
#line 14150
            if (! do_sections) {
#line 14150
              if (! do_segments) {
#line 14150
                if (! do_header) {
#line 14150
                  if (! do_dump) {
#line 14150
                    if (! do_version) {
#line 14150
                      if (! do_histogram) {
#line 14150
                        if (! do_debugging) {
#line 14150
                          if (! do_arch) {
#line 14150
                            if (! do_notes) {
#line 14150
                              if (! do_section_groups) {
#line 14150
                                if (! do_dyn_syms) {
#line 14155
                                  ret = 0;
#line 14156
                                  goto out;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 14160
  ret = 0;
  {
#line 14162
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 14169
    tmp___12 = fseek(file, (long )arch.next_arhdr_offset, 0);
    }
#line 14169
    if (tmp___12 != 0) {
      {
#line 14171
      tmp___11 = gettext("%s: failed to seek to next archive header\n");
#line 14171
      error((char const   *)tmp___11, file_name);
      }
#line 14172
      return (1);
    }
    {
#line 14174
    got = fread((void */* __restrict  */)(& arch.arhdr), (size_t )1, sizeof(arch.arhdr),
                (FILE */* __restrict  */)file);
    }
#line 14175
    if (got != sizeof(arch.arhdr)) {
#line 14177
      if (got == 0UL) {
#line 14178
        goto while_break___0;
      }
      {
#line 14179
      tmp___13 = gettext("%s: failed to read archive header\n");
#line 14179
      error((char const   *)tmp___13, file_name);
#line 14180
      ret = 1;
      }
#line 14181
      goto while_break___0;
    }
    {
#line 14183
    tmp___15 = memcmp((void const   *)(arch.arhdr.ar_fmag), (void const   *)"`\n",
                      (size_t )2);
    }
#line 14183
    if (tmp___15 != 0) {
      {
#line 14185
      tmp___14 = gettext("%s: did not find a valid archive header\n");
#line 14185
      error((char const   *)tmp___14, arch.file_name);
#line 14186
      ret = 1;
      }
#line 14187
      goto while_break___0;
    }
    {
#line 14190
    arch.next_arhdr_offset += sizeof(arch.arhdr);
#line 14192
    archive_file_size = strtoul((char const   */* __restrict  */)(arch.arhdr.ar_size),
                                (char **/* __restrict  */)((void *)0), 10);
    }
#line 14193
    if (archive_file_size & 1UL) {
#line 14194
      archive_file_size ++;
    }
    {
#line 14196
    name___0 = get_archive_member_name(& arch, & nested_arch);
    }
#line 14197
    if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
      {
#line 14199
      tmp___16 = gettext("%s: bad archive file name\n");
#line 14199
      error((char const   *)tmp___16, file_name);
#line 14200
      ret = 1;
      }
#line 14201
      goto while_break___0;
    }
    {
#line 14203
    namelen = strlen((char const   *)name___0);
#line 14205
    qualified_name___0 = make_qualified_name(& arch, & nested_arch, (char const   *)name___0);
    }
#line 14206
    if ((unsigned long )qualified_name___0 == (unsigned long )((void *)0)) {
      {
#line 14208
      tmp___17 = gettext("%s: bad archive file name\n");
#line 14208
      error((char const   *)tmp___17, file_name);
#line 14209
      ret = 1;
      }
#line 14210
      goto while_break___0;
    }
#line 14213
    if (is_thin_archive) {
#line 14213
      if (arch.nested_member_origin == 0UL) {
        {
#line 14217
        tmp___18 = adjust_relative_path((char const   *)file_name, (char const   *)name___0,
                                        (int )namelen);
#line 14217
        member_file_name = tmp___18;
        }
#line 14218
        if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
#line 14220
          ret = 1;
#line 14221
          goto while_break___0;
        }
        {
#line 14224
        member_file = fopen((char const   */* __restrict  */)member_file_name, (char const   */* __restrict  */)"rb");
        }
#line 14225
        if ((unsigned long )member_file == (unsigned long )((void *)0)) {
          {
#line 14227
          tmp___19 = gettext("Input file \'%s\' is not readable.\n");
#line 14227
          error((char const   *)tmp___19, member_file_name);
#line 14228
          free((void *)member_file_name);
#line 14229
          ret = 1;
          }
#line 14230
          goto while_break___0;
        }
        {
#line 14233
        archive_file_offset = (long )arch.nested_member_origin;
#line 14235
        tmp___20 = process_object(qualified_name___0, member_file);
#line 14235
        ret |= tmp___20;
#line 14237
        fclose(member_file);
#line 14238
        free((void *)member_file_name);
        }
      } else {
#line 14213
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 14240
    if (is_thin_archive) {
#line 14243
      if ((unsigned long )nested_arch.file == (unsigned long )((void *)0)) {
        {
#line 14245
        tmp___21 = gettext("%s: contains corrupt thin archive: %s\n");
#line 14245
        error((char const   *)tmp___21, file_name, name___0);
#line 14247
        ret = 1;
        }
#line 14248
        goto while_break___0;
      }
      {
#line 14252
      archive_file_offset = (long )(arch.nested_member_origin + sizeof(arch.arhdr));
#line 14256
      tmp___23 = fseek(nested_arch.file, archive_file_offset, 0);
      }
#line 14256
      if (tmp___23 != 0) {
        {
#line 14258
        tmp___22 = gettext("%s: failed to seek to archive member.\n");
#line 14258
        error((char const   *)tmp___22, nested_arch.file_name);
#line 14259
        ret = 1;
        }
#line 14260
        goto while_break___0;
      }
      {
#line 14263
      tmp___24 = process_object(qualified_name___0, nested_arch.file);
#line 14263
      ret |= tmp___24;
      }
    } else {
      {
#line 14267
      archive_file_offset = (long )arch.next_arhdr_offset;
#line 14268
      arch.next_arhdr_offset += archive_file_size;
#line 14270
      tmp___25 = process_object(qualified_name___0, file);
#line 14270
      ret |= tmp___25;
      }
    }
#line 14273
    if ((unsigned long )dump_sects != (unsigned long )((void *)0)) {
      {
#line 14275
      free((void *)dump_sects);
#line 14276
      dump_sects = (dump_type *)((void *)0);
#line 14277
      num_dump_sects = 0U;
      }
    }
    {
#line 14280
    free((void *)qualified_name___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 14284
  if ((unsigned long )nested_arch.file != (unsigned long )((void *)0)) {
    {
#line 14285
    fclose(nested_arch.file);
    }
  }
  {
#line 14286
  release_archive(& nested_arch);
#line 14287
  release_archive(& arch);
  }
#line 14289
  return (ret);
}
}
#line 14292 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
static int process_file(char *file_name ) 
{ 
  FILE *file ;
  struct stat statbuf ;
  char armag[8] ;
  int ret ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 14300
  tmp___5 = stat((char const   */* __restrict  */)file_name, (struct stat */* __restrict  */)(& statbuf));
  }
#line 14300
  if (tmp___5 < 0) {
    {
#line 14302
    tmp___4 = __errno_location();
    }
#line 14302
    if (*tmp___4 == 2) {
      {
#line 14303
      tmp___0 = gettext("\'%s\': No such file\n");
#line 14303
      error((char const   *)tmp___0, file_name);
      }
    } else {
      {
#line 14305
      tmp___1 = __errno_location();
#line 14305
      tmp___2 = strerror(*tmp___1);
#line 14305
      tmp___3 = gettext("Could not locate \'%s\'.  System error message: %s\n");
#line 14305
      error((char const   *)tmp___3, file_name, tmp___2);
      }
    }
#line 14307
    return (1);
  }
#line 14310
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 14312
    tmp___6 = gettext("\'%s\' is not an ordinary file\n");
#line 14312
    error((char const   *)tmp___6, file_name);
    }
#line 14313
    return (1);
  }
  {
#line 14316
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"rb");
  }
#line 14317
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 14319
    tmp___7 = gettext("Input file \'%s\' is not readable.\n");
#line 14319
    error((char const   *)tmp___7, file_name);
    }
#line 14320
    return (1);
  }
  {
#line 14323
  tmp___9 = fread((void */* __restrict  */)(armag), (size_t )8, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 14323
  if (tmp___9 != 1UL) {
    {
#line 14325
    tmp___8 = gettext("%s: Failed to read file\'s magic number\n");
#line 14325
    error((char const   *)tmp___8, file_name);
#line 14326
    fclose(file);
    }
#line 14327
    return (1);
  }
  {
#line 14330
  tmp___12 = memcmp((void const   *)(armag), (void const   *)"!<arch>\n", (size_t )8);
  }
#line 14330
  if (tmp___12 == 0) {
    {
#line 14331
    ret = process_archive(file_name, file, 0);
    }
  } else {
    {
#line 14332
    tmp___11 = memcmp((void const   *)(armag), (void const   *)"!<thin>\n", (size_t )8);
    }
#line 14332
    if (tmp___11 == 0) {
      {
#line 14333
      ret = process_archive(file_name, file, 1);
      }
    } else {
#line 14336
      if (do_archive_index) {
        {
#line 14337
        tmp___10 = gettext("File %s is not an archive so its index cannot be displayed.\n");
#line 14337
        error((char const   *)tmp___10, file_name);
        }
      }
      {
#line 14340
      rewind(file);
#line 14341
      archive_file_offset = 0L;
#line 14341
      archive_file_size = (unsigned long )archive_file_offset;
#line 14342
      ret = process_object(file_name, file);
      }
    }
  }
  {
#line 14345
  fclose(file);
  }
#line 14347
  return (ret);
}
}
#line 14369 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_24/binutils/readelf.c"
int main(int argc , char **argv ) 
{ 
  int err ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 14375
  setlocale(5, "");
#line 14378
  setlocale(0, "");
#line 14380
  bindtextdomain("binutils", "/usr/local/share/locale");
#line 14381
  textdomain("binutils");
#line 14383
  expandargv(& argc, & argv);
#line 14385
  parse_args(argc, argv);
  }
#line 14387
  if (num_dump_sects > 0U) {
    {
#line 14390
    tmp___0 = malloc((unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 14390
    cmdline_dump_sects = (dump_type *)tmp___0;
    }
#line 14392
    if ((unsigned long )cmdline_dump_sects == (unsigned long )((void *)0)) {
      {
#line 14393
      tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 14393
      error((char const   *)tmp___1);
      }
    } else {
      {
#line 14396
      memcpy((void */* __restrict  */)cmdline_dump_sects, (void const   */* __restrict  */)dump_sects,
             (unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 14398
      num_cmdline_dump_sects = num_dump_sects;
      }
    }
  }
#line 14402
  if (optind < argc - 1) {
#line 14403
    show_name = 1;
  }
#line 14405
  err = 0;
  {
#line 14406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14406
    if (! (optind < argc)) {
#line 14406
      goto while_break;
    }
    {
#line 14407
    tmp___2 = optind;
#line 14407
    optind ++;
#line 14407
    tmp___3 = process_file(*(argv + tmp___2));
#line 14407
    err |= tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 14409
  if ((unsigned long )dump_sects != (unsigned long )((void *)0)) {
    {
#line 14410
    free((void *)dump_sects);
    }
  }
#line 14411
  if ((unsigned long )cmdline_dump_sects != (unsigned long )((void *)0)) {
    {
#line 14412
    free((void *)cmdline_dump_sects);
    }
  }
#line 14414
  return (err);
}
}
